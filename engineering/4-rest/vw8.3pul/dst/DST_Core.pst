<?xml version="1.0"?><st-source><!-- Name: DST_CoreNotice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.Comment: DST_Core contains the core DST classes. It must be parceled in or loaded before all other DST parcels or packages.Copyright: Copyright © 1999-2002 Cincom Systems, Inc.All Rights ReservedThis product contains copyrighted third-party software.Copyright © 1993-1995 Hewlett-Packard Company.All Rights ReservedDbIdentifier: bear73DbTrace: 464614DbUsername: tkoganDbVersion: 8.1 - 1DevelopmentPrerequisites: #(#(#any 'BOSS' '') #(#any 'AT MetaNumerics' ''))DisregardedPrerequisites: #(#(#name 'DST_Core_IDL' #componentType #package))Namespace: Smalltalk.DSTPackageName: DST_CoreParcel: #('DST_Core')ParcelName: DST_CorePrerequisiteParcels: #(#('BOSS' '') #('AT MetaNumerics' ''))PrintStringCache: (8.1 - 1,tkogan)Version: 8.1 - 1Date: 1:09:20 PM January 29, 2016 --><time-stamp>From VisualWorks®, Pre-Release 8.2 (jan16.4) of January 29, 2016 on January 29, 2016 at 1:09:20 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>DST</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>DST</category><attributes><package>DST_Core</package></attributes></name-space><class><name>DSTModuleSecurityNull</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Modules</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTConfiguration</name><environment>DST</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settingDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Configuration</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTConfiguration</class-id><body>This is an abstract class whose subclasses store settings information. Provides access and modification of settings, including reading settings from a file and writing them to a file.Instance Variables:	settingDictionary							&lt;IdentityDictionary &lt;Symbol -&gt; ValueModel&gt;&gt;					Setting information: maps setting symbol to valueShared Variables:	Services					&lt;IdentityDictionary &lt;Symbol -&gt; DSTServiceConfiguration&gt;&gt;					Maps service name to instance holding settings 					for that service.	Transports					&lt;IdentityDictionary &lt;Symbol -&gt; DSTTransportConfiguration&gt;&gt;					Maps transport name to instance holding settings 					for that transport.</body></comment><class><name>DSTTransportConfiguration</name><environment>DST</environment><super>DST.DSTConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Configuration</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTTransportConfiguration</class-id><body>This is an abstract class whose subclasses represent transport protocols and store settings information about those protocols.Inherited Instance Variables:	settingDictionary		&lt;IdentityDictionary &lt;Symbol -&gt; ValueModel&gt;&gt;							Setting information: maps setting symbol to value</body></comment><class><name>ORBObject</name><environment>DST</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessControlList </inst-vars><class-inst-vars>abstractClassId classAbstractClassId accessControlList </class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.ORBObject</class-id><body>Instance Variables:	accessControlListShared Variables:	AccessSymbols	BOAid	Factories	InstallDir	InterfaceRepository	LocalRepository	NamingService	ProfilerObj	Profiling		RemoteRepository	RepositoryCache	Services	SharedRepositoryModule</body></comment><class><name>DSTMetaObject</name><environment>DST</environment><super>DST.ORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name definedIn definition version repositoryId prefix </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTMetaObject</class-id><body>The CORBA architecture is independent of the programming language used to construct clients or implementations.  In order to use the ORB, it is necessary for programmers to know how to access ORB functionality from their particular programming languages.This class, in conjunction with its subclasses and the immediate subclasses of ORBObject, implement the mapping to the Smalltalk programming language.  These classes provide the Smalltalk programmer with mechanisms for expressing the following IDL concepts:1. All IDL basic datatypes (see class DSTtypeBase)2. All IDL constructed datatypes (see class DSTtypeConstr &amp; DSTtypeTemplate)3. References to constants defined in IDL (see class DSTconstant)4. References to objects defined in IDL (see class DSTObjRef)5. Invocations of operations, including passing parameters and receiving results. (see class DSToperation &amp; DSTparameter)6. Exceptions, including what happens when an operation raises an exception and how the exception parameters are accessed. (see class DSTexception)7. Access to attributes (see class DSTattribute)8. Signatures for the operations defined by the ORB, such as the dynamic invocation interface, the object adapters, etc. (see class ORBObject)In addition to defining the language mapping from IDL to Smalltalk, these meta objects are themselves remotely accessible and provide the Interface Repository behavior which is defined for all CORBA implementations.Subclasses must implement the following messages:	TypeCode		marshallTypeCode:on:		typeKind	printing		printDefinitionOn:indent:style:	accessing		descriptionInstance Variables	name 		 &lt;String | Symbol&gt;		printname	repositoryId 	 &lt;RepositoryId&gt;			global unique identifier	version		&lt;String&gt;					the major.minor version number as a string	prefix		&lt;String&gt;					the prefix pragma prefix for this meta object	definedIn 	 &lt;DSTMetaObject&gt;		defining metaobject ("container")	definition	 &lt;String&gt;				optional commentShared Variables	TCTable	&lt;Dictionary key: Integer value: (DSTMetaObject | nil)&gt;  type code table used during unmarshalling to decode typecodes into metaobject	CurrentPrefix	&lt;String&gt;		used by the IDL formatting facility to keep track of the current prefix. Used to decide								when a prefix pragma must be emitted.</body></comment><class><name>DSTtype</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>declarators localtype localclass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtype</class-id><body>Subclasses must implement the following messages:	marshalling		marshall:on:		unMarshall:		typeKind		Instance variables:	declarators 		&lt;Array&gt;	localtype 		&lt;DSTtypeAny&gt;	localclass		&lt;Symbol&gt;</body></comment><class><name>DSTtypeSimple</name><environment>DST</environment><super>DST.DSTtype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeSimple</class-id><body>This is an abstract class which is used purely for organization of IDL type object classes</body></comment><class><name>DSTtypeBase</name><environment>DST</environment><super>DST.DSTtypeSimple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeBase</class-id><body>Smalltalk magnitude classes map directly onto the required IDL basic datatypes, and the subclasses of this abstract class are concerned with their representation in all situations.  In addition, instances of these subclasses perform marshalling and unmarshalling operations related to remote procedure call semantics.</body></comment><class><name>DSTtypeAny</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeAny</class-id><body>Any Smalltalk class which supports the #typeObject method may be used as an instance of an IDL type-any in an operation invocation parameter list.  On return, type-any output parameters and results are returned as Associations of the form  "obj typeObject -&gt; obj".  Associations of this form may also be provided as in parameters to operation calls, for uniformity.  Since all Smalltalk objects are inherently typed by their #class method, and since return parameters also have this characteristic,  Smalltalk programmers may prefer to use normal class typing instead of the IDL version.  To assist with easy conversion of Association valued type-any results to normally typed Smalltalk instances, the method #value has been added to class Object to return the object itself.Thus, possibly-remote operations which yield type-any values can be handled uniformly by appending the #value method to the result.  If the operation is local and is returning a local Smalltalk object directly, then there is no net effect.  However, if the operation is remote and actually returns an Association value, then the value of the Association (the intended result) results.e.g.		property := (aPropertySet getProperty: #company) value  works uniformly when the PropertySet is local and returns a single value and also when it is remote and returns "aDSTtypeString -&gt; 'ParcPlace-Digitalk' "Shared Class Variables:	CORBATypeMap	&lt;WeakKeyDictionary&gt; maps objects that arrived as a value of type Any to their real IDL type	TCStreamDef	&lt;DSTtype&gt; the cached typecode stream definition	TypeMapClass	&lt;Class&gt; the class of dictionary used for the CORBATypeMap</body></comment><class><name>DSTtypeLong</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTtypeLongLong</name><environment>DST</environment><super>DST.DSTtypeLong</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTtypeUnsignedLongLong</name><environment>DST</environment><super>DST.DSTtypeLongLong</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>ORBDeadObject</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.ORBDeadObject</class-id><body>This class implements an object which will raise a notifier when any messages are sent to it.  A reference  to a DeadObject is added by ORBObject&gt;&gt;destroy.  Proper functioning of the object services dictates that such destroyed objects should never be messaged.  Only one instance of a dead object is needed for the whole system and can be obtained by the method 'ORBDeadObject class&gt;&gt;deadObject'.Shared Variables:	DeadObject	&lt;ORBDeadObject&gt;  the single of instance of ORBDeadObject for the system</body></comment><class><name>DSTLongDouble</name><environment>DST</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTLongDouble</class-id><body>Instances of the class LongDouble represent represent an IEEE double-extendedfloating-point number, which supports of an exponent of at least 15 bits in lengthand a fraction of at least 63 bits. See IEEE Standard for Binary Floating-Point Arithmetic,ANSI/IEEE STd 754-1985, for a detailed specification."Right now this class is a value holder for long double values passed in from otherenvironment via DST. It has no real implementation except for what is needed forDST to handle the long double bits comming from the wire and not truncate themor transform them. I.e. a long double can survive a roundtrip through DST and comeback to the origionator unchanged.This is a detailed description of the bits for future implementation.The exponent (e1 and e2) is 15 bits long, where the 7 bits in e1 are the most significant.The value of long double is determined by the expression:  sign     (exponent - 16383)-1      * 2                           * (1 + fraction)Big-Endian                  octet-----------------| s |   e1      | 0 -----------------|       e2      | 1 -----------------|       f1      | 2 -----------------|       f2      | 3 -----------------|       f3      | 4 -----------------|       f4      | 5 -----------------|       f5      | 6 -----------------|       f6      | 7 -----------------|       f7      | 8 -----------------|       f8      | 9 -----------------|       f9      | 10 -----------------|       f10     | 11 -----------------|       f11     | 12-----------------|       f12     | 13-----------------|       f13     | 14-----------------|       f14     | 15-----------------Little-Endian                  octet-----------------|       f14     | 0 -----------------|       f13     | 1 -----------------|       f12     | 2 -----------------|       f11     | 3 -----------------|       f10     | 4 -----------------|       f9      | 5 -----------------|       f8      | 6 -----------------|       f7      | 7 -----------------|       f6      | 8 -----------------|       f5      | 9 -----------------|       f4      | 10 -----------------|       f3      | 11 -----------------|       f2      | 12-----------------|       f1      | 13-----------------|       e2      | 14-----------------| s |   e1      | 15-----------------</body></comment><class><name>DSTIRPragma</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTIRPragma</class-id><body>This class is the abstract base class for CORBA 2.0 interface repository pragmas. There are three pragmas defined by the OMG:	#pragma ID &lt;name&gt; "&lt;id&gt;"	#pragma version &lt;name&gt; &lt;major&gt;.&lt;minor&gt;	#pragma prefix "&lt;string&gt;"DST defines three more:	#pragma SELECTOR &lt;name&gt; &lt;smalltalk selector&gt;	#pragma CLASS &lt;name&gt; &lt;smalltalk class name&gt;	#pragma ACCESS &lt;name&gt; &lt;access rights&gt;The IDL compiler collects the ID and version pragmas for each scope entered and createsa collection of DSTIRPragmas which is associated with the container for the given scope. The current prefix is also recorded as part of the pragma. Once the IDL is compiled therepository IDs of the objects in the repository are set based on the collected pragmas.Subclasses must implement the following messages:	actions		applyTo:Instance variables:	name	&lt;String&gt;		the name of the idl construct to which the pragma applies.</body></comment><class><name>DSTClassPragma</name><environment>DST</environment><super>DST.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTClassPragma</class-id><body>This class represents a class pragma which has the following syntax:	#pragma class &lt;name&gt; &lt;class name&gt;Instance variables:	className	&lt;String&gt;		the user specified class</body></comment><class><name>DSTtypeBoolean</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeBoolean</class-id><body>Boolean values true and false are used by the Smalltalk programmer to represent IDL boolean types in all situations</body></comment><class><name>DSToperationDescription</name><environment>DST</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id definedIn version result mode contexts parameters exceptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSToperation</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>localOp signature sync raises context access </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSToperation</class-id><body>An operation invocation requires the specification of the object to be invoked, the operation to be performed, and the parameters to be supplied.  A language mapping must therefore address how these basic mechanisms are accessed by the programmer.  For Distributed Smalltalk, a remote method invocation is indistinguishable from a local invocation, i.e. normal Smalltalk syntax is observed.  The only difference to the programmer should be the amount of time required to complete the request.Smalltalk method invocation syntax allows zero or multiple input parameters to be supplied in a call.  For return values, however, IDL allows multiple out parameters to be return from a single invocation.  This is handled by returning an Array with all of the non-in (result, out, inout) parameters included in order of their declaration in the IDL operation declaration.  All parameters are allocated and reclaimed from the Smalltalk heap.IDL also allows inout parameters to be defined.  These parameters are expected to be supplied in the invocation and will be returned as out parameters in the resultant array.  Note that the in and out values will be distinct Smalltalk objects, rather than sharing some portion of the heap together (as in C, for example).  Finally, IDL operations declared to have type-void results but which have a single out or inout parameter are returned as single values just like operations with a single result value and no output parameters:  a single value without an enclosing array.Each DSToperation meta object is also an instance of the OperationDef interface in the Repository, and may be accessed accordingly.Instance Variables:	localOp 		&lt;Symbol&gt; 	the local selector associated with this operation	signature		&lt;DSTsignature&gt; signature 	sync 			&lt;Symbol&gt;		raises 			&lt;Array&gt; 	list of exceptions raised	context 		&lt;Array&gt;		context information	access			&lt;Symbol&gt;	access rights needed for user securityShared Variables:	ContextIF					&lt;DSTtypeSequence | nil&gt;		ServiceContextListDef		&lt;DSTtypeSequence | nil&gt;	</body></comment><class><name>IDLPrefix</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prefixString definingContainer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IDLPrefix</class-id><body>IDLPrefix instances are placed in ScopeBlocks. An IDLPrefix holds the current prefix string and defining container. This information is used to implement the prefix pragma.Instance Variables:	prefixString	&lt;String&gt;		prefix string	definingContainer &lt;DSTMetaContainer&gt; container for current scope</body></comment><class><name>DSTEnumerator</name><environment>DST</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>IIOPConnection</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>broker sktAddr conversations peer sendLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPConnection</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  Subclasses must implement the following messages:	spawnConnectionBroker	shutDown	shutDownConnectionInstance Variables:	broker	&lt;Process&gt; the current connection broker	sktAddr	&lt;SocketAccessor&gt; the accessor for the connection broker	conversations	&lt;Dictionary&gt; of conversations	peer	&lt;Object&gt; undocumented	sendLock	&lt;Semaphore&gt; mutex protecting the connection from multiple concurrent sendsShared Class Variables:	ActiveDaemon	&lt;IIOPDaemon&gt; The daemon for this transport	ReceiveTimeOut	&lt;Object&gt; undocumented	WriteIncrement	&lt;Object&gt; undocumented</body></comment><class><name>IIOPServerConnection</name><environment>DST</environment><super>DST.IIOPConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPServerConnection</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTtypeTemplate</name><environment>DST</environment><super>DST.DSTtypeSimple</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size subtype </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeTemplate</class-id><body>This class provides shared implementation between IDL sequence and string datatypes.  No actual instances of this class are created.Instance Variables:	size 		&lt;Integer&gt;	subtype		&lt;DSTtypeAny&gt;</body></comment><class><name>DSTInterceptor</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Interceptors</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTInterceptor</class-id><body>DSTInterceptor is the abstract superclass of all request and message interceptors.  It implements the basic protocol required for the creation and sorting of interceptors.DSTIntercpetor and its subclasses -- in concert with DSTInterceptorCollection, some additions to IIOPConversation, and changes to the methods	IIOPClientConversation&gt;&gt;clientCall:to:withRequest:withArgs:	IIOPClientConversation class&gt;&gt;clientCall:to:withParameters:	IIOPServerConversation&gt;&gt;regularRequest-- implement a largely compliant version of the optional CORBA 2.2 Interceptorspecification.  The approach taken was intended to minimize impact on existingmarshalling code while maximizing compliance.  The approach was motivated by the fact that we hope to rationalize and simplify DST on the Opentalk model soon,in which context, a proper implementation of interceptors would not be an overt kludge on top of code that we already regard as inelegant.  The detailed caveats follow:  	[1] According to the specification, interceptors should wrap the receipt ordispatch of a message.  Instead, our interceptors are inserted into the existingmarshalling sequence.  Execution is driven by the IIOP methods, not by theinterceptors.	[2] Entailed by the above is that interceptors should have access to nearlyall the state involved in message receipt and dispatch.  Our interceptors obtain temporaries that give them access to the current context.  For now, we elected not to pass in the current conversation, though much relevant state is held inthe conversation and its method temporaries.	[3] According to the specification, interceptors should have full control over the handling of errors consequent upon their invocation of the methods thatcomplete the receipt or dispatch of a message.  The error handling machineryof VW is flexible and robust enough to give you nearly all you may require, but you have to work with the fact that it is the IIOP methods which drive execution.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>DSTObjRef</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectId interfaceId interface </inst-vars><class-inst-vars>indexClass </class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTObjRef</class-id><body>This class provides the basic mechanisms for transparent distribution using theORB RPC mechanism.  In a local object message invocation, the client object hasan object reference to the server object itself.  Message invocation in this case isunaffected by these distribution mechanisms.  If the server object is actually aremote object, then the client actually holds an object reference to an instance ofthis class or one of its subclasses.  Since this instance has none of the methodswhich the client object is expecting of the server, the local message send will resultin a #doesNotUnderstand: call instead.  This method is used to actually kick off theremote RPC operation (also see #perform:on:).Smalltalk objects may be referenced directly, or also via instances of DSTObjRef subclasses:	1. Inactive - Local objects which normally exist within this image but which are currently		residing as passive data on a mass storage device, such as an ODBMS, may be		referenced by a suitable DSTObjRefInactive instance.	2. Local - Local objects may be referenced by a DSTObjRefLocal so that messages sent		to them will be processed by the ORB instead of the normal method invocation.	3. Remote - Objects which exist on remote systems are accessed locally via an instance		of a DSTObjRefRemote.	4. Widened - Local objects may choose to allow a subset of their most derived interface		operations to be made available to clients by returning a suitable DSTObjRefWidened		instance as a result value rather than self.Subclasses must implement methods for 	class protocol 		creation-registration			indexInstance Variables:	objectId	&lt;NCSuuid&gt; which uniquely identifies the object (its OID)	interfaceId	&lt;NCSuuid&gt; which identifies the object's interface (its MDI)	interface	&lt;DSTinterface&gt; A cache of the interface object in the Interface RepositoryClass Instance Variables:	indexClass	&lt;Class&gt; the class of collection used for the Index shared class variableShared Class Variables:	LifeCycleObjects	&lt;IdentitySet&gt; all lifecycle objects must be held in existence until explicitly destroyed.	NameOfBinding	&lt;Object&gt; undocumented	ObjectIds	&lt;WeakKeyDictionary&gt; that maps local objects -&gt; ObjectIDs.	ObjectIdsClass	&lt;Class&gt; the dictionary class used for the ObjectIds table	Objects	&lt;WeakValueDictionary&gt; that maps ObjectIDs -&gt; local objects.	ObjectsClass	&lt;Class&gt; the dictionary class used for the Objects table	RegisteredObjects	&lt;IdentitySet&gt; all objects which are registered with the ORB and which must be held in existence at least while it is running.	Retrying	&lt;Boolean&gt; whether to automatically prompt the local user for retries in case of communication failures</body></comment><class><name>DSTObjRefNarrowed</name><environment>DST</environment><super>DST.DSTObjRef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTObjRefNarrowed</class-id><body>This class is used to create surrogates for local objects which support superset of the local object's published IDL interface.  Instances are created by sending the #narrowTo: method to any Object.  Instances which are used locally will generate errors if methods invoked upon them are not in the narrowed interface.  When passed to remote systems, these instances behave as distinct objects.  Instance Variables:	object		&lt;Object&gt; the object which is to receive filtered messages.Shared Variables:		InstanceMap	&lt;IdentityDictionary&gt; objects mapping to their narrowed ObjRef instances	Index			&lt;WeakValueDictionary&gt; indexed by objectId holding WeakArrays of narrowed ObjRef instances</body></comment><class><name>CDRStream</name><environment>DST</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.CDRStream</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  This class implements the marshalling primitives as per the CORBA2.0 specificationInstance Variables:	byteOrder			&lt;Boolean&gt;  				the byte order of the remote systemShared Variables: 	BigEndian 			&lt;Boolean&gt;	 			the byte order of the platfrom	IORDef 				&lt;DSTtypeSequence&gt;	definition of an interoperable object reference</body></comment><class><name>DSTTypeCodeStream</name><environment>DST</environment><super>DST.CDRStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTTypeCodeStream</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTtypeSequence</name><environment>DST</environment><super>DST.DSTtypeTemplate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeSequence</class-id><body>Instances of Smalltalk Collection subclasses may be passed as sequence values in IDL operations.  Since IDL sequences are all strongly typed to have elements of the same type, this represents a limitation which the Smalltalk programmer must take into consideration when defining interfaces.  For situations where the Smalltalk value of choice is a heterogeneous Collection subclass, consider the use of IDL type-structure instead.IDL sequence values returned from remote operations are instantiated as Smalltalk OrderedCollections by default.  This may be overridden to accept &amp; return any Smalltalk class which has the appropriate #at: and #at:Put: methods by using the CLASS= &lt;Smalltalk class name&gt; pragma in IDL definitions.</body></comment><class><name>DSTvalueExpr</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>opString opSel left right </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTvalueExpr</class-id><body>Instance Variables:	opString 	&lt;String&gt;	opSel 		&lt;Boolean&gt;	left 			&lt;DSTvalueExpr&gt;	right 		&lt;DSTvalueExpr&gt;</body></comment><class><name>DSTparameter</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>direction type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTMetaContainer</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents symbols </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTMetaContainer</class-id><body>This class implements the CORBA 1.1 Container interface.  Its two subclasses, DSTinterface and DSTmodule, provide the implementations of InterfaceDef and ModuleDef respectively.Instance Variables:	contents  &lt;OrderedCollection&gt; of the contents of the receiver	symbols  &lt;IdentityDictionary&gt;  holding the contents keyed by their interfaceIDs and by their printNames.</body></comment><class><name>DSTmodule</name><environment>DST</environment><super>DST.DSTMetaContainer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTmodule</class-id><body>Modules contain collections of related IDL declarations and form a new naming scope for their identifiers.  Modules may be searched for their contents by accessing them through the method ORBObject class &gt;&gt; lookupName:levels:limit: excludeInherited, or more directly by accessing the ORBObject class &gt;&gt; repository method to return the overall Repository's enclosing module meta object.Each DSTmodule meta object is also an instance of the ModuleDef interface in the Repository, and may be accessed accordingly.</body></comment><class><name>ORBDaemon</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>portNo configuredPortNo receiveMsg requestBroker rpcService vpId bindingComponent hintComponent conversations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.ORBDaemon</class-id><body>This class  together with its subclasses provides an implementation of the Object Request Broker as defined in the Object Management Group's CORBA 2.0 specification. The Object Request Broker daemons are run as high priority Smalltalk processes to handle incoming RPC packets.  Subclasses of ORBDaemon each implementa request broker that supports a specific protocol.  However, each incoming message  must undergo four major processing steps which are similar to those for outgoing messages:		a) the target objectID of the request, its interfaceID, and the operationID		   of the requested operation are decoded from the packet header. 		   The IR is accessed to locate the appropriate operation meta object.		   An Objects dictionary maintained by the ORB is accessed to look up		   the target object by its objectID.  A lower priority Smalltalk server		   process is forked to perform the remaining steps.		b) the parameters of the request are unmarshalled from the packet by		    the operation object and its associated type meta objects to produce		    local Smalltalk objects in an argument array.		c) the target object is requested to #perform:withArguments: the given		    request with the supplied arguments.  This looks exactly like a local		    method invocation to the target object, and it returns its result value		    upon its completion.		d) a reply packet is created and the result value is marshalled into it by		    the operation meta object.  The packet is returned to the sender by		    the RPC service, and the server process expires.</body></comment><class><name>ORBRequest</name><environment>DST</environment><super>DST.ORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objref context operation arguments result flags status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.ORBRequest</class-id><body>This class implements CORBA 2.0 required functionality for Dynamic Invocation.  It isexpected that the Smalltalk programmer will not use these (somewhat tortuous)facilities, since the Smalltalk #perform:withArguments: method is cleaner and will accomplish exactly the same behavior.    They are, however, provided for completeness.Instance Variables:	objref 		&lt;DSTObjRef&gt;	context 		&lt;Context&gt;	operation 	&lt;DSToperation&gt;	arguments 	&lt;ORBNVList&gt;	result 		&lt;String&gt;	flags 		&lt;Set&gt;	status 		&lt;Symbol&gt;</body></comment><class><name>DSTtypeConstr</name><environment>DST</environment><super>DST.DSTtype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeConstr</class-id><body>IDL type-enumeration, type-structure, and type-union are the most difficult types to map effectively onto Smalltalk language constructs.  See each class comment for details</body></comment><class><name>DSTtypeEnumeration</name><environment>DST</environment><super>DST.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeEnumeration</class-id><body>Smalltalk Symbols are used to represent IDL type-enumeration values, where the symbol name is identical to the enumerator in all cases.  To preserve the IDL ordering requirements on enumerations, each enumeration type also defines a constant array which contains its values in declaration order.  This constant array may be accessed from the CORBAConstants poolDictionary using the fully scoped name of the type (i.e. CORBAConstants at: #'::MetaTypes::TypeCode::TCKind')Instance Variables:	values	&lt;Array&gt;</body></comment><class><name>DSTUnionCase</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discriminator type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTUnionCase</class-id><body>This class is a holds discriminator/type info for a case in a union.Instance Variables:	discriminator	&lt;Object&gt;		type			&lt;DSTtype&gt;</body></comment><class><name>DSTObjRefWidened</name><environment>DST</environment><super>DST.DSTObjRef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTObjRefWidened</class-id><body>This class is used to create surrogates for local objects which support only a subset of the local object's published IDL interface.  Instances are created by sending the #widenTo: method to any Object.  Instances which are used locally will generate errors if methods invoked upon them are not in the widened interface.  When passed to remote systems, these instances behave as distinct objects.  Instance Variables:	object		&lt;Object&gt; the object which is to receive filtered messages.Shared Variables:		InstanceMap	&lt;IdentityDictionary&gt; objects mapping to their widened ObjRef instances	Index			&lt;WeakValueDictionary&gt; indexed by objectId holding WeakArrays of widened ObjRef instances</body></comment><class><name>DSTtypeUnsignedLong</name><environment>DST</environment><super>DST.DSTtypeLong</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>IORTaggedProfile</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag profileData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IORTaggedProfile</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.Instance Variables:	tag				&lt;Integer&gt;			profileData		&lt;ByteArray&gt;	</body></comment><class><name>IORTaggedComponent</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tag componentData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IORTaggedComponent</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.Instance Variables:	tag					&lt;Integer&gt;			componentData		&lt;ByteArray&gt;	</body></comment><class><name>DSTUnion</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discriminator value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTUnion</class-id><body>This class implements a holder for type 'union' values which may be used to provide instances needed for remote method invocations where the CLASS pragma has been used to select the explicit marshalling styleInstance Variables:	discriminator		&lt;Object&gt; a value of the switch type of the union	value				&lt;Object&gt; the value of the union</body></comment><class><name>CDRExternalReadStream</name><environment>DST</environment><super>DST.CDRStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sktAddr msgSize amountRead alignmentBoundary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.CDRExternalReadStream</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTtypeCharacter</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeCharacter</class-id><body>Character values are used by the Smalltalk programmer to represent IDL char types in all situations</body></comment><class><name>IIOPConnectionReaper</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reapDelay reapProcess </inst-vars><class-inst-vars>default </class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPConnectionReaper</class-id><body>IIOPConnectionReaper implements a reap process for shutting down obsolete connections.  It is intended to be used only when the 'receiveTimeout' of IIOPConnection has been set to 'Infinity positive'.Instance Variables:	reapDelay		&lt;Integer&gt;	the delay between reap cycles	reapProcess	&lt;Process&gt;  the reap processClass Instance Variables:	default	&lt;type&gt;  commentShared Variables:	ReapDelay		&lt;Integer&gt;  the default delay between reap cycles</body></comment><class><name>DSTpseudoMeta</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTpseudoMeta</class-id><body>This class and its subclasses are used for browsing purposes only. Its instances are created by othermeta object instances on the fly. For example, enum instances create one DSTvalueinstance for each of the enumeration symbols to be included as components fordisplay purposes.</body></comment><class><name>DSTexception</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>members signal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTexception</class-id><body>Exception handling is implemented using the normal Smalltalk exception handling mechanisms.  Thus to raise an exception, the programmer can merely invoke #error: .  Since IDL exceptions are allowed to have arbitrary structured values returned with the exception, the programmer needs a way to specify this information as well.  Fortunately, Smalltalk is up to the task.  Consider the example Smalltalk fragment which raises the BAD_INV_ORDER exception (one of the standard exceptions defined in interface Object):	^ErrorSignal 		raiseWith: (Array 						with: #'BAD_INV_ORDER' 						with: (Array 								with: minor 								with: #NO))		errorString: ' routine invocations out of order'In order to allow the ORB to correctly return the error result structure to the sender of the method, an array must be returned as the parameter of the error.  Here, the symbolic name of the event is provided in an array along with the type-structure representation of the required error result values.  These values will be marshalled by the ORB to ensure that the same exception can be raised in the context of the client of the remote operation.As with normal Smalltalk exceptions, a #handle:do: recovery block may be used to catch and recover from these exceptions.  The main difference is that the ORB call context will have already unwound to the site of the remote call before the exception is raised.  This greatly limits the extent to which recovery can be accomplished.Each DSTexception meta object is also an instance of the ExceptionDef interface in the Repository, and may be accessed accordingly.Instance variables:	members	&lt;DSTtypeStructure&gt;	signal  		&lt;Signal&gt;</body></comment><class><name>DSTcachedException</name><environment>DST</environment><super>DST.DSTexception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCodeInfo idlName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTcachedException</class-id><body>This class implements the protocols needed for the shared repository mechanism to cache meta objects.  This classacts a cached exception for a meta object stored in a repository.Instance Variables:	typeCodeInfo	&lt;ByteArray&gt;	fullName		&lt;String&gt;</body></comment><class><name>DSTinterface</name><environment>DST</environment><super>DST.DSTMetaContainer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superiors subordinates sunames epv allSuperiors allOperations myOperations extent key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTinterface</class-id><body>Interfaces contain definitions of IDL constructs and define the basic unit of abstract type.  Objects in the system are manipulated via object references which each have an associated interface type.  This interface type defines all of the operations and all of the abstract behavior of the object which is accessible to a client.  Object references to local objects supporting IDL interfaces is via the normal Smalltalk object reference mechanism.  To obtain the interface which is associated with the objRef, the user may invoke the getInterface method to return the actual interface meta object which models its type information.  Other calls, from interface InterfaceDef, Container, Contained, and Object may also be invoked on this metaObjRef to further elucidate its nature.Remote object references are handled via references to local surrogate objects which are subclasses of ORBObjRef.  Since access to remote objects is transparent to the Smalltalk programmer, the above sequence of operations may also be applied.  In addition, and when the programmer knows she is dealing with a surrogate objRef, the call #interface will return the local Repository's meta object for that type.  Access to local meta objects is considerably faster, of course.Instance variables:	superiors 		&lt;OrderedCollection&gt; of interfaces from which I inherit	allSuperiors 	&lt;OrderedCollection&gt; of all interfaces from which I inherit	subordinates 	&lt;OrderedCollection&gt; of all interfaces which inherit from me	sunames		&lt;OrderedCollection&gt; of names of superior interfaces	epv 				&lt;OrderedCollection&gt; entry point vector of Smalltalk selectors for myOperations	myOperations	&lt;OrderedCollection&gt; of the operations which I define	allOperations	&lt;OrderedCollection&gt; of all the operations which I define or inherit	extent			&lt;String&gt; ODL extent name	key				&lt;Array&gt; ODL extent keys	persistence 		&lt;Symbol&gt; either #persistent or #transient or nil.  ODL persistence informationShared variables:	ForceI3IfOn	&lt;Boolean&gt; when 'true' and I3 is on, forces use of I3 marshaling even if a applicable IDL interface is available</body></comment><class><name>DSTcachedInterface</name><environment>DST</environment><super>DST.DSTinterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>idlName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTcachedInterface</class-id><body>This class extends DSTinterface to allow it to act as a cached version of an interface on a remote system.Instance variables:	fullName		&lt;String&gt;</body></comment><class><name>OldWeakKeyDictionary</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tally keys values accessLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.OldWeakKeyDictionary</class-id><body>This class implements a kind of WeakDictionary which weakly holds its keys, instead of its valuesInstance Variables:		tally	&lt;Integer&gt;		The number of elements		keys	&lt;WeakArray&gt;	The keys		values	&lt;Array&gt;			The values</body></comment><class><name>IIOPDaemon</name><environment>DST</environment><super>DST.ORBDaemon</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientConnections serverConnections localServerConversations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPDaemon</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTtypeDouble</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>RepositoryId</name><environment>DST</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.RepositoryId</class-id><body>RepositoryIds are used to uniquely identify modules, interfaces, constants, typedefs, exceptions, attributes, and operations within the interface repository. Each repository id is unique within the system (just like symbols). The repository id is represented as a byte array.Shared Variables:	IDTable			&lt;Array of: (Array of: RepositoryId)&gt;  the hash table for all repository ids</body></comment><class><name>DSTvalue</name><environment>DST</environment><super>DST.DSTpseudoMeta</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTPersistentObject</name><environment>DST</environment><super>DST.ORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTPersistentObject</class-id><body>This class optimizes access to objects which are persistent and know their own object identifier.  Other objects must have such identifiers associated with them in a dictionary (see DSTObjRef), making them less efficient when their instances need to be marshalled in an RPC transmission.Instance Variables:	objectId &lt;NCSuuid&gt; that is allocated for the object when it becomes Persistent (is registered in the 		Objects dictionary).  Due to the allocation cost of these Ids, this is postponed until the 		objectId is actually needed by some ORB-related function.</body></comment><class><name>DSTtypeFixed</name><environment>DST</environment><super>DST.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>digits scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeFixed</class-id><body>This class is now a placeholder, created so that the TCTable of DSTMetaObject couldbe properly reinitialized.</body></comment><class><name>DSToperationInfo</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface operation selector opIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSToperationInfo</class-id><body>Instance variables:	interface 	&lt;DSTinterface&gt;	operation 	&lt;DSToperation&gt;	selector 	&lt;Symbol&gt;	opIndex 	&lt;Integer&gt;</body></comment><class><name>DSTServiceContext</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contextId contextData modified extracted </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Contexts</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTServiceContext</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  This class and its subclasses implement the service contexts as per the CORBA2.0 specification</body></comment><class><name>ORBNVList</name><environment>DST</environment><super>DST.ORBObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.ORBNVList</class-id><body>This class implements CORBA 1.2 required functionality for Name-Value pairs.  It isexpected that the Smalltalk programmer will not use these (somewhat tortuous)facilities, since CORBA typeAny mechanisms are cleaner and will provide the samebehavior.  They are, however, provided for completeness.Instance Variables:	collection	&lt;Collection&gt;</body></comment><class><name>DSTtypeNamed</name><environment>DST</environment><super>DST.DSTtypeSimple</super><private>false</private><indexed-type>none</indexed-type><inst-vars>equivalentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeNamed</class-id><body>Instances of this class are produced by the IDL compiler whenever identifiers are parsed in IDL definitions.  At Repository initialization time, each DSTtypeNamed is matched with a corresponding DSTinterface, DSTdeclaratorSimple, or DSTdeclaratorComplex instances which is registered in the repository.  This is done by searching the outward from the scope in which the name is used until the intended definition is encountered.Instance Variables:	equivalentType	&lt;DSTtypeAny&gt;</body></comment><class><name>DSTvalueNamed</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedIn name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTvalueNamed</class-id><body>Instances of this class are used for IDL of scoped names in union case labels and constant declaration expressions.Instance Variables:	definedIn	&lt;DSTMetaObject&gt;  the defining meta object of the receiver	name		&lt;Symbol&gt;  the IDL name of the receiver	value		&lt;Object&gt;  the value of the receiver</body></comment><class><name>DSTObjRefLocal</name><environment>DST</environment><super>DST.DSTObjRef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTObjRefLocal</class-id><body>An instance of this class is created by an #asLocalObjRef call on any Object.  This may occur explicitly when a programmer wishes to denote that a reference to a local Smalltalk object may also be to a remote object.  In this case, the call to ORBObject&gt;&gt;asRemotable will call #asLocalObjRef if the TestRPC flag is true,  returning an instance to act as a local surrogate for the potentially remotable local object.  As long as TestRPC is true, all local messages sent to this instance will use the full interface-based RPC mechanism.  Once TestRPC is turned off, all local messages will be forwarded to the local object directly using normal Smalltalk messaging. Instance Variables:	object		&lt;Object&gt;	the local object for which the receiver is a surrogateShared Variables: 	Index		&lt;WeakValueDictionary&gt;	indexed by objectId holding references to local objects </body></comment><class><name>DSTtypeArray</name><environment>DST</environment><super>DST.DSTtypeTemplate</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arrayType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTtypeLongDouble</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>GIOPMessage</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageHeader messageStream serviceContextList requestId objectKey response operation principal status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.GIOPMessage</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTServiceConfiguration</name><environment>DST</environment><super>DST.DSTConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Configuration</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTServiceConfiguration</class-id><body>This is an abstract superclass for service configurations.Subclasses must implement the following messages:	accessing		orderOfConfiguration    "Return the order in which a service should be configured at system startup.								The smaller the number, the earlier the service should be configurd."	configuring		configure</body></comment><class><name>DSTInterfaceRepositoryConfiguration</name><environment>DST</environment><super>DST.DSTServiceConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Configuration</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTInterfaceRepositoryConfiguration</class-id><body>Instances of this class store settings information for the interface repository. Provides for the configuration of the interface repository from these settings.</body></comment><class><name>DSTModuleI3Null</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Modules</category><attributes><package>DST_Core</package></attributes></class><class><name>IIOPConversation</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection operation request reply requestId state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPConversation</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>IIOPServerConversation</name><environment>DST</environment><super>DST.IIOPConversation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>canceled </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPServerConversation</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTtypeVoid</name><environment>DST</environment><super>DST.DSTtypeSimple</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeVoid</class-id><body>Void values are never manipulated directly, however void results may be defined on operationsShared Variables:		CachedTypeVoid	&lt;DSTtypeVoid&gt;</body></comment><class><name>DSTUserContext</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Contexts</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTUserContext</class-id><body>This class implements CORBA 2.0 required functionality for User Context Objects.  </body></comment><class><name>DSTSelectorPragma</name><environment>DST</environment><super>DST.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTSelectorPragma</class-id><body>DSTSelectorPragma represents a selector pragma. A selector pragma has the following syntax:	#pragma selector &lt;name&gt; &lt;a selector&gt;Instance variables:	selector		&lt;String&gt;		the Smalltalk selector corresponding to the IDL operation</body></comment><class><name>DSTtypeShort</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTtypeUnsignedShort</name><environment>DST</environment><super>DST.DSTtypeShort</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTNamedValue</name><environment>DST</environment><super>Core.Association</super><private>false</private><indexed-type>none</indexed-type><inst-vars>flags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTModules</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Modules</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTModules</class-id><body>This class serves as an access point for the modules held in its shared variables.Instance Variables:	NoneShared Variables:	DebuggerModule	I3Module	IRBrowserModule	SecurityModule</body></comment><class><name>DSTConversationInfo</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state operation activity target role </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTConversationInfo</class-id><body>I provide information about conversations.Instance Variables:	state		&lt;String&gt;  The state of the conversation	operation	&lt;String&gt;  The operation name	activity		&lt;String&gt;  The activity description	target		&lt;String&gt;  The target object description	role		&lt;String&gt;  Client or Server</body></comment><class><name>WeakKeyDictionary</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tally keys values accessLock minimumSize growBound growRatio shrinkBound shrinkRatio </inst-vars><class-inst-vars>defaultGrowBound defaultGrowRatio defaultShrinkBound defaultShrinkRatio </class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.WeakKeyDictionary</class-id><body>This class implements a kind of WeakDictionary which weakly holds its keys, instead of its values.This version implements new growing and shrinking strategy in an attempt to address some performance issues reported by cutomers. There are some design notes below, however note that it is now possible to plug in the old version (OldWeakKeyDictionary and OldWeakValueDictionary) or a completely new custom version in most places in DST. This should be especially helpful in case the new strategy fails to match the performance of the old one in some scenarios. The new strategy also allows tuning of some of its parameters. Note however that it is a delicate issue and even though there are some basic sanity checks performed when setting the parameters, thorough testing before deployment is highly recomended. The new strategy also allows to disable shrinking altogether by setting the shrinkBound to nil.Now here are some design notes for the new strategy:There's shrinkBound (e.g 20%) and growBound (e.g. 50%) and there's a change ratio (e.g. 2) that applies to size (not tally !). Shrinking is dividing the size by ratio, growing is multiplying the size by ratio. If we define fullness as tally/size. Then the change in fullness after growing and shrinking goes like this:	a) growing:	fullness' = tally / (size * ratio) = (tally / size) * (1 / ratio) = fullness / ratio	b) shrinking:	fullness' = tally / (size / ratio) = (tally / size ) * ratio = fullness * ratioGiven our example values	a) growing at 50%:	fullness = 0.5 =&gt; fullness' = 0.5 / 2 = .25 = 25%	b) shrinking at 20%:	fullness = 0.2 =&gt; fullness' = 0.2 * 2 = 0.4 = 40%So after a grow we are at 20% and we are only 5% away from shrinking. Similiarly after a shrink we are at 40% and only 10% away from growing. This is a fairly small margin, however we don't want to reduce the ratio further (it was effectively 2.5 before), so we need to move the bounds further apart. If we go for 10% and 60% we get	grow: 60% -&gt; 30%	shrink: 10% -&gt; 20%It seems that it would be better to shrink more aggressively so that after shrink we don't have only 10% room from the next shrink. Given that we have 40% room for growing, the default shrink ratio is set to 3 which gives us		shrink: 10% -&gt; 30%So these are the current default parameter values:	shrinkBound = 0.1	"shrink when only 10% full"	shrinkRatio = 3		"shrink by 3"	growBound = 0.6	"grow when 60% full"	growRatio = 2.		"grow by 2"Instance Variables:	tally	&lt;Integer&gt; The number of elements	keys	&lt;WeakArray&gt; The keys	values	&lt;Array&gt; The values	accessLock	&lt;RecursionLock&gt; 	minimumSize	&lt;Integer&gt; never shrink below this size (initialized to the original #new: paramater)	growBound	&lt;Float&gt; the tally/capacity at which we should grow	growRatio	&lt;Number&gt; the ratio by which to grow when grow bound is reached (capacity' := capacity * growRatio)	shrinkBound	&lt;Float&gt; the tally/capacity at which we should shrink	shrinkRatio	&lt;Number&gt; the ratio by which to shrink when shrink bound is reached (capacity' := capacity / shrinkRatio)Class Instance Variables:	defaultGrowBound	&lt;Float&gt; the tally/capacity at which we should grow	defaultGrowRatio	&lt;Number&gt; the ratio by which to grow when grow bound is reached (capacity' := capacity * growRatio)	defaultShrinkBound	&lt;Float&gt; the tally/capacity at which we should shrink	defaultShrinkRatio	&lt;Number&gt; the ratio by which to shrink when shrink bound is reached (capacity' := capacity / shrinkRatio)</body></comment><class><name>WeakValueDictionary</name><environment>DST</environment><super>DST.WeakKeyDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.WeakValueDictionary</class-id><body>This class implements a kind of WeakKeyDictionary which weakly holds its values, not its keys.  Very similar to WeakDictionary, but without keeping track of executors.</body></comment><class><name>DSTObjRefInactive</name><environment>DST</environment><super>DST.DSTObjRef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>activator databaseId useTimer objectCache weakCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTObjRefInactive</class-id><body>This class is intended to support evolution to an Object Database environment where larger numbers of persistent objects may be maintained in stasis outside of the Smalltalk image.  In this environment, a DSTObjRefInactive may be used to indicate a reference to an object which is currently in the InActive state.  Inactive ObjRefs have an activation block which, when evaluated, will materialize the object into the Smalltalk image upon demand.  InActive ObjRefs are used by the BasicLifecycle operations externalize and internalize, which use the BOSS call persistentState and resetPersistentState operations to serialize and deserialize themselves.  Inactive ObjRefs are used in the persistentState implementations in order to keep the BOSS from traversing references to objects which are not a part of their actual persistent state.  Upon reading an Inactive ObjRef, the BOSS will attempt to resolve its reference immediately.  In the default implementation, the activator block contains a local lookup of the object using its UUID and no other persistence mechanism is used.Instance Variables:	activator		&lt;BlockClosure&gt; an activation block which will return an active instance upon request.	databaseId		&lt;String&gt; the identifier used by the database to uniquely reference the object	useTimer		&lt;Integer&gt; the number of timerDaemon intervals (60sec) since the last access	objectCache	&lt;Object&gt; a strong reference to the activated instance	weakCache	&lt;WeakArray&gt; a weak reference to the activated instance(not used in this release)Shared Variables:	CacheTimeout	&lt;Integer&gt; the number of minutes of inactivity after which the strong cache is flushed.	Index			&lt;WeakValueDictionary&gt; of instances of this class keyed by their UUID	ObjRefTimeout	&lt;Integer&gt; the number of minutes of inactivity after which the objRefInactive is flushed</body></comment><class><name>DSTInterceptorCollection</name><environment>DST</environment><super>Core.SortedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Interceptors</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTInterceptorCollection</class-id><body>A DSTInterceptorCollection is a SortedCollection of DSTInterceptors that understands the interception protocols of both message and request interceptors, and that re- dispatches messages in those protocols to its elements.Instance Variables: 	*Indexed*Class Instance Variables:	None.Sharde Variables:	None.</body></comment><class><name>DSTVersionPragma</name><environment>DST</environment><super>DST.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTVersionPragma</class-id><body>This class represents a version pragma. A version pragma has the form:	#pragma version &lt;name&gt; major.minorInstance Variables:	version		&lt;String&gt;		The major.minor version as a string</body></comment><class><name>DSTtypeString</name><environment>DST</environment><super>DST.DSTtypeTemplate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeString</class-id><body>Smalltalk strings and their subclasses may be passed and will be returned by IDL operations involving type-string arguments.  The Smalltalk class of returned values can be specified using the CLASS= &lt;Smalltalk class name&gt; pragma in the IDL definition.</body></comment><class><name>DSTtypeWideString</name><environment>DST</environment><super>DST.DSTtypeString</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeWideString</class-id><body>Smalltalk strings and their subclasses may be passed and will be returned by IDL operations involving type-string arguments.  The Smalltalk class of returned values can be specified using the CLASS= &lt;Smalltalk class name&gt; pragma in the IDL definition.</body></comment><class><name>DSTpseudoTypeCode</name><environment>DST</environment><super>DST.DSTtype</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTpseudoTypeCode</class-id><body>A DSTpseudoTypeCode gets created when the TypeCode IDL keyword is seen by the IDL compiler. It is the type codefor a given IDL type.Shared Variables:	TCStreamDef	&lt;DSTtypeSequence&gt;	a type code stream (a sequence of octet).</body></comment><class><name>DSTsignature</name><environment>DST</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>ins outs return params </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTsignature</class-id><body>Signatures are a subclass of OrderedCollection with some filters for accessing parameters by their direction attributes.Instance Variables:	ins		&lt;DSTsignature&gt;		collection of all of the #in parameters in this signature	outs	&lt;DSTsignature&gt;		collection of all of the #out parameters in this signature	return	&lt;DSTparameter&gt;	 	return parameter of this signature	</body></comment><class><name>DSTAccessPragma</name><environment>DST</environment><super>DST.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessRights </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTAccessPragma</class-id><body>This class represents an access pragma which has the following syntax:	#pragma access &lt;name&gt; &lt;rights&gt;Instance Variables:	accessRights	&lt;Symbol&gt;		the user specified access rights</body></comment><class><name>DSTtypeFloat</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeFloat</class-id><body>Float and Double values are used by the Smalltalk programmer to represent IDL float and double types in all situations</body></comment><class><name>DSTparameterDescription</name><environment>DST</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type typeDef mode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTconstant</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeSpec valueExpr value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTconstant</class-id><body>IDL constant values are stored in a pool dictionary CORBAConstants under the fully qualified name of the constant.  Each DSTconstant meta object is also an instance of the ConstantDef interface in the Repository, and may be accessed accordingly.Instance variables:	valueExpr	&lt;DSTvalueExpr&gt;	typeSpec 	&lt;DSTtype&gt;	value 		&lt;String&gt;</body></comment><class><name>DSTattributeDescription</name><environment>DST</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id definedIn version type mode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>IIOPClientConversation</name><environment>DST</environment><super>DST.IIOPConversation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>semaphore target result args opSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPClientConversation</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTtypeAlias</name><environment>DST</environment><super>DST.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>equivalentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeAlias</class-id><body>A type alias is a first class meta object. Type aliases are created as the resultof a typedef. Type aliases can have class pragmas and thus override the localtype of the type being aliased.Instance variables:	equivalentType	&lt;DSTMetaObject&gt; the type being aliased.</body></comment><class><name>NCSuuid</name><environment>DST</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.NCSuuid</class-id><body>This class implements the NCS 1.5.1 Universally Unique Identifier definition.  A UUIDconsists of a 16 byte quantity which encodes a network IP address and a timestamp value.  In order to allow UUIDs to be used as keys in various dictionariesmaintained by the ORBObject class, they are interned using similar code to thatin the Symbol class.Shared Variables:	NilId 		&lt;NCSuuid&gt; which contains all zero byte values &amp; denotes nil.	STable	 	&lt;Array&gt; The symbol table used to intern UUID values.	Sema 		&lt;Semaphore&gt; 	Tincr 		&lt;Integer&gt;	Tval		&lt;Integer&gt;</body></comment><class><name>OldWeakValueDictionary</name><environment>DST</environment><super>DST.OldWeakKeyDictionary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST_Marshalling_Test</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.OldWeakValueDictionary</class-id><body>This class implements a kind of WeakKeyDictionary which weakly holds its values, not its keys.  Very similar to WeakDictionary, but without keeping track of executors.</body></comment><class><name>OrbResolver</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTpseudoType</name><environment>DST</environment><super>DST.DSTpseudoMeta</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>IIOPClientConnection</name><environment>DST</environment><super>DST.IIOPConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPClientConnection</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTtypeOctet</name><environment>DST</environment><super>DST.DSTtypeBase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeOctet</class-id><body>Character and SmallInteger values may be used by the Smalltalk programmer to represent IDL octet types</body></comment><class><name>ORBStartUpCoordinator</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.ORBStartUpCoordinator</class-id><body>This class coordinates the startup/shutdown for the Distributed Smalltalk System.  There is a single instance of thisclass held by ORBDaemon.  You can get access to this instance by sending the message:ORBDaemon startUpCoordinator.  Instance Variables:	state	&lt;ValueHolder on: Symbol&gt; that contains the current startup state of the system.  The possible states are (#started #stopped #shutdownPending  #aboutToShutdown)	</body></comment><class><name>DSTdeclaratorSimple</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTdeclaratorSimple</class-id><body>Declarators are used to name type meta objects within an IDL scope.  In practice, each declarator is registered in the symbol dictionary of its defining meta container and is referenced by DSTtypeNamed instances in other parts of the Repository.  Instance variables:	baseType 	&lt;DSTtypeAny&gt;</body></comment><class><name>DSTAny</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTAny</class-id><body>This class implements a holder for type 'any' values which may be used to provide instances needed for remote method invocations where the CLASS pragma has been used to select the explicit marshalling styleInstance Variables:	type		&lt;DSTMetaObject&gt;  the type of the any	value		&lt;Object&gt; the value of the any</body></comment><class><name>GIOPMessageHeader</name><environment>DST</environment><super>DST.CDRStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>magic majorVersion minorVersion msgType msgSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-IIOP</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.GIOPMessageHeader</class-id><body>This class is private to the implementation of Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  </body></comment><class><name>DSTmoduleRepository</name><environment>DST</environment><super>DST.DSTmodule</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTmoduleRepository</class-id><body>This class implements the root of the meta object structure constituting the interface repository.Shared Variables:	SearchSubscope	&lt;Boolean&gt;	if true, then name resolution will continue searching the content of the repository, otherwise name resolution will stop at the repository level	PKTable				&lt;Dictionary&gt; the mapping from primitive kind symbols to Smalltalk classes</body></comment><class><name>DSTexceptionDescription</name><environment>DST</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id definedIn version type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>IORMultipleComponents</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components vpId objectId objectAdapter iiopStream bindings hints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IORMultipleComponents</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  Instance Variables: 	components 		&lt;OrderedCollection&gt;	 	vpId  				&lt;ByteArray | nil&gt;		objectId  			&lt;ByteArray | nil&gt;	 	objectAdapter  		&lt;ByteArray | nil&gt;		iiopStream  		&lt;Boolean&gt;	 	bindings  			&lt;OrderedCollection&gt;	 	hints  				&lt;ByteArray | nil&gt;	 </body></comment><class><name>DSTObjRefRemote</name><environment>DST</environment><super>DST.DSTObjRef</super><private>false</private><indexed-type>none</indexed-type><inst-vars>adapterId bindings profiles adapterBootTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTObjRefRemote</class-id><body>This class refines the ORBObjRef class to add information necessary to allow a remote object to be identified via the ORB's location service.   Smalltalk messages which are sent to an instance of this class are forwarded to the remote object automatically by the ORB.Instance Variables:	adapterId	&lt;NCSuuid&gt; that uniquely identifies an object adapter which has been known to	bindings	&lt;DSTBindingComponents&gt; binding associated with the reference	profiles	&lt;Collection&gt; the profile associated with the referene	adapterBootTime	&lt;Integer&gt; Shared Class Variables:	DSTAdapterBindings	&lt;WeakValueDictionary key: NCSuuid value: DSTBindingComponents&gt; cached bindings keyed by adapterIds	Index	&lt;WeakKeyDictionary key: NCSuuid value: WeakValueDictionary&gt; for each adapterId maintain an index of imported remote references keyed by objectIds	MultipleComponentDef	&lt;DSTtype&gt; cached IDL definition of the multiple component profile type	ObjectKeyDef	&lt;DSTtype&gt; cached IDL definition of the object key type	SubIndexClass	&lt;Class&gt; the class of dictionary used for the per-adapter sub-indexes</body></comment><class><name>DSTBindingComponents</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>components bootTime ncsAddr iiopAddr </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTBindingComponents</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.Instance Variables:	components	&lt;OrderedCollection&gt; a collection of tagged components that contain the binding information used for remote messaging	policy		&lt;Integer&gt; the location policy to determine whether the bindings provided identity the object's server location or a location agent.	ncsAddr	&lt;IPSocketAddress&gt; the socket address for communication to the server using the NCS protocol	iiopAddr	&lt;IPSocketAddress&gt;  the socket address for communication to the server using the IIOP protocol</body></comment><class><name>DSTattribute</name><environment>DST</environment><super>DST.DSTMetaObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeSpec readOnly getOp setOp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTattribute</class-id><body>IDL attribute declarations are a shorthand mechanism of defining pairs of simple accessor operations, one to set the value of the attribute and one to get it.  Such accessor methods are common in Smalltalk programs as well, thus attribute declarations are mapped to standard methods to get and set the named attribute value, respectively.For example:attribute		string		title;means that Smalltalk programmers can expect to make #title and #title: calls to get and set the title attribute of the object.  Each DSTattribute meta object is also an instance of the AttributeDef interface in the Repository, and may be accessed accordingly.Instance variables:	typeSpec 	&lt;DSTtype&gt;	readOnly  	&lt;Boolean&gt;	getOp  		&lt;DSToperation&gt;	setOp  		&lt;DSToperation&gt;</body></comment><class><name>DSTcachedOperation</name><environment>DST</environment><super>DST.DSToperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTcachedOperation</class-id><body>This class extends DSToperation to allow it to act as a cached version of an operation stored on a remote system.</body></comment><class><name>DSTMessageInterceptor</name><environment>DST</environment><super>DST.DSTInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Interceptors</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTMessageInterceptor</class-id><body>DSTMessageInterceptor is the abstract superclass of all concretemessage interceptors.  It provides null implementation of the fourmessages in the message interception protocol, any of which may be given non-null implementation by concrete subclasses.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>DSTtypeUnion</name><environment>DST</environment><super>DST.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>switchtype cases defaultValue defaultIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeUnion</class-id><body>IDL type-unions are represented in Smalltalk by instances of the Association class, where the key of the association is the discriminator value and where the value of the association is the union member.  For proper operation during remote invocation, both the key and the value of the association must be of a type which is compatible with the respective union declaration roles.Instance Variables:	switchtype 	&lt;DSTtypeEnumeration | DSTtypeCharacter | DSTtypeInteger | DSTtypeBoolean | DSTtypeNamed&gt;		IDL type of the switch	cases 		&lt;Array of: DSTUnionCase&gt;	defaultValue &lt;Boolean | Symbol | Integer | Character&gt; a computed sample value that can be used to marshall the default case</body></comment><class><name>ScopeBlock</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>prefix container pragmas </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.ScopeBlock</class-id><body>ScopeBlocks are used by the IDL compiler to handle prefix pragmas. As a new scope isentered an instance of a ScopeBlock is created and pushed on a scoping stack.Instance Variables:	prefix 			&lt;IDLPrefix&gt;  holds the current prefix and container	container		&lt;DSTMetaContainer&gt; the container for objects in this scope	pragmas			&lt;OrderedCollection&gt; an ordered stack of pragmas to be applied to						objects in this scope</body></comment><class><name>DSTRequestInterceptor</name><environment>DST</environment><super>DST.DSTInterceptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Interceptors</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTRequestInterceptor</class-id><body>DSTRequestInterceptor is the abstract superclass of all concrete request interceptors.  It provides null implementation of the four messages in the request interception protocol, any of which may be given non-null implementation by concrete subclasses.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>DSTtypeWideCharacter</name><environment>DST</environment><super>DST.DSTtypeCharacter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><class><name>ORBContext</name><environment>DST</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>corbaContext serviceContexts local </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Contexts</category><attributes><package>DST_Core</package></attributes></class><class><name>DSTcachedParameter</name><environment>DST</environment><super>DST.DSTparameter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCodeInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTcachedParameter</class-id><body>This class implements the protocols needed for the shared repository mechanism to cache remote parameters.  This class acts a cached parameter for a meta object stored on a remote system.Instance Variables:	typeCodeInfo	&lt;ByteArray&gt;</body></comment><class><name>DSTIDPragma</name><environment>DST</environment><super>DST.DSTIRPragma</super><private>false</private><indexed-type>none</indexed-type><inst-vars>repositoryId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Compilers</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTIDPragma</class-id><body>This class represents an ID pragma which has the following syntax:	#pragma ID &lt;name&gt; &lt;repositoryId&gt;The repositoryId can be one of three types: IDL, DCE, or LOCAL.Instance variables:	repositoryId	&lt;RepositoryId&gt;	the user specified repository Id</body></comment><class><name>IIOPObjectKey</name><environment>DST</environment><super>Core.ByteArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Protocols-Core</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPObjectKey</class-id><body>This class is private to the implementation of the Distributed Smalltalk.  Users should not use this class directly and should not subclass it.  Instances of this class represent unique keys.  These keys are opaque to theclient and are used for keys to objects from other ORB vendors.Shared Variables: 	ObjKeyTable		&lt;Array&gt;	 the hash table for instances of this class</body></comment><class><name>ORBConstantsDictionary</name><environment>DST</environment><super>Core.IdentityDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>exceptions exceptionIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-Core</category><attributes><package>DST_Core</package></attributes></class><class><name>IIOPConfiguration</name><environment>DST</environment><super>DST.DSTTransportConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Configuration</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.IIOPConfiguration</class-id><body>This class represents the IIOP transport protocol.  It also stores settings related to the protocol.Inherited Instance Variables:	settingDictionary							&lt;IdentityDictionary &lt;Symbol -&gt; ValueModel&gt;&gt;					Setting information: maps setting symbol to valueEntries in settingDictionary (all stored as values):	iiopPortNumberKind								&lt;Symbol&gt;						How is the iiop port number configured (#dynamic, #configured)	iiopConfiguredPortNumber						&lt;Integer&gt;						If #configured	iiopWriteIncrementKind							&lt;Symbol&gt;						How is the write increment configured (#systemDefault, #configured)	iiopConfiguredWriteIncrementSize							&lt;Integer&gt;						If #configured	isI3On					&lt;Boolean&gt;					Is Implicit Invocation Interface on?  Same value as ORBConfigurationManager.</body></comment><class><name>ORBConfigurationManager</name><environment>DST</environment><super>DST.DSTConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logTranscript resetAdapterId chosenTransports </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DST-Configuration</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.ORBConfigurationManager</class-id><body>Instances of this class maintain miscellaneous configuration information for the system. It also acts as an access point to all other configuration information stored in other subclasses of DSTConfiguration. In addition it provides a message logging system, this functionality should be moved elsewhere.  There is a single instance of this class held by ORBDaemon.  You can get access to this instance by sending the message:	"ORBDaemon configurationManager".  Inherited Instance Variables:	settingDictionary							&lt;IdentityDictionary &lt;Symbol -&gt; ValueModel&gt;&gt;					Setting information: maps setting symbol to valueInstance Variables:	resetAdapterId					&lt;Boolean&gt;			  		whether or not the adapterId needs to be reset at startup	logTranscript					&lt;nil | Stream | TextCollector&gt;					where the DST system will log to. 					if nil, goes to Transcript.Entries in settingDictionary (all stored as values):	loggingLevel					&lt;Integer&gt;			  		desired logging level number	debuggingOn					&lt;Boolean&gt;			  		is true iff remote debugging is enabled	localRPCTestingOn					&lt;Boolean&gt;			 		is true iff local RPC testing is on	objectAdapterIdKind					&lt;Symbol&gt;					How is the adapter ID configured (#dynamic, #configured)	configuredAdapterId					&lt;String&gt;						'6f6ad0b9-5b6a-0000-020f-1c680a000000' asValue;	isI3On					&lt;Boolean&gt;					Is Implicit Invocation Interface on?  Same value as IIOPConfiguration..</body></comment><class><name>DSTtypeStructure</name><environment>DST</environment><super>DST.DSTtypeConstr</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fields allFields useClassMethod useCombinedmethod selector readSelectors writeSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CORBA-MetaObjects</category><attributes><package>DST_Core</package></attributes></class><comment><class-id>DST.DSTtypeStructure</class-id><body>Heterogeneous instances of Collection subclasses may be passed as parameter values to IDL operations, assuming that their run-time values can be marshalled by the appropriate type meta objects in the order of field-type specification.  OrderedCollection values containing these instances will be returned by remote operations.In addition, any Smalltalk class which has method selectors with the same names as the fields in the IDL type definition can be used to produce type-structured values for remote calls.  On return parameters, a method of the form #'f1:f2:f3:...:fn:' , where fi are the field names, will be called on the class or on a new instance to properly initialize the result value.  To utilize this capability, the Smalltalk class name must have been declared in a CLASS pragma associated with the IDL type declaration.Instance Variables:	fields				&lt;OrderedCollection&gt;	allFields				&lt;OrderedCollection&gt;	useClassMethod		&lt;Boolean&gt;	useCombinedmethod	&lt;Boolean&gt;	selector				&lt;Symbol&gt;	readSelectors		&lt;OrderedCollection&gt;	writeSelectors		&lt;OrderedCollection&gt;</body></comment><shared-variable><name>TCStreamDef</name><environment>DST.DSTpseudoTypeCode</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>RadiansPerDegree</name><environment>DST.DSTLongDouble</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Pi</name><environment>DST.DSTLongDouble</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>WriteIncrement</name><environment>DST.IIOPConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ReceiveTimeOut</name><environment>DST.IIOPConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ActiveDaemon</name><environment>DST.IIOPConnection</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Services</name><environment>DST.DSTConfiguration</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Transports</name><environment>DST.DSTConfiguration</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>DeadObject</name><environment>DST.ORBDeadObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>CurrentPrefix</name><environment>DST.DSTMetaObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>TCTable</name><environment>DST.DSTMetaObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>TCMap</name><environment>DST.DSTMetaObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Index</name><environment>DST.DSTObjRefWidened</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>InstanceMap</name><environment>DST.DSTObjRefWidened</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Type</name><environment>DST.DSTEnumerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>AllTransports</name><environment>DST.DSTTransportConfiguration</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>BigEndian</name><environment>DST.CDRStream</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>IORDef</name><environment>DST.CDRStream</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>CORBAConstants</name><environment>DST</environment><private>false</private><constant>false</constant><category>CORBA</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Session</name><environment>DST</environment><private>false</private><constant>false</constant><category>CORBA</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ConfigurationManager</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>VPId</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ActiveDaemons</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>OAComponent</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ActiveDaemonsByTag</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>InstalledDaemons</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>TransientErrorHandler</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>NodeName</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>UseDottedQuads</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>NodeId</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>StartUpCoordinator</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>DomainId</name><environment>DST.ORBDaemon</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>I3Module</name><environment>DST.DSTModules</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>SecurityModule</name><environment>DST.DSTModules</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>IDTable</name><environment>DST.RepositoryId</environment><private>false</private><constant>false</constant><category>Statics</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Objects</name><environment>DST.DSTObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Retrying</name><environment>DST.DSTObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ObjectIdsClass</name><environment>DST.DSTObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified </category><initializer>DST.WeakKeyDictionary</initializer><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>LifeCycleObjects</name><environment>DST.DSTObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>RegisteredObjects</name><environment>DST.DSTObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ObjectsClass</name><environment>DST.DSTObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified </category><initializer>DST.WeakValueDictionary</initializer><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ObjectIds</name><environment>DST.DSTObjRef</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>STable</name><environment>DST.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Tincr</name><environment>DST.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>NilId</name><environment>DST.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Sema</name><environment>DST.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Tval</name><environment>DST.NCSuuid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ObjKeyTable</name><environment>DST.IIOPObjectKey</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>InstalledContexts</name><environment>DST.DSTServiceContext</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>CachedTypeVoid</name><environment>DST.DSTtypeVoid</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Index</name><environment>DST.DSTObjRefNarrowed</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>InstanceMap</name><environment>DST.DSTObjRefNarrowed</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ActiveDaemon</name><environment>DST.IIOPConversation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>MessageInterceptors</name><environment>DST.IIOPConversation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>RequestInterceptors</name><environment>DST.IIOPConversation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>MessageTimeOut</name><environment>DST.IIOPConversation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>RemoteRepository</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>NamingService</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>LocalRepository</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>BOAid</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>InterfaceRepository</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Services</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>InstallDir</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>RepositoryCache</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Factories</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>AccessSymbols</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>SharedRepositoryModule</name><environment>DST.ORBObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Index</name><environment>DST.DSTObjRefInactive</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>StorageServer</name><environment>DST.DSTObjRefInactive</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ObjRefTimeout</name><environment>DST.DSTObjRefInactive</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>CacheTimeout</name><environment>DST.DSTObjRefInactive</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>TCStreamDef</name><environment>DST.DSTtypeAny</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>CORBATypeMap</name><environment>DST.DSTtypeAny</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>TypeMapClass</name><environment>DST.DSTtypeAny</environment><private>false</private><constant>false</constant><category>As yet unclassified </category><initializer>DST.WeakKeyDictionary</initializer><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Index</name><environment>DST.DSTObjRefRemote</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>SubIndexClass</name><environment>DST.DSTObjRefRemote</environment><private>false</private><constant>false</constant><category>As yet unclassified </category><initializer>DST.WeakValueDictionary</initializer><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>DSTAdapterBindings</name><environment>DST.DSTObjRefRemote</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>MultipleComponentDef</name><environment>DST.DSTObjRefRemote</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ObjectKeyDef</name><environment>DST.DSTObjRefRemote</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>RequestId</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>HFSem</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>HeaderSize</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>PrincipalDef</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>MessageSize</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>MessageBuffers</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ProfileBodyDef</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Headers</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>LargeBuffers</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Fragments</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ServiceContextListDef</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ObjectKeyDef</name><environment>DST.GIOPMessage</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>LocatorTable</name><environment>DST.OrbResolver</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ReapDelay</name><environment>DST.IIOPConnectionReaper</environment><private>false</private><constant>false</constant><category>statics</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ServiceContextListDef</name><environment>DST.DSToperation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>ContextIF</name><environment>DST.DSToperation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>Index</name><environment>DST.DSTObjRefLocal</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>PKTable</name><environment>DST.DSTmoduleRepository</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><shared-variable><name>SearchSubscope</name><environment>DST.DSTmoduleRepository</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DST_Core</package></attributes></shared-variable><methods><class-id>DST.DSTModuleSecurityNull class</class-id> <category>accessing</category><body package="DST_Core">authorizeHost: aHostId 	"add the hostId to the Authorized Hosts List. No-op if not possible."</body><body package="DST_Core">authorizedHosts	"Answer a collection of hostNames that are authorized to connect to this 	system. Answer empty collection if unaccessable."	^#()</body><body package="DST_Core">checkAccessLocallyFor: anObject selector: anOpSymbol 	"Check the access rights for a local object.	Raise an exception if there are problems.	No-op if security is not loaded or user security is off."</body><body package="DST_Core">checkUserAuthorization: obj forOperation: anOperation 	"Check security constraints - raise exception on violation. 	No-op is security off or not loaded."</body><body package="DST_Core">denyAccessForHost: aHostId 	"remove a hostId from the list of authorized hosts. No-op if not possible."</body><body package="DST_Core">do: aBlock asDelegate: aPrincipal 	"This method evaluates a block with changing the context to 	represent another user.   Just evaluate the block if no security."	aBlock value</body><body package="DST_Core">exampleUserDB	"Return the example user database.	Raise exception if not available."	self signalNotLoaded:  'Cannot access example User Database'</body><body package="DST_Core">hostIsAuthorized: aSockAddr 	"return true if the socket address is authorized for this daemon.	Return true if not security not loaded."	^true</body><body package="DST_Core">hostSecurity	"Answer whether or not host security is enabled"	^false</body><body package="DST_Core">hostSecurityValue	"Answer whether or not system security is enabled"	self signalNotLoaded:  'Cannot return Host Security value'</body><body package="DST_Core">login: aSymbol userId: aNCSuuid 	"Login given the login and userId.	Raise exception on failure."	self signalNotLoaded:  'Cannot login'</body><body package="DST_Core">newSecurityContext	"Return a new security context.  Fail if not loaded."	self error: 'Should not be called'</body><body package="DST_Core">openACLeditorOn: anObject	"Open an ACL editor on 'anObject'.  Raise an exception if not possible."	self signalNotLoaded:  'Cannot open Access Control editor'</body><body package="DST_Core">openSecurityTool	"Open a tool to access all security features.  	Throw exception if not possible."	self signalNotLoaded:  'Cannot open Security Tool'</body><body package="DST_Core">principal	"Answer the Principal for this image.  Nil if unset."	^nil</body><body package="DST_Core">principal: aDSTPrincipal 	"Set the Principal for this image if it's an instance of the appropriate 	type.  No-op if not settable."</body><body package="DST_Core">signalNotLoaded: errorString	"Answer whether or not system security is enabled"	Object errorSignal raiseWith: 'Security is not loaded' errorString: errorString</body><body package="DST_Core">userDB	"Answer the user database. Nil if none."	^nil</body><body package="DST_Core">userDB: aUserDB 	"Set the user database. No-op if none."</body><body package="DST_Core">userNotFoundSignal	"Return 'User Not Found' signal.	Raise exception on failure."	self signalNotLoaded:  'Cannot return signal'</body><body package="DST_Core">userSecurity	"Answer whether or not system security is enabled"	^false</body><body package="DST_Core">userSecurityValue	"Answer whether or not system security is enabled"	self signalNotLoaded: 'Cannot return User Security value'</body></methods><methods><class-id>DST.DSTModuleSecurityNull class</class-id> <category>testing</category><body package="DST_Core">isLoaded	"Is this module loaded."	^false</body></methods><methods><class-id>DST.DSTConfiguration</class-id> <category>private-settings</category><body package="DST_Core">settingFor: aSymbol 	"Retrieve the setting for aSymbol"	^(self settings  at: aSymbol) value</body><body package="DST_Core">settingFor: aSymbol put: aValue	"Set the setting for aSymbol"	^(self settings  at: aSymbol) value: aValue</body><body package="DST_Core">settingModelFor: aSymbol 	"Return direct value model access to the setting for 'aSymbol'"	^self settings at: aSymbol</body></methods><methods><class-id>DST.DSTConfiguration</class-id> <category>accessing</category><body package="DST_Core">allServices	^Services</body><body package="DST_Core">allTransports	^Transports</body><body package="DST_Core">transportNamed: transportName	^self transportNamed: transportName ifAbsent: [self error: 'No transport protocol named "', transportName, '"']</body><body package="DST_Core">transportNamed: transportName ifAbsent: absentBlock	^self allTransports at: transportName asSymbol ifAbsent: absentBlock</body></methods><methods><class-id>DST.DSTConfiguration</class-id> <category>private-read/write</category><body package="DST_Core">lineEnd: strm 	strm cr.	strm nextPut: Character lf</body><body package="DST_Core">readFrom: strm triggeredBy: triggerChannel 	"read configuration from the stream 'strm'."	"Buffer until triggerChannel is set true"	| buffer |	buffer := self copySettingsBufferedTriggerChannel: triggerChannel.		[self skipSeparators: strm.	strm atEnd or: [strm peek = $[]]		whileFalse: 			[| id holder newVal |			id := self readIdFrom: strm.			holder := buffer at: id asSymbol ifAbsent: [Object errorSignal raiseWith: 'Invalid id'].			newVal := self readValueFrom: strm currentValue: holder value.			holder value: newVal]</body><body package="DST_Core">readIdFrom: strm 	| idStrm ch id |	idStrm := WriteStream on: String new.		[ch := strm next.	(ch = $= or: [ch = nil or: [ch isSeparator]])		ifTrue: [true]		ifFalse: 			[idStrm nextPut: ch.			false]] whileFalse.	id := idStrm contents.	id size = 0 ifTrue: [Object errorSignal raiseWith: 'empty id'].	[ch = Character space | (ch = Character tab)]		whileTrue: [ch := strm next].	ch = $= ifFalse: [Object errorSignal raiseWith: 'expected "=" after reading id: ' , id printString].	^id</body><body package="DST_Core">readValueFrom: strm currentValue: currVal 	| first val ch valStrm |		[first := strm next.	first = Character space | (first = Character tab)] whileTrue.	strm atEnd | (first = nil) | (first = Character cr) | (first = Character lf) | (first = Character newPage) ifTrue: [Object errorSignal raiseWith: 'missing value'].	(currVal isString and: [currVal isSymbol not])		ifTrue: [(first = $' or: [first = $"])				ifTrue: 					[valStrm := WriteStream on: String new.					[strm atEnd]						whileFalse: 							[ch := strm next.							ch = first								ifTrue: [^valStrm contents]								ifFalse: [ch = nil | (ch = Character cr) | (ch = Character lf) | (ch = Character newPage)										ifTrue: [Object errorSignal raiseWith: 'expecting quoted string (no closing ' , (String with: first) , ' )']										ifFalse: [valStrm nextPut: ch]]].					Object errorSignal raiseWith: 'expecting quoted string (encountered end of file, no closing ' , (String with: first) , ' )']				ifFalse: [Object errorSignal raiseWith: 'expecting quoted string (first character was ' , (String with: first) , ' )']].	strm skip: -1.	currVal isInteger ifTrue: [first isDigit			ifTrue: [^Integer readFrom: strm]			ifFalse: [Object errorSignal raiseWith: 'expecting integer value (first character was ' , (String with: first) , ' )']].	valStrm := WriteStream on: String new.	[strm atEnd		or: 			[ch := strm next.			ch isSeparator]]		whileFalse: [valStrm nextPut: ch].	val := valStrm contents.	(currVal == true or: [currVal == false])		ifTrue: 			[val asLowercase = 'true' ifTrue: [^true].			val asLowercase = 'false' ifTrue: [^false].			Object errorSignal raiseWith: 'expecting Boolean value (instead got ' , val printString , ' )'].	currVal isSymbol ifTrue: [^val asSymbol].	Object errorSignal raiseWith: 'current value of setting invalid: ' , currVal printString</body><body package="DST_Core">skipSeparators: strm 	"Move the receiver's position past any separators (including comments)."		[	[| next |	next := strm next.	next = $; ifTrue: [		[next := strm next.		next = Character cr or: [next = Character lf]] whileFalse].	next isSeparator] whileTrue.		"We will not reach here if the end-of-stream is encountered"	strm skip: -1]		on: strm class endOfStreamSignal do: [:ex | ex return]</body><body package="DST_Core">writeConfigurationTo: strm 	self settings keys asSortedCollection		do: 			[:key | 			| val |			strm nextPutAll: key.			strm nextPut: $=.			val := self settingFor: key.			strm nextPutAll: (val isSymbol					ifTrue: [val]					ifFalse: [val printString]).			self lineEnd: strm ]</body></methods><methods><class-id>DST.DSTConfiguration</class-id> <category>settings tool access only</category><body package="DST_Core">copySettingsBufferedTriggerChannel: triggerChannel 	| buffered |	buffered := self settings  copyEmpty: self settings  size.	self settings  keysAndValuesDo: [:key :setting | buffered at: key put: 		(BufferedValueHolder subject: setting triggerChannel: triggerChannel)].	^buffered</body></methods><methods><class-id>DST.DSTConfiguration</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"</body></methods><methods><class-id>DST.DSTConfiguration class</class-id> <category>private</category><body package="DST_Core">addService	Services == nil ifTrue: [Services := IdentityDictionary new].	Services at: self configurationName put: self new</body><body package="DST_Core">addTransport	Transports == nil ifTrue: [Transports := IdentityDictionary new].	Transports at: self configurationName put: self new.	self noteTransportChange</body><body package="DST_Core">noteTransportChange	"Tell the configuration manager that the list of transports has 	changed."	"self noteTransportChange"	| daemon mngr |	daemon := #{ORBDaemon} valueOrDo: [nil].	daemon isNil ifTrue: [^self].	mngr := daemon configurationManager.	mngr isNil ifTrue: [^self].	mngr updateChosenTransports</body><body package="DST_Core">removeService	Services == nil ifFalse: [Services removeKey: self configurationName ifAbsent: []]</body><body package="DST_Core">removeTransport	Transports == nil ifFalse: [Transports removeKey: self configurationName ifAbsent: []].	self noteTransportChange</body></methods><methods><class-id>DST.DSTConfiguration class</class-id> <category>accessing</category><body package="DST_Core">configurationName	"Return a symbol identifying this configuration"	self subclassResponsibility</body></methods><methods><class-id>DST.DSTConfiguration class</class-id> <category>instance creation</category><body package="DST_Core">new	^super new initialize</body></methods><methods><class-id>DST.DSTTransportConfiguration</class-id> <category>accessing</category><body package="DST_Core">daemonName	"Class name of the daemon that handles this transport protocol."	self subclassResponsibility</body><body package="DST_Core">defaultPort	"return the default port number"	self subclassResponsibility</body><body package="DST_Core">onByDefault	"Is this transport turned on automatically on system build?"	^self subclassResponsibility</body><body package="DST_Core">portNumber	^(self settingFor: #portNumberKind) == #dynamic		ifTrue: [0]		ifFalse: [self settingFor: #configuredPortNumber]</body><body package="DST_Core">transportName	^self class configurationName</body></methods><methods><class-id>DST.DSTTransportConfiguration</class-id> <category>configuring</category><body package="DST_Core">configureTransportFor: aDaemon 	"Configure the daemon based on my settings"	self subclassResponsibility</body></methods><methods><class-id>DST.DSTTransportConfiguration class</class-id> <category>accessing</category><body package="DST_Core">allTransports	| allTransports |	allTransports := IdentityDictionary new.	self		allSubclassesDo: 			[:cls | 			| trans |			trans := cls new.			allTransports at: trans transportName put: trans].	^allTransports</body></methods><methods><class-id>DST.ORBObject</class-id> <category>accessing</category><body package="DST_Core">accessControlList	"return the access control list"	accessControlList == nil ifTrue: [accessControlList := IdentityDictionary new].	^accessControlList</body></methods><methods><class-id>DST.ORBObject</class-id> <category>ORB-identifiers</category><body package="DST_Core">ACL	"return the ACL of the receiver"	^self class getInstanceACL</body></methods><methods><class-id>DST.ORBObject</class-id> <category>utilities</category><body package="DST_Core">eliminate	"this method will nil all of the instance variables of the receiver. Use 	it in extreme situations where dangling instances cannot be 	otherwise removed"	1 to: self class instSize do: [:i | self instVarAt: i put: nil]</body><body package="DST_Core">expunge	"this method will nil all of the instance variables of the receiver. Use 	it in REALLY EXTREME situations where dangling instances cannot be 	otherwise removed"	self eliminate.	self allOwners		do: 			[:obj | 			1 to: obj class instSize do: [:j | (obj instVarAt: j)					== self ifTrue: [obj instVarAt: j put: nil]].			1 to: obj basicSize do: [:j | (obj basicAt: j)					== self ifTrue: [obj basicAt: j put: nil]]]</body></methods><methods><class-id>DST.ORBObject</class-id> <category>repository</category><body package="DST_Core">allContentsInto: aSet	"add the receiver and all of its containment relatives to the set"	aSet add: self</body><body package="DST_Core">implementation	"Answer the local implementation object of the receiver"	^self getImplementation</body></methods><methods><class-id>DST.ORBObject</class-id> <category>persistence</category><body package="DST_Core">persistentState	"return my persistent state"	self subclassResponsibility</body></methods><methods><class-id>DST.ORBObject</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver. Subclasses should overload as appropriate"	| user cxt |	DSTModules security userSecurity ifTrue: [		[cxt := Processor activeProcess orbContext securityContext.		user := cxt notNil					ifTrue: [cxt login]					ifFalse: [DSTModules security principal login].		self setAccess: ORBObject accessSymbols user: user asSymbol]			on: Object errorSignal do: [:ex | ]]</body></methods><methods><class-id>DST.ORBObject</class-id> <category>distribution-required</category><body package="DST_Core">hostId	"return the hostId of the receiver"	^ORBDaemon hostId</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-access control</category><body package="DST_Core">accessControlList	"return the access control list"	accessControlList == nil ifTrue: [accessControlList := IdentityDictionary new].	^accessControlList</body><body package="DST_Core">accessSymbols	"return the defined access symbols"		^AccessSymbols ifNil: [AccessSymbols := #(admin read write create delete)]</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-identifiers</category><body package="DST_Core">ACL	"return the ACL of the receiver"	^classAbstractClassId ifNil: [classAbstractClassId := self abstractClassId]</body><body package="DST_Core">getInstanceACL	"return the abstractClassId for instances of the receiver"	^abstractClassId ifNil: [abstractClassId := self basicNew abstractClassId]</body><body package="DST_Core">getInstanceInterface	"return the InterfaceDef of the receiver's instances. Here we 	reimplement Object&gt;&gt;CORBAType so as to avoid a pathological 	interaction with DSTtypeNamed"	^ORBObject repository lookup: self basicNew CORBAName</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-objectIds</category><body package="DST_Core">adapterId	"This returns the unique identifier of the adapter currently running"	^ORBDaemon adapterId</body><body package="DST_Core">boaId	"Return my BOA ID"	^BOAid</body><body package="DST_Core">newId	"create a new local uuid"	^self hostId isNil		ifTrue: [^ORBObject initializeError: 0]		ifFalse: [^NCSuuid newId]</body><body package="DST_Core">newId: timeVal 	"create a new local uuid, passing in the time"	^NCSuuid newId: timeVal</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-repository</category><body package="DST_Core">addExceptionToCache: anException exceptionName: anExceptionName 	"add the exception to the cache."	RepositoryCache at: anException repositoryId put: anException.	RepositoryCache at: anExceptionName asSymbol put: anException</body><body package="DST_Core">addInterfaceToCache: anInterface 	"add the interface to the cache.  Add the superiors if needed"	RepositoryCache at: anInterface repositoryId put: anInterface.	RepositoryCache at: anInterface idlName asSymbol put: anInterface.	anInterface superiors:  (anInterface superiors collect: [:superior | RepositoryCache at: superior repositoryId ifAbsent: [self addInterfaceToCache: superior]]).	^anInterface</body><body package="DST_Core">addMetaObjectToCache: aMetaObject identity: anId 	"add the meta object to the cache"	| mo |	(aMetaObject isDSTMetaObject and: [aMetaObject isDSTinterface])		ifTrue: [^self addInterfaceToCache: aMetaObject].	((aMetaObject isMemberOf: ByteArray)		and: [aMetaObject isEmpty not])		ifTrue: 			[mo := DSTMetaObject unMarshallTypeCode: Dictionary new from: (DSTTypeCodeStream with: aMetaObject) reset.			RepositoryCache at: anId put: mo.			^mo].	(aMetaObject isDSTMetaObject and: [aMetaObject isDSTexception])		ifTrue: 			[RepositoryCache at: anId put: aMetaObject.			^aMetaObject].	^nil</body><body package="DST_Core">bossOutSharedRepositoryModule	"ORBObject bossOutSharedRepositoryModule"	| mo bos sups subs |	mo := self localRepository metaObjectOf: #'::SharedIR'.	mo isNil		ifTrue: [self intfReposError: 0]		ifFalse: 			[sups := IdentityDictionary new.			subs := IdentityDictionary new.			mo definedIn: nil.			mo interfaces				do: 					[:if | 					sups at: if put: if superiors.					subs at: if put: if subordinates.					if resetInheritance].			bos := BinaryObjectStorage onNew: (Filename named: 'SharedRM.bos') writeStream.			bos nextPut: mo.			bos close.			mo interfaces				do: 					[:if | 					if setInheritance.					if superiors: (sups at: if).					if subordinates: (subs at: if)].			mo definedIn: self localRepository.			^SharedRepositoryModule]</body><body package="DST_Core">cacheInterface: anId 	"return the interface object associated with the id"	| if |	self remoteRepository isNil		ifTrue: 			[if := self localRepository metaObjectOf: anId.			if notNil ifTrue: [RepositoryCache at: anId put: if]]		ifFalse: 			[if := self sharedRepositoryModule searchScopeFor: anId.			if isNil				ifTrue: [ORBDaemon running						ifTrue: 							[if := self remoteRepository getCachedInterface: anId.							self addInterfaceToCache: if]]				ifFalse: [RepositoryCache at: anId put: if]].	^if</body><body package="DST_Core">cacheMetaObject: anId 	"return the meta object associated with the id"	| mo | 	self remoteRepository isNil		ifTrue: 			[mo := self localRepository metaObjectOf: anId.			mo notNil ifTrue: [RepositoryCache at: anId put: mo]]		ifFalse: 			[mo := self searchSharedRepositoryModule: anId.			mo isNil				ifTrue: [ORBDaemon running						ifTrue: 							[mo := RemoteRepository getCachedMetaObject: anId.							^self addMetaObjectToCache: mo identity: anId]]				ifFalse: [RepositoryCache at: anId put: mo]].	^mo</body><body package="DST_Core">checkInterfaceIdentity: interfaces 	"Check that all interfaces have unique identities"	Transcript crtab; show: 'Checking interface identities...'.	interfaces do: 		[:if | 		| mo |		(mo := RepositoryCache at: if repositoryId					ifAbsent: 						[Dialog notify: 'Identity of interface ' , if idlName , ' is not registered'.						if]) == if ifFalse: [Dialog notify: 'Identity of interface ' , if idlName , ' conflicts with the identity of ' , mo idlName]]</body><body package="DST_Core">checkInterfaceMethods	"check that all classes which have interfaces are complete"	| abscl if epv obj root |	Transcript crtab; show: 'Checking interface implementations...'.	root := Object new CORBAName.	abscl := (Object allSubclasses select: [:cl | (cl includesSelector: #CORBAName)					and: [(cl inheritsFrom: DSTObjRef) not and: [cl basicNew CORBAName ~= root]]])				asSortedCollection: [:a :b | a name &lt; b name].	abscl remove: DSTObjRef ifAbsent: [].	abscl		do: 			[:cl | 			self remoteRepository isNil				ifTrue: 					[if := cl basicNew CORBAInterface.					if isNil						ifTrue: [Transcript crtab; tab; show: '***interface for "' , cl name , '"  is undefined' ]						ifFalse: [(if isMemberOf: DSTinterface)								ifTrue: 									[epv := if fullEntryPointVector.									obj := cl basicNew.									epv do: [:sel | (obj respondsTo: sel)											ifFalse: [Transcript crtab; tab; show: 'WARNING: method for "' , sel , '" for IF "' , if idlName , '" is not implemented in "' , cl name , '"']]]]]].</body><body package="DST_Core">checkRepository	"Verify the accuracy of the DST repository"	"self checkRepository"	self remoteRepository isNil ifTrue: [self checkRepository: ORBObject repositoryClass]</body><body package="DST_Core">checkRepository: repName 	"Verify the accuracy of the named repository"	"self checkRepository"	| ifs ifaces symbols selectors metas nas dif metaConts ops epv |	Transcript cr; cr; show: 'Checking Interface Repository...'.	self checkInterfaceMethods.	ObjectMemory compactingGC.	metas := Set new.	self localRepository allMetaObjectsInto: metas.	metaConts := metas select: [:mo | (mo isKindOf: DSTinterface)					| (mo isKindOf: DSTmodule)].	ifaces := metaConts select: [:if | if isKindOf: DSTinterface].	self checkInterfaceIdentity: ifaces.	symbols := metaConts collect: [:if | if printName].	selectors := repName selectors.	Transcript crtab; show: 'Checking for completeness...'.	ifs := selectors reject: [:sy | symbols includes: sy].	ifs isEmpty ifFalse: [Dialog notify: 'Repository is missing some of the defined modules or interfaces'].	Transcript crtab; show: 'Checking definition consistency...'.	ifs := metas reject: [:mo | metas includes: mo definingMetaObject].	ifs size &lt;= 1 ifFalse: [Dialog notify: 'Repository contains ' , ifs size printString , ' undeclared interfaces'].	Transcript crtab; show: 'Checking inheritance graph consistency...'.	ifs := ifaces reject: [:if | (if superiors reject: [:sup | (ifaces includes: sup)						&amp; (sup subordinates includes: if)]) isEmpty and: [(if subordinates reject: [:sub | (ifaces includes: sub)							&amp; (sub superiors includes: if)]) isEmpty and: [if superiors size = if sunames size]]].	ifs isEmpty ifFalse: [Dialog notify: 'Repository inheritance graph is inconsistent'].	Transcript crtab; show: 'Checking for identifier completeness...'.	nas := metas select: [:mo | mo class == DSTtypeNamed].	nas do: [:mo | mo equivalentType].	Transcript crtab; show: 'Checking for identifier ambiguity...'.	ifs := nas select: [:mo | (dif := mo definingMetaContainer) notNil and: [(mo definingMetaObject isKindOf: DSTMetaContainer)						and: [(dif								lookupName: mo printName								levels: 1								limit: #dk_all								excludeInherited: false) size &gt; 1]]].	ifs isEmpty ifFalse: [Dialog notify: 'Repository contains ambiguous identifiers'].	Transcript crtab; show: 'Checking for unresolved identifiers...'.	ifs := nas select: [:na | na attemptResolution isNil].	ifs isEmpty ifFalse: [Dialog notify: 'Repository contains unresolvable identifiers'].	Transcript crtab; show: 'Checking for inherited interface name ambiguity...'.	ifaces do: [:if | if checkReferencesUniqueness].	Transcript crtab; show: 'Checking for name resolution ambiguity...'.	nas do: [:na | na checkReferencesUniqueness].	Transcript crtab; show: 'Checking for operation ambiguity...'.	ops := metas select: [:mo | mo class == DSToperation].	ifs := ops select: [:mo | (dif := mo definingMetaContainer) notNil and: [(mo definingMetaObject isKindOf: DSTMetaContainer)						and: [(dif								lookupName: mo printName								levels: 1								limit: #dk_all 								excludeInherited: false) size &gt; 1]]].	ifs isEmpty ifFalse: [			"Hacking away here! The main problem is that we treat PIDL as IDL,			and that the CORBA spec for some reason allow overloading of			PIDL operations while not on IDL operation. The is_a operation is			overloaded withing CORBA itself therefore the exception"			| msg ignore |			ignore := false.			msg := 'Repository contains ambiguous operations:\'.			ifs do:[:mo | 				(mo idlName = '::CORBA::InterfaceDef::is_a')					ifTrue: [ignore := true]					ifFalse: [msg := msg, mo idlName, '\']].			(ignore and:[ ifs size = 1])				ifFalse:[Dialog notify: msg  withCRs]].	Transcript crtab; show: 'Checking for operation selector ambiguity...'.	ifs := ifaces select: [:mo | (epv := mo fullEntryPointVector) size ~= epv asBag size].	ifs isEmpty ifFalse: [Dialog notify: 'Repository contains ambiguous operation selectors'].	Transcript crtab; show: 'Checking for exception name ambiguity...'.	ops do: [:op | op checkReferencesUniqueness].	Transcript crtab; show: 'DONE...'; cr</body><body package="DST_Core">localRepository	"return the interfaces in the repository"	LocalRepository isNil ifTrue: [self initializeRepository; checkRepository].	^LocalRepository</body><body package="DST_Core">lookupConstantOrSignal: anId 	"return the constant or signal associated with the id"	| conOrEx | 	self remoteRepository isNil		ifTrue: 			[conOrEx := self localRepository metaObjectOf: anId.			(conOrEx isMemberOf: DSTconstant)				ifTrue: [^conOrEx value].			(conOrEx isMemberOf: DSTtypeEnumeration)				ifTrue: [^conOrEx values].			(conOrEx isDSTMetaObject and: [conOrEx isDSTexception])				ifTrue: [^conOrEx errorSignal].			(conOrEx isKindOf: DSTEnumerator)				ifTrue: [^conOrEx]]		ifFalse: 			[conOrEx := RepositoryCache at: anId ifAbsent: [nil].			conOrEx isNil				ifTrue: 					[conOrEx := self getConstantOrException: anId.					(conOrEx isDSTMetaObject and: [conOrEx isDSTexception])						ifTrue: 							[RepositoryCache at: conOrEx idlName asSymbol put: conOrEx.							RepositoryCache at: conOrEx repositoryId put: conOrEx.							^conOrEx errorSignal]						ifFalse: [^conOrEx]]				ifFalse: [(conOrEx isDSTMetaObject and: [conOrEx isDSTexception])						ifTrue: [^conOrEx errorSignal]						ifFalse: [^conOrEx]]].	^nil</body><body package="DST_Core">lookupInterfaceId: anId	"return the interface object associated with the id"	| if |	anId == NCSuuid nilId ifTrue: [^nil].	if := RepositoryCache at: anId ifAbsent: [self cacheInterface: anId].	(if isDSTMetaObject and: [if isDSTinterface])		ifTrue: [^if]		ifFalse: [self  intfReposError: 0]</body><body package="DST_Core">lookupMetaId: anId 	"Return the repository meta object associated with the id"	| mo |	mo := RepositoryCache at: anId ifAbsent: [self cacheMetaObject: anId].	^mo isNil		ifTrue: [nil]		ifFalse: [mo class == DSTtypeAlias				ifTrue: [mo]				ifFalse: [mo equivalentType]]</body><body package="DST_Core">publishRepository: syArray onFile: fname 	"Utility - publish selected interfaces in the repository on the file, without 	any pragmas or implementation specifics"	| file mo  rmo map |	file := fname asFilename writeStream.	map := Dictionary new.	syArray		do: 			[:sy | 			mo := self repository metaObjectOf: sy.			mo isNil				ifTrue: [Transcript show: '** ' , sy , ' not found in Repository'; cr]				ifFalse: 					[mo printName asUppercase.					rmo := mo referencedMetaContainers.					rmo := rmo - (Set with: (self repository metaObjectOf: #Object)).					rmo do: [:m | m printName = #CORBA ifFalse: [file nextPutAll: '#include &lt;' , (map at: m printName ifAbsent: [m printName]) , '.idl&gt;'; cr]].					mo						publishDefinitionOn: file						indent: 0						style: #default.					file cr]].	file close</body><body package="DST_Core">reInitializeSharedRepositoryModule	"self reInitializeSharedRepositoryModule"	| mo sups subs "bos ws" |	mo := self localRepository metaObjectOf: #'::SharedIR'.	mo isNil		ifTrue: [self intfReposError: 0]		ifFalse: 			[sups := IdentityDictionary new.			subs := IdentityDictionary new.			mo definedIn: nil.			mo interfaces				do: 					[:if | 					sups at: if put: if superiors.					subs at: if put: if subordinates.					if resetInheritance].			"ws := WriteStream on: (ByteArray new: 100).			bos := BinaryObjectStorage onNew: ws.			bos nextPut: mo.			bos close."			mo interfaces				do: 					[:if | 					if setInheritance.					if superiors: (sups at: if).					if subordinates: (subs at: if)].			mo definedIn: self localRepository.			"bos := BinaryObjectStorage onOld: (ReadStream on: ws contents).			SharedRepositoryModule := bos next.			bos close"			SharedRepositoryModule := mo]</body><body package="DST_Core">remoteRepository	^RemoteRepository</body><body package="DST_Core">remoteRepository: anObjRef 	"create a remote object reference for remote shared repository 	operations"	| debug cxt |	(anObjRef isNil or: [anObjRef isLocal])		ifTrue: 			[RemoteRepository := nil.			self addInitialService: self localRepository name: #InterfaceRepository.]		ifFalse: 			[RemoteRepository := anObjRef.			RemoteRepository := anObjRef narrowTo: (ORBObject lookupMetaId: #'::SharedIR::SharedInterfaceRepository') repositoryId.			self initializeRepository.						["get the service context meta objects used for encapsulation"			debug := ORBDaemon debugging.			ORBDaemon debugging: false.			cxt := Processor activeProcess orbContext.			Processor activeProcess orbContext: ORBContext new.			ORBObject lookupInterfaceId: #'::CORBA::Object'.			MethodContext new CORBAInterface.			ORBObject lookupMetaId: #'::TSInteroperation::TransIdentity'.			ORBObject lookupMetaId: #'::UIContexts::DebugContextObject']				ensure: 					[Processor activeProcess orbContext: cxt.					ORBDaemon debugging: debug].			self addInitialService: (anObjRef resolveInitialReferences: #InterfaceRepository) name: #InterfaceRepository]</body><body package="DST_Core">repository	"return a reference to the repository"	"If repository is set to local and it has not been initialize,	initialize it first."	((Services keys includes: #InterfaceRepository) not		and: [DSTInterfaceRepositoryConfiguration current isSetToLocal]) 			ifTrue: [self initializeRepository].	((Services keys includes: #FactoryFinder) not		and: [DSTInterfaceRepositoryConfiguration current isSetToLocal]) 			ifTrue: [self initializeFactories].	^self resolveInitialReferences: #InterfaceRepository</body><body package="DST_Core">repositoryClass	"return the class to be used for the interface repository definitions"	# {DSTRepository} ifDefinedDo: [:rc | ^rc].	UserNotification raiseRequestErrorString: 'Local repository facility not in placed.\Use remote repository.' withCRs.	^nil</body><body package="DST_Core">resetRepository	"clear the Repository cache"	"WARNING: The ORB should be stopped before calling this method"	| presClass |	LocalRepository := nil.	self initializeInterfaceRepository.	self initializeRepositoryCache.	ORBConstantsDictionary rebuild.	Transcript crtab; show: 'Resetting application references...'.	ORBObject withAllSubclasses do: [:cl | cl initializeRepositoryInformation].	DSTObjRef withAllSubclasses do: [:cl | cl initializeRepositoryInformation].	(presClass := #{DSTPresenter} valueOrDo: [nil]) notNil		ifTrue: [presClass withAllSubclasses do: [:cl | cl initializeRepositoryInformation]]</body><body package="DST_Core">resetRepositoryCache	"reset the cache"	self remoteRepository notNil		ifTrue: 			[self initializeRepositoryCache.			ORBConstantsDictionary rebuild]</body><body package="DST_Core">searchSharedRepositoryModule: aSymbol 	"search the shared repository module for anId"	| str x head tail |	aSymbol class == RepositoryId		ifTrue: [^self sharedRepositoryModule symbols at: aSymbol ifAbsent: [nil]]		ifFalse: 			[str := aSymbol asString.			x := str findFirst: [:ch | ch = $:].			x isZero ifTrue: [^nil].			x = 1				ifTrue: 					[str := str copyFrom: 3 to: str size.					x := str findFirst: [:ch | ch = $:]].			head := str copyFrom: 1 to: x - 1.			head asSymbol == self sharedRepositoryModule name				ifTrue: 					[tail := str copyFrom: x + 2 to: str size.					^self sharedRepositoryModule searchScopeFor: tail asSymbol]				ifFalse: [^nil]]</body><body package="DST_Core">sharedRepositoryModule	"return the interfaces in the repository"	| bos | 	SharedRepositoryModule isNil		ifTrue: 			[bos := BinaryObjectStorage onOld: (Filename named: 'SharedRM.bos') readStream.			SharedRepositoryModule := bos next.			bos close].	^SharedRepositoryModule</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>utilities</category><body package="DST_Core">addInitialService: anObject name: aString 	"add anObject to the list fo initial services available to remote 	systems"	Services at: aString asSymbol put: anObject</body><body package="DST_Core">referenceFromFile: aString 	"This method reads an object reference from a file"	| strm col |	strm := aString asFilename readStream.	[col := strm upToEnd]		ensure: [strm close].	^self stringToObject: col trim</body><body package="DST_Core">referenceToFile: aString object: anObject 	"This method writes out the an object to an external file denoted by aString"	| strm |	strm := aString asFilename writeStream.		[strm nextPutAll: (self objectToString: anObject).	strm flush]		ensure: [strm close]</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-exceptions</category><body package="DST_Core">badContextError: minor 	"error processing context object"	^(self standardExceptions at: #BAD_CONTEXT) errorSignal 		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' error processing context object'</body><body package="DST_Core">badInvOrderError: minor 	"routine invocations out of order"	^(self standardExceptions at: #BAD_INV_ORDER) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' routine invocations out of order'</body><body package="DST_Core">badOperationError: minor 	"Invalid operation"	^(self standardExceptions at: #BAD_OPERATION) errorSignal		raiseWith: (Dictionary with: #minor -&gt; (self minorCodeOf: minor) with: #completed -&gt; #COMPLETED_NO)		errorString: ' invalid operation'</body><body package="DST_Core">badParamError: minor 	"an invalid parameter was passed"	^(self standardExceptions at: #BAD_PARAM) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_MAYBE)		errorString: ' an invalid parameter was passed'</body><body package="DST_Core">badTypecodeError: minor 	"bad typecode"	^(self standardExceptions at: #BAD_TYPECODE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' bad typecode'</body><body package="DST_Core">commFailureError: minor 	"communication failure"	^(self standardExceptions at: #COMM_FAILURE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' communication failure'</body><body package="DST_Core">dataConversionError: minor 	"Data conversion error"	^(self standardExceptions at: #DATA_CONVERSION) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' data conversion error'</body><body package="DST_Core">freeMemError: minor 	"cannot free memory"	^(self standardExceptions at: #FREE_MEM) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' cannot free memory'</body><body package="DST_Core">impLimitError: minor 	"violated implementation limit"	^(self standardExceptions at: #IMP_LIMIT) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_MAYBE)		errorString: ' violated implementation limit'</body><body package="DST_Core">initializeError: minor 	"ORB initialization failure"	^(self standardExceptions at: #INITIALIZE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' ORB initialization failure'</body><body package="DST_Core">internalError: minor 	"ORB internal error"	^(self standardExceptions at: #INTERNAL) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' ORB internal error'</body><body package="DST_Core">intfReposError: minor 	"Error accessing interface repository"	^(self standardExceptions at: #INTF_REPOS) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' error accessing interface repository'</body><body package="DST_Core">invFlagError: minor 	"Invalid flag was specified"	^(self standardExceptions at: #INV_FLAG) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' invalid flag was specified'</body><body package="DST_Core">invIdentError: minor 	"Invalid identifier syntax"	^(self standardExceptions at: #INV_IDENT) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' invalid identifier syntax'</body><body package="DST_Core">invObjrefError: minor 	"invalid object reference"	^(self standardExceptions at: #INV_OBJREF) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' invalid object reference'</body><body package="DST_Core">marshallError: minor 	"error marshalling param/result"	^(self standardExceptions at: #MARSHAL) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' error marshalling param/result'</body><body package="DST_Core">minorCodeOf: minor 	"Return minor if it is an integer, otherwise search CORBAConstants with minor 	appended to the scope name of the Object interface. In the later case, 	minor must be a symbol or a string"	"ORBObject minorCodeOf: 1"	"ORBObject minorCodeOf: #M_IF_VERSION_MISMATCH"	"ORBObject minorCodeOf: 'M_PING_LIMIT_EXCEEDED'"	^minor isInteger		ifTrue: [minor]		ifFalse: [CORBAConstants at: minor asSymbol]</body><body package="DST_Core">noImplementError: minor 	"operation implementation unavailable"	^(self standardExceptions at: #NO_IMPLEMENT) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' operation implementation unavailable'</body><body package="DST_Core">noMemoryError: minor 	"dynamic memory allocation failure"	^(self standardExceptions at: #NO_MEMORY) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_MAYBE)		errorString: ' dynamic memory allocation failure'</body><body package="DST_Core">noPermissionError: minor 	"no permission for attempted op"	^(self standardExceptions at: #NO_PERMISSION) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' no permission for attempted op'</body><body package="DST_Core">noResourcesError: minor 	"Insufficient resources for request"	^(self standardExceptions at: #NO_RESOURCES) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' insufficient resources for request'</body><body package="DST_Core">noResponseError: minor 	"response to request not yet available"	^(self standardExceptions at: #NO_RESPONSE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' response to request not yet available'</body><body package="DST_Core">objAdapterError: minor 	"Failure detected by object adaptor"	^(self standardExceptions at: #OBJ_ADAPTER) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' failure detected by object adaptor'</body><body package="DST_Core">persistStoreError: minor 	"persistent storage failure"	^(self standardExceptions at: #PERSIST_STORE) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' persistent storage failure'</body><body package="DST_Core">standardExceptions	"return standard exceptions"	^CORBAConstants standardExceptions</body><body package="DST_Core">transientError: minor 	"transient failure - reissue request"	^(self standardExceptions at: #TRANSIENT) errorSignal		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_NO)		errorString: ' transient failure - reissue request'</body><body package="DST_Core">unknownError: minor 	"an unknown error occurred"	^(self standardExceptions at: #UNKNOWN) errorSignal 		raiseWith: (Dictionary with: #minor -&gt; minor with: #completed -&gt; #COMPLETED_MAYBE)		errorString: ' unknown error'</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-error handling</category><body package="DST_Core">badContextSignal	"Answer the signal used for error processing context object errors"	^(self standardExceptions at: #'BAD_CONTEXT') errorSignal</body><body package="DST_Core">badInvOrderSignal	"Answer the Signal for routine invocations out of order"	^(self standardExceptions at: #'BAD_INV_ORDER') errorSignal</body><body package="DST_Core">badOperationSignal	"Answer the Signal for invalid operation errors"	^(self standardExceptions at: #'BAD_OPERATION') errorSignal</body><body package="DST_Core">badParamSignal	"Answer the signal used for invalid parameters"	^(self standardExceptions at: #'BAD_PARAM') errorSignal</body><body package="DST_Core">badTypecodeSignal	"Answer the signal for bad typecode errors"	^(self standardExceptions at: #'BAD_TYPECODE') errorSignal</body><body package="DST_Core">commFailureSignal	"Answer the signal used for communication failures"	^(self standardExceptions at: #'COMM_FAILURE') errorSignal</body><body package="DST_Core">dataConversionSignal	"Answer the signal used for Data conversion errors"	^(self standardExceptions at: #'DATA_CONVERSION') errorSignal</body><body package="DST_Core">freeMemSignal	"Answer the signal used for cannot free memory errors"	^(self standardExceptions at: #'FREE_MEM') errorSignal</body><body package="DST_Core">impLimitSignal	"Answer the signal used for errors for violating implementation limit"	^(self standardExceptions at: #'IMP_LIMIT') errorSignal</body><body package="DST_Core">initializeSignal	"Answer the signal usef for an ORB initialization failure"	^(self standardExceptions at: #INITIALIZE) errorSignal</body><body package="DST_Core">internalSignal	"Answer the signal used for ORB internal errors"	^(self standardExceptions at: #INTERNAL) errorSignal</body><body package="DST_Core">intfReposSignal	"Answer the signal used for accessing interface repository errors"	^(self standardExceptions at: #'INTF_REPOS') errorSignal</body><body package="DST_Core">invFlagSignal	"Answer the signal used for handling Invalid flags"	^(self standardExceptions at: #'INV_FLAG') errorSignal</body><body package="DST_Core">invIdentSignal	"Answer the signal used for Invalid identifier syntax errors"	^(self standardExceptions at: #'INV_IDENT') errorSignal</body><body package="DST_Core">invObjrefSignal	"Answer the signal used for invalid object references"	^(self standardExceptions at: #'INV_OBJREF') errorSignal</body><body package="DST_Core">marshallSignal	"Answer the signal used for marshalling param/result errors"	^(self standardExceptions at: #MARSHAL) errorSignal</body><body package="DST_Core">noImplementSignal	"Answer the signal used for operation implementation unavailable errors"	^(self standardExceptions at: #'NO_IMPLEMENT') errorSignal</body><body package="DST_Core">noMemorySignal	"Answer the signal used for dynamic memory allocation failures"	^(self standardExceptions at: #'NO_MEMORY') errorSignal</body><body package="DST_Core">noPermissionSignal	"Answer the signal used for no permission for attempted op errors"	^(self standardExceptions at: #'NO_PERMISSION') errorSignal</body><body package="DST_Core">noResourcesSignal	"Answer the signal used for Insufficient resources for request"	^(self standardExceptions at: #'NO_RESOURCES') errorSignal</body><body package="DST_Core">noResponseSignal	"Answer the signal used for errors when a response to the request is not 	yet available"	^(self standardExceptions at: #'NO_RESPONSE') errorSignal</body><body package="DST_Core">objAdapterSignal	"Answer the signal used for failures detected by object adaptor"	^(self standardExceptions at: #'OBJ_ADAPTER') errorSignal</body><body package="DST_Core">persistStoreSignal	"Answer the signal used for persistent storage failures"	^(self standardExceptions at: #'PERSIST_STORE') errorSignal</body><body package="DST_Core">transientSignal	"Answer the signal used for transient failures"	^(self standardExceptions at: #TRANSIENT) errorSignal</body><body package="DST_Core">unknownSignal	"Answer the signal used for unknown exception errors"	^(self standardExceptions at: #UNKNOWN) errorSignal</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>Repository</category><body package="DST_Core">containingRepository	"Forward to repository object"	^self repository containingRepository</body><body package="DST_Core">contents: limitType excludeInherited: bool 	"return the list of objects contained by the receiver. If limitType is set 	to #dk_all, then all contained meta objects are returned. If the 	limitType is the name of an interface type, then only instances of 	that type will be returned."	^self repository contents: limitType excludeInherited: bool</body><body package="DST_Core">createAlias: id name: aName version: aVersion originalType: aType 	"Forward to repository object"	^self repository		createAlias: id		name: aName		version: aVersion		originalType: aType</body><body package="DST_Core">createArray: length elementType: type 	"Forward to repository object"	^self repository createArray: length elementType: type</body><body package="DST_Core">createConstant: id name: aName version: aVersion type: aType value: aValue 	"Forward to repository object"	^self repository		createConstant: id		name: aName		version: aVersion		type: aType		value: aValue</body><body package="DST_Core">createEnum: id name: aName version: aVersion members: memList 	"Forward to repository object"	^self repository		createEnum: id		name: aName		version: aVersion		members: memList</body><body package="DST_Core">createException: id name: aName version: aVersion members: aMemberCollection 	"Redispatch to the repository object."	^self repository		createException: id		name: aName		version: aVersion		members: aMemberCollection</body><body package="DST_Core">createFixed: arg1 scale: arg2	"Forward to repository object"	^self repository		createFixed: arg1		scale: arg2</body><body package="DST_Core">createInterface: id name: aName version: aVersion baseInterfaces: interfaces 	"Forward to repository object"	^self repository		createInterface: id		name: aName		version: aVersion		baseInterfaces: interfaces</body><body package="DST_Core">createModule: id name: aName version: aVersion	"Forward to repository object"	^self repository createModule: id name: aName version: aVersion</body><body package="DST_Core">createSequence: bound elementType: type 	"Forward to repository object"	^self repository createSequence: bound elementType: type</body><body package="DST_Core">createString: bound 	"Forward to repository object"	^self repository createString: bound</body><body package="DST_Core">createStruct: id name: aName version: aVersion members: memList 	"Forward to repository object"	^self repository		createStruct: id		name: aName		version: aVersion		members: memList</body><body package="DST_Core">createUnion: id name: aName version: aVersion discriminatorType: aType members: memList 	"Forward to repository object"	^self repository		createUnion: id		name: aName		version: aVersion		discriminatorType: aType		members: memList</body><body package="DST_Core">createWideString: bound 	"Forward to repository object"	^self repository createWideString: bound</body><body package="DST_Core">defKind	"Forward to repository object"	^self repository defKind</body><body package="DST_Core">definedIn	"return the receivers definedIn"	^self repository definedIn</body><body package="DST_Core">describe: aSymbol excludeInherited: bool max: anInt 	"return the description of each of the contents of the receiver"	^self repository describe: aSymbol excludeInherited: bool max: anInt</body><body package="DST_Core">getPrimitive: pk 	"Forward to repository object"	^self repository getPrimitive: pk</body><body package="DST_Core">id	"return the Repository's repositoryId"	^self repository id</body><body package="DST_Core">id: newId 	"Forward to repository object"	^self repository id: newId</body><body package="DST_Core">lookup: aName	"Forward to repository object"	^self repository lookup: aName</body><body package="DST_Core">lookupId: aRepositoryId 	"return the repository meta object associated with the RepositoryId"	^InterfaceRepository at: aRepositoryId ifAbsent: [nil]</body><body package="DST_Core">lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool 	"search for the contained object with the given symbol in the 	contents of the receiver. Levels gives the number of contained 	containers to search as well. If limitType is set to #all, then all 	contained meta objects are returned. If the limitType is the name of 	an interface type, then only instances of that type will be returned."	^self repository lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool</body><body package="DST_Core">move: newContainer name: newName version: newVersion 	"Forward to repository object"	^self repository		move: newContainer		name: newName		version: newVersion</body><body package="DST_Core">name: newName	"Forward to repository object"	^self repository name: newName</body><body package="DST_Core">version	"Forward to repository object"	^self repository version</body><body package="DST_Core">version: newVersion 	"Forward to repository object"	^self repository version: newVersion</body><body package="DST_Core">within	"return the receivers within"	^self repository within</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-distribution</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::DistributedSmalltalk::ORBObject_class'</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB</category><body package="DST_Core">createNVList: size	"create a NVList of the indicated size"	^ORBNVList new initialize</body><body package="DST_Core">createOperationNVList: operationDef	"create a NVList for the indicated operation"	^ORBNVList new initialize</body><body package="DST_Core">getDefaultContext	"return the default context"	^''</body><body package="DST_Core">listInitialServices	"answer the list of services"	^Services keys</body><body package="DST_Core">objectToString: anObj 	"return the string which refers to the object as per the CORBA2.0 	Spec"	| ws ior ba |	ORBDaemon running ifFalse:[Dialog warn: 'ORB is not running! You may get a stale object reference.'.].	ba := ByteArray new: 100.	ws := (CDRStream on: ba) reset.	ws nextPutBoolean: ws byteOrder.	ws nextPutObjectReference: anObj.	ior := ws contents.	ws := (WriteStream on: (ByteString new: 200)) reset.	ws nextPutAll: 'IOR:'.	ior do: [:ch | ws nextPutAll: ch asHex].	^ws contents asByteString</body><body package="DST_Core">resolveInitialReferences: aString 	"answer the service"	^Services at: aString asSymbol ifAbsent: [(CORBAConstants at: #'::CORBA::ORB::InvalidName') raise]</body><body package="DST_Core">stringToObject: aString 	"return the object which is denoted by the string as per the 	CORBA2.0 Spec"	| prefix strm | 	prefix := aString copyUpTo: $:.	prefix = 'IOR'		ifTrue: 			[strm := (CDRStream on: (ByteArray new: aString size)) reset.			prefix size + 2				to: aString size -1				by: 2				do: [:i | strm nextPut: (aString at: i) digitValue * 16 + (aString at: i + 1) digitValue].			strm reset.			strm byteOrder: strm nextBoolean.			^strm nextObjectReference: (DSTinterface new repositoryId: (RepositoryId fromString: 'IDL:CORBA/Object:1.0'))]		ifFalse: [self invObjrefError: 0]</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>accessing</category><body package="DST_Core">daemon	"return my class object of the running darmon"	^ORBDaemon</body><body package="DST_Core">hostId	"Return my hostId" 	^ORBDaemon hostId</body><body package="DST_Core">hostIdString	^IPSocketAddress bytesToName: self hostId</body><body package="DST_Core">hostName	"Return my hostname"	^ORBDaemon hostName</body><body package="DST_Core">installDir	"Return the product installation directory"	InstallDir isNil ifTrue: [InstallDir := Filename named: '.'].	^InstallDir</body><body package="DST_Core">installDir: aFilename 	"Set the product installation directory"	InstallDir := aFilename</body><body package="DST_Core">orbInterfacePriority	"return the process priority for interactive request processes. This should 	not be changed without lots of thought, as it affects processes which 	compete with the Smalltalk user interface"	^Processor userSchedulingPriority</body><body package="DST_Core">orbPriority	"return the process priority for the ORB and its related processes"	^Processor userInterruptPriority</body><body package="DST_Core">orbRequestPriority	"return the process priority for servicing remote request processes"	^Processor userSchedulingPriority</body><body package="DST_Core">running	"Is my daemon running"	^ORBDaemon running</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>encoding</category><body package="DST_Core">defaultEncoding	^#default.</body><body package="DST_Core">defaultWideCharEncoding	"UCS-2 Unicode 2 byte characters"	^#UCS_2.</body><body package="DST_Core">encoding	^self defaultEncoding.</body><body package="DST_Core">wideCharEncoding	^self defaultWideCharEncoding.</body><body package="DST_Core">wideCharLength	"Return the length of the induvidual characters in the agreed encoding,	default is UniCode 2 and those characters are two bytes wide."	^2</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ImplementationDef</category><body package="DST_Core">describe	"return an ImplementationDescription for an instance of the 	receiver"	| obj |	obj := self basicNew.	^Dictionary		with: #name -&gt; name		with: #id -&gt; obj ACL		with: #definedIn -&gt; obj CORBAType repositoryId</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>explain IOR</category><body package="DST_Core">explainIOR: aString 	"Answer a String whose characters are a description of the receiver."	"Example:"	"self explainIOR: 	'IOR:000000000000000d49444c3a677269643a312e300000000000000002000000010000008200000000000000050000000a0000001076ab145500bb000002c09f03450000000000000b000000107697641108ec000002c09f0345000000081040000000000c4453543a352e303a01f5c78208104004000000123139322e3135392e332e36393b3339393534000008104003000000123139322e3135392e332e36393b34313632320000000000000000002c000100000000000d3139322e3135392e332e36390000a2960000001076ab145500bb000002c09f0345000000'. "	| aStream |	aStream := WriteStream on: (String new: 1000).	self explainIOR: aString printOn: aStream.	^aStream contents</body><body package="DST_Core">explainIOR: aString printOn: aStream 	| prefix strm profiles |	aStream nextPutAll: ORBObject productName; space; nextPutAll: ORBObject versionID; cr.	aStream nextPutAll: ORBObject copyright; cr; cr.	prefix := aString copyUpTo: $:.	prefix = 'IOR' 		ifFalse: [aStream nextPutAll: 'The stringified object ref does not have the valid prefix "IOR"']		ifTrue: [			strm := (CDRStream on: (ByteArray new: aString size)) reset.			(prefix size + 2) to: (aString size) -1 by: 2				do: [:i | strm nextPut: (aString at: i) digitValue * 16 + (aString at: i + 1) digitValue].			strm reset.			strm byteOrder: strm nextBoolean.			aStream nextPutAll: ((strm byteOrder) ifTrue: ['Little Endian'] ifFalse: ['Big Endian']).			aStream nextPutAll: '. Repository ID: "', strm nextString; nextPutAll: '". ';cr.			profiles := CDRStream iorDef unMarshall: strm.			aStream nextPutAll: (profiles size) asString, ' profiles.'; cr.			profiles do: [:p |  self explainIORProfile: p printOn: aStream]]</body><body package="DST_Core">explainIORProfile: aProfile printOn: aStream 	| found profileData components host port objId binding |	aStream cr; nextPutAll: 'Profile tag = ';  nextPutAll: aProfile tag asString; space;                  nextPutAll: 'is '; nextPutAll: (aProfile profileData) size asString; nextPutAll: ' bytes.';cr.	profileData := (CDRStream with: aProfile profileData) reset.	profileData byteOrder: profileData nextBoolean.	found := false.	(aProfile tag == 0) ifTrue: [		found := true.		host := profileData nextString.		port := profileData nextUnsignedShort asString.		objId := IIOPObjectKey intern: (DSTObjRefRemote objectKeyDef unMarshall: profileData).		binding := IORTaggedComponent 							tag: IORTaggedComponent tagDSTIIOPBinding 							componentData: (host , ';' , port) asSymbol.		aStream nextPutAll: 'Profile tag = 0x0 (TAG_INTERNET_IOP)'; cr.		aStream nextPutAll: 'Adapter Id is ', (host size + 2) asString, ' bytes'; cr;				nextPutAll: 'Adapter Id: host = ', host, ' port = ', port; cr;				nextPutAll: 'Object ID is ', objId size asString, ' bytes'; cr;				nextPutAll: 'Object ID: '.		objId do: [:i |  aStream nextPut:			((i &gt;= 32 and: [i&lt;128])  ifTrue: [i asCharacter] ifFalse:[$.])].		aStream cr; nextPutAll: 'The following binding component is generated:'; cr.		self explainIORProfileComponent:  binding printOn: aStream].	(found not and: [aProfile tag == 1]) ifTrue: [		found := true.		components := DSTObjRefRemote multipleComponentDef unMarshall: profileData.		aStream nextPutAll: 'Profile tag = 0x1 (TAG_MULTIPLE_COMPONENTS). '; cr;				nextPutAll: (components size) asString, ' components.';cr.		components do: [:c | self explainIORProfileComponent: c printOn: aStream]].	"... verified on 06Jun99, status = current, on 03May99." 	(found not and: [aProfile tag &gt;= 135266304 and: [aProfile tag &lt; 135266312]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_HP_PROFILE)'; cr.		aStream nextPutAll: 'HP: 0x08100000-0x08100007 (^H^P**). Format not known!'; cr].	"... verified on 06Jun99, status = current, on 03Jun99."	(found not and: [aProfile tag &gt;= 1229081856 and: [aProfile tag &lt; 1229082112]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_IBM_PROFILE)'; cr.		aStream nextPutAll: 'IBM: 0x49424d00-0x49424dff (IBM*). Format not known!'; cr].	"... verified on 06Jun99, status = unknown on 03Jun99."	(found not and: [aProfile tag &gt;= 1230196480 and: [aProfile tag &lt; 1230196496]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_ISO_PROFILE)'; cr.		aStream nextPutAll: 'ISO: 0x49534f00-0x49534f0f (ISO*). Format not known!'; cr].	"... verified on 06Jun99, status = retired on 05May99."	(found not and: [aProfile tag = 1380927744]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_IMPERIAL_COLLEGE_PROFILE)'; cr.		aStream nextPutAll: 'Imperial College  0x524f4900(ROI*). Format not known!'; cr].	"... verified on 06Jun99, status = unknown on 03Jun99."	(found not and: [aProfile tag &gt;= 1314278400 and: [aProfile tag &lt; 1314278408]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_NOVELL_PROFILE)'; cr.		aStream nextPutAll: 'Novell:  0x4e564c00-0x4e564c07(NVL*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 16May99."	(found not and: [aProfile tag &gt;= 1314278400 and: [aProfile tag &lt; 1314278408]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_ORACLE_PROFILE)'; cr.		aStream nextPutAll: 'Oracle:  0x4f524100-0x4f52411f (ORA*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 08May99."	(found not and: [aProfile tag = 1330529024]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_SUN_PROFILE)'; cr.		aStream nextPutAll: 'Sun:  0x4f4e4300(ONC*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 08May99."	(found not and: [aProfile tag = 1313165056]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_SUN_PROFILE)'; cr.		aStream nextPutAll: 'Sun:  0x4e454f00 (NEO*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 03Jun99."	(found not and: [aProfile tag &gt;= 1329742336 and: [aProfile tag &lt; 1329742352]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_BEA_SYSTEMS_PROFILE)'; cr.		aStream nextPutAll: 'BEA Systems:  0x4f424200-0x4f42420f (OBB*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 19May99."	(found not and: [aProfile tag &gt;= 1229739264 and: [aProfile tag &lt; 1229739272]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_ILU_PROFILE)'; cr.		aStream nextPutAll: 'Xerox: 0x494c5500-0x494c5507 (ILU*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 08May99."	(found not and: [aProfile tag = 1313165056]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_EXPERSOFT_PROFILE)'; cr.		aStream nextPutAll: 'Expersoft:  0x50424F50 (PBOP*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 08May99."	(found not and: [aProfile tag &gt;= 1481659136 and: [aProfile tag &lt; 1481659151]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_EXPERSOFT_PROFILE)'; cr.		aStream nextPutAll: 'Expersoft:  0x58505300-0x5850530E (XPS*). Format not known!'; cr].	"... verified on 06Jun99, status = unknown on 03Jun99."	(found not and: [aProfile tag &gt;= 1229147136 and: [aProfile tag &lt; 1229147144]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_ICL_PROFILE)'; cr.		aStream nextPutAll: 'ICL:  0x49434c00-0x49434c07 (ICL*). Format not known!'; cr].	"... verified on 06Jun99, status = unknown on 10Apr99."	(found not and: [aProfile tag &gt;=  1230266112 and: [aProfile tag &lt;  1230266368]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_IT_PROFILE)'; cr.		aStream nextPutAll: 'Iona Technologies:  0x49545f00-0x49545fff (IT*). Format not known!'; cr].	"... verified on 06Jun99, status = unknown on 03Jun99."	(found not and: [aProfile tag = 1431193936]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_ROESCH_CONSULTING_PROFILE)'; cr.		aStream nextPutAll: 'Roesch Consulting:  0x554e4950 (UNIP*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 20May99."	(found not and: [aProfile tag =  1230194944]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_UNION_BANK_PROFILE)'; cr.		aStream nextPutAll: 'Union Bank of Switzerland:  0x49534900 (ISI*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 15May99."	(found not and: [aProfile tag &gt;=   1447645952 and: [aProfile tag &lt;   1447646208]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_INPRISE_PROFILE)'; cr.		aStream nextPutAll: 'Inprise:  0x56495300-0x564953ff (VIS*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 08May99."	(found not and: [aProfile tag &gt;= 1330205440 and: [aProfile tag &lt; 1330205696]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_OIS_PROFILE)'; cr.		aStream nextPutAll: 'Objective Interface Systems:  0x4f495300-0x4f4953ff (OIS*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 20Mar99."	(found not and: [aProfile tag &gt;= 1330856704 and: [aProfile tag &lt; 1330856712]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_OSC_PROFILE)'; cr.		aStream nextPutAll: 'ObjectScape:  0x4F534300-0x4F534307 (OSC*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 28April99."	(found not and: [aProfile tag &gt;= 1146311680 and: [aProfile tag &lt; 1146311808]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_OS_PROFILE)'; cr.		aStream nextPutAll: 'ObjectShare:  0x44535400-0x4453547F (OST*). Format not known!'; cr].	"... verified on 06Jun99, status = current on 01Jun99."	(found not and: [aProfile tag &gt;= 1751483136 and: [aProfile tag &lt; 1751483264]]) ifTrue: [		found := true.		aStream nextPutAll: 'Profile tag = 0x',  aProfile tag asHex, ' (TAG_DAS_PROFILE)'; cr.		aStream nextPutAll: 'PeerLogic:  0x68658300-0x6865837F DAS*). Format not known!'; cr].	(found not) ifTrue: [		aStream nextPutAll: 'Profile tag = '; nextPutAll: aProfile tag asHex; nextPutAll: ' (UNKNOWN)'; cr].	^self</body><body package="DST_Core">explainIORProfileComponent: aComponent printOn: aStream 	| oainfo bootId objId vpid domid foundComponent str host port |	foundComponent := false.	aStream nextPutAll: 'Component tag = ', (aComponent tag) asString, ' is ';			nextPutAll: aComponent componentData size asString, ' bytes'; cr.	(aComponent tag = aComponent class tagDSTObjectAdapter) 		ifTrue: [ oainfo := aComponent componentData.				bootId := 0. 				foundComponent := true.				"9 to: 12 do: [:i | bootId := (bootId bitShift:8) + (oainfo at: i)]."				aStream nextPutAll: 'Component tag = ', (aComponent tag) asString, ' Object Adapter: '; 						nextPutAll: (oainfo copyFrom: 1 to: 7) asString; 						nextPutAll: ' Boottime: ';						nextPutAll: bootId asString;cr].	(foundComponent not and: [aComponent tag = aComponent class tagObjectKey])		ifTrue:  [objId := aComponent componentData.				foundComponent := true.				[objId := NCSuuid on: objId] 					on: Object errorSignal 					do:  [:ex | objId := IIOPObjectKey intern: objId].				aStream nextPutAll: 'Component tag = ', (aComponent tag) asString, ' Object Id: ';						nextPutAll: objId asString; cr].	(foundComponent not and: [aComponent tag = aComponent class tagEndpointId])		ifTrue:  [vpid := aComponent componentData.				foundComponent := true.				[vpid := NCSuuid on: vpid] 					on: Object errorSignal 					do:  [:ex | vpid := IIOPObjectKey intern: vpid].				aStream nextPutAll: 'Component tag = ', (aComponent tag) asString, ' Adapter Id: '; 						nextPutAll: vpid asString; cr].	(foundComponent not and: [aComponent tag = aComponent class tagDSTDomain]) 		ifTrue: [domid := aComponent componentData.				foundComponent := true.				[domid := NCSuuid on: domid] 					on: Object errorSignal 					do:  [:ex | domid := IIOPObjectKey intern: domid].				aStream nextPutAll: 'Component tag = ', (aComponent tag) asString, ' Domain Id: '; 						nextPutAll: domid asString; cr].	(foundComponent not and: [aComponent tag = aComponent class tagDSTIIOPBinding])		ifTrue:  [str := aComponent componentData asString.				host :=  str copyUpTo: $;.				port := str copyFrom: host size + 2 to: str size.				foundComponent := true.				aStream nextPutAll: 'Component tag = ', (aComponent tag) asString, ' IIOP Binding, Host: '; 						nextPutAll: host, ' port: ', port; cr].	(foundComponent not and: [aComponent tag = aComponent class tagDSTNCSBinding])		ifTrue:  [str := aComponent componentData asString.				host :=  str copyUpTo: $;.				port := str copyFrom: host size + 2 to: str size.				foundComponent := true.				aStream nextPutAll: 'Component tag = ', (aComponent tag) asString, ' NCS Binding, Host: '; 						nextPutAll: host, ' port: ', port; cr].	(foundComponent not)		ifTrue: [aStream nextPutAll: 'Component tag = ', (aComponent tag) asString, ' Unknown component'; cr].</body><body package="DST_Core">explainObjectRef: aRef	| iorStr |	iorStr := ORBObject objectToString: aRef.	^self explainIOR: iorStr.</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-notifications</category><body package="DST_Core">flushRemoteServices	"flush refererences to remote services."	RemoteRepository notNil		ifTrue: 			[RemoteRepository := nil.			Services removeKey: #InterfaceRepository ifAbsent: []].	NamingService isRemote		ifTrue: 			[NamingService := nil.			Services removeKey: #NameService ifAbsent: []].	(Services at: #UserSecurityDatabase ifAbsent: [nil]) isRemote		ifTrue: [Services removeKey: #UserSecurityDatabase ifAbsent: []].</body><body package="DST_Core">notifyAboutToStopORB	"Notify dependents that the ORB is about to shut down."		self changed: #aboutToStopORB.</body><body package="DST_Core">notifyInitializeORB	self changed: #initializeORB</body><body package="DST_Core">notifyStartedORB	self changed: #startedORB</body><body package="DST_Core">notifyStoppedORB	self changed: #stoppedORB.	"nil out all the remote references to service because	they shouldn't exist once the orb is stopped.	They will be re-configured when the orb starts."	self flushRemoteServices</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>SharedRepository</category><body package="DST_Core">getCachedInterface: anId 	| int |	int := self lookupInterfaceId: anId.	^DSTcachedInterface new		name: int name		idlName: int idlName		repositoryId: int repositoryId		superiors: (int superiors collect: [:sup | self getCachedInterface: sup repositoryId])		epv: int entryPointVector</body><body package="DST_Core">getCachedMetaObject: anId 	| mo tcs |	mo := self lookupMetaId: anId.	mo isDSTMetaObject ifTrue: [mo isDSTinterface			ifTrue: [^DSTcachedInterface new					name: mo name					idlName: mo idlName					repositoryId: mo repositoryId					superiors: (mo superiors collect: [:sup | self getCachedInterface: sup repositoryId])					epv: mo entryPointVector]			ifFalse: [(mo isDSTtype or: [mo isDSTdeclaratorSimple])					ifTrue: 						[tcs := (DSTTypeCodeStream with: ( ByteArray new: 1024 ) ) reset.						mo marshallTypeCode: Dictionary new on: tcs.						^tcs contents]					ifFalse: [mo isDSTexception ifTrue: [^DSTcachedException								name: mo name								idlName: mo idlName								repositoryId: mo repositoryId								errorTypeCodeInfo: 									[tcs := (DSTTypeCodeStream with: #[]) reset.									mo errorType marshallTypeCode: Dictionary new on: tcs.									tcs contents] value]]]].	^#[]</body><body package="DST_Core">getCachedOperation: selector interface: anId 	| int op tci |	int := self lookupInterfaceId: anId.	op := int findOpBySelector: selector.	op := op operation.	(op isDSTMetaObject and: [op isDSTcachedOperation])		ifTrue: [^op]		ifFalse: [^DSTcachedOperation				name: op name				definedIn: op definedIn				localOp: op localOp				access: op accessRight				signature: (op signature collect: [:par | DSTcachedParameter							name: par name							direction: par direction asUppercase asSymbol							typeCodeInfo: 								[tci := (DSTTypeCodeStream with: ( ByteArray new: 1024 ) ) reset.								par type marshallTypeCode: Dictionary new on: tci.								tci contents] value])				mode: op mode				raises: (op exceptions collect: [:ex | ex idlName])				context: op context]</body><body package="DST_Core">getConstantOrException: aSymbol 	| mo tci |	self remoteRepository isNil		ifTrue: [mo := self localRepository metaObjectOf: aSymbol]		ifFalse: [ORBDaemon running				ifTrue: [^self remoteRepository getConstantOrException: aSymbol]				ifFalse: [^ORBObject intfReposError: 0]].	(mo isMemberOf: DSTconstant)		ifTrue: [^mo value].	mo class == DSTEnumerator ifTrue: [^mo].	(mo isDSTMetaObject and: [mo isDSTexception])		ifTrue: [^DSTcachedException				name: mo name				idlName: mo idlName				repositoryId: mo repositoryId				errorTypeCodeInfo: 					[tci := (DSTTypeCodeStream with: ( ByteArray new: 1024 ) ) reset.					mo errorType marshallTypeCode: Dictionary new on: tci.					tci contents] value].	^ORBObject intfReposError: 1</body><body package="DST_Core">getSharedRepositoryModule	^SharedRepositoryModule</body><body package="DST_Core">sharedRepositoryModule: aDSTModule	SharedRepositoryModule := aDSTModule</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-initialization</category><body package="DST_Core">init	^self</body><body package="DST_Core">initialize	"initialize all class variables"	Services := IdentityDictionary new.	self initializeInterfaceRepository.	self initializeRepositoryCache.</body><body package="DST_Core">initializeBOAid	"comment stating purpose of message"	self hostId isNil		ifTrue: [BOAid := NCSuuid nilId]		ifFalse: [BOAid := (NCSuuid newId: 1)						asIdOn: IPSocketAddress thisHost]</body><body package="DST_Core">initializeInterfaceRepository	InterfaceRepository := Dictionary new: 1200</body><body package="DST_Core">initializeORBAtHost: nodeName nodeId: aHostAddr 	"initialize the ORB and my host related class variables"	ORBDaemon shutDown; initialize: nodeName node: aHostAddr.	self initializeBOAid.	self initializeObjects.	DSTObjRef registerObject: ORBObject as: self boaId.	DSTObjRef registerObject: ORBDaemon as: ORBDaemon adapterId.	self notifyInitializeORB</body><body package="DST_Core">initializeObjects	"initialize all variables which can retain object references"	DSTObjRef withAllSubclasses do: [:cl | cl initialize].	ORBDaemon configurationManager log: '\Resetting ObjectIds for Persistent Objects...\' withCRs.	(DSTPersistentObject withAllSubclasses collect: [:cl | cl allInstances])		do: [:co | co do: [:obj | obj reInitialize]].	ORBContext allInstances do: [:cxt | cxt debuggerContext: nil].	NamingService := nil</body><body package="DST_Core">initializeRepository	"initialize the repository to the definitions in the ORBObject 	repositoryClass class"	"WARNING: The ORB should be stopped before calling this method" 	| rep metas |	Transcript cr; show: 'Initializing Interface Repository...'.	self resetRepository.	self remoteRepository isNil		ifTrue: 			[Transcript crtab; show: 'Resetting repository ids...'.			(DSTMetaObject withAllSubclasses collect: [:cl | cl allInstances])				do: [:co | co do: [:mo | mo reInitialize]].			LocalRepository := DSTmoduleRepository new initialize.			self addInitialService: LocalRepository name: #InterfaceRepository.			LocalRepository				ident: #'Smalltalk Repository'				def: #()				defs: OrderedCollection new.			ORBConstantsDictionary rebuild.			Transcript crtab; show: 'Resetting inheritance graph...'.			DSTinterface withAllSubclasses do: [:cl | cl allInstances do: [:if | if resetInheritance]].			DSTtypeNamed allInstances do: [:tn | tn resolveTo: nil].			rep := ORBObject repositoryClass new.			rep class selectors collect: [:ifn | LocalRepository addMetaObject: (rep perform: ifn)].			metas := Set new.			LocalRepository allMetaObjectsInto: metas.			Transcript crtab; show: 'Rebuilding inheritance graph...'.			metas do: [:mo | (mo isDSTMetaObject and: [mo isDSTinterface])					ifTrue: [mo setInheritance]].			Transcript crtab; show: 'Resolving references...'.			metas				do: 					[:mo | 					mo registerIdentity.					mo resolveTypeReference].			self reInitializeSharedRepositoryModule]</body><body package="DST_Core">initializeRepositoryCache	RepositoryCache := IdentityDictionary new: 1200</body><body package="DST_Core">initializeRepositoryInformation	"initialize the class variables which refer to the repository"	abstractClassId := classAbstractClassId := nil</body><body package="DST_Core">release	"release all class variables"	AccessSymbols := BOAid := Factories := InstallDir := InterfaceRepository := LocalRepository := NamingService := RemoteRepository := RepositoryCache := Services := SharedRepositoryModule := nil</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>instance creation</category><body package="DST_Core">new	"create a new instance and initialize it"	^self basicNew initialize</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>version ID</category><body package="DST_Core">buildDate	^'28 Feb 2002'</body><body package="DST_Core">copyright	^'Copyright © 1996-2002 Cincom Systems, Inc.' , '' , 'All Rights Reserved' , '' , 'This product contains copyrighted third-party software.' , '' , 'Copyright © 1993-1995 Hewlett-Packard Company.' ,'' , 'All Rights Reserved'</body><body package="DST_Core">fixedSizeVersionNumber	"This three-charcter fixed-size rendition of the version number is 	required by 'ORBDaemon&gt;&gt;resetObjectAdaptorComponent'."	^'7.0'</body><body package="DST_Core">productName	^'Cincom Distributed Smalltalk'</body><body package="DST_Core">versionID	^'ALPHA Release ', self versionNumber</body><body package="DST_Core">versionNumber	^'7.0'</body></methods><methods><class-id>DST.ORBObject class</class-id> <category>ORB-DII</category><body package="DST_Core">sendMultipleRequestOneWay: aRequestCollection flags: aFlags	^self error: 'Operation not implemented.'</body><body package="DST_Core">sendMultipleRequestOneway: aRequestCollection	"This method is part of the Smalltalk mapping, mentioned on page 4-9	of the CORBA 2.1 spec.  And, yes, it is spelled exactly as in the spec, 	and not as the spec should have it: 'sendMultipleRequestsOneway:"	self sendMultipleRequestOneWay: aRequestCollection flags: 0</body><body package="DST_Core">sendMultipleRequests: aRequestCollection	"This method is part of the Smalltalk mapping, mentioned on page 4-9	of the CORBA 2.1 spec."	self sendMultipleRequests: aRequestCollection flags: 0</body><body package="DST_Core">sendMultipleRequests: aRequestCollection flags: aFlags	self error: 'Operation not implemented.'</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>Contained</category><body package="DST_Core">containingRepository	"The containingRepository attribute identifies the repository that is 	eventually reached by recursively following the object's definedIn 	attribute."	^ORBObject repository widenTo: #'::CORBA::Repository'</body><body package="DST_Core">definedIn	"The definedIn attribute identifies the container within which the 	object is defined. Objects can be contained either because they are 	defined within the containing object or because they are inherited 	by the containing object. If an object is contained through 	inheritance, the definedIn attribute identifies the InterfaceDef from 	which the object is inherited."	^definedIn</body><body package="DST_Core">definedInString	"Return the repository id of the container object as a byte string."	^self definedIn repositoryId asString</body><body package="DST_Core">describe	"The describe operation returns information about the interface."	^Dictionary with: #kind -&gt; self defKind with: #value -&gt; self description</body><body package="DST_Core">id	"The id attribute identifies the object globally."	repositoryId isNil		ifTrue: 			[repositoryId := self generateRepositoryId.			InterfaceRepository at: repositoryId put: self.			InterfaceRepository at: self idlName asSymbol put: self].	^repositoryId</body><body package="DST_Core">id: aRepositoryId 	"Setting the id attribute changes the global identity of the interface. 	An error is returned if an object with the specified id attribute 	already exists within this object's repository."	self notYetImplemented</body><body package="DST_Core">move: newContainer name: newName version: newVersion 	"The move operation atomically removes the receiver from its current 	container, and adds it to the container specified by newContainer, 	which must: 	1) be in the same repository 	2) be capable of containing this object's type 	3) not already contain an object with this object's name (unless 	multiple versions are supported by the IR) 	The name attribute is changed to newName, and the version 	attribute is changed to newVersion. 	The definedIn and absoluteName attributes are updated to reflect 	the new container and name. If this object is also a container, the 	absoluteName attributes of any objects it contains are also updated."	self notYetImplemented</body><body package="DST_Core">name	"The name attribute identifies the object uniquely within the 	enclosing container object."	^name</body><body package="DST_Core">name: newName 	"Setting the name attribute changes the identity of this definition 	within its container. An error is returned if an object with the 	specified name attribute already exists within this object's 	container."	self notYetImplemented</body><body package="DST_Core">version	"The version attribute distinguishes the object from other versioned 	object with the same name."	version isNil ifTrue: [version := '1.0'].	^version</body><body package="DST_Core">version: newVersion 	"The version attribute distinguishes the object from other versioned 	object with the same name."	self notYetImplemented</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>accessing</category><body package="DST_Core">absoluteName	"The absoluteName attribute is an absolute scoped name that 	identifies a contained object uniquely within its enclosing 	repository. If the object's definedIn attribute references a repository, 	the absoluteName is formed by concatenating the string '::' and the 	object's name attribute. Otherwise, the absoluteName is formed by 	concatenating the absoluteName attribute of the object referenced 	by the object's definedIn attribute, the string '::', and the object's 	name attribute."	^self idlName</body><body package="DST_Core">accessControlList	"return the access control list"	^IdentityDictionary with: #other -&gt; (IdentitySet with: #read)</body><body package="DST_Core">convertedName	"return the converted print name symbol of the receiver"	^self convertSymbol: self printName</body><body package="DST_Core">declarators	"return the declarators of the receiver. Only types can have 	multiple declarators, so return an array with the receiver"	^Array with: self</body><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	definedIn := aMetaObject.</body><body package="DST_Core">definedInOnly: aMetaObject 	"set only the receiver's defining container meta object"	definedIn := aMetaObject.</body><body package="DST_Core">definingMetaContainer	"return the meta container which contains the receiver" 	^self definingMetaObject  definingMetaContainer</body><body package="DST_Core">definition: aStringArray 	"set the definition of the receiver"	definition := aStringArray</body><body package="DST_Core">description	"return a description of the receiver"	self subclassResponsibility</body><body package="DST_Core">equivalentType	"Return the equivalentType. By default return self. Override if need 	something different."	^self</body><body package="DST_Core">idlName	"return the receivers full qualified name"	^self definingMetaObject idlName , '::' , self printName</body><body package="DST_Core">isDeclarator	^false</body><body package="DST_Core">prefix: aPrefix 	"Set the prefix for this meta object."	aPrefix prefixString isNil		ifTrue: [prefix := nil]		ifFalse: [prefix := aPrefix]</body><body package="DST_Core">printName	"return the print name symbol of the receiver"	^name isNil		ifTrue: ['?']		ifFalse: [name]</body><body package="DST_Core">repositoryId	^repositoryId ifNil: [repositoryId := self generateRepositoryId]</body><body package="DST_Core">repositoryId: aRepositoryId 	repositoryId := aRepositoryId</body><body package="DST_Core">unitOfCompilation	"return the unit of compilation of the receiver (a real 	module or interface) that is defined in the repository" 	| def |	^(def := self definingMetaObject) class == DSTmoduleRepository		ifTrue: [self]		ifFalse: [def unitOfCompilation]</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>printing</category><body package="DST_Core">getIDLDefinition	"return the IDL definition of the receiver"	^self getIDLDefinition: #default</body><body package="DST_Core">hasComment	"return true if the receiver has a comment string"	^(definition isNil or: [definition isEmpty]) not</body><body package="DST_Core">hasPragma	"return true if the receiver has a pragma string"	^false</body><body package="DST_Core">printCommentOn: aStream indent: level 	"print the comment of the receiver on the stream, inserting crs 	so that the appropriate print width is obtained. Return true iff 	a comment has been printed."	self hasComment ifFalse: [^false].	1 to: definition size		do: 			[:index | 			self				printSingleComment: (definition at: index)				on: aStream				indent: level.			aStream cr].	^true</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"subclasses must overload"	self subclassResponsibility</body><body package="DST_Core">printHeaderOn: aStream indent: level 	"print the comment of the receiver on the stream. Precede the 	comment with an extra line that contains the receiver's 	name. Return true iff a comment has been printed."	level = 0 ifTrue: [(self hasComment and: [definition first = self printName asString])			ifFalse: [aStream tab: level; nextPutAll: '// '; nextPutAll: self printName; cr]].	^self printCommentOn: aStream indent: level</body><body package="DST_Core">printSingleComment: aString on: aStream indent: indent 	"Print the comment string, assuming it has been indented 	indent tabs. Break the string at word breaks, given the widths 	in the default font, at 450 points."	| readStream position lineBreak font wordWidth tabWidth spaceWidth outStream char commentBegin commentBeginWidth leaderWidth |	readStream := aString readStream.	outStream := (String new: 16) writeStream.	font := Screen default defaultFontPolicy findFont: FontDescription default.	tabWidth := TextConstants at: #DefaultTab.	spaceWidth := font spaceWidth.	commentBegin := '// '.	commentBeginWidth := commentBegin inject: 0 into: [:w :c | w + (font widthOf: c)].	leaderWidth := indent * tabWidth + commentBeginWidth.	position := leaderWidth.	aStream tab: indent; nextPutAll: commentBegin.	lineBreak := 480 - spaceWidth.	char := readStream next.	["In the loop, char is the last character already 	read from readStream. We detect end-of-stream 	by char == nil, because we always read 1 character 	ahead."	char == nil]		whileFalse: [char = Character space				ifTrue: ["Skip inter-word spaces"					char := readStream next]				ifFalse: [char = Character cr						ifTrue: 							[[(char := readStream next) = Character tab]								whileTrue: [].	"skip tabs after cr"							aStream crtab: indent; nextPutAll: commentBegin.							position := leaderWidth]						ifFalse: 							["Collect a word onto outStream, 							and its width in wordWidth."							outStream reset.							wordWidth := 0.														[outStream nextPut: char.							wordWidth := wordWidth + (font widthOf: char).							char := readStream next.							char = Character cr or: [char = Character space or: [char == nil]]]								whileFalse: [].							position + wordWidth &gt; lineBreak								ifTrue: 									["Check whether the word will fit 									on a line."									aStream crtab: indent; nextPutAll: commentBegin.									position := leaderWidth].							aStream nextPutAll: outStream contents.							position := position + wordWidth.							readStream atEnd								ifFalse: 									[position := position + spaceWidth.									aStream space]]]]</body><body package="DST_Core">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"publish my definition"	self		printDefinitionOn: aStream		indent: level		style: aTextStyleName</body><body package="DST_Core">stringNeedsFormatting: aString indent: level style: aTextStyleName 	"answer true if aString extends beyond the maximum right 	margin when starting at the specified indentation"	| tabWidth stringWidth |	tabWidth := TextConstants at: #DefaultTab.	stringWidth := ComposedText widthOfString: aString styleName: aTextStyleName.	^level + (stringWidth / tabWidth) &gt; 20</body><body package="DST_Core">tabFor: aString style: aTextStyleName 	"Calculate the required number of tabs to cover the width of 	aString"	| tabWidth stringWidth |	tabWidth := TextConstants at: #DefaultTab.	stringWidth := ComposedText widthOfString: aString styleName: aTextStyleName.	^stringWidth // tabWidth + (stringWidth \\ tabWidth) sign</body><body package="DST_Core">wantsSpace	"return true if the receiver wants an extra line of space before 	printing itself"	^self hasComment | self hasPragma</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>testing</category><body package="DST_Core">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/Contained:1.0' ifTrue:[^true].	^self isA: aRepositoryId</body><body package="DST_Core">isDSTMetaContainer	^false</body><body package="DST_Core">isDSTMetaObject	^true</body><body package="DST_Core">isDSTattribute	^false</body><body package="DST_Core">isDSTcachedOperation	^false</body><body package="DST_Core">isDSTdeclaratorSimple	^false</body><body package="DST_Core">isDSTexception	^false</body><body package="DST_Core">isDSTinterface	^false</body><body package="DST_Core">isDSTmodule	^false</body><body package="DST_Core">isDSToperation	^false</body><body package="DST_Core">isDSTtype	^false</body><body package="DST_Core">isDSTtypeArray	^false</body><body package="DST_Core">isDSTtypeNamed	^false</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream. Subclasses must overload"	self subclassResponsibility</body><body package="DST_Core">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	self boldMarshall: aParameter on: aStream</body><body package="DST_Core">canMarshall: aParameter 	"return if the receiver can marshall the given parameter"	^(self marshallMatch: aParameter) ~~ false</body><body package="DST_Core">marshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	[self boldMarshall: aParameter on: aStream]		on: self errorSignal do: [:ex | self class marshallError: 0]</body><body package="DST_Core">marshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	[self		boldMarshall: aParameter		on: aStream		withLocalClass: aClass]		on: self errorSignal do: [:ex | self class marshallError: 0]</body><body package="DST_Core">tryMarshallIndirectTypeCode: aDictionary on: aStream 	"if the dictionary contains me, then marshall an indirect typecode"	^(aDictionary includesKey: self)		ifTrue: 			[aStream nextPutUnsignedLong: (self class typeCodeOf: #tk_indirect).			aStream nextPutLong: (aDictionary at: self)					- aStream position.			true]		ifFalse: 			[aStream padToLong.			aDictionary at: self put: aStream position.			false]</body><body package="DST_Core">tryUnmarshallIndirectTypeCode: aDictionary from: aStream 	"if the dictionary contains me, then marshall an indirect typecode"	| ix |	^aStream peek = (self class typeCodeOf: #'tk_indirect')		ifTrue: 			[ix := aStream nextLong.			DSTtypeNamed new resolveTo: (aDictionary at: ix)]		ifFalse: 			[aDictionary add: aStream position -&gt; self.			nil]</body><body package="DST_Core">tryUnmarshallIndirectTypeCode: aDictionary from: aStream typeKind: aTK 	"if the dictionary contains me, then marshall an indirect typecode"	| ix  |	^aTK = (self class typeCodeOf: #tk_indirect)		ifTrue: 			[ix := aStream nextLong.			DSTtypeNamed new resolveTo: (aDictionary at: aStream position + ix)]		ifFalse: 			[aDictionary add: aStream position -&gt; self.			nil]</body><body package="DST_Core">typeCode	"return the type code of the receiver"	^self class typeCodeOf: self typeKind</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream	"unmarshall an indirect type"	| ix  |	ix := aStream nextLong.	^(DSTtypeNamed new) resolveTo: (aDictionary at: aStream position + ix); yourself</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>MetaSem</category><body package="DST_Core">definingMetaObject	"return the receiver's defining meta object" 	^definedIn ifNil: [DSTmoduleRepository new initialize: #Undefined]</body><body package="DST_Core">getIDLDefinition: aTextStyleName 	"return the IDL definition of the receiver formatted with the 	specified text style (a Symbol, e.g. #fixed, #default)"	| str |	str := (String new: 80) writeStream.	self		printDefinitionOn: str		indent: 0		style: aTextStyleName.	^str contents</body><body package="DST_Core">metaObject	^self</body><body package="DST_Core">references	"Return a list with information about meta objects that are referencing the 	receiver. For each referent an Array with three Elements is returned, 	consisting of the referent, its full name, and the number of references to 	the receiver from the referent"	"(ORBObject repository metaObjectOf: #'ContainerSem') references"	"(ORBObject repository metaObjectOf: #'::Naming::NotFound') references"	| metas result refs |	metas := Set with: 1000.	self repository allMetaObjectsInto: metas.	refs := Bag new: 20.	metas		do: 			[:mo | mo isDSTMetaObject ifTrue: [				((mo isDSTtypeNamed)					and: [mo equivalentType idlName = self idlName])					ifTrue: [refs add: mo definingMetaObject].				(((mo isDSToperation)					and: [mo exceptions includes: self])					or: [(mo isDSTinterface)							and: [mo superiors includes: self]])					ifTrue: [refs add: mo]]].	result := refs asSet collect: [:ref | Dictionary					with: #referent -&gt; ref					with: #name -&gt; ref idlName					with: #count -&gt; (refs occurrencesOf: ref)].	^result</body><body package="DST_Core">repository	"return the repository meta object"	^ORBObject repository</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>comparing</category><body package="DST_Core">&lt;= aMetaObject 	"Answer true if and only if the receiver collates before aMetaObject or is 	the same as aMetaObject. The print names of meta objects are used for 	the comparison"	^self printName &lt;= aMetaObject printName</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>private</category><body package="DST_Core">initialSOevents	^self shouldNotImplement</body><body package="DST_Core">setVersion: newVersion 	"Set the version field of the meta object. Called from a version 	pragma."	version := newVersion</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Contained'</body><body package="DST_Core">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	aSet add: self.</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^false</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_none</body><body package="DST_Core">extractFullName: aReposId 	"extract the fullName from the repositoryId from the fullname based 	upon the IR Specification"	^self class extractFullName: aReposId</body><body package="DST_Core">generateRepositoryId	"generate the repositoryId from the fullname based upon the IR 	Specification"	| cn fn ws c1 |	fn := self idlName.	prefix isNil		ifTrue: 			[ws := WriteStream on: (fn species new: fn size + 6).			ws nextPutAll: 'IDL:']		ifFalse: 			[prefix definingContainer isNil				ifFalse: 					[cn := prefix definingContainer idlName.					fn := fn								copyReplaceFrom: 1								to: cn size								with: String new].			prefix prefixString isNil				ifTrue: 					[ws := WriteStream on: (fn species new: fn size + 6).					ws nextPutAll: 'IDL:']				ifFalse: 					[ws := WriteStream on: (fn species new: fn size + 6 + prefix prefixString size).					ws nextPutAll: 'IDL:'.					ws nextPutAll: prefix prefixString; nextPut: $/]].	3 to: fn size		do: 			[:i | 			c1 := fn at: i.			c1 = $:				ifTrue: [(fn at: i + 1)						= $: ifTrue: [ws nextPut: $/]]				ifFalse: [ws nextPut: c1]].	version isNil		ifTrue: [ws nextPutAll: ':1.0']		ifFalse: [ws nextPut: $:; nextPutAll: version].	^RepositoryId fromString: ws contents</body><body package="DST_Core">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	^self definingMetaObject metaObjectOf: aSymbol</body><body package="DST_Core">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^(self metaObjectOf: aSymbol) value</body><body package="DST_Core">registerIdentity	"Register the identity and full name of the receiver in the Interface 	Repository."	| fn |	prefix isNil ifFalse: [self repositoryId].	repositoryId isNil		ifFalse: 			[fn := self idlName.			InterfaceRepository at: repositoryId put: self.			InterfaceRepository at: fn asSymbol put: self.			RepositoryCache at: repositoryId put: self.			RepositoryCache at: fn asSymbol put: self]</body><body package="DST_Core">removeContained: aMetaObject	"Remove references to a contained object, aMetaObject.	Only containers have something interesting to do"</body><body package="DST_Core">removeMetaObject	"Most meta objects don't need any special processing. 	Only DSTinterfaces, DSTmodules, and DSTMetaContainers do 	something special."</body><body package="DST_Core">resolveTypeReference	"implemented by DSTtypeNamed &amp;  DSTconstant only. Others 	should noop"</body><body package="DST_Core">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	^nil</body><body package="DST_Core">unlinkFromRepository	"The receiver is being removed from the repository. Unlink as 	required"	[RepositoryCache includes: self]		whileTrue: [RepositoryCache removeKey: (RepositoryCache keyAtValue: self)].	[InterfaceRepository includes: self]		whileTrue: [InterfaceRepository removeKey: (InterfaceRepository keyAtValue: self)].	definedIn notNil ifTrue: [definedIn removeContained: self].	definedIn := nil</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^OrderedCollection new</body><body package="DST_Core">asMetaInfo	"return an Dictionary with information about the receiver"	^Dictionary		with: #title -&gt; self childName		with: #iconId -&gt; self iconId		with: #hasComponents -&gt; self hasComponents		with: #inheritedDirectly -&gt; false</body><body package="DST_Core">childName	"return the name to be used for the receiver in a browser window"	^self printName</body><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^true</body><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^self class iconId</body><body package="DST_Core">nonTrivialDeclarators	"Get rid of declarators in the browser. Return the declarators of the 	receiver if there is more than one declarator, otherwise return an 	Array containing myself."	^self declarators</body><body package="DST_Core">title	^self shouldNotImplement</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>TypeCode</category><body package="DST_Core">typeEqual: aTC 	"return if the receiver is equal to the given type code"	^self typeCodeConstant = aTC typeCodeConstant</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"</body><body package="DST_Core">initialize: aSymbol 	"initialize the type printname of the receiver"	self initialize.	name := aSymbol</body><body package="DST_Core">reInitialize	"reinitialize the receiver. Zap my objectId and my locally generated 	identity"	repositoryId := nil.</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>exceptions</category><body package="DST_Core">notYetImplemented	"Raise an exception indicating that the write interface to the IR is not 	implemented."	self error: 'Interface repository write interface not yet implemented'</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>fileIn/Out</category><body package="DST_Core">representBinaryOn: binWriter 	"This is called by the BOSS when an on object is written to a BOSS 	stream. By default, meta objects do nothing special to represent 	themselves in binary form."	^nil</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>converting</category><body package="DST_Core">convertSymbol: aSymbol 	"remove underscore characters and capitalize following character"	| str i |	str := aSymbol asString.	[str includes: $_]		whileTrue: 			[i := str indexOf: $_.			str := (str copyFrom: 1 to: i - 1)						, (str copyFrom: i + 1 to: str size) capitalized].	^str asSymbol</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>persistence</category><body package="DST_Core">persistentState	"return my persistent state. NOTE: will want to change this if we add copy 	semantics to meta objects later"	^#()</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>repository-private</category><body package="DST_Core">canContain: kind 	"Check to see if the definition kind can be contained in the receiver."	^false</body></methods><methods><class-id>DST.DSTMetaObject</class-id> <category>parcel support</category><body package="DST_Core">postReadGeneralStructureOn: aBinaryStorageReader 	"Use the exsiting copy in the image, if there is one"	| existOne |	^(existOne := ORBObject lookupId: repositoryId) == nil		ifTrue: 			[(repositoryId isKindOf: RepositoryId)				ifTrue: [repositoryId := RepositoryId fromString: repositoryId].			self]		ifFalse: [self oneWayBecome: existOne]</body></methods><methods><class-id>DST.DSTMetaObject class</class-id> <category>utilities</category><body package="DST_Core">extractFullName: aReposId 	"Extract the fullName from the IDL format repositoryId from the fullname based upon the IR Specification"	| ws first last ch rs | 	rs := aReposId asString.	ws := WriteStream on: (ByteString new: aReposId size + 10).	ws nextPutAll: '::'.	first := rs findFirst: [:c | c = $:].	first isZero		ifTrue: [self error: 'invalid repositoryId']		ifFalse: 			[last := rs findLast: [:c | c = $:].			first + 1 to: last - 1				do: 					[:i | 					ch := rs at: i.					ch = $/						ifTrue: [ws nextPutAll: '::']						ifFalse: [ws nextPut: ch]].			^ws contents]</body><body package="DST_Core">parseName: aString 	"return the components of the qualified name aString as 	ordered collection"	| x tail |	x := aString findFirst: [:ch | ch = $:].	x isZero		ifFalse: 			[tail := aString copyFrom: x + 2 to: aString size.			x = 1 ifTrue: [^self parseName: tail].			^(self parseName: tail)				addFirst: (aString copyFrom: 1 to: x - 1); yourself]		ifTrue: [^OrderedCollection with: aString]</body><body package="DST_Core">requiredEditClasses	"Answer true if the classes needed for editing are in the image.  	Changed in 5i.  'DSTInterfaceBrowser' has been replaced with 	'DSTRemoreHierarchyBrowser'."	^#{DSTRemoteHierarchyBrowser} isDefined		&amp; (#{IDLCompiler} isDefined)</body><body package="DST_Core">scopedNameFrom: anOrderedCollection 	"return a scoped name using the elements of 	anOrderedCollection as the name components"	"self scopedNameFrom: (self parseName: '::a::b::c')"	"self scopedNameFrom: (self parseName: 'a')"	"self scopedNameFrom: #()"	^(anOrderedCollection inject: (WriteStream on: (String new: 20))		into: [:result :el | result nextPutAll: '::'; nextPutAll: el asString; yourself]) contents</body></methods><methods><class-id>DST.DSTMetaObject class</class-id> <category>rendering</category><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^self name</body></methods><methods><class-id>DST.DSTMetaObject class</class-id> <category>private</category><body package="DST_Core">initializeCurrentPrefix	CurrentPrefix := nil</body><body package="DST_Core">typeCodeMap	"Answer the type code map."	^TCMap		ifNil: 			[TCMap := IdentityDictionary new.			TCMap add: #tk_null -&gt; 0.			TCMap add: #tk_void -&gt; 1.			TCMap add: #tk_short -&gt; 2.			TCMap add: #tk_long -&gt; 3.			TCMap add: #tk_ushort -&gt; 4.			TCMap add: #tk_ulong -&gt; 5.			TCMap add: #tk_float -&gt; 6.			TCMap add: #tk_double -&gt; 7.			TCMap add: #tk_boolean -&gt; 8.			TCMap add: #tk_char -&gt; 9.			TCMap add: #tk_octet -&gt; 10.			TCMap add: #tk_any -&gt; 11.			TCMap add: #tk_TypeCode -&gt; 12.			TCMap add: #tk_Principal -&gt; 13.			TCMap add: #tk_objref -&gt; 14.			TCMap add: #tk_struct -&gt; 15.			TCMap add: #tk_union -&gt; 16.			TCMap add: #tk_enum -&gt; 17.			TCMap add: #tk_string -&gt; 18.			TCMap add: #tk_sequence -&gt; 19.			TCMap add: #tk_array -&gt; 20.			TCMap add: #tk_alias -&gt; 21.			TCMap add: #tk_except -&gt; 22.			TCMap add: #tk_longlong -&gt; 23.			TCMap add: #tk_ulonglong -&gt; 24.			TCMap add: #tk_longdouble -&gt; 25.			TCMap add: #tk_wchar -&gt; 26.			TCMap add: #tk_wstring -&gt; 27.			TCMap add: #tk_fixed -&gt;28.			TCMap add: #tk_indirect -&gt; 4294967295.			TCMap yourself]</body><body package="DST_Core">typeCodeTable	"Answer the type code table."	^TCTable		ifNil: 			[TCTable := Dictionary new.			TCTable add: (self typeCodeOf: #tk_null)					-&gt; DSTtypeVoid.			TCTable add: (self typeCodeOf: #tk_void)					-&gt; DSTtypeVoid.			TCTable add: (self typeCodeOf: #tk_short)					-&gt; DSTtypeShort.			TCTable add: (self typeCodeOf: #tk_long)					-&gt; DSTtypeLong.			TCTable add: (self typeCodeOf: #tk_ushort)					-&gt; DSTtypeUnsignedShort.			TCTable add: (self typeCodeOf: #tk_ulong)					-&gt; DSTtypeUnsignedLong.			TCTable add: (self typeCodeOf: #tk_float)					-&gt; DSTtypeFloat.			TCTable add: (self typeCodeOf: #tk_double)					-&gt; DSTtypeDouble.			TCTable add: (self typeCodeOf: #tk_boolean)					-&gt; DSTtypeBoolean.			TCTable add: (self typeCodeOf: #tk_char)					-&gt; DSTtypeCharacter.			TCTable add: (self typeCodeOf: #tk_octet)					-&gt; DSTtypeOctet.			TCTable add: (self typeCodeOf: #tk_any)					-&gt; DSTtypeAny.			TCTable add: (self typeCodeOf: #tk_TypeCode)					-&gt; DSTpseudoTypeCode.			TCTable add: (self typeCodeOf: #tk_Principal)					-&gt; DSTinterface.			TCTable add: (self typeCodeOf: #tk_objref)					-&gt; DSTinterface.			TCTable add: (self typeCodeOf: #tk_struct)					-&gt; DSTtypeStructure.			TCTable add: (self typeCodeOf: #tk_union)					-&gt; DSTtypeUnion.			TCTable add: (self typeCodeOf: #tk_enum)					-&gt; DSTtypeEnumeration.			TCTable add: (self typeCodeOf: #tk_string)					-&gt; DSTtypeString.			TCTable add: (self typeCodeOf: #tk_sequence)					-&gt; DSTtypeSequence.			TCTable add: (self typeCodeOf: #tk_array)					-&gt; DSTtypeArray.			TCTable add: (self typeCodeOf: #tk_alias)					-&gt; DSTtypeAlias.			TCTable add: (self typeCodeOf: #tk_except)					-&gt; DSTexception.			TCTable add: (self typeCodeOf: #tk_longlong)					-&gt; DSTtypeLongLong.			TCTable add: (self typeCodeOf: #tk_ulonglong)					-&gt; DSTtypeUnsignedLongLong.			TCTable add: (self typeCodeOf: #tk_longdouble)					-&gt; DSTtypeLongDouble.			TCTable add: (self typeCodeOf: #tk_wchar)					-&gt; DSTtypeWideCharacter.			TCTable add: (self typeCodeOf: #tk_wstring)					-&gt; DSTtypeWideString.			TCTable add: (self typeCodeOf: #tk_fixed)					-&gt; DSTtypeFixed.			TCTable add: (self typeCodeOf: #tk_indirect)					-&gt; DSTMetaObject.			TCTable yourself]</body></methods><methods><class-id>DST.DSTMetaObject class</class-id> <category>very private</category><body package="DST_Core">initializeTypeCodes	TCMap := TCTable := nil</body></methods><methods><class-id>DST.DSTMetaObject class</class-id> <category>creation</category><body package="DST_Core">new	"create and initialize a metaobject"	^self basicNew initialize</body><body package="DST_Core">prefix: aScope 	| mo |	mo := self basicNew initialize.	mo prefix: aScope prefix.	^mo</body></methods><methods><class-id>DST.DSTMetaObject class</class-id> <category>marshalling</category><body package="DST_Core">typeCodeOf: typeKind 	"return the type code of the kind" 	^self typeCodeMap at: typeKind ifAbsent: [nil]</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall a type code and return an appropriate metaobject"	| tk |	tk := aStream nextUnsignedLong.	^(self typeCodeTable at: tk ifAbsent: [self intfReposError: 0]) new unMarshallTypeCode: aDictionary from: aStream</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream typeKind: anInteger 	"unmarshall a type code and return an appropriate metaobject"	^(self typeCodeTable at: anInteger ifAbsent: [self intfReposError: 0]) new unMarshallTypeCode: aDictionary from: aStream</body></methods><methods><class-id>DST.DSTtype</class-id> <category>repository</category><body package="DST_Core">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	declarators notNil ifTrue: [declarators  do: [:dec | aSet add: dec]].</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^self subclassResponsibility</body></methods><methods><class-id>DST.DSTtype</class-id> <category>marshalling</category><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver. Types with more interesting 	codes should overload"	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class. Subclasses must overload"	self subclassResponsibility</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^self unMarshall: aStream</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream typeKind: anInt 	"unmarshall the type code of the receiver. Types with more 	interesting codes should overload"	| mo |	(mo := self				tryUnmarshallIndirectTypeCode: aDictionary				from: aStream				typeKind: anInt) notNil ifTrue: [^mo].	anInt = self typeCode ifFalse: [self class badTypecodeError: 0]</body></methods><methods><class-id>DST.DSTtype</class-id> <category>printing</category><body package="DST_Core">IDLTypeName	"return the printable name of the receiver's IDL type ie the type to be 	actually marshalled in the NCS packet"	^name</body><body package="DST_Core">declaratorPrintName: n 	"return the nth declarator's printName"	declarators isNil ifFalse: [^(declarators at: n) printName]</body><body package="DST_Core">declaratorString	"return the declarator definition string of the receiver"	| st |	st := WriteStream on: ( String new: 32 ).	self printDeclaratorsOn: st.	^st contents</body><body package="DST_Core">definitionString	"return my unformatted IDL type definition string"	^name</body><body package="DST_Core">hasPragma	"return true if the receiver has a pragma string"	^self localType notNil</body><body package="DST_Core">printDeclaratorsOn: aStream 	"print the declarators list onto the stream"	| dec |	declarators isNil		ifFalse: 			[dec := declarators at: 1.			aStream nextPutAll: dec declaratorString.			2 to: declarators size				do: 					[:i | 					dec := declarators at: i.					aStream nextPutAll: ', '; nextPutAll: dec declaratorString]]</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print my IDL definition on the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it is important that the first token of an IDL 'method' is parsed 	correctly by Parser. Specifically, it must be avoided that the pound 	sign is the 	first character in the method, since it would cause a parsing 	problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make sure that there is always at least one comment line. Also note, 	that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[self hasPragma				ifTrue: 					[aStream nextPutAll: '#pragma class '; nextPutAll: (self declaratorPrintName: 1); nextPutAll: ' '; nextPutAll: self localType; cr.					aStream tab: level; nextPutAll: 'typedef ']				ifFalse: [aStream nextPutAll: 'typedef '].			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body><body package="DST_Core">printFormattedOn: aStream indent: level style: aTextStyleName 	"print the detailed formatted definition of the receiver on 	aStream. To be overloaded by subclasses if formatting is 	actually required"	aStream nextPutAll: self definitionString</body><body package="DST_Core">printHeaderOn: aStream indent: level 	"print the comment of the receiver on the stream. Precede the 	comment with an extra line that contains the receiver's 	name. Return true iff a comment has been printed."	level = 0 ifTrue: [(self hasComment and: [definition first = self childName asString])			ifFalse: [aStream tab: level; nextPutAll: '// '; nextPutAll: self childName; cr]].	^self printCommentOn: aStream indent: level</body><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	[aStream nextPutAll: self definitionString , '  ' , self idlName]		on: Object errorSignal do: [:x | ^super printOn: aStream]</body><body package="DST_Core">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"publish my IDL definition on the stream"	self printHeaderOn: aStream indent: level.	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[aStream nextPutAll: 'typedef '.			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body></methods><methods><class-id>DST.DSTtype</class-id> <category>accessing</category><body package="DST_Core">baseType	"The baseType of most types is self."	^self</body><body package="DST_Core">declarators	"return the declarators of the receiver, or an array of self if nil"	declarators notNil		ifTrue: [^declarators]		ifFalse: [^#()]</body><body package="DST_Core">declarators: decls 	"set the declarators of the receiver"	declarators := decls.	declarators do: [:dec| dec resolveTo: self]</body><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	declarators notNil ifTrue: [declarators do: [:ty | ty definedInOnly: aMetaObject]]</body><body package="DST_Core">idlName	"return the receivers full qualified name"	^self definingMetaObject idlName , '::' , self childName</body><body package="DST_Core">localClass	"return the local class of the receiver"	localclass == nil ifFalse: [^localclass].	localtype == nil ifTrue: [^nil].	^localclass := DST 					at: localtype 					ifAbsent: [localtype asQualifiedReference valueOrDo: [self class intfReposError: 0]]</body><body package="DST_Core">localType	"return the local type of the receiver"	^localtype</body><body package="DST_Core">nAry	"types used as targets of relationships are not nAry"	^false</body><body package="DST_Core">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope. Currently, only structures have sufficent 	information to be able to resolve.  Do nothing here"</body><body package="DST_Core">resolveTo: aType	"cause the receiver to resolve to the given type object"	self error: 'Must be overridden by subclass'</body></methods><methods><class-id>DST.DSTtype</class-id> <category>testing</category><body package="DST_Core">isDSTtype	^true</body></methods><methods><class-id>DST.DSTtype</class-id> <category>copying</category><body package="DST_Core">copy	"perform the copy operation on the receiver"	| obj |	obj := super shallowCopy.	declarators notNil ifTrue: 		[obj declarators: (declarators collect: [:co | co copyDeclaratorOn: self])].	^obj postCopy</body><body package="DST_Core">copyDeclaratorOn: aType	"make a copy of a declarator type, remembering that the declarator will point 	back to the type object which contained it as a declarator. We must avoid 	an infinite loop. Named, array, &amp; pointer types must overload"	^self shallowCopy</body></methods><methods><class-id>DST.DSTtype</class-id> <category>TypeCode</category><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^0</body><body package="DST_Core">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	self error: #Bounds</body></methods><methods><class-id>DST.DSTtype</class-id> <category>rendering</category><body package="DST_Core">childName	"return the name to be used for the receiver in a browser window"	^declarators isNil		ifTrue: [self printName]		ifFalse: [declarators first name]</body><body package="DST_Core">nonTrivialDeclarators	"Get rid of declarators in the browser. Return the declarators of the 	receiver if there is more than one declarator, otherwise return an 	Array containing myself."	^(declarators isNil or: [declarators size == 1])		ifTrue: [Array with: self]		ifFalse: [declarators]</body></methods><methods><class-id>DST.DSTtype</class-id> <category>initialization</category><body package="DST_Core">initialize: aSymbol 	"set the type printname of the receiver"	name := aSymbol</body><body package="DST_Core">localType: aClassName 	"set the description and local type fields"	aClassName isEmpty		ifTrue: [localtype := nil]		ifFalse: [localtype := aClassName asSymbol]</body><body package="DST_Core">with: decls 	"set the type printname of the receiver"	declarators := decls.</body></methods><methods><class-id>DST.DSTtype</class-id> <category>TypeDef</category><body package="DST_Core">description	"return the appropriate description for the receiver"	^Dictionary		with: #name -&gt; name		with: #id -&gt; self id		with: #definedIn -&gt; self definedInString		with: #type -&gt; self</body><body package="DST_Core">type	"return the type code of the receiver"	^self</body></methods><methods><class-id>DST.DSTtype class</class-id> <category>accessing</category><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^#DSTtype</body></methods><methods><class-id>DST.DSTtypeBase</class-id> <category>marshalling</category><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver. Types with more interesting 	codes should overload"	aStream nextPutUnsignedLong: self typeCode</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream	"unmarshall the type code of the receiver - do nothing since the 	TCKind has already been unmarshalled and base types have no 	TypeCode parameters"	^self</body></methods><methods><class-id>DST.DSTtypeBase</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::PrimitiveDef'</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Primitive</body></methods><methods><class-id>DST.DSTtypeBase</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^self subclassResponsibility</body></methods><methods><class-id>DST.DSTtypeBase</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^OrderedCollection with: (DSTpseudoType on: self IDLTypeName)</body><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^declarators notNil</body></methods><methods><class-id>DST.DSTtypeAny</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_any</body></methods><methods><class-id>DST.DSTtypeAny</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	| type value strm |	localtype notNil		ifTrue: 			[type := aParameter type.			value := aParameter value]		ifFalse: 			[type := CORBATypeMap at: aParameter ifAbsent: [aParameter CORBAType].			value := aParameter].	(self isComplexTypeCode: type typeCode)		ifTrue: 			[strm := CDRStream on: (ByteArray new: 100).			type marshallTypeCode: Dictionary new on: strm.			aStream padToLong.			aStream nextPutAll: strm contents]		ifFalse: [type marshallTypeCode: Dictionary new on: aStream].	type boldMarshall: value on: aStream</body><body package="DST_Core">marshallMatch: aParameter 	"Return if the receiver can marshall the given parameter. If it is an 	association (the representation of a Smalltalk any), or if such a 	representation can be built, return true"	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^localtype notNil		ifTrue: [aParameter isKindOf: self localClass]		ifFalse: [aParameter CORBAType marshallMatch: aParameter]</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| type obj tk ba strm byteOrder |	tk := aStream nextUnsignedLong.	(self isComplexTypeCode: tk)		ifTrue: 			[ba := self class typeCodeStreamDef unMarshall: aStream.			strm := (CDRStream on: (ByteArray new: ba size + 4)) reset.			strm nextPutUnsignedLong: ba size.			strm nextPutAll: ba.			strm reset]		ifFalse: 			[strm := aStream.			byteOrder := nil].	type := DSTMetaObject				unMarshallTypeCode: Dictionary new				from: strm				typeKind: tk.	byteOrder notNil ifTrue: [aStream byteOrder: byteOrder].	type definedIn: self definingMetaContainer.	obj := type unMarshall: aStream.	^localtype notNil		ifTrue: [(self localClass new) type: type; value: obj; yourself]		ifFalse: 			[((self isComplexTypeCode: tk)			and: [ (obj isKindOf: DSTUnion)					or: [ (obj isKindOf: Collection)						and: [(obj isSymbol) not]]])				ifTrue: [CORBATypeMap at: obj put: type].			obj]</body></methods><methods><class-id>DST.DSTtypeAny</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'any'</body></methods><methods><class-id>DST.DSTtypeAny</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_any</body></methods><methods><class-id>DST.DSTtypeAny</class-id> <category>testing</category><body package="DST_Core">isComplexTypeCode: anInteger	^anInteger &gt; 13 and: [(#(18 23 24 25 26 27 28) includes: anInteger) not]</body></methods><methods><class-id>DST.DSTtypeAny class</class-id> <category>override corbatype</category><body package="DST_Core">overrideCORBAType: aDSTMetaObject forObject: anObject 	"override the default CORBAType"	(aDSTMetaObject isDSTMetaObject and: [aDSTMetaObject isDSTtype or: [aDSTMetaObject isDSTinterface]])		ifTrue: [CORBATypeMap at: anObject put: aDSTMetaObject]		ifFalse: [self class badParamError: 0]</body></methods><methods><class-id>DST.DSTtypeAny class</class-id> <category>class initialization</category><body package="DST_Core">flushCORBATypeMap	CORBATypeMap := TypeMapClass new: 2011</body><body package="DST_Core">initialize	"DSTtypeAny initialize"	self flushCORBATypeMap</body><body package="DST_Core">release	"release class variables"	CORBATypeMap := TCStreamDef := nil</body></methods><methods><class-id>DST.DSTtypeAny class</class-id> <category>testing</category><body package="DST_Core">test	((DSTtype withAllSubclasses) remove: DSTtypeNamed; yourself) do: [:cl | self test: cl]</body><body package="DST_Core">test: cl 	Transcript print: cl name; flush.	cl allInstances do: [:mo | self testMO: mo].	Transcript cr; flush</body></methods><methods><class-id>DST.DSTtypeAny class</class-id> <category>private</category><body package="DST_Core">typeCodeStreamDef	"answer the type code stream definition"	^TCStreamDef ifNil: [TCStreamDef := (DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray]</body></methods><methods><class-id>DST.DSTtypeLong</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_long</body></methods><methods><class-id>DST.DSTtypeLong</class-id> <category>accessing</category><body package="DST_Core">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	| max maxSize probe |	name = 'short'		ifTrue: [max := 32767]		ifFalse: [name = 'long'				ifTrue: [max := 2147483647]				ifFalse: [name = 'unsigned short'						ifTrue: [maxSize := 65536]						ifFalse: [maxSize := 4294967296]]].	maxSize isNil		ifTrue: [maxSize := max + 1 * 2]		ifFalse: [max := maxSize - 1].	aCol size &lt; maxSize		ifTrue: 			[probe := max.			[aCol includes: probe]				whileTrue: [probe := probe - 1].			^probe]		ifFalse: [^nil]</body></methods><methods><class-id>DST.DSTtypeLong</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = raises exception in nextPutLong:"	aStream nextPutLong: aParameter</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isInteger</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextLong</body></methods><methods><class-id>DST.DSTtypeLong</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'long'</body></methods><methods><class-id>DST.DSTtypeLong</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_long</body></methods><methods><class-id>DST.DSTtypeLongLong</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_longlong</body></methods><methods><class-id>DST.DSTtypeLongLong</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = raises exception in nextPutLongLong:"	aStream nextPutLongLong: aParameter</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextLongLong</body></methods><methods><class-id>DST.DSTtypeLongLong</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'long long'</body></methods><methods><class-id>DST.DSTtypeLongLong</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_longlong</body></methods><methods><class-id>DST.DSTtypeUnsignedLongLong</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_ulonglong</body></methods><methods><class-id>DST.DSTtypeUnsignedLongLong</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = raises exception in nextPutUnsignedLongLong:"	aStream nextPutUnsignedLongLong: aParameter</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextUnsignedLongLong</body></methods><methods><class-id>DST.DSTtypeUnsignedLongLong</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'unsigned long long'</body></methods><methods><class-id>DST.DSTtypeUnsignedLongLong</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_ulonglong</body></methods><methods><class-id>DST.ORBDeadObject</class-id> <category>messaging</category><body package="DST_Core">doesNotUnderstand: aMessage 	"Inform the user that a dead object is being messaged"	Dialog onDebugNotify: 'Message to dead object: ' , aMessage printString.	^ORBObject invObjrefError: 1</body></methods><methods><class-id>DST.ORBDeadObject class</class-id> <category>accessing</category><body package="DST_Core">deadObject	"return the reference to the dead object"	^DeadObject ifNil: [DeadObject := ORBDeadObject new]</body><body package="DST_Core">isDeadObject	^true</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>double dispatching</category><body package="DST_Core">differenceFromFloat: aFloat	^self notImplemented</body><body package="DST_Core">differenceFromFraction: aFraction	^self notImplemented</body><body package="DST_Core">differenceFromInteger: anInteger	^self notImplemented</body><body package="DST_Core">differenceFromLongDouble: aLongDouble	"Presumably here because LongDouble - failed.	If the receiver's magnitude is very small, then aLongDouble's magnitude		must be very small, and the calculation underflowed.	Otherwise, both are very large and the calculation overflowed"	^self notImplemented</body><body package="DST_Core">equalFromFloat: aFloat	^self notImplemented</body><body package="DST_Core">equalFromFraction: aFraction	^self notImplemented</body><body package="DST_Core">equalFromInteger: anInteger	^self notImplemented</body><body package="DST_Core">equalFromLongDouble: aLongDouble	^self notImplemented</body><body package="DST_Core">lessFromFloat: aFloat	^self notImplemented</body><body package="DST_Core">lessFromFraction: aFraction	^self notImplemented</body><body package="DST_Core">lessFromInteger: anInteger	^self notImplemented</body><body package="DST_Core">lessFromLongDouble: aLongDouble	^self notImplemented</body><body package="DST_Core">productFromFloat: aFloat	^self notImplemented</body><body package="DST_Core">productFromFraction: aFraction	^self notImplemented</body><body package="DST_Core">productFromInteger: anInteger	^self notImplemented</body><body package="DST_Core">productFromLongDouble: aLongDouble	"Presumably here because LongDouble * failed.	If the receiver's magnitude is very small, then aLongDouble's magnitude		must be very small, and the calculation underflowed.	Otherwise, both are very large and the calculation overflowed"	^self notImplemented</body><body package="DST_Core">quotientFromFloat: aFloat	^self notImplemented</body><body package="DST_Core">quotientFromFraction: aFraction	^self notImplemented</body><body package="DST_Core">quotientFromInteger: anInteger	^self notImplemented</body><body package="DST_Core">quotientFromLongDouble: aLongDouble 	"Presumably here because LongDouble / failed.	First check for division by zero.	If the receiver's magnitude is smaller than aLongDouble's magnitude, the		calculation overflowed, since the quotient's magnitude &gt; 1.0.	Otherwise, the receiver was larger (in magnitude) than the argument,		so the quotient's magnitude &lt; 1.0 and underflow must have occurred"	^self notImplemented</body><body package="DST_Core">sumFromFloat: aFloat	^self notImplemented</body><body package="DST_Core">sumFromFraction: aFraction	^self notImplemented</body><body package="DST_Core">sumFromInteger: anInteger	^self notImplemented</body><body package="DST_Core">sumFromLongDouble: aLongDouble	"Presumably here because LongDouble + failed.	If the receiver's magnitude is very small, then aLongDouble's magnitude		must be very small, and the calculation underflowed.	Otherwise, both are very large and the calculation overflowed"	^self notImplemented</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>mathematical functions</category><body package="DST_Core">arcCos	"Answer the angle in radians.	The receiver must be between -1.0 and 1.0	The result will be between 0.0 and Pi"	^self notImplemented</body><body package="DST_Core">arcSin	"Answer the angle in radians.	The receiver must be between -1.0 and 1.0	The result will be between -Pi/2 and Pi/2"	^self notImplemented</body><body package="DST_Core">arcTan	"Answer the angle in radians.	The receiver can be any valid LongDouble	The result will be between -Pi/2 and Pi/2"	^self notImplemented</body><body package="DST_Core">cos	"return the cosine of the receiver (an angle in radians)	The receiver can be any valid LongDouble	The result will be between -1.0 and 1.0"	^self notImplemented</body><body package="DST_Core">exp	"return the exponential function of the receiver 	The receiver may be between roughly -709.0 and 709.0 	The result will be greater than 0.0"	^self notImplemented</body><body package="DST_Core">floorLog10	"Answer with a (quick) computation of (self log: 10) floor.	The receiver must be greater than zero	The result will be between -307 and 307"	^self notImplemented</body><body package="DST_Core">ln	"answer the natural log of the reciever	The receiver must be greater than 0.0	The result will be between -709.0 and 709.0"	^self notImplemented</body><body package="DST_Core">raisedTo: power 	"return (receiver ** power)"	^self notImplemented</body><body package="DST_Core">sin	"return the sine of the receiver (an angle in radians)	The receiver can be any valid LongDouble	The result will be between -1.0 and 1.0"	^self notImplemented</body><body package="DST_Core">sqrt	"Answer the square root of the receiver.	The receiver must be positive	The result will be positive"	^self notImplemented</body><body package="DST_Core">tan	"Answer the ratio of the sine to cosine of the receiver in radians.	The receiver can be any valid Float--in practice it is unlikely that		a Float would have a value close enough to Pi/2, or -Pi/2, or		3*Pi/2, or . . . to cause the primitive to fail	The result will be between -Infinity and +Infinity--if failure occurs,		the value was arbitrarily large, either positive or negative"	^self notImplemented</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>comparing</category><body package="DST_Core">&lt; aNumber 	"Answer whether the receiver is less than the argument.	The primitive fails if it cannot coerce the argument to a LongDouble"	^self notImplemented</body><body package="DST_Core">&lt;= aNumber 	"Answer whether the receiver is less than or equal to the argument.   	The primitive fails if it cannot coerce the argument to a LongDouble"	^self notImplemented</body><body package="DST_Core">= aNumber 	"Answer whether the receiver is equal to the argument.	Better implementation needed"	"| a b c status|	a :=  (DSTLongDouble new) basicAt:1 put:222; basicAt: 11 put: 55;yourself.	b := a copy.	c := (DSTLongDouble new) basicAt:2 put:192; basicAt: 8 put: 155;yourself.	status := true.	status := status and: [a = b].	status := status and: [(b = c) not]."	(aNumber class == DSTLongDouble) ifFalse: [^false].	1 to: 16 do: [:i | ((self basicAt: i) = (aNumber basicAt: i)) ifFalse:  [^false]].	^true</body><body package="DST_Core">&gt; aNumber 	"Answer whether the receiver is greater than the argument. 	The primitive fails if it cannot coerce the argument to a LongDouble"	^self notImplemented</body><body package="DST_Core">&gt;= aNumber 	"Answer whether the receiver is greater than or equal to the argument. " 	^self notImplemented</body><body package="DST_Core">hash	^((self basicAt: 16) bitShift: 8) + (self basicAt: 1)</body><body package="DST_Core">~= aNumber 	"Answer whether the receiver is not equal to the argument.	The primitive fails if it cannot coerce the argument to a LongDouble"	^self notImplemented</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>converting</category><body package="DST_Core">asDSTLongDouble	"Answer the receiver itself."	^self</body><body package="DST_Core">asDouble	^self notImplemented</body><body package="DST_Core">asFloat	"Answer the receiver as a float.	If the receiver's magnitude is too great to store in a float		raise an overflow signal	If the receiver's magnitude is too small (the magnitude is too		small for a float), raise an underflow signal"	^self notImplemented</body><body package="DST_Core">reverseByteOrder	"Swap byte order when booting up on a different-endian	machine than the image was saved on."	| bytes |	bytes := self basicSize.	1 to: bytes by: 2 do:		[:i |	| t |		t := self basicAt: i.		self basicAt: i put: (self basicAt: bytes-i+1).		self basicAt: bytes-i+1 put: t]</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>private</category><body package="DST_Core">defaultNumberOfDigits	"Answer how many digits of accuracy this class supports"	^20</body><body package="DST_Core">exponent	"Answer the SmallInteger to whose power two is raised.	Consider the receiver to be represented as a power of 	two multiplied by a mantissa (between one and two)	Optional. See Object documentation whatIsAPrimitive."	^super exponent</body><body package="DST_Core">timesTwoPower: anInteger 	"Answer the receiver multiplied by 2.0 raised to the power of 	the argument"	^self notImplemented</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>arithmetic</category><body package="DST_Core">* aNumber 	"Answer a LongDouble that is the result of multiplying the receiver by the 	argument, aNumber.  The primitive fails if it cannot coerce the argument	to a LongDouble"	^self notImplemented</body><body package="DST_Core">+ aNumber 	"Answer a LongDouble that is the result of adding the receiver to the argument.  	The primitive fails if it cannot coerce the argument to a LongDouble, or if 	overflow occurs."	^self notImplemented</body><body package="DST_Core">- aNumber 	"Answer a LongDouble that is the difference between the receiver and aNumber.  	The primitive fails if it cannot coerce the argument to a LongDouble."	^self notImplemented</body><body package="DST_Core">/ aNumber 	"Answer a LongDouble that is the exact result of dividing the receiver by the 	argument, anInteger.  The primitive fails if it cannot coerce the argument 	to a LongDouble."	^self notImplemented</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>truncation and round off</category><body package="DST_Core">fractionPart	"Answer a LongDouble whose value is the difference between the  	receiver and the receiver's truncated value"	^self notImplemented</body><body package="DST_Core">rounded	"Answer the integer nearest the receiver."	^self notImplemented</body><body package="DST_Core">truncated	"Answer a SmallInteger equal to the value of the receiver     	without its fractional part. Fail if the truncated value cannot be    	represented as a SmallInteger.  In that case, the code below will   	compute a LargeInteger truncated value"	^self notImplemented</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>coercing</category><body package="DST_Core">coerce: aNumber	^aNumber asDSTLongDouble</body><body package="DST_Core">generality	^95</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>accessing</category><body package="DST_Core">at: index        "Override implementation in Object since LongDouble        instances are not element indexable."         ^self shouldNotImplement</body><body package="DST_Core">at: index put: value        "Override implementation in Object since LongDouble        instances are not element indexable."         ^self shouldNotImplement</body><body package="DST_Core">size        "Override implementation in Object since LongDouble        instances are not element indexable."         ^self shouldNotImplement</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"Append to the argument, aStream, a literal form of the receiver 	using a reasonable number of significant digits."	"-1.234567d asDSTLongDouble printString"	"123.4567d asDSTLongDouble printString"	| sign exp frac |	sign := (((self  basicAt: 1) bitAnd: 128) bitShift: -7).	exp := (((self basicAt: 1) bitAnd: 127) asInteger bitShift: 8) + (self basicAt: 2) asInteger.	frac := 12.	sign + exp + frac.	'Not yet impl' printOn: aStream.</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^DSTtypeLongDouble new</body><body package="DST_Core">asIDLString	"return an IDL format string representation of the receiver"	| str |	str := self printString.	^str copyFrom: 1 to: str size - 1</body></methods><methods><class-id>DST.DSTLongDouble</class-id> <category>testing</category><body package="DST_Core">isLiteral	"Answer whether the receiver has a literal text form	recognized by the compiler."	^true</body><body package="DST_Core">isZero	"Answer whether 'self = self class zero'"	^self = 0.0q</body></methods><methods><class-id>DST.DSTLongDouble class</class-id> <category>external accessing</category><body package="DST_Core">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery."	^CLimitedPrecisionRealType double</body></methods><methods><class-id>DST.DSTLongDouble class</class-id> <category>private</category><body package="DST_Core">coerce: value to: class precision: precision exponent: exponent exponentChar: expChar	"Coerce the value to be an instance of 'class', or	if the receiver is a concrete subclass of Number, it	should coerce the number to itself.  'precision' is	the number of digits after the decimal point that	were explicitly represented. 'exponent' is the number	that follows the exponent character--this usually	represents multiplying the number by a power of 10,	but may mean something else for FixedPoint. The	'expChar' is the character that identifies what type	of number this is, and separates the basic number	from its exponent."	"This is a support routine for Number class&gt;&gt;readFrom:,	and may change or disappear from release to release."	^exponent == nil		ifTrue: [value asDSTLongDouble]		ifFalse: [value asDSTLongDouble * (10 raisedTo: exponent)]</body></methods><methods><class-id>DST.DSTLongDouble class</class-id> <category>constants access</category><body package="DST_Core">exponentCharacter	"Answer the Character that precedes the exponent in the printed form for instances"	^$q</body><body package="DST_Core">pi	"Answer the constant, Pi."	^Pi</body><body package="DST_Core">radiansPerDegree	"Answer the constant, RadiansPerDegree."	^RadiansPerDegree</body><body package="DST_Core">unity	"Answer the value which allows, for any given arithmetic value, the following to be true		aNumber * aNumber class unity = aNumber	This must be true regardless of how a given subclass chooses to define #*"	^1.0q</body><body package="DST_Core">zero	"Answer the value which allows, for any given arithmetic value, the following to be true		aNumber + aNumber class zero = aNumber	This must be true regardless of how a given subclass chooses to define #+"	^0.0q</body></methods><methods><class-id>DST.DSTLongDouble class</class-id> <category>instance creation</category><body package="DST_Core">fromDouble: aDouble	^0</body><body package="DST_Core">new 	^self basicNew:16</body></methods><methods><class-id>DST.DSTLongDouble class</class-id> <category>class initialization</category><body package="DST_Core">initialize	"Constants from Computer Approximations, pp. 182-183 	Pi = 3.14159265358979323846264338327950288 	Pi/2 = 1.57079632679489661923132169163975144 	Pi/4 = 0.78539816339744830961566084581987572 	Pi*2 = 6.28318530717958647692528676655900576 	Pi/180 = 0.01745329251994329576923690768488612 	2.0 ln = 0.69314718055994530941723212145817657 	2.0 sqrt = 1.41421356237309504880168872420969808"	"LongDouble initialize."	Pi := -1.0d arcCos.	RadiansPerDegree := Pi / 180.0d</body></methods><methods><class-id>DST.DSTLongDouble class</class-id> <category>testing</category><body package="DST_Core">isVariableSize	"Answer whether the receiver has variable-sized members."	^false</body></methods><methods><class-id>DST.DSTIRPragma</class-id> <category>actions</category><body package="DST_Core">applyTo: aMetaObject 	^self subclassResponsibility</body></methods><methods><class-id>DST.DSTIRPragma</class-id> <category>accessing</category><body package="DST_Core">name	^name</body><body package="DST_Core">name: aName 	name := aName</body></methods><methods><class-id>DST.DSTClassPragma</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma class ' , name , ' ' , className</body></methods><methods><class-id>DST.DSTClassPragma</class-id> <category>accessing</category><body package="DST_Core">className	^className</body><body package="DST_Core">className: aClass 	className := aClass</body></methods><methods><class-id>DST.DSTClassPragma</class-id> <category>actions</category><body package="DST_Core">applyTo: aMetaObject 	"Set local type for metaobject."	| msg |	(aMetaObject canApplyPragma: #CLASS)		ifTrue: [aMetaObject baseType localType: self className]		ifFalse: 			[msg := 'Class pragma not allowed on ' , aMetaObject displayString.			ORBDaemon configurationManager log: msg withCRs.			Dialog notify: msg]</body></methods><methods><class-id>DST.DSTtypeBoolean</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_boolean</body></methods><methods><class-id>DST.DSTtypeBoolean</class-id> <category>accessing</category><body package="DST_Core">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	| candidates |	candidates := #(true false ) asSet - aCol asSet.	^candidates isEmpty		ifTrue: [nil]		ifFalse: [candidates anElement]</body></methods><methods><class-id>DST.DSTtypeBoolean</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = nextputBoolean: raises exception"	((aParameter == true) or: [aParameter == false]) ifFalse: [self class marshallError: 0].	aStream nextPutBoolean: aParameter</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter == true or: [aParameter == false]</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextBoolean</body></methods><methods><class-id>DST.DSTtypeBoolean</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'boolean'</body></methods><methods><class-id>DST.DSTtypeBoolean</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_boolean</body></methods><methods><class-id>DST.DSToperationDescription</class-id> <category>accessing</category><body package="DST_Core">contexts	^contexts</body><body package="DST_Core">contexts: aValue	contexts := aValue</body><body package="DST_Core">definedIn	^definedIn</body><body package="DST_Core">definedIn: aValue	definedIn := aValue</body><body package="DST_Core">exceptions	^exceptions</body><body package="DST_Core">exceptions: aValue	exceptions := aValue</body><body package="DST_Core">id	^id</body><body package="DST_Core">id: aValue	id := aValue</body><body package="DST_Core">mode	^mode</body><body package="DST_Core">mode: aValue	mode := aValue</body><body package="DST_Core">name	^name</body><body package="DST_Core">name: aValue	name := aValue</body><body package="DST_Core">parameters	^parameters</body><body package="DST_Core">parameters: aValue	parameters := aValue</body><body package="DST_Core">result	^result</body><body package="DST_Core">result: aValue	result := aValue</body><body package="DST_Core">version	^version</body><body package="DST_Core">version: aValue	version := aValue</body></methods><methods><class-id>DST.DSToperationDescription</class-id> <category>repository</category><body package="DST_Core">CORBAType	^ORBObject lookupMetaId: #'::CORBA::OperationDescription'</body></methods><methods><class-id>DST.DSToperation</class-id> <category>Operation Def</category><body package="DST_Core">context	"return the context of the receiver"	^context</body><body package="DST_Core">contextIds	"return the context of the receiver. 	This is contextIds rather than context because of IDL naming 	restrictions"	^context</body><body package="DST_Core">contexts	"The contexts attribute specifies the list of context identifiers that 	apply to the operation."	^context</body><body package="DST_Core">contexts: newContexts 	"Set the contexts attribute to the list of context identifiers that 	apply to the operation."	self notYetImplemented</body><body package="DST_Core">description	"return an operation description"	^(DSToperationDescription new) 		name: name; 		id: self id; 		definedIn: self definedInString; 		version: self version;		result: signature returnParameter type equivalentType; 		mode: #NORMAL; 		contexts: self contexts; 		parameters: ((signature asOrderedCollection select: [:p | p isResult not]) collect: [:p | p description]); 		exceptions: (raises asOrderedCollection collect: [:x | (self exceptionOf: x) description]); 		yourself</body><body package="DST_Core">exceptions	"The exceptions attribute specifies the list of exception types that 	can be raised by the operation."	^raises collect: [:x | self exceptionOf: x]</body><body package="DST_Core">exceptions: newExceptions 	"Set the exceptions attribute to the list of exception types that 	can be raised by the operation."	self notYetImplemented</body><body package="DST_Core">mode	"The operation's mode is either oneway (i.e. no output is returned) or 	normal."	sync == nil ifTrue: [sync := #NORMAL].	^sync</body><body package="DST_Core">mode: anOperationMode 	"The mode attribute can only be set to OP_ONEWAY if the result is 	TC_void and all elements of params have a mode of PARAM_IN."	self notYetImplemented</body><body package="DST_Core">params	"The params attribute describes the parameters of the operation. It is 	a sequence of ParameterDescriptions. The order of the 	ParameterDescriptions in the sequence is significant. The name 	member of each description provides the parameter name. The type 	member is a typecode describing the type of the parameter. The 	typeDef member identifies the definition of the type of the 	parameter. The mode member indicates whether the parameter is 	an in, out, or inout parameter."	^signature collect: [:p | p description]</body><body package="DST_Core">params: paramList 	"The params attribute describes the parameters of the operation. It is 	a sequence of ParameterDescriptions. The order of the 	ParameterDescriptions in the sequence is significant. The name 	member of each description provides the parameter name. The type 	member is a typecode describing the type of the parameter. The 	typeDef member identifies the definition of the type of the 	parameter. The mode member indicates whether the parameter is 	an in, out, or inout parameter."	self notYetImplemented</body><body package="DST_Core">result	"The result attribute is a typecode describing the type of the value 	returned by the operation."	^signature returnParameter type equivalentType typeKind</body><body package="DST_Core">resultDef	"The resultDef attribute identifies the definition of the returned type."	^signature returnParameter type equivalentType baseType</body><body package="DST_Core">resultDef: anIDLType 	"Setting the resultDef attribute updates the result attribute."	self notYetImplemented</body></methods><methods><class-id>DST.DSToperation</class-id> <category>printing</category><body package="DST_Core">attrAndTypeString	"return a string with the operation attribute and the result 	type of the receiver"	| tempStream |	tempStream := (String new: 80) writeStream.	self isNormal ifFalse: [tempStream nextPutAll: self mode asLowercase; nextPut: $ ].	tempStream nextPutAll: signature returnParameter IDLTypeName; nextPut: $ .	^tempStream contents</body><body package="DST_Core">hasPragma	"return true if the receiver has a pragma string"	^localOp ~= self defaultOp</body><body package="DST_Core">printContext: attrAndTypeString on: aStream indent: level style: aTextStyleName 	"print the context expression of the receiver"	| tabs tempStream |	(context notNil and: [context isEmpty not])		ifTrue: 			[tabs := level + (self tabFor: attrAndTypeString style: aTextStyleName) + 1.			tempStream := (String new: 80) writeStream.			tempStream nextPutAll: 'context ('; nextPutAll: context first.			2 to: context size do: [:i | tempStream nextPutAll: ', '; nextPutAll: (context at: i)].			tempStream nextPut: $).			aStream crtab: tabs.			(self				stringNeedsFormatting: tempStream contents				indent: tabs				style: aTextStyleName)				ifFalse: [aStream nextPutAll: tempStream contents]				ifTrue: 					[aStream nextPutAll: 'context ('.					aStream nextPutAll: raises first.					2 to: context size do: [:i | aStream nextPut: $,; crtab: tabs + 2; nextPutAll: (context at: i)].					aStream nextPut: $)]]</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the operation on a stream"	| attrAndType |	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	localOp ~= self defaultOp ifTrue: [aStream tab: level; nextPutAll: '#pragma  selector '; nextPutAll: self printName; space; nextPutAll: localOp; cr].	access notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  access '; nextPutAll: self printName; space; nextPutAll: access; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	self printCommentOn: aStream indent: level.	attrAndType := self attrAndTypeString.	self		printOperationHeader: attrAndType		on: aStream		indent: level		style: aTextStyleName.	self		printRaisedExceptions: attrAndType		on: aStream		indent: level		style: aTextStyleName.	self		printContext: attrAndType		on: aStream		indent: level		style: aTextStyleName.	aStream nextPut: $;; cr</body><body package="DST_Core">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'operation ' , self idlName</body><body package="DST_Core">printOperationHeader: attrAndTypeString on: aStream indent: level style: aTextStyleName 	"print the mode and the signature of the receiver"	| tempStream tabs |	tempStream := (String new: 80) writeStream.	tempStream nextPutAll: attrAndTypeString; nextPutAll: name; nextPutAll: ' ('; nextPutAll: signature definitionString; nextPut: $).	aStream tab: level.	(self		stringNeedsFormatting: tempStream contents		indent: level		style: aTextStyleName)		&amp; (signature size &gt; 1) ifFalse: [aStream nextPutAll: tempStream contents]		ifTrue: 			[aStream nextPutAll: attrAndTypeString; nextPutAll: name; nextPutAll: ' ('.			tabs := level + (self tabFor: attrAndTypeString style: aTextStyleName) + 2.			(1 to: signature size - 2)				do: [:i | aStream crtab: tabs; nextPutAll: (signature at: i) definitionString; nextPut: $,].			aStream crtab: tabs; nextPutAll: (signature at: signature size - 1) definitionString; nextPut: $)]</body><body package="DST_Core">printRaisedExceptions: attrAndTypeString on: aStream indent: level style: aTextStyleName 	"print the list of raised exceptions of the receiver"	| tabs tempStream |	(raises notNil and: [raises isEmpty not])		ifTrue: 			[tabs := level + (self tabFor: attrAndTypeString style: aTextStyleName) + 1.			tempStream := (String new: 80) writeStream.			tempStream nextPutAll: 'raises ('; nextPutAll: raises first.			2 to: raises size do: [:i | tempStream nextPutAll: ', '; nextPutAll: (raises at: i)].			tempStream nextPut: $).			aStream crtab: tabs.			(self				stringNeedsFormatting: tempStream contents				indent: tabs				style: aTextStyleName)				ifFalse: [aStream nextPutAll: tempStream contents]				ifTrue: 					[aStream nextPutAll: 'raises ('.					aStream nextPutAll: raises first.					2 to: raises size do: [:i | aStream nextPut: $,; crtab: tabs + 2; nextPutAll: (raises at: i)].					aStream nextPut: $)]]</body><body package="DST_Core">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"publish the operation on a stream"	| attrAndType |	self printCommentOn: aStream indent: level.	attrAndType := self attrAndTypeString.	self		printOperationHeader: attrAndType		on: aStream		indent: level		style: aTextStyleName.	self		printRaisedExceptions: attrAndType		on: aStream		indent: level		style: aTextStyleName.	self		printContext: attrAndType		on: aStream		indent: level		style: aTextStyleName.	aStream nextPut: $;; cr</body></methods><methods><class-id>DST.DSToperation</class-id> <category>initialization</category><body package="DST_Core">cxt: cxt evts: evts params: params id: id type: result attr: attrib 	"initialize the operation named by id with signature consisting of an 	array of typeId symbols"	name := id.	signature := DSTsignature new.	params do: [:p | signature add: p].	signature add: (DSTparameter new			name: #'OP RESULT'			type: result			direction: #OUT).	sync := attrib.	raises := evts.	context := cxt.	localOp := self defaultOp</body><body package="DST_Core">defaultOp	"return a computed local operation selector"	| sel n x | 	sel := nil.	signature parameters		do: 			[:p | 			n := p name asString copy.			n replaceAll: $  with: $_.			n := (self convertSymbol: n) asString.			x := n findLast: [:c | c = $:].			x &gt; 0 ifTrue: [n := n copyFrom: x + 1 to: n size].			sel isNil				ifTrue: [sel := self printName asString unCapitalized , ':']				ifFalse: [sel := sel , n unCapitalized , ':']].	sel ifNil: [sel := self printName asString unCapitalized].	^self convertSymbol: sel</body><body package="DST_Core">initialize	"initialize the operation"	super initialize.	signature := #().	raises := #().	context := #()</body><body package="DST_Core">opSel: localop cxt: cxt evts: evts params: params id: id type: result attr: attrib 	"initialize the operation named by id with signature consisting of an 	array of typeId symbols"	name := id.	signature := DSTsignature new.	params do: [:p | signature add: p].	signature add: (DSTparameter new			name: #'OP RESULT'			type: result			direction: #OUT).	sync := attrib.	raises := evts.	context := cxt.	localOp := self convertSymbol: (localop ifNil: [self defaultOp])</body></methods><methods><class-id>DST.DSToperation</class-id> <category>private</category><body package="DST_Core">callingContext	"Answer the calling context of the receiver." 	"NOTA BENE:  The context answered must be the context 	for either 'NCSClientConversation class&gt;&gt;clientCall:...' or 	'IIOPClientConversation class&gt;&gt;clientCall:...'.  If some other	context is answered, the distributed debugger will fail."	"NOTA BENE: Changes to the implementation of either of the	'clientCall:...' methods may affect the validity of this method."	"NOTA BENE:  The implementation of this method is dependent	on details of the OE implemenatation.  OE optimizations after	VW 3.0 added two intervening contexts between the 'clientCall:...'	context and this context."	self objectEngineImplementationDependent.	^thisContext sender sender sender sender sender sender</body></methods><methods><class-id>DST.DSToperation</class-id> <category>accessing</category><body package="DST_Core">accessRight	^access ifNil: [#noSecurity]</body><body package="DST_Core">accessRight: aString 	access := aString asSymbol</body><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	signature do: [:p | p definedIn: self]</body><body package="DST_Core">exceptionOf: aSymbol 	"Return an exception meta object which has the given print name 	symbol. 	Error if not" 	| ex |	ex := self definingMetaContainer metaObjectOf: aSymbol.	DSTmoduleRepository convenientNameResolution		ifFalse: 			[ex isNil ifTrue: [^nil].			(ex isDSTMetaObject)				ifTrue: [ex := Set with: ex].			^ex inject: Set new				into: 					[:result :mo | 					| m |					m := mo equivalentType.					result add: m; yourself]]		ifTrue: 			[ex := ex equivalentType.			(ex isDSTMetaObject and: [ex isDSTexception])				ifTrue: [^ex]				ifFalse: [self class intfReposError: 0]]</body><body package="DST_Core">findCorbaExceptionFor: anException 	"return the appropriate error so that it can be marshalled on a stream"	| ex errs opErrs param exType |	errs := ORBObject standardExceptions.	ex := errs values detect: [:exmo | exmo errorSignal == anException getSignal]				ifNone: [].	ex isNil		ifFalse: 			[param := anException parameter.			exType := #systemException]		ifTrue: 			[opErrs := Dictionary new.			raises do: [:sy | opErrs add: sy -&gt; (self exceptionOf: sy)].			ex := opErrs detect: [:exmo | exmo errorSignal == anException getSignal]						ifNone: [].			ex isNil				ifFalse: 					[param := anException parameter.					exType := #userException]				ifTrue: 					[ex := errs at: #UNKNOWN.					param := Dictionary with: #minor -&gt; 0 with: #completed -&gt; #COMPLETED_MAYBE.					exType := #systemException]].	^Array		with: ex		with: param		with: exType</body><body package="DST_Core">isNormal	"return if the receiver has default (normal) invocation 	semantics"	^self mode == #NORMAL</body><body package="DST_Core">isOneWay	"return if the receiver has been specified to have the one-way (asynchronous) attribute"	^sync == #ONEWAY</body><body package="DST_Core">localOp	"return the operation's local opselector"	^localOp</body><body package="DST_Core">localOp: aSelector 	"set the operation's local opselector"	localOp := aSelector</body><body package="DST_Core">opSelector	"return the operation's selector"	^name isNil 		ifTrue: ['?']		ifFalse: [name]</body><body package="DST_Core">signature	"Return the signature for the operation. The last parameter is the 	return value."	^signature</body></methods><methods><class-id>DST.DSToperation</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::OperationDef'</body><body package="DST_Core">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	signature do: [:s | s allMetaObjectsInto: aSet]</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #SELECTOR #VERSION #ACCESS) includes: pragma</body><body package="DST_Core">checkReferencesUniqueness	"check if all referenced exceptions can be resolved uniquely" 		[DSTmoduleRepository convenientNameResolution: false.	raises asSet		do: 			[:na | 			| ref |			ref := self exceptionOf: na.			ref size &gt; 1 ifTrue: [Dialog notify: 'Operation ''' , self idlName , ''' raises ambiguous exception ''' , na asString , '''']]]		ensure: [DSTmoduleRepository convenientNameResolution: true]</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Operation</body><body package="DST_Core">registerIdentity	"Register the identity and full name of the receiver in the Interface 	Repository."	"Though very odd but four PIDL operations in CORBA::Object has 	special operator mappings defined by GIOP (CORBA 2.0  section 12.4.1). 	This is the best place that I can think of to insert the mapping"	self definedIn name == #Object		ifTrue:[ self name == #get_interface					ifTrue:[ name := #_interface].				self name == #get_implementation					ifTrue:[ name := #_implementation].				 self name == #is_a					ifTrue:[ name := #_is_a].				self name == #non_existent					ifTrue:[ name := #_not_existent]].	super registerIdentity.</body></methods><methods><class-id>DST.DSToperation</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^signature nonTrivialSignature , self exceptions</body><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^(signature nonTrivialSignature isEmpty &amp; raises isEmpty) not</body></methods><methods><class-id>DST.DSToperation</class-id> <category>marshalling</category><body package="DST_Core">handleErrorResultFrom: aPacket 	"unmarshall the appropriate error result from the 	stream"	| ix ex parm |	ix := aPacket nextUnsignedShort.	self unMarshallServiceContextFrom: aPacket.	ix &gt; 32767		ifTrue: 			[ix := 65536 - ix.			ex := CORBAConstants standardExceptionForIndex: ix]		ifFalse: [ex := self exceptionOf: (raises at: ix)].	parm := ex errorType unMarshall: aPacket.	^ex errorSignal raiseWith: parm errorString: ' '</body><body package="DST_Core">handleFaultResultFrom: aPacket 	"unmarshall the appropriate fault result from the stream"	self class unknownError: 0</body><body package="DST_Core">marshallArguments: argArray on: aStream 	"marshall the arguments onto the stream"	| inArray |	inArray := signature parameters.	argArray size = inArray size		ifTrue: [1 to: inArray size				do: 					[:inx | 					| typ direction |					typ := inArray at: inx.					direction := typ mode.					direction == #IN						ifTrue: [typ marshall: (argArray at: inx)								on: aStream]						ifFalse: [direction == #INOUT ifTrue: [typ marshall: (argArray at: inx) value on: aStream]]]]		ifFalse: [ORBObject badParamError: 0]</body><body package="DST_Core">marshallErrorResult: exception on: aStream 	"marshall the appropriate error result on the stream"	| ex ix errs opErrs param |	errs := CORBAConstants standardExceptions.	ex := errs values detect: [:exmo | exmo errorSignal == exception getSignal]				ifNone: [].	ex isNil		ifFalse: 			[ix := (CORBAConstants indexForStandardException: ex) negated.			param := exception parameter]		ifTrue: 			[opErrs := Dictionary new.			raises do: [:sy | opErrs add: sy -&gt; (self exceptionOf: sy)].			ex := opErrs detect: [:exmo | exmo errorSignal == exception getSignal]						ifNone: [].			ex isNil				ifFalse: 					[ix := raises indexOf: (opErrs keyAtValue: ex).					param := exception parameter]				ifTrue: 					[ex := errs at: #UNKNOWN.					ix := (CORBAConstants indexForStandardException: ex) negated.					param := Dictionary with: #minor -&gt; 0 with: #completed -&gt; #COMPLETED_MAYBE]].	aStream nextPutShort: ix.	self marshallServiceContextForReply: aStream.	ex errorType marshall: param on: aStream</body><body package="DST_Core">marshallResult: result on: aStream withArgs: argArray 	"marshall the results onto the stream"	| restype |	restype := signature returnParameter.	restype isVoid ifFalse: [restype marshall: result on: aStream].	signature parameters keysAndValuesDo: [:i :p | p notIN ifTrue: [p marshall: (argArray at: i) value on: aStream]]</body><body package="DST_Core">marshallServiceContextForReply: aStream 	"marshall the context on the reply stream"	"remove the security context and the debugging context since they 	do not propagate backwards"	| orbCxt |		[orbCxt := Processor activeProcess orbContext.	orbCxt debuggerContext: nil.	orbCxt securityContext: nil.	self class serviceContextListDef marshall: orbCxt serviceContextList on: aStream]		on: Object errorSignal do: [:ex | self class badContextError: 0]</body><body package="DST_Core">marshallServiceContextForRequest: aStream 	"marshall the context on the request stream"	"WARNING: do not change this method without making sure that 	'callingContext' returns the right value"	| orbCxt newCxt |	orbCxt := Processor activeProcess orbContext.	[	Processor activeProcess orbContext: nil.		(DSTModules security isLoaded and: [orbCxt local and: [orbCxt securityContext isNil]])			ifTrue: 				[newCxt := DSTModules security newSecurityContext.				newCxt notNil ifTrue: [orbCxt securityContext: newCxt]].		self class serviceContextListDef marshall: orbCxt serviceContextList on: aStream	] ensure: [Processor activeProcess orbContext: orbCxt]</body><body package="DST_Core">unMarshallArgumentsFrom: aStream 	"unmarshall the arguments from the stream"	^signature parameters collect: [:p | p mode == #IN			ifTrue: [p unMarshall: aStream]			ifFalse: [p mode == #INOUT					ifTrue: [(p unMarshall: aStream) asCORBAParameter]					ifFalse: [nil asCORBAParameter]]]</body><body package="DST_Core">unMarshallResultsFrom: aPacket withArgs: argArray 	"un-marshall the results from the stream"	| paramArray result |	result := signature returnParameter unMarshall: aPacket.	signature outParameters isEmpty		ifFalse: 			[paramArray := signature parameters.			paramArray keysAndValuesDo: [:i :p | p notIN ifTrue: [(argArray at: i)						value: (p unMarshall: aPacket)]]].	^result</body><body package="DST_Core">unMarshallServiceContextFrom: aStream 	"unmarshall the service context from the stream. This method relies 	on the fact that the active process was newly created and has an 	unset ORB context"	| cxtList orbCxt |	cxtList := self class serviceContextListDef unMarshall: aStream.	cxtList isEmpty		ifFalse: 			[orbCxt := Processor activeProcess orbContext.			cxtList do: [:cxt | orbCxt addServiceContext: cxt]]</body></methods><methods><class-id>DST.DSToperation</class-id> <category>testing</category><body package="DST_Core">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/OperationDef:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="DST_Core">isDSToperation	^true</body></methods><methods><class-id>DST.DSToperation</class-id> <category>converting</category><body package="DST_Core">asOperationInfo	"return an operationInfo object for the receiver"	| if |	^DSToperationInfo new		interface: (if := self definingMetaContainer)		operation: self		selector: localOp		opIndex: (if entryPointVector indexOf: localOp)				- 1</body></methods><methods><class-id>DST.DSToperation class</class-id> <category>marshalling</category><body package="DST_Core">contextInterface	"cache and return the interface for marshalling ORBContext strings"	^ContextIF</body><body package="DST_Core">serviceContextListDef	"cache and return the interface for marshalling ORBContext strings"	| fieldArray |	^ServiceContextListDef		ifNil: 			[fieldArray := Array with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #contextId))							with: DSTtypeUnsignedLong new)						with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #contextData))								with: ((DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray)).			ServiceContextListDef := DSTtypeSequence new subtype: ((DSTtypeStructure new) id: #ServiceContext fields: fieldArray; localType: #DSTServiceContext) size: nil]</body></methods><methods><class-id>DST.IDLPrefix</class-id> <category>accessing</category><body package="DST_Core">definingContainer	^definingContainer</body><body package="DST_Core">definingContainer: defContainer 	definingContainer := defContainer</body><body package="DST_Core">prefixString	^prefixString</body><body package="DST_Core">prefixString: aString 	prefixString := aString</body></methods><methods><class-id>DST.IDLPrefix class</class-id> <category>instance creation</category><body package="DST_Core">prefix: aString container: aContainer 	| p |	p := self basicNew.	p prefixString: aString.	aContainer isNil		ifTrue: [p definingContainer: ORBObject repository]		ifFalse: [p definingContainer: aContainer].	^p</body></methods><methods><class-id>DST.DSTEnumerator</class-id> <category>comparing</category><body package="DST_Core">&lt; anEnumerator 	"Answer true if the receiver is equal to aCORBAEnum, otherwise 	answer false"	^self value &lt; anEnumerator value</body><body package="DST_Core">= anEnumeratorOrSymbol 	"Answer true if the receiver is equal to aCORBAEnum, otherwise 	answer false. It should be noted that we allow comparison against 	symbols for migration"	^anEnumeratorOrSymbol class == DSTEnumerator		ifTrue: [name == anEnumeratorOrSymbol name and: [value == anEnumeratorOrSymbol value]]		ifFalse: [name == anEnumeratorOrSymbol]</body><body package="DST_Core">&gt; anEnumerator 	"Answer true if the receiver is equal to aCORBAEnum, otherwise 	answer false"	^self value &gt; anEnumerator value</body><body package="DST_Core">hash	^self value hash</body></methods><methods><class-id>DST.DSTEnumerator</class-id> <category>accessing</category><body package="DST_Core">name	"answer the name"	^name</body><body package="DST_Core">type	"answer the type"	^ORBObject repository lookupId: type</body><body package="DST_Core">value	"answer the integer value of the enumeration"	^value</body></methods><methods><class-id>DST.DSTEnumerator</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print a representation of the receiver"	super printOn: aStream.	aStream nextPutAll: ' (' , self name asString , ')'</body></methods><methods><class-id>DST.DSTEnumerator</class-id> <category>persistence</category><body package="DST_Core">persistentState	"return the persistent state of the receiver"	^Array		with: name		with: value		with: type</body><body package="DST_Core">representBinaryOn: binWriter 	"Represent a DSTEnumeration by its contents (elements). This is called by 	the BOSS when an on object is written to a BOSS stream. Note that 	this process will automatically register the receiver as a persistent 	object. If that stream is subsequently stored in the object database, 	then a tombstone will remain after I am reclaimed which will allow 	me to be resurrected later"	^MessageSend		receiver: self class		selector: #createLike:		argument: self persistentState</body></methods><methods><class-id>DST.DSTEnumerator</class-id> <category>repository</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^self type</body></methods><methods><class-id>DST.DSTEnumerator</class-id> <category>private</category><body package="DST_Core">n: aSymbol v: anInteger t: aDSTtypeEnumeration 	"set the enumeration"	name := aSymbol.	value := anInteger.	type := aDSTtypeEnumeration repositoryId</body></methods><methods><class-id>DST.DSTEnumerator class</class-id> <category>instance creation</category><body package="DST_Core">createLike: anArray 	"create a new instance of the receiver's class with the given 	persistent state. This is called by the BOSS when a new object is to 	be created from a BOSS binary stream. Cause the newly created 	object to replace its resident version, if one exists."	| enumName value type | 	enumName := anArray at: 1.	value := anArray at: 2.	type :=  ORBObject lookupMetaId: (anArray at: 3).	^self name: enumName value: value type: type</body><body package="DST_Core">name: aSymbol value: anInteger type: aDSTtypeEnumeration 	"create a new instance"	^(self basicNew) n: aSymbol v: anInteger t: aDSTtypeEnumeration; yourself</body></methods><methods><class-id>DST.IIOPConnection</class-id> <category>conversations</category><body package="DST_Core">allConversations	"return a list with all active conversations"	| convs | 	convs := Set new.	conversations values do: [:co | convs add: co].	^convs asOrderedCollection</body><body package="DST_Core">conversations	^conversations</body><body package="DST_Core">registerConversation: aConv 	"register the conversation by adding it to the list of conversations for 	this connection"	conversations at: aConv requestId put: aConv</body><body package="DST_Core">unRegisterConversation: aConv 	"unregister the conversation by removing it from the list of 	conversations for this connection. If there are no more conversations, 	shutdown the connection so that the socket may be reused."	conversations removeKey: aConv requestId ifAbsent: [].	conversations isEmpty ifTrue: [self shutDownConnection]</body><body package="DST_Core">unRegisterConversationWithoutShutdown: aConv 	"unregister the conversation by removing it from the list of 	conversations for this connection."	conversations removeKey: aConv requestId ifAbsent: [].</body></methods><methods><class-id>DST.IIOPConnection</class-id> <category>testing</category><body package="DST_Core">isActive	"answer whether or not the connection is active"	^sktAddr isActive</body></methods><methods><class-id>DST.IIOPConnection</class-id> <category>private</category><body package="DST_Core">cancel	"cancel the current connection"	self subclassResponsibility</body><body package="DST_Core">error: aString 	"log this error when the logging is enabled"	| configMgr |	configMgr := ORBDaemon configurationManager.	configMgr logging &gt; 0 ifTrue: [configMgr log: ('\' , aString , '\') withCRs]</body><body package="DST_Core">on: aSocketAccessor 	"initialize a new instance with a socket accessor"	sktAddr := aSocketAccessor.	self initialize</body><body package="DST_Core">readRemainingBytes: aStream 	"get the remaining bytes from the socket for this message"	[(sktAddr notNil and: [sktAddr isActive])		and: [aStream amountRead &lt; aStream msgSize]]		whileTrue: [aStream nextBuffer]</body><body package="DST_Core">sendMessageInIncrements: aCDRStream 	| howManySent index msgSize increment bytes noError |	index := 1.	howManySent := 0.	msgSize := aCDRStream size.	noError := true.	[howManySent &lt; msgSize &amp; noError]		whileTrue: 			[increment := WriteIncrement min: msgSize - howManySent.			bytes := sktAddr						writeFrom: aCDRStream collection						startingAt: index						forSure: increment						wait: self class receiveTimeout * 1000.			howManySent := bytes + howManySent.			bytes = increment				ifTrue: [index := howManySent + 1]				ifFalse: [noError := false]].	^howManySent</body><body package="DST_Core">shutDownConnection	^self subclassResponsibility</body></methods><methods><class-id>DST.IIOPConnection</class-id> <category>startup-shutdown</category><body package="DST_Core">shutDown	"shutdown the connection"	self subclassResponsibility</body><body package="DST_Core">spawnConnectionBroker	"spawn a connection broker"	self subclassResponsibility</body></methods><methods><class-id>DST.IIOPConnection</class-id> <category>accessing</category><body package="DST_Core">peer	^( peer isNil )		ifTrue:	[ peer := sktAddr getPeer ]		ifFalse:	[ peer ]</body><body package="DST_Core">sendLock	sendLock == nil ifTrue: [sendLock := Semaphore forMutualExclusion].	^sendLock</body></methods><methods><class-id>DST.IIOPConnection</class-id> <category>messages</category><body package="DST_Core">sendCloseConnectionToPeer	"Send the IIOP close connection message to my peer connection. This 	is a low level connection management message that informs the peer 	that the connection will be presently shutdown.  Generally this is sent 	when the ORB is shut down, on a connection timeout, or on a com 	error."	| request msgStream |	(sktAddr notNil and: [sktAddr isActive])		ifTrue: 			[request := GIOPMessage newCloseConnection.			request msgSize: 0.			msgStream := request messageContents.			sktAddr				writeFrom: msgStream collection				startingAt: 1				forSure: msgStream size				wait: self class receiveTimeout * 1000]</body></methods><methods><class-id>DST.IIOPConnection</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	conversations := Dictionary new.	sendLock := Semaphore forMutualExclusion</body></methods><methods><class-id>DST.IIOPConnection</class-id> <category>printing</category><body package="DST_Core">printOn: aStream	aStream nextPutAll: self class name.	sktAddr getPeer printBytesOn: aStream</body></methods><methods><class-id>DST.IIOPConnection class</class-id> <category>class initialization</category><body package="DST_Core">initialize	"initialize the receiver"	WriteIncrement := 4096</body><body package="DST_Core">initialize: aDaemon 	"initialize the receiver"	ActiveDaemon := aDaemon</body><body package="DST_Core">release	"release class variables"	ActiveDaemon :=WriteIncrement :=nil</body></methods><methods><class-id>DST.IIOPConnection class</class-id> <category>accessing</category><body package="DST_Core">receiveTimeout	"Answer the maximum timeout.  Initialize to the shown 	number of seconds if nil.  Users who wish to run long-	lasting connections should reset the receive timeout to	a higher value, or, in extreme cases, to 'Infinity positive'."	^ReceiveTimeOut == nil		ifTrue:	[ 600 ]		ifFalse:	[ ReceiveTimeOut ]</body><body package="DST_Core">receiveTimeout: seconds	"Set the maximum timeout."	"IIOPConnection receiveTimeout: Infinity positive."	ReceiveTimeOut :=  seconds.	( ReceiveTimeOut == Infinity positive )		ifTrue:	[ IIOPConnectionReaper startup ]		ifFalse:	[ IIOPConnectionReaper shutdown ]</body><body package="DST_Core">writeIncrement: anInteger 	"set the write increment for outgoing messages, the value is rounded 	to a multiple of 8"	(anInteger isInteger)		ifTrue: [WriteIncrement := anInteger - (anInteger \\ 8)]</body></methods><methods><class-id>DST.IIOPConnection class</class-id> <category>instance creation</category><body package="DST_Core">new: aSocketAccessor	^self basicNew on: aSocketAccessor</body></methods><methods><class-id>DST.IIOPServerConnection</class-id> <category>startup-shutdown</category><body package="DST_Core">shutDown	"terminate the broker"	[broker terminate]		on: Object errorSignal do: [:ex | (sktAddr notNil and: [sktAddr isActive])			ifTrue: [sktAddr close]]</body><body package="DST_Core">spawnConnectionBroker	"This idler process is responsible for watching for incoming 	messages on the socket accessor"	broker := [			[| inbuf count request receiveMsg |			receiveMsg := true.						[Processor yield.			receiveMsg and: [sktAddr isActive]]				whileTrue: [					[inbuf := ByteArray new: GIOPMessage headerSize.					count := sktAddr								readInto: inbuf								start: 1								for: inbuf size								wait: self class receiveTimeout * 1000.					count == inbuf size						ifTrue: 							[request := GIOPMessage messageHeader: inbuf socketAccessor: sktAddr.							request isValidMessage								ifTrue: [request isValidRequest										ifTrue: [(IIOPServerConversation new: self)												processRequest: request]										ifFalse: 											["Could be a valid error 											message or possible 											condition for abortive 											disconnect"											self error: 'invalid request'.											receiveMsg := false]]								ifFalse: 									["send error message and do 									abortive disconnect"									self error: 'invalid message'.									receiveMsg := false]]						ifFalse: [receiveMsg := false]]						on: sktAddr errorReporter errorSignal						do: 							[:ex | 							self error: 'client connection lost'.							receiveMsg := false]]]				ensure: [self shutDownConnection]]				forkAt: ORBObject orbPriority</body></methods><methods><class-id>DST.IIOPServerConnection</class-id> <category>private</category><body package="DST_Core">shutDownConnection	"signal all clients in the conversation list - which will result in comm 	failures, then do the necessary cleanup"	conversations values do: [:conv | conv cancel].	self isActive		ifTrue: 			[self sendCloseConnectionToPeer.			sktAddr close].	ActiveDaemon unRegisterServerConnection: self.	self shutDown</body></methods><methods><class-id>DST.IIOPServerConnection</class-id> <category>message handlers</category><body package="DST_Core">cancelReply: aRequestId 	"tag this request as cancelled by notifying the appropriate server 	conversation"	| conv |	conv := conversations at: aRequestId ifAbsent: [nil].	conv notNil ifTrue: [conv canceled: true]</body><body package="DST_Core">sendReply: aServConv 	"Send the reply immediately.  If the write fails, shut down the connection 	so it can be reused.  If the conversationn involves a special selector, mark	the server connection as special.	AR52524  Added in the sendLock so the the cleint and server connection deal properely with threaded calls S.G. and M.K"	sendLock critical: [| bytes msgStream |		( aServConv canceled )			ifFalse:	[	( sktAddr isActive )							ifTrue:	[						msgStream := aServConv reply messageContents.					msgStream size &gt; WriteIncrement						ifTrue: [bytes := self sendMessageInIncrements: msgStream]						ifFalse: [bytes := sktAddr									writeFrom: msgStream collection									startingAt: 1									forSure: msgStream size									wait: self class receiveTimeout * 1000].					bytes = msgStream size						ifFalse: 							[self shutDownConnection.							ORBObject transientError: 0]]].		self unRegisterConversationWithoutShutdown: aServConv ]</body></methods><methods><class-id>DST.DSTtypeTemplate</class-id> <category>copying</category><body package="DST_Core">copyDeclaratorOn: aType 	"make a copy of a declarator type, remembering that the declarator will point 	back to the type object which contained it as a declarator. We must avoid 	an infinite loop. Array, &amp; pointer types must overload"	| obj |	obj := super copyDeclaratorOn: aType .	subtype == aType		ifTrue: [obj subtype: nil]		ifFalse: [obj subtype: (subtype copyDeclaratorOn: aType)].	^obj</body></methods><methods><class-id>DST.DSTtypeTemplate</class-id> <category>printing</category><body package="DST_Core">IDLTypeName	"return the printable name of the receiver's IDL type ie the type to be 	actually marshalled in the NCS packet"	^self definitionString</body><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	[aStream nextPutAll: self definitionString , ' ' , self idlName]		on: Object errorSignal do: [:x | ^super printOn: aStream]</body></methods><methods><class-id>DST.DSTtypeTemplate</class-id> <category>accessing</category><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	subtype notNil ifTrue: [subtype definedIn: aMetaObject]</body><body package="DST_Core">nAry	"template types used as targets of relationships are nAry"	^true</body><body package="DST_Core">subtype	"return the subtype of the receiver"	^subtype</body><body package="DST_Core">subtype: atype	"set the subtype of the receiver"	subtype := atype</body></methods><methods><class-id>DST.DSTtypeTemplate</class-id> <category>initialization</category><body package="DST_Core">sizes: sizes ident: aSymbol 	"Initialize instance variables for a fixed sized array"	name := aSymbol.	size := sizes at: 1.	sizes size = 1		ifTrue: [subtype := nil]		ifFalse: [subtype := self class new sizes: (sizes copyFrom: 2 to: sizes size)						ident: '']</body><body package="DST_Core">subtype: aType size: aSize	"initialize the subtype and size of the receiver"	subtype := aType.	size := aSize.</body></methods><methods><class-id>DST.DSTtypeTemplate</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^subtype nonTrivialDeclarators asOrderedCollection</body><body package="DST_Core">childName	"return the name to be used for the receiver in a browser window"	^declarators isNil		ifTrue: [self definitionString]		ifFalse: [super childName]</body></methods><methods><class-id>DST.DSTtypeTemplate</class-id> <category>repository</category><body package="DST_Core">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	subtype allMetaObjectsInto: aSet</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#CLASS) includes: pragma</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_array</body><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^2</body><body package="DST_Core">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^subtype].	anInt = 2 ifTrue: [^size].	self error: #Bounds</body></methods><methods><class-id>DST.DSTInterceptor</class-id> <category>sorting</category><body package="DST_Core">orderOfExecution	^self subclassResponsibility</body></methods><methods><class-id>DST.DSTInterceptor class</class-id> <category>instance creation</category><body package="DST_Core">construct	^self new</body></methods><methods><class-id>DST.DSTInterceptor class</class-id> <category>sorting</category><body package="DST_Core">orderOfExecution	^self subclassResponsibility</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>override inheritance</category><body package="DST_Core">abstractClassId	"pass this operation to the referenced object"	^self perform: #abstractClassId on: #()</body><body package="DST_Core">acl	"pass this operation to the referenced object"	^self perform: #acl on: #()</body><body package="DST_Core">addAccess: aCollection user: aUserId 	"pass this operation to the referenced object"   	^self perform: #addAccess:user: on: (Array with: aCollection with: aUserId)</body><body package="DST_Core">classObject	"pass this operation to the referenced object"	^self perform: #classObject on: #()</body><body package="DST_Core">destroy	"pass this operation to the referenced object"	self perform: #destroy on: #().	super destroy</body><body package="DST_Core">getMemoryUtilization	"return memory utilization information"	^self perform: #getMemoryUtilization on: #()</body><body package="DST_Core">inspector	"pass this operation to the referenced object"	^self perform: #inspector on: #()</body><body package="DST_Core">isKindOf: aClass 	"Return if the receiver responds to the given selector"	| mdi |	^(super isKindOf: aClass)		or: [(mdi := aClass basicNew CORBAType repositoryId) == interfaceId or: [(self interface allSuperiors collect: [:su | su repositoryId])					includes: mdi]]</body><body package="DST_Core">productName	"pass this operation to the referenced object"	^self perform: #productName on: #()</body><body package="DST_Core">removeAccess: aCollection user: aUserId 	"pass this operation to the referenced object"   	^self perform: #removeAccess:user: on: (Array with: aCollection with: aUserId)</body><body package="DST_Core">removeUserFromACL: aUserId 	"pass this operation to the referenced object"	^self perform: #removeUserFromACL: on: (Array with: aUserId)</body><body package="DST_Core">respondsTo: aSelector 	"Return if the receiver responds to the given selector"	^(super respondsTo: aSelector)		or: [(self interface findOpBySelector: aSelector) notNil]</body><body package="DST_Core">session	"pass this operation to the referenced object"	^self perform: #session on: #()</body><body package="DST_Core">setAccess: aCollection user: aUserId 	"pass this operation to the referenced object"   	^self perform: #setAccess:user: on: (Array with: aCollection with: aUserId)</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>accessing</category><body package="DST_Core">interface	"Answer the local interface meta object of the receiver. Answer the value 	of interface."  	interface isNil ifTrue: [interface := ORBObject lookupMetaId: interfaceId].	^interface</body><body package="DST_Core">interface: anInterface	"Set the value of interface."	interface := anInterface</body><body package="DST_Core">interfaceId	"Answer the value of interfaceId."	^interfaceId</body><body package="DST_Core">isDSTObjRef	"True if I'm a DST object reference"	^true</body><body package="DST_Core">isLocal	"ObjRefs denote remote objects"	^false</body><body package="DST_Core">isRemote	"ObjRefs in general denote remote objects"	^true</body><body package="DST_Core">objectId	"Answer the value of the objectId."	objectId == nil ifTrue: [objectId := super objectId].	^objectId</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>DependentObject</category><body package="DST_Core">addDependent: anObject 	"Add anObject as one of the receiver's dependents."	^(self interface findOpBySelector: #addDependent:) isNil		ifTrue: [super addDependent: anObject]		ifFalse: [(self perform: #addDependent: on: (Array with: anObject)) asLocal]</body><body package="DST_Core">changeRequest	"The receiver wants to change; check with all dependents that it is 	OK."	^(self interface findOpBySelector: #changeRequest) isNil		ifTrue: [super changeRequest]		ifFalse: [self perform: #changeRequest on: #()]</body><body package="DST_Core">changeRequest: anAspectSymbol 	"The receiver wants to change this aspect; check with all dependents 	that it is OK."	^(self interface findOpBySelector: #changeRequest:) isNil		ifTrue: [super changeRequest: anAspectSymbol]		ifFalse: [self perform: #changeRequest: on: (Array with: anAspectSymbol)]</body><body package="DST_Core">changeRequestFrom: aRequestorObject 	"Receiver wants to change; check with all dependents (other than 	requestor) that it is OK."	^(self interface findOpBySelector: #changeRequestFrom:) isNil		ifTrue: [^super changeRequestFrom: aRequestorObject]		ifFalse: [self perform: #changeRequestFrom: on: (Array with: aRequestorObject)]</body><body package="DST_Core">expressInterestIn: anAspect for: anObject sendBack: aSelector 	"Arrange to receive a message with aSelector when anAspect changes 	at anObject"	^(self interface findOpBySelector: #expressInterestIn:for:sendBack:) isNil		ifTrue: [super				expressInterestIn: anAspect				for: anObject				sendBack: aSelector]		ifFalse: [self perform: #expressInterestIn:for:sendBack: on: (Array					with: anAspect					with: anObject					with: aSelector)]</body><body package="DST_Core">removeDependent: anObject 	"Remove the argument, anObject, as one of the receiver's 	dependents."	^(self interface findOpBySelector: #removeDependent:) isNil		ifTrue: [super removeDependent: anObject]		ifFalse: [(self perform: #removeDependent: on: (Array with: anObject)) asLocal]</body><body package="DST_Core">retractInterestIn: anAspect for: anObject 	"Arrange to receive a message with aSelector when anAspect changes 	at anObject"	^(self interface findOpBySelector: #retractInterestIn:for:) isNil		ifTrue: [super retractInterestIn: anAspect for: anObject]		ifFalse: [(self perform: #retractInterestIn:for: on: (Array with: anAspect with: anObject)) asLocal]</body><body package="DST_Core">update: anAspectSymbol 	"Receive a change notice from an object of whom the receiver is a 	dependent. The argument anAspectSymbol is typically a Symbol that 	indicates what change has occurred. The default behavior is to do 	nothing; a subclass might want to change itself in some way."	^(self interface findOpBySelector: #update:) isNil		ifTrue: [^super update: anAspectSymbol]		ifFalse: [^self perform: #update: on: (Array with: anAspectSymbol)]</body><body package="DST_Core">update: anAspectSymbol with: aParameter 	"Receive a change notice from an object of whom the receiver is a 	dependent. The argument anAspectSymbol is typically a Symbol that 	indicates what change has occurred and aParameter is additional 	information. The default behavior is to do nothing; a subclass might 	want to change itself in some way."	^(self interface findOpBySelector: #update:with:) isNil		ifTrue: [super update: anAspectSymbol with: aParameter]		ifFalse: [self perform: #update:with: on: (Array with: anAspectSymbol with: aParameter)]</body><body package="DST_Core">update: anAspectSymbol with: aParameter from: aSender 	"Receive a change notice from an object, denoted by aSender, of 	whom the receiver is a dependent. The argument anAspectSymbol is 	typically a Symbol that indicates what change has occurred and 	aParameter is additional information. The default behavior is to do 	nothing; a subclass might want to change itself in some way."	^(self interface findOpBySelector: #update:with:from:) isNil		ifTrue: [super				update: anAspectSymbol				with: aParameter				from: aSender]		ifFalse: [self perform: #update:with:from: on: (Array					with: anAspectSymbol					with: aParameter					with: aSender)]</body><body package="DST_Core">updateRequest	"Default behavior is to grant update requests; a subclass might want 	to override this behavior if it is in the middle of making another 	change."	^(self interface findOpBySelector: #updateRequest) isNil		ifTrue: [super updateRequest]		ifFalse: [self perform: #updateRequest on: #()]</body><body package="DST_Core">updateRequest: anAspectSymbol 	"Default behavior is to grant update requests for the aspect; a 	subclass might want to override this behavior if it is in the middle 	of making another change."	^(self interface findOpBySelector: #updateRequest:) isNil		ifTrue: [super updateRequest: anAspectSymbol]		ifFalse: [self perform: #updateRequest: on: (Array with: anAspectSymbol)]</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>repository</category><body package="DST_Core">clearInterfaceReferencesTo: anInterface 	"clear any references to the given interface"	interface == anInterface ifTrue: [interface := nil].</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>distribution-required</category><body package="DST_Core">CORBAInterface	"return an instance of the DSTinterface which defines the behavior of the 	receiver when passed as a CORBA object"	^self interface</body><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^self interface</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>persistence</category><body package="DST_Core">asInactiveObjRef	"any ObjRef is a valid Inactive ObjRef"	^self</body><body package="DST_Core">representBinaryOn: binWriter 	"Represent an ORBPersistentObjRef by a constructor which will 	rebuild either an objref or the object itself"	^MessageSend		receiver: self class		selector: #findOrCreateOnArray:		argument: (Array				with: self objectId				with: interfaceId				with: self adapterId				with: self interoperableObjRefProfiles)</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print a representation of the receiver on the stream"	[aStream nextPutAll: 'a remote "' , self interface printName , '"']		on: Object errorSignal do: [:ex | super printOn: aStream]</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>initialization</category><body package="DST_Core">objectId: anId adapterId: anAdapterId interfaceId: anId2 	"initialize the objectId and interfaceId instance variables"	self		objectId: anId		interfaceId: anId2</body><body package="DST_Core">objectId: anId interfaceId: anId2 	"initialize the objectId and interfaceId instance variables"	objectId := anId.	interfaceId := anId2</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>message handlers</category><body package="DST_Core">doesNotUnderstand: aMessage 	"Search the call chain for the ORBObject subclass which is initiating 	the call. Pass that object as the from object."    	^self perform: aMessage selector on: aMessage arguments</body><body package="DST_Core">getOpInfo: opSelector	"return the operation information for the selector"	| opInfo interfaceObject |      	(interfaceObject := self interface) isNil		ifTrue: [^ORBObject intfReposError: 0].	(opInfo := interfaceObject findOpBySelector: opSelector) isNil 		and: [(opInfo := (ORBObject lookupMetaId: #'SmalltalkSpecific::SmalltalkObject')					findOpBySelector: opSelector) isNil 		ifTrue: [^ORBObject badOperationError: 0]].	^opInfo</body><body package="DST_Core">perform: opSelector on: parameters 	"invoke the operation on the remote object and wait for a return"	| opInfo result failed clientClass |	failed := false.	opInfo := self getOpInfo: opSelector.	clientClass := ORBDaemon chooseTransportFor: self.	^clientClass notNil		ifTrue: 			[[result := clientClass						clientCall: opInfo						to: self						withParameters: parameters]				on: ORBObject commFailureSignal do: [:ex | Retrying					ifTrue: [failed := true]					ifFalse: [ex reject]].			failed				ifTrue: [(ORBDaemon chooseTransportFor: self withClientClass: clientClass)						clientCall: opInfo						to: self						withParameters: parameters]				ifFalse: [result]]		ifFalse: [nil]</body></methods><methods><class-id>DST.DSTObjRef</class-id> <category>CORBA Object</category><body package="DST_Core">duplicate	"defined in CORBA::Object PIDL. defer to my superclass"   	^super duplicate</body><body package="DST_Core">getImplementation	"pass this operation to the referenced object's psuedo object"	^self perform: #getImplementation on: #()</body><body package="DST_Core">getInterface	"pass this operation to the referenced object's psuedo object"   	^self perform: #getInterface on: #()</body><body package="DST_Core">hash: upperBound 	"pass this operation to the referenced object's psuedo object"   	^self perform: #hash: on: (Array with: upperBound)</body><body package="DST_Core">isA: interfaceIdString 	"pass this operation to the referenced object's psuedo object"   	^self perform: #isA: on: (Array with: interfaceIdString)</body><body package="DST_Core">isEquivalent: anObject 	"return true if the receiver is the same as anObject false otherwise. Check 	for identity then pass on to te referenced object."	self == anObject		ifTrue: [^true]		ifFalse: [^self perform: #isEquivalent on: (Array with: anObject)]</body><body package="DST_Core">isNil	"return true if the object ID is the Nil ID"	^self objectId isNilId</body><body package="DST_Core">nonExistent	"pass this operation to the referenced object's psuedo object. catch any 	exceptions and return false if the exception is the 	CORBA::OBJECT_NOT_EXIST exception"	[^self perform: #nonExistent on: #()] on: ORBObject invObjrefSignal 		do:  [:x | ^true]</body><body package="DST_Core">release	"defined in CORBA::Object PIDL. defer to my superclass"   	^super release</body></methods><methods><class-id>DST.DSTObjRef class</class-id> <category>repository</category><body package="DST_Core">clearInterfaceReferencesTo: anInterface 	"clear any references to the given interface"	self allInstances do: [:ref | ref clearInterfaceReferencesTo: anInterface]</body><body package="DST_Core">initializeRepositoryInformation	"clear any references to interfaces"	self allInstances do: [:ref | ref interface: nil]</body></methods><methods><class-id>DST.DSTObjRef class</class-id> <category>utilities</category><body package="DST_Core">destroyRegisteredObjectsForClass: aClass 	"administration utility to destroy the objects in the registered objects 	table for a specific class of object"	self registeredObjects do: [:obj | (obj isKindOf: aClass)			ifTrue: [self unRegisterObject: obj]]</body><body package="DST_Core">printClassProfile: aCollection 	"print a population breakdown of the elements of the collection"	| c3 c4 i c5 ass classes printed |	classes := #(#ORBObject #DSTPresenter) select: [:cn | (cn asQualifiedReference valueOrDo: []) notNil].	printed := Set new.	classes		do: 			[:cn | 			| col cl|			cl := cn asQualifiedReference value.			Transcript show: '	' , cn , ' (or subclasses) Objects: ' , (col := aCollection select: [:o | o isKindOf: cl]) size printString; cr.			printed addAll: col].	Transcript show: '	Other Objects: ' , (c3 := aCollection reject: [:o | printed includes: o]) size printString; cr.	c4 := Dictionary new.	c3		do: 			[:obj | 			i := c4 at: obj class ifAbsent: [c4 at: obj class put: 0].			c4 at: obj class put: i + 1].	c5 := c4 associations asSortedCollection: [:a :b | a value &gt; b value].	1 to: (5 min: c5 size)		do: 			[:j | 			ass := c5 at: j.			Transcript show: '		' , ass key name , ' Objects: ' , ass value printString; cr].	Transcript show: '	Total Objects: ' , aCollection size printString; cr</body><body package="DST_Core">printStatistics	"print object reference statistics on the transcript"	ObjectMemory compactingGC.	Transcript cr; show: 'Object map composition'; cr.	self printClassProfile: Objects values.	Transcript show: 'ObjectId map composition'; cr.	self printClassProfile: ObjectIds keys.	Transcript show: 'RegisteredObjects'; cr.	self printClassProfile: RegisteredObjects.	self allSubclasses do: [:cl | Transcript show: 'Index of ' , cl name , ' = ' , cl index size printString; cr]</body></methods><methods><class-id>DST.DSTObjRef class</class-id> <category>creation-registration</category><body package="DST_Core">findOrCreateOnArray: anArray 	"If the object is already registered, return that object, else return the 	appropriate kind of objref"	| id if ad tps |	id := anArray at: 1.	if := anArray at: 2.	ad := anArray at: 3.	tps := anArray at: 4.	^(ORBDaemon isLocalAdapter: ad)		ifTrue: [DSTObjRefInactive				findOrCreateOnOID: id				AID: ad				MDI: if]		ifFalse: [DSTObjRefRemote findOrCreateOnProfiles: tps MDI: if]</body><body package="DST_Core">findOrCreateOnOID: anObjectId AID: anAdapterId MDI: anInterfaceId 	"find or create a new object reference"	| objref obj | 	^(obj := self objectOf: anObjectId) isNil		ifTrue: 			[objref := self new						objectId: anObjectId						adapterId: anAdapterId						interfaceId: anInterfaceId.			self registerObject: objref as: anObjectId.			objref]		ifFalse: [obj asRemotable]</body><body package="DST_Core">index	"Answer the value of index."	^self subclassResponsibility</body><body package="DST_Core">indexObject: obj as: anId 	"index the local object by giving it a particular objectId"	self index at: anId put: obj.	^obj</body><body package="DST_Core">indexOf: uuId 	"return the local object associated with uuId"	| res |	res := self index at: uuId ifAbsent: [nil].	^res = 0		ifTrue: [nil]		ifFalse: [res]</body><body package="DST_Core">objectIdOf: anObj 	"return the uuId associated with the local object. Assign if necessary"	| id |	^anObj isNil		ifTrue: [NCSuuid nilId]		ifFalse: [ObjectIds at: anObj				ifAbsent: 					[id := ORBObject newId.					self registerObject: anObj as: id]]</body><body package="DST_Core">objectOf: uuId 	"return the local object associated with uuId"	^Objects at: uuId ifAbsent: [self searchBlock value: uuId]</body><body package="DST_Core">registerObject: obj 	"add the object to the set of registered objects"	(obj isMemberOf: ORBDeadObject)		ifTrue: [Dialog onDebugNotify: 'Attempting to register a Dead Object'].	((obj isMemberOf: DSTObjRefRemote)		or: [obj isMemberOf: DSTObjRefLocal])		ifFalse: [RegisteredObjects add: obj].	^obj</body><body package="DST_Core">registerObject: obj as: anId 	"register the local object by giving it a particular objectId"	(obj isDSTObjRef)		ifTrue: [self indexObject: obj as: anId]		ifFalse: 			[Objects at: anId put: obj.			ObjectIds at: obj put: anId].	^anId</body><body package="DST_Core">searchBlock	"return a block which indicates which index tables to search in addition to Objects"	^[:id | self indexOf: id]</body><body package="DST_Core">unRegisterObject: anObject 	"remove the object from the set of registered objects"	| oid |	RegisteredObjects remove: anObject ifAbsent: [].	oid := ObjectIds at: anObject ifAbsent: [Objects keyAtValue: anObject ifAbsent: [nil]].	Objects removeKey: oid ifAbsent: [].	ObjectIds removeKey: anObject ifAbsent: [].	DSTObjRefWidened unRegisterWidenedObjects: anObject</body></methods><methods><class-id>DST.DSTObjRef class</class-id> <category>initialization</category><body package="DST_Core">flushObjectIds	ObjectIds := ObjectIdsClass new: 2111</body><body package="DST_Core">flushObjectMaps	"remove unneeded entries from the object map dictionaries. Here we 	zap the set of registered objects and the objectId map so that they 	can be reclaimed by the GC if no references remain"	RegisteredObjects := IdentitySet new: 2111.	DSTObjRefWidened flushInstanceMap.	ObjectMemory compactingGC</body><body package="DST_Core">flushObjects	Objects := ObjectsClass new: 2111</body><body package="DST_Core">initialize	"initialize the class variables"	self flushObjects.	self flushObjectIds.	RegisteredObjects := IdentitySet new: 2111.	LifeCycleObjects := IdentitySet new: 2111.	Retrying := false</body><body package="DST_Core">release	"release the class variables"	Objects := nil.	ObjectIds := nil.	RegisteredObjects := nil.	LifeCycleObjects := nil.	Retrying := nil</body></methods><methods><class-id>DST.DSTObjRef class</class-id> <category>accessing</category><body package="DST_Core">defaultIndexClass	^WeakValueDictionary</body><body package="DST_Core">indexClass	^indexClass ifNil: [ self defaultIndexClass ]</body><body package="DST_Core">indexClass: aClass"	aClass &lt;Class&gt; the class of collection used for the Index shared class variable"	indexClass := aClass</body><body package="DST_Core">isAccessable: anObject	"return if the receiver is accessable by a remote system"	^(self registeredObjects includes: anObject) or: [ObjectIds includesKey: anObject]</body><body package="DST_Core">objectMap	^Objects</body><body package="DST_Core">registeredObjects	^RegisteredObjects</body><body package="DST_Core">retrying	"get the retrying flag"	^Retrying</body><body package="DST_Core">retrying: bool	"set the retrying flag"	Retrying := bool == true</body></methods><methods><class-id>DST.DSTObjRefNarrowed</class-id> <category>accessing</category><body package="DST_Core">adapterId	"Answer the value of adapterId."	^object adapterId</body><body package="DST_Core">bindings	"answer the bindings for this object reference"	^object bindings</body><body package="DST_Core">interoperableObjRefProfiles	^object interoperableObjRefProfiles</body><body package="DST_Core">isLocal	"Narrowed ObjRefs denote remote objects"	^false</body><body package="DST_Core">isRemote	"Narrowed ObjRefs denote remote objects"	^true</body><body package="DST_Core">object: anObject	"set the object to which the reciever refers"	object := anObject</body><body package="DST_Core">objectId	"Answer the value of the objectId."	^object objectId</body></methods><methods><class-id>DST.DSTObjRefNarrowed</class-id> <category>local-remote</category><body package="DST_Core">asLocal	"return the receiver"	^self</body></methods><methods><class-id>DST.DSTObjRefNarrowed</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print a representation of the receiver on the stream"	aStream nextPutAll: 'a narrowed ' , self interface printName</body></methods><methods><class-id>DST.DSTObjRefNarrowed class</class-id> <category>creation-registration</category><body package="DST_Core">findOrCreateOn: anObject asInterfaceId: anId 	"Create an instance of a narrowed object reference to refer to the 	given object by the given interface" 	| objref array i uuid |	array := InstanceMap at: anObject ifAbsent: [nil].	array isNil		ifTrue: [array := Array new: 10]		ifFalse: [array do: [:el | (el notNil and: [el interfaceId == anId])					ifTrue: [^el]]].	objref := self basicNew.	uuid := ORBObject newId.	objref objectId: uuid interfaceId: anId.	objref object: anObject.	i := array indexOf: nil				ifAbsent: 					[array growToAtLeast: array size * 2.					array size].	array at: i put: objref.	InstanceMap at: anObject put: array.	^self indexObject: objref as: uuid.</body><body package="DST_Core">index	"Answer the value of index."	^Index</body><body package="DST_Core">unRegisterNarrowedObjects: anObject 	"remove the object from the set of registered objects"	InstanceMap removeKey: anObject ifAbsent: []</body></methods><methods><class-id>DST.DSTObjRefNarrowed class</class-id> <category>initialization</category><body package="DST_Core">flushIndex	"flush the class index"	"self flushIndex"	Index := self indexClass new: 2011</body><body package="DST_Core">flushInstanceMap	"since the instance map keys are objects for which widened objrefs 	have been generated, we check to see if any of the widened objrefs 	remain. If they have all been reclaimed, then we can safely remove 	the key from the map and allow that object to possibly be reclaimed 	as well. If any widened refs remain, then they will hold existence 	ensuring links to the key object and it cannot be deleted."	| newMap |	newMap := IdentityDictionary new.	InstanceMap associationsDo: [:ass | (ass value select: [:el | el notNil]) isEmpty ifFalse: [newMap add: ass]].	InstanceMap := newMap</body><body package="DST_Core">initialize	InstanceMap := IdentityDictionary new.	self flushIndex</body><body package="DST_Core">release	InstanceMap := Index := nil</body></methods><methods><class-id>DST.CDRStream</class-id> <category>marshalling</category><body package="DST_Core">decodeLong: ba 	"decode a long integer from the byte array"	| result |	result := 0.	1 to: 4 do: [:i | result := (result bitShift: 8)					+ (ba at: i)].	^result</body><body package="DST_Core">decodeLongLong: ba 	"decode a long integer from the byte array"	| result |	result := 0.	1 to: 8 do: [:i | result := (result bitShift: 8)					+ (ba at: i)].	^result</body><body package="DST_Core">decodeShort: ba 	"decode a short integer from the byte array"	^((ba at: 1) asInteger bitShift: 8)		+ (ba at: 2) asInteger</body><body package="DST_Core">encodeLong: anInt 	"encode the long integer in a byte array"	| ba |	ba := ByteArray new: 4.	ba at: 1 put: ((anInt bitShift: -24)			bitAnd: 255).	ba at: 2 put: ((anInt bitShift: -16)			bitAnd: 255).	ba at: 3 put: ((anInt bitShift: -8)			bitAnd: 255).	ba at: 4 put: (anInt bitAnd: 255).	^ba</body><body package="DST_Core">nextBoolean	"return the next boolean in the receiver"	self nextByte = 0		ifTrue: [^false]		ifFalse: [^true]</body><body package="DST_Core">nextByte	"return the next byte from the receiver"	^self next</body><body package="DST_Core">nextBytes: n	"return the next n bytes from the receiver"	| ba |	ba := ByteArray new: n.	^self nextBytesInto: ba.</body><body package="DST_Core">nextBytesInto: aByteObject	| size |	size := aByteObject size.	position + size &lt;= readLimit		ifTrue: [ aByteObject					replaceBytesFrom: 1					to: size					with: collection					startingAt: position+1.				position := position + size]		ifFalse: [1 to: size do: [:i |  aByteObject byteAt: i put: self next]].</body><body package="DST_Core">nextCharacter	"return the next character in the receiver"	^self nextByte fromCORBACharCode</body><body package="DST_Core">nextDouble	"return the next double in the receiver."	| res |	self alignToDouble.	res := 0.0d copy.	res whileMutableDo: [ | size |		size := res basicSize.		self mustSwapBytes			ifTrue: [				size to: 1 by: -1 do: [ :i |					res basicAt: i put: self next ] ]  			ifFalse: [				1 to: size do: [ :i |					res basicAt: i put: self next ] ] ].	^res</body><body package="DST_Core">nextFixed: digits scale: scale	"Read the next fixed point number of the CDRStream"	|  byte sign aNumber |	aNumber := 0.	byte := self next.	(digits // 2) timesRepeat: [		aNumber := aNumber * 10 + (byte bitShift: -4).		aNumber := aNumber * 10 + (byte bitAnd: 15).		byte := self next.].	sign := (byte bitAnd: 15) == 12			ifTrue:[1]			ifFalse:[-1].	aNumber := aNumber * 10 + (byte bitShift: -4).	aNumber := (aNumber * (10 ** scale negated)) asFixedPoint: (scale &gt; 0		ifTrue:[scale]		ifFalse:[0]).	^sign * aNumber</body><body package="DST_Core">nextFloat	"return the next float in the receiver."	| res |	self alignToLong.	res := 0.0 copy.	res whileMutableDo: [ | size |		size := res basicSize.		self mustSwapBytes			ifTrue: [				size to: 1 by: -1 do: [ :i |					res basicAt: i put: self next ] ]  			ifFalse: [				1 to: size do: [ :i |					res basicAt: i put: self next ] ] ].	^res</body><body package="DST_Core">nextLocalType	"We put the local type information for type retention."	^nil</body><body package="DST_Core">nextLong	"return the next long integer in the receiver"	| ival |	ival := self nextUnsignedLong.	(ival &gt; 536870911 and: [ival &gt; 2147483647])		ifTrue: [^(4294967296 - ival) negated]		ifFalse: [^ival]</body><body package="DST_Core">nextLongDouble	"return the next long double in the receiver."	| res |	self alignToLongDouble.	res := DSTLongDouble new.	1 to: res basicSize do: [:i | res basicAt: i put: self next].	self mustSwapBytes ifTrue: [res reverseByteOrder].	^res</body><body package="DST_Core">nextLongLong	"return the next long long integer in the receiver"	"536870911 is the largest possible SmallInteger (faster &gt; test)"	"9223372036854775807 = 7FFF FFFF FFFF FFFF Hex"	"18446744073709551616 = 1 0000 0000 0000 0000 Hex"	| ival |	ival := self nextUnsignedLongLong.	(ival &gt; 536870911 and: [ival &gt; 9223372036854775807])		ifTrue: [^(18446744073709551616 - ival) negated]		ifFalse: [^ival]</body><body package="DST_Core">nextObjectReference: anInterface 	"unmarshall the object reference in the receiver"	| tps reposId mdi | 	reposId := self nextString.	tps := IORDef unMarshall: self.	^tps isEmpty		ifTrue: [nil]		ifFalse: 			[reposId isEmpty				ifTrue: ["is this what we should do here?"					mdi := anInterface repositoryId]				ifFalse: [mdi := RepositoryId fromString: reposId].			DSTObjRefRemote findOrCreateOnProfiles: tps MDI: mdi]</body><body package="DST_Core">nextPutBoolean: aBoolean 	"marshall the boolean in the receiver"	"Must raise an exception if non-Boolean"	self nextPut: (aBoolean ifTrue: [1] ifFalse: [0])</body><body package="DST_Core">nextPutByte: aByte	"marshall the byte in the receiver"	self nextPut: aByte</body><body package="DST_Core">nextPutBytes: aByteObject 	| size |	size := aByteObject size.	position + size &lt;= writeLimit		ifFalse: 			[collection growToAtLeast: collection size + size.			writeLimit := collection size].	collection		replaceBytesFrom: position + 1		to: position + size		with: aByteObject		startingAt: 1.	position := position + size</body><body package="DST_Core">nextPutCharacter: aCharacter 	"marshall the character in the receiver"	"Must raise exception if non-character (currently	via MNU on toCORBACharCode"	self nextPutByte: aCharacter toCORBACharCode</body><body package="DST_Core">nextPutDouble: aDouble 	"marshall the double float in the receiver."	| param |	self padToDouble.	BigEndian		ifTrue: [param := aDouble]		ifFalse: 			[param := aDouble copy.			param reverseByteOrder].	1 to: param basicSize do: [:i | self nextPut: (param basicAt: i)]</body><body package="DST_Core">nextPutEncapsulationHeader	| pos |	pos := self position.	self nextPutUnsignedLong: 0.	self nextPutBoolean: self byteOrder.	^pos</body><body package="DST_Core">nextPutFixed: aFixedPoint digits: digits scale: scale	"Put aFixedPoint on to the CDRStream.  Note that the CORBA fixed type of 	limited scale, and a prescribed decimal point position, unlike the FixedPoint	in Smalltalk.  Hence, if the scale is non-negative we round down to obtain	the IDL prescribed precision."	| denom n aStream  low byte numerator denominator base |	denom := 10 ** scale.	(aFixedPoint * denom) abs &lt; (10 ** digits)		ifFalse:[self error: 'Out of the fixed range'].	numerator := aFixedPoint numerator.	denominator := aFixedPoint denominator.	base := 10.	n :=  numerator * denom + (denominator bitShift: -1) // denominator.	numerator &lt; 0		ifTrue: 			[low := 13.			n := n negated]		ifFalse:[low := 12].	aStream := WriteStream on: (ByteArray new: 32).	(digits // 2 + 1)  timesRepeat: [		byte := low bitOr: (( n \\ base) bitShift: 4).		aStream nextPut: byte.		n := n // base.		low := n \\ base.		n := n // base].	self nextPutBytes: aStream contents reverse.</body><body package="DST_Core">nextPutFloat: aFloat 	"marshall the float in the receiver."	| param |	self padToLong.	BigEndian		ifTrue: [param := aFloat]		ifFalse: 			[param := aFloat copy.			param reverseByteOrder].	1 to: param basicSize do: [:i | self nextPut: (param basicAt: i)]</body><body package="DST_Core">nextPutLocalType: aString 	"Localtype is not used for CDR marshalling of typecode information"</body><body package="DST_Core">nextPutLong: anInt 	"marshall the long integer in the receiver"	"Must raise exception if not an integer (currently via MNU on 	bitShift:)"	self padToLong.	writeLimit - position &gt;= 4		ifFalse: 			[collection growToAtLeast: (writeLimit + 4).			writeLimit := collection size].	collection at: position + 1 put: ((anInt bitShift: -24)			bitAnd: 255).	collection at: position + 2 put: ((anInt bitShift: -16)			bitAnd: 255).	collection at: position + 3 put: ((anInt bitShift: -8)			bitAnd: 255).	collection at: (position := position + 4) put: (anInt bitAnd: 255)</body><body package="DST_Core">nextPutLongDouble: aLongDouble 	"marshall the long double float in the receiver."	| param |	self padToLongDouble.	BigEndian		ifTrue: [param := aLongDouble]		ifFalse: 			[param := aLongDouble copy.			param reverseByteOrder].	1 to: param basicSize do: [:i | self nextPut: (param basicAt: i)]</body><body package="DST_Core">nextPutLongLong: aLongLong 	"marshall the long integer in the receiver"	"Must raise exception if not an integer (currently via nextPutLong:)"	self padToLongLong.	writeLimit - position &gt;= 8		ifFalse: 			[collection growToAtLeast: collection size + 8.			writeLimit := collection size].	collection at: position + 1 put: ((aLongLong bitShift: -56)			bitAnd: 255).	collection at: position + 2 put: ((aLongLong bitShift: -48)			bitAnd: 255).	collection at: position + 3 put: ((aLongLong bitShift: -40)			bitAnd: 255).	collection at: position + 4 put: ((aLongLong bitShift: -32)			bitAnd: 255).	collection at: position + 5 put: ((aLongLong bitShift: -24)			bitAnd: 255).	collection at: position + 6 put: ((aLongLong bitShift: -16)			bitAnd: 255).	collection at: position + 7 put: ((aLongLong bitShift: -8)			bitAnd: 255).	collection at: (position := position + 8) put: (aLongLong bitAnd: 255)</body><body package="DST_Core">nextPutObjectReference: aParameter 	"marshall the object reference in the receiver"	aParameter isNil		ifTrue: 			[self nextPutString: ''.			IORDef marshall: #() on: self]		ifFalse: 			[self nextPutString: aParameter CORBAInterface repositoryId.			IORDef marshall: aParameter interoperableObjRefProfiles on: self]</body><body package="DST_Core">nextPutShort: anInt	"marshall the short integer in the receiver"	"Must raise exception if not an integer (currently via MNU on bitShift:)"	self padToShort; 		nextPut: ((anInt bitShift: -8) bitAnd: 255); 		nextPut: (anInt bitAnd: 255)</body><body package="DST_Core">nextPutString: aString 	"Marshall the parameter onto the stream"	"Must raise exception is not string or nil"	aString == nil		ifTrue: [self nextPutLong: 1; nextPut: 0]		ifFalse: 			[self nextPutLong: aString size + 1.			self nextPutBytes: aString toCORBACharCodes.			self nextPut: 0]</body><body package="DST_Core">nextPutUUID: auuid	"return the next UUID in the receiver"	self padToLong; nextPutAll: auuid.</body><body package="DST_Core">nextPutUnsignedLong: anInt 	"marshall the long integer in the receiver"	"Must raise exception if not an integer (currently via nextPutLong:)"	self nextPutLong: anInt</body><body package="DST_Core">nextPutUnsignedLongLong: anInt 	"marshall the long integer in the receiver"	"Must raise exception if not an integer (currently via nextPutLong:)"	self nextPutLongLong: anInt</body><body package="DST_Core">nextPutUnsignedShort: anInt 	"marshall the short integer in the receiver"	"Must raise exception if not an integer (currently via nextPutShort:)"	self nextPutShort: anInt</body><body package="DST_Core">nextPutWideCharacter: aCharacter 	"marshall the character in the receiver"	"Must raise exception if non-character"	"Description from class character:		For character codes between 0 and 65535 (16rFFFF), the Unicode		Character Code Standard is used.  Characters with codes between 		0 and 255 also coincide with the ISO 8859-1 standard. At present, 		mappings for Characters greater than 65535 are undefined.	It is assumed that if ISO 8859-1 characters are most common in	an application, the type char is used instead of wchar. So here	we assume that characters are two byte wide (or user defined	encoding)"	| anInt len |	len := ORBObject wideCharLength.	anInt := aCharacter asInteger.	self padToWideChar.	self nextPut: len.	BigEndian 		ifTrue: [			len-1 to: 1 by: -1 do: [:i |  				self nextPut: ((anInt bitShift: -8*i) bitAnd: 255).].			self nextPut: (anInt bitAnd: 255)]		ifFalse:  [			self nextPut: (anInt bitAnd: 255).			1 to: len-1 do: [:i |  				self nextPut: ((anInt bitShift: -8*i) bitAnd: 255).]]</body><body package="DST_Core">nextPutWideString: aString 	"Marshall the parameter onto the stream"	"Must raise exception is not string or nil"	| bytes str |	aString == nil		ifTrue: [self nextPutUnsignedLong: 1]		ifFalse: 			[str := aString asTwoByteString.			"unclear if length is bytes or wide chars"			self nextPutUnsignedLong: str size + 1.			BigEndian ifFalse:  [					str := str copy.					str reverseByteOrder].			bytes := str copy changeClassToThatOf: #[].			self nextPutBytes: bytes].	"unclear if terminating null is a byte or a wide char"	self nextPutBytes: (ByteArray new: ORBObject wideCharLength withAll: 0)</body><body package="DST_Core">nextShort	"return the next short integer in the receiver"	| ival |	ival := self nextUnsignedShort.	ival &gt; 32767		ifTrue: [^(65536 - ival) negated]		ifFalse: [^ival]</body><body package="DST_Core">nextString	"unMarshall a string"	| s result | 	s := self nextUnsignedLong.	^s &gt; 0		ifTrue: 			[result := String new: s-1.			self nextBytesInto: result.			self next = 0 ifFalse: [self error: 'String not null terminated'].			result]		ifFalse: ['']</body><body package="DST_Core">nextUUID	"return the next uuid in the receiver"	| uuid |	self alignToLong.	uuid := self				next: 16				into: (NCSuuid new: 16)				startingAt: 1.	^NCSuuid intern: uuid</body><body package="DST_Core">nextUnsignedLong	"return the next long integer in the receiver"	| ba b0 b1 b2 w |	self alignToLong.	self isBigEndian		ifTrue: [(readLimit - position) &gt;= 4				ifTrue: [b0 := collection at: position + 1.  						b1 := collection at: position + 2.  						b2 := collection at: position + 3.    						w := collection at: (position := position + 4)]				ifFalse: [b0 := self next.  						b1 := self next.  						b2 := self next.  						w := self next].				"Following sequence minimizes LargeInteger arithmetic for small results."				b2=0 ifFalse: [w := (b2 bitShift: 8) + w].				b1=0 ifFalse: [w := (b1 bitShift: 16) + w].				b0=0 ifFalse: [w := (b0 bitShift: 24) + w].				^w]		ifFalse: [ba := ByteArray new: 4.				4 to: 1 by: -1 do: [:i | ba at: i put: self next].				^self decodeLong: ba].</body><body package="DST_Core">nextUnsignedLongLong	"return the next long integer in the receiver"	| ba b0 b1 b2 b3 b4 b5 b6 w |	self alignToLongLong.	self isBigEndian		ifFalse: [ba := ByteArray new: 8.				8 to: 1 by: -1 do: [:i | ba at: i put: self next].				^self decodeLongLong: ba]		ifTrue: [(readLimit - position) &gt;= 8				ifTrue: [						b0 := collection at: position + 1.  						b1 := collection at: position + 2.  						b2 := collection at: position + 3.    						b3 := collection at: position + 4.  						b4 := collection at: position + 5.  						b5 := collection at: position + 6.						b6 := collection at: position + 7.    						w := collection at: (position := position + 8)]				ifFalse: [						b0 := self next.  						b1 := self next.  						b2 := self next.  						b3 := self next.  						b4 := self next.  						b5 := self next.  						b6 := self next.						w := self next].				"Following sequence minimizes LargeInteger arithmetic for small results."				b6=0 ifFalse: [w := (b6 bitShift: 8) + w].					b5=0 ifFalse: [w := (b5 bitShift: 16) + w].				b4=0 ifFalse: [w := (b4 bitShift: 24) + w].				b3=0 ifFalse: [w := (b3 bitShift: 32) + w].				b2=0 ifFalse: [w := (b2 bitShift: 40) + w].				b1=0 ifFalse: [w := (b1 bitShift: 48) + w].				b0=0 ifFalse: [w := (b0 bitShift: 56) + w].				^w]</body><body package="DST_Core">nextUnsignedShort	"return the next short integer in the receiver"	| ba |	self alignToShort.	ba := ByteArray new: 2.	self isBigEndian		ifTrue: [1 to: 2 do: [:i | ba at: i put: self next]]		ifFalse: [2 to: 1 by: -1 do: [:i | ba at: i put: self next]].	^self decodeShort: ba</body><body package="DST_Core">nextWideCharacter	"return the next wide character in the receiver"	"The first byte is the number of bytes that form the character."	| nBytes bytes result |	self alignToWideChar.	nBytes := self next.	bytes := ByteArray new: nBytes.	self mustSwapBytes		ifTrue: [nBytes to: 1 by: -1 do: [:i | bytes at: i put: self next]]		ifFalse: [1 to: nBytes do: [:i | bytes at: i put: self next]].	result := 0.	1 to: nBytes do: [:i | result := (result bitShift: 8) + (bytes at: i)].	^Character value: result</body><body package="DST_Core">nextWideString	"unMarshall a wide string"	| nWideChars bytes | 	"unclear if the length is in bytes or wide chars"	nWideChars := self nextUnsignedLong.	^(nWideChars &gt; 0)		ifTrue: 			[bytes := ByteArray new: (nWideChars-1)* ORBObject wideCharLength.			self nextBytesInto: bytes.			"unclear if terminating null is a byte or a wide char"			self nextBytes: ORBObject wideCharLength.			self mustSwapBytes 				ifTrue: [bytes := self  class reverseWideStringByteOrder: bytes].			bytes asStringEncoding:  ORBObject wideCharEncoding]		ifFalse: ['']</body><body package="DST_Core">setEncapsulationLength: anInteger 	"set the length of an encapsulated typecode in this stream"	| pos | 	pos := position.	self position: anInteger.	self nextPutUnsignedLong: pos - anInteger - 4.	position := pos</body></methods><methods><class-id>DST.CDRStream</class-id> <category>alignment</category><body package="DST_Core">alignToDouble	"advance the position to the Double alignment boundary"	[(position bitAnd: 7) isZero | self atEnd]		whileFalse: [self next]</body><body package="DST_Core">alignToLong	"advance the position to the Long alignment boundary"	[(position bitAnd: 3) == 0  or: [position &gt;= readLimit]]		whileFalse: [position := position + 1]</body><body package="DST_Core">alignToLongDouble	"advance the position to the Long Double alignment boundary"	[(position bitAnd: 7) isZero | self atEnd]		whileFalse: [self next]</body><body package="DST_Core">alignToLongLong	"advance the position to the Long Long alignment boundary"	[(position bitAnd: 7) isZero | self atEnd]		whileFalse: [self next]</body><body package="DST_Core">alignToShort	"advance the position to the Short alignment boundary"	[(position bitAnd: 1) isZero | self atEnd]		whileFalse: [self next]</body><body package="DST_Core">alignToWideChar	"advance the position to the WideChar alignment boundary"	[(position bitAnd: 1) isZero | self atEnd]		whileFalse: [self next]</body><body package="DST_Core">padToDouble	"advance the position to the Double alignment boundary"	[(position bitAnd: 7) isZero]		whileFalse: [self nextPut: 0]</body><body package="DST_Core">padToLong	"advance the position to the Long alignment boundary"	(position bitAnd: 3) == 0 ifTrue: [^self].	self nextPut: 0.	(position bitAnd: 3) == 0 ifTrue: [^self].	self nextPut: 0.	(position bitAnd: 3) == 0 ifTrue: [^self].	self nextPut: 0.	(position bitAnd: 3) == 0 ifTrue: [^self].</body><body package="DST_Core">padToLongDouble	"advance the position to the Long Double alignment boundary"	[(position bitAnd: 7) isZero]		whileFalse: [self nextPut: 0]</body><body package="DST_Core">padToLongLong	"advance the position to the LongLong alignment boundary"	[(position bitAnd: 7) isZero]		whileFalse: [self nextPut: 0]</body><body package="DST_Core">padToShort	"advance the position to the Short alignment boundary"	[(position bitAnd: 1) isZero]		whileFalse: [self nextPut: 0]</body><body package="DST_Core">padToWideChar	"advance the position to the Wide Char alignment boundary"	[(position bitAnd: 1) isZero]		whileFalse: [self nextPut: 0]</body></methods><methods><class-id>DST.CDRStream</class-id> <category>accessing</category><body package="DST_Core">byteOrder	"return the byte ordering of the message, in cases for a new stream 	we set the byte order to false for all platforms"	byteOrder == nil ifTrue: [byteOrder := false].	^byteOrder</body><body package="DST_Core">byteOrder: aBoolean 	"set the byte ordering of the message"	byteOrder := aBoolean</body><body package="DST_Core">collection	^collection</body><body package="DST_Core">next	"Answer the next object in the Stream represented by the receiver. Fail if	the collection of this stream is not an Array or a String. Fail if the	stream is positioned at its end, or if the position is out of bounds in the	collection."	position &gt;= readLimit		ifTrue: [^self pastEnd]		ifFalse: [^collection at: (position := position + 1)]</body><body package="DST_Core">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next anInteger elements of the receiver into aSequenceableCollection 	starting at startIndex in aSequenceableCollection. Answer aSequenceableCollection."	| howManyRead |	howManyRead := 0.	[howManyRead &lt; anInteger] whileTrue:		[| increment newHowManyRead |		self atEnd ifTrue: [^Stream incompleteNextCountSignal raiseRequestWith: howManyRead].		increment := (readLimit - position) min: (anInteger - howManyRead).		newHowManyRead := howManyRead + increment.		aSequenceableCollection			replaceFrom: startIndex + howManyRead			to: startIndex + newHowManyRead - 1			with: collection			startingAt: position + 1.		position := position + increment.		howManyRead := newHowManyRead].	^aSequenceableCollection</body><body package="DST_Core">next: anInteger putAll: aSequenceableCollection startingAt: startIndex 	"Store the anInteger elements of aSequenceableCollection starting	at startIndex into the next anInteger elements of the receiver.	Answer aSequenceableCollection"	| newPosition |	anInteger &gt;= 1 ifFalse: [^aSequenceableCollection].	newPosition := position + anInteger.	newPosition &gt; writeLimit		ifTrue: [collection growToAtLeast: newPosition.				writeLimit := collection size].	collection		replaceFrom: position+1		to: newPosition		with: aSequenceableCollection		startingAt: startIndex.	position := newPosition.	^aSequenceableCollection</body><body package="DST_Core">nextPut: anObject	"Insert the argument at the next position in the Stream represented by the	receiver. Answer the argument. Fail the primitive if:		1. The collection of this stream is not a ByteString. 		2. The stream is positioned at its end.		3. The position is out of bounds in the collection.  		4. The argument is not of the right type for the collection."	position = writeLimit		ifTrue: [self pastEndPut: anObject]		ifFalse:			[collection at: (position := position + 1) put: anObject].	^anObject</body></methods><methods><class-id>DST.CDRStream</class-id> <category>testing</category><body package="DST_Core">isBigEndian	"answer the byte ordering of the elements - a value of zero indicates 	big-endian byte ordering"  	^self byteOrder ifTrue: [false] ifFalse: [true]</body><body package="DST_Core">mustSwapBytes 	^self isBigEndian ~~ BigEndian</body><body package="DST_Core">notReadingFromRemoteIR"This check allows the type code unmarshaling machinery to distinguish the case when we're in the process of reading DST specific typecode format used for fetching type definitions from a remote Interface Repository (IR)."	^true</body></methods><methods><class-id>DST.CDRStream</class-id> <category>positioning</category><body package="DST_Core">position: anInteger 	"Set position to anInteger as long as anInteger is within the bounds 	of the receiver's contents. If it is not, provide an error notification."	(anInteger &gt;= 0 and: [anInteger &lt;= collection size])		ifTrue: 			[anInteger &gt;= readLimit ifTrue: [readLimit := anInteger].			position := anInteger]		ifFalse: [^self positionOutOfBoundsError: anInteger]</body></methods><methods><class-id>DST.CDRStream class</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	BigEndian := UninterpretedBytes isBigEndian</body><body package="DST_Core">reInitialize	"re-initialize the receiver"	| fieldArray |	self initialize.	fieldArray := Array with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #tag))					with: DSTtypeUnsignedLong new)				with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #profileData))						with: ((DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray)).	IORDef := DSTtypeSequence new subtype: ((DSTtypeStructure new) id: #TaggedProfile fields: fieldArray; localType: #IORTaggedProfile) size: nil</body></methods><methods><class-id>DST.CDRStream class</class-id> <category>accessing</category><body package="DST_Core">iorDef	^IORDef</body></methods><methods><class-id>DST.CDRStream class</class-id> <category>private</category><body package="DST_Core">reverseWideStringByteOrder: bytes	"self reverseWideStringByteOrder: 		(ByteArray withAll: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16))"	| len |	len := ORBObject wideCharLength.	1 to: bytes basicSize - 1 by: len do:		[:i |	| tmp |		0 to: len/2 -1 do:[:j |			tmp := bytes basicAt: i+j.			bytes basicAt: i+j put: (bytes basicAt: i+len-j-1).			bytes basicAt: i+len-j-1 put: tmp]].	^bytes</body></methods><methods><class-id>DST.DSTTypeCodeStream</class-id> <category>marshalling</category><body package="DST_Core">nextLocalType	"We put the local type information for type retention."	^self nextString</body><body package="DST_Core">nextPutLocalType: aString 	"We put the local type information for type retention."	self nextPutString: aString</body></methods><methods><class-id>DST.DSTTypeCodeStream</class-id> <category>testing</category><body package="DST_Core">notReadingFromRemoteIR"This check allows the type code unmarshaling machinery to distinguish the case when we're in the process of reading DST specific typecode format used for fetching type definitions from a remote Interface Repository (IR)."	^false</body></methods><methods><class-id>DST.DSTtypeSequence</class-id> <category>SequenceDef</category><body package="DST_Core">bound	"The bound attribute specifies the maximum number of elements in 	the sequence. A bound of zero indicates an unbounded sequence."	^size</body><body package="DST_Core">bound: newBound 	"Setting the bound attribute updates the type attribute."	self notYetImplemented</body><body package="DST_Core">elementType	"The type of the elements of the sequence is described by 	elementType and identified by elementTypeDef."	^subtype equivalentType baseType</body><body package="DST_Core">elementTypeDef	"The type of the elements of the sequence is described by 	elementType and identified by elementTypeDef."	^subtype equivalentType baseType</body><body package="DST_Core">elementTypeDef: anIDLType 	"Setting the elementTypeDef attribute also updates the elementType 	attribute. The type attribute is also updated."	self notYetImplemented</body></methods><methods><class-id>DST.DSTtypeSequence</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 		"Marshall the parameter onto the stream. Subclasses must 	overload, for sequences we disregard the localClass"	"canMarshall = Dictionary or doesn't MNU on 'do:'"	| sz |	(size == nil or: [size = 0 or: [ aParameter size &lt;= size]])		ifFalse: [^self class marshallError: 0].	aStream nextPutUnsignedLong: (sz := aParameter size).	sz == 0 ifTrue: [^self].	(aParameter class == ByteArray and: [subtype class == DSTtypeOctet or: [subtype class == DSTtypeCharacter]])		ifTrue: [aStream nextPutAll: aParameter]		ifFalse: [(aParameter isDictionary)				ifTrue: [aParameter associationsDo: [:x | subtype boldMarshall: x on: aStream]]				ifFalse: [aParameter do: [:x | subtype boldMarshall: x on: aStream]]]</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else.	Modified in 5i with the final 'and:' clause, to test the subtype, so that unions of 	sequences get marshalled with some degree of discrimination."			^( aParameter isCollection 		and: [ size == nil or: [size == 0 or: [ aParameter size &lt;= size ] ] ] )		and: [ aParameter size &lt; 1 or: [ subtype marshallMatch: ( aParameter at: 1) ] ]</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	| pos |	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	pos := aStream nextPutEncapsulationHeader.	subtype marshallTypeCode: aDictionary on: aStream.	aStream nextPutUnsignedLong: (size == nil ifTrue: [0] ifFalse: [size]).	aStream setEncapsulationLength: pos</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result actual |	actual := aStream nextUnsignedLong.	(size notNil and: [size &gt; 0 and: [actual &gt; size]])		ifTrue: [self error: 'Sequence has too many elements'].	aClass == nil		ifTrue: [result := OrderedCollection new: actual.				1 to: actual do: [:i | result add: (subtype unMarshall: aStream)].				^result]		ifFalse: [(aClass == ByteArray and:				[subtype class == DSTtypeOctet or: [subtype class == DSTtypeCharacter]])					ifTrue: [^aStream nextAvailable: actual]].	result := aClass new: actual.	(result isKindOf: ArrayedCollection)		ifTrue: [1 to: actual do: [:i | result at: i put: (subtype unMarshall: aStream)]]		ifFalse: [1 to: actual do: [:i | result add: (subtype unMarshall: aStream)]].	^result</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream	"unmarshall the type code of the receiver."	| byteOrder |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	subtype := self class unMarshallTypeCode: aDictionary from: aStream.	size := aStream nextUnsignedLong.	aStream byteOrder: byteOrder</body></methods><methods><class-id>DST.DSTtypeSequence</class-id> <category>printing</category><body package="DST_Core">definitionString	"return my IDL type definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: name; nextPutAll: '&lt;'; nextPutAll: subtype definitionString.	size isNil | (size = 0) ifFalse: [aStream nextPutAll: ', '; nextPutAll: size printString].	aStream nextPut: $&gt;.	^aStream contents</body></methods><methods><class-id>DST.DSTtypeSequence</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CompoundDefs::SequenceCompoundDef'</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Sequence</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_sequence</body><body package="DST_Core">typeParameter: anInt 	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^subtype].	anInt = 2 ifTrue: [^size isNil			ifTrue: [0]			ifFalse: [size]].	self error: #Bounds</body></methods><methods><class-id>DST.DSTtypeSequence</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'sequence'</body></methods><methods><class-id>DST.DSTvalueExpr</class-id> <category>operators</category><body package="DST_Core">and	"and the left and right arguments and return the result"	| l r |	l := left value.	r := right value.	^l == true		ifTrue: [r]		ifFalse: [l == false				ifTrue: [l]				ifFalse: [l asInteger bitAnd: r asInteger]]</body><body package="DST_Core">bool	"return the right argument as the result of a boolean literal"	^right value</body><body package="DST_Core">characterLiteral	^right</body><body package="DST_Core">complement	"complement the right argument and return the result"	| v |	v := right value.	v isInteger ifTrue: [^v bitInvert].	(v == true or: [v == false])		ifTrue: [^v not].	self notify: 'Complement operator applied to illegal value'</body><body package="DST_Core">concat	"concat the left and right arguments and return the result"	| l r |	l := left value.	r := right value.	^l , r</body><body package="DST_Core">div	"divide the left and right arguments and return the result"	^left value / right value</body><body package="DST_Core">fixedPointLiteral	^right</body><body package="DST_Core">floatLiteral	^right</body><body package="DST_Core">minus	"subtract the left and right arguments and return the result"	^left value - right value</body><body package="DST_Core">mod	"mod the left and right arguments and return the result"	^left value \\ right value</body><body package="DST_Core">mult	"multiply the left and right arguments and return the result"	^left value * right value</body><body package="DST_Core">neg	"negate the right argument and return the result"	^right value negated</body><body package="DST_Core">nest	"return the right argument as the result"	^right value</body><body package="DST_Core">not	"complement the right argument and return the result"	^right value not</body><body package="DST_Core">or	"or the left and right arguments and return the result"	| l r |	l := left value.	r := right value.	^l == true		ifTrue: [l]		ifFalse: [l == false				ifTrue: [r]				ifFalse: [l asInteger bitOr: r asInteger]]</body><body package="DST_Core">plus	"add the left and right arguments and return the result"	^left value + right value</body><body package="DST_Core">shLeft	"shift the left value left by the right argument and return the result"	^left value bitShift: right value</body><body package="DST_Core">shRight	"shift the left value right by the right argument and return the result"	^left value bitShift: right value negated</body><body package="DST_Core">stringLiteral	^right</body><body package="DST_Core">unaryPlus	^right value</body><body package="DST_Core">xor	"xor the left and right arguments and return the result"	| l r |	l := left value.	r := right value.	^l == true		ifTrue: [l]		ifFalse: [l == false				ifTrue: [r]				ifFalse: [l asInteger bitXor: r asInteger]]</body></methods><methods><class-id>DST.DSTvalueExpr</class-id> <category>accessing</category><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	(left respondsTo: #definedIn:) ifTrue: [left definedIn: aMetaObject].	(right respondsTo: #definedIn:) ifTrue: [right definedIn: aMetaObject].</body><body package="DST_Core">value	"return the value of the receiver"	^self perform: opSel</body></methods><methods><class-id>DST.DSTvalueExpr</class-id> <category>initialization</category><body package="DST_Core">op: aStr sel: aSel right: rExpr left: lExpr 	"initialize a new instance"	opString := aStr.	opSel := aSel.	left := lExpr.	right := rExpr</body></methods><methods><class-id>DST.DSTvalueExpr</class-id> <category>printing</category><body package="DST_Core">asIDLString	"return the IDL string representation of the receiver"	opSel == #bool ifTrue: [^opString].	opSel == #nest ifTrue: [^'(' , right asIDLString , ')'].	opSel == #concat ifTrue: [^left asIDLString , ' ' , right asIDLString].	opSel == #floatLiteral ifTrue: [^left].	opSel == #fixedPointLiteral ifTrue: [^left].	opSel == #characterLiteral ifTrue: [^'''' , left , ''''].	opSel == #stringLiteral ifTrue: [^left asIDLString].	(#(#neg #complement #unaryPlus) includes: opSel)		ifTrue: [^opString , ' ' , right asIDLString].	^left asIDLString , ' ' , opString , ' ' , right asIDLString</body></methods><methods><class-id>DST.DSTvalueExpr</class-id> <category>repository</category><body package="DST_Core">allMetaObjectsInto: aSet 	"add all of the referenced metaobjects to the set"	(left respondsTo: #allMetaObjectsInto:)		ifTrue: [left allMetaObjectsInto: aSet].	(right respondsTo: #allMetaObjectsInto:)		ifTrue: [right allMetaObjectsInto: aSet]</body></methods><methods><class-id>DST.DSTvalueExpr class</class-id> <category>creation</category><body package="DST_Core">op: aStr sel: aSel right: rExpr left: lExpr	"create a new instance"	^self new op: aStr sel: aSel right: rExpr left: lExpr</body></methods><methods><class-id>DST.DSTparameter</class-id> <category>attributes</category><body package="DST_Core">direction	"returns the parameter direction, as a lowercase string"	^direction asString asLowercase</body><body package="DST_Core">notIN	"return if the receiver is not an IN mode parameter"	^direction ~= #IN</body><body package="DST_Core">notOUT	"return if the receiver is not an OUT mode parameter"	^direction ~= #OUT</body></methods><methods><class-id>DST.DSTparameter</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParam on: aStream	"marshall an instance of the receiver's type on the stream"   	type boldMarshall: aParam on: aStream</body><body package="DST_Core">unMarshall: aStream	"unmarshall an instance of the receiver's type from the stream"	^type unMarshall: aStream</body></methods><methods><class-id>DST.DSTparameter</class-id> <category>printing</category><body package="DST_Core">IDLTypeName	"return the type name of the receiver"	^type IDLTypeName</body><body package="DST_Core">definitionString	"return the IDL definition of the receiver"	| aStream |	aStream := (String new: 80) writeStream.	self isResult ifFalse: [aStream nextPutAll: self direction; nextPut: $ ].	aStream nextPutAll: self IDLTypeName; nextPut: $ ; nextPutAll: self printName.	^aStream contents</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print the parameter on a stream. Note: This is called in text 	view mode during repository browsing"	self printCommentOn: aStream indent: level.	aStream nextPutAll: self definitionString</body><body package="DST_Core">printName	"return the name of the receiver"	^name printName</body><body package="DST_Core">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: direction , '  ' , type idlName , '  ' , name printName</body></methods><methods><class-id>DST.DSTparameter</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^type nonTrivialDeclarators asOrderedCollection</body><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^(#DST , (self isResult			ifTrue: ['RESULT']			ifFalse: [direction]) , 'parameter') asSymbol</body><body package="DST_Core">isResult	"Return true if this is a operation result"	^self printName == #'OP RESULT'</body></methods><methods><class-id>DST.DSTparameter</class-id> <category>Parameter Def</category><body package="DST_Core">description	"return an operation description"	^(DSTparameterDescription new) 		name: self printName; 		type: type equivalentType; 		typeDef: type equivalentType; 		mode: direction; 		yourself</body><body package="DST_Core">mode	"return the direction of the receiver"	^direction</body><body package="DST_Core">name	"return the receiver's name"	^name printName</body><body package="DST_Core">type	"return the type of the receiver"	^type</body></methods><methods><class-id>DST.DSTparameter</class-id> <category>accessing</category><body package="DST_Core">definedIn: aMetaObject 	"set the defining metaObject of the receiver"	super definedIn: aMetaObject.	name definedIn: aMetaObject.	type definedIn: aMetaObject</body><body package="DST_Core">isVoid	"return if the type of the parameter is void"	^type isMemberOf: DSTtypeVoid</body></methods><methods><class-id>DST.DSTparameter</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Contained'</body><body package="DST_Core">allMetaObjectsInto: aSet 	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet."	name allMetaObjectsInto: aSet."	type allMetaObjectsInto: aSet</body><body package="DST_Core">typeKind        "Return the type code kind of a parameter."        ^type typeKind</body></methods><methods><class-id>DST.DSTparameter</class-id> <category>initialization</category><body package="DST_Core">name: aName type: aType direction: aDirection 	"called by the IDL compiler: initialize these values of the parameter"	direction := aDirection.	type  := aType.	aName isSymbol		ifTrue: [name := (DSTtypeNamed new) initialize: aName; definedIn: self; yourself]		ifFalse: [name := aName]</body></methods><methods><class-id>DST.DSTMetaContainer</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Container'</body><body package="DST_Core">addMetaObject: aMetaObject 	"add the meta-object to the container"	contents add: aMetaObject.	self registerMetaObject: aMetaObject.	aMetaObject definedInOnly: self</body><body package="DST_Core">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	contents do: [:mo | mo allMetaObjectsInto: aSet].</body><body package="DST_Core">interfaceOf: aSymbol 	"Return an instance which has the given print name symbol. Error if 	not" 	| if |	aSymbol == NCSuuid nilId ifTrue: [^nil].	if := self metaObjectOf: aSymbol.	if isNil ifTrue: [^nil].			DSTmoduleRepository convenientNameResolution		ifFalse: 			[(if isDSTMetaObject)				ifTrue: [if := Set with: if].			^if inject: Set new				into: 					[:result :mo | 					| m |					m := mo equivalentType.					result add: m; yourself]]		ifTrue: 			[if := if equivalentType.			(if isDSTMetaObject and: [if isDSTinterface])				ifTrue: [^if]				ifFalse: [self class intfReposError: 0]]</body><body package="DST_Core">referencedMetaContainers	"return the other modules or interfaces which are referenced by the 	receiver. Used to generate automatic include declarations for printed 	output to be compiled by other IDL compilers"	| rmo metas res |	rmo := Set new.	metas := Set new.	self allMetaObjectsInto: metas.	metas		do: 			[:mo | 			(mo isDSTMetaObject and: [mo isDSTinterface])				ifTrue: [mo allSuperiors do: [:sup | rmo add: sup definingMetaObject]].			mo class == DSTtypeNamed ifTrue: [rmo add: mo equivalentType definingMetaObject]].	res := rmo - (Set with: self) - (Set withAll: contents).	metas do: [:mo | (mo class == DSTtypeNamed 			and: [(res includes: mo equivalentType definingMetaObject)				&amp; (mo printName first ~= $:)])			ifTrue: [Transcript show: '**Warning: ' , mo printName , ' in ' , mo definingMetaObject printName , ' is a non-local reference'; cr]].	^res</body><body package="DST_Core">registerMetaObject: aMetaObject 	"register the meta-object in the symbol table of the receiver"	| id na |	id := aMetaObject repositoryId.	aMetaObject declarators		do: 			[:decl | 			na := decl printName.			(self checkForCollision: na)				ifTrue: [^Dialog notify: 'Name redefinition "' , na , '" in ' , self printName].			symbols at: na asSymbol put: decl].	id notNil ifTrue: [symbols at: id put: aMetaObject]</body><body package="DST_Core">removeContained: aMetaObject	self contents notNil ifTrue: [self contents remove: aMetaObject ifAbsent: []]</body><body package="DST_Core">removeMetaObject	"Enable the receiver to be garbage collected"	super removeMetaObject.	definedIn := contents := symbols := nil</body><body package="DST_Core">requiredUnitsOfCompilationInto: aSet 	"add the units of compilation (i.e. meta objects like modules or 	interfaces 	which are linked to a selector of the repository class) which are 	required 	by the receiver to aSet"	| metas unit |	(aSet includes: (unit := self unitOfCompilation))		ifFalse: 			[aSet add: unit.			unit requiredUnitsOfCompilationInto: aSet]		ifTrue: 			[metas := Set new: contents size + 1.			self allMetaObjectsInto: metas.			metas do: [:mo | mo isDSTMetaObject					ifTrue: 						[mo isDSTinterface ifTrue: [mo allSuperiors do: [:sup | (aSet includes: (unit := sup unitOfCompilation))									ifFalse: 										[aSet add: unit.										unit requiredUnitsOfCompilationInto: aSet]]].						mo isDSTtypeNamed ifTrue: [(aSet includes: (unit := mo equivalentType unitOfCompilation))								ifFalse: 									[aSet add: unit.									unit requiredUnitsOfCompilationInto: aSet]].						mo isDSToperation ifTrue: [mo exceptions do: [:ex | (aSet includes: (unit := ex unitOfCompilation))									ifFalse: 										[aSet add: unit.										unit requiredUnitsOfCompilationInto: aSet]]]]]]</body><body package="DST_Core">typeOf: aSymbol 	"return the type object which is associated with the given identifier"	| mo |	mo := self metaObjectOf: aSymbol.	mo isNil ifTrue: [Dialog notify: '"' , aSymbol , '" is not defined in the scope of "' , self definingMetaObject printName , '"'].	[mo isDSTMetaObject and: [mo isDSTdeclaratorSimple]]				whileTrue: [mo := mo baseType].	^(mo isDSTMetaObject and: [mo isDSTtype])		ifTrue: [mo]		ifFalse: [self class intfReposError: 0]</body><body package="DST_Core">unRegisterMetaObject: aMetaObject 	"unregister the meta-object from the symbol table of the receiver"	| id na |	id := aMetaObject repositoryId.	aMetaObject declarators		do: 			[:decl | 			na := decl printName asSymbol.			(symbols keys includes: na)				ifTrue: [symbols removeKey: na]].	id notNil ifTrue: [symbols removeKey: id]</body><body package="DST_Core">unlinkFromRepository	"The receiver is being removed from the repository. Unlink as 	required"	super unlinkFromRepository.	contents := symbols := nil</body></methods><methods><class-id>DST.DSTMetaContainer</class-id> <category>Container</category><body package="DST_Core">contents: limitType excludeInherited: bool 	"The contents operation returns the list of objects directly contained 	by or inherited into the object. The operation is used to navigate 	through the hierarchy of objects. Starting with the repository object, 	a client uses this operation to list all of the objects contained by the 	repository, all of the objects contained by the modules within the 	repository, and then all of the interfaces within a specific module, 	and so on. 		If limitType is set to dk_all, objects of all interface types are 	returned. 		If limitType is set to a specific interface, only objects of that 	interface type are returned. 		If excludeInherited is TRUE, inherited objects (if any) are not 	returned. If set to FALSE, all contained objects--whether contained 	due to inheritance or because they were defined within the 	object--are returned."	| res |	res := contents asSet select: [:mo | limitType = #dk_all | (limitType = mo defKind)].	bool ifFalse: [self withAllSuperiors do: [:mo | res addAll: (mo contents: limitType excludeInherited: true)]].	^res</body><body package="DST_Core">createAlias: aRepositoryId name: aName version: aVersion originalType: anIDLType 	"The createAlias operation returns a new AliasDef with the specified 	originalType. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created alias. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="DST_Core">createConstant: aRepositoryId name: aName version: aVersion type: anIDLType value: aValue 	"The createConstant operation returns a new ConstantDef with the 	specified type and value. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created constant. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="DST_Core">createEnum: aRepositoryId name: aName version: aVersion members: memberList 	"The createEnum operation returns a new EnumDef with the 	specified members. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created enumeration. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="DST_Core">createException: aRepositoryId name: aName version: aVersion members: aMemberCollection 	"The createException operation returns a new ExceptionDef with the specified 	members. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created exception. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="DST_Core">createInterface: aRepositoryId name: aName version: aVersion baseInterfaces: interfaceList 	"The createInterface operation returns a new empty InterfaceDef 	with the specified base interfaces. Type, exception, and constant 	definitions can be added using create&lt;Type&gt; operations on the new 	interface. OperationDefs can be added by using createOperation and 	AttributeDefs can be added by using createAttribute. Definitions can 	also be added by using the move operation. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created interface. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="DST_Core">createModule: aRepositoryId name: aName version: aVersion 	"The createModule operation returns a new empty ModuleDef. 	Definitions can be added using create&lt;Type&gt; operations on the new 	module, or by using the move operation. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created module. An error is returned if an object with 	the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="DST_Core">createStruct: aRepositoryId name: aName version: aVersion members: memberList 	"The createStruct operation returns a new StructDef with the 	specified members. The type member of the StructMembers 	structure is ignored, and should be set to TC_void. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created structure. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="DST_Core">createUnion: aRepositoryId name: aName version: aVersion discriminatorType: aDiscriminatorType members: memberList 	"The createUnion operation returns a new UnionDef with the 	specified discriminator type and members. The type member of the 	UnionMember structure is ignored, and should be set to TC_void. 		The aRepositoryId and aName parameters are used to initialize the 	identity of the created union. An error is returned if an object 	with the specified aRepositoryId already exists within this object's 	repository, or, assuming multiple versions are not supported, if an 	object with the specified aName already exists within this container."	self notYetImplemented</body><body package="DST_Core">describe: aSymbol excludeInherited: bool max: anInt 	"The describeContents operation combines the contents operation 	and the describe operation. For each object returned by the contents 	operation, the description of the object is returned. 		If limitType is set to #dk_all, objects of all interface types are returned. 	If limitType is set to a specific interface, only objects of that 	interface type are returned. 		maxReturnedObjs limits the number of objects that can be returned 	in an invocation of the call to the number provided. Setting the 	parameter to -1 means return all contained objects."	| res |	res := (self contents: aSymbol excludeInherited: bool) asOrderedCollection.	anInt negative not &amp; (anInt &lt; res size) ifTrue: [res := res copyFrom: 1 to: anInt].	^res collect: [:mo | Dictionary			with: #containedObject -&gt; (mo widenTo: #'::CORBA::Contained')			with: #kind -&gt; mo defKind			with: #value -&gt; mo description]</body><body package="DST_Core">description	"return the description of the receiver"	^Dictionary		with: #containedObject -&gt; self definedInString		with: #kind -&gt; self defKind		with: #value -&gt; self id</body><body package="DST_Core">lookup: searchName 	"The lookup operation locates a definition relative to the receiver 	given a scoped name using IDL's name scoping rules. An absolute 	scoped name (beginning with '::' locates the definition relative to the 	enclosing repository. If no object is found, a nil object reference is 	returned."	| components container mo ns |	components := self components: searchName.	components first = #'::'		ifTrue: 			[container := ORBObject repository.			ns := searchName.			components removeFirst]		ifFalse: 			[container := self.			ns := container idlName , '::' , searchName].	mo := self class lookupId: ns.	mo isNil ifFalse: [^mo].	components		do: 			[:c | 			mo := container						lookupName: c						levels: 1						limit: #dk_all						excludeInherited: true.			mo isEmpty				ifTrue: [^nil]				ifFalse: [container := mo asOrderedCollection first]].	container isNil ifFalse: [container registerIdentity].	^container</body><body package="DST_Core">lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool 	"The lookup name operation is used to locate an object by name 	within a particular object or within the objects contained by that 	object. aSymbol specifies which name is to be searched for. 		anInt controls whether the lookup is constrained to the 	object the operation is invoked on or whether it should search 	through objects contained by the object as well. Setting 	levels to -1 searches the current object and all contained 	objects. Setting levels to 1 searches only the current object. 		If limitType is set to dk_all, objects of all interface types are 	returned. 	If limitType is set to a specific interface, only objects of that 	interface type are returned. 		If excludeInherited is TRUE, inherited objects (if any) are not 	returned. If set to FALSE, all contained objects--whether contained 	due to inheritance or because they were defined within the 	object--are returned."	| res r |	res := Set with: (symbols at: aSymbol ifAbsent: [nil]).	anInt = -1 ifTrue: [contents do: [:mo | (mo isDSTMetaObject and: [mo isDSTMetaContainer])				ifTrue: 					[r := mo								lookupName: aSymbol								levels: anInt								limit: limitType								excludeInherited: bool.					res addAll: r]]].	anInt &gt; 1 ifTrue: [contents do: [:mo | (mo isDSTMetaObject and: [mo isDSTMetaContainer])				ifTrue: 					[r := mo								lookupName: aSymbol								levels: anInt - 1								limit: limitType								excludeInherited: bool.					res addAll: r]]].	res := res select: [:mo | limitType = #dk_all | (limitType = mo defKind)].	bool ifFalse: [self withAllSuperiors do: [:mo | res addAll: (mo					lookupName: aSymbol					levels: 1					limit: limitType					excludeInherited: true)]].	^res</body></methods><methods><class-id>DST.DSTMetaContainer</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^contents inject: OrderedCollection new into: [:comps :mo | comps , mo nonTrivialDeclarators]</body><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^self allComponents isEmpty not</body></methods><methods><class-id>DST.DSTMetaContainer</class-id> <category>accessing - private</category><body package="DST_Core">allSuperiors	"modules have no superiors"	^#()</body><body package="DST_Core">contents	"return the container's contents array."	^contents</body><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	contents do: [:mo | mo definedIn: self]</body><body package="DST_Core">definingMetaContainer	"return the meta container which contains the receiver"	^self</body><body package="DST_Core">definition: aStringArray 	"set the definition of the receiver.  Do nothing, as it has already been set"</body><body package="DST_Core">symbols	"return the container's symbol dictionary."	^symbols</body><body package="DST_Core">withAllSuperiors	"modules have no superiors"	^#()</body></methods><methods><class-id>DST.DSTMetaContainer</class-id> <category>private</category><body package="DST_Core">checkForCollision: aName 	"Check to see if aName is already in the container. Do a case 	insensitive check."	symbols keysDo: [:n | n isSymbol ifTrue: [n asString asUppercase = aName asUppercase ifTrue: [^true]]].	^false</body><body package="DST_Core">components: aString 	"Break a scoped name into its base components."	"Slash as temporary separator is inherited from a previous	implementation that used UnixFilename to divide components."	| components separator compSeparator compString stream |	separator := $/.	compSeparator := '::'.	compString := aString copyReplaceAll: compSeparator with: (String with: separator).	components := OrderedCollection new.	stream := compString readStream.	(stream peekFor: separator)		ifTrue: [components add: compSeparator asSymbol].	[stream atEnd]		whileFalse: [components add: (stream upTo: separator) asSymbol].	^components</body></methods><methods><class-id>DST.DSTMetaContainer</class-id> <category>testing</category><body package="DST_Core">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/Container:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="DST_Core">isDSTMetaContainer	^true</body></methods><methods><class-id>DST.DSTMetaContainer</class-id> <category>accessing</category><body package="DST_Core">exceptions	"return the receiver's exceptions"	contents isNil ifTrue: [^#()].	^contents select: [:obj | obj isDSTMetaObject and: [obj isDSTexception]]</body></methods><methods><class-id>DST.DSTmodule</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::ModuleDef'</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Module</body><body package="DST_Core">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	(name isMemberOf: ORBDeadObject)		ifTrue: [^nil].	^(self searchScopeFor: aSymbol)		ifNil: [self definingMetaObject metaObjectOf: aSymbol]</body><body package="DST_Core">removeMetaObject	"Prepare the metaobject so that it can be garbage collected."	| mos refs |	mos := Set new.	self allMetaObjectsInto: mos.	mos do: [:m | CORBAConstants removeKey: m idlName asSymbol ifAbsent: []].	refs := mos select: [:mo | mo isDSTMetaObject and: [mo isDSTinterface or: [mo isDSTdeclaratorSimple]]].	DSTtypeNamed allInstances do: [:tn | (refs includes: tn equivType)			ifTrue: [tn resolveTo: nil]].	(refs select: [:m | m class == DSTinterface])		do: [:obj | obj allOwners do: [:own | (own isKindOf: DSTObjRef)					ifTrue: [own interface: nil]]].	mos do: [:m | m destroy].	super removeMetaObject</body><body package="DST_Core">removeMetaObject: aMetaContainer 	"Remove the meta-object from the Repository. An association 	between the fully scoped name of the receiver and its 	presenters will be added to aCollection. 	The presenters contained in aCollection must be 	relinked with the replacing meta objects (if possible)"	| mos refs |	contents remove: aMetaContainer ifAbsent: [].	symbols removeKey: aMetaContainer repositoryId ifAbsent: [].	symbols removeKey: aMetaContainer printName ifAbsent: [].	mos := Set new.	aMetaContainer allMetaObjectsInto: mos.	mos		do: 			[:m | CORBAConstants removeKey: m idlName asSymbol ifAbsent: []].	refs := mos select: [:mo | mo isDSTMetaObject and: [mo isDSTinterface or: [mo isDSTdeclaratorSimple]]].	DSTtypeNamed allInstances do: [:tn | (refs includes: tn equivType)			ifTrue: [tn resolveTo: nil]].	(refs select: [:m | m class == DSTinterface])		do: [:obj | obj allOwners do: [:own | (own isKindOf: DSTObjRef)					ifTrue: [own interface: nil]]].	mos do: [:m | m unlinkFromRepository].</body><body package="DST_Core">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	| head str tail x | 	aSymbol class == NCSuuid		ifTrue: [x := 0]		ifFalse: 			[str := aSymbol asString.			x := str findFirst: [:ch | ch = $:]].	x isZero		ifTrue: [^symbols at: aSymbol ifAbsent: [nil]]		ifFalse: 			[x = 1 ifTrue: [^nil].			head := str copyFrom: 1 to: x - 1.			tail := str copyFrom: x + 2 to: str size.			^(symbols at: head asSymbol ifAbsent: [^nil])				searchScopeFor: tail asSymbol].	^nil</body></methods><methods><class-id>DST.DSTmodule</class-id> <category>accessing</category><body package="DST_Core">addSubordinate: aMO	"only interfaces keep track of sub-interfaces.  Do nothing"</body><body package="DST_Core">allOperations: oList avoiding: iSet	"only interfaces can add operations to the set.  Do nothing"</body><body package="DST_Core">interfaces	"return the interfaces which are declared within the receiver"	^contents select: [:mo | mo isDSTMetaObject and: [mo isDSTinterface]]</body></methods><methods><class-id>DST.DSTmodule</class-id> <category>testing</category><body package="DST_Core">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/ModuleDef:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="DST_Core">isDSTmodule	^true</body></methods><methods><class-id>DST.DSTmodule</class-id> <category>creation</category><body package="DST_Core">def: stArray defs: anArray 	"Set the module's description and contents"	definition := stArray.	contents := anArray asOrderedCollection.	contents		do: 			[:mo | 			mo definedIn: self.			self registerMetaObject: mo]</body><body package="DST_Core">ident: id 	"Set the module's name"	name := id.</body><body package="DST_Core">ident: id def: stArray defs: anArray 	"initialize a new instance of the receiver"	name := id.	definition := stArray.	contents := anArray.	contents		do: 			[:mo | 			mo definedIn: self.			self registerMetaObject: mo]</body></methods><methods><class-id>DST.DSTmodule</class-id> <category>printing</category><body package="DST_Core">forwardInterfaces	"for the benefit of simple minded compilers, return the interfaces 	which need to be forward declared within the receiver"	| allIfs encountered forward s et |	allIfs := contents  "self interfaces".	encountered := Set new.	forward := Set new.	allIfs		do: 			[:if | 			encountered add: if.			s := Set new.			if allMetaObjectsInto: s.			s do: [:mo | mo class = DSTtypeNamed					ifTrue: 						[et := mo equivalentType definingMetaContainer.						(allIfs includes: et)							&amp; (encountered includes: et) not							ifTrue: 								[forward add: et.								encountered add: et]]]].	^forward</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver onto the stream"	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level; nextPutAll: 'module '; nextPutAll: name asString; nextPutAll: '  {'.	contents isEmpty		ifFalse: 			[aStream cr; cr.			(1 to: contents size)				do: 					[:i | 					(i &gt; 1 and: [(contents at: i - 1) wantsSpace or: [(contents at: i) wantsSpace]])						ifTrue: [aStream cr].					(contents at: i)						printDefinitionOn: aStream						indent: level + 1						style: aTextStyleName].			aStream tab: level].	aStream nextPutAll: '};'; cr</body><body package="DST_Core">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'module ' , self idlName</body><body package="DST_Core">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"publish the IDL definition of the receiver onto the stream"	self printHeaderOn: aStream indent: level.	aStream tab: level; nextPutAll: 'module '; nextPutAll: name asString; nextPutAll: '  {'; cr; cr.	self forwardInterfaces		do: 			[:if |  			aStream tab: level+1.			aStream nextPutAll: 'interface  ' , if printName , ';  // forward declaration'; cr].	contents isEmpty		ifFalse: 			[aStream cr; cr.			(1 to: contents size)				do: 					[:i | 					(i &gt; 1 and: [(contents at: i - 1) wantsSpace or: [(contents at: i) wantsSpace]])						ifTrue: [aStream cr].					(contents at: i)						publishDefinitionOn: aStream						indent: level + 1						style: aTextStyleName].			aStream tab: level].	aStream nextPutAll: '};'; cr</body></methods><methods><class-id>DST.DSTmodule</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	contents := OrderedCollection new.	symbols := Dictionary new.</body></methods><methods><class-id>DST.DSTmodule</class-id> <category>repository-private</category><body package="DST_Core">canContain: kind 	"Check to see if the definition kind can be contained in the receiver."	^#(#dk_Constant #dk_Typedef #dk_Exception #dk_Interface #dk_Module) includes: kind</body></methods><methods><class-id>DST.DSTmodule</class-id> <category>ModuleDef</category><body package="DST_Core">description	"return a module description"	^(Dictionary new) 		add: #name -&gt; name; 		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedInString; 		add: #version -&gt; self version; 		yourself</body></methods><methods><class-id>DST.ORBDaemon</class-id> <category>private</category><body package="DST_Core">registerDaemon	"add this daemon to the list of ActiveDaemons"	ActiveDaemons add: self.	ActiveDaemonsByTag at: self class tagBinding put: self</body><body package="DST_Core">removeDaemon	"add this daemon to the list of ActiveDaemons"	ActiveDaemons remove: self ifAbsent: [nil]. 	ActiveDaemonsByTag removeKey: self class tagBinding ifAbsent: [nil]</body></methods><methods><class-id>DST.ORBDaemon</class-id> <category>accessing</category><body package="DST_Core">bindingComponent	"answer the tagged component which contains the binding for this 	daemon"	^self subclassResponsibility</body><body package="DST_Core">configuredPortNo	"answer the configured port number for this daemon"	^configuredPortNo ifNil: [0]</body><body package="DST_Core">configuredPortNo: anInteger 	"set the port for this daemon, a port number of 0 will dynamically 	allocate a new port number on start up. The parameter must be an 	either 0 or 16 bit integer not in the reserved port range of range of 1 	to 1023."	(anInteger = 0 or: [anInteger &gt; 1023 and: [anInteger &lt;= 65536]])		ifTrue: [configuredPortNo := anInteger]		ifFalse: [ORBObject badParamError: 0]</body><body package="DST_Core">hintComponent	"answer the tagged component which contains the hint for the last known 	binding for this daemon"	^self subclassResponsibility</body><body package="DST_Core">hostId	^NodeId</body><body package="DST_Core">hostName	^self class useDottedQuads		ifTrue:	[ self class bytesToName: self hostId ]		ifFalse:	[ self class hostName ]</body><body package="DST_Core">port	"return the port number that was allocated dynamically for the 	object adaptor"	^portNo</body><body package="DST_Core">running	"return if whether the ORB is running"	^receiveMsg</body></methods><methods><class-id>DST.ORBDaemon</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	receiveMsg := false</body></methods><methods><class-id>DST.ORBDaemon</class-id> <category>core</category><body package="DST_Core">prepareToShutDown	"Before full shutdown is scheduled make sure daemon 	processes know that the ORB is shutting down"	receiveMsg := false.</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>transports</category><body package="DST_Core">activeDaemons	^ActiveDaemons asOrderedCollection</body><body package="DST_Core">chooseTransportFor: anObjRef 	| bindings tags daemon | 	anObjRef class == DSTObjRefRemote		ifTrue: 			[bindings := anObjRef bindings.			tags := bindings components collect: [:binding | binding tag]]		ifFalse: [tags := SortedCollection sortBlock:  [:a :b | a &gt; b].				ActiveDaemonsByTag keysAndValuesDo: [:k :v | tags add: k]].	tags		detect: 			[:t | 			daemon := ActiveDaemonsByTag at: t ifAbsent: [nil].			daemon notNil]		ifNone: [nil].	^daemon isNil		ifTrue: [ORBObject commFailureError: 1]		ifFalse: [daemon class clientConversationClass]</body><body package="DST_Core">chooseTransportFor: anObjRef withClientClass: aConvClass 	| bindings tags daemon |	anObjRef class == DSTObjRefRemote		ifTrue: 			[bindings := anObjRef bindings.			tags := bindings components collect: [:binding | binding tag]]		ifFalse: [tags := ActiveDaemonsByTag keys asSortedCollection: [:a :b | a &gt; b]].	tags		detect: 			[:t | 			daemon := ActiveDaemonsByTag at: t ifAbsent: [nil].			daemon notNil and: [daemon class clientConversationClass ~~ aConvClass]]		ifNone: [daemon := nil].	^daemon isNil		ifTrue: [aConvClass ifNil: [ORBObject commFailureError: 1]]		ifFalse: [daemon class clientConversationClass]</body><body package="DST_Core">hostName	"return my hostname"	^NodeName isNil ifTrue:['localhost'] ifFalse:[NodeName]</body><body package="DST_Core">iiopProfileFor: anObject daemon: aDaemon 	"Answer an iiop profile that provides the binding information for the 	given daemon"	^aDaemon iiopProfileFor: anObject</body><body package="DST_Core">installedDaemonFor: aSymbol 	"answer the daemon for the given symbol"	^InstalledDaemons at: aSymbol ifAbsent: [nil]</body><body package="DST_Core">interoperableObjRefProfilesFor: anObject 	"return a collection of profiles for this object"	| col | 	^self running		ifTrue: 			[col := OrderedCollection with: (self multipleComponentProfileFor: anObject).			ActiveDaemons do: [:daemon | daemon class name == #IIOPDaemon ifTrue: [col add: (self iiopProfileFor: anObject daemon: daemon)]].			col]		ifFalse: [#()]</body><body package="DST_Core">isLocalAdapter: anAdapterId	"answer whether or not the adapterId is local to this image"	| iiopDaemon |	^anAdapterId == self adapterId or: [anAdapterId class == NCSuuid			ifTrue: [false]			ifFalse:				[iiopDaemon := ActiveDaemonsByTag at: IORTaggedComponent tagDSTIIOPBinding ifAbsent: [nil].				iiopDaemon isNil					ifTrue: [false]					ifFalse: [iiopDaemon bindingComponent componentData asString asSymbol == anAdapterId]]]</body><body package="DST_Core">leanInteroperableObjRefProfileFor: anObject 	"return a collection of profiles for this object. Modified to only return one 	profile. If IIOP is on, take that profile, if not create a multicomponent profile"	^self running ifFalse: [#()]		ifTrue: [			[| iiopDaemon |			iiopDaemon := ActiveDaemons detect: [:daemon | daemon class name == #IIOPDaemon].			Array with: (self iiopProfileFor: anObject daemon: iiopDaemon)]				on: Collection notFoundSignal do: [:ex | Array with: (self multipleComponentProfileFor: anObject)]]</body><body package="DST_Core">multipleComponentProfileFor: anObject 	"answer an multiple component profile that provides the binding 	information for the given daemon"	| mcp pd col |	mcp := IORTaggedProfile new.	mcp tag: mcp class tagMultipleComponents.	pd := CDRStream on: (ByteArray new: 250).	pd nextPutBoolean: pd byteOrder.	col := OrderedCollection new: 10.	col add: (IORTaggedComponent objectKeyComponent: anObject objectId).	col add: (IORTaggedComponent endPointComponent: VPId).	col add: self objectAdapterComponent.	ActiveDaemons do: [:daemon | col add: daemon bindingComponent].	DSTObjRefRemote multipleComponentDef marshall: col on: pd.	mcp profileData: pd contents.	^mcp</body><body package="DST_Core">objectAdapterComponent	"answer the hp object adapter component"	^OAComponent</body><body package="DST_Core">resetObjectAdaptorComponent	"reset the DST object adapter component for this image. Note this 	should only be called when starting the daemons"	| bootTime strm |	bootTime := Time totalSeconds - (Date					newDay: 21					monthNumber: 11					year: 1996) asSeconds.	strm := CDRStream on: (ByteArray new: 12).	strm nextPutBytes: ('DST:' , ORBObject fixedSizeVersionNumber , ':') toCORBACharCodes.	strm nextPutLong: bootTime.	OAComponent := IORTaggedComponent objectAdapterComponent: strm contents</body><body package="DST_Core">running	"answer true if the ORB is running"	^ActiveDaemons isEmpty not</body><body package="DST_Core">unRegisterWithLocator	"Register the adapter with the locator"</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>accessing</category><body package="DST_Core">adapterId	^VPId</body><body package="DST_Core">configurationManager	ConfigurationManager == nil		ifTrue: [	ConfigurationManager := ORBConfigurationManager new].	^ConfigurationManager</body><body package="DST_Core">domainId	^DomainId</body><body package="DST_Core">hostId	^NodeId</body><body package="DST_Core">startUpCoordinator	^StartUpCoordinator</body><body package="DST_Core">useDottedQuads	"Answers the boolean that determines whether dotted quads or host names	will be used in object references.  The default is true, as dotted quads are	compliant and most efficient.  The use of host names allows circumvention	of some of the problems entailed by NAT."	^UseDottedQuads</body><body package="DST_Core">useDottedQuads: aBoolean	"Resets the boolean that determines whether dotted quads or host names	will be used in object references.  The default is true, as dotted quads are	compliant and most efficient.  The use of host names allows circumvention	of some of the problems entailed by NAT."	UseDottedQuads := aBoolean</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>private</category><body package="DST_Core">bytesToName: aByteArray	"Convert the bytes to the canonical printed representation."	| ws |	ws := WriteStream on: (String new: 7).	1 to: aByteArray size do: [:i | (aByteArray at: i) printOn: ws. i = aByteArray size ifFalse: [ws nextPut: $.]].	^ws contents</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::DistributedSmalltalk::SmalltalkObjectAdapter'</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>migration</category><body package="DST_Core">debugging	"return whether I am debugging message sends"	^self configurationManager  debugging</body><body package="DST_Core">debugging: aBoolean 	"set whether I am debugging message sends"	self configurationManager  debugging: aBoolean</body><body package="DST_Core">logging	^self configurationManager  logging</body><body package="DST_Core">testRPC	"return my class variable"	^self configurationManager localRPCTesting</body><body package="DST_Core">testRPC: aBoolean 	"turn on or off the testing of RPC interaction for local message sends 	involving my subclasses"	self configurationManager localRPCTesting: aBoolean == true</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>SharedIR</category><body package="DST_Core">getCachedInterface: anId 	^ORBObject getCachedInterface: anId</body><body package="DST_Core">getCachedMetaObject: anId 	^ORBObject getCachedMetaObject: anId</body><body package="DST_Core">getCachedOperation: selector interface: anId 	^ORBObject getCachedOperation: selector interface: anId</body><body package="DST_Core">getConstantOrException: aSymbol 	^ORBObject getConstantOrException: aSymbol</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>initialization</category><body package="DST_Core">initialize	"Initialize the receiver.  ActiveDaemonsByTag is	now aDictionary, to accomodate tags larger than	SmallInteger maxVal."	DomainId := 'ebcfdc8c-41f0-701c-d5d6-0f0070280000'.	ActiveDaemons := IdentitySet new.	ActiveDaemonsByTag := Dictionary new.	InstalledDaemons := IdentityDictionary new.	StartUpCoordinator := ORBStartUpCoordinator new.	UseDottedQuads := true</body><body package="DST_Core">initialize: aHostName node: aHostAddr 	NodeId := aHostAddr.	NodeName := aHostName.	DSTModules security authorizeHost: NodeId.	self initializeObjects</body><body package="DST_Core">initializeObjects	"set the vpId and lookup the hostId"	CDRStream reInitialize.	self initializeVPId.	self resetObjectAdaptorComponent.</body><body package="DST_Core">initializeVPId	"set the vpId and lookup the hostId"	VPId := self configurationManager adapterId.	DSTObjRef registerObject: self as: self configurationManager adapterId</body><body package="DST_Core">release	"release class variables"	DomainId := ActiveDaemons := ActiveDaemonsByTag := InstalledDaemons := ConfigurationManager := StartUpCoordinator := nil</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>ORB</category><body package="DST_Core">listInitialServices	"answer the list of services"	^ORBObject listInitialServices</body><body package="DST_Core">resolveInitialReferences: aString 	"answer the service"	^ORBObject resolveInitialReferences: aString</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>instance creation</category><body package="DST_Core">new	"create a new instance and initialize it"	^self basicNew initialize</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>VirtualProcess</category><body package="DST_Core">orbObject	^ORBObject</body><body package="DST_Core">ping	^true</body><body package="DST_Core">update: aDomainId vpId: aVpId 	VPId := aVpId asSymbol.	DomainId := aDomainId.	^self</body><body package="DST_Core">verify: aDomainId vpId: aVpId 	^DomainId = aDomainId and: [VPId asByteString = aVpId]</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>startup-shutdown</category><body package="DST_Core">shutDown	"shut down all the active daemons"</body></methods><methods><class-id>DST.ORBDaemon class</class-id> <category>handlers</category><body package="DST_Core">transientErrorHandler	"Vide the comment in 'ORBDaemon class&gt;&gt;transientErroHandler:'."	^TransientErrorHandler</body><body package="DST_Core">transientErrorHandler: aTwoParameterBlock	"The block should take two parameters, first, the exception	and second, the server conversation that entailed it.		A Note On Transients:		Transients are difficult to trap in user code, because they are 		generated on the server side, in a spawned process, created		to respond to a remote request, initiated in another image.		Since an unhandled transient will try to open a notifier, a user 		producing a headless server wants to trap them.		Transients are *usually* raised when clients and servers are		both overloaded: the client spawning requests and the server		receiving them.   If the server is swamped with incoming 		requests, it is spending all of its time spawning processes to 		respond to them -- so, those spawned processes never get a 		timeslice in which to run (which can entail that the requests		will time out on the *client* side).  When the server gets a 		breathing space to run its spawned, responding processes, 		and has return values to pass back, the client is too busy 		doing other things to listen, and this gives you a transient.		This entails that you really might want to find out exactly 		why and how you are getting transients before cutting off 		notification of them with a handler block that throws them 		away."	TransientErrorHandler := aTwoParameterBlock</body></methods><methods><class-id>DST.ORBRequest</class-id> <category>Request</category><body package="DST_Core">addArg: aNamedValue 	"add an argument to the receiver"	arguments isNil ifTrue: [arguments := ORBNVList new initialize].	arguments addNamedValue: aNamedValue.	^0</body><body package="DST_Core">addArg: anId type: aTypeCode value: any length: anInt flags: aFlags 	"add an argument to the receiver"	arguments isNil ifTrue: [arguments := ORBNVList new initialize].	arguments		addItemIdentifier: anId		typeCode: aTypeCode		any: any		long: anInt		flags: aFlags.	^0</body><body package="DST_Core">delete	"This operation deletes the request. Any memory associated with the 	request is also freed"	objref := context := operation := arguments := result := flags := nil</body><body package="DST_Core">getResponse	"This operation determines whether a request has completed. If so, 	then the out and return parameters defined in the Request are valid. 	If the RESP_NO_WAIT flag is set, then get_response() returns 	immediately even if the request is still in progress"	^self getResponse: 0</body><body package="DST_Core">getResponse: aFlags 	"This operation determines whether a request has completed. If so, 	then the out and return parameters defined in the Request are valid. 	If the RESP_NO_WAIT flag is set, then get_response() returns 	immediately even if the request is still in progress."	aFlags == 1		ifTrue: [status == #done				ifTrue: [^1]				ifFalse: [^0]]		ifFalse: [[status == #done]				whileFalse: [Processor yield]].	^1</body><body package="DST_Core">invoke	"This operation calls the ORB, which performs method resolution and 	invokes an appropriate method. If the method returns successfully, 	its result is placed in the result argumentspecified on 	create_request()"	self invoke: 0</body><body package="DST_Core">invoke: aFlags 	"This operation calls the ORB, which performs method resolution and 	invokes an appropriate method. If the method returns successfully, 	its result is placed in the result argumentspecified on 	create_request()"	status := #working.	result at: 1 put: 'result'.	result at: 2 put: (objref perform: operation withArguments: arguments asLocal asValueArray).	result at: 3 put: 0.	result at: 4 put: 0.	status := #done.	^nil</body><body package="DST_Core">invokeOneWay	"This operation calls the ORB, which performs method resolution and 	invokes an appropriate method. If the method returns successfully, 	its result is placed in the result argumentspecified on 	create_request()"	self invoke: 0</body><body package="DST_Core">pollResponse	"This operation determines whether a request has completed. If so, 	then the out and return parameters defined in the Request are valid. 	RESP_NO_WAIT flag is set, so get_response() will return 	immediately even if the request is still in progress"	^self getResponse: 1</body><body package="DST_Core">send	"Send initiates an operation according to the information in the 	Request. Unlike invoke(), send() returns control to the caller without 	waiting for the operation to finish. To determine when the operation 	is done, the caller must use the ORB's get_response() or 	get_next_response() operations . The out parameters and return 	value must not be used until the operation is done"	self send: 0</body><body package="DST_Core">send: aFlags 	"Send initiates an operation according to the information in the 	Request. Unlike invoke(), send() returns control to the caller without 	waiting for the operation to finish. To determine when the operation 	is done, the caller must use the ORB's get_response() or 	get_next_response() operations . The out parameters and return 	value must not be used until the operation is done"	status := #working.		[result at: 1 put: 'result'.	result at: 2 put: (objref perform: operation withArguments: arguments asLocal asValueArray).	result at: 3 put: 0.	result at: 4 put: 0.	status := #done]  forkAt: ORBObject orbRequestPriority.</body><body package="DST_Core">sendOneWay	"Send initiates an operation according to the information in the 	Request. Unlike invoke(), send() returns control to the caller without 	waiting for the operation to finish. To determine when the operation 	is done, the caller must use the ORB's get_response() or 	get_next_response() operations . The out parameters and return 	value must not be used until the operation is done"	self send: 0</body></methods><methods><class-id>DST.ORBRequest</class-id> <category>initialization</category><body package="DST_Core">objref: anObjref context: aString operation: anId arguments: aNVList result: aNamedValue flags: anInt 	"initialize the receiver"	objref := anObjref.	context := aString.	operation := anId.	arguments:= aNVList.	result := aNamedValue.	flags := anInt.	status := #initial</body></methods><methods><class-id>DST.ORBRequest</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::DynamicInvocation::Request'</body></methods><methods><class-id>DST.DSTtypeConstr</class-id> <category>printing</category><body package="DST_Core">wantsSpace	"return true if the receiver wants an extra line of space before 	printing itself"	^true</body></methods><methods><class-id>DST.DSTtypeConstr</class-id> <category>repository</category><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Typedef</body></methods><methods><class-id>DST.DSTtypeConstr</class-id> <category>accessing</category><body package="DST_Core">baseType	^self</body><body package="DST_Core">declarators	"return the declarators of the receiver, or an array of self if nil"	declarators notNil		ifTrue: [^declarators]		ifFalse: [^Array with: self]</body></methods><methods><class-id>DST.DSTtypeEnumeration</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::EnumDef'</body><body package="DST_Core">allMetaObjectsInto: aSet 	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	values notNil ifTrue: [values do: [:val | (val isDSTMetaObject)				ifTrue: [aSet add: val]]]</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#CLASS) includes: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Enum</body><body package="DST_Core">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	^(values includes: aSymbol)		ifTrue: [self]		ifFalse: [self definingMetaObject metaObjectOf: aSymbol]</body><body package="DST_Core">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^(values includes: aSymbol)		ifTrue: [aSymbol]		ifFalse: [self class intfReposError: 0]</body><body package="DST_Core">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	(values includes: aSymbol)		ifTrue: [^DSTEnumerator				name: aSymbol				value: (values indexOf: aSymbol)						- 1				type: self]		ifFalse: [^nil]</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_enum</body><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^1 + values size</body><body package="DST_Core">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^self printName].	(anInt between: 2 and: self typeParamCount )ifTrue: [^(values at: anInt - 1) asString].	self error: #Bounds</body></methods><methods><class-id>DST.DSTtypeEnumeration</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = MNU on asSymbol or (idx &lt;= 0)"	aParameter class == DSTEnumerator		ifTrue: [aStream nextPutLong: aParameter value]		ifFalse: 			[| idx |			idx := values indexOf: aParameter asSymbol.			idx &gt; 0 ifFalse: [self class marshallError: 0].			aStream nextPutLong: idx - 1]</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter class == DSTEnumerator or: [(aParameter isKindOf: CharacterArray)			and: [(values indexOf: aParameter asSymbol)					&gt; 0]]</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	| pos |	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	pos := aStream nextPutEncapsulationHeader.	aStream nextPutString: self repositoryId; nextPutString: self printName.	aStream nextPutLocalType: self localType; nextPutUnsignedLong: values size.	values do: [:v | aStream nextPutString: v].	aStream setEncapsulationLength: pos</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	| int |	int := aStream nextUnsignedLong.	^DSTEnumerator		name: (values at: int + 1)		value: int		type: self</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall the type code of the receiver"	| mo sz byteOrder locType str |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextString.	repositoryId isEmpty ifFalse: [repositoryId := RepositoryId fromString: repositoryId].	(repositoryId notEmpty and: [ aStream notReadingFromRemoteIR ])		"We have to make sure that we don't do this in case of reading a typecode from remote IR,		otherwise we'll have an infinite recursion, more detail can be found in AR#49408"		ifTrue: [mo := ORBObject lookupMetaId: repositoryId].	name := aStream nextString.	(name isEmpty and: [mo notNil]) ifTrue: [name := mo name].	locType := aStream nextLocalType.	sz := aStream nextUnsignedLong.	values := (1 to: sz)				collect: [:v | 						str := aStream nextString asSymbol.						(str isEmpty and: [mo notNil]) ifTrue: [str := mo values at: v].						str].	locType isNil		ifTrue: [mo isNil ifFalse: [mo localType isNil ifFalse: [self localType: mo localType]]]		ifFalse: [self localType: locType].	aStream byteOrder: byteOrder</body></methods><methods><class-id>DST.DSTtypeEnumeration</class-id> <category>EnumDef</category><body package="DST_Core">description	"return an enumeration description"	|d| 	d := (Dictionary new) 			add: #name -&gt; name; 			add: #id -&gt; self id; 			add: #definedIn -&gt; self definedInString; 			add: #version -&gt; self version; 			add: #type -&gt; self;			yourself.	d overrideCORBAType: (ORBObject lookupMetaId: #'::CORBA::TypeDescription').	^d</body><body package="DST_Core">members	"The members attribute contains a distinct name for each possible 	value of the enumeration."	^values</body><body package="DST_Core">members: newMembers 	"The members attribute contains a distinct name for each possible 	value of the enumeration."	self notYetImplemented</body></methods><methods><class-id>DST.DSTtypeEnumeration</class-id> <category>accessing</category><body package="DST_Core">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	| candidates |	candidates := self values asSet - aCol asSet.	^candidates isEmpty		ifTrue: [nil]		ifFalse: [candidates anElement]</body><body package="DST_Core">values	^values</body></methods><methods><class-id>DST.DSTtypeEnumeration</class-id> <category>printing</category><body package="DST_Core">definitionString	"return my unformatted definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: 'enum '; nextPutAll: name; nextPutAll: ' {'.	(1 to: values size - 1)		do: [:i | aStream nextPutAll: (values at: i); nextPutAll: ', '].	values isEmpty ifFalse: [aStream nextPutAll: values last].	aStream nextPut: $}.	^aStream contents</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print my IDL definition on the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it 	is important that the first token of an IDL 'method' is parsed 	correctly by 	Parser. Specifically, it must be avoided that the pound sign is the 	first 	character in the method, since it would cause a parsing problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make 	sure that there is always at least one comment line. Also note, that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	self hasPragma ifTrue: [aStream tab: level; nextPutAll: '#pragma class '; nextPutAll: self printName; nextPutAll: ' '; nextPutAll: self localType; cr].	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[aStream nextPutAll: 'typedef '.			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body><body package="DST_Core">printFormattedOn: aStream indent: level style: aTextStyleName 	"print the detailed formatted definition of the receiver on 	aStream. To be overloaded by subclasses if formatting is 	actually required"	| unformatted |	unformatted := self definitionString.	(self		stringNeedsFormatting: unformatted		indent: level		style: aTextStyleName)		ifTrue: 			[aStream nextPutAll: 'enum '; nextPutAll: name; nextPutAll: ' {'; cr.			(1 to: values size - 1)				do: [:i | aStream tab: level + 1; nextPutAll: (values at: i); nextPut: $,; cr].			values isEmpty ifFalse: [aStream tab: level + 1; nextPutAll: values last; cr].			aStream tab: level; nextPut: $}]		ifFalse: [aStream nextPutAll: unformatted]</body><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'enum ' , self idlName</body></methods><methods><class-id>DST.DSTtypeEnumeration</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^values asOrderedCollection collect: [:v | DSTvalue on: v]</body></methods><methods><class-id>DST.DSTtypeEnumeration</class-id> <category>initialization</category><body package="DST_Core">id: aSymbol values: anArray 	"Initialize instance variables for an enumerated type"	name := aSymbol asSymbol.	values := anArray</body></methods><methods><class-id>DST.DSTUnionCase</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: value on: aStream 	| decl |	decl := type declarators.	^(decl isEmpty			ifTrue: [type]			ifFalse: [decl first]) 		boldMarshall: value on: aStream</body><body package="DST_Core">marshallMatch: aParameter 	"Return: 	true			- if I can marshall the parameter 	false		- if I can NOT marshall the parameter 	#mappable	- if I can marshall the parameter by mapping to something else"	| decl |	decl := type declarators.	^(decl isEmpty			ifTrue: [type]			ifFalse: [decl first]) 		marshallMatch: aParameter</body><body package="DST_Core">unMarshall: aStream 	| decl |	decl := type declarators.	^(decl isEmpty			ifTrue: [type]			ifFalse: [decl first]) 		unMarshall: aStream</body></methods><methods><class-id>DST.DSTUnionCase</class-id> <category>printing</category><body package="DST_Core">printDeclaratorOn: aStream 	"print one cases declarator in the switch body of a union"	aStream nextPut: $ ; nextPutAll: type declaratorString; nextPutAll: '; '</body><body package="DST_Core">printDiscriminatorOn: aStream indent: level 	"print one cases discriminator in the switch body of a union"	aStream tab: level.	discriminator == #default		ifTrue: [aStream nextPutAll: 'default: ']		ifFalse: [aStream nextPutAll: 'case '; nextPutAll: discriminator asIDLString; nextPutAll: ': ']</body><body package="DST_Core">printFormattedOn: aStream indent: level style: aTextStyleName 	"print one case in the switch body of a union"	self printDiscriminatorOn: aStream indent: level .	type		printFormattedOn: aStream		indent: level + 1		style: aTextStyleName.	self printDeclaratorOn: aStream.	aStream cr</body><body package="DST_Core">printOn: aStream 	"print one case in the switch body of a union"	self printDiscriminatorOn: aStream indent: 0.	aStream nextPutAll: type definitionString.	self printDeclaratorOn: aStream</body></methods><methods><class-id>DST.DSTUnionCase</class-id> <category>accessing</category><body package="DST_Core">declarators	^type declarators</body><body package="DST_Core">discriminator	^discriminator</body><body package="DST_Core">discriminator: aDiscriminator	discriminator := aDiscriminator</body><body package="DST_Core">type	^type</body></methods><methods><class-id>DST.DSTUnionCase</class-id> <category>testing</category><body package="DST_Core">isDefaultDiscriminator	^discriminator value == #default</body></methods><methods><class-id>DST.DSTUnionCase</class-id> <category>repository</category><body package="DST_Core">allMetaObjectsInto: aSet 	"add all of the contained metaobjects to the set"	(discriminator respondsTo: #allMetaObjectsInto:)		ifTrue: [discriminator allMetaObjectsInto: aSet].	type allMetaObjectsInto: aSet</body></methods><methods><class-id>DST.DSTUnionCase</class-id> <category>initialize-release</category><body package="DST_Core">discriminator: aDiscriminator type: aType 	discriminator := aDiscriminator.	type := aType</body></methods><methods><class-id>DST.DSTUnionCase class</class-id> <category>instance creation</category><body package="DST_Core">discriminator: discriminator type: type	| case |	case := self new.	case discriminator: discriminator type: type.	^case</body><body package="DST_Core">discriminator: discriminator type: type declarators: declarators	| case |	case := self new.	case discriminator: discriminator type: type.	type declarators: declarators.	^case</body></methods><methods><class-id>DST.DSTObjRefWidened</class-id> <category>local-remote</category><body package="DST_Core">asLocal	"return the receiver"	^self</body></methods><methods><class-id>DST.DSTObjRefWidened</class-id> <category>message handlers</category><body package="DST_Core">perform: opSelector on: parameters 	"invoke the operation on the remote object and wait for a return"	(self getOpInfo: opSelector) isNil ifTrue: [Dialog onDebugNotify: 'Operation "' , opSelector , '" is not in interface " ' , interface printName , '"'].	^object perform: opSelector withArguments: parameters</body></methods><methods><class-id>DST.DSTObjRefWidened</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print a representation of the receiver on the stream"	aStream nextPutAll: 'a widened ' , self interface printName</body></methods><methods><class-id>DST.DSTObjRefWidened</class-id> <category>accessing</category><body package="DST_Core">isLocal	"ObjRefs denote remote objects"	^true</body><body package="DST_Core">isRemote	"Widened ObjRefs denote local objects"	^false</body><body package="DST_Core">object: anObject	"set the object to which the reciever refers"	object := anObject</body></methods><methods><class-id>DST.DSTObjRefWidened class</class-id> <category>creation-registration</category><body package="DST_Core">findOrCreateOn: anObject asInterfaceId: anId 	"Create an instance of a widened object reference to refer to the 	given object by the given interface" 	| objref array i uuid |	array := InstanceMap at: anObject ifAbsent: [nil].	array isNil		ifTrue: [array := Array new: 10]		ifFalse: [array do: [:el | (el notNil and: [el interfaceId == anId])					ifTrue: [^el]]].	objref := self basicNew.	uuid := ORBObject newId.	objref objectId: uuid interfaceId: anId.	objref object: anObject.	i := array indexOf: nil				ifAbsent: 					[array growToAtLeast: array size * 2.					array size].	array at: i put: objref.	InstanceMap at: anObject put: array.	^self indexObject: objref as: uuid.</body><body package="DST_Core">index	"Answer the value of index."	^Index</body><body package="DST_Core">unRegisterWidenedObjects: anObject 	"remove the object from the set of registered objects"	InstanceMap removeKey: anObject ifAbsent: []</body></methods><methods><class-id>DST.DSTObjRefWidened class</class-id> <category>initialization</category><body package="DST_Core">flushIndex	"flush the class index"	"self flushIndex"	Index := self indexClass new: 2011</body><body package="DST_Core">flushInstanceMap	"since the instance map keys are objects for which widened objrefs 	have been generated, we check to see if any of the widened objrefs 	remain. If they have all been reclaimed, then we can safely remove 	the key from the map and allow that object to possibly be reclaimed 	as well. If any widened refs remain, then they will hold existence 	ensuring links to the key object and it cannot be deleted."	| newMap |	newMap := IdentityDictionary new.	InstanceMap associationsDo: [:ass | (ass value select: [:el | el notNil]) isEmpty ifFalse: [newMap add: ass]].	InstanceMap := newMap</body><body package="DST_Core">initialize	InstanceMap := IdentityDictionary new.	self flushIndex</body><body package="DST_Core">release	InstanceMap := Index := nil</body></methods><methods><class-id>DST.DSTtypeUnsignedLong</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_ulong</body></methods><methods><class-id>DST.DSTtypeUnsignedLong</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = raises exception in nextPutUnsignedLong:"	aStream nextPutUnsignedLong: aParameter</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextUnsignedLong</body></methods><methods><class-id>DST.DSTtypeUnsignedLong</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'unsigned long'</body></methods><methods><class-id>DST.DSTtypeUnsignedLong</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_ulong</body></methods><methods><class-id>DST.IORTaggedProfile</class-id> <category>accessing</category><body package="DST_Core">profileData	^profileData</body><body package="DST_Core">profileData: aByteArray	profileData := aByteArray</body><body package="DST_Core">tag	^tag</body><body package="DST_Core">tag: anInteger	tag := anInteger</body></methods><methods><class-id>DST.IORTaggedProfile</class-id> <category>testing</category><body package="DST_Core">isInternetIOPProfile	^tag = self class tagInternetIOP</body><body package="DST_Core">isMultipleComponentsProfile	^tag = self class tagMultipleComponents</body></methods><methods><class-id>DST.IORTaggedProfile class</class-id> <category>instance creation</category><body package="DST_Core">tag: anInteger profileData: aByteArray 	^(self basicNew) tag: anInteger; profileData: aByteArray; yourself</body></methods><methods><class-id>DST.IORTaggedProfile class</class-id> <category>constants</category><body package="DST_Core">tagInternetIOP	^0</body><body package="DST_Core">tagMultipleComponents	^1</body></methods><methods><class-id>DST.IORTaggedProfile class</class-id> <category>testing</category><body package="DST_Core">validTag: aSmallInteger	^ ( ( aSmallInteger == self tagInternetIOP ) 		or: [ aSmallInteger == self tagMultipleComponents ] )</body></methods><methods><class-id>DST.IORTaggedComponent</class-id> <category>accessing</category><body package="DST_Core">componentData	^componentData</body><body package="DST_Core">componentData: aByteArray 	componentData := aByteArray</body><body package="DST_Core">tag	^tag</body><body package="DST_Core">tag: anInteger	tag := anInteger</body></methods><methods><class-id>DST.IORTaggedComponent class</class-id> <category>instance creation</category><body package="DST_Core">domainIdComponent: aString	^self tag: self tagDSTDomain componentData: aString asByteArray</body><body package="DST_Core">endPointComponent: aString 	^self tag: self tagEndpointId componentData: aString asByteArray</body><body package="DST_Core">iiopBindingComponent: aString	^self tag: self tagDSTIIOPBinding componentData: aString asByteArray</body><body package="DST_Core">iiopHintComponent: aString	^self tag: self tagDSTIIOPHint componentData: aString asByteArray</body><body package="DST_Core">iiopStreamComponent	^self tag: self tagDSTIIOPStream componentData: #[]</body><body package="DST_Core">ncsBindingComponent: aString	^self tag: self tagDSTNCSBinding componentData: aString asByteArray</body><body package="DST_Core">ncsHintComponent: aString	^self tag: self tagDSTNCSHint componentData: aString asByteArray</body><body package="DST_Core">objectAdapterComponent: aString	^self tag: self tagDSTObjectAdapter componentData: aString asByteArray</body><body package="DST_Core">objectKeyComponent: anObjectId 	^self tag: self tagObjectKey componentData: anObjectId asByteArray</body><body package="DST_Core">tag: anInteger componentData: aByteArray 	^(self basicNew) tag: anInteger; componentData: aByteArray; yourself</body></methods><methods><class-id>DST.IORTaggedComponent class</class-id> <category>constants</category><body package="DST_Core">locateAlways	^3</body><body package="DST_Core">locateNever	^0</body><body package="DST_Core">locateObject	^1</body><body package="DST_Core">locateOperation	^2</body><body package="DST_Core">tagDCEBindingName	^101</body><body package="DST_Core">tagDCEComponentNoPipes	^102</body><body package="DST_Core">tagDCEStringBinding	^100</body><body package="DST_Core">tagDSTDCEHint	^16r4453548D</body><body package="DST_Core">tagDSTDomain	^16r4453540D</body><body package="DST_Core">tagDSTIIOPBinding	^16r44535439</body><body package="DST_Core">tagDSTIIOPHint	^16r4453548E</body><body package="DST_Core">tagDSTIIOPStream	^16r44535449</body><body package="DST_Core">tagDSTNCSBinding	^16r4453543A</body><body package="DST_Core">tagDSTNCSHint	^16r4453548F</body><body package="DST_Core">tagDSTObjectAdapter	^16r44535407</body><body package="DST_Core">tagEndpointId	^11</body><body package="DST_Core">tagLocationPolicy	^12</body><body package="DST_Core">tagObjectKey	^10</body></methods><methods><class-id>DST.DSTUnion</class-id> <category>accessing</category><body package="DST_Core">discriminator	^discriminator</body><body package="DST_Core">discriminator: aValue	discriminator := aValue</body><body package="DST_Core">value	^value</body><body package="DST_Core">value: aValue	value := aValue</body></methods><methods><class-id>DST.DSTUnion class</class-id> <category>creation</category><body package="DST_Core">discriminator: aDiscriminator value: aValue	^self new discriminator: aDiscriminator; value: aValue; yourself</body></methods><methods><class-id>DST.CDRExternalReadStream</class-id> <category>accessing</category><body package="DST_Core">alignmentBoundary	^alignmentBoundary</body><body package="DST_Core">amountRead	^amountRead</body><body package="DST_Core">msgSize	^msgSize</body><body package="DST_Core">msgSize: anInteger	msgSize := anInteger</body></methods><methods><class-id>DST.CDRExternalReadStream</class-id> <category>position accessing</category><body package="DST_Core">incrementAmountReadBy: anInteger 	amountRead := amountRead + anInteger</body><body package="DST_Core">position: anInteger 	"Set position to anInteger as long as anInteger is within the bounds 	of the receiver's contents. If it is not, provide an error notification."	(anInteger &gt;= 0 and: [anInteger &lt;= collection size])		ifTrue: 			[anInteger &gt;= readLimit ifTrue: [readLimit := anInteger].			position := anInteger]		ifFalse: [^self positionOutOfBoundsError: anInteger]</body></methods><methods><class-id>DST.CDRExternalReadStream</class-id> <category>testing</category><body package="DST_Core">atEnd	"Answer true if the position is greater than or equal to the limit, 	otherwise answer false."	^self basicAtEnd and: [self endTest]</body></methods><methods><class-id>DST.CDRExternalReadStream</class-id> <category>alignment</category><body package="DST_Core">alignToDouble	"Advance the position to the Double alignment boundary."	[((alignmentBoundary + position) bitAnd: 7) isZero | self atEnd]		whileFalse: [self next]</body><body package="DST_Core">alignToLong	"Advance the position to the Long alignment boundary."	[((alignmentBoundary + position) bitAnd: 3) == 0  or: [ self atEnd]]		whileFalse: [self next]</body><body package="DST_Core">alignToShort	"Advance the position to the Short alignment boundary."	[((alignmentBoundary + position) bitAnd: 1) isZero | self atEnd]		whileFalse: [self next]</body></methods><methods><class-id>DST.CDRExternalReadStream</class-id> <category>private</category><body package="DST_Core">basicAtEnd	"Answer true if the position is greater than or equal to the limit, otherwise 	answer false. Fail if position or readLimit is not a SmallInteger and answer 	true.  Only called by 'atEnd', which will continue processing if true is returned 	in order to handle streaming across buffer boundries."	&lt;primitive: 67&gt;	^true</body><body package="DST_Core">endTest	"Answer true if the receiver is at the end of the data, if not get the next buffer.	Used by 'atEnd'."	position &lt; readLimit ifTrue: [^false].	self nextBuffer 		ifFalse: [^true].	^position = readLimit</body><body package="DST_Core">nextBuffer	"Read the next buffer and answer true if there was any data."	| dataRemaining bytesRead |	alignmentBoundary := alignmentBoundary + readLimit.	dataRemaining := msgSize - amountRead.	^dataRemaining isZero		ifTrue: [false]		ifFalse: [(sktAddr notNil and: [sktAddr isActive])				ifTrue: 					[bytesRead := sktAddr								readInto: collection								start: 1								for: (collection size min: dataRemaining)								wait: IIOPConversation messageTimeout * 1000.					bytesRead == 0						ifTrue: 							[sktAddr close.							false]						ifFalse: 							[readLimit := bytesRead.							position := 0.							self incrementAmountReadBy: bytesRead.							true]]				ifFalse: [false]]</body><body package="DST_Core">on: aSocketAccessor headerSize: anInteger	"Answer a new instance of the receiver that streams over 	aSocketConnection."	sktAddr := aSocketAccessor.	amountRead := 0.	collection := ByteArray new: 4096.	writeLimit := collection size.	readLimit := position := 0.	alignmentBoundary := anInteger</body><body package="DST_Core">pastEnd	"Raise a signal if the receiver is at the end of the data; if not get the 	next buffer and return next character."	position &lt; readLimit ifTrue: [^collection at: (position := position + 1)].	^self nextBuffer		ifTrue: [collection at: (position := position + 1)]		ifFalse: [[self class endOfStreamSignal raiseRequestFrom: self] 				on: Signal noHandlerSignal 				do: [:ex | ex parameter proceedWith: nil]]</body></methods><methods><class-id>DST.CDRExternalReadStream class</class-id> <category>instance creation</category><body package="DST_Core">on: aSocketAccessor headerSize: anInteger	"Answer a new instance of the receiver that streams over 	aSocketConnection."	^self basicNew on: aSocketAccessor headerSize: anInteger</body></methods><methods><class-id>DST.DSTtypeCharacter</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_char</body></methods><methods><class-id>DST.DSTtypeCharacter</class-id> <category>accessing</category><body package="DST_Core">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	aCol size &lt; 256		ifTrue: [0 to: 255 do: [:i | (aCol includes: i fromCORBACharCode)					ifFalse: [^i asCharacter]]]		ifFalse: [^nil]</body></methods><methods><class-id>DST.DSTtypeCharacter</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = nextPutCharacter: raises exception"	aStream nextPutCharacter: aParameter</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: Character</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextCharacter</body></methods><methods><class-id>DST.DSTtypeCharacter</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'char'</body></methods><methods><class-id>DST.DSTtypeCharacter</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_char</body></methods><methods><class-id>DST.IIOPConnectionReaper</class-id> <category>api</category><body package="DST_Core">reap: aSet	"... implements a conservative reap policy.  First, reap on the basis of 'isActive' status.  	Then reap all connections without conversations, but only if there is at least one with	conversations."	| dict |	dict := Dictionary new.	aSet do: 		[ :conn |	| pr |  					dict at: ( pr := conn peer ) ifAbsentPut: Set new.					( conn isActive )						ifTrue:	[ ( dict at: pr ) add: conn ]						ifFalse:	[ conn shutDownConnection ]		].	dict keysAndValuesDo: 		[ :pr :cs | 	| withConv |					withConv := cs select: [ :conn | conn conversations isEmpty not ].					( withConv isEmpty not )						ifTrue:	[ ( cs - withConv ) do: [ :conn | conn shutDownConnection ] ]		]</body><body package="DST_Core">start	self reapProcess:			(	[	[	[ true ]							whileTrue:						[	| daemon |							daemon := ORBDaemon installedDaemonFor: #IIOPDaemon.							self reap: daemon allClientConnections.							self reap: daemon allServerConnections.							( Delay forMilliseconds: self reapDelay ) wait.						]					] ensure: [ self terminateReaper ]				] forkAt: self class reapProcessPriority			)</body><body package="DST_Core">stop	self terminateReaper.	self reapProcess: nil</body></methods><methods><class-id>DST.IIOPConnectionReaper</class-id> <category>accessing</category><body package="DST_Core">reapDelay	^reapDelay</body><body package="DST_Core">reapDelay: anInteger	reapDelay := anInteger</body><body package="DST_Core">reapProcess	^reapProcess</body><body package="DST_Core">reapProcess: aProcess	reapProcess := aProcess</body></methods><methods><class-id>DST.IIOPConnectionReaper</class-id> <category>initialize-release</category><body package="DST_Core">initialize	self stop.	reapDelay := self class reapDelay.</body></methods><methods><class-id>DST.IIOPConnectionReaper</class-id> <category>private</category><body package="DST_Core">terminateReaper	( reapProcess notNil )		ifTrue: [ reapProcess terminate ]</body></methods><methods><class-id>DST.IIOPConnectionReaper class</class-id> <category>instance management</category><body package="DST_Core">default	^( default isNil )		ifTrue:	[ default := super new initialize ]		ifFalse:	[ default ]</body><body package="DST_Core">default: anObjectOrNil	^default := anObjectOrNil</body><body package="DST_Core">new	^self default</body><body package="DST_Core">releaseDefault	"IIOPConnectionReaper releaseDefault."	default := nil</body></methods><methods><class-id>DST.IIOPConnectionReaper class</class-id> <category>accessing</category><body package="DST_Core">reapDelay	"Answers the millisecond delay separating reap cycles."	^( ReapDelay isNil )		ifTrue:	[ ReapDelay := 7 * 60 *1000 ]		ifFalse:	[ ReapDelay ]</body><body package="DST_Core">reapDelay: anInteger	"Sets the millisecond delay separating reap cycles."	ReapDelay := anInteger</body><body package="DST_Core">reapProcessPriority	"Answers the priority level at which the reap process is run."	^Processor userBackgroundPriority</body></methods><methods><class-id>DST.IIOPConnectionReaper class</class-id> <category>api</category><body package="DST_Core">shutdown	( self default notNil )		ifTrue:	[	self default stop.  					self releaseDefault 				]</body><body package="DST_Core">startup	( IIOPConnection receiveTimeout == Infinity positive )		ifTrue:	[ self default start ]</body></methods><methods><class-id>DST.DSTpseudoMeta</class-id> <category>accessing</category><body package="DST_Core">description	"return an operation description"	^(Dictionary new)		add: #name -&gt; name; 		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedIn; 		yourself</body></methods><methods><class-id>DST.DSTpseudoMeta</class-id> <category>rendering</category><body package="DST_Core">childName	"return the name to be used for the receiver in a browser window"	^name asString</body><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^false</body></methods><methods><class-id>DST.DSTpseudoMeta</class-id> <category>printing</category><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"subclasses must overload"	self shouldNotImplement</body><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: self class name , ' ' , self printName</body></methods><methods><class-id>DST.DSTpseudoMeta class</class-id> <category>creation</category><body package="DST_Core">on: aSymbolOrString 	"return a meta pseudo object with name set to aSymbolOrString"	^self basicNew initialize: aSymbolOrString asString</body></methods><methods><class-id>DST.DSTexception</class-id> <category>testing</category><body package="DST_Core">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/ExceptionDef:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="DST_Core">isDSTexception	^true</body></methods><methods><class-id>DST.DSTexception</class-id> <category>Exception Def</category><body package="DST_Core">description	"return an operation description"	^(DSTexceptionDescription new)		name: name;		id: self id; 		definedIn: self definedInString;		version: self version;		type: members;		yourself</body><body package="DST_Core">members	"return the members of the receiver"	^members members</body><body package="DST_Core">members: newMembers 	"return the members of the receiver"	self notYetImplemented</body><body package="DST_Core">type	"return the members of the receiver"	^members</body></methods><methods><class-id>DST.DSTexception</class-id> <category>printing</category><body package="DST_Core">definitionString	"return my unformatted IDL definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: 'exception '; nextPutAll: name; nextPutAll: ' {'.	members fields do: [:fld | aStream nextPutAll: fld definitionString; nextPut: $ ; nextPutAll: fld declaratorString; nextPutAll: '; '].	aStream nextPut: $}.	^aStream contents</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver on the stream"	| unformatted |	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level.	unformatted := self definitionString.	(self		stringNeedsFormatting: unformatted		indent: level		style: aTextStyleName)		ifTrue: 			[aStream nextPutAll: 'exception '; nextPutAll: name; nextPutAll: ' {'; cr.			members fields				do: 					[:fld | 					aStream tab: level + 1.					fld						printFormattedOn: aStream						indent: level + 1						style: aTextStyleName.					aStream nextPut: $ ; nextPutAll: fld declaratorString; nextPut: $;; cr].			aStream tab: level; nextPut: $}]		ifFalse: [aStream nextPutAll: unformatted].	aStream nextPut: $;; cr</body><body package="DST_Core">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'exception ' , self idlName</body></methods><methods><class-id>DST.DSTexception</class-id> <category>accessing</category><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	members definedIn: aMetaObject</body><body package="DST_Core">errorSignal	"return the receiver's error signal object. The instance variable signal must be laze initialized because in the parcel suppotwe have to nil it out."	^signal isNil		ifTrue: 			[signal := Object errorSignal newSignalMayProceed: false.			signal nameClass: self class message: self name.			signal notifierString: 'ORB Exception (' , name , ') -']		ifFalse: [signal]</body><body package="DST_Core">errorType	"return the type of the exception"	^members</body></methods><methods><class-id>DST.DSTexception</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^members allComponents</body><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^members hasComponents</body></methods><methods><class-id>DST.DSTexception</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::ExceptionDef'</body><body package="DST_Core">allMetaObjectsInto: aSet 	"add all of the referenced metaobjects to the set"	super allMetaObjectsInto: aSet.	members allMetaObjectsInto: aSet</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Exception</body></methods><methods><class-id>DST.DSTexception</class-id> <category>creation</category><body package="DST_Core">id: anId  members: anArray	"initialize the receiver"	name := anId. 	members := DSTtypeStructure on: anArray.	signal := Object errorSignal newSignalMayProceed: false.	signal nameClass: self class message: anId.	signal notifierString: 'ORB Exception (' , name , ') -'.</body></methods><methods><class-id>DST.DSTexception</class-id> <category>parcel support</category><body package="DST_Core">traceFrom: aTracer 	"Don't trace my signal"		"We have to remove the signal from cache, CORBAConstants.	DO NOT remove the following	line unless you absolutely know what you are doing."	signal notNil		ifTrue: [CORBAConstants removeKey: self idlName asSymbol ifAbsent: [] ].	signal := nil.	super traceFrom: aTracer.</body></methods><methods><class-id>DST.DSTcachedException</class-id> <category>private</category><body package="DST_Core">id: anId idlName: aFullName repositoryId: aRepositoryId members: aByteArray 	"initialize the receiver"	name := anId.	idlName := aFullName.	repositoryId := RepositoryId fromString: aRepositoryId.	typeCodeInfo := aByteArray.	members := DSTMetaObject unMarshallTypeCode: Dictionary new from: (DSTTypeCodeStream with: aByteArray) reset.	signal := Object errorSignal newSignalMayProceed: false.	signal notifierString: 'ORB Exception (' , name , ') -'.	signal nameClass: self class message: anId.</body></methods><methods><class-id>DST.DSTcachedException</class-id> <category>errorType</category><body package="DST_Core">errorTypeCodeInfo	"return the type of the exception"	^typeCodeInfo ifNil: [self class intfReposError: 0]</body></methods><methods><class-id>DST.DSTcachedException</class-id> <category>repository</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SharedIR::CachedException'</body></methods><methods><class-id>DST.DSTcachedException</class-id> <category>accessing</category><body package="DST_Core">idlName 	^idlName</body></methods><methods><class-id>DST.DSTcachedException class</class-id> <category>instance creation</category><body package="DST_Core">name: aSymbol idlName: aString repositoryId: aRepositoryId errorTypeCodeInfo: aByteArray		^(self new) id: aSymbol idlName: aString repositoryId: aRepositoryId members: aByteArray; yourself</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>printing</category><body package="DST_Core">IDLTypeName	"return the printable name of the receiver's IDL type ie the type to be	actually marshalled in the NCS packet"	^name</body><body package="DST_Core">hasPragma	"return true if the receiver has a pragma string"	^true</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print the IDL definition of the receiver onto the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it 	is important that the first token of an IDL 'method' is parsed 	correctly by 	Parser. Specifically, it must be avoided that the pound sign is the 	first 	character in the method, since it would cause a parsing problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make 	sure that there is always at least one comment line. Also note, that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll:  prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]]. 	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	self		printInterfaceHeaderOn: aStream		indent: level		style: aTextStyleName.	self printODLHeaderOn: aStream level: level.	aStream nextPut: ${.	contents isEmpty		ifFalse: 			[aStream cr; cr.			(1 to: contents size)				do: 					[:i | 					(i &gt; 1 and: [(contents at: i - 1) wantsSpace or: [(contents at: i) wantsSpace]])						ifTrue: [aStream cr].					(contents at: i)						printDefinitionOn: aStream						indent: level + 1						style: aTextStyleName].			aStream tab: level].	aStream nextPutAll: '};'; cr</body><body package="DST_Core">printInterfaceHeaderOn: aStream indent: level style: aTextStyleName 	"print the name and the superiors of the receiver"	| tempStream su |	tempStream := (String new: 80) writeStream.	tempStream nextPutAll: 'interface '; nextPutAll: name asString.	su := sunames asOrderedCollection.	su remove: #Object ifAbsent: [].	su isEmpty		ifFalse: 			[tempStream nextPutAll: ' : '.			(1 to: su size - 1)				do: [:i | tempStream nextPutAll: (su at: i) asString; nextPutAll: ', '].			tempStream nextPutAll: su last asString].	aStream tab: level.	(self		stringNeedsFormatting: tempStream contents		indent: level		style: aTextStyleName)		&amp; su isEmpty not ifFalse: [aStream nextPutAll: tempStream contents; nextPut: $ ]		ifTrue: 			[aStream nextPutAll: 'interface '; nextPutAll: name asString; nextPutAll: ' :'.			(1 to: su size - 1)				do: [:i | aStream crtab: level + 4; nextPutAll: (su at: i) asString; nextPutAll: ', '].			aStream crtab: level + 4; nextPutAll: su last asString; crtab: level]</body><body package="DST_Core">printODLHeaderOn: aStream level: level 	"print ODL extent and key information if it is present"	| last |	extent notNil | key notNil		ifTrue: 			[aStream cr; tab: level; nextPut: $(; tab.			extent notNil ifTrue: [aStream nextPutAll: 'extent'; tab; nextPutAll: extent; cr; tab: level + 1].			key isEmpty				ifFalse: 					[(key isMemberOf: Array)						ifTrue: [aStream nextPutAll: 'keys'; tab]						ifFalse: [aStream nextPutAll: 'key'; tab].					last := key at: key size.					key						do: 							[:k | 							(k isMemberOf: Array)								ifTrue: 									[aStream nextPut: $(; nextPutAll: (k at: 1).									2 to: k size do: [:i | aStream nextPutAll: ', '; nextPutAll: (k at: i)].									aStream nextPut: $)]								ifFalse: [aStream nextPutAll: k].							k == last ifFalse: [aStream nextPutAll: ', ']]].			aStream nextPut: $); cr; tab: level]</body><body package="DST_Core">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'interface ' , self idlName</body><body package="DST_Core">publishDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver onto the stream, with no pragmas"	self printHeaderOn: aStream indent: level.	self		printInterfaceHeaderOn: aStream		indent: level		style: aTextStyleName.	self printODLHeaderOn: aStream level: level.	aStream nextPut: ${.	contents isEmpty		ifFalse: 			[aStream cr; cr.			(1 to: contents size)				do: 					[:i | 					(i &gt; 1 and: [(contents at: i - 1) wantsSpace or: [(contents at: i) wantsSpace]])						ifTrue: [aStream cr].					(contents at: i)						publishDefinitionOn: aStream						indent: level + 1						style: aTextStyleName].			aStream tab: level].	aStream nextPutAll: '};'; cr</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	(self canMarshall: aParameter)		ifTrue: [aStream nextPutObjectReference: aParameter]		ifFalse: [self class marshallError: 0]</body><body package="DST_Core">canMarshall: aParameter 	"return if the receiver can marshall the given parameter"	^aParameter == nil or: [name == #SmalltalkObject or: [name == #ClassObject or: [aParameter CORBAInterface isAko: self]]]</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		aParameter == nil ifTrue: [^#mappable].	^name == #SmalltalkObject or: [name == #ClassObject or: [aParameter CORBAInterface isAko: self]]</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	| pos |	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	pos := aStream nextPutEncapsulationHeader.	aStream nextPutString: self repositoryId; nextPutString: self printName.	aStream setEncapsulationLength: pos</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class. Subclasses must overload"	^aStream nextObjectReference: self</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream 	"unMarshall the type code of the receiver"	|  byteOrder |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextString.	name := aStream nextString.	repositoryId isEmpty		ifTrue: [^self class badTypecodeError: 0]		ifFalse: [repositoryId := RepositoryId fromString: repositoryId].	aStream byteOrder: byteOrder</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>searching</category><body package="DST_Core">allAttributes	"returns an ordered collection of all of the attributes defined by the 	receiver and its direct supertypes"	| allAttributes |	allAttributes := OrderedCollection new.	self withAllSuperiors do: [:if | allAttributes addAll: if attributes].	^allAttributes</body><body package="DST_Core">allAttributes: oList avoiding: iSet 	"returns an ordered collection of all of the attributes defined by the 	receiver and its direct supertypes. Add the receiver to the set and do not 	revisit any IFs in that set"	iSet add: self.	self attributes do: [:op | oList add: op].	superiors do: [:su | (iSet includes: su)			ifFalse: [su allAttributes: oList avoiding: iSet]]</body><body package="DST_Core">allOperations	"returns an ordered collection of all of the operations defined by the 	receiver and its direct supertypes"	| ifs | 	^allOperations notNil		ifTrue: [allOperations]		ifFalse: 			[allOperations := OrderedCollection new.			ifs := self withAllSuperiors.			ifs do: [:if | allOperations addAll: if operations].			allOperations]</body><body package="DST_Core">allOperations: oList avoiding: iSet 	"returns an ordered collection of all of the operations defined by the 	receiver and its direct supertypes. Add the receiver to the set and do not 	revisit any IFs in that set"	iSet add: self.	self operations do: [:op | oList add: op].	superiors do: [:su | (iSet includes: su)			ifFalse: [su allOperations: oList avoiding: iSet]]</body><body package="DST_Core">findOpByIndex: index 	"find the DSToperation by its index in the interface. Return an 	array with the operation and its local opSelector"	| op ops | 	ops := self entryPointVector.	(index between: 0 and: ops size - 1) ifFalse: [self class badOperationError: 0].	op := self operations at: (ops at: index + 1).	^Array with: op with: op localOp</body><body package="DST_Core">findOpByIndex: index version: requestedVersion 	"Find the operation by its index in the interface. Raise an exception if the 	index is invalid or if requestedVersion is not compatible (greater than) the 	version of the receiver. Return an array with the operation and its local 	opSelector"	| result |	result := self findOpByIndex: index.	self version &lt; requestedVersion ifTrue: [self class badOperationError: #'M_IF_VERSION_MISMATCH'].	^result</body><body package="DST_Core">findOpByName: aString 	"find the DSToperation by its name in the interface. Return an 	array with the operation and its local opSelector"	| sym |	sym := aString asSymbol.	^self allOperations detect: [:oper | oper name == sym]		ifNone: [self findOpByName: sym forInterface: (ORBObject lookupMetaId: #'SmalltalkSpecific::SmalltalkObject')]</body><body package="DST_Core">findOpBySelector: opSelector	"... find the DSToperation in the interface by its selector.  Return an OperationInfo object."	| op |	op := self findOpInMyVector: opSelector.	op isNil		ifTrue: [self allSuperiors do: [:sup | (op := sup findOpInMyVector: opSelector) notNil ifTrue: [^op asOperationInfo]]]		ifFalse: [^op asOperationInfo].	^DSTModules i3 newOperationInfoForInterface: self selector: opSelector</body><body package="DST_Core">findOpInMyVector: opSelector 	"find the DSToperation in the this interface by its selector. Return an 	Operation object"	 	^self operations at: opSelector ifAbsent: [nil]</body><body package="DST_Core">findOpInSubordinate: opSelector avoiding: iSet 	"find the DSToperation in the interface by its selector. Return an array with: 	#(theInterface theOperation theOpSelector theOpIndex)"	| if ar |	iSet add: self.	self allOperations do: [:op | op localOp == opSelector ifTrue: [^Array				with: (if := op definingMetaContainer)				with: op				with: opSelector				with: (if entryPointVector indexOf: opSelector)						- 1				with: self]].	subordinates do: [:sub | (iSet includes: sub)			ifFalse: 				[ar := sub findOpInSubordinate: opSelector avoiding: iSet.				ar notNil ifTrue: [^ar]]].	^nil</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>InterfaceDef</category><body package="DST_Core">baseInterfaceIds	"return the ids of the base interfaces of the receiver"	^self allSuperiors asOrderedCollection collect: [:if | if id]</body><body package="DST_Core">baseInterfaces	"return the base interfaces of the receiver"	^self allSuperiors</body><body package="DST_Core">baseInterfaces: interfaces 	"Setting baseInterfaces returns an error if the name attribute of any 	object contained by this interface conflicts with the name attribute 	of any object contained by any of the specified base interfaces."	self notYetImplemented</body><body package="DST_Core">createAttribute: anId name: aName version: aVersion type: anIDLType mode: anAttributeMode 	"The createAttribute operation returns a new AttributeDef contained 	in the receiver. The id, name, version, type, and mode attributes are 	set as specified. The type attribute is also set. The definedIn 	attribute is initialized to identify the containing interface. An error is 	returned if an object with the specified id already exists within the 	receiver's repository, or if an object with the specified name already 	exists within this interface."	self notYetImplemented</body><body package="DST_Core">createOperation: anId name: aName version: aVersion result: anIDLType mode: anOperationMode params: paramList exceptions: exceptionList contexts: contextList 	"The createOperation operation returns a new OperationDef 	contained in the receiver. The id, name, version, result, mode, 	params, exceptions, and context attributes are 	set as specified. The result attribute is also set. The definedIn 	attribute is initialized to identify the containing interface. An error is 	returned if an object with the specified id already exists within the 	receiver's repository, or if an object with the specified name already 	exists within this interface."	self notYetImplemented</body><body package="DST_Core">describeImplementation	"returns a FullImplementationDescription struct"	^Dictionary		with: #name -&gt; name		with: #id -&gt; self id		with: #definedIn -&gt; self definingMetaObject id		with: #methods -&gt; self entryPointVector</body><body package="DST_Core">describeInterface	"return a FullInterfaceDescription of the receiver"	^(Dictionary new)	add: #name -&gt; name;	add: #id -&gt; self id;	add: #definedIn -&gt; self definedInString;	add: #version -&gt; self version;	add: #operations -&gt; ((contents select: [:co | co isDSTMetaObject and: [co isDSToperation]])				collect: [:op | op description]);	add: #attributes -&gt; ((contents select: [:co | co isDSTMetaObject and: [co isDSTattribute]])				collect: [:at | at description]);	add: #baseInterfaces -&gt; self baseInterfaceIds;	add: #type -&gt; self;	yourself</body><body package="DST_Core">description	"return an interface description"	^(Dictionary new) 		add: #name -&gt; name; 		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedInString; 		add: #version -&gt; self version;		add: #baseInterfaces -&gt; self baseInterfaceIds;		yourself</body><body package="DST_Core">isA: interfaceId 	"isA returns TRUE if the receiver is identical to or inherits, directly or 	indirectly, from the interface identified by the parameter. Otherwise 	it returns FALSE."	| targetId |	targetId := RepositoryId fromString: interfaceId.	self repositoryId == targetId ifTrue: [^true].	self allSuperiors do: [:sup | sup repositoryId == targetId ifTrue: [^true]].	^false</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>accessing</category><body package="DST_Core">addSubordinate: anInterface 	"private - add a subordinate DSTinterface to the interface, at the end of the 	list"	anInterface isDSTinterface		ifTrue: [(self subordinates includes: anInterface)				ifFalse: [self subordinates add: anInterface]]		ifFalse: [self error: 'Can only add interfaces as subordinates']</body><body package="DST_Core">allSuperiors	"return the transitive closure of the receiver's superiors"	allSuperiors isNil		ifTrue: 			[(name == #SharedInterfaceRepository and: [self class remoteRepository notNil])				ifTrue: [allSuperiors := Set new]				ifFalse: [allSuperiors := Set with: (ORBObject lookupInterfaceId: #'::CORBA::Object')].			superiors do: [:if | if allSuperiorsAvoiding: allSuperiors]].	^allSuperiors</body><body package="DST_Core">allSuperiorsAvoiding: iSet 	"return the transitive closure of the receiver's superiors. Avoid 	recursing to the members of the set"	iSet add: self.	superiors do: [:if | (iSet includes: if)			ifFalse: [if allSuperiorsAvoiding: iSet]]</body><body package="DST_Core">attributes	"return the receiver's attributes"	contents isNil ifTrue: [^#()].	^contents select: [:obj | obj isDSTMetaObject and: [obj isDSTattribute]]</body><body package="DST_Core">entryPointVector	"return the epv of the receiver"	epv isNil		ifTrue: 			[epv := OrderedCollection new.			contents				do: 					[:co | 					(co isDSTMetaObject and: [co isDSTattribute])						ifTrue: 							[epv addAll: (co getOperations collect: [:op | op localOp]).							epv addAll: (co setOperations collect: [:op | op localOp])].					co class == DSToperation ifTrue: [epv add: co localOp]]].	^epv</body><body package="DST_Core">fullEntryPointVector	"return the complete epv of the receiver"	| res ifs |	res := OrderedCollection new.	ifs := self withAllSuperiors.	ifs do: [:if | res addAll: if entryPointVector].	^res</body><body package="DST_Core">grandSuperiors	"return the receiver's non-immediate superiors"	^self allSuperiors - self superiors</body><body package="DST_Core">operations	"return the receiver's operations"	| ops |	^myOperations		ifNil: 			[contents isNil ifTrue: [myOperations := IdentityDictionary new].			ops := IdentityDictionary new.			contents				do: 					[:obj | 					(obj isDSTMetaObject and: [obj isDSToperation])						ifTrue: [ops at: obj localOp put: obj].					(obj isDSTMetaObject and: [obj isDSTattribute])						ifTrue: 							[obj getOperations do: [:getOp | ops at: getOp localOp put: getOp].							obj setOperations do: [:setOp | ops at: setOp localOp put: setOp]]].			myOperations := ops]</body><body package="DST_Core">removeSubordinate: anInterface 	"private - remove a subordinate DSTinterface from the interface"	subordinates notNil ifTrue: [subordinates remove: anInterface ifAbsent: []]</body><body package="DST_Core">removeSuperior: anInterface 	"private - remove a superior DSTinterface from the interface"	superiors remove: anInterface ifAbsent: [].	allSuperiors := nil.	self subordinates do: [:sub | sub removeSuperior: anInterface].</body><body package="DST_Core">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope. Currently, only structures have sufficent 	information to be able to resolve.  Do nothing here"</body><body package="DST_Core">subordinates	"return the receiver's immediate subordinates"	subordinates isNil ifTrue: [subordinates := OrderedCollection new].	^subordinates</body><body package="DST_Core">subordinates: aCollection	"set the receiver's immediate subordinates"	subordinates := aCollection</body><body package="DST_Core">sunames	"return the receiver's immediate sunames"	sunames isNil ifTrue: [^#()].	^sunames</body><body package="DST_Core">superiors	"return the receiver's immediate superiors"	superiors isNil ifTrue: [superiors := Set new].	^superiors</body><body package="DST_Core">superiors: aSet	"set the receiver's immediate superiors"	superiors := aSet</body><body package="DST_Core">withAllSuperiors	"return the transitive closure of the receiver's superiors"		| sup |	sup := Set new: (self allSuperiors size + 1).	sup add: self.	sup addAll: self allSuperiors.	^sup</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>initializing</category><body package="DST_Core">initialize	"private - initialize the instance variables of the receiver"	super initialize.	contents := OrderedCollection new.	superiors := Set new.	subordinates := Set new.	symbols := Dictionary new</body><body package="DST_Core">n: aName s: supers d: aDescr b: aBody 	"private - initialize the instance variables: 	name = a printable name symbol 	definition = a printable description of the interface 	contents = an ordered collection of constants, types, attributes, 	operations, and events 	superiors = a set of DST interfaces"	aName isSymbol		ifFalse: [self error: 'Print name must be a symbol'].	repositoryId := nil.	name := aName.	definition := aDescr.	contents := aBody asOrderedCollection.	superiors := Set new.	subordinates := Set new.	sunames := supers.	aBody		do: 			[:bod | 			bod definedIn: self.			self registerMetaObject: bod]</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>generation</category><body package="DST_Core">generateClassAttributes: override 	"generate and compile Smalltalk method definitions for my attributes"	| aStream param aname aClass |	aClass := name asQualifiedReference valueOrDo: [override or: [self generateClassDef]].	aStream := String new writeStream.	self attributes		do: 			[:attr | 			aname := self convertSymbol: attr printName.			attr getOperations do: [:op | (override or: [(aClass includesSelector: op localOp) not])					ifTrue: 						[aStream nextPutAll: '!' , name , ' methodsFor: ''attributes''!'; cr.						aStream nextPutAll: op localOp; cr.						aStream tab; nextPutAll: '"get the value of the attribute"'; cr.						aStream cr; tab; nextPutAll: '^' , aname , ' ! !'; cr; cr]].			attr setOperations do: [:op | (override or: [(aClass includesSelector: op localOp) not])					ifTrue: 						[aStream nextPutAll: '!' , name , ' methodsFor: ''attributes''!'; cr.						param := self convertSymbol: 'a_' , op signature inParameters first type printName.						aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.						aStream tab; nextPutAll: '"set the value of the attribute"'; cr.						aStream cr; tab; nextPutAll: aname , ' := ' , param , '.'; cr.						aStream tab; nextPutAll: 'self changed: #' , aname , ' with: self.'; cr.						aStream nextPutAll: ' ! !'; cr; cr]]].	^aStream contents</body><body package="DST_Core">generateClassDef	"generate and compile a Smalltalk class definition with my name"	(self generateClassDefinition: true) readStream fileIn.	^name asQualifiedReference value</body><body package="DST_Core">generateClassDefinition: override 	"generate and compile a Smalltalk class definition with my name"	| instvars aClass superclass category aStream |	instvars := ''.	self attributes do: [:attr | instvars := instvars , ' ' , (self convertSymbol: attr printName)].	aClass :=name asQualifiedReference valueOrDo: [].	aClass isNil		ifTrue: 			[superclass := Object.			category := 'IDL-Classes']		ifFalse: 			[override ifFalse: [^''].			superclass := aClass superclass.			category := aClass category].	aStream := String new writeStream.	aStream nextPutAll: superclass name , ' subclass: #' , name , '	instanceVariableNames: ''' , instvars , '''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , category , ''' !'; cr.	^aStream contents</body><body package="DST_Core">generateClassOperations: override	"generate and compile Smalltalk method definitions for my operations"	| aStream opstr typ parmBag sym aClass |	aClass := name asQualifiedReference valueOrDo: [override or: [self generateClassDef]].	aStream := String new writeStream.	(contents select: [:obj | obj isDSTMetaObject and: [obj isDSToperation]])		do: [:op | (override or: [(aClass includesSelector: op localOp) not])				ifTrue: 					[parmBag := Bag new.					aStream nextPutAll: '!' , name , ' methodsFor: ''' , self printName , '''!'; cr.					opstr := op localOp asString readStream.					aStream nextPutAll: (opstr upTo: $:).					op signature inParameters						do: 							[:parm | 							aStream nextPut: $:; nextPut: $ .							typ := parm type printName replaceAll: $  with: $_.							sym := self convertSymbol: 'a_' , typ.							parmBag add: sym.							(parmBag occurrencesOf: sym)								= 1 ifFalse: [sym := sym asString , (parmBag occurrencesOf: sym) asString].							aStream nextPutAll: sym.							aStream nextPut: $ ; nextPutAll: (opstr upTo: $:)].					aStream cr; nextPut: $".					op publishDefinitionOn: aStream indent: 1 style: #default.					aStream nextPut: $"; cr; tab; nextPutAll: '^self   ! !'; cr; cr]].	^aStream contents</body><body package="DST_Core">generateClassSkeleton: override	"generate and compile a Smalltalk class skeleton with my name"	| aStream |	aStream := String new writeStream.	aStream nextPutAll: (self generateClassDefinition: override); cr; cr.	aStream nextPutAll: (self generateClassAttributes: override); cr; cr.	aStream nextPutAll: (self generateClassOperations: override); cr; cr.	^aStream contents</body><body package="DST_Core">generateRelationship: rel addOp: op on: aStream 	"generate the addRelationship operation"	| param |	aStream nextPutAll: '!' , name , ' methodsFor: ''admin-relationships''!'; cr.	param := self convertSymbol: 'a_' , op signature inParameters first type equivalentType printName.	aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.	aStream tab; nextPutAll: '"add a value to the relationship"'; cr; cr.	aStream tab; nextPutAll: 'self ' , rel printName , ' add: ' , param , '.'; cr.	aStream tab; nextPutAll: 'self changed: #' , rel printName , ' with: self  ! !'; cr; cr</body><body package="DST_Core">generateRelationship: rel assertOp: op on: aStream param: param 	"generate the assert operations on the relationship"	| inverse |	aStream nextPutAll: '!' , name , ' methodsFor: ''relationships''!'; cr.	aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.	aStream tab; nextPutAll: '"form the relationship"'; cr; cr.	rel inverse isNil		ifFalse: 			[inverse := self metaObjectOf: rel inverse.			inverse isMultiValued				ifTrue: [aStream tab; nextPutAll: param , ' ' , inverse addOperation localOp , ' self.'; cr]				ifFalse: [aStream tab; nextPutAll: param , ' ' , inverse setOperation localOp , ' self.'; cr]].	rel isMultiValued		ifTrue: [aStream tab; nextPutAll: 'self ' , rel addOperation localOp , ' ' , param; cr]		ifFalse: [aStream tab; nextPutAll: 'self ' , rel setOperation localOp , ' ' , param; cr].	aStream cr</body><body package="DST_Core">generateRelationship: rel getOp: op on: aStream 	"generate the getOp method for the class"	| reltype |	aStream nextPutAll: '!' , name , ' methodsFor: ''relationships''!'; cr.	aStream nextPutAll: op localOp; cr.	aStream tab; nextPutAll: '"get the value of the relationship"'; cr.	reltype := rel isMultiValued				ifTrue: [' := ' , (self convertSymbol: '_' , rel target printName) , ' new']				ifFalse: [''].	aStream cr; tab; nextPutAll: '^' , rel printName , ' ifNil: [' , rel printName , reltype , '] ! !'; cr; cr</body><body package="DST_Core">generateRelationship: rel removeOp: op on: aStream 	"generate the remove operation on the relationship"	| param |	aStream nextPutAll: '!' , name , ' methodsFor: ''admin-relationships''!'; cr.	param := self convertSymbol: 'a_' , op signature inParameters first type equivalentType printName.	aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.	aStream tab; nextPutAll: '"remove a value from the relationship"'; cr.	aStream cr; tab; nextPutAll: 'self ' , rel printName , ' remove: ' , param , '.'; cr.	aStream tab; nextPutAll: 'self changed: #' , rel printName , ' with: self.'; cr.	aStream nextPutAll: ' ! !'; cr; cr</body><body package="DST_Core">generateRelationship: rel retractOp: op on: aStream param: param 	"generate the retract operations on the relationship"	| inverse |	aStream nextPutAll: '!' , name , ' methodsFor: ''relationships''!'; cr.	aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.	aStream tab; nextPutAll: '"drop the relationship"'; cr; cr.	rel inverse isNil		ifFalse: 			[inverse := self metaObjectOf: rel inverse.			inverse isMultiValued				ifTrue: [aStream tab; nextPutAll: param , ' ' , inverse removeOperation localOp , ' self.'; cr]				ifFalse: [aStream tab; nextPutAll: param , ' ' , inverse setOperation localOp , ' nil.'; cr]].	rel isMultiValued		ifTrue: [aStream tab; nextPutAll: 'self ' , rel removeOperation localOp , ' ' , param; cr]		ifFalse: [aStream tab; nextPutAll: 'self ' , rel setOperation localOp , ' nil'; cr].	aStream cr</body><body package="DST_Core">generateRelationship: rel setOp: op on: aStream 	"generate the set, assert, and retract operations on the relationship"	| param |	param := self convertSymbol: 'a_' , op signature inParameters first type printName.	('_form*' match: op printName asString)		ifTrue: [self				generateRelationship: rel				assertOp: op				on: aStream				param: param]		ifFalse: [('_drop*' match: op printName asString)				ifTrue: [self						generateRelationship: rel						retractOp: op						on: aStream						param: param]				ifFalse: 					[aStream nextPutAll: '!' , name , ' methodsFor: ''admin-relationships''!'; cr.					aStream nextPutAll: op localOp; nextPutAll: ' ' , param; cr.					aStream tab; nextPutAll: '"set the value of the relationship"'; cr.					aStream cr; tab; nextPutAll: rel printName , ' := ' , param , '.'; cr.					aStream tab; nextPutAll: 'self changed: #' , rel printName , ' with: self.'; cr]].	aStream nextPutAll: ' ! !'; cr; cr</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CompoundDefs::InterfaceCompoundDef'</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="DST_Core">checkReferencesUniqueness	"check if all referenced superiors can be resolved uniquely" 		[DSTmoduleRepository convenientNameResolution: false.	sunames asSet		do: 			[:na | 			| ref |			ref := self definingMetaObject interfaceOf: na.			ref size &gt; 1 ifTrue: [Dialog notify: 'Interface ''' , self printName , ''' inherits from ambiguous ''' , na asString , '''']]]		ensure: [DSTmoduleRepository convenientNameResolution: true]</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Interface</body><body package="DST_Core">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	| res |	^symbols at: aSymbol		ifAbsent: 			[self allSuperiors do: [:if | (res := if searchScopeFor: aSymbol) notNil ifTrue: [^res]].			^self definingMetaObject metaObjectOf: aSymbol]</body><body package="DST_Core">removeMetaObject	"Enable the receiver to be garbage collected"	super removeMetaObject.	self superiors do: [:sup | sup removeSubordinate: self].	self subordinates do: [:sub | sub removeSuperior: self].	superiors := subordinates := epv := allOperations := myOperations := nil.	sunames := #()</body><body package="DST_Core">resetInheritance	"reset instance variables related to inheritance"	subordinates := Set new.	superiors := Set new.	allOperations := myOperations := allSuperiors := nil.</body><body package="DST_Core">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	| str x head tail |	str := aSymbol asString.	x := str findFirst: [:ch | ch = $:].	x isZero		ifTrue: [^symbols at: aSymbol ifAbsent: [nil]]		ifFalse: 			[x = 1 ifTrue: [^nil].			head := str copyFrom: 1 to: x - 1.			tail := str copyFrom: x + 2 to: str size.			^(symbols at: head asSymbol ifAbsent: [^nil])				searchScopeFor: tail asSymbol].	^nil</body><body package="DST_Core">setInheritance	"resolve inheritance references to named interfaces in the repository" 	superiors := sunames asSet collect: [:na | self definingMetaObject interfaceOf: na].	superiors do: [:if | if addSubordinate: self].	repositoryId isNil ifTrue: [ self repositoryId].	RepositoryCache at: repositoryId put: self.</body><body package="DST_Core">unlinkFromRepository	"The receiver is being removed from the repository. Unlink as 	required"	super unlinkFromRepository.	self superiors do: [:sup | sup removeSubordinate: self].	self subordinates do: [:sub | sub removeSuperior: self].	superiors := subordinates := epv := allOperations := myOperations := nil.	sunames := #().	DSTObjRef withAllSubclasses do: [:cl | cl allInstances do: [:inst | inst clearInterfaceReferencesTo: self]]</body><body package="DST_Core">updateInheritance	"resolve missing inheritance references, if possible, to named 	interfaces in the repository"	| if |	(name isMemberOf: ORBDeadObject)		ifTrue: [^nil].	allOperations := myOperations := allSuperiors := nil.	self sunames asSet - (self superiors asSet collect: [:su | su printName])		do: 			[:na | 			if := self definingMetaObject interfaceOf: na.			if isNil ifTrue: [^nil].			if addSubordinate: self.			superiors add: if]</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>rendering</category><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^self superiors isEmpty not or: [self allComponents isEmpty not]</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>testing</category><body package="DST_Core">IIOPIsA: aString	aString asString = 'IDL:CORBA/InterfaceDef:1.0' ifTrue:[^true].	^super IIOPIsA: aString</body><body package="DST_Core">isAko: anInterface 	"succeed if anInterface is in my superiors list"	anInterface name == #Object		ifTrue: [^true]		ifFalse: [self withAllSuperiors do: [:if | if repositoryId == anInterface repositoryId ifTrue: [^true]]].	^false</body><body package="DST_Core">isDSTinterface	^true</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>parcel support</category><body package="DST_Core">storeGeneralStructureOn: aBinaryStorageWriter	"We need to cut of the subordinates of the dstInterface"	| save |	save :=  subordinates.	subordinates := nil.	super storeGeneralStructureOn: aBinaryStorageWriter.	subordinates := save.</body><body package="DST_Core">traceFrom: aTracer 	aTracer doTraceOfDSTInterface: self</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>TypeCode</category><body package="DST_Core">type	"return the type code of the receiver"	^self</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_objref</body><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^1</body><body package="DST_Core">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^repositoryId printString ].	self error: #Bounds</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_objref</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>repository-private</category><body package="DST_Core">canContain: kind 	"Check to see if the definition kind can be contained in the receiver."	^#(#dk_Constant #dk_Typedef #dk_Exception #dk_Attribute #dk_Operation) includes: kind</body></methods><methods><class-id>DST.DSTinterface</class-id> <category>private</category><body package="DST_Core">findOpByName: aSymbol forInterface: anInterface	"... find the DSToperation by its name in the specified interface."	^anInterface class == self class		ifTrue: [anInterface allOperations detect: [:oper | oper name == aSymbol]				ifNone: [DSTModules i3 newOperationFor: aSymbol]]		ifFalse: [nil]</body></methods><methods><class-id>DST.DSTcachedInterface</class-id> <category>accessing</category><body package="DST_Core">epv	^epv</body><body package="DST_Core">identity	^repositoryId</body><body package="DST_Core">idlName	^idlName</body><body package="DST_Core">operations	"return the receiver's operations"	myOperations isNil		ifTrue: 			[myOperations := IdentityDictionary new.			epv do: [:sel | myOperations at: sel put: nil]].	^myOperations</body><body package="DST_Core">updateInheritance	"resolve missing inheritance references, if possible, to named 	interfaces in the repository"	(name isMemberOf: ORBDeadObject)		ifTrue: [^nil].	allOperations := myOperations := allSuperiors := nil</body></methods><methods><class-id>DST.DSTcachedInterface</class-id> <category>searching</category><body package="DST_Core">allOperations	"returns an ordered collection of all of the operations defined by the 	receiver and its direct supertypes. This method will retrieve cached 	operations if needed"	| ifs | 	^allOperations notNil		ifTrue: [allOperations]		ifFalse: 			[allOperations := OrderedCollection new.			ifs := self withAllSuperiors.			ifs do: [:if | if entryPointVector do: [:opSelector | allOperations add: (self findOpBySelector: opSelector) operation]].			allOperations]</body><body package="DST_Core">findOpByIndex: index 	"find the DSToperation by its index in the interface. Return an 	array with the operation and its local opSelector"	| op opSelector |	(index between: 0 and: epv size - 1)		ifFalse: [self class badOperationError: 0].	opSelector := epv at: index + 1.	op := self operations at: opSelector.	op isNil ifTrue: [(ORBObject remoteRepository notNil and: [ORBDaemon running])			ifTrue: 				[op := ORBObject remoteRepository getCachedOperation: opSelector interface: self repositoryId.				op definedIn asUUID == self repositoryId					ifTrue: [op definedIn: self]					ifFalse: [self class intfReposError: 0].				self operations at: opSelector put: op]			ifFalse: [self class intfReposError: 0]].	^Array with: op with: op localOp</body><body package="DST_Core">findOpInMyVector: opSelector 	"find the DSToperation in the this interface by its selector. Return an 	Operation object"	| op |	op := self operations at: opSelector ifAbsent: [^nil].	op isNil ifTrue: [(ORBObject remoteRepository notNil and: [ORBDaemon running])			ifTrue: 				[op := ORBObject remoteRepository getCachedOperation: opSelector interface: self repositoryId.				(RepositoryId fromString: op definedIn) == self repositoryId					ifTrue: [op definedIn: self]					ifFalse: [self class intfReposError: 0].				self operations at: opSelector put: op.				^op]].	^op</body></methods><methods><class-id>DST.DSTcachedInterface</class-id> <category>repository</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SharedIR::CachedInterface'</body></methods><methods><class-id>DST.DSTcachedInterface</class-id> <category>private</category><body package="DST_Core">name: aName idlName: aFullName repositoryId: anId superiors: aSupCollection epv: anEntryPointVector	name := aName.	idlName := aFullName.	repositoryId := RepositoryId fromString: anId.	superiors := aSupCollection.	epv := anEntryPointVector.</body></methods><methods><class-id>DST.DSTcachedInterface class</class-id> <category>instance creation</category><body package="DST_Core">name: aName idlName: aFullName repositoryId: anId superiors: aSupCollection epv: anEntryPointVector 	^(self new)		name: aName		idlName: aFullName		repositoryId: anId		superiors: aSupCollection asSet		epv: anEntryPointVector; yourself</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>initialize-release</category><body package="DST_Core">initSize: aSize 	keys := WeakArray new: aSize.	values := Array new: aSize.	tally := 0.	self makeDependent</body><body package="DST_Core">makeDependent	keys addDependent: self.</body><body package="DST_Core">release	keys release.	values release.	super release.</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>accessing</category><body package="DST_Core">associations	"Answer an OrderedCollection containing the receiver's associations in an 	arbitrary order."	| aCollection |	aCollection := OrderedCollection new: tally.	self associationsDo: [:assn | aCollection add: assn].	^aCollection</body><body package="DST_Core">at: key 	"Answer the value at key.  If key is not found, raise a signal."	^self at: key ifAbsent: [self keyNotFoundError: key]</body><body package="DST_Core">at: key ifAbsent: aBlock 	"Answer the value at key. If key is not found, answer the 	result of evaluating aBlock."	(key == nil or: [key = 0]) ifTrue: [^aBlock value].	^self accessLock		critical: 			[| index obj |			index := self findKeyOrNil: key.			obj := keys at: index.			(obj == nil or: [obj = 0])				ifTrue: [aBlock value]				ifFalse: [values at: index]]</body><body package="DST_Core">at: key put: anObject 	"Set the value at key to be anObject. If key is not found, create a new 	entry for key and set is value to anObject. Answer anObject."	key == nil | (key = 0) ifTrue: [^self subscriptBoundsError: key].	anObject = 0 ifTrue: [^self error: 'Invalid value'].	^self accessLock		critical: 			[| index element |			tally * 2 &gt; keys size ifTrue: [self grow].			index := self findKeyOrNil: key.			element := values at: index.			element == nil ifTrue: [tally := tally + 1].			keys at: index put: key.			values at: index put: anObject.			anObject]</body><body package="DST_Core">capacity	^keys capacity</body><body package="DST_Core">keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value is identical to the argument, value.  	If there is none, answer the result of evaluating exceptionBlock." 	self keysAndValuesDo: 		[:aKey :aValue | value == aValue ifTrue: [^aKey]].	^exceptionBlock value</body><body package="DST_Core">keys	^self accessLock		critical: 			[| keyList |			keyList := OrderedCollection new: tally.			1 to: keys size				do: 					[:index | 					| key |					key := keys at: index.					(key isNil or: [key = 0 or: [(values at: index)								= 0]])						ifFalse: [keyList add: key]].			^keyList]</body><body package="DST_Core">tally	^tally</body><body package="DST_Core">values	^self accessLock		critical: 			[| valList |			valList := OrderedCollection new: tally.			1 to: values size				do: 					[:index | 					| val key |					key := keys at: index.					(key isNil or: [key = 0 or: [(val := values at: index) = 0]])						ifFalse: [valList add: val]].			^valList]</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>dictionary removing</category><body package="DST_Core">removeAssociation: anAssociation 	"Remove the key and value association, anAssociation, from the 	receiver.  Answer anAssociation.  If the key is not in the receiver,	then provide an error notification that it was not found."	^self removeAssociation: anAssociation ifAbsent: [self notFoundError]</body><body package="DST_Core">removeAssociation: anAssociation ifAbsent: anExceptionBlock 	"Remove the key and value association, anAssociation, from the 	receiver.  If not found, answer the result of evaluating 	anExceptionBlock, otherwise answer anAssociation."	^self removeKey: anAssociation key ifAbsent: anExceptionBlock</body><body package="DST_Core">removeKey: key 	"Remove key from the receiver.  If key is not in the receiver, raise a signal.  Otherwise, answer the value associated with key."	^self removeKey: key ifAbsent: [self keyNotFoundError: key]</body><body package="DST_Core">removeKey: key ifAbsent: aBlock 	"Remove key from the receiver. If key is not in the receiver, 	answer the result of evaluating aBlock. Otherwise, answer the value 	associated with key."	^self accessLock		critical: 			[| index element |			index := self findKey: key ifAbsent: [nil].			index isNil				ifTrue: [aBlock value]				ifFalse: 					[element := keys at: index.					keys at: index put: 0.					values at: index put: 0.					element]]</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>finalization</category><body package="DST_Core">finalizeElements	"Reclaim the slots containing dead objects."	"If any changed then we need to reconstruct ourselves	so we might as well grow to the correct size."	self accessLock critical: [keys isNil			ifFalse: 				[| oldTally |				oldTally := tally.				self reclaimElements.				tally = oldTally ifFalse: [self privateGrow]]]</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>private</category><body package="DST_Core">accessLock	accessLock isNil ifTrue: [accessLock := RecursionLock new].	^accessLock</body><body package="DST_Core">copyEmpty: aSize	"Answer a copy of the receiver that contains no elements.	This method should be redefined in subclasses that add	instance variables, so that the state of those variables	is preserved"	^self class new: aSize</body><body package="DST_Core">findKey: key ifAbsent: aBlock	"Look for the key in the receiver.  If it is found, answer	the index of the association containing the key, otherwise	answer the result of evaluating aBlock."		| index |	index := self findKeyOrNil: key.	(keys basicAt: index) == nil ifTrue: [^aBlock value].	^index</body><body package="DST_Core">findKeyOrNil: key 	"Look for the key in the receiver. If it is found, answer 	the index of the association containing the key, otherwise 	answer the index of the first unused slot."	| location length probe pass |	length := keys size.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.		[probe := keys at: location.	probe = 0 ifTrue: [values at: location put: 0].	probe == nil or: [probe == key]]		whileFalse: [(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body><body package="DST_Core">initialIndexFor: aHashValue boundedBy: length 	"Find the place where we should start the search. 	Optimize for relatively small dictionaries."	"For very large dictionaries, spread out the hash."	| maxHash |	maxHash := ObjectMemory maximumIdentityHashValue.	length &gt; maxHash ifTrue: [^aHashValue * (length // maxHash + 1) \\ length + 1].	^aHashValue \\ length + 1</body><body package="DST_Core">keyNotFoundError: key	"Raise a signal indicating that the key was	not found."	^Dictionary keyNotFoundSignal raiseWith: key</body><body package="DST_Core">rehash	self changeCapacityTo: self capacity</body><body package="DST_Core">swap: nextIndex with: oldIndex 	"Move the element at oneIndex to anotherIndex, and vice-versa."	| k v |	k := keys at: oldIndex.	v := values at: oldIndex.	keys at: oldIndex put: (keys at: nextIndex).	values at: oldIndex put: (values at: nextIndex).	keys at: nextIndex put: k.	values at: nextIndex put: v</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>enumerating</category><body package="DST_Core">associationsDo: aBlock 	"Evaluate aBlock for associations consisting of the receiver's keys and 	their values."	self accessLock		critical: 			[tally == 0 ifTrue: [^self].			1 to: keys size do: 				[:index | 				| key val |				(((key := keys at: index) == nil or: [key = 0])					or: [(val := values at: index) = 0])					ifFalse: [aBlock value: key -&gt; val]]]</body><body package="DST_Core">collect: aBlock 	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a collection.	 Answer the new collection."	| newCollection |	newCollection := OrderedCollection new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^newCollection</body><body package="DST_Core">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="DST_Core">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the 	argument."	self accessLock		critical: 			[tally == 0 ifTrue: [^self].			1 to: keys size do: 				[:index | 				| key val |				(((key := keys at: index) == nil or: [key = 0])					or: [(val := values at: index) = 0])					ifFalse: [aBlock value: val]]]</body><body package="DST_Core">keysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."	self accessLock		critical: 			[tally = 0 ifTrue: [^self].			1 to: keys size do: 				[:index | 				| key val |				(((key := keys at: index) == nil or: [key = 0])					or: [(val := values at: index) = 0])					ifFalse: [aBlock value: key value: val]]]</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>private-finalization/growth</category><body package="DST_Core">changeCapacityTo: newCapacity 	"Change the size of the receiver to newCapacity. The receiver will 	be regrown to fit its contents."	"Note that this is used in rehashing -- don't optimize the case 	where the receiver doesn't change in size."	self accessLock		critical: 			[| newSelf |			newSelf := self copyEmpty: newCapacity.			1 to: keys size				do: 					[:index | 					| key val |					key := keys at: index.					(key isNil or: [key = 0 or: [(val := values at: index) = 0]])						ifFalse: [newSelf privateAt: key put: val]].			self release.			newSelf release.			self become: newSelf.			self makeDependent]</body><body package="DST_Core">grow	"The receiver becomes roomier."	"Reclaim elements to get an accurate 'tally' before the grow."	self reclaimElements.	self privateGrow.</body><body package="DST_Core">privateAt: key put: anObject 	"Set the value at key to be anObject. If key is not found, create a new 	entry for key and set is value to anObject. Answer anObject."	| index element |	index := self findKeyOrNil: key.	element := values at: index.	element == nil ifTrue: [tally := tally + 1].	keys at: index put: key.	values at: index put: anObject.	^anObject</body><body package="DST_Core">privateGrow	"The receiver becomes roomier."	"To prevent collapsing down to zero the capacity	should have a delta above the multiplied size.  41	is a arbitrary number designed to (hopefully more	frequently then a round number) be prime when	added to the multiplied size.  5 is picked as the	multiplier also rather arbitrarily, hopefully it is big	enough that grows won't happen too often, while	not making the dictionary too big."	self changeCapacityTo: (41 + (tally * 5))</body><body package="DST_Core">reclaimElements	| deathMarker size |	size := keys size.	deathMarker := 1.	[deathMarker ~= 0]		whileTrue: [(deathMarker := keys						indexOf: 0						replaceWith: nil						startingAt: deathMarker						stoppingAt: size) = 0 ifFalse: [tally := tally - 1]]</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>testing</category><body package="DST_Core">includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	^self accessLock		critical: 			[| index elem |			index := self findKeyOrNil: key.			(elem := values at: index) notNil or: [elem ~= 0]]</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>printing</category><body package="DST_Core">maxPrint	"Answer the maximum number of characters to print with printOn:."	^5000</body><body package="DST_Core">printOn: aStream  	"Append to the argument aStream a sequence of characters that identifies the receiver."	| tooMany |	tooMany := aStream position + self maxPrint.	aStream nextPutAll: self class name, ' ('.	self associationsDo: 		[:element | 		aStream position &gt; tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].		element printOn: aStream.		aStream space].	aStream nextPut: $)</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>updating</category><body package="DST_Core">update: anAspectSymbol with: aParameter from: aSender 	"Finalize all finalizable entries of aSender."	(aSender == keys and: [anAspectSymbol = #ElementExpired])		ifTrue: [self finalizeElements]		ifFalse: [^self]</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>fileIn/Out</category><body package="DST_Core">representBinaryOn: binWriter	" Represent a Dictionary by its elements	(Associations). "	^MessageSend		receiver: self class		selector: #withAll:		argument: self associations asArray</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>adding</category><body package="DST_Core">add: anAssociation 	"Include anAssociation as one of the receiver's elements. Answer 	anAssociation."	self at: anAssociation key put: anAssociation value.	^anAssociation</body></methods><methods><class-id>DST.OldWeakKeyDictionary</class-id> <category>user interface</category><body package="DST_Core">inspect	"Create and schedule a DictionaryInspector in which the user can examine the	receiver's variables."	| insp |	insp := Smalltalk at: #DictionaryInspector ifAbsent: [^super inspect].	Cursor wait showWhile: [insp openOn: self]</body></methods><methods><class-id>DST.OldWeakKeyDictionary class</class-id> <category>instance creation</category><body package="DST_Core">new	^self new: 100</body><body package="DST_Core">new: aSize 	^super new initSize: (Dictionary goodSizeFrom: aSize)</body></methods><methods><class-id>DST.IIOPDaemon</class-id> <category>conversations</category><body package="DST_Core">allConversations	"return a list with all active conversations"	| convs |	convs := Set new.	clientConnections values do: [:co | convs addAll: co allConversations].	serverConnections do: [:co | convs addAll: co allConversations].	conversations values do: [:co | convs add: co].	localServerConversations values do: [:co | convs add: co].	^convs asOrderedCollection</body><body package="DST_Core">cancelReply: aRequestId 	"tag this request as cancelled and notify the server conversation"</body><body package="DST_Core">conversationInfoList	"answer a list of information for conversations currently active" 	^self allConversations collect: [:msg | msg asConversationInfo]</body><body package="DST_Core">unRegisterClientConversation: conversation	conversations removeKey: conversation requestId ifAbsent: []</body><body package="DST_Core">unRegisterServerConversation: conversation	localServerConversations removeKey: conversation requestId ifAbsent: []</body></methods><methods><class-id>DST.IIOPDaemon</class-id> <category>connections</category><body package="DST_Core">findOrCreateClientConnectionFor: anObjRef 	"find or create a client connection for the object reference"	| skt connection |	connection := clientConnections at: anObjRef adapterId ifAbsent: [nil].	(anObjRef adapterId isNilId or: [connection isNil or: [connection isActive not]])		ifTrue: 			[			[skt := SocketAccessor family: (SocketAddress domainCodeFromName: #afInet)						type: SocketAccessor sockStream.			skt connectTo: anObjRef bindings socketAddressForIIOP]				on: Object errorSignal				do: 					[:ex | 					skt := ex parameter.					skt notNil ifTrue: [skt class == SocketAccessor ifTrue: [skt close]].					skt := nil].			(skt notNil and: [skt isActive])				ifTrue: 					[connection := IIOPClientConnection new: skt.					clientConnections at: anObjRef adapterId put: connection.					connection spawnConnectionBroker]].	^connection</body><body package="DST_Core">handleServerConnection: aSocketAccessor 	"Create a server connection and spawn an idler process to watching 	for incoming messages on the socket accessor"	| connection |	connection := IIOPServerConnection new: aSocketAccessor.	serverConnections add: connection.	connection spawnConnectionBroker</body><body package="DST_Core">unRegisterClientConnection: anIIOPClientConnection 	"remove the server connection from the list of connection"	| key |	key := clientConnections keyAtValue: anIIOPClientConnection ifAbsent: [nil].	key notNil ifTrue: [clientConnections removeKey: key ifAbsent: [nil]]</body><body package="DST_Core">unRegisterServerConnection: anIIOPServerConnection 	"remove the server connection from the list of connection"	serverConnections remove: anIIOPServerConnection ifAbsent: [nil]</body></methods><methods><class-id>DST.IIOPDaemon</class-id> <category>core</category><body package="DST_Core">objectRequestBroker	"This idler process is responsible for watching for incoming 	connections from a well-known socket address. Note that the 	rpcService will be initialized coming into this method however it 	may be nilled when the orb is shut down. Therefore we need to 	validate it after the readwait expires"	| childSocket |	self class configurationManager 		log:	(	'\IIOP daemon process listening on socket: ' , 				rpcService getName printString , 				'\'			) withCRs.		[	rpcService listenFor: 1.		[	[	Processor yield.				receiveMsg			]	whileTrue: 				[	rpcService readWait.					( ( childSocket := rpcService acceptNonBlock) isNil ) 						ifFalse:	[ self handleServerConnection: childSocket ]				]		]	on: rpcService errorReporter errorSignal 			do: [:ex | ]	]	ensure: [	receiveMsg						ifTrue:	[	self shutDown.									self class configurationManager 										log: (	'\ORB process ended\'  )withCRs								]				]</body><body package="DST_Core">sendLocalReply: aServConv 	"handle the reply locally without bothering the RpcService"	| reply client |	aServConv canceled		ifTrue: []		ifFalse: 			[reply := GIOPMessage messageHeader: aServConv reply messageHeader messageStream: aServConv reply messageStream.			reply notNil ifTrue: [reply isValidReply					ifTrue: 						[reply extractReplyHeader.						client := conversations at: reply requestId ifAbsent: [self error: 'failure detected - conversation not found'].						client notNil							ifTrue: 								[client reply: reply.								conversations removeKey: reply requestId ifAbsent: [].								client signalSemaphore]]]]</body><body package="DST_Core">sendLocalRequest: aClientConv 	"handle the request locally without bothering the RpcService"	| id conv |	id := aClientConv request requestId.	conversations at: id put: aClientConv.	conv := IIOPServerConversation new: nil.	localServerConversations at: id put: conv.	conv processRequest: (GIOPMessage messageHeader: aClientConv request messageHeader messageStream: aClientConv request messageStream).	^true</body><body package="DST_Core">sendReply: aServConv 	"Send the reply immediately.  The connection will only 	be nil under local RPC testing.  In 5i, in response to 	popular request, we splice in a transient error handler.	For an explanation of transients, vide the comment in	'ORBDaemon class&gt;&gt;transientErrorHandler:'."	| connection |	connection := aServConv connection.	( connection isNil )		ifTrue:	[	self sendLocalReply: aServConv.					self unRegisterServerConversation: aServConv				]		ifFalse:	[ 	[ connection sendReply: aServConv ]						on:	Error						do:	[ :ex | ( ( ex getSignal ~= ORBObject transientSignal )									or: [ self class transientErrorHandler isNil ] )										ifTrue:	[ ex pass ]										ifFalse:	[ self class transientErrorHandler 														value: ex 														value: aServConv ]							]				]</body><body package="DST_Core">sendRequest: aClientConv 	"Send the request immediately"	| connection |	^(aClientConv target class == DSTObjRefRemote or: [aClientConv target class == DSTObjRefNarrowed])		ifTrue: 			[connection := self findOrCreateClientConnectionFor: aClientConv target.			(connection notNil and: [connection isActive])				ifTrue: 					[aClientConv connection: connection.					connection sendRequest: aClientConv]				ifFalse: [false]]		ifFalse: [self sendLocalRequest: aClientConv]</body><body package="DST_Core">shutDown	"shut down the request broker process and clear dictionaries 	which contain references to local objects"	IIOPConnectionReaper shutdown.	receiveMsg := false.	requestBroker notNil		ifTrue: 			[requestBroker terminate.			requestBroker := nil].	self removeDaemon.	(rpcService notNil and: [rpcService isActive])		ifTrue: [rpcService close].	serverConnections do: [:co | co shutDown].	clientConnections do: [:co | co shutDown]</body><body package="DST_Core">startObjectServer	"Starts the IIOP daemon server process"	hintComponent := nil.	bindingComponent := nil.	localServerConversations := WeakDictionary new.	IIOPConnection initialize: self.	IIOPConversation initialize: self.	GIOPMessage reInitialize.	CDRStream reInitialize.	DSTServiceContext reInitialize.	receiveMsg := false.	clientConnections := IdentityDictionary new.	serverConnections := IdentitySet new.	conversations := Dictionary new.	(rpcService notNil and: [rpcService isActive])		ifTrue: [rpcService close].		[receiveMsg := true.	rpcService := SocketAccessor newTCPserverAtPort: self configuredPortNo.	portNo := rpcService getName port.	vpId := ( self hostName, ';' , portNo asString ) asSymbol.	bindingComponent := IORTaggedComponent iiopBindingComponent: vpId.	self registerDaemon.	requestBroker := ["set up remote object server process"			self objectRequestBroker]				forkAt: ORBObject orbPriority]		on: Object errorSignal		do: 			[:x | 			self class configurationManager log: '\Warning:  the IIOP Daemon failed to start (' withCRs , x errorString , ').\' withCRs.			receiveMsg := false.			x reject].	IIOPConnectionReaper startup</body></methods><methods><class-id>DST.IIOPDaemon</class-id> <category>configuration</category><body package="DST_Core">configureWriteIncrementSize: anInteger 	"set the fragment size with NCSPacket"	^(self isValidWriteIncrementSize: anInteger)		ifTrue: [IIOPConnection writeIncrement: anInteger]</body></methods><methods><class-id>DST.IIOPDaemon</class-id> <category>private</category><body package="DST_Core">error: aString 	"log this error when the logging is enabled"	| configMgr |	configMgr := ORBDaemon configurationManager.	configMgr logging &gt; 0 ifTrue: [configMgr log: ('\' , aString , '\') withCRs]</body><body package="DST_Core">isValidWriteIncrementSize:  anInteger 	"answer whether or not this is a valid write increment size"	^(anInteger isInteger)		and: [anInteger &gt; 512 and: [anInteger &lt;= 81920]]</body><body package="DST_Core">readRemainingBytes: aStream onSocket: aSocketAccessor 	"get the remaining bytes from the socket for this message"	[(aSocketAccessor notNil and: [aSocketAccessor isActive])		and: [aStream amountRead &lt; aStream msgSize]]		whileTrue: [aStream nextBuffer]</body></methods><methods><class-id>DST.IIOPDaemon</class-id> <category>accessing</category><body package="DST_Core">allClientConnections	| set |	set := Set new.	set addAll: self clientConnections.	^set</body><body package="DST_Core">allConnections	| set |	set := Set new.	set addAll: self serverConnections.	set addAll: self clientConnections.	^set</body><body package="DST_Core">allServerConnections	| set |	set := Set new.	set addAll: self serverConnections.	^set</body><body package="DST_Core">bindingComponent	"Answer the tagged component which contains the binding for this 	daemon."	( bindingComponent == nil ) 		ifTrue:	[ bindingComponent := 					IORTaggedComponent iiopBindingComponent: self hostName, 					';' , 					self port printString				].	^bindingComponent</body><body package="DST_Core">clientConnections	^clientConnections</body><body package="DST_Core">configuredPortNo	"Answer the configured port number for this daemon."	^configuredPortNo == nil		ifTrue: [0]		ifFalse: [configuredPortNo]</body><body package="DST_Core">iiopProfileFor: anObject	"Answer a profile that provides the binding information for the IIOPDaemon."	| tp pd |	tp := IORTaggedProfile new.	tp tag: tp class tagInternetIOP.	pd := CDRStream on: (ByteArray new: 100).	pd nextPutBoolean: pd byteOrder.	pd nextPutByte: 1.	pd nextPutByte: 0.	pd nextPutString: self hostName.	pd nextPutShort: self port.	DSTObjRefRemote objectKeyDef marshall: anObject objectId asByteArray on: pd.	tp profileData: pd contents.	^tp</body><body package="DST_Core">serverConnections	^serverConnections</body></methods><methods><class-id>DST.IIOPDaemon class</class-id> <category>accessing</category><body package="DST_Core">clientConversationClass	"answer the class for creation client conversations"	^IIOPClientConversation</body><body package="DST_Core">tagBinding	^IORTaggedComponent tagDSTIIOPBinding</body><body package="DST_Core">transportName	^#IIOP</body></methods><methods><class-id>DST.IIOPDaemon class</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	InstalledDaemons at: self name put: self new</body><body package="DST_Core">release	"release class variable"	InstalledDaemons := nil</body></methods><methods><class-id>DST.DSTtypeDouble</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_double</body></methods><methods><class-id>DST.DSTtypeDouble</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = MNU on asDouble"	aStream nextPutDouble: aParameter asDouble</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: Number</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^aStream nextDouble</body></methods><methods><class-id>DST.DSTtypeDouble</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'double'</body></methods><methods><class-id>DST.DSTtypeDouble</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_double</body></methods><methods><class-id>DST.RepositoryId</class-id> <category>converting</category><body package="DST_Core">asByteString	"Forward this to the asString method."	^self asString</body><body package="DST_Core">asString	"Answer the receiver converted to a String."	| str |	str := ByteString new: self size.	1 to: self size do: [:i | str at: i put: (self at: i) fromCORBACharCode].	^str</body><body package="DST_Core">decodeAsLiteralArray	"Return an instance based on the information encoded in the receiver."	^self</body><body package="DST_Core">literalArrayEncoding	"Return a literal suitable for reconstituting the receiver."	^self</body><body package="DST_Core">toCORBACharCodes	^self</body></methods><methods><class-id>DST.RepositoryId</class-id> <category>testing</category><body package="DST_Core">isRepositoryId	^true</body><body package="DST_Core">refersToLiteral: anObject	^self == anObject</body></methods><methods><class-id>DST.RepositoryId</class-id> <category>fileIn/Out</category><body package="DST_Core">representBinaryOn: binWriter	" RepositoryIds must be re-interned	when they are read in. " 	^MessageSend		receiver: self class		selector: #intern:		argument: self asString</body></methods><methods><class-id>DST.RepositoryId</class-id> <category>accessing</category><body package="DST_Core">at: anInteger put: anObject 	"Provide an error notification that RepositoryIds cannot be	modified."	self errorNoModification</body><body package="DST_Core">formatName	"Return the format name component of the repository id as a symbol."	^(self asString copyUpTo: $:) asSymbol</body><body package="DST_Core">identifiers	"Return the list of identifiers. Identifiers are separated by '/' 	characters as a string."	| s start end |	s := self asString.	(start := s indexOf: $:) isZero ifFalse: [start := start + 1].	(end := s				nextIndexOf: $:				from: start				to: s size) isZero ifFalse: [end := end - 1].	^s copyFrom: start to: end</body><body package="DST_Core">replaceFrom: start to: stop with: replacement startingAt: repStart 	"Provide an error notification that RepositoryIds can not be	modified."	self errorNoModification</body><body package="DST_Core">value	"Allow this object to act as a ValueHolder on itself."	^self</body><body package="DST_Core">version	"Return the version portion of the repository id as a string."	| s start |	s := self asString.	start := s				nextIndexOf: $:				from: 5				to: s size.	^s copyFrom: start + 1 to: s size</body></methods><methods><class-id>DST.RepositoryId</class-id> <category>printing</category><body package="DST_Core">isLiteral	"Answer whether the receiver is a literal."	^true</body><body package="DST_Core">printOn: aStream 	(1 to: self size)		do: [:index | aStream nextPut: (self at: index) asCharacter]</body></methods><methods><class-id>DST.RepositoryId</class-id> <category>copying</category><body package="DST_Core">copy	"Answer the receiver, because RepositoryIds are unique."	^self</body><body package="DST_Core">shallowCopy	"Answer the receiver because RepositoryIds are unique."	^self</body></methods><methods><class-id>DST.RepositoryId</class-id> <category>private</category><body package="DST_Core">errorNoModification	self error:  'symbols can not be modified.'</body></methods><methods><class-id>DST.RepositoryId</class-id> <category>comparing</category><body package="DST_Core">= anObject 	"Answer whether the receiver and the argument are the same object 	(have the same object pointer)."	^self == anObject</body></methods><methods><class-id>DST.RepositoryId class</class-id> <category>instance creation</category><body package="DST_Core">defaultImplementor	"Answer a class that usually represents repository ids."	^RepositoryId</body><body package="DST_Core">fromString: aString 	"Alternate form of intern."	^self intern: aString</body><body package="DST_Core">intern: aRepositoryId 	"Answer a unique RepositoryId whose characters are those of 	aRepositoryId."	| anId repId index table subTable subIndex |	anId := aRepositoryId class == self				ifTrue: [aRepositoryId]				ifFalse: [(self new: aRepositoryId size)						replaceBytesFrom: 1						to: aRepositoryId size						with: aRepositoryId						startingAt: 1].	repId := self findInterned: anId.	repId notNil ifTrue: [^repId].	table := self table.	index := anId hash \\ table size + 1.	subTable := table at: index.	subIndex := subTable				indexOf: 0				replaceWith: anId				startingAt: 1				stoppingAt: subTable size.	subIndex = 0		ifTrue: 			[| newTable |			newTable := subTable class new: subTable size + 1.			newTable				replaceFrom: 1				to: subTable size				with: subTable.			newTable at: newTable size put: anId.			table at: index put: newTable].	^anId</body><body package="DST_Core">readFrom: aStream	"Create an object based on the contents of aStream."	| object |	object := self evaluatorClass evaluate: aStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object</body></methods><methods><class-id>DST.RepositoryId class</class-id> <category>accessing</category><body package="DST_Core">findInterned: aRepositoryId 	"If aRepositoryId has been interned (into a RepositoryId), 	answer the RepositoryId, otherwise answer nil."	| v idSize |	idSize := aRepositoryId size.	v := self table at: aRepositoryId hash \\ self table size + 1.	1 to: v size do: 		[:i | 		| test |		((test := v at: i) class == self and: [idSize = test size				and: 					[| match ii |					match := true.					ii := 0.					[match and: [(ii := ii + 1) &lt;= idSize]]						whileTrue: [(aRepositoryId at: ii)								= (test at: ii) ifFalse: [match := false]].					match]])			ifTrue: [^test]].	^nil</body><body package="DST_Core">tableSize	"Answer the number of RepositoryIds in the table."	| total |	self table isNil ifTrue: [^1023].	total := 0.	self table do: [:bucket | total := total + bucket size].	^total</body></methods><methods><class-id>DST.RepositoryId class</class-id> <category>class initialization</category><body package="DST_Core">initialize	"Initialize the class variables."	self rehash</body><body package="DST_Core">release	"release the class variables."	IDTable := nil</body></methods><methods><class-id>DST.RepositoryId class</class-id> <category>private</category><body package="DST_Core">rehash	"Rebuild the hash table that holds all the unique RepositoryIds."	"We want to keep the average number of probes for a lookup	constant; independent of the number of symbols.  Therefore,	when rehashing we adjust the number of buckets such that	we meet a target bucket size (e.g. symbols/buckets).	Choosing a target bucket size is a classic time/space tradeoff;	the value used here is 10, based on empirical tests."	| numBuckets | 	"Set knows good hash moduli."	numBuckets := Set goodSizeFrom: (self tableSize / 10) rounded.	self table: ((1 to: numBuckets) collect: [:id | WeakArray with: 0]).	ObjectMemory garbageCollect.	self allInstancesDo: [:id | self intern: id].	"RepositoryId rehash"</body><body package="DST_Core">table	"answer the table that holds repositoryIds"	^IDTable</body><body package="DST_Core">table: newArray 	^IDTable := newArray</body></methods><methods><class-id>DST.DSTPersistentObject</class-id> <category>accessing</category><body package="DST_Core">makeClean	"set that the receiver has not been modified.  A hook for future persistence management"	^self</body><body package="DST_Core">makeModified	"set that the receiver has been modified.  A hook for future persistence management"	^self</body><body package="DST_Core">objectId	"Answer the value of the objectId."	^objectId ifNil: [objectId := super objectId].</body><body package="DST_Core">objectId: anObjectId 	"set the objectId of the receiver"	objectId := anObjectId</body></methods><methods><class-id>DST.DSTPersistentObject</class-id> <category>persistence</category><body package="DST_Core">representBinaryOn: binWriter 	"Represent an ORBObject by its contents (elements). This is called by 	the BOSS when an on object is written to a BOSS stream. Note that 	this process will automatically register the receiver as a persistent 	object. If that stream is subsequently stored in the object database, 	then a tombstone will remain after I am reclaimed which will allow 	me to be resurrected later"	^MessageSend		receiver: self class		selector: #createLike:		argument: (Array with: self objectId with: self persistentState)</body></methods><methods><class-id>DST.DSTPersistentObject</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver" 	super initialize.	self makeModified</body><body package="DST_Core">reInitialize	"reinitialize the receiver. Zap my objectId"	objectId := nil.</body></methods><methods><class-id>DST.DSTPersistentObject class</class-id> <category>persistence</category><body package="DST_Core">activatorBlock	"return the block which will reactivate the object from the database"	^[:aDatabaseId | DSTObjRefInactive objectOf: aDatabaseId]</body></methods><methods><class-id>DST.DSTPersistentObject class</class-id> <category>factory</category><body package="DST_Core">createLike: anArray 	"create a new instance of the receiver's class with the given 	persistent state. This is called by the BOSS when a new object is to 	be created from a BOSS binary stream. Cause the newly created 	object to replace its resident version, if one exists."	| oid state obj | 	oid := anArray at: 1.	state := anArray at: 2.	obj := self new.	obj objectId: oid.	obj restorePersistentState: state.	^obj</body></methods><methods><class-id>DST.DSTtypeFixed</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream. "	[aStream		nextPutFixed: aParameter		digits: digits		scale: scale]		on: Error do: [:ex | self class marshallError: 0]</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: FixedPoint</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	aStream nextPutUnsignedLong: self typeCode; 			nextPutUnsignedShort: (digits == nil ifTrue: [0] ifFalse: [digits]);			nextPutShort: (scale == nil ifTrue: [0] ifFalse: [scale]).</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextFixed: digits scale: scale</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream	"marshall the type code of the receiver"	digits := aStream nextUnsignedShort.	scale := aStream nextShort.</body></methods><methods><class-id>DST.DSTtypeFixed</class-id> <category>printing</category><body package="DST_Core">definitionString	"return my IDL type definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream 		nextPutAll: name; 		nextPutAll: '&lt;'; 		nextPutAll: digits printString;		nextPutAll: ', '; 		nextPutAll: scale printString;		nextPut: $&gt;.	^aStream contents</body></methods><methods><class-id>DST.DSTtypeFixed</class-id> <category>initialization</category><body package="DST_Core">digits: d scale: s 	name := 'fixed'.	digits := d value.	scale := s value.</body><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'fixed'</body></methods><methods><class-id>DST.DSTtypeFixed</class-id> <category>accessing</category><body package="DST_Core">digits	^digits</body><body package="DST_Core">digits: anUnsignedLong	digits := anUnsignedLong</body><body package="DST_Core">scale	^scale</body><body package="DST_Core">scale: anSignedShort	scale := anSignedShort</body></methods><methods><class-id>DST.DSTtypeFixed</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::FixedDef'</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Fixed</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_fixed</body><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. "	^2</body><body package="DST_Core">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^digits].	anInt = 2 ifTrue: [^scale].	self error: #Bounds</body></methods><methods><class-id>DST.DSTtypeFixed</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_fixed</body></methods><methods><class-id>DST.DSToperationInfo</class-id> <category>accessing</category><body package="DST_Core">interface	"return the interface of the receiver"	^interface</body><body package="DST_Core">interfaceId	"return the interfaceId of the defining interface"	^interface repositoryId</body><body package="DST_Core">opIndex	"return the opIndex of the receiver"	^opIndex</body><body package="DST_Core">operation	"return the operation of the receiver"	^operation</body><body package="DST_Core">selector	"return the selector of the receiver"	^selector</body><body package="DST_Core">traceString	"return a string for printing the receiver"	^operation printName , ' (' , selector , ')'</body></methods><methods><class-id>DST.DSToperationInfo</class-id> <category>creation</category><body package="DST_Core">interface: anIf operation: anOp selector: aSymbol opIndex: anInt 	"set all instance variables in the receiver"	interface := anIf.	operation := anOp.	selector := aSymbol.	opIndex := anInt.	anInt &lt; 0 ifTrue: [self error: 'Invalid operation index']</body></methods><methods><class-id>DST.DSTServiceContext</class-id> <category>private</category><body package="DST_Core">contextId: anInteger contextData: aByteArray 	"initialize a new instance of the reciever"	contextId := anInteger.	contextData := aByteArray.	modified := false.	extracted := false</body><body package="DST_Core">encapsulateContextData	^#[]</body><body package="DST_Core">extractContext	"extract the context from contextData, subclasses should override"	extracted := true.	^self</body></methods><methods><class-id>DST.DSTServiceContext</class-id> <category>accessing</category><body package="DST_Core">contextData	"return the byte array that contains the encapsulated context"	^(modified or: [contextData isNil])		ifTrue: [contextData := self encapsulateContextData]		ifFalse: [contextData]</body><body package="DST_Core">contextId	^contextId</body></methods><methods><class-id>DST.DSTServiceContext class</class-id> <category>constants</category><body package="DST_Core">concurrencyServiceId	"answer the value of the Id for the dst concurrency context"	^16r08108003</body><body package="DST_Core">distributedDebuggerId	"answer the value of the Id for the dst debugger context"	^16r08108000</body><body package="DST_Core">securityServiceId	"answer the value of the Id for the dst security context"	^16r08108002</body><body package="DST_Core">transactionServiceId	"answer the value of the Id for service contexts"	^0</body></methods><methods><class-id>DST.DSTServiceContext class</class-id> <category>instance creation</category><body package="DST_Core">contextId: anInteger contextData: aByteArray 	"create a new instance of receiver or subclass, based on the contextId"	| class |	class := InstalledContexts at: anInteger ifAbsent: [self].	^(class basicNew) contextId: anInteger contextData: aByteArray; yourself</body></methods><methods><class-id>DST.DSTServiceContext class</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	InstalledContexts := Dictionary new</body><body package="DST_Core">reInitialize	"initialize the receiver"	InstalledContexts := Dictionary new.	DSTServiceContext allSubclasses do: [:cl | cl installContext]</body><body package="DST_Core">release	"release the class variable"	InstalledContexts := nil</body></methods><methods><class-id>DST.DSTServiceContext class</class-id> <category>private</category><body package="DST_Core">installContext	"add the receiver to the dictionary of installed contexts"</body></methods><methods><class-id>DST.ORBNVList</class-id> <category>NVList</category><body package="DST_Core">addItemIdentifier: id typeCode: typeCode any: any long: int flags: flags 	"This operation adds a new item to the indicated list. The item is 	added after the previously added item"	collection isNil ifTrue: [collection := OrderedCollection new].	collection add: (DSTNamedValue			name: id			value: any			flags: flags).	^0</body><body package="DST_Core">free	"	// This operation frees the list structure and any associated 		// memory 		CORBA::ORBStatus free ();	"	collection do: [:nv | nv value: nil]</body><body package="DST_Core">freeMemory	"This operation frees any dynamically allocated out-arg memory 	associated with the list. The list itself is not freed."	collection do: [:nv | nv value: nil]</body><body package="DST_Core">getCount	"This operation returns the total number of items allocated for this list"	^collection size</body></methods><methods><class-id>DST.ORBNVList</class-id> <category>adding</category><body package="DST_Core">addNamedValue: aDSTNamedValue 	"add the named value to the NVList"	collection add: aDSTNamedValue</body></methods><methods><class-id>DST.ORBNVList</class-id> <category>accessing</category><body package="DST_Core">asValueArray	"return the values of the receiver"	| ar |	ar := Array new: collection size.	1 to: collection size do: [:i | ar at: i put: (collection at: i) value].	^ar</body></methods><methods><class-id>DST.ORBNVList</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	collection := OrderedCollection new.</body></methods><methods><class-id>DST.ORBNVList</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::DynamicInvocation::NVList'</body></methods><methods><class-id>DST.ORBNVList class</class-id> <category>validation</category><body package="DST_Core">testAll	"test the NVlist interface"	|  list |	Transcript show: 'Testing NV Lists'; cr.	list := self new.	list		addItemIdentifier: 1		typeCode: 2		any: 3		long: 4		flags: 5.	list asValueArray.	list getCount.	list freeMemory</body></methods><methods><class-id>DST.DSTtypeNamed</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	self equivalentType boldMarshall: aParameter on: aStream</body><body package="DST_Core">boldMarshall: aParameter on: aStream withLocalClass: aClass	"Marshall the parameter onto the stream" 	self equivalentType boldMarshall: aParameter on: aStream withLocalClass: aClass</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^self equivalentType marshallMatch: aParameter</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^self equivalentType unMarshall: aStream</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^self equivalentType unMarshall: aStream withLocalClass: aClass</body></methods><methods><class-id>DST.DSTtypeNamed</class-id> <category>repository</category><body package="DST_Core">CORBAInterface	"return the CORBAInterface of the receiver. This must be the equivalent 	type's CORBAInterface since typeObject forwards also"	^self equivalentType CORBAInterface</body><body package="DST_Core">CORBAType	"return the CORBAType of the receiver. This must be the equivalent 	type's CORBAType since typeObject forwards also"	^self equivalentType CORBAType</body><body package="DST_Core">checkReferencesUniqueness	"check if name resolution is ambiguous"	| ref |	 	[DSTmoduleRepository convenientNameResolution: false.	equivalentType := nil.	ref := self attemptResolution.	ref isNil ifTrue: [^nil].	(ref isDSTMetaObject)		ifTrue: [ref := Set with: ref].	ref size &gt; 1 ifTrue: [Dialog notify: 'Resolution of ''' , self printName , ''' for ''' , self idlName , ''' is ambiguous']]		ensure: 			[DSTmoduleRepository convenientNameResolution: true.			equivalentType := nil]</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream	"marshall the type code of the receiver"	^self equivalentType marshallTypeCode: aDictionary on: aStream</body><body package="DST_Core">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^self equivalentType metaValueOf: aSymbol</body><body package="DST_Core">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope."	self equivalentType resolveLocalTypesIn: aType</body><body package="DST_Core">resolveTypeReference	"implemented by DSTtypeNamed &amp; DSTconstant. Others 	should noop"	| msg |	self resolveTo: (self definingMetaObject metaObjectOf: name).	equivalentType isNil		ifTrue: 			[msg := 'Forward declaration of "' , name , '" in "' , self definingMetaObject printName , '" never defined.'.			Transcript show: msg; cr.			"Dialog notify: msg"]</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^self equivalentType typeKind</body><body package="DST_Core">typeParamCount	"return the TCParamCount of the receiver"	^self equivalentType typeParamCount</body><body package="DST_Core">typeParameter: anInt	"return the TCParameter of the receiver"	^self equivalentType typeParameter: anInt</body></methods><methods><class-id>DST.DSTtypeNamed</class-id> <category>printing</category><body package="DST_Core">asIDLString	"return the IDLstring representation of the receiver"	^name</body><body package="DST_Core">asString	"return the string representation of the receiver"	^self printName</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print the IDL definition of the receiver onto the stream. 	Special case interface forward references."	| eqType |	eqType := self equivalentType.	eqType isNil ifTrue: [self error: 'Forward declaration of ' , self printName , ' never defined'].	(eqType isDSTMetaObject and: [eqType isDSTinterface])		ifTrue: 			[self printHeaderOn: aStream indent: level.			aStream tab: level; nextPutAll: 'interface '; nextPutAll: name asString; nextPut: $;; cr.			^self].	eqType		printDefinitionOn: aStream		indent: level		style: aTextStyleName</body><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'ref ' , self idlName</body></methods><methods><class-id>DST.DSTtypeNamed</class-id> <category>accessing</category><body package="DST_Core">attemptResolution	"return the equivalentType or attempt to resolve. Return nil if this is 	not possible"	equivalentType notNil ifTrue: [^equivalentType].	equivalentType := self definingMetaObject metaObjectOf: name.	^equivalentType</body><body package="DST_Core">equivType	"private - return the equivalentType"	^equivalentType</body><body package="DST_Core">equivalentType	"return the equivalentType. Resolve if necessary, and fail if not 	resolvable"	(equivalentType isNil and: [self attemptResolution isNil])		ifTrue: 			[Transcript show: 'Forward declaration of "' , name , '" in "' , self definingMetaObject printName , '" never defined.'; cr.			self class intfReposError: 0].	^equivalentType</body><body package="DST_Core">resolveTo: aType 	"cause the receiver to resolve to the given type object"	equivalentType := aType</body><body package="DST_Core">value	"return the value of the receiver's equivalent type"	^self equivalentType value</body><body package="DST_Core">valueExcept: aCol 	"Answer a valid value not contained in the collection, otherwise 	nil"	^self equivalentType valueExcept: aCol</body></methods><methods><class-id>DST.DSTtypeNamed</class-id> <category>testing</category><body package="DST_Core">isDSTtypeNamed	^true</body></methods><methods><class-id>DST.DSTtypeNamed</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^self equivalentType nonTrivialDeclarators asOrderedCollection</body><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^self equivalentType iconId</body><body package="DST_Core">nonTrivialDeclarators	"Don't display forward declarations of interfaces in the browser."	^#()</body></methods><methods><class-id>DST.DSTtypeNamed</class-id> <category>copying</category><body package="DST_Core">copyDeclaratorOn: aType	"make a copy of a declarator type, remembering that the declarator will point 	back to the type object which contained it as a declarator. We must avoid 	an infinite loop. Array, &amp; pointer types must overload"	| obj |	obj := super copyDeclaratorOn: aType .	obj resolveTo: nil.	^obj</body></methods><methods><class-id>DST.DSTtypeNamed</class-id> <category>initialization</category><body package="DST_Core">d: aDescr s: supers n: aName i: anInterface 	"Called when a forward declaration is seen. 	Supers and anInterface are not used."	(aName isSymbol)		ifFalse: [self error: 'Print name must be a symbol'].	name := aName asSymbol.	definition := aDescr</body></methods><methods><class-id>DST.DSTvalueNamed</class-id> <category>accessing</category><body package="DST_Core">allSemantics	^Set new: 0</body><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	definedIn := aMetaObject</body><body package="DST_Core">idlName	"return the receivers full qualified name"	^self definingMetaObject idlName , '::' , name</body><body package="DST_Core">semantic	^nil</body><body package="DST_Core">value	"return the value of the receiver"	value == nil ifTrue: [value := definedIn metaValueOf: name].	^value</body><body package="DST_Core">value: anObject	value := anObject</body></methods><methods><class-id>DST.DSTvalueNamed</class-id> <category>repository</category><body package="DST_Core">allMetaObjectsInto: aSet 	"add me"	aSet add: self</body><body package="DST_Core">cleanHouse	"Close all local and remote presentations. Here do nothing."</body><body package="DST_Core">definingMetaObject	"return my defining meta object"	^definedIn</body><body package="DST_Core">registerIdentity	"do nothing"</body><body package="DST_Core">resolveTypeReference	"force evaluation of my value"	self value</body><body package="DST_Core">unlinkFromRepository	"The receiver is being removed from the repository. Unlink as 	required.  Here do nothing"</body></methods><methods><class-id>DST.DSTvalueNamed</class-id> <category>printing</category><body package="DST_Core">asIDLString	"return the IDLstring representation of the receiver"	^name</body></methods><methods><class-id>DST.DSTvalueNamed</class-id> <category>initialization</category><body package="DST_Core">initialize: aName 	"set the type printname of the receiver"	name := aName</body></methods><methods><class-id>DST.DSTObjRefLocal</class-id> <category>local-remote</category><body package="DST_Core">asLocal	"return the object"	^object asLocal</body><body package="DST_Core">asLocalObjRef	"return the receiver"	^self</body><body package="DST_Core">asRemotable	"return the receiver"	^self</body></methods><methods><class-id>DST.DSTObjRefLocal</class-id> <category>message handlers</category><body package="DST_Core">perform: opSelector on: parameters 	"invoke the operation on the remote object and wait for a 	return" 	ORBObject running		ifTrue: [^super perform: opSelector on: parameters]		ifFalse: [^object perform: opSelector withArguments: parameters]</body></methods><methods><class-id>DST.DSTObjRefLocal</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print a representation of the receiver on the stream"	aStream nextPutAll: 'a (remotable) "' , self interface printName , '"'</body></methods><methods><class-id>DST.DSTObjRefLocal</class-id> <category>accessing</category><body package="DST_Core">isLocal	"return if the handle is local"	^object isLocal</body><body package="DST_Core">isRemote	"the receiver is simulating a remote object"	^true</body><body package="DST_Core">object: anObject	"set the object to which the reciever refers"	object := anObject</body></methods><methods><class-id>DST.DSTObjRefLocal</class-id> <category>override inheritance</category><body package="DST_Core">isKindOf: aClass 	"Return if the receiver is a kind of the class"	^(super isKindOf: aClass) or: [object isKindOf: aClass]</body></methods><methods><class-id>DST.DSTObjRefLocal class</class-id> <category>creation-registration</category><body package="DST_Core">findOrCreateOn: anObject 	"return either a unique object reference to the object or the object 	itself if it is active"	| oid obj |	oid := anObject objectId.	obj := self indexOf: oid.	^obj ifNil: [self indexObject: ((self new) objectId: oid interfaceId: anObject CORBAInterface repositoryId; object: anObject; yourself) as: oid]</body><body package="DST_Core">index	"Answer the value of index."	^Index</body></methods><methods><class-id>DST.DSTObjRefLocal class</class-id> <category>initialization</category><body package="DST_Core">flushIndex	"flush the class index"	"self flushIndex"	Index := self indexClass new: 2011</body><body package="DST_Core">initialize	"initialize the class variables"	self flushIndex</body><body package="DST_Core">release	"release the class variables"	Index := nil</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall = size matches and not exception on marshalling on elements"	(aParameter size = size)		ifFalse: [self class marshallError: 0].	1 to: aParameter size do: [:i | subtype boldMarshall: (aParameter at: i)			on: aStream].</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter size = size and: [subtype marshallMatch: (aParameter at: 1)]</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	| pos |	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	pos := aStream nextPutEncapsulationHeader.	subtype marshallTypeCode: aDictionary on: aStream.	aStream nextPutUnsignedLong: size.	aStream setEncapsulationLength: pos</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result |	aClass isNil		ifTrue: [result := Array new: size]		ifFalse: [result := aClass new: size].	1 to: size do: [:i | result at: i put: (subtype unMarshall: aStream)].	aClass == NCSuuid ifTrue: [^NCSuuid intern: result].	^result</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream	"unmarshall the type code of the receiver"	| byteOrder |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	subtype := self class unMarshallTypeCode: aDictionary from: aStream.	size := aStream nextUnsignedLong.	aStream byteOrder: byteOrder</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>ArrayDef</category><body package="DST_Core">elementType	"The type of the elements is described by elementType."	^subtype equivalentType baseType</body><body package="DST_Core">elementTypeDef	"The type of the elements is identified by elementTypeDef."	^subtype equivalentType baseType</body><body package="DST_Core">elementTypeDef: anIDLType 	"Setting the elementTypeDef attribute also updates the elementType 	and the inherited type attributes."	self notYetImplemented</body><body package="DST_Core">length	"The length attribute specifies the number of elements in the array."	^size</body><body package="DST_Core">length: newLength 	"Setting the length attribute also updates the inherited type 	attribute."	self notYetImplemented</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>accessing</category><body package="DST_Core">arrayType	"The arrayType of an array is the type for printing."	^arrayType</body><body package="DST_Core">baseType	"The baseType of an array is the subtype."	^subtype</body><body package="DST_Core">resolveTo: aType	"cause the receiver to resolve to the given type object"	subtype class == self class		ifTrue: [subtype resolveTo: aType]		ifFalse: [subtype := aType]</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>printing</category><body package="DST_Core">declaratorString	"return an IDL declarator string"	(subtype isDSTMetaObject and: [subtype isDSTtypeArray])		ifTrue: [^self printName , '[' , size printString , ']' , subtype declaratorString]		ifFalse: [^self printName , '[' , size printString , ']']</body><body package="DST_Core">definitionString	"return my unformatted IDL type definition string"	^subtype name</body><body package="DST_Core">idlName	"return the receivers full qualified name"	^self definingMetaObject idlName , '::' , self declaratorString</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>rendering</category><body package="DST_Core">childName	"return the name to be used for the receiver in a browser window"	^self declaratorString</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>initialization</category><body package="DST_Core">sizes: sizes ident: aSymbol type: aType 	"Initialize instance variables for a fixed sized array"	super initialize: aSymbol.	size := sizes at: 1.	arrayType := aType.	sizes size = 1		ifTrue: [subtype := aType]		ifFalse: [subtype := self class new						sizes: (sizes copyFrom: 2 to: sizes size)						ident: ''						type: aType]</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>TypeCode</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_array</body><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^2</body><body package="DST_Core">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^subtype].	anInt = 2 ifTrue: [^size].	self error: #Bounds</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CompoundDefs::ArrayCompoundDef'</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Array</body></methods><methods><class-id>DST.DSTtypeArray</class-id> <category>testing</category><body package="DST_Core">isDSTtypeArray	^true</body></methods><methods><class-id>DST.DSTtypeLongDouble</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_longdouble</body></methods><methods><class-id>DST.DSTtypeLongDouble</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = MNU on asDouble"	aStream nextPutLongDouble: aParameter asDSTLongDouble</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: Number</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^aStream nextLongDouble</body></methods><methods><class-id>DST.DSTtypeLongDouble</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'long double'</body></methods><methods><class-id>DST.DSTtypeLongDouble</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_longdouble</body></methods><methods><class-id>DST.GIOPMessage</class-id> <category>constants</category><body package="DST_Core">cancelRequestMsg	"return the value for a cancel request message"	^2</body><body package="DST_Core">closeConnectionMsg	"return the value for a close connection message"	^5</body><body package="DST_Core">errorMsg	"return the value for an error message"	^6</body><body package="DST_Core">locateReplyMsg	"return the value for a locate reply message"	^4</body><body package="DST_Core">locateRequestMsg	"return the value for a locate request message"	^3</body><body package="DST_Core">locationForward	^3</body><body package="DST_Core">noException	^0</body><body package="DST_Core">objectForward	^2</body><body package="DST_Core">objectHere	^1</body><body package="DST_Core">replyMsg	"return the value for a reply message"	^1</body><body package="DST_Core">requestMsg	"return the value for a reply message"	^0</body><body package="DST_Core">systemException	^2</body><body package="DST_Core">unknownObject	^0</body><body package="DST_Core">userException	^1</body></methods><methods><class-id>DST.GIOPMessage</class-id> <category>accessing</category><body package="DST_Core">byteOrder	"return the byte ordering of the message"	^messageHeader byteOrder</body><body package="DST_Core">byteOrder: aBoolean 	"return the byte ordering of the message"	messageHeader byteOrder: aBoolean</body><body package="DST_Core">headerSize	^HeaderSize</body><body package="DST_Core">magic	"return the magic byte array of the message"	^messageHeader magic</body><body package="DST_Core">magic: aString 	"set the magic byte array of the message"	messageHeader magic: aString</body><body package="DST_Core">majorVersion	"return the major version number of the message"	^messageHeader majorVersion</body><body package="DST_Core">majorVersion: aByte 	"set the major version number of the message"	messageHeader majorVersion: aByte</body><body package="DST_Core">messageContents	"this is a special method used by the IIOPDaemon to send the 	contents of this message to a remote system. For performance 	reasons, we use the actual CDRStream's collection rather than 	making a copy of it. We also write the header to the beginning of the 	stream"	self insertMessageHeader.	^messageStream</body><body package="DST_Core">messageHeader	^messageHeader</body><body package="DST_Core">messageStream	^messageStream</body><body package="DST_Core">minorVersion	"return the major version number of the message"	^messageHeader minorVersion</body><body package="DST_Core">minorVersion: aByte	"set the minor version number of the message"	messageHeader minorVersion: aByte</body><body package="DST_Core">msgSize	"return the size of the message"	^messageHeader msgSize</body><body package="DST_Core">msgSize: anInt 	"set the size of the message"	messageHeader msgSize: anInt</body><body package="DST_Core">msgType	"return the type of the message"	^messageHeader msgType</body><body package="DST_Core">msgType: anInt 	"set the type of the message"	messageHeader msgType: anInt</body><body package="DST_Core">needsResponse	"Answer whether or not I need to respond to this message"	^response isNil		ifTrue: [self isCancelRequest not]		ifFalse: [response]</body><body package="DST_Core">objectKey	^objectKey</body><body package="DST_Core">operation	^operation</body><body package="DST_Core">principal	"Answer the principal"	^principal</body><body package="DST_Core">requestId	"Answer the requestId"	^requestId</body><body package="DST_Core">serviceContextList	"answer the serviceContextList"	^serviceContextList == nil		ifTrue: [#()]		ifFalse: [serviceContextList]</body></methods><methods><class-id>DST.GIOPMessage</class-id> <category>instance creation</category><body package="DST_Core">asCancelRequest	"initialize the receiver as a cancel request message"	self msgType: self requestMsg.	self magic: 'GIOP'.	self majorVersion: 1.	self minorVersion: 0.	self byteOrder: false 	"BIG-ENDIAN"</body><body package="DST_Core">asCloseConnection	"initialize the receiver as a close connection message"	self msgType: self closeConnectionMsg.	self magic: 'GIOP'.	self majorVersion: 1.	self minorVersion: 0.	"BIG-ENDIAN"	self byteOrder: false</body><body package="DST_Core">asReply	"initialize the receiver as a reply"	self msgType: self replyMsg.	self magic: 'GIOP'.	self majorVersion: 1.	self minorVersion: 0.	self byteOrder: false 	"BIG-ENDIAN"</body><body package="DST_Core">asRequest	"initialize the receiver as a request"	self msgType: self requestMsg.	self magic: 'GIOP'.	self majorVersion: 1.	self minorVersion: 0.	self byteOrder: false 	"BIG-ENDIAN"</body><body package="DST_Core">messageHeader: aGIOPMessageHeader messageStream: aCDRStream 	"initialize the receiver"	messageHeader := aGIOPMessageHeader reset.	messageStream := aCDRStream reset position: HeaderSize</body><body package="DST_Core">messageHeader: aCollection socketAccessor: ipSocketAccessor 	"initialize the receiver"	messageHeader := (GIOPMessageHeader with: aCollection) reset.	messageStream := CDRExternalReadStream on: ipSocketAccessor headerSize: self headerSize.	messageStream byteOrder: messageHeader byteOrder.	messageStream msgSize: messageHeader msgSize</body><body package="DST_Core">requestId: anInteger locateStatus: aSymbol objRef: anObjRef 	"marshall the locate reply header"	requestId := anInteger.	messageStream nextPutLong: anInteger.	messageStream nextPutLong: (self perform: aSymbol).	anObjRef notNil ifTrue: [messageStream nextPutObjectReference: anObjRef CORBAInterface]</body><body package="DST_Core">requestId: anInteger status: aSymbol 	"initialize the reply header. Since we are replying, we remove both 	the security and debugger context since they only propagate in the 	forward direction"	| orbCxt |	requestId := anInteger.	orbCxt := Processor activeProcess orbContext.	orbCxt debuggerContext: nil.	orbCxt securityContext: nil.	ServiceContextListDef marshall: orbCxt serviceContextList on: messageStream.	messageStream nextPutLong: anInteger.	messageStream nextPutLong: (self perform: aSymbol)</body><body package="DST_Core">response: aBoolean objectKey: anObjRef operation: aString principal: aCollection	"initialize the request header"	requestId := self newRequestId.	messageStream nextPutLong: requestId.	messageStream nextPutBoolean: aBoolean.	ObjectKeyDef marshall: anObjRef objectId asByteArray on: messageStream withLocalClass: ObjectKeyDef localClass.	messageStream nextPutString: aString.	PrincipalDef marshall: aCollection on: messageStream withLocalClass: PrincipalDef localClass</body></methods><methods><class-id>DST.GIOPMessage</class-id> <category>converting</category><body package="DST_Core">externalMessageStreamToInternal	"convert the external read stream to an internal CDRStream by 	getting all the bytes from the socket"	| buffer pos size |	messageStream class == CDRExternalReadStream		ifTrue: 			[size := messageStream msgSize + HeaderSize.			buffer := self class newBuffer: size.			pos := messageStream alignmentBoundary + messageStream position.			messageStream				next: size - pos				into: buffer				startingAt: pos + 1.			messageStream := CDRStream on: buffer.			"Set the position to the size to set the read limit"			messageStream position: size.			messageStream position: pos.			messageStream byteOrder: self byteOrder]</body></methods><methods><class-id>DST.GIOPMessage</class-id> <category>testing</category><body package="DST_Core">isCancelRequest	"return true if the receiver is a cancel request message"	^self msgType = self cancelRequestMsg</body><body package="DST_Core">isCloseConnection	"return true if the receiver is an close connection message"	^self msgType = self closeConnectionMsg</body><body package="DST_Core">isLocateReply	"return true if the receiver is a locate reply message"	^self msgType = self locateReplyMsg</body><body package="DST_Core">isLocateRequest	"return true if the receiver is a locate request message"	^self msgType = self locateRequestMsg</body><body package="DST_Core">isMessageError	"return true if the receiver is an error message"	^self msgType = self errorMsg</body><body package="DST_Core">isReply	"return true if the receiver is a reply message"	^self msgType = self replyMsg</body><body package="DST_Core">isRequest	"return true if the receiver is a request message"	^self msgType = self requestMsg</body><body package="DST_Core">isValidMessage	"check the validity of the message header based on magic and 	versions"	^self magic = 'GIOP' and: [self majorVersion = 1 and: [self minorVersion = 0]]</body><body package="DST_Core">isValidReply	"check the message header to see if it's a valid reply"	^self isReply | self isLocateReply</body><body package="DST_Core">isValidRequest	"check the message header to see if it's a valid request"	^self isRequest | self isCancelRequest | self isLocateRequest</body><body package="DST_Core">replyStatusException	"test the reply status to test if no exception occurred"	^status = self systemException or: [status = self userException]</body><body package="DST_Core">replyStatusLocationForward	"test for a location forward status"	^status = self locationForward</body><body package="DST_Core">replyStatusNoException	"test the reply status to test if no exception occurred"	^status = self noException</body><body package="DST_Core">replyStatusObjectForward	"test for a location reply object forward status"	^status = self objectForward</body></methods><methods><class-id>DST.GIOPMessage</class-id> <category>headers</category><body package="DST_Core">extractCancelRequestHeader	"initialize the receiver as a request"	requestId := messageStream nextUnsignedLong</body><body package="DST_Core">extractLocateReplyHeader	"initialize the receiver as a request"	requestId := messageStream nextUnsignedLong.	status := messageStream nextUnsignedLong</body><body package="DST_Core">extractLocateRequestHeader	"initialize the receiver as a request"	requestId := messageStream nextUnsignedLong.	objectKey := ObjectKeyDef unMarshall: messageStream.	objectKey := [NCSuuid on: objectKey] on: Object errorSignal do: [:ex | IIOPObjectKey intern: objectKey]</body><body package="DST_Core">extractReplyHeader	"extract the information from the reply header"	serviceContextList := ServiceContextListDef unMarshall: messageStream.	requestId := messageStream nextUnsignedLong.	status := messageStream nextUnsignedLong</body><body package="DST_Core">extractRequestHeader	"initialize the receiver as a request"	serviceContextList := ServiceContextListDef unMarshall: messageStream.	requestId := messageStream nextUnsignedLong.	response := messageStream nextBoolean.	objectKey := ObjectKeyDef unMarshall: messageStream.	operation := messageStream nextString.	principal := PrincipalDef unMarshall: messageStream</body></methods><methods><class-id>DST.GIOPMessage</class-id> <category>private</category><body package="DST_Core">insertMessageHeader	| pos |	pos := messageStream position.	messageStream position: 0.	messageStream nextPutAll: messageHeader collection.	messageStream position: pos</body><body package="DST_Core">newRequestId	"increment the requestId making sure that it does not exceed the 	value of an unsigned long - and currently the maxVal of 	SmallInteger"	^RequestId := RequestId + 1 \\ 536870911</body></methods><methods><class-id>DST.GIOPMessage class</class-id> <category>buffer management</category><body package="DST_Core">freeBuffer: aByteArray 	"return the buffer to the pool. Large buffers will not be retained"	| size |	size := aByteArray size.	size = HeaderSize ifTrue: [Headers size &gt; 20			ifFalse: 				[HFSem wait.				Headers addLast: aByteArray.				HFSem signal.				^self]].	size = MessageSize ifTrue: [MessageBuffers size &gt; 20			ifFalse: 				[HFSem wait.				MessageBuffers addLast: aByteArray.				HFSem signal.				^self]]</body><body package="DST_Core">freeBuffers: aMessage 	"free the appropirate buffers with for this message"	self freeBuffer: aMessage messageStream collection.	self freeBuffer: aMessage messageHeader collection</body><body package="DST_Core">newBuffer: size 	"return a buffer of at least the requested size"	| buf |	HFSem wait.	size = HeaderSize ifTrue: [Headers isEmpty			ifTrue: 				[HFSem signal.				^ByteArray new: size]			ifFalse: 				[buf := Headers removeLast.				HFSem signal.				^buf]].	size &lt;= MessageSize ifTrue: [MessageBuffers isEmpty			ifTrue: 				[HFSem signal.				^ByteArray new: MessageSize]			ifFalse: 				[buf := MessageBuffers removeLast.				HFSem signal.				^buf]].	HFSem signal.	^ByteArray new: size</body></methods><methods><class-id>DST.GIOPMessage class</class-id> <category>accessing</category><body package="DST_Core">headerSize	^HeaderSize</body></methods><methods><class-id>DST.GIOPMessage class</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	HeaderSize := 12.	MessageSize := 4084.	RequestId := 1.	Headers := OrderedCollection new: 20.	MessageBuffers := OrderedCollection new: 20.	LargeBuffers := OrderedCollection new: 5.	HFSem := Semaphore forMutualExclusion</body><body package="DST_Core">reInitialize	"initialize the receiver"	| fieldArray |	HeaderSize := 12.	RequestId := 1.	ObjectKeyDef := (DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray.	fieldArray := Array with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #contextId))					with: DSTtypeUnsignedLong new)				with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #contextData))						with: (DSTtypeSequence new subtype: DSTtypeOctet new size: nil; localType: #ByteArray)).	ServiceContextListDef := DSTtypeSequence new subtype: ((DSTtypeStructure new) id: #ServiceContext fields: fieldArray; localType: #DSTServiceContext) size: nil.	PrincipalDef := (DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray.	ProfileBodyDef := (DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray</body></methods><methods><class-id>DST.GIOPMessage class</class-id> <category>instance creation</category><body package="DST_Core">messageHeader: aMessageHeader messageStream: aMessageStream	"Answer a new instance of the receiver, which streams over an 	internal messageStream. Note: this is used when sending a 	message only"	^(self basicNew) messageHeader: aMessageHeader messageStream: aMessageStream; yourself</body><body package="DST_Core">messageHeader: aCollection socketAccessor: ipSocketAccessor 	"Answer a new instance of the receiver, which streams over an 	external ipSocketAccessor. Note: this is used when receiving a 	message only"	^(self basicNew) messageHeader: aCollection socketAccessor: ipSocketAccessor; yourself</body><body package="DST_Core">newCloseConnection	"initialize a new close connection packet"	^self newMessage asCloseConnection</body><body package="DST_Core">newMessage	"initialize a new fragment packet"	| stream header |	stream := CDRStream on: (self newBuffer: MessageSize).	header := GIOPMessageHeader with: (self newBuffer: HeaderSize).	^self messageHeader: header messageStream: stream</body><body package="DST_Core">newReply	"initialize a new reply packet"	^self newMessage asReply</body><body package="DST_Core">newRequest	"initialize a new request packet"	^self newMessage asRequest</body></methods><methods><class-id>DST.DSTServiceConfiguration</class-id> <category>accessing</category><body package="DST_Core">isSetToLocal	^(self settingFor: #kind) == #local</body><body package="DST_Core">orderOfConfiguration	"Return the order in which a service should be configured at system startup.	The smaller the number, the earlier the service should be configurd."	self subclassResponsibility</body><body package="DST_Core">serviceName	"Return a symbol identifying this service"	^self class configurationName</body><body package="DST_Core">setFilename: aFilename	self settingFor: #kind put: #filename.	self settingFor: #filename put: aFilename.</body><body package="DST_Core">setHostname: hostname transport: transport port: port	self settingFor: #kind put: #hostname.	self settingFor: #hostname put: hostname.	self settingFor: #transport put: (transport isSymbol ifTrue: [transport] ifFalse: [transport transportName]).	self settingFor: #port put: port.</body><body package="DST_Core">setLocal	self settingFor: #kind put: #local</body></methods><methods><class-id>DST.DSTServiceConfiguration</class-id> <category>configuring</category><body package="DST_Core">configure	"configure the service for this image"	self subclassResponsibility</body></methods><methods><class-id>DST.DSTServiceConfiguration</class-id> <category>private</category><body package="DST_Core">orbFromHostname	| objRef |	objRef := OrbResolver				generateOrbProxy: (self settingFor: #hostname)				transport: (self transportNamed: (self settingFor: #transport))				port: (self settingFor: #port).	"Install the interface meta object for a remote orb so that we don't have 	to look it up."	( #{DSTRepository} isDefined )		ifTrue:	[ objRef interface: 					( #{DSTRepository} value new DistributedSmalltalk 						metaObjectOf: #ORBObject_class)				].	^objRef</body><body package="DST_Core">settings	"The user preference profile is a Dictionary full of value models 	hashed against subject keys."	"If you change something here change the class comment which 	documents this."	settingDictionary == nil		ifTrue: 			[| transport mngr |			mngr := ORBDaemon configurationManager.			transport := mngr primaryTransport.			settingDictionary := IdentityDictionary new.			settingDictionary 				at: #kind put: #local asValue;				at: #hostname put: '' asValue;				at: #transport put: transport transportName asValue;				at: #port put: transport defaultPort asValue;				at: #filename put: '' asValue].	^settingDictionary</body></methods><methods><class-id>DST.DSTServiceConfiguration class</class-id> <category>accessing</category><body package="DST_Core">current	^ORBDaemon configurationManager configurationOf: self configurationName</body></methods><methods><class-id>DST.DSTInterfaceRepositoryConfiguration</class-id> <category>configuring</category><body package="DST_Core">configure	"configure the remote repository for this image. Note that the 	interface for the SharedIR is implemented on ORBDaemon class. 	This 	is different from most of the other services we are configuring and 	is 	NOT what you get when you ask the remote orb to 	'resolveInitialReferences: #InterfaceRepository'"	| kind |	ORBDaemon running ifFalse: [^self].	kind := self settingFor: #kind.	ORBObject remoteRepository: (kind == #filename			ifTrue: [ORBObject referenceFromFile: (self settingFor: #filename)]			ifFalse: [kind == #hostname					ifTrue: [self orbFromHostname daemon]					ifFalse: [nil]])</body></methods><methods><class-id>DST.DSTInterfaceRepositoryConfiguration</class-id> <category>accessing</category><body package="DST_Core">orderOfConfiguration	"Return the order in which a service should be configured at system startup. 	The smaller the number, the earlier the service should be configurd. 	The interface repository might be needed to configure services that are remote, 	therefore, it has the lowest number."	^1</body></methods><methods><class-id>DST.DSTInterfaceRepositoryConfiguration class</class-id> <category>accessing</category><body package="DST_Core">configurationName	"Return a symbol identifying this configuration"	^#interfaceRepository</body></methods><methods><class-id>DST.DSTInterfaceRepositoryConfiguration class</class-id> <category>class initialization</category><body package="DST_Core">initialize	"self initialize"	self addService</body><body package="DST_Core">release	self removeService</body></methods><methods><class-id>DST.DSTModuleI3Null class</class-id> <category>testing</category><body package="DST_Core">isLoaded	"Is this module loaded."	^false</body></methods><methods><class-id>DST.DSTModuleI3Null class</class-id> <category>accessing</category><body package="DST_Core">newOperationFor: aSymbol	"Return a new operation. If not available or not configured, 	return nil."	^nil</body><body package="DST_Core">newOperationInfoForInterface: anInterface selector: aSelector 	"Return a new operation info. If not available or not configured, 	return nil."	^nil</body></methods><methods><class-id>DST.IIOPConversation</class-id> <category>accessing</category><body package="DST_Core">activityString	"return the string representation of the requestId"	^self requestId printString</body><body package="DST_Core">asConversationInfo	"answer information about the receiver"	^DSTConversationInfo on: self</body><body package="DST_Core">connection	"answer the peer connection for this conversation"	^connection</body><body package="DST_Core">connection: aConnection	"set the peer connection for this conversation"	connection := aConnection</body><body package="DST_Core">operation	^operation</body><body package="DST_Core">reply	"return the reply message."	^reply</body><body package="DST_Core">reply: aMessage 	reply := aMessage</body><body package="DST_Core">request	"return the request message."	^request</body><body package="DST_Core">requestId	^requestId</body><body package="DST_Core">state	"answer the state of the conversation"	^state == nil		ifTrue: [#unknown]		ifFalse: [state]</body></methods><methods><class-id>DST.IIOPConversation</class-id> <category>interceptors</category><body package="DST_Core">messageInterceptors	"Construct the interceptor instances from the interceptor classes. 	This could be a single interceptor or a collection of interceptors or nil."	^MessageInterceptors isNil 		ifFalse:	[ MessageInterceptors construct ]		ifTrue:	[ MessageInterceptors ]</body><body package="DST_Core">requestInterceptors	"Construct the interceptor instances from the interceptor classes. 	This could be a single interceptor or a sorted collection of interceptors or nil."	^RequestInterceptors isNil 		ifFalse:	[ RequestInterceptors construct ]		ifTrue:	[ RequestInterceptors ]</body></methods><methods><class-id>DST.IIOPConversation class</class-id> <category>interceptors</category><body package="DST_Core">clearMessageInterceptors	"	IIOPConversation clearMessageInterceptors.	"	MessageInterceptors := nil</body><body package="DST_Core">clearRequestInterceptors	"	IIOPConversation clearRequestInterceptors.	"	RequestInterceptors := nil</body><body package="DST_Core">installMessageInterceptor: anInterceptorClass	MessageInterceptors isNil 		ifTrue:	[ MessageInterceptors := anInterceptorClass ]		ifFalse:	[	MessageInterceptors isSequenceable 						ifTrue:	[ MessageInterceptors add: anInterceptorClass ]						ifFalse:	[MessageInterceptors := DSTInterceptorCollection 															with: MessageInterceptors 															with: anInterceptorClass ]				]</body><body package="DST_Core">installRequestInterceptor: anInterceptorClass	RequestInterceptors isNil 		ifTrue: [RequestInterceptors := anInterceptorClass]		ifFalse: 			[RequestInterceptors isSequenceable 				ifTrue:	[ RequestInterceptors add: anInterceptorClass ]				ifFalse:	[ RequestInterceptors := DSTInterceptorCollection 													with: RequestInterceptors 													with: anInterceptorClass						]			]</body><body package="DST_Core">messageInterceptorClasses	^MessageInterceptors</body><body package="DST_Core">messageInterceptors	"Construct the interceptor instances from the interceptor classes. 	This could be a single interceptor or a collection of interceptors or nil."	^MessageInterceptors isNil 		ifFalse:	[ MessageInterceptors construct ]		ifTrue:	[ MessageInterceptors ]</body><body package="DST_Core">requestInterceptorClasses	^RequestInterceptors</body><body package="DST_Core">requestInterceptors	"Construct the interceptor instances from the interceptor classes. 	This could be a single interceptor or a sorted collection of interceptors or nil."	^RequestInterceptors isNil 		ifFalse:	[ RequestInterceptors construct ]		ifTrue:	[ RequestInterceptors ]</body></methods><methods><class-id>DST.IIOPConversation class</class-id> <category>initialization</category><body package="DST_Core">initialize: aDaemon 	"initialize the receiver"	ActiveDaemon := aDaemon</body></methods><methods><class-id>DST.IIOPConversation class</class-id> <category>accessing</category><body package="DST_Core">messageTimeout	"Return the maximum timeout.  Initialize it to the shown 	number of seconds if nil.  Users who wish to run long-	lasting connections should reset the receive timeout to	a higher value, or, in extreme cases, to 'Infinity positive'.	Note that IIOPConnection class&gt;&gt;receiveTimeout will	also require adjustment in this circumstance."	^MessageTimeOut == nil		ifTrue:	[ 300]		ifFalse:	[ MessageTimeOut	]</body><body package="DST_Core">messageTimeout: seconds	"Set the maximum timeout."	"IIOPConversation messageTimeout: Infinity positive."	MessageTimeOut :=  seconds</body></methods><methods><class-id>DST.IIOPServerConversation</class-id> <category>accessing</category><body package="DST_Core">canceled	"answer whether or not this conversation has been canceled"	^canceled</body><body package="DST_Core">canceled: aBoolean 	"set cancelled flag for this conversation"	canceled := aBoolean == true</body><body package="DST_Core">opSelector	^request notNil		ifTrue: [request operation]		ifFalse: ['unknown']</body><body package="DST_Core">role	"answer the role description"	^'server'</body><body package="DST_Core">targetId	^nil</body></methods><methods><class-id>DST.IIOPServerConversation</class-id> <category>requests</category><body package="DST_Core">cancelRequest	"do the actual work of decoding the message and performing the 	cancel request."	reply msgSize: reply messageStream size - reply headerSize.	connection notNil		ifTrue: [connection cancelReply: request requestId]		ifFalse: [ActiveDaemon cancelReply: request requestId]</body><body package="DST_Core">doRequest	"get the remaining bytes and dispatch the request accordingly"	request isRequest ifTrue: [^self regularRequest].	request isCancelRequest ifTrue: [^self cancelRequest].	request isLocateRequest ifTrue: [^self locateRequest]</body><body package="DST_Core">errorReply: anArray forException: anException 	"RGF: Editted to change 'thisContext' to 'anException 	initialContext'. So that stack displays at the correct place. 	Unwinding should (I assume) be added."	self canceled ifTrue: [^self].	request needsResponse		ifTrue: 			[| mo |			reply isNil ifFalse: [GIOPMessage freeBuffers: reply].			reply := GIOPMessage newReply.			reply requestId: request requestId status: (anArray at: 3).			mo := anArray at: 1.			reply messageStream nextPutString: mo repositoryId.			mo errorType marshall: (anArray at: 2)				on: reply messageStream.			reply msgSize: reply messageStream size - reply headerSize]</body><body package="DST_Core">locateRequest	"do the actual work of decoding the message and performing the 	locate request."	| obj |	reply := GIOPMessage newReply.	reply msgType: reply locateReplyMsg.	obj := DSTObjRefRemote objectOf: request objectKey.	obj isNil		ifTrue: [reply				requestId: request requestId				locateStatus: #unknownObject				objRef: nil]		ifFalse: [obj isLocal				ifTrue: [reply						requestId: request requestId						locateStatus: #objectHere						objRef: obj]				ifFalse: [reply						requestId: request requestId						locateStatus: #objectHere						objRef: nil]].	reply msgSize: reply messageStream size - reply headerSize</body><body package="DST_Core">processRequest: aCallMessage 	"do the actual work of decoding the message and performing the 	request"	| ar |		[	request := aCallMessage.		( request isRequest )			ifTrue:	[	request extractRequestHeader.						requestId := request requestId.						( connection notNil )							ifTrue:	[ connection registerConversation: self ].						request externalMessageStreamToInternal]			ifFalse:	[	( request isLocateRequest )							ifTrue:	[	request extractLocateRequestHeader.										requestId := request requestId.										( connection notNil )											ifTrue:	[ connection registerConversation: self ]									]							ifFalse:	[	( request isCancelRequest )											ifTrue:	[	request extractCancelRequestHeader 													]											ifFalse:	[	( request isCloseConnection )															ifTrue:	[ connection shutDownConnection ]															ifFalse:	[ ORBObject badParamError: 1 ]													]									]					]	]	on: Object errorSignal		do:	[:ex |	self readRemainingBytes.					operation isNil						ifTrue:	[ ar := DSToperation new findCorbaExceptionFor: ex ]						ifFalse:	[ ar := operation findCorbaExceptionFor: ex ].					[	"This can blow in response to a WSAECONNRESET, hence the 'on:do:'."						[ self errorReply: ar forException: ex ]							on:	Error							do:	[ :exc |	Transcript cr; show: ex messageText.										^self 								].						ActiveDaemon sendReply: self 					] fork.				^self			].	self spawnRequest</body><body package="DST_Core">regularRequest	"Do the actual work of decoding the message and performing the 	request.  In 5i, interceptors have been spliced in as indicated in	the code comments below."	| prio msgIntercept reqIntercept orbCxt |	prio := Processor activeProcess priority.	[	| receiver opargs result |		receiver := DSTObjRefRemote objectOf: (NCSuuid on: request objectKey).		receiver isNil			ifTrue:	[	ORBObject invObjrefError: 0					]			ifFalse:	[	operation := receiver CORBAInterface findOpByName: request operation.						operation isNil							ifTrue:	[	ORBObject badOperationError: 0									]							ifFalse:	[	orbCxt := Processor activeProcess orbContext.										"Interceptor Hook for 'requestPreUnMarshall'."										( msgIntercept := self messageInterceptors ) isNil 											ifFalse:	[ msgIntercept 														preReceiveMessage: request 														context: orbCxt 														target: receiver													].										opargs := operation unMarshallArgumentsFrom: request messageStream.										"Interceptor Hook for 'requestPostUnMarshall'."										( reqIntercept := self requestInterceptors ) isNil 											ifFalse:	[ reqIntercept 														targetInvokePreReceive: request 														context: orbCxt 														target: receiver 														parameters: opargs													].										self checkAuthorization: receiver forOperation: operation.										Processor activeProcess priority: ORBObject orbRequestPriority.										Processor yield.										result := receiver 													perform: operation localOp 													withArguments: opargs asArray.										Processor activeProcess priority: prio.										reply := GIOPMessage newReply.										reply requestId: request requestId status: #noException.										"Interceptor Hook for 'replyPreMarshall'."										( reqIntercept := self requestInterceptors ) isNil 											ifFalse:	[ reqIntercept														targetInvokePostReceive: request														context: orbCxt														target: receiver														result: result ].										operation											marshallResult: result											on: reply messageStream											withArgs: opargs.										reply msgSize: reply messageStream size - reply headerSize.										"Interceptor Hook for 'replyPostMarshall'."										( msgIntercept := self messageInterceptors ) isNil 											ifFalse:	[ msgIntercept														postReceiveMessage: request														context: orbCxt														target: receiver														reply: reply ]								]					]	]	on: Object errorSignal		do:	[:ex | 	| ar |					Processor activeProcess priority: prio.					operation isNil						ifTrue:	[ ar := DSToperation new findCorbaExceptionFor: ex ]						ifFalse:	[ ar := operation findCorbaExceptionFor: ex ].					self errorReply: ar forException: ex			]</body><body package="DST_Core">spawnRequest		[	(Processor activeProcess orbContext) addServiceContexts: request serviceContextList; local: false.		state := #working.		self doRequest.		request needsResponse 			ifTrue: [				reply notNil ifTrue: [					state := #replying.					ActiveDaemon sendReply: self.					state := #final.					"If it is local rpc, don't release the buffer. It will be released by					the sending thread."					self connection isNil ifFalse: [GIOPMessage freeBuffers: reply]]]			ifFalse: [ "Need to unRegister the oneway call conversation"				self connection isNil					ifTrue: [ActiveDaemon unRegisterServerConversation: self;							unRegisterClientConversation: self]					ifFalse: [self connection unRegisterConversationWithoutShutdown: self]]	] fork</body></methods><methods><class-id>DST.IIOPServerConversation</class-id> <category>private</category><body package="DST_Core">cancel	"cancel the current connection"	self canceled: true</body><body package="DST_Core">checkAuthorization: obj forOperation: anOperation 	"Check security constraints - raise exception on violation. 	No-op is security off or not loaded." 	DSTModules security hostSecurity 		ifTrue: [(DSTModules security hostIsAuthorized: self hostAddressOfClient)					ifFalse: [^ORBObject noPermissionError: 0]].	DSTModules security checkUserAuthorization: obj forOperation: anOperation</body><body package="DST_Core">hostAddressOfClient	"answer the host address for the cleint conversation"	^connection isNil		ifTrue: [ActiveDaemon hostId]		ifFalse: [connection hostAddressOfClient]</body><body package="DST_Core">readRemainingBytes	"get the remaining bytes from the socket for this message"	connection notNil ifTrue: [connection readRemainingBytes: request messageStream]</body></methods><methods><class-id>DST.IIOPServerConversation</class-id> <category>initialize-release</category><body package="DST_Core">initialize: aServerConnection 	"initialize instance variables"	state := #init.	canceled := false.	connection := aServerConnection</body></methods><methods><class-id>DST.IIOPServerConversation class</class-id> <category>instance creation</category><body package="DST_Core">new: aServerConnection 	^self basicNew initialize: aServerConnection</body></methods><methods><class-id>DST.DSTtypeVoid</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream. Do nothing"</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^true</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class. 	Do nothing"	^nil</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream	"unmarshall the type code of the receiver - do nothing since there 	are no parameters and the TCkind has already been unmarshalled"	^self</body></methods><methods><class-id>DST.DSTtypeVoid</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_void</body></methods><methods><class-id>DST.DSTtypeVoid</class-id> <category>rendering</category><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^false</body></methods><methods><class-id>DST.DSTtypeVoid</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'void'</body></methods><methods><class-id>DST.DSTtypeVoid</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::PrimitiveDef'</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_void</body></methods><methods><class-id>DST.DSTtypeVoid</class-id> <category>accessing</category><body package="DST_Core">idlName	"return the receivers full qualified name"	^self definingMetaObject  idlName , '::' , self printName</body></methods><methods><class-id>DST.DSTtypeVoid class</class-id> <category>initialization</category><body package="DST_Core">initialize	"DSTtypeVoid initialize"	CachedTypeVoid := DSTtypeVoid new</body></methods><methods><class-id>DST.DSTtypeVoid class</class-id> <category>instance creation</category><body package="DST_Core">name: aName 	aName = 'void'		ifTrue: [^CachedTypeVoid]		ifFalse: [self class intfReposError: 0]</body></methods><methods><class-id>DST.DSTUserContext</class-id> <category>CORBAContext</category><body package="DST_Core">createChild: aString 	"This operation creats a child context object which is chained into the 	receiver"	^bindings at: aString put: self class new</body><body package="DST_Core">delete	"This operation deletes the receiver"	bindings := nil</body><body package="DST_Core">deleteTree	"This operation deletes the receiver and all of its descendents"	bindings do: [:value | value class == self class ifTrue: [value delete]].	self delete</body><body package="DST_Core">deleteValues: aString 	"This method deletes the specifed property value(s) from the context 	object. If aString has a wildcard character, then all property names 	that match will be deleted"	(bindings keys select: [:key | aString match: key])		do: [:key | bindings removeKey: key ifAbsent: []]</body><body package="DST_Core">getValues: propName 	"This method retreves the specified context property value(s). If 	propName has a trailing wildcard character ('*'), then all matching 	properties and their values are returned"	| aCollection |	aCollection := OrderedCollection new.	bindings keysAndValuesDo: [:key :value | 			(propName match: key) ifTrue: [aCollection add: key-&gt;value]].	^aCollection</body><body package="DST_Core">setOneValue: anAssociation 	"this method sets a single context object property. At this time only 	string values may be propagated by the ORB as per the CORBA 2.0 	Specification"	bindings add: anAssociation</body><body package="DST_Core">setValues: aCollection 	"this operation sets one or more property values in the context object"	aCollection do: [:assoc | self setOneValue: assoc]</body></methods><methods><class-id>DST.DSTUserContext</class-id> <category>accessing</category><body package="DST_Core">userContextList	"answer a copy of the user context list"	^bindings associations</body></methods><methods><class-id>DST.DSTUserContext</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	bindings := Dictionary new</body></methods><methods><class-id>DST.DSTUserContext class</class-id> <category>instance creation</category><body package="DST_Core">new	^self basicNew initialize</body></methods><methods><class-id>DST.DSTSelectorPragma</class-id> <category>accessing</category><body package="DST_Core">selector	^selector</body><body package="DST_Core">selector: aSelector 	selector := aSelector</body></methods><methods><class-id>DST.DSTSelectorPragma</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma selector ' , name , ' ' , selector</body></methods><methods><class-id>DST.DSTSelectorPragma</class-id> <category>actions</category><body package="DST_Core">applyTo: aMetaObject 	"set the selector for the operation from the pragma."	| msg |	(aMetaObject canApplyPragma: #ID)		ifTrue: [aMetaObject localOp: (aMetaObject convertSymbol: self selector)]		ifFalse: 			[msg := 'Selector pragma not allowed on ' , aMetaObject displayString.			ORBDaemon configurationManager log: msg withCRs.			Dialog notify: msg]</body></methods><methods><class-id>DST.DSTtypeShort</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_short</body></methods><methods><class-id>DST.DSTtypeShort</class-id> <category>accessing</category><body package="DST_Core">valueExcept: aCol 	"Answer a valid boolean value not contained in the collection, otherwise 	nil"	| max maxSize probe |	name = 'short'		ifTrue: [max := 32767]		ifFalse: [name = 'long'				ifTrue: [max := 2147483647]				ifFalse: [name = 'unsigned short'						ifTrue: [maxSize := 65536]						ifFalse: [maxSize := 4294967296]]].	maxSize isNil		ifTrue: [maxSize := max + 1 * 2]		ifFalse: [max := maxSize - 1].	aCol size &lt; maxSize		ifTrue: 			[probe := max.			[aCol includes: probe]				whileTrue: [probe := probe - 1].			^probe]		ifFalse: [^nil]</body></methods><methods><class-id>DST.DSTtypeShort</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = exception on nextPutShort:"	aStream nextPutShort: aParameter</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^(aParameter isInteger)		and: [aParameter between:  -32768 and:  32767]</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextShort</body></methods><methods><class-id>DST.DSTtypeShort</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'short'</body></methods><methods><class-id>DST.DSTtypeShort</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_short</body></methods><methods><class-id>DST.DSTtypeUnsignedShort</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_ushort</body></methods><methods><class-id>DST.DSTtypeUnsignedShort</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = exception on nextPutUnsignedShort:"	aStream nextPutUnsignedShort: aParameter</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextUnsignedShort</body></methods><methods><class-id>DST.DSTtypeUnsignedShort</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'unsigned short'</body></methods><methods><class-id>DST.DSTtypeUnsignedShort</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_ushort</body></methods><methods><class-id>DST.DSTNamedValue</class-id> <category>accessing</category><body package="DST_Core">flags	"answer the list of flags"		^flags</body><body package="DST_Core">flags: aCollection	"answer the list of flags"		flags := aCollection</body><body package="DST_Core">name	"answer the name"		^key</body><body package="DST_Core">name: aString	"answer the name"		super key: aString</body></methods><methods><class-id>DST.DSTNamedValue class</class-id> <category>instance creation</category><body package="DST_Core">name: aString value: anObject flags: aCollection 	"Answer a new instance of the receiver with the arguments as the 	name and value of the association. Also set hte flags accordingly"	^(super key: aString value: anObject)		flags: aCollection</body></methods><methods><class-id>DST.DSTModules class</class-id> <category>accessing</category><body package="DST_Core">i3	I3Module == nil ifTrue: [^DSTModuleI3Null].	^I3Module</body><body package="DST_Core">security	SecurityModule == nil ifTrue: [^DSTModuleSecurityNull].	^SecurityModule</body></methods><methods><class-id>DST.DSTModules class</class-id> <category>class initialization</category><body package="DST_Core">i3Module: aModule	I3Module := aModule</body><body package="DST_Core">initialize	self initializeI3Module.	self initializeSecurityModule.</body><body package="DST_Core">initializeI3Module	I3Module := nil</body><body package="DST_Core">initializeSecurityModule	SecurityModule := nil</body><body package="DST_Core">securityModule: aModule	SecurityModule := aModule</body></methods><methods><class-id>DST.DSTConversationInfo</class-id> <category>initialize-release</category><body package="DST_Core">initializeFrom: aConversation 	"initialize the receiver using information from aConversation"	target := aConversation targetId isNil				ifTrue: ['']				ifFalse: [aConversation targetId printString].	role := aConversation role.	operation := aConversation opSelector.	activity := aConversation activityString.	state := aConversation state</body></methods><methods><class-id>DST.DSTConversationInfo</class-id> <category>accessing</category><body package="DST_Core">activity	"answer the activity description"	^activity</body><body package="DST_Core">operation	"answer the operation description"	^operation</body><body package="DST_Core">role	"answer the role description"	^role</body><body package="DST_Core">state	"answer the state description"	^state</body><body package="DST_Core">target	"answer the target object description"	^target</body></methods><methods><class-id>DST.DSTConversationInfo</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"Append to the argument, aStream, the print description of the receiver"	super printOn: aStream.	(self role == nil or: [self operation == nil])		ifFalse: [aStream nextPutAll: ' ('; nextPutAll: self role; nextPutAll: ' for '; nextPutAll: self operation; nextPut: $)]</body></methods><methods><class-id>DST.DSTConversationInfo class</class-id> <category>instance creation</category><body package="DST_Core">on: aConversation 	"answer a new instance of information about aConversation"	^self new initializeFrom: aConversation</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>private</category><body package="DST_Core">accessLock	accessLock isNil ifTrue: [accessLock := RecursionLock new].	^accessLock</body><body package="DST_Core">checkBound: aFloat	(aFloat &lt; 1 and: [ aFloat &gt; 0 ])		ifFalse: [ Warning raiseSignal: 'Bound must between 0 and 1!' ].</body><body package="DST_Core">checkRatio: aNumber	aNumber &gt; 1 ifFalse: [ Warning raiseSignal: 'Ratio must be greater than 1!' ].	self shrinkBound ifNotNil: [ :shrink || maximum |		maximum := self growBound / shrink.		aNumber &lt; maximum			ifFalse: [ Warning					raiseWith: (Array with: maximum)					errorPattern: 'Grow ratio must be at most &lt;1p&gt;' ] ].</body><body package="DST_Core">copyEmpty: aSize	"Answer a copy of the receiver that contains no elements.	This method should be redefined in subclasses that add	instance variables, so that the state of those variables	is preserved"	^(self class new: aSize)		shrinkBound: shrinkBound;		growBound: growBound;		shrinkRatio: shrinkRatio;		growRatio: growRatio;		minimumSize: minimumSize;		yourself</body><body package="DST_Core">findKey: key ifAbsent: aBlock	"Look for the key in the receiver.  If it is found, answer	the index of the association containing the key, otherwise	answer the result of evaluating aBlock."		| index |	index := self findKeyOrNil: key.	(keys basicAt: index) == nil ifTrue: [^aBlock value].	^index</body><body package="DST_Core">findKeyOrNil: key 	"Look for the key in the receiver. If it is found, answer 	the index of the association containing the key, otherwise 	answer the index of the first unused slot."	| location length probe pass |	length := keys size.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.		[probe := keys at: location.	probe = 0 ifTrue: [values at: location put: 0].	probe == nil or: [probe == key]]		whileFalse: [(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body><body package="DST_Core">initialIndexFor: aHashValue boundedBy: length 	"Find the place where we should start the search. 	Optimize for relatively small dictionaries."	"For very large dictionaries, spread out the hash."	| maxHash |	maxHash := ObjectMemory maximumIdentityHashValue.	length &gt; maxHash ifTrue: [^aHashValue * (length // maxHash + 1) \\ length + 1].	^aHashValue \\ length + 1</body><body package="DST_Core">keyNotFoundError: key	"Raise a signal indicating that the key was	not found."	^Dictionary keyNotFoundSignal raiseWith: key</body><body package="DST_Core">rehash	self changeCapacityTo: self capacity</body><body package="DST_Core">swap: nextIndex with: oldIndex 	"Move the element at oneIndex to anotherIndex, and vice-versa."	| k v |	k := keys at: oldIndex.	v := values at: oldIndex.	keys at: oldIndex put: (keys at: nextIndex).	values at: oldIndex put: (values at: nextIndex).	keys at: nextIndex put: k.	values at: nextIndex put: v</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>printing</category><body package="DST_Core">maxPrint	"Answer the maximum number of characters to print with printOn:."	^5000</body><body package="DST_Core">printOn: aStream  	"Append to the argument aStream a sequence of characters that identifies the receiver."	| tooMany |	tooMany := aStream position + self maxPrint.	aStream nextPutAll: self class name, ' ('.	self associationsDo: 		[:element | 		aStream position &gt; tooMany ifTrue: [aStream nextPutAll: '...etc...)'. ^self].		element printOn: aStream.		aStream space].	aStream nextPut: $)</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>accessing</category><body package="DST_Core">associations	"Answer an OrderedCollection containing the receiver's associations in an 	arbitrary order."	| aCollection |	aCollection := OrderedCollection new: tally.	self associationsDo: [:assn | aCollection add: assn].	^aCollection</body><body package="DST_Core">at: key 	"Answer the value at key.  If key is not found, raise a signal."	^self at: key ifAbsent: [self keyNotFoundError: key]</body><body package="DST_Core">at: key ifAbsent: aBlock 	"Answer the value at key. If key is not found, answer the 	result of evaluating aBlock."	(key == nil or: [key = 0]) ifTrue: [^aBlock value].	^self accessLock		critical: 			[| index obj |			index := self findKeyOrNil: key.			obj := keys at: index.			(obj == nil or: [obj = 0])				ifTrue: [aBlock value]				ifFalse: [values at: index]]</body><body package="DST_Core">at: key put: anObject 	"Set the value at key to be anObject. If key is not found, create a new 	entry for key and set is value to anObject. Answer anObject."	(key == nil or: [ key = 0 ]) ifTrue: [^self subscriptBoundsError: key].	anObject = 0 ifTrue: [^self error: 'Invalid value'].	^self accessLock		critical: 			[| index |			tally * 2 &gt; keys size ifTrue: [self grow].			index := self findKeyOrNil: key.			(keys at: index) == nil ifTrue: [				tally := tally + 1.				keys at: index put: key].			values at: index put: anObject.			anObject]</body><body package="DST_Core">capacity	^keys capacity</body><body package="DST_Core">keyAtValue: value ifAbsent: exceptionBlock	"Answer the key whose value is identical to the argument, value.  	If there is none, answer the result of evaluating exceptionBlock." 	self keysAndValuesDo: 		[:aKey :aValue | value == aValue ifTrue: [^aKey]].	^exceptionBlock value</body><body package="DST_Core">keys	^self accessLock		critical: 			[| keyList |			keyList := OrderedCollection new: tally.			1 to: keys size				do: 					[:index | 					| key |					key := keys at: index.					(key isNil or: [key = 0 or: [(values at: index)								= 0]])						ifFalse: [keyList add: key]].			^keyList]</body><body package="DST_Core">tally	^tally</body><body package="DST_Core">values	^self accessLock		critical: 			[| valList |			valList := OrderedCollection new: tally.			1 to: values size				do: 					[:index | 					| val key |					key := keys at: index.					(key isNil or: [key = 0 or: [(val := values at: index) = 0]])						ifFalse: [valList add: val]].			^valList]</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>user interface</category><body package="DST_Core">inspect	"Create and schedule a DictionaryInspector in which the user can examine the	receiver's variables."	| insp |	insp := Smalltalk at: #DictionaryInspector ifAbsent: [^super inspect].	Cursor wait showWhile: [insp openOn: self]</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>dictionary removing</category><body package="DST_Core">removeAssociation: anAssociation 	"Remove the key and value association, anAssociation, from the 	receiver.  Answer anAssociation.  If the key is not in the receiver,	then provide an error notification that it was not found."	^self removeAssociation: anAssociation ifAbsent: [self notFoundError]</body><body package="DST_Core">removeAssociation: anAssociation ifAbsent: anExceptionBlock 	"Remove the key and value association, anAssociation, from the 	receiver.  If not found, answer the result of evaluating 	anExceptionBlock, otherwise answer anAssociation."	^self removeKey: anAssociation key ifAbsent: anExceptionBlock</body><body package="DST_Core">removeKey: key 	"Remove key from the receiver.  If key is not in the receiver, raise a signal.  Otherwise, answer the value associated with key."	^self removeKey: key ifAbsent: [self keyNotFoundError: key]</body><body package="DST_Core">removeKey: key ifAbsent: aBlock 	"Remove key from the receiver. If key is not in the receiver, 	answer the result of evaluating aBlock. Otherwise, answer the value 	associated with key."	^self accessLock		critical: 			[| index element |			index := self findKey: key ifAbsent: [nil].			index isNil				ifTrue: [aBlock value]				ifFalse: 					[element := keys at: index.					keys at: index put: 0.					values at: index put: 0.					element]]</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>enumerating</category><body package="DST_Core">associationsDo: aBlock 	"Evaluate aBlock for associations consisting of the receiver's keys and 	their values."	self accessLock		critical: 			[tally == 0 ifTrue: [^self].			1 to: keys size do: 				[:index | 				| key val |				(((key := keys at: index) == nil or: [key = 0])					or: [(val := values at: index) = 0])					ifFalse: [aBlock value: key -&gt; val]]]</body><body package="DST_Core">collect: aBlock 	"Evaluate aBlock with each of the values of the receiver as the  	argument.  Collect the resulting values into a collection.	 Answer the new collection."	| newCollection |	newCollection := OrderedCollection new: self size.	self do: [:each | newCollection add: (aBlock value: each)].	^newCollection</body><body package="DST_Core">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="DST_Core">do: aBlock 	"Evaluate aBlock with each of the receiver's elements as the 	argument."	self accessLock		critical: 			[tally == 0 ifTrue: [^self].			1 to: keys size do: 				[:index | 				| key val |				(((key := keys at: index) == nil or: [key = 0])					or: [(val := values at: index) = 0])					ifFalse: [aBlock value: val]]]</body><body package="DST_Core">keysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."	self accessLock		critical: 			[tally = 0 ifTrue: [^self].			1 to: keys size do: 				[:index | 				| key val |				(((key := keys at: index) == nil or: [key = 0])					or: [(val := values at: index) = 0])					ifFalse: [aBlock value: key value: val]]]</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>initialize-release</category><body package="DST_Core">accessLock: aRecursionLock	accessLock := aRecursionLock</body><body package="DST_Core">initSize: aSize 	keys := WeakArray new: aSize.	values := Array new: aSize.	tally := 0.	"To allow disabling shrinking, the default is only applied during instance creation. If it is subsequently nilled out then shrinking is disabled."	shrinkBound := self class defaultShrinkBound.	self makeDependent</body><body package="DST_Core">makeDependent	keys addDependent: self.</body><body package="DST_Core">release	keys release.	values release.	super release.</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>private-finalization/growth</category><body package="DST_Core">changeCapacityTo: newCapacity 	"Change the size of the receiver to newCapacity. The receiver will 	be regrown to fit its contents."	"Note that this is used in rehashing -- don't optimize the case 	where the receiver doesn't change in size."	self accessLock		critical: 			[| newSelf |			newSelf := self copyEmpty: newCapacity.			newSelf accessLock: self accessLock.			1 to: keys size				do: 					[:index | 					| key val |					key := keys at: index.					(key isNil or: [key = 0 or: [(val := values at: index) = 0]])						ifFalse: [newSelf privateAt: key put: val]].			self release.			newSelf release.			self become: newSelf.			self makeDependent]</body><body package="DST_Core">grow	"The receiver becomes roomier."	"Reclaim elements to get an accurate 'tally' before the grow."	| needRehash |	needRehash := self reclaimElements.	self tally / self capacity &gt; self growBound		ifTrue: [ self privateGrow ]		ifFalse: [ needRehash ifTrue: [ self changeCapacityTo: self capacity ] ]</body><body package="DST_Core">privateAt: key put: anObject 	"Set the value at key to be anObject. If key is not found, create a new 	entry for key and set is value to anObject. Answer anObject."	| index element |	index := self findKeyOrNil: key.	element := values at: index.	element == nil ifTrue: [tally := tally + 1].	keys at: index put: key.	values at: index put: anObject.	^anObject</body><body package="DST_Core">privateGrow	"The receiver becomes roomier."	"To prevent collapsing down to zero the capacity	should have a delta above the multiplied size.  41	is a arbitrary number designed to (hopefully more	frequently then a round number) be prime when	added to the multiplied size.  5 is picked as the	multiplier also rather arbitrarily, hopefully it is big	enough that grows won't happen too often, while	not making the dictionary too big."	"self changeCapacityTo: (41 + (tally * 5))"	self changeCapacityTo: (self minimumSize max: (self capacity * self growRatio) floor )</body><body package="DST_Core">privateShrink	self shrinkRatio ifNotNil: [		self changeCapacityTo: (			self minimumSize max: (self capacity / self shrinkRatio) floor ) ]</body><body package="DST_Core">reclaimElements	| deathMarker size needRehash |	size := keys size.	deathMarker := 1.	needRehash := false.	[deathMarker ~= 0] whileTrue: [		deathMarker := keys indexOf: 0 replaceWith: nil startingAt: deathMarker stoppingAt: size.		deathMarker = 0 ifFalse: [			tally := tally - 1.			values at: deathMarker put: nil.			"Minor optimization, if there's a nil behind me, then I cannot be in the middle of a 'same hash value' chain and we don't need an expensive rehash."			needRehash := needRehash or: [ (keys at: deathMarker \\ size + 1) notNil ] ] ].	^needRehash</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>fileIn/Out</category><body package="DST_Core">representBinaryOn: binWriter	" Represent a Dictionary by its elements	(Associations). "	^MessageSend		receiver: self class		selector: #withAll:		argument: self associations asArray</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>adding</category><body package="DST_Core">add: anAssociation 	"Include anAssociation as one of the receiver's elements. Answer 	anAssociation."	self at: anAssociation key put: anAssociation value.	^anAssociation</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>updating</category><body package="DST_Core">update: anAspectSymbol with: aParameter from: aSender 	"Finalize all finalizable entries of aSender."	(aSender == keys and: [anAspectSymbol = #ElementExpired])		ifTrue: [self finalizeElements]		ifFalse: [^self]</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>accessing - growth parameters</category><body package="DST_Core">growBound	^growBound ifNil: [ self class defaultGrowBound ]</body><body package="DST_Core">growBound: aFloat"	aFloat &lt;Float&gt; the tally/capacity at which we should grow"	| new |	new := aFloat			ifNil: [ self class defaultGrowBound ]			ifNotNil: [ self checkBound: aFloat. aFloat ].	self shrinkBound ifNotNil: [ :shrink || minimum |		minimum := self growRatio * shrink.		new &gt; minimum			ifFalse: [ Warning					raiseWith: (Array with: minimum)					errorPattern: 'Grow bound must be at least &lt;1p&gt;' ] ].	growBound := aFloat</body><body package="DST_Core">growRatio	^growRatio ifNil: [ self class defaultGrowRatio ]</body><body package="DST_Core">growRatio: aNumber"	aNumber &lt;Number&gt; the ratio by which to grow when grow bound is reached (capacity' := capacity * growRatio)"	| new |	new := aNumber ifNil: [ self class defaultGrowRatio ].	self checkRatio: new.	growRatio := aNumber</body><body package="DST_Core">minimumSize	^minimumSize ifNil: [41]</body><body package="DST_Core">minimumSize: anInteger"	anInteger &lt;Integer&gt; never shrink below this size (initialized to the original #new: paramater)"	minimumSize := anInteger</body><body package="DST_Core">shrinkBound"To allow disabling shrinking, the default is only applied during instance creation. If it is subsequently nilled out then shrinking is disabled."	^shrinkBound</body><body package="DST_Core">shrinkBound: aFloat"	aFloat &lt;Float&gt; the tally/capacity at which we should shrink"	| maximum |	aFloat ifNil: [ shrinkBound := nil. ^self ].	self checkBound: aFloat.	maximum := self growBound / self shrinkRatio.	aFloat &lt; maximum		ifFalse: [ Warning				raiseWith: (Array with: maximum)				errorPattern: 'Shrink bound must be at most &lt;1p&gt;' ].	shrinkBound := aFloat</body><body package="DST_Core">shrinkRatio	^shrinkRatio ifNil: [ self class defaultShrinkRatio ]</body><body package="DST_Core">shrinkRatio: aNumber"	aNumber &lt;Number&gt; the ratio by which to shrink when shrink bound is reached (capacity' := capacity / shrinkRatio)"	| new |	new := aNumber ifNil: [ self class defaultShrinkRatio ].	self checkRatio: new.	shrinkRatio := aNumber</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>finalization</category><body package="DST_Core">finalizeElements	"Reclaim the slots containing dead objects."	self accessLock critical: [		keys isNil ifFalse: [ | needRehash |			needRehash := self reclaimElements.			(self shrinkBound notNil and: [ self tally / self capacity &lt; self shrinkBound ])				ifTrue: [ self privateShrink ]				ifFalse: [ needRehash ifTrue: [ self changeCapacityTo: self capacity ] ] ] ]</body></methods><methods><class-id>DST.WeakKeyDictionary</class-id> <category>testing</category><body package="DST_Core">includesKey: key 	"Answer whether the receiver has a key equal to the argument, key."	^self accessLock		critical: 			[| index elem |			index := self findKeyOrNil: key.			(elem := values at: index) notNil and: [elem ~= 0]]</body></methods><methods><class-id>DST.WeakKeyDictionary class</class-id> <category>instance creation</category><body package="DST_Core">new	^self new: 100</body><body package="DST_Core">new: aSize 	^super new initSize: (Dictionary goodSizeFrom: aSize)</body></methods><methods><class-id>DST.WeakKeyDictionary class</class-id> <category>accessing - growth parameters</category><body package="DST_Core">defaultGrowBound	^defaultGrowBound ifNil: [ self defaultGrowBoundValue ]</body><body package="DST_Core">defaultGrowBound: aFloat"	aFloat &lt;Float&gt; the tally/capacity at which we should grow"	defaultGrowBound := aFloat</body><body package="DST_Core">defaultGrowBoundValue	^0.6</body><body package="DST_Core">defaultGrowRatio	^defaultGrowRatio ifNil: [ self defaultGrowRatioValue ]</body><body package="DST_Core">defaultGrowRatio: aNumber"	aNumber &lt;Number&gt; the ratio by which to grow when grow bound is reached (capacity' := capacity * growRatio)"	defaultGrowRatio := aNumber</body><body package="DST_Core">defaultGrowRatioValue	^2</body><body package="DST_Core">defaultShrinkBound	^defaultShrinkBound ifNil: [ self defaultShrinkBoundValue ]</body><body package="DST_Core">defaultShrinkBound: aFloat"	aFloat &lt;Float&gt; the tally/capacity at which we should shrink"	defaultShrinkBound := aFloat</body><body package="DST_Core">defaultShrinkBoundValue	^0.1</body><body package="DST_Core">defaultShrinkRatio		^defaultShrinkRatio ifNil: [ self defaultShrinkRatioValue ]</body><body package="DST_Core">defaultShrinkRatio: aNumber"	aNumber &lt;Number&gt; the ratio by which to shrink when shrink bound is reached (capacity' := capacity / shrinkRatio)"	defaultShrinkRatio := aNumber</body><body package="DST_Core">defaultShrinkRatioValue		^3</body></methods><methods><class-id>DST.WeakValueDictionary</class-id> <category>updating</category><body package="DST_Core">update: anAspectSymbol with: aParameter from: aSender 	"Finalize all finalizable entries of aSender."	(aSender == values and: [anAspectSymbol = #ElementExpired])		ifTrue: [self finalizeElements]		ifFalse: [^self]</body></methods><methods><class-id>DST.WeakValueDictionary</class-id> <category>private</category><body package="DST_Core">findKeyOrNil: key 	"Look for the key in the receiver. If it is found, answer 	the index of the association containing the key, otherwise 	answer the index of the first unused slot."	| location length probe pass |	length := keys size.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.		[probe := keys at: location.	(values at: location) = 0		ifTrue: 			[keys at: location put: 0.			probe := 0].	probe == nil or: [probe = key]]		whileFalse: [(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body></methods><methods><class-id>DST.WeakValueDictionary</class-id> <category>initialize-release</category><body package="DST_Core">initSize: aSize 	keys := Array new: aSize.	values := WeakArray new: aSize.	tally := 0.	shrinkBound := self class defaultShrinkBound.	self makeDependent</body><body package="DST_Core">makeDependent	values addDependent: self.</body></methods><methods><class-id>DST.WeakValueDictionary</class-id> <category>private-reclaim/grow</category><body package="DST_Core">reclaimElements	| deathMarker size needRehash |	size := values basicSize.	deathMarker := 1.	needRehash := false.	[ deathMarker ~= 0 ] whileTrue: [		deathMarker := values indexOf: 0 replaceWith: nil startingAt: deathMarker stoppingAt: size.		deathMarker = 0 ifFalse: [			keys at: deathMarker put: nil.			tally := tally - 1.			"Minor optimization, if there's an element behind me, then I might be in the middle of a 'same hash value' chain and we'll need to rehash."			needRehash := needRehash or: [ (keys at: deathMarker \\ size + 1) notNil ] ] ].	^needRehash</body></methods><methods><class-id>DST.DSTObjRefInactive</class-id> <category>StorageModel</category><body package="DST_Core">destroy	"&lt;nil&gt; Remove the receiver from the CORBA registry."	objectCache notNil		ifTrue: [			objectCache destroy].	^self class unRegisterObject: self.</body><body package="DST_Core">remove	"&lt;nil&gt; Remove the receiver from the CORBA registry."	objectCache notNil		ifTrue: 			[objectCache remove.			self flushCache].	^self class unRegisterObject: self</body><body package="DST_Core">updateAndRemove	"&lt;nil&gt; Remove the receiver from the CORBA registry."	objectCache notNil		ifTrue: 			[objectCache updateAndRemove.			self flushCache].	^self class unRegisterObject: self</body></methods><methods><class-id>DST.DSTObjRefInactive</class-id> <category>accessing</category><body package="DST_Core">activator: aBlock	"set the activator"	activator := aBlock</body><body package="DST_Core">databaseId	^databaseId</body><body package="DST_Core">flushCache 	objectCache := nil</body><body package="DST_Core">incrementUseTimer	^useTimer := useTimer + 1</body><body package="DST_Core">isFlushed	"return if cache is flushed"	^objectCache isNil</body><body package="DST_Core">isLocal	"Inactive ObjRefs denote local objects"	^true</body><body package="DST_Core">isRemote	"Inactive ObjRefs denote local objects"	^false</body><body package="DST_Core">objectId: anId interfaceId: anId2 	"initialize the objectId and interfaceId instance variables"	super objectId: anId interfaceId: anId2 .	databaseId := anId printString.	activator := self class activatorBlock</body><body package="DST_Core">objectId: oid interfaceId: mdi activator: aBlock databaseId: aDatabaseId object: anObject	"initialize the objectId and interfaceId instance variables"	objectId := oid.	interfaceId := mdi.	activator := aBlock.	databaseId := aDatabaseId.	useTimer := 0.	objectCache := anObject.	weakCache := WeakArray with: anObject</body><body package="DST_Core">useTimer	^useTimer</body></methods><methods><class-id>DST.DSTObjRefInactive</class-id> <category>message handlers</category><body package="DST_Core">perform: opSelector on: parameters 	"invoke the operation on the local object and return"	| obj  |	obj := self  reActivate.	^obj perform: opSelector withArguments: parameters</body></methods><methods><class-id>DST.DSTObjRefInactive</class-id> <category>persistence</category><body package="DST_Core">reActivate	"reactivate the object from its activator"	| w |	useTimer := 0.	objectCache notNil ifTrue: [^objectCache].	(weakCache notNil and: [(w := weakCache at: 1) notNil &amp; (w ~= 0)])		ifTrue: [objectCache := w].	objectCache := activator value: self databaseId.	^objectCache isNil | (objectCache == self)		ifTrue: 			[Dialog onDebugNotify: 'Inactive Object for "' , objectId printString , '" does not exist'.			ORBObject invObjrefError: 0]		ifFalse: [objectCache]</body><body package="DST_Core">representBinaryOn: binWriter 	"Represent an ORBPersistentObjRef by a constructor which will 	rebuild either an objref or the object itself"	^MessageSend		receiver: self class		selector: #findOrCreateOnArray:		argument: (Array				with: interfaceId				with: self adapterId				with: self interoperableObjRefProfiles				with: self databaseId				with: self reActivate class name)</body></methods><methods><class-id>DST.DSTObjRefInactive</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print a representation of the receiver on the stream"	aStream nextPutAll: 'an Inactive ' , self interface printName</body></methods><methods><class-id>DST.DSTObjRefInactive class</class-id> <category>creation-registration</category><body package="DST_Core">activatorBlock	"return the block which will reactivate the object from the database"	^[:aDatabaseId | DSTObjRefInactive objectOf: aDatabaseId]</body><body package="DST_Core">findOrCreateOn: anObject 	"return either a unique object reference to the object or the object 	itself if it is active"	| dbId ior orbId |	dbId := anObject databaseIdentifier.	ior := self indexOf: dbId.	^ior		ifNil: 			[orbId := ORBObject newId.			ior := self new						objectId: orbId						interfaceId: anObject CORBAType repositoryId						activator: anObject class activatorBlock						databaseId: dbId						object: anObject.			self indexObject: ior as: dbId.			self indexObject: ior as: orbId]</body><body package="DST_Core">findOrCreateOnArray: anArray 	"If the object is already registered, return that object, else return the 	appropriate kind of objref"	| if ad dbId cls tps |	if := anArray at: 1.	ad := anArray at: 2.	tps := anArray at: 3.	dbId := anArray at: 4.	cls := anArray at: 5.	^(ORBDaemon isLocalAdapter: ad)		ifTrue: [self findOrCreateOnId: dbId andClass: cls]		ifFalse: [DSTObjRefRemote findOrCreateOnProfiles: tps MDI: if]</body><body package="DST_Core">findOrCreateOnId: aDatabaseId andClass: aClassSymbol 	"return either a unique object reference to the object or the object 	itself if it is active"	| obj ior orbId key |	key := aDatabaseId asSymbol.	obj := self indexOf: key.	^obj		ifNil: 			[| aClass |			aClass := aClassSymbol asQualifiedReference value.			orbId := ORBObject newId.			ior := self new						objectId: orbId						interfaceId: aClass basicNew CORBAType repositoryId						activator: aClass activatorBlock						databaseId: aDatabaseId						object: nil.			self indexObject: ior as: key.			self indexObject: ior as: orbId.			ior]</body><body package="DST_Core">findOrCreateOnOID: anObjectId AID: anAdapterId MDI: anInterfaceId activator: aBlock 	"find or create a new object reference"	| obj |	obj := super				findOrCreateOnOID: anObjectId				AID: anAdapterId				MDI: anInterfaceId.	obj class == self ifTrue: [obj activator: aBlock].	^obj</body><body package="DST_Core">index	"Answer the value of index."	^Index</body></methods><methods><class-id>DST.DSTObjRefInactive class</class-id> <category>daemon</category><body package="DST_Core">flushCacheTimeout 	"the number of 1 minute intervals to wait before flushing the object cache"	^CacheTimeout ifNil: [CacheTimeout := 2]</body><body package="DST_Core">flushObjRefTimeout 	"the number of 1 minute intervals to wait before flushing the object reference"	^ObjRefTimeout ifNil: [ObjRefTimeout := 60]</body><body package="DST_Core">timerDaemon	"return a block which will run concurrent with the ORB to control 	inactive object lifetimes"	^[]"	[| t i |	i := 0.	[ORBObject running]		whileTrue: 			[(Delay forSeconds: 6) wait.			(i := i + 1 \\ 10) = 0 ifTrue: [self index values					do: 						[:ori | 						t := ori incrementUseTimer.						ori isFlushed ifFalse: [t &gt; self flushCacheTimeout ifTrue: [ori flushCache]].						t &gt; self flushObjRefTimeout ifTrue: [self unRegisterObject: ori]]]].	Transcript show: 'ObjRef timer stopped'; cr]"</body></methods><methods><class-id>DST.DSTObjRefInactive class</class-id> <category>initialization</category><body package="DST_Core">flushIndex	"flush the class index"	"self flushIndex"	Index := self indexClass new: 2011</body><body package="DST_Core">initialize	"initialize the class variables"	"self initialize"	self flushIndex.	CacheTimeout := ObjRefTimeout := nil</body><body package="DST_Core">release	"release the instances stored in the class variables"	Index := CacheTimeout := ObjRefTimeout := nil</body></methods><methods><class-id>DST.DSTObjRefInactive class</class-id> <category>StorageModelFactory</category><body package="DST_Core">unRegisterObject: anObject 	"unregister the object from the storage server and from the local orb"	(self index) removeKey: anObject databaseId asSymbol ifAbsent: []; removeKey: anObject objectId ifAbsent: [].	super unRegisterObject: anObject</body></methods><methods><class-id>DST.DSTInterceptorCollection</class-id> <category>initialize-release</category><body package="DST_Core">construct	^(DSTInterceptorCollection new: self size) 		addAllWithoutSorting: 			( self collect: [:anInterceptorClass | anInterceptorClass construct ] );		yourself</body><body package="DST_Core">initialize	"Set the initial value of the receiver's sorting algorithm to a default."	sortBlock := [ :x :y | x orderOfExecution &lt;= y orderOfExecution ]</body></methods><methods><class-id>DST.DSTInterceptorCollection</class-id> <category>message intercepting</category><body package="DST_Core">postReceiveMessage: aRequest context: anORBContext target: anObjRef reply: aReply	^self do: [ :each | each postReceiveMessage: aRequest context: anORBContext target: anObjRef reply: aReply]</body><body package="DST_Core">postSendMessage: aRequest context: anORBContext target: aReceiver reply: aReply	^self do: [ :each |		each			postSendMessage: aRequest			context: anORBContext			target: aReceiver			reply: aReply ]</body><body package="DST_Core">preReceiveMessage: aRequest context: anORBContext target: aReceiver	^self do: [ :each | each 						preReceiveMessage: aRequest 						context: anORBContext 						target: aReceiver ]</body><body package="DST_Core">preSendMessage: aRequest context: anORBContext target: aReceiver	^self do: [ :each | each 						preSendMessage: aRequest 						context: anORBContext 						target: aReceiver ]</body></methods><methods><class-id>DST.DSTInterceptorCollection</class-id> <category>request intercepting</category><body package="DST_Core">clientInvokePostSend: aRequest context: anORBContext target: anObjRef operation: anOperation result: anObject	^self do: [ :each |		each			clientInvokePostSend: aRequest			context: anORBContext			target: anObjRef			operation: anOperation			result: anObject ]</body><body package="DST_Core">clientInvokePreSend: aRequest context: anORBContext target: anObjRef operation: anOperation parameters: someParams	^self do: [ :each | each 						clientInvokePreSend: aRequest 						context: anORBContext 						target: anObjRef 						operation: anOperation 						parameters: someParams ]</body><body package="DST_Core">targetInvokePostReceive: aRequest context: anORBContext target: anObjRef result: aResult	^self do: [ :each | each targetInvokePostReceive: aRequest context: anORBContext target: anObjRef result: aResult]</body><body package="DST_Core">targetInvokePreReceive: aRequest context: anORBContext target: aReceiver parameters: someParams	^self do: [ :each | each 						targetInvokePreReceive: aRequest 						context: anORBContext 						target: aReceiver 						parameters: someParams ]</body></methods><methods><class-id>DST.DSTVersionPragma</class-id> <category>accessing</category><body package="DST_Core">version	^version</body><body package="DST_Core">version: aVersion 	version := aVersion</body></methods><methods><class-id>DST.DSTVersionPragma</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma version ' , name , ' ' , version</body></methods><methods><class-id>DST.DSTVersionPragma</class-id> <category>actions</category><body package="DST_Core">applyTo: aMetaObject 	"set the version for the meta object from the pragma."	| msg id |	(aMetaObject canApplyPragma: #VERSION)		ifTrue: 			[aMetaObject setVersion: self version.			(id := aMetaObject repositoryId) isNil ifFalse: [id formatName == #IDL					ifTrue: 						[aMetaObject repositoryId: nil.						aMetaObject id]]]		ifFalse: 			[msg := 'Version pragma not allowed on ' , aMetaObject displayString.			ORBDaemon configurationManager log: msg withCRs.			Dialog notify: msg]</body></methods><methods><class-id>DST.DSTtypeString</class-id> <category>StringDef</category><body package="DST_Core">bound	"The bound attribute specifies the maximum number of characters in 	the string, and must not be zero."	^size</body><body package="DST_Core">bound: newSize 	"The bound attribute specifies the maximum number of characters in 	the string, and must not be zero."	self notYetImplemented</body></methods><methods><class-id>DST.DSTtypeString</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"		(size == nil or: [size = 0 or: [ aParameter size &lt;= size]])		ifFalse: [^self class marshallError: 0].	aStream nextPutString: aParameter</body><body package="DST_Core">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	self boldMarshall: aParameter on: aStream</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		aParameter == nil ifTrue: [^#mappable].	^(aParameter isCharacterArray)		and: [size == nil or: [size = 0 or: [ aParameter size &lt;= size]]]</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	aStream nextPutUnsignedLong: self typeCode; nextPutUnsignedLong: (size == nil ifTrue: [0] ifFalse: [size])</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result |	result := aStream nextString.	aClass notNil ifTrue: [^aClass fromString: result].	^result</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream	"marshall the type code of the receiver"	size := aStream nextUnsignedLong</body></methods><methods><class-id>DST.DSTtypeString</class-id> <category>printing</category><body package="DST_Core">definitionString	"return my CDL type definition string"	^size isNil		ifTrue: ['string']		ifFalse: ['string&lt;' , size printString , '&gt;']</body></methods><methods><class-id>DST.DSTtypeString</class-id> <category>rendering</category><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^declarators notNil</body></methods><methods><class-id>DST.DSTtypeString</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'string'</body><body package="DST_Core">maxSize: anint	"initialize the receiver with the max size"	size := anint.	name := 'string'.	subtype := DSTtypeCharacter new</body></methods><methods><class-id>DST.DSTtypeString</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CompoundDefs::PrimitiveCompoundDef'</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_String</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_string</body><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^1</body><body package="DST_Core">typeParameter: anInt	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	anInt = 1 ifTrue: [^size isNil ifTrue: [0] ifFalse: [size]].	self error: #Bounds</body></methods><methods><class-id>DST.DSTtypeString</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_string</body></methods><methods><class-id>DST.DSTtypeWideString</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_wstring</body></methods><methods><class-id>DST.DSTtypeWideString</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = nextPutWideString raises exception"	(self marshallMatch: aParameter) == false		ifTrue: [^self class marshallError: 0].	aStream nextPutWideString:  aParameter."  asTwoByteString."</body><body package="DST_Core">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	(self marshallMatch: aParameter) == false		ifTrue: [^self class marshallError: 0].	aStream nextPutWideString: aParameter. "asTwoByteString."</body><body package="DST_Core">marshallMatch: aParameter 	"Return: 	true			- if I can marshall the parameter 	false		- if I can NOT marshall the parameter 	#mappable	- if I can marshall the parameter by mapping to 	something else"	aParameter == nil ifTrue: [^#mappable].	^(aParameter isTwoByteArray or: [aParameter isCharacterArray])		and: [size == nil or: [size = 0 or: [aParameter size &lt;= size]]]</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result |	result := aStream nextWideString.	aClass notNil ifTrue: [^aClass fromString: result].	^result</body></methods><methods><class-id>DST.DSTtypeWideString</class-id> <category>printing</category><body package="DST_Core">definitionString	"return my CDL type definition string"	^size isNil		ifTrue: ['wstring']		ifFalse: ['wstring&lt;' , size printString , '&gt;']</body></methods><methods><class-id>DST.DSTtypeWideString</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'wstring'</body><body package="DST_Core">maxSize: anint	"initialize the receiver with the max size"	size := anint.	name := 'wstring'.	subtype := DSTtypeWideCharacter new</body></methods><methods><class-id>DST.DSTtypeWideString</class-id> <category>repository</category><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Wstring</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_wstring</body></methods><methods><class-id>DST.DSTpseudoTypeCode</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the aParameter's typecode onto the stream"	"canMarshall not = MNU on 'aParameter typeCode'"	| strm |	(self isComplexTypeCode: aParameter typeCode)		ifTrue: 			[strm := CDRStream on: (ByteArray new: 100).			aParameter marshallTypeCode: Dictionary new on: strm.			aStream padToLong.			aStream nextPutAll: strm contents]		ifFalse: [aParameter marshallTypeCode: Dictionary new on: aStream]</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter respondsTo: #typeKind</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receive"	aStream nextPutUnsignedLong: self typeCode</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| type tk ba strm byteOrder |	tk := aStream nextUnsignedLong.	(self isComplexTypeCode: tk)		ifTrue: 			[ba := self class typeCodeStreamDef unMarshall: aStream.			strm := (CDRStream on: (ByteArray new: ba size + 4)) reset.			strm nextPutUnsignedLong: ba size.			strm nextPutAll: ba.			strm reset]		ifFalse: 			[strm := aStream.			byteOrder := nil].	type := DSTMetaObject				unMarshallTypeCode: Dictionary new				from: strm				typeKind: tk.	byteOrder notNil ifTrue: [aStream byteOrder: byteOrder].	type definedIn: self definingMetaContainer.	^type</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall the type code of the receiver - do nothing since the 	TCKind has already been unmarshalled and TypeCodes have no 	TypeCode parameters"	^self</body></methods><methods><class-id>DST.DSTpseudoTypeCode</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_TypeCode</body></methods><methods><class-id>DST.DSTpseudoTypeCode</class-id> <category>printing</category><body package="DST_Core">IDLTypeName	"return the printable name of the receiver's IDL type"	^'TypeCode'</body><body package="DST_Core">definitionString	"return my unformatted IDL definition string"	^'TypeCode'</body></methods><methods><class-id>DST.DSTpseudoTypeCode</class-id> <category>testing</category><body package="DST_Core">isComplexTypeCode: anInteger        ^anInteger &gt; 13 and: [anInteger ~= 18]</body></methods><methods><class-id>DST.DSTpseudoTypeCode</class-id> <category>TypeCode</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_TypeCode</body></methods><methods><class-id>DST.DSTpseudoTypeCode</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::PrimitiveDef'</body></methods><methods><class-id>DST.DSTpseudoTypeCode class</class-id> <category>private</category><body package="DST_Core">typeCodeStreamDef        "answer the type code stream definition"        ^TCStreamDef ifNil: [TCStreamDef := (DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray]</body></methods><methods><class-id>DST.DSTsignature</class-id> <category>accessing</category><body package="DST_Core">inParameters	"returns the parameters which are #in or #inout"	^ins ifNil: [ins := self select: [:p | p notOUT]]</body><body package="DST_Core">nonTrivialSignature	"returns a copy of the receiver that does not include a void result. I.e. only 	meaningful results are included"	| c |	c := self copy.	c isEmpty ifTrue: [^c].	^c returnParameter isVoid		ifTrue: [c removeLast; yourself]		ifFalse: [c]</body><body package="DST_Core">outParameters	"returns the parameters which are #out or #inout"	^outs		ifNil: 			[outs := self select: [:p | p notIN].			outs removeLast.			outs]</body><body package="DST_Core">parameters	"return a signature without the result"	^params		ifNil: 			[params := self copy.			params isEmpty ifFalse: [params removeLast].			params]</body><body package="DST_Core">returnParameter	"returns the return parameter of the signature, or nil if none"	^return ifNil: [return := self last]</body></methods><methods><class-id>DST.DSTsignature</class-id> <category>printing</category><body package="DST_Core">definitionString	"return a definition string for the parameters of the receiver"	| aStream |	self size = 1 ifTrue: [^''].	aStream := (String new: 80) writeStream.	aStream nextPutAll: self first definitionString.	2 to: self size - 1 do: [:i | aStream nextPutAll: ', '; nextPutAll: (self at: i) definitionString].	^aStream contents</body></methods><methods><class-id>DST.DSTAccessPragma</class-id> <category>accessing</category><body package="DST_Core">accessRights	^accessRights</body><body package="DST_Core">accessRights: someAccess 	accessRights := someAccess</body></methods><methods><class-id>DST.DSTAccessPragma</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma access ' , name , ' ' , accessRights</body></methods><methods><class-id>DST.DSTAccessPragma</class-id> <category>actions</category><body package="DST_Core">applyTo: aMetaObject 	"Set the access rights for an operation from the specified pragma."	| msg |	(aMetaObject canApplyPragma: #ACCESS)		ifTrue: [aMetaObject accessRight: self accessRights]		ifFalse: 			[msg := 'Access pragma not allowed on ' , aMetaObject displayString.			ORBDaemon configurationManager log: msg withCRs.			Dialog notify: msg]</body></methods><methods><class-id>DST.DSTtypeFloat</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_float</body></methods><methods><class-id>DST.DSTtypeFloat</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall = MNU on asFloat"	aStream nextPutFloat: aParameter asFloat</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^aParameter isKindOf: Number</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class"	^aStream nextFloat</body></methods><methods><class-id>DST.DSTtypeFloat</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'float'</body></methods><methods><class-id>DST.DSTtypeFloat</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_float</body></methods><methods><class-id>DST.DSTparameterDescription</class-id> <category>accessing</category><body package="DST_Core">mode	^mode</body><body package="DST_Core">mode: aValue	mode := aValue</body><body package="DST_Core">name	^name</body><body package="DST_Core">name: aValue	name := aValue</body><body package="DST_Core">type	^type</body><body package="DST_Core">type: aValue	type := aValue</body><body package="DST_Core">typeDef	^typeDef</body><body package="DST_Core">typeDef: aValue	typeDef := aValue</body></methods><methods><class-id>DST.DSTparameterDescription</class-id> <category>repository</category><body package="DST_Core">CORBAType	^ORBObject lookupMetaId: #'::CORBA::ParameterDescription'</body></methods><methods><class-id>DST.DSTconstant</class-id> <category>ConstantDef</category><body package="DST_Core">description	"return a constant description"	^(Dictionary new)		add: #name -&gt; name;		add: #id -&gt; self id;		add: #definedIn -&gt; self definedInString;		add: #version -&gt; self version;		add: #type -&gt; self;		add: #value -&gt; self value;		yourself</body><body package="DST_Core">type	"return the typeSpec of the receiver"	^typeSpec</body><body package="DST_Core">typeDef	"The typeDef attribute identifies the definition of the type of the 	constant."	^typeSpec</body><body package="DST_Core">typeDef: newIDLType 	"The typeDef attribute identifies the definition of the type of the 	constant."	self notYetImplemented</body><body package="DST_Core">value	"The value attribute contains the value of the constant, not the computation of the value."	^value ifNil: [value := valueExpr value]</body><body package="DST_Core">value: newValue 	"The value attribute contains the value of the constant, not the 	computation of the value."	self notYetImplemented</body></methods><methods><class-id>DST.DSTconstant</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^(typeSpec nonTrivialDeclarators asOrderedCollection) add: (DSTvalue on: valueExpr asIDLString); yourself</body></methods><methods><class-id>DST.DSTconstant</class-id> <category>initialization</category><body package="DST_Core">t: aType  i: ident  v: aValue	"initialize the receiver"	typeSpec := aType.	name := ident.	valueExpr := aValue.</body></methods><methods><class-id>DST.DSTconstant</class-id> <category>printing</category><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver on the stream"	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level; nextPutAll: 'const '; nextPutAll: typeSpec definitionString; nextPut: $ ; nextPutAll: name; nextPut: $ ; nextPutAll: '= '.	(valueExpr isString)		ifTrue: [aStream nextPut: $"; nextPutAll: valueExpr; nextPut: $"]		ifFalse: [aStream nextPutAll: valueExpr asIDLString].	aStream nextPut: $;; cr</body><body package="DST_Core">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'const ' , self idlName</body></methods><methods><class-id>DST.DSTconstant</class-id> <category>accessing</category><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	typeSpec definedIn: aMetaObject.	(valueExpr respondsTo: #definedIn:) ifTrue: [valueExpr definedIn: aMetaObject]</body></methods><methods><class-id>DST.DSTconstant</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::ConstantDef'</body><body package="DST_Core">allMetaObjectsInto: aSet 	"add all of the referenced metaobjects to the set"	super allMetaObjectsInto: aSet.	typeSpec allMetaObjectsInto: aSet.	(valueExpr respondsTo: #allMetaObjectsInto:) ifTrue: [valueExpr allMetaObjectsInto: aSet]</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Constant</body><body package="DST_Core">resolveTypeReference	"implemented by DSTtypeNamed &amp;  DSTconstant. Others 	should noop"	self value</body></methods><methods><class-id>DST.DSTattributeDescription</class-id> <category>accessing</category><body package="DST_Core">definedIn	^definedIn</body><body package="DST_Core">definedIn: aValue	definedIn := aValue</body><body package="DST_Core">id	^id</body><body package="DST_Core">id: aValue	id := aValue</body><body package="DST_Core">mode	^mode</body><body package="DST_Core">mode: aValue	mode := aValue</body><body package="DST_Core">name	^name</body><body package="DST_Core">name: aValue	name := aValue</body><body package="DST_Core">type	^type</body><body package="DST_Core">type: aValue	type := aValue</body><body package="DST_Core">version	^version</body><body package="DST_Core">version: aValue	version := aValue</body></methods><methods><class-id>DST.DSTattributeDescription</class-id> <category>repository</category><body package="DST_Core">CORBAType	^ORBObject lookupMetaId: #'::CORBA::AttributeDescription'</body></methods><methods><class-id>DST.IIOPClientConversation</class-id> <category>accessing</category><body package="DST_Core">needsResponse	^operation isOneWay not</body><body package="DST_Core">opSelector	"return the opSelector string"	^opSelector value</body><body package="DST_Core">role	"answer the role description"	^'client'</body><body package="DST_Core">semaphoreIsEmpty	^semaphore isEmpty</body><body package="DST_Core">target	^target</body><body package="DST_Core">targetId	^target adapterId</body></methods><methods><class-id>DST.IIOPClientConversation</class-id> <category>private</category><body package="DST_Core">cancel	"cancel this conversation"	self signalSemaphore</body></methods><methods><class-id>DST.IIOPClientConversation</class-id> <category>requests</category><body package="DST_Core">clientCall: opInfo to: objref withRequest: aRequest withArgs: argArray 	"This method is called to initiate a remote procedure call.  Now, when 	an RPC times out, a CORBA noResponseError is raised instead of a 	CommunicationError.  This allows the user to trap the error and retry.	In 5i, interceptors have been spliced in."	| orbCxt msgIntercept timeout |	state := #init.	args := argArray.	operation := opInfo operation.	opSelector := [ opInfo traceString ].	request := aRequest.	target := objref.	requestId := aRequest requestId.	"Interceptor Hook for 'requestPostMarshall'."	orbCxt := Processor activeProcess orbContext.	( msgIntercept := self messageInterceptors ) isNil 		ifFalse:	[ 	msgIntercept 						preSendMessage: aRequest 						context: orbCxt 						target: target				].	( ActiveDaemon sendRequest: self )		ifTrue:	[	operation isOneWay						ifTrue:	[ state := #done. ^nil ].					( Infinity positive  ~~ ( timeout := self class messageTimeout ) )						ifTrue:	[ self replyWaitWithTimeoutMs: timeout * 1000 ]						ifFalse:	[ self replyWait ].				]		ifFalse:	[	operation isOneWay						ifTrue:	[ state := #done. ^nil ]				].	state := #done.	^reply isNil		ifTrue:	[	ORBObject commFailureError: 0				]		ifFalse:	[	"Interceptor Hook for 'replyPreUnMarshall'."					msgIntercept isNil 						ifFalse: [ msgIntercept postSendMessage: request context: orbCxt target: target reply: reply ].					self unMarshallReply.					reply serviceContextList isEmpty						ifFalse:	[	orbCxt := Processor activeProcess orbContext.									reply serviceContextList do: [:cxt | orbCxt addServiceContext: cxt]								].					reply replyStatusNoException						ifTrue:	[ result ]						ifFalse:	[ reply replyStatusLocationForward									ifTrue:	[ result perform: operation localOp withArguments: args ]									ifFalse:	[ (result at: 1) corbaRaiseWith: (result at: 2) ]								]				]</body><body package="DST_Core">signalSemaphore	"signal the client conversation that a message has been received"	semaphore ifNotNil: [ semaphore signal ]</body><body package="DST_Core">unMarshallReply	"unmarshall the reply, this will either be a reply message or a locate 	reply message"	| mo param str reposId | 	reply isLocateReply		ifTrue: 			[reposId := DSTinterface new repositoryId: (RepositoryId fromString: 'IDL:CORBA/Object:1.0').			reply replyStatusObjectForward ifTrue: [result := reply messageStream nextObjectReference: reposId]]		ifFalse: 			[state := #replied.			operation isOneWay ifFalse: [reply replyStatusNoException					ifTrue: [result := operation unMarshallResultsFrom: reply messageStream withArgs: args]					ifFalse: [reply replyStatusLocationForward							ifTrue: [result := reply messageStream nextObjectReference: target interface]							ifFalse: [reply replyStatusException									ifTrue: 										[str := reply messageStream nextString.										mo := ORBObject lookupMetaId: (RepositoryId fromString: str).										mo isNil											ifTrue: [ORBObject marshallError: 0]											ifFalse: 												[param := mo errorType unMarshall: reply messageStream.												result := Array with: mo errorSignal with: param]]									ifFalse: [self error: 'unknown reply type']]]]]</body></methods><methods><class-id>DST.IIOPClientConversation</class-id> <category>delay management</category><body package="DST_Core">replyWait	semaphore := Semaphore new.	state := #wait.		semaphore wait.</body><body package="DST_Core">replyWaitWithTimeoutMs: milliseconds	| delay |	delay := Delay forSeconds: self class messageTimeout.	semaphore := delay delaySemaphore.	state := #wait.	delay startup.		semaphore wait.	delay inProgress		ifFalse:	[	self connection notNil						ifTrue: [ self connection unRegisterConversation: self ].					Transcript show: 'IIOP message timeout expired'; cr.					ORBObject noResponseError: 0				].	delay disable</body></methods><methods><class-id>DST.IIOPClientConversation class</class-id> <category>creation</category><body package="DST_Core">clientCall: opInfo to: objRef withParameters: parameters 	"Perform a remote method call on the given object with the given 	operation information. Do not let the user interface process get 	blocked."	"NOTA BENE: Changes to this method may affect the validity	of either			DSToperation&gt;&gt;callingContext	or			Context&gt;&gt;createDebugger 	and break the remote debugger.  The latter method is doubly 	sensitive, upon both the layout of parameters and local variables 	in this method and the particulars of OE-level block optimization.  	Do not change this method, or the two methods listed above, 	without verifying that they continue to work in harmony."	| proc prio result request orbCxt reqIntercept |	proc := Processor activeProcess.	prio := proc priority.	proc priority: ORBObject orbPriority.	orbCxt := proc orbContext.	[	request := GIOPMessage newRequest.		"Interceptor Hook for 'requestPreMarshall'."		( reqIntercept := self requestInterceptors ) isNil 			ifFalse:	[ reqIntercept 						clientInvokePreSend: request 						context: orbCxt 						target: objRef 						operation: opInfo operation 						parameters: parameters					].		opInfo operation marshallServiceContextForRequest: request messageStream.		request			response: opInfo operation isOneWay not			objectKey: objRef			operation: opInfo operation name			principal: #().		opInfo operation marshallArguments: parameters on: request messageStream.		request msgSize: request messageStream size - request headerSize.		result := self basicNew					clientCall: opInfo					to: objRef					withRequest: request					withArgs: parameters.		GIOPMessage freeBuffers: request.		"Interceptor Hook for 'replyPostUnMarshall'."		reqIntercept isNil 			ifFalse:	[ reqIntercept						clientInvokePostSend: request						context: orbCxt						target: objRef						operation: opInfo operation						result: result ].	] ensure: [ proc priority: prio ].	^result</body></methods><methods><class-id>DST.DSTtypeAlias</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	self localType notNil		ifTrue: [(aParameter isKindOf: self localClass)				ifTrue: [self equivalentType						boldMarshall: aParameter						on: aStream						withLocalClass: self localClass]				ifFalse: [self equivalentType boldMarshall: aParameter on: aStream]]		ifFalse: [self equivalentType boldMarshall: aParameter on: aStream]</body><body package="DST_Core">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream"	self equivalentType boldMarshall: aParameter on: aStream withLocalClass: aClass</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		(self localType notNil and: [aParameter isKindOf: self localClass]) ifTrue: [^true].	^equivalentType marshallMatch: aParameter</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	| pos |	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	pos := aStream nextPutEncapsulationHeader.	aStream nextPutString: self repositoryId; nextPutString: self printName.	aStream nextPutLocalType: self localType.	equivalentType marshallTypeCode: aDictionary on: aStream.	aStream setEncapsulationLength: pos</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self localType notNil		ifTrue: [self equivalentType unMarshall: aStream withLocalClass: self localClass]		ifFalse: [self equivalentType unMarshall: aStream]</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class. "	^self equivalentType unMarshall: aStream withLocalClass: aClass</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream 	"unMarshall the type code of the receiver"	| mo byteOrder locType |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextString.	repositoryId isEmpty ifFalse: [repositoryId := RepositoryId fromString: repositoryId].	name := aStream nextString.	locType := aStream nextLocalType.	equivalentType := self class unMarshallTypeCode: aDictionary from: aStream.	locType isNil		ifTrue: [repositoryId isEmpty				ifFalse: 					[mo := ORBObject lookupMetaId: repositoryId.					mo isNil ifFalse: [mo localType isNil ifFalse: [self localType: mo localType]]]]		ifFalse: [self localType: locType].	aStream byteOrder: byteOrder</body></methods><methods><class-id>DST.DSTtypeAlias</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::AliasDef'</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #CLASS #VERSION) includes: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Alias</body><body package="DST_Core">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^self equivalentType metaValueOf: aSymbol</body><body package="DST_Core">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope."	self equivalentType resolveLocalTypesIn: aType</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_alias</body></methods><methods><class-id>DST.DSTtypeAlias</class-id> <category>AliasDef</category><body package="DST_Core">description	"return an alias description"	| d |	d := (Dictionary new) 			add: #name -&gt; name; 			add: #id -&gt; self id; 			add: #definedIn -&gt; self definedInString; 			add: #version -&gt; self version; 			add: #type -&gt; self; 			yourself.	d overrideCORBAType: (ORBObject lookupMetaId: #'::CORBA::TypeDescription').	^d</body><body package="DST_Core">originalTypeDef	"The originalTypeDef attribute identifies the type being aliased."	^self equivalentType</body><body package="DST_Core">originalTypeDef: aType 	"Setting the originalTypeDef attribute also updates the type 	attribute."	self notYetImplemented</body></methods><methods><class-id>DST.DSTtypeAlias</class-id> <category>printing</category><body package="DST_Core">IDLTypeName	"return the printable name of the receiver's type ie the type 	to be actually marshalled"	^'alias (' , equivalentType baseType name , ')'</body><body package="DST_Core">asString	"return the string representation of the receiver"	^equivalentType asString</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print a typedef onto the outstream in response to a format request."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level.	self localType isNil		ifFalse: 			[aStream nextPutAll: '#pragma class '; nextPutAll: self name; nextPutAll: ' '; nextPutAll: self localType; cr.			aStream tab: level; nextPutAll: 'typedef ']		ifTrue: [aStream nextPutAll: 'typedef '].	(equivalentType isDSTMetaObject and: [equivalentType isDSTtypeArray])		ifTrue: [aStream nextPut: $ ; nextPutAll: equivalentType arrayType equivalentType definitionString; nextPut: $ ; nextPutAll: equivalentType declaratorString]		ifFalse: [aStream nextPut: $ ; nextPutAll: equivalentType definitionString; nextPut: $ ; nextPutAll: name].	aStream nextPut: $;; cr</body><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'typedef '; nextPutAll: (equivalentType isNil			ifTrue: ['?']			ifFalse: [equivalentType definitionString]); space; nextPutAll: (name isNil			ifTrue: ['?']			ifFalse: [self name])</body></methods><methods><class-id>DST.DSTtypeAlias</class-id> <category>accessing</category><body package="DST_Core">definedIn: aMetaObject 	"Set the receiver's defining container meta object."	super definedIn: aMetaObject.	equivalentType notNil ifTrue: [equivalentType definedIn: aMetaObject]</body><body package="DST_Core">equivalentType	"Return the type being aliased."	(equivalentType isMemberOf: DSTtypeNamed)		ifTrue: [^equivalentType equivalentType]		ifFalse: [^equivalentType]</body><body package="DST_Core">resolveTo: aType 	"cause the receiver to resolve to the given type object"	equivalentType := aType</body><body package="DST_Core">valueExcept: aCol 	"Answer a valid value not contained in the collection, otherwise 	nil"	^self equivalentType valueExcept: aCol</body></methods><methods><class-id>DST.DSTtypeAlias</class-id> <category>initialization</category><body package="DST_Core">initialize: decl type: aType 	"Set the name and declarator fields."	name := decl name.	declarators := nil.	equivalentType := decl baseType</body></methods><methods><class-id>DST.DSTtypeAlias</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^OrderedCollection with: (DSTpseudoType on: self IDLTypeName)</body><body package="DST_Core">childName	"return the name to be used for the receiver in a browser window"	^declarators isNil		ifTrue: [self printName]		ifFalse: [name]</body><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^self equivalentType iconId</body></methods><methods><class-id>DST.DSTtypeAlias</class-id> <category>copying</category><body package="DST_Core">copyDeclaratorOn: aType	"make a copy of a declarator type, remembering that the declarator will point 	back to the type object which contained it as a declarator. We must avoid 	an infinite loop. Array, &amp; pointer types must overload"	| obj |	obj := super copyDeclaratorOn: aType .	obj resolveTo: nil.	^obj</body></methods><methods><class-id>DST.NCSuuid</class-id> <category>repository</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can 	marshall an instance of the receiver."	^ORBObject lookupMetaId: #'::CORBA::ORBId'</body></methods><methods><class-id>DST.NCSuuid</class-id> <category>persistence</category><body package="DST_Core">representBinaryOn: binWriter 	"Represent an ORBPersistentObjRef by a constructor which will 	rebuild either an objref or the object itself"	^MessageSend		receiver: self class		selector: #intern:		argument: self asByteArray</body></methods><methods><class-id>DST.NCSuuid</class-id> <category>private</category><body package="DST_Core">copy	"return the receiver"	^self</body><body package="DST_Core">key	"return the receiver. used by HandleRegistry"	^self</body><body package="DST_Core">postReadGeneralStructureOn: aBinaryStorageReader	"When we bring in an uuid we have to intern it"	| existOne |	^self == (existOne := self class intern: self)		ifTrue:[self]		ifFalse:[self oneWayBecome: existOne]</body></methods><methods><class-id>DST.NCSuuid</class-id> <category>converting</category><body package="DST_Core">asByteArray	"Answer an instance of ByteArray whose elements	are the elements of the receiver."	^ByteArray fromString: self</body><body package="DST_Core">asByteString	"Answer an instance of ByteString whose elements 	are the elements of the receiver."	^self asByteArray asByteString</body><body package="DST_Core">asFactoryIdOn: hostId	"perform the interface to factory oid mapping for the given host"	| ba x |	ba := self asByteArray.	1 to: 4 do: [:i | ba at: 9 + i put: (hostId at: i)].	ba at: 9 put: 2.	(6 to: 1 by: -1)		do: 			[:j | 			ba at: j put: (x := (ba at: j) + 1 bitAnd: 255).			x isZero ifFalse: [^ba asString asUUID]]</body><body package="DST_Core">asIdOn: hostId	"return a copy of the receiver on the the given host"	| ba  |	ba := self shallowCopy.	1 to: 4 do: [:i | ba at: 9 + i put: (hostId at: i)].	^self class intern: ba</body><body package="DST_Core">hostId	"return the hostId of the receiver"	^(self copyFrom: 10 to: 13) asByteArray</body></methods><methods><class-id>DST.NCSuuid</class-id> <category>printing</category><body package="DST_Core">asString	"return the printString notation"	^self printString</body><body package="DST_Core">printOn: aStream	"return a human readable string for the uuid, in DCE format"	self isNil ifTrue: [^aStream nextPutAll: 'NIL'].	1 to: 4 do: [:i | aStream nextPutAll: (self at: i) asHex].	aStream nextPutAll: '-'.	5 to: 6 do: [:i | aStream nextPutAll: (self at: i) asHex].	aStream nextPutAll: '-'.	7 to: 8 do: [:i | aStream nextPutAll: (self at: i) asHex].	aStream nextPutAll: '-'.	9 to: 10 do: [:i | aStream nextPutAll: (self at: i) asHex].	aStream nextPutAll: '-'.	11 to: 16 do: [:i | aStream nextPutAll: (self at: i) asHex].</body></methods><methods><class-id>DST.NCSuuid</class-id> <category>testing</category><body package="DST_Core">isLocalId	"return if the uuid is local"	^self hostId = ORBObject hostId</body><body package="DST_Core">isNilId	"return if the uuid is nil"	^self == NilId</body></methods><methods><class-id>DST.NCSuuid class</class-id> <category>accessing</category><body package="DST_Core">findInterned: aUUID 	"If aUUID has been interned (into a UUID), 	answer the UUID, otherwise answer nil."	| v stringSize |	stringSize := aUUID size.	v := self table at: aUUID hash \\ self table size + 1.	1 to: v size do: 		[:i | 		| test |		((test := v at: i) class == self and: [stringSize = test size				and: 					[| match ii |					match := true.					ii := 0.					[match and: [(ii := ii + 1) &lt;= stringSize]]						whileTrue: [(aUUID at: ii)								= (test at: ii) ifFalse: [match := false]].					match]])			ifTrue: [^test]].	^nil</body><body package="DST_Core">getImageId	"Get a small unique number for this image.	In the case of multiprocessor machine, to make UUID unique, it is necessary	to assign a differenet image id for each image running on the same machine."	^0</body><body package="DST_Core">tableSize	"Answer the number of UUIDs in the system."	^self allInstances size</body></methods><methods><class-id>DST.NCSuuid class</class-id> <category>instance creation</category><body package="DST_Core">from: aByteArray at: index 	"extract and intern a uuid from the byte array at the index"	| uuid |	uuid := self new: 16.	uuid		replaceBytesFrom: 1		to: 16		with: aByteArray		startingAt: index.	^self intern: uuid</body><body package="DST_Core">newId	"Create a new local uuid, using NCS guidelines: The time stamp is 	the number of 4 us intervals since 1/1/80"	| uuid hostId time |	Sema		critical: 			[hostId := ORBObject hostId.			uuid := self new: 16.			Tincr := Tincr + 1.			Tval isZero | (Tincr &gt; 249)				ifTrue: 					[Tval := Time totalSeconds - (Date newDay: 1 monthNumber: 1 year: 1980) asSeconds * 250000 + (Time millisecondClockValue \\ 1000 * 250).					Tincr := 0].			time := Tval + Tincr.			(6 to: 1 by: -1)				do: 					[:i | 					uuid at: i put: (time bitAnd: 255).					time := time bitShift: -8].			uuid at: 9 put: 2.			1 to: 4 do: [:j | uuid at: j + 9 put: (hostId at: j)].			uuid at: 15 put: self getImageId].	^self intern: uuid</body><body package="DST_Core">newId: timeVal 	"create a new local uuid, using NCS guidelines and the given time stamp value"	| uuid hostId time |	time := timeVal.	hostId := ORBObject hostId.	uuid := self new: 16.	(6 to: 1 by: -1)		do: 			[:i | 			uuid at: i put: (time bitAnd: 255).			time := time bitShift: -8].	uuid at: 9 put: 2.	1 to: 4 do: [:j | uuid at: j + 9 put: (hostId at: j)].	^self intern: uuid</body><body package="DST_Core">nilId	"return a nil local uuid, using NCS guidelines"	^NilId</body><body package="DST_Core">on: aString 	"return a uuid with value from an encoded print string or packed 	char array"	| uuid k ix dce |	aString size = 16 ifTrue: [aString class == self			ifTrue: [^self intern: aString]			ifFalse: 				[uuid := self new: 16.				1 to: 16 do: [:i | uuid at: i put: (aString at: i) asInteger].				^self intern: uuid]].	aString size = 36 ifFalse: [^self error: 'Cannot convert to UUID'].	uuid := self new: 16.	dce := (aString at: 9)				= $- and: [(aString at: 14)					= $- and: [(aString at: 19)						= $- and: [(aString at: 24)							= $-]]].	dce		ifTrue: ["handle DCE format"			ix := #(8 13 18 23 )]		ifFalse: ["handle NCS format"			ix := #(12 15 18 21 24 27 30 33 )].	k := 0.	1 to: 16 do: [:i | (dce or: [(#(7 8 ) includes: i) not])			ifTrue: 				[uuid at: i put: (aString at: (k := k + 1)) digitValue * 16 + ((aString at: (k := k + 1)) digitValue).				(ix includes: k)					ifTrue: [k := k + 1]]].	^self intern: uuid</body></methods><methods><class-id>DST.NCSuuid class</class-id> <category>class initialization</category><body package="DST_Core">initialize	"initialize the class"	"self initialize"	"Protect against multiple initialize's."	(ObjectMemory dependents includes: self)		ifFalse:	[ObjectMemory addDependent: self].	Tval := Tincr := 0.	Sema := Semaphore new signal.	self rehash.	NilId := self intern: (String new: 16)</body><body package="DST_Core">obsolete	ObjectMemory removeDependent: self.	super obsolete.</body><body package="DST_Core">reInitialize	"initialize the class"	Sema wait.	Tval := Tincr := 0.	Sema signal.	NilId := self intern: (String new: 16).</body><body package="DST_Core">release	"release the class variables"	NilId := Sema := STable := Tincr := Tval := nil</body></methods><methods><class-id>DST.NCSuuid class</class-id> <category>private</category><body package="DST_Core">intern: aUUID 	"Answer a unique UUID whose characters are those of aUUID."	| uuid index table subTable subIndex id |	^Sema		critical: 			[id := aUUID class == self						ifTrue: ["putting old id in new table"							aUUID]						ifFalse: ["create a new one"							(self new: 16)								replaceBytesFrom: 1								to: 16								with: aUUID								startingAt: 1].			uuid := self findInterned: id.			uuid notNil				ifTrue: [uuid]				ifFalse: 					[table := self table.					index := id hash \\ table size + 1.					subTable := table at: index.					subIndex := subTable								indexOf: 0								replaceWith: id								startingAt: 1								stoppingAt: subTable size.					subIndex = 0						ifTrue: 							[| newTable |							newTable := subTable class new: subTable size + 1.							newTable								replaceFrom: 1								to: subTable size								with: subTable.							newTable at: newTable size put: id.							table at: index put: newTable].					id]]</body><body package="DST_Core">rehash	"Rebuild the hash table that holds all the unique UUIDs."	"We want to keep the average number of probes for a lookup	constant; independent of the number of symbols.  Therefore,	when rehashing we adjust the number of buckets such that	we meet a target bucket size (e.g. symbols/buckets).	Choosing a target bucket size is a classic time/space tradeoff;	the value used here is 10, based on empirical tests."	| numBuckets |	"Set knows good hash moduli."	numBuckets := (Set goodSizeFrom: (self tableSize / 10) rounded) max: 3943.	self table: ((1 to: numBuckets) collect: [:uid | WeakArray with: 0]).	ObjectMemory garbageCollect.	self allInstancesDo: [:uid | self intern: uid].</body><body package="DST_Core">table	"return the symbol table for UUIDs"	^STable</body><body package="DST_Core">table: newArray 	"set the symbol table for UUIDs"	^STable := newArray</body></methods><methods><class-id>DST.NCSuuid class</class-id> <category>updating</category><body package="DST_Core">update: anAspect with: arguments from: anObject	"Check for return from snapshot to reInitialize."	anAspect == #earlySystemInstallation		ifTrue: [self reInitialize]</body></methods><methods><class-id>DST.OldWeakValueDictionary</class-id> <category>initialize-release</category><body package="DST_Core">initSize: aSize 	keys := Array new: aSize.	values := WeakArray new: aSize.	tally := 0.	self makeDependent</body><body package="DST_Core">makeDependent	values addDependent: self.</body></methods><methods><class-id>DST.OldWeakValueDictionary</class-id> <category>updating</category><body package="DST_Core">update: anAspectSymbol with: aParameter from: aSender 	"Finalize all finalizable entries of aSender."	(aSender == values and: [anAspectSymbol = #ElementExpired])		ifTrue: [self finalizeElements]		ifFalse: [^self]</body></methods><methods><class-id>DST.OldWeakValueDictionary</class-id> <category>private-reclaim/grow</category><body package="DST_Core">reclaimElements	| deathMarker size |	size := values basicSize.	deathMarker := 1.	[deathMarker ~= 0]		whileTrue: [(deathMarker := values						indexOf: 0						replaceWith: nil						startingAt: deathMarker						stoppingAt: size) = 0				ifFalse: 					[keys at: deathMarker put: nil.					tally := tally - 1]]</body></methods><methods><class-id>DST.OldWeakValueDictionary</class-id> <category>private</category><body package="DST_Core">findKeyOrNil: key 	"Look for the key in the receiver. If it is found, answer 	the index of the association containing the key, otherwise 	answer the index of the first unused slot."	| location length probe pass |	length := keys size.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.		[probe := keys at: location.	(values at: location) = 0		ifTrue: 			[keys at: location put: 0.			probe := 0].	probe == nil or: [probe = key]]		whileFalse: [(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body></methods><methods><class-id>DST.OrbResolver class</class-id> <category>private</category><body package="DST_Core">addRemoteOrb: anObjRef 	| key |	key := self keyForObjRef: anObjRef.	self locatorTable at: key put: anObjRef</body><body package="DST_Core">generateVPBindingFor: hostName transport: transport port: aPortNo	"aSymbol MUST be one of the elements returned from 	OrbResolver class&gt;&gt;allTransports"	| daemon tag vpId |	(daemon := ORBDaemon installedDaemonFor: transport daemonName) == nil		ifTrue: [^nil]		ifFalse: [tag := daemon bindingComponent tag].	vpId := (hostName , ';' , aPortNo asString) asByteArray.	^DSTBindingComponents 		on: (OrderedCollection 				with: (IORTaggedComponent 						tag: tag componentData: vpId))</body><body package="DST_Core">isThisOrb: key 	| daemon stream transport port |	stream := key readStream.	stream skipUpTo: $:; skip: 1.	transport := stream upTo: $:.	(daemon := ORBDaemon installedDaemonFor: (ORBDaemon configurationManager configurationOf: transport asSymbol) daemonName) notNil ifTrue: [port := daemon port].	^key == (self			keyForHostname: ORBObject hostName			transportName: transport asSymbol			port: port)</body><body package="DST_Core">keyForHostname: hostname 	| trans |	trans := ORBDaemon configurationManager primaryTransport.	^self		keyForHostname: hostname		transportName: trans transportName		port: trans defaultPort</body><body package="DST_Core">keyForHostname: hostname transport: transport  port: aPortNo 	^(hostname, ':', transport transportName, ':', aPortNo printString) asSymbol</body><body package="DST_Core">keyForHostname: hostname transportName: transportName  port: aPortNo 	^(hostname, ':', transportName, ':', aPortNo printString) asSymbol</body><body package="DST_Core">keyForObjRef: anObjRef 	| transportName port |	transportName := nil.	#(#iiopPort #ncsPort) with: #(#IIOP #NCS) do:		[:p :t | transportName isNil				ifTrue: [port := anObjRef bindings perform: p.			  			port notNil ifTrue: [transportName := t]]].	^self		keyForHostname: anObjRef hostName		transportName: transportName		port: port</body><body package="DST_Core">locatorTable	^LocatorTable		ifNil: 			[LocatorTable := Dictionary new.			LocatorTable]</body><body package="DST_Core">lookupOrbReferenceFor: hostname transport: transport port: aPortNo 	| key |	key := self				keyForHostname: hostname				transportName: transport transportName				port: aPortNo.	(self isThisOrb: key)		ifTrue: [^ORBObject]		ifFalse: [^self locatorTable at: key ifAbsent: [nil]]</body></methods><methods><class-id>DST.OrbResolver class</class-id> <category>reference generation</category><body package="DST_Core">generateOrbProxy: hostName 	"get a remote orbObject from the specified host"	"default to IIOP and use the default IIOP port"	| trans |	trans := ORBDaemon configurationManager primaryTransport.	^self		generateOrbProxy: hostName		transport: trans		port: trans defaultPort</body><body package="DST_Core">generateOrbProxy: hostName transport: transport port: aPortNo 	"get a remote orbObject from the specified host"	| bindings ref |	ref := self				lookupOrbReferenceFor: hostName				transport: transport				port: aPortNo.	ref		ifNil: 			[bindings := self						generateVPBindingFor: hostName						transport: transport						port: aPortNo.			ref := DSTObjRefRemote new						objectId: ORBObject boaId						adapterId: NCSuuid newId									"have to hard-code the following instead of doing 'ORBObject CORBAType repositoryId' 									because we might need a proxy for get a remote repository, but									CORBAType needs info from the repository. 									'Chicken and egg' problem"						interfaceId: 'IDL:DistributedSmalltalk/ORBObject_class:1.0' asRepositoryId						bindings: bindings						profiles: nil.			self addRemoteOrb: ref].	^ref</body><body package="DST_Core">generateOrbProxyOnReference: anObjRef 	"get a remote orbObject from the given ObjRef"	"self generateOrbProxyOnReference: (self generateOrbProxy: ORBObject hostName)"	| ref |	anObjRef isLocal		ifTrue: [ref := ORBObject asRemotable]		ifFalse: 			[ref := DSTObjRefRemote new					objectId: ORBObject boaId					adapterId: NCSuuid newId					interfaceId: ORBObject CORBAType repositoryId					bindings: anObjRef bindings					profiles: nil.			self addRemoteOrb: ref].	^ref</body><body package="DST_Core">listInitialServices: hostname 	"list the initial services at a remote orb"	^(self generateOrbProxy: hostname) listInitialServices</body><body package="DST_Core">resolveInitialReferences: aString hostname: hostname 	"list the initial services at a remote orb"	^(self generateOrbProxy: hostname)		resolveInitialReferences: aString</body></methods><methods><class-id>DST.OrbResolver class</class-id> <category>examples</category><body package="DST_Core">genericExample: hostname	"demontrate getting a remote ORB from a client MDF image"	"self initializeLocatorTable"	"self genericExample: ORBObject hostName"	"self genericExample: 'bonampak'"	"self genericExample: 'ya'"	(self listInitialServices: hostname) inspect.	(self resolveInitialReferences: #NameService hostname: hostname) inspect.	(self resolveInitialReferences: #FactoryFinder hostname: hostname) inspect.	(self resolveInitialReferences: #InterfaceRepository hostname: hostname) inspect</body></methods><methods><class-id>DST.OrbResolver class</class-id> <category>initialization</category><body package="DST_Core">initialize	self initializeLocatorTable</body><body package="DST_Core">initializeLocatorTable	LocatorTable := nil.</body></methods><methods><class-id>DST.DSTpseudoType class</class-id> <category>accessing</category><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^#DSTtype</body></methods><methods><class-id>DST.IIOPClientConnection</class-id> <category>private</category><body package="DST_Core">processMessage: aGIOPMessage	| client |	( aGIOPMessage isValidReply )		ifTrue:	[	aGIOPMessage isReply						ifTrue:	[ aGIOPMessage extractReplyHeader ]						ifFalse:	[ aGIOPMessage extractLocateReplyHeader ].					client := conversations 								at: aGIOPMessage requestId								ifAbsent:	[	self readRemainingBytes: aGIOPMessage messageStream.												nil											].					( client notNil )						ifTrue:	[	"Be careful.  The client can also be signaled by the timeout 									delay in the waiting thread.  The 'on:do:' below handles the									worst effects of this."									self unRegisterConversationWithoutShutdown: client.									[ client reply: aGIOPMessage externalMessageStreamToInternal ]										on:	IncompleteNextCountError										do:	[ :ex |	( client semaphoreIsEmpty )														ifTrue:	[	Transcript 																		cr; 																		show: 'Incomplete next count error.'.																	ex return 																]														ifFalse:	[	ex pass																]											].									client signalSemaphore								]				]		ifFalse:	[ ( aGIOPMessage isCloseConnection )					ifTrue:	[ self shutDown ]					ifFalse:	[ self error: 'invalid message for client connection' ]				]</body><body package="DST_Core">shutDownConnection	"signal all clients in the conversation list - which will result in comm 	failures, then do the necessary cleanup"	conversations values do: [:conv | conv cancel].	self isActive		ifTrue: 			[sktAddr close].	ActiveDaemon unRegisterClientConnection: self.	self shutDown</body></methods><methods><class-id>DST.IIOPClientConnection</class-id> <category>startup-shutdown</category><body package="DST_Core">shutDown	"terminate the broker"	[broker terminate]		on: Object errorSignal do: [:ex | (sktAddr notNil and: [sktAddr isActive])			ifTrue: [sktAddr close]]</body><body package="DST_Core">spawnConnectionBroker	"spawn a thread that listens for replies and dispatches them to the 	appropriate conversation"	broker := [			[| receiveMsg inbuf count reply |			receiveMsg := true.						[Processor yield.			receiveMsg and: [sktAddr isActive]]				whileTrue: [					[inbuf := ByteArray new: GIOPMessage headerSize.					count := sktAddr								readInto: inbuf								start: 1								for: inbuf size								wait: self class receiveTimeout * 1000.					count ~~ inbuf size						ifTrue: [receiveMsg := false]						ifFalse: 							[reply := GIOPMessage messageHeader: inbuf socketAccessor: sktAddr.							reply isValidMessage								ifTrue: [self processMessage: reply]								ifFalse: 									[self error: 'invalid reply message' withCRs.									receiveMsg := false]]]						on: ( sktAddr errorReporter errorSignal, IncompleteNextCountError )						do: 							[:ex | 							self error: 'server connection lost'.							receiveMsg := false]]]				ensure: [self shutDownConnection]]				forkAt: ORBObject orbPriority</body></methods><methods><class-id>DST.IIOPClientConnection</class-id> <category>message handlers</category><body package="DST_Core">sendRequest: aClientConv 	"Send the request immediately.  If the write fails, shut down the connection so 	it can be reused.	Ensure uninteruptable execution, even if a long message has to be written in multiple parts.	AR52524  Added in the sendLock so the the cleint and server connection deal properely with threaded calls S.G. and M.K "		^sendLock critical: [ | msgStream bytes |		(sktAddr notNil and: [sktAddr isActive]) 			ifTrue: [				aClientConv needsResponse ifTrue: [ self registerConversation: aClientConv].				msgStream := aClientConv request messageContents.				msgStream size &gt; WriteIncrement 					ifTrue: [bytes := self sendMessageInIncrements: msgStream]					ifFalse: 						[bytes := sktAddr 									writeFrom: msgStream collection									startingAt: 1									forSure: msgStream size									wait: self class receiveTimeout * 1000].				bytes = msgStream size 					ifTrue: [true]					ifFalse: 						[self shutDownConnection.						false]]			ifFalse: [false]]</body></methods><methods><class-id>DST.DSTtypeOctet</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_octet</body></methods><methods><class-id>DST.DSTtypeOctet</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall = no MNU on between:and: and 0&lt;=aParameter&lt;=255"	(aParameter between: 0 and: 255)		ifFalse: [self class marshallError: 0].	aStream nextPutByte: aParameter</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^(aParameter isInteger)		and: [aParameter between: 0 and: 255]</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextByte</body></methods><methods><class-id>DST.DSTtypeOctet</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'octet'</body></methods><methods><class-id>DST.DSTtypeOctet</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_octet</body></methods><methods><class-id>DST.ORBStartUpCoordinator</class-id> <category>accessing</category><body package="DST_Core">orbRunning	"Answer whether or not the ORB is running."	^ORBDaemon running</body><body package="DST_Core">shutDownPending	"Answer whether or not the orb is in the process of shutting down."	^state value == #shutDownPending</body><body package="DST_Core">started	^state value == #started</body><body package="DST_Core">state	"Answer the state of the orb."	^state</body><body package="DST_Core">state: aSymbol 	"Set the state variable."	state value: aSymbol</body><body package="DST_Core">stopped	^state value == #stopped</body></methods><methods><class-id>DST.ORBStartUpCoordinator</class-id> <category>startup-shutdown</category><body package="DST_Core">shutDown: aTime 	"for migration"	self shutDownRequestBroker: aTime</body><body package="DST_Core">shutDownRequestBroker 	"Shut down the system.  The state value has been changed in	5i to '#shutDownPending' as '#aboutToShutdown' was unused.	Production of the notification event '#aboutToStopORB' has been 	added for those application that need to take cleanup actions 	just prior to shutdown."	ORBObject notifyAboutToStopORB.	ORBDaemon activeDaemons do: [:daemon | daemon shutDown].	ObjectMemory removeDependent: self.	DSTObjRef flushObjectMaps.	state value: #stopped.	ORBObject notifyStoppedORB</body><body package="DST_Core">shutDownRequestBroker: aTime 	"Shutdown the request broker.  In 5i we check whether the a shutdown	has completed or is in progress before proceeding.  Thus, we no longer 	send multiple notifications to dependents on repeated programmatic 	shutdowns."	( self stopped or: [ self shutDownPending ] )		ifTrue:	[ ^ORBDaemon configurationManager						log:	(	'\Error: Request Broker Shutdown Failed -',								' ORB already stopped or shutting down.' 							) withCRs				].						ORBDaemon activeDaemons do: [:daemon | daemon prepareToShutDown ].	state value: #shutDownPending.	( aTime == 0 )		ifTrue:	[	self shutDownRequestBroker				]		ifFalse:	[	[	self delayAction: 'Shutdown' time: aTime.						self shutDownRequestBroker					] fork				]</body><body package="DST_Core">startRequestBroker	"... start the request broker based on the configuration information supplied by the 	user.  This method was reorganized in 5i for readability. A return was added in the 	inner 'ifFalse:' clause, to ensure correct behavior under programmatic invocation.	The boolean return value was scrapped, as it is never tested for and there are far 	better ways to get at ORB state."	| configMgr chosenTransports startedDaemons daemon errMsg |	"... innocuous initializations."	OrbResolver initializeLocatorTable.	ORBObject init.	configMgr := ORBDaemon configurationManager.	chosenTransports := configMgr chosenTransports.	startedDaemons := OrderedCollection new.	errMsg := '\Error: Request Broker Startup Failed - '.	[ chosenTransports		do:	[ :transport | 				daemon := ORBDaemon installedDaemonFor: transport daemonName.				( daemon isNil )					ifTrue:	[ configMgr log: ( errMsg, transport transportName, ' not installed.\'  ) withCRs ]					ifFalse:	[ ( daemon running not )								ifTrue:	[	transport configureTransportFor: daemon.											daemon startObjectServer.											startedDaemons add: daemon										]								ifFalse:	[	^configMgr log: ( errMsg, transport transportName , ' already running'  ) withCRs											"Without this return, you can pop into the 'ifTrue:' clause at the end on a											redundant programmatic invocation and get incoherent state."										]							]			]	]	on: Object errorSignal		do:	[:ex | 				( daemon notNil )					ifTrue:	[ configMgr log: ( errMsg, 'the ', daemon class name , 											' failed with exception (', ex errorString, ')\'  ) withCRs							]					ifFalse:	[ configMgr log: ( errMsg, 'failed with exception (', ex errorString, ')\' ) withCRs ].				startedDaemons do: [ :startedDaemon | startedDaemon shutDown ].				startedDaemons := #()			].	( startedDaemons isEmpty )		ifTrue:	[	state value: #stopped.					ObjectMemory removeDependent: self.				]		ifFalse:	[	state value: #started.					ObjectMemory addDependent: self.					ORBDaemon resetObjectAdaptorComponent.					configMgr configureSystemAtStartup.					ORBObject notifyStartedORB.				]</body></methods><methods><class-id>DST.ORBStartUpCoordinator</class-id> <category>private</category><body package="DST_Core">delayAction: aString time: minutes 	"Delay the shutdown for some period of time"	| delayTime dt configMgr |	configMgr := ORBDaemon configurationManager.	delayTime := 60 * minutes.	[delayTime &gt; 0		ifTrue: 			[dt := delayTime // 60.			configMgr log: aString , ' will occur in ' withCRs , (dt isZero						ifTrue: ['']						ifFalse: [dt = 1								ifTrue: [dt printString , ' minute']								ifFalse: [dt printString , ' minutes']]) , ((delayTime rem: 60) isZero						ifTrue: ['.\' withCRs]						ifFalse: [(dt isZero								ifTrue: ['']								ifFalse: [' and '])								, (delayTime rem: 60) printString , ' seconds.\' withCRs]).			true]		ifFalse: [false]]		whileTrue: 			[Processor yield.			(Delay forSeconds: 15) wait.			delayTime := delayTime - 15]</body><body package="DST_Core">shutDownQuietly	"shutDown the various daemons"	self shutDownRequestBroker: 0</body></methods><methods><class-id>DST.ORBStartUpCoordinator</class-id> <category>updating</category><body package="DST_Core">update: anEvent with: aParameter 	"Very Important - check to see if the system is going down and 	shut down the ORB if so"	anEvent == #aboutToQuit 		ifTrue: [self shutDownQuietly].	anEvent == #aboutToSnapshot 		ifTrue: [self orbRunning ifTrue: [self shutDownQuietly]].	anEvent == #returnFromSnapshot 		ifTrue: [self shutDownQuietly].</body></methods><methods><class-id>DST.ORBStartUpCoordinator</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	state := ( self orbRunning					ifTrue:	[ #started ]					ifFalse:	[ #stopped ] 			) asValue</body></methods><methods><class-id>DST.ORBStartUpCoordinator class</class-id> <category>instance creation</category><body package="DST_Core">new	"create a new instance of the receiver"	^self basicNew initialize</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>testing</category><body package="DST_Core">isDSTdeclaratorSimple	^true</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	baseType boldMarshall: aParameter on: aStream</body><body package="DST_Core">marshallMatch: param 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^baseType marshallMatch: param</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^baseType unMarshall: aStream</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>repository</category><body package="DST_Core">CORBAInterface	"return an instance of the DSTinterface which defines the behavior of the 	receiver when passed as a CORBA object"	^baseType CORBAInterface</body><body package="DST_Core">CORBAName	"return the name of my base type's CORBA interface in the repository"	^baseType CORBAName</body><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^baseType CORBAType</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the 	baseType of the receiver."	^self baseType canApplyPragma: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^baseType defKind</body><body package="DST_Core">metaValueOf: aSymbol 	"return the meta value which is associated with the given identifier"	^self baseType metaValueOf: aSymbol</body><body package="DST_Core">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	^baseType searchScopeFor: aSymbol</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>accessing</category><body package="DST_Core">baseType	"return the base type of the receiver"	^baseType</body><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	baseType notNil ifTrue: [baseType definedIn: aMetaObject]</body><body package="DST_Core">equivalentType	"The equivalentType for a declarator is the base type."	^baseType</body><body package="DST_Core">isDeclarator	"return true"	^true</body><body package="DST_Core">resolveTo: aType 	"cause the receiver to resolve to the given type object"	baseType isNil ifTrue: [baseType := aType]</body><body package="DST_Core">valueExcept: aCol 	"Answer a valid value not contained in the collection, otherwise 	nil"	^self baseType valueExcept: aCol</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>printing</category><body package="DST_Core">IDLTypeName	"return the printable name of the receiver's type ie the type 	to be actually marshalled in the NCS packet"	^name</body><body package="DST_Core">declaratorString	"return an IDL declarator string"	self baseType isDSTtypeArray		ifTrue: [^self baseType declaratorString]		ifFalse: [^self printName]</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print my IDL definition on the stream"	self baseType		printDefinitionOn: aStream		indent: level		style: aTextStyleName</body><body package="DST_Core">printOn: aStream 	"print the receiver"	aStream nextPutAll: 'declarator ' , self idlName</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^self baseType isNil		ifTrue: [OrderedCollection new]		ifFalse: [OrderedCollection with: self baseType]</body><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^self baseType notNil</body><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^baseType iconId</body><body package="DST_Core">nonTrivialDeclarators	"Get rid of declarators in the browser. Return the declarators of the 	receiver if there is more than one declarator, otherwise return an 	Array containing myself."	^Array with: (self baseType isNil			ifTrue: [self]			ifFalse: [self baseType])</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>TypeCode</category><body package="DST_Core">marshallTypeCode: aDictionary on: aStream	"marshall the type code of the receiver"	^baseType marshallTypeCode: aDictionary on: aStream</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^baseType typeKind</body><body package="DST_Core">typeParamCount	"return the TCParamCount of the receiver"	^baseType typeParamCount</body><body package="DST_Core">typeParameter: anInt 	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	^baseType typeParameter: anInt</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>DeclaratorDef</category><body package="DST_Core">description	"return a declarator description"	^Dictionary new		add: #name -&gt; name;		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedInString;		add: #type -&gt; self;		yourself</body><body package="DST_Core">type	"return the base type of the receiver"	^self baseType</body></methods><methods><class-id>DST.DSTdeclaratorSimple</class-id> <category>initialization</category><body package="DST_Core">array: anArray 	"Initialize a simple declarator with a DSTtypeArray."	self initialize.	name := anArray name.	baseType := anArray</body></methods><methods><class-id>DST.DSTAny</class-id> <category>accessing</category><body package="DST_Core">type	^type</body><body package="DST_Core">type: aValue	type := aValue</body><body package="DST_Core">value	^value</body><body package="DST_Core">value: aValue	value := aValue</body></methods><methods><class-id>DST.GIOPMessageHeader</class-id> <category>accessing</category><body package="DST_Core">byteOrder	"return the byte ordering of the message"	byteOrder == nil ifTrue: [byteOrder := (collection at: 7) == 1].	^byteOrder</body><body package="DST_Core">byteOrder: aBoolean 	"return the byte ordering of the message"	| pos |	byteOrder == aBoolean		ifFalse: 			[byteOrder := aBoolean.			pos := position.			position := 6.			self nextPutBoolean: aBoolean.			position := pos]</body><body package="DST_Core">magic	"return the magic byte array of the message"	^magic == nil		ifTrue: [magic := (collection copyFrom: 1 to: 4) fromCORBACharCodes]		ifFalse: [magic]</body><body package="DST_Core">magic: aString 	"set the magic byte array of the message"	| pos |	magic = aString		ifFalse: 			[magic := aString.			pos := position.			position := 0.			self nextPutBytes: aString toCORBACharCodes.			position := pos]</body><body package="DST_Core">majorVersion	"return the major version number of the message"	^majorVersion == nil		ifTrue: [majorVersion := collection at: 5]		ifFalse: [majorVersion]</body><body package="DST_Core">majorVersion: aByte	"set the major version number of the message"	| pos |	majorVersion = aByte		ifFalse: 			[majorVersion := aByte.			pos := position.			position := 4.			self nextPutByte: aByte.			position := pos]</body><body package="DST_Core">minorVersion	"return the major version number of the message"	^minorVersion == nil		ifTrue: [minorVersion := collection at: 6]		ifFalse: [minorVersion]</body><body package="DST_Core">minorVersion: aByte	"set the minor version number of the message"	| pos |	minorVersion = aByte		ifFalse: 			[minorVersion := aByte.			pos := position.			position := 5.			self nextPutByte: aByte.			position := pos]</body><body package="DST_Core">msgSize	"return the size of the message"	msgSize == nil		ifTrue: 			[| pos |			pos := position.			position := 8.			msgSize := self nextUnsignedLong.			position := pos].	^msgSize</body><body package="DST_Core">msgSize: anInt 	"set the size of the message"	| pos |	msgSize = anInt		ifFalse: 			[msgSize := anInt.			pos := position.			position := 8.			self nextPutLong: msgSize.			position := pos]</body><body package="DST_Core">msgType	"return the type of the message"	^msgType == nil		ifTrue: [msgType := collection at: 8]		ifFalse: [msgType]</body><body package="DST_Core">msgType: anInt 	"set the type of the message"	| pos |	msgType = anInt		ifFalse: 			[msgType := anInt.			pos := position.			position := 7.			self nextPutByte: msgType.			position := pos]</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>testing</category><body package="DST_Core">IIOPIsA: aRepositoryId 	aRepositoryId asString = 'IDL:CORBA/Repository:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Repository'</body><body package="DST_Core">addMetaObject: aMetaObject 	"Add the meta-object to the Repository. allow any kind IDL Definition 	to be added in the Repository so foreign forward declarations can be 	supported"	| mos |	contents add: aMetaObject.	self registerMetaObject: aMetaObject.	(aMetaObject isDSTMetaObject and: [aMetaObject isDSTMetaContainer])		ifTrue: ["this is what DST will always generate and normally expects to see"			aMetaObject definedInOnly: self]		ifFalse: ["this implies something foreign and not expected, the aMetaObject 			has to inform all of his children"			[aMetaObject definedIn: self]				on: Object messageNotUnderstoodSignal				do: 					[:ex | 					"be sure to do something legal"					| theMessage |					theMessage := ex parameter.					(theMessage class = Message and: [theMessage selector = #definedIn: and: [theMessage arguments = (Array with: self)]])						ifTrue: 							["aMetaObject did not understand the message 							#definedIn:"							aMetaObject definedInOnly: self.							ex return]						ifFalse: ["this was not our call, so we don't handle it"							ex reject]]].	mos := Set new.	aMetaObject allMetaObjectsInto: mos.	mos do: [:m | m registerIdentity]</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Repository</body><body package="DST_Core">metaObjectOf: aSymbol 	"return the meta object which is associated with the given identifier"	| obj |	^(self searchScopeFor: aSymbol)		ifNil: 			[obj := self searchScopeFor: #'CORBA::Object'.			obj notNil				ifTrue: [obj searchScopeFor: aSymbol]				ifFalse: [nil]]</body><body package="DST_Core">searchOutwards: aString 	"Find and answer the meta object by resolving the scoped name 	aString. 	Iterate outwards towards enclosing name spaces. Otherwise return 	nil"	| mo nameComponents |	mo := self metaObjectOf: aString asSymbol.	nameComponents := self class parseName: aString.		[nameComponents removeLast.	mo == nil and: [nameComponents size &gt; 0]]		whileTrue: [mo := self metaObjectOf: (self class scopedNameFrom: nameComponents) asSymbol].	^(mo isMemberOf: DSTdeclaratorSimple)		ifTrue: [mo baseType]		ifFalse: [mo]</body><body package="DST_Core">searchScopeFor: aSymbol 	"return the meta object which is associated with the given identifier"	| head str tail x |	aSymbol class == RepositoryId		ifTrue: [^self lookupId: aSymbol]		ifFalse: 			[str := aSymbol asString.			x := str findFirst: [:ch | ch = $:]].	x isZero		ifTrue: [^symbols at: aSymbol ifAbsent: [self searchSubScopeFor: aSymbol]]		ifFalse: 			[x = 1 ifTrue: [^self searchScopeFor: (str copyFrom: 3 to: str size) asSymbol].			head := str copyFrom: 1 to: x - 1.			tail := str copyFrom: x + 2 to: str size.			^(symbols at: head asSymbol ifAbsent: [^nil])				searchScopeFor: tail asSymbol].	^nil</body><body package="DST_Core">searchSubScopeFor: aSymbol 	"If enabled, search contents for the symbol. 	Note that CORBA actually requires full name specification for referenced 	names outside of the scope of a metaobject. DST provides subscope 	searching as a convenience feature. If subscope searching is enabled, 	then this method will return the FIRST metaobject that is found using 	aSymbol. If subscope searching is disabled, then the result will be ALL 	metaobjects that can be found for aSymbol. The result must then be 	checked for uniqueness."	| m found |	found := nil.	contents do: [:mo | (m := mo searchScopeFor: aSymbol) notNil ifTrue: [self class convenientNameResolution				ifTrue: [^m]				ifFalse: [(found ifNil: [found := Set new])						add: m]]].	^found</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>Repository</category><body package="DST_Core">createArray: length elementType: aType 	"The createArray operation returns a new ArrayDef with the 	specified length and elementType. 	It is the callers responsibility to invoke destroy on the returned 	object if it is not successfully used in creating a definition that is 	derived from contained (as createSequence is NOT derived from 	Contained)."	self notYetImplemented</body><body package="DST_Core">createFixed: arg1 scale: arg2 	self notYetImplemented</body><body package="DST_Core">createSequence: bound elementType: aType 	"The createSequence operation returns a new SequenceDef with the 	specified bound and elementType. 	It is the callers responsibility to invoke destroy on the returned 	object if it is not successfully used in creating a definition that is 	derived from contained (as createSequence is NOT derived from 	Contained)."	self notYetImplemented</body><body package="DST_Core">createString: bound 	"The createString operation returns a new StringDef with the 	specified bound, which must be non-zero. The getPrimitive 	operation is used for unbounded strings. 	It is the callers responsibility to invoke destroy on the returned 	object if it is not successfully used in creating a definition that is 	derived from contained (as createString is NOT derived from 	Contained)."	self notYetImplemented</body><body package="DST_Core">createWideString: bound 	"The createString operation returns a new StringDef with the 	specified bound, which must be non-zero. The getPrimitive 	operation is used for unbounded strings. 	It is the callers responsibility to invoke destroy on the returned 	object if it is not successfully used in creating a definition that is 	derived from contained (as createString is NOT derived from 	Contained)."	self notYetImplemented</body><body package="DST_Core">getPrimitive: pk 	"The getPrimitive operation returns a reference to a PrimitiveDef 	with the specified kind attribute. All PrimitiveDefs are immutable 	and are owned by the repository."	| prim type |	pk isSymbol		ifTrue: 			[name := #'CORBA::PrimitiveKind::' , pk.			type := CORBAConstants at: name]		ifFalse: [type := pk].	prim := self class primitiveKindTable at: type name ifAbsent: [self error: 'Invalid primitive kind specified'].	^prim new widenTo: #'::CORBA::PrimitiveDef'</body><body package="DST_Core">lookupId: aRepositoryId 	"return the repository meta object associated with the RepositoryId"	| mo |	mo := self class lookupId: aRepositoryId.	mo isNil ifTrue: [aRepositoryId formatName == #IDL ifTrue: [mo := self lookup: (self extractFullName: aRepositoryId)]].	^mo</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return a sorted collection of all my component meta objects."	^super allComponents asSortedCollection asOrderedCollection</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>MetaSem</category><body package="DST_Core">definingMetaObject	"return the receiver's defining meta object"	^self</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'repository ' , self printName</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>accessing</category><body package="DST_Core">idlName	"return the receivers full qualified name"	^''</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>repository-private</category><body package="DST_Core">canContain: kind 	"Check to see if the definition kind can be contained in the receiver."	^#(#dk_Constant #dk_Typedef #dk_Exception #dk_Interface #dk_Module) includes: kind</body></methods><methods><class-id>DST.DSTmoduleRepository</class-id> <category>parcel support</category><body package="DST_Core">traceFrom: aTracer 	"If this module is the root,  stop tracing" 	aTracer doTraceOfDSTmoduleRepository: self</body></methods><methods><class-id>DST.DSTmoduleRepository class</class-id> <category>accessing</category><body package="DST_Core">convenientNameResolution	"answer whether name resolution will continue in the repository contents" 	^SearchSubscope ifNil: [SearchSubscope := true]</body><body package="DST_Core">convenientNameResolution: aBoolean 	"set the flag whether name resolution will continue in the repository 	contents" 	^SearchSubscope := aBoolean == true</body></methods><methods><class-id>DST.DSTmoduleRepository class</class-id> <category>rendering</category><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary" 	^#DSTRepository</body></methods><methods><class-id>DST.DSTmoduleRepository class</class-id> <category>private</category><body package="DST_Core">primitiveKindTable	"answer the primitive kind table" 	^PKTable		ifNil: 			[PKTable := Dictionary new.			PKTable add: #pk_void -&gt; DSTtypeVoid.			PKTable add:  #pk_short -&gt; DSTtypeShort.			PKTable add:  #pk_long -&gt; DSTtypeLong.			PKTable add:  #pk_ushort -&gt; DSTtypeUnsignedShort.			PKTable add:  #pk_ulong -&gt; DSTtypeUnsignedLong.			PKTable add:  #pk_float -&gt; DSTtypeFloat.			PKTable add:  #pk_double -&gt; DSTtypeDouble.			PKTable add:  #pk_boolean -&gt; DSTtypeBoolean.			PKTable add:  #pk_char -&gt; DSTtypeCharacter.			PKTable add:  #pk_octet -&gt; DSTtypeOctet.			PKTable add:  #pk_any -&gt; DSTtypeAny.			PKTable add:  #pk_TypeCode -&gt; DSTpseudoTypeCode.			PKTable add:  #pk_Principal -&gt; DSTinterface.			PKTable add:  #pk_string -&gt; DSTtypeString.			PKTable add:  #pk_objref -&gt; DSTinterface.			PKTable add:  #pk_longlong -&gt; DSTtypeLongLong.			PKTable add:  #pk_ulonglong-&gt; DSTtypeUnsignedLongLong.			PKTable add:  #pk_longdouble -&gt; DSTtypeLongDouble.			PKTable add:  #pk_wchar -&gt; DSTtypeWideCharacter.			PKTable add:  #pk_wstring -&gt; DSTtypeWideString.			PKTable yourself]</body></methods><methods><class-id>DST.DSTexceptionDescription</class-id> <category>accessing</category><body package="DST_Core">definedIn	^definedIn</body><body package="DST_Core">definedIn: aValue	definedIn := aValue</body><body package="DST_Core">id	^id</body><body package="DST_Core">id: aValue	id := aValue</body><body package="DST_Core">name	^name</body><body package="DST_Core">name: aValue	name := aValue</body><body package="DST_Core">type	^type</body><body package="DST_Core">type: aValue	type := aValue</body><body package="DST_Core">version	^version</body><body package="DST_Core">version: aValue	version := aValue</body></methods><methods><class-id>DST.DSTexceptionDescription</class-id> <category>repository</category><body package="DST_Core">CORBAType	^ORBObject lookupMetaId: #'::CORBA::ExceptionDescription'</body></methods><methods><class-id>DST.IORMultipleComponents</class-id> <category>accessing</category><body package="DST_Core">bindings	"Answer a collection of bindings where the object was last seen.	Altered to test for IIOP, the more likely binding, first."	^bindings ifNil: [bindings := components select: 						[:co | co tag = co class tagDSTIIOPBinding 								or: [co tag = co class tagDSTNCSBinding]]]</body><body package="DST_Core">domainId	"Answer the globally unique string that identitfies the domain of	the object."	| tc |	tc := components detect: [:co | co tag = co class tagDSTDomain]				ifNone: [nil].	^tc isNil		ifTrue: [nil]		ifFalse: [tc componentData]</body><body package="DST_Core">dstObjectAdapter	"Answer the string providing specific information about a DST object	adapter."	^components detect: [:co | co tag = co class tagDSTObjectAdapter]		ifNone: [nil]</body><body package="DST_Core">endPointId	"answer the globally unique string which identitfies the endpoint for 	the object. This also is referred to as the adapter Id or virtual process 	Id"	| tc |	^vpId		ifNil: 			[tc := components detect: [:co | co tag == co class tagEndpointId]						ifNone: [nil].			tc isNil				ifTrue: [vpId := nil]				ifFalse: [vpId := tc componentData]]</body><body package="DST_Core">hints	"Answer a collection of bindings where the object was last seen.	Altered to directly test for the two tag values we care about and	test the more likely tag first."	^hints ifNil: [hints := components select: 							[:co | co tag = co class tagDSTIIOPHint 									or: [co tag = co class tagDSTNCSHint]]]</body><body package="DST_Core">objectKey	"answer the unique key which identitifies the object"	| tc |	^objectId		ifNil: 			[tc := components detect: [:co | co tag == co class tagObjectKey]						ifNone: [nil].			tc isNil				ifTrue: [objectId := nil]				ifFalse: [objectId := tc componentData]]</body><body package="DST_Core">supportsIIOPStreaming	"answer whether or not streaming can be used by the remote system"	| tc |	^iiopStream		ifNil:			[tc := components detect: [:co | co tag = co class tagDSTIIOPStream]						ifNone: [nil].			tc isNil				ifTrue: [iiopStream := false]				ifFalse: [iiopStream := true]]</body></methods><methods><class-id>DST.IORMultipleComponents</class-id> <category>private</category><body package="DST_Core">on: aCollection 	components := aCollection</body></methods><methods><class-id>DST.IORMultipleComponents class</class-id> <category>instance creation</category><body package="DST_Core">on: aCollection 	^self basicNew on: aCollection</body></methods><methods><class-id>DST.DSTObjRefRemote</class-id> <category>accessing</category><body package="DST_Core">adapterId	"Answer the value of adapterId."	^adapterId</body><body package="DST_Core">bindings	"answer the bindings for this object reference"	^bindings</body><body package="DST_Core">hostIdString	^IPSocketAddress bytesToName: bindings hostAddress</body><body package="DST_Core">hostName	^bindings hostName</body><body package="DST_Core">interoperableObjRefProfiles	^self profiles ifNil: [ORBObject invObjrefError: 0]</body><body package="DST_Core">objectId	"Answer the value of the objectId."	^objectId ifNil: [ORBObject invObjrefError: 0]</body><body package="DST_Core">profiles	"answer the collection of profiles"	^profiles</body></methods><methods><class-id>DST.DSTObjRefRemote</class-id> <category>persistence</category><body package="DST_Core">asLocal	"return the receiver's local object"	^self</body><body package="DST_Core">asRemotable	"return the receiver's local object"	^self</body></methods><methods><class-id>DST.DSTObjRefRemote</class-id> <category>initialization</category><body package="DST_Core">objectId: anId adapterId: anAdapterId interfaceId: anId2 bindings: aBindingComponents profiles: aCollection 	"initialize the appropriate instance variables"	self objectId: anId interfaceId: anId2.	adapterId := anAdapterId.	bindings := aBindingComponents.	profiles := aCollection</body><body package="DST_Core">objectId: anId adapterId: anAdapterId interfaceId: anId2 bindings: aBindingComponents profiles: aCollection adapterBootTime: anInteger 	"initialize the appropriate instance variables"	self objectId: anId interfaceId: anId2.	adapterId := anAdapterId.	bindings := aBindingComponents.	profiles := aCollection.	adapterBootTime := anInteger</body></methods><methods><class-id>DST.DSTObjRefRemote</class-id> <category>private</category><body package="DST_Core">updateObjRefProfiles: aCollection bootTime: anInteger multiComponents: anIORMultipleComponents 	"update the binding information for DST object references"	adapterBootTime notNil ifTrue: [adapterBootTime &lt; anInteger			ifTrue: 				[adapterBootTime := anInteger.				profiles := aCollection.				bindings := self class							findOrCreateBindingFor: adapterId							bootTime: anInteger							bindings: anIORMultipleComponents bindings]]</body></methods><methods><class-id>DST.DSTObjRefRemote</class-id> <category>narrowing</category><body package="DST_Core">narrowTo: aRepositoryId 	"Create a Narrowed Object Reference as a suitably-narrowed 	reference to the receiver. Warning - this is not a safecast narrow, 	you may get an invalid operation if you narrowTo an inappropriate 	interface. You should use this method with extreme caution"	aRepositoryId class == RepositoryId		ifTrue: [^DSTObjRefNarrowed findOrCreateOn: self asInterfaceId: aRepositoryId]		ifFalse: [^ORBObject badParamError: 0]</body></methods><methods><class-id>DST.DSTObjRefRemote class</class-id> <category>private</category><body package="DST_Core">bindingComponentOf: anAdapterId 	"answer the binding component for the adapter"	^DSTAdapterBindings at: anAdapterId ifAbsent: [nil]</body><body package="DST_Core">bindingComponentOf: anAdapterId is: aDSTBindingComponent 	"record the binding component for the adapter"	DSTAdapterBindings at: anAdapterId put: aDSTBindingComponent</body><body package="DST_Core">findOrCreateBindingFor: anAdapterId bootTime: anInteger bindings: aCollection 	"find or create a new binding for the adapterId. If binding component 	is found for adapater, update if necessary"	| bindings |	bindings := self bindingComponentOf: anAdapterId.	bindings isNil		ifTrue: 			[bindings := DSTBindingComponents on: aCollection.			bindings bootTime: anInteger.			self bindingComponentOf: anAdapterId is: bindings]		ifFalse: [bindings bootTime &lt; anInteger ifTrue: [bindings components: aCollection bootTime: anInteger]].	^bindings</body><body package="DST_Core">findOrCreateOnIIOPProfile: aTaggedProfile MDI: anInterfaceId profiles: aCollection 	"... extracts the information from the IIOP profile to create an object reference."	| profileData host port objId objref vpId bindings |	profileData := (CDRStream with: aTaggedProfile profileData) reset.	profileData byteOrder: profileData nextBoolean.	^( IORTaggedProfile validTag: profileData nextByte )		ifTrue:	[	host := profileData nextString.					port := profileData nextUnsignedShort.					objId := ObjectKeyDef unMarshall: profileData.					vpId := (host , ';' , port asString) asSymbol.					[ objId := NCSuuid on: objId ] 						on: Object errorSignal 						do:  [ :ex | objId := IIOPObjectKey intern: objId].					[ vpId := NCSuuid on: vpId asByteString ] 						on: Object errorSignal 						do:  [ :ex | vpId := IIOPObjectKey intern: vpId ].					bindings := DSTBindingComponents on: (OrderedCollection with: 									( IORTaggedComponent 										tag: IORTaggedComponent tagDSTIIOPBinding 										componentData: vpId ) ).					objref := self new							objectId: objId							adapterId: vpId							interfaceId: anInterfaceId							bindings: bindings							profiles: aCollection.					self registerObjRef: objref.					objref				]		ifFalse:	[	ORBObject invObjrefError: 0				]</body><body package="DST_Core">findOrCreateOnMultipleComponentProfile: aTaggedProfile MDI: anInterfaceId profiles: aCollection 	"extract the information from the MultiComponent profile to create 	an object reference"	| profileData objId obj objref vpId mcs bindings oaInfo bootTime |	profileData := (CDRStream with: aTaggedProfile profileData) reset.	profileData byteOrder: profileData nextBoolean.	mcs := IORMultipleComponents on: (MultipleComponentDef unMarshall: profileData).	oaInfo := mcs dstObjectAdapter.	^(oaInfo isNil or: [(oaInfo componentData copyFrom: 1 to: 3) asString ~= 'DST'])		ifTrue: [self findOrCreateOnNonDSTProfiles: aCollection MDI: anInterfaceId]		ifFalse: 			[objId := mcs objectKey.			vpId := mcs endPointId.			[objId := NCSuuid on: objId] on: Object errorSignal 				do:  [:ex | objId := IIOPObjectKey intern: objId].			[vpId := NCSuuid on: vpId asByteString] on: Object errorSignal				do:  [:ex | vpId := IIOPObjectKey intern: vpId].			objId isNilId				ifTrue: [nil]				ifFalse: 					[bootTime := profileData decodeLong: (oaInfo componentData copyFrom: 9 to: 12).					(obj := self objRefOf: objId adapterId: vpId) isNil						ifTrue: 							[bindings := self										findOrCreateBindingFor: vpId										bootTime: bootTime										bindings: mcs bindings.							bindings bootTime: bootTime.							objref := self new										objectId: objId										adapterId: vpId										interfaceId: anInterfaceId										bindings: bindings										profiles: aCollection										adapterBootTime: bootTime.							self registerObjRef: objref.							objref]						ifFalse: 							[obj								updateObjRefProfiles: aCollection								bootTime: bootTime								multiComponents: mcs.							obj asRemotable]]]</body><body package="DST_Core">findOrCreateOnNonDSTIIOPProfile: aTaggedProfile MDI: anInterfaceId profiles: aCollection	"... extracts the information from a non-DST IIOP profile to create an object	reference.  For a non-DST IIOP profile, we are no longer to try to decode	object id and adapterId to an NCSuuid because that may result in a wrong 	uuid in some cases, e.g. a forgien adaperId may be in the form		'123.45.6.78;1234' 		and it must not be coerced into an NCSuuid."	| profileData host port objId objref vpId bindings |	profileData := (CDRStream with: aTaggedProfile profileData) reset.	profileData byteOrder: profileData nextBoolean.	^( IORTaggedProfile validTag: profileData nextByte )		ifTrue:	[	host := profileData nextString.					port := profileData nextUnsignedShort.					objId := ObjectKeyDef unMarshall: profileData.					vpId := (host , ';' , port asString) asSymbol.					objId :=  IIOPObjectKey intern: objId.					vpId := IIOPObjectKey intern: vpId.					bindings := DSTBindingComponents on: 						(OrderedCollection 							with: (IORTaggedComponent 										tag: IORTaggedComponent tagDSTIIOPBinding 										componentData: vpId)).					objref := self new							objectId: objId							adapterId: vpId							interfaceId: anInterfaceId							bindings: bindings							profiles: aCollection.					self registerObjRef: objref.					objref				]		ifFalse:	[	ORBObject invObjrefError: 0				]</body><body package="DST_Core">findOrCreateOnNonDSTProfiles: aCollection MDI: anInterfaceId 	"the multiple component profile is not from a Distributed 	Smalltalk system, look for an IIOP profile or create a generic 	reference"	| profile |	profile := aCollection detect: [:tp | tp isInternetIOPProfile]				ifNone: [nil].	^profile isNil		ifTrue: [self new				objectId: nil				adapterId: nil				interfaceId: anInterfaceId				bindings: (DSTBindingComponents on: #())				profiles: aCollection]		ifFalse: [self				findOrCreateOnNonDSTIIOPProfile: profile				MDI: anInterfaceId				profiles: aCollection]</body></methods><methods><class-id>DST.DSTObjRefRemote class</class-id> <category>creation-registration</category><body package="DST_Core">findOrCreateOnProfiles: aCollection MDI: anInterfaceId 	"find or create a new object reference"	| profile |	profile := aCollection detect: [:tp | tp isMultipleComponentsProfile]				ifNone: [nil].	^profile isNil		ifTrue: [self findOrCreateOnNonDSTProfiles: aCollection MDI: anInterfaceId]		ifFalse: [self				findOrCreateOnMultipleComponentProfile: profile				MDI: anInterfaceId				profiles: aCollection]</body><body package="DST_Core">index	"Answer the value of index."	^Index</body><body package="DST_Core">indexOf: anObjId adapterId: anAdapterId 	"search the index to find the local object reference associated 	objectId/vpId"	| dict res |	dict := self index at: anAdapterId ifAbsent: [nil].	^(dict isNil or: [dict = 0])		ifTrue: [nil]		ifFalse: 			[res := dict at: anObjId ifAbsent: [nil].			res = 0				ifTrue: [nil]				ifFalse: [res]]</body><body package="DST_Core">objRefOf: anObjectId adapterId: anAdapterId 	"return the object reference associated with uuId"	^(ORBDaemon isLocalAdapter: anAdapterId)		ifTrue: [self objectOf: anObjectId]		ifFalse: [self indexOf: anObjectId adapterId: anAdapterId]</body><body package="DST_Core">registerObjRef: anObjRef 	"register the local object reference by its objectKey/vpId"	| dict |	dict := self index at: anObjRef adapterId ifAbsent: [nil].	(dict isNil or: [dict = 0])		ifTrue: 			[dict := SubIndexClass new: 2011.			self index at: anObjRef adapterId put: dict].	dict at: anObjRef objectId put: anObjRef.	^anObjRef</body><body package="DST_Core">searchBlock	"return a block which indicates which index tables to search in 	addition to Objects"	^[:objId | (DSTObjRefWidened indexOf: objId)		ifNil: [(DSTObjRefInactive indexOf: objId)				ifNil: [nil]]]</body></methods><methods><class-id>DST.DSTObjRefRemote class</class-id> <category>accessing</category><body package="DST_Core">defaultIndexClass	^WeakKeyDictionary</body><body package="DST_Core">multipleComponentDef	"answer the appropriate meta object based upon the multiple 	components profile idl description"	^MultipleComponentDef</body><body package="DST_Core">objectKeyDef	"answer the appropriate meta object based upon the idl description 	for object keys"	^ObjectKeyDef</body></methods><methods><class-id>DST.DSTObjRefRemote class</class-id> <category>initialization</category><body package="DST_Core">flushIndex	"flush the class index"	"self flushIndex"	Index := self indexClass new: 2011</body><body package="DST_Core">initialize	"initialize the class variables"	| fieldArray |	DSTAdapterBindings := WeakValueDictionary new: 2011.	self flushIndex.	ObjectKeyDef := (DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray.	fieldArray := Array with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #tag))					with: DSTtypeUnsignedLong new)				with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #componentData))						with: ((DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray)).	MultipleComponentDef := DSTtypeSequence new subtype: ((DSTtypeStructure new) id: #TaggedComponent fields: fieldArray; localType: #IORTaggedComponent) size: nil</body><body package="DST_Core">release	"release the class variables"	DSTAdapterBindings := Index := MultipleComponentDef := ObjectKeyDef := nil</body></methods><methods><class-id>DST.DSTBindingComponents</class-id> <category>accessing</category><body package="DST_Core">bootTime	"answer the bootTime"	^bootTime</body><body package="DST_Core">components	^components</body><body package="DST_Core">hostAddress	"answer the hostAddress based upon the information in the binding 	components"	ncsAddr notNil ifTrue: [^ncsAddr hostAddress].	iiopAddr notNil ifTrue: [^iiopAddr hostAddress].	^self socketAddressForNCS notNil		ifTrue: [ncsAddr hostAddress]		ifFalse: [self socketAddressForIIOP notNil				ifTrue: [iiopAddr hostAddress]				ifFalse: [nil]]</body><body package="DST_Core">hostName	"answer the hostName based upon the information in the binding 	components"	ncsAddr notNil ifTrue: [^ncsAddr hostName].	iiopAddr notNil ifTrue: [^iiopAddr hostName].	^self socketAddressForNCS notNil		ifTrue: [ncsAddr hostName]		ifFalse: [self socketAddressForIIOP notNil				ifTrue: [iiopAddr hostName]				ifFalse: [nil]]</body><body package="DST_Core">iiopPort	| addr |	addr := self createAddressFromIIOPBinding.	^addr isNil		ifTrue: [nil]		ifFalse: [addr port]</body><body package="DST_Core">ncsPort	| addr |	addr := self createAddressFromNCSBinding.	^addr isNil		ifTrue: [nil]		ifFalse: [addr port]</body></methods><methods><class-id>DST.DSTBindingComponents</class-id> <category>private</category><body package="DST_Core">bootTime: anInteger	"set the boot time for the binding"	bootTime := anInteger</body><body package="DST_Core">createAddressFromIIOPBinding	| comp |	comp := components detect: [:co | co tag = co class tagDSTIIOPBinding]				ifNone: [nil].	^comp isNil		ifTrue: [nil]		ifFalse: [(comp componentData isKindOf: String)				ifTrue: [self socketAddressFromString: comp componentData]				ifFalse: [self socketAddressFromString: comp componentData asString]]</body><body package="DST_Core">createAddressFromNCSBinding	| comp |	comp := components detect: [:co | co tag = co class tagDSTNCSBinding]				ifNone: [nil].	^comp isNil		ifTrue: [nil]		ifFalse: [self socketAddressFromString: comp componentData fromCORBACharCodes]</body><body package="DST_Core">on: aCollection 	components := aCollection</body><body package="DST_Core">socketAddressFromString: aString 	"return a socket address based on the information contained in the string"	| hostName hostId port |   	hostName := aString copyUpTo: $;.	hostId := IPSocketAddress hostAddressByNameOrAddressString: hostName.	port := (aString copyFrom: hostName size + 2 to: aString size) asNumber.	^IPSocketAddress hostAddress: hostId port: port</body></methods><methods><class-id>DST.DSTBindingComponents</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ' (host=', self hostName asString, ', ', self hostAddress printString, ')'.	aStream nextPutAll: ' (port=', self iiopPort asString, ', ', self ncsPort asString, ')'.</body></methods><methods><class-id>DST.DSTBindingComponents</class-id> <category>tranports</category><body package="DST_Core">socketAddressForIIOP	"answer the socket address for the NCS transport"	^iiopAddr ifNil: [iiopAddr := self createAddressFromIIOPBinding]</body><body package="DST_Core">socketAddressForNCS	"answer the socket address for the NCS transport"	^ncsAddr ifNil: [ncsAddr := self createAddressFromNCSBinding]</body></methods><methods><class-id>DST.DSTBindingComponents</class-id> <category>initialization</category><body package="DST_Core">components: aCollection bootTime: anInteger 	"initialize the receiver, reseting the addrs"	components := aCollection.	bootTime := anInteger.	ncsAddr := nil.	iiopAddr := nil</body></methods><methods><class-id>DST.DSTBindingComponents class</class-id> <category>instance creation</category><body package="DST_Core">on: aCollection 	"answer a new instance of cacheInfo"	^self new on: aCollection</body></methods><methods><class-id>DST.DSTattribute</class-id> <category>testing</category><body package="DST_Core">IIOPIsA: aRepositoryId	aRepositoryId asString = 'IDL:CORBA/AttributeDef:1.0' ifTrue:[^true].	^super IIOPIsA: aRepositoryId</body><body package="DST_Core">isDSTattribute	^true</body></methods><methods><class-id>DST.DSTattribute</class-id> <category>Attribute Def</category><body package="DST_Core">description	"return an attribute description"	^(DSTattributeDescription new)		name: name;		id: self id;		definedIn: self definedInString;		version: self version; 		type: self type; 		mode: self mode;		yourself</body><body package="DST_Core">mode	"return the mode of the receiver"	^readOnly		ifTrue: [#READONLY]		ifFalse: [#NORMAL]</body><body package="DST_Core">mode: newMode 	"return the mode of the receiver"	self notYetImplemented</body><body package="DST_Core">type	"The type attribute provides the typecode describing the type of this 	attribute."	^typeSpec equivalentType</body><body package="DST_Core">typeDef	"The typeDef attribute identifies the object defining the type of this 	attribute."	^typeSpec equivalentType baseType</body><body package="DST_Core">typeDef: anIDLType 	"Setting typeDef also updates the type attribute."	self notYetImplemented</body></methods><methods><class-id>DST.DSTattribute</class-id> <category>accessing</category><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	self getOperations do: [:op | op definedIn: aMetaObject].	self setOperations do: [:op | op definedIn: aMetaObject].	typeSpec definedIn: aMetaObject</body><body package="DST_Core">getOperations	"return the operation objects for the _get_attribute() operation"	^getOp ifNil: [getOp := typeSpec declarators collect: [:dec | DSToperation new						opSel: name						cxt: #()						evts: #()						params: DSTsignature new						id: ('_get_' , dec printName asString) asSymbol						type: typeSpec						attr: nil]]</body><body package="DST_Core">isReadOnly	"return the read only state of the receiver"	^readOnly</body><body package="DST_Core">setOperations	"return an operation object for the _set_attribute() operation"	^setOp ifNil: [setOp := readOnly					ifTrue: [#()]					ifFalse: [typeSpec declarators collect: [:dec | DSToperation new								opSel: (name asString , ':') asSymbol								cxt: #()								evts: #()								params: (DSTsignature with: (DSTparameter new											name: #new_value											type: typeSpec											direction: #IN))								id: ('_set_' , dec printName asString) asSymbol								type: DSTtypeVoid new								attr: nil]]]</body></methods><methods><class-id>DST.DSTattribute</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^typeSpec nonTrivialDeclarators asOrderedCollection addAll: self getOperations; addAll: self setOperations; yourself</body><body package="DST_Core">iconId	"Return the key to find my icon image in the installed icon dictionary"	^('DST' , (readOnly			ifTrue: ['R']			ifFalse: ['RW']) , 'attribute') asSymbol</body></methods><methods><class-id>DST.DSTattribute</class-id> <category>printing</category><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"print the IDL definition of the receiver on the stream"	self printCommentOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	(repositoryId isNil not and: [repositoryId ~= self generateRepositoryId])		ifTrue: [aStream tab: level; nextPutAll: '#pragma  ID '; nextPutAll: self printName; space; nextPut: $"; nextPutAll: repositoryId asString; nextPut: $"; cr].	version notNil ifTrue: [aStream tab: level; nextPutAll: '#pragma  version '; nextPutAll: self printName; space; nextPutAll: version; cr].	aStream tab: level.	readOnly ifTrue: [aStream nextPutAll: 'readonly '].	aStream nextPutAll: 'attribute '; nextPutAll: typeSpec definitionString; nextPut: $ ; nextPutAll: typeSpec declaratorString; nextPut: $;; cr</body><body package="DST_Core">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: 'attribute ' , self idlName</body></methods><methods><class-id>DST.DSTattribute</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::AttributeDef'</body><body package="DST_Core">allMetaObjectsInto: aSet 	"add all of the referenced metaobjects to the set"	super allMetaObjectsInto: aSet.	typeSpec allMetaObjectsInto: aSet.	self getOperations do: [:op | op allMetaObjectsInto: aSet].	self setOperations do: [:op | op allMetaObjectsInto: aSet]</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#ID #VERSION) includes: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Attribute</body></methods><methods><class-id>DST.DSTattribute</class-id> <category>initialization</category><body package="DST_Core">r: bool t: aType 	"initialize the receiver"	readOnly := bool.	typeSpec := aType.	name := typeSpec declaratorString</body></methods><methods><class-id>DST.DSTcachedOperation</class-id> <category>private</category><body package="DST_Core">name: aName definedIn: anId localOp: aSelector access: anAccess signature: aSignature mode: aMode raises: aCollection context: aCxt 	name := aName.	definedIn := anId.	localOp := aSelector.	access := anAccess.	signature := aSignature.	sync := aMode.	raises := aCollection.	context := aCxt</body></methods><methods><class-id>DST.DSTcachedOperation</class-id> <category>accessing</category><body package="DST_Core">access	^self accessRight</body><body package="DST_Core">definedIn	^(definedIn class == RepositoryId)		ifTrue: [definedIn]		ifFalse: [self definingMetaObject id]</body><body package="DST_Core">exceptionOf: aSymbol 	"Return an exception meta object which has the given print name symbol. 	Error if not"	| ex |	ex := ORBObject lookupMetaId: aSymbol.	(ex isDSTMetaObject and: [ex isDSTexception])		ifTrue: [^ex]		ifFalse: [self class intfReposError: 0]</body><body package="DST_Core">exceptions	^raises</body><body package="DST_Core">idlName		^[super idlName] on: Object errorSignal do: [:ex | name]</body><body package="DST_Core">raises	^raises</body></methods><methods><class-id>DST.DSTcachedOperation</class-id> <category>testing</category><body package="DST_Core">isDSTcachedOperation	^true</body></methods><methods><class-id>DST.DSTcachedOperation</class-id> <category>repository</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SharedIR::CachedOperation'</body></methods><methods><class-id>DST.DSTcachedOperation class</class-id> <category>instance creation</category><body package="DST_Core">name: aName definedIn: anId localOp: aSelector access: anAccess signature: aSignature mode: aMode raises: aCollection context: aCxt 	^(self new)		name: aName		definedIn: anId		localOp: aSelector		access: anAccess		signature: aSignature		mode: aMode		raises: aCollection		context: aCxt; yourself</body></methods><methods><class-id>DST.DSTMessageInterceptor</class-id> <category>intercepting</category><body package="DST_Core">postReceiveMessage	"... intentionally null."</body><body package="DST_Core">postReceiveMessage: aRequest context: anORBContext target: anObjRef reply: aReply	self postReceiveMessage "for backward compatiblity only, override for new usage"</body><body package="DST_Core">postSendMessage	"... intentionally null."</body><body package="DST_Core">postSendMessage: aRequest context: anORBContext target: aReceiver	self postSendMessage "for backward compatiblity only, override for new usage"</body><body package="DST_Core">preReceiveMessage: aRequest context: anORBContext target: aReceiver	"... intentionally null."</body><body package="DST_Core">preSendMessage: aRequest context: anORBContext target: aReceiver	"... intentionally null."</body></methods><methods><class-id>DST.DSTtypeUnion</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::UnionDef'</body><body package="DST_Core">allMetaObjectsInto: aSet 	"add all of the contained metaobjects to the set"	super allMetaObjectsInto: aSet.	switchtype allMetaObjectsInto: aSet.	cases do: [:case | case allMetaObjectsInto: aSet]</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#CLASS) includes: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Union</body><body package="DST_Core">lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool 	"Modified version of DSTMetaContainer's routine. Used to lookup 	definitions within a structure."	cases do: [:ca | ca declarators do: [:d | d name == aSymbol ifTrue: [^Set with: d]]].	^#()</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_union</body><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^cases size * 3 + 2</body><body package="DST_Core">typeParameter: anInt 	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	| n m case |	anInt = 1 ifTrue: [^self printName].	anInt = 2 ifTrue: [^switchtype].	(anInt between: 3 and: self typeParamCount)		ifTrue: 			[n := anInt - 3 // 3.			case := cases at: n + 1.			(m := anInt \\ 3) = 0				ifTrue: [^case discriminator value asString]				ifFalse: [^m = 1						ifTrue: [case type printName asString]						ifFalse: [case type]]].	self error: #Bounds</body></methods><methods><class-id>DST.DSTtypeUnion</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	self localClass == nil		ifTrue:  [self boldMarshallImplict: aParameter on: aStream]		ifFalse:  [self boldMarshallExplict: aParameter on: aStream ]</body><body package="DST_Core">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream."	aClass == nil		ifTrue:  [self boldMarshallImplict: aParameter on: aStream]		ifFalse:  [self boldMarshallExplict: aParameter on: aStream withLocalClass: aClass ]</body><body package="DST_Core">boldMarshallExplict: aParameter on: aStream	"Marshall the parameter onto the stream."	"This is an explict union (as marked by having a local class)."	"Determine which case to use and try to marshall it."	| discriminator case |	discriminator := aParameter discriminator.	case := self caseExplictDiscriminator: discriminator.	case == nil ifTrue: [self class marshallError: 0].	switchtype boldMarshall: discriminator on: aStream.	case boldMarshall: aParameter value on: aStream</body><body package="DST_Core">boldMarshallExplict: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream."	"This is an explict union (as marked by having a local class)."	"Determine which case to use and try to marshall it."	| discriminator case |	discriminator := aParameter discriminator.	case := self caseExplictDiscriminator: discriminator.	case == nil ifTrue: [self class marshallError: 0].	switchtype boldMarshall: discriminator on: aStream.	case boldMarshall: aParameter value on: aStream</body><body package="DST_Core">boldMarshallImplict: aParameter on: aStream 	"Marshall the parameter onto the stream."	"This is an implict union (as marked by lacking a local class)."	"Determine which case to use and try to marshall it."	| case expr |	case := self caseImplictFor: aParameter.	expr := case discriminator value.	case isDefaultDiscriminator ifTrue: [expr := self defaultValue].	switchtype boldMarshall: expr on: aStream.	case boldMarshall: aParameter on: aStream</body><body package="DST_Core">caseExplictDiscriminator: aDiscriminator 	"Return the case that has the discriminator 'aDiscriminator', 	or return nil if there is no match."	"In the explict case we can just look for a discriminator 	that matches."	| cadefault |	cadefault := nil.	cases do: [:case | 		case isDefaultDiscriminator			ifTrue: [cadefault := case]			ifFalse: [aDiscriminator = case discriminator value  ifTrue: [^case]]].	^cadefault</body><body package="DST_Core">caseImplictFor: aParameter 	"Return the case for the parameter, or return nil"	"In the implict case we try each type to see how well 	it matches aParameter. If there are no perfect matches 	we use one that is mappable, failing that we return nil."	| mappableCase |	mappableCase := nil.	cases		do: 			[:case | 			| match |			match := case marshallMatch: aParameter.			match == true ifTrue: [^case].			match == #mappable ifTrue: [mappableCase := case]].	^mappableCase</body><body package="DST_Core">marshallMatch: aParameter 	"Return: 		true			- if I can marshall the parameter 		false		- if I can NOT marshall the parameter 		#mappable	- if I can marshall the parameter by mapping to something else"	^self localClass == nil		ifTrue: 			[| mappable |			mappable := false.			cases				do: 					[:case | 					| match |					match := case marshallMatch: aParameter.					match == true ifTrue: [^true].					match == #mappable ifTrue: [mappable := match]].			mappable]		ifFalse: [aParameter isKindOf: self localClass]</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	| pos |	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	aStream nextPutUnsignedLong: self typeCode.	pos := aStream nextPutEncapsulationHeader.	aStream nextPutString: self repositoryId; nextPutString: self printName; nextPutLocalType: self localType.	switchtype marshallTypeCode: aDictionary on: aStream.	aStream nextPutLong: self defaultIndex - 1.	aStream nextPutUnsignedLong: cases size.	cases do: [:ca | 		"DSTtypeAny new marshall: ca discriminator value on: aStream."		switchtype marshall: ca discriminator value on: aStream.		aStream nextPutString: ca type childName.		ca type marshallTypeCode: aDictionary on: aStream].	aStream setEncapsulationLength: pos</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| switch value defaultCase |	switch := switchtype unMarshall: aStream.	cases do: [:ca | switch = ca discriminator value			ifTrue: 				[value := ca unMarshall: aStream.				^aClass notNil					ifTrue: [aClass discriminator: switch value: value]					ifFalse: [value]]			ifFalse: [ca discriminator == #default ifTrue: [defaultCase := ca]]].	defaultCase isNil		ifTrue: [^self class marshallError: 0]		ifFalse: 			[value := defaultCase unMarshall: aStream.			^aClass notNil				ifTrue: [aClass discriminator: switch value: value]				ifFalse: [value]]</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall the type code of the receiver"	| mo sz byteOrder locType |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextString.	repositoryId isEmpty ifFalse: [repositoryId := RepositoryId fromString: repositoryId].	(repositoryId notEmpty and: [ aStream notReadingFromRemoteIR ]) 		"We have to make sure that we don't do this in case of reading a typecode from remote IR,		otherwise we'll have an infinite recursion, more detail can be found in AR#49408"		ifTrue: [mo := ORBObject lookupMetaId: repositoryId].	name := aStream nextString.	(name isEmpty and: [mo notNil]) ifTrue: [name := mo name].	locType := aStream nextLocalType.	switchtype := self class unMarshallTypeCode: aDictionary from: aStream.	defaultIndex := aStream nextLong + 1.	sz := aStream nextUnsignedLong.	cases := (1 to: sz) collect: [:idx || label discrim type |				"typ := DSTtypeAny new unMarshallType: aStream."				label := switchtype unMarshall: aStream.				discrim := DSTvalueNamed new initialize: aStream nextString.				discrim value: label.				discrim definedIn: self.				type := self class unMarshallTypeCode: aDictionary from: aStream.				"typ initialize: n."				type definedIn: self.				DSTUnionCase discriminator: discrim type: type].	defaultIndex &gt; 0 ifTrue: [(cases at: defaultIndex) discriminator: #default].	locType isNil		ifTrue: [mo isNil ifFalse: [mo localType isNil ifFalse: [self localType: mo localType]]]		ifFalse: [self localType: locType].	aStream byteOrder: byteOrder</body></methods><methods><class-id>DST.DSTtypeUnion</class-id> <category>UnionDef</category><body package="DST_Core">description	"return a union description"	|d|	d := (Dictionary new) 			add: #name -&gt; name; 			add: #id -&gt; self id; 			add: #definedIn -&gt; self definedInString; 			add: #version -&gt; self version; 			add: #type -&gt; self;			yourself.	d overrideCORBAType: (ORBObject lookupMetaId: #'::CORBA::TypeDescription').	^d</body><body package="DST_Core">discriminatorType	"The discriminatorType attribute describes the union's discriminator 	type."	^switchtype</body><body package="DST_Core">discriminatorTypeDef	"The discriminatorTypeDef attribute identifies the union's 	discriminator type."	^switchtype</body><body package="DST_Core">discriminatorTypeDef: aTypeDef 	"Setting the discriminatorTypeDef attribute also updates the 	discriminatorType attribute. The type attribute is also updated."	self notYetImplemented</body><body package="DST_Core">members	"The members attribute contains a description of each union 	member. The label of each union member description is a distinct 	value of the discriminator type. Adjacent members can have the 	same name. Members with the same name must also have the same 	type. A label with type octet and value 0 indicates the default union 	member."	^cases collect: [:case | 		(Dictionary new) 			add: #name -&gt; case type equivalentType childName; 			add: #label -&gt; case discriminator value; 			add: #type -&gt; case type; 			add: #typeDef -&gt; case type; 			yourself]</body><body package="DST_Core">members: memberList 	"When setting the members attribute, the type member of the union 	member structure is ignored and should be set to TC_void. The type 	attribute is also updated."	self notYetImplemented</body></methods><methods><class-id>DST.DSTtypeUnion</class-id> <category>accessing</category><body package="DST_Core">allCaseValues	"Answer all case labels of the receiver"	| col |	col := OrderedCollection new.	cases do: [:case | col add: case discriminator value].	col remove: #default ifAbsent: [].	^col</body><body package="DST_Core">defaultIndex	defaultIndex == nil ifTrue: [defaultIndex := 0].	^defaultIndex</body><body package="DST_Core">defaultValue	"answer a computed value for the default case of the switchtype"	defaultValue == nil ifTrue: [		(defaultValue := switchtype valueExcept: self allCaseValues) == nil ifTrue: [self class marshallError: 1]].	^defaultValue</body><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	switchtype definedIn: aMetaObject.	cases		do: 			[:case | 			(case discriminator isMemberOf: DSTvalueNamed)				ifTrue: [case discriminator definedIn: switchtype].			case type definedIn: self]</body></methods><methods><class-id>DST.DSTtypeUnion</class-id> <category>printing</category><body package="DST_Core">definitionString	"return my unformatted IDL definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: 'union '; nextPutAll: name; nextPutAll: ' switch ('; nextPutAll: switchtype definitionString; nextPutAll: ') {'.	cases do: [:ca | ca printOn: aStream].	aStream nextPut: $}.	^aStream contents</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print my IDL definition on the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it 	is important that the first token of an IDL 'method' is parsed 	correctly by 	Parser. Specifically, it must be avoided that the pound sign is the 	first 	character in the method, since it would cause a parsing problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make 	sure that there is always at least one comment line. Also note, that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	self hasPragma ifTrue: [aStream tab: level; nextPutAll: '#pragma class '; nextPutAll: self printName; nextPutAll: ' '; nextPutAll: self localType; cr].	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[aStream nextPutAll: 'typedef '.			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body><body package="DST_Core">printFormattedOn: aStream indent: level style: aTextStyleName 	"print the detailed formatted definition of the receiver on 	aStream. To be overloaded by subclasses if formatting is 	actually required"	| unformatted intro |	unformatted := self definitionString.	(self		stringNeedsFormatting: unformatted		indent: level		style: aTextStyleName)		ifTrue: 			[intro := 'union ' , name , ' switch ('.			aStream nextPutAll: intro.			switchtype				printFormattedOn: aStream				indent: level + (self tabFor: intro style: aTextStyleName) + 1				style: aTextStyleName.			aStream nextPutAll: ') {'; cr.			1 to: cases size				do: 					[:idx | 					| case |					case := cases at: idx.					(idx &gt;= cases size or: [case type ~~ (cases at: idx + 1)])						ifTrue: [case								printFormattedOn: aStream								indent: level + 1								style: aTextStyleName]						ifFalse: 							[case printDiscriminatorOn: aStream indent: level.							aStream cr]].			aStream tab: level; nextPut: $}]		ifFalse: [aStream nextPutAll: unformatted]</body><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'union ' , self idlName</body></methods><methods><class-id>DST.DSTtypeUnion</class-id> <category>initialization</category><body package="DST_Core">name: aSymbol switch: switchType triples: anArray 	"initialize instance variables for a structure with given subtypes. 	The triples array contains a list of cases, where each triple is		(1:caseLabelValues 2:caseType 3:caseDeclarator)"	| oc |	name := aSymbol asSymbol.	switchtype := switchType.	oc := OrderedCollection new: anArray size.	anArray do: [:caseArray | (caseArray at: 1)			do: 				[:discrim | 				oc add: (DSTUnionCase						discriminator: discrim						type: (caseArray at: 2)						declarators: (Array with: (caseArray at: 3))).				discrim == #default ifTrue: [defaultIndex := oc size]]].	cases := oc asArray</body></methods><methods><class-id>DST.DSTtypeUnion</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^switchtype nonTrivialDeclarators asOrderedCollection , 		(cases 			inject: OrderedCollection new 			into: [:comps :case | 				comps , 					(Array with: (DSTvalue on: case discriminator asIDLString)) , 					case type nonTrivialDeclarators])</body></methods><methods><class-id>DST.ScopeBlock</class-id> <category>accessing</category><body package="DST_Core">container	^container</body><body package="DST_Core">container: aContainer 	container := aContainer</body><body package="DST_Core">pragmas	^pragmas</body><body package="DST_Core">prefix	^prefix</body><body package="DST_Core">prefix: aPrefix 	prefix := aPrefix</body></methods><methods><class-id>DST.ScopeBlock</class-id> <category>actions</category><body package="DST_Core">addPragma: aPragma 	pragmas addLast: aPragma</body></methods><methods><class-id>DST.ScopeBlock</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	prefix := IDLPrefix new.	container := nil.	pragmas := OrderedCollection new</body></methods><methods><class-id>DST.ScopeBlock class</class-id> <category>instance creation</category><body package="DST_Core">new	^super new initialize</body><body package="DST_Core">prefix: aPrefix container: aContainer 	| block |	block := self new.	block prefix: aPrefix.	block container: aContainer.	^block</body></methods><methods><class-id>DST.DSTRequestInterceptor</class-id> <category>intercepting</category><body package="DST_Core">clientInvokePostSend	"... intentionally null."</body><body package="DST_Core">clientInvokePostSend: aRequest context: anORBContext target: anObjRef operation: anOperation result: anObject	self clientInvokePostSend "for backward compatiblity only, override for new usage"</body><body package="DST_Core">clientInvokePreSend: aRequest context: anORBContext target: anObjRef operation: anOperation parameters: someParams	"... intentionally null."</body><body package="DST_Core">targetInvokePostReceive	"... intentionally null."</body><body package="DST_Core">targetInvokePostReceive: aRequest context: anORBContext target: anObjRef reply: aReply 	self targetInvokePostReceive "for backward compatiblity only, override for new usage"</body><body package="DST_Core">targetInvokePreReceive: aRequest context: anORBContext target: aReceiver parameters: someParams	"... intentionally null."</body></methods><methods><class-id>DST.DSTtypeWideCharacter</class-id> <category>Primitive Def</category><body package="DST_Core">kind	"return the receiver's primitive type"	^#pk_wchar</body></methods><methods><class-id>DST.DSTtypeWideCharacter</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	"canMarshall not = nextPutCharacter: raises exception"	aStream nextPutWideCharacter: aParameter</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^aStream nextWideCharacter</body></methods><methods><class-id>DST.DSTtypeWideCharacter</class-id> <category>initialization</category><body package="DST_Core">initialize	"initialize the receiver"	super initialize.	name := 'wchar'</body></methods><methods><class-id>DST.DSTtypeWideCharacter</class-id> <category>repository</category><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_wchar</body></methods><methods><class-id>DST.ORBContext</class-id> <category>accessing</category><body package="DST_Core">corbaContext	"answer the corbaContext of the reciever"	^corbaContext ifNil: [corbaContext := DSTUserContext new]</body><body package="DST_Core">corbaContext: aCORBAContext 	"set the corbaContext of the reciever"	corbaContext := aCORBAContext</body><body package="DST_Core">debuggerContext	"answer the distributed debugger context"	^serviceContexts at: self class distributedDebuggerId ifAbsent: [nil]</body><body package="DST_Core">debuggerContext: aDebuggerContext 	"set the distributed debugger context"	aDebuggerContext notNil		ifTrue: [self addServiceContext: aDebuggerContext]		ifFalse: [serviceContexts removeKey: self class distributedDebuggerId ifAbsent: []]</body><body package="DST_Core">local	"answer whether or not the context's origin is local to this image"	^local ifNil: [true]</body><body package="DST_Core">local: aBoolean 	"set whether or not the context's origin is local to this image"	local := aBoolean ~~ false</body><body package="DST_Core">replyServiceList	"answer the list of service contexts as an ordered collection"	^serviceContexts values</body><body package="DST_Core">requestServiceList	"answer the list of service contexts as an ordered collection"	^serviceContexts values</body><body package="DST_Core">securityContext	"answer the security service context"	^serviceContexts at: self class securityServiceId ifAbsent: [nil]</body><body package="DST_Core">securityContext: aSecurityContext 	"set the security service context"	aSecurityContext notNil		ifTrue: [self addServiceContext: aSecurityContext]		ifFalse: [serviceContexts removeKey: self class securityServiceId ifAbsent: []]</body><body package="DST_Core">serviceContextList	"answer the list of service contexts as an ordered collection"	^serviceContexts values</body></methods><methods><class-id>DST.ORBContext</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	serviceContexts := Dictionary new</body></methods><methods><class-id>DST.ORBContext</class-id> <category>adding-removing</category><body package="DST_Core">addServiceContext: aServiceContext 	"add the context to the list of service contexts"	(aServiceContext isKindOf: DSTServiceContext)		ifTrue: [serviceContexts at: aServiceContext contextId put: aServiceContext]		ifFalse: [ORBObject badContextError: 0]</body><body package="DST_Core">addServiceContexts: aCollection 	"add the collection of service contexts to the current service context 	list"	aCollection do: [:cxt | self addServiceContext: cxt]</body></methods><methods><class-id>DST.ORBContext class</class-id> <category>constants</category><body package="DST_Core">distributedDebuggerId	"answer the value of the Id for the dst debugger context"	^16r08108000</body><body package="DST_Core">securityServiceId	"answer the value of the Id for the dst security context"	^16r08108002</body></methods><methods><class-id>DST.ORBContext class</class-id> <category>instance creation</category><body package="DST_Core">new	"create an instance of the receiver"	^self basicNew initialize</body></methods><methods><class-id>DST.DSTcachedParameter</class-id> <category>accessing</category><body package="DST_Core">definedIn: aMetaObject 	"set the defining metaObject of the receiver"	definedIn := aMetaObject.	type definedIn: aMetaObject</body><body package="DST_Core">direction	^direction</body><body package="DST_Core">idlName		^[super idlName] on: Object errorSignal do: [:ex | name]</body><body package="DST_Core">name 	^name</body><body package="DST_Core">typeCodeInfo	^typeCodeInfo ifNil: [self class intfReposError: 0]</body></methods><methods><class-id>DST.DSTcachedParameter</class-id> <category>printing</category><body package="DST_Core">printName	^name</body><body package="DST_Core">printOn: aStream	"print the receiver's printname on the stream"	aStream nextPutAll: direction  , '  ' , name</body></methods><methods><class-id>DST.DSTcachedParameter</class-id> <category>private</category><body package="DST_Core">name: aName direction: aSymbol typeCodeInfo: aByteArray  	name := aName.	direction := aSymbol.	typeCodeInfo := aByteArray.	type := DSTMetaObject unMarshallTypeCode: Dictionary new from: (DSTTypeCodeStream with: aByteArray) reset</body></methods><methods><class-id>DST.DSTcachedParameter</class-id> <category>repository</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SharedIR::CachedParameter'</body></methods><methods><class-id>DST.DSTcachedParameter class</class-id> <category>instance creation</category><body package="DST_Core">name: aName direction: aSymbol typeCodeInfo: aByteArray	^(self new) name: aName direction: aSymbol typeCodeInfo: aByteArray; yourself</body></methods><methods><class-id>DST.DSTIDPragma</class-id> <category>actions</category><body package="DST_Core">applyTo: aMetaObject 	"set the repository id of the meta object from the pragma."	| msg |	(aMetaObject canApplyPragma: #ID)		ifTrue: [aMetaObject repositoryId: self repositoryId]		ifFalse: 			[msg := 'Id pragma not allowed on ' , aMetaObject displayString.			ORBDaemon configurationManager log: msg withCRs.			Dialog notify: msg]</body></methods><methods><class-id>DST.DSTIDPragma</class-id> <category>accessing</category><body package="DST_Core">repositoryId	^repositoryId</body><body package="DST_Core">repositoryId: aRepositoryId 	repositoryId := aRepositoryId</body></methods><methods><class-id>DST.DSTIDPragma</class-id> <category>printing</category><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: '#pragma ID ' , name , ' ' , repositoryId asString</body></methods><methods><class-id>DST.IIOPObjectKey</class-id> <category>testing</category><body package="DST_Core">isNilId	^false</body></methods><methods><class-id>DST.IIOPObjectKey</class-id> <category>accessing</category><body package="DST_Core">at: anInteger put: anObject 	"Provide an error notification that object keys cannot be	modified."	self errorNoModification</body></methods><methods><class-id>DST.IIOPObjectKey</class-id> <category>copying</category><body package="DST_Core">copy	"Answer the receiver, because object keys are unique."	^self</body><body package="DST_Core">shallowCopy	"Answer the receiver because object keys are unique."	^self</body></methods><methods><class-id>DST.IIOPObjectKey</class-id> <category>private</category><body package="DST_Core">errorNoModification	self error:  'symbols can not be modified.'</body></methods><methods><class-id>DST.IIOPObjectKey</class-id> <category>comparing</category><body package="DST_Core">= anObject 	"Answer whether the receiver and the argument are the same object 	(have the same object pointer)."	^self == anObject</body></methods><methods><class-id>DST.IIOPObjectKey</class-id> <category>repository</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can 	marshall an instance of the receiver."	^(DSTtypeSequence new) subtype: DSTtypeOctet new size: nil; localType: #ByteArray</body></methods><methods><class-id>DST.IIOPObjectKey class</class-id> <category>instance creation</category><body package="DST_Core">defaultImplementor	"Answer a class that usually represents repository ids."	^IIOPObjectKey</body><body package="DST_Core">fromString: aString 	"Alternate form of intern."	^self intern: aString</body><body package="DST_Core">intern: anObjectKey 	"Answer a unique IIOPObjectKey whose characters are those of 	anObjectKey."	| anId repId index table subTable subIndex |	anId := anObjectKey class == self				ifTrue: [anObjectKey]				ifFalse: [(self new: anObjectKey size)						replaceBytesFrom: 1						to: anObjectKey size						with: anObjectKey						startingAt: 1].	repId := self findInterned: anId.	repId notNil ifTrue: [^repId].	table := self table.	index := anId hash \\ table size + 1.	subTable := table at: index.	subIndex := subTable				indexOf: 0				replaceWith: anId				startingAt: 1				stoppingAt: subTable size.	subIndex = 0		ifTrue: 			[| newTable |			newTable := subTable class new: subTable size + 1.			newTable				replaceFrom: 1				to: subTable size				with: subTable.			newTable at: newTable size put: anId.			table at: index put: newTable].	^anId</body><body package="DST_Core">readFrom: aStream	"Create an object based on the contents of aStream."	| object |	object := self evaluatorClass evaluate: aStream.	(object isKindOf: self) ifFalse: [self error: self name, ' expected'].	^object</body><body package="DST_Core">tableSize	"Answer the number of DSTObjectKeys in the table."	| total |	self table isNil ifTrue: [^251].	total := 0.	self table do: [:bucket | total := total + bucket size].	^total</body></methods><methods><class-id>DST.IIOPObjectKey class</class-id> <category>accessing</category><body package="DST_Core">findInterned: anObjectKey 	"If anObjectKey has been interned (into a IIOPObjectKey), 	answer the IIOPObjectKey, otherwise answer nil."	| v idSize |	idSize := anObjectKey size.	v := self table at: anObjectKey hash \\ self table size + 1.	1 to: v size do: 		[:i | 		| test |		((test := v at: i) class == self and: [idSize = test size				and: 					[| match ii |					match := true.					ii := 0.					[match and: [(ii := ii + 1) &lt;= idSize]]						whileTrue: [(anObjectKey at: ii)								= (test at: ii) ifFalse: [match := false]].					match]])			ifTrue: [^test]].	^nil</body></methods><methods><class-id>DST.IIOPObjectKey class</class-id> <category>class initialization</category><body package="DST_Core">initialize	"initialize the class"	self rehash</body><body package="DST_Core">release	"release class variable"	ObjKeyTable := nil</body></methods><methods><class-id>DST.IIOPObjectKey class</class-id> <category>private</category><body package="DST_Core">rehash	"Rebuild the hash table that holds all the unique DSTObjectKeys."	"We want to keep the average number of probes for a lookup	constant; independent of the number of symbols.  Therefore,	when rehashing we adjust the number of buckets such that	we meet a target bucket size (e.g. objectkeys/buckets).	Choosing a target bucket size is a classic time/space tradeoff;	the value used here is 10, based on empirical tests."	| numBuckets |	"Set knows good hash moduli."	numBuckets := Set goodSizeFrom: (self tableSize / 10) rounded.	self table: ((1 to: numBuckets) collect: [:key | WeakArray with: 0]).	ObjectMemory garbageCollect.	self allInstancesDo: [:key | self intern: key].	"DSTObjectKey rehash"</body><body package="DST_Core">table	"return the table for DSTObjectKeys"	^ObjKeyTable</body><body package="DST_Core">table: newArray 	"set the table for DSTObjectKeys"	^ObjKeyTable := newArray</body></methods><methods><class-id>DST.ORBConstantsDictionary</class-id> <category>accessing</category><body package="DST_Core">at: aStringOrSymbol 	"Answer the value at key. If needed get the value from the 	Repository."	| index obj key |	exceptions == nil ifTrue: [self initializeStandardExceptions].	key := aStringOrSymbol asSymbol.	index := self findKeyOrNil: key.	^(self basicAt: index) == nil		ifTrue: 			[obj := ORBObject lookupConstantOrSignal: key.			obj isNil				ifTrue: [ORBObject intfReposError: 0]				ifFalse: [super at: key put: obj]]		ifFalse: [valueArray at: index]</body><body package="DST_Core">at: key ifAbsent: aBlock 	"Answer the value at key. If needed get the value from the 	Repository. If key is not found, answer the result of evaluating 	aBlock."	| index obj |	exceptions == nil ifTrue: [self initializeStandardExceptions].	index := self findKeyOrNil: key.	^(self basicAt: index)		== nil		ifTrue: 			[obj := [ORBObject lookupConstantOrSignal: key]						on: ORBObject intfReposSignal do: [:ex | (ex parameter at: #minor ifAbsent: [nil]								= 1)							ifTrue: [nil]							ifFalse: [ex reject]].			obj isNil				ifTrue: [aBlock value]				ifFalse: [super at: key put: obj]]		ifFalse: [valueArray at: index]</body><body package="DST_Core">indexForStandardException: anException 	"return a unique index for the standard exception"	exceptionIndex == nil ifTrue: [self initializeStandardExceptions].	^exceptionIndex indexOf: anException</body><body package="DST_Core">standardExceptionForIndex: anInteger 	"return the standard exception for the index"	exceptionIndex == nil ifTrue: [self initializeStandardExceptions].	^exceptionIndex at: anInteger</body><body package="DST_Core">standardExceptions	"return standard exceptions"	exceptions == nil ifTrue: [self initializeStandardExceptions].	^exceptions</body></methods><methods><class-id>DST.ORBConstantsDictionary</class-id> <category>private</category><body package="DST_Core">changeCapacityTo: newSize	"Change the number of elements of the collection.	Preserve the values of exceptions and exceptionIndexs	by saving them across the become."	| exs exidx |	exs := exceptions.	exidx := exceptionIndex.	super changeCapacityTo: newSize.	exceptions := exs.	exceptionIndex := exidx.</body></methods><methods><class-id>DST.ORBConstantsDictionary</class-id> <category>initialize-release</category><body package="DST_Core">initializeStandardExceptions	"initialize standard exceptions, communication failure minor codes, 	and invalid operation minor codes"	| memberArray ex prefix |	exceptions := IdentityDictionary new.	memberArray := Array with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #minor))					with: DSTtypeUnsignedLong new)				with: (Array with: (Array with: (DSTdeclaratorSimple new initialize: #completed))						with: (DSTtypeEnumeration new id: #completion_status values: #(#COMPLETED_YES #COMPLETED_NO #COMPLETED_MAYBE))).	prefix := 'IDL:omg.org/CORBA/'.	self class standardExceptionNames		do: 			[:exName | 			ex := DSTexception new id: exName members: memberArray.			exceptions at: exName put: ex.			self at: exName put: ex errorSignal.			ex repositoryId: (RepositoryId fromString: prefix , exName , ':1.0').			ORBObject addExceptionToCache: ex exceptionName: exName ].	exceptionIndex := exceptions asSortedCollection: [:a :b | a name &lt; b name].	self at: #M_PING_LIMIT_EXCEEDED put: 1.	self at: #M_REQUEST_LIMIT_EXCEEDED put: 2.	self at: #M_FRAGMENT_REQUEST_LIMIT_EXCEEDED put: 3.	self at: #M_IF_VERSION_MISMATCH put: 1</body></methods><methods><class-id>DST.ORBConstantsDictionary class</class-id> <category>class initialization</category><body package="DST_Core">initialize	"ORBConstantsDictionary initialize"	CORBAConstants := self new.</body></methods><methods><class-id>DST.ORBConstantsDictionary class</class-id> <category>instance creation</category><body package="DST_Core">new	"Create an instance - guess a good size."	^self new: (self standardExceptionNames size * 2)</body></methods><methods><class-id>DST.ORBConstantsDictionary class</class-id> <category>accessing</category><body package="DST_Core">rebuild	"Create a new CORBAConstants and pre-initialize it"	self initialize.	CORBAConstants initializeStandardExceptions.</body></methods><methods><class-id>DST.ORBConstantsDictionary class</class-id> <category>private</category><body package="DST_Core">standardExceptionNames	"return a an array of names for exceptions"	^#(UNKNOWN BAD_PARAM NO_MEMORY IMP_LIMIT  COMM_FAILURE INV_OBJREF NO_PERMISSION INTERNAL MARSHAL INITIALIZE NO_IMPLEMENT BAD_TYPECODE BAD_OPERATION NO_RESOURCES NO_RESPONSE PERSIST_STORE BAD_INV_ORDER TRANSIENT FREE_MEM INV_IDENT INV_FLAG INTF_REPOS BAD_CONTEXT OBJ_ADAPTER DATA_CONVERSION OBJECT_NOT_EXIST TRANSACTION_REQUIRED TRANSACTION_ROLLEDBACK INVALID_TRANSACTION INV_POLICY CODESET_INCOMPATIBLE)</body></methods><methods><class-id>DST.IIOPConfiguration</class-id> <category>accessing</category><body package="DST_Core">daemonName	"Class name of the daemon that handles this transport protocol."	^#IIOPDaemon</body><body package="DST_Core">defaultPort	"return the dst default iiop port"	^3460</body><body package="DST_Core">defaultWriteIncrement	"default to a smaller write increment size on windows 3.1 platform. Yuck!"	OSHandle currentPlatformID findString: 'win32s' startingAt: 1 ifAbsent: [^20480].	^1024</body><body package="DST_Core">onByDefault	"Is this transport turned on automatically on system build?"	^true</body><body package="DST_Core">writeIncrement	^(self settingFor: #writeIncrementKind) == #systemDefault		ifTrue: [self defaultWriteIncrement]		ifFalse: [self settingFor: #configuredWriteIncrementSize]</body></methods><methods><class-id>DST.IIOPConfiguration</class-id> <category>configuring</category><body package="DST_Core">configureTransportFor: aDaemon 	aDaemon configuredPortNo: self portNumber.	aDaemon configureWriteIncrementSize: self writeIncrement</body></methods><methods><class-id>DST.IIOPConfiguration</class-id> <category>private</category><body package="DST_Core">settings	"The user preference profile is a Dictionary full of value models 	hashed  against subject keys."	"If you change something here change the class comment which 	documents this."	settingDictionary == nil		ifTrue: 			[settingDictionary := IdentityDictionary new.			settingDictionary				at: #portNumberKind put: #configured asValue;				at: #configuredPortNumber put: self defaultPort asValue;				at: #writeIncrementKind put: #systemDefault asValue;				at: #configuredWriteIncrementSize put: self defaultWriteIncrement asValue;				at: #isI3On put: (ORBDaemon configurationManager isI3OnModel)].	^settingDictionary</body></methods><methods><class-id>DST.IIOPConfiguration class</class-id> <category>accessing</category><body package="DST_Core">configurationName	"Return a symbol identifying this configuration"	^#IIOP</body></methods><methods><class-id>DST.IIOPConfiguration class</class-id> <category>class initialization</category><body package="DST_Core">initialize	"add my self as new transport for configuration"	"self initialize"	self addTransport</body><body package="DST_Core">release	self removeTransport</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>accessing-transports</category><body package="DST_Core">chooseTransportNamed: transportName	self chosenTransports at: transportName asSymbol put: (self transportNamed: transportName).	self changed: #transports</body><body package="DST_Core">chosenTransports	chosenTransports == nil		ifTrue: 			[chosenTransports := IdentityDictionary new: self allTransports size.			self allTransports keysAndValuesDo: [:name :transport | transport onByDefault ifTrue: [chosenTransports at: name put: transport]]].	^chosenTransports</body><body package="DST_Core">isChosenTransportNamed: transportName 	"Is the transport named 'transportName' chosen?"	^self chosenTransports includesKey: transportName asSymbol</body><body package="DST_Core">primaryTransport	| chosen |	chosen := self chosenTransports.	chosen size = 0 ifTrue: [self error: 'no transport protocols selected - please select one'].	chosen size = 1 ifTrue: [^chosen values first].	^chosen detect: [:trans | trans onByDefault]		ifNone: [chosen values first]</body><body package="DST_Core">unchooseTransportNamed: transportName	self chosenTransports removeKey: transportName asSymbol ifAbsent: [].	self changed: #transports</body><body package="DST_Core">updateChosenTransports	"If the list of allTransports has changed (possibly	even been blasted away and reloaded), recompute	the chosen transports - using new instances for	those that exist and dropping any that nolonger	exist."	"ORBDaemon configurationManager updateChosenTransports"	chosenTransports == nil		ifFalse: 			[| newChosen |			newChosen := IdentityDictionary new: self allTransports size.			chosenTransports				keysAndValuesDo: 					[:name :transport | 					| newTrans |					newTrans := self allTransports at: name ifAbsent: [nil].					newTrans notNil ifTrue: [newChosen at: name put: newTrans]].			chosenTransports := newChosen]</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>accessing</category><body package="DST_Core">adapterId	"set the vpId and lookup the hostId"	| id objectAdapterIdKind |	objectAdapterIdKind := self  settingFor: #objectAdapterIdKind.	objectAdapterIdKind isNil		ifTrue: [self  log: '\Error initializing adapter Id. Configuration information invalid\' withCRs]		ifFalse: [objectAdapterIdKind == #dynamic				ifTrue: [id := NCSuuid newId]				ifFalse: [objectAdapterIdKind == #configured						ifTrue: [id := (self settingFor: #configuredAdapterId) asUUID]						ifFalse: [self  log: '\Error initializing adapter Id. Configuration information invalid\' withCRs]]].	id isNil ifTrue: [id := NCSuuid newId].	^id</body><body package="DST_Core">checkIfChangesAccepted	"Used in providing programmatic access to settings file load/save.	This message works out if any DSTSystemSettings tools that are 	being used to edit configurations at the moment have unaccepted 	changes.  Returns true if there are no unaccepted changes, false 	otherwise. "	| allChangesAccepted |	allChangesAccepted := true.	( #{DSTSystemSettings} isDefined ) 		ifTrue:	[ #{DSTSystemSettings} value allInstances do: 					[ :inst | inst requestSliceChange 								ifFalse: [ allChangesAccepted := false ]					]				].	^allChangesAccepted.</body><body package="DST_Core">debugging 	"return whether I am debugging message sends"	^self settingFor: #debuggingOn</body><body package="DST_Core">debugging: aBoolean 	"set whether I am debugging message sends"	self settingFor: #debuggingOn put: (aBoolean == true).</body><body package="DST_Core">debuggingValue	"return value model for whether I am debugging message sends"	^self settingModelFor: #debuggingOn</body><body package="DST_Core">loadFromFile: aFileNameString	"provides programtic access to settings file load/save	reads in configurations from the file whose name is aFileNameString"	| stream |	self checkIfChangesAccepted ifFalse: [^self].	stream := aFileNameString asFilename readStream.	[self readFrom: stream] ensure: [stream close].</body><body package="DST_Core">localRPCTesting	^self settingFor: #localRPCTestingOn</body><body package="DST_Core">localRPCTesting: aBoolean 	"turn on or off the testing of RPC interaction for local message sends 	involving my subclasses"	self settingFor: #localRPCTestingOn put: (aBoolean == true)</body><body package="DST_Core">localRPCTestingValue	^self settingModelFor: #localRPCTestingOn</body><body package="DST_Core">logTranscript	"return the logTranscript we are holding"	^logTranscript isNil		ifTrue: [Transcript]		ifFalse: [logTranscript]</body><body package="DST_Core">logTranscript: aTranscript 	"set the logTranscript we are holding"	logTranscript := aTranscript.	self changed: #logTranscript</body><body package="DST_Core">logging	"return the logging level we are holding"	^self settingFor: #loggingLevel</body><body package="DST_Core">logging: anInteger 	"return the logging level we are holding"	self settingFor: #loggingLevel put: anInteger</body><body package="DST_Core">loggingValue	"return the logging level we are holding"	^self settingModelFor: #loggingLevel</body><body package="DST_Core">saveToFile: aFileNameString	"Provides programtic access to settings file load/save	writes configurations to the file whose name is aFileNameString"	| stream |	self checkIfChangesAccepted ifFalse: [^self].	stream := aFileNameString asFilename writeStream.	[self writeTo: stream] ensure: [stream close].</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>private-change propagation</category><body package="DST_Core">adapterIdChanged	"the adapterId has changed, set the resetAdapterId  to true since 	the configuration modification will take effect at system startup"	resetAdapterId := true.	self changed: #adapterId</body><body package="DST_Core">adapterIdKindChanged	"the adapterId has changed, set the resetAdapterId  to true since 	the configuration modification will take effect at system startup"	resetAdapterId := true.	self changed: #adapterIdKind</body><body package="DST_Core">debuggingChanged	(self settingFor: #debuggingOn)		ifFalse: 			[| acp |			Processor activeProcess orbContext debuggerContext: nil.			acp := ScheduledControllers activeControllerProcess.			acp notNil ifTrue: [acp orbContext debuggerContext: nil]].	self changed: #debugging</body><body package="DST_Core">localRPCTestingChanged	self changed: #localRPCTesting</body><body package="DST_Core">loggingChanged	self changed: #logging</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>logging</category><body package="DST_Core">log: theMessage 	"Log to the logTranscript"	(self logTranscript) nextPutAll: theMessage; flush</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>accessing - I3</category><body package="DST_Core">changedI3	self changed: #transports</body><body package="DST_Core">isI3On	^self settingFor: #isI3On</body><body package="DST_Core">isI3On: aBoolean	self settingFor: #isI3On put: aBoolean.</body><body package="DST_Core">isI3OnModel	^self settingModelFor: #isI3On</body><body package="DST_Core">turnOffI3While: aBlock 	"Turn off the Implict Invocation Interface for the duration of aBlock. 	Make sure it is returned to its previous state afterwards."	"Note: due to the multi-threaded nature of the system it is possible	that other calls may sneak in while I3 is off."	| mdl prev |	mdl := self settingModelFor: #isI3On.	prev := mdl value.	mdl setValue: false.	^aBlock ensure: [mdl setValue: prev]</body><body package="DST_Core">turnOnI3While: aBlock 	"Turn on the Implict Invocation Interface for the duration of aBlock. 	Make sure it is returned to its previous state afterwards."	"Note: due to the multi-threaded nature of the system it is possible	that other calls may sneak in while I3 is on."	| mdl prev |	mdl := self settingModelFor: #isI3On.	prev := mdl value.	mdl setValue: true.	^aBlock ensure: [mdl setValue: prev]</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>configuring</category><body package="DST_Core">configureSystemAtStartup	"this method is called by the startup coordinator to configure the 	system if necessary at startup"	resetAdapterId		ifTrue: 			[ORBDaemon initializeVPId.			resetAdapterId := false].	(self allServices asSortedCollection: [:ser1 :ser2 | "Configure the services in the order of their priorities"		ser1 orderOfConfiguration &lt;= ser2 orderOfConfiguration])		do: [:service | [service configure]				on: self errorSignal do: [:x | self log: ('\Error: Configuration of ' , service serviceName , ' failed\') withCRs]]</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>private</category><body package="DST_Core">settings	"The user preference profile is a Dictionary full of value models hashed	against subject keys."	"If you change something here change the class comment which documents this."	settingDictionary == nil ifTrue: [		| adapterId |		adapterId := '6f6ad0b9-5b6a-0000-020f-1c680a000000'.		settingDictionary := IdentityDictionary new.		settingDictionary			at: #objectAdapterIdKind put: (#dynamic asValue onChangeSend: #adapterIdKindChanged to: self);			at: #configuredAdapterId put: (adapterId asValue onChangeSend: #adapterIdChanged to: self);			at: #loggingLevel put: (0 asValue onChangeSend: #loggingChanged to: self);			at: #debuggingOn put: (false asValue onChangeSend: #debuggingChanged to: self);			at: #localRPCTestingOn put: (false asValue onChangeSend: #localRPCTestingChanged to: self);			at: #isI3On put: (false asValue onChangeSend: #changedI3 to: self)].	^settingDictionary</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>settings tool access only</category><body package="DST_Core">configurationOf: configSymbol	configSymbol == #DST ifTrue: [^self].	^self allTransports at: configSymbol ifAbsent: [self allServices at: configSymbol ifAbsent: [nil]]</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>private-read/write</category><body package="DST_Core">readSectionIdFrom: strm 	| idStrm ch id |	idStrm := WriteStream on: String new.		ch := strm next.	ch = $[ ifFalse: [Object errorSignal raiseWith: 'expected "[" got "', (String with: ch), '"'].	[ch := strm next.	strm skipSeparators.	(ch = $] or: [ch = nil or: [ch isSeparator]])		ifTrue: [true]		ifFalse: 			[idStrm nextPut: ch.			false]] whileFalse.	id := idStrm contents.	id size = 0 ifTrue: [Object errorSignal raiseWith: 'empty id'].	[ch = Character space | (ch = Character tab)]		whileTrue: [ch := strm next].	ch = $] ifFalse: [Object errorSignal raiseWith: 'expected "]" after reading section id: ' , id printString].	^id</body><body package="DST_Core">writeConfiguration: sectionId to: strm 	strm nextPut: $[.	strm nextPutAll: sectionId.	strm nextPut: $].	self lineEnd: strm. 	(self configurationOf: sectionId)		writeConfigurationTo: strm</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>public-read/write</category><body package="DST_Core">readFrom: strm	"Read section by section, don't change buffered values	until whole file is complete without errors."	| triggerChannel |	triggerChannel := false asValue.	[self skipSeparators: strm.	strm atEnd]		whileFalse: 			[| id conf |			id := self readSectionIdFrom: strm.			conf := self configurationOf: id asSymbol.			conf == nil ifTrue: [Object errorSignal raiseWith: 'Invalid section id'].			conf readFrom: strm triggeredBy:  triggerChannel].	triggerChannel value: true.</body><body package="DST_Core">writeTo: strm	self allTransports keys asSortedCollection do: [:sectionId | self writeConfiguration: sectionId to: strm].	self allServices keys asSortedCollection do: [:sectionId | self writeConfiguration: sectionId to: strm].	self writeConfiguration: #DST to: strm</body></methods><methods><class-id>DST.ORBConfigurationManager</class-id> <category>initialize-release</category><body package="DST_Core">initialize	"initialize the receiver"	"ORBDaemon configurationManager initialize." "(close all settings tools &amp; ORB control panels first)"	resetAdapterId := false.	super initialize.</body></methods><methods><class-id>DST.ORBConfigurationManager class</class-id> <category>development</category><body package="DST_Core">zap	"Hack, for when implementation changes - development only"	"evaluate below""	Services := nil.	DSTServiceConfiguration allSubclasses do: [:svc | svc initialize].	Transports := nil.	DSTTransportConfiguration allSubclasses do: [:trans | trans initialize].	ORBDaemon classPool at: #ConfigurationManager put: nil"</body></methods><methods><class-id>DST.DSTtypeStructure</class-id> <category>accessing</category><body package="DST_Core">allFields	"Return an ordered collection of all my fields."	^allFields == nil		ifTrue: [allFields := fields inject: OrderedCollection new into: [:comps :mo | comps , mo declarators]]		ifFalse: [allFields]</body><body package="DST_Core">computeSelectors	"re compute my selector caches"	| sel |	selector := ''.	readSelectors := OrderedCollection new.	writeSelectors := OrderedCollection new.	self allFields		do: 			[:fld | 			sel := fld convertedName.			readSelectors add: sel.			sel := sel asString , ':'.			writeSelectors add: sel asSymbol.			selector := selector , sel].	selector := selector asSymbol</body><body package="DST_Core">definedIn: aMetaObject 	"set the receiver's defining container meta object"	super definedIn: aMetaObject.	fields do: [:ty | ty definedIn: self].</body><body package="DST_Core">fields	"return the list of fields"	^fields</body><body package="DST_Core">readSelectors	"Return an ordered collection of read selectors on my fields."	readSelectors == nil ifTrue: [self computeSelectors].	^readSelectors</body><body package="DST_Core">resolveLocalTypesIn: aType 	"Called by typeAny to get any local type symbols which relate to the 	receiver in its scope. Find the receiver's typename in the 	context of the given type. If so, copy its localType to the receiver" 	| mo |  	mo := aType typeOf: name asSymbol.	mo notNil ifTrue: [self localType: mo localType].	fields do: [:fld | fld resolveLocalTypesIn: aType]</body><body package="DST_Core">selector	"Return an ordered collection of all my fields."	selector == nil ifTrue: [self computeSelectors].	^selector</body><body package="DST_Core">useClassMethod	"return if the class method is to be used"	useClassMethod == nil ifTrue: [useClassMethod := self localClass respondsTo: self selector].	^useClassMethod</body><body package="DST_Core">useCombinedmethod	"return if the combined instance method is to be used"	useCombinedmethod == nil ifTrue: [useCombinedmethod := self localClass new respondsTo: self selector].	^useCombinedmethod</body><body package="DST_Core">writeSelectors	"Return an ordered collection of write selectors on my fields."	writeSelectors == nil ifTrue: [self computeSelectors].	^writeSelectors</body></methods><methods><class-id>DST.DSTtypeStructure</class-id> <category>repository</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::StructDef'</body><body package="DST_Core">allMetaObjectsInto: aSet	"add all of the contained metaobjects to the set" 	super allMetaObjectsInto: aSet.	fields do: [:s | s allMetaObjectsInto: aSet]</body><body package="DST_Core">canApplyPragma: pragma 	"Check to see if the argument pragma can be applied to the receiver."	^#(#CLASS) includes: pragma</body><body package="DST_Core">defKind        "Return the definition kind."        ^#dk_Struct</body><body package="DST_Core">lookupName: aSymbol levels: anInt limit: limitType excludeInherited: bool 	"Modified version of DSTMetaContainer's routine. Used to lookup 	definitions within a structure."	self allFields do: [:f | f name == aSymbol ifTrue: [^Set with: f]].	^#()</body><body package="DST_Core">typeKind	"return the TCKind of the receiver"	^#tk_struct</body><body package="DST_Core">typeParamCount	"return the number of parameters which the receiver supports. 	Subtypes should overload as required"	^self allFields size * 2 + 1</body><body package="DST_Core">typeParameter: anInt 	"return the nth parameter which the receiver supports. 	Subtypes should overload as required"	| f |	anInt = 1 ifTrue: [^self printName].	(anInt between: 2 and: self typeParamCount)		ifTrue: 			[f := self allFields at: (anInt - 2 // 2) + 1.			anInt - 2 \\ 2 = 0				ifTrue: [^f printName asString]				ifFalse: [^f]].	self error: #Bounds</body></methods><methods><class-id>DST.DSTtypeStructure</class-id> <category>marshalling</category><body package="DST_Core">boldMarshall: aParameter on: aStream 	"Marshall the parameter onto the stream"	self		boldMarshall: aParameter		on: aStream		withLocalClass: self localClass</body><body package="DST_Core">boldMarshall: aParameter on: aStream withLocalClass: aClass 	"Marshall the parameter onto the stream. Subclasses must overload. 	(Modified to use Dictionary access)"	"canMarshall = dictionary has those elements 		or class responds to to those messages"	| i |	aClass isNil		ifTrue: 			[i := 0.			self allFields do: [:fld | fld boldMarshall: (aParameter at: (self readSelectors at: (i := i + 1)))					on: aStream]]		ifFalse: 			[i := 0.			self allFields do: [:fld | fld boldMarshall: (aParameter perform: (self readSelectors at: (i := i + 1)))					on: aStream]]</body><body package="DST_Core">marshallMatch: aParameter 	"Return:		true			- if I can marshall the parameter		false		- if I can NOT marshall the parameter		#mappable	- if I can marshall the parameter by mapping to something else"		^self localClass == nil		ifTrue: 			[(aParameter isDictionary)				ifFalse: [^false].			1 to: self readSelectors size do: [:idx | aParameter at: (self readSelectors at: idx)					ifAbsent: [^false]].			true]		ifFalse: [aParameter isKindOf: self localClass]</body><body package="DST_Core">marshallTypeCode: aDictionary on: aStream 	"marshall the type code of the receiver"	| flds pos |	(self tryMarshallIndirectTypeCode: aDictionary on: aStream)		ifTrue: [^self].	flds := self allFields.	aStream nextPutUnsignedLong: self typeCode.	pos := aStream nextPutEncapsulationHeader.	aStream nextPutString: self repositoryId; nextPutString: self printName.	aStream nextPutLocalType: self localType; nextPutUnsignedLong: flds size.	flds		do: 			[:f | 			aStream nextPutString: f printName.			f marshallTypeCode: aDictionary on: aStream].	aStream setEncapsulationLength: pos</body><body package="DST_Core">unMarshall: aStream 	"Unmarshall a result from the stream and return an object of the 	appropriate class."	^self unMarshall: aStream withLocalClass: self localClass</body><body package="DST_Core">unMarshall: aStream withLocalClass: aClass	"Unmarshall a result from the stream and return an object of the 	appropriate class."	| result values |	values := self allFields collect: [:fld | fld unMarshall: aStream].	aClass notNil		ifTrue: [(aClass respondsTo: self selector)				ifTrue: [result := aClass perform: selector withArguments: values asArray]				ifFalse: [result := aClass new.						(result respondsTo: self selector)						ifTrue: [result perform: selector withArguments: values asArray]						ifFalse: 							[self writeSelectors do: [:sel | result perform: sel with: values removeFirst]]]]		ifFalse: 			[result := Dictionary new.			self readSelectors do: [:key | result at: key put: values removeFirst]].	^result</body><body package="DST_Core">unMarshallTypeCode: aDictionary from: aStream 	"unmarshall the type code of the receiver"	| mo sz n field byteOrder locType |	aDictionary add: aStream position -&gt; self.	aStream nextUnsignedLong.	byteOrder := aStream byteOrder.	aStream byteOrder: aStream nextBoolean.	repositoryId := aStream nextString.	repositoryId isEmpty ifFalse: [repositoryId := RepositoryId fromString: repositoryId].	name := aStream nextString.	locType := aStream nextLocalType.	sz := aStream nextUnsignedLong.	(repositoryId notEmpty and: [ aStream notReadingFromRemoteIR ]) 		"We have to make sure that we don't do this in case of reading a typecode from remote IR,		otherwise we'll have an infinite recursion, more detail can be found in AR#49408"		ifTrue: [mo := ORBObject lookupMetaId: repositoryId].	(name isEmpty and: [mo notNil]) ifTrue: [name := mo name].	fields := (1 to: sz)				collect: 					[:f | 					n := aStream nextString.					(n isEmpty and: [mo notNil]) ifTrue: [n := (mo allFields at: f) name].					field := self class unMarshallTypeCode: aDictionary from: aStream.					field definedIn: self.					(field isDSTinterface)						ifTrue: 							[field initialize: n.							field]						ifFalse: 							[field declarators: (Array with: (DSTdeclaratorSimple new initialize: n)).							field]].	locType isNil		ifTrue: [mo isNil ifFalse: [mo localType isNil ifFalse: [self localType: mo localType]]]		ifFalse: [self localType: locType].	aStream byteOrder: byteOrder</body></methods><methods><class-id>DST.DSTtypeStructure</class-id> <category>initialization</category><body package="DST_Core">id: aSymbol fields: fieldarray 	"initialize a new instance"	| field decls |	name := aSymbol asSymbol.	fields := OrderedCollection new. 	fieldarray do: [:f| 		field := f at: 2.		decls := f at: 1.		field declarators: decls.		fields add: field]</body><body package="DST_Core">reInitialize	"reinitialize the receiver. Zap my caches"	super reInitialize.	useClassMethod := useCombinedmethod := selector := readSelectors := writeSelectors := nil.</body></methods><methods><class-id>DST.DSTtypeStructure</class-id> <category>StructDef</category><body package="DST_Core">description	"return a structure description"	|d|	d:= (Dictionary new) 		add: #name -&gt; name; 		add: #id -&gt; self id; 		add: #definedIn -&gt; self definedInString; 		add: #version -&gt; self version; 		add: #type -&gt; self;		yourself.	d overrideCORBAType: (ORBObject lookupMetaId: #'::CORBA::TypeDescription').	^d</body><body package="DST_Core">members	"The members attribute contains a description of each structure 	member."	^self allFields collect: [:field | (Dictionary new) add: #name -&gt; field name; add: #type -&gt; field equivalentType; add: #typeDef -&gt; field equivalentType; yourself]</body><body package="DST_Core">members: memberList 	"Setting the members attribute also updates the type attribute. When 	setting the members attribute, the type member of the 	StructMember structure is ignored and should be set to TC_void."	self notYetImplemented</body></methods><methods><class-id>DST.DSTtypeStructure</class-id> <category>printing</category><body package="DST_Core">definitionString	"return my unformatted IDL definition string"	| aStream |	aStream := (String new: 80) writeStream.	aStream nextPutAll: 'struct  '; nextPutAll: name; nextPutAll: ' {'.	fields do: [:fld | aStream nextPutAll: fld definitionString; nextPut: $ ; nextPutAll: fld declaratorString; nextPutAll: '; '].	aStream nextPut: $}.	^aStream contents</body><body package="DST_Core">printDefinitionOn: aStream indent: level style: aTextStyleName 	"Print my IDL definition on the stream."	"Since the default Parser class is used to parse the selector of IDL 	units, it 	is important that the first token of an IDL 'method' is parsed 	correctly by 	Parser. Specifically, it must be avoided that the pound sign is the 	first 	character in the method, since it would cause a parsing problem. 	Therefore we show pragmas AFTER the comment lines and we also 	make 	sure that there is always at least one comment line. Also note, that 	senders of Parser&gt;&gt;parseSelector: (such as 	Text&gt;&gt;makeSelectorBoldIn:) 	assume that the selector starts at position 1 of the method source."	self printHeaderOn: aStream indent: level.	prefix isNil ifFalse: [CurrentPrefix ~= prefix prefixString			ifTrue: 				[aStream tab: level; nextPutAll: '#pragma  prefix '; nextPut: $"; nextPutAll: prefix prefixString; nextPut: $"; cr.				CurrentPrefix := prefix prefixString]].	self hasPragma ifTrue: [aStream tab: level; nextPutAll: '#pragma class '; nextPutAll: self printName; nextPutAll: ' '; nextPutAll: self localType; cr].	aStream tab: level.	declarators isNil		ifTrue: 			[self				printFormattedOn: aStream				indent: level				style: aTextStyleName.			aStream nextPutAll: ';'; cr]		ifFalse: 			[aStream nextPutAll: 'typedef '.			self				printFormattedOn: aStream				indent: level + (self tabFor: 'typedef ' style: aTextStyleName)				style: aTextStyleName.			aStream nextPut: $ ; nextPutAll: self declaratorString; nextPut: $;; cr]</body><body package="DST_Core">printFormattedOn: aStream indent: level style: aTextStyleName 	"print the detailed formatted definition of the receiver on 	aStream. To be overloaded by subclasses if formatting is 	actually required"	| unformatted |	unformatted := self definitionString.	(self		stringNeedsFormatting: unformatted		indent: level		style: aTextStyleName)		ifTrue: 			[aStream nextPutAll: 'struct '; nextPutAll: name; nextPutAll: ' {'; cr.			fields				do: 					[:fld | 					aStream tab: level + 1.					fld						printFormattedOn: aStream						indent: level + 1						style: aTextStyleName.					aStream nextPut: $ ; nextPutAll: fld declaratorString; nextPut: $;; cr].			aStream tab: level; nextPut: $}]		ifFalse: [aStream nextPutAll: unformatted]</body><body package="DST_Core">printOn: aStream 	"print the receiver's printname on the stream"	aStream nextPutAll: 'struct ' , self idlName</body></methods><methods><class-id>DST.DSTtypeStructure</class-id> <category>rendering</category><body package="DST_Core">allComponents	"Return an ordered collection of all my component meta objects."	^fields inject: OrderedCollection new into: [:comps :mo | comps , mo nonTrivialDeclarators]</body><body package="DST_Core">hasComponents	"return true iff I have components worthwhile to show in a browser 	window"	^fields isEmpty not</body></methods><methods><class-id>DST.DSTtypeStructure class</class-id> <category>creation</category><body package="DST_Core">on: aFieldArray 	"create a structure metaobject with the given fields"	|  | 	^self new id: 'exception' 		fields: aFieldArray</body></methods><methods><class-id>Core.Double</class-id> <category>converting</category><body package="DST_Core">asDSTLongDouble	"1.2333d halt; asDSTLongDouble"	| longDouble |	longDouble := DSTLongDouble new.	longDouble basicAt: 1 put: (self basicAt: 1).	longDouble basicAt: 2 put: ((self basicAt: 2) bitAnd: 240).	3 to: 8 do: [:i | 		longDouble			basicAt: i 			put: ((((self basicAt: i-1) bitAnd: 15) bitShift: 4) bitOr: 				(((self basicAt: i) bitAnd: 240) bitShift: -4))].	longDouble basicAt: 9 put: (((self basicAt: 8) bitAnd: 15) bitShift: 4).	" Used to debug it:	dstream := WriteStream on: (String new: 8).	ldstream := WriteStream on: (String new: 16).	1 to: 8  do: [:i | dstream nextPutAll: (self basicAt: i) asHex; space].	1 to: 16 do: [:j | ldstream nextPutAll: (longDouble basicAt: j) asHex; space].	"	^longDouble.</body></methods><methods><class-id>Core.Double</class-id> <category>DST</category><body package="DST_Core">asIDLString	"return an IDL format string representation of the receiver"	| str |	str := self printString.	^str copyFrom: 1 to: str size - 1</body><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^DSTtypeDouble new</body></methods><methods><class-id>UI.Dialog class</class-id> <category>DST</category><body package="DST_Core">notify: messageString 	"Present the message string to the user. Continue processing 	when the user selects the 'Proceed' button. Open a debugger if 	requested. 	The messageString is presented in several lines in the dialog box, if the 	string would be unreasonably long for a one-line dialog."	"self notify: 'Beware, this is an error'."	"self notify: 'This notification warning should not be presented as one long 	line in a even wider dialog box'."	| words msg len |	"(Delay forMilliseconds: 100) wait."	words := messageString asOrderedCollectionOfSubstrings.	msg := words isEmpty ifTrue: [String new] ifFalse: [words first].	len := msg size.	(2 to: words size) do: [:i | 			len := len + (words at: i) size + 1.			msg := msg , (len &lt; 70							ifTrue: [' ']							ifFalse: 								[len := (words at: i) size.								'\']) , (words at: i)].	^(self dialogSupplier		choose: msg withCRs		labels: (Array with: 'Proceed' with: 'Abort')		values: #(#yes #no)		default: #yes	) == #yes		ifTrue: [ true ]		ifFalse: [ self error: messageString. false ]</body><body package="DST_Core">notify: messageString exception: anException 	"Notify the user about anException. Format the information in the exception 	and include it in the dialog. Continue processing when the user selects 	the 'Proceed' button. Open a debugger if requested."	| msg parm |	msg := String new writeStream.	msg nextPutAll: messageString.	messageString last = $: ifFalse: [msg nextPut: $:].	msg space; nextPutAll: anException signal errorString.	parm := anException parameter.	parm notNil ifTrue: [(parm isKindOf: OrderedCollection)			| (parm isKindOf: Array)			ifTrue: ["struct of exception"				parm do: [:field | msg space; nextPutAll: field printString]]			ifFalse: [msg space; nextPutAll: parm printString]].	self notify: msg contents</body><body package="DST_Core">onDebugNotify: messageString 	"Write the message to the Transcript. If ORBObject daemon 	debugging, then open a notifier"	"self onDebugNotify: 'You may want to check this'"	ORBObject daemon debugging ifTrue: [		Transcript show: '*** ' , messageString; cr.		self notify: messageString ]</body><body package="DST_Core">requestChoose: messageString initialAnswer: aString labels: labels values: values default: defaultValue equalize: eqBoolean onHelp: helpBlock 	"Ask the user a question. Provide aString as initial content of the input 	field. Let the user pick from a row of buttons made up to match the labels 	collection. Return an association: The key is the response from the 	corresponding item from the values collection, and the value is the 	content of the input field. If eqBoolean is true, the buttons will be equal in 	width. The button for the special value #help will just execute the 	helpBlock (if not nil)"	"self 	requestChoose: 'Enter your\(valued)\response:' withCRs 	initialAnswer: 'Hi there!' 	labels: (Array with: 'absolutely' with: 'sort of' with: 'not really') 	values: #(#yes #help #no) 	default: #help 	equalize: true 	onHelp: nil. 	self 	requestChoose: 'Enter another response:' initialAnswer: 'Hi there!' 	labels: (Array with: 'definitely' with: 'sort of no' with: 'sort of yes' with: 	'nope') 	values: #(#yes #maybeNo #help #no) 	default: #no 	equalize: false 	onHelp: [Transcript show: 'This is help';cr]"	^self dialogSupplier		requestChoose: messageString		initialAnswer: aString		labels: labels		values: values		default: defaultValue		equalize: eqBoolean		onHelp: helpBlock</body><body package="DST_Core">requestHost: aString 	"Ask the user for a valid host by name or IP address using aString as the 	initial prompt. Return an Association instance with the host name as key 	and its IP address as value. Return nil if the user cancels the request."	"self requestHost: 'Enter a host name:'"	| host nodeId |	(host := self request: aString initialAnswer: ORBObject hostName) isEmpty ifTrue: [^nil].	host = ORBObject hostName		ifTrue: [nodeId := ORBObject hostId]		ifFalse: [[(nodeId := Object errorSignal handle: [:x | nil]						do: [IPSocketAddress hostAddressByNameOrAddressString: host]) isNil]				whileTrue: [(host := self request: ('Please enter a valid name \or address for the host.\\' , aString) withCRs initialAnswer: host) isEmpty ifTrue: [^nil]]].	^host -&gt; nodeId</body></methods><methods><class-id>Core.Set</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Set'</body></methods><methods><class-id>Core.Set</class-id> <category>parcel support</category><body package="DST_Core">postReadGeneralStructureOn: aBinaryStorageReader	"Since basic size may change when parceled in."	self rehash.</body></methods><methods><class-id>Core.Signal</class-id> <category>DST</category><body package="DST_Core">corbaHandle: handlerBlock do: doBlock 	"standard wrapper as required by the IDL Smalltalk Language Mapping for 	exception handling"	^self handle: handlerBlock do: doBlock</body><body package="DST_Core">corbaRaise	"standard wrapper as required by the IDL Smalltalk Language 	Mapping for raising exceptions"	^self raiseWith: #()</body><body package="DST_Core">corbaRaiseWith: aDictionary 	"standard wrapper as required by the IDL Smalltalk Language 	Mapping for raising exceptions with exception values"	^self raiseWith: aDictionary</body><body package="DST_Core">corbaRaiseWith: aDictionary errorString: aString 	"standard wrapper as required by the IDL Smalltalk Language 	Mapping for raising exceptions with exception values"	^self raiseWith: aDictionary errorString: aString</body></methods><methods><class-id>Core.Stream</class-id> <category>DST</category><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'SmalltalkTypes::Stream'</body></methods><methods><class-id>Core.Object</class-id> <category>DST</category><body package="DST_Core">abstractClassId	"return the abstract class UUID of my factory"	self subclassResponsibility</body><body package="DST_Core">acl	"return the access control list of the receiver"	(self respondsTo: #accessControlList)		ifTrue: [^self accessControlList]		ifFalse: [^(CORBAConstants at: #'::Security::NotSupported')				raiseWith: Dictionary new errorString: ' this object does not support access control']</body><body package="DST_Core">ACL	"return the ACL of the receiver"  	^self abstractClassId</body><body package="DST_Core">adapterId	"Answer the value of aId."	^ORBDaemon adapterId</body><body package="DST_Core">addAccess: aCollection user: aUserId 	"add access rights for a user"	| acl accessRights |	(self respondsTo: #accessControlList)		ifTrue: [((aCollection isKindOf: Collection)				and: [(aUserId isKindOf: Symbol)						or: [aUserId isKindOf: NCSuuid]])				ifTrue: 					[((acl := self accessControlList) isKindOf: IdentityDictionary)						ifFalse: [ORBObject internalError: 0].					accessRights := self accessControlList at: aUserId ifAbsent: [nil].					accessRights isNil						ifTrue: 							[accessRights := IdentitySet new.							acl at: aUserId put: accessRights].					aCollection do: [:sym | accessRights add: sym].					self changed: #accessControlList]				ifFalse: [self class badParamError: 0]]		ifFalse: [^(CORBAConstants at: #'::Security::NotSupported')				raiseWith: Dictionary new errorString: ' this object does not support access control']</body><body package="DST_Core">asCORBANamedValue: aString flags: aCollection</body><body package="DST_Core">asCORBAParameter	"Answer an object that confomrs to the CORBAParameter protocol as 	required by the IDL Smalltalk Language Mapping"	^ValueHolder with: self</body><body package="DST_Core">asCORBAUnion: aDiscriminator 	"Answer an object that confomrs to the CORBAUnion protocol as 	required by the IDL Smalltalk Language Mapping"	^DSTUnion discriminator: aDiscriminator value: self</body><body package="DST_Core">asIDLString	^self asString</body><body package="DST_Core">asInactiveObjRef	"return a persistent object reference to the receiver which is == to 	that returned by previous calls on this method"	^DSTObjRefInactive findOrCreateOn: self</body><body package="DST_Core">asLocal	"return the receiver"	^self</body><body package="DST_Core">asLocalObjRef	"return a local object reference to the receiver which is == to 	that returned by previous calls on this method"	^DSTObjRefLocal findOrCreateOn: self</body><body package="DST_Core">asRemotable	"return a LocalPersistentObjRef if TestRPC is on, else self. This allows 	developers to note places in their code where remote accesses are 	likely to occur, and then use the RPC mechanism to test interface 	correctness in a local-only execution environment. With TestRPC off, 	Smalltalk objRefs are used for the receiver directly with no 	performance penalties."	ORBDaemon testRPC ifTrue: [^self asLocalObjRef]</body><body package="DST_Core">asString	^self printString</body><body package="DST_Core">asText	^self asString asText</body><body package="DST_Core">classObject	"Answer the class object of the receiver"	^self class</body><body package="DST_Core">CORBAInterface	"return an instance of the DSTinterface which defines the behavior of the 	receiver when passed as a CORBA object. This must be a local repository 	object"	^ORBObject lookupMetaId: self CORBAName asSymbol</body><body package="DST_Core">CORBAName	"return the CORBA name of the receiver's IDL definition in the local 	repository"	^#'::SmalltalkSpecific::SmalltalkObject'</body><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter. The returned 	object must be local"	^ORBObject lookupMetaId: self CORBAName asSymbol</body><body package="DST_Core">createRequestIn: context selector: symbol withArguments: aNVList result: aNamedValue flags: int 	"This operation is used to create a dynamic request on the receiver"	^Dictionary		with: #result -&gt; aNamedValue		with: #request -&gt; (ORBRequest new				objref: self				context: context				operation: symbol				arguments: aNVList				result: aNamedValue				flags: int)		with: #Result -&gt; 0</body><body package="DST_Core">databaseIdentifier	^self objectId printString</body><body package="DST_Core">doItValue: result	"ignore by default"	^self</body><body package="DST_Core">duplicate	"defined in CORBA::Object PIDL. Note that this is not a lifecycle operation. It 	is necessary so systems that do not support garbage collection and only 	here for completeness. Just return myself"   	^self</body><body package="DST_Core">getImplementation	"return the ImplementationDef of the receiver (its class object)"	^self class</body><body package="DST_Core">getInterface	"CORBA required. Return the InterfaceDef of the receiver, which may 	be local or remote depending upon the location of the object. For 	local objects, we return a local repository object"	^ORBObject repository lookup: self CORBAName</body><body package="DST_Core">getMemoryUtilization	"return memory utilization information"	| info |	ObjectMemory globalCompactingGC.	info := ObjectMemory dynamicallyAllocatedFootprint.	^Dictionary		with: #dynamicFootPrint -&gt; info		with: #freeBytes -&gt; ObjectMemory current availableFreeBytes</body><body package="DST_Core">hash: upperBound 	"operation on CORBA psuedo Object to hash an object with an upper 	maximum bound (we ignore the bound)"	^self hash</body><body package="DST_Core">interoperableObjRefProfiles	"return a sequence of a tagged profiles for the given object"	^ORBDaemon interoperableObjRefProfilesFor: self	"The MC profile is needed for the object id lookup"	"^ORBDaemon leanInteroperableObjRefProfileFor: self"</body><body package="DST_Core">isA: interfaceIdString 	"isA returns TRUE if the receiver is identical to or inherits, directly or 	indirectly, from the interface identified by the parameter. Otherwise 	it returns FALSE. This implementation forwards the request to the       interface object"	^self getInterface asLocal isA: interfaceIdString</body><body package="DST_Core">isANumber	"Answer true if the receiver is a number."	^false</body><body package="DST_Core">isCharacterArray	"Answer true if the receiver is an instance of CharacterArray or a sub-type."	^false</body><body package="DST_Core">isCollection	"Answer true if the receiver is a collection."	^false</body><body package="DST_Core">isDeadObject	^false</body><body package="DST_Core">isDictionary	"Answer true if the receiver is a Dictionary."	^false</body><body package="DST_Core">isDSTMetaObject	^false</body><body package="DST_Core">isDSTObjRef	"True if I'm a DST object reference"	^false</body><body package="DST_Core">isEquivalent: anObject 	"return true if the receiver is equivalent to anObject false otherwise."	^self = anObject</body><body package="DST_Core">isLocal	"the receiver is a local object"	^true</body><body package="DST_Core">isRemote	"the receiver is a remote object"	^self isLocal not</body><body package="DST_Core">isTwoByteArray	"Answer true if the receiver is a two byte array."	^false</body><body package="DST_Core">mustBeLocal	"Return the local receiver. Raise an exception if the receiver is not a 	local object"	| res | 	res := self asLocal.	res isRemote ifTrue: [^self error: res printString , ' must be a local object'].	^res</body><body package="DST_Core">nonExistent	"Coerce nil to true and everything else to false. UndefinedObject 	overrides with ^true"	^false</body><body package="DST_Core">objectEngineImplementationDependent	"This method is intentionally null and is employed to highlight	those methods whose implementation is sensitively dependent	on the particulars of the object engine."</body><body package="DST_Core">objectId	"assign an objectId to the receiver and register it with the ORB"	^DSTObjRef objectIdOf: self</body><body package="DST_Core">overrideCORBAType: aDSTMetaObject 	"override the default CORBAType"	DSTtypeAny overrideCORBAType: aDSTMetaObject forObject: self</body><body package="DST_Core">removeAccess: aCollection user: aUserId 	"remove access for the user"	| acl accessRights |	(self respondsTo: #accessControlList)		ifTrue: [((aCollection isKindOf: Collection)				and: [(aUserId isKindOf: Symbol)						or: [aUserId isKindOf: NCSuuid]])				ifTrue: 					[((acl := self accessControlList) isKindOf: IdentityDictionary)						ifFalse: [^(CORBAConstants at: #'::Security::NotSupported')								raiseWith: Dictionary new errorString: ' incorrect implementation'].					(accessRights := acl at: aUserId ifAbsent: [nil]) isNil ifTrue: [^(CORBAConstants at: #'::Security::UserNotFound')							raiseWith: Dictionary new errorString: ' user not in access control list'].					aCollection do: [:sym | accessRights remove: sym ifAbsent: []].					self changed: #accessControlList]				ifFalse: [self class badParamError: 0]]		ifFalse: [^(CORBAConstants at: #'::Security::NotSupported')				raiseWith: Dictionary new errorString: ' this object does not support access control']</body><body package="DST_Core">removeUserFromACL: aUserId 	"remove a user from the acl"	| acl |	(self respondsTo: #accessControlList)		ifTrue: [((aUserId isKindOf: Symbol)				or: [aUserId isKindOf: NCSuuid])				ifTrue: 					[((acl := self accessControlList) isKindOf: IdentityDictionary)						ifFalse: [ORBObject internalError: 0].					(acl removeKey: aUserId ifAbsent: [nil]) isNil						ifTrue: [^(CORBAConstants at: #'::Security::UserNotFound')								raiseWith: Dictionary new errorString: ' user not in access control list']						ifFalse: [self changed: #accessControlList]]				ifFalse: [self class badParamError: 0]]		ifFalse: [^(CORBAConstants at: #'::Security::NotSupported')				raiseWith: Dictionary new errorString: ' this object does not support access control']</body><body package="DST_Core">setAccess: aCollection user: aUserId 	"set the access rights for a user"	| acl accessRights |	(self respondsTo: #accessControlList)		ifTrue: [((aCollection isKindOf: Collection)				and: [(aUserId isKindOf: Symbol)						or: [aUserId isKindOf: NCSuuid]])				ifTrue: 					[((acl := self accessControlList) isKindOf: IdentityDictionary)						ifFalse: [^(CORBAConstants at: #'::Security::NotSupported')								raiseWith: Dictionary new errorString: ' incorrect implementation'].					accessRights := IdentitySet new.					aCollection do: [:sym | accessRights add: sym].					acl at: aUserId put: accessRights.					self changed: #accessControlList]				ifFalse: [self class badParamError: 0]]		ifFalse: [^(CORBAConstants at: #'::Security::NotSupported')				raiseWith: Dictionary new errorString: ' this object does not support access control']</body><body package="DST_Core">stValues: anArray	"dummy method which should be overridden by GemStone fileIns"	self shouldNotImplement</body><body package="DST_Core">updateObjRefProfiles: aCollection bootTime: anInteger multiComponents: anIORMultipleComponents	"do nothing for local objects"	^self</body><body package="DST_Core">value	^self</body><body package="DST_Core">widenTo: anInterfaceID 	"Create a LocalObjRef as a suitably-widened reference to the receiver"	| if1 if2 | 	if1 := self CORBAType.	if2 := ORBObject lookupMetaId: anInterfaceID.	(if1 isAko: if2)		ifTrue: [^DSTObjRefWidened findOrCreateOn: self asInterfaceId: if2 repositoryId]		ifFalse: 			[Dialog onDebugNotify: 'Interface "' , if1 printName , '" is not derived from "' , if2 printName , '"'.			^ORBObject intfReposError: 0]</body></methods><methods><class-id>Graphics.ColorValue class</class-id> <category>DST</category><body package="DST_Core">red16: red green16: green blue16: blue 	"Answer a ColorValue with the supplied RGB values."	"The three components are specified as 16-bit quantities 	each. To create the color value instance, the 16-bit value of each 	component is divided by 8 (see my scalingValue)."	^self		scaledRed: (red bitShift: -3)		scaledGreen: (green bitShift: -3)		scaledBlue: (blue bitShift: -3)</body></methods><methods><class-id>Graphics.ColorValue</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::ColorValue'</body></methods><methods><class-id>Core.Exception</class-id> <category>DST</category><body package="DST_Core">corbaExceptionValue        "standard wrapper as required by the IDL Smalltalk Language        Mapping for accessing the exception value"        ^self parameter</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can 	marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^(DSTtypeWideString new) localType: self class name; yourself</body><body package="DST_Core">isCharacterArray	"Answer true if the receiver is an instance of CharacterArray or a 	sub-type. TwoByte strings/symbols should not really be thought of 	as character arrays."	^false</body><body package="DST_Core">isTwoByteArray	"Answer true if the receiver is a two byte character array."	^true</body><body package="DST_Core">toCORBACharCodes	^self asByteArrayEncoding: ORBObject wideCharEncoding</body><body package="DST_Core">toCORBAWideCharCodes        "return the receiver as a ByteArray with each character encoded to the         CORBA wide character encoding"         | copiedWideString |         copiedWideString := self copy.        (UninterpretedBytes isBigEndian)			ifFalse: [copiedWideString reverseByteOrder].        ^copiedWideString changeClassToThatOf: #[].</body></methods><methods><class-id>Core.Date</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Date'</body></methods><methods><class-id>Core.ByteString</class-id> <category>DST</category><body package="DST_Core">asByteSymbol	"This is to allow byte symbols be created from CORBA type 'string' during 	unmarshalling, if the local class for the string is a ByteSymbol."	^self asSymbol</body></methods><methods><class-id>Core.ByteString</class-id> <category>accessing</category><body package="DST_Core">replaceBytesFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the receiver	starting at index, repStart, in the collection, replacement.  Answer the	receiver."	&lt;primitive: 559&gt;	| repOff |	repOff := repStart - start.	(self == replacement and: [repStart &lt; start])		ifTrue:	["Replacement would be overwritten; use reverse order"				stop to: start by: -1 do:					[ :i |	self byteAt: i put: (replacement byteAt: repOff + i)]]		ifFalse:	[start to: stop do:					[ :i |	self byteAt: i put: (replacement byteAt: repOff + i)]]</body></methods><methods><class-id>Core.ByteString</class-id> <category>converting</category><body package="DST_Core">toCORBACharCodes	^self</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>DST</category><body package="DST_Core">asUUID	"Answer the unique symbol whose characters are the characters of the string."	^NCSuuid on: self</body><body package="DST_Core">capitalized	self isEmpty ifFalse:  [| newString |		newString := self shallowCopy.		newString at: 1 put: (self at: 1) asUppercase.		^newString].	^self</body><body package="DST_Core">CORBAType	"Return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every class 	which can be passed as an IDL type 'any' parameter." 	^DSTtypeString new localType: self class name; yourself</body><body package="DST_Core">isCharacterArray	"Answer true if the receiver is an instance of CharacterArray or a 	sub-type (except wide strings - see TwoByteString)."	^true</body><body package="DST_Core">trim	"Return a copy of the receiver which has 	no trailing spaces or control chars."	| i |	i := self size.	[i &gt; 0 and: [(self at: i) asInteger &lt;= 32]]		whileTrue: [i := i - 1].	^self copyFrom: 1 to: i</body><body package="DST_Core">unCapitalized	"Answer the receiver whose first character is lower cased."	self isEmpty ifFalse: [| newString |		newString := self shallowCopy.		newString at: 1 put: (self at: 1) asLowercase.		^newString].	^self</body><body package="DST_Core">withoutSpaces	"Drop all spaces after the initial character."	| ws |	self isEmpty ifTrue: [^self].	ws := WriteStream on: (self species new: self size).	ws nextPut: (self at: 1).	2 to: self size do: 		[:i | 		| c |		c := self at: i.		c = $  ifFalse: [ws nextPut: c]].	^ws contents</body></methods><methods><class-id>Core.Number</class-id> <category>converting</category><body package="DST_Core">asDSTLongDouble	^(self asDouble) asDSTLongDouble</body></methods><methods><class-id>Core.Number</class-id> <category>DST</category><body package="DST_Core">isANumber	"Answer true if the receiver is a number."	^true</body></methods><methods><class-id>Graphics.ComposedText class</class-id> <category>DST</category><body package="DST_Core">widthOfString: aString styleName: aSymbol 	"Calculate the width of the string if composed with the 	specified style (e.g. #default, #fixed)"	^self widthOfText: aString asText styleName: aSymbol</body><body package="DST_Core">widthOfText: aText styleName: aSymbol 	"Calculate the width of the text if composed with the specified 	style (e.g. #default, #fixed)"	^(ComposedText withText: aText style: (aSymbol == #default			ifTrue: [TextConstants at: #DefaultTextStyle]			ifFalse: [TextAttributes styleNamed: aSymbol])) width</body></methods><methods><class-id>Core.ArithmeticValue</class-id> <category>DST</category><body package="DST_Core">asNumber	"... return the receiver."</body></methods><methods><class-id>UI.SimpleHelp class</class-id> <category>DST</category><body package="DST_Core">showText: aText 	"Displays aText in a dialog after adjusting the size of the window"	"self showText: 'What we have here is 	a few too many lines 	but who is to say.'"	"self showText: (self class sourceCodeAt: #showText:)"	| spec txt txtExtent dialog box |	dialog := self new.	spec := self interfaceSpecFor: #windowSpec.	txt := ComposedText withText: aText asText style: TextAttributes default.	dialog helpString: txt.	dialog allButOpenFrom: spec.	txtExtent := txt preferredBounds extent.	box := 0 @ 0 extent: (txtExtent x + 60 max: 80)					@ ((txtExtent y + 60 min: 400)							max: 90).	box := box align: box center with: WindowSensor cursorPoint.	dialog builder openPopUpIn: box type: #dialog.	^dialog accept value</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::OrderedCollection'</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>converting</category><body package="DST_Core">toCORBACharCodes	^self</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>DST</category><body package="DST_Core">asInactiveObjRef	"nil is a valid Inactive ObjRef"	^self</body><body package="DST_Core">asLocal	"nil is already local"	^self</body><body package="DST_Core">asLocalObjRef	"nil is a valid LocalObjRef"</body><body package="DST_Core">CORBAName	"return the name of my CORBA interface in the repository"	^#'::CORBA::Object'</body><body package="DST_Core">nonExistent	"Coerce nil to true and everything else to false."	^true</body><body package="DST_Core">objectId	^NCSuuid nilId</body><body package="DST_Core">toCORBACharCode	"return the receiver converted to the CORBA character 	encoding (ISO 8859L1)"	"Here we know that the character codes are the same 	between VW and ISO8859L1 since VW2.5."	^0</body></methods><methods><class-id>OS.SocketAccessor</class-id> <category>DST</category><body package="DST_Core">readInto: inbuf start: index for: count wait: milliseconds 	"Read from the socket. Branch on whether or not the 	connection is intended to be eternal.  If not, shut down 	the connection if the timer  expires as well. This allows 	the connections to be shut down when not in use, and 	is prefered."	| bytes |	[	( ( Infinity positive  ~~ milliseconds )				ifTrue:	[ self readWaitWithTimeoutMs: milliseconds ]				ifFalse:	[ self readWait. false ] )					ifTrue:	[ bytes := 0 ]					ifFalse:	[	bytes := self											primReadInto: inbuf											startingAt: index											for: count							]	]	on: Error		do: [ :ex | bytes := 0 ].	^bytes</body><body package="DST_Core">writeFrom: aBuffer startingAt: index forSure: increment wait: milliseconds 	"Branch on whether we are intended to issue a timed write to the socket. 	Catch any exception and set the bytes to 0 if we get one."	| bytes |	[	( ( Infinity positive  ~~ milliseconds )				ifTrue:	[ self writeWaitWithTimeoutMs: milliseconds ]				ifFalse:	[ self writeWait. false ] )					ifTrue:	[	bytes := 0							]					ifFalse:	[	bytes := self											writeFrom: aBuffer											startingAt: index											forSure: increment							]	]	on: Error		do: [ :ex | bytes := 0 ].	^bytes</body></methods><methods><class-id>Core.Time</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Time'</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^DSTtypeUnsignedLongLong new</body></methods><methods><class-id>Core.Process</class-id> <category>DST</category><body package="DST_Core">corbaContext	"return the current CORBA Context object"	^self orbContext corbaContext</body><body package="DST_Core">corbaContext: aCORBAContext 	"set the current CORBA Context object"	^self orbContext corbaContext: aCORBAContext</body><body package="DST_Core">orbContext	"return the current ORB Context object"	| ctx |	(ctx := self environmentAt: #DSTORBContext) == nil		ifTrue: 			[ctx := ORBContext new.			self orbContext: ctx].	^ctx</body><body package="DST_Core">orbContext: anORBContext	"set the current ORB Context object"	^self environmentAt:  #DSTORBContext put: anORBContext</body><body package="DST_Core">unwindUpTo: aContext	| unwindSemaphore currentProcess firstContext |	"Unwind self up to a context. Self may be part of a distributed thread.	Return the thread local to aContext"	self == Processor activeProcess		ifTrue: [^self error: 'Process has to be suspended'].	unwindSemaphore := Semaphore new.	firstContext := suspendedContext.	self interruptWith:		[firstContext unwindUpTo: aContext asLocal andPassSuspendedProcessIn:			[:suspendedProcess |			currentProcess := suspendedProcess.			unwindSemaphore signal]].	unwindSemaphore wait.	^currentProcess</body></methods><methods><class-id>Core.Behavior</class-id> <category>DST</category><body package="DST_Core">asIDLDefinition	"This class is designed to take a Smalltalk class &amp; emit the IDL source 	definition, subject to substantial modification by the user. The class 	must have its MDI defined. Note: This will incorrectly define any 	method containing a carriage return before an argument. 	Note: This will at present only account for instance methods."	| strm  sdi sels ivars attrs sym  sif |	strm := ReadWriteStream on: String new.	(self includesSelector: #CORBAName)		ifFalse: [self defineCORBAName].	strm nextPutAll: '// This interface defines the behavior of ' , self name , ' objects'; cr.	strm nextPutAll: '//'; cr.	strm nextPutAll: 'interface ' , self name.	sdi := ( sif := superclass basicNew CORBAType) repositoryId.	sdi == Object basicNew CORBAType repositoryId		ifFalse: [strm nextPutAll: ' : ' , sif name asString ].	strm nextPut: $  ; nextPut: ${; cr.	sels := self selectors asSortedCollection.	ivars := (self instVarNames collect: [:s | s asSymbol]) asSortedCollection.	attrs := SortedCollection new.	ivars do: [:sy | (sels includes: sy)			ifTrue: 				[sels remove: sy.				attrs add: sy]].	attrs		do: 			[:at | 			sym := (at , ':') asSymbol.			(sels includes: sym)				ifFalse: [strm tab; nextPutAll: 'readonly attribute'; tab]				ifTrue: 					[strm tab; nextPutAll: 'attribute'; tab; tab; tab.					sels remove: sym].			strm tab; nextPutAll: 'string'; tab; tab; nextPutAll: at , ';'; cr].	strm cr.	sels do: [:sy | self genOpFor: sy on: strm].	strm nextPut: $}.	ComposedTextView open: strm contents asText asValue label: self name , ' IDL template'</body><body package="DST_Core">CORBAName	"Return the name of my CORBA interface in the repository."	^#'::SmalltalkSpecific::ClassObject'</body><body package="DST_Core">defineACL	"Define ACL and create if necessary."	| aStream acl |	aStream := String new writeStream.	acl := (self includesSelector: #abstractClassId)				ifTrue: [self basicNew abstractClassId]				ifFalse: [ORBObject newId].	aStream nextPutAll: '!' , self name , ' methodsFor: ''repository''!'; cr.	aStream nextPutAll: 'abstractClassId'; cr; tab; nextPutAll: '"return the abstract class Id of the receiver"'; cr; cr; tab; nextPutAll: '^''' , acl printString , ''' asUUID ! !'; cr.	aStream contents readStream fileIn.	^self basicNew abstractClassId</body><body package="DST_Core">defineCORBAName	"Define CORBAName and create if necessary."	(self includesSelector: #CORBAName)		ifFalse: [self defineCORBAName: self name category: #repository].	^self basicNew CORBAName</body><body package="DST_Core">defineCORBAName: result category: category 	"Define CORBAName method in category, returning the result as a symbol."	| aStream |	aStream := String new writeStream.	aStream nextPutAll: '!' , self name , ' methodsFor: '''; nextPutAll: category asString; nextPutAll: '''!'; cr.	aStream nextPutAll: 'CORBAName'; cr.	aStream tab; nextPutAll: '"return the name of my CORBA interface in the repository"'; cr; cr.	aStream tab; nextPutAll: '^'; nextPutAll: result asSymbol printString; nextPutAll: ' ! !'; cr.	aStream contents readStream fileIn</body><body package="DST_Core">describeImplementation	"Return a FullImplementationDescription for an instance of the receiver."	| obj |	obj := self basicNew.	^Dictionary		with: #name -&gt; self name		with: #id -&gt; obj ACL printString		with: #definedIn -&gt; obj CORBAType id		with: #methods -&gt; self allSelectors</body><body package="DST_Core">genOpFor: aSymbol on: aStream 	"Generate the code to implement an IDL definition for the method."	| meth src header hstrm idlname opname st st1 resType |	(#(#abstractClassId #initialize #productName) includes: aSymbol)		ifTrue: [^self].	meth := self compiledMethodAt: aSymbol.	src := meth getSource.	header := src readStream upTo: Character cr.	(src includes: $^)		ifTrue: [resType := 'ResultType']		ifFalse: [resType := 'void'].	hstrm := header readStream.	opname := hstrm through: $:.	opname last = $:		ifTrue: [idlname := opname copyFrom: 1 to: opname size - 1]		ifFalse: [idlname := opname].	aStream cr; tab; nextPutAll: '#pragma selector '; nextPutAll: idlname; nextPutAll: ' '; nextPutAll: aSymbol; cr.	opname last = $:		ifTrue: 			[aStream tab; nextPutAll: resType; tab; tab.			[hstrm peek = $ ]				whileTrue: [hstrm next].			st := hstrm upTo: $ .			aStream nextPutAll: opname; skip: -1; nextPutAll: '(in '.			st1 := st copy.			('an*' match: st1)				ifTrue: [st1 := st1 copyFrom: 3 to: st1 size]				ifFalse: [('a*' match: st1)						ifTrue: [st1 := st1 copyFrom: 2 to: st1 size]].			aStream nextPutAll: st1 , ' ' , st.			[hstrm atEnd]				whileFalse: 					[hstrm upTo: $:.					[hstrm peek = $ ]						whileTrue: [hstrm next].					st := hstrm upTo: $ .					aStream nextPutAll: ', in '.					st1 := st copy.					('an*' match: st1)						ifTrue: [st1 := st1 copyFrom: 3 to: st1 size]						ifFalse: [('a*' match: st1)								ifTrue: [st1 := st1 copyFrom: 2 to: st1 size]].					aStream nextPutAll: st1 , ' ' , st]]		ifFalse: 			[aStream tab.			('is*' match: opname)				ifTrue: [aStream nextPutAll: 'boolean']				ifFalse: [('has*' match: opname)						ifTrue: [aStream nextPutAll: 'boolean']						ifFalse: [aStream nextPutAll: resType]].			aStream tab; tab; nextPutAll: opname; nextPutAll: '('].	aStream nextPut: $); nextPut: $;; cr</body><body package="DST_Core">getInstanceACL	"Return the abstractClassId for instances of the receiver."	^self basicNew abstractClassId</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::IdentityDictionary'</body></methods><methods><class-id>Core.Integer</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^DSTtypeLong new</body></methods><methods><class-id>Core.Symbol class</class-id> <category>DST</category><body package="DST_Core">fromString: aString 	^self intern: aString</body></methods><methods><class-id>Core.Symbol</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can 	marshall an instance of the receiver"	^ORBObject lookupMetaId: #'::SharedIR::Symbol'</body></methods><methods><class-id>Core.Interval class</class-id> <category>DST</category><body package="DST_Core">first: v1 last: v2 increment: v3 	"An IDL-kind way to create intervals. See Debugging::IntegerInterval"	^self		from: v1		to: v2		by: v3</body></methods><methods><class-id>Core.Boolean</class-id> <category>DST</category><body package="DST_Core">CORBAType	"Return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every class 	that can be passed as an IDL type 'any' parameter."	^DSTtypeBoolean new</body></methods><methods><class-id>Core.Association</class-id> <category>DST</category><body package="DST_Core">CORBAType	"Return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Association'</body></methods><methods><class-id>Core.GenericException</class-id> <category>printing</category><body package="DST_Core">description	"Answer the exception text."	| text |	^( messageText ~~ nil and: [ messageText respondsTo: #asString ] )  		ifTrue:	[ messageText asString ]		ifFalse:	[ ( text := messageText value ) == nil					ifTrue:	[ self defaultMessageText ]					ifFalse:	[ text  asString ] ]</body></methods><methods><class-id>Kernel.CodeWriteAnalysisTracer</class-id> <category>tracing</category><body package="DST_Core">doTraceOfDSTInterface: anObject	"We need to cut of the subordinates of the dstInterface"	| save |	save := anObject subordinates.	anObject subordinates: nil.	self doTraceOfObject: anObject.	anObject subordinates: save.</body><body package="DST_Core">doTraceOfDSTmoduleRepository: anObject	"no op"</body></methods><methods><class-id>Core.String</class-id> <category>DST</category><body package="DST_Core">asIDLString	^'"' , self asString , '"'</body><body package="DST_Core">asOrderedCollectionOfSubstrings	"return an array of the substrings of the receiver, delimited by spaces"	| reader result |	reader := ReadStream on: self.	result := OrderedCollection new.	[reader atEnd]		whileFalse: [result add: (reader upTo: $ )].	^result</body><body package="DST_Core">asRepositoryId	"Create a RepositoryId from a string."	^RepositoryId fromString: self</body><body package="DST_Core">padRight: length	"pad the receiver to length with spaces, truncate if necessary"	| str | 	str := String new: length.	(1 to: length)  do: [:i|		i &lt;= self size			ifTrue: [str at: i put: (self at: i)]			ifFalse: [str at: i put: $  ]].	^str</body><body package="DST_Core">sizeInBytes	"Answer how many bytes the receiver contains."	^self size</body><body package="DST_Core">toCORBACharCodes	"return the receiver as a ByteArray with each character encoded to the CORBA character 	encoding (ISO8859L1)"	^self asByteArrayEncoding: #ISO8859_1</body><body package="DST_Core">toCORBAWideCharCodes	"return the receiver as a ByteArray with each character encoded to the 	CORBA wide character encoding"	^self asTwoByteString toCORBAWideCharCodes.</body></methods><methods><class-id>Core.ArrayedCollection class</class-id> <category>DST</category><body package="DST_Core">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of ArrayedCollection, containing the five 	arguments as the elements."	| newCollection |	newCollection := self new: 5.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	^newCollection</body></methods><methods><class-id>Core.Dictionary</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Dictionary'</body><body package="DST_Core">isDictionary	"Answer true if the receiver is a Dictionary."	^true</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>DST</category><body package="DST_Core">asIDLString	"return an IDL format string representation of the receiver"	| str |	str := self printString.	str at: str size put: $d.	^str</body><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	| abs integral fractional log |	abs := self abs.	abs &lt; 1 ifTrue: [		fractional := scale min: 31.		^DSTtypeFixed new			digits: fractional;			scale: fractional;			yourself ].	log := abs truncated log.	integral := log ceiling.	integral &gt; 31 ifTrue: [ self error: 'Maximum size of fixed is 31 decimal digits!' ].	log &lt; integral ifFalse: [		"1000 log = 3.0, but is 4 digits"		integral := integral + 1 ].	fractional := scale min: 31 - integral.	^DSTtypeFixed new		digits: integral + fractional;		scale: fractional		yourself</body></methods><methods><class-id>Core.TwoByteSymbol</class-id> <category>DST</category><body package="DST_Core">isCharacterArray	"Answer true if the receiver is an instance of CharacterArray or a 	sub-type. TwoByte strings/symbols should not really be thought of 	as character arrays."	^false</body><body package="DST_Core">isTwoByteArray	"Answer true if the receiver is a two byte character array."	^true</body></methods><methods><class-id>Core.Text class</class-id> <category>DST</category><body package="DST_Core">textString: aString runs: anArray  	^self basicNew setString: aString setRuns: anArray</body></methods><methods><class-id>Core.Text</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Text'</body><body package="DST_Core">textString	^string</body></methods><methods><class-id>Core.Collection class</class-id> <category>DST</category><body package="DST_Core">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of a Collection containing the		four arguments as the elements."	| newCollection |	newCollection := self new.	newCollection add: firstObject.	newCollection add: secondObject.	newCollection add: thirdObject.	newCollection add: fourthObject.	newCollection add: fifthObject.	^newCollection</body></methods><methods><class-id>Core.Collection</class-id> <category>DST</category><body package="DST_Core">anElement	"return an arbitrary element of the receiver"	self do: [:el | ^el]</body><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::OrderedCollection'</body><body package="DST_Core">isCollection	"Answer true if the receiver is a collection."	^true</body></methods><methods><class-id>Core.ISO8859L1String</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^DSTtypeString new</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^DSTtypeLongLong new</body></methods><methods><class-id>Core.Point</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Point'</body></methods><methods><class-id>Core.ByteArray</class-id> <category>DST</category><body package="DST_Core">CORBAType	"Return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SharedIR::ByteArray'</body><body package="DST_Core">fromCORBACharCodes	"Return the receiver as a String with each character decoded from the CORBA character 	encoding (ISO8859L1)."	^self asStringEncoding: #ISO8859_1</body></methods><methods><class-id>UI.TwoDList</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::DataViews::TwoDList'</body><body package="DST_Core">elements	"return the receiver"	^collection</body></methods><methods><class-id>Kernel.CodeWriter</class-id> <category>dst tracing</category><body package="DST_Core">doTraceOfDSTInterface: anObject	"We need to cut of the subordinates of the dstInterface"	| save |	save := anObject subordinates.	anObject subordinates: nil.	self doTraceOfObject: anObject.	anObject subordinates: save.</body><body package="DST_Core">doTraceOfDSTmoduleRepository: anObject		stream storeObjectPointer: 1</body></methods><methods><class-id>Core.Float</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^DSTtypeFloat new</body></methods><methods><class-id>Core.Character</class-id> <category>DST</category><body package="DST_Core">asHex	"answer the 2-byte hex representation of the receiver"	| res |	res := (self asInteger printStringRadix: 16) asLowercase.	res size = 1		ifTrue: [^'0' , res]		ifFalse: [^res]</body><body package="DST_Core">asIDLString	"return an IDL format string representation of the receiver"	^String with: $' with: self with: $'</body><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver. This method must be implemented in every 	class which can be passed as an IDL type 'any' parameter"	^(self codePoint &lt; 256) ifTrue: [DSTtypeCharacter new] ifFalse: [DSTtypeWideCharacter new].</body><body package="DST_Core">toCORBACharCode	"return the receiver converted to the CORBA character 	encoding (ISO 8859L1)"	"Here we know that the character codes are the same 	between VW and ISO8859L1 since VW2.5."	^self asInteger</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>DST</category><body package="DST_Core">asHex	"answer the 2-byte hex representation of the receiver"	| res |	res := (self printStringRadix: 16) asLowercase.	res size = 1		ifTrue: [^'0' , res]		ifFalse: [^res]</body><body package="DST_Core">fromCORBACharCode	"return the receiver converted to a Character decoded from the 	CORBA character encoding (ISO 8859L1)"	"self &gt; 160 ifFalse: [Performance tuning: asCharacter is much faster 	than the dictionary lookup (decode:). 	Here we know that the character codes 0 to 160 are the same 	between Smalltalk and ISO8859L1 	self asCharacter] 	ifTrue: [ISO8859L1String decode: self]"	^self asCharacter</body></methods><methods><class-id>Core.Bag</class-id> <category>DST</category><body package="DST_Core">CORBAType	"Return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Bag'</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>DST</category><body package="DST_Core">asString	^self value asString</body></methods><methods><class-id>OS.IPSocketAddress class</class-id> <category>DST</category><body package="DST_Core">hostAddressByNameOrAddressString: aString 	"Answer the host address for the named host."	| address |	aString = '-thishost-' ifTrue: [^self thisHost].	address := self stringToBytes: aString.	address isNil 		ifTrue: [address := self primHostAddressByName: (IOAccessor convertSimpleStringForPlatform: aString)].	^address isNil		ifTrue: [OSErrorHolder inaccessibleSignal raiseWith: aString]		ifFalse: [address]</body></methods><methods><class-id>Core.RunArray</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::RunArray'</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>DST</category><body package="DST_Core">CORBAType	"return an instance of the DSTmetaObject subclass which can marshall an 	instance of the receiver."	^ORBObject lookupMetaId: #'::SmalltalkTypes::Rectangle'</body></methods><initialize><class-id>DST.ORBObject</class-id></initialize><initialize><class-id>DST.DSTtypeAny</class-id></initialize><initialize><class-id>DST.DSTLongDouble</class-id></initialize><initialize><class-id>DST.IIOPConnection</class-id></initialize><initialize><class-id>DST.DSTObjRef</class-id></initialize><initialize><class-id>DST.DSTObjRefNarrowed</class-id></initialize><initialize><class-id>DST.CDRStream</class-id></initialize><initialize><class-id>DST.ORBDaemon</class-id></initialize><initialize><class-id>DST.DSTObjRefWidened</class-id></initialize><initialize><class-id>DST.IIOPDaemon</class-id></initialize><initialize><class-id>DST.RepositoryId</class-id></initialize><initialize><class-id>DST.DSTServiceContext</class-id></initialize><initialize><class-id>DST.DSTObjRefLocal</class-id></initialize><initialize><class-id>DST.GIOPMessage</class-id></initialize><initialize><class-id>DST.DSTInterfaceRepositoryConfiguration</class-id></initialize><initialize><class-id>DST.DSTtypeVoid</class-id></initialize><initialize><class-id>DST.DSTModules</class-id></initialize><initialize><class-id>DST.DSTObjRefInactive</class-id></initialize><initialize><class-id>DST.NCSuuid</class-id></initialize><initialize><class-id>DST.OrbResolver</class-id></initialize><initialize><class-id>DST.DSTObjRefRemote</class-id></initialize><initialize><class-id>DST.IIOPObjectKey</class-id></initialize><initialize><class-id>DST.ORBConstantsDictionary</class-id></initialize><initialize><class-id>DST.IIOPConfiguration</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Magnitude</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ArithmeticValue</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>powersOfTwo </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>LargeInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>LargePositiveInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>CodeWriter</name><environment>Kernel</environment><super>Kernel.ObjectTracer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definedObjects classes extendedClasses extensionMethods exclusionset definedBindings scopeZones currentClass objectSpace analysisTracer symbolNum stringNum byteArrayNum floatNum doubleNum largePositiveNum largeNegativeNum mclassNum mclassclassNum refNamObjNum scopeZonesNum defObjOrganizerNum classOrganizerNum arbObjectNum arbClassNum stream sourceStream sourceName hideOnLoad pointer currentKey properties prerequisites namedObjects newSourceKeys dateString timeString scratchDictionary codeComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>TwoByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>TwoDList</name><environment>UI</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents collection rows columns transposed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ColorValue</name><environment>Graphics</environment><super>Graphics.SimplePaint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>red green blue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Signal</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent mayProceed notifierString nameClass nameMessage exceptionClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ISO8859L1String</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>SocketAccessor</name><environment>OS</environment><super>OS.BlockableIOAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>networkFamily </inst-vars><class-inst-vars>concreteClass </class-inst-vars><imports></imports><category>OS-Sockets</category><attributes><package>OS-Sockets</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>RunArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runs values cacheRun cacheRunStart </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ReadWriteStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Bag</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TwoByteString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Process</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList systemRecords interruptProtect environment isSystem name debugger locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>CodeWriteAnalysisTracer</name><environment>Kernel</environment><super>Kernel.ObjectTracer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classifications mclassList referencedNamedObjects currentClass scopeZones codeMode packageClasses extendedClasses packageNamedObjects compiledMethodCount scratchDictionary codeComponent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Code Storage</category><attributes><package>System-Code Storage</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>