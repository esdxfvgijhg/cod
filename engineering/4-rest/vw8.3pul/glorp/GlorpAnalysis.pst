<?xml version="1.0"?><st-source><!-- Name: GlorpAnalysisNotice: Copyright 2006-2012 Alan Knight.Portions © 2012-2015 Cincom Systems, Inc.  All rights reserved.This utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This provides descriptor systems for reading the meta-tables of relational databases.  With this data it builds a model of the tables, columns and foreign keys of the specific databases they hold.  This supports constructing specific descriptor systems for those databases.It also holds a query performance analyzer that can keep track of queries executed and their time.  Other analysis tools (but portable, so not GUI tools) for use with Glorp may be added here.DbIdentifier: bear73DbTrace: 502561DbUsername: nrossDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#bundle 'Glorp' '') #(#any 'GlorpVWPortNonBase' ''))Namespace: GlorpPackageName: GlorpAnalysisParcel: #('GlorpAnalysis')ParcelName: GlorpAnalysisPrerequisiteParcels: #(#('Glorp' '') #('GlorpVWPortNonBase' ''))PrintStringCache: (8.3 - 2,nross)Version: 8.3 - 2Date: 11:29:14 AM June 16, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:29:14 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.MetadataDescriptorSystem</class-id><body>This is an abstract superclass for descriptor systems describing database metadata.</body></comment><class><name>SQLite3MetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.MetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id><body>SQLiteMetadataDescriptorSystem describes SQLite's non-standard metadata.</body></comment><class><name>SQLite3DatabaseTable</name><environment>Glorp</environment><super>Glorp.DatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>foreignKeysData indexesData tableSql </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3DatabaseTable</class-id><body>This class temporarily substitutes for the DatabaseTable parent class during the meta-information gathering stage.It knows about SQLite3's special PRAGMA procs, and holds the SQLite3 specific intermediate pieces of information.In the end, members of this class know how to generate the usual DatabaseTable object from their own info, usingthe method &gt;&gt;asDatabaseTable.</body></comment><class><name>InformationSchemaMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.MetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id><body>This is an abstract superclass for descriptor systems describing database metadata, for databases which conform at least reasonably closely to the information_schema standard.</body></comment><class><name>ReferentialConstraintTableMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.InformationSchemaMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</class-id><body>This is a base descriptor system for reading database information from a Postgresql and MS SQL Server databases, which have in common the REFERENTIAL_CONSTRAINTS table.</body></comment><class><name>PostgresqlMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.PostgresqlMetadataDescriptorSystem</class-id><body>This is a base descriptor system for reading database information from a Postgresql database.</body></comment><class><name>SQLite3IndexColumnData</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seqno cid name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3IndexColumnData</class-id><body>This class holds the data returned by a SQLite PRAGMA index_info( indexname ) query.First, use the index_list() pragma for a given table name, to get the list of indexes.Then, use the index_info() pragma to get the relevent column information for eachreturned index name.Instance Variables	cid		&lt;Integer&gt;	Column id of the returned data. Can probably be ignored--use name instead.	name	&lt;String&gt;	Column name.	seqno	&lt;Integer&gt;	This column's position within the index, zero-based.</body></comment><class><name>GlorpSQLite3MetaSession</name><environment>Glorp</environment><super>Glorp.GlorpSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.GlorpSQLite3MetaSession</class-id><body>GlorpSqlite3MetaSession is a special subclass of GlorpSession which serves to impose restrictions on DatabaseTable and other metadescriptor-related classes. This is something of a hack, but seems to be the simplest way to acquire the information schema from SQLite. SQLite has no standard information schema tables, so the info-schema contents must be extracted from special Sqlite PRAGMA statements, which work much like stored procedures that return row sets.Note that the api/queries protocol attempts to simulate the behavior of actual information_schema databases. If the query concerns DatabaseTable, it is likely to work, and is used by ActiveRecord. For other classes, results are considered experimental. The methods in this protocol can act as though they read DatabaseField, ForeignKeyConstraint, PrimaryKeyConstraint, UniqueConstraint. But they are really just reconstructing the information ad hoc, and simulating a query result. For many simple queries, Glorp executes the where: block successfully, without sending any query (which it cannot do, since there is no actual info schema table).</body></comment><class><name>SQLServerMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLServerMetadataDescriptorSystem</class-id><body>This is a descriptor system for reading database information from a SQLServer database.</body></comment><class><name>MySQLMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.InformationSchemaMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.MySQLMetadataDescriptorSystem</class-id><body>This is a descriptor system for reading database information from a MySQL database.</body></comment><class><name>ReferentialConstraint</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.ReferentialConstraint</class-id><body>Similar to PrimaryKeyConstraint, this is a class mostly used to increase our ability to easily refer to a table. We don't expect to ever actually read instances of it.</body></comment><class><name>OracleMetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.MetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.OracleMetadataDescriptorSystem</class-id><body>This describes Oracle's non-standard metadata.</body></comment><class><name>GlorpQueryPerformanceAnalyzer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session commands </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id><body>This can keep track of the commands executed and the time taken, to provide information about how to optimize the query performance.</body></comment><class><name>DB2MetadataDescriptorSystem</name><environment>Glorp</environment><super>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpAnalysis</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.DB2MetadataDescriptorSystem</class-id><body>This is a descriptor system for reading database information from a DB2 database.</body></comment><class><name>SQLite3IndexData</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seq name unique indexColumnsData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3IndexData</class-id><body>This class holds the data returned by a SQLite PRAGMA index_list( tablename ) query.See the comment for SQLiteIndexColumnData for more information about capturing theSQLite indexes data.Instance Variables	name	&lt;String&gt;	The index name.	seq		&lt;Integer&gt;	Can probably be ignored. For each table, the indexes are numbered from 0.	unique	&lt;Integer&gt;	1 means the index is unique, 0 else.</body></comment><class><name>SQLite3ForeignKeyData</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id seq sourceTableName targetTableName sourceColumnName targetColumnName onUpdate onDelete match </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpAnalysis</package></attributes></class><comment><class-id>Glorp.SQLite3ForeignKeyData</class-id><body>This class holds the data returned by a SQLite PRAGMA foreign_key_info( tablename ) query.</body></comment><methods><class-id>Glorp.MetadataDescriptorSystem</class-id> <category>classes</category><body package="GlorpAnalysis">classModelForDatabaseField: aClassModel	aClassModel newAttributeNamed: #table type: DatabaseTable.	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #isPrimaryKey type: Boolean.	aClassModel newAttributeNamed: #isNullable type: Boolean.	aClassModel newAttributeNamed: #isUnique type: Boolean.	aClassModel newAttributeNamed: #type type: GlorpDatabaseType.</body><body package="GlorpAnalysis">classModelForDatabaseIndex: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #fields collectionOf: DatabaseField.</body><body package="GlorpAnalysis">classModelForDatabaseTable: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #schema type: String.	aClassModel newAttributeNamed: #fields collectionOf: DatabaseField.	aClassModel newAttributeNamed: #foreignKeyConstraints collectionOf: ForeignKeyConstraint.	aClassModel newAttributeNamed: #indexes collectionOf: DatabaseIndex.	aClassModel newAttributeNamed: #primaryKeyFields collectionOf: DatabaseField.</body><body package="GlorpAnalysis">classModelForForeignKeyConstraint: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #sourceFields collectionOf: DatabaseField.	aClassModel newAttributeNamed: #targetFields collectionOf: DatabaseField.</body><body package="GlorpAnalysis">classModelForNamedSequence: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #schema type: String.</body><body package="GlorpAnalysis">classModelForPrimaryKeyConstraint: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #table type: DatabaseTable.</body></methods><methods><class-id>Glorp.MetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">descriptorForDatabaseField: aDescriptor	self subclassResponsibility.</body><body package="GlorpAnalysis">descriptorForDatabaseIndex: aDescriptor	self subclassResponsibility.</body><body package="GlorpAnalysis">descriptorForDatabaseTable: aDescriptor	self subclassResponsibility.</body><body package="GlorpAnalysis">descriptorForForeignKeyConstraint: aDescriptor	self subclassResponsibility.</body><body package="GlorpAnalysis">descriptorForGlorpKeyColumnUsage: aDescriptor	self subclassResponsibility</body><body package="GlorpAnalysis">descriptorForPrimaryKeyConstraint: aDescriptor	self subclassResponsibility.</body></methods><methods><class-id>Glorp.MetadataDescriptorSystem</class-id> <category>metadata classes</category><body package="GlorpAnalysis">databaseTable	^DatabaseTable</body></methods><methods><class-id>Glorp.MetadataDescriptorSystem class</class-id> <category>instance creation</category><body package="GlorpAnalysis">concreteClassForPlatform: aPlatform	aPlatform isOraclePlatform ifTrue: [^OracleMetadataDescriptorSystem].	aPlatform isPostgreSQLPlatform ifTrue: [^PostgresqlMetadataDescriptorSystem].	aPlatform isMySQLPlatform ifTrue: [^MySQLMetadataDescriptorSystem].	aPlatform isSQLServerPlatform ifTrue: [^SQLServerMetadataDescriptorSystem].	aPlatform isSQLite3Platform ifTrue: [^SQLite3MetadataDescriptorSystem].	aPlatform isDB2Platform ifTrue: [^DB2MetadataDescriptorSystem].	GlorpError signal: aPlatform class name, ' is not yet supported for Glorp analysis.'.</body><body package="GlorpAnalysis">forPlatform: aPlatform	^self == MetadataDescriptorSystem		ifTrue: [(self concreteClassForPlatform: aPlatform) forPlatform: aPlatform]		ifFalse: [super forPlatform: aPlatform].</body><body package="GlorpAnalysis">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system."	^aGlorpLogin database class = SQLite3Platform		ifTrue: [SQLite3MetadataDescriptorSystem sessionForLogin: aGlorpLogin]		ifFalse: [super sessionForLogin: aGlorpLogin]</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">descriptorForDatabaseField: aDescriptor	"Map the Field object to the associated columns in the COLUMNS table.	Note that we cannot get the table name in the retrieved rows because that	info is not returned from the SQLite pragma. We can only map to what is	returned by the pseudo query. So, the table reference is back-filled later."	| table |	table := self tableNamed: 'columns'.	aDescriptor table: table.		"(aDescriptor newMapping: OneToOneMapping)		attributeName: #table."	(aDescriptor newMapping: DirectMapping)		from: 'position' to: (table fieldNamed: 'cid').	(aDescriptor newMapping: DirectMapping)		from: 'name' to: (table fieldNamed: 'name').	(aDescriptor newMapping: DirectMapping) 		from: 'isNullable' to: (table fieldNamed: 'notnull').	"(aDescriptor newMapping: DirectMapping) 		from: 'type' to: (table fieldNamed: 'type')."	self fieldTypeMappingFor: aDescriptor.	(aDescriptor newMapping: DirectMapping) 		from: 'dbDefaultValue' to: (table fieldNamed: 'dflt_value').	(aDescriptor newMapping: DirectMapping) 		from: 'isPrimaryKey' to: (table fieldNamed: 'pk').	"initialize any variables that reading from the database will not set	(these values should be the same as in DatabaseField&gt;&gt;initialize).	The database cannot know whether a given field is a lockField."	(aDescriptor newMapping: ConstantMapping)		attributeName: #isLockKey;		constantValue: false.</body><body package="GlorpAnalysis">descriptorForDatabaseIndex: aDescriptor</body><body package="GlorpAnalysis">descriptorForDatabaseTable: aDescriptor</body><body package="GlorpAnalysis">descriptorForForeignKeyConstraint: aDescriptor	" *** This method was defined by Glorp.MetadataDescriptorSystem as a subclass responsibility.	Replace its body with a proper implementation. *** "</body><body package="GlorpAnalysis">descriptorForPrimaryKeyConstraint: aDescriptor	" *** This method was defined by Glorp.MetadataDescriptorSystem as a subclass responsibility.	Replace its body with a proper implementation. *** "</body><body package="GlorpAnalysis">descriptorForSQLite3DatabaseTable: aDescriptor	"SELECT * FROM sqlite_master WHERE type = 'table' AND 'name' = ?"	"type name tbl_name rootpage sql"	"Note, fwiw, that for type='table' entries, name and tbl_name fields will have the same value."	| table |	table := self tableNamed: 'sqlite_master'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) fromPseudoVariable: #type to: (table fieldNamed: 'type').	(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'name').	(aDescriptor newMapping: DirectMapping) fromPseudoVariable: #tbl_name to: (table fieldNamed: 'tbl_name').	(aDescriptor newMapping: DirectMapping) from: #tableSql to: (table fieldNamed: 'sql').	(aDescriptor newMapping: SQLite3PragmaMapping)		attributeName: #fields;		shouldProxy: false.	(aDescriptor newMapping: SQLite3PragmaMapping)		attributeName: #foreignKeysData;		shouldProxy: false.	(aDescriptor newMapping: SQLite3PragmaMapping)		attributeName: #indexesData;		shouldProxy: false.</body><body package="GlorpAnalysis">descriptorForSQLite3ForeignKeyData: aDescriptor      "PRAGMA foreign_key_list(table-name);"	"id seq table from to on_update on_delete match"	"As if from a query like this:	SELECT id, seq, sourceTable, from, table, to ORDER BY id, seq WHERE sourceTable = ?"	| fkeysTable |	fkeysTable := self tableNamed: 'foreign_keys'.	aDescriptor table: fkeysTable.		((aDescriptor newMapping: DirectMapping)		from: 'id' to: (fkeysTable fieldNamed: 'id')).  "which column id (not column name)."	((aDescriptor newMapping: DirectMapping)		from: 'seq' to: (fkeysTable fieldNamed: 'seq')).  "which position in the fkey."	((aDescriptor newMapping: DirectMapping) 		from: 'targetTableName' to: (fkeysTable fieldNamed: 'table')).  "the pkey table."	((aDescriptor newMapping: DirectMapping) 		from: 'sourceColumnName' to: (fkeysTable fieldNamed: 'from')). "my fkey column."	((aDescriptor newMapping: DirectMapping) 		from: 'targetColumnName' to: (fkeysTable fieldNamed: 'to')).   "the pkey column."	"The following fields are absent in earlier SQLite 3 dlls, so we ignore them.	((aDescriptor newMapping: DirectMapping) 		from: 'onUpdate' to: (fkeysTable fieldNamed: 'on_update')). 	((aDescriptor newMapping: DirectMapping) 		from: 'onDelete' to: (fkeysTable fieldNamed: 'on_delete')).	((aDescriptor newMapping: DirectMapping) 		from: 'match' to: (fkeysTable fieldNamed: 'match'))."</body><body package="GlorpAnalysis">descriptorForSQLite3IndexColumnData: aDescriptor      "PRAGMA index_list(table-name);"	"seq name unique"	| indexColumnsTable |	indexColumnsTable := self tableNamed: 'index_info'.	aDescriptor table: indexColumnsTable.		((aDescriptor newMapping: DirectMapping)		from: 'seqno' to: (indexColumnsTable fieldNamed: 'seqno')).  	"The index column sequence number."	((aDescriptor newMapping: DirectMapping) 		from: 'cid' to: (indexColumnsTable fieldNamed: 'cid')).			"The column id, which we don't use."	((aDescriptor newMapping: DirectMapping) 		from: 'name' to: (indexColumnsTable fieldNamed: 'name')).  	"The name of the column, which we use."</body><body package="GlorpAnalysis">descriptorForSQLite3IndexData: aDescriptor      "PRAGMA index_list(table-name);"	"seq name unique"	| indexesTable |	indexesTable := self tableNamed: 'index_list'.	aDescriptor table: indexesTable.		((aDescriptor newMapping: DirectMapping) 		from: 'name' to: (indexesTable fieldNamed: 'name')).  "The name of the index."	((aDescriptor newMapping: DirectMapping)		from: 'seq' to: (indexesTable fieldNamed: 'seq')).  "The index number, which we don't use."	((aDescriptor newMapping: DirectMapping) 		from: 'unique' to: (indexesTable fieldNamed: 'unique')). "If the index is unique, 1, otherwise, 0."	"collection of SQLiteIndexColumnData."	(aDescriptor newMapping: SQLite3PragmaMapping)		attributeName: #indexColumnsData;		shouldProxy: false.</body><body package="GlorpAnalysis">fieldTypeMappingFor: aDescriptor	| table typeField |	table := aDescriptor table.	typeField := table fieldNamed: 'type'.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #type		fromDb:			[:row :elementBuilder :context | 			self platform				typeWithDatabaseName:					(elementBuilder valueOfField: (context translateField: typeField))				characterWidth: 0				extraInformation: #()]		toDb:			[:rows :attribute :attributeRows | ]		mappingFields: (Array with: typeField).</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>classes</category><body package="GlorpAnalysis">classModelForSQLite3DatabaseTable: aClassModel	super classModelForDatabaseTable: aClassModel.	aClassModel newAttributeNamed: #foreignKeysData collectionOf: SQLite3ForeignKeyData.	aClassModel newAttributeNamed: #indexesData collectionOf: SQLite3IndexData.	aClassModel newAttributeNamed: #tableSql type: String.</body><body package="GlorpAnalysis">classModelForSQLite3ForeignKeyData: aClassModel	"id seq table from to on_update on_delete match"	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #seq type: Integer.	aClassModel newAttributeNamed: #sourceTableName type: String.	aClassModel newAttributeNamed: #targetTableName type: String.	aClassModel newAttributeNamed: #sourceColumnName type: String.	aClassModel newAttributeNamed: #targetColumnName type: String."	The following fields are absent in older SQLite 3 dlls.	aClassModel newAttributeNamed: #onUpdate type: String.	aClassModel newAttributeNamed: #onDelete type: String.	aClassModel newAttributeNamed: #match type: String."</body><body package="GlorpAnalysis">classModelForSQLite3IndexColumnData: aClassModel	aClassModel newAttributeNamed: #seqno type: Integer.	aClassModel newAttributeNamed: #cid type: Integer.	aClassModel newAttributeNamed: #name type: String.</body><body package="GlorpAnalysis">classModelForSQLite3IndexData: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #seq type: Integer.	aClassModel newAttributeNamed: #unique type: Integer.	aClassModel newAttributeNamed: #indexColumnsData collectionOf: SQLite3IndexColumnData.</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis">tableForCOLUMNS: aTable	"PRAGMA table_info(table-name)"	"cid name type notnull dflt_value pk"	| tableName |	tableName := (aTable createFieldNamed: 'tbl_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'sqlite_master') fieldNamed: 'tbl_name').	(aTable createFieldNamed: 'cid' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'name' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'type' type: platform int4.	aTable createFieldNamed: 'notnull' type: platform boolean.	aTable createFieldNamed: 'dflt_value' type: (platform varchar: 255).	aTable createFieldNamed: 'pk' type: platform boolean</body><body package="GlorpAnalysis">tableForFOREIGN_KEYS: aTable      "PRAGMA foreign_key_list(table-name);"	"id seq table from to on_update on_delete match"	"This function returns a collection of fkey columns for aTable, mapped to pkey columns of 'table'."	| tableName |	tableName := (aTable createFieldNamed: 'tbl_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'sqlite_master') fieldNamed: 'tbl_name').	(aTable createFieldNamed: 'id' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'seq' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'from' type: (platform varchar: 255).	aTable createFieldNamed: 'to' type: (platform varchar: 255).	aTable createFieldNamed: 'on_update' type: (platform varchar: 255).	aTable createFieldNamed: 'on_delete' type: (platform varchar: 255).	aTable createFieldNamed: 'match' type: (platform varchar: 255).</body><body package="GlorpAnalysis">tableForINDEX_INFO: aTable	"seqno cid name"	| tableName |	tableName := (aTable createFieldNamed: 'index_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'index_list') fieldNamed: 'name').	(aTable createFieldNamed: 'seqno' type: (platform int4)) bePrimaryKey.	(aTable createFieldNamed: 'cid' type: (platform int4)) bePrimaryKey.	(aTable createFieldNamed: 'name' type: (platform varchar: 255))</body><body package="GlorpAnalysis">tableForINDEX_LIST: aTable	"seq name unique"	| tableName |	tableName := (aTable createFieldNamed: 'tbl_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'sqlite_master') fieldNamed: 'tbl_name').	(aTable createFieldNamed: 'seq' type: (platform int4)) bePrimaryKey.	(aTable createFieldNamed: 'name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'unique' type: (platform int4))</body><body package="GlorpAnalysis">tableForSQLITE_MASTER: aTable	"SELECT * FROM sqlite_master WHERE type = 'table'."	"type can be TABLE, VIEW or INDEX"	"type name tbl_name rootpage sql"	(aTable createFieldNamed: 'type' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'tbl_name' type: (platform varchar: 255)).	(aTable createFieldNamed: 'rootpage' type: (platform varchar: 255)).	(aTable createFieldNamed: 'sql' type: (platform varchar: 255))</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>accessing</category><body package="GlorpAnalysis">allClasses	allClasses isEmpty ifTrue: [allClasses := self constructAllClasses asSet asOrderedCollection].	^allClasses</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>session creation</category><body package="GlorpAnalysis">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system. This is the easiest way to get a full blown session going."	| newSession |	platform isNil ifTrue: [self platform: aGlorpLogin database].	aGlorpLogin database class = self platform class ifFalse: [self error: 'Login is incompatible with the database specified in the descriptor system'].	newSession := GlorpSQLite3MetaSession new.	newSession accessor: (DatabaseAccessor forLogin: aGlorpLogin).	newSession system: self.	^newSession.</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>initialize-release</category><body package="GlorpAnalysis">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	"self useDirectAccessForMapping: false."	^self</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem</class-id> <category>metadata classes</category><body package="GlorpAnalysis">databaseTable	^SQLite3DatabaseTable</body></methods><methods><class-id>Glorp.SQLite3MetadataDescriptorSystem class</class-id> <category>instance creation</category><body package="GlorpAnalysis">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system. This is the easiest way to get a full blown session going."	| system session |	system := self forPlatform: aGlorpLogin database.	session :=  GlorpSQLite3MetaSession new.	session accessor: (DatabaseAccessor forLogin: aGlorpLogin).	session system: system.	^session.</body></methods><methods><class-id>Glorp.SQLite3DatabaseTable</class-id> <category>accessing</category><body package="GlorpAnalysis">foreignKeysData	^foreignKeysData</body><body package="GlorpAnalysis">foreignKeysData: anObject	foreignKeysData := anObject</body><body package="GlorpAnalysis">hasAutoIncrement	"Return true if my original create table statement sql has an auto increment primary key:	INTEGER PRIMARY KEY AUTOINCREMENT. This means my pkey column is Serial.	With SQLite3, a field declared this way automatically gets ROWID value from a	private sequence table. (This method can be tricked if the sql contains CRs or Tabs.)"	| sql |	^(sql := self tableSql)		ifNil: [false]		ifNotNil: 			[((sql asUppercase copyWithout: Character space)				indexOfSubCollection: 'INTEGERPRIMARYKEYAUTOINCREMENT'				startingAt: 1) &gt; 0]</body><body package="GlorpAnalysis">indexesData	^indexesData</body><body package="GlorpAnalysis">indexesData: anObject	indexesData := anObject</body><body package="GlorpAnalysis">tableSql	^tableSql</body><body package="GlorpAnalysis">tableSql: anObject	tableSql := anObject</body></methods><methods><class-id>Glorp.SQLite3DatabaseTable</class-id> <category>fields</category><body package="GlorpAnalysis">addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: suffixExpression	"Generate the foreign key using these source and target fields, which are likely proxy objects.	This method assigns a temporary name to avoid endless recursion. Later, after the proxies	have been instantiated, a	proper name is regenerated."	| newFK |	newFK := ForeignKeyConstraint				sourceFields: sourceFields				targetFields: targetFields				suffixExpression: suffixExpression.	newFK name: 'ForeignKeyNumber_' , (foreignKeyConstraints size + 1) printString.	^foreignKeyConstraints add: newFK</body></methods><methods><class-id>Glorp.SQLite3DatabaseTable</class-id> <category>converting</category><body package="GlorpAnalysis">asDatabaseTable	"This is where we switch from this subclass, which exists purely to gather info from	SQLite's PRAGMAs, to become its super class, DatabaseTable. Before throwing away	the special index and foreign key information, figure out which columns are unique,	generate the primaryKeyFields list, and switch the #fields &gt;&gt;table references to their	replacement table object."	| table ivarName |	self findUniqueColumns.	self findPrimaryKeyFields.	table := DatabaseTable new.	#(#name #schema #fields #foreignKeyConstraints #indexes #parent #lockKeyFields #primaryKeyFields #isImaginary #replacementSubSelect)		do: 			[:ivar |			ivarName := ivar asString.			table instVarNamed: ivarName put: (self instVarNamed: ivarName)].	table fields do: [:fld| fld table: table].	^table</body><body package="GlorpAnalysis">findPrimaryKeyFields	"This method isn't strictly necessary, since the pkey info is already available and the	lazy accessor will gather them if necessary. But, this method calculates them in	the official pkey sequence order, which can be useful for comparisson purposes, and	if nothing else, it serves as a check comparing index contents with the pkey field flag.	Check each index to see if it is both unique and has all the expected pkey columns.	Save primaryKeyFields according to the index 'seqno' information.	Possible wrong sort order if there is a separate unique index on the pkey columns,	and we compare that index before we get to the true pkey index."	| pknames match pkFields pkSet |	pkFields := self fields select: [:fld | fld isPrimaryKey].	pknames := pkFields collect: [:fld | fld name].	pkSet := pknames asSet.	match := self indexesData detect: 					[:indexDat |					indexDat unique = 1						ifTrue: [pkSet = indexDat columnNames asSet]						ifFalse: [false]]				ifNone: [].	match ifNotNil: [primaryKeyFields := match asOrderedFieldsForTable: self]</body><body package="GlorpAnalysis">findUniqueColumns	"Check each index to see if it is both unique and has just one column.	If true, then assign the corresponding DatabaseField isUnique: true."	| uniqueField cols |	self indexesData do: 			[:indexDat |			uniqueField := indexDat unique = 1						ifTrue: 							[cols := indexDat columnNames.							cols size = 1								ifTrue: 									[self fields detect: [:fld | fld name = cols first]										ifNone: [self error: (#CannotFindUniqueIndex &lt;&lt; #store &gt;&gt;'Cannot find unique-indexed column.')]]].			uniqueField ifNotNil: [uniqueField isUnique: true]]</body></methods><methods><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis">informationSchemaName	"Return the name of the schema we'll use for the information_schema tables. Typically we'd expect that to be information_schema, but it isn't necessarily so."	^'INFORMATION_SCHEMA'.</body><body package="GlorpAnalysis">tableForCOLUMNS: aTable	| tableName schema |	aTable schema: self informationSchemaName.	tableName := (aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	schema := (aTable createFieldNamed: 'table_schema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'column_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: (self tablesTable fieldNamed: 'table_name')		from: schema to: (self tablesTable fieldNamed: 'table_schema').	aTable createFieldNamed: 'ordinal_position' type: platform int4.	aTable createFieldNamed: 'is_nullable' type: (platform boolean).	aTable createFieldNamed: 'data_type' type: (platform varchar: 255).	aTable createFieldNamed: 'column_default' type: (platform varchar: 255).	aTable createFieldNamed: 'character_maximum_length' type: platform int4.	aTable createFieldNamed: 'numeric_precision' type: platform int4.	aTable createFieldNamed: 'numeric_scale' type: platform int4.</body><body package="GlorpAnalysis">tableForKEY_COLUMN_USAGE: aTable	| columns constraints |	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_schema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'column_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'constraint_schema' type: (platform varchar: 255).	aTable createFieldNamed: 'ordinal_position' type: platform int4.	columns := self columnsTable.	aTable addForeignKeyFrom: (aTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')		from: (aTable fieldNamed: 'table_schema') to: (columns fieldNamed: 'table_schema')		from: (aTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name').	constraints := self constraintsUsageReferenceTable.	aTable addForeignKeyFrom: (aTable fieldNamed: 'constraint_name') to: (constraints fieldNamed: 'constraint_name')		from: (aTable fieldNamed: 'constraint_schema') to: (constraints fieldNamed: 'constraint_schema').</body><body package="GlorpAnalysis">tableForTABLES: aTable	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_schema' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'table_type' type: (platform varchar: 255).</body><body package="GlorpAnalysis">tableForTABLE_CONSTRAINTS: aTable	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_schema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_schema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_type' type: (platform varchar: 255)) bePrimaryKey.  "FOREIGN KEY"</body></methods><methods><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">descriptorForDatabaseField: aDescriptor	"Map the Field object to the associated columns in the COLUMNS table.	The inst vars #type and #defaultValue use AdHocMappings, and their mappings	are described in their own respective methods, &gt;&gt;fieldTypeMappingFor:, and	&gt;&gt;fieldDefaultValueMappingFor:, as shown."	| table usageTable constraintTable isPkMapping |	table := self columnsTable.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'column_name').	(aDescriptor newMapping: OneToOneMapping) 		attributeName: #table.	(aDescriptor newMapping: DirectMapping) 		from: #isNullable to: (table fieldNamed: 'is_nullable');		converter: (self platform converterNamed: #booleanToStringYesNo).	self fieldTypeMappingFor: aDescriptor.	self fieldDefaultValueMappingFor: aDescriptor.	usageTable := self keyColumnUsageTable.	constraintTable := self constraintsTable.	(aDescriptor newMapping: ToManyMapping)		attributeName: #primaryKeyConstraints;		referenceClass: PrimaryKeyConstraint;		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'table_schema') to: (constraintTable fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from:  'PRIMARY KEY' to: (constraintTable fieldNamed: 'constraint_type')).	isPkMapping := (aDescriptor newMapping: DirectMapping) 		from: #isPrimaryKey 		to: [:each | each primaryKeyConstraints notEmpty].	isPkMapping shouldProxy: false.	"initialize any variables that reading from the database will not set	(these values should be the same as in DatabaseField&gt;&gt;initialize).	The database cannot know whether a given field is a lockField."	(aDescriptor newMapping: ConstantMapping)		attributeName: #isLockKey;		constantValue: false.</body><body package="GlorpAnalysis">descriptorForDatabaseIndex: aDescriptor</body><body package="GlorpAnalysis">descriptorForDatabaseTable: aDescriptor	| table usageTable constraintTable map query |	table := self tablesTable.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'table_name').	(aDescriptor newMapping: DirectMapping) from: 'schema' to: (table fieldNamed: 'table_schema').	(aDescriptor newMapping: ToManyMapping)		attributeName: #fields.	usageTable := self keyColumnUsageTable.	constraintTable := self constraintsTable.	map := (aDescriptor newMapping: ToManyMapping)		attributeName: #foreignKeyConstraints;		referenceClass: ForeignKeyConstraint;		useLinkTable;		join: (Join			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'table_schema') to: (constraintTable fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from:  'FOREIGN KEY' to: (constraintTable fieldNamed: 'constraint_type')).	query := map buildQuery.	query baseExpression requiresDistinct: true.</body><body package="GlorpAnalysis">descriptorForForeignKeyConstraint: aDescriptor	| table usageTable columns targetFieldMapping |	table := self constraintsTable.	aDescriptor table: table.	aDescriptor directMapping from: #name to: (table fieldNamed: 'constraint_name').	"We have to make sure we map our primary keys directly. Otherwise we'll get into trying to use the relationship mappings to find foreign key values and it gets ugly. Make them pseudo-variables so we don't have to actually create inst vars for them."	(aDescriptor directMapping from: #schema to: (table fieldNamed: 'constraint_schema')) beForPseudoVariable.	(aDescriptor directMapping from: #tableName to: (table fieldNamed: 'table_name')) beForPseudoVariable.	(aDescriptor directMapping from: #tableSchema to: (table fieldNamed: 'table_schema')) beForPseudoVariable.	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	usageTable := self keyColumnUsageTable.	columns := self columnsTable.	(aDescriptor newMapping: ToManyMapping)		attributeName: #sourceFields;		referenceClass: DatabaseField;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'ordinal_position'];		join: (Join			from: (table fieldNamed: 'constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'table_schema') to: (columns fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name')).	targetFieldMapping := aDescriptor toManyMapping		attributeName: #targetFields;		useLinkTable;		join: (Join 			from: (table fieldNamed: 'constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'referenced_table_schema') to: (columns fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'referenced_table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'referenced_column_name') to: (columns fieldNamed: 'column_name')).	targetFieldMapping orderBy: [:eachField | (eachField primaryKeyConstraints getTable: usageTable) getField: 'ordinal_position'].</body><body package="GlorpAnalysis">descriptorForPrimaryKeyConstraint: aDescriptor	"Note that this maps to the same table as a ForeignKeyConstraint, and I haven't bothered to do any inheritance, just relying on the joins in the relationships to distinguish the two. Also, we don't really have to map anything at all here, but the name is useful for telling instances apart, if we ever got instances."	| table tableTable |	table := self constraintsTable.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'constraint_name').	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	tableTable := self tablesTable.	aDescriptor oneToOneMapping		attributeName: #table;		join: (Join 			from: (table fieldNamed: 'table_name') to: (tableTable fieldNamed: 'table_name')			from: (table fieldNamed: 'table_schema') to: (tableTable fieldNamed: 'table_schema')).</body><body package="GlorpAnalysis">extraFieldsForTypeIn: table	"Return an additional fields we're going to need in order to determine the data type of a column."	^#().</body><body package="GlorpAnalysis">fieldDefaultValueMappingFor: aDescriptor	"The DB keeps column_default as a string.  Since the default value can include arithmetic values, function calls, etc., we try seveal methods to recover the value.  To use this mapping to de-convert the string to our field's type, we need the builder's field (called &gt;&gt;instance) to have its type already built, since the block uses that GlorpType to understand the 'column_default' string."	| table defaultValueField |	table := aDescriptor table.	defaultValueField := table fieldNamed: 'column_default'.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #dbDefaultValue		fromDb:			[:row :elementBuilder :context |			[self platform				toGlorpType: elementBuilder instance type				fromString: (elementBuilder valueOfField: (context translateField: defaultValueField))]					on: Error					do: [:ex || aDBMSDefaultValueString |						aDBMSDefaultValueString := elementBuilder valueOfField: (context translateField: defaultValueField).						ex return: aDBMSDefaultValueString]]		toDb: [:rows :attribute :attributeRows | ]		mappingFields: (Array with: defaultValueField).</body><body package="GlorpAnalysis">fieldTypeMappingFor: aDescriptor	| table typeField widthField precisionField scaleField |	table := aDescriptor table.	typeField := table fieldNamed: 'data_type'.	widthField := table fieldNamed: self characterLengthFieldName.	precisionField := table fieldNamed: 'numeric_precision'.	scaleField := table fieldNamed: 'numeric_scale'.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #type		fromDb:			[:row :elementBuilder :context || glorpType |			glorpType := self platform				typeWithDatabaseName:					(elementBuilder valueOfField: (context translateField: typeField))				characterWidth:					(elementBuilder valueOfField: (context translateField: widthField))				extraInformation:					(self getExtraInformationFor: context inBuilder: elementBuilder).			glorpType class = GlorpNumericType ifTrue:				[glorpType					precision: (elementBuilder valueOfField: (context translateField: precisionField));					scale: (elementBuilder valueOfField: (context translateField: scaleField))].			glorpType]		toDb: [:rows :attribute :attributeRows | (rows at: table) at: typeField put: attribute typeName]		mappingFields: (Array with: typeField with: widthField with: precisionField with: scaleField), (self extraFieldsForTypeIn: table).</body><body package="GlorpAnalysis">getExtraInformationFor: aContext inBuilder: anElementBuilder	"If there's extra information we need to pass in to compute the data type, set it up here."</body></methods><methods><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id> <category>helpers</category><body package="GlorpAnalysis">characterLengthFieldName	^'character_maximum_length'.</body><body package="GlorpAnalysis">foreignKeyConstraintTypeString	"Return the string we expect in the database table for constraints to distinguish foreign key constraints from others."	^'FOREIGN KEY'.</body><body package="GlorpAnalysis">targetOfForeignKeysConstraintTypeString	"Return the string we expect in the database constraints table for the constraint type that is the target of foreign key constraints."	^'PRIMARY KEY'</body></methods><methods><class-id>Glorp.InformationSchemaMetadataDescriptorSystem</class-id> <category>table roles</category><body package="GlorpAnalysis">columnsTable	^self tableNamed: 'COLUMNS'</body><body package="GlorpAnalysis">constraintsTable	^self tableNamed: 'TABLE_CONSTRAINTS'</body><body package="GlorpAnalysis">constraintsUsageReferenceTable	^self tableNamed: 'TABLE_CONSTRAINTS'</body><body package="GlorpAnalysis">keyColumnUsageTable	^self tableNamed: 'KEY_COLUMN_USAGE'</body><body package="GlorpAnalysis">tablesTable	^self tableNamed: 'TABLES'</body></methods><methods><class-id>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">descriptorForDatabaseField: aDescriptor	| table refTable usageTable |	super descriptorForDatabaseField: aDescriptor.	table := aDescriptor table.	usageTable := self keyColumnUsageTable.	refTable := self constraintsUsageReferenceTable.	(aDescriptor newMapping: ToManyMapping)		attributeName: #constraintsTargetingMe;		referenceClass: ReferentialConstraint;		beForPseudoVariable;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'ordinal_position'];		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_schema') to: (refTable fieldNamed: 'constraint_schema')			from: (usageTable fieldNamed: 'constraint_name') to: (refTable fieldNamed: 'constraint_name')).</body><body package="GlorpAnalysis">descriptorForDatabaseIndex: aDescriptor</body><body package="GlorpAnalysis">descriptorForForeignKeyConstraint: aDescriptor	| table usageTable columns targetFieldMapping |	table := self constraintsTable.	aDescriptor table: table.	aDescriptor directMapping from: #name to: (table fieldNamed: 'constraint_name').	"We have to make sure we map our primary keys directly. Otherwise we'll get into trying to use the relationship mappings to find foreign key values and it gets ugly. Make them pseudo-variables so we don't have to actually create inst vars for them."	(aDescriptor directMapping from: #schema to: (table fieldNamed: 'constraint_schema')) beForPseudoVariable.	(aDescriptor directMapping from: #tableName to: (table fieldNamed: 'table_name')) beForPseudoVariable.	(aDescriptor directMapping from: #tableSchema to: (table fieldNamed: 'table_schema')) beForPseudoVariable.	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	usageTable := self keyColumnUsageTable.	columns := self columnsTable.	(aDescriptor newMapping: ToManyMapping)		attributeName: #sourceFields;		referenceClass: DatabaseField;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'ordinal_position'];		join: (Join			from: (table fieldNamed: 'constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'table_schema') to: (columns fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name')).	targetFieldMapping := aDescriptor toManyMapping		attributeName: #targetFields;		join: [:eachField | eachField primaryKeyConstraints foreignKeyConstraintsUsingMeAsTargetConstraint ] .	"Note that to get the link table to order by, we need to refer to it in terms of the relationship that controls it, not just ask the base for that table."	targetFieldMapping orderBy: [:eachField | (eachField primaryKeyConstraints getTable: usageTable) getField: 'ordinal_position'].</body><body package="GlorpAnalysis">descriptorForPrimaryKeyConstraint: aDescriptor	"Note that this maps to the same table as a ForeignKeyConstraint, and I haven't bothered to do any inheritance, just relying on the joins in the relationships to distinguish the two. Also, we don't really have to map anything at all here, but the name is useful for telling instances apart, if we ever got instances."	| table refTable |	super descriptorForPrimaryKeyConstraint: aDescriptor.	table := aDescriptor primaryTable.	refTable := self constraintsUsageReferenceTable.	aDescriptor oneToOneMapping		attributeName: #foreignKeyConstraintsUsingMeAsTargetConstraint;		referenceClass: ForeignKeyConstraint;		useLinkTable;		beForPseudoVariable;		join: (Join			from: (table fieldNamed: 'constraint_name') to: (refTable fieldNamed: 'unique_constraint_name')			from: (table fieldNamed: 'constraint_schema') to: (refTable fieldNamed: 'unique_constraint_schema'));		reverseJoin: (Join 			from: (refTable fieldNamed: 'constraint_schema') to: (table fieldNamed: 'constraint_schema')			from: (refTable fieldNamed: 'constraint_name') to: (table fieldNamed: 'constraint_name')			from: 'FOREIGN KEY' to: (table fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis">descriptorForReferentialConstraint: aDescriptor	"We don't really have to map anything at all here to real variables, but the name is useful for telling instances apart, if we ever got instances. Other than that everything is pseudovariables"	| table usageTable columns |	table := self constraintsUsageReferenceTable.	aDescriptor table: table.		aDescriptor directMapping from: 'name' to: (table fieldNamed: 'constraint_name').	usageTable := self keyColumnUsageTable.	columns := self columnsTable.	aDescriptor oneToOneMapping		attributeName: #targetField;		referenceClass: DatabaseField;		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'unique_constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'unique_constraint_schema') to: (usageTable fieldNamed: 'constraint_schema'));		reverseJoin: (Join 			from: (usageTable fieldNamed: 'table_schema') to: (columns fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name')).</body></methods><methods><class-id>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis">allTableNames	^#(COLUMNS KEY_COLUMN_USAGE REFERENTIAL_CONSTRAINTS TABLES TABLE_CONSTRAINTS)</body><body package="GlorpAnalysis">tableForREFERENTIAL_CONSTRAINTS: aTable	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_schema' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'unique_constraint_schema' type: (platform varchar: 255).	aTable createFieldNamed: 'unique_constraint_name' type: (platform varchar: 255).	aTable createFieldNamed: 'table_name' type: (platform varchar: 255).</body></methods><methods><class-id>Glorp.ReferentialConstraintTableMetadataDescriptorSystem</class-id> <category>table roles</category><body package="GlorpAnalysis">constraintsUsageReferenceTable	^self tableNamed: 'REFERENTIAL_CONSTRAINTS'</body></methods><methods><class-id>Glorp.PostgresqlMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis">tableForPG_CLASS: aTable	| |	aTable schema: 'PG_CATALOG'.	(aTable createFieldNamed: 'relname' type: (platform varchar: 255)) bePrimaryKey.</body></methods><methods><class-id>Glorp.PostgresqlMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">descriptorForNamedSequence: aDescriptor	"Really, we need to filter named sequences according to relkind='S', which is probably most easily done using filtered inheritance, but since we're going to be retrieving them specifically by name one at a time anyway, this should be adequate."	| table |	table := self tableNamed: 'PG_CLASS'.	aDescriptor table: table.		aDescriptor directMapping from: 'name' to: (table fieldNamed: 'relname').</body><body package="GlorpAnalysis">getExtraInformationFor: aContext inBuilder: anElementBuilder	^nil</body></methods><methods><class-id>Glorp.SQLite3IndexColumnData</class-id> <category>accessing</category><body package="GlorpAnalysis">cid	^cid</body><body package="GlorpAnalysis">cid: anObject	cid := anObject</body><body package="GlorpAnalysis">name	^name</body><body package="GlorpAnalysis">name: anObject	name := anObject</body><body package="GlorpAnalysis">seqno	^seqno</body><body package="GlorpAnalysis">seqno: anObject	seqno := anObject</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>api/queries</category><body package="GlorpAnalysis">execute: aQuery	| rawResults |	^aQuery resultClass == DatabaseTable		ifFalse: [self executeForNonTable: aQuery]		ifTrue:			[| sqliteQuery |			sqliteQuery := aQuery copy.			aQuery copyAttributesTo: sqliteQuery.			sqliteQuery				initResultClass: SQLite3DatabaseTable				whereClause: aQuery whereClause				singleObject: aQuery readsOneObject.			sqliteQuery AND: [:each | each type = 'table'].			sqliteQuery setOrdering: aQuery ordering.			sqliteQuery setGrouping: aQuery grouping.			rawResults := super execute: sqliteQuery.			aQuery readsOneObject				ifTrue:					[rawResults ifNotNil: [self databaseTableFromSqliteDatabaseTable: rawResults]]				ifFalse:					[(rawResults isEmpty or: [rawResults first isNil])						ifTrue: [OrderedCollection new]						ifFalse: [self databaseTablesFromSqliteDatabaseTables: rawResults]]]</body><body package="GlorpAnalysis">read: aClass	^aClass = DatabaseTable		ifTrue: [super read: aClass]		ifFalse: [self read: aClass limit: nil]</body><body package="GlorpAnalysis">read: aClass limit: anInteger	^aClass = DatabaseTable		ifTrue: [super read: aClass limit: anInteger]		ifFalse: [self read: aClass where: nil limit: anInteger]</body><body package="GlorpAnalysis">read: aClass orderBy: aCriteria	^aClass = DatabaseTable		ifTrue: [super read: aClass orderBy: aCriteria]		ifFalse: [(self read: aClass) sort: aCriteria]</body><body package="GlorpAnalysis">read: aClass where: aBlock	^aClass = DatabaseTable		ifTrue: [super read: aClass where: aBlock]		ifFalse: [self read: aClass where: aBlock limit: nil]</body><body package="GlorpAnalysis">read: aClass where: aBlock limit: anInteger	"The SQLite3 information schema doesn't exist, so we cannot make the usual queries. But we can handle a query to read some classes by simply reading about every DatabaseTable (which we do have the machinery to read), and collecting all the existing aClass instances. If aClass isn't one of the following, the superclass send may not work."	| selector result |	selector := self class sqliteClassSelectors		at: aClass		ifAbsent: [^super read: aClass where: aBlock limit: anInteger].	result := (self read: DatabaseTable)		inject: Set new		into: [:all :table | all addAll: (table perform: selector). all].	aBlock isNil ifTrue: [^result asArray].	result := result select: aBlock.	anInteger isNil ifTrue: [^result asArray].	"In the absence of ordering, the next line is doubtful, but it lets us imitate super"	^result asArray first: anInteger</body><body package="GlorpAnalysis">readOneOf: aClass	^aClass = DatabaseTable		ifTrue: [super readOneOf: aClass ]		ifFalse: [self readOneOf: aClass where: nil]</body><body package="GlorpAnalysis">readOneOf: aClass where: aBlock	^aClass = DatabaseTable		ifTrue: [super readOneOf: aClass where: aBlock]		ifFalse: [(self read: aClass where: aBlock limit: 1) first]</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>private-sqlite</category><body package="GlorpAnalysis">databaseTableFromSqliteDatabaseTable: aRawTable	"Return the cached DatabaseTable version of the raw SqliteDatabaseTable query results.  If the raw table is not already in the cache, convert it and add it to the cache.  In addition, foreign key target tables will also be read and added to the cache."	| newTable |	(newTable := self updateSQLiteTableData: aRawTable) ifNotNil: 		[self cacheAt: newTable name asUppercase put: newTable.		self resolveForeignKeyProxiesForDatabaseTable: newTable].	"Return the cached table, a DatabaseTable."	^self cachedTableNamed: aRawTable name asUppercase</body><body package="GlorpAnalysis">databaseTablesFromSqliteDatabaseTables: rawTables	"This repeats in sequence the steps of the singular method #databaseTableFromSqliteDatabaseTable: and so could be implemented as	^rawTables collect: [:rawTable | self databaseTableFromSqliteDatabaseTable: rawTable]but since the foreign key resolution step may trigger the same process on target tables it is more sensible, when we have a group, to update and cache them all first and resolve their foreign keys after all are cached."	| newTables |	newTables := OrderedCollection new: rawTables size.	rawTables do:		[:rawTable || newTable |		newTable := self updateSQLiteTableData: rawTable.		newTable isNil ifFalse:			[self cacheAt: rawTable name asUppercase put: newTable.			newTables add: newTable]].	newTables do: [:newTable | self resolveForeignKeyProxiesForDatabaseTable: newTable].	"Now that we've read and cached the full extent of connected tables, return the original query results."	^rawTables collect: [:rawTable | self cachedTableNamed: rawTable name asUppercase]</body><body package="GlorpAnalysis">findForeignKeysForTable: aRawTable	"SQLite pragmas provide only the fkey source and target field and table names. This method	generates the corresponding foreignKeyConstraint objects. The parameter is a SqliteDatabaseTable	representing the DatabaseTable that we are in the process of instantiating from the meta info.	Constraint source and target fields which are not in the cache (DatabaseTable) are represented as proxy	objects to be resolved later."	| sqliteFKeys keyIds |	sqliteFKeys := aRawTable foreignKeysData.	keyIds := (sqliteFKeys collect: [:fkey | fkey id]) asSet.	keyIds do:		[:keyId || keyColsUnsorted sourceFields targetFields keyCols |		keyColsUnsorted := sqliteFKeys select: [:fkey | fkey id = keyId].		keyCols := (keyColsUnsorted asSortedCollection: [:a :b | a seq &lt;= b seq]) asArray.		sourceFields := keyCols collect:			[:fkey || tableName fieldName sourceTable |			tableName := fkey sourceTableName asUppercase.			fieldName := fkey sourceColumnName asUppercase.			(sourceTable := self cachedTableNamed: tableName)				ifNil: [self proxyForField: fieldName ofTable: tableName]				ifNotNil: [sourceTable fields							detect: [:fld | fld name asUppercase = fieldName]							ifNone: [self error: 'fkey sourceField is from self, yet not found.']]].			targetFields := keyCols collect:				[:fkey || tableName fieldName targetTable |				tableName := fkey targetTableName asUppercase.				fieldName := fkey targetColumnName asUppercase.				(targetTable := self cachedTableNamed: tableName)					ifNil: [self proxyForField: fieldName ofTable: tableName]					ifNotNil: [targetTable fields								detect: [:fld | fld name asUppercase = fieldName]								ifNone: [self error: 'fkey target field not found.']]].			aRawTable addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: nil].</body><body package="GlorpAnalysis">resolveForeignKeyProxiesForDatabaseTable: newTable	"Ensure no fields are proxies, then (re)generate the name."	newTable foreignKeyConstraints do:		[:constraint |		constraint sourceFields:			(constraint sourceFields collect:				[:each | each class = SQLite3Proxy ifTrue: [each getValue] ifFalse: [each]]).		constraint targetFields:			(constraint targetFields collect:				[:each | each class = SQLite3Proxy ifTrue: [each getValue] ifFalse: [each]]).		constraint name: nil; name].</body><body package="GlorpAnalysis">updateSQLiteTableData: rawTable	"Convert each SQLiteDatabaseTable object to the usual DatabaseTable object.  Instances of the former contain raw column, index, and foreign key information that needs to be converted into ForeignKeyConstraints and unique column attributes.  The conversion method, #asDatabaseTable also relinks all DatabaseField references to the new DatabaseTable object, so that the original SQLiteDatabaseTable can finally be discarded after this call completes."	^(self cachedTableNamed: rawTable name asUppercase) isNil ifTrue:		[self findForeignKeysForTable: rawTable.		rawTable asDatabaseTable]</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>private-sqlite-cache</category><body package="GlorpAnalysis">cachedTableNamed: aTableName	"This method checks the cache, and returns the requested DatabaseTable object if found, or nil."	^aTableName ifNotNil: [self cacheLookupForClass: DatabaseTable key: aTableName]</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>private-queries</category><body package="GlorpAnalysis">executeForNonTable: aQuery	"This implements &gt;&gt;execute: for classes other than DatabaseTable. With no actual information_schema	available, our metadata descriptor system needs unusual mappings in place for those expected by Glorp.	This method verifies that the requested class can be handled. "	self class sqliteClassSelectors at: aQuery resultClass				ifAbsent: [self error: 'executeForNonTable: was sent for a DatabaseTable.'].	self error: 'Not yet implemented: needs mappings for metadata descriptor.'.	super execute: aQuery.</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession</class-id> <category>private-sqlite-proxy</category><body package="GlorpAnalysis">proxyForField: aFieldName ofTable: aTableName	| proxy aBlock |	aBlock := [:each | each name asUppercase = aTableName asUppercase].	proxy := SQLite3Proxy				readOneOf: SQLite3DatabaseTable				where: [:each | each type = 'table' AND: aBlock asGlorpExpression]				in: self.	proxy glorpProxyAction: 			[:session :rawResult |			rawResult				ifNotNil: 					[|table|					table := session databaseTableFromSqliteDatabaseTable: rawResult.					table fieldNamed: aFieldName]].	proxy glorpOwner: self.	^proxy</body><body package="GlorpAnalysis">proxyForTableNamed: aTableName	| proxy aBlock |	aBlock := [:each | each name asUppercase = aTableName asUppercase].	proxy := SQLite3Proxy				readOneOf: SQLite3DatabaseTable				where: [:each | each type = 'table' AND: aBlock asGlorpExpression]				in: self.	proxy glorpProxyAction: 			[:session :rawResult |			rawResult				ifNotNil: [session databaseTableFromSqliteDatabaseTable: rawResult]].	proxy glorpOwner: self.	^proxy</body></methods><methods><class-id>Glorp.GlorpSQLite3MetaSession class</class-id> <category>api/queries</category><body package="GlorpAnalysis">sqliteClassSelectors	^(Dictionary new)		at: ForeignKeyConstraint put: #foreignKeyConstraints;		at: PrimaryKeyConstraint put: #primaryKeyConstraints;		at: UniqueConstraint put: #uniqueConstraints;		at: DatabaseField put: #fields;		yourself</body></methods><methods><class-id>Glorp.SQLServerMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">descriptorForDatabaseField: aDescriptor	| table usageTable constraintTable |	super descriptorForDatabaseField: aDescriptor.	table := aDescriptor table.		"The 'columns' table"	usageTable := self keyColumnUsageTable.	constraintTable := self constraintsTable.	(aDescriptor newMapping: ToManyMapping)		attributeName: #primaryOrUniqueKeyConstraints;		referenceClass: PrimaryKeyConstraint;	"the PrimaryKeyConstraint table is OK for primary and unique constraints"		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'table_schema') to: (usageTable fieldNamed: 'table_schema')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'table_schema') to: (constraintTable fieldNamed: 'table_schema')			from: (usageTable fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from:  (AdHocProxy readBlock: [self targetOfForeignKeysConstraintTypeString]) to: (constraintTable fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis">descriptorForForeignKeyConstraint: aDescriptor	super descriptorForForeignKeyConstraint: aDescriptor.	(aDescriptor mappingForAttributeNamed: #targetFields)		join: [:eachField | eachField primaryOrUniqueKeyConstraints foreignKeyConstraintsUsingMeAsTargetConstraint]</body><body package="GlorpAnalysis">fieldTypeMappingFor: aDescriptor	"For SQL Server, we can find out if this is an IDENTITY column only by calling a special function called COLUMNPROPERTY."		| table isIDMapping columnField schemaField tableField |	table := aDescriptor table.	schemaField := table fieldNamed: 'table_schema'.	tableField := table fieldNamed: 'table_name'.	columnField := table fieldNamed: 'column_name'.	isIDMapping := (aDescriptor newMapping: DirectMapping)		fromPseudoVariable: #isIdentityColumn		type: Integer		to:			([:each | 				| tableExp objectId | 				tableExp := each getTable: table.				objectId := ((tableExp getField: schemaField) , '.', (tableExp getField: tableField)) objectId.				objectId columnPropertySchema: (tableExp getField: columnField) property: 'IsIdentity']			asGlorpExpressionForDescriptor: aDescriptor).	isIDMapping readOnly: true.	isIDMapping shouldProxy: false.	^super fieldTypeMappingFor: aDescriptor</body><body package="GlorpAnalysis">getExtraInformationFor: aContext inBuilder: anElementBuilder	"SQL Server identity column information."		| field mapping |	mapping := anElementBuilder descriptor mappingForAttributeNamed:			#isIdentityColumn.	field := anElementBuilder fieldTranslations keys		detect: [:each | each name asSymbol = #COLUMNPROPERTY].	^( (mapping valueInBuilder: anElementBuilder as: field) = 1) ifTrue: ['IDENTITY'] ifFalse: [nil].</body></methods><methods><class-id>Glorp.SQLServerMetadataDescriptorSystem</class-id> <category>helpers</category><body package="GlorpAnalysis">targetOfForeignKeysConstraintTypeString	"SQLServer version 10 and after makes unique constraints the target of foreign key constraints, whereas earlier versions of SQLServer make primary key constraints the target.  This method checks the version to determine the string ('PRIMARY KEY' or 'UNIQUE') we expect in the database constraints table for the constraint type that is the target of foreign key constraints.  When found, we cache the value as a standalone function on the platform instance, just in case we ever want to use it in a query clause such as	read: PrimaryKeyConstraint	where: [:each | each targetOfForeignKeysConstraintTypeString = each type]where it will provide the value ('PRIMARY KEY' or 'UNIQUE') - provided this method has been called beforehand of course."	^(self platform functions		at: #targetOfForeignKeysConstraintTypeString		ifAbsentPut:			[(StandaloneFunction named:				((self session accessor connection dbmsVersion copyUpTo: $.) asNumber &gt;= 10					ifFalse: [super targetOfForeignKeysConstraintTypeString]					ifTrue: ['UNIQUE']))				type: self platform varchar;				yourself])			name</body></methods><methods><class-id>Glorp.MySQLMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">extraFieldsForTypeIn: table	"Return an additional fields we're going to need in order to determine the data type of a column."	^Array with: (table fieldNamed: 'extra').</body><body package="GlorpAnalysis">getExtraInformationFor: aContext inBuilder: anElementBuilder	"MySQL has extra type information in the field called EXTRA."	| field |	field := anElementBuilder descriptor table fieldNamed: 'extra'.	^anElementBuilder valueOfField: (aContext translateField: field).</body></methods><methods><class-id>Glorp.MySQLMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis">tableForCOLUMNS: aTable	super tableForCOLUMNS: aTable.	"aTable createFieldNamed: 'numeric_scale' type: platform int4."	aTable createFieldNamed: 'extra' type: (platform varchar: 255).</body><body package="GlorpAnalysis">tableForKEY_COLUMN_USAGE: aTable	| columns |	super tableForKEY_COLUMN_USAGE: aTable.	aTable createFieldNamed: 'referenced_table_schema' type: (platform varchar: 255).	aTable createFieldNamed: 'referenced_table_name' type: (platform varchar: 255).	aTable createFieldNamed: 'referenced_column_name' type: (platform varchar: 255).	columns := self columnsTable.	aTable addForeignKeyFrom: (aTable fieldNamed: 'referenced_table_name') to: (columns fieldNamed: 'table_name')		from: (aTable fieldNamed: 'referenced_table_schema') to: (columns fieldNamed: 'table_schema')		from: (aTable fieldNamed: 'referenced_column_name') to: (columns fieldNamed: 'column_name').</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">descriptorForDatabaseField: aDescriptor	| table usageTable constraintTable isPkMapping refTable typeField widthField precisionField scaleField |	table := self tableNamed: 'all_tab_columns'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'column_name').	(aDescriptor newMapping: OneToOneMapping) 		attributeName: #table.	(aDescriptor newMapping: DirectMapping) 		from: #isNullable to: (table fieldNamed: 'nullable');		converter: (self platform converterNamed: #booleanToStringYN).	typeField := table fieldNamed: 'data_type'.	widthField := table fieldNamed: self characterLengthFieldName.	precisionField := table fieldNamed: 'data_precision'.	scaleField := table fieldNamed: 'data_scale'.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #type		fromDb: 			[:row :elementBuilder :context |			self platform				typeWithDatabaseName: (elementBuilder valueOfField: (context translateField: typeField))				characterWidth: (elementBuilder valueOfField: (context translateField: widthField))				precision: (elementBuilder valueOfField: (context translateField: precisionField))				scale: (elementBuilder valueOfField: (context translateField: scaleField))]		toDb: [:rows :attribute :attributeRows | (rows at: table) at: typeField put: attribute typeName]		mappingFields: (Array				with: typeField				with: widthField				with: precisionField				with: scaleField).	usageTable := self tableNamed: 'all_cons_columns'.	constraintTable := self tableNamed: 'all_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #primaryKeyConstraints;		referenceClass: PrimaryKeyConstraint;		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'owner') to: (usageTable fieldNamed: 'owner')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'owner') to: (constraintTable fieldNamed: 'owner')			from: (usageTable fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from:  'P' to: (constraintTable fieldNamed: 'constraint_type')).	isPkMapping := (aDescriptor newMapping: DirectMapping) 		from: #isPrimaryKey 		to: [:each | each primaryKeyConstraints notEmpty].	isPkMapping shouldProxy: true.	refTable := self tableNamed: 'all_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #constraintsTargetingMe;		referenceClass: ReferentialConstraint;		beForPseudoVariable;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'position'];		join: (Join			from: (table fieldNamed: 'column_name') to: (usageTable fieldNamed: 'column_name')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name')			from: (table fieldNamed: 'owner') to: (usageTable fieldNamed: 'owner'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constraint_name') to: (refTable fieldNamed: 'constraint_name')			from: (usageTable fieldNamed: 'owner') to: (refTable fieldNamed: 'owner')).	"initialize any variables that reading from the database will not set	(these values should be the same as in DatabaseField&gt;&gt;initialize).	The database cannot know whether a given field is a lockField."	(aDescriptor newMapping: ConstantMapping)		attributeName: #isLockKey;		constantValue: false.</body><body package="GlorpAnalysis">descriptorForDatabaseIndex: aDescriptor</body><body package="GlorpAnalysis">descriptorForDatabaseTable: aDescriptor	| table constraintTable |	table := self tableNamed: 'all_tables'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'table_name').	(aDescriptor newMapping: DirectMapping) from: 'schema' to: (table fieldNamed: 'owner').	(aDescriptor newMapping: ToManyMapping)		attributeName: #fields.	constraintTable := self tableNamed: 'all_constraints'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #foreignKeyConstraints;			referenceClass: ForeignKeyConstraint;		join: (Join			from: (table fieldNamed: 'owner') to: (constraintTable fieldNamed: 'owner')			from: (table fieldNamed: 'table_name') to: (constraintTable fieldNamed: 'table_name')			from: 'R' to: (constraintTable fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis">descriptorForForeignKeyConstraint: aDescriptor	| table usageTable columns targetFieldMapping |	table := self tableNamed: 'all_constraints'.	aDescriptor table: table.	aDescriptor directMapping from: 'name' to: (table fieldNamed: 'constraint_name').	"We have to make sure we map our primary keys directly. Otherwise we'll get into trying to use the relationship mappings to find foreign key values and it gets ugly. Make them pseudo-variables so we don't have to actually create inst vars for them."	(aDescriptor directMapping from: #schema to: (table fieldNamed: 'owner')) beForPseudoVariable.	(aDescriptor directMapping from: #tableName to: (table fieldNamed: 'table_name')) beForPseudoVariable.	(aDescriptor directMapping from: #tableSchema to: (table fieldNamed: 'owner')) beForPseudoVariable.	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	usageTable := self tableNamed: 'all_cons_columns'.	columns := self tableNamed: 'all_tab_columns'.	(aDescriptor newMapping: ToManyMapping)		attributeName: #sourceFields;		referenceClass: DatabaseField;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'position'];		join: (Join			from: (table fieldNamed: 'constraint_name') to: (usageTable fieldNamed: 'constraint_name')			from: (table fieldNamed: 'owner') to: (usageTable fieldNamed: 'owner')			from: (table fieldNamed: 'table_name') to: (usageTable fieldNamed: 'table_name'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'owner') to: (columns fieldNamed: 'owner')			from: (usageTable fieldNamed: 'table_name') to: (columns fieldNamed: 'table_name')			from: (usageTable fieldNamed: 'column_name') to: (columns fieldNamed: 'column_name')).	aDescriptor oneToOneMapping		attributeName: #table;		referenceClass: DatabaseTable;		beForPseudoVariable;		join: (Join 			from: (table fieldNamed: 'owner') to: ((self tableNamed: 'all_tables') fieldNamed: 'owner')			from: (table fieldNamed: 'table_name') to: ((self tableNamed: 'all_tables') fieldNamed: 'table_name')).	targetFieldMapping := aDescriptor toManyMapping		attributeName: #targetFields;		join: [:eachField | eachField primaryKeyConstraints foreignKeyConstraintsUsingMeAsTargetConstraint ] .	"Note that to get the link table to order by, we need to refer to it in terms of the relationship that controls it, not just ask the base for that table."	targetFieldMapping orderBy: [:eachField | (eachField primaryKeyConstraints getTable: usageTable) getField: 'position'].</body><body package="GlorpAnalysis">descriptorForNamedSequence: aDescriptor	| table |	table := self tableNamed: 'all_sequences'.	aDescriptor table: table.		aDescriptor directMapping from: 'name' to: (table fieldNamed: 'sequence_name').	aDescriptor directMapping from: 'schema' to: (table fieldNamed: 'sequence_owner').</body><body package="GlorpAnalysis">descriptorForPrimaryKeyConstraint: aDescriptor	| table constraintTable tableTable |	table := self tableNamed: 'all_constraints'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'constraint_name').	(aDescriptor directMapping from: #type to: (table fieldNamed: 'constraint_type')) beForPseudoVariable.	tableTable := self tableNamed: 'all_tables'.	aDescriptor oneToOneMapping		attributeName: #table;		join: (Join 			from: (table fieldNamed: 'table_name') to: (tableTable fieldNamed: 'table_name')			from: (table fieldNamed: 'owner') to: (tableTable fieldNamed: 'owner')).	constraintTable := self tableNamed: 'all_constraints'.	aDescriptor oneToOneMapping		attributeName: #foreignKeyConstraintsUsingMeAsTargetConstraint;		referenceClass: ForeignKeyConstraint;		beForPseudoVariable;		join: (Join			from: (table fieldNamed: 'constraint_name') to: (constraintTable fieldNamed: 'r_constraint_name')			from: (table fieldNamed: 'owner') to: (constraintTable fieldNamed: 'r_owner')			from: 'R' to: (constraintTable fieldNamed: 'constraint_type')).</body><body package="GlorpAnalysis">descriptorForReferentialConstraint: aDescriptor	| table |	table := self tableNamed: 'all_constraints'.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'constraint_name').</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>accessing</category><body package="GlorpAnalysis">allTableNames	^#()</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis">tableForALL_CONSTRAINTS: aTable	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'owner' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_type' type: (platform varchar: 255)) bePrimaryKey. 	(aTable createFieldNamed: 'r_constraint_name' type: (platform varchar: 255)).	(aTable createFieldNamed: 'r_owner' type: (platform varchar: 255)).</body><body package="GlorpAnalysis">tableForALL_CONS_COLUMNS: aTable	(aTable createFieldNamed: 'owner' type: (platform varchar: 30)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 30)) bePrimaryKey.	(aTable createFieldNamed: 'table_name' type: (platform varchar: 30)) bePrimaryKey.	(aTable createFieldNamed: 'column_name' type: (platform varchar: 4000)) bePrimaryKey.	(aTable createFieldNamed: 'position' type: (platform int4)).</body><body package="GlorpAnalysis">tableForALL_SEQUENCES: aTable	| |	(aTable createFieldNamed: 'sequence_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'sequence_owner' type: (platform varchar: 255)) bePrimaryKey.</body><body package="GlorpAnalysis">tableForALL_TABLES: aTable	(aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'owner' type: (platform varchar: 255)) bePrimaryKey.</body><body package="GlorpAnalysis">tableForALL_TAB_COLUMNS: aTable	| tableName schema |	tableName := (aTable createFieldNamed: 'table_name' type: (platform varchar: 255)) bePrimaryKey.	schema := (aTable createFieldNamed: 'owner' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'column_name' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tableNamed: 'all_tables') fieldNamed: 'table_name')		from: schema to: ((self tableNamed: 'all_tables') fieldNamed: 'owner').	aTable createFieldNamed: 'column_id' type: platform int4.	aTable createFieldNamed: 'nullable' type: (platform char: 1).	aTable createFieldNamed: 'data_type' type: (platform varchar: 255).	aTable createFieldNamed: 'char_length' type: platform int4.	aTable createFieldNamed: 'data_precision' type: platform int4.	aTable createFieldNamed: 'data_scale' type: platform int4.</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>helpers</category><body package="GlorpAnalysis">characterLengthFieldName	^'char_length'.</body><body package="GlorpAnalysis">foreignKeyConstraintTypeString	"Return the string we expect in the database table for constraints to distinguish foreign key constraints from others."	^'R'.</body><body package="GlorpAnalysis">targetOfForeignKeysConstraintTypeString	"Return the string we expect in the database constraints table for the constraint type that is the target of foreign key constraints."	^'P'</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>classes</category><body package="GlorpAnalysis">constructAllClasses	^(super constructAllClasses)		add: DatabaseField;		add: DatabaseTable;		add: DatabaseIndex;		add: ForeignKeyConstraint;		add: PrimaryKeyConstraint;		add: ReferentialConstraint;		add: NamedSequence;		yourself.</body></methods><methods><class-id>Glorp.OracleMetadataDescriptorSystem</class-id> <category>private</category><body package="GlorpAnalysis">deferentialSetSchema: newTable	"Oracle's metadata descriptor system doesn't use the user's schema. Leaving the schema empty has always worked."</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id> <category>initialize-release</category><body package="GlorpAnalysis">initialize	commands := OrderedCollection new: 500.</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id> <category>notification</category><body package="GlorpAnalysis">command: aDatabaseCommand	commands add: aDatabaseCommand-&gt;nil.</body><body package="GlorpAnalysis">time: aTime	"Make sure we log at least 1ms for each command"	commands last value: (aTime max: 1).</body><body package="GlorpAnalysis">update: eventName with: aParameter	self perform: eventName with: aParameter.</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id> <category>hookup</category><body package="GlorpAnalysis">connectTo: aSession	session := aSession.	session accessor addDependent: self.</body><body package="GlorpAnalysis">disconnectFrom: aSession	session := aSession.	session accessor removeDependent: self.</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer</class-id> <category>reporting</category><body package="GlorpAnalysis">commandsByTime	^commands asSortedCollection: [:a :b | (a value ifNil: [0]) &gt;= (b value ifNil: [0])].</body><body package="GlorpAnalysis">commandsForTableNamed: aTableName	"Return a list of all the commands, with their time, associated with aTable"	| table |	table := session system tableNamed: aTableName.	^commands select: [:each |  		each key tables includes: table].</body><body package="GlorpAnalysis">privateCommands	^commands.</body><body package="GlorpAnalysis">subsume: aGlorpQueryPerformanceAnalyzer	"Add in the data from this other session."	commands addAll: aGlorpQueryPerformanceAnalyzer privateCommands.</body><body package="GlorpAnalysis">summaryByTypeOfTimesByTable	| readSummary writeSummary |	readSummary := Dictionary new.	readSummary at: #READS put: 0.	writeSummary := Dictionary new.	writeSummary at: #WRITES put: 0.	commands do: [:each |  | summary |		summary := (each key isKindOf: RowBasedCommand) 			ifTrue: [				writeSummary at: #WRITES put: (writeSummary at: #WRITES) + each value.				writeSummary] 			ifFalse: [				readSummary at: #READS put: (readSummary at: #READS) + each value.				readSummary].		summary at: #totalNumberOfQueries put: (summary at: #totalNumberOfQueries ifAbsentPut: [0]) + 1.		each key tables do: [:eachTable |			summary at: (self translateTable: eachTable) put: (summary at: (self translateTable: eachTable) ifAbsentPut: [0]) + each value]].	^Array with: readSummary with: writeSummary.</body><body package="GlorpAnalysis">summaryOfCountsByTable	| summary |	summary := Dictionary new.	commands do: [:each | 		each key tables do: [:eachTable |			summary at: (self translateTable: eachTable) put: (summary at: (self translateTable: eachTable) ifAbsentPut: [0]) + 1]].	^summary.</body><body package="GlorpAnalysis">summaryOfTimesByTable	| summary |	summary := Dictionary new.	commands do: [:each | 		each key tables do: [:eachTable |			summary at: (self translateTable: eachTable) put: (summary at: (self translateTable: eachTable) ifAbsentPut: [0]) + each value]].	^summary.</body><body package="GlorpAnalysis">totalTime	^commands inject: 0 into: [:sum :each | sum + each value].</body><body package="GlorpAnalysis">translateTable: aTable	"In case we've subsumed multiple sessions, normalize them all to the main one."	^session system tableNamed: aTable name.</body></methods><methods><class-id>Glorp.GlorpQueryPerformanceAnalyzer class</class-id> <category>instance creation</category><body package="GlorpAnalysis">for: aSession	"Hook us up to aSession"	^self new connectTo: aSession.</body><body package="GlorpAnalysis">for: aSession during: aBlock	| monitor |	monitor := self for: aSession.	aBlock ensure: [monitor disconnectFrom: aSession].	^monitor.</body><body package="GlorpAnalysis">monitor: aSession forSeconds: seconds	^self for: aSession during: [(Delay forSeconds: seconds) wait].</body><body package="GlorpAnalysis">new	^super new initialize.</body></methods><methods><class-id>Glorp.DB2MetadataDescriptorSystem</class-id> <category>initialization</category><body package="GlorpAnalysis">constructAllTables	"Subclasses can override this method to add tables to the list. But by default we also look for all table methods in our system, and add them to the class list, so if the methods are written there, then we don't need to do anything further. If the table methods are defined on the classes themselves, then we'll still have to construct the list manually."	self allTableNames do: [:each | 		self tableNamed: each asString].	"self constructTablesFromInitializeMethods."	^tables.</body></methods><methods><class-id>Glorp.DB2MetadataDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpAnalysis">baseDescriptorForDatabaseField: aDescriptor	"This is very like super descriptorForField:  some column names are different, as is the boolean to text converter."	"Map the Field object to the associated columns in the COLUMNS table.	The inst vars #type and #defaultValue use AdHocMappings, and their mappings	are described in their own respective methods, &gt;&gt;fieldTypeMappingFor:, and	&gt;&gt;fieldDefaultValueMappingFor:, as shown."	| table usageTable constraintTable isPkMapping |	table := self columnsTable.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'colname').	(aDescriptor newMapping: OneToOneMapping) 		attributeName: #table.	(aDescriptor newMapping: DirectMapping) 		from: #isNullable to: (table fieldNamed: 'nulls');		converter: (self platform converterNamed: #booleanToStringYN).	self fieldTypeMappingFor: aDescriptor.	self fieldDefaultValueMappingFor: aDescriptor.	usageTable := self keyColumnUsageTable.	constraintTable := self constraintsTable.	(aDescriptor newMapping: ToManyMapping)		attributeName: #primaryKeyConstraints;		referenceClass: PrimaryKeyConstraint;		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'colname') to: (usageTable fieldNamed: 'colname')			from: (table fieldNamed: 'tabschema') to: (usageTable fieldNamed: 'tabschema')			from: (table fieldNamed: 'tabname') to: (usageTable fieldNamed: 'tabname'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constname') to: (constraintTable fieldNamed: 'constname')			from: (usageTable fieldNamed: 'tabschema') to: (constraintTable fieldNamed: 'tabschema')			from: (usageTable fieldNamed: 'tabname') to: (constraintTable fieldNamed: 'tabname')			from:  'P' to: (constraintTable fieldNamed: 'type')).	isPkMapping := (aDescriptor newMapping: DirectMapping) 		from: #isPrimaryKey 		to: [:each | each primaryKeyConstraints notEmpty].	isPkMapping shouldProxy: false.	"initialize any variables that reading from the database will not set	(these values should be the same as in DatabaseField&gt;&gt;initialize).	The database cannot know whether a given field is a lockField."	(aDescriptor newMapping: ConstantMapping)		attributeName: #isLockKey;		constantValue: false.</body><body package="GlorpAnalysis">baseDescriptorForPrimaryKeyConstraint: aDescriptor	"Note that this maps to the same table as a ForeignKeyConstraint, and I haven't bothered to do any inheritance, just relying on the joins in the relationships to distinguish the two. Also, we don't really have to map anything at all here, but the name is useful for telling instances apart, if we ever got instances."	| table tableTable |	table := self constraintsTable.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'constname').	(aDescriptor directMapping from: #type to: (table fieldNamed: 'type')) beForPseudoVariable.	tableTable := self tablesTable.	aDescriptor oneToOneMapping		attributeName: #table;		join: (Join 			from: (table fieldNamed: 'tabname') to: (tableTable fieldNamed: 'tabname')			from: (table fieldNamed: 'tabschema') to: (tableTable fieldNamed: 'tabschema')).</body><body package="GlorpAnalysis">baseFieldTypeMappingFor: aDescriptor	| table typeField widthField scaleField |	table := aDescriptor table.	typeField := table fieldNamed: 'typename'.	widthField := table fieldNamed: self characterLengthFieldName.	"This is also the precisionField for numeric types"	scaleField := table fieldNamed: 'scale'.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #type		fromDb:			[:row :elementBuilder :context || glorpType |			glorpType := self platform				typeWithDatabaseName:					(elementBuilder valueOfField: (context translateField: typeField))				characterWidth:					(elementBuilder valueOfField: (context translateField: widthField))				extraInformation:					(self getExtraInformationFor: context inBuilder: elementBuilder).			glorpType class = GlorpNumericType ifTrue:				[glorpType					precision: (elementBuilder valueOfField: (context translateField: widthField));					scale: (elementBuilder valueOfField: (context translateField: scaleField))].			glorpType]		toDb: [:rows :attribute :attributeRows | (rows at: table) at: typeField put: attribute typeName]		mappingFields: (Array with: typeField with: widthField with: scaleField), (self extraFieldsForTypeIn: table).</body><body package="GlorpAnalysis">descriptorForDatabaseField: aDescriptor	| table refTable usageTable |	self baseDescriptorForDatabaseField: aDescriptor.	table := aDescriptor table.	usageTable := self keyColumnUsageTable.	refTable := self constraintsUsageReferenceTable.	(aDescriptor newMapping: ToManyMapping)		attributeName: #constraintsTargetingMe;		referenceClass: ReferentialConstraint;		beForPseudoVariable;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'colseq'];		join: (Join			from: (table fieldNamed: 'colname') to: (usageTable fieldNamed: 'colname')			from: (table fieldNamed: 'tabname') to: (usageTable fieldNamed: 'tabname')			from: (table fieldNamed: 'tabschema') to: (usageTable fieldNamed: 'tabschema'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constname') to: (refTable fieldNamed: 'constraint_name')).</body><body package="GlorpAnalysis">descriptorForDatabaseTable: aDescriptor	| table usageTable constraintTable map query |	table := self tablesTable.	aDescriptor table: table.		(aDescriptor newMapping: DirectMapping) from: 'name' to: (table fieldNamed: 'tabname').	(aDescriptor newMapping: DirectMapping) from: 'schema' to: (table fieldNamed: 'tabschema').	(aDescriptor newMapping: ToManyMapping)		attributeName: #fields.	usageTable := self keyColumnUsageTable.	constraintTable := self constraintsTable.	map := (aDescriptor newMapping: ToManyMapping)		attributeName: #foreignKeyConstraints;		referenceClass: ForeignKeyConstraint;		useLinkTable;		join: (Join			from: (table fieldNamed: 'tabschema') to: (usageTable fieldNamed: 'tabschema')			from: (table fieldNamed: 'tabname') to: (usageTable fieldNamed: 'tabname'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'constname') to: (constraintTable fieldNamed: 'constname')			from: (usageTable fieldNamed: 'tabschema') to: (constraintTable fieldNamed: 'tabschema')			from: (usageTable fieldNamed: 'tabname') to: (constraintTable fieldNamed: 'tabname')			from:  'F' to: (constraintTable fieldNamed: 'type')).	query := map buildQuery.	query baseExpression requiresDistinct: true.</body><body package="GlorpAnalysis">descriptorForForeignKeyConstraint: aDescriptor	"DB2 doesn't include a systabs.tabconst-&gt;constschema field. Perhaps it is always the same as tabschema."	| table usageTable columns targetFieldMapping |	table := self constraintsTable.	aDescriptor table: table.	aDescriptor directMapping from: #name to: (table fieldNamed: 'constname').	"We have to make sure we map our primary keys directly. Otherwise we'll get into trying to use the relationship mappings to find foreign key values and it gets ugly. Make them pseudo-variables so we don't have to actually create inst vars for them."	"(aDescriptor directMapping from: #schema to: (table fieldNamed: 'tabschema')) beForPseudoVariable."	(aDescriptor directMapping from: #tableName to: (table fieldNamed: 'tabname')) beForPseudoVariable.	(aDescriptor directMapping from: #tableSchema to: (table fieldNamed: 'tabschema')) beForPseudoVariable.	(aDescriptor directMapping from: #type to: (table fieldNamed: 'type')) beForPseudoVariable.	usageTable := self keyColumnUsageTable.	columns := self columnsTable.	(aDescriptor newMapping: ToManyMapping)		attributeName: #sourceFields;		referenceClass: DatabaseField;		useLinkTable;		orderBy: [:each | (each getTable: usageTable) getField: 'colseq'];		join: (Join			from: (table fieldNamed: 'constname') to: (usageTable fieldNamed: 'constname')			from: (table fieldNamed: 'tabschema') to: (usageTable fieldNamed: 'tabschema')			from: (table fieldNamed: 'tabname') to: (usageTable fieldNamed: 'tabname'));		reverseJoin: (Join			from: (usageTable fieldNamed: 'tabschema') to: (columns fieldNamed: 'tabschema')			from: (usageTable fieldNamed: 'tabname') to: (columns fieldNamed: 'tabname')			from: (usageTable fieldNamed: 'colname') to: (columns fieldNamed: 'colname')).	targetFieldMapping := aDescriptor toManyMapping		attributeName: #targetFields;		join: [:eachField | eachField primaryKeyConstraints foreignKeyConstraintsUsingMeAsTargetConstraint].	"Note that to get the link table to order by, we need to refer to it in terms of the relationship that controls it, not just ask the base for that table."	targetFieldMapping orderBy: [:eachField | (eachField primaryKeyConstraints getTable: usageTable) getField: 'colseq'].</body><body package="GlorpAnalysis">descriptorForNamedSequence: aDescriptor	"The SEQUENCES table has these fields of interest: SEQSCHEMA, SEQNAME, OWNER, OWNERTYPE, SEQID, SEQTYPE (S or I), INCREMENT, START, MAXVAL, MINVAL, and more."	| table |	table := self tableNamed: 'sequences'.	aDescriptor table: table.		aDescriptor directMapping from: 'schema' to: (table fieldNamed: 'seqschema').	aDescriptor directMapping from: 'name' to: (table fieldNamed: 'seqname').</body><body package="GlorpAnalysis">descriptorForPrimaryKeyConstraint: aDescriptor	"See super class comments. In addition, since syscat.tabconst has no constschema field (and there is no sysibm.table_constraints table, either), then it seems sensible to assume that the constraint schema is identical to the table schema, which is encoded here."	| table refConstraintTable |	self baseDescriptorForPrimaryKeyConstraint: aDescriptor.	table := aDescriptor primaryTable.	refConstraintTable := self constraintsUsageReferenceTable.	aDescriptor oneToOneMapping		attributeName: #foreignKeyConstraintsUsingMeAsTargetConstraint;		referenceClass: ForeignKeyConstraint;		useLinkTable;		beForPseudoVariable;		join: (Join			from: (table fieldNamed: 'constname') to: (refConstraintTable fieldNamed: 'unique_constraint_name')			from: (table fieldNamed: 'tabschema') to: (refConstraintTable fieldNamed: 'unique_constraint_schema'));		reverseJoin: (Join 			from: (refConstraintTable fieldNamed: 'constraint_schema') to: (table fieldNamed: 'tabschema')			from: (refConstraintTable fieldNamed: 'constraint_name') to: (table fieldNamed: 'constname')			from: 'F' to: (table fieldNamed: 'type')).</body><body package="GlorpAnalysis">descriptorForReferentialConstraint: aDescriptor	"We don't really have to map anything at all here to real variables, but the name is useful for telling instances apart, if we ever got instances. Other than that everything is pseudovariables.	Note 1: unique_constraint_name is what we call it, but the constraint is really ID'd using constraint_name.	Note 2: usage table doesn't have constraint_schema. This is because DB2 generates unique internal names?"	| table usageTable columns |	table := self constraintsUsageReferenceTable.	aDescriptor table: table.		aDescriptor directMapping from: 'name' to: (table fieldNamed: 'constraint_name').	usageTable := self keyColumnUsageTable.	columns := self columnsTable.	aDescriptor oneToOneMapping		attributeName: #targetField;		referenceClass: DatabaseField;		beForPseudoVariable;		useLinkTable;		join: (Join			from: (table fieldNamed: 'unique_constraint_name') to: (usageTable fieldNamed: 'constname'));		reverseJoin: (Join 			from: (usageTable fieldNamed: 'tabschema') to: (columns fieldNamed: 'tabschema')			from: (usageTable fieldNamed: 'tabname') to: (columns fieldNamed: 'tabname')			from: (usageTable fieldNamed: 'colname') to: (columns fieldNamed: 'colname')).</body><body package="GlorpAnalysis">fieldDefaultValueMappingFor: aDescriptor	"The DB keeps column_default as a string.  Since the default value can include arithmetic values, function calls, etc., we try seveal methods to recover the value.  To use this mapping to de-convert the string to our field's type, we need the builder's field (called &gt;&gt;instance) to have its type already built, since the block uses that GlorpType to understand the 'default' string."		| table defaultValueField |	table := aDescriptor table.	defaultValueField := table fieldNamed: 'default'.	(aDescriptor newMapping: AdHocMapping)		forAttribute: #dbDefaultValue		fromDb:			[:row :elementBuilder :context | 			[self platform				toGlorpType: (elementBuilder instance type)				fromString: (elementBuilder valueOfField: (context translateField: defaultValueField))]					on: Error					do: [:ex || aDBMSDefaultValueString |						aDBMSDefaultValueString := elementBuilder valueOfField: (context translateField: defaultValueField).						ex return: aDBMSDefaultValueString]]		toDb: [:rows :attribute :attributeRows | ]		mappingFields: (Array with: defaultValueField).</body><body package="GlorpAnalysis">fieldTypeMappingFor: aDescriptor	"For DB2, if columns.identity = 'Y', then this field is an IDENTITY column "		| table isIDMapping |	table := aDescriptor table.	isIDMapping := (aDescriptor newMapping: DirectMapping)		fromPseudoVariable: #isIdentityColumn		to: (table fieldNamed: 'identity');		converter: (self platform converterNamed: #booleanToStringYN).	isIDMapping readOnly: true.	isIDMapping shouldProxy: false.	^self baseFieldTypeMappingFor: aDescriptor</body><body package="GlorpAnalysis">getExtraInformationFor: aContext inBuilder: anElementBuilder	"DB2 identity column information."		| field mapping |	mapping := anElementBuilder descriptor mappingForAttributeNamed:			#isIdentityColumn.	field := anElementBuilder fieldTranslations keys		detect: [:each | each name asSymbol = #identity].	^(mapping valueInBuilder: anElementBuilder as: field) ifTrue: ['IDENTITY'] ifFalse: [nil].</body></methods><methods><class-id>Glorp.DB2MetadataDescriptorSystem</class-id> <category>helpers</category><body package="GlorpAnalysis">characterLengthFieldName	^'length'.</body><body package="GlorpAnalysis">foreignKeyConstraintTypeString	"Return the string we expect in the database table for constraints to distinguish foreign key constraints from others."	^'F'.</body><body package="GlorpAnalysis">targetOfForeignKeysConstraintTypeString	"Return the string we expect in the database constraints table for the constraint type that is the target of foreign key constraints."	^'P'</body></methods><methods><class-id>Glorp.DB2MetadataDescriptorSystem</class-id> <category>table roles</category><body package="GlorpAnalysis">constraintsTable	^self tableNamed: 'TABCONST'</body><body package="GlorpAnalysis">keyColumnUsageTable	^self tableNamed: 'KEYCOLUSE'</body></methods><methods><class-id>Glorp.DB2MetadataDescriptorSystem</class-id> <category>tables</category><body package="GlorpAnalysis">allTableNames	^#(columns keycoluse referential_constraints tables tabconst sequences)</body><body package="GlorpAnalysis">informationSchemaName	"Return the name of the schema we'll use for the information_schema tables. Typically we'd expect that to be information_schema, but it isn't necessarily so."		^'SYSCAT'</body><body package="GlorpAnalysis">sysibmSchemaName	"This is the more private view of system tables. Its use is discouraged by IBM, but	the views offered here are often more complient with the current information_schema spec."		^'SYSIBM'</body><body package="GlorpAnalysis">tableForCOLUMNS: aTable	| tableName schema |	aTable schema: self informationSchemaName.	tableName := (aTable createFieldNamed: 'tabname' type: (platform varchar: 255)) bePrimaryKey.	schema := (aTable createFieldNamed: 'tabschema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'colname' type: (platform varchar: 255)) bePrimaryKey.	aTable 		addForeignKeyFrom: tableName to: ((self tablesTable) fieldNamed: 'tabname')		from: schema to: ((self tablesTable) fieldNamed: 'tabschema').	aTable createFieldNamed: 'colno' type: platform int2.	aTable createFieldNamed: 'typename' type: (platform varchar: 128).	aTable createFieldNamed: 'length' type: platform int4.	"This serves as precision for DECIMAL columns."	aTable createFieldNamed: 'scale' type: platform int2.	aTable createFieldNamed: 'default' type: (platform varchar: 254).	aTable createFieldNamed: 'nulls' type: (platform char).	aTable createFieldNamed: 'identity' type: (platform char).	aTable createFieldNamed: 'generated' type: (platform char).</body><body package="GlorpAnalysis">tableForKEYCOLUSE: aTable	"CONSTNAME, TABSCHEMA, TABNAME, COLNAME, COLSEQ.	Note: CONSTNAME is the same as referential_constraints.constraint_name, and I think that column	holds DB2 generated values. Users refer to the constraint by referential_constraints.unique_constraint_name."	| columns constraints |	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'tabname' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'tabschema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'colname' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constname' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'colseq' type: platform int4.	columns := self columnsTable.	aTable addForeignKeyFrom: (aTable fieldNamed: 'tabname') to: (columns fieldNamed: 'tabname')		from: (aTable fieldNamed: 'tabschema') to: (columns fieldNamed: 'tabschema')		from: (aTable fieldNamed: 'colname') to: (columns fieldNamed: 'colname').	constraints := self constraintsTable.	aTable addForeignKeyFrom: (aTable fieldNamed: 'constname') to: (constraints fieldNamed: 'constname').</body><body package="GlorpAnalysis">tableForREFERENTIAL_CONSTRAINTS: aTable	"We need the sysibm.referential_constraints table because the current syscat.references	table gives one row per constraint, and lists the fields together in a single large column,	which isn't as convenient as the sysibm view.	Also, we ignore CONSTRAINT_CATALOG and UNIQUE_CONSTRAINT_CATALOG."	aTable schema: self sysibmSchemaName.	(aTable createFieldNamed: 'constraint_name' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'constraint_schema' type: (platform varchar: 255)) bePrimaryKey.	aTable createFieldNamed: 'unique_constraint_schema' type: (platform varchar: 255).	aTable createFieldNamed: 'unique_constraint_name' type: (platform varchar: 255).	"aTable createFieldNamed: 'table_name' type: (platform varchar: 255)."</body><body package="GlorpAnalysis">tableForSEQUENCES: aTable	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'seqschema' type: (platform varchar: 128)) bePrimaryKey.	(aTable createFieldNamed: 'seqname' type: (platform varchar: 128)) bePrimaryKey.</body><body package="GlorpAnalysis">tableForTABCONST: aTable	"Note: constraint_schema is missing from this DB2 table.	Either it is in the table schema, or it isn't needed."	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'constname' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'tabname' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'tabschema' type: (platform varchar: 255)) bePrimaryKey.	(aTable createFieldNamed: 'type' type: (platform varchar: 255)) bePrimaryKey.  "F for foreign key"</body><body package="GlorpAnalysis">tableForTABLES: aTable	aTable schema: self informationSchemaName.	(aTable createFieldNamed: 'tabname' type: (platform varchar: 128)) bePrimaryKey.	(aTable createFieldNamed: 'tabschema' type: (platform varchar: 128)) bePrimaryKey.	aTable createFieldNamed: 'type' type: (platform char).</body></methods><methods><class-id>Glorp.DB2MetadataDescriptorSystem</class-id> <category>api</category><body package="GlorpAnalysis">databaseIdentitySequenceNamed: aString	^sequences at: aString asUppercase ifAbsentPut: [platform newDatabaseIdentitySequenceNamed: aString].</body></methods><methods><class-id>Glorp.SQLite3IndexData</class-id> <category>accessing</category><body package="GlorpAnalysis">indexColumnsData	^indexColumnsData</body><body package="GlorpAnalysis">indexColumnsData: anObject	indexColumnsData := anObject</body><body package="GlorpAnalysis">name	^name</body><body package="GlorpAnalysis">name: anObject	name := anObject</body><body package="GlorpAnalysis">seq	^seq</body><body package="GlorpAnalysis">seq: anObject	seq := anObject</body><body package="GlorpAnalysis">unique	^unique</body><body package="GlorpAnalysis">unique: anObject	unique := anObject</body></methods><methods><class-id>Glorp.SQLite3IndexData</class-id> <category>converting</category><body package="GlorpAnalysis">asOrderedFieldsForTable: aTable	"Return a list of aTable's fields referenced by me, sorted	according to the seqno inst var."	^self columnDataSortedBySeq collect: 			[:columnDatum |			aTable fields detect: [:fld | fld name = columnDatum name]				ifNone: [self error: 'Cannot find indexed column.']]</body><body package="GlorpAnalysis">columnDataSortedBySeq	"Return my list of columns, sorted according to the seq inst var."	^self indexColumnsData asSortedCollection: [:a :b | a seqno &lt;= b seqno]</body><body package="GlorpAnalysis">columnNames	"Return my list of column names, unsorted."	^self indexColumnsData collect: [:each| each name]</body></methods><methods><class-id>Glorp.SQLite3ForeignKeyData</class-id> <category>accessing</category><body package="GlorpAnalysis">id	^id</body><body package="GlorpAnalysis">id: anObject	id := anObject</body><body package="GlorpAnalysis">match	^match</body><body package="GlorpAnalysis">match: anObject	match := anObject</body><body package="GlorpAnalysis">onDelete	^onDelete</body><body package="GlorpAnalysis">onDelete: anObject	onDelete := anObject</body><body package="GlorpAnalysis">onUpdate	^onUpdate</body><body package="GlorpAnalysis">onUpdate: anObject	onUpdate := anObject</body><body package="GlorpAnalysis">seq	^seq</body><body package="GlorpAnalysis">seq: anObject	seq := anObject</body><body package="GlorpAnalysis">sourceColumnName	^sourceColumnName</body><body package="GlorpAnalysis">sourceColumnName: anObject	sourceColumnName := anObject</body><body package="GlorpAnalysis">sourceTableName	^sourceTableName</body><body package="GlorpAnalysis">sourceTableName: anObject	sourceTableName := anObject</body><body package="GlorpAnalysis">targetColumnName	^targetColumnName</body><body package="GlorpAnalysis">targetColumnName: anObject	targetColumnName := anObject</body><body package="GlorpAnalysis">targetTableName	^targetTableName</body><body package="GlorpAnalysis">targetTableName: anObject	targetTableName := anObject</body></methods><methods><class-id>Glorp.GlorpDoubleType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'double'</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>types</category><body package="GlorpAnalysis">typeWithDatabaseName: aString characterWidth: aNumber precision: precision scale: scale	"(See implementors of #fieldTypeMappingFor: as examples of how other platforms handle numeric types' metadata.)  In Oracle, type NUMBER includes type integer:  an integer is just a NUMBER whose precision is nil and whose scale is 0. That's what Oracle shows in its information schema. (Note that Oracle won't allow us to create a NUMBER column with (NULL, 0) explicitly, but INTEGER works.)	Create table x(id INTEGER) results in a NUMBER(NULL, 0) column type (length=22) in the Oracle all_tab_columns info-schema table.	Create table x(id FLOAT) results in a FLOAT column type (length=22) precision = 126, scale=null.	Create table x(id BINARY_FLOAT) results in a BINARY_FLOAT column type (length=4) precision=null, scale=null.	Create table x(id BINARY_DOUBLE) results in a BINARY_DOUBLE column type (length=8) precision=null, scale=null.	Oracle has no BOOLEAN type: a particular NUMBER(NULL, 0) may in fact be used as a boolean column, storing just 1s and 0s, but we always return the platform's integer type, not its boolean type, when gererating the schema automatically. (The user can alter it later if it is desired that 1 and 0 in that column be mapped as true and false in the image.)"	| glorpType |	glorpType := self typeWithDatabaseName: aString characterWidth: aNumber.	glorpType class = GlorpNumericType ifFalse: [^glorpType].	precision isNil &amp; (scale=0) ifTrue: [^self integer].	^glorpType precision: precision; scale: scale; yourself</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'timetz'</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'char: ', width printString</body></methods><methods><class-id>Glorp.GlorpPGTimestampWithTimeZoneType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'timestamptz'</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'varchar: ', width printString</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'clob'</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	"The approach to getting the source of the block may need development (or replacing with a guaranteed DNU telling the user to add it by hand)."	| w |	w := WriteStream on: String new.	generator class == AdHocVersionGenerator		ifFalse:			[w nextPutAll: 'versionFieldFor: '.			self underlyingType hasParameters ifTrue: [w nextPut: $(].			w nextPutAll: 'platform '.			w nextPutAll: self underlyingType platformSelector.			self underlyingType hasParameters ifTrue: [w nextPut: $)]]		ifTrue:			[w nextPutAll: 'generatorFor: '.			self underlyingType hasParameters ifTrue: [w nextPut: $(].			w nextPutAll: 'platform '.			w nextPutAll: self underlyingType platformSelector.			self underlyingType hasParameters ifTrue: [w nextPut: $)].			w nextPutAll: ' withBlock: '.			w nextPutAll: self generator block method decompiledSource].	^w contents</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'serial'</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'boolean'</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'timestamp'</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	"Since I am almost always called within a 'nextPutAll: ... platformSelector' expression, the asString is almost needless.  However subclass overrides of this all return strings, not symbols, so I should too."	^self selector asString</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	^'time'</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>accessing</category><body package="GlorpAnalysis">platformSelector	| w |	platform supportsVariableSizedNumerics ifFalse: [^super platformSelector].	w := WriteStream on: String new.	w nextPutAll: super platformSelector.	precision isNil ifFalse: 		[w nextPutAll: ' precision: ' , precision printString.		scale isNil ifFalse: [w nextPutAll: '; scale: ' , scale printString].		w nextPutAll: '; yourself'].	^w contents</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GlorpDatabaseType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform selector typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>OraclePlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>VersionType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingType generator generatesOverExistingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>GlorpVarCharType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><class><name>GlorpPGTimestampWithTimeZoneType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpCharType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>GlorpBooleanType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpClobType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpDoubleType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpSerialType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractIntegerType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence increment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpNumericType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>precision scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpPGTimeWithTimeZoneType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpTimeStampType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpTimeType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class></st-source>