<?xml version="1.0"?><st-source><!-- Name: GlorpAtlasUINotice: Copyright 2015-2016 Cincom Systems, Inc.  All rights reserved.Comment: Load and use this simple UI utility in VisualWorks only, not in ObjectStudio.  (ObjectStudio's modelling and mapping tools provide a UI on a much more powerful version of the same capability.)I provide a simple tabular UI to drive the Glorp Atlas, which generates domain classes and a descriptor system from database tables.  To open it, select	Glorp Atlas UIin the launcher's Tools menu, or execute	Glorp.MappingUI open.Successive pages let you choose	- the login to the database	- the tables of interest, the proposed domain class names for themand a final post-generation page provides example Glorp code for connecting.DbIdentifier: bear73DbTrace: 491998DbUsername: nrossDbVersion: 8.2 - 3DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'Tools-NavigationPages' '') #(#any 'GlorpAtlasClassGeneration' '') #(#any 'Tools-Settings-VW' ''))Namespace: GlorpPackageName: GlorpAtlasUIParcel: #('GlorpAtlasUI')ParcelName: GlorpAtlasUIPrerequisiteDescriptions: #(#(#name 'Database' #componentType #package) #(#name 'Tools-NavigationPages' #componentType #package) #(#name 'GlorpAtlasClassGeneration' #componentType #package) #(#name 'Tools-Settings-VW' #componentType #package))PrerequisiteParcels: #(#('Database' '') #('Tools-NavigationPages' '') #('GlorpAtlasClassGeneration' '') #('Tools-Settings-VW' ''))PrintStringCache: (8.2 - 3,nross)Version: 8.2 - 3Date: 1:43:02 PM June 17, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (jun16.3) of June 17, 2016 on June 17, 2016 at 1:43:02 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MappingModel</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedPlatform system inflector classBuilder descriptorClass databaseTables tableSelectionCriteria schema tableNotSelectionCriteria tablesClasses </inst-vars><class-inst-vars>defaultPackage defaultNamespace descriptorClassName defaultDomainSuperclassName defaultDescriptorSuperclassName tableSelectionCriteria tableNotSelectionCriteria </class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.MappingModel</class-id><body>I map the UI inputs to the Atlas domain class and descriptor system generation.  My class instance variables are set from the Launcher's 'Glorp Atlas' settings page.Instance Variables:	classBuilder	&lt;MappingClassBuilderHelper&gt;	description of classBuilder	databaseTables	&lt;OrderedCollection of: Glorp.DatabaseTable&gt;	selected database tables	descriptorClass	&lt;Glorp.DescriptorSystem&gt;	sublass of Glorp.DescriptorSystem	inflector	&lt;Inflector&gt;	 inflector	schema	&lt;String&gt;	 database schema to select tables from	selectedPlatform	&lt;DatabasePlatform&gt;	selected platform	system	&lt;ActiveRecordDescriptorSystem&gt;	metadata system to read schemas and/or tables in database.	tableSelectionCriteria	&lt;String&gt;	only show tables whose names match	tableNotSelectionCriteria	&lt;String&gt;	only show tables whose names do not match	tablesClasses	&lt;OrderedCollection(Table-&gt;String)&gt;	current choice of which tables to map and what class names to useClass Instance Variables	defaultDescriptorSuperclassName	&lt;String&gt;	the parent of the descriptor system;  it will be, or will descend from, DescriptorSystem (or ActiveRecordDescriptorSystems)	defaultDomainSuperclassName		&lt;String&gt;	the parent of the domain classes;  it will be, or will descend from, PersistentObject (or ActiveRecord for ActiveRecordDescriptorSystems)	defaultNamespace		&lt;String&gt; 	initial name offered for the namespace in which the domain classes and descriptor system will be placed	defaultPackage			&lt;String&gt;	initial name offered for the package into which the domain classes and descriptor system will be generated	descriptorClassName		&lt;String&gt;	initial name offered for the prefix of the descriptor system class to be generated (suffix determined by parent class)	tableSelectionCriteria	&lt;String&gt;	In SQL LIKE statements, the percent sign (%) matches zero or more characters, and underscore (_) a single character	tableNotSelectionCriteria	&lt;String&gt;	As above, but tables whose names match will be excluded from the list it selects, not included </body></comment><class><name>MappingSubcanvas</name><environment>Glorp</environment><super>Tools.SequenceableSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.MappingSubcanvas</class-id><body>Superclass for Glorp Atlas UI tool pages</body></comment><class><name>CreatePersistentObjects</name><environment>Glorp</environment><super>Glorp.MappingSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>createDescriptorSystemAspect descriptorClassPrefixAspect descriptorSuperclassAspect descriptorSuperclassListAspect classDefinition domainSuperclassListAspect domainSuperclassAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.CreatePersistentObjects</class-id><body>The page where we choose the tables to map, the domain class names and the Glorp system descriptor we will create, their superclasses, and the package and namespace in which we will place them.Instance Variables:	classDefinition	&lt;DefinitionCreationDialog&gt; 	createDescriptorSystemAspect	&lt;ValueModel&gt;	datasetAspect	&lt;SelectionInListSortAware&gt;	descriptorClassPrefixAspect	&lt;ValueModel&gt;	String , 'DescriptorSystem' or 'ActiveRecordDescriptorSystem' will be the name of the generated class (see #atlasNameExtension)	descriptorSuperclassAspect	&lt;ValueModel&gt;	A subclass of DescriptorSystem	descriptorSuperclassListAspect	&lt;ValueModel&gt;	DescriptorSystem and subclasses from which to choose	domainSuperclassAspect		&lt;ValueModel&gt;	A subclass of PersistentObject	domainSuperclassListAspect	&lt;ValueModel&gt;	PersistentObject, ActiveRecord and user's setting from which to choose</body></comment><class><name>TestPersistentObjects</name><environment>Glorp</environment><super>Glorp.MappingSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workspaceAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.TestPersistentObjects</class-id><body>A workspace for testing newly created persistent objects.Instance Variables:	workspaceAspect	&lt;Workbook&gt; workspace to run a script</body></comment><class><name>MappingUI</name><environment>Glorp</environment><super>Tools.PageSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.MappingUI</class-id><body>I manage navigating forth and back in the Glorp Atlas tool's set of UI pages </body></comment><class><name>LoginDialog</name><environment>Glorp</environment><super>Database.ConnectionDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaHolder schemaListHolder system descriptorSuperclassListAspect descriptorSuperclassAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-ActiveRecord</category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.LoginDialog</class-id><body>This combines Database.ConnectionProfiles with schemas.  The user can select or define (and save, if desired) a profile.  Having done so, they can populate the schema drop-down with the schemas in that database by creating a Glorp.Login and making it the current login of a metadata descriptor system.  Thus it can return such a system to the caller.Instance Variables:	schemaHolder	  &lt;ValueHolder&gt;	 Holds the current owner string.	schemaListHolder &lt;ValueHolder&gt;	 Holds the list of schemas in the currently-specified database.	system	&lt;ActiveRecordDescriptorSystem&gt;	metadata system to read schemas in database.BE AWARE: #resetSystem is called if the dialog is cancelled, or when #chooseLogin is sent to the class side to get a login instead of a system, to ensure logout of the system's metadataSession when the system is not returned.  Any use of the inherited class-side protocol to use this dialog to return other non-system objects would be debatable but, if done, should ensure #resetSystem is sent.</body></comment><class><name>MappingClassModelHelper</name><environment>Glorp</environment><super>Glorp.ClassModelHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.MappingClassModelHelper</class-id><body>Expected to merge with superclass when this leaves preview.Instance Variables:	superclass	&lt;Class&gt;	create the class as a child of this class</body></comment><class><name>ConnectionSubcanvas</name><environment>Glorp</environment><super>Glorp.MappingSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionProfileListHolder connectionProfileHolder databaseListHolder databaseHolder environmentListHolder environmentHolder schemaTemp passwordHolder userNameListHolder userNameHolder currentProfileHolder loginError </inst-vars><class-inst-vars>lastUsedProfile lastSchema </class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.ConnectionSubcanvas</class-id><body>Subcanvas for a database login.	connectionProfileListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt; 	This and most of the following variables hold various aspects of the dialog interface.	connectionProfileHolder	&lt;ValueHolder with: String&gt;	databaseListHolder	&lt;ValueHolder with: &lt;List of: Symbol&gt;&gt;	databaseHolder	&lt;AspectAdaptor&gt;		environmentListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt;	environmentHolder	&lt;AspectAdaptor&gt;	userNameListHolder	&lt;ValueHolder with: &lt;List of: String&gt;&gt;	userNameHolder	&lt;AspectAdaptor&gt;	passwordHolder	&lt;AspectAdaptor&gt;	currentProfileHolder	&lt;ValueHolder with: ConnectionProfile&gt;	A value holder with the "working copy" of a ConnectionProfile. It is a subject channel of some of the aspects above, which are aspects adaptors.	loginError	&lt;ValueModel&gt;	displays login error if anyClass instance Variables:	lastUsedProfile	&lt;ConnectionProfile&gt;	The connection profile most recently accepted by the user.</body></comment><class><name>LoginSubcanvas</name><environment>Glorp</environment><super>Glorp.ConnectionSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaHolder schemaListHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-ActiveRecord</category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.LoginSubcanvas</class-id><body>This combines Database.ConnectionProfiles with schemas.  The user can select an existing a profile or they can define a new one (and save it, if desired).  Having done so, they can populate the schema drop-down with the schemas in that database by creating a Glorp.Login and making it the current login of a metadata descriptor system on the model.  If they do, the model has a system with already-logged-in metadataSession for use reading table data;  if not, the system is created from the login when the subcanvas moves to the next page.Instance Variables:	schemaHolder	  &lt;ValueHolder&gt;	 Holds the current owner string.	schemaListHolder &lt;ValueHolder&gt;	 Holds the list of schemas in the currently-specified database.</body></comment><class><name>MappingClassBuilderHelper</name><environment>Glorp</environment><super>Glorp.ClassBuilderHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclassBindingReference </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.MappingClassBuilderHelper</class-id><body>I expect to merge with my superclass when I leave preview.  I let the user specify a domain superclass which will be the superclass of all classes I create.  Its default value is PersistentObject, which is the hardcoded value in the superclass.Instance Variables:	superclassBindingReference	&lt;BindingReference&gt;	path to the domain superclass</body></comment><class><name>MapTablesToClasses</name><environment>Glorp</environment><super>Glorp.MappingSubcanvas</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedRow datasetAspect showTablesWithPatternAspect tableNamePatternAspect showTablesWithoutPatternAspect tableNameNotPatternAspect selectTablesAspect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.MapTablesToClasses</class-id><body>The page where we choose the tables to map, the domain class names and the Glorp system descriptor we will create, their superclasses, and the package and namespace in which we will place them.Instance Variables:	datasetAspect	&lt;SelectionInListSortAware&gt;		selectedRow	&lt;DatasetRow&gt; represents  a table row that maps a table to class	selectTablesAspect				&lt;ValueModel&gt;	boolean: select  for generation all/none of the tables shown	showTablesWithPatternAspect		&lt;ValueModel&gt;	boolean: show all tables in database/schema or just matching ones	tableNamePatternAspect			&lt;ValueModel&gt;	SQL match pattern: matching tables will be shown in the list	showTablesWithoutPatternAspect	&lt;ValueModel&gt;	boolean: show all tables in database/schema or just matching ones	tableNameNotPatternAspect		&lt;ValueModel&gt;	SQL match pattern: matching tables will be excluded from the list</body></comment><class><name>DatasetRow</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>createClass table className </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpAtlasUI</package></attributes></class><comment><class-id>Glorp.DatasetRow</class-id><body>I represent the mapping between database table (whose data we have read from the database' metadata) and a persistent object.Instance Variables:	className	&lt;String&gt;	 class name for a persistent object	createClass	&lt;Boolean&gt; defines if the class will be created	table	&lt;Glorp.DatabaseTable&gt;	the table from which we will generate the domain class</body></comment><methods><class-id>Glorp.MappingModel</class-id> <category>accessing</category><body package="GlorpAtlasUI">databaseTables	^databaseTables</body><body package="GlorpAtlasUI">readDatabaseTablesLike: aString unlike: anotherString	tableSelectionCriteria := aString.	tableNotSelectionCriteria := anotherString.	self readDatabaseTables.</body><body package="GlorpAtlasUI">schema	^schema</body><body package="GlorpAtlasUI">schema: aString	schema := aString</body><body package="GlorpAtlasUI">selectedPlatform	^selectedPlatform</body><body package="GlorpAtlasUI">selectedPlatform: aString	selectedPlatform := aString</body><body package="GlorpAtlasUI">system	^system</body><body package="GlorpAtlasUI">system: anActiveRecordDescriptorSystem	system := anActiveRecordDescriptorSystem.</body><body package="GlorpAtlasUI">tableNotSelectionCriteria	^tableNotSelectionCriteria</body><body package="GlorpAtlasUI">tableSelectionCriteria	^tableSelectionCriteria</body><body package="GlorpAtlasUI">tablesClasses	^tablesClasses</body><body package="GlorpAtlasUI">tablesClasses: someAssociations	"A collection of aTable-&gt;aString, where aString names the class to be generated and aTable is the table to which it will be mapped."	tablesClasses := someAssociations.</body></methods><methods><class-id>Glorp.MappingModel</class-id> <category>generate classes</category><body package="GlorpAtlasUI">checkNamespace: aNamespace	^aNamespace isNameSpace 		ifTrue: [aNamespace]		ifFalse: 			[self error: ((#NameAlreadyExist &lt;&lt; #glorp &gt;&gt; '&lt;1s&gt; already exists and is not a NameSpace')						expandMacrosWith: aNamespace)]</body><body package="GlorpAtlasUI">classBuilderForPackage: aPackage	^MappingClassBuilderHelper new		system: system;		package: (Store.Registry packageNamedOrCreate: aPackage);		dictionary: IdentityDictionary new;		domainSuperclassName: self class defaultDomainSuperclassName;		yourself</body><body package="GlorpAtlasUI">createMappingsForActiveRecord	"For our relationship mappings to find their end-points, ensure each generated descriptor knows the table it was generated from, before we generate mappings."	classBuilder generateClassModelsFromTables do:		[:eachClassModel || eachDescriptor |	"the descriptor's existence is ensured by the class model's generation."		eachDescriptor := self system descriptorFor: eachClassModel describedClass.		eachDescriptor tables isEmpty ifTrue:			[eachDescriptor addTable: (self tablesClasses detect: [:assoc | assoc value = eachClassModel describedClass name asString]) key]].	[classBuilder createMappingsForActiveRecord]		on: CannotAutomaticallyMapRelationship		do: [:ex |	"We want to log our failures somewhere"			Transcript cr; show: ex description.			ex resume].</body><body package="GlorpAtlasUI">createNamespace: nameSpaceName	| nameSpace reference |	nameSpace := Smalltalk.	(GeneralBindingReference parseString: nameSpaceName) do: 			[:token | 			reference := token asQualifiedReference.			nameSpace := reference 						ifDefinedDo: [:value | self checkNamespace: value] 						elseDo: 							[nameSpace 								defineNameSpace: token								private: false								imports: ''								category: '']].	^nameSpace</body><body package="GlorpAtlasUI">generateClassesFromTables	"Generate actual classes"	classBuilder generateClassesFromTablesIntoPackage.</body><body package="GlorpAtlasUI">generateDescriptorClass: descriptorPrefix superclass: aDescriptorSystemClass namespace: aNamespaceString	"Generate the AR descriptor system subclass"	WriteAtlasHelper system: system.	Store.Policies packagePolicy		forcePackage: classBuilder package		while: [descriptorClass := system				writeAtlas: descriptorPrefix				superclass: aDescriptorSystemClass				in: aNamespaceString asQualifiedReference value].</body><body package="GlorpAtlasUI">mapLinkTableFieldsToDomainClasses: someUserAssignedLinkTables	"Find tables that, though not selected for domain classes, are being viewed and link tables that are selected for domain classes.  Add variables for them.  (We can ignore the foreignKeyConstraintsForCreation/foreignKeyConstraints distinction here as we've just obtained these tables by reading from the database.  If in future we can obtain this info from a defined schema that includes imaginary tables, consider using foreignKeyConstraintsForCreation.)"	| internalLinkTables nearTableClass farTableClass |	internalLinkTables := self databaseTables select: 		[:each |		(self system tables includes: each) not and:			[(self system isLinkTable: each) and:				[each foreignKeyConstraints allSatisfy: [:fkc | self system tables includes: fkc targetTable]]]].	internalLinkTables do: [:each | self system tables at: each name put: each].	internalLinkTables addAll: someUserAssignedLinkTables.	internalLinkTables do:		[:eachLinkTable || targetTableClasses |		self system tables at: eachLinkTable name put: eachLinkTable.		targetTableClasses := eachLinkTable foreignKeyConstraints collect:			[:fkc | self tablesClasses detect: [:assoc | assoc key = fkc targetTable]].		targetTableClasses size = 2 ifFalse:	"For now, keep it simple;  assume linkTable has two foreign-keyed fields"			[CannotAutomaticallyDetermineJoin new				tables: (targetTableClasses collect: [:each | each key]);				constraints: eachLinkTable foreignKeyConstraints;				signal: 'Cannot automatically resolve link table'].		nearTableClass := targetTableClasses first.		farTableClass := targetTableClasses last.		"Near to far (via linkTable) on near class"		(classBuilder getClass: nearTableClass value) addOwnedVariable:			(ClassModelVariableHelper	"see #isString call in #addMappingToDescriptor:"				name: (inflector pluralize: (inflector instVarize: eachLinkTable foreignKeyConstraints last someSourceField name))				type: farTableClass value				field: eachLinkTable foreignKeyConstraints last someSourceField				collection: ManyToManyMapping).	"later, check for any unique constraint =&gt; OneToMany"		"Far to near (via linkTable) on far class"		(classBuilder getClass: farTableClass value) addOwnedVariable:			(ClassModelVariableHelper	"see #isString call in #addMappingToDescriptor:"				name: (inflector pluralize: (inflector instVarize: eachLinkTable foreignKeyConstraints first someSourceField name))				type: nearTableClass value				field: eachLinkTable foreignKeyConstraints first someSourceField				collection: ManyToManyMapping)].	"later, check for any unique constraint =&gt; OneToMany"</body><body package="GlorpAtlasUI">mapTablesToClasses: tableClassMap superclass: domainSuperclass namespace: aNamespaceString in: aPackage	"If any selected tables have invalid names (empty or start with #), assume the user is directing you to use them for link tables."	| package classModelHelper assignedLinkTables |	"Create the package if it doesn't exist."	package := Store.Registry packageNamedOrCreate: aPackage.	"Create namespaces if they are not present"	aNamespaceString asQualifiedReference		ifDefinedDo: [:value | self checkNamespace: value]		elseDo: [Store.Policies packagePolicy forcePackage: package				while: [self createNamespace: aNamespaceString]].	"Extract any select tables that are in fact link tables."	assignedLinkTables := (tableClassMap removeAllSuchThat: [:each | each value isEmpty])		collect: [:each | each key].	"Map table fields to class inst. vars"	classBuilder := self classBuilderForPackage: aPackage.	classBuilder domainSuperclassName: domainSuperclass fullName.	tableClassMap do:		[:assoc |		(classModelHelper := MappingClassModelHelper new)			namespace: aNamespaceString;			className: assoc value;			superclass: classBuilder domainSuperclass.		classBuilder dictionary			at: classModelHelper className asSymbol			put: classModelHelper.		self			mapTableFields: assoc key			for: classModelHelper			tableClassMap: tableClassMap].	"Look for any more link tables.  Add instVar mappings for all linkTables terminating on domain-class tables."	self mapLinkTableFieldsToDomainClasses: assignedLinkTables.</body><body package="GlorpAtlasUI">setSelectedTables: someAssociations	| namedTables |	self tablesClasses: someAssociations.	namedTables := Dictionary new.	someAssociations do:		[:assoc || table | table := assoc key.		namedTables at: table name put: table].	system tables: namedTables.</body></methods><methods><class-id>Glorp.MappingModel</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initialize	inflector := Inflector new.	tableSelectionCriteria := self class tableSelectionCriteria.	tableNotSelectionCriteria := self class tableNotSelectionCriteria.</body><body package="GlorpAtlasUI">readDatabaseTables	"The unusual approach of asking the metadataSession to #read: ... using a query's whereClause instead of asking it simply to execute that query is used here because the SQLiteMetaSession is currently set up to handle calls of the form	self read{OneOf}: DatabaseTable ...polymorphically, whereas it does not yet handle executing polymorphically a query whose resultClass is DatabaseTable.  (This may be changed by AR 66475.)"	| tableQuery |	tableQuery := ReadQuery read: DatabaseTable.	(self system platform supportsSchemas not		or: [self schema isNil			or: [self schema isEmpty]]) ifFalse:		[tableQuery AND: [:table | table schema = self schema]].	self tableSelectionCriteria = '%' ifFalse:		[tableQuery := tableQuery AND: [:table | table name like: self tableSelectionCriteria]].	self tableNotSelectionCriteria isEmpty ifFalse:		[tableQuery := tableQuery AND: [:table | (table name like: self tableNotSelectionCriteria) not]].	databaseTables := self system metadataSession read: DatabaseTable where: tableQuery whereClause.</body></methods><methods><class-id>Glorp.MappingModel</class-id> <category>login</category><body package="GlorpAtlasUI">activeRecordSystemLogin: aLogin	^system := (Glorp.ActiveRecords.ActiveRecordDescriptorSystem sessionForLogin: aLogin) system.</body></methods><methods><class-id>Glorp.MappingModel</class-id> <category>private</category><body package="GlorpAtlasUI">addReversRelation: aField name: aName type: smalltalkType reverse: aVariableHelper	"I am code-identical to GlorpMetaProcess&gt;&gt;addReversRelation:name:type:to:reverse: except that the to-parameter 'dictionary' is instead obtained from the classBuilder in my first line."		| tempHelper revVariableHelper |	tempHelper := classBuilder dictionary		at: smalltalkType asSymbol		ifAbsentPut:			[| helper |			helper := ClassModelHelper new.			helper className: smalltalkType.			helper].	revVariableHelper := ClassModelVariableHelper				name: (inflector instVarize: aField table name , '_' , aField name)				type: aName				field: aField				collection: OneToManyMapping.	revVariableHelper ownedClass: tempHelper.	revVariableHelper reverseJoin: aVariableHelper.	aVariableHelper reverseJoin: revVariableHelper.	^tempHelper addVariable: revVariableHelper</body><body package="GlorpAtlasUI">mapTableFields: aTable for: classModelHelper tableClassMap: tableClassMap		| myVariable fkTable   |	aTable fields		do:			[:aField | 			| smalltalkType |			smalltalkType := aField foreignKeyConstraints isEmpty				ifTrue: [aField impliedSmalltalkType]				ifFalse: [ fkTable := aField foreignKeyConstraints first targetTable name.					(tableClassMap detect: [ :assoc | assoc key name = fkTable] ifNone: [nil])						ifNotNil: [ :assoc | assoc value]						ifNil: [ inflector classify: fkTable ]].			classModelHelper				addVariable:					(myVariable := ClassModelVariableHelper						name: (inflector instVarize: aField name)						type: smalltalkType						field: aField).			myVariable ownedClass: classModelHelper.			aField foreignKeyConstraints isEmpty				ifFalse: [self 						addReversRelation: aField 						name: classModelHelper className 						type: smalltalkType 						reverse: myVariable]].</body></methods><methods><class-id>Glorp.MappingModel</class-id> <category>test objects</category><body package="GlorpAtlasUI">testScript	"If the user has not checked 'Create descriptor', still show this script with a nonce descriptor name and comment.  The user may intend to write a descriptor system by hand - and anyway, we must not raise a DNU and this is the easiers way to avoid it."	| stream login descriptorClassFullName |	descriptorClassFullName := descriptorClass isNil		ifFalse: [descriptorClass fullName]		ifTrue: ['ReplaceWithDescriptorSystemWhenCreated "system was not generated"'].	stream := String new writeStream.	login := system session accessor currentLogin.	stream 		nextPutAll: 'login := Glorp.Login new';		crtab;		nextPutAll: 'database: ', login database class fullName, ' new;';		crtab;		nextPutAll:  'username: ', (login username ifNil: ['String new'] ifNotNil: [login username printString]), ';' ;		crtab;		nextPutAll: 'password: ', (login password ifNil: ['String new'] ifNotNil: [login password printString]), ';';		crtab;		nextPutAll: 'connectString: ', login connectString printString, ';';		crtab;		nextPutAll: 'schema: ', (login schema ifNil: ['']) printString, ';';		crtab;		nextPutAll: 'yourself.';		cr;		nextPutAll: 'system := ', descriptorClassFullName, ' forPlatform: login database.';		cr;		nextPutAll: 'session := (system sessionForLogin: login).';		cr;		nextPutAll: 'session login.';		cr.	system allClasses do: [ :cl |		stream 			cr;			nextPutAll: 'session read: ', cl fullName, '.'].	stream		cr; cr;		nextPutAll: 'session logout.'.		^stream contents</body></methods><methods><class-id>Glorp.MappingModel class</class-id> <category>accessing</category><body package="GlorpAtlasUI">defaultDescriptorSuperclassName	^defaultDescriptorSuperclassName ifNil: [defaultDescriptorSuperclassName := self defaultDescriptorSuperclassNameValue]</body><body package="GlorpAtlasUI">defaultDescriptorSuperclassName: aString	aString asQualifiedReference valueOrDo: [self error: 'No such class: ', aString].	defaultDescriptorSuperclassName := aString.</body><body package="GlorpAtlasUI">defaultDomainSuperclassName	^defaultDomainSuperclassName ifNil: [defaultDomainSuperclassName := self defaultSuperclassNameValue]</body><body package="GlorpAtlasUI">defaultDomainSuperclassName: aString	aString asQualifiedReference valueOrDo: [self error: 'No such class: ', aString].	defaultDomainSuperclassName := aString.</body><body package="GlorpAtlasUI">defaultNamespace	^defaultNamespace ifNil: [ defaultNamespace := self defaultNamespaceValue ]</body><body package="GlorpAtlasUI">defaultNamespace: aString	defaultNamespace := aString</body><body package="GlorpAtlasUI">defaultPackage 	^defaultPackage ifNil: [ defaultPackage := self defaultPackageValue ]</body><body package="GlorpAtlasUI">defaultPackage: aString	defaultPackage := aString</body><body package="GlorpAtlasUI">descriptorClassPrefix	^descriptorClassName ifNil: [ descriptorClassName :=  self descriptorClassPrefixValue ]</body><body package="GlorpAtlasUI">descriptorClassPrefix: aString	descriptorClassName := aString</body><body package="GlorpAtlasUI">tableNotSelectionCriteria	^tableNotSelectionCriteria ifNil: [tableNotSelectionCriteria := String new]</body><body package="GlorpAtlasUI">tableNotSelectionCriteria: aString	tableNotSelectionCriteria := aString.</body><body package="GlorpAtlasUI">tableSelectionCriteria	^tableSelectionCriteria ifNil: [tableSelectionCriteria := '%']</body><body package="GlorpAtlasUI">tableSelectionCriteria: aString	tableSelectionCriteria := aString.</body></methods><methods><class-id>Glorp.MappingModel class</class-id> <category>defaults</category><body package="GlorpAtlasUI">defaultDescriptorSuperclassNameValue	"For testing;  it may be the tool should use ActiveRecordDescriptorSystem as its default, even detecting and switching to something else when the chosen tables do not all have a field called id that is the sole primaryKey."	^'Glorp.DescriptorSystem'</body><body package="GlorpAtlasUI">defaultNamespaceValue	^'Smalltalk'</body><body package="GlorpAtlasUI">defaultPackageValue	^'NewPackage'</body><body package="GlorpAtlasUI">defaultSuperclassNameValue	^'Glorp.PersistentObject'</body><body package="GlorpAtlasUI">descriptorClassPrefixValue	^'New'</body><body package="GlorpAtlasUI">flushDefaults	defaultPackage := nil.	defaultNamespace := nil.	descriptorClassName := nil.	defaultDomainSuperclassName := nil.	defaultDescriptorSuperclassName := nil.	tableSelectionCriteria := nil.	tableNotSelectionCriteria  := nil.</body><body package="GlorpAtlasUI">switchStandardDefaultsToActiveRecord	"If we have standard defaults, switch to ActiveRecord pattern defaults and return true.  If not, do nothing and return false."	(MappingModel defaultDescriptorSuperclassName = 'Glorp.DescriptorSystem'		and: [MappingModel defaultDomainSuperclassName = 'Glorp.PersistentObject'])			ifFalse: [^false].	MappingModel		defaultDescriptorSuperclassName: 'Glorp.ActiveRecords.ActiveRecordDescriptorSystem';		defaultDomainSuperclassName: 'Glorp.ActiveRecords.ActiveRecord'.	^true</body></methods><methods><class-id>Glorp.MappingModel class</class-id> <category>instance creation</category><body package="GlorpAtlasUI">new	^super new initialize</body></methods><methods><class-id>Glorp.MappingSubcanvas</class-id> <category>utility</category><body package="GlorpAtlasUI">indentFor: aClass from: aSuperclass	"Quick hack - replace with general utility method that we doubtless have somewhere."	| tab pivotClass |	tab := 0.	pivotClass := aClass.	[pivotClass == aSuperclass] whileFalse:		[pivotClass := pivotClass superclass.		tab := tab + 1].	^String new: tab withAll: Character space</body></methods><methods><class-id>Glorp.MappingSubcanvas class</class-id> <category>accessing</category><body package="GlorpAtlasUI">messageCatalogID	^#glorp</body></methods><methods><class-id>Glorp.MappingSubcanvas class</class-id> <category>class initialization</category><body package="GlorpAtlasUI">initialize	ApplicationModel 		visualAt: #glorp		put: (ListIconLibrary visualFor: #store)</body></methods><methods><class-id>Glorp.CreatePersistentObjects</class-id> <category>aspects</category><body package="GlorpAtlasUI">createDescriptorSystemAspect	^createDescriptorSystemAspect</body><body package="GlorpAtlasUI">descriptorClassPrefixAspect	^descriptorClassPrefixAspect</body><body package="GlorpAtlasUI">descriptorSuperclassAspect	^descriptorSuperclassAspect</body><body package="GlorpAtlasUI">descriptorSuperclassListAspect	^descriptorSuperclassListAspect</body></methods><methods><class-id>Glorp.CreatePersistentObjects</class-id> <category>utility</category><body package="GlorpAtlasUI">findCassNamed: aString subclassOf: aSuperclass	"Allow the string to be a full name or a simple name, the latter in the common case there are not two such names.  We need our to-be-discarded failure strings to be the names of anything that understands #name;  we use a raw Login."	| candidates |	candidates := aSuperclass withAllSubclasses select:		[:each |		each fullName = aString ifTrue: [^each].		each name = aString].	candidates isEmpty ifTrue: [^Login basicNew name: 'Unrecognised ', aString].	candidates size &gt; 1 ifTrue: [^Login basicNew name: 'Give fullName ', aString].	^candidates first</body><body package="GlorpAtlasUI">isDescriptorSuperclass: aDescriptorSystemClass compatibleWithDomainSuperclass: aPersistentObjectClass	"ActiveRecordDescriptorSystems must have ActiveRecord subclasses for their domain classes.  (It is just possible users might define #domainSuperclassRoot methods on their own descriptor system root classes.)"	^self createDescriptorSystemAspect value not		or: [(aPersistentObjectClass includesBehavior: aDescriptorSystemClass domainSuperclassRoot)		or: [Dialog confirm: (#DomainSuper1sIncompatDescSuper2s &lt;&lt; #glorp &gt;&gt;			'The descriptor system superclass&lt;nt&gt;&lt;1s&gt;&lt;n&gt;is not compatible with the domain superclass&lt;nt&gt;&lt;2s&gt;&lt;n&gt;Do you plan to change the other field before doing ''Next''?&lt;n&gt;(If ''No'', you must reset the current field to another value.)' expandMacrosWith: aDescriptorSystemClass fullName with: aPersistentObjectClass fullName)]]</body><body package="GlorpAtlasUI">isDescriptorSuperclassCompatibleWithDomainSuperclass	^self isDescriptorSuperclass: self descriptorSystemSuperclass compatibleWithDomainSuperclass: self domainSuperclass</body></methods><methods><class-id>Glorp.CreatePersistentObjects</class-id> <category>accessing</category><body package="GlorpAtlasUI">classDefinition	^classDefinition</body><body package="GlorpAtlasUI">classNS	^self classDefinition namespaceModule value</body><body package="GlorpAtlasUI">classPackage	^self classDefinition packageModule value</body><body package="GlorpAtlasUI">descriptorSystemSuperclass	^self descriptorSuperclassAspect subject value</body><body package="GlorpAtlasUI">domainSuperclass	^self domainSuperclassAspect subject value</body><body package="GlorpAtlasUI">domainSuperclassAspect	^domainSuperclassAspect</body><body package="GlorpAtlasUI">domainSuperclassListAspect	^domainSuperclassListAspect</body></methods><methods><class-id>Glorp.CreatePersistentObjects</class-id> <category>actions</category><body package="GlorpAtlasUI">closeRequestFromParent	self model		mapTablesToClasses: self model tablesClasses		superclass: self domainSuperclass		namespace: self classNS		in: self classPackage.	self model generateClassesFromTables.	self createDescriptorSystemAspect value ifTrue:		[[self model createMappingsForActiveRecord]			on: Error			do: [:ex |				self errorDialog: ex.				^false].		self model			generateDescriptorClass: self descriptorClassPrefixAspect value			superclass: self descriptorSystemSuperclass			namespace: self classNS].	^true</body><body package="GlorpAtlasUI">errorDialog: anException	Dialog warn: (#ErrorGeneratingClasses1s &lt;&lt; #glorp &gt;&gt;'Error generating classes:  &lt;1s&gt;' expandMacrosWith: anException description).</body></methods><methods><class-id>Glorp.CreatePersistentObjects</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initializeAspects	| descriptorSuperclasses usersDescriptorSuperclass domainSuperclasses usersDomainClass |	classDefinition := DefinitionCreationDialog new.	self classDefinition packageModule value: self model class defaultPackage.	self classDefinition namespaceModule value: self model class defaultNamespace.	createDescriptorSystemAspect := true asValue.	createDescriptorSystemAspect onChangeSend: #isDescriptorSuperclassCompatibleWithDomainSuperclass to: self.	descriptorClassPrefixAspect := self model class descriptorClassPrefix asValue.	descriptorSuperclasses := DescriptorSystem withAllSubclasses.	MetadataDescriptorSystem withAllSubclasses do:		[:each | descriptorSuperclasses remove: each ifAbsent: []].	usersDescriptorSuperclass := MappingModel defaultDescriptorSuperclassName asStrictReference value.	descriptorSuperclassListAspect :=		(descriptorSuperclasses collect: [:each | (self indentFor: each from: DescriptorSystem) , each fullName])			asValue.	descriptorSuperclassAspect := (TypeConverter on: usersDescriptorSuperclass asValue)			getBlock: [:m | m value name]			putBlock: [:m :v | m value: (self findCassNamed: v trimBlanks subclassOf: DescriptorSystem)]			updateBlock: [:m :a :p | self isDescriptorSuperclass: m value compatibleWithDomainSuperclass: self domainSuperclass].	domainSuperclasses := OrderedCollection		with: PersistentObject		with: Glorp.ActiveRecords.ActiveRecord.	usersDomainClass := MappingModel defaultDomainSuperclassName asStrictReference value.	(domainSuperclasses includes: usersDomainClass) ifFalse: [domainSuperclasses add: usersDomainClass].	domainSuperclassListAspect :=		(domainSuperclasses collect: [:each | (self indentFor: each from: PersistentObject) , each fullName])			asValue.	domainSuperclassAspect := (TypeConverter on: usersDomainClass asValue)		getBlock: [:m | m value name]		putBlock: [:m :v | m value: (self findCassNamed: v trimBlanks subclassOf: PersistentObject)]		updateBlock: [:m :a :p | self isDescriptorSuperclass: self descriptorSystemSuperclass compatibleWithDomainSuperclass: m value].</body></methods><methods><class-id>Glorp.CreatePersistentObjects class</class-id> <category>accessing</category><body package="GlorpAtlasUI">header	^#CreatePersistentObjectsHeader &lt;&lt; #glorp &gt;&gt; 'Create Persistent Classes (and Descriptor System)'</body><body package="GlorpAtlasUI">helpText	^#CreatingPersistentObjectsHelpText &lt;&lt; #glorp &gt;&gt;'This generates a descriptor system subclass for the selected tables and their relationships, plus a domain class for each such table.Package:  the classes will be created in the chosen package (which will be created if it is does not already exist).Namespace:  the classes will be created in the chosen namespace (which will be created if it is does not already exist).Domain superclass:  the parent of your domain classes	PersistentObject is compatible with any descriptor system.		Choose ActiveRecord or a subclass if you want to use ActiveRecordDescriptorSystem or a subclass.	Set a value in the Launcher''s Glorp Atlas settings page to add your own domain superclass to the list.(See the GlorpGuide.pdf for information on the general PersistentObject pattern and the specific ActiveRecord pattern.)Create Descriptor	Prefix:  check to create a system descriptor class with the chosen prefix.  (For example having the prefix "My" will create the class: MyDescriptorSystem.)	Superclass:  select a subclass of DescriptorSystem if you want to generate a DescriptorSystem with a more specific superclass.Moving to the next page generates selected domain classes and descriptor system.'</body></methods><methods><class-id>Glorp.TestPersistentObjects</class-id> <category>interface opening</category><body package="GlorpAtlasUI">postBuildWith: aBuilder	"This is a clone of Workbook&gt;&gt;postOpenWith:, which is not called when it is an embedded subcanvas."	super postBuildWith: aBuilder.	self workspaceAspect pageHolder selection: self workspaceAspect pageHolder list first.</body></methods><methods><class-id>Glorp.TestPersistentObjects</class-id> <category>accessing</category><body package="GlorpAtlasUI">workspaceAspect	^workspaceAspect</body></methods><methods><class-id>Glorp.TestPersistentObjects</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initializeAspects	workspaceAspect := Workbook with: self model testScript labeled: 'TestScript'.	workspaceAspect addLocal: #login.	workspaceAspect addLocal: #system.	workspaceAspect addLocal: #session.</body></methods><methods><class-id>Glorp.TestPersistentObjects class</class-id> <category>accessing</category><body package="GlorpAtlasUI">header	^#TestPersistentObjectHeader &lt;&lt; #glorp &gt;&gt;'Test Persistent Objects'</body><body package="GlorpAtlasUI">helpText	^#TestPersistentObjectScriptHelp &lt;&lt; #glorp &gt;&gt; 'The script shows code to login to your database and retrieve instances of the domain classes you have generated.  (And to logout when done;  this is not done automatically.)Local variables ''login'' ''system'' and ''session'' have been created for the workspace script to use as needed.'</body></methods><methods><class-id>Glorp.MappingUI</class-id> <category>accessing</category><body package="GlorpAtlasUI">defaultModelClass	^MappingModel</body></methods><methods><class-id>Glorp.MappingUI</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initializePages	pages := Array new: 4.	pages		at: 1 put: LoginSubcanvas;		at: 2 put: MapTablesToClasses;		at: 3 put: CreatePersistentObjects;		at: 4 put: TestPersistentObjects.	^pages</body></methods><methods><class-id>Glorp.MappingUI class</class-id> <category>accessing</category><body package="GlorpAtlasUI">messageCatalogID	^#glorp</body><body package="GlorpAtlasUI">wizardHeader	^'Creating Persistent Objects from Tables'</body></methods><methods><class-id>Glorp.LoginDialog</class-id> <category>aspects</category><body package="GlorpAtlasUI">descriptorSuperclassAspect	^descriptorSuperclassAspect</body><body package="GlorpAtlasUI">descriptorSuperclassListAspect	^descriptorSuperclassListAspect</body><body package="GlorpAtlasUI">schemaHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^schemaHolder isNil		ifTrue:[ schemaHolder := String new asValue ]		ifFalse:	[ schemaHolder ]</body><body package="GlorpAtlasUI">schemaListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^schemaListHolder isNil		ifTrue: [ schemaListHolder := List new asValue ]		ifFalse: 	[ schemaListHolder ]</body></methods><methods><class-id>Glorp.LoginDialog</class-id> <category>notifications</category><body package="GlorpAtlasUI">profileSelected	| profile name |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name] ifNone: [^self].	currentProfileHolder value: profile copy.</body><body package="GlorpAtlasUI">schemaChanged	system isNil ifFalse:		[system metadataSession accessor currentLogin schema: self schemaHolder value].</body></methods><methods><class-id>Glorp.LoginDialog</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initialize	super initialize.	self initializeSchemaList.</body><body package="GlorpAtlasUI">initializeAspects	| descriptorRootClass |	super initializeAspects.	descriptorRootClass := DescriptorSystem.	descriptorSuperclassListAspect :=		(descriptorRootClass allSubclasses collect:			[:each | (self indentFor: each from: descriptorRootClass), each fullName]) asValue.	"As the to-be-discarded nil-equivalent initial value, we need anything whose name is the empty string;  we use a raw Login."	descriptorSuperclassAspect := (TypeConverter on: (Login basicNew name: '') asValue)		getBlock: [:m | m value name]		putBlock: [:m :v | m value: (self findCassNamed: v trimBlanks subclassOf: descriptorRootClass)]		updateBlock: [:m :a :p | true].</body><body package="GlorpAtlasUI">initializeSchemaList	self schemaListHolder value: self knownSchemas asSortedCollection</body><body package="GlorpAtlasUI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(builder componentAt: #schemaCombo) 		widget controller continuousAccept: true.</body></methods><methods><class-id>Glorp.LoginDialog</class-id> <category>accessing</category><body package="GlorpAtlasUI">descriptorSystemClass	^self descriptorSuperclassAspect subject value</body><body package="GlorpAtlasUI">system	^system</body><body package="GlorpAtlasUI">system: ActiveRecordDescriptorSystem	system := ActiveRecordDescriptorSystem.</body></methods><methods><class-id>Glorp.LoginDialog</class-id> <category>private</category><body package="GlorpAtlasUI">closeCancel	self resetSystem.	super closeCancel.</body><body package="GlorpAtlasUI">knownSchemas	"Later connect, get schemas, disconnect for valid Login or session, and cache till Login data changes."	^#()</body><body package="GlorpAtlasUI">resetBrowseFilesButton	"In Store.ConnectionDialog, the isNil guard is needed, so it might be needed here too."	| showSchemas getSchemasWidget schemaComboWidget |	(self builder componentAt: #browseFiles) isNil ifTrue: [^self].	showSchemas := super resetBrowseFilesButton not.	getSchemasWidget := self builder componentAt: #getSchemas.	schemaComboWidget := self builder componentAt: #schemaCombo.	getSchemasWidget isVisible: showSchemas.	schemaComboWidget isVisible: showSchemas.	showSchemas ifFalse: [schemaHolder value: String new].	getSchemasWidget isEnabled:		(showSchemas and: [self currentProfile isValidForMultiUserDB]).	self schemaHolder value: ''.	self resetSystem.</body><body package="GlorpAtlasUI">resetSystem	system isNil ifFalse:		[system metadataSession logout.		system := nil.		self initializeSchemaList].</body></methods><methods><class-id>Glorp.LoginDialog</class-id> <category>private-profile list</category><body package="GlorpAtlasUI">currentLogin	^super currentLogin		schema: self schemaHolder value;		yourself</body><body package="GlorpAtlasUI">currentSession	"Return an unlogged-in session for the specified Login and descriptor system."	^self descriptorSystemClass sessionForLogin: self currentLogin</body></methods><methods><class-id>Glorp.LoginDialog</class-id> <category>actions</category><body package="GlorpAtlasUI">getSchemas	"Change the halt to a comment (or drop the guard) when satisfied the guard is robust (or is needless).  The guard should only ever happen if #getSchemas raises an error (e.g. cannot login) which is somehow resumed to avoid closing the dialog, and the problem is then fixed without changing the dialog data, e.g. by (re)starting a tunnel, after which the user invokes getSchemas again.  Arguably we need not bother guarding against this case - it's very hard to evoke and the user will have seen an error.  The main reason for the guard is to spot if the #getSchemas button is enabled when it should not be, indicating wrong UI logic."	system isNil ifFalse:		[self halt: 'Did wrong UI logic re-enable getSchemas?'.		self resetSystem].	system := (Glorp.ActiveRecords.ActiveRecordDescriptorSystem				sessionForLogin: super currentLogin)	"do not set schema while getting schemas"			system.	self schemaListHolder value:		(system platform readSchemasForSession: system metadataSession) asSortedCollection.	self schemaHolder value: '- choose from dropdown -'.	(self builder componentAt: #getSchemas) isEnabled: false.</body></methods><methods><class-id>Glorp.LoginDialog</class-id> <category>utility</category><body package="GlorpAtlasUI">findCassNamed: aString subclassOf: aSuperclass	"Allow the string to be a full name or a simple name, the latter in the common case there are not two such names.  We need our to-be-discarded failure strings to be the names of anything that understands #name;  we use a raw Login."	| candidates |	candidates := aSuperclass withAllSubclasses select:		[:each |		each fullName = aString ifTrue: [^each].		each name = aString].	candidates isEmpty ifTrue: [^Login basicNew name: 'Unrecognised ', aString].	candidates size &gt; 1 ifTrue: [^Login basicNew name: 'Give fullName ', aString].	^candidates first</body><body package="GlorpAtlasUI">indentFor: aClass from: aSuperclass	"Quick hack - replace with general utility method if we have one somewhere.  Note tab := - 1 in the first line - this version knows it does not include the superclass."	| tab pivotClass |	tab := -1.	pivotClass := aClass.	[pivotClass == aSuperclass] whileFalse:		[pivotClass := pivotClass superclass.		tab := tab + 1].	^String new: tab withAll: Character space</body></methods><methods><class-id>Glorp.LoginDialog class</class-id> <category>accessing</category><body package="GlorpAtlasUI">chooseLogin	| instance |	instance := self new.	instance open ifFalse: [^nil].	instance system isNil ifFalse:		[instance resetSystem].	^instance currentLogin</body><body package="GlorpAtlasUI">chooseMetaSystem	"Return the system which was used to populate the schema drop-down;  this system will have logged-in metadataSession with schema now assigned to be chosen schema (if one was chosen).  Only use this method if the caller intends to use that system and take responsibility for cleaning it up."	| instance |	instance := self new.	instance open ifFalse: [^nil].	^instance system</body><body package="GlorpAtlasUI">chooseSession	| instance |	instance := self new.	instance open ifFalse: [^nil].	instance system isNil ifFalse:		[instance resetSystem].	^instance currentSession</body><body package="GlorpAtlasUI">openGlorpWorkbook	"Temporarily we reference GlorpWorkbook indirectly, until it is moved to a prereq."	^(#{Glorp.UI.GlorpWorkbook} valueOrDo: [^nil])		openOnSession: (self chooseSession ifNil: [^nil])</body></methods><methods><class-id>Glorp.MappingClassModelHelper</class-id> <category>accessing</category><body package="GlorpAtlasUI">addOwnedVariable: aClassModelVariableHelper	"Refactor into standard #addVariable: behaviour."	self addVariable: aClassModelVariableHelper.	aClassModelVariableHelper ownedClass: self.</body><body package="GlorpAtlasUI">addVariable: aClassModelVariableHelper	(superclass notNil and:		[superclass instVarNames includes: aClassModelVariableHelper name])			ifTrue: [^self].	super addVariable: aClassModelVariableHelper.</body><body package="GlorpAtlasUI">superclass	^superclass</body><body package="GlorpAtlasUI">superclass: aClass	superclass := aClass</body></methods><methods><class-id>Glorp.ConnectionSubcanvas</class-id> <category>private-profile list</category><body package="GlorpAtlasUI">addOrReplaceProfile: aProfile	"If there is a profile with the same name as that of the argument,	replace it with the argument."	(self class profiles includes: aProfile) ifTrue: [self class profiles remove: aProfile].	self class profiles add: aProfile.</body><body package="GlorpAtlasUI">allProfiles	^self class profiles copyWith: self lastUsedProfile</body><body package="GlorpAtlasUI">currentProfile	^currentProfileHolder value</body><body package="GlorpAtlasUI">currentProfile: aProfile	currentProfileHolder value: aProfile.	self connectionProfileHolder value:		((self class profiles anySatisfy: [:some | some name = aProfile name])			ifTrue: [aProfile name]			ifFalse: [nil])</body><body package="GlorpAtlasUI">deleteProfileNamed: aString	| profile |	profile := self class profiles detect: [:some | some name = aString].	self class profiles remove: profile</body><body package="GlorpAtlasUI">lastUsedProfile	self class lastUsedProfile isNil ifTrue:		[self class lastUsedProfile: self createNewProfile].	^self class lastUsedProfile</body><body package="GlorpAtlasUI">updateProfileList	self connectionProfileListHolder value: self knownProfileNames</body></methods><methods><class-id>Glorp.ConnectionSubcanvas</class-id> <category>aspects</category><body package="GlorpAtlasUI">connectionProfileHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^connectionProfileHolder isNil		ifTrue:			[connectionProfileHolder := String new asValue]		ifFalse:			[connectionProfileHolder]</body><body package="GlorpAtlasUI">connectionProfileListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^connectionProfileListHolder isNil		ifTrue:			[connectionProfileListHolder := List new asValue]		ifFalse:			[connectionProfileListHolder]</body><body package="GlorpAtlasUI">databaseHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseHolder isNil		ifTrue:			[databaseHolder := String new asValue]		ifFalse:			[databaseHolder]</body><body package="GlorpAtlasUI">databaseListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^databaseListHolder isNil		ifTrue:			[databaseListHolder := List new asValue]		ifFalse:			[databaseListHolder]</body><body package="GlorpAtlasUI">environmentHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentHolder isNil		ifTrue:			[environmentHolder := String new asValue]		ifFalse:			[environmentHolder]</body><body package="GlorpAtlasUI">environmentListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^environmentListHolder isNil		ifTrue:			[environmentListHolder := List new asValue]		ifFalse:			[environmentListHolder]</body><body package="GlorpAtlasUI">loginError	^loginError</body><body package="GlorpAtlasUI">passwordHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^passwordHolder isNil		ifTrue:			[passwordHolder := String new asValue]		ifFalse:			[passwordHolder]</body><body package="GlorpAtlasUI">userNameHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameHolder isNil		ifTrue:			[userNameHolder := String new asValue]		ifFalse:			[userNameHolder]</body><body package="GlorpAtlasUI">userNameListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^userNameListHolder isNil		ifTrue:			[userNameListHolder := List new asValue]		ifFalse:			[userNameListHolder]</body></methods><methods><class-id>Glorp.ConnectionSubcanvas</class-id> <category>very temp - fix</category><body package="GlorpAtlasUI">currentLogin	^Login newFromConnectionProfile: self currentProfile</body><body package="GlorpAtlasUI">passwordself halt.	^passwordHolder ifNil: [ passwordHolder := String new asValue]</body></methods><methods><class-id>Glorp.ConnectionSubcanvas</class-id> <category>private</category><body package="GlorpAtlasUI">createNewProfile	| profile databaseNames |	profile := ConnectionProfile new.	databaseNames := ConnectionProfile concreteDatabaseDriverClassNames.	databaseNames isEmpty ifFalse:		[profile driverClassName: databaseNames first].	^profile</body><body package="GlorpAtlasUI">knownEnvironmentStrings	^(self allProfiles collect: [:each | each environment]) asSet</body><body package="GlorpAtlasUI">knownProfileNames	^(self class profiles collect: [:each | each name]) asSortedCollection</body><body package="GlorpAtlasUI">knownUserNames	"Collect user names used in the existing connection profiles."	^(self allProfiles collect: [:each | each userName]) asSet</body><body package="GlorpAtlasUI">resetBrowseFilesButton	| browseFilesWidget enableAndShow |	browseFilesWidget := self builder componentAt: #browseFiles.	enableAndShow := #('SQLite3Connection' 'SQLite3ThreadedConnection') includes: self databaseHolder value.	browseFilesWidget isEnabled == enableAndShow ifFalse:		[browseFilesWidget			isEnabled: enableAndShow;			isVisible: enableAndShow].	^enableAndShow</body><body package="GlorpAtlasUI">resetProfileName	self currentProfile resetName.	self connectionProfileHolder value: nil.	self profileChanged</body></methods><methods><class-id>Glorp.ConnectionSubcanvas</class-id> <category>actions</category><body package="GlorpAtlasUI">browseFiles	| fname |	fname := Dialog		requestFileName: #PleaseTypeAFileName &lt;&lt; #database &gt;&gt; 'Please type a file name: '		default: '*.sqlite'.	fname isEmpty ifTrue: [^self].	self environmentHolder value: fname.	self environmentChanged.</body><body package="GlorpAtlasUI">clearProfile	self class lastUsedProfile: nil.	self currentProfile: self lastUsedProfile copy.</body><body package="GlorpAtlasUI">connect	self class lastUsedProfile: self currentProfile.	AdHocQueryTool open source connectToProfile: self currentProfile.</body><body package="GlorpAtlasUI">deleteProfile	| nameToDelete |	nameToDelete := self connectionProfileHolder value.	nameToDelete isNil ifTrue: [^self].	(Dialog confirm: (#GenKeyDeleteProfile &lt;&lt; #database &gt;&gt; 'Are you sure you want to delete this connection profile?')) ifFalse: [^self].	self 		deleteProfileNamed: nameToDelete;		currentProfile: self createNewProfile;		updateProfileList</body><body package="GlorpAtlasUI">saveProfile	| name savedProfile |	name := Dialog		request: #ProfileName &lt;&lt; #database &gt;&gt; 'Profile name:'		initialAnswer: self currentProfile originalName.	name isEmpty ifTrue: [^self].	self currentProfile name: name.	savedProfile := self currentProfile copy.	self		addOrReplaceProfile: savedProfile;	 	updateProfileList.	"As we have not changed the currentProfile, use setValue: to avoid needless updates ..."	self connectionProfileHolder setValue: self currentProfile name.	"... but we must update the widget itself"	(self connectionProfileHolder myDependents		detect: [:each | each class = ComboBoxInputFieldView]		ifNone: [^self])		"ifNone not a possible outcome outside 'closing while doing' weirdness"			updateDisplayContents.</body></methods><methods><class-id>Glorp.ConnectionSubcanvas</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initialize	super initialize.	self initializeAspects.	self 		updateProfileList;		currentProfile: self lastUsedProfile copy.	self databaseListHolder value: ConnectionProfile concreteDatabaseDriverClassNames.	self environmentListHolder value: 		self knownEnvironmentStrings asSortedCollection.	self userNameListHolder value:		self knownUserNames asSortedCollection.	self connectionProfileHolder onChangeSend: #profileSelected to: self.	currentProfileHolder onChangeSend: #profileChanged to: self.</body><body package="GlorpAtlasUI">initializeAspects	currentProfileHolder := ValueHolder new.	"Show the class names as strings but hold them as symbols."	databaseHolder := (TypeConverter on: (self profileAspect: #driverClassName))		getBlock: [:m | m value asString]		putBlock: [:m :v | m value: v asSymbol]		updateBlock: [:m :a :p | true].	"must be valid by construction of the drop-down (user-typing barred)"	environmentHolder := self profileAspect: #environment.	userNameHolder := self profileAspect: #userName.	passwordHolder := self profileAspect: #password.</body><body package="GlorpAtlasUI">postBuildWith: aBuilder	#(databaseCombo environmentCombo userNameCombo passwordField) do:		[:widgetName |		(builder componentAt: widgetName) 			widget controller continuousAccept: true].	self profileChanged. "cause update"</body><body package="GlorpAtlasUI">profileAspect: aSymbol	^(AspectAdaptor forAspect: aSymbol)		subjectChannel: currentProfileHolder;		yourself</body><body package="GlorpAtlasUI">setModel: aWsdlBuilderModel	model := aWsdlBuilderModel.	"self safelyExecute: [self initializeAspects]"	loginError := String new asValue.</body></methods><methods><class-id>Glorp.ConnectionSubcanvas</class-id> <category>notifications</category><body package="GlorpAtlasUI">databaseChanged	self resetProfileName.</body><body package="GlorpAtlasUI">environmentChanged	self resetProfileName</body><body package="GlorpAtlasUI">passwordChanged	self resetProfileName</body><body package="GlorpAtlasUI">profileChanged	| hasName |	hasName := self currentProfile name notNil.	self builder window notNil ifTrue:		[(self builder componentAt: #saveProfile) isEnabled: hasName not.		(self builder componentAt: #deleteProfile) isEnabled: hasName.		(self builder componentAt: #connect) isEnabled: self currentProfile isValid].	self resetBrowseFilesButton.	self loginError value: String new.</body><body package="GlorpAtlasUI">profileSelected	| name profile |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name].	currentProfileHolder value: profile copy</body><body package="GlorpAtlasUI">userNameChanged	self resetProfileName</body></methods><methods><class-id>Glorp.ConnectionSubcanvas class</class-id> <category>accessing</category><body package="GlorpAtlasUI">header	^#DatabaseConnectionHeader &lt;&lt; #glorp &gt;&gt; 'Specify the database connection'</body><body package="GlorpAtlasUI">helpText	^#DatabaseConnectionHelpText &lt;&lt; #glorp &gt;&gt; 'Provide the connection data.  If the database platform requires it (SQLite does not), the ''Get Schemas'' button will enable when the subform has connection data.  You can then click it to populate the schema drop-down.If desired,	- use the AdHoc SQL button to open a connected SQL window where you can run test queries on the database	- use the Clear button to reset all fields to their defaults	- use the Save button to add a connection profile to the drop-down list	(N.B. only the profile is saved;  the currently chosen schema is not saved.)See the DatabaseAppDevGuide.pdf for information on connection profiles.'</body><body package="GlorpAtlasUI">lastUsedProfile	^lastUsedProfile</body><body package="GlorpAtlasUI">lastUsedProfile: aProfile	lastUsedProfile := aProfile</body><body package="GlorpAtlasUI">profiles	^DBProfileManager profiles</body></methods><methods><class-id>Glorp.LoginSubcanvas</class-id> <category>private</category><body package="GlorpAtlasUI">knownSchemas	"Later connect, get schemas, disconnect for valid Login or session, and cache till Login data changes."	^#()</body><body package="GlorpAtlasUI">resetBrowseFilesButton	"In Store.ConnectionDialog, the isNil guard is needed, so it might be needed here too."	| showSchemas getSchemasWidget schemaComboWidget |	(self builder componentAt: #browseFiles) isNil ifTrue: [^self].	showSchemas := super resetBrowseFilesButton not.	getSchemasWidget := self builder componentAt: #getSchemas.	schemaComboWidget := self builder componentAt: #schemaCombo.	getSchemasWidget isVisible: showSchemas.	schemaComboWidget isVisible: showSchemas.	showSchemas ifFalse: [schemaHolder value: String new].	getSchemasWidget isEnabled:		(showSchemas and: [self currentProfile isValidForMultiUserDB]).	self schemaHolder value: ''.	self resetSystem.</body><body package="GlorpAtlasUI">resetSystem	model system isNil ifFalse:		[model system metadataSession logout.		model system: nil.		self initializeSchemaList].</body></methods><methods><class-id>Glorp.LoginSubcanvas</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initialize	super initialize.	self initializeSchemaList.</body><body package="GlorpAtlasUI">initializeAspects	super initializeAspects.	"schemaHolder := self profileAspect: #schema."</body><body package="GlorpAtlasUI">initializeSchemaList	self schemaListHolder value: self knownSchemas asSortedCollection</body><body package="GlorpAtlasUI">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(builder componentAt: #schemaCombo) 		widget controller continuousAccept: true.</body></methods><methods><class-id>Glorp.LoginSubcanvas</class-id> <category>aspects</category><body package="GlorpAtlasUI">schemaHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^schemaHolder isNil		ifTrue:[ schemaHolder := String new asValue ]		ifFalse:	[ schemaHolder ]</body><body package="GlorpAtlasUI">schemaListHolder	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^schemaListHolder isNil		ifTrue: [ schemaListHolder := List new asValue ]		ifFalse: 	[ schemaListHolder ]</body></methods><methods><class-id>Glorp.LoginSubcanvas</class-id> <category>notifications</category><body package="GlorpAtlasUI">profileSelected	| profile name |	name := self connectionProfileHolder value.	name isNil ifTrue: [^self].	profile := self class profiles detect: [:some | some name = name] ifNone: [^self].	currentProfileHolder value: profile copy.</body><body package="GlorpAtlasUI">schemaChanged	self model schema: self schemaHolder value.	model system isNil ifFalse:		[model system metadataSession accessor currentLogin schema: self schemaHolder value].</body></methods><methods><class-id>Glorp.LoginSubcanvas</class-id> <category>actions</category><body package="GlorpAtlasUI">cancel	self resetSystem.	^super cancel.</body><body package="GlorpAtlasUI">closeRequestFromParent	self class lastUsedProfile: self currentProfile.	"Push up once superclass has this method."	[self model system isNil ifTrue:			[self model activeRecordSystemLogin: self currentLogin]]		on: Error		do: [:ex | self loginError value: 'Login Error: ', ex description. ^false].	^true</body><body package="GlorpAtlasUI">getSchemas	"Change the halt to a comment (or drop the guard) when satisfied the guard is robust (or is needless).  Since we reset the system if #getSchemas raises an error, this should only ever happen if the #getSchemas button is enabled when it should not be, indicating an error."	model system isNil ifFalse:		[self halt: 'Did wrong UI logic re-enable getSchemas?'.		self resetSystem].	[model activeRecordSystemLogin: super currentLogin.	"do not set schema while getting schemas"	self schemaListHolder value:		(model system platform readSchemasForSession: model system metadataSession) asSortedCollection.	self schemaHolder value: '- choose from dropdown -'.	(self builder componentAt: #getSchemas) isEnabled: false] 		on: Error		do: [:ex |			self resetSystem.			self loginError value: 'Login Error: ', ex description].</body></methods><methods><class-id>Glorp.LoginSubcanvas</class-id> <category>accessing</category><body package="GlorpAtlasUI">currentLogin	^super currentLogin		schema: self schemaHolder value;		yourself</body></methods><methods><class-id>Glorp.LoginSubcanvas class</class-id> <category>accessing</category><body package="GlorpAtlasUI">header	^#DatabaseLoginHeader &lt;&lt; #glorp &gt;&gt; 'Specify DB connection, then schema (if needed)'</body><body package="GlorpAtlasUI">helpText	^#DatabaseLoginHelpText &lt;&lt; #glorp &gt;&gt; 'Provide the connection data.  If the database platform requires it (SQLite does not), the ''Get Schemas'' button will enable when the subform has connection data; clicking it populates the schema drop-down.  Either with or without doing this, enter a schema, then move to the next screen to see the tables in that schema.If desired,	- use the AdHoc SQL button to open a connected SQL window where you can run test queries on the database	- use the Clear button to reset all fields to their defaults	- use the Save button to add a connection profile to the drop-down list	(N.B. only the profile is saved;  the currently chosen schema is not saved.)See the DatabaseAppDevGuide.pdf for information on connection profiles.'</body></methods><methods><class-id>Glorp.MappingClassBuilderHelper</class-id> <category>accessing</category><body package="GlorpAtlasUI">domainSuperclass	^superclassBindingReference value</body><body package="GlorpAtlasUI">domainSuperclassBindingReference	superclassBindingReference isNil ifTrue: [self domainSuperclassName: 'Glorp.PersistentObject'].	^superclassBindingReference</body><body package="GlorpAtlasUI">domainSuperclassName: aString	superclassBindingReference := aString asQualifiedReference.</body></methods><methods><class-id>Glorp.MappingClassBuilderHelper</class-id> <category>create class</category><body package="GlorpAtlasUI">createClassFor: classModelHelper	| strm |	strm := WriteStream on: String new.	classModelHelper variables do:		[:aVariable |		strm nextPutAll: aVariable variableNameForGeneratedClass; space].	^classModelHelper qualifiedReference		defineClass: classModelHelper className asSymbol		superclass: self domainSuperclassBindingReference	"the only change from the super implementation"		indexedType: #none		private: false		instanceVariableNames: strm contents		classInstanceVariableNames: String new		imports: String new		category: String new</body></methods><methods><class-id>Glorp.MapTablesToClasses</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initializeAspects	selectedRow := nil asValue.	showTablesWithPatternAspect := false asValue.	showTablesWithPatternAspect onChangeSend: #setTableClassMap to: self.	tableNamePatternAspect := self model tableSelectionCriteria asValue.	showTablesWithoutPatternAspect := false asValue.	showTablesWithoutPatternAspect onChangeSend: #setTableClassMap to: self.	tableNameNotPatternAspect := self model tableNotSelectionCriteria asValue.	"For now, this is changed only by clicking on the 'Create Class' label, but left a ValueHolder in case of other use later"	selectTablesAspect := false asValue.	selectTablesAspect onChangeSend: #resetCreateClasses to: self.		datasetAspect :=  SelectionInListSortAware new.	datasetAspect selectionIndexHolder compute: [:v | self selectedRow value: datasetAspect selection].	self setTableClassMap.</body><body package="GlorpAtlasUI">resetCreateClasses	self datasetAspect list do:		[:each | each createClass: self selectTablesAspect value].	self datasetAspect listHolder changed: #value.</body><body package="GlorpAtlasUI">setTableClassMap	self model		readDatabaseTablesLike: self tableNamePattern		unlike: self tableNameNotPattern.	"Set the latest patterns as next-time-defaults on the class whether used this time or not."	self model class		tableSelectionCriteria: self tableNamePatternAspect value;		tableNotSelectionCriteria: self tableNameNotPatternAspect value.	datasetAspect list: OrderedCollection new.	self model databaseTables do:		[:table |		datasetAspect list add:			(DatasetRow				initializeFrom: table				createClass: self selectTablesAspect value)].</body></methods><methods><class-id>Glorp.MapTablesToClasses</class-id> <category>utility</category><body package="GlorpAtlasUI">findCassNamed: aString subclassOf: aSuperclass	"Allow the string to be a full name or a simple name, the latter in the common case there are not two such names.  We need our to-be-discarded failure strings to be the names of anything that understands #name;  we use a raw Login."	| candidates |	candidates := aSuperclass withAllSubclasses select:		[:each |		each fullName = aString ifTrue: [^each].		each name = aString].	candidates isEmpty ifTrue: [^Login basicNew name: 'Unrecognised ', aString].	candidates size &gt; 1 ifTrue: [^Login basicNew name: 'Give fullName ', aString].	^candidates first</body></methods><methods><class-id>Glorp.MapTablesToClasses</class-id> <category>aspects</category><body package="GlorpAtlasUI">datasetAspect	^datasetAspect</body><body package="GlorpAtlasUI">selectTablesAspect	^selectTablesAspect</body><body package="GlorpAtlasUI">selectedRow	^selectedRow</body><body package="GlorpAtlasUI">showTablesWithPatternAspect	^showTablesWithPatternAspect</body><body package="GlorpAtlasUI">showTablesWithoutPatternAspect	^showTablesWithoutPatternAspect</body><body package="GlorpAtlasUI">tableNameNotPattern	^self showTablesWithoutPatternAspect value		ifTrue: [self tableNameNotPatternAspect value]		ifFalse: ['']</body><body package="GlorpAtlasUI">tableNameNotPatternAspect	^tableNameNotPatternAspect</body><body package="GlorpAtlasUI">tableNamePattern	^self showTablesWithPatternAspect value		ifTrue: [self tableNamePatternAspect value]		ifFalse: ['%']</body><body package="GlorpAtlasUI">tableNamePatternAspect	^tableNamePatternAspect</body></methods><methods><class-id>Glorp.MapTablesToClasses</class-id> <category>actions</category><body package="GlorpAtlasUI">closeRequestFromParent	| tablesToClassNames |	tablesToClassNames :=		(datasetAspect list select: [:row | row createClass])			collect: [:row | row table -&gt; row className].	tablesToClassNames isEmpty ifTrue:		[Dialog warn: 'No tables selected'.		^false].	self model setSelectedTables: tablesToClassNames.	^true</body><body package="GlorpAtlasUI">selectedRowClassNameLabelPressed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."	| ascSortBlock dscSortBlock sortBlock |	ascSortBlock := [:x :y | x className displayString &lt;= y className displayString].	dscSortBlock := [:x :y | x className displayString &gt;= y className displayString].	sortBlock := self datasetAspect sortAspect == #selectedRowClass		ifTrue: [			self datasetAspect sortDirection == #asc				ifTrue: [self datasetAspect sortDirection: #dsc.					ascSortBlock]				ifFalse: [self datasetAspect sortDirection: #asc.					dscSortBlock]]		ifFalse: [self datasetAspect sortAspect: #selectedRowClass.				self datasetAspect sortDirection: #dsc.				ascSortBlock].	self datasetAspect refreshList:		(SortedCollection withAll: (self datasetAspect list) sortBlock: sortBlock) asList.</body><body package="GlorpAtlasUI">selectedRowCreateClassLabelPressed	self selectTablesAspect value: self selectTablesAspect value not.	"self resetCreateClasses.	onChangeSend sends this."</body><body package="GlorpAtlasUI">selectedRowTableNameLabelPressed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined."	| ascSortBlock dscSortBlock sortBlock |	ascSortBlock := [:x :y | x tableName displayString &lt;= y tableName displayString].	dscSortBlock := [:x :y | x tableName displayString &gt;= y tableName displayString].	sortBlock := self datasetAspect sortAspect == #selectedRowTable		ifTrue: [			self datasetAspect sortDirection == #asc				ifTrue: [self datasetAspect sortDirection: #dsc.					ascSortBlock]				ifFalse: [self datasetAspect sortDirection: #asc.					dscSortBlock]]		ifFalse: [self datasetAspect sortAspect: #selectedRowTable.				self datasetAspect sortDirection: #dsc.				ascSortBlock].	self datasetAspect refreshList:		(SortedCollection withAll: (self datasetAspect list) sortBlock: sortBlock) asList.</body></methods><methods><class-id>Glorp.MapTablesToClasses class</class-id> <category>accessing</category><body package="GlorpAtlasUI">header	^#MapTablesToClassesHeader &lt;&lt; #glorp &gt;&gt;'Choose which tables are mapped to classes'</body><body package="GlorpAtlasUI">helpText	^#MapTablesToClassesHelpText &lt;&lt; #glorp &gt;&gt;'This reads all or some of the tables in the chosen database (and schema).  It lets the user choose which tables will be mapped, and they can rename the suggested classes.Table names like: ... and/or unlike: ...	(un)check either box to (un)apply its criteria.  Only tables whose names match / do not match the strings are (re)read from the database.Mapping Table names to classes:  there are three columns	''Table'' holds the database tables names read from the database and schema.		- click on the label to (re)sort the list	''Create Classes'' determines which tables have domain classes generated from them		- click on the label to add/drop all tables		- click on a checkbox to add/drop that table	''Named'' shows the names that the domain classes will have		- edit a proposed class name if desired		- click on the label to (re)sort the listMoving to the next page saves your choices of which tables to map to which classes.'</body></methods><methods><class-id>Glorp.DatasetRow</class-id> <category>accessing</category><body package="GlorpAtlasUI">className	^className</body><body package="GlorpAtlasUI">className: aString	className := aString</body><body package="GlorpAtlasUI">createClass	^createClass</body><body package="GlorpAtlasUI">createClass: aBoolean	createClass := aBoolean</body><body package="GlorpAtlasUI">table	^table</body><body package="GlorpAtlasUI">table: anObject	table := anObject</body><body package="GlorpAtlasUI">tableName	^table name</body></methods><methods><class-id>Glorp.DatasetRow</class-id> <category>initialize-release</category><body package="GlorpAtlasUI">initializeFrom: aTable createClass: aBoolean	table := aTable.	className :=  Inflector new classify: aTable name.	createClass := aBoolean.</body></methods><methods><class-id>Glorp.DatasetRow class</class-id> <category>instance creation</category><body package="GlorpAtlasUI">initializeFrom: aTable createClass: aBoolean	^self new		initializeFrom: aTable createClass: aBoolean;		yourself</body></methods><methods><class-id>Glorp.Login class</class-id> <category>instance creation</category><body package="GlorpAtlasUI">newFromConnectionProfile: aConnectionProfile	"Temporary sort hack to ensure ODBC gets SQLServer first."	| specificPlatformClass |	specificPlatformClass := (DatabasePlatform allSubclasses asSortedCollection: [:a :b | b name &lt; a name])		detect: [:each | each vwConnectionClassNames includes: aConnectionProfile driverClassName asString]		ifNone: [^nil].	^self new		secure: false;		database: specificPlatformClass new;		username: aConnectionProfile userName;		password: aConnectionProfile password;		name: aConnectionProfile name;		connectString: aConnectionProfile environment</body></methods><methods><class-id>Glorp.MySQLODBCPlatform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">supportsMapping	^false</body><body package="GlorpAtlasUI">vwConnectionClassNames	^#('ODBCThreadedConnection' 'ODBCConnection')</body></methods><methods><class-id>Glorp.PostgresSocketPlatform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">supportsMapping	^true</body><body package="GlorpAtlasUI">vwConnectionClassNames	^#('PostgresSocketConnection')</body></methods><methods><class-id>Glorp.OraclePlatform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">supportsMapping	^true</body><body package="GlorpAtlasUI">vwConnectionClassNames	^#('OracleThreadedConnection' 'OracleConnection')</body></methods><methods><class-id>Glorp.OracleODBCPlatform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">vwConnectionClassNames	^#('ODBCThreadedConnection' 'ODBCConnection')</body></methods><methods><class-id>Glorp.SQLite3Platform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">supportsMapping	^true</body><body package="GlorpAtlasUI">vwConnectionClassNames	^#('SQLite3Connection' 'SQLite3Connection')</body></methods><methods><class-id>Glorp.MySQLPlatform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">supportsMapping	^true</body><body package="GlorpAtlasUI">vwConnectionClassNames	^#('MySQLConnection')</body></methods><methods><class-id>Glorp.SQLServerPlatform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">vwConnectionClassNames	"Remove the last name after 70082 goes in."	^#('ODBCThreadedConnection' 'ODBCConnection' 'NTAuthenticatedConnection' 'MS_SQLServerConnection')</body></methods><methods><class-id>Glorp.DB2Platform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">vwConnectionClassNames	^#('DB2ThreadedConnection' 'DB2Connection')</body></methods><methods><class-id>Glorp.DatabasePlatform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">supportsMapping	^false</body><body package="GlorpAtlasUI">vwConnectionClassNames	^#()</body></methods><methods><class-id>Glorp.PostgresLibpqPlatform class</class-id> <category>accessing</category><body package="GlorpAtlasUI">supportsMapping	^true</body><body package="GlorpAtlasUI">vwConnectionClassNames	^#('PostgresLibpqConnection')</body></methods><methods><class-id>Glorp.CreatePersistentObjects class</class-id> <category>interface specs</category><body package="GlorpAtlasUI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeAutoSave true #positionAutoSave true #sizeType #lastSavedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #CreateClassesFromDatabaseTables 				#defaultString: 'Create Classes from Database Tables' 				#catalogID: #glorp ) 			#min: #(#{Core.Point} 730 329 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 672 524 1402 853 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 250 0 0 0 0 1 0 1 ) 							#name: #createDescriptorSystem 							#model: #descriptorClassPrefixAspect ) 						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 4 0 0 0 235 0 0 1 ) 							#name: #createDescriptorSystem 							#model: #createDescriptorSystemAspect 							#label: 							#(#{Kernel.UserMessage} 								#key: #CreateDescriptorWithPrefix 								#defaultString: 'Create Descriptor System with prefix:' 								#catalogID: #glorp ) ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 1 0 124 0 -5 1 149 0 ) 						#name: #CompositeDescriptorSystem ) ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 10 0 -5 1 80 0 ) 					#name: #classDefinition 					#flags: 0 					#isOpaque: true 					#majorKey: #{Tools.DefinitionCreationDialog} 					#minorKey: #locationSpecWithPackage 					#clientKey: #classDefinition ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 255 0 165 0 -5 1 184 0 ) 					#name: #DescriptorSuperclassCombo 					#model: #descriptorSuperclassAspect 					#comboList: #descriptorSuperclassListAspect ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 30 0 168 0 ) 					#name: #DescriptorSuperclassLabel 					#label: 'Descriptor System superclass:' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 155 0 88 0 -5 1 107 0 ) 					#name: #DomainSuperclassCombo 					#model: #domainSuperclassAspect 					#comboList: #domainSuperclassListAspect ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 5 0 91 0 ) 					#name: #DomainSuperclassLabel 					#label: 'Domain superclass:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 30 0 238 0 ) 					#name: #DomainDescSysCompatText 					#label: 'Domain and descriptor system supercasses must be compatible:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 30 0 258 0 ) 					#name: #PersObjWithAnyDSText 					#label: '- PersistentObject is compatible with any DescriptorSystem' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 30 0 278 0 ) 					#name: #ActRecWithActRecDSText 					#label: '- ActiveRecord is compatible with ActiveRecordDescriptorSystem' ) ) ) )</body></methods><methods><class-id>Glorp.TestPersistentObjects class</class-id> <category>interface specs</category><body package="GlorpAtlasUI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeAutoSave true #positionAutoSave true #sizeType #lastSavedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #TestingRetrievingPersistentObjects 				#defaultString: 'Testing Retrieving Persistent Objects' 				#catalogID: #glorp ) 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 1024 768 ) 			#bounds: #(#{Graphics.Rectangle} 752 394 1242 748 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 10 0 -15 1 -10 1 ) 					#name: #workspace 					#flags: 0 					#majorKey: #{Tools.Workbook} 					#minorKey: #windowSpec 					#clientKey: #workspaceAspect ) ) ) )</body></methods><methods><class-id>Glorp.LoginDialog class</class-id> <category>interface specs</category><body package="GlorpAtlasUI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ConnectToDatabase 				#defaultString: 'Connect to Database' 				#catalogID: #glorp ) 			#min: #(#{Core.Point} 426 270 ) 			#max: #(#{Core.Point} 426 270 ) 			#bounds: #(#{Graphics.Rectangle} 747 465 1173 735 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 46 0 320 0 202 0 ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 14 0 320 0 38 0 ) 					#name: #connectionProfile 					#model: #connectionProfileHolder 					#type: #string 					#comboList: #connectionProfileListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 56 0 310 0 79 0 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #databaseChanged ) 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 85 0 310 0 109 0 ) 					#name: #environmentCombo 					#model: #environmentHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #environmentChanged ) 					#isReadOnly: false 					#comboList: #environmentListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 114 0 310 0 138 0 ) 					#name: #userNameCombo 					#model: #userNameHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #userNameChanged ) 					#isReadOnly: false 					#comboList: #userNameListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 143 0 310 0 167 0 ) 					#name: #passwordField 					#model: #passwordHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #passwordChanged ) 					#type: #password ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 207 0 310 0 227 0 ) 					#name: #schemaCombo 					#model: #schemaHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #schemaChanged ) 					#isReadOnly: false 					#comboList: #schemaListHolder ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 173 0 220 0 196 0 ) 					#name: #saveProfile 					#model: #saveProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Save 						#defaultString: 'Save...' 						#catalogID: #glorp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 230 0 173 0 310 0 196 0 ) 					#name: #deleteProfile 					#model: #deleteProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Delete 						#defaultString: 'Delete' 						#catalogID: #glorp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'Connect' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #database ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 80 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 138 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 167 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 109 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #database ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 38 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #profile 						#defaultString: 'Connection Profile:' 						#catalogID: #database ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 91 0 -10 1 109 0 ) 					#name: #browseFiles 					#model: #browseFiles 					#label: 					#(#{Kernel.UserMessage} 						#key: #BrowseFiles 						#defaultString: 'Browse Files' 						#catalogID: #glorp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 207 0 100 0 227 0 ) 					#name: #getSchemas 					#model: #getSchemas 					#label: 					#(#{Kernel.UserMessage} 						#key: #GetSchemas 						#defaultString: 'Get Schemas' 						#catalogID: #database ) 					#isDefault: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 241 0 ) 					#name: #Label1 					#label: 'Descriptor system:' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 238 0 -10 1 257 0 ) 					#name: #ComboBox1 					#model: #descriptorSuperclassAspect 					#isReadOnly: false 					#comboList: #descriptorSuperclassListAspect ) ) ) )</body></methods><methods><class-id>Glorp.ConnectionSubcanvas class</class-id> <category>interface specs</category><body package="GlorpAtlasUI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ConnectToDatabase 				#defaultString: 'Connect to Database' 				#catalogID: #glorp ) 			#min: #(#{Core.Point} 426 245 ) 			#max: #(#{Core.Point} 426 245 ) 			#bounds: #(#{Graphics.Rectangle} 747 478 1173 723 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 46 0 320 0 202 0 ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 14 0 320 0 38 0 ) 					#name: #connectionProfile 					#model: #connectionProfileHolder 					#type: #string 					#comboList: #connectionProfileListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 56 0 310 0 79 0 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #databaseChanged ) 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 85 0 310 0 109 0 ) 					#name: #environmentCombo 					#model: #environmentHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #environmentChanged ) 					#isReadOnly: false 					#comboList: #environmentListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 114 0 310 0 138 0 ) 					#name: #userNameCombo 					#model: #userNameHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #userNameChanged ) 					#isReadOnly: false 					#comboList: #userNameListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 143 0 310 0 167 0 ) 					#name: #passwordField 					#model: #passwordHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #passwordChanged ) 					#type: #password ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 173 0 220 0 196 0 ) 					#name: #saveProfile 					#model: #saveProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Save 						#defaultString: 'Save...' 						#catalogID: #glorp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 230 0 173 0 310 0 196 0 ) 					#name: #deleteProfile 					#model: #deleteProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Delete 						#defaultString: 'Delete' 						#catalogID: #glorp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'AdHoc SQL' 						#catalogID: #glorp ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #clearProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClearProfile 						#defaultString: 'Clear' 						#catalogID: #glorp ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 80 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #glorp ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 138 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #glorp ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 167 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #glorp ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 109 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #glorp ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 38 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #profile 						#defaultString: 'Connection Profile:' 						#catalogID: #glorp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 91 0 -10 1 109 0 ) 					#name: #browseFiles 					#model: #browseFiles 					#label: 					#(#{Kernel.UserMessage} 						#key: #BrowseFiles 						#defaultString: 'Browse Files' 						#catalogID: #glorp ) 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -40 1 -1 1 -1 1 ) 					#name: #InputField1 					#flags: 0 					#isOpaque: true 					#model: #loginError 					#tabable: false ) ) ) )</body></methods><methods><class-id>Glorp.LoginSubcanvas class</class-id> <category>interface specs</category><body package="GlorpAtlasUI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ConnectToDatabase 				#defaultString: 'Connect to Database' 				#catalogID: #glorp ) 			#min: #(#{Core.Point} 426 245 ) 			#max: #(#{Core.Point} 426 245 ) 			#bounds: #(#{Graphics.Rectangle} 660 315 1086 560 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 46 0 320 0 202 0 ) ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 14 0 320 0 38 0 ) 					#name: #connectionProfile 					#model: #connectionProfileHolder 					#type: #string 					#comboList: #connectionProfileListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 56 0 310 0 79 0 ) 					#name: #databaseCombo 					#model: #databaseHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #databaseChanged ) 					#type: #string 					#comboList: #databaseListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 85 0 310 0 109 0 ) 					#name: #environmentCombo 					#model: #environmentHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #environmentChanged ) 					#isReadOnly: false 					#comboList: #environmentListHolder ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 114 0 310 0 138 0 ) 					#name: #userNameCombo 					#model: #userNameHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #userNameChanged ) 					#isReadOnly: false 					#comboList: #userNameListHolder ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 143 0 310 0 167 0 ) 					#name: #passwordField 					#model: #passwordHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #passwordChanged ) 					#type: #password ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 207 0 310 0 227 0 ) 					#name: #schemaCombo 					#model: #schemaHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #schemaChanged ) 					#isReadOnly: false 					#comboList: #schemaListHolder ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 173 0 220 0 196 0 ) 					#name: #saveProfile 					#model: #saveProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Save 						#defaultString: 'Save...' 						#catalogID: #glorp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 230 0 173 0 310 0 196 0 ) 					#name: #deleteProfile 					#model: #deleteProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #Delete 						#defaultString: 'Delete' 						#catalogID: #glorp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 14 0 -10 1 39 0 ) 					#name: #connect 					#model: #connect 					#label: 					#(#{Kernel.UserMessage} 						#key: #Connect 						#defaultString: 'AdHoc SQL' 						#catalogID: #glorp ) 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 46 0 -10 1 71 0 ) 					#name: #cancel 					#model: #clearProfile 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClearProfile 						#defaultString: 'Clear' 						#catalogID: #glorp ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 80 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #interface 						#defaultString: 'Interface:' 						#catalogID: #glorp ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 138 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #userName 						#defaultString: 'User Name:' 						#catalogID: #glorp ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 167 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #password 						#defaultString: 'Password:' 						#catalogID: #glorp ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 109 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #environment 						#defaultString: 'Environment:' 						#catalogID: #glorp ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 9 0 38 0 0 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #profile 						#defaultString: 'Connection Profile:' 						#catalogID: #glorp ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -90 1 91 0 -10 1 109 0 ) 					#name: #browseFiles 					#model: #browseFiles 					#label: 					#(#{Kernel.UserMessage} 						#key: #BrowseFiles 						#defaultString: 'Browse Files' 						#catalogID: #glorp ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 207 0 100 0 227 0 ) 					#name: #getSchemas 					#model: #getSchemas 					#label: 					#(#{Kernel.UserMessage} 						#key: #GetSchemas 						#defaultString: 'Get Schemas' 						#catalogID: #glorp ) 					#isDefault: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -40 1 -1 1 -1 1 ) 					#name: #loginError 					#flags: 0 					#isOpaque: true 					#model: #loginError 					#tabable: false ) ) ) )</body></methods><methods><class-id>Glorp.MapTablesToClasses class</class-id> <category>interface specs</category><body package="GlorpAtlasUI">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #sizeAutoSave true #positionAutoSave true #sizeType #lastSavedSize #openType #advanced #positionType #lastSavedPosition ) 			#label: 			#(#{Kernel.UserMessage} 				#key: #CreateClassesFromDatabaseTables 				#defaultString: 'Create Classes from Database Tables' 				#catalogID: #glorp ) 			#min: #(#{Core.Point} 730 329 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 672 524 1402 853 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showVerticalLines true #allowColumnReordering false #showLineNumbers false #allowColumnResizing true #rowLabelsAsButtons false #showHorizontalLines true ) 					#layout: #(#{Graphics.LayoutFrame} 5 0 43 0 -5 1 0 1 ) 					#name: #datasetAspect 					#flags: 7 					#isOpaque: true 					#model: #datasetAspect 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow tableName' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Table 								#defaultString: 'Table' 								#catalogID: #glorp ) 							#labelIsImage: false 							#width: 250 							#rendererType: #Text 							#editorType: #None 							#choices: #tagList 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow createClass' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Class 								#defaultString: 'Create Class' 								#catalogID: #glorp ) 							#labelIsImage: false 							#width: 90 							#rendererType: #CheckBox 							#editorType: #CheckBox 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedRow className' 							#label: 							#(#{Kernel.UserMessage} 								#key: #Named 								#defaultString: 'Named' 								#catalogID: #glorp ) 							#labelIsImage: false 							#width: 250 							#editorType: #InputField 							#noScroll: false 							#labelsAsButtons: true ) ) 					#verticalPolicy: #wrap 					#horizontalPolicy: #wrapNext 					#labelsAsButtons: true ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 5 0 0 0 95 0 0 1 ) 							#name: #CheckBox1 							#model: #showTablesWithPatternAspect 							#label: 							#(#{Kernel.UserMessage} 								#key: #ShowTableNamesLike 								#defaultString: 'Tables like:' 								#catalogID: #glorp ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 95 0 0 0 -5 1 0 1 ) 							#name: #InputField1 							#model: #tableNamePatternAspect ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 1 0 5 0 -1 0.5 30 0 ) 						#name: #CompositeMatchTableNames ) ) 				#(#{UI.CompositeSpecCollection} 					#collection: #(						#(#{UI.CheckBoxSpec} 							#layout: #(#{Graphics.LayoutFrame} 5 0 0 0 95 0 0 1 ) 							#name: #CheckBox2 							#model: #showTablesWithoutPatternAspect 							#label: 							#(#{Kernel.UserMessage} 								#key: #ShowTableNamesUnLike 								#defaultString: 'and unlike:' 								#catalogID: #glorp ) ) 						#(#{UI.InputFieldSpec} 							#layout: #(#{Graphics.LayoutFrame} 95 0 0 0 -5 1 0 1 ) 							#name: #InputField2 							#model: #tableNameNotPatternAspect ) ) 					#compositeSpec: 					#(#{UI.CompositeSpec} 						#layout: #(#{Graphics.LayoutFrame} 1 0.5 5 0 -1 1 30 0 ) 						#name: #CompositeUnmatchTableNames ) ) ) ) )</body></methods><methods><class-id>UI.CommandRegistry class</class-id> <category>commands - glorp</category><body package="GlorpAtlasUI">glorpAtlasCommand	&lt;command: #glorpAtlas&gt;	^Command		label: #Glorp_Atlas_UI &lt;&lt; #menus &gt;&gt; 'Glorp Atlas UI'		group: #database		bindings: #(			#isMacOSX #(cmd F10)			#isMSWindows #(F10)			#isX11 #(F10)		)</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-glorp atlas</category><body package="GlorpAtlasUI">glorpAtlasDescriptorPrefix	&lt;setting: #(glorpAtlas descriptorPrefix)&gt;	^(StringSetting on: MappingModel aspect: #descriptorClassPrefix )		label: #DescriptorPrefix &lt;&lt; #glorp &gt;&gt; 'Descriptor prefix';		default: MappingModel descriptorClassPrefixValue;		helpText: #DescriptorClassPrefixHelpText &lt;&lt; #glorp &gt;&gt; 'The descriptor class prefix:  the application descriptor system class name is constructed from this prefix and the descriptor superclass'' atlasNameExtension';		yourself</body><body package="GlorpAtlasUI">glorpAtlasDescriptorSuper	&lt;setting: #(glorpAtlas descriptorSuperclass)&gt;	^(StringSetting on: MappingModel aspect: #defaultDescriptorSuperclassName )		label: #DescriptorSuperclassName &lt;&lt; #glorp &gt;&gt; 'Descriptor superclass name';		default: MappingModel defaultDescriptorSuperclassNameValue;		helpText: #DescriptorSuperclassNameHelpText &lt;&lt; #glorp &gt;&gt; 'The fullName of the default superclass for descriptor system classes generated from database schema';		yourself</body><body package="GlorpAtlasUI">glorpAtlasDomainSuper	&lt;setting: #(glorpAtlas superclass)&gt;	^(StringSetting on: MappingModel aspect: #defaultDomainSuperclassName )		label: #DomainSuperclassName &lt;&lt; #glorp &gt;&gt; 'Domain superclass name';		default: MappingModel defaultSuperclassNameValue;		helpText: #DomainSuperclassNameHelpText &lt;&lt; #glorp &gt;&gt; 'The fullName superclass of domain classes generated from the database tables';		yourself</body><body package="GlorpAtlasUI">glorpAtlasNamespace	&lt;setting: #(glorpAtlas namespace)&gt;	^(StringSetting on: MappingModel aspect: #defaultNamespace )		label: #NamespaceName &lt;&lt; #glorp &gt;&gt; 'Namespace name';		default: MappingModel defaultNamespaceValue;		helpText: #NamespaceNameHelpText &lt;&lt; #glorp &gt;&gt; 'The fullName of the namespace in which domain classes and the descriptor system class will be generated';		yourself</body><body package="GlorpAtlasUI">glorpAtlasPackage	&lt;setting: #(glorpAtlas package)&gt;	^(StringSetting on: MappingModel aspect: #defaultPackage )		label: #PackageName &lt;&lt; #glorp &gt;&gt; 'Package name';		default: MappingModel defaultPackageValue;		helpText: #PackageNameHelpText &lt;&lt; #glorp &gt;&gt; 'The name of the package in which domain classes and the descriptor system class will be generated';		yourself</body><body package="GlorpAtlasUI">glorpAtlasPage	&lt;settingsPage: #(glorpAtlas)&gt;	^ModularSettingsPage new		label: #GlorpAtlas &lt;&lt; #glorp &gt;&gt; 'Glorp Atlas';		icon: (ListIconLibrary visualFor: #store);		useRadioButtonsForEnumerations;		settings: (self settingsWithPrefix: #(glorpAtlas))</body></methods><methods><class-id>Database.ConnectionDialog</class-id> <category>private-profile list</category><body package="GlorpAtlasUI">currentLogin	^Login newFromConnectionProfile: self currentProfile</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>menus - tools - database</category><body package="GlorpAtlasUI">menuItemGlorpAtlasUI	"Open the Glorp Mapping Wizard"	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #glorpAtlas		icon: #(#{UI.ResourceRetriever} #{Tools.ListIconLibrary} #store )		nameKey: nil		menu: #(#menuBar #tools #database)		position: 10.2&gt;	MappingUI open.</body></methods><initialize><class-id>Glorp.MappingSubcanvas</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>ClassModelHelper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className variables namespace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><class><name>ConnectionDialog</name><environment>Database</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionProfileListHolder connectionProfileHolder databaseListHolder databaseHolder environmentListHolder environmentHolder userNameListHolder userNameHolder passwordHolder currentProfileHolder </inst-vars><class-inst-vars>lastUsedProfile </class-inst-vars><imports></imports><category>Database-Connection Dialog</category><attributes><package>Database</package></attributes></class><class><name>PageSequence</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model pages pageIndex client subcanvasName modelClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wizard-Tools</category><attributes><package>Tools-NavigationPages</package></attributes></class><class><name>ClassBuilderHelper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system dictionary package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><class><name>SequenceableSubcanvas</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent model </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Wizard-Tools</category><attributes><package>Tools-NavigationPages</package></attributes></class></st-source>