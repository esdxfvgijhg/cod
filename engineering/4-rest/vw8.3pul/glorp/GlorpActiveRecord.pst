<?xml version="1.0"?><st-source><!-- Name: GlorpActiveRecordNotice: Copyright 2006-2012 Alan Knight.Portions © 2012-2014 Cincom Systems, Inc.  All rights reserved.This utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This implements the ActiveRecord pattern as a way of generating Glorp metadata automatically.  (It borrows from ActiveRecord as implemented in RubyOnRails.)  For more information, see Chapter 3 of doc/GlorpGuide.pdf (code for this chapter's examples is in the GlorpGuideExamples parcel).DbIdentifier: bear73DbTrace: 502563DbUsername: nrossDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'GlorpAnalysis' ''))ExplicitPrerequisites: #()IgnoredPrerequisites: #('Seaside-Glorp')PackageName: GlorpActiveRecordParcel: #('GlorpActiveRecord')ParcelName: GlorpActiveRecordPrerequisiteParcels: #(#('GlorpAnalysis' ''))PrintStringCache: (8.3 - 1,nross)Version: 8.3 - 1Date: 11:29:14 AM June 16, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:29:14 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ActiveRecords</name><environment>Glorp</environment><private>false</private><imports>			private Glorp.*			</imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></name-space><comment><name-space-id>Glorp.ActiveRecords</name-space-id><body>This is a namespace for classes in the GlorpActiveRecord package.</body></comment><class><name>Inflector</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>plurals singulars irregulars uncountables pluralTableNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><comment><class-id>Glorp.Inflector</class-id><body>This is modeled after the Ruby on Rails Inflector class that attempts to figure out instance variable and database naming conventions to infer the nature of relationships.</body></comment><class><name>ActiveRecordDescriptorSystem</name><environment>Glorp.ActiveRecords</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metadataSession inflector currentDescriptor deferredDescriptorOperations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><comment><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id><body>This is the descriptor system for active record objects. Active records will be aware of this, and this doesn't expect to have normal Glorp metadata description methods in it, but rather will generate as much as it can dynamically based on the classes and the database schema.Instance Variables	currentDescriptor	&lt;Descriptor&gt; A private place holder used during initialization.	deferredDescriptorOperations	&lt;OrderedCollection&gt; A private holder of pending operations.	inflector	&lt;Inflector&gt;	Helps ActiveRecord use existing naming conventions.	metadataSession	&lt;GlorpSession&gt;	 The GlorpSession used by our MetadataDescriptorSystem, which provides information about existing tables, columns and constraints.</body></comment><class><name>ActiveRecordPaginator</name><environment>Glorp.ActiveRecords</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pageSize pageIndex query session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpActiveRecord</package></attributes></class><comment><class-id>Glorp.ActiveRecords.ActiveRecordPaginator</class-id><body>ActiveRecordPaginator queries a database and retrieves PersistentObject objects in chunks (pages), rather than all at once.Instance Variables:	pageIndex	&lt;Integer&gt; current page index	pageSize	&lt;Integer&gt; size of each page to be retrieved	query	&lt;AbstractReadQuery | CompoundQuery&gt;	query that we will search the database with	session	&lt;GlorpSession&gt;</body></comment><class><name>CannotAutomaticallyMapRelationship</name><environment>Glorp</environment><super>Glorp.ValidationError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>varClassName variable referenceClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpActiveRecord</package></attributes></class><comment><class-id>Glorp.CannotAutomaticallyMapRelationship</class-id><body>When we create descriptors, Glorp will try to map instance variables with names that match classes as relations. If there are no any relations in the database that correspond these names reraise this resumable exception instead of CannotAutomaticallyDetermineJoin Instance Variables:	referenceClassName	&lt;String&gt;	referenceClassName, the class with possible relation	varClassName	&lt;String&gt;	varClassName the class Glorp tries to create auto-mapping	variable	&lt;String &gt;	inst variable Glorp was unable to map as relation</body></comment><class><name>ActiveRecord</name><environment>Glorp.ActiveRecords</environment><super>Glorp.PersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><comment><class-id>Glorp.ActiveRecords.ActiveRecord</class-id><body>This is the abstract superclass for ActiveRecord objects. Using an ActiveRecordDescriptorSystem, these can be automatically read from and written to a relational database, based on naming conventions and on database information.Instance Variables	id &lt;Integer&gt; Holds the primary key of an object's row in the database table.Shared Variables	DefaultLogin &lt;Glorp.Login&gt; Holds the database platform and connection information to connect to your database.	DefaultSystem &lt;ActiveRecordDescriptorSystem&gt; Holds the default descriptor system for ActiveRecord subclasses.</body></comment><shared-variable><name>Default</name><environment>Glorp.Inflector</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GlorpActiveRecord</package></attributes></shared-variable><shared-variable><name>DefaultSystem</name><environment>Glorp.ActiveRecords.ActiveRecord</environment><private>false</private><constant>false</constant><category>login</category><initializer>nil</initializer><attributes><package>GlorpActiveRecord</package></attributes></shared-variable><shared-variable><name>DefaultLogin</name><environment>Glorp.ActiveRecords.ActiveRecord</environment><private>false</private><constant>false</constant><category>login</category><initializer>Glorp.Login new</initializer><attributes><package>GlorpActiveRecord</package></attributes></shared-variable><methods><class-id>Glorp.Inflector</class-id> <category>api</category><body package="GlorpActiveRecord">camelize: aString	^self camelize: aString firstLetterInUppercase: true.</body><body package="GlorpActiveRecord">camelize: aString firstLetterInUppercase: firstUpper	"You know, it's really possible to get carried away with regexes. This seems rather simpler to me than the regex implementation."	| source result nextUpper next |	source := aString asString readStream.	result := WriteStream on: String new.	nextUpper := firstUpper.	[source atEnd] whileFalse: [		next := source next.		next = $_ 			ifTrue: [nextUpper := true] 			ifFalse: [				next = $.					ifTrue: [result nextPutAll: '.'. nextUpper := true]					ifFalse: [						result nextPut: (nextUpper 							ifTrue: [nextUpper := false. next asUppercase] 							ifFalse: [next asLowercase])]]].	^result contents.</body><body package="GlorpActiveRecord">classify: tableName	"I guess this makes something into a class name. What, um, clever naming."   ^self camelize: (pluralTableNames ifTrue: [self singularize: tableName] ifFalse: [tableName]).</body><body package="GlorpActiveRecord">dasherize: aString	^aString asString replaceRegex: '_' withString: '-'.</body><body package="GlorpActiveRecord">demodulize: className	^className replaceRegex: '^.*\:\:' withString:''.</body><body package="GlorpActiveRecord">foreignKey: className	^self foreignKey: className separateWithUnderscore: true.</body><body package="GlorpActiveRecord">foreignKey: className separateWithUnderscore: aBoolean	^(self underscore: (self demodulize: className)), (aBoolean ifTrue: ['_id'] ifFalse: ['id']).</body><body package="GlorpActiveRecord">humanize: lowerCaseAndUnderscoredWord	| humanized |	humanized := ((lowerCaseAndUnderscoredWord replaceRegex: '_id$' withString: '')		replaceRegex: '_' withString: ' ').	^humanized isEmpty		ifTrue: [humanized]		ifFalse: [(String with: humanized first asUppercase), (humanized copyFrom: 2 to: humanized size)]</body><body package="GlorpActiveRecord">instVarize: lowerCaseAndUnderscoredWord	| withoutId |	withoutId := lowerCaseAndUnderscoredWord replaceRegex: '_id$' withString: ''.	^self camelize: withoutId firstLetterInUppercase: false.</body><body package="GlorpActiveRecord">ordinalize: aNumericString	| number remainder |	number := aNumericString asNumber.	((11 to: 13) includes: (number \\ 100)) ifTrue: [^aNumericString, 'th'].	remainder := number \\ 10.	remainder = 1 ifTrue: [^aNumericString, 'st'].	remainder = 2 ifTrue: [^aNumericString, 'nd'].	remainder = 3 ifTrue: [^aNumericString, 'rd'].	^aNumericString, 'th'.</body><body package="GlorpActiveRecord">pluralize: aString	| target |	target := aString asString.	(uncountables includes: target asLowercase) ifTrue: [^target].	plurals do: [:each | target replaceRegex: each key asRegexIgnoringCase withString: each value ifMatchedDo: [:result | ^result]].	"As far as I can tell, this is what the initial '$' -&gt; 's' rule accomplishes."	^target, 's'.</body><body package="GlorpActiveRecord">primaryKeyInstVarize: lowerCaseAndUnderscoredWord	"Return the corresponding instance variable name, assuming that this is a primary key. This means that we expect primary keys of the form job_id for a primary key to the jobs table"	^('*_id' match: lowerCaseAndUnderscoredWord)		ifTrue: ['id']		ifFalse: [self instVarize: lowerCaseAndUnderscoredWord].</body><body package="GlorpActiveRecord">singularize: aString	| target |	target := aString asString.	(uncountables includes: target asLowercase) ifTrue: [^target].	singulars do: [:each | target replaceRegex: each key asRegexIgnoringCase withString: each value ifMatchedDo: [:result | ^result]].	^target.</body><body package="GlorpActiveRecord">tableize: aClassName	| underscored |	underscored := self underscore: aClassName.	^pluralTableNames ifTrue: [self pluralize: underscored] ifFalse: [underscored].</body><body package="GlorpActiveRecord">underscore: aWord   ^((((aWord asString replaceRegex: '\:\:' withString: '/') 		replaceRegex: '([A-Z]+)([A-Z][a-z])' withString: '\1_\2')			replaceRegex: '([a-z\d])([A-Z])' withString: '\1_\2')				copyReplaceAll: '-' with: '_') asLowercase.</body><body package="GlorpActiveRecord">uppercaseFirst: aString	"Return the string except with the first character as upper case."	"self new uppercaseFirst: 'abCde'."	aString isEmpty ifTrue: [^aString].	^(String with: (aString first asUppercase)), (aString copyFrom: 2 to: aString size).</body></methods><methods><class-id>Glorp.Inflector</class-id> <category>setup</category><body package="GlorpActiveRecord">irregular: aString string: anotherString	| first rest |	first := String with: aString first.	rest := aString copyFrom: 2 to: aString size.	self plural: ('(', first, ')', rest, '$') string: ('\1', (anotherString copyFrom: 2 to: anotherString size)).	first := String with: anotherString first.	rest := anotherString copyFrom: 2 to: anotherString size.	self singular: ('(', first, ')', rest, '$') string: ('\1', (aString copyFrom: 2 to: aString size)).</body><body package="GlorpActiveRecord">plural: aString string: anotherString	plurals addFirst: aString -&gt;anotherString.</body><body package="GlorpActiveRecord">singular: aString string: anotherString	singulars addFirst: aString -&gt;anotherString.</body><body package="GlorpActiveRecord">uncountable: aCollection	uncountables addAll: aCollection.</body></methods><methods><class-id>Glorp.Inflector</class-id> <category>accessing</category><body package="GlorpActiveRecord">pluralTableNames	^pluralTableNames</body><body package="GlorpActiveRecord">pluralTableNames: aBoolean	pluralTableNames := aBoolean</body></methods><methods><class-id>Glorp.Inflector</class-id> <category>initialize-release</category><body package="GlorpActiveRecord">initialize	plurals := OrderedCollection new.	singulars := OrderedCollection new.	irregulars := OrderedCollection new.	uncountables := OrderedCollection new.	pluralTableNames := false.	self initializeDefaultInflections.</body><body package="GlorpActiveRecord">initializeDefaultInflections	"self reset"	"The single $ doesn't seem to work here, and I'm not even quite sure what it's supposed to do. Match an empty string? Or an empty string at the end of the string? But wouldn't the latter always match. Anyway, leaving it out""	  self plural: '$' string: 's'."	  self plural: 's$' string: 's'. 	  self plural: '(ax|test)is$' string: '\1es'.	  self plural: '(octop|vir)us$' string: '\1i'.	  self plural: '(alias|status)$' string: '\1es'. 	  self plural: '(bu)s$' string: '\1ses'.	  self plural: '(buffal|tomat)o$' string: '\1oes'.	  self plural: '([ti])um$' string: '\1a'.	  self plural: 'sis$' string: 'ses'.	"I had to mess around with this one quite a bit, and ended up splitting it in two " 	  self plural: '([^f])(fe)$' string: '\1ves'. 	  self plural: '([^f])([lr])f$' string: '\1\2ves'. 	  self plural: '(hive)$' string: '\1s'. 	  self plural: '([^aeiouy]|qu)y$' string: '\1ies'. 	  self plural: '(x|ch|ss|sh)$' string: '\1es'. 	  self plural: '(matr|vert|ind)(ix|ex)$' string: '\1ices'. 	  self plural: '([m|l])ouse$' string: '\1ice'. 	  self plural: '^(ox)$' string: '\1en'. 	  self plural: '(quiz)$' string: '\1zes'.	 	  self singular: 's$' string: ''. 	  self singular: '(n)ews$' string: '\1ews'. 	  self singular: '([ti])a$' string: '\1um'. 	  self singular: '((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$' string: '\1\2sis'. 	  self singular: '(^analy)ses$' string: '\1sis'. 	  self singular: '([^f])ves$' string: '\1fe'. 	  self singular: '(hive)s$' string: '\1'. 	  self singular: '(tive)s$' string: '\1'. 	  self singular: '([lr])ves$' string: '\1f'. 	  self singular: '([^aeiouy]|qu)ies$' string: '\1y'. 	  self singular: '(s)eries$' string: '\1eries'. 	  self singular: '(m)ovies$' string: '\1ovie'. 	  self singular: '(x|ch|ss|sh)es$' string: '\1'. 	  self singular: '([m|l])ice$' string: '\1ouse'. 	  self singular: '(bus)es$' string: '\1'. 	  self singular: '(o)es$' string: '\1'. 	  self singular: '(shoe)s$' string: '\1'. 	  self singular: '(cris|ax|test)es$' string: '\1is'. 	  self singular: '(octop|vir)i$' string: '\1us'. 	  self singular: '(alias|status)es$' string: '\1'. 	  self singular: '^(ox)en' string: '\1'. 	  self singular: '(vert|ind)ices$' string: '\1ex'. 	  self singular: '(matr)ices$' string: '\1ix'. 	  self singular: '(quiz)zes$' string: '\1'. 	 	  self irregular: 'person' string: 'people'. 	  self irregular: 'man' string: 'men'. 	  self irregular: 'child' string: 'children'. 	  self irregular: 'sex' string: 'sexes'.	  self irregular: 'move' string: 'moves'. 	 	  self uncountable: #('equipment' 'information' 'rice' 'money' 'species' 'series' 'fish' 'sheep').</body></methods><methods><class-id>Glorp.Inflector</class-id> <category>extensions</category><body package="GlorpActiveRecord">isChildRelationshipFieldName: fieldName	"Return true if this looks like a relationship from something to a collection of children."		^(self instVarize: fieldName asLowercase)= 'child'</body></methods><methods><class-id>Glorp.Inflector class</class-id> <category>instance creation</category><body package="GlorpActiveRecord">default	Default isNil ifTrue: [Default := self new].	^Default.</body><body package="GlorpActiveRecord">inflections	^self default.</body><body package="GlorpActiveRecord">new	^super new initialize.</body><body package="GlorpActiveRecord">reset	"self reset"	Default := nil.</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>accessing</category><body package="GlorpActiveRecord">allActiveRecordClasses	^self class environment allClasses select: [:each | each inheritsFrom: ActiveRecord]</body><body package="GlorpActiveRecord">allDescriptors	| result |	result := super allDescriptors.	"If we haven't yet initialized the descriptors we get from the super call, do so now. Check it by looking for a mapping we know ought to be there."	result isEmpty ifTrue: [^result].	(result first mappingForAttributeNamed: #session) isNil 		ifTrue: [			result do: [:each | 				self addAutomaticMappingsFor: each].			self runDeferredDescriptorInitializations].	^result.</body><body package="GlorpActiveRecord">allTableNames	^#().</body><body package="GlorpActiveRecord">hasMetadataSession	^metadataSession notNil.</body><body package="GlorpActiveRecord">inflector	^inflector</body><body package="GlorpActiveRecord">inflector: anInflector	inflector := anInflector</body><body package="GlorpActiveRecord">metadataSession	metadataSession isNil ifTrue: [self setupMetadataSession].	^metadataSession.</body><body package="GlorpActiveRecord">metadataSession: aGlorpSession	metadataSession := aGlorpSession</body><body package="GlorpActiveRecord">platform: dbPlatform	self initializePlatform: dbPlatform.	^ super platform: dbPlatform</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>private</category><body package="GlorpActiveRecord">deferredDescriptorOperations	^deferredDescriptorOperations</body><body package="GlorpActiveRecord">findConstraintsForSQLiteTables	"Find the foreign key constraints for all of our tables."	| allTables fkeys constraints |	allTables := metadataSession read: DatabaseTable.	constraints := OrderedCollection new.	fkeys := allTables collect: 					[:aTable |					fkeys := aTable foreignKeyConstraints select: 									[:constraint |									(constraint targetFields										detect: [:field | tables keys includes: field table name]										ifNone: [nil]) notNil].					constraints addAll: fkeys].	^constraints</body><body package="GlorpActiveRecord">findConstraintsForTables	"Find the constraints for all of our tables, obviously. Note that the metadata varies by database. Some have foreign key constraints referencing primary key constraints. Others have them referencing target columns directly. Do a different query for each."	| query refersToPrimaryKeyConstraints |	"A slightly ugly test for whether we use primary key constraints or columns directly, but should be reliable."	self platform class = SQLite3Platform ifTrue: [^self findConstraintsForSQLiteTables].	refersToPrimaryKeyConstraints := ((self metadataSession		descriptorFor: PrimaryKeyConstraint)		mappingForAttributeNamed:			#foreignKeyConstraintsUsingMeAsTargetConstraint) notNil.	refersToPrimaryKeyConstraints		ifTrue:			[query := Query				read: PrimaryKeyConstraint				where:					[:each | 					each type = metadataSession system targetOfForeignKeysConstraintTypeString						&amp; (each table schema asLowercase = self session schema asLowercase)						&amp; (each table name in: (tables collect: [:eachTable | eachTable sqlString]))].			query retrieve: [:each | each foreignKeyConstraintsUsingMeAsTargetConstraint]]		ifFalse:			[query := Query				read: ForeignKeyConstraint				where: [:each |					(each tableSchema asLowercase = self session schema asLowercase)					&amp; (each targetFields table name in: tables keys)]].	^metadataSession execute: query.</body><body package="GlorpActiveRecord">findTableForClass: aClass	"Find the table object to use for our class. Basically, look for both the singular and the plural version of the class name, since schemas often aren't very consistent about it."		| possibleTables table |	possibleTables := self tableNamesForClass: aClass.	possibleTables do: [:each |		table := self tableNamed: each ifNone: [nil].		table isNil ifFalse: [^table]].	^nil</body><body package="GlorpActiveRecord">initializeDescriptor: aDescriptor	"This is the method called when a descriptor is being created. Call the super initialization method, but also make note of the current descriptor in an instance variable, which we'll refer to in order to know our context when some of the other metadata is being lazily created during this initialization."	currentDescriptor := aDescriptor.	super initializeDescriptor: aDescriptor.	aDescriptor tables isEmpty ifTrue: [		| table |		table := self findTableForClass: aDescriptor describedClass.		table isNil ifFalse: [aDescriptor table: table]].</body><body package="GlorpActiveRecord">initializeTable: newTable	| initializerName selector |	initializerName := 'tablefor', newTable name asLowercase, ':'.	self class selectorsAndMethodsDo: [:each :method |		each asLowercase = initializerName ifTrue: [selector := each]].	selector ifNotNil: [self perform: selector with: newTable].	newTable		postInitializeIn: self;		schema: self databaseSchema</body><body package="GlorpActiveRecord">initializeTableExtras: newTable	"We expect the primary information for the table to have been read from the database. Call a method to add any extras information that we want to specify above and beyond that."	| initializerName |	initializerName := ('tableExtrasFor' , (newTable sqlString asUppercase) , ':') asSymbol.	(self respondsTo: initializerName)		ifTrue: [self perform: initializerName with: newTable].	newTable postInitializeIn: self.</body><body package="GlorpActiveRecord">instVarize: aField	"Convert the name of the field to instance variable form. Treat it differently if it's a primary key or a regular field. Subclasses may also override to provide different behaviour."	^aField isPrimaryKey		ifTrue: [(inflector primaryKeyInstVarize: aField name asLowercase) asSymbol]		ifFalse: [(inflector instVarize: aField name asLowercase) asSymbol].</body><body package="GlorpActiveRecord">newTableNamed: aString	| newTable |	newTable := DatabaseTable new.	newTable		name: aString;		schema: self session currentLogin schema.	tables at: aString asUppercase put: newTable.	self initializeTable: newTable.	^newTable</body><body package="GlorpActiveRecord">resetDescriptors	"DEEPLY PRIVATE!!!  Descriptor identity is important, so doing this is normally a very bad idea. We're only doing this to avoid some circularities between figuring out what the descriptors are and figuring out what the tables are."	descriptors := Dictionary new.	currentDescriptor := nil.	deferredDescriptorOperations := OrderedCollection new.</body><body package="GlorpActiveRecord">setupMetadataSession	"Create the session that we will use to read table and constraint information from the database. Share the connection with the main session."	metadataSession := MetadataDescriptorSystem sessionForLogin: self session accessor currentLogin.	metadataSession accessor: self session accessor.	metadataSession isLoggedIn ifFalse: [metadataSession login].</body><body package="GlorpActiveRecord">tableNameForClass: aClass	"Return the table name we expect for this class. By default, this is just a direct call to the inflector, but subclasses may override to use different conventions."	^inflector tableize: aClass name.</body><body package="GlorpActiveRecord">tableNamedFromDatabase: aString	"Return the table object matching the given name. Get all the table information directly from the database."	^(self databaseSchema isNil or: [self databaseSchema isEmpty])		ifTrue: [self metadataSession readOneOf: DatabaseTable where: [:each | each name asUppercase = aString asUppercase]]		ifFalse: [self metadataSession readOneOf: DatabaseTable where:				[:each |				each schema asUppercase = self databaseSchema asUppercase					AND: [each name asUppercase = aString asUppercase]]]</body><body package="GlorpActiveRecord">tableNamesForClass: aClass	^self tableNamesForClassName: aClass name</body><body package="GlorpActiveRecord">tableNamesForClassName: aClassName	| name1 oldPlurality name2 |	name1 := inflector tableize: aClassName.	oldPlurality := inflector pluralTableNames.	inflector pluralTableNames: oldPlurality not.	[name2 := inflector tableize: aClassName]		ensure: [inflector pluralTableNames: oldPlurality].	^Array with: name1 with: name2.</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>automatic mappings</category><body package="GlorpActiveRecord">addAutomaticMappingForField: aField in: aDescriptor	"We have a field in a table that aDescriptor maps to. Try to create a mapping for that field."	| instVarName mapping aClass |	instVarName := self instVarize: aField.	"If we already have a mapping created, or if there's no matching instance variable, do nothing."	(aDescriptor mappingForAttributeNamed: instVarName) isNil ifFalse: [^self].	(aDescriptor describedClass allInstVarNames includes: instVarName asString) ifFalse: [^self].	"Are there foreign key constraints - if not, create a direct mapping."	(aField table hasForeignKeyConstraintsForField: aField)		ifFalse: [^aDescriptor directMapping from: instVarName to: aField].	"Otherwise, we have to create a relationship mapping"	mapping := self createRelationshipMappingFor: instVarName in: aDescriptor.	aClass := self referenceClassForField: aField from: aDescriptor.	aClass isNil		ifTrue: ["Remove the mapping if there is no a class yet "aDescriptor removeMapping: mapping]		ifFalse: [mapping					attributeName: instVarName;					referenceClass: aClass ].</body><body package="GlorpActiveRecord">addAutomaticMappingForInstanceVariable: instVarName in: aDescriptor	"See if we have a field matching the instance variable name, and if so, create a direct mapping."	| field fieldName |	(aDescriptor mappingForAttributeNamed: instVarName) isNil ifFalse: [^self].	fieldName := inflector underscore: instVarName.	field := aDescriptor primaryTable fieldNamed: fieldName ifAbsent: [^self] caseSensitive: false.	aDescriptor directMapping from: instVarName to: field.</body><body package="GlorpActiveRecord">addAutomaticMappingForRelationship: instVarName in: aDescriptor	"Add a mapping for an instance variable that we don't have a field for. That means it's presumably a to-many relationship, either with a link table or with a backward foreign key."	| referenceClass referenceDescriptor referenceTable directRelationship mapping |	(aDescriptor mappingForAttributeNamed: instVarName) isNil ifFalse: [^self].	referenceClass := aDescriptor describedClass environment at: (inflector uppercaseFirst: (inflector singularize: instVarName)) ifAbsent: [^self].	(referenceDescriptor := self descriptorFor: referenceClass) isNil ifTrue: [^self].	(referenceTable := referenceDescriptor primaryTable) isNil ifTrue: [^self].	directRelationship := referenceTable hasForeignKeyConstraintsForTargetField: aDescriptor table primaryKeyFields first.	mapping := aDescriptor toManyMapping.	mapping		attributeName: instVarName;		referenceClass: referenceClass;		usesLinkTable: directRelationship not.	directRelationship ifFalse: [		[mapping join] on: CannotAutomaticallyDetermineJoin do: [:ex |			ex constraints isEmpty 				ifTrue: [aDescriptor removeMapping: mapping.						CannotAutomaticallyMapRelationship new							model: aDescriptor describedClass;							varClassName: aDescriptor describedClass name;							variable: instVarName;							referenceClassName: referenceClass name;							signal ]				ifFalse: [self tryToSetLinkFieldsFor: mapping choosingConstraintsFrom: ex constraints]]].</body><body package="GlorpActiveRecord">addAutomaticMappingsFor: aDescriptor	"Create mappings for aDescriptor automatically, based on what we can infer from the database schema."	"All active records can get at their session."	(aDescriptor mappingForAttributeNamed: #session) isNil ifTrue:		[(aDescriptor newMapping: ConstantMapping)			constantValueIsSession;			attributeName: #session].	aDescriptor primaryTable ifNil: [^self].	"For all instance variables, look to see if we have a corresponding field to create a direct mapping for."	aDescriptor describedClass allInstVarNames do: [:each |		self addAutomaticMappingForInstanceVariable: each asSymbol in: aDescriptor].	"For all fields, see if we have a corresponding instance variable, either direct or a relationship."	aDescriptor table fields do: [:each | 		self addAutomaticMappingForField: each in: aDescriptor].	"For instance variables that are to-many, create the relationship appropriately, where the field doesn't exist in our table."		aDescriptor describedClass hasMany, aDescriptor describedClass hasAndBelongsToMany do: [:each |		self addAutomaticMappingForRelationship: each in: aDescriptor].	"If we didn't filll it in otherwise, just try and add something automatic."	aDescriptor describedClass allInstVarNames do: [:each |		(aDescriptor mappingForAttributeNamed: each asSymbol) isNil ifTrue: [			self addAutomaticMappingForRelationship: each in: aDescriptor]].</body><body package="GlorpActiveRecord">createRelationshipMappingFor: instVarName in: aDescriptor	"Try to create a relationship mapping for the instance variable. Use hasMany and hasAndBelongsToMany as hints if available."	| toMany linked mapping |	toMany := aDescriptor describedClass hasMany includes: instVarName.	linked := aDescriptor describedClass hasAndBelongsToMany includes: instVarName.	toMany | linked ifFalse: [^aDescriptor oneToOneMapping].	mapping := ToManyMapping new.	linked ifTrue: [mapping useLinkTable].	^mapping.</body><body package="GlorpActiveRecord">findSequencesForTables	"If we have sequences in the database that are expected to be used for generating primary keys, there's no direct connection between the field and the sequence. Rely on naming convention for primary key fields. Subclasses can override to change the naming convention."	| sequenceName sequence keyField sequenceQuery |	(metadataSession descriptorFor: NamedSequence) isNil ifTrue: [^self].	tables do:		[:eachTable |		keyField := eachTable fieldNamed: 'id' ifAbsent: [nil] caseSensitive: false.		sequenceName := keyField isNil ifFalse: [self sequenceNameForField: keyField].		sequence := keyField isNil ifFalse:			[sequenceQuery := Query				readOneOf: NamedSequence				where: [:eachSequence | eachSequence name asLowercase = sequenceName asLowercase].			metadataSession platform isDB2Platform ifTrue:				[sequenceQuery := sequenceQuery AND: [:eachSequence | eachSequence schema = eachTable schema]].			metadataSession execute: sequenceQuery].		sequence isNil ifFalse:			[keyField type: self platform sequence.			keyField postInitializeIn: self]].</body><body package="GlorpActiveRecord">fixUpMappingsFor: aDescriptor	"Do any modifications we need to do to our mappings. Most notably, if we have an embedded mapping, make sure that the embedded object doesn't have the normal mapping for #id."	aDescriptor mappings do: [:each |		each class = EmbeddedValueOneToOneMapping ifTrue: [			((self descriptorFor: each referenceClass) mappingForAttributeNamed: #id) beForPseudoVariable]].</body><body package="GlorpActiveRecord">referenceClassForField: aDatabaseField from: aDescriptor	"Return the class that we think aDatabaseField is a foreign key to. We have two possible mechanisms. First, we look for foreign keys connecting this field to another table, and then use the class connected to that table. If we can't find that, then we convert the class name to a table name and look that up in the namespace of the referring class."	| targetTable constraints descriptor |	constraints := aDatabaseField foreignKeyConstraints.	constraints size = 1 ifTrue:		[targetTable := constraints first targetFields first table.		descriptor := descriptors detect: [:each | each tables includes: targetTable] ifNone: [nil].		descriptor isNil ifFalse: [^descriptor describedClass]].	^Dialect 		lookupClassNamed: (inflector humanize: aDatabaseField name)		inContextOf: aDescriptor describedClass</body><body package="GlorpActiveRecord">tryToSetLinkFieldsFor: aMapping choosingConstraintsFrom: constraints 	"The join for the mapping doesn't seem to be obvious. See if we can guess what it might be.  Our main guess is that if a link table links two kinds of things of the same class, then it's quite possibly a tree-type relationship, so if the fields are named parent/child, we can infer that the plural attribute is children. And we know this is a plural attribute if we got here."	| sourceTables targetTables possibleLinkFields |	sourceTables := aMapping descriptor tables.	targetTables := aMapping referenceDescriptor tables.	constraints do: [:eachConstraint |		(inflector isChildRelationshipFieldName: eachConstraint sourceFields first name)			ifTrue: [				possibleLinkFields := Array with: eachConstraint targetFields first with:eachConstraint sourceFields first.				possibleLinkFields := possibleLinkFields reject: [:eachField | sourceTables includes: eachField table].				possibleLinkFields := possibleLinkFields reject: [:eachField | targetTables includes: eachField table].				^aMapping linkField: possibleLinkFields first]].</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>descriptor initialization</category><body package="GlorpActiveRecord">mappingNamed: aSymbol do: aBlock	"We want to do the operation in aBlock to a mapping which may not exist yet. Queue it up, noting who the current descriptor was, and then run it after we've done the automatic setup. The typical usage for this is to customize a mapping that we expect to be automatically generated."	deferredDescriptorOperations add: (MessageSend receiver: currentDescriptor selector: #runDeferredOperation:onMapping: arguments: (Array with: aBlock with: aSymbol)).</body><body package="GlorpActiveRecord">runDeferredDescriptorInitializations	"We've finished doing automatic setup, now run the operations we wanted to do after that, both our own, and ones the user explicitly asked for."	descriptors do: [:each | self fixUpMappingsFor: each].	deferredDescriptorOperations do: [:each | each value].	deferredDescriptorOperations := OrderedCollection new.	currentDescriptor := nil.</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>validation</category><body package="GlorpActiveRecord">noDescriptorInitializerFound: aDescriptor	"This is the method called if there is no method to initialize a table. That's ok, we don't require the descriptor to be initialized, though if it was initialized, we'll use the information."	^self</body><body package="GlorpActiveRecord">noTableInitializerFound: aDatabaseTable	"This is the method called if there is no method to initialize a table. That's ok, we don't require the table to be initialized, though if it was initialized, we'll use the information."	^self.</body><body package="GlorpActiveRecord">validateDescriptor: aDescriptor	"Validate aDescriptor in the context of this system, doing any specific validations that need the full environment information or rely on subclass-specific information here."	"Descriptors with not tables are possible in general, especially with placeHolders (see DatabaseIndex in the metadata descriptor system, but with ActiveRecord we don't expect to see that, and it probably indicates a mismatch between names.Create subclass of ValidationError with specific error description and raise it "	aDescriptor tables isEmpty 		ifTrue: [ NoTableFound new					model: aDescriptor describedClass;					expectedTables: (self tableNamesForClass: aDescriptor describedClass);					raiseRequest ].</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>api</category><body package="GlorpActiveRecord">tableNamed: aString	"Return the table object matching the given name. We get all the table information directly from the database."	^self tableNamed: aString ifNone: [NoTableFound new parameter: aString; raiseRequest].</body><body package="GlorpActiveRecord">tableNamed: aString ifNone: aBlock	"Return the table object matching the given name. We get all the table information directly from the database unless the user has specified specific table code - in which case, we want to reflect what the user has specified in -this- descriptor system. The reason for that is we want to use descriptor systems to transform an existing database in to the database described by the descriptor system."	^tables at: aString asString asUppercase		ifAbsent: 			[| newTable databaseTable fromDatabase |			fromDatabase := false.			newTable := self newTableNamed: aString.			databaseTable := self tableNamedFromDatabase: aString.			" Scenario 1: The table defined by the developer is empty and a table exists in the database - use that "			(databaseTable notNil and: [newTable isEmpty])				ifTrue: 					[newTable := databaseTable.					tables at: newTable name asUppercase put: newTable.					self initializeTableExtras: newTable.					fromDatabase := true.					databaseTable := nil].			" Scenario 2: The table defined by the developer is not empty and a table exists in the database - use the database table name and schema but keep the table definition done by the developer "			(databaseTable notNil and: [newTable isEmpty not])				ifTrue: [newTable setSchemaAndNamesCaseFromTable: databaseTable onPlatform: self platform].			" Scenario 3: The table defined by the developer is empty and there is no table in the database - don't record this tables existance "			(fromDatabase not and: [newTable isEmpty])				ifTrue: 					[tables removeKey: aString asUppercase.					^aBlock value].			" Scenario 4: The table defined by the developer is not empty and there is no table in the database, or scenario 1 or 2 qualified "			newTable]</body><body package="GlorpActiveRecord">tableNamedFromMethod: aString ifNone: aBlock	"Return the table object matching the given name. Ignore the database and just use the information from the method. Appropriate if we're planning to create the schema from the methods."	^super tableNamed: aString ifNone: aBlock.</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>initialization</category><body package="GlorpActiveRecord">addTablesFromInitializeMethodsFor: aClass	"Similar to the superclass version, but subtly different - in the ActiveRecordDescriptorSystem, tableFor: methods can be rejected if they are empty or contain no mappings. If that happens, it is not an error, just something we need to ignore."	| match |	match := 'tableFor'. 	Dialect selectorsFor: aClass do:			[:each | 			(each copyFrom: 1 to: (match size min: each size)) = match				ifTrue:					[| tableName |					tableName := each copyFrom: match size + 1 to: each size - 1.					self tableNamed: tableName ifNone: []]].</body><body package="GlorpActiveRecord">constructAllClasses	^super constructAllClasses asSet		addAll: self allActiveRecordClasses;		asOrderedCollection</body><body package="GlorpActiveRecord">constructAllTables	| constraints |	super constructAllTables.	self allClasses		do: [:each | each tableNames do: [:eachName | self tableNamed: eachName]].		"If the descriptor asks for a table, we know we'll need that table. But if it complains about not being able to create joins, because we don't know about the related tables yet, just ignore that. And discard the descriptors afterwards, so they'll get regenerated once we know what all the tables are."	[self allClasses do: [:each | self descriptorFor: each]]		on: CannotAutomaticallyDetermineJoin		do: [:ex | ex return: nil].	self resetDescriptors.	tables isEmpty ifTrue: [^self].	"Iterate over the tables we know about so far, seeing if their constraints tell us about any other tables we ought to care about. Iterate over a copy because we expect that collection to be modified as we go. For the same reason, we don't care about the result, just the side effect."	tables copy		inject: OrderedCollection new		into:			[:sum :each | 			each foreignKeyConstraints				do: [:eachConstraint | sum add: eachConstraint targetTable].			sum].		constraints := self findConstraintsForTables.	constraints do: [:each | self tableNamed: each sourceTable sqlString].	self findSequencesForTables.	^tables.</body><body package="GlorpActiveRecord">initialize	super initialize.	inflector := Inflector new.	deferredDescriptorOperations := OrderedCollection new.	metadataSession isNil ifFalse: [metadataSession reset].</body><body package="GlorpActiveRecord">initializePlatform: dbPlatform	dbPlatform useBinding: (self shouldUseBindingFor: dbPlatform)</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>testing</category><body package="GlorpActiveRecord">shouldUseBindingFor: dbPlatform	^ dbPlatform supportsBinding and: [ (dbPlatform class == PostgreSQLPlatform) not ]</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>callbacks</category><body package="GlorpActiveRecord">joinFor: aMapping toTables: toTables fromConstraints: fromConstraints toConstraints: toConstraints	"Figure out the join for the given mapping, given the list of tables and constraints. First, we using the foreign key constraints. But if those are ambiguous, fall back on the naming conventions."	| fieldName joinTable sourceField possibleTargetFields |	[^super joinFor: aMapping toTables: toTables fromConstraints: fromConstraints toConstraints: toConstraints]		on: CannotAutomaticallyDetermineJoin 		do: [:ex | ex return].		fieldName := self inflector foreignKey: aMapping attributeName.	joinTable := toTables size = 1 		ifTrue: [toTables asArray first] 		ifFalse: [toTables					detect: [:each | each name = self inflector tableize: aMapping describedClass name]					ifNone: [CannotAutomaticallyDetermineJoin new								tables: toTables;								constraints: (toConstraints, fromConstraints);								signal: #CannotAutomaticallyDetermineJoin &lt;&lt; #glorp &gt;&gt; 'Cannot automatically determine join']].	sourceField := aMapping descriptor primaryTable fieldNamed: fieldName ifAbsent: [nil] caseSensitive: false.	possibleTargetFields := joinTable fields select: [:each | each isPrimaryKey].	(sourceField isNil or: [possibleTargetFields size ~= 1]) ifTrue: [		CannotAutomaticallyDetermineJoin new			tables: toTables;			constraints: (toConstraints, fromConstraints);			signal: #CannotAutomaticallyDetermineJoin &lt;&lt; #glorp &gt;&gt; 'Cannot automatically determine join'].	^Join 		from: sourceField		to: possibleTargetFields first.</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem class</class-id> <category>table creation</category><body package="GlorpActiveRecord">createTables	^self createTablesFor: ActiveRecord defaultLogin</body><body package="GlorpActiveRecord">recreateTables	self dropTablesFor: ActiveRecord defaultLogin.	self createTablesFor: ActiveRecord defaultLogin</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordPaginator</class-id> <category>accessing</category><body package="GlorpActiveRecord">objects	^query shallowCopy		offset: pageSize * (self pageIndex - 1);		limit: pageSize;		executeIn: session</body><body package="GlorpActiveRecord">pageCount	^(self size / self pageSize) ceiling</body><body package="GlorpActiveRecord">pageIndex	^ pageIndex min: self pageCount</body><body package="GlorpActiveRecord">pageIndex: anObject	pageIndex := (anObject max: 1) min: self pageCount</body><body package="GlorpActiveRecord">pageSize	^pageSize</body><body package="GlorpActiveRecord">pageSize: anObject	pageSize := anObject</body><body package="GlorpActiveRecord">query	^query</body><body package="GlorpActiveRecord">query: anObject	query := anObject</body><body package="GlorpActiveRecord">size	| countQuery |	countQuery := Query read: query resultClass where: query whereClause.	countQuery retrieve: [:each | each id distinct count].	^ (session execute: countQuery) first</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordPaginator</class-id> <category>initialize-release</category><body package="GlorpActiveRecord">initialize: objectClass session: aSession	session := aSession.	query := Query read: objectClass.	pageIndex := 1.	pageSize := 20</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordPaginator class</class-id> <category>instance creation</category><body package="GlorpActiveRecord">for: objectClass session: aSession	^self new initialize: objectClass session: aSession</body></methods><methods><class-id>Glorp.CannotAutomaticallyMapRelationship</class-id> <category>accessing</category><body package="GlorpActiveRecord">messageText	^#CannotMapVariable1sFromClass2sToClass3s &lt;&lt; #glorp &gt;&gt; 'Cannot map variable &lt;1s&gt; from class &lt;2s&gt; to class &lt;3s&gt;. There is no connecting relation in the database'		expandMacrosWith: variable with: varClassName with: referenceClassName</body><body package="GlorpActiveRecord">referenceClassName	^referenceClassName</body><body package="GlorpActiveRecord">referenceClassName: anObject	referenceClassName := anObject</body><body package="GlorpActiveRecord">varClassName	^varClassName</body><body package="GlorpActiveRecord">varClassName: anObject	varClassName := anObject</body><body package="GlorpActiveRecord">variable	^variable</body><body package="GlorpActiveRecord">variable: anObject	variable := anObject</body></methods><methods><class-id>Glorp.CannotAutomaticallyMapRelationship class</class-id> <category>testing</category><body package="GlorpActiveRecord">mayResume	^true</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord</class-id> <category>accessing</category><body package="GlorpActiveRecord">id	^id.</body><body package="GlorpActiveRecord">id: anInteger	id := anInteger.</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord</class-id> <category>testing</category><body package="GlorpActiveRecord">isInDatabase	^id notNil</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord</class-id> <category>initialize-release</category><body package="GlorpActiveRecord">initialize	" Initialize our collections by default, for convenience "	[self session ifNil: [^self]] on: Error do: [:sig | ^self].	self classModel attributes do: [:each |		each isCollectionAttribute ifTrue: [each setValueIn: self to: each collectionType new]].</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord class</class-id> <category>login-private</category><body package="GlorpActiveRecord">resetAllProcessVariables	"Reset all the information that we keep in per-process variables."	"ActiveRecord resetAllProcessVariables"	self resetSession.	self resetSystem.	self resetLogin.</body><body package="GlorpActiveRecord">resetLogin	^ProcessEnvironment current localRemoveKey: #glorpLogin.</body><body package="GlorpActiveRecord">resetSession	^ProcessEnvironment current localRemoveKey: #glorpSession.</body><body package="GlorpActiveRecord">resetSystem	^ProcessEnvironment current localRemoveKey: #glorpSystem.</body><body package="GlorpActiveRecord">setLogin: aGlorpLogin	"Set the login that this process will use. If it's asked for a session, and doesn't have one, it will use this login information to generate one."	ProcessEnvironment at: #glorpLogin put: aGlorpLogin.</body><body package="GlorpActiveRecord">setSession: aGlorpSession	"Set the session that this process will use."	ProcessEnvironment at: #glorpSession put: aGlorpSession.</body><body package="GlorpActiveRecord">setSystem: aDescriptorSystemClass	"Set the system class that this process will use. If it's asked for a session, and doesn't have one, it will use this login information to generate one. If it doesn't have one, it will use ActiveRecordDescriptorSystem."	| theClass |	theClass := aDescriptorSystemClass isBehavior		ifTrue: [aDescriptorSystemClass]		ifFalse: [aDescriptorSystemClass class].	ProcessEnvironment at: #glorpSystem put: theClass.</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord class</class-id> <category>hints</category><body package="GlorpActiveRecord">tableNames	"Subclasses can override this to list the names of tables that this class needs. The table for the class itself should be picked up automatically, so this is most important for link tables."	^#().</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecord class</class-id> <category>login</category><body package="GlorpActiveRecord">defaultLogin	^DefaultLogin</body><body package="GlorpActiveRecord">defaultLogin: aGlorpLogin	"ActiveRecord defaultLogin: (GlorpDatabaseLoginResource current login)"	DefaultLogin := aGlorpLogin</body><body package="GlorpActiveRecord">defaultSystem	DefaultSystem isNil ifTrue: [DefaultSystem := ActiveRecordDescriptorSystem].	^DefaultSystem.</body><body package="GlorpActiveRecord">defaultSystem: aDescriptorSystemClass	"ActiveRecord defaultSystem: TestActiveRecordDescriptorSystem"	DefaultSystem := aDescriptorSystemClass.</body><body package="GlorpActiveRecord">getLogin	^ProcessEnvironment current at: #glorpLogin ifAbsent: [self defaultLogin].</body><body package="GlorpActiveRecord">getSession	"Get the session to use for these objects. This may have to have been set somewhere previously, either by Seaside having put it in a dynamic variable or by someone putting it in the process environment. If they haven't, but we can find a login and a descriptor system to use, we will create a session and register it in the process environment."	| seasideSessionClass seasideSession theEnvironment |	seasideSessionClass := Smalltalk at: #'Seaside.WACurrentSession' ifAbsent: [nil].	seasideSession := seasideSessionClass isNil ifFalse: [seasideSessionClass value].	seasideSession isNil ifFalse: [([seasideSession databaseSession] on: MessageNotUnderstood do: [:ex | nil]) isNil ifFalse: [^seasideSession databaseSession]].	theEnvironment := ProcessEnvironment current.	^theEnvironment at: #glorpSession ifAbsent: [		theEnvironment at: #glorpSession put: (self getSystem sessionForLogin: self getLogin)].</body><body package="GlorpActiveRecord">getSystem	^ProcessEnvironment current at: #glorpSystem ifAbsent: [self defaultSystem].</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>creating mappings</category><body package="GlorpActiveRecord">mappingNamed: aSymbol do: aBlock	"We want to do the operation in aBlock to a mapping which may not exist yet. Queue it up, noting who the current descriptor was, and then run it after we've done the automatic setup. The typical usage for this is to customize a mapping that we expect to be automatically generated."	system deferredDescriptorOperations add: (MessageSend receiver: self selector: #runDeferredOperation:onMapping: arguments: (Array with: aBlock with: aSymbol)).</body><body package="GlorpActiveRecord">runDeferredOperation: aBlock onMapping: aSymbol		| mapping |	mapping := self mappingForAttributeNamed: aSymbol.	mapping isNil 		ifTrue: [self error: 'No mapping found for ', self classModel printString, '&gt;&gt;', aSymbol]		ifFalse: [aBlock value: mapping].</body></methods><methods><class-id>Core.String</class-id> <category>regular expressions</category><body package="GlorpActiveRecord">replaceRegex: regularExpressionString withString: stringOrBlock	"This vaguely emulates the Ruby gsub method, which takes a regular expression as input and returns a substituted version. It also allows \0, \1, \2 etc in the substituting string as references to subexpression 1, 2 etc. in the original matcher. Note the fun off-by-one-ness, resulting from translating the Ruby API directly. If we are given a block, it can take either one argument (the match) or two (the match + the matcher)."	^self replaceRegex: regularExpressionString withString: stringOrBlock ifMatchedDo: [:result | result].</body><body package="GlorpActiveRecord">replaceRegex: regularExpressionString withString: stringOrBlock ifMatchedDo: matchBlock	"This vaguely emulates the Ruby gsub method, which takes a regular expression as input and returns a substituted version. It also allows \0, \1, \2 etc in the substituting string as references to subexpression 1, 2 etc. in the original matcher. Note the fun off-by-one-ness, resulting from translating the Ruby API directly. If we are given a block, it can take either one argument (the match) or two (the match + the matcher). The matchBlock lets us evaluate a block if a match is found."	| matcher block matched result |	matcher := regularExpressionString asRegex.	matched := false.	block := stringOrBlock isString		ifTrue: [[:each | 			'\\\d+' asRegex 				copy: stringOrBlock 				translatingMatchesUsing: [:match |  | theMatch |					theMatch := matcher subexpression: (match copyFrom: 2 to: match size) asNumber + 1.					theMatch]]]		ifFalse: [stringOrBlock].	result := matcher copy: self translatingMatchesUsing: [:match | 		matched := true.		block numArgs = 1 			ifTrue: [block value: match]			ifFalse: [block value: match value: matcher]].	matched ifTrue: [^matchBlock value: result] ifFalse: [^result]</body></methods><methods><class-id>RxMatcher</class-id> <category>converting</category><body package="GlorpActiveRecord">asRegex	^self.</body><body package="GlorpActiveRecord">asRegexIgnoringCase	^self.</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>hints</category><body package="GlorpActiveRecord">hasAndBelongsToMany	"Return a collection of symbols for the relationships this object has that are to-many relations connected with a link table. Subclasses should override.  (This method is only used by ActiveRecord subclasses in the basic ActiveRecord pattern, but we implement it here, on ActiveRecord's superclass, so tools can check it more generally.)"	^#()</body><body package="GlorpActiveRecord">hasMany	"Return a collection of symbols for the relationships this object has that are to-many relations. Subclasses should override.  (This method is only used by ActiveRecord subclasses in the basic ActiveRecord pattern, but we implement it here, on ActiveRecord's superclass, so tools can check it more generally.)"	^#()</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PersistentObject</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpCore</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>RxMatcher</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>matcher ignoreCase startOptimizer stream markerPositions markerCount lastResult lastChar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>VB-Regex</category><attributes><package>Regex11</package></attributes></class><class><name>ValidationError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Descriptor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tables mappings system mappedFields cachePolicy typeResolver mapsPrimaryKeys keyFields classModel multipleTableJoin imaginaryTableReplacements mappingsForFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class></st-source>