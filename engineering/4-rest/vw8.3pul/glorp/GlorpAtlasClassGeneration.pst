<?xml version="1.0"?><st-source><!-- Name: GlorpAtlasClassGenerationNotice: Copyright 2013-2015 Cincom Systems, Inc.  All rights reserved.Comment: Load and use this programmatic utility in VisualWorks only, not in ObjectStudio.  (ObjectStudio's modelling and mapping tools provide a UI on a more powerful version of the same capability.)This extends the GlorpActiveRecord utilities.  Like ActiveRecord, it automatically reads the schema to create a descriptor system that maps between them, but it can read from schemas that do not adhere to the ActiveRecord pattern, and it can generate classes that match the tables.  The API is:	GlorpMetaProcess		fromTablesIn: aLogin		schema: aSchemaNameString		generateClassesIn: anExistingNameSpaceName		packageName: aNewOrExistingPackageName		descriptorSystemClass: aNewOrExistingClassName.This method returns the generated system.  It checks the supplied schema name against the list returned by	session := MetadataDescriptorSystem forLogin: aLogin.	session login.	session platform readSchemasForSession: session.and throws an error if it cannot find a match.  If it cannot creating a mapping for a relationship, it writes to the Transcript.DbIdentifier: bear73DbTrace: 468409DbUsername: nrossDbVersion: 8.1 - 4DevelopmentPrerequisites: #(#(#any 'GlorpAtlasSystemGeneration' ''))PackageName: GlorpAtlasClassGenerationParcel: #('GlorpAtlasClassGeneration')ParcelName: GlorpAtlasClassGenerationPrerequisiteDescriptions: #(#(#name 'GlorpAtlasSystemGeneration' #componentType #package))PrerequisiteParcels: #(#('GlorpAtlasSystemGeneration' ''))PrintStringCache: (8.1 - 4,nross)Version: 8.1 - 4Date: 12:56:08 PM February 5, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (feb16.1) of February 5, 2016 on February 5, 2016 at 12:56:08 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GlorpMetaProcess</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inflector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><comment><class-id>Glorp.GlorpMetaProcess</class-id><body>GlorpMetaProcess holds the ActiveRecord inflector and the API for meta-data creation methods that can act on non-ActiveRecord-compliant schemas.Instance Variables	descriptorSystem	the system into which the meta-data from the schema will be read	inflector	&lt;Inflector&gt;	the inflector applies the ActiveRecord pattern to guess class names</body></comment><class><name>ClassModelHelper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className variables namespace </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><comment><class-id>Glorp.ClassModelHelper</class-id><body>ClassModelHelper manages the creation of a class from data (usually obtained from a database table).Instance Variables:	className	&lt;String&gt;	the simple name of the class we will generate	namespace	&lt;String&gt;	the fulleName of the NameSpace in which the class will be created	variables		&lt;Collection(ClassModelVariableHelper)&gt;	defines the instVars the class will be given</body></comment><class><name>ClassBuilderHelper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system dictionary package </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><comment><class-id>Glorp.ClassBuilderHelper</class-id><body>ClassBuilderHelper holds a data (usually read from database tables) that can guide creation of classes (usually, one class per table).Instance Variables:	dictionary	&lt;IdentityDictionary(String-&gt;ClassModelHelper)&gt;	the class names and their class models	package	&lt;PackageModel&gt;		create classes in this package	system	&lt;DescriptorSystem&gt;		system whose tables guides the creation of these classes</body></comment><class><name>MappingHelper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field attribute usedClass descriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><comment><class-id>Glorp.MappingHelper</class-id><body>Instance Variables	atlas	&lt;Object&gt; undocumented	field	&lt;Object&gt; undocumented	class	&lt;Object&gt; undocumented	attribute	&lt;Object&gt; undocumented	usedClass	&lt;Object&gt; undocumented	descriptor	&lt;Object&gt; undocumented</body></comment><class><name>ClassModelVariableHelper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type collection field reverseJoin ownedClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><comment><class-id>Glorp.ClassModelVariableHelper</class-id><body>Instance Variables:	name	&lt;Object&gt; undocumented	type		&lt;Object&gt; undocumented	collection	&lt;RelationshipMapping class&gt; a concrete to-one or to-many subclass </body></comment><class><name>RelationshipMappingHelper</name><environment>Glorp</environment><super>Glorp.MappingHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><class><name>DirectMappingHelper</name><environment>Glorp</environment><super>Glorp.MappingHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><class><name>OneToOneMappingHelper</name><environment>Glorp</environment><super>Glorp.RelationshipMappingHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><class><name>ToManyMappingHelper</name><environment>Glorp</environment><super>Glorp.RelationshipMappingHelper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasClassGeneration</package></attributes></class><methods><class-id>Glorp.GlorpMetaProcess</class-id> <category>create class</category><body package="GlorpAtlasClassGeneration">addFieldsFromTable: aTable name: aName classModelHelper: classModelHelper dictionary: dictionary	| myVariable |	aTable fields do: 			[:aField |			| smalltalkType |			smalltalkType := aField foreignKeyConstraints isEmpty						ifTrue: [aField impliedSmalltalkType]						ifFalse: 							[inflector classify: aField foreignKeyConstraints first targetTable name].			classModelHelper addVariable: (myVariable := ClassModelVariableHelper								name: (inflector instVarize: aField name)								type: smalltalkType								field: aField).			myVariable ownedClass: classModelHelper.			aField foreignKeyConstraints isEmpty				ifFalse: 					[self						addReversRelation: aField						name: aName						type: smalltalkType						to: dictionary						reverse: myVariable]]</body><body package="GlorpAtlasClassGeneration">addReversRelation: aField name: aName type: smalltalkType to: dictionary reverse: aVariableHelper	| tempHelper revVariableHelper |	tempHelper := dictionary at: smalltalkType asSymbol				ifAbsentPut: 					[| helper |					helper := ClassModelHelper new.					helper className: smalltalkType.					helper].	revVariableHelper := ClassModelVariableHelper				name: (inflector instVarize: aField table name , '_' , aField name)				type: aName				field: aField				collection: OneToManyMapping.	revVariableHelper ownedClass: tempHelper.	revVariableHelper reverseJoin: aVariableHelper.	aVariableHelper reverseJoin: revVariableHelper.	^tempHelper addVariable: revVariableHelper</body><body package="GlorpAtlasClassGeneration">defineUsedClassesAndVariablesForTables: someTables in: aNamespaceString	"Return a ClassBuilder with the data it needs to generate classes from the tables, and a descriptor system connecting the two."	| dictionary |	dictionary := IdentityDictionary new.	someTables do: 			[:aTable |			| aName classModelHelper |			aName := inflector classify: aTable name.			classModelHelper := ClassModelHelper new.			classModelHelper				namespace: aNamespaceString;				className: aName.			self				addFieldsFromTable: aTable				name: aName				classModelHelper: classModelHelper				dictionary: dictionary.			dictionary at: aName asSymbol put: classModelHelper].	^ClassBuilderHelper new		dictionary: dictionary;		yourself</body></methods><methods><class-id>Glorp.GlorpMetaProcess</class-id> <category>initialize-release</category><body package="GlorpAtlasClassGeneration">initialize	inflector := Inflector new.</body></methods><methods><class-id>Glorp.GlorpMetaProcess</class-id> <category>accessing</category><body package="GlorpAtlasClassGeneration">inflector	^inflector</body><body package="GlorpAtlasClassGeneration">inflector: anObject	inflector := anObject</body></methods><methods><class-id>Glorp.GlorpMetaProcess class</class-id> <category>instance creation</category><body package="GlorpAtlasClassGeneration">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpMetaProcess class</class-id> <category>class creation</category><body package="GlorpAtlasClassGeneration">fromTablesIn: aLogin schema: aSchemaString generateClassesIn: aNamespaceString packageName: aPackageName descriptorSystemClass: dsClassPrefix	| system tables classBuilderHelper |	system := (Glorp.ActiveRecords.ActiveRecordDescriptorSystem sessionForLogin: aLogin) system.	(aLogin database supportsSchemas not or:		[(aLogin database readSchemasForSession: system metadataSession) includes: aSchemaString])			ifFalse: [self error: 'This database does not contain a schema of this name'].	tables := aLogin database getTablesForSchema: aSchemaString				forSession: system metadataSession.	classBuilderHelper := (self new				defineUsedClassesAndVariablesForTables: tables				in: aNamespaceString)				system: system;				package: (Store.Registry packageNamedOrCreate: aPackageName);				yourself.	"Generate the actual classes"	classBuilderHelper generateClassesFromTablesIntoPackage.	"Generate the descriptor system"	classBuilderHelper generateClassModelsFromTables.	[classBuilderHelper createMappingsForActiveRecord]		on: CannotAutomaticallyMapRelationship		do: [:ex |	"We want to log our failures somewhere"			Transcript cr; show: ex description.			ex resume].	"later, replace with logging"	"Generate the AR descriptor system subclass"	WriteAtlasHelper system: system.	system		writeAtlas: dsClassPrefix		in: aNamespaceString asQualifiedReference value		package: aPackageName.	WriteAtlasHelper system: nil.	^system</body></methods><methods><class-id>Glorp.ClassModelHelper</class-id> <category>accessing</category><body package="GlorpAtlasClassGeneration">addVariable: aClassModelVariableHelper	self variables add: aClassModelVariableHelper</body><body package="GlorpAtlasClassGeneration">className	^className</body><body package="GlorpAtlasClassGeneration">className: aString	"The simple name of the class to be created."	className := aString</body><body package="GlorpAtlasClassGeneration">implementedClass	^self printNamespaceClass asQualifiedReference value</body><body package="GlorpAtlasClassGeneration">namespace	^namespace</body><body package="GlorpAtlasClassGeneration">namespace: aString	"The fullName of the NameSpace in which the class is to be created."	namespace := aString</body><body package="GlorpAtlasClassGeneration">printNamespaceClass	^self namespace , '.' , self className</body><body package="GlorpAtlasClassGeneration">qualifiedReference	^((self namespace isNil or: [self namespace isEmpty])		ifTrue: ['Smalltalk.ObjectStudio']		ifFalse: [self namespace]) asQualifiedReference		value</body><body package="GlorpAtlasClassGeneration">variables	^variables</body><body package="GlorpAtlasClassGeneration">variables: someStrings	variables := someStrings.</body></methods><methods><class-id>Glorp.ClassModelHelper</class-id> <category>methods</category><body package="GlorpAtlasClassGeneration">qualifiedReferenceString	^self qualifiedReference fullName , '.'</body></methods><methods><class-id>Glorp.ClassModelHelper</class-id> <category>initialize-release</category><body package="GlorpAtlasClassGeneration">initialize	className := nil.	variables := OrderedCollection new.	namespace := ''.</body></methods><methods><class-id>Glorp.ClassModelHelper class</class-id> <category>instance creation</category><body package="GlorpAtlasClassGeneration">new	^(super new) initialize</body></methods><methods><class-id>Glorp.ClassBuilderHelper</class-id> <category>code generation</category><body package="GlorpAtlasClassGeneration">createMappingsForActiveRecord	self classHelperList do:		[:aClassHelper || aDescriptor theClass |		theClass := (aClassHelper qualifiedReferenceString, aClassHelper className)				asQualifiedReference value.		aDescriptor := self system descriptorFor: theClass.		aClassHelper variables do:			[:aVariable | aVariable addMappingToDescriptor: aDescriptor]].</body><body package="GlorpAtlasClassGeneration">generateClassModelsFromTables	^self classHelperList collect:		[:classHelper |		self system addClassModel:			(self autoCreateClassModelForTable: classHelper)]</body><body package="GlorpAtlasClassGeneration">generateClassesFromTables	^self system allClasses:		(self classHelperList collect:			[:classModelHelper || cls |			cls := self createClassFor: classModelHelper.			self createAccessorsForClass: cls.			cls])</body><body package="GlorpAtlasClassGeneration">generateClassesFromTablesIntoPackage	^Store.Policies packagePolicy		forcePackage: self package		while: [self generateClassesFromTables]</body></methods><methods><class-id>Glorp.ClassBuilderHelper</class-id> <category>accessing</category><body package="GlorpAtlasClassGeneration">classHelperList	^self dictionary values</body><body package="GlorpAtlasClassGeneration">dictionary	^dictionary</body><body package="GlorpAtlasClassGeneration">dictionary: anIdentityDictionary	dictionary := anIdentityDictionary.</body><body package="GlorpAtlasClassGeneration">getClass: aClassName	^self dictionary at: aClassName asSymbol</body><body package="GlorpAtlasClassGeneration">getVariable: aVarName class: aClassname	^(self getClass: aClassname) variables detect: [:each | each name = aVarName] ifNone: [nil]</body><body package="GlorpAtlasClassGeneration">package	^package</body><body package="GlorpAtlasClassGeneration">package: anObject	package := anObject</body><body package="GlorpAtlasClassGeneration">system	^system</body><body package="GlorpAtlasClassGeneration">system: aDescriptorSystem	system := aDescriptorSystem</body></methods><methods><class-id>Glorp.ClassBuilderHelper</class-id> <category>create class</category><body package="GlorpAtlasClassGeneration">createAccessorsForClass: cls		cls instVarNames		do:			[:each | 			cls				compile: ('&lt;1s&gt;&lt;n&gt;&lt;t&gt;^&lt;1s&gt;' expandMacrosWith: each)					classified: #accessing;				compile:						('&lt;1s&gt;: anObject&lt;n&gt;&lt;t&gt;&lt;1s&gt; := anObject' expandMacrosWith: each)					classified: #accessing]</body><body package="GlorpAtlasClassGeneration">createClassFor: classModelHelper	| strm |	strm := WriteStream on: String new.	classModelHelper variables do:		[:aVariable |		strm nextPutAll: aVariable variableNameForGeneratedClass; space].	^classModelHelper qualifiedReference		defineClass: classModelHelper className asSymbol		superclass: #{Glorp.PersistentObject}		indexedType: #none		private: false		instanceVariableNames: strm contents		classInstanceVariableNames: String new		imports: String new		category: String new</body></methods><methods><class-id>Glorp.ClassBuilderHelper</class-id> <category>metaprocess</category><body package="GlorpAtlasClassGeneration">autoCreateClassModelForTable: classModelHelper	| aClassModel |	aClassModel := GlorpClassModel for:		(classModelHelper qualifiedReferenceString, classModelHelper className) asQualifiedReference value.	classModelHelper variables do:		[:aVariable || smalltalkType |		smalltalkType := aVariable isString			ifTrue: [(classModelHelper qualifiedReferenceString, aVariable type) asQualifiedReference value]			ifFalse: [aVariable type].		aVariable collection			ifTrue: [aClassModel					newAttributeNamed: aVariable variableNameForGeneratedClass					collectionOf: smalltalkType]			ifFalse: [aClassModel					newAttributeNamed: aVariable variableNameForGeneratedClass					type: smalltalkType]].	^aClassModel</body></methods><methods><class-id>Glorp.MappingHelper</class-id> <category>initialize-release</category><body package="GlorpAtlasClassGeneration">initialize	field := nil.	usedClass := nil.	attribute := nil.</body></methods><methods><class-id>Glorp.MappingHelper</class-id> <category>remove mapping</category><body package="GlorpAtlasClassGeneration">removeAllMappingsForField	self field ifNotNil:		[([descriptor allMappingsForField: self field]			on: Error do: [ :err | ^self])				do: [:aMapping |					descriptor removeMapping: aMapping.					descriptor tables]]</body><body package="GlorpAtlasClassGeneration">removeExistingMappings	self removeAllMappingsForField.	self removeMappingForAttribute</body><body package="GlorpAtlasClassGeneration">removeMappingForAttribute	| aMapping |	aMapping := descriptor mappingForAttributeNamed: self attribute.	aMapping ifNotNil: [descriptor removeMapping: aMapping]</body></methods><methods><class-id>Glorp.MappingHelper</class-id> <category>accessing</category><body package="GlorpAtlasClassGeneration">attribute	^attribute</body><body package="GlorpAtlasClassGeneration">attribute: anObject	attribute := anObject</body><body package="GlorpAtlasClassGeneration">descriptor	^descriptor</body><body package="GlorpAtlasClassGeneration">descriptor: anObject	descriptor := anObject</body><body package="GlorpAtlasClassGeneration">descriptorSystem	^self descriptor system</body><body package="GlorpAtlasClassGeneration">field	^field</body><body package="GlorpAtlasClassGeneration">field: anObject	field := anObject</body><body package="GlorpAtlasClassGeneration">usedClass	usedClass ifNil: [usedClass := self attribute classModel describedClass].	^usedClass</body><body package="GlorpAtlasClassGeneration">usedClass: anObject	usedClass := anObject</body></methods><methods><class-id>Glorp.MappingHelper</class-id> <category>mapping</category><body package="GlorpAtlasClassGeneration">createMapping	self subclassResponsibility</body><body package="GlorpAtlasClassGeneration">createMappingForAttributeName: attributeName	attribute := descriptor classModel attributeNamed: attributeName.	^self createMappings</body><body package="GlorpAtlasClassGeneration">createMappings	self getDescriptor.	self removeExistingMappings.	self customMappings.	self addTablesToDescriptor</body><body package="GlorpAtlasClassGeneration">customMappings	^self subclassResponsibility</body><body package="GlorpAtlasClassGeneration">getDescriptor	descriptor ifNil: [descriptor := self system descriptorFor: self usedClass]</body><body package="GlorpAtlasClassGeneration">newMapping	^descriptor newMapping: self mappingClass</body></methods><methods><class-id>Glorp.MappingHelper</class-id> <category>add tables</category><body package="GlorpAtlasClassGeneration">addTablesToDescriptor	self field		ifNotNil: 			[self field table				ifNotNil: 					[:table |					(descriptor tables detect: [:each | each name = table name] ifNone: [nil])						ifNil: [descriptor table: table]]]</body></methods><methods><class-id>Glorp.MappingHelper</class-id> <category>constants</category><body package="GlorpAtlasClassGeneration">mappingClass	^self subclassResponsibility</body></methods><methods><class-id>Glorp.MappingHelper class</class-id> <category>instance creation</category><body package="GlorpAtlasClassGeneration">createForAtlas: anAtlas attribute: anAttribute field: aField type: aString	^self createForAtlas: anAtlas attribute: anAttribute field: aField useLinkTable: false type: aString</body><body package="GlorpAtlasClassGeneration">createForDescriptor: aDescriptor attributeName: attributeName field: aField type: aString	| mapClass |	mapClass := self allSubclasses detect: [ :each | each type = aString] ifNone: [self].	^mapClass createForDescriptor: aDescriptor attributeName: attributeName field: aField</body><body package="GlorpAtlasClassGeneration">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.MappingHelper class</class-id> <category>start process</category><body package="GlorpAtlasClassGeneration">createForDescriptor: aDescriptor attributeName: attributeName field: aField	^(self new)		field: aField;		descriptor: aDescriptor;		createMappingForAttributeName: attributeName</body></methods><methods><class-id>Glorp.ClassModelVariableHelper</class-id> <category>accessing</category><body package="GlorpAtlasClassGeneration">collection	^collection superclass == ToManyMapping</body><body package="GlorpAtlasClassGeneration">collection: aRelationshipMappingSubclass	collection := aRelationshipMappingSubclass.</body><body package="GlorpAtlasClassGeneration">field	^field</body><body package="GlorpAtlasClassGeneration">field: anObject	field := anObject</body><body package="GlorpAtlasClassGeneration">name	^name</body><body package="GlorpAtlasClassGeneration">name: anObject	name := anObject</body><body package="GlorpAtlasClassGeneration">ownedClass	^ownedClass</body><body package="GlorpAtlasClassGeneration">ownedClass: anObject	ownedClass := anObject</body><body package="GlorpAtlasClassGeneration">reverseJoin	^reverseJoin</body><body package="GlorpAtlasClassGeneration">reverseJoin: anObject	reverseJoin := anObject</body><body package="GlorpAtlasClassGeneration">type	^type</body><body package="GlorpAtlasClassGeneration">type: anObject	type := anObject</body></methods><methods><class-id>Glorp.ClassModelVariableHelper</class-id> <category>os-printing</category><body package="GlorpAtlasClassGeneration">print	| aStream |	aStream := WriteStream on: String new.	aStream nextPutAll: (self name ifNil: ['']);		nextPut: $-;		nextPutAll:(self type ifNil: [''] ifNotNil: [self isString ifTrue: [self type] ifFalse: [self type name]]);		nextPut: $-;		nextPutAll: (self collection ifTrue: ['Collection'] ifFalse: ['']).	^aStream contents.</body><body package="GlorpAtlasClassGeneration">printOn: aStream	aStream nextPutAll: (self name ifNil: ['']);		nextPut: $-;		nextPutAll:(self type ifNil: [''] ifNotNil: [self isString ifTrue: [self type] ifFalse: [self type name]]);		nextPut: $-;		nextPutAll: (self collection ifTrue: ['Collection'] ifFalse: ['']).</body></methods><methods><class-id>Glorp.ClassModelVariableHelper</class-id> <category>testing</category><body package="GlorpAtlasClassGeneration">isMapped	^self field notNil</body><body package="GlorpAtlasClassGeneration">isString	^self type isString</body></methods><methods><class-id>Glorp.ClassModelVariableHelper</class-id> <category>descriptor</category><body package="GlorpAtlasClassGeneration">addDirectMappingTo: aDescriptor	MappingHelper		createForDescriptor: aDescriptor		attributeName: self name asSymbol		field: self field		type: 'DirectMapping'</body><body package="GlorpAtlasClassGeneration">addMappingToDescriptor: aDescriptor	aDescriptor tables isEmpty ifTrue: [aDescriptor addTable: self field table].	self removeMappingFrom: aDescriptor.	self isString 		ifTrue: [self addRelationshipMappingTo: aDescriptor]		ifFalse: [self addDirectMappingTo: aDescriptor]</body><body package="GlorpAtlasClassGeneration">addRelationshipMappingTo: aDescriptor	"This refactored copy of #addAutomaticMappingForRelationship:in: is mainly for use when our intended final target is not an ActiveRecord descriptor system.  However the current system of the parameter will be an ActiveRecordDescriptorSystem, thus we can call #tryToSetLinkFieldsFor:choosingConstraintsFrom: on it."	| mappingClass targetTable |	mappingClass := self selectMappingType.	targetTable := self determineTargetField table.	(self hasMultipleReferencesForTable: targetTable)		ifTrue: [(aDescriptor newMapping: mappingClass)				attributeName: self variableNameForGeneratedClass asSymbol;				join: (self createJoinForDescriptorMapping: aDescriptor)]		ifFalse:			[| mapping |			mapping := (aDescriptor newMapping: mappingClass)				attributeName: self variableNameForGeneratedClass asSymbol;				yourself.			[mapping join]				on: CannotAutomaticallyDetermineJoin				do: [:ex | ex constraints isEmpty					ifTrue: [aDescriptor removeMapping: mapping.							CannotAutomaticallyMapRelationship new								model: aDescriptor describedClass;								varClassName: aDescriptor describedClass name;								variable: mapping attributeName;								referenceClassName: mapping referenceClass name;								parameter: ex constraints;								signal]					ifFalse: [aDescriptor system tryToSetLinkFieldsFor: mapping choosingConstraintsFrom: ex constraints]]].</body><body package="GlorpAtlasClassGeneration">createJoinForDescriptorMapping: aDescriptor	"Get the order right:  from the descriptor's table, not to it."	| fkc sourceFields targetFields |	fkc := self field foreignKeyConstraints first. 	sourceFields := fkc sourceFields.	targetFields := fkc targetFields.	(sourceFields allSatisfy: [:each | aDescriptor tables includes: each table]) ifFalse:		[sourceFields := fkc targetFields.		targetFields := fkc sourceFields].	^Join fromAll: sourceFields toAll: targetFields</body><body package="GlorpAtlasClassGeneration">determineSourceField	^self field foreignKeyConstraints first sourceFields first</body><body package="GlorpAtlasClassGeneration">determineTargetField	^self field foreignKeyConstraints first targetFields first</body><body package="GlorpAtlasClassGeneration">hasMultipleReferencesForTable: aTable	| dict |	dict := IdentityDictionary new.	self field table foreignKeyConstraints do: 			[:aConstraint |			aConstraint targetFields do: 					[:aField |					dict at: aField table ifAbsentPut: [0].					dict at: aField table put: (dict at: aField table) + 1]].	^(dict at: aTable) &gt; 1</body><body package="GlorpAtlasClassGeneration">removeMappingFrom: aDescriptor	| aMapping hlpName |	hlpName := self variableNameForGeneratedClass.	aMapping := aDescriptor mappingForAttributeNamed: hlpName asSymbol.	aDescriptor removeMapping: aMapping</body><body package="GlorpAtlasClassGeneration">selectMappingType	^collection</body><body package="GlorpAtlasClassGeneration">variableNameForGeneratedClass	"The name we will use to create an instVar in our generated class, and, asSymbol, in our Glorp ClassModel or Descriptor."	^self isString		ifFalse: [self name]		ifTrue: [collection == ManyToManyMapping				ifTrue: [self name]				ifFalse: [self name , 'Child']]</body></methods><methods><class-id>Glorp.ClassModelVariableHelper class</class-id> <category>instance creation</category><body package="GlorpAtlasClassGeneration">name: aName type: aType field: aField	^self		name: aName		type: aType		field: aField		collection: OneToOneMapping	"For now, we ignore the fact that the last line should (technically) be		collection: (name isString ifTrue: [OneToOneMapping] ifFalse: [DirectMapping])	as the value of collection is not used at the moment in the case of a DirectMapping."</body><body package="GlorpAtlasClassGeneration">name: aName type: aType field: aField collection: aRelationshipMappingSubclass	^self new		name: aName;		type: aType;		field: aField;		collection: aRelationshipMappingSubclass;		yourself</body></methods><methods><class-id>Glorp.RelationshipMappingHelper</class-id> <category>constants</category><body package="GlorpAtlasClassGeneration">mappingClass	^OneToOneMapping</body></methods><methods><class-id>Glorp.RelationshipMappingHelper</class-id> <category>mapping</category><body package="GlorpAtlasClassGeneration">customMappings	self newMapping attributeName: self attribute name.	self descriptorSystem isActiveRecord ifTrue: 		[self descriptorSystem			referenceClassForField: self field			from: self descriptor].</body></methods><methods><class-id>Glorp.RelationshipMappingHelper class</class-id> <category>type</category><body package="GlorpAtlasClassGeneration">type	^'NotDone'</body></methods><methods><class-id>Glorp.DirectMappingHelper</class-id> <category>constants</category><body package="GlorpAtlasClassGeneration">mappingClass	^DirectMapping</body></methods><methods><class-id>Glorp.DirectMappingHelper</class-id> <category>mapping</category><body package="GlorpAtlasClassGeneration">createMapping	self subclassResponsibility</body><body package="GlorpAtlasClassGeneration">customMappings	self newMapping from: self attribute name to: self field</body></methods><methods><class-id>Glorp.DirectMappingHelper class</class-id> <category>type</category><body package="GlorpAtlasClassGeneration">type	^'DirectMapping'</body></methods><methods><class-id>Glorp.OneToOneMappingHelper</class-id> <category>constants</category><body package="GlorpAtlasClassGeneration">mappingClass	^OneToOneMapping</body></methods><methods><class-id>Glorp.OneToOneMappingHelper class</class-id> <category>type</category><body package="GlorpAtlasClassGeneration">type	^'OneToOneMapping'</body></methods><methods><class-id>Glorp.ToManyMappingHelper</class-id> <category>constants</category><body package="GlorpAtlasClassGeneration">mappingClass	^ToManyMapping</body></methods><methods><class-id>Glorp.ToManyMappingHelper class</class-id> <category>type</category><body package="GlorpAtlasClassGeneration">type	^'ToManyMapping'</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>class defaults</category><body package="GlorpAtlasClassGeneration">domainSuperclassRoot	^PersistentObject</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>api</category><body package="GlorpAtlasClassGeneration">addClassModel: aClassModel	"Return the parameter, now ensured to be known to the system and its descriptor, which is ensured to exist."	| aDescriptor |	aClassModel system: self.	classModels at: aClassModel describedClass put: aClassModel.	aDescriptor := descriptors		at: aClassModel describedClass		ifAbsentPut:			[| newDescriptor | newDescriptor := Descriptor new.			newDescriptor system: self.			newDescriptor].	aDescriptor classModel: aClassModel.	^aClassModel</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>accessing</category><body package="GlorpAtlasClassGeneration">allClasses: aCollection	^allClasses := aCollection</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>testing</category><body package="GlorpAtlasClassGeneration">isActiveRecord	^false</body><body package="GlorpAtlasClassGeneration">isLinkTable: aTable	"Should this table have a descriptor, class model and domain class, or is it just a linkTable other tables? a table with no primary key, only two fields and both of them foreign-key-constrained sure looks like a link table to me."	^aTable hasPrimaryKeyConstraints not		and: [aTable fields size = 2			and: [aTable foreignKeyFields size = 2 "or we could use = aTable fields size"]]</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>accessing</category><body package="GlorpAtlasClassGeneration">getTablesForSchema: aSchema forSession: aSession	| query |	query := Query read: aSession system databaseTable.	^query executeIn: aSession</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem class</class-id> <category>class defaults</category><body package="GlorpAtlasClassGeneration">domainSuperclassRoot	^ActiveRecord</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>testing</category><body package="GlorpAtlasClassGeneration">isActiveRecord	^true</body><body package="GlorpAtlasClassGeneration">isLinkTable: aTable	"Should this table have a descriptor, class model and domain class, or is it just a linkTable other tables?  For ActiveRecord pattern, not having an ID field is a sure sign of not corresponding to a domain class."	^(super isLinkTable: aTable)		and: [aTable fieldNamed: 'id' ifAbsent: [^true] caseSensitive: false.			false]</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>accessing</category><body package="GlorpAtlasClassGeneration">getTablesForSchema: aSchema forSession: aSession	| query |	query := Query		read: aSession system databaseTable		where: [:each | each schema = aSchema].	^query executeIn: aSession</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>atlas</category><body package="GlorpAtlasClassGeneration">readSchemasForSession: aSession	"Should not be called if supportsSchemas is false."	| query |	query := Query read: aSession system databaseTable.	query retrieve: [:each | each schema distinct].	^query executeIn: aSession</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DatabasePlatform</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types converters useBinding reservedWords functions characterEncoding </inst-vars><class-inst-vars>converterRepository </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>SQLite3Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>ActiveRecordDescriptorSystem</name><environment>Glorp.ActiveRecords</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metadataSession inflector currentDescriptor deferredDescriptorOperations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class></st-source>