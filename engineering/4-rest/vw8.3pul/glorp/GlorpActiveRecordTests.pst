<?xml version="1.0"?><st-source><!-- Name: GlorpActiveRecordTestsNotice: Copyright 2006-2012 Alan Knight.Portions © 2012-2014 Cincom Systems, Inc.  All rights reserved.These tests are made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This holds tests for the GlorpActiveRecord package.DbIdentifier: bear73DbTrace: 502562DbUsername: nrossDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'GlorpActiveRecord' '') #(#any 'GlorpTest' ''))ExplicitPrerequisites: #('SUnit')IgnoredPrerequisites: #('SUnit-Bridge2SU2')PackageName: GlorpActiveRecordTestsParcel: #('GlorpActiveRecordTests')ParcelName: GlorpActiveRecordTestsPrerequisiteParcels: #(#('GlorpActiveRecord' '') #('GlorpTest' ''))PrintStringCache: (8.3 - 1,nross)Version: 8.3 - 1Date: 11:29:17 AM June 16, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:29:17 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>GlorpActiveRecordTests</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private Glorp.*			private Glorp.ActiveRecords.*			</imports><category></category><attributes><package>GlorpActiveRecordTests</package></attributes></name-space><class><name>TestActiveRecordDescriptorSystem</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>TreeNode</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>treeNodes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>BankTransaction</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner amount serviceCharge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>Person</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name address </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>BankAccount</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bankAccountNumber customers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>ActiveRecordTest</name><environment>GlorpActiveRecordTests</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>ActiveRecordNewSessionTest</name><environment>GlorpActiveRecordTests</environment><super>GlorpActiveRecordTests.ActiveRecordTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.ActiveRecordNewSessionTest</class-id><body>I reset the session test resource in setUp to ensure that each of my tests runs in a new session.  I have all and only the tests that require this, my superclass having all the tests that are valid in the same session.  Thus we minimise the number of sessions created during the run.</body></comment><class><name>Customer</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name bankTransactions bankAccounts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>InflectorTest</name><environment>GlorpActiveRecordTests</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testData inflector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>ActiveRecordValidationTest</name><environment>GlorpActiveRecordTests</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session blogPostClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>GlorpWriteBarriersReleaseTest</name><environment>GlorpActiveRecordTests</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><comment><class-id>GlorpActiveRecordTests.GlorpWriteBarriersReleaseTest</class-id><body>This test verifies that ModificationTracker-enabled GlorpSession objects can be garbage collected when they are no longer in use.</body></comment><class><name>BankAccountNumber</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bankCode branchNumber accountNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>ActiveRecordSessionResource</name><environment>GlorpActiveRecordTests</environment><super>Glorp.GlorpSessionResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecordTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>Address</name><environment>GlorpActiveRecordTests</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>street houseNum </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><class><name>GlorpImmutabilityOnVWTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpActiveRecordTests</package></attributes></class><methods><class-id>GlorpActiveRecordTests.TestActiveRecordDescriptorSystem</class-id> <category>initialize</category><body package="GlorpActiveRecordTests">initialize	super initialize.	inflector pluralTableNames: false.</body></methods><methods><class-id>GlorpActiveRecordTests.TestActiveRecordDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpActiveRecordTests">descriptorForAddress: aDescriptor	aDescriptor table: (self tableNamed: 'GR_ADDRESS').</body><body package="GlorpActiveRecordTests">descriptorForBankAccount: aDescriptor	aDescriptor table: (self tableNamed: 'BANK_ACCT').	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)		attributeName: #bankAccountNumber;		referenceClass: BankAccountNumber.</body><body package="GlorpActiveRecordTests">descriptorForBankAccountNumber: aDescriptor	aDescriptor table: (self tableNamed: 'BANK_ACCT').	self mappingNamed: #bankCode do: [:mapping |		mapping type: Integer].</body><body package="GlorpActiveRecordTests">descriptorForBankTransaction: aDescriptor	aDescriptor table: (self tableNamed: 'BANK_TRANS').</body><body package="GlorpActiveRecordTests">descriptorForCustomer: aDescriptor	aDescriptor table: (self tableNamed: 'GR_CUSTOMER').</body></methods><methods><class-id>GlorpActiveRecordTests.TestActiveRecordDescriptorSystem</class-id> <category>validation</category><body package="GlorpActiveRecordTests">validate	| nonGeneratedTables id |	super validate.	nonGeneratedTables := tables select: [:each | 		id := each fieldNamed: 'ID' ifAbsent: [nil] caseSensitive: false.		id isNil ifTrue: [true] ifFalse: [id type class ~~ GlorpSerialType]].	"Ick. We have to know how many there ought to be that don't match."	nonGeneratedTables size ~= 9 ifTrue: [self error: 'Incorrect field types for IDs'].</body></methods><methods><class-id>GlorpActiveRecordTests.TreeNode</class-id> <category>printing</category><body package="GlorpActiveRecordTests">printOn: aStream	super printOn: aStream.	aStream nextPut: $(; print: id; nextPut: $).</body></methods><methods><class-id>GlorpActiveRecordTests.TreeNode</class-id> <category>accessing</category><body package="GlorpActiveRecordTests">children	^self treeNodes</body><body package="GlorpActiveRecordTests">id	^id</body><body package="GlorpActiveRecordTests">id: anObject	id := anObject</body><body package="GlorpActiveRecordTests">treeNodes	^treeNodes.</body><body package="GlorpActiveRecordTests">treeNodes: aCollection	treeNodes := aCollection.</body></methods><methods><class-id>GlorpActiveRecordTests.TreeNode</class-id> <category>initialize</category><body package="GlorpActiveRecordTests">initialize	super initialize.	treeNodes := OrderedCollection new.</body></methods><methods><class-id>GlorpActiveRecordTests.TreeNode class</class-id> <category>configuration</category><body package="GlorpActiveRecordTests">hasAndBelongsToMany	^#(treeNodes).</body></methods><methods><class-id>GlorpActiveRecordTests.Person</class-id> <category>accessing</category><body package="GlorpActiveRecordTests">address	^address</body><body package="GlorpActiveRecordTests">address: aString	address := aString</body><body package="GlorpActiveRecordTests">id	^id</body><body package="GlorpActiveRecordTests">id: anInteger	id := anInteger</body><body package="GlorpActiveRecordTests">name	^name</body><body package="GlorpActiveRecordTests">name: aString	name := aString</body></methods><methods><class-id>GlorpActiveRecordTests.Person class</class-id> <category>examples</category><body package="GlorpActiveRecordTests">example1	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: nil.</body><body package="GlorpActiveRecordTests">example2	^self new		id: 2;		name: 'John Doe';		address: Address example2.</body></methods><methods><class-id>GlorpActiveRecordTests.BankAccount</class-id> <category>accessing</category><body package="GlorpActiveRecordTests">bankAccountNumber	^bankAccountNumber</body><body package="GlorpActiveRecordTests">bankAccountNumber: anObject	bankAccountNumber := anObject</body><body package="GlorpActiveRecordTests">customers	^customers</body><body package="GlorpActiveRecordTests">customers: anObject	customers := anObject</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests-bank</category><body package="GlorpActiveRecordTests">testBankAccount	| account accounts |	account := BankAccount new 		id: 123;		bankAccountNumber: BankAccountNumber example12345.	session modify: account in: [].	session reset.	accounts := session read: BankAccount.	self assert: accounts size = 1.	self assert: accounts first id = account id.	self assert: accounts first customers size = 0.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests</category><body package="GlorpActiveRecordTests">testDeletePerson	| person people |	person := Person example1.	session modify: person in: [].	session reset.	people := session read: Person.	session delete: people first.	session reset.	people := session read: Person.	self assert: people size = 0.</body><body package="GlorpActiveRecordTests">testPersonWithAddress	| person people addresses |	person := Person example2.	session modify: person in: [].	session reset.	people := session read: Person.	self assert: people size = 1.	self assert: people first id = person id.	self assert: people first name = person name.	self assert: people first address notNil.		addresses := session read: Address where: [:each | each id = people first address id].	self assert: addresses size = 1.	self assert: addresses first == people first address yourSelf.	self assert: addresses first street = person address street.	self assert: addresses first houseNum = person address houseNum.</body><body package="GlorpActiveRecordTests">testReadPersonNoAddress	| person people |	person := Person example1.	session modify: person in: [].	session reset.	people := session read: Person.	self assert: people size = 1.	self assert: people first id = person id.	self assert: people first name = person name.	self assert: people first address isNil.</body><body package="GlorpActiveRecordTests">testWritePersonNoAddress	| person rows |	person := Person example1.	session modify: person in: [].	rows := session accessor executeSQLString: 'SELECT * FROM PERSON'.	self assert: rows size = 1.	self assert: rows first first = person id.	self assert: (rows first at: 2) = person name.</body><body package="GlorpActiveRecordTests">testWritePersonWithAddress	| person rows |	person := Person example2.	session modify: person in: [].	rows := session accessor executeSQLString: 'SELECT * FROM PERSON'.	self assert: rows size = 1.	self assert: rows first first = person id.	self assert: (rows first at: 2) = person name.	self assert: (rows first at: 3) notNil.	rows := session accessor executeSQLString: 'SELECT * FROM GR_ADDRESS'.	self assert: rows size = 1.	self assert: rows first first = person address id.	self assert: (rows first at: 2) = person address street.	self assert: (rows first at: 3) = person address houseNum.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests-tree nodes</category><body package="GlorpActiveRecordTests">testDeleteTreeNode	"Make sure we don't delete out of order"	| allNodes |	self writeNodeWithChildren.	allNodes := session read: TreeNode.	session inUnitOfWorkDo: [allNodes do: [:each | session delete: each]].</body><body package="GlorpActiveRecordTests">testReadTreeNode	| allNodes |	self writeNodeWithChildren.	allNodes := session read: TreeNode orderBy: #id.	self assert: (allNodes collect: [:each | each id]) asArray = #( 1 2 3).	self assert: allNodes first children size = 2.	self assert: (allNodes first children collect: [:each | each id]) asSortedCollection asArray = #( 2 3).	self assert: allNodes first children first children isEmpty.</body><body package="GlorpActiveRecordTests">writeNodeWithChildren	| |	(GlorpManyToManyDBTest new session: session; treeNodeClass: TreeNode) writeNodeWithChildren.	session reset.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>tests-instance side find</category><body package="GlorpActiveRecordTests">testFindQBEByPrimaryKey	| qbe people person |	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new id: 2; session: session.	people := qbe find.	self assert: people size = 1.	self assert: people first id = 2.</body><body package="GlorpActiveRecordTests">testFindQBEByPrimaryKeyNotFound	| qbe people person |	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new id: 1; session: session.	people := qbe find.	self assert: people size = 0.</body><body package="GlorpActiveRecordTests">testFindQBETwoAttributes	| qbe people person |	person := Person example1 session: session.	person bePersistent; commitUnitOfWork.	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new id: 2; name: 'John Doe'; session: session.	people := qbe find.	self assert: people size = 1.	self assert: people first id = 2.</body><body package="GlorpActiveRecordTests">testFindQBETwoAttributesNotFound	| qbe people person |	person := Person example1 session: session.	person bePersistent; commitUnitOfWork.	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new id: 1; name: 'John Doe'; session: session.	people := qbe find.	self assert: people size = 0.</body><body package="GlorpActiveRecordTests">testFindQBEWildcard	| qbe people person |	person := Person example1 session: session.	person bePersistent; commitUnitOfWork.	person := Person example2 session: session.	person bePersistent; commitUnitOfWork.	session reset.	qbe := Person new name: 'John%'; session: session.	people := qbe find.	self assert: people size = 1.	self assert: people first name = 'John Doe'.</body><body package="GlorpActiveRecordTests">testQBEMatchAttribute	| expression |	expression := (Person new matchAttribute: MessageArchiver new to: 'John Doe') asGlorpExpression.	self assert: expression relation = #=.</body><body package="GlorpActiveRecordTests">testQBEMatchAttributeWildcard	| expression |	expression := (Person new matchAttribute: MessageArchiver new to: 'John%') asGlorpExpression.	self assert: expression relation = #LIKE.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest</class-id> <category>running</category><body package="GlorpActiveRecordTests">setUp	super setUp.	session := ActiveRecordSessionResource current session.	session login.	session beginTransaction.</body><body package="GlorpActiveRecordTests">tearDown	super tearDown.	session isNil ifFalse: [		session rollbackTransaction.		session reset].	ActiveRecord resetAllProcessVariables.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordTest class</class-id> <category>resources</category><body package="GlorpActiveRecordTests">resources	^Array with: ActiveRecordSessionResource.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordNewSessionTest</class-id> <category>tests-class side methods</category><body package="GlorpActiveRecordTests">testFind	| person |	person := Person example2.	session modify: person in: [].	session reset.	person := Person find: 2.	self assert: person notNil.	self assert: person name = 'John Doe'.</body><body package="GlorpActiveRecordTests">testFindAll	| person people |	person := Person example2.	session modify: person in: [].	session reset.	people := Person findAll.	self assert: people size = 1.	self assert: people first name = 'John Doe'.</body><body package="GlorpActiveRecordTests">testFindWhere	| person people |	person := Person example2.	session modify: person in: [].	session reset.	people := Person findWhere: [:each | each id = 2].	self assert: people size = 1.	self assert: people first name = 'John Doe'.	people := Person findWhere: [:each | each id = 1].	self assert: people size = 0.</body><body package="GlorpActiveRecordTests">testSave	| person |	(Person example2)		bePersistent;		commitUnitOfWork.	session reset.	person := session readOneOf: Person.	self assert: person notNil.	self assert: person name = 'John Doe'.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordNewSessionTest</class-id> <category>tests</category><body package="GlorpActiveRecordTests">testCompare	| person1 person1_2 person2 |	person1 := Person example1.	person1_2 := Person example1.	person2 := Person example2.	self deny: person1 = person2.	self assert: person1 = person1.	self assert: person1 = person1_2.	person1 := Person new.	person2 := Person new.	self deny: person1 = person2.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordNewSessionTest</class-id> <category>running</category><body package="GlorpActiveRecordTests">setUp	"The tests of this class cannot use the same session as the rest and so must have the resource give them a new session.  Later, rework so a resource is not used in these resource-inapplicable cases."	self assert: (ActiveRecordSessionResource reset; isAvailable).	super setUp.</body></methods><methods><class-id>GlorpActiveRecordTests.InflectorTest</class-id> <category>tests</category><body package="GlorpActiveRecordTests">testCamelize 	self myTestData: self camelWithNamespaceToUnderscoreWithDotTestData.	self myTestData do: [:each | | camelized |		camelized := inflector camelize: each value.		 self assert: camelized = each key].</body><body package="GlorpActiveRecordTests">testCamelizeWithModule 	self myTestData: self camelWithNamespaceToUnderscoreWithDotTestData.	self myTestData do: [:each | | camelized |		camelized := inflector camelize: each value firstLetterInUppercase: true.		 self assert: camelized = each key].</body><body package="GlorpActiveRecordTests">testClassify  	self myTestData: self classNameToTableNameTestData.	self myTestData do: [:each | | className |		className := inflector classify: each value.		 self assert: className = each key].</body><body package="GlorpActiveRecordTests">testClassifyNonPluralTables	Inflector default pluralTableNames: false. 	self myTestData: self classNameToTableNameTestDataNonPlural.	self myTestData do: [:each | | className |		className := inflector classify: each value.		 self assert: className = each key].</body><body package="GlorpActiveRecordTests">testDasherize 	self myTestData: self underscoresToDashesTestData.	self myTestData do: [:each | | dashed |		dashed := inflector dasherize: each key.		 self assert: dashed = each value].</body><body package="GlorpActiveRecordTests">testDemodulize 	self assert: 'Account' = (inflector demodulize: 'MyApplication::Billing::Account').</body><body package="GlorpActiveRecordTests">testForeignKey 	self myTestData: self classNameToForeignKeyWithUnderscoreTestData.	self myTestData do: [:each | | foreignKey |		foreignKey := inflector foreignKey: each key.		 self assert: foreignKey = each value].	self myTestData: self classNameToForeignKeyWithoutUnderscoreTestData.	self myTestData do: [:each | | foreignKey |		foreignKey := inflector foreignKey: each key separateWithUnderscore: false.		 self assert: foreignKey = each value].</body><body package="GlorpActiveRecordTests">testGsub 	self assert: ('hello' replaceRegex: '[aeiou]' withString: '*') = 'h*ll*'. 	self assert: ('hello' replaceRegex: '([aeiou])' withString: '&lt;\1&gt;') = 'h&lt;e&gt;ll&lt;o&gt;'. 	self assert: ('hello' replaceRegex: '.' withString: [:each | each first asInteger printString, ' ']) = '104 101 108 108 111 '.</body><body package="GlorpActiveRecordTests">testHumanize 	self myTestData: self underscoreToHumanTestData.	self myTestData do: [:each | | human |		human := inflector humanize: each key.		 self assert: human = each value].</body><body package="GlorpActiveRecordTests">testOrdinals 	self myTestData: self ordinalTestData.	self myTestData do: [:each | | ordinalized |		ordinalized := inflector ordinalize: each key.		 self assert: ordinalized = each value].</body><body package="GlorpActiveRecordTests">testPluralizePlurals  	self assert: ('plurals' = (inflector pluralize: 'plurals')).  	self assert: ('Plurals' = (inflector pluralize: 'Plurals')).</body><body package="GlorpActiveRecordTests">testSingularToPlural 	self myTestData: self singularToPluralTestData.	self myTestData do: [:each | | plural |		plural := inflector pluralize: each key.		 self assert: plural = each value].</body><body package="GlorpActiveRecordTests">testTableize 	self myTestData: self classNameToTableNameTestData.	self myTestData do: [:each |  | tableized |		tableized := inflector tableize: each key.		self assert: tableized = each value].</body><body package="GlorpActiveRecordTests">testTableizeNonPlural	Inflector default pluralTableNames: false. 	self myTestData: self classNameToTableNameTestDataNonPlural.	self myTestData do: [:each |  | tableized |		tableized := inflector tableize: each key.		self assert: tableized = each value].</body><body package="GlorpActiveRecordTests">testUnderscore 	self myTestData: self camelToUnderscoreTestData.	self myTestData do: [:each | self assert: (inflector underscore: each key) = each value]. 	self myTestData: self camelToUnderscoreWithoutReverseTestData.	self myTestData do: [:each | self assert: (inflector underscore: each key) = each value].</body><body package="GlorpActiveRecordTests">testUnderscoreAsReverseOfDasherize 	self myTestData: self underscoresToDashesTestData.	self myTestData do: [:each | | dashed |		dashed := inflector underscore: (inflector dasherize: each key).		self assert: (dashed = each key)].</body><body package="GlorpActiveRecordTests">testUnderscoreToLowerCamel 	self myTestData: self underscoreToLowerCamelTestData.	self myTestData do: [:each | | camelized |		camelized := inflector camelize: each key firstLetterInUppercase: false.		self assert: (camelized = each value)].</body><body package="GlorpActiveRecordTests">testUnderscoreWithSlashes 	self myTestData: self camelWithModuleToUnderscoreWithSlashesTestData.	self myTestData do: [:each |  | underscored |		underscored := inflector underscore: each key.		self assert: underscored = each value].</body></methods><methods><class-id>GlorpActiveRecordTests.InflectorTest</class-id> <category>test data</category><body package="GlorpActiveRecordTests">camelToUnderscoreTestData	^#('Product' -&gt; 'product' 'SpecialGuest' -&gt; 'special_guest' 'ApplicationController' -&gt; 'application_controller' 'Area51Controller' -&gt; 'area51_controller')</body><body package="GlorpActiveRecordTests">camelToUnderscoreWithoutReverseTestData	^#('HTMLTidy' -&gt; 'html_tidy' 'HTMLTidyGenerator' -&gt; 'html_tidy_generator' 'FreeBSD' -&gt; 'free_bsd' 'HTML' -&gt; 'html').</body><body package="GlorpActiveRecordTests">camelWithModuleToUnderscoreWithSlashesTestData	^#('Admin::Product' -&gt; 'admin/product' 'Users::Commission::Department' -&gt; 'users/commission/department' 'UsersSection::CommissionDepartment' -&gt; 'users_section/commission_department').</body><body package="GlorpActiveRecordTests">camelWithNamespaceToUnderscoreWithDotTestData	^#( 'Admin.Product' -&gt; 'admin.product' 'Users.Commission.Department' -&gt; 'users.commission.department' 'UsersSection.CommissionDepartment' -&gt; 'users_section.commission_department').</body><body package="GlorpActiveRecordTests">classNameToForeignKeyWithUnderscoreTestData	^#( 'Person' -&gt; 'person_id' 'MyApplication::Billing::Account' -&gt; 'account_id').</body><body package="GlorpActiveRecordTests">classNameToForeignKeyWithoutUnderscoreTestData	^#( 'Person' -&gt; 'personid'  'MyApplication::Billing::Account' -&gt; 'accountid').</body><body package="GlorpActiveRecordTests">classNameToTableNameTestData	^#('PrimarySpokesman' -&gt; 'primary_spokesmen' 'NodeChild' -&gt; 'node_children' 'Address' -&gt; 'addresses').</body><body package="GlorpActiveRecordTests">classNameToTableNameTestDataNonPlural	^#('PrimarySpokesman' -&gt; 'primary_spokesman' 'NodeChild' -&gt; 'node_child' 'Address' -&gt; 'address').</body><body package="GlorpActiveRecordTests">ordinalTestData	^#('0' -&gt; '0th' '1' -&gt; '1st' '2' -&gt; '2nd' '3' -&gt; '3rd' '4' -&gt; '4th' '5' -&gt; '5th' '6' -&gt; '6th' '7' -&gt; '7th' '8' -&gt; '8th' '9' -&gt; '9th' '10' -&gt; '10th' '11' -&gt; '11th' '12' -&gt; '12th' '13' -&gt; '13th' '14' -&gt; '14th' '20' -&gt; '20th' '21' -&gt; '21st' '22' -&gt; '22nd' '23' -&gt; '23rd' '24' -&gt; '24th' '100' -&gt; '100th' '101' -&gt; '101st' '102' -&gt; '102nd' '103' -&gt; '103rd' '104' -&gt; '104th' '110' -&gt; '110th' '1000' -&gt; '1000th' '1001' -&gt; '1001st').</body><body package="GlorpActiveRecordTests">singularToPluralTestData 	^#( 'search' -&gt; 'searches' 'switch' -&gt; 'switches' 'fix' -&gt; 'fixes' 'box' -&gt; 'boxes' 'process' -&gt; 'processes' 'address' -&gt; 'addresses' 'case' -&gt; 'cases' 'stack' -&gt; 'stacks' 'wish' -&gt; 'wishes' 'fish' -&gt; 'fish' 'category' -&gt; 'categories' 'query' -&gt; 'queries' 'ability' -&gt; 'abilities' 'agency' -&gt; 'agencies' 'movie' -&gt; 'movies' 'archive' -&gt; 'archives' 'index' -&gt; 'indices' 'wife' -&gt; 'wives' 'safe' -&gt; 'saves' 'half' -&gt; 'halves' 'move' -&gt; 'moves' 'salesperson' -&gt; 'salespeople' 'person' -&gt; 'people' 'spokesman' -&gt; 'spokesmen' 'man' -&gt; 'men' 'woman' -&gt; 'women' 'basis' -&gt; 'bases' 'diagnosis' -&gt; 'diagnoses' 'datum' -&gt; 'data' 'medium' -&gt; 'media' 'analysis' -&gt; 'analyses' 'node_child' -&gt; 'node_children' 'child' -&gt; 'children' 'experience' -&gt; 'experiences' 'day' -&gt; 'days' 'comment' -&gt; 'comments' 'foobar' -&gt; 'foobars' 'newsletter' -&gt; 'newsletters' 'old_news' -&gt; 'old_news' 'news' -&gt; 'news' 'series' -&gt; 'series' 'species' -&gt; 'species' 'quiz' -&gt; 'quizzes' 'perspective' -&gt; 'perspectives' 'ox' -&gt; 'oxen' 'photo' -&gt; 'photos' 'buffalo' -&gt; 'buffaloes' 'tomato' -&gt; 'tomatoes' 'dwarf' -&gt; 'dwarves' 'elf' -&gt; 'elves' 'information' -&gt; 'information' 'equipment' -&gt; 'equipment' 'bus' -&gt; 'buses' 'status' -&gt; 'statuses' 'status_code' -&gt; 'status_codes' 'mouse' -&gt; 'mice' 'louse' -&gt; 'lice' 'house' -&gt; 'houses' 'octopus' -&gt; 'octopi' 'virus' -&gt; 'viri' 'alias' -&gt; 'aliases' 'portfolio' -&gt; 'portfolios' 'vertex' -&gt; 'vertices' 'matrix' -&gt; 'matrices' 'axis' -&gt; 'axes' 'testis' -&gt; 'testes' 'crisis' -&gt; 'crises' 'rice' -&gt; 'rice' 'shoe' -&gt; 'shoes' 'horse' -&gt; 'horses' 'prize' -&gt; 'prizes' 'edge' -&gt; 'edges' 'address' -&gt; 'addresses').</body><body package="GlorpActiveRecordTests">underscoreToHumanTestData	^#('employee_salary' -&gt; 'Employee salary' 'employee_id' -&gt; 'Employee' 'underground' -&gt; 'Underground').</body><body package="GlorpActiveRecordTests">underscoreToLowerCamelTestData	^#('product' -&gt; 'product' 'special_guest' -&gt; 'specialGuest' 'application_controller' -&gt; 'applicationController' 'area51_controller' -&gt; 'area51Controller').</body><body package="GlorpActiveRecordTests">underscoresToDashesTestData	^#('street' -&gt; 'street' 'street_address' -&gt; 'street-address' 'person_street_address' -&gt; 'person-street-address')</body></methods><methods><class-id>GlorpActiveRecordTests.InflectorTest</class-id> <category>support</category><body package="GlorpActiveRecordTests">myTestData	^testData.</body><body package="GlorpActiveRecordTests">myTestData: anArray	testData := OrderedCollection new.	1 to: anArray size by: 3 do: [:i |		testData add: ((anArray at: i) perform: (anArray at: i+1) with: (anArray at: i+2))].</body><body package="GlorpActiveRecordTests">setUp	super setUp.	"Make sure we get the latest rules"	Inflector reset.	inflector := Inflector inflections.	inflector pluralTableNames: true.</body></methods><methods><class-id>GlorpActiveRecordTests.InflectorTest</class-id> <category>running</category><body package="GlorpActiveRecordTests">tearDown	Inflector reset.	super tearDown.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordValidationTest</class-id> <category>Running</category><body package="GlorpActiveRecordTests">setUp	| none |	none := Store.Registry packageNamed: '(none)'.	Store.Policies packagePolicy 		forcePackage: none		while: [blogPostClass := Smalltalk.GlorpActiveRecordTests				defineClass: #BlogPost asSymbol				superclass: #'Glorp.ActiveRecords.ActiveRecord' asStrictReference				indexedType: #none				private: false				instanceVariableNames: ''				classInstanceVariableNames: ''				imports: ''				category: ' '. ].</body><body package="GlorpActiveRecordTests">tearDown	session ifNotNil: [ session logout].	(Refactory.Browser.RemoveClassChange removeClassName: blogPostClass fullName) execute.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordValidationTest</class-id> <category>testing</category><body package="GlorpActiveRecordTests">testNoTableFound	|  system |	system := TestActiveRecordDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database.	self 		should: [session := system sessionForLogin: GlorpDatabaseLoginResource current login]		raise: Glorp.NoTableFound.	self assert: session isNil. 	[session := [system sessionForLogin: GlorpDatabaseLoginResource current login]						on: InvalidSessionSetup						do: [:ex | ex resume].	self assert: true]		on: Glorp.NoTableFound		do: [ :ex | 			self assert: ( 'No table found for BlogPost, expected to see one of  #(''blog_post'' ''blog_posts'')' match: ex printString).			ex proceed ].	self assert: session notNil</body></methods><methods><class-id>GlorpActiveRecordTests.GlorpWriteBarriersReleaseTest</class-id> <category>testing</category><body package="GlorpActiveRecordTests">generateSessionsUsingModificationTracker	"Generate a bunch of GlorpSessions with modificationTracker enabled.  While this method is running, they will be referenced via the method cache (even if this method were to flushes the cache itself, e.g. by a call of globalCompactingGC).  Once this method ends, there will be no references to prevent GC - specifically, the modification trackers will not prevent themselves or their sessions being GCed."	1 to: 10 do:		[:i || session |		session := TestActiveRecordDescriptorSystem sessionForLogin:			GlorpDatabaseLoginResource current login.		session useModificationTracker.		ObjectMemory garbageCollect].</body><body package="GlorpActiveRecordTests">testReleaseOfSessionsHavingModificationTracker	"Verify that the trackers don't prevent sessions from being reclaimed."	| numSessionsBefore numTrackersBefore numSessionsAfter numTrackersAfter numSystemsBefore numSystemsAfter |	ObjectMemory garbageCollect.	numSystemsBefore := (TestActiveRecordDescriptorSystem allInstancesWeakly: true) size.	numSessionsBefore := (GlorpSession allInstancesWeakly: true) size.	numTrackersBefore := (GlorpVWWriteBarrierTracker allInstancesWeakly: true) size.	"Generate the sessions inside a separate method to avoid this cached test method from holding onto an instance."	self generateSessionsUsingModificationTracker.	ObjectMemory garbageCollect.	ObjectMemory garbageCollect.	numSystemsAfter := (TestActiveRecordDescriptorSystem allInstancesWeakly: true) size.	numSessionsAfter := (GlorpSession allInstancesWeakly: true) size.	numTrackersAfter := (GlorpVWWriteBarrierTracker allInstancesWeakly: true) size.	self assert: numSystemsAfter &lt;= numSystemsBefore		description: 'System points strongly at session;  must GC system to lose session'.	self assert: numSessionsAfter &lt;= numSessionsBefore		description: 'Tracked session(s) not being GCed'.	self assert: numTrackersAfter &lt;= numTrackersBefore		description: 'We GCed the session but not its tracker'.</body></methods><methods><class-id>GlorpActiveRecordTests.BankAccountNumber</class-id> <category>accessing</category><body package="GlorpActiveRecordTests">accountNumber	^accountNumber</body><body package="GlorpActiveRecordTests">accountNumber: anObject	accountNumber := anObject</body><body package="GlorpActiveRecordTests">bankCode	^bankCode</body><body package="GlorpActiveRecordTests">bankCode: anObject	bankCode := anObject</body><body package="GlorpActiveRecordTests">branchNumber	^branchNumber</body><body package="GlorpActiveRecordTests">branchNumber: anObject	branchNumber := anObject</body></methods><methods><class-id>GlorpActiveRecordTests.BankAccountNumber class</class-id> <category>examples</category><body package="GlorpActiveRecordTests">example12345	^self new		accountNumber: 12345;		bankCode: 4;		branchNumber: 777.</body></methods><methods><class-id>GlorpActiveRecordTests.ActiveRecordSessionResource</class-id> <category>setup</category><body package="GlorpActiveRecordTests">glorpTestsSystem	GlorpDemoTablePopulatorResource current.	system isNil ifTrue: [		system := TestActiveRecordDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database].	^system.</body><body package="GlorpActiveRecordTests">setUp	super setUp.	ActiveRecord setSession: session.</body><body package="GlorpActiveRecordTests">tearDown	ActiveRecord setSession: nil.	super tearDown.</body></methods><methods><class-id>GlorpActiveRecordTests.Address</class-id> <category>accessing</category><body package="GlorpActiveRecordTests">houseNum	^houseNum</body><body package="GlorpActiveRecordTests">houseNum: aString	houseNum := aString</body><body package="GlorpActiveRecordTests">id	^id</body><body package="GlorpActiveRecordTests">id: anInteger	id := anInteger</body><body package="GlorpActiveRecordTests">street	^street</body><body package="GlorpActiveRecordTests">street: aString	street := aString</body></methods><methods><class-id>GlorpActiveRecordTests.Address class</class-id> <category>examples</category><body package="GlorpActiveRecordTests">example2	^self new		id: 2;		street: 'Nowhere';		houseNum: '1000'.</body></methods><methods><class-id>Glorp.GlorpImmutabilityOnVWTest</class-id> <category>testing</category><body package="GlorpActiveRecordTests">getTrackerList	^(Dialect smalltalkAt: #'WriteBarriers.Tracker') trackers.</body><body package="GlorpActiveRecordTests">testAutoRegistrationUsingImmutabilityFlag	| person |	Dialect isVisualWorks ifFalse: [^self].	session beginTransaction.	session useModificationTracker.	[ session modify: GlorpPerson example1 in: [].	session reset.	person := session readOneOf: GlorpPerson. 	session beginUnitOfWork.	person name: 'foo'.	self assert: (session isRegistered: person)] ensure: [session rollbackUnitOfWork. session rollbackTransaction].</body><body package="GlorpActiveRecordTests">testAutoRegistrationUsingImmutabilityFlagFail	| person |	Dialect isVisualWorks ifFalse: [^self].	session beginTransaction.	[ session modify: GlorpPerson example1 in: [].	session reset.	person := session readOneOf: GlorpPerson. 	session beginUnitOfWork.	person name: 'Foo'.	self deny: (session isRegistered: person)] ensure: [			session rollbackUnitOfWork.	session rollbackTransaction].</body><body package="GlorpActiveRecordTests">testAutoRegistrationUsingImmutabilityFlagStartingUnitOfWork	| person |	Dialect isVisualWorks ifFalse: [^self].	session beginTransaction.	session useModificationTracker.	[ session modify: GlorpPerson example1 in: [].	session reset.	person := session readOneOf: GlorpPerson. 	person name: 'foo'.	self assert: (session isRegistered: person)] ensure: [session rollbackUnitOfWork. session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpImmutabilityOnVWTest</class-id> <category>support</category><body package="GlorpActiveRecordTests">tearDown	session dontUseModificationTracker.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpDirectMappingDBTest</class-id> <category>tests</category><body package="GlorpActiveRecordTests">testTwoMappingsToSubselectNonProxied	"There are some awful sharing bugs that were manifesting with relationships that made use of the direct-to-subselect mapping. Let's actually test it on the mapping that manifested it, in mapping to the information_schema."	| constraint metaSession |	session system platform supportsInformationSchema ifFalse: [^self knownFailure].	[constraint := session system platform class == SQLite3Platform		ifTrue:			[metaSession := (MetadataDescriptorSystem forPlatform: session system platform) sessionForLogin: session accessor currentLogin.			metaSession accessor: session accessor.			metaSession readOneOf: ForeignKeyConstraint where: [:each | each name asLowercase = 'gr_message_to_gr_folder__ref']]		ifFalse:			[session system: (MetadataDescriptorSystem forPlatform: session system platform).			((session system descriptorFor: DatabaseField) mappingForAttributeNamed: #isPrimaryKey) shouldProxy: false.			session readOneOf: ForeignKeyConstraint where: [:each | each name asLowercase = 'gr_message_to_gr_folder__ref2']].	"Note: proxies to booleans confuse if statements"	self assert: constraint sourceFields first isPrimaryKey yourSelf.	self assert: constraint sourceFields last isPrimaryKey yourSelf.	self assert: constraint targetFields first isPrimaryKey yourSelf.	self assert: constraint targetFields last isPrimaryKey yourSelf.	self assert: constraint sourceFields size = 2.	self assert: constraint targetFields size = 2.	self deny: (constraint targetFields includes: constraint sourceFields first)]		ensure: [session rollbackTransaction].</body><body package="GlorpActiveRecordTests">testTwoMappingsToSubselectProxied	"There are some awful sharing bugs that were manifesting with relationships that made use of the direct-to-subselect mapping. Let's actually test it on the mapping that manifested it, in mapping to the information_schema."	| constraint metaSession |	session system platform supportsInformationSchema ifFalse: [^self knownFailure].	[constraint := session system platform class == SQLite3Platform		ifTrue:			[metaSession := (MetadataDescriptorSystem forPlatform: session system platform) sessionForLogin: session accessor currentLogin.			metaSession accessor: session accessor.			metaSession readOneOf: ForeignKeyConstraint where: [:each | each name asLowercase = 'gr_message_to_gr_folder__ref']]		ifFalse:			[session system: (MetadataDescriptorSystem forPlatform: session system platform).			((session system descriptorFor: DatabaseField) mappingForAttributeNamed: #isPrimaryKey) shouldProxy: false.			session readOneOf: ForeignKeyConstraint where: [:each | each name asLowercase = 'gr_message_to_gr_folder__ref2']].	"Note: proxies to booleans confuse if statements"	self assert: constraint sourceFields first isPrimaryKey yourSelf.	self assert: constraint sourceFields last isPrimaryKey yourSelf.	self assert: constraint targetFields first isPrimaryKey yourSelf.	self assert: constraint targetFields last isPrimaryKey yourSelf.	self assert: constraint sourceFields size = 2.	self assert: constraint targetFields size = 2.	self assert: constraint sourceFields first name = constraint targetFields first name]		ensure: [session rollbackTransaction].</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>GlorpSessionBasedTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>ActiveRecordDescriptorSystem</name><environment>Glorp.ActiveRecords</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metadataSession inflector currentDescriptor deferredDescriptorOperations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>ActiveRecord</name><environment>Glorp.ActiveRecords</environment><super>Glorp.PersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>GlorpSessionResource</name><environment>Glorp</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDirectMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person personId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class></st-source>