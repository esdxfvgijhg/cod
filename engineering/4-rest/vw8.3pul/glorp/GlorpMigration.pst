<?xml version="1.0"?><st-source><!-- Name: GlorpMigrationNotice: The code is Copyright 2008-2016 Cincom Systems, Inc.  All rights reserved.This utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: The package allows migrating from one schema version to another. The migration steps include - creating a new database schema descriptor- calculating changes between database schema versions- applying changes to a databaseCreating a new version of a database descriptor system.MyDescriptorSystem newDatabaseSchema: 'MyDescriptorSystem_V1'.The MyDescriptorSystem_V1 class will include all methods that describe tables from MyDescriptorSystem and a new method #migrationAncestor  that returns the MyDescriptorSystem. This method is used to calculate the migration path. For example.Load the WVExample-BlogServer package and execute:BlogDatabaseSchema newDatabaseSchema: ' MyBlogDatabaseSchema_v1'.There is MyBlogDatabaseSchema_v1 created in the WVExample-BlogServer package.Migration.In the new cloned version you can do some changes in the database schema and then migrate your database to a new version.Let's do some changes in your new class MyBlogDatabaseSchema_v1. For example you can add the new #filler column to your database table POSTS:tableForPOSTS: aTable	(aTable createFieldNamed: 'id' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'title' type: (platform varchar: 200).	aTable createFieldNamed: 'content' type: platform text.	aTable createFieldNamed: 'created' type: platform timestamp.	aTable createFieldNamed: 'filler' type: ( platform varchar: 20 )Now we can migrate to the new database schema.The migration API allows you to generate a migration script, review and update it before applying the schema changes to a database.To run our example now we need a database connection.Glorp.GlorpDatabaseLoginResource defaultLogin: ((Login new)		database: PostgreSQLPlatform new;		username: 'user';		password: 'xxxx';		connectString: 'localhost:5432_postgres').DatabaseAccessor loggingEnabled: true. <-  it helps to see the SQL statements in the system transcript.Initialize the source description system:session := BlogDatabaseSchema sessionForLogin: GlorpDatabaseLoginResource current login.sourceDescriptorSystem := session system.If your database doesn't have the POSTS and COMMENTS tables to run the example you need the create tables from the descriptor system.session recreateTables..Create an instance of the database descriptor we are going to migrate to:sourceDescriptorSystem := (MyBlogDatabaseSchema_v1 sessionForLogin: GlorpDatabaseLoginResource current login) system.Create a migration script to migrate from  BlogDatabaseSchema to MyBlogDatabaseSchema_v1:sourceDescriptorSystem createDefaultMigrationScriptFor: destinationDescriptorSystem.There is a new method in BlogDatabaseSchema:migrationScriptTo MyBlogDatabaseSchema_v1: aMigrationChangeSet	<migrationScriptTo: # MyBlogDatabaseSchema_v1>	aMigrationChangeSet addFieldNamed: 'filler' toTableNamed: 'posts'.You can modify the script before applying the schema changes to a database. Additional script API can be found in the MigrationChangeSet class in protocols such as 'api - add/drop field', 'api - add/drop foreign key' and etc.Having the migration script you can migrate to a new version:sourceDescriptorSystem migrateTo: destinationDescriptorSystem.DbIdentifier: bear73DbTrace: 491250DbUsername: nrossDbVersion: 8.2 - 5DevelopmentPrerequisites: #(#(#any 'Database' '') #(#any 'GlorpActiveRecord' ''))PackageName: GlorpMigrationParcel: #('GlorpMigration')ParcelName: GlorpMigrationPrerequisiteDescriptions: #(#(#name 'Database') #(#name 'GlorpActiveRecord'))PrerequisiteParcels: #(#('Database' '') #('GlorpActiveRecord' ''))PrintStringCache: (8.2 - 5,nross)Version: 8.2 - 5Date: 12:42:55 PM May 27, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (may16.4) of May 27, 2016 on May 27, 2016 at 12:42:55 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Migration</name><environment>Glorp</environment><private>false</private><imports>			private Glorp.*			</imports><category>GlorpMigration</category><attributes><package>GlorpMigration</package></attributes></name-space><class><name>MigrationOperation</name><environment>Glorp.Migration</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseTable destination source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.MigrationOperation</class-id><body>MigrationOperation is an abstract class for migration operations. The operations know how to write a migration script and apply changes to a database.Subclasses must implement the following messages:	api		applyInSession:		writeFor:on:Instance Variables:	databaseTable	&lt;DatabaseTable&gt; database table	destination	&lt;DescriptorSystem&gt; destination system the operation is described in	source	&lt;DescriptorSystem&gt; source system the operation will be applied to	exceptionBlock	&lt;BlockClosure&gt; block that handles exceptions during operation.</body></comment><class><name>DropPrimaryKeyConstraint</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.DropPrimaryKeyConstraint</class-id><body>DropPrimaryKeyConstraint drops a primary key constraint</body></comment><class><name>ScriptErrors</name><environment>Glorp.Migration</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.ScriptErrors</class-id><body>ScriptErrors collects all ScriptError's when the migration operations are created from a scriptInstance Variables:	selector	&lt;Symbol&gt;	script method selector </body></comment><class><name>RenameField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField newFieldName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.RenameField</class-id><body>RenameField renames a database fieldInstance Variables:	databaseField	&lt;DatabaseField&gt;	database field to rename 	newFieldName	&lt;String&gt;	 new field name</body></comment><class><name>CreateTable</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CreateTable</class-id><body>CreateTable creates a database table</body></comment><class><name>CompositeMigrationOperation</name><environment>Glorp.Migration</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source destination </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CompositeMigrationOperation</class-id><body>CompositeMigrationOperation represents a multiple operations in steps in a chained migration. Say we are migrating from v.1 to v. 10 of a database schema along a migration path v.1, v.2, etc. Each of the intermediate migrations will be represented by instances of subclasses of CompositeMigrationOperation.Instance Variables:	destination	&lt;Symbol&gt;	symbolic name of the class that is the destination of the intermediate migration.	source	&lt;Symbol&gt;	symbolic name of the class that is the source of the intermediate migration.</body></comment><class><name>CopyTableData</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>destinationTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CopyTableData</class-id><body>CopyTableData copies data from #databaseTable to #destinationTableInstance Variables:	destinationTable	&lt;DatabaseTable&gt;	destination table</body></comment><class><name>PopulateField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField fieldValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.PopulateField</class-id><body>PopulateField populates a database field with some data. If the field type is different than the #fieldValue type the database will raise an error.Instance Variables:	databaseField	&lt;DatabaseField&gt;	database field	fieldValue	&lt;Object&gt;	filed value</body></comment><class><name>DropField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.DropField</class-id><body>DropField drops a database columnInstance Variables:	databaseField	&lt;DatabaseField&gt;	database field to drop</body></comment><class><name>TableCopyForMigration</name><environment>Glorp.Migration</environment><super>Glorp.DatabaseTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.TableCopyForMigration</class-id><body>TableCopyForMigration is used to copy database tables to protect the original database definition.</body></comment><class><name>CreatePrimaryKeyConstraint</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CreatePrimaryKeyConstraint</class-id><body>CreatePrimaryKeyConstraint creates a primary key constraintInstance Variables:	constraint	&lt;PrimaryKeyConstraint&gt; primary key constraint</body></comment><class><name>AlterField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField isNullable isUnique isLockKey defaultValue type dropDefault </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.AlterField</class-id><body>AlterField alters a database column. Currently supported  #type, #dbDefaultValue and #isNullable changes.Instance Variables:	databaseField	&lt;DatabaseField&gt;	database field	defaultValue	&lt;Object&gt;	if not nil the database field dbDefaultValue will be set to this value	dropDefault	&lt;Boolean&gt;	dropDefault if true the #dbDefaultValue will be set to nil	isLockKey	&lt;Boolean&gt;	not suported	isNullable	&lt;Boolean&gt;	if true, the database field will drop NOT NULL attribute. If false the database field will be altered with NOT NULL attribute.	isUnique	&lt;Boolean&gt;	not supported currently. 	type	&lt;GlorpDatabaseType&gt;	if not nil, the database field type will be changed to a new type</body></comment><class><name>ExecuteSql</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sqlString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.ExecuteSql</class-id><body>ExecuteSql executes a database SQL statementInstance Variables:	sqlString	&lt;String&gt;	sqlString to execute</body></comment><class><name>MigrationScriptError</name><environment>Glorp.Migration</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><class><name>AddField</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>databaseField fieldType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.AddField</class-id><body>AddField adds a database column to a tableInstance Variables:	databaseField	&lt;DatabaseField&gt;	database field to add to a table	fieldType	&lt;GlorpDatabaseType&gt;	database field type</body></comment><class><name>CopyFieldData</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fromField toField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CopyFieldData</class-id><body>CopyFieldData copies database field data from #fromField to #toFieldInstance Variables:	fromField	&lt;DatabaseField&gt;	description of fromField	toField	&lt;DatabaseField&gt;	description of toField</body></comment><class><name>ScriptedOperations</name><environment>Glorp.Migration</environment><super>Glorp.Migration.CompositeMigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.ScriptedOperations</class-id><body>ScriptedMigrationStep represents a single step in a chained migration. Say we are migrating from v.1 to v. 10 of a database schema. There are existing scripts to migrate from v.3 to v. 4, and v. 4 to v. 5. These two scripts will be represented by instances of ScriptedMigrationStep.Instance Variables:	selector	&lt;Symbol&gt; a script selector</body></comment><class><name>ScriptError</name><environment>Glorp.Migration</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.ScriptError</class-id><body>ScriptError will be raised while creating a migration operation from a script. The exception is resumable.</body></comment><class><name>MigrationError</name><environment>Glorp.Migration</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>migrationOperation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.MigrationError</class-id><body>MigrationError will be raise if an error occurs while applying changes to a database. The #messageText will try to retrive the database error description.Instance Variables:	migrationOperation	&lt;MigrationOperation&gt; currently executed migration operation </body></comment><class><name>CreateForeignKeyConstraint</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id><body>CreateForeignKeyConstraint creates a foreign key contstraint Instance Variables:	constraint	&lt;ForeignKeyConstraint&gt; foreign key constraint</body></comment><class><name>CalculatedOperations</name><environment>Glorp.Migration</environment><super>Glorp.Migration.CompositeMigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CalculatedOperations</class-id><body>The following comment was cloned from the original comment of ScriptedMigrationStep==========================================================CalculatedMigrationStep represents a single step in a chained migration. Say we are migrating from v.1 to v. 10 of a database schema. There are no existing scripts to migrate from v.3 to v. 4, and v. 4 to v. 5. The corresponding migration steps will be represented by instances of CalculatedMigrationStep.</body></comment><class><name>DropForeignKeyConstraint</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraint </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id><body>DropForeignKeyConstraint drops a foreign key constraintInstance Variables:	constraint	&lt;ForeignKeyConstraint&gt;	constraint to drop</body></comment><class><name>MigrationChangeSet</name><environment>Glorp.Migration</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source destination operations destinationTables sourceTables currentDestination currentSource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.MigrationChangeSet</class-id><body>MigrationChangeSet allows migrating from one database schema to another. The migration can include the following steps:- calculating changes from one database descriptor system to another as a collection of migration operations- the migration operations can be saved as a script and modified- the migration operations can be created from a migration script- applying the migration operations to the database.Instance Variables:	source	&lt;DescriptorSystem&gt; the source database schema	destination	&lt;DescriptorSystem&gt; the destination database schema	operations	&lt;(Collection of: MigrationOperation)&gt; individual operations are instances of MigrationOperation subclasses. When a MigrationChangeSet is applied, the migration operations get applied in the same order they have been previously added to the change set view #addOperation: method. Each of the API methods should result in exactly one #addOperation: message send.	destinationTables	&lt;Dictionary&gt; destinationTables hold migration copies of the &lt;DatabaseTable&gt; instances as set up by the destination schema.	sourceTables	&lt;Dictionary&gt; sourceTables hold migration copies of the &lt;DatabaseTable&gt; instances as set up by the source schema.	currentDestination	&lt;DescriptorSystem&gt; Intermediate destination	currentSource	&lt;DescriptorSystem&gt; Intermediate source. For the migration operations defined in scripts we need the script source and  destination if they are different from the original source and final destination. For example,  if we have migration path: v1-&gt;v2-&gt;v3-&gt;v4-&gt;v5 versions and v2 has a migration script to v3 that adds a new field. The information about this field type will be in the v3 version but may not be in the final v5.Calculating migration operations.- if there is no migration scripts between descriptor system version  V1 and VN the migration operations are calculated as difference between V1 and VN and all intermediate versions are ignored.- if there is a migration script for example in version V10 the migration operations are calculated in a few steps:	- collected operations from V1 to V10	- collected operations from V10 script	- collected operations from V10 to VNError handlingCalculatingChangeSetError will be raised while calculating a migration change set if - the source descriptor system has more than one script to migrate to the destination system- the source system migration path doesn't include the destination system.All script errors will be collected and raised as ScriptErrors.MigrationError will be raise if an error occurs while applying changes to a database. The #messageText will try to retrive the database error description.</body></comment><class><name>CalculatingChangeSetError</name><environment>Glorp.Migration</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source destination </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.CalculatingChangeSetError</class-id><body>CalculatingChangeSetError will be raised while calculating a migration change set if - the source descriptor system has more than one script to migrate to the destination system- the source system migration path doesn't include the destination system.Instance Variables:	destination	&lt;DescriptorSystem&gt;	description of destination	source	&lt;DescriptorSystem&gt;	description of source</body></comment><class><name>DropTable</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.DropTable</class-id><body>DropTable drops a database table</body></comment><class><name>RenameTable</name><environment>Glorp.Migration</environment><super>Glorp.Migration.MigrationOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newTableName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMigration</package></attributes></class><comment><class-id>Glorp.Migration.RenameTable</class-id><body>RenameTable renames a database table.Instance Variables:	newTableName	&lt;String&gt;	new table name</body></comment><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>accessing</category><body package="GlorpMigration">databasePlatform	^self databaseTable		ifNotNil: [self databaseTable platform]		ifNil: [source platform]</body><body package="GlorpMigration">databaseTable	^databaseTable</body><body package="GlorpMigration">databaseTable: anObject	databaseTable := anObject</body><body package="GlorpMigration">databaseTables	^ Array with: self databaseTable</body><body package="GlorpMigration">destination	^destination</body><body package="GlorpMigration">destination: aSchema	destination := aSchema</body><body package="GlorpMigration">exceptionBlock	^[:ex | ex pass]</body><body package="GlorpMigration">source	^source</body><body package="GlorpMigration">source: aSchema	source := aSchema</body><body package="GlorpMigration">tableName	^ self databaseTable name</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>testing</category><body package="GlorpMigration">hasAddForeignKeyConstraintFor: aForeignKeyConstraint	^false</body><body package="GlorpMigration">hasDropForeignKeyConstraintFor: aForeignKeyConstraint	^false</body><body package="GlorpMigration">hasDropPrimaryKeyConstraintForFor: aDatabaseTable	^false</body><body package="GlorpMigration">isAlterField	^false</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>printing</category><body package="GlorpMigration">printOn: aStream	self writeFor: 'aMigrationChangeSet' on: aStream</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession"The method applies the database changes to a database  "	^ self subclassResponsibility</body><body package="GlorpMigration">writeFor: argumentName on: aStream"The method writes the migration script "	^self subclassResponsibility</body></methods><methods><class-id>Glorp.Migration.MigrationOperation</class-id> <category>sorting</category><body package="GlorpMigration">weigh	^100</body></methods><methods><class-id>Glorp.Migration.MigrationOperation class</class-id> <category>instance creation</category><body package="GlorpMigration">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.DropPrimaryKeyConstraint</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor 		dropConstraint: databaseTable primaryKeyConstraints  		ifError: self exceptionBlock</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		nextPutAll: ' dropPrimaryKeyFromTableNamed: ';		nextPutAll: databaseTable name printString;		nextPut: $.;		cr</body></methods><methods><class-id>Glorp.Migration.DropPrimaryKeyConstraint</class-id> <category>testing</category><body package="GlorpMigration">hasDropPrimaryKeyConstraintForFor: aDatabaseTable		^databaseTable name asUppercase = aDatabaseTable name asUppercase</body></methods><methods><class-id>Glorp.Migration.DropPrimaryKeyConstraint</class-id> <category>sorting</category><body package="GlorpMigration">weigh	^15</body></methods><methods><class-id>Glorp.Migration.ScriptErrors</class-id> <category>accessing</category><body package="GlorpMigration">messageText	| stream |	parameter ifNil: [^nil ].	messageText		ifNil: [stream := WriteStream on: String new.			stream nextPutAll: 'Errors in ', selector printString, ' script'; cr.			parameter do: [ :each | stream nextPutAll: each description ; cr.].			messageText := stream contents].	^messageText</body><body package="GlorpMigration">selector	^selector</body><body package="GlorpMigration">selector: anObject	selector := anObject</body></methods><methods><class-id>Glorp.Migration.ScriptErrors</class-id> <category>printing</category><body package="GlorpMigration">description	^self messageText</body></methods><methods><class-id>Glorp.Migration.ScriptErrors class</class-id> <category>instance creation</category><body package="GlorpMigration">errors: aCollection from: aSymbol	^self new		parameter: aCollection;		selector: aSymbol;		yourself</body></methods><methods><class-id>Glorp.Migration.RenameField</class-id> <category>accessing</category><body package="GlorpMigration">databaseField		^databaseField</body><body package="GlorpMigration">databaseField: aDatabaseField		databaseField := aDatabaseField</body><body package="GlorpMigration">newFieldName	^newFieldName</body><body package="GlorpMigration">newFieldName: aString	newFieldName := aString</body><body package="GlorpMigration">tableName	^self databaseField table name printString</body></methods><methods><class-id>Glorp.Migration.RenameField</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor		renameField: self databaseField		to: self newFieldName		ifError: self exceptionBlock</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'renameFieldNamed: ';		nextPutAll: self databaseField name printString;		space;		nextPutAll: 'inTableNamed: ';		nextPutAll: self databaseField table name printString;		space;		nextPutAll: 'to: ';		nextPutAll: self newFieldName printString;		nextPutAll: '.';		cr</body></methods><methods><class-id>Glorp.Migration.CreateTable</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession createTables: (OrderedCollection with: self databaseTable )</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		nextPutAll: ' createTableNamed: ';		nextPutAll: self tableName printString;		nextPutAll: '.';		cr.</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation</class-id> <category>accessing</category><body package="GlorpMigration">destination	^destination</body><body package="GlorpMigration">destination: anObject	destination := anObject</body><body package="GlorpMigration">source	^source</body><body package="GlorpMigration">source: anObject	source := anObject</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation</class-id> <category>testing</category><body package="GlorpMigration">isCalculated	^ false</body><body package="GlorpMigration">isScripted	^ false</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation</class-id> <category>initialize-release</category><body package="GlorpMigration">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation</class-id> <category>calculate changes</category><body package="GlorpMigration">calculateChangeSetOperations: aMigrationSet	self calculateChangesFor: aMigrationSet.	^aMigrationSet operations</body><body package="GlorpMigration">calculateChangesFor: aMigrationSet	^self subclassResponsibility</body></methods><methods><class-id>Glorp.Migration.CompositeMigrationOperation class</class-id> <category>instance creation</category><body package="GlorpMigration">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.CopyTableData</class-id> <category>accessing</category><body package="GlorpMigration">destinationTable	^destinationTable</body><body package="GlorpMigration">destinationTable: anObject	destinationTable := anObject</body></methods><methods><class-id>Glorp.Migration.CopyTableData</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession		aGlorpSession accessor		copyDataFromTable: self databaseTable		toTable: self destinationTable		ifError: self exceptionBlock</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'copyDataFromTableNamed: ';		nextPutAll: self tableName printString;		space;		nextPutAll: 'toTableNamed: ';		nextPutAll: self destinationTable name printString;		nextPut: $.;		cr</body></methods><methods><class-id>Glorp.Migration.PopulateField</class-id> <category>accessing</category><body package="GlorpMigration">databaseField	^databaseField</body><body package="GlorpMigration">databaseField: anObject	databaseField := anObject</body><body package="GlorpMigration">fieldName	^ self databaseField name</body><body package="GlorpMigration">fieldValue	^fieldValue</body><body package="GlorpMigration">fieldValue: anObject	fieldValue := anObject</body><body package="GlorpMigration">tableName	^self databaseField table name printString</body></methods><methods><class-id>Glorp.Migration.PopulateField</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	" Could a more appripriate (Glorp based) protocol than straight SQL be used here?"	aGlorpSession accessor		populateField: self databaseField		with: self fieldValue		ifError: self exceptionBlock</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'populateFieldNamed: ';		nextPutAll: self fieldName printString;		space;		nextPutAll: 'inTableNamed: ';		nextPutAll: self databaseField table name printString;		space;		nextPutAll: 'with: ';		nextPutAll: self fieldValue printString;		nextPut: $.;		cr.</body></methods><methods><class-id>Glorp.Migration.DropField</class-id> <category>accessing</category><body package="GlorpMigration">databaseField	^databaseField</body><body package="GlorpMigration">databaseField: anObject	databaseField := anObject</body><body package="GlorpMigration">exceptionBlock	"Do nothing if no such field exists."	^[:ex | ex]</body><body package="GlorpMigration">tableName	^self databaseField table name printString</body></methods><methods><class-id>Glorp.Migration.DropField</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor		dropFields: (Array with: self databaseField)		ifError: (aGlorpSession platform				migrationExceptionBlockFor: self				accessor: aGlorpSession accessor).</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'dropFieldNamed: ';		nextPutAll: self databaseField name printString;		space;		nextPutAll: 'fromTableNamed: ';		nextPutAll: self databaseField table name printString;		nextPutAll: '.';		cr.</body></methods><methods><class-id>Glorp.Migration.TableCopyForMigration</class-id> <category>accessing</category><body package="GlorpMigration">migrationCopy	^ self</body><body package="GlorpMigration">postMigrationCopy	"	Ensure that any collections that we might be operating upon during migration are copied	in order to protect the original database definition.	"	fields := fields copy.	foreignKeyConstraints := foreignKeyConstraints copy.	indexes := indexes copy.	lockKeyFields := lockKeyFields copy.	primaryKeyFields := primaryKeyFields copy</body></methods><methods><class-id>Glorp.Migration.CreatePrimaryKeyConstraint</class-id> <category>accessing</category><body package="GlorpMigration">constraint	^constraint</body><body package="GlorpMigration">constraint: anObject	constraint := anObject</body><body package="GlorpMigration">tableName	^self constraint table name printString</body></methods><methods><class-id>Glorp.Migration.CreatePrimaryKeyConstraint</class-id> <category>sorting</category><body package="GlorpMigration">weigh	^20</body></methods><methods><class-id>Glorp.Migration.CreatePrimaryKeyConstraint</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor		addConstraint: self constraint		ifError: (aGlorpSession platform				migrationExceptionBlockFor: self				accessor: aGlorpSession accessor).</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space.	self constraint primaryKeyFields size = 1		ifTrue: [aStream 					nextPutAll: 'setAsPrimaryKeyFieldNamed:  ', self constraint primaryKeyFields first name printString]		ifFalse: [aStream nextPutAll: 'setAsPrimaryKeyFieldsNamed:  #( '.				self constraint primaryKeyFields 					do: [ :each | aStream nextPutAll: each name printString] 					separatedBy: [aStream space].				aStream nextPut: $) ].	aStream			space;			nextPutAll: 'inTableNamed: ';			nextPutAll: self constraint  table name asUppercase printString;			space;			nextPut: $.;			cr</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>testing</category><body package="GlorpMigration">accept: aDatabaseField	^self databaseField name = aDatabaseField name		and: [self databaseField table name = aDatabaseField table name]</body><body package="GlorpMigration">isAlterField	^true</body><body package="GlorpMigration">isModified	^isNullable notNil		or: [ isUnique notNil			or: [ isLockKey notNil 				or: [ defaultValue notNil					or: [ type notNil 						or: [dropDefault notNil ]]]]]</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>accessing</category><body package="GlorpMigration">databaseField	^databaseField</body><body package="GlorpMigration">databaseField: anObject	databaseField := anObject</body><body package="GlorpMigration">defaultValue	^defaultValue</body><body package="GlorpMigration">dropDefault	^dropDefault</body><body package="GlorpMigration">dropDefaultValue	dropDefault := true</body><body package="GlorpMigration">fieldName	^self databaseField name printString</body><body package="GlorpMigration">isLockKey	^isLockKey</body><body package="GlorpMigration">isNullable	^isNullable</body><body package="GlorpMigration">isUnique	^isUnique</body><body package="GlorpMigration">setDefaultValueTo: anObject		defaultValue := anObject</body><body package="GlorpMigration">setNotNullable	isNullable := false</body><body package="GlorpMigration">setNullable	databaseField isPrimaryKey ifFalse: [ isNullable := true ]</body><body package="GlorpMigration">setTypeTo: aType		type := aType</body><body package="GlorpMigration">tableName	^self databaseField table name printString</body><body package="GlorpMigration">type	^type</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession platform applyAlterField: self InSession: aGlorpSession</body><body package="GlorpMigration">writeDefaultValueFor: argumentName on: aStream	defaultValue ifNotNil: 		[aStream			tab;			nextPutAll: argumentName;			space;			nextPutAll: 'setDefaultValueForFieldNamed: ';			nextPutAll: self fieldName;			space;			nextPutAll: 'inTableNamed: ';			nextPutAll: self tableName;			space;			nextPutAll: 'to: ';			nextPutAll: defaultValue printString;			nextPut: $.;			cr ].</body><body package="GlorpMigration">writeDropDefaultFor: argumentName on: aStream	dropDefault ifNotNil: 		[aStream			tab;			nextPutAll: argumentName;			space;			nextPutAll: 'dropDefaultValueForFieldNamed: ';			nextPutAll: self fieldName;			space;			nextPutAll: 'inTableNamed: ';			nextPutAll: self tableName;			nextPut: $.;			cr ].</body><body package="GlorpMigration">writeFor: argumentName on: aStream	self writeIsNullableFor: argumentName on: aStream.	self writeTypeFor: argumentName on: aStream.	self writeDropDefaultFor: argumentName on: aStream.	self writeDefaultValueFor: argumentName on: aStream.</body><body package="GlorpMigration">writeIsNullableFor: argumentName on: aStream	isNullable ifNotNil: [ :val |  		aStream tab.		val 			ifTrue: [aStream					nextPutAll: argumentName;					space;					nextPutAll: 'setNullableForFieldNamed: ';					nextPutAll: self fieldName;					space;					nextPutAll: 'inTableNamed: ';					nextPutAll: self tableName;					nextPut: $. ]			ifFalse: [aStream						nextPutAll: argumentName;						space;						nextPutAll: 'setNotNullableForFieldNamed: ';						nextPutAll: self fieldName;						space;						nextPutAll: 'inTableNamed: ';						nextPutAll: self tableName;						nextPut: $.].			aStream cr].</body><body package="GlorpMigration">writeTypeFor: argumentName on: aStream	type ifNotNil: 		[ aStream			tab;			nextPutAll: argumentName;			space;			nextPutAll: 'changeTypeForFieldNamed: ';			nextPutAll: self fieldName;			space;			nextPutAll: 'inTableNamed: ';			nextPutAll: self tableName;			space;			nextPutAll: 'to: ';			nextPutAll: '[ :dbplatform | dbplatform  ', type platformSelector, '].';			cr ].</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>validation</category><body package="GlorpMigration">validateModificationsFrom: sourceField sourceField: destField	(sourceField isTheSameTypeAs: destField) ifFalse: [type := destField type].	(sourceField isPrimaryKey not and: [destField isPrimaryKey not			and: [sourceField isNullable ~= destField isNullable]])				ifTrue: [isNullable := destField isNullable].	sourceField dbDefaultValue = destField dbDefaultValue ifFalse:		[destField dbDefaultValue ifNil: [dropDefault := true].		defaultValue := destField dbDefaultValue]."NOT SUPPORTED YET:  the rest of the column properties are platform dependent and should be calculated depending on database platform.	sourceField imDefaultValue = destField imDefaultValue ifFalse: [imDefaultValue := destField imDefaultValue].	sourceField isUnique = destField isUnique ifFalse: [isUnique := destField isUnique].	sourceField isLockKey = destField isLockKey ifFalse: [isLockKey := destField isLockKey]."</body></methods><methods><class-id>Glorp.Migration.AlterField</class-id> <category>sorting</category><body package="GlorpMigration">weigh	"We should alter a field before generating primary and foreign keys.  Thus we give this (not very well named) ordering method a value that ensures alter is processed earlier."	^18</body></methods><methods><class-id>Glorp.Migration.ExecuteSql</class-id> <category>accessing</category><body package="GlorpMigration">sqlString	^sqlString</body><body package="GlorpMigration">sqlString: anObject	sqlString := anObject</body></methods><methods><class-id>Glorp.Migration.ExecuteSql</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor doDDLOperation: [		aGlorpSession accessor executeSQLStringNoResult: self sqlString ]</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		nextPutAll: ' execute: ';		nextPutAll: self sqlString printString;		nextPut: $.;		cr.</body></methods><methods><class-id>Glorp.Migration.ExecuteSql</class-id> <category>initialize-release</category><body package="GlorpMigration">initialize	super initialize.	sqlString := nil.</body></methods><methods><class-id>Glorp.Migration.AddField</class-id> <category>accessing</category><body package="GlorpMigration">bePrimaryKey		databaseField ifNotNil: [databaseField bePrimaryKey]</body><body package="GlorpMigration">databaseField	^databaseField</body><body package="GlorpMigration">databaseField: anObject	databaseField := anObject</body><body package="GlorpMigration">fieldName	^ self databaseField name</body><body package="GlorpMigration">fieldType	^fieldType</body><body package="GlorpMigration">fieldType: anObject	fieldType := anObject</body><body package="GlorpMigration">tableName	^ self databaseField table name printString</body></methods><methods><class-id>Glorp.Migration.AddField</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor		addFields: (Array with: self databaseField)		ifError: (aGlorpSession platform				migrationExceptionBlockFor: self				accessor: aGlorpSession accessor).</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream tab.	databaseField isPrimaryKey ifTrue: [ aStream nextPut: $(].	aStream		nextPutAll: argumentName;		space;		nextPutAll: 'addFieldNamed: ';		nextPutAll: self fieldName printString;		space;		nextPutAll: 'toTableNamed: ';		nextPutAll: self databaseField table name printString.	databaseField isPrimaryKey ifTrue: [ aStream nextPutAll: ') bePrimaryKey'].	aStream 		nextPutAll: '.';		cr.</body></methods><methods><class-id>Glorp.Migration.AddField</class-id> <category>sorting</category><body package="GlorpMigration">weigh	^5</body></methods><methods><class-id>Glorp.Migration.CopyFieldData</class-id> <category>accessing</category><body package="GlorpMigration">fromField	^fromField</body><body package="GlorpMigration">fromField: anObject	fromField := anObject</body><body package="GlorpMigration">tableName	^ self toField table name</body><body package="GlorpMigration">toField	^toField</body><body package="GlorpMigration">toField: anObject	toField := anObject</body></methods><methods><class-id>Glorp.Migration.CopyFieldData</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor		copyDataFromField: self fromField		toField: self toField		ifError: self exceptionBlock.</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'copyDataFromFieldNamed: ';		nextPutAll: self fromField name printString;		space;		nextPutAll: 'toFieldNamed: ';		nextPutAll: self toField name printString;		space;		nextPutAll: 'inTableNamed: ';		nextPutAll: self tableName printString;		nextPut: $.;		cr</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations</class-id> <category>accessing</category><body package="GlorpMigration">selector		^selector</body><body package="GlorpMigration">selector: anObject		selector := anObject</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations</class-id> <category>printing</category><body package="GlorpMigration">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: source name;		nextPut: $-;		nextPutAll: selector;		nextPut: $-;		nextPutAll: destination name;		nextPut: $).</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations</class-id> <category>testing</category><body package="GlorpMigration">isScripted	^ true</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations</class-id> <category>calculate changes</category><body package="GlorpMigration">calculateChangesFor: aMigrationSet		aMigrationSet calculateChangesFor: aMigrationSet source usingScript: self selector</body></methods><methods><class-id>Glorp.Migration.ScriptedOperations class</class-id> <category>instance creation</category><body package="GlorpMigration">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.ScriptError class</class-id> <category>testing</category><body package="GlorpMigration">mayResume	^true</body></methods><methods><class-id>Glorp.Migration.MigrationError</class-id> <category>accessing</category><body package="GlorpMigration">messageText	| stream |	stream := WriteStream on: String new.	migrationOperation 		ifNotNil: [stream := WriteStream on: String new.				stream nextPutAll: 'Can not execute the script line: '; cr.				migrationOperation writeFor: 'migration' on: stream.				stream cr].	stream nextPutAll: (self class messageTextFrom: self).	^stream contents</body><body package="GlorpMigration">migrationOperation	^migrationOperation</body><body package="GlorpMigration">migrationOperation: anObject	migrationOperation := anObject</body></methods><methods><class-id>Glorp.Migration.MigrationError</class-id> <category>printing</category><body package="GlorpMigration">description	^self messageText</body></methods><methods><class-id>Glorp.Migration.MigrationError class</class-id> <category>accessing</category><body package="GlorpMigration">messageTextFrom: exception	| stream dbError exceptionParameter |		(exceptionParameter := exception parameter) ifNil: [^exception messageText].	stream := WriteStream on: String new.	dbError := (exceptionParameter isKindOf: Collection) 		ifTrue: [exceptionParameter  first] 		ifFalse: [(exceptionParameter isKindOf: Exception) ifTrue: [exceptionParameter] ifFalse: [^exception messageText] ].	((dbError isKindOf: (Dialect smalltalkAt: 'SpError' ifAbsent: [nil])) and: [dbError parameter notEmpty]) ifTrue: [dbError := dbError parameter first ].	(dbError isKindOf: ExternalDatabaseError)		ifTrue: [stream nextPutAll: exceptionParameter class name asString.				stream cr; nextPutAll: dbError dbmsErrorString]		ifFalse: [ stream nextPutAll: dbError messageText].	^stream contents</body></methods><methods><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id> <category>accessing</category><body package="GlorpMigration">constraint	^constraint</body><body package="GlorpMigration">constraint: aForeignKeyConstraint	constraint :=  aForeignKeyConstraint</body><body package="GlorpMigration">tableName	^constraint  sourceFields first table name printString</body></methods><methods><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id> <category>testing</category><body package="GlorpMigration">hasAddForeignKeyConstraintFor: aForeignKeyConstraint	^constraint  isSimilarForeignKeyConstraint:  aForeignKeyConstraint</body></methods><methods><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id> <category>sorting</category><body package="GlorpMigration">weigh	^25</body></methods><methods><class-id>Glorp.Migration.CreateForeignKeyConstraint</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor 		addConstraint: constraint 		ifError: self exceptionBlock</body><body package="GlorpMigration">writeFor: argumentName on: aStream		aStream			tab;			nextPutAll: argumentName;			space;			nextPutAll: 'addForeignKeyFromTable: ';			nextPutAll: constraint  sourceFields first table name asUppercase printString;			space.		(constraint  sourceFields size = 1 and: [constraint  targetFields size = 1])			ifTrue: [aStream						nextPutAll: 'fromField: ';						nextPutAll: constraint  sourceFields first name asUppercase printString]			ifFalse: [aStream nextPutAll: 'fromFields: #( '.					constraint  sourceFields do: [ :f | aStream nextPutAll:  f name asUppercase printString, ' ' ].					aStream nextPutAll: ' ) ' ].		aStream			space;			nextPutAll: 'toTable: ';			nextPutAll: constraint  targetFields first table name asUppercase printString;			space.		(constraint  sourceFields size = 1 and: [constraint  targetFields size = 1])			ifTrue: [aStream						nextPutAll: 'toField: ';						nextPutAll: constraint  targetFields first name asUppercase printString]			ifFalse: [aStream nextPutAll: 'toFields: #( '.					constraint  targetFields do: [ :f | aStream nextPutAll:  f name asUppercase printString, ' ' ].					aStream nextPutAll: ' )' ].		constraint   suffixExpression			ifNotNil: [ :exp |					aStream						space;						nextPutAll: ' suffixExpression: ';						nextPutAll: exp printString;						nextPut: $.].		aStream 			nextPut: $.;			cr</body></methods><methods><class-id>Glorp.Migration.CalculatedOperations</class-id> <category>testing</category><body package="GlorpMigration">isCalculated	^ true</body></methods><methods><class-id>Glorp.Migration.CalculatedOperations</class-id> <category>printing</category><body package="GlorpMigration">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: source name;		nextPutAll: '--';		nextPutAll: destination name;		nextPut: $).</body></methods><methods><class-id>Glorp.Migration.CalculatedOperations</class-id> <category>calculate changes</category><body package="GlorpMigration">calculateChangesFor: aMigrationSet	^aMigrationSet calculateOperations</body></methods><methods><class-id>Glorp.Migration.CalculatedOperations class</class-id> <category>instance creation</category><body package="GlorpMigration">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id> <category>accessing</category><body package="GlorpMigration">constraint	^constraint</body><body package="GlorpMigration">constraint: aForeignKeyConstraint	constraint  := aForeignKeyConstraint</body><body package="GlorpMigration">exceptionBlock	"Do nothing if no constraint exists."	^[:ex | ex]</body><body package="GlorpMigration">tableName	^constraint  sourceFields first table name printString</body></methods><methods><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor 		dropConstraint:  constraint  		ifError: self exceptionBlock</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'dropForeignKeyFromTable: ';		nextPutAll: constraint  sourceFields first table name asUppercase printString;		space.		constraint  sourceFields size = 1		ifTrue: [aStream					nextPutAll: 'forField: ';					nextPutAll: constraint  sourceFields first name asUppercase printString]		ifFalse: [aStream nextPutAll: 'forAllFields: #( '.				constraint  sourceFields do: [ :f | aStream nextPutAll:  f name asUppercase printString, ' ' ].				aStream nextPutAll: ' )' ].	aStream		nextPut: $.;		cr</body></methods><methods><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id> <category>testing</category><body package="GlorpMigration">hasDropForeignKeyConstraintFor: aForeignKeyConstraint	^constraint  isSimilarForeignKeyConstraint:  aForeignKeyConstraint</body></methods><methods><class-id>Glorp.Migration.DropForeignKeyConstraint</class-id> <category>sorting</category><body package="GlorpMigration">weigh	^10</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>accessing</category><body package="GlorpMigration">currentDestination	^currentDestination</body><body package="GlorpMigration">currentSource	^currentSource</body><body package="GlorpMigration">destination	^destination</body><body package="GlorpMigration">destination: anObject	destination := anObject</body><body package="GlorpMigration">destinationTableNamed: tableName	" Answer a table cached in destinationTables dictionary.	If absent, get it from the destination.	Use a migration copy so I don't mess up the original."	| tables |	tables := destinationTables at: self currentDestination class name ifAbsentPut: [Dictionary new].	^[tables		at: tableName asUppercase		ifAbsentPut: [ 			(self currentDestination				tableNamed: tableName				ifNone: [^ScriptError raiseRequestErrorString: ( 'Destination schema: &lt;1s&gt; . The table: &lt;2s&gt;  does not exist' expandMacrosWith: self currentDestination class name with: tableName)] ) 			migrationCopy ]	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: ( 'Destination schema: &lt;1s&gt; error: &lt;2s&gt;' expandMacrosWith: self currentDestination class name with:  ex messageText) ]</body><body package="GlorpMigration">fieldNamed: aString from: aTable	aTable ifNil: [^nil].	^aTable 		fieldNamed: aString  		ifAbsent: [ScriptError raiseRequestErrorString: ('The field named &lt;1s&gt; does not exist' expandMacrosWith: aString)]</body><body package="GlorpMigration">operations	^operations</body><body package="GlorpMigration">operations: anObject	operations := anObject</body><body package="GlorpMigration">source	^source</body><body package="GlorpMigration">source: anObject	source := anObject</body><body package="GlorpMigration">sourceTableNamed: tableName	" Answer a table cached in sourceTables dictionary.	If absent, get it from the source.	Use a migration copy so I don't mess up the original."	| tables |	tables := sourceTables at: self currentSource class name ifAbsentPut: [Dictionary new].	^[ tables		at: tableName asUppercase		ifAbsentPut: [ 					(self currentSource tableNamed: tableName 						ifNone: [^ScriptError raiseRequestErrorString: ( 'Source schema: &lt;1s&gt; . The table: &lt;2s&gt;  does not exist' expandMacrosWith: self currentSource class name with: tableName)] ) 					migrationCopy ]	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: ( 'Source schema: &lt;1s&gt; error: &lt;2s&gt;' expandMacrosWith: self currentSource class name with:  ex messageText)]</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>migrate</category><body package="GlorpMigration">applyInSession: aGlorpSession	self		whileInSession: aGlorpSession		do:  [ self basicApplyInSession: aGlorpSession ]</body><body package="GlorpMigration">applyInSourceSession	self applyInSession: self source session</body><body package="GlorpMigration">basicApplyInSession: aGlorpSession	self operations do: [ :each |		[ each applyInSession: aGlorpSession ]			on: Error			do: [ :ex | (MigrationError new							migrationOperation: each;							parameter: ex;							yourself) raise] ]</body><body package="GlorpMigration">whileInSession: aGlorpSession do: aBlock	| loggedIn |	(loggedIn := aGlorpSession isLoggedIn)		ifFalse: [ aGlorpSession login ].	^ aBlock ensure: [		loggedIn ifFalse: [ aGlorpSession logout ] ]</body><body package="GlorpMigration">whileInSourceSessionDo: aBlock	^ self		whileInSession: self source session		do: aBlock</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>calculate changes</category><body package="GlorpMigration">addCompositeOperation: aCompositeMigrationOperation from: sourceDescriptorSystem to: destinationDescriptorSystem	| changeSubSet |	changeSubSet := self 				newChangeSetFrom: (self getSystemFrom: sourceDescriptorSystem or: aCompositeMigrationOperation source) 				to: (self getSystemFrom: destinationDescriptorSystem or: aCompositeMigrationOperation destination).	^ operations		addAll: (aCompositeMigrationOperation calculateChangeSetOperations: changeSubSet );		yourself</body><body package="GlorpMigration">addOperation: aMigrationOperation	aMigrationOperation source: self currentSource.	aMigrationOperation destination: self currentDestination.	^ self operations add: aMigrationOperation</body><body package="GlorpMigration">calculateChangesFor: aDescriptorSystem usingScript: messageSelector 	| errors |	errors := OrderedCollection new.	[aDescriptorSystem		perform: messageSelector		with: self.	] on: Glorp.Migration.ScriptError do: [ :ex | errors add: ex. ex resume ].	errors notEmpty ifTrue: [^(Glorp.Migration.ScriptErrors errors: errors from: messageSelector) raiseSignal ].</body><body package="GlorpMigration">calculateMigrationScript	| scripts chains |	scripts := source class migrationPathWithScriptsTo: destination class.	scripts size = 1 ifTrue: [ 	^scripts first calculateChangeSetOperations: self].	chains := self calculateScriptChainsFrom: scripts.	chains do: [ :eachChain |		| firstStep lastStep |		firstStep := eachChain first.		lastStep := eachChain last.		" Yes I know I could use ifTrue:ifFalse: here, but in case we ended up with more types of steps,		successive ifTrue: seems like a better idea. "		firstStep isCalculated ifTrue: [			" all steps in the chain are calculated. It's a transitive operation, so let's set the first step's destination			to be the same as last step destination, and disregard all intermediate steps."			firstStep destination: lastStep destination.			self				addCompositeOperation: firstStep				from: source				to: destination ].		firstStep isScripted ifTrue: [			" all steps in the chain are scripted. Each of the scripts has its own set of operations that have to be			collected in the final change set (my operations). Iterate over the chain's steps. "			eachChain do: [ :eachStep |				self					addCompositeOperation: eachStep					from: source					to: destination] ] ]</body><body package="GlorpMigration">calculateOperations	^self		calculateOperationsFrom: self source		to: self destination</body><body package="GlorpMigration">calculateOperationsFrom: aSource to: aDestination	| fromTables toTables toDelete toAdd toModify |	fromTables := aSource allTables copy.	toTables := aDestination allTables copy.	toDelete := fromTables reject: [:each | 	toTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toAdd := toTables reject: [:each | 	fromTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toModify := fromTables reject: [:each | (toDelete includes: each) or: [toAdd includes: each]].	self createTables: toAdd.	self dropTables: toDelete.	toModify do: [:each |			| newVersion |			newVersion := aDestination tableNamed: each sqlString.			self calculateUpdateTableFrom: each to: newVersion].	operations := operations asSortedCollection: [:a :b | a weigh &lt;= b weigh].</body><body package="GlorpMigration">calculatePrimaryKeyOperationFrom: oldPrimaryConstraint to: newPrimaryConstraint forceRecreation: aBoolean		(oldPrimaryConstraint isNil and: [newPrimaryConstraint isNil]) 	ifTrue: [^nil].	(oldPrimaryConstraint notNil and: [newPrimaryConstraint isNil])		ifTrue: 	[^self dropPrimaryKeyFromTableNamed: oldPrimaryConstraint table name].	(oldPrimaryConstraint isNil and: [newPrimaryConstraint notNil])		ifTrue: [^self addPrimaryKeyConstraint: newPrimaryConstraint].	aBoolean | (oldPrimaryConstraint isTheSameAs: newPrimaryConstraint) not		ifTrue: [(self findAllForeignKeyConstraintsTo: oldPrimaryConstraint table in: source) do: [:each | self dropForeignKeyConstraint: each.].			self dropPrimaryKeyFromTableNamed: newPrimaryConstraint table name.			self addPrimaryKeyConstraint: newPrimaryConstraint.			(self findAllForeignKeyConstraintsTo: newPrimaryConstraint table in: destination)				do: [ :constraint |					self addForeignKeyConstraint: ((self 						newForeignKeyConstraintFor: constraint sourceFields						from: newPrimaryConstraint fields 						suffixExpression: constraint suffixExpression) 						name: constraint name; 						yourself).]]</body><body package="GlorpMigration">calculateScriptChainsFrom: migrationPathWithScripts	^ migrationPathWithScripts piecesCutWhere: [ :eachMigrationStep :next | eachMigrationStep class ~= next class ]</body><body package="GlorpMigration">calculateUpdateFieldFrom: sourceField to: destField	| changes |	changes := AlterField new databaseField: destField; yourself.	changes validateModificationsFrom: sourceField sourceField: destField.	changes isModified ifTrue: [self addOperation: changes].	^changes isModified</body><body package="GlorpMigration">calculateUpdateTableFrom: aTable to: newTable	"Calculate the migration change set between aTable and newTable"	| newFields deletedFields modifiedFields newConstraints deletedConstraints primaryKeyNeedsRecreating preservedFields originalModifiedFields |	newConstraints := newTable foreignKeyConstraints reject: [:each | aTable hasForeignKeyConstraintTheSameAs: each].	deletedConstraints := aTable foreignKeyConstraints reject: [:each | newTable hasForeignKeyConstraintTheSameAs: each].	newFields := newTable fields reject: [:each | aTable hasFieldNamed: each name].	deletedFields := aTable fields reject: [:each | newTable hasFieldNamed: each name].	"Possibly modified fields (they're not new fields)."	preservedFields := newTable fields reject: [:each | newFields includes: each].	"Fields whose names are preserved, but whose other attribute(s) have changed.	(Switching field names is treated as a major content change for each field.)"	modifiedFields := preservedFields select: [:each | self calculateUpdateFieldFrom: (aTable fieldNamed: each name) to: each.].	originalModifiedFields := modifiedFields collect: [:each | aTable fieldNamed: each name].	primaryKeyNeedsRecreating := newFields anySatisfy: [:each | newTable primaryKeyFields includes: each].	primaryKeyNeedsRecreating := primaryKeyNeedsRecreating or:		[deletedFields anySatisfy: [:each | aTable primaryKeyFields includes: each]].	primaryKeyNeedsRecreating := primaryKeyNeedsRecreating or:		[originalModifiedFields anySatisfy: [:each | aTable primaryKeyFields includes: each]].	self 		calculatePrimaryKeyOperationFrom: aTable primaryKeyConstraints  		to: newTable primaryKeyConstraints 		forceRecreation: primaryKeyNeedsRecreating.	self dropForeignKeyConstraints: deletedConstraints.	self dropFields: deletedFields.	self addFields: newFields.	self addForeignKeyConstraints:  newConstraints.</body><body package="GlorpMigration">findAllForeignKeyConstraintsTo: aTable in: aSchema	| foreignFields |	foreignFields := OrderedCollection new.	aSchema allTables do: [:table |		table foreignKeyConstraints do: [:constraint | 	(constraint refersToTable: aTable) ifTrue: [foreignFields add: constraint]]].	^foreignFields</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>printing</category><body package="GlorpMigration">asMigrationScriptOn: variableName	| stream |	stream := WriteStream on: String new.	self writeScriptOn: stream withArgument: variableName.	^stream contents</body><body package="GlorpMigration">generateDefaultMigrationScriptSource: methodSelector	| argumentName stream |	stream := WriteStream on: String new.	argumentName := 'aMigrationChangeSet'.	self		writeMethodHeaderFor: methodSelector withArgument: argumentName on: stream;		writePragmaOn: stream;		writeScriptOn: stream withArgument: argumentName.	^stream contents</body><body package="GlorpMigration">printOn: aStream		aStream nextPutAll: 'Migration set from:'.		source ifNotNil: [ aStream nextPutAll: source class name].	aStream nextPutAll: ' to:'.		destination ifNotNil: [aStream nextPutAll: destination class name].	operations ifNotNil: [aStream cr.						operations do: [ :op | op printOn: aStream]]</body><body package="GlorpMigration">writeMethodHeaderFor: methodSelector withArgument: argumentName on: aStream	aStream		nextPutAll: methodSelector;		space;		nextPutAll: argumentName;		cr</body><body package="GlorpMigration">writePragmaOn: aStream	aStream		tab;		nextPutAll: '&lt;', self source class migrationPragmaSelector, ' ', self destination class name printString, '&gt;' ;		cr</body><body package="GlorpMigration">writeScriptOn: aStream withArgument: argumentName	| sourceClass destinationClass |	destinationClass := destination class.	sourceClass := source class.	operations do: [ :eachOperation | 		(eachOperation source class ~= sourceClass			or: [eachOperation destination class ~= destinationClass])			ifTrue: [aStream 					crtab; 					nextPutAll: argumentName, ' operationsFrom: ', eachOperation source class  fullName printString; 					nextPutAll: ' to: ', eachOperation destination class  fullName printString, '.'; 					cr.				sourceClass := eachOperation source class.				destinationClass := eachOperation destination class ].		eachOperation writeFor: argumentName on: aStream ]</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>initialize-release</category><body package="GlorpMigration">from: sourceSystemDescriptor to: destinationSystemDescriptor	source := sourceSystemDescriptor.	destination := destinationSystemDescriptor.	currentDestination := destinationSystemDescriptor.	currentSource := sourceSystemDescriptor</body><body package="GlorpMigration">initialize	operations := OrderedCollection new.	sourceTables := Dictionary new.	destinationTables := Dictionary new.</body><body package="GlorpMigration">newChangeSetFrom: aSource to: aDestination	^ self species new		from: aSource to: aDestination;		yourself.</body><body package="GlorpMigration">operationsFrom: sourceSchemaString to: destinationSchemaString		(currentSource class fullName = sourceSchemaString		and: [currentDestination class fullName = destinationSchemaString]) ifTrue: [^nil ].	currentDestination := destinationSchemaString asSymbol asQualifiedReference valueOrDo: [^self error: ( 'There is no qualified reference for:  &lt;1s&gt;' expandMacrosWith: destinationSchemaString)].	currentDestination := currentDestination forPlatform: destination platform.	destination session system: currentDestination.	currentSource := sourceSchemaString asSymbol asQualifiedReference valueOrDo: [^self error: ( 'There is no qualified reference for:  &lt;1s&gt;' expandMacrosWith: sourceSchemaString)].	currentSource := currentSource forPlatform: source platform.	source session system: currentSource.</body><body package="GlorpMigration">resetOperations	operations := OrderedCollection new</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - alter field</category><body package="GlorpMigration">changeTypeForFieldNamed: fieldName inTableNamed: sourceTableName to: aBlockOrGlorpDatabaseType"Changes the database field type. aBlockOrGlorpDatabaseType parameter can be  GlorpDatabaseType or Block. The block should return an object of GlorpDatabaseType"	^[ self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #setTypeTo:		value: (aBlockOrGlorpDatabaseType isGlorpType 					ifTrue: [aBlockOrGlorpDatabaseType] 					ifFalse: [aBlockOrGlorpDatabaseType value: source platform])	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #changeTypeForFieldNamed:inTableNamed:to: ', ex messageText].</body><body package="GlorpMigration">dropDefaultValueForFieldNamed: fieldName inTableNamed: sourceTableName "Drops the  database field default value in the table"	^ [self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #dropDefaultValue		value: nil		] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #dropDefaultValueForFieldNamed:inTableNamed:to: ', ex messageText].</body><body package="GlorpMigration">setDefaultValueForFieldNamed: fieldName inTableNamed: sourceTableName to: anObject"Sets the  database field default value in the table"	^ [self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #setDefaultValueTo:		value: anObject		] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #setDefaultValueForFieldNamed:inTableNamed:to: ', ex messageText].</body><body package="GlorpMigration">setNotNullableForFieldNamed: fieldName inTableNamed: sourceTableName "Sets NOT NULL for the database field  in the table"	^[ self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #setNotNullable		value: nil	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #setNotNullableForFieldNamed:inTableNamed:to: ', ex messageText].</body><body package="GlorpMigration">setNullableForFieldNamed: fieldName inTableNamed: sourceTableName "Sets NULL for the database field  in the table"	^[ self		alterFieldNamed: fieldName 		in: sourceTableName		attribute: #setNullable		value: nil	] on: Error do: [ :ex | ScriptError raiseRequestErrorString: 'Error in #setNullableForFieldNamed:inTableNamed:to: ', ex messageText].</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - add/drop field</category><body package="GlorpMigration">addField: aDatabaseField"Adds a database field to a table. The parameter has to be Glorp.DatabaseField "	aDatabaseField ifNil: [^nil].	(aDatabaseField isKindOf: DatabaseField) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in #addField: parameter' ].	^self addOperation: (AddField new							databaseField: aDatabaseField;							yourself)</body><body package="GlorpMigration">addFieldNamed: fieldName toTable: aDatabaseTable"Adds a database field with the specified name to a table. The first parameter is a string, the second one is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #addFieldNamed:toTable: second parameter'].	^ self addField: (self fieldNamed: fieldName from: aDatabaseTable)</body><body package="GlorpMigration">addFieldNamed: fieldName toTableNamed: tableName"Adds a database field to a table. Both parameters are strings "	^ self addFieldNamed: fieldName toTable:  (self destinationTableNamed: tableName)</body><body package="GlorpMigration">addFields: aCollection"Adds a database fields to a table. The parameter has to be a collection of  Glorp.DatabaseField "	aCollection do: [ :eachField | self addField: eachField ]</body><body package="GlorpMigration">createFieldNamed: fieldName type: aBlockOrGlorpDatabaseType inTableNamed: tableName "Creates a new database field in a table."	^self 		createFieldNamed: fieldName 		type: aBlockOrGlorpDatabaseType		inTableNamed: tableName		with: nil</body><body package="GlorpMigration">createFieldNamed: fieldName type: aBlockOrGlorpDatabaseType inTableNamed: tableName with: aBlock"Creates a new database field in a table. The type parameter has to be GlorpDatabaseType object or a Block. The block should return an object of GlorpDatabaseType . The database field will be passed to aBlock to allow changing the field attributes"	| newField |	[newField :=  (self destinationTableNamed: tableName)					createFieldNamed: fieldName					type:  (aBlockOrGlorpDatabaseType isGlorpType 							ifTrue: [aBlockOrGlorpDatabaseType] 							ifFalse: [aBlockOrGlorpDatabaseType value: source platform]).	aBlock ifNotNil: [ :theBlock | 	theBlock cull: newField ].		] on: Error do: [ :ex | ^ScriptError raiseRequestErrorString: ex messageText].	^ self addField: newField</body><body package="GlorpMigration">dropField: aDatabaseField"Drops a database field to a table. The parameter has to be Glorp.DatabaseField "	aDatabaseField ifNil: [^nil].	(aDatabaseField isKindOf: DatabaseField) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in #dropField: parameter'].	^ self addOperation: (DropField new							databaseField: aDatabaseField;							yourself)</body><body package="GlorpMigration">dropFieldNamed: fieldName fromTable: aDatabaseTable"Drops a database field from a table. The first parameter is a string, the second one is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #dropFieldNamed:fromTable: second parameter'].	^self dropField: (self fieldNamed: fieldName from: aDatabaseTable)</body><body package="GlorpMigration">dropFieldNamed: fieldName fromTableNamed: sourceTableName"Drops a database field from a table. Both parameters are strings "	^ self		dropFieldNamed: fieldName		fromTable: (self sourceTableNamed: sourceTableName)</body><body package="GlorpMigration">dropFields: aCollection"Drops a database fields from a table. The parameter has to be a collection of  Glorp.DatabaseField "	aCollection do: [ :eachField | self dropField: eachField ]</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - add/drop foreign key</category><body package="GlorpMigration">addForeignKeyConstraint: aForeignKeyConstraint"Adds a database foreign key constraints to a table. The parameter has to be Glorp.ForeignKeyConstraint "	(aForeignKeyConstraint isKindOf: ForeignKeyConstraint) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.ForeignKeyConstraint object in #addForeignKeyConstraint: parameter' ].	(self operations detect:[ :op | op hasAddForeignKeyConstraintFor: aForeignKeyConstraint ] ifNone: [nil]) notNil ifTrue: [^nil].	^ self addOperation: (CreateForeignKeyConstraint new							constraint: aForeignKeyConstraint;							yourself)</body><body package="GlorpMigration">addForeignKeyConstraints: collForeignKeyConstraints"Adds database foreign key constraints to a table. The parameter is a collection of Glorp.ForeignKeyConstraint"	collForeignKeyConstraints do: [ :each | self addForeignKeyConstraint:  each ]</body><body package="GlorpMigration">addForeignKeyFromTable: sourceTable fromAllFields: collSourceFieldNames toTable: targetTable toAllFields: collTargetFieldNames suffixExpression: expString"Adds a database foreign key constraints from sourceTable fields to targetTable fields. All parameters are strings"	| constraint table sourceFields dtable targetFields |	(table := self sourceTableNamed: sourceTable) ifNil: [^nil].	sourceFields := OrderedCollection new.	collSourceFieldNames do: [ :fname | sourceFields add: ((self fieldNamed: fname from: table) ifNil: [^nil] )].	(dtable := self destinationTableNamed: targetTable) ifNil: [^nil].	targetFields := OrderedCollection new.	collTargetFieldNames do: [	:fname | targetFields add: ((self fieldNamed: fname from: dtable)  ifNil: [^nil])].	[constraint := table 					addForeignKeyFromAll: sourceFields 					toAll: targetFields					suffixExpression: expString.	] on: Error do: [ :ex | ^ScriptError raiseRequestErrorString: ex messageText].	^self addForeignKeyConstraint: constraint</body><body package="GlorpMigration">addForeignKeyFromTable: sourceTableName fromField: sourceFieldName toTable: targetTableName toField: targetFieldName"Adds a database foreign key constraints from sourceTable fields to targetTable fields. All parameters are strings"	^self 		addForeignKeyFromTable: sourceTableName 		fromField: sourceFieldName 		toTable: targetTableName 		toField: targetFieldName 		suffixExpression: nil</body><body package="GlorpMigration">addForeignKeyFromTable: sourceTableName fromField: sourceFieldName toTable: targetTableName toField: targetFieldName suffixExpression: expString		^self		addForeignKeyFromTable: sourceTableName		fromFields: (OrderedCollection with: sourceFieldName)		toTable: targetTableName		toFields: (OrderedCollection with: targetFieldName)		suffixExpression: expString</body><body package="GlorpMigration">addForeignKeyFromTable: sourceTable fromFields: collSourceFieldNames toTable: targetTable toFields: collTargetFieldNames		^self addForeignKeyFromTable: sourceTable fromFields: collSourceFieldNames		toTable: targetTable toFields: collTargetFieldNames suffixExpression: nil</body><body package="GlorpMigration">addForeignKeyFromTable: aTable fromFields: sourceFieldNames toTable: refTable toFields: targetFieldNames suffixExpression: expString"Adds a database foreign key constraints from sourceTable fields to targetTable fields. All parameters are strings"	| constraint table sourceFields dtable targetFields newFK |	(table := self destinationTableNamed: aTable) ifNil: [^nil].	sourceFields := OrderedCollection new.	sourceFieldNames do: [ :fname | sourceFields add: ((self fieldNamed: fname from: table) ifNil: [^nil] )].	(dtable := self destinationTableNamed: refTable) ifNil: [^nil].	targetFields := OrderedCollection new.	targetFieldNames do: [	:fname | targetFields add: ((self fieldNamed: fname from: dtable)  ifNil: [^nil])].	(sourceFields size ~=  targetFields size) 		ifTrue: [^ScriptError raiseRequestErrorString: ( 'Can not create ForeignKeyConstraint for: &lt;1s&gt; from: &lt;2s&gt;. Number ofreferencing columns must match referenced columns' expandMacrosWith: sourceFieldNames printString with: targetFieldNames printString)  ].	newFK := self newForeignKeyConstraintFor: sourceFields from: targetFields suffixExpression: expString.	[constraint := table foreignKeyConstraints 		detect: [ :each |  each isSimilarForeignKeyConstraint: newFK ] 		ifNone: [table 					addForeignKeyFromAll: sourceFields 					toAll: targetFields					suffixExpression: expString]	] on: Error do: [ :ex | ^ScriptError raiseRequestErrorString: ex messageText].	^self addForeignKeyConstraint: constraint</body><body package="GlorpMigration">dropForeignKeyConstraint: aForeignKeyConstraint"Drops a database foreign key constraints from a table. The parameter has to be Glorp.ForeignKeyConstraint "	(aForeignKeyConstraint isKindOf: ForeignKeyConstraint) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.ForeignKeyConstraint object in #dropForeignKeyConstraint: parameter' ].		(self operations detect:[ :op | op hasDropForeignKeyConstraintFor: aForeignKeyConstraint ] ifNone: [nil]) notNil ifTrue: [^nil].		^ self addOperation: (DropForeignKeyConstraint new							constraint: aForeignKeyConstraint;							yourself)</body><body package="GlorpMigration">dropForeignKeyConstraints: collForeignKeyConstraints"Drops database foreign key constraints from a table. The parameter has to be a collection of Glorp.ForeignKeyConstraint "	 collForeignKeyConstraints do: [ :each | self dropForeignKeyConstraint: each ]</body><body package="GlorpMigration">dropForeignKeyFromTable: sourceTableName forAllFields: collFieldNames"Drops a database foreign key constraints from a table for the fields. #sourceTableName parameter is a string. #collFieldNames is collection of strings"	| constraints table |	(table := self sourceTableNamed: sourceTableName) ifNil: [^nil].	constraints := OrderedCollection new.	[collFieldNames 		do: [ :sf | (table foreignKeyConstraintsForField: (self fieldNamed: sf from: table)) 					ifNotNil: [ :coll | constraints addAll: coll ]].	] on: Error do: [ :ex | ^ScriptError raiseRequestErrorString: ex messageText].	self dropForeignKeyConstraints: constraints</body><body package="GlorpMigration">dropForeignKeyFromTable: sourceTableName forField: sourceFieldName"Drops a database foreign key constraints from a table for the field. Both parameters are strings"	self dropForeignKeyFromTable: sourceTableName forAllFields: (OrderedCollection with: sourceFieldName)</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - create/drop table</category><body package="GlorpMigration">createTable: aDatabaseTable"Creates the database table. The parameter is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #createTable: parameter' ].		^self addOperation:		(CreateTable new			databaseTable: aDatabaseTable migrationCopy;				yourself)</body><body package="GlorpMigration">createTableNamed: destinationTableName"Creates the database table. The parameter is a string "	^self createTable: (self destinationTableNamed: destinationTableName)</body><body package="GlorpMigration">createTables: aCollection"Creates database tables. The parameter is collection of Glorp.DatabaseTable "		aCollection do: [ :each | self createTable: each ]</body><body package="GlorpMigration">createTablesNamed: aCollection"Creates database tables. The parameter is a collection of strings "	aCollection do: [ :eachName | self createTableNamed: eachName ]</body><body package="GlorpMigration">dropTable: aDatabaseTable"Drops the database table. The parameter is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #dropTable: parameter' ].			^self addOperation: (DropTable new		databaseTable: aDatabaseTable migrationCopy;		yourself)</body><body package="GlorpMigration">dropTableNamed: tableName"Drops the database table. The parameter is a string "	^ self dropTable: (self sourceTableNamed: tableName)</body><body package="GlorpMigration">dropTables: aCollection"Drops database tables. The parameter is collection of Glorp.DatabaseTable "		aCollection do: [ :each | self dropTable: each ]</body><body package="GlorpMigration">dropTablesNamed: aCollection"Drops database tables. The parameter is collection of strings "		aCollection do: [ :each | self dropTableNamed: each ]</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - copy/add data</category><body package="GlorpMigration">copyDataFromField: fromDatabaseField toField: toDatabaseField "Copies database field data to another field. The parameters are Glorp.DatabaseField "	(fromDatabaseField isNil or: [toDatabaseField isNil]) ifTrue: [^nil].	((fromDatabaseField isKindOf: DatabaseField) 		and: [toDatabaseField isKindOf: DatabaseField])		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in #copyDataFromField:toField: parameters' ].	^ self addOperation: (CopyFieldData new		fromField: fromDatabaseField;		toField: toDatabaseField;		yourself)</body><body package="GlorpMigration">copyDataFromFieldNamed: fromFieldName toFieldNamed: toFieldName inTableNamed: tableName"Copies database field data to another field. The parameters are strings"	 self		copyDataFromField: (self fieldNamed: fromFieldName from: (self sourceTableNamed: tableName))		toField:  (self fieldNamed: toFieldName from: (self destinationTableNamed: tableName))</body><body package="GlorpMigration">copyDataFromTable: fromDatabaseTable toTable: toDatabaseTable"Copies database table data to another table. The parameters are Glorp.DatabaseTable "	(fromDatabaseTable isNil or: [ toDatabaseTable isNil]) ifTrue: [^nil].	((fromDatabaseTable isKindOf: DatabaseTable) 		and: [toDatabaseTable isKindOf: DatabaseTable])		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #copyDataFromTable:toTable: parameters' ].	^ self addOperation: (CopyTableData new		databaseTable: fromDatabaseTable;		destinationTable: toDatabaseTable;		yourself)</body><body package="GlorpMigration">copyDataFromTableNamed: fromTableName toTableNamed: toTableName"Copies database table data to another table. The parameters are strings "	^ self		copyDataFromTable: (self sourceTableNamed: fromTableName)		toTable: (self destinationTableNamed: toTableName)</body><body package="GlorpMigration">populateField: aDatabaseField with: aValue"Populates database field with data. The first parameter is Glorp.DatabaseField. aValue has to match the database field type "	aDatabaseField ifNil: [^nil].	(aDatabaseField isKindOf: DatabaseField) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in populateField:with: parameters' ].	^ self addOperation: (PopulateField new		databaseField: aDatabaseField;		fieldValue: aValue;		yourself)</body><body package="GlorpMigration">populateFieldNamed: fieldName inTableNamed: tableName with: aValue"Populates database field with data. The first two parameters are strings. aValue has to match the database field type "	^ self		populateField: (self fieldNamed: fieldName from: (self destinationTableNamed: tableName))		with: aValue</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - add/drop primary key</category><body package="GlorpMigration">addPrimaryKeyConstraint: aPrimaryKeyConstraint"Adds a database primary key constraints to a table. The parameter has to be Glorp.PrimaryKeyConstraint "	(aPrimaryKeyConstraint isKindOf: PrimaryKeyConstraint) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.PrimaryKeyConstraint object in #addPrimaryKeyConstraint: parameter' ].	^self addOperation:(CreatePrimaryKeyConstraint new							constraint: aPrimaryKeyConstraint;							yourself )</body><body package="GlorpMigration">dropPrimaryKeyFromTableNamed: sourceTableName"Drops database primary key constraints from a table. The parameter is string"	|  table |	(table := self sourceTableNamed: sourceTableName) ifNil: [^nil].	table hasPrimaryKeyConstraints ifFalse: [^ScriptError raiseRequestErrorString: ('Drop Primary keys error: There is no primary keys in the table &lt;1s&gt;' expandMacrosWith: sourceTableName )].	self addOperation:(DropPrimaryKeyConstraint new						databaseTable: table;						yourself)</body><body package="GlorpMigration">setAsPrimaryKeyFieldNamed: sourceFieldName inTableNamed: sourceTableName"Adds the field to a primary key constraints in the table. Both parameters are strings"	self setAsPrimaryKeyFieldsNamed: (OrderedCollection with: sourceFieldName)  inTableNamed: sourceTableName</body><body package="GlorpMigration">setAsPrimaryKeyFieldsNamed: collSourceFieldNames inTableNamed: sourceTableName 	"Adds the fields to primary key constraints in the table. Both parameters are strings"	|  table fields |	(table := self sourceTableNamed: sourceTableName) ifNil: [^nil].	fields := collSourceFieldNames collect:		[:each || field |		(field := self fieldNamed: each from: table) ifNil: [^nil].		(field isPrimaryKey and:			[(self operations anySatisfy:				[:operation | operation hasDropPrimaryKeyConstraintForFor: field table]) not])			ifTrue: [^ScriptError raiseRequestErrorString: ('The field &lt;1s&gt; is already the primary key in the table &lt;2s&gt;' expandMacrosWith: each with: sourceTableName)].		field].	"Ensure that the pkey fields are not nullable."	fields do: [:aField | aField isNullable ifTrue: [self setNotNullableForFieldNamed: aField name inTableNamed: aField table name]].	self addPrimaryKeyConstraint: (PrimaryKeyConstraint forTable: table fields: fields).</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - execute sql</category><body package="GlorpMigration">execute: sqlString"Executes the SQL statement. The parameter is string" 	sqlString isEmpty ifTrue: [^nil].	^ self addOperation: (ExecuteSql new		sqlString: sqlString;		yourself)</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>api - rename</category><body package="GlorpMigration">renameField: aDatabaseField to: newFieldName"Renames a database field to newFieldName. The first parameter is Glorp.DatabaseField "	aDatabaseField ifNil: [^nil].	(aDatabaseField isKindOf: DatabaseField) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseField object in #renameField:to: parameter' ].	^ self addOperation: (RenameField new		databaseField: aDatabaseField;		newFieldName: newFieldName;		yourself)</body><body package="GlorpMigration">renameFieldNamed: oldFieldName inTableNamed: tableName to: newFieldName"Renames a database field to newFieldName in the table. All parameters are strings "	^ self		renameField: ( self fieldNamed:oldFieldName from: (self sourceTableNamed: tableName))		to: newFieldName</body><body package="GlorpMigration">renameTable: aDatabaseTable to: newTableName"Renames the database table  to newTableName. The parameter is Glorp.DatabaseTable "	aDatabaseTable ifNil: [^nil].	(aDatabaseTable isKindOf: DatabaseTable) 		ifFalse: [^ScriptError raiseRequestErrorString: 'Expected Glorp.DatabaseTable object in #renameTable:to: parameter' ].		^ self addOperation: (RenameTable new		databaseTable: aDatabaseTable;		newTableName: newTableName;		yourself)</body><body package="GlorpMigration">renameTableNamed: oldTableName to: newTableName"Renames the database table to newTableName. All parameters are strings "	^ self		renameTable: (self sourceTableNamed: oldTableName)		to: newTableName</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet</class-id> <category>private</category><body package="GlorpMigration">alterFieldNamed: fieldName in: tableName attribute: aSymbol value: anObject	| operation aDatabaseField table |	(table := self sourceTableNamed: tableName) ifNil: [^nil].	(aDatabaseField := self fieldNamed: fieldName from: table) ifNil: [^nil].	operation := self operations 					detect: [ :op | op isAlterField and: [op accept: aDatabaseField]] 					ifNone: [self addOperation: (AlterField new databaseField: aDatabaseField; yourself )].	anObject		ifNil: [operation perform: aSymbol]		ifNotNil: [operation perform: aSymbol with: anObject ]</body><body package="GlorpMigration">getSystemFrom: aDescriptorSystem or: aDescriptorClass	^ aDescriptorClass = aDescriptorSystem class		ifTrue: [aDescriptorSystem]		ifFalse: [ (aDescriptorClass sessionForLogin: aDescriptorSystem session currentLogin) system]</body><body package="GlorpMigration">newForeignKeyConstraintFor: sourceFields from: targetFields suffixExpression: suffixExpression	^ForeignKeyConstraint		sourceFields: sourceFields		targetFields: targetFields 		suffixExpression:  suffixExpression</body></methods><methods><class-id>Glorp.Migration.MigrationChangeSet class</class-id> <category>instance creation</category><body package="GlorpMigration">from: sourceSystemDescriptor to: destinationSystemDescriptor	^ self new		from: sourceSystemDescriptor to: destinationSystemDescriptor;		yourself</body><body package="GlorpMigration">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.Migration.CalculatingChangeSetError</class-id> <category>accessing</category><body package="GlorpMigration">destination	^destination</body><body package="GlorpMigration">destination: anObject	destination := anObject</body><body package="GlorpMigration">source	^source</body><body package="GlorpMigration">source: anObject	source := anObject</body></methods><methods><class-id>Glorp.Migration.DropTable</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	| system |	aGlorpSession accessor dropTable: self databaseTable  ifError: self exceptionBlock.	system := aGlorpSession system.	system platform areSequencesExplicitlyCreated ifTrue:		[(system allSequencesFor: (OrderedCollection with:  self databaseTable)) do:			[:each | aGlorpSession accessor						dropSequence: each						ifAbsent: [:ex | ex]]]. "so we can insert a breakpoint"</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		nextPutAll: ' dropTableNamed: ';		nextPutAll: self tableName printString;		nextPutAll: '.';		cr.</body></methods><methods><class-id>Glorp.Migration.RenameTable</class-id> <category>accessing</category><body package="GlorpMigration">newTableName	^newTableName</body><body package="GlorpMigration">newTableName: anObject	newTableName := anObject</body></methods><methods><class-id>Glorp.Migration.RenameTable</class-id> <category>api</category><body package="GlorpMigration">applyInSession: aGlorpSession	aGlorpSession accessor		renameTable:  self databaseTable		to: self newTableName		inPlatform: self databasePlatform		ifError: self exceptionBlock</body><body package="GlorpMigration">writeFor: argumentName on: aStream	aStream		tab;		nextPutAll: argumentName;		space;		nextPutAll: 'renameTableNamed: ';		nextPutAll: self tableName printString;		space;		nextPutAll: 'to: ';		nextPutAll: self newTableName printString;		nextPutAll: '.';		cr</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>api</category><body package="GlorpMigration">applyAlterField: anAlterField InSession: aGlorpSession	"Combine the [NOT] NULL change with the type change because MS-SQLServer requires both type and NULL together.  Changing DEFAULT means first dropping the existing constraint, if any, and then adding the new one.  Currently, changing/dropping the default value is unsupported with SQL Server.  Note that SQL Server will return an error for NULL primary key column def."	| accessor |	accessor := aGlorpSession accessor.	((anAlterField isNullable notNil) or: [anAlterField type notNil]) ifTrue:		[|tempField |		tempField := anAlterField databaseField copy.		anAlterField type ifNotNil: [:val | tempField type: val].		tempField isPrimaryKey ifTrue: [tempField beNullable: false].		anAlterField isNullable ifNotNil: [:val | tempField beNullable: val].		tempField isNullable			ifTrue: [accessor alterFieldDropNotNull: tempField ifError: anAlterField exceptionBlock]			ifFalse: [accessor alterFieldSetNotNull: tempField ifError: anAlterField exceptionBlock]].</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services columns</category><body package="GlorpMigration">printSqlStatementToRenameColumn: oldColumn to: newColumnName on: aStream	" SQL Server statement is	sp_rename &lt;schema.table.oldColumn&gt;, &lt;newColumn&gt;, 'COLUMN'."		| oldColumnName |	oldColumnName := (self ddlTableNameFor: oldColumn table) , '.'		, (self nameForColumn: oldColumn name).	^self		sp_renameFrom: oldColumnName		to: (self nameForColumn: newColumnName)		type: 'COLUMN'		on: aStream</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services tables</category><body package="GlorpMigration">printSqlStatementToRenameTable: aDatabaseTable to: newTableName on: aStream	" SQL Server statement is	sp_rename &lt;oldTableName&gt;, &lt;newTableName&gt;, 'OBJECT'."	^self sp_renameFrom: (self ddlTableNameFor: aDatabaseTable) to: newTableName type: 'OBJECT' on: aStream</body><body package="GlorpMigration">sp_renameFrom: oldName to: newName type: aType on: aStream	" SQL Server statement is	sp_rename &lt;oldTableName&gt;, &lt;newTableName&gt;, 'OBJECT'.	Tables are OBJECTs, Columns are type COLUMN."	aStream		nextPutAll: 'sp_rename ';		nextPutAll: oldName printString;		nextPutAll: ', ';		nextPutAll: newName printString;		nextPutAll: ', ';		nextPutAll: aType printString</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>testing</category><body package="GlorpMigration">isGlorpType	^true</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration">calculateSynchronizeChangeSetFor: aCollection"The method calculates a change set between database tables and this descriptor and applies the changes to the database"	| systemFromDB migrationChangeSet |	systemFromDB := self databaseCopyWithTables: aCollection.	migrationChangeSet := Glorp.Migration.MigrationChangeSet from: systemFromDB to: self.	^ migrationChangeSet		calculateOperations;		yourself</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>private</category><body package="GlorpMigration">databaseCopyWithTables: aCollection	^ ActiveRecordDescriptorSystem new		getSessionAndPlatformFrom: self;		readTablesFromDatabase: (aCollection collect: [ :eachTable | eachTable name ]);		yourself.</body><body package="GlorpMigration">getSessionAndPlatformFrom: aDescriptorSystem	self		session: aDescriptorSystem session;		platform: aDescriptorSystem platform;		useDirectAccessForMapping: aDescriptorSystem useDirectAccessForMapping;		useJoinsForAnySatisfy: aDescriptorSystem useJoinsForAnySatisfy</body><body package="GlorpMigration">readTablesFromDatabase: tableNames	tableNames do: [ :eachName |		(self tableNamedFromDatabase: eachName) ifNotNil: [ :databaseTable |			tables at: eachName asUppercase put: databaseTable ] ].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>api-migration</category><body package="GlorpMigration">migrationCopy	^ (self copy changeClassTo: Glorp.Migration.TableCopyForMigration) postMigrationCopy</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>api</category><body package="GlorpMigration">applyAlterField: anAlterField InSession: aGlorpSession	"The migration change mechanism generates a series of discrete changes to the field.  But some DB platforms (eg., MySQL) require complete column specification for any change.  This method places all the changes into a single 'alter' statement.  Piecewise, each successive statement would undo the previous one."		| accessor newField |	anAlterField isModified ifFalse: [^self].	accessor := aGlorpSession accessor.	newField := anAlterField databaseField copy.	anAlterField dropDefault ifNotNil: [newField dbDefaultValue: nil].	anAlterField defaultValue ifNotNil: [:val | newField dbDefaultValue: anAlterField defaultValue].	anAlterField type ifNotNil: [:val | newField type: val].	anAlterField isNullable ifNotNil: [:val | newField beNullable: val].	"Write the change(s) to the DB by generating an 'alter' statement.	Use nullable attribute, whether it's changed or not, since any will do."	newField isNullable		ifTrue: [accessor				alterFieldDropNotNull: newField				ifError: anAlterField exceptionBlock]		ifFalse: [accessor				alterFieldSetNotNull: newField				ifError: anAlterField exceptionBlock].</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services columns</category><body package="GlorpMigration">createAlterColumnStatement: aField newType: aType usingExpression: expression	"With CHANGE COLUMN, MySQL requires the OLD and NEW column names, even if you're just changing the type.	There is no USING clause, so nonNil expression may need to be examined further."		| newField sqlStatementStream |	newField := aField copy.	newField type: aType.	sqlStatementStream := WriteStream on: String new.	self printSqlStatementToAlterColumn: aField to: newField on:			sqlStatementStream.	^sqlStatementStream contents</body><body package="GlorpMigration">createAlterColumnStatementDropNotNull: aField	| newField sqlStatementStream |	newField := aField copy.	newField beNullable: true.	sqlStatementStream := WriteStream on: String new.	self printSqlStatementToAlterColumn: aField to: newField on:			sqlStatementStream.	^sqlStatementStream contents</body><body package="GlorpMigration">createAlterColumnStatementSetNotNull: aField	"MySQL uses CHANGE oldName newName type spec instead of: ALTER COLUMN...TYPE."		| newField sqlStatementStream |	newField := aField copy.	newField beNullable: false.	sqlStatementStream := WriteStream on: String new.	self printSqlStatementToAlterColumn: aField to: newField on:			sqlStatementStream.	^sqlStatementStream contents</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services constraints</category><body package="GlorpMigration">createConstraintDropStatement: aConstraint	"MySQL is apparently case-sensitive when dropping constraint names.	The constraints that we create are typically uppercase, but the constraint names we read	from the meta descriptors tend to be lowercase (for some reason)."	| aStream |	aConstraint shouldCreateInDatabase ifFalse: [^''].	aStream := WriteStream on: (String new: 50).	aStream nextPutAll: 'ALTER TABLE '.	self printDDLTableNameFor: aConstraint table on: aStream.	aStream		nextPutAll: ' DROP ';		nextPutAll: (self keywordForConstraintsWhenDropping: aConstraint);		nextPut: $ .	(aConstraint class = PrimaryKeyConstraint)		ifFalse: [aStream nextPutAll: aConstraint name asUppercase].	^aStream contents.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services columns</category><body package="GlorpMigration">defaultUniqueConstraintNameFor: aField	"Return the presumed name of a UNIQUE constraint for aField."		| constraintName |	constraintName := aField name.	^self capitalWritingOfColumnName		ifTrue: [constraintName asUppercase]		ifFalse: [constraintName]</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>constants</category><body package="GlorpMigration">keywordForConstraintsWhenDropping: aConstraint	"Return the term we use to describe a constraint when dropping them. This is required because MySQL wants you to use 'DROP FOREIGN KEY' or ''PRIMARY KEY' rather than the ANSI 'DROP CONSTRAINT'. Other constraints are treated by MySQL as column attributes (part of the column's type specification)."		^aConstraint class = PrimaryKeyConstraint		ifTrue: ['PRIMARY KEY']		ifFalse:			[aConstraint class = ForeignKeyConstraint				ifTrue: ['FOREIGN KEY']				ifFalse: [self error: 'Invalid constraint being dropped for MySQL.']]</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services columns</category><body package="GlorpMigration">printColumn: eachGlorpDatabaseField on: sqlStatementStream	"Print the column specification for the CREATE TABLE statement.	Don't show a default value for serial columns, since their semanitics are different."	sqlStatementStream		space;		nextPutAll: (self nameForColumn: eachGlorpDatabaseField name);		space.	self printColumnTypeSpec: eachGlorpDatabaseField on: sqlStatementStream</body><body package="GlorpMigration">printColumnTypeSpec: eachGlorpDatabaseField on: sqlStatementStream	"Print the column type specification for the CREATE/ALTER TABLE statement.  Don't show a default value for serial columns, since their semantics are different."		sqlStatementStream		nextPutAll: eachGlorpDatabaseField typeString;		space;		nextPutAll: (eachGlorpDatabaseField type isSerial					ifTrue: ['']					ifFalse: [self sqlTextForDEFAULT: eachGlorpDatabaseField dbDefaultValue]);		space;		nextPutAll: (eachGlorpDatabaseField isNullable					ifTrue: [self sqlTextForNULLAttributeConstraint]					ifFalse: [self sqlTextForNOTNULLAttributeConstraint]);		space;		nextPutAll: (eachGlorpDatabaseField isUnique					ifTrue: [self sqlTextForUNIQUEAttributeConstraint]					ifFalse: [self sqlTextForNOTUNIQUEAttributeConstraint]).</body><body package="GlorpMigration">printSqlStatementToAlterColumn: oldColumn to: newColumn on: aStream	"If you want to change a column name or type, use the CHANGE clause, followed by full type spec."		aStream		nextPutAll: 'ALTER TABLE ';		nextPutAll: (self ddlTableNameFor: oldColumn table);		nextPutAll: ' CHANGE ';		nextPutAll: (self nameForColumn: oldColumn name);		space;		nextPutAll: (self nameForColumn: newColumn name);		space.	self printColumnTypeSpec: newColumn on: aStream</body><body package="GlorpMigration">printSqlStatementToRenameColumn: oldColumn to: newColumnName on: aStream	"If you want to change a column name or type, use the CHANGE clause, followed by full type spec."		| newColumn |	newColumn := oldColumn copy.	newColumn name: newColumnName.	self printSqlStatementToAlterColumn: oldColumn to: newColumn on: aStream</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GlorpMigration">isGlorpType	^false</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>private</category><body package="GlorpMigration">allMigrationPragmas	^Pragma allNamed: self migrationPragmaSelector in: self</body><body package="GlorpMigration">completeMigrationPathUntil: aBlock	| nextAncestor |	nextAncestor := self.	[ nextAncestor isNil ] whileFalse: [		(aBlock value:  nextAncestor) 			ifTrue: [nextAncestor := nil]			ifFalse: [nextAncestor := nextAncestor migrationAncestor ]].</body><body package="GlorpMigration">defaultDeltaScriptSelectorFor: anotherDescriptorSystemClass	^(self migrationPragmaSelector copyFrom: 1 to: self migrationPragmaSelector size - 1), anotherDescriptorSystemClass name, ':'</body><body package="GlorpMigration">isMigrationAncestorOf: aDescriptorSystem	^self migrationAncestor = aDescriptorSystem 		or: [self migrationAncestor notNil and: [self migrationAncestor isMigrationAncestorOf:  aDescriptorSystem]]</body><body package="GlorpMigration">isMigrationDescendantOf: aDescriptorSystem	^aDescriptorSystem migrationAncestor = self 		or: [aDescriptorSystem migrationAncestor notNil and: [aDescriptorSystem migrationAncestor isMigrationAncestorOf:  self]]</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>accessing</category><body package="GlorpMigration">migrationAncestor"To be able to migrate from one version to another one this method has to return the previous version of a descriptor system"	^nil</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>private</category><body package="GlorpMigration">migrationPathTo: destinationDescriptorSystem	| migrationPath |	migrationPath := OrderedCollection new.	(self  isMigrationDescendantOf: destinationDescriptorSystem) 		ifTrue: [ destinationDescriptorSystem completeMigrationPathUntil: [ :cl | migrationPath addFirst: cl. cl = self ] ].	(self  isMigrationAncestorOf: destinationDescriptorSystem) 		ifTrue: [ self completeMigrationPathUntil: [ :cl | migrationPath add: cl. cl = destinationDescriptorSystem ] ].	^migrationPath isEmpty 		ifTrue: [(Glorp.Migration.CalculatingChangeSetError new				source: self ;				destination: destinationDescriptorSystem;				errorString: ( 'The databaseSchemas &lt;1s&gt; and &lt;2s&gt; are not in a direct migration path.' expandMacrosWith: self name with: destinationDescriptorSystem name );					yourself) raise ]		ifFalse: [migrationPath]</body><body package="GlorpMigration">migrationPathWithScriptsTo: destinationDescriptorSystem	| migrationPath scripts |	migrationPath := self migrationPathTo:  destinationDescriptorSystem.	scripts := OrderedCollection new.	1 to: migrationPath size - 1		do: [ :ind | | src dest pragmas |			src := migrationPath at: ind.			dest := migrationPath at: ind + 1.			pragmas := src migrationPragmasFor: dest.			pragmas size &gt; 1 ifTrue: [ ^(Glorp.Migration.CalculatingChangeSetError new					source: src;					destination: dest;					errorString: ( 'The descriptor system &lt;1s&gt; has more than one migration script for &lt;2s&gt; ' expandMacrosWith: src name with: dest name );					yourself) raise ].			pragmas notEmpty				ifTrue: [ scripts add: (Glorp.Migration.ScriptedOperations new					source: src;					destination: dest;					selector: pragmas first selector;					yourself) ]				ifFalse: [scripts add: (Glorp.Migration.CalculatedOperations new					source: src;					destination: dest;					yourself) ]			].	^ scripts</body><body package="GlorpMigration">migrationPragmaSelector	^ #migrationScriptTo:</body><body package="GlorpMigration">migrationPragmasFor: aDescriptorSystemClass		^self allMigrationPragmas select: [ :eachPragma |		(eachPragma argumentAt: 1)  = aDescriptorSystemClass name ]</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMigration">allMigrationPragmas	^ self class allMigrationPragmas</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration">calculateSynchronizeChangeSet"Calculates a change set between the database tables and tables description"	^ self calculateSynchronizeChangeSetFor: self allTables</body><body package="GlorpMigration">calculateSynchronizeChangeSetFor: aCollection	" Simple DescriptorSystem doesn't know how to do this. Do nothing."</body><body package="GlorpMigration">createDefaultMigrationScript: methodSelector for: anotherDescriptorSystem"Creates a default migration script with specified method selector. The script method will be created with a pragma which argument is the destination descriptor system name"		| source |	source := self		generateDefaultMigrationScriptSource: methodSelector		for: anotherDescriptorSystem.	(Refactory.Browser.AddMethodChange		compile: source		in: self class		classified: #'migration scripts')			package: self class package;			execute.	^self		detectMigrationPragma: methodSelector		for: anotherDescriptorSystem class		ifNone: [Glorp.Migration.MigrationScriptError raiseErrorString: 'Failed to create the default migration script for: ', anotherDescriptorSystem class name ]</body><body package="GlorpMigration">createDefaultMigrationScriptFor: anotherDescriptorSystem"Creates a default migration script and saves it in the method  #migrationScriptToAnotherDescriptorSystemName. The script method will be created with a pragma which argument is the destination descriptor system name"	^self 		createDefaultMigrationScript: (self defaultDeltaScriptSelectorFor: anotherDescriptorSystem )  		for: anotherDescriptorSystem</body><body package="GlorpMigration">createMigrationChangeSetFor: anotherDescriptorSystem"Creates a migration change set to migrate to another descriptor system "		^ (self newMigrationChangeSetFor: anotherDescriptorSystem)		calculateMigrationScript;		yourself</body><body package="GlorpMigration">createScriptAndMigrateTo: anotherDescriptorSystem"Creates a default migration script, saves it in the method  #migrationScriptToAnotherDescriptorSystemName and applies the script changes to a database"	| pragma |	pragma := self 		detectMigrationPragmaFor: anotherDescriptorSystem class		ifNone: 	[self createDefaultMigrationScriptFor: anotherDescriptorSystem  ].	self		migrateTo: anotherDescriptorSystem		using: pragma selector</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMigration">defaultDeltaScriptSelectorFor: anotherDescriptorSystem	^ self class defaultDeltaScriptSelectorFor: anotherDescriptorSystem class</body><body package="GlorpMigration">detectMigrationPragma: methodSelector for: aDescriptorSystemClass ifNone: aBlock		^ (self migrationPragmasFor: aDescriptorSystemClass)		detect: [ :eachPragma | eachPragma method selector = methodSelector asSymbol ]		ifNone: aBlock</body><body package="GlorpMigration">detectMigrationPragmaFor: aDescriptorSystemClass ifNone: aBlock	" It's a little counter-intuitive here. If #migrationPragmasFor: aDescriptorSystemClass	returns a non-empty collection, it will automatically satisfy the 'detect' condition.	Therefore, we just put 'true' in the detect block.	"	^ (self migrationPragmasFor: aDescriptorSystemClass)		detect: [ :p |  true ]		ifNone: aBlock</body><body package="GlorpMigration">generateDefaultMigrationScriptSource: methodSelector for: anotherDescriptorSystem"Creates a mogration script source"			^ (self createMigrationChangeSetFor: anotherDescriptorSystem) generateDefaultMigrationScriptSource: methodSelector</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>testing</category><body package="GlorpMigration">hasTables	^tables notEmpty</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration">migrateTo: anotherDescriptorSystem"Creates a default migration script and applies the script changes to a database"	^(self createMigrationChangeSetFor: anotherDescriptorSystem)		applyInSession: self session</body><body package="GlorpMigration">migrateTo: anotherDescriptorSystem using: messageSelector"Applies the migration script from the specified method to a database"	(self newMigrationChangeSetFor: anotherDescriptorSystem)		calculateChangesFor: self usingScript: messageSelector;		applyInSession: self session</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMigration">migrationPragmaSelector	^ self class migrationPragmaSelector</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration">migrationPragmasFor: aDescriptorSystemClass		^self class migrationPragmasFor: aDescriptorSystemClass</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMigration">newMigrationChangeSetFor: aSystemDescriptor	" Answer a new instance of the migration object "	^ Glorp.Migration.MigrationChangeSet from: self to: aSystemDescriptor</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>migration - api</category><body package="GlorpMigration">recreateTables"The method drops all database tables and recreates them from this descriptor "	self recreateTables: self allTables</body><body package="GlorpMigration">recreateTables: aCollection"The method drops specified tables and recreates them from this descriptor "	self session recreateTables: aCollection</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>testing</category><body package="GlorpMigration">isDB2TableReorgException: ex	"Look for messages that indicate a table REORG is necessary."	^(ex class = UnableToExecuteSQL and: 			[| messages |			messages := Array with: 'Operation not allowed for reason code "7"'						with: 'is in an invalid state for the operation. Reason code="23"'.			messages				detect: [:msg | (ex messageText indexOfSubCollection: msg startingAt: 1) &gt; 0] ifNone: ['']]) notEmpty</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>api</category><body package="GlorpMigration">applyAlterField: anAlterField InSession: aGlorpSession	"Apply the [NOT] NULL change before the type change because some platforms (MS-SQLServer) want the type included for that change."	| accessor |	accessor := aGlorpSession accessor.	anAlterField dropDefault ifNotNil: 		[accessor alterFieldDropDefault: anAlterField databaseField ifError: (self migrationExceptionBlockFor: anAlterField accessor: accessor)].	anAlterField defaultValue ifNotNil: 		[ :val | accessor alterField: anAlterField databaseField setDefault: anAlterField defaultValue ifError: (self migrationExceptionBlockFor: anAlterField accessor: accessor)].	anAlterField isNullable ifNotNil:		[ :val |		val 			ifTrue: [accessor alterFieldDropNotNull: anAlterField databaseField ifError: (self migrationExceptionBlockFor: anAlterField accessor: accessor)]			ifFalse: [accessor alterFieldSetNotNull: anAlterField databaseField ifError: (self migrationExceptionBlockFor: anAlterField accessor: accessor)]].	anAlterField type ifNotNil: 		[ :val | accessor alterField: anAlterField databaseField newType: val ifError: (self migrationExceptionBlockFor: anAlterField accessor: accessor)].</body><body package="GlorpMigration">migrationExceptionBlockFor: aMigrationOperation accessor: anAccessor	^aMigrationOperation exceptionBlock</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>pragmas</category><body package="GlorpMigration">pragmas	&lt;pragmas: #instance&gt;	^#( migrationScriptTo: )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>GlorpDatabaseType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform selector typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>ActiveRecordDescriptorSystem</name><environment>Glorp.ActiveRecords</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metadataSession inflector currentDescriptor deferredDescriptorOperations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DatabasePlatform</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types converters useBinding reservedWords functions characterEncoding </inst-vars><class-inst-vars>converterRepository </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>DB2Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>MySQLPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>GlorpError</name><environment>Glorp</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class></st-source>