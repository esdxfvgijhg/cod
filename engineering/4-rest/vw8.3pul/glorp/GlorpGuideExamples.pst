<?xml version="1.0"?><st-source><!-- Name: GlorpGuideExamplesNotice: Copyright 2013 Cincom Systems, Inc.  All Rights Reserved.Comment: This package holds two separate examples.The first is an ActiveRecord example, in namespace ActiveRecordDemo, whose classes are:	Customer,	Vehicle,	ActiveRecordDemoSchema.The remaing classes embody the Glorp models and descriptorSystem of the example from Chapter 7 of the GlorpGuide.pdf, in the section named Mapping Dictionaries. The classes are completely separate from the first example. They are:	AddressBook,	Person,	MyAppDescriptorSystem.DbIdentifier: bear73DbTrace: 405850DbUsername: nrossDbVersion: 7.10 - 1DevelopmentPrerequisites: #(#(#any 'Glorp' '') #(#any 'GlorpActiveRecord' '') #(#any 'Base VisualWorks' ''))PackageName: GlorpGuideExamplesParcel: #('GlorpGuideExamples')PrerequisiteDescriptions: #(#(#name 'Glorp' #componentType #bundle) #(#name 'GlorpActiveRecord' #componentType #package) #(#name 'Base VisualWorks' #componentType #bundle))PrerequisiteParcels: #(#('Glorp' '') #('GlorpActiveRecord' '') #('Base VisualWorks' ''))PrintStringCache: (7.10 - 1,nross)Version: 7.10 - 1Date: 1:15:01 PM May 3, 2013 --><time-stamp>From VisualWorksÂ®, Pre-Release 7.10 (may13.1) of May 3, 2013 on May 3, 2013 at 1:15:01 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>ActiveRecordDemo</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private Glorp.*			private Glorp.ActiveRecords.*			</imports><category></category><attributes><package>GlorpGuideExamples</package></attributes></name-space><comment><name-space-id>ActiveRecordDemo</name-space-id><body>ActiveRecordDemo is the namespace which contains the domain model classes, Customer and Vehicle, and their descriptor system, ActiveRecordDemoSchema.This separate namespace allows for domain model classes whose names exactly match their corresponding database table names (it prevents naming collisions with existing classes in your image). Matching table and domain class names helps ActiveRecord automatically infer the relations between tables and domain classes.</body></comment><class><name>MyAppDescriptorSystem</name><environment>Smalltalk</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			Glorp.*			</imports><category></category><attributes><package>GlorpGuideExamples</package></attributes></class><comment><class-id>MyAppDescriptorSystem</class-id><body>MyAppDescriptorSystem is an example from Chapter 7 of the GlorpGuide.pdf, in the section named Mapping Dictionaries.To use, alter the MyAppDescriptorSystem (class) login method with your own database client information. Then evaluate:		MyAppDescriptorSystem exampleAllAtOnce.To see the resulting data as objects, evaluate:		MyAppDescriptorSystem showAddresses.To see the resulting data as table rows, evaluate:		MyAppDescriptorSystem showAllTableRows.To explore adding data in stages, using separate units of work, examine these methods:		MyAppDescriptorSystem (class) example1, example2, and example3.To explore how to use modification tracking, examine and evaluate this method:		MyAppDescriptorSystem exampleWithModificationTracking</body></comment><class><name>Person</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id firstName lastName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Application</category><attributes><package>GlorpGuideExamples</package></attributes></class><comment><class-id>Person</class-id><body>Person is a Model class used by Glorp to describe a row of the PEOPLE table.Instance Variables	firstName	&lt;String&gt;	id	&lt;Integer&gt;	A unique id assigned by Glorp to each instance of AddressBook, serving as the primary key.	lastName	&lt;String&gt;</body></comment><class><name>Customer</name><environment>ActiveRecordDemo</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstName lastName vehicle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpGuideExamples</package></attributes></class><comment><class-id>ActiveRecordDemo.Customer</class-id><body>Customer is a simple ActiveRecord domain model class. That is, it inherits directly from ActiveRecord.The methods &gt;&gt;getLogin, &gt;&gt;getSchema and &gt;&gt;getSession have been overriden to use those of the ActiveRecordDemoSchema, rather than inheriting the global default used by ActiveRecord. This was done in an effort to isolate the example code and minimize interaction with global settings.Instance Variables	firstName	&lt;String&gt;	lastName	&lt;String&gt;	vehicle		&lt;Vehicle&gt;	The person's car or truck.</body></comment><class><name>ActiveRecordDemoSchema</name><environment>ActiveRecordDemo</environment><super>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpGuideExamples</package></attributes></class><comment><class-id>ActiveRecordDemo.ActiveRecordDemoSchema</class-id><body>ActiveRecordDemoSchema implements the ActiveRecordDescriptorSystem. It works with Customers and their Vehicles, and declares them in the method, #allClasses. There are also the #tableForCUSTOMER: and #tableForVEHICLE: methods which describe the columns and relations between the tables. This information is enough for ActiveRecord to create the tables if they are missing. The instance methods on the domain classes, Customer and Vehicle, allow the usual add, change, delete database operations.The #tableFor: methods serve to define your tables if they don't already exist, so that ActiveRecord can create them in the first place. Once the tables exist, ActiveRecord can infer the schema's domain classes and relationships between the corresponding tables.If your domain class names do not match your table names, simply add the following instance side method for each such class. For example, if your domain class corresponding to the CUSTOMER table is 'MyCustomer', add this instance side method:	&gt;&gt;descriptorForMyCustomer: aDescriptor		aDescriptor table: (self tableNamed: 'CUSTOMER').This example tries to isolate its own login and session variables from the global default values. There are two shared variables, DefaultLogin and DefaultSession, used by this schema and its domain classes. It is hoped that the added complexity is worth the isolation from global defaults that it provides.To get started, first make sure that your database doesn't already contain CUSTOMER and VEHICLE tables. If so, try adding the &gt;&gt;descriptorFor: methods above, and use a different table name. Next, update the class side &gt;&gt;login method with your own database platform and user id. Then you're ready to experiment with this example. See the class side examples methods and try evaluating the code in each method comment.</body></comment><class><name>AddressBook</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title entries </inst-vars><class-inst-vars>entries </class-inst-vars><imports></imports><category>My Application</category><attributes><package>GlorpGuideExamples</package></attributes></class><comment><class-id>AddressBook</class-id><body>AddressBook is a Glorp model class which describes an object from a row of the ADDRESS_BOOK table.Instance Variables	entries	&lt;Dictionary&gt;  A dictionary of person nickname (a String, person_key) to Person. The dictionary corresponds to a third table, ADDRESS_BOOK_LINKS.	id	&lt;Integer&gt;	A unique id assigned by Glorp to each instance of AddressBook, serving as the primary key.	title	&lt;String&gt;	Title of this address book instance.</body></comment><class><name>Vehicle</name><environment>ActiveRecordDemo</environment><super>Glorp.ActiveRecords.ActiveRecord</super><private>false</private><indexed-type>none</indexed-type><inst-vars>make model year color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpGuideExamples</package></attributes></class><comment><class-id>ActiveRecordDemo.Vehicle</class-id><body>Vehicle is a simple ActiveRecord domain model class. That is, it inherits directly from ActiveRecord.The methods &gt;&gt;getLogin, &gt;&gt;getSchema and &gt;&gt;getSession have been overriden to use those of the ActiveRecordDemoSchema, rather than inheriting the global default used by ActiveRecord. This was done in an effort to isolate the example code and minimize interaction with global settings.Instance Variables	make	&lt;String&gt;	model	&lt;String&gt;	year	&lt;Integer&gt;	color	&lt;String&gt;</body></comment><shared-variable><name>DefaultLogin</name><environment>ActiveRecordDemo.ActiveRecordDemoSchema</environment><private>false</private><constant>false</constant><category>login</category><initializer>nil</initializer><attributes><package>GlorpGuideExamples</package></attributes></shared-variable><shared-variable><name>DefaultSession</name><environment>ActiveRecordDemo.ActiveRecordDemoSchema</environment><private>false</private><constant>false</constant><category>login</category><initializer>nil</initializer><attributes><package>GlorpGuideExamples</package></attributes></shared-variable><shared-variable><name>MyLogin</name><environment>MyAppDescriptorSystem</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>GlorpGuideExamples</package></attributes></shared-variable><methods><class-id>MyAppDescriptorSystem</class-id> <category>classes</category><body package="GlorpGuideExamples">classModelForAddressBook: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #entries collection: Dictionary of: Person</body><body package="GlorpGuideExamples">classModelForPerson: aClassModel	aClassModel newAttributeNamed: #lastName.	aClassModel newAttributeNamed: #firstName.	aClassModel newAttributeNamed: #id</body><body package="GlorpGuideExamples">constructAllClasses	^(super constructAllClasses)</body></methods><methods><class-id>MyAppDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpGuideExamples">descriptorForAddressBook: aDescriptor	| table linkTable |	table := self tableNamed: 'ADDRESS_BOOK'.	linkTable := self tableNamed: 'ADDRESS_BOOK_LINKS'.	aDescriptor table: table.	aDescriptor		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'id')).	aDescriptor		addMapping: (DirectMapping from: #title to: (table fieldNamed: 'title')).	(aDescriptor newMapping: DictionaryMapping)				attributeName: #entries;				referenceClass: Person;				keyField: (linkTable fieldNamed: 'person_key');				relevantLinkTableFields: (Array with: (linkTable fieldNamed: 'person_id'))</body><body package="GlorpGuideExamples">descriptorForPerson: aDescriptor	| personTable |	personTable := self tableNamed: 'PEOPLE'.	aDescriptor table: personTable.	(aDescriptor newMapping: DirectMapping) from: #id		to: (personTable fieldNamed: 'id').	(aDescriptor newMapping: DirectMapping) from: #firstName		to: (personTable fieldNamed: 'first_name').	(aDescriptor newMapping: DirectMapping) from: #lastName		to: (personTable fieldNamed: 'last_name')</body></methods><methods><class-id>MyAppDescriptorSystem</class-id> <category>initialize-release</category><body package="GlorpGuideExamples">initialize	super initialize.	^self</body></methods><methods><class-id>MyAppDescriptorSystem</class-id> <category>tables</category><body package="GlorpGuideExamples">allTableNames	^#('PEOPLE' 'ADDRESS_BOOK' 'ADDRESS_BOOK_LINKS')</body><body package="GlorpGuideExamples">tableForADDRESS_BOOK: aTable	aTable createFieldNamed: 'title' type: (platform varChar: 50).	(aTable createFieldNamed: 'id' type: platform sequence) bePrimaryKey</body><body package="GlorpGuideExamples">tableForADDRESS_BOOK_LINKS: aTable	| personId bookId |	personId := (aTable createFieldNamed: 'person_id' type: platform int4 ) bePrimaryKey.	aTable addForeignKeyFrom: personId to: ((self tableNamed: 'PEOPLE') fieldNamed: 'id').	bookId := (aTable createFieldNamed: 'address_book_id' type: (platform int4)) bePrimaryKey.	aTable addForeignKeyFrom: bookId to: ((self tableNamed: 'ADDRESS_BOOK') fieldNamed: 'id').	aTable createFieldNamed: 'person_key' type: (platform varChar: 30)</body><body package="GlorpGuideExamples">tableForPEOPLE: aTable	aTable createFieldNamed: 'first_name' type: (platform varChar: 50).	aTable createFieldNamed: 'last_name' type: (platform varChar: 50).	(aTable createFieldNamed: 'id' type: platform sequence) bePrimaryKey</body></methods><methods><class-id>MyAppDescriptorSystem class</class-id> <category>examples</category><body package="GlorpGuideExamples">example1	"Create tables and add Contacts for Jim."	"MyAppDescriptorSystem example1"	| session jimAddresses |	session := MyAppDescriptorSystem sessionForLogin: self login.	session login.	session createTables.	session inUnitOfWorkDo: 			[jimAddresses := AddressBook title: 'Jim Contacts'.			jimAddresses				at: 'moe' put: (Person first: 'Moe' last: 'Howard');				at: 'curly' put: (Person first: 'Curly' last: 'Howard');				at: 'larry' put: (Person first: 'Larry' last: 'Fine').			session register: jimAddresses]</body><body package="GlorpGuideExamples">example2	"Add the same new contacts for Mary and for George."	"MyAppDescriptorSystem example2"	| session maryAddresses moe georgeAddresses curly larry |	session := MyAppDescriptorSystem sessionForLogin: self login.	session login.	session inUnitOfWorkDo: 			[maryAddresses := AddressBook title: 'Mary Contacts'.			moe := session readOneOf: Person where: [:each | each firstName = 'Moe' AND: [each lastName = 'Howard']].			curly := session readOneOf: Person where: [:each | each firstName = 'Curly'].			larry := session readOneOf: Person where: [:each | each firstName = 'Larry'].			maryAddresses				at: 'moe' put: moe;				at: 'curly' put: curly;				at: 'larry' put: larry;				at: 'harold' put: (Person first: 'Harold' last: 'Lloyd');				at: 'charlie' put: (Person first: 'Charlie' last: 'Chaplin').			session register: maryAddresses].	session inUnitOfWorkDo: 			[georgeAddresses := AddressBook title: 'George Contacts'.			maryAddresses entries				keysAndValuesDo: [:key :value | georgeAddresses at: key put: value].			session register: georgeAddresses]</body><body package="GlorpGuideExamples">example3	"Rename Charlie Chaplin to Buster Keaton, and update Contact nicknames for Mary and George."	"MyAppDescriptorSystem example3"	| session maryAddresses georgeAddresses buster |	session := MyAppDescriptorSystem sessionForLogin: self login.	session login.	maryAddresses := session readOneOf: AddressBook where: [:each | each title = 'Mary Contacts'].	georgeAddresses := session readOneOf: AddressBook where: [:each | each title = 'George Contacts'].	session inUnitOfWorkDo: 			[buster := georgeAddresses entries at: 'charlie'.			session register: buster.			buster				firstName: 'Buster';				lastName: 'Keaton'].	session inUnitOfWorkDo: 			[session register: maryAddresses.			session register: georgeAddresses.			maryAddresses entries removeKey: 'charlie'.			georgeAddresses entries removeKey: 'charlie'].	session inUnitOfWorkDo: 			[session register: maryAddresses.			session register: georgeAddresses.			maryAddresses entries at: 'buster' put: buster.			georgeAddresses entries at: 'buster' put: buster]</body><body package="GlorpGuideExamples">exampleAllAtOnce	"MyAppDescriptorSystem exampleAllAtOnce"	| session jimAddresses maryAddresses moe georgeAddresses curly larry buster |	session := MyAppDescriptorSystem sessionForLogin: self login.	session login.	session createTables.	session inUnitOfWorkDo: 			[jimAddresses := AddressBook title: 'Jim Contacts'.			jimAddresses				at: 'moe' put: (Person first: 'Moe' last: 'Howard');				at: 'curly' put: (Person first: 'Curly' last: 'Howard');				at: 'larry' put: (Person first: 'Larry' last: 'Fine').			session register: jimAddresses.			maryAddresses := AddressBook title: 'Mary Contacts'.			moe := session readOneOf: Person						where: [:each | each firstName = 'Moe' AND: [each lastName = 'Howard']].			curly := session readOneOf: Person						where: [:each | each firstName = 'Curly'].			larry := session readOneOf: Person						where: [:each | each firstName = 'Larry'].			maryAddresses				at: 'moe' put: moe;				at: 'curly' put: curly;				at: 'larry' put: larry;				at: 'harold' put: (Person first: 'Harold' last: 'Lloyd');				at: 'charlie' put: (Person first: 'Charlie' last: 'Chaplin').			session register: maryAddresses.			georgeAddresses := AddressBook title: 'George Contacts'.			maryAddresses entries				keysAndValuesDo: [:key :value | georgeAddresses at: key put: value].			session register: georgeAddresses.			buster := georgeAddresses entries at: 'charlie'.			session register: buster.			buster				firstName: 'Buster';				lastName: 'Keaton'.			maryAddresses entries removeKey: 'charlie'.			georgeAddresses entries removeKey: 'charlie'.			session register: maryAddresses.			session register: georgeAddresses.			maryAddresses entries at: 'buster' put: buster.			georgeAddresses entries at: 'buster' put: buster].	"session dropTables."</body><body package="GlorpGuideExamples">exampleWithModificationTracking	"This example demonstrates how to use the modification tracker. The second unitOfWork doesn't need to register: curly."	"MyAppDescriptorSystem dropTables.	MyAppDescriptorSystem exampleAllAtOnce.	MyAppDescriptorSystem exampleWithModificationTracking"	| session addresses jimAddresses curly otherSession |	session := MyAppDescriptorSystem sessionForLogin: self login.	session login.	session useModificationTracker.				"Enable modification tracking."	session inUnitOfWorkDo: 					"Load all the data into objects."		[addresses := session read: AddressBook.		jimAddresses := addresses detect: [:address| address title = 'Jim Contacts'].		curly := jimAddresses entries at: 'curly'.		curly printOn: Transcript].	session inUnitOfWorkDo:					"Make a change without needing to register."		[curly lastName: 'HOWARD'].	session logout.	otherSession := MyAppDescriptorSystem sessionForLogin: self login.		"Show results."	otherSession login.	otherSession inUnitOfWorkDo: 		[addresses := otherSession read: AddressBook.			"Load all the data into objects."		jimAddresses := addresses detect: [:address| address title = 'Jim Contacts'].		curly := jimAddresses entries at: 'curly'.		curly printOn: Transcript].</body><body package="GlorpGuideExamples">login	MyLogin isNil ifTrue: [ MyLogin := (Login new)		database: (SQLite3Platform new initializeFunctions);		username: 'x';		password: 'x';		secure: false;		"schema: 'na';"		connectString: 'x6'].	^MyLogin</body></methods><methods><class-id>MyAppDescriptorSystem class</class-id> <category>printing</category><body package="GlorpGuideExamples">showAddresses	"List my entire database contents as Smalltalk objects."	"MyAppDescriptorSystem showAddresses"	| session addresses |	session := MyAppDescriptorSystem sessionForLogin: self login.	session login.	addresses := session read: AddressBook.	Transcript cr; cr; show: '==== Glorp Addresses ===='; cr.	addresses do: [:address| address printOn: Transcript].</body><body package="GlorpGuideExamples">showAllTableRows	"List the raw contents of all my tables, using SQL."	"MyAppDescriptorSystem showAllTableRows"	| session tableNames |	session := MyAppDescriptorSystem sessionForLogin: self login.	session login.	Transcript cr; cr; show: '==== Glorp Tables ===='; cr.	tableNames := session system allTableNames.	tableNames do: 			[:aTableName |			| rows |			Transcript cr; show: aTableName; cr.			rows := session accessor executeSQLString: 'select * from ' , aTableName.			rows do: 					[:aRow |					Transcript show: aRow printString; cr]]</body></methods><methods><class-id>MyAppDescriptorSystem class</class-id> <category>utility</category><body package="GlorpGuideExamples">createTables	"MyAppDescriptorSystem createTables"	self createTablesFor: self login.</body><body package="GlorpGuideExamples">dropTables	"MyAppDescriptorSystem dropTables"	self dropTablesFor: self login.</body></methods><methods><class-id>Person</class-id> <category>accessing</category><body package="GlorpGuideExamples">firstName	^firstName</body><body package="GlorpGuideExamples">firstName: anObject	firstName := anObject</body><body package="GlorpGuideExamples">id	^id</body><body package="GlorpGuideExamples">id: anObject	id := anObject</body><body package="GlorpGuideExamples">lastName	^lastName</body><body package="GlorpGuideExamples">lastName: anObject	lastName := anObject</body></methods><methods><class-id>Person</class-id> <category>printing</category><body package="GlorpGuideExamples">printOn: aStream	aStream		nextPutAll: id printString;		nextPutAll: ', ';		nextPutAll: (firstName ifNil: [firstName printString]);		nextPut: Character space;		nextPutAll: (lastName ifNil: [lastName printString]);		cr</body><body package="GlorpGuideExamples">printString	| aStream |	aStream := String new writeStream.	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>Person</class-id> <category>initialize-release</category><body package="GlorpGuideExamples">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	id := nil.	firstName := nil.	lastName := nil.	^self</body></methods><methods><class-id>Person class</class-id> <category>instance creation</category><body package="GlorpGuideExamples">first: firstname last: lastname	"Answer a newly created and initialized instance."	^(super new initialize)		firstName: firstname;		lastName: lastname;		yourself</body><body package="GlorpGuideExamples">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>ActiveRecordDemo.Customer</class-id> <category>accessing</category><body package="GlorpGuideExamples">firstName	^firstName</body><body package="GlorpGuideExamples">firstName: anObject	firstName := anObject</body><body package="GlorpGuideExamples">lastName	^lastName</body><body package="GlorpGuideExamples">lastName: anObject	lastName := anObject</body><body package="GlorpGuideExamples">vehicle	^vehicle</body><body package="GlorpGuideExamples">vehicle: anObject	vehicle := anObject</body></methods><methods><class-id>ActiveRecordDemo.Customer</class-id> <category>initialize-release</category><body package="GlorpGuideExamples">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	^self</body></methods><methods><class-id>ActiveRecordDemo.Customer</class-id> <category>printing</category><body package="GlorpGuideExamples">printOn: aStream	aStream		nextPutAll: id printString;		nextPutAll: ', ';		nextPutAll: (firstName ifNil: [firstName printString]);		nextPut: Character space;		nextPutAll: (lastName ifNil: [lastName printString]);		cr; nextPut: Character tab.	vehicle ifNil: [aStream nextPutAll: 'no vehicle'] ifNotNil: [vehicle printOn: aStream].	aStream cr.</body></methods><methods><class-id>ActiveRecordDemo.Customer class</class-id> <category>examples</category><body package="GlorpGuideExamples">charles	^Customer new firstName: 'Charles'; lastName: 'Boyer'; vehicle: (Vehicle ford); yourself</body><body package="GlorpGuideExamples">fred	^Customer new firstName: 'Fred'; lastName: 'Friendly'; vehicle: (Vehicle civic); yourself</body><body package="GlorpGuideExamples">jim	^Customer new firstName: 'James'; lastName: 'McKoy'; vehicle: (Vehicle toyota); yourself</body><body package="GlorpGuideExamples">julie	^Customer new firstName: 'Julie'; lastName: 'Andrews'; vehicle: (Vehicle f100); yourself</body></methods><methods><class-id>ActiveRecordDemo.Customer class</class-id> <category>login</category><body package="GlorpGuideExamples">getLogin	^self getSchema defaultLogin</body><body package="GlorpGuideExamples">getSchema	^ActiveRecordDemoSchema</body><body package="GlorpGuideExamples">getSession	^self getSchema defaultSession</body></methods><methods><class-id>ActiveRecordDemo.ActiveRecordDemoSchema</class-id> <category>initialize-release</category><body package="GlorpGuideExamples">initialize	super initialize.	inflector pluralTableNames: false</body></methods><methods><class-id>ActiveRecordDemo.ActiveRecordDemoSchema</class-id> <category>accessing</category><body package="GlorpGuideExamples">allClasses	^Array with: Customer with: Vehicle</body></methods><methods><class-id>ActiveRecordDemo.ActiveRecordDemoSchema</class-id> <category>tables</category><body package="GlorpGuideExamples">tableForCUSTOMER: aTable	| vehicleId |	(aTable createFieldNamed: 'id' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'FIRST_NAME' type: (platform varchar: 30).	aTable createFieldNamed: 'LAST_NAME' type:  (platform varchar: 30).	vehicleId := aTable createFieldNamed: 'VEHICLE_ID' type: (platform integer).	aTable addForeignKeyFrom: vehicleId to: ((self tableNamed: 'VEHICLE') fieldNamed: 'id').</body><body package="GlorpGuideExamples">tableForVEHICLE: aTable	(aTable createFieldNamed: 'id' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'MAKE' type: (platform varchar: 30).	aTable createFieldNamed: 'MODEL' type: (platform varchar: 30).	aTable createFieldNamed: 'YEAR' type: platform integer.	aTable createFieldNamed: 'COLOR' type: (platform varchar: 30)</body></methods><methods><class-id>ActiveRecordDemo.ActiveRecordDemoSchema class</class-id> <category>examples</category><body package="GlorpGuideExamples">examplePopulate	"Create tables and add data."	"ActiveRecordDemoSchema dropTables; createTables; examplePopulate"	| customers |	self setCustomDefaults.	customers := OrderedCollection new						add: Customer charles;						add: Customer fred;						add: Customer jim;						add: Customer julie;						yourself.	customers do: [:each| each bePersistent; commitUnitOfWork].</body><body package="GlorpGuideExamples">exampleRead	"Read and return all customer data."	"(ActiveRecordDemoSchema dropTables; createTables; examplePopulate; exampleRead) inspect"	| customers strm |	self setCustomDefaults.	customers := Customer findAll.	strm := String new writeStream.	customers do: [:each | each printOn: strm].	^strm contents</body><body package="GlorpGuideExamples">exampleUpdate	"Read and update a customer's lastName and vehicle color."	"(ActiveRecordDemoSchema dropTables; createTables; examplePopulate; exampleUpdate; exampleRead) inspect"	| aCustomer finds |	self setCustomDefaults.	finds := Customer findWhere: [:each| each lastName = 'Friendly'].	aCustomer := finds first.	aCustomer bePersistent.	aCustomer lastName: 'FRIENDLY'.	aCustomer vehicle color: 'TEAL'.	aCustomer commitUnitOfWork.	^aCustomer</body></methods><methods><class-id>ActiveRecordDemo.ActiveRecordDemoSchema class</class-id> <category>accessing</category><body package="GlorpGuideExamples">defaultLogin	^DefaultLogin ifNil: [DefaultLogin := self login]</body><body package="GlorpGuideExamples">defaultLogin: aLogin	DefaultLogin := aLogin</body><body package="GlorpGuideExamples">defaultSession	^DefaultSession ifNil: [DefaultSession := self sessionForLogin: self defaultLogin]</body><body package="GlorpGuideExamples">defaultSession: aSession	^DefaultSession := aSession</body></methods><methods><class-id>ActiveRecordDemo.ActiveRecordDemoSchema class</class-id> <category>initialize-release</category><body package="GlorpGuideExamples">login	^(Login new)		database: (SQLite3Platform new initializeFunctions; yourself);		username: 'x';		password: 'x';		secure: false;		connectString: 'x6'.	"^(Glorp.Login new)		database: (Glorp.OraclePlatform new initializeFunctions; yourself);		username: 'scott';		password: 'tiger';		secure: false;		schema: 'scott';		connectString: 'XE'"</body></methods><methods><class-id>ActiveRecordDemo.ActiveRecordDemoSchema class</class-id> <category>class initialization</category><body package="GlorpGuideExamples">setCustomDefaults	"Set the defaults for only my ActiveRecord classes."	"ActiveRecordDemoSchema setCustomDefaults"	self defaultLogin: nil.	self defaultSession: nil</body><body package="GlorpGuideExamples">setSystemDefaults	"Use this method to set the defaults for all ActiveRecord classes. Update ActiveRecord's shared variables to match my login and session."	"ActiveRecordDemoSchema setSystemDefaults"	ActiveRecord		setLogin: self defaultLogin;		setSystem: self;		setSession: self defaultSession</body></methods><methods><class-id>ActiveRecordDemo.ActiveRecordDemoSchema class</class-id> <category>table creation</category><body package="GlorpGuideExamples">createTables	"ActiveRecordDemoSchema createTables"	self createTablesFor: self login.</body><body package="GlorpGuideExamples">dropTables	"ActiveRecordDemoSchema dropTables"	self dropTablesFor: self login.</body></methods><methods><class-id>AddressBook</class-id> <category>accessing</category><body package="GlorpGuideExamples">at: aKey put: aValue	self entries at: aKey put: aValue</body><body package="GlorpGuideExamples">entries	^entries</body><body package="GlorpGuideExamples">entries: anObject	entries := anObject</body><body package="GlorpGuideExamples">id	^id</body><body package="GlorpGuideExamples">id: anObject	id := anObject</body><body package="GlorpGuideExamples">title	^title</body><body package="GlorpGuideExamples">title: anObject	title := anObject</body></methods><methods><class-id>AddressBook</class-id> <category>initialize-release</category><body package="GlorpGuideExamples">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	id := nil.	title := nil.	entries := Dictionary new.	^self</body></methods><methods><class-id>AddressBook</class-id> <category>printing</category><body package="GlorpGuideExamples">printOn: aStream	aStream		nextPutAll: id printString;		nextPutAll: ', ';		nextPutAll: (title ifNil: [title printString]);		cr.	entries keysAndValuesDo: 			[:key :value |			aStream				nextPutAll: (key ifNil: key printString) , '-&gt;' , value printString].	aStream cr</body><body package="GlorpGuideExamples">printString	| aStream |	aStream := String new writeStream.	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>AddressBook class</class-id> <category>instance creation</category><body package="GlorpGuideExamples">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="GlorpGuideExamples">title: aString	"Answer a newly created and initialized instance."	^(super new initialize) title: aString; yourself</body></methods><methods><class-id>ActiveRecordDemo.Vehicle</class-id> <category>accessing</category><body package="GlorpGuideExamples">color	^color</body><body package="GlorpGuideExamples">color: anObject	color := anObject</body><body package="GlorpGuideExamples">make	^make</body><body package="GlorpGuideExamples">make: anObject	make := anObject</body><body package="GlorpGuideExamples">model	^model</body><body package="GlorpGuideExamples">model: anObject	model := anObject</body><body package="GlorpGuideExamples">year	^year</body><body package="GlorpGuideExamples">year: anObject	year := anObject</body></methods><methods><class-id>ActiveRecordDemo.Vehicle</class-id> <category>initialize-release</category><body package="GlorpGuideExamples">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	^self</body></methods><methods><class-id>ActiveRecordDemo.Vehicle</class-id> <category>printing</category><body package="GlorpGuideExamples">printOn: aStream	aStream		nextPutAll: id printString;		nextPutAll: ', ';		nextPutAll: (make ifNil: [make printString]);		nextPut: Character space;		nextPutAll: (model ifNil: [model printString]);		nextPut: Character space;		nextPutAll: (year printString ifNil: [year printString]);		nextPut: Character space;		nextPutAll: (color ifNil: [color printString])</body></methods><methods><class-id>ActiveRecordDemo.Vehicle class</class-id> <category>examples</category><body package="GlorpGuideExamples">civic	^self new make: 'Honda'; model: 'Civic'; year: 2007; color: 'tan'; yourself</body><body package="GlorpGuideExamples">f100	^self new make: 'Ford'; model: 'F100'; year: 2003; color: 'blue'; yourself</body><body package="GlorpGuideExamples">ford	^self new make: 'Ford'; model: 'Taurus'; year: 2010; color: 'gray'; yourself</body><body package="GlorpGuideExamples">toyota	^self new make: 'Toyota'; model: 'Corolla'; year: 1998; color: 'red'; yourself</body></methods><methods><class-id>ActiveRecordDemo.Vehicle class</class-id> <category>login</category><body package="GlorpGuideExamples">getLogin	^self getSchema defaultLogin</body><body package="GlorpGuideExamples">getSchema	^ActiveRecordDemoSchema</body><body package="GlorpGuideExamples">getSession	^self getSchema defaultSession</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ActiveRecord</name><environment>Glorp.ActiveRecords</environment><super>Glorp.PersistentObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>ActiveRecordDescriptorSystem</name><environment>Glorp.ActiveRecords</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metadataSession inflector currentDescriptor deferredDescriptorOperations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class></st-source>