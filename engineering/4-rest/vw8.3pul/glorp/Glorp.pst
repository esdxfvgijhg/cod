<?xml version="1.0"?><st-source><!-- Name: GlorpNotice: Copyright 2000-2015  Alan KnightGLORP is made available to use under the Smalltalk Shared-Base license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions.The Software is provided "as is", without warranty of any kind, express or implied, including but not limited to the warranties of merchantability, fitness for a particular purpose and noninfringement.  In no event shall the authors or copyright holders be liable for any claim, damages or other liability, whether in an action of contract, tort or otherwise, arising from, out of or in connection with the Software or the use or other dealings in the Software.The Software shall not restrict in any way the license of any software or product that includes it or makes use of it in any way, subject to the following conditions.If you modify the class definitions or the methods of the Software, the following requirement will apply to the source code of those modified class definitions and modified methods only.  It will not apply to the definitions or methods of subclasses of classes in the Software, or to code that calls the Software and/or has the Software call back to it, through using classes and methods of the software in code, or by using blocks, or by using the #perform: mechanism or similar mechanisms, or any other code, modified or otherwise, that is not a class definition of a class provided by the Software, or a method provided by the Software.  If modifications to the classes or methods of the Software are included in software or products made available under any license then the source code of those modifications shall on request be made available to the originating supplier of the Software, who shall provide them to anyone on request under this license.The above copyright notice and license terms shall be included in all copies of the Software or of substantial portions of the Software.The intent of this license is not to change the meaning of the prior license but to provide a self-contained and clear license that imposes the intended conditions. The previous license referenced another license but had negations and redefinitions of its conditions, and became particularly confusing as that license changed in subsequent versions.BundleName: GlorpBundleStructure: a Store.BundleForParcelComment: GLORP maps between Smalltalk and relational databases.  GLORP lets SQL queries be written as if they were Smalltalk code.  For more information, see the following:	doc/GlorpGuide.pdf explains the Glorp framework (code for the guide's examples is in the GlorpGuideExamples parcel)	preview/glorp/GlorpUserGuide0.3.pdf, written by an early user of GLORP, works up from very basic database operations to the Glorp meta-systemDevelopmentPrerequisites: #(#(#any 'GlorpVWPort' ''))IsDeployedBundle: trueParcel: nilParcelName: GlorpPrerequisiteParcels: #(#('GlorpVWPort' ''))Version: 8.3 - 43Date: 11:42:48 AM July 7, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on July 7, 2017 at 11:42:48 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TableSorter</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderedTables tables visitedTables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.TableSorter</class-id><body>This implements a topological sort for tables, based on the foreign key constraints between them.Instance Variables:	orderedTables	&lt;Collection of: DatabaseTable&gt;	The resulting tables in sorted order.	tables	&lt;(Collection of: (DatabaseTable))&gt;	The input tables.	visitedTables	&lt;IdentitySet of: DatabaseTable&gt;	The tables we have already visited during the sort.</body></comment><class><name>CachePolicy</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expiryAction numberOfElements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.CachePolicy</class-id><body>A CachePolicy implements the different possible policies we might use for caching. The superclass implements the trivial policy of keeping all objects forever.The policy also controls what we store in the cache. In general, it's assumed to be a cache entry of some sort, and the policy is responsible for wrapping and unwrapping objects going to and from the cache. The default policy is that the objects themselves are the cache entry (saving one object per cached object in overhead).Instance Variables	size	&lt;Number&gt;	The minimum cache size we want to use.	expiryAction &lt;Symbol&gt; What to do when an object has expired. Currently hard-coded as one of #remove, #notify, #refresh, #notifyAndRemove.</body></comment><class><name>WeakVWCachePolicy</name><environment>Glorp</environment><super>Glorp.CachePolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.WeakVWCachePolicy</class-id><body>This is a cache policy that uses VisualWorks 7.x weak references (ephemerons) to store references to objects, letting them vanish if not referenced. It uses the numberOfElements inst var as an indicator of how many objects to keep hard references to, preventing objects from disappearing too quickly.Instance Variables:</body></comment><class><name>GlorpExpression</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.GlorpExpression</class-id><body>This is the superclass of Glorp expression tree nodes. These are used to represent the where clause of a query, or things that describe relationships between objects and/or represent boolean expressions evaluated against them. They are typically created by converting a block into an expression using asGlorpExpression. Then they are used in generating the SQL string to be sent to the database.Subclasses must implement the following messages:	accessing		canHaveBase	api		base		get:withArguments:	converting		asJoin	navigating		ultimateBaseExpression	preparing		asExpressionJoiningSource:toTarget:		rebuildOn:startingFrom:withOuterScopeBase:	printing		printOnlySelfOn:		printTreeOn:</body></comment><class><name>FunctionExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>function base alias symbol type </inst-vars><class-inst-vars>functions </class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.FunctionExpression</class-id><body>This represents a database function or other modifier. For example, conversion to upper or lower case, or the ascending/descending modifier in order by clauses. At the moment it is hard-coded to to handle only the descending modifier and does not handle e.g. function arguments, functions that differ between databases, functional syntax ( as opposed to postfix). One would probably define subclasses to handle these cases, but this is the simplest thing that could possibly work for the current functionality.Instance Variables	function	&lt;String&gt;	The string we print to the database	base &lt;GlorpExpression&gt; The thing we're a function of.	alias &lt;String&gt; If we're to be selected as a field, what should we be selected as. Think SELECT t1.A + t1.B AS FRED.	symbol &lt;Symbol&gt; The original symbol used to create us. Helpful if recreating onto a different platform where the DB string can be different.	type &lt;GlorpDatabaseType&gt; Optional. If we have a type defined, then we can record it here. Otherwise, we will return the type of the field we are operating on.	</body></comment><class><name>StandaloneFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.StandaloneFunction</class-id><body>This represents a function that takes no arguments and is complete in itself. The obvious example is COUNT(*). Making a special '*' pseudo-field seems even more of a hack than just hard-coding it into a function like this. It's possible that things like nextval(sequence) might be able to fall in this category too.</body></comment><class><name>TypeResolver</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>members system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.TypeResolver</class-id><body>TypeResolvers are used to implement inheritance. Each descriptor has a type resolver, which can be asked for the types associated with that descriptor. By default we get an IdentityTypeResolver, which just gives us a single class. With inheritance we can get different types.Subclasses must implement the following messages:	accessing		classesRequiringIndependentQueriesFor:		describedConcreteClassFor:withBuilder:descriptor:	type resolution		typeMappingRootDescriptorInstance Variables:	members	&lt;(SequenceableCollection of: (Descriptor))&gt;	The descriptors of the classes that this resolver applies to.	system	&lt;DescriptorSystem&gt;	The system in which the members live.</body></comment><class><name>GlorpDatabaseType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform selector typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseType</class-id><body>This is an abstract superclass for objects representing types in the database. Each one will correspond to a particular simple type that we can store and retrieve from the database. e.g. int, varchar, and so on. For types that are variable sizes, different instances may represent, e.g. varchar(5) vs. varchar(20). While the classes may be reused across different databases, a database platform is expected to be able to return the types that it knows about as instances of these clasess. So you can send #varchar to OraclePlatform and get back one of these.Subclasses must implement the following messages:	exdi specific		exdiTypeInstance Variables	platform	&lt;DatabasePlatform&gt;	The platform that owns us.	typeString	&lt;String&gt;	Our name in the database.	selector &lt;Symbol&gt; The name of the message we can send to the platform to get ourselves or an equivalent type back again.</body></comment><class><name>GlorpAbstractNumericType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.GlorpAbstractNumericType</class-id><body>I handle types that understand numeric operators.</body></comment><class><name>GlorpDoubleType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Mapping</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor attribute debugRead debugWrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.Mapping</class-id><body>This is the abstract superclass for all Glorp mappings. A mapping defines how one particular instance variable will be mapped into and out of the database. There is considerable variation among the subclasses.Subclasses must implement the following messages:	accessing		allTables	mapping		mapFromObject:intoRowsIn:		mapObject:inElementBuilder:		referencedIndependentObjectsFrom:		trace:context:	testing		controlsTables		isRelationship		isStoredInSameTable		mappedFieldsInstance Variables:	attribute	&lt;GlorpAttributeModel&gt;	The description of the instance variable we map.	canRead	&lt;Boolean&gt;	Is this mapping allowed to read.	canWrite	&lt;Boolean&gt;	Is this mapping allowed to write.	debugRead	&lt;Boolean&gt;	For debugging purposes. If true, we will halt when this mapping is about to read..	debugWrite	&lt;Boolean&gt;	For debugging purposes. If true, we will halt when this mapping is about to write.	descriptor	&lt;Descriptor&gt;	The descriptor that contains this mapping.</body></comment><class><name>RelationshipMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query join usesLinkTable shouldProxy linkTableJoin targetTableJoin reverseJoin shouldUseFilteredRead rowMapKeyConstructorBlock controlsTables isExclusive linkFields proxyAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.RelationshipMapping</class-id><body>This is an abstract superclass for relationships between one mapped object and another (or a collection of others).Instance Variables:	join	&lt;Join&gt;	The join between our table and the target. Note that if we use a link table, this will be a join between our table and the link table.	targetTableJoin	&lt;Join&gt;	If we're using a link table, it may be desirable to also join to attributes of the main table. This optional extra join allows that.	query	&lt;SimpleQuery&gt;	The query that will return the other side of the relationship, given parameters describing our side.	linkFields	&lt;Collection of: DatabaseField&gt;	When there's a link table, we need to know the other side of the relationship, from link table to target. Usually we can figure it out based on the target table and the foreign key constraints, but sometimes (e.g. if there are multiple relationships to the same table) we need to be told which fields are the ones that connect to this table. Again that's FROM the LINK table TO the TARGET table, not the entry in the link table that we'd connect  to.	reverseJoin	&lt;Join&gt;	caches the other end of the relationship, as above.	rowMapKeyConstructorBlock	&lt;BlockClosure&gt;	Usually row map keys are constructed automatically, but it's possible that in weird cases we  might need to construct complicated ones (e.g. if there are 3 things that need to participate instead of just two, as in Store's use of the same link table and the same row to indicate the relationship from package to class and package to metaclass).	shouldProxy	&lt;Boolean&gt;	Should we proxy or directly construct the referenced object	shouldUseFilteredRead	&lt;Boolean&gt;	should we use a filtered read.	usesLinkTable	&lt;Boolean&gt;	Do we use a link table, or is it a direct join to the target.	isExclusive &lt;Boolean&gt; Is this an exclusive relationship - so that when the parent object is deleted, the child or children will also be deleted.</body></comment><class><name>OneToOneMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.OneToOneMapping</class-id><body>This represents a simple one to one relationship, e.g. from Person to Address. Assuming each person has only one address. Note that this has no methods, since a to-one relationship is the default for RelationshipMapping.</body></comment><class><name>EmbeddedValueOneToOneMapping</name><environment>Glorp</environment><super>Glorp.OneToOneMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldTranslation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id><body>This represents a one-to-one mapping in which the referenced object is stored as part of the same table as the containing object.</body></comment><class><name>PrefixFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments separator argumentModifierBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.PrefixFunction</class-id><body>This represents a function which prints prefix, printing its name, followed by the arguments in parentheses. This is the most common sort of function, e.g. MIN(), MAX(), DISTINCT, TO_CHAR Instance Variables:	arguments	&lt;(SequenceableCollection of: GlorpExpression)&gt;	Our arguments (in addition to our base).	separator	&lt;String&gt;	What we will use to separate the arguments. By default, a comma.</body></comment><class><name>Query</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session prepared expectedRows collectionType ordering maximumLobSizeToRetrieveDirectly readsOneObject grouping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.Query</class-id><body>This is an abstract superclass for Glorp queries.Subclasses must implement the following messages:	accessing		readsOneObject	executing		executeWithParameters:in:Instance Variables:	collectionType	&lt;Class&gt;	What sort of collection should this query return its results in.	expectedRows	&lt;Integer&gt;	Roughly how many rows should we expect to get back. Doesn't have to be right, but can be used to set buffer sizes appropriately in the database.	ordering	&lt;(SequenceableCollection of: (GlorpExpression | Block | Symbol))&gt;	If we order the results, what are the ordering criteria. Either an expression, but one whose root ends up evaluating to a field, or a block or symbol that can be converted to same.	prepared	&lt;Boolean&gt;	In AbstractReadQuery and subclasses, this records whether the query has already been prepared (at the Glorp level; this says nothing about prepared statements for the database, which is a wholly separate issue).  In RecursiveQuery, it records if the recursive system has been prepared.  Other subclasses do not use it.	session	&lt;GlorpSession&gt;	What session should this query execute in. Can be nil until we start to prepare the query.</body></comment><class><name>CompoundQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queries operation primaryQuery requiresDistinct </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.CompoundQuery</class-id><body>This is a query that has more than one subquery, combined by expressions like UNION ALL or INTERSECTION. It doesn't do all that much except print its subqueries and combine them according to the operation.Instance Variables:	operation	&lt;String&gt;	The name of the operation we are using to combine the queries.	primaryQuery	&lt;Query&gt;	The first query that we contain. This determines what objects we actually return. All of the queries should match up in terms of what they return, or the database is unlikely to accept this as a valid query.	queries	&lt;(SequenceableCollection of: SimpleQuery)&gt;	The queries we contain.</body></comment><class><name>RecursiveQuery</name><environment>Glorp</environment><super>Glorp.CompoundQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mappingToCloseOver retrievalMappingExpressions unionQuery fetchBaseExpression mappingDefiner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.RecursiveQuery</class-id><body>I implement a recursive SQL query using a common table expression.  I use the state and behaviour I inherit from my superclass to define the final query that will actually return rows to the user, holding my anchor and recursive queries inside a compound query.Instance Variables: 	fetchBaseExpression	&lt;BlockClosure | GlorpExpression | nil&gt;	if the recursive relation self-connects an alsoFetched class, not the primaryQuery's resultClass, give the alsoFetch expression	mappingDefiner	&lt;BlockClosure | nil&gt;	if the self-relationship to be recursed over is not already in the system, define it in the cloned descriptor (the block parameter)	mappingToCloseOver	&lt;RelationshipMapping&gt;	the self-relationship that we will follow recursively	retrievalMappingExpressions	&lt;Collection of: Symbol | MappingExpression&gt;	mapping expressions connecting the bases to the fields (these are cloned to the recursion table)	unionQuery	&lt;CompoundQuery&gt;	contains the anchor and recursive queries that between them populate the recursion table (the common table expession) Recursive queries contain the following elements (this example is in PostgreSQL form):	"First we define the common table expression."	WITH RECURSIVE ancestor(primaryKey, trace, timeStamp) AS	(	"An anchor query populates the first row(s) of the recursion.		(SELECT primarykey, trace, timeStamp			FROM tw_bundle			WHERE primarykey = 529)	"id of some bundle whose ancestors we will read"	UNION ALL	"unites the anchor query to the recursive query"		(SELECT a2.primaryKey, a1.trace, a1.timeStamp			FROM tw_bundle a1, ancestor a2			WHERE a1.primarykey = a2.trace)	)	"Finally, we select the rows to return from the common table and others"	SELECT t1.* from tw_bundle t1, ancestor t2	WHERE t1.trace = t2.trace AND t1.timeStamp = t2.timeStampThe above SELECTs from both main and recursive tables in each recursive step.  We can instead SELECT only from the main bundle, using the recursive table to hold the minimal (e.g. primary key(s) or equivalent) values returned at each step and using them to determine the next step's WHERE or JOIN conditions.  For example:	WITH RECURSIVE ancestor(primaryKey, trace) AS	(		(SELECT primarykey, trace			FROM tw_bundle			WHERE primarykey = 529)	UNION ALL		(SELECT a1.primaryKey, a1.trace			FROM tw_bundle a1, ancestor a2			WHERE  a1.primarykey = a2.trace)	)	SELECT t1.* from tw_bundle t1, ancestor t2	WHERE t1.primaryKey = t2.primaryKeyIn the code above, the recursion step's join is expressed as a WHERE clause for ease of reading.  Postgres is one of several platforms which are optimised to use ANSI Joins, rather than a WHERE clause, when joining.  Glorp generates SQL in ANSI Join form by default for such platforms.  Therefore (unless 	useANSIJoins: falseis sent to the recursive query before executing), SQL generated for a PostgresPlatform subclass will in fact look like this:	WITH RECURSIVE ancestor(primaryKey, trace) AS	(		(SELECT primarykey, trace			FROM tw_bundle			WHERE primarykey = 529)	UNION		(SELECT a1.primaryKey, a1.trace			FROM tw_bundle a1 INNER JOIN ancestor a2							ON a1.primarykey = a2.trace)	)	SELECT t1.* from tw_bundle t1, ancestor t2	WHERE t1.primaryKey = t2.primaryKeyThis is important in DB2.  DB2Platform&gt;&gt;supportsANSIJoinsWithRecursion returns false, so a RecursiveQuery sets 'useANSIJoins' to false on that platform.  However DB2 is unable to distinguish OUTER JOINS in ANSI syntax, so a RecursiveQuery using an OUTER JOIN will not run correctly there.This class has no class-side instance creation protocol.  To create an instance, send a method in AbstractReadQuery's 'recursing' protocol to a final query (or send #asRecursiveQuery to the final query followed by a cascade of setters);  load the GlorpTest parcel to find examples such as	(Query read: GlorpTreeNode where: [:each | each id = 9])		retrieve: [:each | each parent id]		thenFollow: #parent		recursivelyRetrieving: [:each | each recurse parent id]		intersect: (Query read: GlorpTreeNode).This returns all GlorpTreeNodes that are descended from the id=9 node.</body></comment><class><name>GlorpAbstractStringType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width queryType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpTextType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>DatabasePlatform</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types converters useBinding reservedWords functions characterEncoding </inst-vars><class-inst-vars>converterRepository </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabasePlatform</class-id><body>This is an abstract superclass for classes that provide a compatibility layer for different databases. They encapsulate different SQL syntaxes, binding mechanism, types that are available, and general limits.Subclasses must implement the following messages:	accessing		vwEXDIConnectionClass	binding		bindingsForGroupWritingFor:	constants		areSequencesExplicitlyCreated		supportsMillisecondsInTimes	sequences		databaseSequenceClass	testing		usesArrayBindingRatherThanGrouping	types		int4		sequence		serial		timestamp		varbinary		varcharInstance Variables:	characterEncoding	&lt;ByteSymbol&gt;	What character encoding should we use for the database connection.	converters	&lt;Dictionary from: Symbol to: DatabaseConverter&gt;	The available type converters. So, for example, if there is a boolean to integer conversion, we expect it in this dictionary associated with the symbol #booleanToInteger. If that symbol isn't there, we will look up the converter by performing #booleanToIntegerConverter and caching the result.	functions	&lt;FunctionExpression&gt;	Which functions are available for this database. There is a set of common functions created by FunctionExpression, plus we can define our own additions or overrides that are specific to this database.	reservedWords	&lt;Collection of: String&gt;	Which names are reserved words in this database. Any that we use as table or column names will need to be quoted.	types	&lt;Dictionary from: Symbol to: GlorpDatabaseType&gt;	A cache of available types, mapped by name to the type instance.	useBinding	&lt;Boolean&gt;	By default, should we use binding for this database.</body></comment><class><name>MySQLPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.MySQLPlatform</class-id><body>This is a definition for MySQL databases. It's not done yet, just here as a placeholder.</body></comment><class><name>MySQLODBCPlatform</name><environment>Glorp</environment><super>Glorp.MySQLPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>VersionType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingType generator generatesOverExistingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VersionType</class-id><body>This represents the type of something used for a version field.Instance Variables:	underlyingType	&lt;DatabaseType&gt;	The type of our field, into which we will write generated values of that type.	generatesOverExistingValues	&lt;Boolean&gt;	If a field already has a value, do we generate another?	generator	&lt;GlorpDatabaseValueGenerator&gt;	The generator used to generate the next value.</body></comment><class><name>GlorpAttributeModel</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type collectionType keyType classModel attributeIndex useDirectAccess setSelector canRead canWrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.GlorpAttributeModel</class-id><body>This is the metadata for an individual instance variable. It will be held in a GlorpClassModel, and used for accessing the variable when building or writing out objects.Instance Variables:	attributeIndex	&lt;Integer&gt;	If we use instVarAt:{put:} to get/set values, cache the instance variable index in the class	canRead	&lt;Boolean&gt;	May I read my value from the database and set it on the object?	canWrite	&lt;Boolean&gt;	May I get my value from the object and write it to the database?	classModel	&lt;GlorpClassModel&gt;	The class model that contains us.	collectionType	&lt;Class&gt;	If we are an attribute that holds a collection, what is the class of the collection.	keyType	&lt;Class&gt;	If we represent a dictionary attribute, what is the type of our key (type will hold the type of our value in that case).	name	&lt;Symbol&gt;	The name of the attribute/instance variable (also the get selector)	setSelector	&lt;Symbol&gt;	the selector I use for setting (if useDirectAccess false), lazily initialized to #&lt;name&gt;:	type	&lt;Class&gt;	The class possessing the instance variable that I model	useDirectAccess	&lt;Boolean&gt;	Do I use instVarAt:{put:} to access my attribute values (the default) or name{:} ?</body></comment><class><name>ObjectExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mappingExpressions requiresDistinct tableAliases fieldAliases </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ObjectExpression</class-id><body>This is a not-especially well-named superclass for expressions that end up mapping to rows in the database, more or less. That is, it's more or less a superclass for things that have the capacity to alias tables, and to have mapping expressions derived from them. Since, depending on your point of view, everything is an object, the name isn't very descriptive. Or if some things aren't considered objects, TableExpression is a good candidate. But we have the common functionality for managing tables, and for keeping a dictionary of our sub-mapping expressions.Subclasses must implement the following messages:	accessing		system		table	fields		controlsTablesInstance Variables:	fieldAliases	&lt;Dictionary from: DatabaseField to: DatabaseField&gt;	For each field, the corresponding aliased field for our query. So, e.g. PERSON.NAME will map to t1.NAME. These aren't strings, though, these are fields derived from the aliased table.	mappingExpressions	&lt;Dictionary from: Symbol to: ( MappingExpression | TableExpression) &gt;	Each attribute that's derived from us will be maintained in this dictionary. This is very important, because Glorp relies critically on these expressions being identical. So "object field == object field".	requiresDistinct	&lt;Boolean&gt;	Do the fields that we will cause to be added to the SELECT portion of the query need a DISTINCT wrapped around them?	tableAliases	&lt;Dictionary from: DatabaseTable to: DatabaseTable&gt;	While the query is being prepared, tables will be assigned aliases. This keeps track of the aliases for the tables that we control. As with fieldAliases, note that this stores table copies with their names altered, not strings.</body></comment><class><name>MappingExpression</name><environment>Glorp</environment><super>Glorp.ObjectExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name base outerJoin mapping phantom </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.MappingExpression</class-id><body>This represents an attribute of some other object. It's called a mapping expression because each attribute has a mapping, and when we come to prepare the query, we'll be using that mapping's information to deduce joins, and to print properly.Instance Variables:	base	&lt;BaseExpression | MappingExpression&gt;	The expression we are built on, which is to say the expression describing the object of which we are an attribute.	mapping	&lt;Mapping&gt;	The mapping we correspond to in the base. So if the base was [:each | each owner city] and we are #name, then we the mapping is for the attribute #name in the descriptor for City.	name	&lt;Symbol&gt;	The name of our attribute. We will use this to determine the mapping.	outerJoin	&lt;Boolean&gt;	Are we to interpret the join to our parent object's table as being an outer join or not?	phantom &lt;Boolean&gt; Is this a phantom mapping - one which is not defined in the descriptor explicitly, but is temporarily created to define a reverse relationship, an alsoFetch of subclasses, or some other transient usage.</body></comment><class><name>DatabaseAccessor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection currentLogin logging logger logOnly reusePreparedStatements deniedCommands mutex dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseAccessor</class-id><body>This translates between the the general, portable Glorp protocol and whatever needs to be done to access a database in a particular smalltalk dialect. Most of the real work is done in its subclasses.Subclasses must implement the following messages:	accessing		connectionClassForLogin:	executing		basicExecuteSQLString:		externalDatabaseErrorSignal		rowCount	login		loginIfError:		logout		showDialog:Instance Variables	connection	&lt;varies&gt;	The underlying database connection	currentLogin	&lt;Login&gt; The glorp-level login we are using	logging	&lt;Boolean&gt;	(default is false) Is logging on or off	logOnly &lt;Boolean&gt; (default is false) If logging is true, and logOnly is true, then the commands are ONLY logged and not executed.	logger &lt;TextCollector&gt; (default is Transcript) The user can put any TextCollector API supporting class in here to collect information. It must support #show: and #cr.	permittedCommands	&lt;Collection of: DatabaseCommand class&gt;	The list of commands we are permitted to use. This allows us to filter commands, indicating that a particular session should only be doing inserts right now, not updates, deletes, or queries. Or that it should only be doing writes, not reads.	reusePreparedStatements	&lt;Boolean&gt;	Should we try to reuse prepared statements,that have the same SQL, or just re-prepare each time.</body></comment><class><name>VADatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isInTransaction </inst-vars><class-inst-vars>databaseErrorSignal </class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VADatabaseAccessor</class-id><body>An accessor for VisualAge 8.0 and higher. Instance Variables	isInTransaction	&lt;Boolean&gt;	Are we in a transaction. We don't have an indicator for this from the database layer, so keep track of it here.</body></comment><class><name>UnmanagedCache</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items policy extraReferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.UnmanagedCache</class-id><body>An unmanaged cache, e.g. the preparedStatements cache of a VWDatabaseAccessor, has no CacheManager and so no access to a session or descriptor system.  It caches items added by the user and expires them according to its user-assigned policy.Instance Variables:	items	&lt;Dictionary from: Object to: Object&gt;	The cached items, keyed by their primary key values	policy	&lt;CachePolicy&gt;	Controls whether data is held with the instance, whether and when it expires, etc.	extraReferences	&lt;nil|FixedSizeQueue&gt;	Weak policies can keep a fixed number of instances</body></comment><class><name>Cache</name><environment>Glorp</environment><super>Glorp.UnmanagedCache</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.Cache</class-id><body>This is the per-class cache of instances read from the database.  A CachePolicy is assigned by the descriptor (or, if the cache's class has no descriptor in the session's system, by default) and controls whether and how the cached instances are expired.Instance Variables:	mainCache	&lt;CacheManager&gt;	manages a group of class-specific caches of instances read in a session</body></comment><class><name>FieldValueWrapper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contents hasValue containedBy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.FieldValueWrapper</class-id><body>When we are creating our rowmap, we need to be able to unify values. That is, we express the constraint that field A in table T1 must be equal to field B in table T2. And we have to be able to do this whether or not we have yet assigned a value to either of these fields, and whether or not other equality constraints have already been imposed on one or the other of these fields. We do this by holding the values in a wrapper. When we unify them, we replace one wrapper with the other, so that both rows now refer to the same value. In order to efficiently find where things are contained, we hold a collection of the containing rows.Instance Variables:	containedBy	&lt;(Association key: DatabaseField value: (IdentitySet of: DatabaseRow)) | (IdentityDictionary of: Same)&gt;	The rows that contain this wrapper. Using a trick similar to #dependents, we optimize the containedByCollection to be an association if we are only contained in one row (the most common case). Otherwise we have a dictionary. The containing rows are indexed by field, because when we're updating the row to replace the wrapper, we need to know which field to replace. Also, a single row could conceivably contain the same wrapper in two different fields, and both need to be updated.	contents	&lt;Object&gt;	The value we contain	hasValue	&lt;Boolean&gt;	Has our value been set or not. We can't just test for nil in contents, because nil is a valid value.</body></comment><class><name>BasicTypeResolver</name><environment>Glorp</environment><super>Glorp.TypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>concreteMembers subclassDescriptorsBuilt rootDescriptor rootClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.BasicTypeResolver</class-id><body>This is an abstract superclass for TypeResolvers that do inheritance in some form.Instance Variables:	concreteMembers	&lt;(Collection of: (Descriptor))&gt;	Which of our members can actually be instantiated, as opposed to abstract superclasses.	rootClass	&lt;Behavior&gt;	Which is the root class of the inheritance hierarchy we represent.	rootDescriptor	&lt;Descriptor&gt;	The descriptor for the root class	subclassDescriptorsBuilt	&lt;Boolean&gt;	Have we asked the system for the descriptors for all of the root's subclasses yet?</body></comment><class><name>FilteredTypeResolver</name><environment>Glorp</environment><super>Glorp.BasicTypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.FilteredTypeResolver</class-id><body>This is a type resolver for inheritance where all of the classes are represented in a single table, with some sort of identifying field for which subclass they are. The table would have the union of all possible fields for all classes. It's called filtering, because for any particular class, we filter out those instances from all those represented in the table.</body></comment><class><name>GlorpCharType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>BaseExpression</name><environment>Glorp</environment><super>Glorp.ObjectExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor availableSubSelectNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.BaseExpression</class-id><body>This represents the base object that we're looking for in a query. So if we ask to read: Person, then we will have a base expression corresponding to Person. Even if what we end up retrieving is not part of the Person object, it remains the base, because it's what defines our point of view.Instance Variables:	availableSubSelectNumber	&lt;Integer&gt;	As the base of the query, we keep track of how many subselects there are. New subselects will need to have a unique number so they can prefix their tables as e.g. s1t1 when aliasing them, and the number comes from this counter.	descriptor	&lt;Descriptor&gt;	The descriptor for the class we're looking for.</body></comment><class><name>VWDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driverSession preparedStatements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-VW3</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VWDatabaseAccessor</class-id><body>An accessor for VisualWorks EXDI connections.Instance Variables:	driverSession	&lt;ExternalDatabaseSession&gt;	If we aren't re-using a prepared statement, then we work directly with a single EXDI session that we keep hold of and reuse for each command.	preparedStatements	&lt;UnmanagedCache&gt;	A cache of prepared statements that we can re-use, if the platform supports such reuse, keyed by their SQL and bindTemplate concatenated.</body></comment><class><name>GlorpFloatType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>TimedExpiryCachePolicy</name><environment>Glorp</environment><super>Glorp.CachePolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timeout </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.TimedExpiryCachePolicy</class-id><body>This implements a cache that notes that an object is stale after some amount of time since it has been read.Instance Variables:	timeout	&lt;Integer&gt;	The time in seconds until we note an object as needing refreshing.</body></comment><class><name>TimedStrongCachePolicy</name><environment>Glorp</environment><super>Glorp.TimedExpiryCachePolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.TimedStrongCachePolicy</class-id><body>This implements a cache that notes that an object is stale after some amount of time since it has been read.Instance Variables:	timeout	&lt;Integer&gt;	The time in seconds until we note an object as needing refreshing.</body></comment><class><name>GlorpRelativeValueType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.GlorpRelativeValueType</class-id><body>GlorpRelativeValueType uses a delegation pattern, representing any database type that can support a 'relative update' like this:	UPDATE aTable SET aColumn = aColumn + 10 WHERE ...The SQL doesn't overwrite the target value directly, but changes it relative to what it was.  If noone else has updated aColumn between Glorp's reading and writing it, this will just be the value the instance already has.  Otherwise, to keep Glorp and the database in synch after commit, the full SQL resembles	UPDATE aTable SET aColumn = aColumn + 10 WHERE ... RETURNING aColumnso that the value of the returned type can be set on the image instance.  (Not all platforms support this:  a platform that returns false to supportsReturningUpdatedValues will not set the new value and so must use relative values with caution, discarding written objects or explicitly refreshing them.)Instance Variables:	underlyingType	&lt;GlorpDatabaseType&gt;	The type my instance represents (typically, a subclass of GlorpAbstractNumericType).</body></comment><class><name>GlorpBlobType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queryType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>AdabasLikePlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.AdabasLikePlatform</class-id><body>This is a platform for Adabas and related databases.</body></comment><class><name>GlorpDatabaseValueGenerator</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseValueGenerator</class-id><body>This is an abstract superclass for thing that generate values when objects are written to the database. The most common usage is the various types of sequences, identity columns and other primary key generating mechanism. But it can also be used for optimistic locking via version numbers or timestamps. It doesn't actually have any code at the moment, so it might just be deletable, or maybe there's some refactoring to be done.</body></comment><class><name>DatabaseSequence</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseValueGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reservedNumbers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseSequence</class-id><body>This is an abstract superclass for identifier generation mechanisms in the database. For example, Oracle sequences, SQL Server identity columns, and so on.Subclasses must implement the following messages:	sequencing		getSequenceValueFromDatabaseFor:in:using:		postWriteAssignSequenceValueFor:in:using:Instance Variables:	reservedNumbers	&lt;OrderedCollection&gt;	Numbers that we have already reserved and have available. This is only useful if the sequence can generate more than one identifier in a single request, and we have configured it (and ourselves) to do so and use those numbers. This is useful for efficiency when inserting lots of data.</body></comment><class><name>NamedSequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name tableSelectCommand schema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.NamedSequence</class-id><body>This is a database sequence that is identified by name.Subclasses must implement the following messages:	SQL		tableSelectCommandFor:in:reserving:Instance Variables:	name	&lt;String&gt;	The name of the sequence	schema	&lt;String&gt;	The schema that contains the sequence. Subclasses should set this up appropriately.	tableSelectCommand	&lt;SQLStringSelectCommand&gt;	The command to execute to get the next value. </body></comment><class><name>DB2IdentitySequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DB2IdentitySequence</class-id><body>DB2IdentitySequence is the sequence class for DB2 identity columns. Glorp prefers sequence objects over identity columns, and although DB2 has both, Glorp defaults to using sequences. Therefore there is no code here to create an identity column. Primary keys will use sequences instead. DB2IdentitySequence primarily helps in the analysis of tables that were created outside Glorp.One can obtain the most recently installed number using a query like this.	VALUES IDENTITY_VAL_LOCAL().</body></comment><class><name>GlorpVirtualCollection</name><environment>Glorp</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query session realObjects parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpVirtualCollection</class-id><body>This represents a virtual collection, i.e. one that we haven't really read into memory yet. It responds to a reasonable subset of collection protocol, and will read the elements into memory only when necessary. So, e.g. a select: operation takes a query block, and is equivalent to AND:ing that query block to the main query.To create a virtual collection, ask the session for one. e.g. session virtualCollectionOf: AClass.This is an initial version which will read in the objects fairly eagerly. An optimization might be to defer certain types of operations depending on whether the block can be evaluated into SQL or not. e.g.  collect: [:each | each name]can be turned into a retrieve: operation. But   collect: [:each | each printString]cannot. We could try to check the block for operations like collect: and detect:, deferring the point at which the objects will be read in.Handling of ordering is also a little bit funny. The blocks we like for ordering aren't compatible with sortedCollection type blocks. It'd be nice to be more compatible.</body></comment><class><name>IIF</name><environment>Glorp</environment><super>Glorp.PrefixFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argumentTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.IIF</class-id><body>This represents a MS ACCESS function which prints prefix, printing IIF, followed by the argument in parentheses, and then the rest of the MS SQL Server CASE statement, with a single test condition (WHEN) and a default value (ELSE):Example: IIF(Condition, ReturnIfTrue, ReturnIfValue)	IIF ( base? = arg1, arg2, arg3 ) AS aliasFor example:	IIF (('SELECT count(*) FROM aTable')= '0', 0, 1 ) AS alias</body></comment><class><name>VersionGenerator</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseValueGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VersionGenerator</class-id><body>An abstract superclass for generators that generate version numbers (rather than sequence numbers).Subclasses must implement the following messages:	sequencing		nextValueFor:in:</body></comment><class><name>AdHocVersionGenerator</name><environment>Glorp</environment><super>Glorp.VersionGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block numberOfArguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.AdHocVersionGenerator</class-id><body>This is a version generator that takes an arbitrary block and runs it.Instance Variables:	block	&lt;BlockClosure&gt;	The block we evaluate to get the next version.	numberOfArguments	&lt;Integer&gt;	Generated automatically. How many arguments does block take. If zero, we invoke it without our arguments. If not, we give it the arguments to use.</body></comment><class><name>JoinBaseExpression</name><environment>Glorp</environment><super>Glorp.BaseExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.JoinBaseExpression</class-id><body>When we use an expression as a join, we tend to write it backwards. We use expressions when the relationship is more complicated than we can express as a single join. And we describe it by giving the target and describing how to use relationships to get from the target object to the source object. We can't do it forwards, because the forward relationship is exactly what we're trying to describe with this join. For example, for a (rather contrived) Address to Job relationship, we might write it as  [:eachJob | eachJob worker address]However, this means that when we're trying to rebuild this expression and fit it into a query, it's backwards from most expressions. We know that, so we give it a special kind of base that makes it rebuild itself slightly different, by preferring the target rather than the source.  </body></comment><class><name>DatabaseConverter</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseConverter</class-id><body>This is a superclass for objects that convert back and forth between database representations and object representations.Subclasses must implement the following messages:	converting		convert:fromDatabaseRepresentationAs:		convert:toDatabaseRepresentationAs:Instance Variables:	name	&lt;ByteSymbol&gt;	The name for this converter. The name is used, concatenated with #Converter, to create a symbol that can be performed against the DatabasePlatform to give this converter. So, e.g. booleanToIntegerConverter.</body></comment><class><name>PluggableDatabaseConverter</name><environment>Glorp</environment><super>Glorp.DatabaseConverter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stToDb dbToSt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PluggableDatabaseConverter</class-id><body>This is a converter where the conversion is specified by two blocks.Instance Variables	dbToSt	&lt;BlockClosure&gt;	The block to run to convert from the database representation to the Smalltalk representation. Takes one argument, the value to be converted.	stToDb	&lt;BlockClosure&gt;	The block to run to convert from the Smalltalk representation to the database representation. Takes one argument, the value to be converted.</body></comment><class><name>ToManyMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderBy shouldWriteTheOrderField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ToManyMapping</class-id><body>This is a superclass for mappings which represent a relationship between one object and a collection of others. It isn't an abstract superclass, you can use this class directly, and you will get the same behaviour as if you were using OneToManyMapping. Or if you set useLinkTable to true, you'll get the same behaviour as a ManyToManyMapping.Instance Variables:	orderBy	&lt;(SequenceableCollection of: (GlorpExpression | BlockClosure))&gt;	By what criteria should we order the collection of items when we are reading.	shouldWriteTheOrderField	&lt;Boolean&gt;	On write, when we write an item in the collection, should we also write the index at which it occurs in the collection into the database. This lets us preserve ordering if we just used a SequenceableCollection in memory. If this is true, we assume that the first item in orderBy will give us the field to write the index into.</body></comment><class><name>SQLite3PragmaMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMappings</package></attributes></class><class><name>RecursiveMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.RecursiveMapping</class-id><body>I exist to let knitting behaviour be partitioned between me and RecursiveBuilder in the development of Glorp recursion.</body></comment><class><name>NullConverter</name><environment>Glorp</environment><super>Glorp.DatabaseConverter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.NullConverter</class-id><body>This is a no-op converter. When converting in either direction, it just returns the value.</body></comment><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues supportsUnboundRowCount canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLServerPlatform</class-id><body>This is a platform for the Microsoft SQL Server database.  SQLServer uses type Bit (values 0 and 1) to represent booleans in the database.</body></comment><class><name>AccessPlatform</name><environment>Glorp</environment><super>Glorp.SQLServerPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.AccessPlatform</class-id><body>This is a platform for the Microsoft Access database. It subclasses from SQL Server, because the two have a number of characteristics in common.</body></comment><class><name>TypeMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.TypeMapping</class-id><body>TypeMappings are used to implement inheritance. They do not map to particular instance variables, but instead define things about the way the class is read. The default type mapping is IdentityTypeMapping, which does nothing. To use inheritance, substitute either a FilteredTypeMapping or a HorizontalTypeMapping. TypeMappings become part of a TypeResolver, which keeps the information for a class and its subclasses, each of which will have a typeMapping specific to that class.Subclasses must implement the following messages:	testing		isAbstract</body></comment><class><name>FilteredTypeMapping</name><environment>Glorp</environment><super>Glorp.TypeMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field key keyDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.FilteredTypeMapping</class-id><body>FilteredTypeMapping assumes that all objects are stored in a single table, and there's a field in that table that identifies which subclass it is.Instance Variables:	field	&lt;DatabaseField&gt;	The field which identifies the subclass.	key	&lt;Object&gt;	The value we expect to find in that field for this particular subclass	keyDictionary	&lt;Dictionary&gt;	A dictionary for us and all of our subclasses from key values to subclass.</body></comment><class><name>OracleSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count sequenceIncrement accessProtect </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OracleSequence</class-id><body>This supports Oracle sequence using select nextval from sys.allObjects. It also supports getting multiple sequence numbers at once. Going against AllObjects seemed to work much better than going against any real table.Instance Variables:	accessProtect	&lt;RecursionLock | Semaphore&gt;	Mutual exclusion on our sequence allocation, since we may need to protect our cache of already-allocated numbers, and prevent two different processes from going to the database simultaneously. This might want to be pushed up to a superclass so it can be shared.	count	&lt;Number&gt;	How many identifiers have we gotten in a row without going to the database.	sequenceIncrement	&lt;SmallInteger&gt;	By how much does the sequence in the database increment on each nextVal call.</body></comment><class><name>DB2Sequence</name><environment>Glorp</environment><super>Glorp.OracleSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DB2Sequence</class-id><body>DB2Sequence implements DB2 sequences using nextVal. The mechanism is similar to that of Postgres.Get a sequence number using a query like this. 	SELECT NEXT VALUE FOR my_sequence.Note that DB2 sequences are only supported in single partition databases.Instance Variables	accessProtect	&lt;RecursionLock | Semaphore&gt;	Mutual exclusion on our sequence allocation, since we may need to protect our cache of already-allocated numbers, and prevent two different processes from going to the database simultaneously. This might want to be pushed up to a superclass so it can be shared.	count	&lt;Number&gt;	How many identifiers have we gotten in a row without going to the database.	sequenceIncrement	&lt;SmallInteger&gt;	By how much does the sequence in the database increment on each nextVal call.</body></comment><class><name>OcelotPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OcelotPlatform</class-id><body>This is a platform for the open-source Ocelot database.</body></comment><class><name>FirebirdPlatform</name><environment>Glorp</environment><super>Glorp.OcelotPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.FirebirdPlatform</class-id><body>This is a Glorp platform for the InterBase and Firebird databases.  It is currently subclassed from Ocelot because both claim to be highly standard-compliant.  It would probably be better if both inherited from some sort of abstract SQL92Platform.Firebird/InterBase supports binding in all statements (indeed its EXDI appears to require it for blobs) and can also reuse SELECT statements, but reuse of RowBasedCommands (INSERT, DELETE, UPDATE) for blobs is unreliable although binding of such statements is essential.  Set	reusePreparedStatements: falseon Logins that have an instance of this class as their platform.</body></comment><class><name>TransformingFieldValueWrapper</name><environment>Glorp</environment><super>Glorp.FieldValueWrapper</super><private>false</private><indexed-type>none</indexed-type><inst-vars>forwardTransformation inverseTransformation innerWrapper </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpUnitOfWork</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.TransformingFieldValueWrapper</class-id><body>This wraps another wrapper and transforms its value.Instance Variables:	forwardTransformation	&lt;Block&gt;	What to do to convert our value going out.	innerWrapper	&lt;FieldValueWrapper&gt;	The wrapper that really has the value.	inverseTransformation	&lt;Block&gt;	What to do to convert our value going in.</body></comment><class><name>TableExpression</name><environment>Glorp</environment><super>Glorp.ObjectExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.TableExpression</class-id><body>This is an expression representing a table. Typically we refer to things in terms of objects which control tables, but sometimes you want to refer directly to a table that's not mapped, either in the process of building up a more OO representing (e.g. referring to a link table) or because we just want to do something more complicated that's not mapped, or incompletely mapped.Instance Variables:	base	&lt;BaseExpression | MappingExpression&gt;	The expression on which we are built.	table	&lt;DatabaseTable&gt;	The table that we represent.</body></comment><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.GlorpSession</class-id><body>This is the main class for communicating between the user and Glorp. It acts as a broker for reading queries, and as the main point for registering objects for modification.A note about the distinction between #begin/rollback/commitUnitOfWork and #begin/rollback/commitTransaction is in order. There are two basic scenarios. In the first scenario, you wrap your updates in a UnitOfWork using #beginUnitOfWork, doing the updates, and then #commitUnitOfWork. Method #commitUnitOfWork privately sends #beginTransaction, writes all the data to disk, and then sends #commitTransaction. So, the UnitOfWork itself keeps track of all the updates, and if commited, it sends them on to the database within a private Transaction.In the second scenario, you control the Transaction, starting with #beginTransaction. If you then wrap your updates inside a UnitOfWork, you get the same behavior as before--the UnitOfWork won't send to disk until you say #commitUnitOfWork. But this time, your UnitOfWork will notice that you have an ongoing Transaction so it sends neither #beginTransaction nor #commitTransaction. Instead, it expects you to send #commitTransaction later. In short, it won't touch the Transaction control since you own it. This scenario can be used to execute a series of operations, each in a separate UnitOfWork, where all can be committed or rolled back downstream.Of course, a UnitOfWork is optional, likewise a Transaction, but their use is much recommended.Instance Variables	system	&lt;DescriptorSystem&gt;	The definition of our tables, classes, and the relationships between them.	currentUnitOfWork	&lt;UnitOfWork | nil&gt;	If we have an active unit of work, this will hold it. All modifications are tracked through the unit of work.	cache	&lt;CacheManager&gt;	Our cache of objects that we've already read.	accessor	&lt;DatabaseAccessor&gt;	Our connection to the database.	application	&lt;?&gt;	application-specific data	reaper &lt;TimedProxyReaper&gt; If we are using TimedProxy for some of our relationships, this holds the reaper which will expire them on timeout.	errorAction &lt;Block&gt; What block should we evaluate when there's an error.	modificationTracker &lt;GlorpVWWriteBarrierTracker&gt; VisualWorks-specific. This holds the GlorpVWWriteBarrierTracker in use for this session. This uses immutability to keep track of objects which are changed.</body></comment><class><name>Join</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources targets base outerJoin owningMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.Join</class-id><body>This is a specialized variety of expression that is more constrained and is used for defining relationships. It has two main purposes - ease of construction: Relationships are normally defined by field to field equality expressions (my foreign key field = his primary key field). These are more tedious to create via block expressions, so this provides a simpler syntax. - constrained semantics. These define both read and write for the relationship, so fully general expressions won't work (most notably, relations other than equality are hard to write). Using a primaryKeyExpression ensures that we satisfy these constraints.I'm not completely sure this class is a good idea. It makes for an annoying assymetry between different kinds of expressions. This is especially notable now that we allow sources to be constants. It's possible that all we need is an expression constructor that generates real expressions, but with more convenient syntax and ensuring that the constraints are met.Note that although these are typically fk=pk, it's allowed to be the other way around -- i.e. our object-level relationships can be the opposite of the way the fk's "point" in the database.Instance Variables:	base	&lt;BaseExpression&gt;	The base on which we are built. Mostly used if we want to convert this into a real expression.	sources	&lt;SequenceableCollection of: (DatabaseField | ConstantExpression)&gt; The source fields (typically the foreign keys)	targets	&lt;SequenceableCollection of: DatabaseField&gt; The target fields (typically the targets of the foreign keys)</body></comment><class><name>GlorpVarBinaryType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>width </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>ConditionalMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conditionalField conditionalMethod cases otherwiseCase conditionalFieldMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ConditionalMapping</class-id><body>This is a mapping that does different things depending on some testable condition. Depending on whether we're reading or writing, we are likely to test different things. This is useful if a field can be interpreted in more than one way. The API is rather messy.Instance Variables:	cases	&lt;SequenceableCollection of: (Association)&gt;	Used on read - a list of associations representing the cases we test. The key is either a one-argument block to be evaluated or a one-argument selector to be performed by the descriptorSystem, returning a boolean, and the value is the mapping to use if it returns true. 	conditionalField	&lt;DatabaseField&gt;	The field whose value will be used as the argument to the blocks/selectors in cases.	otherwiseCase	&lt;Mapping&gt;	If none of the other cases evaluate to true on read, use this mapping.	conditionalMethod	&lt;Block | Symbol&gt;	Used on write - a zero-argument selector or one-argument block. The selector will be sent to the object being written, the block will be evaluated with that object as the argument. This is expected to return the object that will be written via the appropriate mapping.	conditionalFieldMapping	&lt;Mapping&gt;	Used on write - the mapping used to write out the value in the conditional field.</body></comment><class><name>DirectToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DirectToManyMapping</class-id><body>This is a to-many mapping where the class in the collection is a simple type, not a compound object. This requires fiddling with the descriptors, to allow each such mapping to define a different descriptor for the target class. This should be regarded as something of a prototype. It seems to work, at least for basic operations, but it may well have problems.Instance Variables:	resultField	&lt;DatabaseField&gt;	The field in the target table in which we have our results.</body></comment><class><name>DatabaseCommand</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useBinding stream sqlString session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseCommand</class-id><body>A DatabaseCommand is what a query uses to actually generate its SQL and to execute it. A command wraps a stream, into which the SQL is written, but with knowledge of the platform for which it's being written, and potentially details about how it should execute.Subclasses must implement the following messages:	accessing		arrayBoundFields		bindings		bindingTypes		parameterTypeSignature	executing		printSQL	testing		succeededInstance Variables:	platform	&lt;DatabasePlatform&gt;	The database for which we're to generate/execute SQL.	sqlString	&lt;String&gt;	The resulting SQL.	stream	&lt;Stream&gt;	The stream into which we generate the SQL. Once we've finished and got sqlString this isn't necessary any more.	useBinding	&lt;Boolean&gt;	Should we use binding, or print parameters directly into the string.</body></comment><class><name>RowBasedCommand</name><environment>Glorp</environment><super>Glorp.DatabaseCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>row allRows rowCount failed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.RowBasedCommand</class-id><body>This is a command based on one or more in-memory rows. The purposes is to write, or delete that row or rows. This knows enough to be able to use features like array binding to do the row operations more efficiently.Subclasses must implement the following messages:	bound values		arrayBoundFields		singleRowBoundFieldsInstance Variables:	allRows	&lt;(Collection of: (DatabaseRow))&gt; A collection of rows. May be nil. If we have multiples, then we will be array bound or otherwise bulk-written under certain circumstances.	row	&lt;DatabaseRow&gt;	The primary row, either the single row we're writing, or the one we're writing right now out of the allRows collection.	rowCount	&lt;Integer&gt;	The row count from the last statement we executed.	succeeded	&lt;Boolean&gt;	Has the statement overall succeded or failed.</body></comment><class><name>UpdateCommand</name><environment>Glorp</environment><super>Glorp.RowBasedCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.UpdateCommand</class-id><body>A command to update one or more rows.  The updated row is identified by the values of its primary key field(s), e.g.	UPDATE AUTHOR SET NAME = 'William Shakespeare' WHERE ID = 2and by those of its lock key field(s) if present, e.g.	UPDATE BOOK SET COPIES_IN_STOCK = 4000,VERSION = 3 WHERE ID = 23 AND VERSION = 2Lock fields can be used to assist optimistic locking by blocking update of written-since-read rows.  A lock field appears in the UPDATE clause, with its to-write value, and again in the WHERE clause, with its was-read value.In a where clause, the SQL must be WHERE ... IS NULL, not WHERE ... =NULL, whether binding or not, so my #printSQL method writes IS NULL if a lock field's was-read value is nil (see #printLockEqualityForField:on:, which leads through a RelationalEpression to #printWithNullOn:)..  Thus we can have	UPDATE BOOK SET TITLE = ?,COPIES_IN_STOCK = ?,VERSION = ? WHERE ID = ? AND VERSION = ?bound to	#('Mastering ENVY/Developer' 4000 3 5 2)but if the bound values were	#('Mastering ENVY/Developer' 4000 1 5 nil)then the SQL would be	UPDATE BOOK SET TITLE = ?,COPIES_IN_STOCK = ?,VERSION = ? WHERE ID = ? AND VERSION IS NULLIf there is only one lock field then its final nil binding value would have no bind marker and could just be ignored (as happened in older Glorp).  When there are two lock fields (rarer case), a nil read value for the first would be bound to the second's ? in the SQL, its own value being ignored.  Therefore I suppress binding nil to a lock field.</body></comment><class><name>RelativeUpdateCommand</name><environment>Glorp</environment><super>Glorp.UpdateCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relativeFields lockKeyFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.RelativeUpdateCommand</class-id><body>One or more of my fields' types isRelativeType, which means that instead of reading a value of 20 and writing a value of 100 as in 	UPDATE AUTHOR SET BALANCE = 120 WHERE ID = 2we write, for such a field,	UPDATE AUTHOR SET BALANCE = BALANCE + 100 WHERE ID = 2Thus, as an alternative to optimistic locking (i.e. using one or more lock fields to abort update if the row has been updated by someone else between our reading and updating it), Glorp can compute the read-to-update difference, write a relative update statement and so be sure the increment is correct whatever other changes have been made in the interim.Instance Variables:	relativeFields	&lt;SequenceableCollection&gt;	fields to be updated whose type isRelativeType.	normalFields		&lt;SequenceableCollection&gt;	fields to be updated whose type is neither Lock Key nor Relative.</body></comment><class><name>ReturningUpdateCommand</name><environment>Glorp</environment><super>Glorp.RelativeUpdateCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.ReturningUpdateCommand</class-id><body>After updating a relative field, return the value of that field and set it on the image object.  Here's an example query	UPDATE table SET field = field + 100 - 20 WHERE id = 1 RETURNING fieldIn this example, the final value of the relative field is now 80 (the difference between its initial value of 20 read by Glorp and its changed value of 100 set in the image) plus whatever else may have been added or subtracted in other processes.  The updated final value is returned and set on the object by Glorp.</body></comment><class><name>OutputUpdateCommand</name><environment>Glorp</environment><super>Glorp.ReturningUpdateCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OutputUpdateCommand</class-id><body>I behave like my superclass, with a slight change in my query's syntax. Here's an example.	UPDATE table SET field = field + ? - ? OUTPUT INSERTED.field WHERE id = ?This form is needed by SQLServer.  Because it inserts the OUTPUT before the WHERE clause, i.e. in the middle of the update statement, it must be more invasive in its overriding of the super implementation.</body></comment><class><name>FixedSizeQueue</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>maximumSize items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.FixedSizeQueue</class-id><body>This is a fixed size queue of objects. It's intended for keeping around a fixed number of references to objects in a weak dictionary. As such its API is rather limited (one method), and it's write-only.Instance Variables:	items	&lt;OrderedCollection&gt;	The items in the queue	maximumSize	&lt;Integer&gt;	How many items we're allowed</body></comment><class><name>SelectCommand</name><environment>Glorp</environment><super>Glorp.DatabaseCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameters blockFactor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SelectCommand</class-id><body>This represents a SELECT query to the database. This can either be based on a GLORP query, or on a hard-coded SQL string.Subclasses must implement the following messages:	accessing		printSQLInstance Variables:	blockFactor	&lt;SmallInteger&gt;	The blocking factor to use for this query. This is most likely to make a difference for these kind of operations, and so is directly settable here.	parameters	&lt;Dictionary from: DatabaseField to: Object&gt;	The parameters to the query.</body></comment><class><name>Descriptor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tables mappings system mappedFields cachePolicy typeResolver mapsPrimaryKeys keyFields classModel multipleTableJoin imaginaryTableReplacements mappingsForFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.Descriptor</class-id><body>For each persistent class, there is a descriptor. This is what tells GLORP how to read and write objects of this class. The descriptor is not actually a very complicated object, because most of the information is in the mappings described below. But the descriptor does keep hold of a few per-class pieces of information, notablyInstance Variables:	cachePolicy	&lt;CachePolicy&gt;	The cache policy to use. If left blank, default to what the system specifies.	describedClass	&lt;Class&gt;	The persistent class that we map.	mappedFields	&lt;Collection of: DatabaseField&gt;	The database fields we have mappings for (cached computed value)	mappings	&lt;(Collection of: Mapping)&gt;	Our mappings.	mapsPrimaryKeys	&lt;Object&gt;	Do we map the primary keys (cached computed value)	multipleTableJoin	&lt;(Collection of: Join)&gt;	description of multipleTableCriteria	system	&lt;DescriptorSystem&gt;	The descriptor system that we belong to.	tables	&lt;(SequenceableCollection of: (DatabaseTable))&gt;	The tables that we map	typeResolver	&lt;TypeResolver&gt;	description of typeResolver</body></comment><class><name>MultipleRowMapKey</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpUnitOfWork</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.MultipleRowMapKey</class-id><body>This is a special (and rarely needed) form of row map key that allows an arbitrary number of objects to participate in it.</body></comment><class><name>GlorpError</name><environment>Glorp</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpError</class-id><body>This is an abstract superclass for GLORP exceptions.</body></comment><class><name>GlorpWriteFailure</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command object </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpWriteFailure</class-id><body>I am raised if Glorp encounters an error while trying to write some rows. This typically indicates an optimistic lock failure, although it might also happen if we violated a constraint.  I can be handled via	on: GlorpWriteFailure	do: [:ex | ex resume: true]to carry on and treat the whole operation as a success, or	on: GlorpWriteFailure	do: [:ex | ex resume: false](false is my defaultResumeValue, so 	do: [:ex | ex resume]would do as well) to raise a GlorpTransactionFailure.  See GlorpOptimisticLockingTest for examples of handling and not handling.Instance Variables:	command	&lt;DatabaseCommand&gt;	The command we were trying to execute.	object	&lt;Collection&gt;			A collection of the one or more objects we were trying to write.</body></comment><class><name>UnitOfWork</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session transaction deletedObjects newObjects rowMap commitPlan deletePlan rowsByTable succeeded linkRowsForUpdate commitPhase deleting </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.UnitOfWork</class-id><body>A UnitOfWork keeps track of objects which might potentially be modified and lets you roll them back or commit the changes into the database.Instance Variables:	newObjects	&lt;IdentitySet of: Object&gt;	The objects registered with us as being new (i.e. not existing already in the database)	session	&lt;Session&gt;	The session in which this is all taking place.	transaction	&lt;ObjectTransaction&gt;	Keeps track of the original object state so that we can revert it.	rowMap	&lt;RowMap&gt;	A holder for the rows when we are writing out changes.	commitPlan	&lt;(OrderedCollection of: DatabaseRow)&gt;	The list of rows to be written, in order. Constructed by topological sorting the contents of the row map.	calculatingRows &lt;Boolean&gt; Are we in the process of computing the rows to be written. If so, we should not be doing reads and registrations - it's probably an error in the mapping code by accidentally forcing a read.</body></comment><class><name>GlorpAbstractIntegerType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpPreparedStatement</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>signature statement busy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.GlorpPreparedStatement</class-id><body>This represents a prepared statement in the database. Instance Variables:	busy	&lt;Boolean&gt;	Are we currently in use - that is to say, are we executing and/or holding an active cursor.	signature	&lt;String&gt;	A string that we can use to match up to commands and see if we are appropriate for the command to use. The signature of a command is its SQL String plus a string representing the types of its parameters.	statement	&lt;Object&gt;	The actual statement object. Because we don't really know what type this is, and it varies by dialect, we allow the accessor to extract it from us and do the real work.</body></comment><class><name>PostfixFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.PostfixFunction</class-id><body>This represents a function that prints postfix, meaning its name comes after its argument. For example, DESC for a descending sort. That's maybe stretching the definition of a function, but that's how it's implemented for purposes of Glorp SQL definition.</body></comment><class><name>SQLServerSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLServerSequence</class-id><body>This implements SQL Server sequences, which aren't really sequences at all, but identity columns. That means we can't do more than one at a time, and we have to do an extra select to get the value back.</body></comment><class><name>GlorpInvalidExpressionError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpInvalidExpressionError</class-id><body>This represents an invalid expression condition in a query.</body></comment><class><name>DatabaseField</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table name isPrimaryKey position type isNullable isUnique isLockKey imDefaultValue dbDefaultValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseField</class-id><body>This represents a field in a database table. See also DatabaseTable. Glorp relies heavily on identity of fields for comparison purposes, so be careful when copying these.Instance Variables:	imDefaultValue	&lt;Object&gt;	If the column in the database does not have a default value but we wish one, or it						does but we wish to use a different default value, set this in the image before writing.	dbDefaultValue	&lt;Object&gt;	If the column in the database has a default value, put it here to use in (re)creation						statements (by the user setting it or by reading it in a metadata descriptor system).	isLockKey	&lt;Boolean&gt;	Is this field part of an optimistic lock key. If so, then on update we will generate an						update statement that checks that this value hasn't changed since the object was read.	isNullable	&lt;Boolean&gt;	Is this field allowed to be null?	isPrimaryKey	&lt;Boolean&gt;	Is this field part of the primary key?	isUnique	&lt;Boolean&gt;	Does this field have a unique constraint in the database?	name	&lt;String&gt;	The name of the field.	position	&lt;Object | ProtoObject&gt;	description of position	table	&lt;DatabaseTable&gt;	The table that contains this field.	type	&lt;GlorpDatabaseType&gt;	The type of  data that this field contains.</body></comment><class><name>RelationExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relation leftChild rightChild outerJoin </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.RelationExpression</class-id><body>This represents a relationship between two sub-expressions, that is something like = or AND. So in object attribute = field, we're the equals node. We have exactly two children, and mostly just print ourselves in between them. However there is some other interesting logic in there about splitting up comparisons between objects into comparisons between keys, and even just printing can get fairly complicated.Instance Variables:	leftChild	&lt;GlorpExpression&gt;	The left child.	rightChild	&lt;GlorpExpression&gt;	The right child.	outerJoin	&lt;Boolean&gt;	Is this an outer join (only makes sense if we are an equality comparison).	relation	&lt;String&gt;	The string or symbol that we print for our relationship.</body></comment><class><name>CollectionExpression</name><environment>Glorp</environment><super>Glorp.RelationExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.CollectionExpression</class-id><body>This represents expressions on collection objects taking a block, which at the moment means just anySatisfy:We treat this as a relation, but with the special properties that when we convert the right hand side into an expression we assume it's a block and give it a base which is the left-hand side. Also, we don't print this relation when printing SQL, we just print the right hand side.</body></comment><class><name>AbstractProxy</name><environment>Glorp</environment><super>ProtoObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value isInstantiated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.AbstractProxy</class-id><body>This is an abstract superclass for proxy objects. It inherits from ProtoObject, which is part of the platform specific layer, but implements most of the proxy functionality.Instance Variables:	isInstantiated	&lt;Boolean&gt;	Has this proxy been instantiated or not.	value	&lt;Object&gt;	What we are proxying for.</body></comment><class><name>AdHocProxy</name><environment>Glorp</environment><super>Glorp.AbstractProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>readBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.AdHocProxy</class-id><body>This represents a proxy that gets its value in a user-defined way, by evaluating a block.Instance Variables:	readBlock	&lt;BlockClosure&gt;	The zero-argument block we evaluate to get the proxied object.</body></comment><class><name>GlorpClassModel</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system describedClass subclasses attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.GlorpClassModel</class-id><body>This holds the metadata describing a class. Since Smalltalk classes are fairly self-describing, this mostly consists of the names and types of the instance variables that we want to be persistent. If those variables are collections, we also want to know the types of the items in the collections.Instance Variables:	attributes	&lt;(Collection of: GlorpAttributeModel)&gt;	Our attributes, one for each instance variable.	describedClass	&lt;Class&gt;	The class we hold metadata for.	subclasses	&lt;Array of: Class&gt;	The collection of subclasses of our describedClass. Computed automatically, and used as a performance optimization for inheritance testing.	system	&lt;DescriptorSystem&gt;	The system that contains us.</body></comment><class><name>GlorpInvalidTypeError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>object expectedType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpInvalidTypeError</class-id><body>When mapping, if we encounter an object in a relationship that doesn't match the type we're expecting from the ClassModel/AttributeModel then we raise this exception. Instance Variables:	expectedType	&lt;GlorpClassModel&gt;		The classModel for the type we were expecting.	object	&lt;Object&gt;	The object that contained the invalid reference.</body></comment><class><name>QuerySelectCommand</name><environment>Glorp</environment><super>Glorp.SelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query boundExpressions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.QuerySelectCommand</class-id><body>This is the normal class to use for select queries. It generates SQL for a select operation returning a set of rows.Instance Variables:	boundExpressions	&lt;(Collection of: GlorpExpression)&gt;	The expressions for which we need bind parameters. We expect that these are things that resolve to fields, or more generally, to something the database will accept as a valid target of a bind	query	&lt;Query&gt;	The query in which we're executing.</body></comment><class><name>CompoundSelectCommand</name><environment>Glorp</environment><super>Glorp.QuerySelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>commands </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.CompoundSelectCommand</class-id><body>This is a select command that uses a number of sub-commands to print multiple queries, and combine them into one for execution. Used in conjunction with compound queries, e.g. using UNION ALL. The query knows what the combination operation is.Instance Variables:	commands	&lt;(Collection of: DatabaseCommand)&gt;	The commands we are to print.</body></comment><class><name>RecursiveCommand</name><environment>Glorp</environment><super>Glorp.CompoundSelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>recursiveUnionCommand </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.RecursiveCommand</class-id><body>I print the SQL to define and populate a recursive common table expression, before using my superclass' behaviour to select the rows to be returned by my RecursiveQuery.Instance Variables:	recursiveUnionCommand	&lt;CompoundSelectCommand&gt;	The union command that defines the recursion we are to print.</body></comment><class><name>GlorpVarCharType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>MySQLSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.MySQLSequence</class-id><body>This is a sequence type for MySQL AutoIncrement fields.</body></comment><class><name>ElementBuilder</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instance requiresPopulating key expression cursor fieldTranslations isExpired row query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.ElementBuilder</class-id><body>This is the abstract superclass of builders. These assemble information, either primitive data or objects, from a database result set.Subclasses must implement the following messages:	building objects		buildObjectFrom:		findInstanceForRow:useProxy:	selecting fields		fieldsFromMyPerspectiveInstance Variables:	expression	&lt;MappingExpression&gt;	The expression we're mapping. e.g. if the query is reading people, this might be the expression corresponding to "each address", meaning that we build the address object related to the main Person instance by the given relationship. 	fieldTranslations	&lt;Array of: Integer&gt;	 The translation of the field positions from where they are in the descriptor to where they are in the row we're reading. This is done so we can read the rows efficiently, by index, rather than doing lots of dictionary lookups by name. If we're doing a simple read, the translations will probably be a no-op, but if we read multiple objects, some of the fields will be in different positions than they are in our table definition.	instance	&lt;Object&gt;	The thing we're constructing.	isExpired	&lt;Boolean&gt;	If our instance is in cache, we use that instead. However, if the instance has expired, then we do something different (most likely force a refresh) than if it's still alive.	key	&lt;Object&gt;	The key for this row. This is lazily computed, and "self" is used a special marker to indicate that it hasn't been computed yet.	query	&lt;AbstractReadQuery&gt;	the query that we're building results for.	requiresPopulating	&lt;Boolean&gt;	Do we need to populate the object. Will be false if the object was found in cache and hasn't expired.	row	&lt;Array&gt;	The database results. May actually be a result set row of some sort rather than an array, depending on the dialect, but should always respond to indexing protocol.</body></comment><class><name>SelectingElementBuilder</name><environment>Glorp</environment><super>Glorp.ElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.SelectingElementBuilder</class-id><body>This is a special subclass of ElementBuilder used when we execute a query that reads multiple different things, but in any row, we expect only one of them to have a value. This is useful if we're doing inheritance queries where each concrete subclass is in a separate table. We can join the queries together, but we expect each row to contain only one particular subclass instance.</body></comment><class><name>AbstractReadQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultClass whereClause base limit offset proxyType shouldRefresh tracing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.AbstractReadQuery</class-id><body>An abstract superclass for Glorp queries. Most query types will descend from this, but a couple are specialized.Subclasses must implement the following messages:	executing		rowsFromDatabaseWithParameters:Instance Variables:	base	&lt;BaseExpression&gt;	In Glorp expressions it's very important that expressions we're trying to compose together are built on the same base, which represents the object that we're talking about in the query. This holds the base expression that we're expecting to use in this query.	limit	&lt;Integer&gt;	Some databases support limiting the number of rows retrieved. If we can, we'll use this variable to set that.	offset	&lt;Integer&gt;	Some databases support starting from a given point in the collection of retrievable rows, often used in combination with limit. So, e.g. get me the rows, sorted by name, starting at the 1012th and giving me 40 of them.	proxyType	&lt;Class | nil&gt;	If this is nil, do not use proxies. Otherwise, use this class to create proxies for relationships. At the moment, likely to be either Proxy or TimedProxy.	readsOneObject	&lt;Boolean&gt;	Do we return only one object, or a collection. That is, is this a readManyOf: or a readOneOf:	resultClass	&lt;Behavior&gt;	What kind of objects are we looking for.	shouldRefresh	&lt;Boolean&gt;	If the result is already in cache, should we refresh it according to what the database says, or just return it as is.	tracing	&lt;Tracing&gt;	The tracing. This describes the graph of objects we will actually retrieve.	whereClause	&lt;GlorpExpression | BlockClosure&gt;	What is the criteria on which we will filter the results?The whereClause often begins as a one-argument BlockClosure.  At some point during construction or evaluation it is converted to a GlorpExpression.</body></comment><class><name>GlorpTimeStampType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>PostgresPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>charactersThatNeedEscaping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PostgresPlatform</class-id><body>This is a an abstract superclass for the protocol 2 and protocol 3 APIs of the open-source PostgreSQL database.This supports binding but has it off by default.  To change this generally, implement (class-side) useBindingByDefault to return true for it or a subclass.  To change it (for all platforms) in a given image, set	Glorp.DatabasePlatform.UseBindingIfSupported := trueIn either case check already-assigned values of any existing platform instances after changing.Instance Variables	charactersThatNeedEscaping	&lt;Array of Char&gt;	the standard_conforming_strings setting determines whether we must escape backslash;  we must always escape single-quote</body></comment><class><name>PostgresSocketPlatform</name><environment>Glorp</environment><super>Glorp.PostgresPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PostgresSocketPlatform</class-id><body>This is a platform for the socket protocol 3 API of the PostgreSQL database.</body></comment><class><name>SQLStringSelectCommand</name><environment>Glorp</environment><super>Glorp.QuerySelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLStringSelectCommand</class-id><body>This is a select command whose SQL is given, rather than being generated from a query.</body></comment><class><name>SQLite3PragmaCommand</name><environment>Glorp</environment><super>Glorp.SQLStringSelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>SubSelectBaseExpression</name><environment>Glorp</environment><super>Glorp.BaseExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trueBase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.SubSelectBaseExpression</class-id><body>This is a special variation of a base expression which is used when we know we are a subselect. In some circumstances we'll need to operate with respect to the subselect base, as if we were a standalone query. But sometimes we'll need to know the broader context in which we're living. Having a separate subclass helps us distinguish.Instance Variables:	trueBase	&lt;MappingExpression&gt;	The base on which we are built. Note that this doesn't mean this is the overall base expression, in fact it's probably a mapping expression, it's just the thing from which this subselect was built. Presumably the ultimate base expression can be found by following that outer context down, but there could be multiple levels of subselects involved.</body></comment><class><name>SimpleQuery</name><environment>Glorp</environment><super>Glorp.AbstractReadQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builders fields joins tablePrefix customCommand tablesToPrint useANSIJoins </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.SimpleQuery</class-id><body>This is a query that is directly executable. A single query might be more than we can do in a single database read, so we might have to break it down into simple queries. But at the moment we just break anything down into an equivalent single query.Instance Variables:	builders	&lt;OrderedCollection of: ElementBuilder)&gt;	The builders that will assemble the object from the row that this query returns.	fields	&lt;OrderedCollection of: DatabaseField&gt;	The fields being selected.	joins	&lt;OrderedCollection of: Join&gt; While preparing the query, we will need to build up a list of joins implied by the relationships in the where clause, ordering, and so forth. This acts as storage for those.	tablePrefix	&lt;String&gt;	If we are part of a subselect, we want to prefix all of our table aliases with some known, common prefix, so that we won't have our own t1 which would get confused with the parent query's t1. The normal convention is something like 's1' for subselect 1, so we get s1t1, and so forth.	command &lt;DatabaseCommand&gt; We can tell the query to use a specific command instead of generating one appropriately. Note that if this is set, it overrides most of the other sql generation.</body></comment><class><name>SQLite3PragmaQuery</name><environment>Glorp</environment><super>Glorp.SimpleQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.SQLite3PragmaQuery</class-id><body>This is a query intended to execute a SQLite3 PRAGMA command. The command behaves like a stored function that takes a parameter and returns a result set. The meta information schema for SQLite is not available in the standard views, but it can be eventually deduced by executing particular pragma commands.</body></comment><class><name>DelegatingDatabaseConverter</name><environment>Glorp</environment><super>Glorp.DatabaseConverter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>host stToDbSelector dbToStSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DelegatingDatabaseConverter</class-id><body>This is a converter which delegates the conversion to methods on some other object, typically the database platform.Instance Variables	host	&lt;Object&gt;	The receiver of the methods specified by the selectors.	dbToStSelector	&lt;Symbol&gt;	The symbol we perform when converting from database to object representation. Takes two arguments, the value, and the database type.	stToDbSelector	&lt;Symbol&gt;	The symbol we perform when converting from object to database representation. Takes two arguments, the value, and the database type.</body></comment><class><name>SqueakDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isInTransaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-VW3</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SqueakDatabaseAccessor</class-id><body>A database accessor for Squeak.Instance Variables:	isInTransaction	&lt;Boolean&gt;	Are we in a transaction. We don't have an indicator for that from the database layer, so keep track of it here.</body></comment><class><name>DuplicatePrimaryKeyException</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>existingObject newObject </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.DuplicatePrimaryKeyException</class-id><body>This is an exception we raise when we detect two different objects with the same primary key in our cache.</body></comment><class><name>GlorpExpressionsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.GlorpExpressionsPackage</class-id><body>This class represents package information for the GlorpExpressions package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>GlorpClobType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractStringType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpDateType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpSmallIntType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractIntegerType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>IdentityTypeMapping</name><environment>Glorp</environment><super>Glorp.TypeMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.IdentityTypeMapping</class-id><body>This is the default type mapping for classes that aren't using inheritance. It implements all of the protocol as no-ops.</body></comment><class><name>InsertCommand</name><environment>Glorp</environment><super>Glorp.RowBasedCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InsertCommand</class-id><body>A command to insert our set of rows.</body></comment><class><name>GlorpPGTimestampWithTimeZoneType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>InsertMultiValuesCommand</name><environment>Glorp</environment><super>Glorp.InsertCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InsertMultiValuesCommand</class-id><body>If my platform usesArrayBindingToGroupWrite and I useBinding, or I have only one row, then I am identical to my superclass.  In all other cases, I concatenate the values of my rows, so that instead of, for example,	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ( 'a', 'A', '1');	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ('b', 'B', '2');	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ('c', 'C', '3');	...or, if bound but not usesArrayBindingToGroupWrite,	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ( ?, ?, ?);	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ( ?, ?, ?);	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ( ?, ?, ?);	...I write what is technically a single command	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ( 'a', 'A', '1'), ('b', 'B', '2'), ('c', 'C', '3'). ...or, if bound,	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ( ?, ?, ?), ( ?, ?, ?), ( ?, ?, ?). ...</body></comment><class><name>InsertIdentityColumnCommand</name><environment>Glorp</environment><super>Glorp.InsertMultiValuesCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identityColumn </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InsertIdentityColumnCommand</class-id><body>I insert one or more rows of a table that has an identityColumn, i.e. a column whose values are set by the server and must be recovered post-insert.Instance variables	identityColumn	&lt;DatabaseField&gt;	a column whose value for each row is set by the server during insertion of that row</body></comment><class><name>Case</name><environment>Glorp</environment><super>Glorp.PrefixFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argumentTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.Case</class-id><body>This represents a function which prints prefix, printing CASE, followed by the argument in parentheses, and then the rest of the MS SQL Server CASE statement, with a single test condition (WHEN) and a default value (ELSE):CASE (arg1)	WHEN arg2 THEN arg3 	ELSE arg4END AS arg5For example:CASE ('SELECT count(*) FROM aTable')	WHEN '0' THEN 0 	ELSE 1 END AS arg3</body></comment><class><name>FieldExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field base alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.FieldExpression</class-id><body>This is an expression representing a field in a table. It could be used, for example, if we were writing a data level expression.   getTable: 'foo') getField: 'bar'Instance Variables:	alias	&lt;Object&gt;	Sometimes in queries we want to retrieve values in columns other than what they are normally named. So we can give the field an alias, and generate something like "select id, name as somethingElse"	base	&lt;GlorpExpression&gt;	The expression this is based on, which ought to be something which is associated with the table that contains our field.	field	&lt;DatabaseField&gt;	The field we represent in the expression.</body></comment><class><name>InsertMultiValuesTablesCommand</name><environment>Glorp</environment><super>Glorp.InsertCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InsertMultiValuesTablesCommand</class-id><body>I am only supported on Oracle as yet.  I can write bound or unbound rows to multiple tables in a single round trip, but am only used for unbound multiple row inserts to a single table as yet.  (My superclass handles bound inserts to a single table better, using array-binding.  Array binding is much faster than multi-value binding, e.g. three times faster, so only in the inhomogeneous rows case could I outperform array binding.  When running unbound, I will of course outperform my round-trip-per-row unbound rival, but Oracle is usually run bound whenever the dialect's external database interface to it supports binding.)I concatenate the values of my rows, so that instead of, for example,	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ('a', 'A', '1');	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ('b', 'B', '2');	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ('c', 'C', '3');	...or, if bound,	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES (?, ?, ?);	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES (?, ?, ?);	INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES (?, ?, ?);	...I write what is technically a single command	INSERT ALL 		INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ('a', 'A', '1')		INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ('b', 'B', '2')		INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ('c', 'C', '3')		...	SELECT * FROM DUALor, if bound	INSERT ALL 		INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES (?, ?, ? )		INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES (?, ?, ? )		INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES (?, ?, ? )		...	SELECT * FROM DUALI am indistinguishable from my superclass if there is only one row, and so am never created in that case;  my code assumes I have multiple rows.I support inhomogeneous row grouping, e.g.	INSERT ALL		INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ( 'a', 'A', '1')		INTO GR_ADDRESS (ID,STREET,HOUSE_NUM) VALUES ( 'b', 'B', '2')		INTO GR_POSTOFFICE (ID,POSTCODE) VALUES ('1', 'A13 6BA')		INTO GR_POSTOFFICE (ID,POSTCODE) VALUES ('2', 'A13 6BB')		INTO GR_POSTOFFICE (ID,POSTCODE) VALUES ('3', 'A13 6BC')		INTO GR_REGION (ID,LOCATION) VALUES (1000, 'Cornwall')		INTO GR_REGION (ID,LOCATION) VALUES (1001, 'Devon')		...	SELECT * FROM DUALGlorp does not yet exploit this.</body></comment><class><name>GeneralSubSelectExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.GeneralSubSelectExpression</class-id><body>This represents an arbitrary sub-select. This would normally get created by embedding a query instance inside a query block. For example   where: [:each | each id &gt; 2 &amp; (each something = aWholeOtherQuery)].Warning: This can be get very complicated, especially if aWholeOtherQuery refers to variables inside the main query block, creating a correlated subselect.Instance Variables:	query	&lt;Query&gt;	The query that we subselect.</body></comment><class><name>SQLite3Sequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLite3Sequence</class-id><body>Sequences for SQLite.</body></comment><class><name>ObjectBuilder</name><environment>Glorp</environment><super>Glorp.ElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queryCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.ObjectBuilder</class-id><body>This builds full-blown persistent objects with descriptors. This is the most common type of builder.</body></comment><class><name>ConditionalBuilder</name><environment>Glorp</environment><super>Glorp.ObjectBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.ConditionalBuilder</class-id><body>My expression is a MappingExpression whose mapping is conditional.  When I have no row, I guess at my descriptor (and so my reference class) by using my mapping's representativeMapping.  When I have a row, I use that to find the actual descriptor for that row.Instance Variables:	rowMapping	&lt;Mapping&gt;	the conditional's mapping chosen by the row							(initialized as the representativeMapping till the row is known)</body></comment><class><name>SubSelectExpression</name><environment>Glorp</environment><super>Glorp.RelationExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query localBase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.SubSelectExpression</class-id><body>This is a special sort of relation expression used when printing subselects that are generated out of anySatisfy: or noneSatisfy: using an EXISTS/NOT EXISTS clause.Instance Variables:	localBase	&lt;SubSelectBaseExpression&gt;	The base expression that our sub-query is built on, as opposed to the overall base expression of query.	query	&lt;SimpleQuery&gt;	The sub-query we are responsible for.</body></comment><class><name>GlorpSerialType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractIntegerType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence increment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Dialect</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>dialectName timestampClass lookedUpNames isNamespaceAware lastSystemTime lastServerTime </class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.Dialect</class-id><body>This is an encapsulation layer for dialect differences between Smalltalk. It has a variety of class messages that do different things depending which dialect we are running on.</body></comment><class><name>Login</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>database username password connectString name schema secure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.Login</class-id><body>Enough information to log in to a particular database.Instance Variables:	connectString	&lt;String&gt;	The string that will be passed to the driver level to tell us what to connect to. This might be e.g. an ODBC data source name, or it might be a host name plus socket/database name for Postgresql.	database	&lt;DatabasePlatform&gt;	The platform describing what type of database this is. Used here mostly to indicate how we need to talk to the underlying connection layer, which may be different by database.	name	&lt;String&gt;	A name we can use to describe this. No significance to the database.	password	&lt;String&gt;	The connect password.	schema	&lt;String&gt;	What should our default schema be. Used mostly internally, to set the schema of the tables we are using.	username	&lt;String&gt;	The connect username.</body></comment><class><name>DB2Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DB2Platform</class-id><body>This is a Glorp platform for DB2 databases.</body></comment><class><name>GlorpIntegerType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractIntegerType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>GlorpExtensionsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpExtensions</package></attributes></class><comment><class-id>Glorp.GlorpExtensionsPackage</class-id><body>This class represents package information for the GlorpExtensions package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>CannotFindSession</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.CannotFindSession</class-id><body>This is an error that we raise when trying to determine what session to use for an operation, and we don't have enough information to figure it out.</body></comment><class><name>DataElementBuilder</name><environment>Glorp</environment><super>Glorp.ElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.DataElementBuilder</class-id><body>This builds raw data items rather than persistent objects with descriptors. Used if we do something like   aQuery retrieve: [:each | each address streetName].giving us back simple data objects.This makes building them quite simple.</body></comment><class><name>CompoundConstantBuilder</name><environment>Glorp</environment><super>Glorp.DataElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.CompoundConstantBuilder</class-id><body>My expression is a ConstantExpression but I am the builder in the cursor returned by a CompoundQuery, copied from a builder of its primaryQuery's builder.  Since the corresponding ConstantExpressions of other subqueries may have different values, I always return the row's value for me, not my expression's value.</body></comment><class><name>OraclePlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OraclePlatform</class-id><body>This is a platform for Oracle databases. Currently there's only one, but it might be better for some purposes to separate out by versions, as some older versions don't support all features.</body></comment><class><name>OracleODBCPlatform</name><environment>Glorp</environment><super>Glorp.OraclePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.OracleODBCPlatform</class-id><body>This is a platform for Oracle, as accessed through ODBC. The database doesn't change, but at least in VW we determine which connection type to use based on the platform object, so we need to use an ODBC connection rather than an OCI connection.</body></comment><class><name>InsertSelectRowCommand</name><environment>Glorp</environment><super>Glorp.InsertIdentityColumnCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InsertSelectRowCommand</class-id><body>I refuse to group-write;  all my rows are written singly.  After each INSERT, I SELECT to get the server-generated value of the row's identity column in the same round-trip, e.g.	INSERT INTO mytable(firstname, lastname, address)		VALUES (?, ?, ?);	SELECT SCOPE_IDENTITY()or	INSERT INTO mytable(firstname, lastname, address)		VALUES ('John', 'Smith', 'CA');	SELECT SCOPE_IDENTITY()		SELECT SCOPE_IDENTITY() is more robust than SELECT @@IDENTITY but needs to be sent in the same round trip as the insert that generated the id.In SELECT @@IDENTITY, SQLServer returned the value as a FixedPoint (bizarre! - perhaps the SELECT @@IDENTITY mechanism can return Fixed Points in another usage scenario and so used this as its generic return type).  Thus the value comes back as a FixedPoint but is of course an integer.  This did not cause problems until we began binding arrays of columns for insert. Without a call of #asInteger, it would be possible for an array from Store to have FixedPoint values mingled with Integer values, which violates the ODBC api's expected type.  As this command runs singly, we can ignore this.(At present, only SQLServer uses me and my subclass, so the pre- and post-insertion SQL we generate is SQLServer-specific.  When another platform needs the same INSERT...SELECT...-in-same-round-trip behaviour, we can be generalised to get those SQL strings from our session's platform.)</body></comment><class><name>SAPDBPlatform</name><environment>Glorp</environment><super>Glorp.AdabasLikePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SAPDBPlatform</class-id><body>Ths is a platform for SAPDB, but appears very unfinished;  for example, it needs to define int4, which is a subclassResponsibility inherit from the super.</body></comment><class><name>ExpressionGroup</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ExpressionGroup</class-id><body>This isn't really an expression, in that it can never occur due to parsing. It's a way of grouping several expressions together so that we can process them together, essentially making sure that the iteration methods will loop over all the expressions, but only do each node once, even if it occurs in multiple expressions.  This is used in processing order expressions to figure out what tables and join expressions we need.Because it is only used in transient ways, it probably doesn't implement all the required operations for normal expression usage.</body></comment><class><name>ObjectTransaction</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>undoMap collectionMementos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.ObjectTransaction</class-id><body>An ObjectTransaction knows how to remember the state of objects and revert them back to that state later on. It does this by making a *shallow* copy of the registered objects and everything connected to them, and then putting that into an identity dictionary keyed by the originals.If you have to undo, you push the state from the shallow copies back into the originals.Yes, that works, and it's all you have to do. It even handles collections become:ing different sizes.This is fairly independent of GLORP. You could use this mechanism in general, if you provided your own mechanism for figuring out what to register, or even just uncommented the one in here.Instance Variables:	undoMap	&lt;IdentityDictionary&gt;	 The dictionary of originals-&gt;copies.</body></comment><class><name>RecursiveBuilder</name><environment>Glorp</environment><super>Glorp.ObjectBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.RecursiveBuilder</class-id><body>I exist to let knitting behaviour be partitioned between me and RecursiveMapping in the development of Glorp recursion.</body></comment><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DescriptorSystem</class-id><body>This holds onto the Glorp metadata. Each session will have a DescriptorSystem associated with it, which describes the tables, descriptors, and class models that are to be made persistent.Subclasses must implement the following messages:	accessing		allTableNames		constructAllClassesInstance Variables:	allClasses	&lt;Collection of: Behavior&gt;	The classes we have metadata for.	cachePolicy	&lt;CachePolicy&gt;	The default cache policy to use. Descriptors can override this.	classModels	&lt;Dictionary from: Behavior to: GlorpClassModel&gt;	Our class models, indexed by class.	descriptors	&lt;Dictionary from: Behavior to: Descriptor&gt;	Our descriptors, indexed by class.	platform	&lt;DatabasePlatform&gt;	The platform for which we will be used. This is required because the table definitions will refer to the platform in order to get the appropriate types for fields.	sequences	&lt;Dictionary from: String to: DatabaseSequence&gt;	The sequences that we have available, indexed by name asUppercase.	session	&lt;GlorpSession&gt;	The session we provide metadata to.	tables	&lt;Dictionary from: String to: DatabaseTable&gt;	Our database tables, indexed by name asUppercase.	typeResolvers	&lt;Dictionary from: Behavior to: TypeResolver&gt;	The type resolvers that we will use for inheritance, indexed by class.	useDirectAccessForMapping	&lt;Boolean&gt;	By default, should we use direct instance variable access (instVarAt:) or send get/set messages. Individual attributes can override this.	useJoinsForAnySatisfy	&lt;Boolean&gt;	By default, should we use joins for anySatisfy and similar queries, or should we use EXISTS subselects.</body></comment><class><name>DynamicDescriptorSystem</name><environment>Glorp</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributeNameToFieldNameBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DynamicDescriptorSystem</class-id><body>This is a descriptor system whose descriptors and tables are created dynamically rather than out of generated code. Note that identity is extremely important, so care is required to set these up properly.</body></comment><class><name>SQLite3Platform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLite3Platform</class-id><body>I support Glorp's use of the SQLite database;  see http://www.sqlite.org.  Some notes on the implementation:SQLite provides no specific support for time-related data other than column-default-value UTC functions:	CURRENT_DATE format YYYY-MM-DD	CURRENT_TIME format HH:MM:SS	CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SSI therefore map Date, Time and Timestamp to and from strings via #to... and (inherited) #read... methods whose formats agree with these functions.  (I also return false to #supportsMillisecondsInTimes, again in agreement with the above functions which do not include millliseconds.)My #maximumLengthOfTableName value is limited purely for convenience;  it can probably be much larger.In VW, this version uses the non-threaded SQLite3Connection EXDI class.  Make my #vwEXDIConnectionClass return SQLite3ThreadedConnection to make Glorp use the threaded interface and, if using this with Store, also change its string reference in #asGlorpDatabase, #databaseFor:.  Alternatively, create an SQLlite3ThreadedPlatform subclass of me and add an extra line, instead of changing a line, to the Store methods.  (Note that in order to be thread-safe, your SQLite installation must be compiled with the SQLITE_THREADSAFE preprocessor macro set to 1.  In SQLite3, both the Windows and Linux precompiled binaries in the distribution are compiled this way.  If you are unsure if the SQLite library you are linking against is compiled to be threadsafe you can call the sqlite3_threadsafe()  interface to find out.)SQLite parses FOREIGN KEY constraints but does not enforce them.SQLite's approach to data typing is unusual for SQL.  Its data values are:	NULL	INTEGER. The value is a signed integer, stored in 1, 2, 3, 4, 6, or 8 bytes depending on the magnitude of the value.	REAL. The value is a floating point value, stored as an 8-byte IEEE floating point number.	TEXT. The value is a text string, stored using the database encoding (UTF-8, UTF-16BE or UTF-16-LE).	BLOB. The value is a blob of data, stored exactly as it was inputbut its typing is dynamic, so any column can in principle store any value, and its column affinities are	TEXT - can store NULL, TEXT or BLOB	NUMERIC - can store all five; text values that converts to reals or integers without loss of information are so stored	INTEGER - as NUMERIC plus reals that convert to integer without loss of information are so stored	REAL - as NUMERIC but integer values are coerced to reals	NONE - no coercion is performed.My int* and float*/double type methods that define Glorp types for SQLite conform to the expressibility of the above data values.</body></comment><class><name>AddingWriteStream</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>target </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>GlorpExtensions</package></attributes></class><comment><class-id>Glorp.AddingWriteStream</class-id><body>Why *can't* you stream onto a set? Or a bag, or a SortedCollection? No good reason that I can see. This implements only a subset of stream behaviour, that which is necessary to let us build up collections where we have to "append" elements using #add: rather than #at:put: and explicit grows.Instance Variables:	target	&lt;Collection&gt;	The thing we're streaming onto.</body></comment><class><name>MessageArchiver</name><environment>Glorp</environment><super>ProtoObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mySelector myArguments myReceiver query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.MessageArchiver</class-id><body>This is what we use to construct GlorpExpression trees out of blocks. An instance of MessageArchiver is passed into the block. It has a doesNotUnderstand: handler, and in response to almost any message, will just return a new MessageArchiver which knows it is descended from this one. The result (assuming no inlined messages or other tricky stuff happened) is a tree of MessageArchivers recording all the sent messages. We can then traverse that and construct the appropriate expression tree.Instance Variables:	myArguments	&lt;(Collection of: (Object | ProtoObject))&gt;	The arguments to the message that caused me to be constructed.	myReceiver	&lt;MessageArchiver | nil&gt;	The object that received the message that caused me to be constructed. For the initial MessageArchiver that's passed in, this will be nil. Otherwise it is a MessageArchiver.	mySelector	&lt;Symbol&gt;	The selector of the message that caused me to be constructed.	query	&lt;AbstractReadQuery&gt;	The query for which I am constructing the expression. This is here so that we can construct the final expression tree directly onto its BaseExpression.</body></comment><class><name>GlorpMSSQLSysnameType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Cast</name><environment>Glorp</environment><super>Glorp.PrefixFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.Cast</class-id><body>This is an attempt to allow a cast to be used on constants, as e.g.   CAST value: '1-2-3' as: platform dateIt doesn't work yet, since printing of constants doesn't like having functions in the way - it conflicts with type conversion, and looks like it'll take a bit of work to fix.</body></comment><class><name>AccessCast</name><environment>Glorp</environment><super>Glorp.Cast</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.AccessCast</class-id><body>This class provides limited CAST functionality for MS Access, which doesn't use CAST but instead provides some conversion functions.This class attempts to find the correct conversion function for the intended CAST operation. It ignores the source type, and uses the argument to determine which conversion function to use.	Here are some of Access' convesion functions: CDBL(), CSTR(), CBOOL(), CLNG(). Also, INT(), which yields a truncated double.	DATETIME is actually a Double, with Date().Time().	Get date, the integer part, from a DATETIME with: Int(Now()) == DateValue(#3/31/1999#).	Get DOUBLE from DATETIME with: CDbl(Now()).	Get DATETIME back froum DOUBLE with: CVDate(Cdbl(Now())).	Get DATETIME from DATE with: CVDate( CDate( #Jan 31, 1994#) ).</body></comment><class><name>IdentityTypeResolver</name><environment>Glorp</environment><super>Glorp.TypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.IdentityTypeResolver</class-id><body>This is a trivial type resolver (and the default one) that just uses a single class, with no inheritance.</body></comment><class><name>ConditionalToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>conditional </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ConditionalToManyMapping</class-id><body>This is a conditional mapping, but one where the condition is applied to a relationship with a collection, and applies to individual elements of the collection. So, rather than making a single choice overall of which mapping to apply, we loop over the collection and make the choice separately for each element.This is experimental, and probably suffers from lots of limitations.</body></comment><class><name>CompositeQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>queries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.CompositeQuery</class-id><body>This is a query that contains several sub-queries, and executes them all in sequence, returning the concatenation of all the results. This is different from a CompoundQuery, which groups multiple queries together according to operations like UNION ALL, or INTERSECT. This just puts together several different queries and executes them separately, combining the results in Smalltalk. CompoundQuery is more powerful, and can take advantage of database features, but this is more flexible.</body></comment><class><name>ReadQuery</name><environment>Glorp</environment><super>Glorp.AbstractReadQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.ReadQuery</class-id><body>This represents a general read query. By general we mean that it might require more than one trip to the database. It computes a "tracing" indicating which groups of objects can be read simultaneously, then constructs a group of corresponding SimpleQuery instances and executes them.</body></comment><class><name>JoinPrinter</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>joinsToProcess availableTables query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.JoinPrinter</class-id><body>This is a helper class used for printing collections of joins in the &lt;expletive deleted&gt; ANSI join syntax. This syntax wants us to embed all of the joins into the initial list of tables, so we have to come up with an order for printing that makes sure we get all the joins in properly. This is more complicated than you might think.Instance Variables:	availableTables	&lt;(Collection of: DatabaseTable)&gt;	Which are the tables that we plan to print.	joinsToProcess	&lt;(Collection of: Join)&gt;	Which joins do we have to put in between those tables somehow or other.	query	&lt;Query&gt;	What is the query in which we are printing all of this.</body></comment><class><name>DatabaseTableConstraint</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name table shouldCreateInDatabase fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseTableConstraint</class-id><body>Abstract superclass reifying a constraint on a value in a column or between values in columns.</body></comment><class><name>PrimaryKeyConstraint</name><environment>Glorp</environment><super>Glorp.DatabaseTableConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tableName type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PrimaryKeyConstraint</class-id><body>This is a class representing non-foreign key database constraints. It's not actually used for very much, but is mostly so we can model the metadata in the database's information_schema to get information we need about primary keys and other information that may be represented as constraints rather than field attributes.</body></comment><class><name>JustSelectTheMaximumSequenceValueAndAddOne</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field table </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.JustSelectTheMaximumSequenceValueAndAddOne</class-id><body>This is a sequence that just does a select max(primaryKeyFieldName) for the table in question and adds one to it. This is, um, less-than-perfectly efficient, and I'm not at all clear that it'll work for a multi-user system. But it's what Store used to do on SQL Server, so we'd like to be able to mimic it. And it's actually easier to preallocate for than identity columns, which is nice. This isn't really named in the same sense as the others, but it's useful to inherit the named preallocation behaviour, and we store the field to select against in the name.Instance Variables:	tableName	&lt;DatabaseTable&gt;	the table we sequence.	field &lt;DatabaseField&gt; the field we sequence.</body></comment><class><name>GlorpUnitOfWorkPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.GlorpUnitOfWorkPackage</class-id><body>This class represents package information for the GlorpUnitOfWork package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>HorizontalTypeMapping</name><environment>Glorp</environment><super>Glorp.TypeMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mappedClass isAbstract </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.HorizontalTypeMapping</class-id><body>HorizontalTypeMapping assumes that all objects are stored in different tables. Only leaf classes in the inheritance hierarchy can be mapped. The descriptors for the classes themselves have the necessary information, our only job is to be involved in building up the query. Queries can be done either by splitting up into a series of separate queries, or as one horribly complex query with union all clauses.Instance Variables:	isAbstract	&lt;Boolean&gt;	Is this an abstract superclass.	mappedClass	&lt;Class&gt;	The class that we are mapping.</body></comment><class><name>ValidationError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.ValidationError</class-id><body>ValidationError is a superclass for all errors that are raise while validating a descriptor. The exception may resume.</body></comment><class><name>InvalidSessionSetup</name><environment>Glorp</environment><super>Glorp.ValidationError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.InvalidSessionSetup</class-id><body>InvalidSessionSetup will be raised if the descriptor system we are validating is different from the current session descriptor.</body></comment><class><name>GlorpDatabasePackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.GlorpDatabasePackage</class-id><body>This class represents package information for the GlorpDatabase package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>SubstringFunction</name><environment>Glorp</environment><super>Glorp.PrefixFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.SubstringFunction</class-id><body>This is a function subclass specifically for substring functions. It needs its own separate subclass because it has to be written out differently for different databases, particularly if applied to LOB types.</body></comment><class><name>ConstantExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ConstantExpression</class-id><body>This represents a literal constant. So, if object field = 2, this would be the (2) part.Instance Variables:	alias	&lt;String&gt;	Sometimes in queries we want to retrieve something specific in a column value. So, e.g. "select name as one, 2 as two from ...." Where we get back columns named 'one' and 'two', where the value of 'two' is always 2. The alias tells us what to alias the column for this as, if we're using this as something to be selected.	value	&lt;Object&gt;	The literal constant value.</body></comment><class><name>EmptyExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.EmptyExpression</class-id><body>This represents the null expression, but more polymorphically than just sticking nil in the where clause. We also use this as a short-circuiting mechanism if we're given a where clause that is either just literal true or literal false. So if you end up creating a query with a literal false, we will never go to the database, we'll just return an empty collection as the result. This is more useful than you might think.Instance Variables:	base	&lt;GlorpExpression&gt;	Our base expression, which we'll use in case someone ANDs or ORs something onto us.	value	&lt;Boolean| nil &gt; If we are true or false, then this result may end up being short-circuited. If it's nil, then we're just an empty where clause.</body></comment><class><name>DB2IdentityType</name><environment>Glorp</environment><super>Glorp.GlorpSerialType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.DB2IdentityType</class-id><body>DB2IdentityType represents identity column types in DB2. Glorp prefers sequences over identity columns, and uses sequences when generating schemas. But since pre-exisitng DB2 tables may contain identity columns, this class is necessary. See also, DB2Sequence and DB2IdentitySequence.</body></comment><class><name>MessageArchiverForGetMapping</name><environment>Glorp</environment><super>Glorp.MessageArchiver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.MessageArchiverForGetMapping</class-id><body>This is a special subclass of MessageArchiver which constructs its expression using getMapping:named: rather than just get:. It's possible it ought to be generalized to one that's parameterized by what message it sends, but right now I only need the one...</body></comment><class><name>GlorpRecursiveCollection</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstItem </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpRecursiveCollection</class-id><body>I pretend to be a collection and a stream to Glorp, receiving a collection of blobs that I rearrange into a chain.  To my Glorp domain class, I pretend to be a stream on a single object, not a collection, returning only the first item when asked my contents.Instance Variables:	firstItem	&lt;Object&gt;	the first item in the chain</body></comment><class><name>InfixFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>argument arguments functionParts </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.InfixFunction</class-id><body>This is a function that is infix. That is, it prints its name in between its arguments. For example, + for string concatenation, || for logical OR. Instance Variables:	arguments	&lt;Collection of GlorpExpression&gt;	Our post-arguments (the first one being the base).	functionParts &lt;Array of: String&gt; The parts of our name. For a two-argument function, this is just the same as an array containing the name, but for one with more (e.g. BETWEEN AND) it contains the different portions of the name.</body></comment><class><name>ReversingFunction</name><environment>Glorp</environment><super>Glorp.InfixFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ReversingFunction</class-id><body>I print my arguments in reverse.  Use me when it is essential for the MessageArchiver to have the base argument first, to parse correctly, but the SQL needs it to appear second.  Typically, this happens when a constant must be printed first in the SQL but lacks the information that MessageArchiver expects to parse a block into a GlorpExpression.</body></comment><class><name>DolphinDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DolphinDatabaseAccessor</class-id><body>The database accessor subclass for Dolphin Smalltalk.</body></comment><class><name>GlorpInMemorySequenceDatabaseType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>representationType </inst-vars><class-inst-vars>count </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Proxy</name><environment>Glorp</environment><super>Glorp.AbstractProxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session query parameters action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.Proxy</class-id><body>This implements the Glorp database proxy behaviour, for proxies that get their result by evaluating a query using a particular set of parameters, in the context of a particular Glorp query.Instance Variables:	parameters	&lt;Dictionary | SequenceableCollection&gt;	Our parameters, keyed either by name or by index.	query	&lt;Query&gt;	The query we will evaluate. Note that for a mapping, all proxies will share the same query instance.	session	&lt;GlorpSession&gt;	The session in which this proxy exists, and against which the query will be executed to find our value.</body></comment><class><name>SQLite3Proxy</name><environment>Glorp</environment><super>Glorp.Proxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.SQLite3Proxy</class-id><body>SQLiteProxy is different from a normal proxy in that its &gt;&gt;glorpTriggerProxyAction: method passes back the result of the block, which the &gt;&gt;getValue method reassigns to the originally retrieved #value inst var. The idea is to have a proxy that represents a DatabaseField, when there is no such entity in any SQLite schema table, so it must be constructed from a variety of special SQLite3 function calls (called pragmas).</body></comment><class><name>GlorpCorePackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.GlorpCorePackage</class-id><body>This class represents package information for the GlorpCore package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>BoundParametersUpdateCommand</name><environment>Glorp</environment><super>Glorp.ReturningUpdateCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.BoundParametersUpdateCommand</class-id><body>BoundParametersUpdateCommand outputs the returned relative field values to bind variables.  It is only used by Oracle when binding at the moment. For Oracle, this command must be bound, since the RETURN values are only able to be transmitted by Oracle through a bound array. An added curiousity, the EXDI permits us to access the returned array values through the &gt;&gt;bindVariable: method, normally intended for PLSQL queries.</body></comment><class><name>GlorpNumericType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>precision scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>PersistentObject</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.PersistentObject</class-id><body>This is an abstract superclass for Glorp persistent objects. Things don't have to subclass from this in order to be persistent, but if they do, they will inherit some methods which may be useful.</body></comment><class><name>CacheManager</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subCaches session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.CacheManager</class-id><body>This is the entire cache for a session, consisting of multiple sub-caches, one per class.Instance Variables:	session	&lt;Session&gt;	The containing session.	subCaches	&lt;Dictionary from: Class to: Cache&gt;	The per-class caches.</body></comment><class><name>GlorpTransactionFailure</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpTransactionFailure</class-id><body>This is the exception we raise if we encounter a database error trying to commit a transaction.</body></comment><class><name>GlorpDatabaseWriteError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command databaseError accessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseWriteError</class-id><body>This is the error we raise when we encounter an exception inside Glorp's database write code. This is uniform across dialects, so it can be reliably caught. We wrap the underlying exception.Instance Variables:	accessor	&lt;DatabaseAccessor&gt;	The accessor we were executing against.	command	&lt;DatabaseCommand&gt;	The command we were executing	databaseError	&lt;Exception&gt;	The exception that the system raised.</body></comment><class><name>GlorpHelper</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>GlorpHelper</class-id><body>This is a helper class for methods that I'd like to be able to add as extensions, but don't want to for fear of conflicting with dialects that have them, or people who implement them for their own projects, and any other miscellaneous extensions. One extension is that this class is in the Smalltalk namespace, so is universally accessible, and it provides a way for class extensions that don't have visibility of the Glorp namespace to access the Dialect class.</body></comment><class><name>DualRoleFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments whereClauseVersion selectListVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpExpressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.DualRoleFunction</class-id><body>This is a function that prints in different ways in a field list than it does in a where clause, typically because use of the where clause version isn't supported in field lists.</body></comment><class><name>GlorpQueries</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpQueries</class-id><body>This class represents package information for the GlorpQueries package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>DatabaseIndex</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>MjlGlorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseIndex</class-id><body>This describes an index in the database. Glorp doesn't use it internally, other than when creating tables in the database.Instance Variables:	fields	&lt;(SequenceableCollection of: DatabaseField)&gt;	The set of fields that are to be indexed.	name	&lt;String&gt;	The name of the index. We will try and generate one based on the table if one is not supplied.</body></comment><class><name>GlorpMySQLClobType</name><environment>Glorp</environment><super>Glorp.GlorpClobType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.GlorpMySQLClobType</class-id><body>MySQL clobs come back from the driver as binary data, so we need to make a subclass that knows it needs a converter for its incoming data.</body></comment><class><name>DeleteCommand</name><environment>Glorp</environment><super>Glorp.RowBasedCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DeleteCommand</class-id><body>A command to delete our set of rows.</body></comment><class><name>TimedProxyReaper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>weakValueDictionary keysSortedByExpiryTime indexOffset mutex reaperThread delay maximumWork nextId timeout done startTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpCore</package></attributes></class><comment><class-id>Glorp.TimedProxyReaper</class-id><body>Overview:A TimedProxyReaper collects TimedProxies and, using a background process, uninstantiates when they are due to expire. You can control the number of seconds between each invocation of the background process, with the message #delay:, and you can control the amount of work the background process will do each time it runs with the message #maximumWork:.API Methods:</body></comment><class><name>AdabasDPlatform</name><environment>Glorp</environment><super>Glorp.AdabasLikePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.AdabasDPlatform</class-id><body>This is a platform for the Adabas database, but appears very unfinished;  for example, it needs to define int4, which is a subclassResponsibility inherit from the super.</body></comment><class><name>QueryDeleteCommand</name><environment>Glorp</environment><super>Glorp.SelectCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query rowCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.QueryDeleteCommand</class-id><body>This represent a query that does a delete with a where clauseInstance Variables	query	&lt;SimpleQuery&gt;	The query that holds our where clause.</body></comment><class><name>RowMap</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowDictionary hasDeletions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.RowMap</class-id><body>This is the central class used for writing. We build up a collection of rows that are to be written, indexed by the objects that "own" them. While any object can contribute values to a row (for example, in a relationship, the value of a field that is a foreign key may come from the primary key of another object) it is a central assumption that each row is owned by a single object. Once we know all the rows, we can compute which ones have changed from their previous database values (see RowMapForMementos) and which fields within them have changed, and then we can write them out.Instance Variables:	hasDeletions	&lt;Boolean&gt;	Do we have any deletions. Deletions are marked by a flag in the row, but it's useful to know quickly if we have any or not.	rowDictionary	&lt;(Dictionary from: DatabaseTable to: (Dictionary from: Object to: DatabaseRow)&gt;	The rows, indexed by their table, then by the owning object.</body></comment><class><name>DictionaryMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyMapping valueMapping associationDescriptor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DictionaryMapping</class-id><body>This allows us to map a dictionary into tables. It should, I hope, support arbitrarily either mapping to single fields, or to objects, for either the key or the value. At the moment, it at least passes the tests for the value-&gt;object and value-&gt;value cases.Instance Variables:	keyMapping	&lt;DatabaseMapping&gt;	The mapping to use to read/write the key. It should be for an attribute named #key.	valueMapping	&lt;DatabaseMapping&gt;	The mapping to use to read/write the value. It should be for an attribute named #value. Note that this is optional, and isn't a full blown mapping, because if we have a relationship, we will normally just use this mapping to describe it directly. If we have a direct mapping for the value, then we have this odd situation where we use the Join from this mapping, but the direct mapping to control the read/write of the variable.	associationDescriptor	&lt;Descriptor&gt;	We manipulate the key/value pairs as associations in some places, and have a mock descriptor for association, specific to this mapping, which is used to get the key/value.</body></comment><class><name>BasicDictionaryMapping</name><environment>Glorp</environment><super>Glorp.DictionaryMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.BasicDictionaryMapping</class-id><body>This class is obsolete, but exists only so that people using the old name will not have to change their code.</body></comment><class><name>GlorpTimeType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>AdHocMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fromDbMappingBlock toDbMappingBlock mappedFields shouldProxy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.AdHocMapping</class-id><body>AdHocMapping is a configurable sort of mapping, done via two blocks. It's not easy to use, but gives you very direct access to the underlying mechanisms, so it should be possible to write mappings that are otherwise very complicated or impossible.Instance Variables:	fromDbMappingBlock	&lt;BlockClosure&gt;	The block we invoke when reading from the database. It's given arguments of the "row" we got from the database (note that this doesn't necessarily correspond to a single row, but is all the fields we selected in the query) , the elementBuilder associated with our containing object, and the "context", the expression from the query for what we're reading from the database. Typical usage is to use the context to translate a field into the appropriate aliased field from the query, and use the element builder to get the value of that field. e.g. elementBuilder valueOfField: (context translateField: someField) in: row	mappedFields	&lt;SequenceableCollection of: DatabaseField&gt;	The list of fields we work with. We need to specify this so that Glorp knows that it needs to e.g. includes these fields in the list of those selected.	shouldProxy	&lt;Boolean&gt;	Should we create a proxy for our target objects when we read an object containing this mapping.	toDbMappingBlock	&lt;BlockClosure&gt;	The block we invoke when writing to the database. It takes as arguments the rowmap being created, the target object we are writing, and a dictionary of the rows we already have associated with this object. The block is expected to update the rowmap with the new information.</body></comment><class><name>NoTableFound</name><environment>Glorp</environment><super>Glorp.ValidationError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expectedTables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.NoTableFound</class-id><body>NoTableFound is raise if there is possible mismatch between an active record and database table namesInstance Variables:	expectedTables	&lt;OrderedCollection&gt;	 expected table names to map the model</body></comment><class><name>ConstantMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constantValue valueIsSession </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ConstantMapping</class-id><body>Sometimes you just want a constant value to be set, either in the row, the object or both. And sometimes you just want a non-mapping (e.g. with a ConditionalMapping where oneof the conditions means "this isn't mapped"). This mapping represents these situations.It also handles the special case where it's useful to have access to the session inside adomain object, by allowing you to map it to an instance variable.So far only the case of mapping to an inst var is implemented.Instance Variables:</body></comment><class><name>OneToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.OneToManyMapping</class-id><body>This represents a mapping from one object to a collection of others. This class is really only here for backward compatibility. Using ToManyMapping directly will give exactly the same behaviour.</body></comment><class><name>TableBasedSequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequenceTableName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.TableBasedSequence</class-id><body>This is a sequence that gets its values from a sequence table. It doesn't look like it's fully implemented, or used.Instance Variables:	sequenceTableName	&lt;String&gt;	The name of the sequence table to use.</body></comment><class><name>GlorpMiscPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpMiscPackage</class-id><body>This class represents package information for the GlorpMisc package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>ManyToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.ManyToManyMapping</class-id><body>This is a to-many relationship in which we use a link table to the collection, rather than a foreign key in the items of the collection pointing back to the "owner". Using this class is exactly equivalent to just using a ToManyMapping and setting the useLinkTable field to true.</body></comment><class><name>GlorpBooleanType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabaseTypes</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>ObjectStudioDatabaseAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inTransaction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id><body>An accessor for ObjectStudio.Instance Variables:	inTransaction	&lt;Boolean&gt;	Are we in a transaction. We don't have an indicator for this from the database layer, so keep track of it here.</body></comment><class><name>TimedProxy</name><environment>Glorp</environment><super>Glorp.Proxy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id reaper secondsToLive timeToDie association </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.TimedProxy</class-id><body>This is a proxy which only holds onto its value for a fixed amount of time, and then uninstantiates. This is useful in highly-connected object graphs, where we might like to get rid of parts of a large tree that we are no longer using, but where simple weak references won't give enough information. For one to one relationships, we can cut the proxy relation, the object will remain in cache if it is registered or being otherwised referenced, and if we ask for it again, we won't have to go to the database because it will be found in cache. It's probably not such a good idea to use these kind of proxies for collections, where we will have to go to the database again if we need the value. See also TimedProxyReaper.Instance Variables:	association	&lt;Association&gt; The association in the TimedProxyReaper which holds onto our identifier plus a time after which we should expire.	id	&lt;Integer&gt;	An ID, assigned to us by the reaper, so that it doesn't hold strong references to us.	reaper	&lt;TimedProxyReaper&gt;	The reaper which controls this proxy.	secondsToLive	&lt;ArithmeticValue&gt;	How much time, in seconds, we should wait after we were last touched before expiring.	timeToDie	&lt;Integer&gt;	The millisecond clock value at which we expire. Is this a problem if there are dialects/versions for which the millisecond clock wraps around?</body></comment><class><name>RowMapForMementos</name><environment>Glorp</environment><super>Glorp.RowMap</super><private>false</private><indexed-type>none</indexed-type><inst-vars>correspondenceMap reversedCorrespondenceMap collectionMementos </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.RowMapForMementos</class-id><body>This is a specialized version of RowMap for creating rowmaps out of the mementos in the undo/correspondence map. When doing partial writes we create a rowmap for the current state of the objects, then a rowmap for the original state, and difference the two.The tricky part is that the mementos refer back to the original objects, so when we establish unification constraints between rows, they would establish them to original objects. This is wrong, and not trivial to debug.So this rowmap keeps the correspondence map and knows that it has to compensate and get the memento for any related objects.</body></comment><class><name>DictionaryBuilder</name><environment>Glorp</environment><super>Glorp.ElementBuilder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyBuilder valueBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.DictionaryBuilder</class-id><body>This is a subclass of builders that builds dictionaries. Basically it needs to build both the key and the value and then assemble them into a dictionary.Instance Variables:	keyBuilder	&lt;ElementBuilderr&gt;	The builder for the key	valueBuilder	&lt;ElementBuilder&gt;	The builder for the value.</body></comment><class><name>ParameterExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base lookupKey </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.ParameterExpression</class-id><body>This is an expression representing a placeholder for a parameter value. So, e.g. object attribute = &lt;parameter for field OWNER_ID&gt;. This is most frequently used for the queries in proxies, although it can be used anywhere. The parameter can be identified by either a field, a name, or an index, which can get fairly ugly.Instance Variables:	base	&lt;GlorpExpression&gt;	Our base expression.	lookupKey	&lt;DatabaseField | SomethingElse&gt;	The thing based on which we look up our parameter value in the array or dictionary of parameters that's passed to the query. So it can be number (for positional usage), a field, or something else.. </body></comment><class><name>NullSequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.NullSequence</class-id><body>This is a sequence that doesn't do anything. It's really just a placeholder.</body></comment><class><name>GlorpDatabaseReadError</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command databaseError accessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseReadError</class-id><body>This is the error we raise when we encounter an exception inside Glorp's database read code. This is uniform across dialects, so it can be reliably caught. We wrap the underlying exception.Instance Variables:	accessor	&lt;DatabaseAccessor&gt;	The accessor we were executing against.	command	&lt;DatabaseCommand&gt;	The command we were executing	databaseError	&lt;Exception&gt;	The exception that the system raised.</body></comment><class><name>Tracing</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base allTracings retrievalExpressions alsoFetchExpressions query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.Tracing</class-id><body>A tracing is a collection of expressions representing the graph of other objects whichare to be read at the same time as the root object.Instance Variables:	base	&lt;Expression&gt;	The base expression representing the root object. Same as the parameter to the query block	allTracings	&lt;Collection of: Expression&gt;	The expressions representing each of the associated objects. e.g. base accounts, base amount serviceCharge .	alsoFetchExpressions	&lt;(Collection of: GlorpExpression)&gt;	Objects to also retrieve, but not included in the result set, just knitted together with the other related objects.	retrievalExpressions	&lt;(Collection of: GlorpExpression)&gt;	Objects to also retrieve, and to include in the result set</body></comment><class><name>GlorpDatabaseTypesPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabaseTypes</package></attributes></class><comment><class-id>Glorp.GlorpDatabaseTypesPackage</class-id><body>This class represents package information for the GlorpDatabaseTypes package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>PostgresLibpqPlatform</name><environment>Glorp</environment><super>Glorp.PostgresPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PostgresLibpqPlatform</class-id><body>This is a platform for the libpq C protocol 3 API of the open-source PostgreSQL database.</body></comment><class><name>FilteringQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection filter collectBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.FilteringQuery</class-id><body>This is a query that expects all the objects it might return to already be in memory, and in a collection from which it can pick them out by evaluating a block. This is used to implement filtered reads on a mapping. When one of the mappings fires, it reads all the relevant results, and so each instance  using that mapping can get the results out of memory without going to the database again.Instance Variables:	collectBlock	&lt;Block&gt;	A one-argument block we evaluate to actually collect up the results. That is, internally we are likely to have a more complex representation in the collection, e.g. an array containing various extra information plus the objects. This gets the objects out of the collection.	collection	&lt;(GlorpVirtualCollection of: Object)&gt;	The collection on which we filter. Typically a virtual collection, at least for filtered reads, but can also handle a normal collection.	filter	&lt;Block&gt;	The two-argument block we use to filter. The first argument is the entry from the collection, the second is the parameters to the query that were used.	readsOneObject	&lt;Boolean&gt;	A duplicate of readsOneObject in AbstractReadyQuery. Do we return a collection, or a single result.</body></comment><class><name>VersionNumberVersionGenerator</name><environment>Glorp</environment><super>Glorp.VersionGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.VersionNumberVersionGenerator</class-id><body>This generates version numbers by adding one to the previous value of the designated field.</body></comment><class><name>CannotAutomaticallyDetermineJoin</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constraints tables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.CannotAutomaticallyDetermineJoin</class-id><body>When we create descriptors, Glorp will try to determine the join to use between two tables based on foreign key constraints, if it hasn't been specified explicitly. If we can't find any foreign key constraints, or if we find too many, and can't decide automatically which one to use, we raise this exception.This is an exception raised when creating Instance Variables:	constraints	&lt;Array of: ForeignKeyConstraint&gt;	The list of constraints we found.	tables	&lt;Collection of: DatabaseTable&gt;	The two tables we were trying to find a join between.</body></comment><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseTable</class-id><body>This is our internal representation of a table in the database. It holds onto enough information for us to both map to the table, and to create it in the database if required.Instance Variables	fields	&lt;(Collection of: DatabaseField)&gt;	The columns in the table.	foreignKeyConstraints	&lt;(Collection of: ForeignKeyConstraint)&gt;	The foreign key constraints between this table and others.	indexes	&lt;(Collection of: DatabaseIndex)&gt;	The indexes on this table.	isImaginary	&lt;Boolean&gt;	We allow "imaginary" tables, which don't really exist in the database. This is most useful in connection with embedded mappings. For example, we can have a Currency object which maps to a CURRENCY table, but there is no currency table in the database, and instead we have a number of embedded mappings that put those fields inside another table.	lockKeyFields	&lt;Collection of: DatabaseField&gt;	Which fields (which should also be in our field list) are checked when doing optimistic locking	name	&lt;String&gt;	The name of the table.	parent	&lt;DatabaseTable | nil&gt;	For a normal table, this is nil. When we create an aliased table we remember who the original table was using this field.	primaryKeyFields	&lt;(SequenceableCollection of: (DatabaseField))&gt;	Which fields (which should also be in our field list) are primary keys.	replacementSubSelect	&lt;CompoundQuery | SimpleQuery&gt;	I honestly don't remember at the moment what this does, but it seems to be used when we're traversing relationships that are in imaginary tables in order to figure out what the actual join has to be. And maybe the join needs to be done in a subselect rather than as a simple join in certain cases.	schema	&lt;String&gt;	What is the name of the schema in which this table exists. This is used when printing the qualified name of the table. 	uniqueConstraints	&lt;(Collection of: UniqueConstraint)&gt;	The unique constraints for this table</body></comment><class><name>GlorpIllegalCommand</name><environment>Glorp</environment><super>Glorp.GlorpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.GlorpIllegalCommand</class-id><body>This is the exception we raise if we try to execute a command for which permission has been denied at the Glorp level. e.g. we try to insert while denyWrites is active.Instance Variables:	command	&lt;DatabaseCommand&gt;	The command we tried to execute.</body></comment><class><name>PostgreSQLPlatform</name><environment>Glorp</environment><super>Glorp.PostgresPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PostgreSQLPlatform</class-id><body>This is a platform for the socket protocol 2 API of the PostgreSQL database.</body></comment><class><name>MultipleMappingsForInstanceVariable</name><environment>Glorp</environment><super>Glorp.ValidationError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attributeNames readableMappings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMisc</category><attributes><package>GlorpMisc</package></attributes></class><comment><class-id>Glorp.MultipleMappingsForInstanceVariable</class-id><body>This error raises when validating a descriptor if there is more than one mapping to the same instance variable.Instance Variables:	attributeNames	&lt;Collection of String&gt;	the list of attributes referencing the same instance variable	readableMappings	&lt;Collection of Mapping&gt;	the list of mappings referencing the same instance variable</body></comment><class><name>GlorpDictionaryDescription</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyExpression valueExpression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpDictionaryDescription</class-id><body>When querying for a dictionary, it's not enough to tell the query to return its collection in a dictionary. We need to be able to describe both the key and the value. So we would pass an instance of this as the collectionType: to a query or mapping.Instance Variables:	keyExpression	&lt;GlorpExpression | Block&gt;	The description of the key	valueExpression	&lt;GlorpExpression | Block&gt;	The description of the value</body></comment><class><name>VariableJoin</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>joins </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.VariableJoin</class-id><body>This represents a join that could be to multiple different tables, e.g. when using horizontal inheritance.Instance Variables:	joins	&lt;Dictionary from: Class to: Join&gt;	description of joins</body></comment><class><name>DatabaseRow</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table contents shouldBeWritten owner forDeletion status oldVersion generated parent operation </inst-vars><class-inst-vars>missingFieldIndicator emptySlot </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.DatabaseRow</class-id><body>This represents the data to be written out to a row. Database rows are normally stored in a rowmap, keyed according to their table and the object that did the primary writes to them. We expect that that's only one object, although embedded values are an exception to that.Instance Variables:	table	&lt;DatabaseTable&gt;	The table holding the data	contents	&lt;IdentityDictionary&gt;	Holds the fields with their values, indirectly through FieldValueWrapper instances.	shouldBeWritten	&lt;Boolean&gt;	Normally true, but can be set false to suppress writing of a particular row. Used with embedded value mappings, where we create their row, unify it with the parent row, and suppress writing of the original row.	owner	&lt;Object&gt;	The primary object that wrote into this row, would also be the key into the rowmap.	forDeletion &lt;Boolean&gt; Is this row to be deleted or written.	status &lt;Symbol&gt; Used for topological sort to determine write order. We keep a symbol indicating the "visited" status of the row while doing the sort. This doesn't separate the sort from the row, using each row directly as a node in the graph. This is less general, but uses less memory than other alternatives.	parent &lt;DatabaseRow&gt; Also used during sorting. Keep track of our parent node.	oldVersion &lt;DatabaseRow&gt; The old version of us. Used if we increment a version field to keep track of what its value was before.	generated &lt;Boolean&gt; True if we have already had field with generated types generated in the preWrite phase. This is needed because we generate all sequences before doing any writes. But if we use an explicit writeRow: operation, then we want to make sure that generated values are generated. And some generated types write over what was there before (e.g. optimistic lock fields). So we need a way of knowing if generation has already been done. Note that this doesn't apply if using post-write sequence generation (i.e. identity columns) because then it's all after the write. This makes certain things not work as well, but that's what you get for using identity columns.	</body></comment><class><name>UniqueConstraint</name><environment>Glorp</environment><super>Glorp.DatabaseTableConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.UniqueConstraint</class-id><body>UniqueConstraint implementation has not been finishedInstance Variables:	isForPrimaryKey	&lt;Boolean&gt;	description of isForPrimaryKey</body></comment><class><name>GlorpCursoredStream</name><environment>Glorp</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>command cursor mightHaveDuplicateRows builders buildersThatReturnResults databaseAccessor peekBuffer rawPeekBuffer statement </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpQueries</category><attributes><package>GlorpQueries</package></attributes></class><comment><class-id>Glorp.GlorpCursoredStream</class-id><body>This is a Glorp wrapper for a database cursor. It has stream-like behaviour, which is implemented by getting rows from the underlying cursor and constructing the objects as required. All queries go through one of these streams, although in the default case they will get all the results out of it (at which point the cursor will be closed) and then return them in another kind of collection. But it's possible to use one of these as the return type, in which case you can make use of the open cursor to incrementally get results.Instance Variables:	builders	&lt;(Collection of: ObjectBuilder)&gt;	The ObjectBuilders used to construct the objects we return out of the rows.	buildersThatReturnResults	&lt;(SequenceableCollection of: ElementBuilder)&gt;		command	&lt;DatabaseCommand&gt;	The command that was executed to give us this cursor.	cursor	&lt;&gt;	The underlying database cursor. Class varies by dialect. We deal with the lack of polymorphism by indirecting all cursor operations through the accessor.	databaseAccessor	&lt;DatabaseAccessor&gt;	The accessor that the command was executed against.	mightHaveDuplicateRows	&lt;Boolean&gt;	May this stream have duplicate rows? This can happen, for example, if we do a join that causes some sub-section of the row to be duplicated. If so, we need to check for this and remove duplicates from the object stream as we go. This forces us to peek ahead.	peekBuffer	&lt;Object&gt;	The peek buffer (holding an object) that we use when peeking ahead.	rawPeekBuffer	&lt;&gt;	The peek buffer (holding a row) that we use when peeking ahead. We need to buffer at both levels.	statement	&lt;GlorpPreparedStatement&gt;	The actual prepared statement that the command ran in order to get our results.</body></comment><class><name>SQLStringCommand</name><environment>Glorp</environment><super>Glorp.DatabaseCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameters maximumBlobSizeToRetrieveDirectly </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.SQLStringCommand</class-id><body>This represents a command that executes arbitrary SQL and is not a select. For selects use SQLStringSelectCommand.</body></comment><class><name>PseudoColumnFunction</name><environment>Glorp</environment><super>Glorp.FunctionExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><comment><class-id>Glorp.PseudoColumnFunction</class-id><body>My pupose is to set an alias on my base.	- I provide a wrapping alias to any RelationExpression on which I am called.  Ordinarily, this RelationExpression will be acting as a field in the source or target of a join, and therefore as a column in a SELECT list.I set the alias of any other My name is usually just an empty string.  My alias is usually not empty.  I therefore merely print my base expression (expected to be a RelationExpression)	- as an aliased expression in a SELECT list	- as merely the unaltered base expression in a joinI suppress binding while printing my base:  see the comment in my #printSQLOn:withParameters:Background remark:  my existence probably indicates some issue in aliasing which better understanding could eliminate.  FieldExpressions can be alised but those aliases are not printed to the SELECT list.</body></comment><class><name>GlorpPGTimeWithTimeZoneType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>FirebirdSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.FirebirdSequence</class-id><body>Implements firebird sequence generation by calling out to gen_id()</body></comment><class><name>PGSequence</name><environment>Glorp</environment><super>Glorp.NamedSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.PGSequence</class-id><body>This implements postgresql sequences using nextVal. The mechanism is similar to Oracle sequences, but we don't have to give it a table to select against when all we want is a bunch of numbers, so the implementation is simpler.</body></comment><class><name>ForeignKeyConstraint</name><environment>Glorp</environment><super>Glorp.DatabaseTableConstraint</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suffixExpression sourceFields targetFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.ForeignKeyConstraint</class-id><body>This represents a foreign key constraint in the database. It's used during table creation, but more important it's used when calculating the order in which we need to write rows. Also, if joins aren't specified on a relationship, we will try to infer them from the foreign key constraints.Instance Variables:	name	&lt;Object&gt;	The name of the constraint.	shouldCreateInDatabase	&lt;Boolean&gt;	We may have table definitions that we don't want to create in the database, either because we know they're already there, or because they are for "imaginary" tables.	sourceFields	&lt;(SequenceableCollection of: DatabaseField)&gt;	The fields we constrain from. The order is fairly arbitrary, but at least we use it consistently.	suffixExpression	&lt;String&gt;	A bit of a hack to allow us to append some extra text to the constraint. In particular, added to support the ability to append "ON DELETE CASCADE".	targetFields	&lt;(SequenceableCollection of: DatabaseField)&gt;	The fields we constraint to.</body></comment><class><name>InsertSelectRowsCommand</name><environment>Glorp</environment><super>Glorp.InsertSelectRowCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InsertSelectRowsCommand</class-id><body>I allow insertion of multiple rows in a single round trip when the target table has an IdentityColumn.  I insert rows and then select the values generated by the server for the identity column in the inserted rows.  These values are output into a temporary table variable declared before the insert.  The three statements that make up this command's SQL are, for example,	DECLARE @TableOfIdentities TABLE (IdentValue INT);	INSERT INTO mytable(firstname, lastname, address)		OUTPUT Inserted.id INTO @TableOfIdentities(IdentValue)		VALUES ( 'James', 'Bond', '10 Richmond Place'), ('Sherlock', 'Holmes', '221b Baker Street'), ('Jane', 'Marple', 'St Mary's Mead') ...;	SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValuewhen unbound.  The bound equivalent is	DECLARE @TableOfIdentities TABLE (IdentValue INT);	INSERT INTO mytable(firstname, lastname, address)		OUTPUT Inserted.id INTO @TableOfIdentities(IdentValue)		VALUES (?, ?, ?);	SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValueOn SQLServerPlatform (the only platform using this command at this time) when values for two or more rows are bound in an array of arrays (this array bound approach is the norm), then they appear as	...;	bindInput:			#(				#('James' 'Sherlock' 'Jane' ... )				#('Bond' 'Holmes' 'Marple' ... )				#('10 Richmond Place' '221b Baker Street' 'St Mary's Mead' ... )			)and it iterates ALL the statements for each row.  Thus each of many answer streams contains the IdentValues for one row  (temporary table TableOfIdentities is redeclared for each row).  See #postWriteAssignSequenceInRoundTrip: for how this is handled.  (Values can also be bound sequentially in the generated SQL statement, similar to unbound	... VALUES (?, ?, ?), (?, ?, ?) ...and in that case the before and after statements are only executed once and the answer stream behaviour is the same as for unbound.  This is only used if #usesArrayBindingToGroupWrite is false;  it is true for SQLServerPlatform.)</body></comment><class><name>GlorpMappingsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.GlorpMappingsPackage</class-id><body>This class represents package information for the GlorpMappings package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>GlorpRowSorter</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>childSelector queue sorted current items childCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.GlorpRowSorter</class-id><body>This sorts a set of rows to determine the order in which they should be inserted into the database. It does this using a breadth first topological sort. What that means is that instead of traversing the graph depth first, as is normal for topological, we traverse it breadth first. This gives us the desirable property of keeping the child rows together as much as possible. Since the initial input will already have been sorted by the static table ordering that is implied by the foreign key constraints, this will also keep rows from the same table together, unless the sort algorithm finds a reason the order needs to be changed. This maximizes the opportunities for using optimizations like Oracle array binding, which want to write groups of similar rows all at once. Note that we can't just use the table order directly, because there may be row-level issues. That is, rows may need to be written before other rows in the same table, or even if there is a table constraint, it may only be relevant for a small number of rows.Instance Variables:	childCache	&lt;IdentityDictionary from: Object to: Collection&gt;	The calculation of children may be expensive, and may have to be done more than once for an item, so we cache the information here.	childSelector	&lt;Symbol | BlockClosure&gt;	The zero-argument selector which we perform on an item, or the one-argument block which we evaluate in order to get the children.	current	&lt;DatabaseRow | GlorpBreadthFirstTopologicalSortItem&gt;	The item we are currently examining.	items	&lt;ReadStream&gt;	A stream on the items we are intended to sort.	queue	&lt;OrderedCollection&gt;	This maintains the breadth first order. So, when we encounter an item, we add its children to the end of the queue. The Sorter processes the items in order off the queue, resulting in a breadth first traversal.	sorted	&lt;OrderedCollection&gt;	The resulting collection, in sorted order.</body></comment><class><name>TimestampVersionGenerator</name><environment>Glorp</environment><super>Glorp.VersionGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.TimestampVersionGenerator</class-id><body>A generator that puts Timestamp now into fields when it is invoked.</body></comment><class><name>GlorpMSSQLFloatType</name><environment>Glorp</environment><super>Glorp.GlorpAbstractNumericType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>HorizontalTypeResolver</name><environment>Glorp</environment><super>Glorp.BasicTypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shouldUseSingleQuery </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.HorizontalTypeResolver</class-id><body>This implements inheritance where each concrete class is represented in its own table. Each table will duplicate the fields that are in common between the concrete classes.</body></comment><class><name>DirectMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field converter shouldProxy query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><comment><class-id>Glorp.DirectMapping</class-id><body>This is the simplest type of mapping, it maps directly between an instance variable that holds some "primitive" type, and a field in a database table.Instance Variables:	converter	&lt;DatabaseConverter&gt;	The converter used to transform the data into database form and back again. This will be automatically computed based on the types defined, if possible, but for more complex conversions (e.g. booleans into strings in the database) a converter can be explicitly specified.	field	&lt;DatabaseField | FunctionExpression&gt;	The field to write to. One complication is that (for reading purposes) the field may be a function. So we might have a mapping that reads from the TO_UPPER of some field, or even an aggregate function like MAX.</body></comment><class><name>RowMapKey</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>key1 key2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpUnitOfWork</package></attributes></class><comment><class-id>Glorp.RowMapKey</class-id><body>This class serves as a key for a dictionary containing two sub-keys, where we want to be able to look up based on the identity of both sub-keys paired together. This is used primarily for many-to-many mappings indexing into rowmaps, where we want to key the row by the identity of the object that determines it, but there are two of them.Instance Variables:key1	&lt;Object&gt;	One sub-key.key2	&lt;Object&gt;	The other sub-key.'</body></comment><class><name>InMemorySequence</name><environment>Glorp</environment><super>Glorp.DatabaseSequence</super><private>false</private><indexed-type>none</indexed-type><inst-vars>count </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><comment><class-id>Glorp.InMemorySequence</class-id><body>This is a sequence generator that just generates numbers in memory. Mostly useful for testing, because the numbers aren't guaranteed unique in the database unless we are the only user, and our initial value was appropriately set.Instance Variables:	count	&lt;Integer&gt;	The last used identifier.</body></comment><shared-variable><name>Singleton</name><environment>Glorp.NullSequence</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>GlorpDatabase</package></attributes></shared-variable><shared-variable><name>LoggingEnabled</name><environment>Glorp.DatabaseAccessor</environment><private>false</private><constant>false</constant><category>accessing</category><initializer></initializer><attributes><package>GlorpDatabase</package></attributes></shared-variable><shared-variable><name>UseBindingIfSupported</name><environment>Glorp.DatabasePlatform</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>nil</initializer><attributes><package>GlorpDatabase</package></attributes></shared-variable><methods><class-id>Glorp.TableSorter</class-id> <category>accessing</category><body package="GlorpUnitOfWork">addTable: aTable 	tables add: aTable</body><body package="GlorpUnitOfWork">hasBeenVisited: aTable	^visitedTables includes: aTable.</body><body package="GlorpUnitOfWork">markVisited: aTable	visitedTables add: aTable.</body></methods><methods><class-id>Glorp.TableSorter</class-id> <category>initializing</category><body package="GlorpUnitOfWork">initialize	tables := OrderedCollection new: 100.	visitedTables := IdentitySet new: 100.</body></methods><methods><class-id>Glorp.TableSorter</class-id> <category>sorting</category><body package="GlorpUnitOfWork">sort	orderedTables := OrderedCollection new: tables size.	tables do: [:each | self visit: each].	^orderedTables select: [:each | tables includes: each].</body><body package="GlorpUnitOfWork">visit: aTable 	"The essential bit of topological sort. Visit each node in post-order, traversing dependencies, based on foreign key constraints to database-generated fields. "	(self hasBeenVisited: aTable) ifTrue: [^self].	self markVisited: aTable.	self visitDependentTablesFor: aTable.	orderedTables add: aTable</body><body package="GlorpUnitOfWork">visitDependentTablesFor: aTable	"If the foreign key is also in the database (the default), getting this write-order right may be essential to having the database accept it.  If not, but one of a table's fields (key or otherwise) is also an IdentityColumn (i.e. post-write-assigned) primary key of another table, then a Glorp-only foreign key may be of use in getting the post-write-assigned value for the other row before it is written."	aTable foreignKeyConstraints do:		[:eachConstraint |		self visit: eachConstraint targetTable].</body></methods><methods><class-id>Glorp.TableSorter class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork">for: tables	| sorter |	sorter := self new.	tables do: [:each |		sorter addTable: each].	^sorter.</body><body package="GlorpUnitOfWork">new	^super new initialize.</body></methods><methods><class-id>Glorp.CachePolicy</class-id> <category>initialize</category><body package="GlorpCore">collectionForExtraReferences	^nil.</body><body package="GlorpCore">initialize	numberOfElements := 100.	expiryAction := #remove.</body><body package="GlorpCore">newItemsIn: aCache	^self dictionaryClass new: 20.</body></methods><methods><class-id>Glorp.CachePolicy</class-id> <category>accessing</category><body package="GlorpCore">dictionaryClass	^Dictionary.</body><body package="GlorpCore">expiryAction	^expiryAction</body><body package="GlorpCore">expiryAction: aSymbol	"See class comment for possible values"	expiryAction := aSymbol</body><body package="GlorpCore">numberOfElements	^numberOfElements</body><body package="GlorpCore">numberOfElements: anInteger	numberOfElements := anInteger</body></methods><methods><class-id>Glorp.CachePolicy</class-id> <category>wrap/unwrap</category><body package="GlorpCore">cacheEntryFor: anObject	^anObject.</body><body package="GlorpCore">contentsOf: aCacheEntry	^aCacheEntry.</body><body package="GlorpCore">hasExpired: aCacheEntry	^false.</body><body package="GlorpCore">markEntryAsCurrent: aCacheEntry in: aCache	^self.</body></methods><methods><class-id>Glorp.CachePolicy</class-id> <category>expiry</category><body package="GlorpCore">expire: anItem	"Force anItem to be expired. This may be ignored if the policy doesn't respect this, and is ignored by default"</body><body package="GlorpCore">notifyOfExpiry: anObject in: aCache 	anObject glorpNoticeOfExpiryIn: aCache session.</body><body package="GlorpCore">release: aCache	(expiryAction == #notify or: [expiryAction == #notifyAndRemove])		ifTrue: [			aCache do: [:each |				(self contentsOf: each)  glorpNoticeOfExpiryIn: aCache session]].</body><body package="GlorpCore">takeExpiryActionForKey: key withValue: anObject in: aCache	expiryAction == #refresh		ifTrue: [aCache session refresh: anObject].	(#(#notify #notifyAndRemove) includes: expiryAction) ifTrue: [		self notifyOfExpiry: anObject in: aCache].	(#(#remove #notifyAndRemove) includes: expiryAction) ifTrue: [		aCache removeKey: key ifAbsent: []].</body><body package="GlorpCore">willRemoveItems	^(expiryAction == #notifyAndRemove or: [expiryAction == #remove])</body></methods><methods><class-id>Glorp.CachePolicy class</class-id> <category>instance creation</category><body package="GlorpCore">default	"Use of the WeakVWCachePolicy is tied in with Ephemera which we do not expect to get working in VW3."	Dialect isVWWithNameSpaces ifTrue: [^WeakVWCachePolicy new].	^self new</body><body package="GlorpCore">new	^super new initialize.</body></methods><methods><class-id>Glorp.WeakVWCachePolicy</class-id> <category>expiry</category><body package="GlorpCore">collectionForExtraReferences	^FixedSizeQueue maximumSize: self numberOfReferencesToKeepAround.</body><body package="GlorpCore">markEntryAsCurrent: item in: aCache	aCache markEntryAsCurrent: item.</body></methods><methods><class-id>Glorp.WeakVWCachePolicy</class-id> <category>accessing</category><body package="GlorpCore">dictionaryClass	^Dialect smalltalkAt: #EphemeralValueDictionary ifAbsent: [Dictionary].</body><body package="GlorpCore">numberOfReferencesToKeepAround	^numberOfElements.</body></methods><methods><class-id>Glorp.WeakVWCachePolicy</class-id> <category>initialize-release</category><body package="GlorpCore">newItemsIn: aCache	| items |	items := super newItemsIn: aCache.	items manager: aCache.	^items.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>printing</category><body package="GlorpExpressions">className	^self class name.</body><body package="GlorpExpressions">displayString	| stream |	stream := String new writeStream.	self printOnlySelfOn: stream.	^stream contents.</body><body package="GlorpExpressions">printOn: aStream 	self printTreeOn: aStream</body><body package="GlorpExpressions">printOnlySelfOn: aStream	self subclassResponsibility.</body><body package="GlorpExpressions">printTreeOn: aStream	self subclassResponsibility.</body><body package="GlorpCore">sqlString	| command |	command := QuerySelectCommand new		useBinding: false;		session: self ultimateBaseExpression descriptor session.	self printSQLOn: command withParameters: #().	^command contents.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>preparing</category><body package="GlorpExpressions">addBoundExpressionsIn: aCommand</body><body package="GlorpExpressions">additionalExpressions	^#().</body><body package="GlorpExpressions">additionalExpressionsIn: aQuery 	"Return the collection of additional expressions (representing joins) that this expression tree requires. Because some additional expressions may in turn have their own additional expressions (mapping joins represented by general expressions), repeat until we don't get any more."	| allExpressions newExpressions allNewExpressions expressionsConsidered |	allExpressions := self asExpressionGroup.	allExpressions addAll: aQuery ordering.	allExpressions addAll: aQuery grouping.	allExpressions addAll: aQuery tracing additionalExpressions.	expressionsConsidered := IdentitySet new.	allNewExpressions := OrderedCollection new.	newExpressions := nil.	[newExpressions := (newExpressions isNil ifTrue: [allExpressions] ifFalse: [newExpressions])		inject: ExpressionGroup new 		into: [:sum :each | 			((expressionsConsidered includes: each) not and: [				each queryLevelBaseExpression == aQuery baseExpression]) ifTrue: [					sum addAll: each additionalExpressions.					expressionsConsidered add: each].			sum].	allNewExpressions addAll: newExpressions children.	newExpressions isEmpty] whileFalse.	^allNewExpressions.</body><body package="GlorpExpressions">addToTargetFields: aCollection	"If we can provide target fields, add them to the collection"	^self.</body><body package="GlorpExpressions">allControlledTables	"Return all the tables that we control, directly or indirectly. Basically, if we are a mapping expression with a link table, return the link table as well as any tables of ours."	^self tables.</body><body package="GlorpExpressions">allRelationsFor: rootExpression do: aBlock andBetweenDo: anotherBlock	"In any normal relationship, there's only one thing. Just do it"	aBlock value: rootExpression leftChild value: rootExpression rightChild.</body><body package="GlorpExpressions">allTables	^self inject: Set new into: [:sum :each | 		sum addAll: each tables. sum].</body><body package="GlorpExpressions">allTablesToPrint	^self inject: Set new into: [:sum :each | 		sum addAll: each tablesToPrint. sum].</body><body package="GlorpExpressions">allTablesToPrintStoppingAt: aSubSelectBaseExpression	^self inject: Set new into: [:sum :each | 		each queryLevelBaseExpression == aSubSelectBaseExpression ifTrue: [			sum addAll: each tablesToPrint]. sum].</body><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	self subclassResponsibility.</body><body package="GlorpExpressions">assignTableAliasesStartingAt: anInteger prefix: aString	^anInteger.</body><body package="GlorpExpressions">bindingType	^self type.</body><body package="GlorpExpressions">condenseBooleanEquality	^self.</body><body package="GlorpExpressions">condenseBooleanEqualityExpressions	^self.</body><body package="GlorpDatabase">condensePrimaryKeyComparison	^self.</body><body package="GlorpExpressions">condensePrimaryKeyComparisons	^self.</body><body package="GlorpExpressions">prepareIn: aQuery	"A little weird, because what we end up asking for additional expressions from, might not be us"	aQuery adjustWhereClause.	(aQuery whereClause additionalExpressionsIn: aQuery) do:		[:each | 		(aQuery shouldExpressionBeJoin: each)			ifTrue: [aQuery addJoin: each]			ifFalse: [aQuery privateAnd: each]].	aQuery whereClause isOuterJoin ifTrue:	"ANSI syntax does not support outer joins in the where clause"		[(aQuery shouldExpressionBeJoin: aQuery whereClause)			ifTrue:				[aQuery addJoin: aQuery whereClause.				aQuery whereClause: (EmptyExpression new base: aQuery baseExpression)]			ifFalse: [self error: 'Our whereClause wants to be treated as an outer join but should not be a join']].</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression	"Rebuild the expression on the new base. If we encounter anExpression, treat that as the base, and build only from that point up. e.g. if we have a.b.c.d and we rebuildOn: z startingFrom: b, then the result will be z.c.d"	^self rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: nil.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	"Rebuild the expression on the new base. If we encounter anExpression, treat that as the base, and build only from that point up. e.g. if we have a.b.c.d and we rebuildOn: z startingFrom: b, then the result will be z.c.d. Pieces that aren't based on anExpression should be built onto ultimateBaseExpression instead of aBaseExpression. They represents parts of outer scope trees that are referenced within us.  Note that anExpression can be nil, but if it is, then ultimateBaseExpression is effectively ignored."	self subclassResponsibility.</body><body package="GlorpExpressions">removeNonJoinParts	"Remove anything that's not an actual join. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to use the general ones, because they're not field level."	^self.</body><body package="GlorpExpressions">replaceJoinsWithInverse	"If we don't know specifically what to do with a kind of expression, assume it doesn't apply and we should be replacing it with nothing."	^self.</body><body package="GlorpExpressions">rewriteBooleanEquality: relation	"Does not apply to general expressions"</body><body package="GlorpExpressions">rewriteEquality	^self.</body><body package="GlorpExpressions">rewriteEqualityExpressions	^self.</body><body package="GlorpExpressions">rewriteFunctionArguments	"If a function needs to adjust its arguments, do that here. The motivating example is one where a string argument is rewritten into a form that's of a different length, e.g. the Postgresql driver does that to strings in Blobs"	^self.</body><body package="GlorpExpressions">rewriteFunctionArgumentsWith: ourArgument	"If a function needs to adjust its arguments, do that here. The motivating example is one where a string argument is rewritten into a form that's of a different length, e.g. the Postgresql driver does that to strings in Blobs"	^self.</body><body package="GlorpExpressions">tableForANSIJoin	"Which table will we join to."	^nil.</body><body package="GlorpExpressions">tables	^#().</body><body package="GlorpExpressions">tablesContainingMe	"Return a list of tables that contain this object, whether or not we control them. This is mostly the same as tables, but will differ for embedded mappings."	^self tables.</body><body package="GlorpExpressions">tablesToPrint	^#().</body><body package="GlorpExpressions">validate</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>iterating</category><body package="GlorpExpressions">allSatisfy: aBlock	"Answer true if aBlock answers true for any element of the receiver.	 An empty collection answers false."	self do: [:each| (aBlock value: each) ifFalse: [^false]].	^true</body><body package="GlorpExpressions">anySatisfy: aBlock	"Answer true if aBlock answers true for any element of the receiver.	 An empty collection answers false."	self do: [:each| (aBlock value: each) ifTrue: [^true]].	^false</body><body package="GlorpExpressions">collect: aBlock	| newCollection |	newCollection := OrderedCollection new.	self do: [:each | newCollection add: (aBlock value: each)].	^newCollection.</body><body package="GlorpExpressions">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone: [self notFoundError]</body><body package="GlorpExpressions">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="GlorpExpressions">do: aBlock	"Iterate over the expression tree"	self do: aBlock skipping: IdentitySet new.</body><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	aSet add: self.	aBlock value: self.</body><body package="GlorpExpressions">inject: anObject into: aBlock	| sum |	sum := anObject.	self do: [:each | sum := aBlock value: sum value: each].	^sum</body><body package="GlorpExpressions">select: aBlock	| newCollection |	newCollection := OrderedCollection new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>inspecting</category><body package="GlorpExpressions">inspectorChildren	^#()</body><body package="GlorpExpressions">inspectorHierarchies	| hierarchy |	hierarchy := ((Smalltalk at: #Tools ifAbsent: [^#()])		at: #Trippy ifAbsent: [^#()])		at: #Hierarchy ifAbsent: [^#()].	^Array with: (hierarchy			id: #expression			label: 'Expression Tree'			parentBlock: [:each | nil]			childrenBlock: [:each | each inspectorChildren])</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>testing</category><body package="GlorpExpressions">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^false.</body><body package="GlorpExpressions">canBind	"Return true if this represents a value that can be bound into a prepared statement"	^false.</body><body package="GlorpExpressions">canKnit	"Return true if, when building objects, we can knit the object corresponding to this expression to a related object. Roughly speaking, is this a mapping expression"	^false.</body><body package="GlorpExpressions">canPrint	"Return true if we can print into a where clause"	^true.</body><body package="GlorpExpressions">canTranslateFields	"Return true if we are a mapping expression and can thus translate from fields into their aliased version for a particular query."	^false.</body><body package="GlorpExpressions">hasImpliedClauses	"Return true if this implies additional SQL clauses beyond just a single field expression"	^false.</body><body package="GlorpExpressions">hasProvidedAdditionalExpressions	"Return true if we have already provided additional expressions to some query. Only important when we're preparing a subselect and don't want to bring in joins that are part of the main query"	^true.</body><body package="GlorpExpressions">hasTableAliases	^false.</body><body package="GlorpExpressions">isConstantExpression	^false.</body><body package="GlorpExpressions">isDistinct	^false.</body><body package="GlorpExpressions">isEmptyExpression	^false.</body><body package="GlorpExpressions">isGlorpExpression	^true.</body><body package="GlorpExpressions">isJoin	^false.</body><body package="GlorpExpressions">isMappable	"Return true if we're something that can be returned in a select statement."	^true.</body><body package="GlorpExpressions">representsDerivedObject	^false.</body><body package="GlorpExpressions">returnsDictionary	"Return true if we representa  ampping to a dictionary"	^false.</body><body package="GlorpExpressions">shortCircuitOnNullComparison: anObject	"Return true if we represent an expression that compares null to a non-nullable value, so we don't ever need to really evaluate it"	^false.</body><body package="GlorpExpressions">willPrintAsWhereClause	^true.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>accessing</category><body package="GlorpExpressions">beOuterJoin	"A no-op"</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^self subclassResponsibility.</body><body package="GlorpExpressions">commonTableExpressionName	"If we decide to store values obtained via this expression in a field of common table expression, e.g. to recursively collect such values, what should that field be called."	| newName maxNameLength |	newName := self mappingSequenceName.	maxNameLength := self system platform maximumLengthOfColumnName.	^maxNameLength &lt; newName size		ifFalse: [newName]		ifTrue:			[(newName copyFrom: 1 to: (maxNameLength * 0.25) rounded) 				, '_' ,			(newName copyFrom: newName size - (maxNameLength * 0.75) rounded + 3 to: newName size)]</body><body package="GlorpExpressions">field	^nil.</body><body package="GlorpExpressions">fieldFromMeOrSubclasses	"For mapping expression, return the field for this mapping, but if the field is not mapped, and the class uses inheritance, check for subclasses, and use a random one of the subclass mappings. For all others, just return the field."	^self field.</body><body package="GlorpExpressions">hasDescriptor	^false.</body><body package="GlorpExpressions">isOuterJoin	"Only used in prepareIn: as a prudential test before join-checking the outermost whereClause itself, not to rehandle it unless needed.  Remove this method if that use is dropped."	^false</body><body package="GlorpExpressions">printsTable	^false.</body><body package="GlorpExpressions">type	^self field type.</body><body package="GlorpExpressions">valueIn: aDictionary	"Return the value associated with this expression given the parameters in aDictionary. Only meaningful for ParameterExpressions"	^self.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>api</category><body package="GlorpExpressions">, anExpression	^self get: #, withArguments: (Array with: anExpression asGlorpExpression).</body><body package="GlorpExpressions">AND: anExpression	"This method doesn't really have to exist, because it would be inferred using operationFor:, but it's included here for efficiency and to make it a little less confusing how relation expression get created. Note that the two expression must already be  built on the same base!"	anExpression isNil ifTrue: [^self].	anExpression == true ifTrue: [^self].	anExpression == false ifTrue: [^false].	(anExpression isGlorpExpression and: [anExpression isEmptyExpression]) ifTrue: [^self].	^RelationExpression named: #AND basedOn: self withArguments: (Array with: anExpression).</body><body package="GlorpExpressions">AND: anExpression AND: otherExpression	"A convenience method to allow easy conjunction of multiple ANDs at the same level"	^(self AND: anExpression) AND: otherExpression.</body><body package="GlorpExpressions">AND: anExpression AND: otherExpression AND: thirdExpression	"A convenience method to allow easy conjunction of multiple ANDs at the same level"	^((self AND: anExpression) AND: otherExpression) AND: thirdExpression.</body><body package="GlorpExpressions">AND: anExpression AND: otherExpression AND: thirdExpression AND: fourthExpression	"A convenience method to allow easy conjunction of multiple ANDs at the same level"	^(((self AND: anExpression) AND: otherExpression) AND: thirdExpression) AND: fourthExpression.</body><body package="GlorpExpressions">asGlorpExpression	^self.</body><body package="GlorpExpressions">base	self subclassResponsibility.</body><body package="GlorpExpressions">equals: anExpression	^RelationExpression named: #= basedOn: self withArguments: (Array with: anExpression).</body><body package="GlorpExpressions">get: aSymbol withArguments: anArray	self subclassResponsibility.</body><body package="GlorpExpressions">getFunction: aSymbol withArguments: anArray	| expression |	expression := FunctionExpression for: aSymbol withArguments: anArray basedOn: self.	expression isNil ifTrue: [^nil].	^expression.</body><body package="GlorpExpressions">getFunction: aSymbol withArguments: anArray in: system	| expression |	expression := FunctionExpression for: aSymbol withArguments: anArray basedOn: self system: system.	expression isNil ifTrue: [^nil].	^expression.</body><body package="GlorpExpressions">OR: anExpression	"This method doesn't really have to exist, because it would be inferred using operationFor:, but it's included here for efficiency and to make it a little less confusing how relation expression get created.  Note that the two expression must already be  built on the same base!"	anExpression isNil ifTrue: [^self].		anExpression == true ifTrue: [^true].	anExpression == false ifTrue: [^self].	(anExpression isGlorpExpression and: [anExpression isEmptyExpression]) ifTrue: [^self].	^RelationExpression named: #OR basedOn: self withArguments: (Array with: anExpression).</body><body package="GlorpExpressions">parameter: aConstantExpression	"Create a parameter expression with the given name. But note that the name doesn't have to be a string. Database fields, symbols, and integers are all plausible"	| value |	value := aConstantExpression class == ParameterExpression ifTrue: [aConstantExpression field] ifFalse: [aConstantExpression value].	^ParameterExpression forField: value basedOn: self.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>converting</category><body package="GlorpExpressions">asDistinctFieldOn: anExpression	^(self asGlorpExpressionOn: anExpression) get: #distinct withArguments: #().</body><body package="GlorpExpressions">asExpressionGroup	^ExpressionGroup with: self</body><body package="GlorpExpressions">asField	"If we correspond to a single field, return it"	^self field.</body><body package="GlorpExpressions">asGeneralGlorpExpression	"Convert the result to a general (tree-format) expression, if it's the more limited join expression"	^self.</body><body package="GlorpExpressions">asGeneralGlorpExpressionWithFields	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	^self.</body><body package="GlorpExpressions">asGlorpExpressionForDescriptor: aDescriptor	self ultimateBaseExpression descriptor: aDescriptor.</body><body package="GlorpExpressions">asGlorpExpressionOn: aBaseExpression	aBaseExpression ultimateBaseExpression == self ultimateBaseExpression		ifTrue: [^self].	^self rebuildOn: aBaseExpression.</body><body package="GlorpExpressions">asGlorpExpressionOn: aBaseExpression basedOn: oldBaseExpression withUltimateBase: ultimateBaseExpression	^self		rebuildOn: aBaseExpression		startingFrom: oldBaseExpression		withOuterScopeBase: ultimateBaseExpression.</body><body package="GlorpExpressions">asGlorpExpressionOn: aBaseExpression in: aQuery	^self asGlorpExpressionOn: aBaseExpression.</body><body package="GlorpExpressions">asGlorpExpressionOn: anExpression withUltimateBase: aBaseExpression	"Build the expression, knowing that some parts of it may refer to an outer context based on aBaseExpression. This is primarily useful for subselect blocks"	^self rebuildOn: anExpression startingFrom: self queryLevelBaseExpression withOuterScopeBase: aBaseExpression.</body><body package="GlorpExpressions">asIndependentJoins	"If this is an ANDed clause, split it into independent joins"	^Array with: self.</body><body package="GlorpExpressions">asJoin	self subclassResponsibility.</body><body package="GlorpExpressions">asNonDistinctField	^self</body><body package="GlorpExpressions">generalExpressionPart	"If we have a mixture of joins and general expressions, return only the general part"	^self.</body><body package="GlorpExpressions">inverseJoin	"We assume that only the parts that are actually joins ought to invert"	| new |	new := self asGlorpExpressionOn: BaseExpression new.	new do: [:each |		each replaceJoinsWithInverse].	^new.</body><body package="GlorpExpressions">onlyJoinParts	"Strip out any generic parts, leaving only the things that are actually joins"	| new |	new := self asGlorpExpressionOn: BaseExpression new.	new do: [:each |		each removeNonJoinParts].	new := new condenseBooleanEquality.	new isJoin ifFalse: [new do: [:each | each condenseBooleanEqualityExpressions]].	^new.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression	^self rebuildOn: aBaseExpression startingFrom: nil.</body><body package="GlorpExpressions">sourceForTarget: aField ifNone: aBlock	^aBlock value</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>primary keys</category><body package="GlorpExpressions">primaryKeyFromDictionary: aDictionary	"Given a set of parameters, return a primary key suitable for retrieving our target. We can't do this for general expressions, so indicate failure by returning nil"	^nil.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>navigating</category><body package="GlorpExpressions">queryLevelBaseExpression	^self ultimateBaseExpression</body><body package="GlorpExpressions">ultimateBaseExpression	self subclassResponsibility.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>private/accessing</category><body package="GlorpExpressions">requiresDistinct	^false.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>debugging</category><body package="GlorpExpressions">sharedPiecesWith: anExpression	"Return a set of the pieces we share in common with anExpression. Mostly useful for debugging unwanted sharing, or the lack of wanted sharing. Note that this won't dive down into subselects."	| myPieces shared |	myPieces := IdentitySet new.	shared := IdentitySet new.	self do: [:each | myPieces add: each].	anExpression do: [:each | (myPieces includes: each) ifTrue: [shared add: each]].	^shared.</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>comparing</category><body package="GlorpExpressions">isSameAliasedFieldAs: aFieldOrFunction	^self == aFieldOrFunction</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>initialize-release</category><body package="GlorpExpressions">in: anExpression	^RelationExpression named: #IN basedOn: self withArguments: (Array with: anExpression).</body><body package="GlorpExpressions">initialize	"Not all dialects implement Object&gt;&gt;initialize so we reimplement here."</body></methods><methods><class-id>Glorp.GlorpExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">new	^super new initialize.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>accessing</category><body package="GlorpExpressions">alias	^alias</body><body package="GlorpExpressions">alias: aString	alias := aString</body><body package="GlorpExpressions">arguments	^#().</body><body package="GlorpExpressions">arguments: anArray	^self.</body><body package="GlorpExpressions">base	^base.</body><body package="GlorpExpressions">base: anExpression	base := anExpression.</body><body package="GlorpExpressions">canHaveBase	^true.</body><body package="GlorpExpressions">convertedDbValueOf: anObject	"Not clear what should happen here, but let's just pass it through for the moment"	^(self converterForStType: anObject class) convert: anObject toDatabaseRepresentationAs: self type.</body><body package="GlorpExpressions">converterForStType: aClass	^self type notNil 		ifTrue: [self type converterForStType: aClass]		ifFalse: [self field converterForStType: aClass].</body><body package="GlorpExpressions">defaultType	"We don't know our type. Return a basic numeric type as being as good a guess as any."	^base system platform numeric</body><body package="GlorpExpressions">field	^base field.</body><body package="GlorpExpressions">fieldExpression	^base fieldExpression.</body><body package="GlorpExpressions">function: aString	function := aString.</body><body package="GlorpExpressions">function: aString arguments: anArray	self function: aString.</body><body package="GlorpExpressions">impliedSmalltalkType	type isNil ifFalse: [^type impliedSmalltalkType].	^self field impliedSmalltalkType.</body><body package="GlorpExpressions">mappedFields	^Array with: self.</body><body package="GlorpExpressions">name	^function.</body><body package="GlorpExpressions">symbol	^symbol</body><body package="GlorpExpressions">symbol: aSymbol	symbol := aSymbol</body><body package="GlorpExpressions">table	(self hasField and: [self field notNil]) ifTrue: [^self field table].	"If we don't have a field, then maybe we have a relationship mapping or a base, so get the descriptor's primary table. Relevant if we have a function like EXISTS"	^self base table.</body><body package="GlorpExpressions">tablesToPrint	^#().</body><body package="GlorpExpressions">type	"Since &gt;&gt;field is recursively chased down to a real field, we could end up with the field's type.	However, if we chase &gt;&gt;base down to a type, and we reach a CAST function, we assume that the CAST's type wins over field's type."	| field |	type isNil ifFalse: [^type].	field := self field.	^field isNil		ifTrue: [self defaultType]		ifFalse: 			[base class = Cast			"We expect base to have a type if it's a CAST"				ifTrue: [base type]				ifFalse: [field type]]</body><body package="GlorpExpressions">type: aGlorpDatabaseType	type := aGlorpDatabaseType</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>navigating</category><body package="GlorpExpressions">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>printing</category><body package="GlorpExpressions">printOnlySelfOn: aStream	aStream nextPutAll: function.</body><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters: aDictionary.	alias notNil ifTrue: [aStream nextPutAll: ' AS '; nextPutAll: alias].</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary		self subclassResponsibility.</body><body package="GlorpExpressions">printTreeOn: aStream 	aStream 		nextPutAll: function</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>testing</category><body package="GlorpExpressions">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^true.</body><body package="GlorpExpressions">isDistinct	^function = 'DISTINCT'.</body><body package="GlorpExpressions">isGenerated	^false.</body><body package="GlorpExpressions">printsIntoJoins	"Certain functions should be printed into joins as well as into select lists (e.g. UPPER). However, there are others that don't (at least I don't think so) make any sense in joins, e.g. DISTINCT. Differentiate the two. Right now the only one I can think of that doesn't make sense is distinct. It's not clear to me that I'm not just hacking my way through this"	^self isDistinct not.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>iterating</category><body package="GlorpExpressions">convertValueOf: anObject in: aDictionary	| translated |	translated := anObject isGlorpExpression 		ifTrue: [anObject valueIn: aDictionary]		ifFalse: [anObject].	translated isGlorpExpression ifTrue: [^translated].	^self base convertedDbValueOf: translated.</body><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>api</category><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| newBase |	newBase := base asExpressionJoiningSource: source toTarget: target.	^self copy function: function; base: newBase.</body><body package="GlorpExpressions">get: aSymbol withArguments: anArray	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>converting</category><body package="GlorpExpressions">asDistinctFieldOn: anExpression	self isDistinct ifTrue: [^self asGlorpExpressionOn: anExpression].	^super asDistinctFieldOn: anExpression.</body><body package="GlorpExpressions">asNonDistinctField	^self isDistinct ifTrue: [base] ifFalse: [self].</body><body package="GlorpExpressions">hasField	"If we correspond to a single field, return it. This is a bit of a hack having this only here, because for some functions it doesn't work."	^base hasField.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>compatibility</category><body package="GlorpExpressions">translateField: aField	^base translateField: aField.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>mapping</category><body package="GlorpExpressions">valueInBuilder: anElementBuilder	^self base valueInBuilder: anElementBuilder as: self.</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder as: anExpression	^self base valueInBuilder: anElementBuilder as: anExpression.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>preparing</category><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	rebuilt := (base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression) getFunction: self symbol withArguments: (self arguments collect: [:each | each rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression]) in: aBaseExpression system.	rebuilt alias: self alias.	^rebuilt.</body><body package="GlorpExpressions">rewriteBooleanEquality: relation	base := base rewriteBooleanEquality: relation.</body></methods><methods><class-id>Glorp.FunctionExpression</class-id> <category>copying</category><body package="GlorpExpressions">createFor: arguments	| new |	new := self copy.	new arguments: arguments.	new type: type.	^new.</body><body package="GlorpExpressions">createFor: arguments withBase: anExpression symbol: aSymbol	| new |	new := self copy.	new base: anExpression.	new symbol: aSymbol.	new type: type.	new arguments: arguments.	^new.</body><body package="GlorpExpressions">withTable: aTable	"For a function expression, we shouldn't need to do anything here. It will have already been rebuilt on a base that has aliases"	^self."	| copy newBase |	newBase := BaseExpression new.	newBase descriptor: base descriptor.	copy := self rebuildOn: newBase.	copy fieldExpression setTable: aTable.	^copy."</body></methods><methods><class-id>Glorp.FunctionExpression class</class-id> <category>private</category><body package="GlorpExpressions">basicFunctions	functions isNil ifTrue: [functions := self createBasicFunctionsFor: DatabasePlatform new].	^functions</body><body package="GlorpExpressions">createBasicFunctionsFor: aDatabasePlatform	| defaultFunctions |	defaultFunctions := IdentityDictionary new.	defaultFunctions		at: #negated put: (PrefixFunction named: '-');		at: #descending put: (PostfixFunction named: 'DESC');		at: #distinct put: (PrefixFunction named: 'DISTINCT');		at: #max put: (PrefixFunction named: 'MAX');		at: #min put: (PrefixFunction named: 'MIN');		at: #sum put: (PrefixFunction named: 'SUM');		at: #avg put: (PrefixFunction named: 'AVG');		at: #average put: (PrefixFunction named: 'AVG');		at: #toChar: put: (PrefixFunction named: 'TO_CHAR');		at: #not put: (PrefixFunction named: 'NOT');		at: #, put: (InfixFunction named: '||');		at: #countStar put: (StandaloneFunction named: 'COUNT(*)');		at: #prepend: put: (ReversingFunction named: '||');		at: #count put: (PrefixFunction named: 'COUNT');		at: #between:and: put: (InfixFunction named: #('BETWEEN' 'AND'));		at: #alias: put: (PseudoColumnFunction named: '');		at: #isNil put: ((RelationExpression new)						relation: #=;						rightChild: nil asGlorpExpression);		at: #notNil put: ((RelationExpression new)						relation: #&lt;&gt;;						rightChild: nil asGlorpExpression);		at: #isNIL put: ((RelationExpression new)						relation: #=;						rightChild: nil asGlorpExpression);		at: #notNIL put: ((RelationExpression new)						relation: #&lt;&gt;;						rightChild: nil asGlorpExpression).						defaultFunctions at: #exists: put: ((InfixFunction named: 'EXISTS') type: aDatabasePlatform boolean).	defaultFunctions at: #notExists: put: ((InfixFunction named: 'NOT EXISTS') type: aDatabasePlatform boolean).	defaultFunctions		at: #asUppercase put: (PrefixFunction named: 'UPPER');		at: #asLowercase put: (PrefixFunction named: 'LOWER');		at: #replace:with: put: (PrefixFunction named: 'REPLACE');		at: #cast: put: ((Cast named: 'CAST') separator: ' AS ');		at: #copyFrom:to: put: (SubstringFunction named: 'SUBSTR')."		at: #+ put: (InfixFunction named: '+');		at: #- put: (InfixFunction named: '-');		at: #/ put: (InfixFunction named: '/');		at: #* put: (InfixFunction named: '*')."	defaultFunctions at: #length put: ((PrefixFunction named: 'LENGTH') type: aDatabasePlatform integer).	^defaultFunctions</body><body package="GlorpExpressions">initialize	self resetFunctions.</body><body package="GlorpExpressions">named: aString	"Used for creating template instances only"	^self new function: aString.</body><body package="GlorpExpressions">resetFunctions	"After adding a function, execute 'FunctionExpression resetFunctions' for it to be immediately visible to a currently-running Glorp."	functions := nil.</body></methods><methods><class-id>Glorp.FunctionExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">for: aSymbol withArguments: anArray basedOn: anExpression	| base system |	base := anExpression ultimateBaseExpression.	system := base isNil ifTrue: [nil] ifFalse: [base system].		^self for: aSymbol withArguments: anArray basedOn: anExpression system: system.</body><body package="GlorpExpressions">for: aSymbol withArguments: anArray basedOn: anExpression system: system	| functionTemplate newFunction |	functionTemplate := (system isNil		ifTrue: [self basicFunctions]		ifFalse: [system platform functions]) at: aSymbol ifAbsent: [^nil].	newFunction := functionTemplate		createFor: anArray		withBase: anExpression		symbol: aSymbol.	^newFunction.</body></methods><methods><class-id>Glorp.StandaloneFunction</class-id> <category>mapping</category><body package="GlorpExpressions">valueInBuilder: anElementBuilder	^anElementBuilder valueOfField: self</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder as: anExpression	^anElementBuilder valueOfField: anExpression.</body></methods><methods><class-id>Glorp.StandaloneFunction</class-id> <category>printing</category><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	aStream nextPutAll: ' '; nextPutAll: function.</body></methods><methods><class-id>Glorp.StandaloneFunction</class-id> <category>accessing</category><body package="GlorpExpressions">field	^nil.</body><body package="GlorpExpressions">type	type isNil ifFalse: [^type].	^self defaultType.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>registering</category><body package="GlorpMappings">register: aDescriptor	^self register: aDescriptor abstract: false</body><body package="GlorpMappings">register: aDescriptor abstract: abstract	self system: aDescriptor system.	self addMember: aDescriptor.	aDescriptor typeResolver: self</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>accessing</category><body package="GlorpMappings">addMember: aDescriptor	members isNil ifTrue: [members := OrderedCollection new].	(members includes: aDescriptor)		ifFalse: [members add: aDescriptor]		ifTrue: [Transcript cr; show: ('Your system does a duplicate registration of ', aDescriptor printString, ' in ', self printString)]</body><body package="GlorpMappings">allTablesFor: aDescriptor	"Return all tables used by this descriptor or its subclasses. For a non-inheritance descriptor, this is the same as tables."	self subclassResponsibility.</body><body package="GlorpMappings">classesRequiringIndependentQueriesFor: aClass	self subclassResponsibility</body><body package="GlorpMappings">describedConcreteClassFor: row withBuilder: builder descriptor: aDescriptor	self subclassResponsibility</body><body package="GlorpMappings">shouldUseSingleQuery	"Return true if we should attempt to combine queries for multiple subclasses in disjoint tables into one."	^false.</body><body package="GlorpMappings">system	^system</body><body package="GlorpMappings">system: aDescriptorSystem	system := aDescriptorSystem.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>type resolution</category><body package="GlorpMappings">fieldsForSelectStatement	"Return fields that are needed in a select statement - i.e. return all inherited fields that are part of the tables we are already selecting for this object"	^#().</body><body package="GlorpMappings">typeMappingRootDescriptor	self subclassResponsibility</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>other</category><body package="GlorpMappings">describedClasses	^members collect: [:each | each describedClass ].</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>query setup</category><body package="GlorpMappings">setUpExpressionsForQuery: aQuery	"A hook to let us do any modifications to the query that we need."	^self.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>testing</category><body package="GlorpMappings">supportsOrderingFor: aDescriptor	^true.</body><body package="GlorpMappings">usesInheritance	^false.</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>validation</category><body package="GlorpMappings">validate	^self.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">generatesOverExistingValues	"Do we generate our value even if there's alread one present in the field"	^false.</body><body package="GlorpDatabaseTypes">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^false.</body><body package="GlorpDatabaseTypes">hasSequence	^false.</body><body package="GlorpDatabaseTypes">hasWidth	"Return true if this type has a width attribute - basically meaning it's a string or LOB type. Note that this is different from the isVariableWidth test, which tells us if a field has fixed vs. varying width. So a CHAR field hasWidth=&gt;true, but isVariableWidth=&gt;false, while a VARCHAR field hasWidth=&gt;true isVariableWidth=&gt;false, and a NUMBER has both false."	^false.</body><body package="GlorpDatabaseTypes">isGenerated	^false</body><body package="GlorpDatabaseTypes">isIdentityColumn	^false.</body><body package="GlorpDatabaseTypes">isSerial	"answer if this is a database-generated primary key column"	^false</body><body package="GlorpDatabaseTypes">isStringType	"Return true if the type of values this stores are strings"	^false.</body><body package="GlorpDatabaseTypes">isVariable	^false.</body><body package="GlorpDatabaseTypes">isVariableWidth	"Return true if this type allows varying length data within a particular instance. e.g., this is true for a varchar, but false for a fixed size character field"	^false.</body><body package="GlorpDatabaseTypes">requiresCast	^false.</body><body package="GlorpDatabaseTypes">requiresConvertToVarbinary	"This is a hack for testing against SQL Server"	^false.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">glorpPrintSelectSQLOn: aCommand	self printSelectSQLOn: aCommand withParameters: #().</body><body package="GlorpDatabaseTypes">glorpPrintSQLOn: aCommand	aCommand nextPutAll: self typeString.</body><body package="GlorpDatabaseTypes">platform	^platform</body><body package="GlorpDatabaseTypes">platform: aDatabasePlatform	platform := aDatabasePlatform.</body><body package="GlorpDatabaseTypes">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow</body><body package="GlorpDatabaseTypes">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: aSession</body><body package="GlorpDatabaseTypes">preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	aDatabaseField imDefaultValue isNil ifTrue: [^self].	(aDatabaseRow hasValueFor: aDatabaseField) ifTrue: [^self].	"Default values will not write if this field is constrained to a primary key generator"	(aDatabaseRow expectsToGetValueFor: aDatabaseField) ifTrue: [^self].	aDatabaseRow at: aDatabaseField put: (aDatabaseField imDefaultValue).</body><body package="GlorpDatabaseTypes">print: aValue on: aStream	aValue glorpPrintSQLOn: aStream.</body><body package="GlorpDatabaseTypes">printCollection: aCollection on: aStream	aCollection glorpPrintSQLOn: aStream for: self.</body><body package="GlorpDatabaseTypes">printNullCastOn: aStream	"Some platforms, eg., DB2, need to cast NULL for collections, as in	SELECT ... WHERE ... IN (CAST(NULL AS type))."		| expr |	expr := FunctionExpression		for: #cast:		withArguments: (Array with: (ConstantExpression for: self))		basedOn: (ConstantExpression for: nil).	expr printSelectSQLOn: aStream withParameters: #()</body><body package="GlorpDatabaseTypes">printSelectSQLOn: aCommand withParameters: aDictionary	aCommand nextPutAll: self typeString.</body><body package="GlorpDatabaseTypes">printValueForField: aField inRow: aRow on: aCommand	"I am the type of aField."	| fieldValue |	fieldValue := aRow at: aField ifAbsent: [nil].	(aCommand canBind: fieldValue to: self)		ifTrue: [aCommand nextPutBindMarkerIn: nil]		ifFalse: [self print: fieldValue on: aCommand].</body><body package="GlorpDatabaseTypes">typeName	"An alias that can be used to print the non-parameterized name"	^typeString.</body><body package="GlorpDatabaseTypes">typeString	^typeString.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	self subclassResponsibility.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">isRelativeType	^false</body><body package="GlorpDatabaseTypes">precision: anInteger	^self error: ((self class name asString), ' is not a variable precision type.')</body><body package="GlorpDatabaseTypes">queryType	"If we can't pass this type in as an argument to a query (e.g. a blob) then return a type we can use instead"	^self.</body><body package="GlorpDatabaseTypes">scale: anInteger	^self error: ((self class name asString), ' is not a variable scale type.')</body><body package="GlorpDatabaseTypes">selector	^selector</body><body package="GlorpDatabaseTypes">selector: aSymbol	selector := aSymbol</body><body package="GlorpDatabaseTypes">sequence	^nil</body><body package="GlorpDatabaseTypes">size: anInteger	^self error: ((self class name asString), ' is not a variable sized type.')</body><body package="GlorpDatabaseTypes">typeString: aString	typeString := aString</body><body package="GlorpDatabaseTypes">underlyingType	^self.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize</body><body package="GlorpDatabaseTypes">initializeForField: aDatabaseField in: aDescriptorSystem</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	^self platform nullConverter.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	"Return the Smalltalk type which most commonly corresponds to our database type. By default, Object if we don't have any more specific information."	^Object.</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes">= aType	^self basicEquals: aType.</body><body package="GlorpDatabaseTypes">basicEquals: aType	self class == aType class ifFalse: [^false].	self platform == aType platform ifFalse: [^false].	self typeString = aType typeString ifFalse: [^false].	^true.</body><body package="GlorpDatabaseTypes">hash	^self platform hash bitXor: self typeString hash</body></methods><methods><class-id>Glorp.GlorpDatabaseType class</class-id> <category>instance creation</category><body package="GlorpDatabaseTypes">instance	^super new</body><body package="GlorpDatabaseTypes">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDatabaseType class</class-id> <category>printing</category><body package="GlorpDatabaseTypes">padToThreeDigits: anInteger	| string |	string := anInteger truncated printString.	string size = 3 ifTrue: [^string].	string size = 2 ifTrue: [^'0', string].	string size = 1 ifTrue: [^'00', string].</body><body package="GlorpDatabaseTypes">padToTwoDigits: anInteger	| string |	string := anInteger truncated printString.	^string size = 1 ifTrue: ['0', string] ifFalse: [string].</body></methods><methods><class-id>Glorp.GlorpAbstractNumericType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Number.</body></methods><methods><class-id>Glorp.GlorpAbstractNumericType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">beRelative	"When a mapping to a field with this type updates the database, the difference between the original and changed values is added to the value in the database, and (if #supportsReturningUpdatedValues is true) the resulting value in the database is returned, to be set on the object."	^(GlorpRelativeValueType new underlyingType: self)		platform: self platform;		selector: self selector;		typeString: self typeString;		yourself</body></methods><methods><class-id>Glorp.GlorpDoubleType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	^self platform converterNamed: #numberToDouble.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Dialect doublePrecisionFloatClass.</body></methods><methods><class-id>Glorp.GlorpDoubleType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Double.</body></methods><methods><class-id>Glorp.GlorpDoubleType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'double precision'.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>preparing</category><body package="GlorpMappings">joinExpressionFor: anExpression	^nil.</body><body package="GlorpMappings">multipleTableExpressionsFor: anExpression	^#().</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>mapping</category><body package="GlorpMappings">applicableMappingForObject: anObject 	"For polymorphism with conditional mappings"	^self</body><body package="GlorpMappings">createDeleteRowFor: anObject in: aRowMap	"Only applies to mappings that write into link tables"</body><body package="GlorpMappings">expressionFor: anObject	"Return an expression representing the value of the object. This can be nil, an object value or values, an expression, or a collection of expressions (for a composite key, if we're passed an expression)"	anObject isNil ifTrue: [^#(nil)].	anObject isGlorpExpression ifFalse: [		^self mappedFields collect: [:each | 				self valueOfField: each fromObject: anObject]].	^self mappedFields		collect: [:each | (anObject getField: each)].</body><body package="GlorpMappings">expressionFor: anObject basedOn: anExpression relation: aSymbol	"Return our expression using the object's values. e.g. if this was a direct mapping from id-&gt;ID and the object had id: 3, then return TABLE.ID=3. Used when rewriting object=object into field=field"	| myValue result |	"result's initial value is nil, used in first iteration below"	myValue := self expressionFor: anObject.	myValue with: self join allTargetFields do:		[:eachValue :eachField || source |		source := anExpression get: self attribute name.		source hasDescriptor ifTrue: [source := source getField: eachField].		result := (source get: aSymbol withArguments: (Array with: eachValue)) AND: result].	^result.</body><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap	self subclassResponsibility.</body><body package="GlorpMappings">mapObject: anObject inElementBuilder: anObject1	self subclassResponsibility.</body><body package="GlorpMappings">mappedTables	^(self mappedFields collect: [:each | each table]) asSet.</body><body package="GlorpMappings">readBackNewRowInformationFor: anObject fromRowsIn: aRowMap 	"	self subclassResponsibility. ?"</body><body package="GlorpMappings">referencedIndependentObjectsFrom: anObject	self subclassResponsibility.</body><body package="GlorpMappings">trace: aTracing context: anExpression	self subclassResponsibility.</body><body package="GlorpMappings">translateField: aDatabaseField 	"Most mappings don't translate."	^aDatabaseField</body><body package="GlorpMappings">translateTable: aTable	"If we have a field translation, return the translated (i.e. real) table to use. This ideally allows us to use either the real table in which something is embedded, or the imaginary table"	^aTable.</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject	self error: 'Can''t get value of field'.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>testing</category><body package="GlorpMappings">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	self isRelationship ifFalse: [^true].	^self isToManyRelationship not.</body><body package="GlorpMappings">controlsTables	"Return true if this type of mapping 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	self subclassResponsibility</body><body package="GlorpMappings">hasAttribute	"Return true if this maps an attribute, which is normally true"	^true</body><body package="GlorpMappings">hasImpliedClauses	"Return true if this implies multiple sql clauses"	^false.</body><body package="GlorpMappings">hasValueThatCanProvideField: aField from: anObject	"Return true if we have enough information in ourselves to populate our fields. The only time this won't be true is if we're either holding an uninstantiated proxy or have a to-many relationship mapping with an empty collection."	^true.</body><body package="GlorpMappings">includesSubFieldsInSelectStatement	^false</body><body package="GlorpMappings">isRelationship	"True when the mapping associates different persistent classes."	^self subclassResponsibility</body><body package="GlorpMappings">isStoredInSameTable	"True when the mapping is between two objects that occupy the same table, e.g. an embedded mapping."	^self subclassResponsibility</body><body package="GlorpMappings">isToManyRelationship	^false.</body><body package="GlorpMappings">isTypeMapping	^false</body><body package="GlorpMappings">mappedFields	self subclassResponsibility</body><body package="GlorpMappings">mapsPrimaryKeys	^(self mappedFields detect: [:each | each isPrimaryKey] ifNone: [nil]) notNil.</body><body package="GlorpMappings">mapsSimpleObject	"Return true if we know that we map something without a descriptor. For some mappings, like ad hoc or conditional, we don't really know, so we default to false"	^false.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>accessing</category><body package="GlorpMappings">allTables	self subclassResponsibility.</body><body package="GlorpMappings">attribute	attribute isNil ifTrue: [attribute := GlorpAttributeModel new].	^attribute.</body><body package="GlorpMappings">attributeName	^self attribute name.</body><body package="GlorpMappings">attributeName: aSymbol	| oldAttribute symbolName |	symbolName := aSymbol asSymbol.	oldAttribute := attribute.	attribute := self classModel attributeNamed: symbolName.	oldAttribute isNil		ifTrue: [self initializeAttribute]		ifFalse: [attribute copyFrom: oldAttribute].</body><body package="GlorpMappings">beForPseudoVariable	self attribute beForPseudoVariable.</body><body package="GlorpMappings">beReadOnly	self canWrite: false.</body><body package="GlorpMappings">canRead	^self attribute canRead.</body><body package="GlorpMappings">canRead: aBoolean	self attribute canRead: aBoolean.</body><body package="GlorpMappings">canWrite	^self attribute canWrite.</body><body package="GlorpMappings">canWrite: aBoolean	self attribute canWrite: aBoolean.</body><body package="GlorpMappings">classModel	"If we don't have one, just make a temporary one. We'll fix it later"	descriptor isNil ifTrue: [^GlorpClassModel new].	^self descriptor classModel.</body><body package="GlorpMappings">descriptor	^descriptor</body><body package="GlorpMappings">descriptor: aDescriptor	descriptor := aDescriptor.	attribute isNil ifFalse: [self copyAttributeAttributes].</body><body package="GlorpMappings">fieldsForDescriptorSelectStatement	"Return a collection of fields that this mapping will read from a row when the containing object is read, as opposed to when we're specifically told to use this field. Normally it amounts to the same thing."	^self mappedFields.</body><body package="GlorpMappings">fieldsForSelectStatement	"Return a collection of fields that this mapping will read from a row"	self canRead ifFalse: [^#()].	^self mappedFields</body><body package="GlorpMappings">isForPseudoVariable	^self attribute isForPseudoVariable or: [self attribute isValid not].</body><body package="GlorpMappings">readOnly	^self canWrite not.</body><body package="GlorpMappings">readOnly: aBoolean	self canWrite: aBoolean not.</body><body package="GlorpMappings">referenceClass	^self attribute type.</body><body package="GlorpMappings">session		^self descriptor session.</body><body package="GlorpMappings">system		^self descriptor system.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>printing SQL</category><body package="GlorpMappings">allRelationsFor: rootExpression do: aBlock andBetweenDo: anotherBlock	"Normal mappings just operate on a single expression"	aBlock value: rootExpression leftChild value: rootExpression rightChild.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>public</category><body package="GlorpMappings">getValueFrom: anObject	"Glorp leaves it to callers check (as far up the stack as is sensible) whether this attribute canWrite, bypassing if not (except in cases where the context makes it clear the attribute must be writable)."	^self attribute getValueFrom: anObject.</body><body package="GlorpMappings">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: '(';		nextPutAll: (attribute isNil ifTrue: [''] ifFalse: [self attributeName]) ;		nextPutAll: ')'.</body><body package="GlorpMappings">setValueIn: anObject to: aValue	self canRead ifFalse: [^aValue].	^self attribute setValueIn: anObject to: aValue</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>debugging</category><body package="GlorpMappings">debugRead	^debugRead</body><body package="GlorpMappings">debugRead: aBoolean	debugRead := aBoolean</body><body package="GlorpMappings">debugWrite	^debugWrite</body><body package="GlorpMappings">debugWrite: aBoolean	debugWrite := aBoolean</body><body package="GlorpMappings">stopIfDebuggingRead	debugRead ifTrue: [self halt].</body><body package="GlorpMappings">stopIfDebuggingWrite	debugWrite ifTrue: [self halt].</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>api</category><body package="GlorpMappings">beExclusive	self error: 'Only relationship mappings can be exclusive'.</body><body package="GlorpMappings">isExclusive	^false.</body><body package="GlorpMappings">isExclusive: aBoolean	aBoolean ifTrue: [self error: 'Only relationship mappings can be exclusive'].</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>iterating</category><body package="GlorpMappings">loopOverAttributeOf: anObject doing: aTwoArgumentBlock	"Loop over the target, which we extract from anObject, and iterate over it evaluating the block. For things that aren't collections, iterating means just run once. Note that the argument is expected to be an instance of our descriptor, as opposed to the attribute method, which expects the target object"	| target |	target := self getValueFrom: anObject.	self attribute loopOver: target doing: aTwoArgumentBlock.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>initialize/release</category><body package="GlorpMappings">copyAttributeAttributes	"We have an attributemodel that was created before we actually had a descriptor. It's possible that it had properties set. Make sure we copy them. If necessary, initialize things that require it."	| oldAttribute |	oldAttribute := attribute.	attribute := self classModel attributeNamed: oldAttribute name type: oldAttribute type collectionType: oldAttribute collectionType.	attribute copyFrom: oldAttribute.	self initializeAttribute.</body><body package="GlorpMappings">initialize	debugRead := false.	debugWrite := false.</body><body package="GlorpMappings">initializeAttribute	"This is where we can initialize aspects of the attribute, if required. The motivating example is initializing the collection type of the attribute if it wasn't set. We need it to have some type, but we don't want to initialize it while we're doing basic initialization and aren't yet properly attached to a descriptor or class model"</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>validation</category><body package="GlorpMappings">initializeRuntimeMappings	"I do nothing but my subclasses might"	^self</body><body package="GlorpMappings">validate	self validateAttribute</body><body package="GlorpMappings">validateAttribute	self canWrite ifTrue: [self attribute validateCanWrite].	self canRead ifTrue: [self attribute validateCanRead]</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>proxies</category><body package="GlorpMappings">newProxyIn: anObjectBuilder 	| proxy |	proxy := Proxy new.	proxy query: (self queryFor: anObjectBuilder).	proxy glorpProxyAction: self proxyAction.	^proxy</body><body package="GlorpMappings">proxyAction	^nil.</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>private</category><body package="GlorpMappings">convertedDbValueOf: stValue 	"Mappings in general don't know how to do type conversion. Subclasses that deal with database primitive types should override."	^stValue</body></methods><methods><class-id>Glorp.Mapping class</class-id> <category>instance creation</category><body package="GlorpMappings">new	^super new initialize.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>mapping</category><body package="GlorpMappings">addPhantomMappingExpressionOn: base 	| phantomMapping phantomMappingName phantomExpression |	phantomMapping := self reverseMapping.	phantomMappingName := 'glorp_internal_' , self attributeName , '_to_' 				, self descriptor describedClass name.	phantomExpression := base getMapping: phantomMapping				named: phantomMappingName.	phantomExpression bePhantom.	^phantomExpression</body><body package="GlorpMappings">buildGeneralQueryIn: anObjectBuilder	"For filtered queries. We need to build this in terms of the parent query"	| base parentCriteria fullCriteria phantomExpression newQuery |	base := BaseExpression new.	base descriptor: self referenceDescriptor.	phantomExpression := self addPhantomMappingExpressionOn: base.	parentCriteria := anObjectBuilder query whereClause.	fullCriteria := parentCriteria		rebuildOn: phantomExpression.	newQuery := Query read: self referenceClass.	"newQuery collectionType: self collectionType."	fullCriteria isEmptyExpression ifFalse: [newQuery whereClause: fullCriteria].	self		setGeneralQueryRetrievalIn: newQuery		basedOn: base		phantom: phantomExpression.	^newQuery.</body><body package="GlorpMappings">buildQuery	| toMany builtQuery |	toMany := self attribute isCollectionAttribute.	builtQuery := toMany		ifTrue: [Query read: self referenceClass where: self join]		ifFalse: [Query readOneOf: self referenceClass where: self join].	builtQuery session: self session.	builtQuery baseExpression descriptor: (self session descriptorFor: self referenceClass).	builtQuery collectionType: self collectionType.	self usesLinkTable ifTrue:		[builtQuery AND: (self expressionFromLinkToReferenceTableWithBase: builtQuery baseExpression)].	^builtQuery</body><body package="GlorpMappings">buildRowMapKeyForSource: source target: target index: index	^(RowMapKey new)		key1: target yourSelf;		key2: source yourSelf.</body><body package="GlorpMappings">createDeleteRowFor: anObject in: aRowMap	"This is like firing the mapping, but instead of creating the data, we just need to check if there are link table entries, and if so, make sure they are deleted"	| target mementoizedTarget|	self canWrite ifFalse: [^self].	self usesLinkTable ifFalse: [^self].	target := self getValueFrom: anObject.	target := self session realObjectFor: target ifNone: [^self].	(self isValidTarget: target) ifTrue: [		mementoizedTarget := aRowMap collectionMementoFor: target.		self createDeleteRowForLinkFrom: anObject toTarget: mementoizedTarget in: aRowMap].</body><body package="GlorpMappings">createDeleteRowForLinkFrom: anObject toTarget: target in: aRowMap	| linkTable |	self usesLinkTable ifFalse: [^false].	linkTable := self linkTableJoin allTables asArray first.	self attribute		loopOver: target		doing:			[:index :eachTarget | 			| intermediate |			intermediate := self				rowMapKeyForSource: anObject				target: eachTarget				index: index.			aRowMap				rowForTable: linkTable				withKey: intermediate				ifPresent:					[:linkRow | linkRow isEmpty ifFalse: [linkRow forDeletion: true]]].</body><body package="GlorpMappings">extendedJoin	"In order to do a many-to-many read we need more information than just the write, we need to know 	the relationship to the other table. Construct that based on the table information"	| generalMappingCriteria base |	self usesLinkTable ifFalse: [^self join].	generalMappingCriteria := self join asGeneralGlorpExpressionWithFields.	base := generalMappingCriteria ultimateBaseExpression.	^(self expressionFromLinkToReferenceTableWithBase: base) AND: generalMappingCriteria.</body><body package="GlorpMappings">extendedJoinFromSource: sourceExpression toTarget: targetExpression	"In order to do a many-to-many read we need more information than just the write, we need to know 	the relationship to the other table. Construct that based on the table information"	| generalMappingCriteria |	self usesLinkTable 		ifFalse: [^self join asExpressionJoiningSource: sourceExpression toTarget: targetExpression].	generalMappingCriteria := self join asExpressionJoiningSource: sourceExpression toTarget: targetExpression.	^(self expressionFromLinkToReferenceTableWithBase: targetExpression) AND: generalMappingCriteria.</body><body package="GlorpMappings">isValidTarget: anObject	^anObject isGlorpProxy		ifTrue: [anObject isInstantiated]		ifFalse: [true].</body><body package="GlorpMappings">knitFromBuilder: sourceBuilder toBuilder: targetBuilder 	self canRead ifFalse: [^self].	self attribute knit: sourceBuilder instance to: targetBuilder instance</body><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap 	"Our target is a collection. The tricky bit is that if we're building rows into a RowMapForMementos, then the collection we contain isn't the one we want to use. We want the old version. Ask the row map to give it to us. If it's a normal row map, we'll just get the same thing back" 	| target mementoizedTarget|	self canWrite ifFalse: [^self].	target := self getValueFrom: anObject.	target := self session realObjectFor: target ifNone: [^self].	(self isValidTarget: target) ifTrue: [		mementoizedTarget := aRowMap collectionMementoFor: target.		self mapFromObject: anObject toTarget: mementoizedTarget puttingRowsIn: aRowMap].</body><body package="GlorpMappings">mapFromObject: anObject toTarget: target puttingRowsIn: aRowMap	self attribute		loopOver: target		doing:			[:index :eachTarget | 			| intermediate |			intermediate := self				rowMapKeyForSource: anObject				target: eachTarget				index: index.			self				mapOneFromObject: anObject				toTarget: eachTarget				intermediate: intermediate				atPosition: index				puttingRowsIn: aRowMap].</body><body package="GlorpMappings">mapObject: anObject inElementBuilder: anElementBuilder	| value session parameters |	session := descriptor session.	parameters := self parametersIn: anElementBuilder.	value := self shouldProxy		ifTrue:			[| proxy |			proxy := (self newProxyIn: anElementBuilder)				session: session;				parameters: parameters;				glorpOwner: anObject.			"If we know in advance the proxy would return nil, or an empty collection, just put that in rather than the proxy"			(proxy query shortCircuitEmptyReturn: parameters)				ifTrue: [proxy getValue]				ifFalse: [proxy]]		ifFalse:			[(self queryFor: anElementBuilder)				executeWithParameters: parameters				in: session].	^self setValueIn: anObject to: value.</body><body package="GlorpMappings">mapOneFromObject: sourceObject toTarget: targetObject intermediate: aRowMapKey atPosition: index puttingRowsIn: aRowMap	self linkTableJoin		mapFromSource: sourceObject		andTarget: aRowMapKey		intoRowsIn: aRowMap.	self targetTableJoin isNil		ifFalse:			[self targetTableJoin				mapFromSource: sourceObject				andTarget: (self mapsSimpleObject ifTrue: [aRowMapKey] ifFalse: [targetObject])				intoRowsIn: aRowMap].	self usesLinkTable		ifTrue:			[self reverseJoin				mapFromSource: aRowMapKey				andTarget: (self mapsSimpleObject ifTrue: [aRowMapKey] ifFalse: [targetObject])				intoRowsIn: aRowMap].	self		writeExtraInformationInto: aRowMap		atKey: aRowMapKey		forSourceObject: sourceObject		targetObject: targetObject		atIndex: index.</body><body package="GlorpMappings">parametersIn: anElementBuilder	| parameters |	self shouldUseFilteredRead ifTrue: [^anElementBuilder command parameters].	parameters := IdentityDictionary new.	self join		mappableSourceFieldsDo:			[:eachSource | parameters at: eachSource put: (anElementBuilder valueOfField: eachSource)].	^parameters.</body><body package="GlorpMappings">privateAndBasicSetQuery: aQuery	"To be used with caution, or in the development of a new mapping type."	query := aQuery.</body><body package="GlorpMappings">query	query isNil ifTrue: [query := self buildQuery].	^query</body><body package="GlorpMappings">reverseJoin	reverseJoin isNil ifTrue: [reverseJoin := self joinFromLinkToReferenceTable].	^reverseJoin.</body><body package="GlorpMappings">reverseMapping	"Construct the backwards mapping that corresponds to us. If it's using a link table, then we are at least potentially a toMany mapping. Otherwise, we can point backwards only to a single object."	| mapping |	^self usesLinkTable		ifTrue: 			[mapping := (ManyToManyMapping new)				attributeName: #temporaryAttributeFromSubselect;				referenceClass: self descriptor describedClass;				join: self reverseJoin inverseJoin;				descriptor: self descriptor.			mapping reverseJoin: self join inverseJoin onlyJoinParts]		ifFalse: 			[(OneToOneMapping new)				attributeName: #temporaryAttributeFromSubselect;				referenceClass: self descriptor describedClass;				join: self join inverseJoin;				descriptor: self descriptor]</body><body package="GlorpMappings">rowMapKeyForSource: source target: target index: index	"Create the row map key. Make sure we're holding onto the real objects, so proxies don't time out on us"	self needsSpecialRowMapKey ifFalse: [^target].	(target yourSelf isNil or: [source yourSelf isNil]) ifTrue: [^nil].	^rowMapKeyConstructorBlock isNil		ifTrue:			[self				buildRowMapKeyForSource: source				target: target				index: index]		ifFalse:			[rowMapKeyConstructorBlock value: source yourSelf value: target yourSelf].</body><body package="GlorpMappings">setGeneralQueryRetrievalIn: newQuery basedOn: base phantom: phantomExpression	self descriptor keyFields		do: [:eachField | newQuery retrieve: (phantomExpression getField: eachField)].	newQuery retrieve: base.</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject	^self valueOfField: aField fromObject: anObject ifNone: [self error: 'Cannot find value'].</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject ifNone: aBlock	"Return the value of a given field in our target object. Used in extracting primary keys when they are mapped via relationships."	| targetField target |	self usesLinkTable ifTrue: [^aBlock value].	targetField := self join		targetForSource: aField		value: [target := self getValueFrom: anObject].	targetField isNil ifTrue: [^aBlock value].	"If it's a proxy and uninstantiated, we have to get the value from the proxy"	(target isGlorpProxy and: [target isInstantiated not])		ifTrue: [^target parameters at: aField].	"If the object is instantiated, then we prefer to get the value from the object, because if it's non-primary key then the proxy may not know it, or it may vary from what the proxy has. Well, that seems unlikely, but try this anyway"	self attribute		loopOver: target		doing:			[:index :eachTarget || value |			value := self referenceDescriptor						valueOfField: targetField						fromObject: eachTarget						ifNone: [self].			value == self ifFalse: [^value]].	"We couldn't get it from the object, probably because it's unmapped. See if the proxy has it after all"	target isGlorpProxy ifTrue: [^target parameters at: aField].	"We couldn't get the value at all. This may mean that the object is new, so it has no proxies holding the value. Return nil and hope it's new and that it will all get figured out"	^aBlock value</body><body package="GlorpMappings">writeExtraInformationInto: aRowMap atKey: rowMapKey forSourceObject: sourceObject targetObject: targetObject  atIndex: index</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>testing</category><body package="GlorpMappings">controlsTables	"Return true if this type of method 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	^controlsTables</body><body package="GlorpMappings">hasValueThatCanProvideField: aField from: anObject	"Return true if we have enough information in ourselves to populate our fields. The only time this won't be true is if we're either holding an uninstantiated proxy or have a to-many relationship mapping with an empty collection. Assumes that aField is one that we map."	| value |	value := self getValueFrom: anObject.	value isGlorpProxy ifFalse: [^value notNil].	value isInstantiated ifTrue: [^true].	^value parameters includesKey: aField.</body><body package="GlorpMappings">isRelationship	"True when the mapping associates different persistent classes."	^true</body><body package="GlorpMappings">isStoredInSameTable	"Normally, a relationship mapping isn't stored in the same table, but if we're part of a dictionary mapping and the table is mapped to an association, then we want to be treated that way. The test is a horrible hack"	^self classModel describedClass == Association.</body><body package="GlorpMappings">isToManyRelationship	^self attribute isCollectionAttribute.</body><body package="GlorpMappings">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	^self join allSourceFields select: [:each | each isMappable and: [(each isGlorpExpression not or: [each isConstantExpression not])]].</body><body package="GlorpMappings">needsSpecialRowMapKey	"Return true if we have to use a special key object for the row map, rather than just our target"	^self usesLinkTable.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>accessing</category><body package="GlorpMappings">allTables	(self join) isNil ifTrue: [^#()].	^(self join) allTables.</body><body package="GlorpMappings">basicReferenceClass	^self attribute type.</body><body package="GlorpMappings">basicReferenceDescriptor	^self system descriptorFor: self basicReferenceClass.</body><body package="GlorpMappings">collectionType	^nil.</body><body package="GlorpMappings">controlsTables: aBoolean	"We can indicate that this relationship does not actually control its tables. This is going to be true if the parent controls the same tables and coexists with us. Think StoreVersionlessPundle and Pundle"	controlsTables := aBoolean.</body><body package="GlorpMappings">join	join isNil ifTrue: [self initializeJoin].	^join.</body><body package="GlorpMappings">join: aJoin	"We allow the join to be specified either as a Join (the normal case) or as an expression. We expect an expression specifying the relationship in terms of other relationships. So, e.g. to specify the join from InsurancePlan to PolicyHolder we might specify[:eachPolicyHolder | eachPolicyHolder employer availablePlans].  Note that the relationship is described from the point of view of the target, and is just a list of mappings. Then we take this internally and transform it into an equality expression we can use to define the relationship."	| base basicExpression |	(Dialect isBlock: aJoin) 		ifTrue: [			self beReadOnly.			base := JoinBaseExpression new.			base descriptor: (self system descriptorFor: self referenceClass).			basicExpression := aJoin asGlorpExpressionOn: base.			"It doesn't matter what name we give the parameter, because it will be rewritten into a primary key comparison anyway, that will use the fields as 'names'. Also, it's important that we assign into join here, because otherwise the rewriteEquality operation will try and figure out a join for us, since it's still nil."			join := basicExpression get: #= withArguments: (				Array with: (ParameterExpression forField: 'sourceObject' basedOn: basicExpression join)).			join := join rewriteEquality]		ifFalse: [join := aJoin].	[join owningMapping: self] on: MessageNotUnderstood do: [:ex | ex | ex return].</body><body package="GlorpMappings">linkTableJoin	linkTableJoin isNil ifTrue: [^self join].	^linkTableJoin</body><body package="GlorpMappings">linkTableJoin: aJoin	"Set the join from the link table to the target table. Normally this is calculated automatically (see reverseJoin), but it can be set manually if that's not possible (for example, because you want to include a constant value in the join, that won't be included in the foreign key constraints). See also relevantLinkTableFields if you need to give a hint."	linkTableJoin := aJoin.	[aJoin owningMapping: self] on: MessageNotUnderstood do: [:ex | ex | ex return].</body><body package="GlorpMappings">mappingCriteria	^self join.</body><body package="GlorpMappings">mappingCriteria: aJoin	self join: aJoin.</body><body package="GlorpMappings">proxyAction	"Return an action each proxy should take when it's instantiated. This is a two-argument block		[:owner :target | "	^proxyAction.</body><body package="GlorpMappings">proxyAction: aBlock	"Set an action each proxy should take when it's instantiated. This is a two-argument block		[:owner :target | "	proxyAction := aBlock.</body><body package="GlorpMappings">referenceClass: aClass	self attribute type: aClass.</body><body package="GlorpMappings">referenceDescriptor	^self system descriptorFor: self referenceClass.</body><body package="GlorpMappings">reverseJoin: aJoin	"Set the reverse join - the join from the link table to the target table. Normally this will be calculated based on the foreign key constraints, but in rare cases (e.g. a foreign key that may be to more than one table) you may want to set it explicitly"	reverseJoin := aJoin.</body><body package="GlorpMappings">shouldProxy	^shouldProxy.</body><body package="GlorpMappings">shouldProxy: aBoolean	shouldProxy := aBoolean.</body><body package="GlorpMappings">targetTableJoin	^targetTableJoin</body><body package="GlorpMappings">targetTableJoin: aJoin	"Set the join from the source table to the target table. Note that is is only required if you are using a link table, and in addition to the link table join need to connect from the source table directly to the target table as well.  This is *NOT* supposed to be a join from the link table to the target table. That's reverseJoin, and is calculated automatically. See relevantLinkTableFields if you need to give a hint, or linkTableJoin: if you want to set it explicitly."	targetTableJoin := aJoin.	aJoin owningMapping: self.</body><body package="GlorpMappings">useLinkTable	usesLinkTable := true.</body><body package="GlorpMappings">usesLinkTable	^usesLinkTable</body><body package="GlorpMappings">usesLinkTable: anObject	usesLinkTable := anObject</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>initializing</category><body package="GlorpMappings">constraintsFrom: oneTableSet to: anotherTableSet	^(self oneWayConstraintsFrom: oneTableSet to: anotherTableSet), 		(self oneWayConstraintsFrom: anotherTableSet to: oneTableSet)</body><body package="GlorpMappings">initialize	super initialize.	shouldProxy := true.	shouldUseFilteredRead := false.	usesLinkTable := false.	controlsTables := true.	isExclusive := false.</body><body package="GlorpMappings">initializeJoin	"We haven't been given a join. There might be a compound one, or else see if we can make an educated guess at one"	linkTableJoin notNil ifTrue: [join := linkTableJoin, targetTableJoin. ^self].	self initializeJoinTo: self relatedTables.</body><body package="GlorpMappings">initializeJoinTo: otherTables	"We haven't been giving a join. See if we can make an educated guess at one by looking for tables with constraints to us. If linkFields is set, it tells us the source field for the relationship between the link table and the target, so in looking for our own relationship to the link table, we exclude that."	| toConstraints fromConstraints |	self descriptor tables isEmpty ifTrue: [^self join: Join new].	(self referenceDescriptor tables isEmpty and: [self referenceDescriptor typeResolver usesInheritance]) ifTrue: [^self join: Join new].	toConstraints := self oneWayConstraintsFrom: self descriptor tables to: otherTables.	linkFields isNil ifFalse: [toConstraints := toConstraints reject: [:eachConstraint | eachConstraint targetFields anySatisfy: [:eachField | linkFields includes: eachField]]].	fromConstraints :=  self oneWayConstraintsFrom: otherTables to: self descriptor tables.	linkFields isNil ifFalse: [fromConstraints := fromConstraints reject: [:eachConstraint | eachConstraint sourceFields anySatisfy: [:eachField | linkFields includes: eachField]]].	self join: (self system joinFor: self toTables: otherTables fromConstraints: fromConstraints toConstraints: toConstraints).</body><body package="GlorpMappings">oneWayConstraintsFrom: oneTableSet to: anotherTableSet	| matches |	matches := OrderedCollection new: 3.	oneTableSet do: [:eachFromTable |		 anotherTableSet do: [:eachToTable |			matches addAll:  (eachFromTable foreignKeyConstraints					select: [:eachConstraint | eachConstraint refersToTable: eachToTable])]].	^matches.</body><body package="GlorpMappings">relatedTables	"If the user has told a RelationshipMapping to use a linkTable but not specified the join or the linkField(s) then this method seeks all tables that have at least one foreign key constraint to one of the relation's source tables and another to one of  the relation's target tables, checking that these two constraints are not in fact the same constraint (of course, that can only occur when the relation's source and target are the same)."	| otherTables possibleLinkTables |	otherTables := self basicReferenceDescriptor tables.	usesLinkTable ifFalse: [^otherTables].	linkFields isNil ifFalse: [^(linkFields collect: [:each | each table]) asSet asArray].	"The user has not told us the linkField(s), so they must think there is only one possible candidate."	possibleLinkTables := self system allTables reject:		[:each || linkToMeConstraints linkToOtherConstraints |		(linkToMeConstraints := each constraintsToAnyOf: self descriptor tables) isEmpty		or: [(linkToOtherConstraints := each constraintsToAnyOf: otherTables) isEmpty		or: [(linkToMeConstraints size = 1) &amp; (linkToOtherConstraints size = 1)			and: [linkToMeConstraints first ==  linkToOtherConstraints first]]]].	possibleLinkTables size ~= 1		ifTrue: [CannotAutomaticallyDetermineJoin new			tables: possibleLinkTables;			signal: 'Cannot automatically determine link table..'].	^possibleLinkTables.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>api</category><body package="GlorpMappings">beExclusive	"Make this an exclusive relationship - so that when the parent object is deleted, the child or children will also be deleted"	isExclusive := true.</body><body package="GlorpMappings">constructRowMapKeyAs: aBlock	"Give us the opportunity to construct a custom row map key. This is useful if you need to force two relationships to share a link table entry"	rowMapKeyConstructorBlock := aBlock.</body><body package="GlorpMappings">isExclusive	"Return whether this an exclusive relationship - so that when the parent object is deleted, the child or children will also be deleted"	^isExclusive.</body><body package="GlorpMappings">isExclusive: aBoolean	"Set whether this an exclusive relationship - so that when the parent object is deleted, the child or children will also be deleted"	isExclusive := aBoolean.</body><body package="GlorpMappings">linkField: aDatabaseField	linkFields := Array with: aDatabaseField.</body><body package="GlorpMappings">linkFields	^linkFields.</body><body package="GlorpMappings">linkFields: aCollection	"Set the fields that are foreign keys *from* the link table (this is only used if we have one) to the *target* table. This is used as a hint in the case where the link table is ambiguous, and is easier than specifying the full join."	linkFields := aCollection.</body><body package="GlorpMappings">referencedIndependentObjectsFrom: anObject	| value |	self canWrite ifFalse: [^#()].	value := self getValueFrom: anObject.	value == nil ifTrue: [^#()].	^Array with: value.</body><body package="GlorpMappings">relevantLinkTableFields	^linkFields.</body><body package="GlorpMappings">relevantLinkTableFields: aCollection	linkFields := aCollection.</body><body package="GlorpMappings">shouldUseFilteredRead	^shouldUseFilteredRead.</body><body package="GlorpMappings">shouldUseFilteredRead: aBoolean	shouldUseFilteredRead := aBoolean.</body><body package="GlorpMappings">useFilteredRead	shouldUseFilteredRead := true.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>processing</category><body package="GlorpMappings">trace: aTracing context: anExpression	"Currently we don't trace relationships across tables, so all we do hereis accumulate the list of embedded mappings"	| newContext |	(aTracing tracesThrough: self) ifFalse: [^self].	newContext := anExpression get: self attributeName.	aTracing addExpression: newContext.	self referenceDescriptor trace: aTracing context: newContext.</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>preparing</category><body package="GlorpMappings">joinExpressionFor: targetExpression	"We're looking for the object represented by this mapping, and we know the object represented by its source. Use our mapping criteria to construct a join that traverses that instance of this relationship"	| sourceExpression |	(self controlsTables not and: [self classModel describedClass == Association]) ifTrue: [^nil].	sourceExpression := targetExpression base.	^self extendedJoinFromSource: sourceExpression toTarget: targetExpression.</body><body package="GlorpMappings">multipleTableExpressionsFor: anExpression	^self referenceDescriptor multipleTableJoin		collect: [:each | each asExpressionJoiningSource: anExpression toTarget: anExpression]</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>validation</category><body package="GlorpMappings">targetTables	^((self usesLinkTable ifTrue: [self reverseJoin] ifFalse: [self join]) allTargetFields collect: [:each | each table]) asSet.</body><body package="GlorpMappings">validate	| targetJoinSourceFields targetJoinTargetTables |	super validate.	self join isNil ifTrue: [^self].	targetJoinSourceFields := targetTableJoin isNil ifTrue: [#()] ifFalse: [targetTableJoin allSourceFields].	targetJoinTargetTables :=  targetTableJoin isNil ifTrue: [#()] ifFalse: [targetTableJoin allTargetFields collect: [:each | each table]].	(self join allSourceFields asArray, targetJoinSourceFields)		do:			[:each | 			(each class == DatabaseField or: [each isKindOf: FunctionExpression]) 				ifTrue: [(self descriptor tables includes: each table)					ifFalse: [self error: 'Joins should go from the table(s) associated with this descriptor to the other table(s)']]].	(self targetTables asArray, targetJoinTargetTables)		do:			[:each | 			(self referenceDescriptor allTables includes: each)				ifFalse:					[self						error:							'Joins should go to the table(s) associated with the reference class of the mapping']].	join allSourceFields asSet size = join allSourceFields size ifFalse: [self error: 'The same field occurs twice in the join. This might be legal, but is probably a cut and paste error.'].	join allTargetFields asSet size = join allTargetFields size ifFalse: [self error: 'The same field occurs twice in the join. This might be legal, but is probably a cut and paste error.'].	(self isExclusive and: [self canWrite not]) ifTrue: [self error: 'It is not meaningful to have an exclusive relationship that is read-only.'].</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>proxies</category><body package="GlorpMappings">queryFor: anObjectBuilder 	"If we have a specific query we should use in this case, rather than our general one, construct it. Right now that only applies if we're using filtered reads"	| basicQuery collection primaryKey newQuery cachedQuery filterBlock |	self shouldUseFilteredRead 		ifFalse: [^self query].	cachedQuery := anObjectBuilder cachedQueryFor: self.	cachedQuery isNil 		ifTrue: 			[basicQuery := self buildGeneralQueryIn: anObjectBuilder.			self query tracing alsoFetchExpressions 				do: [:each | basicQuery alsoFetch: each].			collection := GlorpVirtualCollection new setQuery: basicQuery]		ifFalse: [collection := cachedQuery collection].	primaryKey := anObjectBuilder primaryKey.	filterBlock := self descriptor keyFields size = 1				ifTrue: [[:objects :parameters | (objects at: 1) = primaryKey]]				ifFalse:					[[:objects :parameters |					(1 to: primaryKey size)						inject: true						into: [:sum :i | sum and: [(primaryKey at: i) = (objects at: i)]]]].	newQuery := FilteringQuery on: collection filter: filterBlock.	newQuery collectBlock: [:each | each last].	newQuery readsOneObject: self attribute isCollectionAttribute not.	newQuery collectionType: self collectionType.	anObjectBuilder cachedQueryFor: self is: newQuery.	^newQuery</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>private/expressions</category><body package="GlorpMappings">constraints	"Return a list of the constraints from our link table. If the linkField is set, filter the constraints to those that include that field."	| referenceKeys linkTable referenceTables allConstraints relevantConstraints |	referenceKeys := self join targetKeys asOrderedCollection.	linkTable := referenceKeys first table.	"If we haven't been told the relevant link table fields, assume we can find them by looking at all the ones that aren't the ones from our source to the link, and all the rest will be from the link to the target."	allConstraints := linkTable foreignKeyConstraints.	relevantConstraints := linkFields isNil		ifTrue: [allConstraints reject: [:each | each sourceFields allSatisfy:				[:eachSourceField | referenceKeys includes: eachSourceField]]]		ifFalse: [allConstraints select: [:each | each sourceFields anySatisfy:				[:eachSourceField | linkFields includes: eachSourceField]]].	"Validate that we can handle this case"	referenceTables := (relevantConstraints collect: [:each | each targetTable]) asSet.	referenceTables size &gt; 1 ifTrue: [self error: 'Cannot handle this general a case. Try hinting using relevantLinkTableFields:'].	referenceTables size = 0 ifTrue: [self error: 'No tables found. Did you set up foreign key references in the table definitions?'].	"We validated:  the constraints all target the same table."	^relevantConstraints</body><body package="GlorpMappings">expressionFromLinkToReferenceTableWithBase: base	| reverse |	reverse := self reverseJoin asGlorpExpressionOn: base.	^reverse asGeneralGlorpExpressionWithFields.</body><body package="GlorpMappings">joinFromLinkToReferenceTable	"Generate the inverse mapping expression, i.e. the one connecting the link table to the reference table, using the foreign key constraints. We assume that if there's a general part, it applies only to the original join, and not to the reverse join that we're generating."	| expression generalPart |	expression := Join new.	self constraints do: [:eachConstraint | 		eachConstraint sourceFields with: eachConstraint targetFields do: 			[:eachSource :eachTarget |				expression addSource: eachSource target: eachTarget]].	generalPart := self join generalExpressionPart.	^generalPart isNil ifTrue: [expression] ifFalse: [generalPart AND: expression].</body><body package="GlorpMappings">singleJoinFromLinkToReferenceTableForConstraints: constraints	"Generate the inverse mapping expression, i.e. the one connecting the link table to the reference table, using the foreign key constraints. We assume that if there's a general part, it applies only to the original join, and not to the reverse join that we're generating."	| expression generalPart |	expression := Join new.	constraints do: [:eachConstraint | 		eachConstraint sourceFields with: eachConstraint targetFields do: 			[:eachSource :eachTarget |				expression addSource: eachSource target: eachTarget]].	generalPart := self join generalExpressionPart.	^generalPart isNil ifTrue: [expression] ifFalse: [generalPart AND: expression].</body></methods><methods><class-id>Glorp.RelationshipMapping</class-id> <category>printing</category><body package="GlorpMappings">field	^self join targetKeys first</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>testing</category><body package="GlorpMappings">controlsTables	"Return true if this type of method 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	^false</body><body package="GlorpMappings">isStoredInSameTable	^true</body><body package="GlorpMappings">shouldProxy	^false.</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>transformations</category><body package="GlorpMappings">defaultTransformationExpressionFor: aDescriptor 	"If there's no transformation, get all the mapped fields from the other descriptor and construct a transformation of each onto itself. This lets us unify the fields in my row with the fields in its row"	| fields transform |	fields := IdentitySet new.	aDescriptor mappings do: [:each | fields addAll: each mappedFields].	transform := Join new.	fields do: [:each | transform addSource: each target: each].	^transform</body><body package="GlorpMappings">hasTransformation	^false.</body><body package="GlorpMappings">transformationExpression	^self hasFieldTranslation		ifTrue: [fieldTranslation]		ifFalse: [fieldTranslation := self defaultTransformationExpressionFor: self referenceDescriptor]</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>accessing</category><body package="GlorpMappings">fieldTranslation	^fieldTranslation</body><body package="GlorpMappings">fieldTranslation: aPrimaryKeyExpression 	fieldTranslation := aPrimaryKeyExpression</body><body package="GlorpMappings">hasFieldTranslation	^fieldTranslation notNil.</body><body package="GlorpMappings">join	^nil.</body><body package="GlorpMappings">join: anExpression	self error: 'Embedded mappings do not use joins'.</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>mapping</category><body package="GlorpMappings">knitFromBuilder: sourceBuilder toBuilder: targetBuilder 	sourceBuilder requiresPopulating ifFalse: [^self].	super knitFromBuilder: sourceBuilder toBuilder: targetBuilder</body><body package="GlorpMappings">mapFromObject: anObject toTarget: target puttingRowsIn: aRowMap 	self transformationExpression 		mapFromSource: anObject		andTarget: target		intoRowsIn: aRowMap.	self transformationExpression allTables do: [:eachTable |			aRowMap rowForTable: eachTable withKey: target ifPresent: [  :each |			each shouldBeWritten: false]].</body><body package="GlorpMappings">mapObject: anObject inElementBuilder: anElementBuilder	| myTraceNode myBuilder |	"If the object already has a value in my slot, then this it got a cache hit, the embedded value was carried along for the ride, and we don't need to assign anything"	(self getValueFrom: anObject) isNil ifFalse: [^self].	"Otherwise, we need to look up the trace node that corresponds to this mapping, and get its instance"	myTraceNode := anElementBuilder expression get: self attributeName.	myBuilder := anElementBuilder query elementBuilderFor: myTraceNode.	self setValueIn: anObject to: myBuilder instance.</body><body package="GlorpMappings">reverseMapping	^self class new		attributeName: #temporaryReverseMappingForEmbeddedMapping;		referenceClass: self descriptor describedClass;		descriptor: self descriptor.</body><body package="GlorpMappings">translateField: aDatabaseField	^fieldTranslation isNil		ifTrue: [aDatabaseField]		ifFalse: [fieldTranslation sourceForTarget: aDatabaseField ifNone: [aDatabaseField]]</body><body package="GlorpMappings">translateTable: aTable	"If we have a field translation, return the translated (i.e. real) table to use. This ideally allows us to use either the real table in which something is embedded, or the imaginary table"	fieldTranslation isNil ifTrue: [^aTable].	1 to: fieldTranslation allTargetFields size		do:			[:i | 			(fieldTranslation allTargetFields at: i) table == aTable				ifTrue: [^(fieldTranslation allSourceFields at: i) table]].	^aTable.</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject ifNone: aBlock	| targetField target |	targetField := self transformationExpression targetForSource: aField.	targetField isNil ifTrue: [^aBlock value].	target := self getValueFrom: anObject.	^self referenceDescriptor valueOfField: targetField fromObject: target.</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>internal</category><body package="GlorpMappings">fieldsForSelectStatement	"Return a collection of fields that this mapping will read from a row"	"Return nothing, because our sub-objects will take care of adding their own fields, translated correctly through us."	^#().</body><body package="GlorpMappings">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	fieldTranslation isNil ifFalse: [^fieldTranslation allSourceFields].	^self referenceDescriptor mappedFields.</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>preparing</category><body package="GlorpMappings">joinExpressionFor: targetExpression	"We're looking for the object represented by this mapping, and we know the object represented by its source. Use our mapping criteria to construct a join that traverses that instance of this relationship.	Embedded values never induce a join."	^nil.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>printing</category><body package="GlorpExpressions">printBasicSQLOn: aStream withParameters: aDictionary forSelect: aBoolean	aStream		nextPutAll: function;		nextPut: $(.	aBoolean		ifTrue: [base printSelectSQLOn: aStream withParameters: aDictionary]		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].	arguments do:		[:each |		"It's possible there needs to be type conversion here similar to InfixFunction&gt;&gt;printSQLOn:withParameters:, but it's not clear how common that case is, or how best to do it, so leaving it until it becomes a problem."		aStream nextPutAll: separator.		aBoolean 			ifTrue: [each printSelectSQLOn: aStream withParameters: aDictionary]			ifFalse: [each printSQLOn: aStream withParameters: aDictionary]].	aStream nextPut: $).	aBoolean &amp; alias notNil ifTrue:		[aStream			nextPutAll: ' AS ';			nextPutAll: alias].</body><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary	self printBasicSQLOn: aStream withParameters: aDictionary forSelect: true.</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	self printsIntoJoins		ifTrue: [self printBasicSQLOn: aStream withParameters: aDictionary forSelect: false]		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].</body><body package="GlorpExpressions">printTreeOn: aStream 	aStream		nextPutAll: function, '('.	base printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>initializing</category><body package="GlorpExpressions">initialize	super initialize.	arguments := #().	separator := ','.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>converting</category><body package="GlorpExpressions">convertedStValueOf: anObject	"This assumes that functions that do conversions have already had their effect in the database, and all we're concerned with is the fundamental data type conversion"	^base convertedStValueOf: anObject.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	arguments do: [:each | each do: aBlock skipping: aSet].	aBlock value: self.</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>accessing</category><body package="GlorpExpressions">argumentModifierBlock	^argumentModifierBlock</body><body package="GlorpExpressions">argumentModifierBlock: aBlock	argumentModifierBlock := aBlock</body><body package="GlorpExpressions">arguments	^arguments.</body><body package="GlorpExpressions">arguments: aCollection	"Our arguments may have already been set to a block, in which case we evaluate it with the incoming collection."	argumentModifierBlock notNil ifTrue: [^arguments := argumentModifierBlock value: self value: aCollection].	arguments := aCollection.</body><body package="GlorpExpressions">mappingSequenceName	"This could be confusing if we also use the original field.  Should we add some text for ourselves to distinguish.  Can we use the name or must we use the symbol - nextPsuedoBlobnegated (symbol) versus nextPsuedoBlob- (name) as field names in recursion table?  Or even check and choose whichever of the two had no bad characters.  For now, we use the symbol, guessing it is the safer bet."	^base mappingSequenceName, symbol</body><body package="GlorpExpressions">separator	^separator</body><body package="GlorpExpressions">separator: aString	separator := aString</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>recursion</category><body package="GlorpExpressions">createMappingToFieldInRecursionTable: aDatabaseTable	^base createMappingToFieldInRecursionTable: aDatabaseTable</body></methods><methods><class-id>Glorp.PrefixFunction</class-id> <category>navigating</category><body package="GlorpExpressions">penultimateBaseExpression	^base penultimateBaseExpression</body></methods><methods><class-id>Glorp.Query</class-id> <category>accessing</category><body package="GlorpQueries">collectionType	"Note that queries default the collection type to array, while mappings default to OrderedCollection. In 2003, Alan wrote: I think it makes sense.  In 2017, Niall wrote: if the collectionType of the proxy's query is nil then #resultCollectionFor: returns an Array and registering an Array ignores its internals.  If, however, it is an OrderedCollection then its internals _are_ registered, thus are in the transaction's collectionMementos, which become the RowMapForMementos' collectionMementos.  It is therefore important for a mapping and its query to agree on this, else some operations - #delete: is the one where I saw a problem - DNU when the RowMapForMementos cannot find the collectionMemento it seeks in RelationshipMapping&gt;&gt;mapFromObject:intoRowsIn.  Ordinary set up should ensure this but anyone getting 'clever' with a mapping's query needs to be aware of it."	collectionType isNil ifTrue: [collectionType := Array].	^collectionType.</body><body package="GlorpQueries">collectionType: aClass	collectionType := aClass.</body><body package="GlorpQueries">expectedRows	"How many rows do we think it's likely this query will bring back. Used for tweaking things like block factor"	^expectedRows isNil		ifTrue: [expectedRows := self readsOneObject ifTrue: [1] ifFalse: [100]]		ifFalse: [expectedRows].</body><body package="GlorpQueries">expectedRows: anInteger	"How many rows do we think it's likely this query will bring back. Used for tweaking things like block factor"	expectedRows := anInteger</body><body package="GlorpQueries">maximumLobSizeToRetrieveDirectly	^maximumLobSizeToRetrieveDirectly</body><body package="GlorpQueries">maximumLobSizeToRetrieveDirectly: anInteger	maximumLobSizeToRetrieveDirectly := anInteger.</body><body package="GlorpQueries">platform	^session system platform.</body><body package="GlorpQueries">readsOneObject	readsOneObject isNil ifTrue: [^false].	^readsOneObject.</body><body package="GlorpQueries">readsOneObject: aBoolean 	readsOneObject := aBoolean</body><body package="GlorpQueries">session	^session</body><body package="GlorpQueries">session: aSession 	session := aSession</body></methods><methods><class-id>Glorp.Query</class-id> <category>executing</category><body package="GlorpQueries">execute	"Users must call #setUpBaseFromSession: before calling #retrieve: or #AND:/#OR: when the block contains aggregation functions or platform-specific functions.  In that case, this convenience method lets you evaluate the configured query without explicitly setting its session a second time."	^self executeWithParameters:#() in: session</body><body package="GlorpQueries">executeIn: aSession	^self executeWithParameters:#() in: aSession.</body><body package="GlorpQueries">executeWithParameters: parameterArray in: aSession 	self subclassResponsibility.</body><body package="GlorpQueries">resultCollectionFor: aCursoredStream	| results finalAnswer |	collectionType isNil ifTrue: [^aCursoredStream upToEnd].	collectionType == aCursoredStream class ifTrue: [^aCursoredStream].	results := (aCursoredStream newCollectionOfSize: self expectedRows for: collectionType) writeStream.	results nextPutAll: aCursoredStream upToEnd.	finalAnswer := results contents.	session register: finalAnswer.	^finalAnswer.</body></methods><methods><class-id>Glorp.Query</class-id> <category>specifying retrievals</category><body package="GlorpQueries">retrieveDictionaryWithKey: keyExpression value: valueExpression	self collectionType: (GlorpDictionaryDescription new keyExpression: keyExpression; valueExpression: valueExpression).</body><body package="GlorpQueries">returnsDictionary	^collectionType class == GlorpDictionaryDescription.</body></methods><methods><class-id>Glorp.Query</class-id> <category>sql generation</category><body package="GlorpQueries">printCompoundSelectAliasesOn: aStream	"Since only a CompoundSelectCommand can call this method, it is unclear why it is defined on the superclass, as if any subclass other than CompoundQuery could call it."	self printOrderingOn: aStream.	self printGroupingOn: aStream.</body><body package="GlorpQueries">printGroupingOn: aStream	grouping isNil ifTrue: [^self].	aStream nextPutAll: ' GROUP BY '.	GlorpHelper		do: [:each |			each				rewriteFunctionArguments;				printSQLOn: aStream withParameters: nil]		for: grouping		separatedBy: [aStream nextPutAll: ', ']</body><body package="GlorpQueries">printOrderingOn: aStream	"Before printing, send each expression &gt;&gt;rewriteFunctionArguments.	It has no effect for most expressions and most functions, but is	needed with some platforms (see Substring)."	ordering isNil ifTrue: [^self].	aStream nextPutAll: ' ORDER BY '.	GlorpHelper		do: [:each |			each				rewriteFunctionArguments;				printSQLOn: aStream withParameters: nil]		for: ordering		separatedBy: [aStream nextPutAll: ', ']</body><body package="GlorpQueries">rewriteExcept	"Rewrite any EXCEPT operation we have into a NOT EXISTS tests. Only a CompoundQuery would have such an operation"</body><body package="GlorpQueries">rewriteIntersect	"Rewrite any INTERSECT operation we have into an EXISTS tests. Only a CompoundQuery would have such an operation"</body></methods><methods><class-id>Glorp.Query</class-id> <category>ordering</category><body package="GlorpQueries">expressionBlockFor: anOrderingCriteria	"Allow us to use symbols interchangeably with simple blocks for ordering, so 	#firstName is equivalent to [:each | each firstName]. Also, allow chains of symbols, so #(owner firstName)"	anOrderingCriteria isGlorpExpression ifTrue: [^anOrderingCriteria].	anOrderingCriteria glorpIsBlock ifTrue: [^anOrderingCriteria].	anOrderingCriteria isSymbol 		ifTrue: [^[:each | each perform: anOrderingCriteria]].		"otherwise, we assume it's a collection of symbols, the only other valid case"	anOrderingCriteria do: [:each | each isSymbol ifFalse: [self error: 'invalid ordering criteria']].	^[:each | anOrderingCriteria inject: each into: [:sum :eachExpression |		sum perform: eachExpression]].</body><body package="GlorpQueries">groupBy	"Preserve prior behaviour:  return nil or the first groupBy, which previously was the only groupBy and will likely be the only groupBy in all cases where calling this makes sense.  The sole known appropriate use for this method is to allow a prior version of Glorp to be loaded from Store.  However it can be used as a shortcut when it is known that grouping only has one item (or the first is intentionally sought).  As with #setOrdering:, we make the assumption that noone will ever #setGrouping: to an empty collection or a collection that is later emptied (all checks of ordering assume nil is the only empty condition that need be considered)."	^grouping isNil ifFalse: [grouping first]</body><body package="GlorpQueries">groupBy: aBlock	grouping isNil		ifTrue: [grouping := Array with: aBlock]		ifFalse: [grouping := grouping , (Array with: aBlock)].</body><body package="GlorpQueries">grouping	^grouping</body><body package="GlorpQueries">orderBy: aBlock	ordering isNil 		ifTrue: [ordering := Array with: aBlock]		ifFalse: [ordering := ordering , (Array with: aBlock)].</body><body package="GlorpQueries">ordering	^ordering.</body><body package="GlorpQueries">setGrouping: aCollection	grouping := aCollection.</body><body package="GlorpQueries">setOrdering: aCollection	ordering := aCollection.</body></methods><methods><class-id>Glorp.Query</class-id> <category>copying</category><body package="GlorpQueries">copy	^self shallowCopy postCopy.</body><body package="GlorpQueries">copyAttributesTo: newQuery	"We're creating a new query similar to ourselves, but not a direct copy. Copy over the relevant attributes. Note that we don't copy over the ordering, because that's less universally appropriate. Caller beware."	newQuery expectedRows: self expectedRows.	newQuery collectionType: self collectionType.	newQuery readsOneObject: self readsOneObject.	newQuery maximumLobSizeToRetrieveDirectly: self maximumLobSizeToRetrieveDirectly.</body><body package="GlorpQueries">copyOfBuildersFor: aGlorpCursoredStream	^self copyOfBuilders do: [:each | each cursor: aGlorpCursoredStream]</body><body package="GlorpQueries">postCopy	prepared := false.</body></methods><methods><class-id>Glorp.Query</class-id> <category>printing</category><body package="GlorpQueries">printOn: aStream	"I hate the printing with namespaces in vw"      | title |        title := self class name.        aStream nextPutAll:                ((title at: 1) isVowel ifTrue: ['an '] ifFalse: ['a ']).        aStream nextPutAll: title</body></methods><methods><class-id>Glorp.Query</class-id> <category>testing</category><body package="GlorpQueries">hasGrouping	^self grouping notNil</body><body package="GlorpQueries">hasOrdering	^self ordering notNil</body><body package="GlorpQueries">shortCircuitEmptyReturn: parameters	^false.</body></methods><methods><class-id>Glorp.Query</class-id> <category>initialize</category><body package="GlorpQueries">initialize	prepared := false.	maximumLobSizeToRetrieveDirectly := 32768.</body></methods><methods><class-id>Glorp.Query class</class-id> <category>instance creation</category><body package="GlorpQueries">count: aClass	^self count: aClass where: nil.</body><body package="GlorpQueries">count: aClass where: anExpression	| query |	query := self readOneOf: aClass where: anExpression.	query retrieve: #countStar.	^query.</body><body package="GlorpQueries">new	^super new initialize.</body><body package="GlorpQueries">read: aClass	^self read: aClass where: nil</body><body package="GlorpQueries">read: aClass where: anExpression	"Backward-compatibility, since we changed the class name."	^SimpleQuery read: aClass where: anExpression</body><body package="GlorpQueries">readManyOf: aClass	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:).	^self read: aClass</body><body package="GlorpQueries">readManyOf: aClass where: anExpression	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:).	^self read: aClass where: anExpression</body><body package="GlorpQueries">readOneOf: aClass	^SimpleQuery readOneOf: aClass.</body><body package="GlorpQueries">readOneOf: aClass where: anExpression	^SimpleQuery readOneOf: aClass where: anExpression.</body><body package="GlorpQueries">returningManyOf: aClass	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:).	^self read: aClass</body><body package="GlorpQueries">returningManyOf: aClass where: anExpression	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:).	^self read: aClass where: anExpression</body><body package="GlorpQueries">returningOneOf: aClass	"Backward-compatibility, since we changed the class name."	"returningOneOf: is a synonym of readOneOf:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #readOneOf:).	^self readOneOf: aClass.</body><body package="GlorpQueries">returningOneOf: aClass where: anExpression	"Backward-compatibility, since we changed the class name."	"returningOneOf: is a synonym of readOneOf:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #readOneOf:where:).	^self readOneOf: aClass where: anExpression</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>executing</category><body package="GlorpQueries">executeWithParameters: parameterArray in: aSession	session := aSession.	^self 		readFromDatabaseWithParameters: parameterArray.</body><body package="GlorpQueries">readFromDatabaseWithParameters: anArray	| answerStream result |	answerStream := self rowsFromDatabaseWithParameters: anArray.	^self readsOneObject		ifTrue: [result := answerStream next. answerStream release. result]		ifFalse: [self resultCollectionFor: answerStream].</body><body package="GlorpQueries">rowsFromDatabaseWithParameters: anArray	^session accessor		executeCommand: (self sqlWith: anArray)		returnCursor: true.</body><body package="GlorpCore">sqlWith: aDictionary	self prepare.	session platform queryWithUnsupportedOperationsEliminatedFrom: self do: [:newQuery | 		^newQuery			prepare;			sqlWith: aDictionary].	^CompoundSelectCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>accessing</category><body package="GlorpQueries">addQuery: aQuery	queries isEmpty ifTrue: [primaryQuery := aQuery].	queries add: aQuery.</body><body package="GlorpQueries">baseExpression	^primaryQuery baseExpression.</body><body package="GlorpQueries">joins	^queries inject: #() into: [:sum :each | sum, each joins].</body><body package="GlorpQueries">limit	^primaryQuery limit.</body><body package="GlorpQueries">limit: anInteger	"We currently ignore limit sets and use the one from our contained queries."	^self.</body><body package="GlorpQueries">mightHaveDuplicateRows	^primaryQuery mightHaveDuplicateRows.</body><body package="GlorpQueries">offset	^primaryQuery offset.</body><body package="GlorpQueries">offset: anInteger	"We currently ignore offset sets and use the one from our contained queries."	^self.</body><body package="GlorpQueries">operation: aString	operation := aString.</body><body package="GlorpQueries">primaryQuery: aQuery	primaryQuery := aQuery.</body><body package="GlorpQueries">proxyType	^primaryQuery proxyType.</body><body package="GlorpQueries">proxyType: aClass		"We currently ignore proxy types and use the ones from our main query."	^self.</body><body package="GlorpQueries">queries	^queries</body><body package="GlorpQueries">queries: aCollectionOfQueries	queries := aCollectionOfQueries</body><body package="GlorpQueries">requiresDistinct	^requiresDistinct</body><body package="GlorpQueries">requiresDistinct: aBoolean	requiresDistinct := aBoolean.</body><body package="GlorpQueries">resultClass	^primaryQuery resultClass.</body><body package="GlorpQueries">shouldRefresh	^primaryQuery shouldRefresh.</body><body package="GlorpQueries">shouldRefresh: aBoolean	"We currently ignore sets of this, and use the value from our primary query."	^self.</body><body package="GlorpQueries">tracing	^primaryQuery tracing.</body><body package="GlorpQueries">whereClause	| allCriteria |	allCriteria := queries inject: #() into: [:sum :each | sum, each whereClause].	^ExpressionGroup new addAll: allCriteria	"this #addAll: returns self, not its parameter"</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>boolean operations</category><body package="GlorpQueries">AND: anExpression	"If intentionally sent to a comppund query, presumably we want each and every contained query limited by the ANDed clause.  (if the parameter is an expression, not a block, the  ANDing will rebase it, thus avoiding identity - leading to wrong table aliases and bound expressions - across queries.)"	queries do: [:each | each AND: anExpression].</body><body package="GlorpQueries">except: aQuery	^self minus: aQuery.</body><body package="GlorpQueries">minus: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^self].	^CompoundQuery newMinus addQuery: self; addQuery: aQuery.</body><body package="GlorpQueries">unionAll: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^self].	^self isUnionAll		ifTrue:			[queries add: aQuery.			self]		ifFalse:			[(CompoundQuery newUnionAll)				addQuery: self;				addQuery: aQuery].</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>testing</category><body package="GlorpQueries">isIntersect	^operation = #INTERSECT.</body><body package="GlorpQueries">isMinus	^operation = #EXCEPT.</body><body package="GlorpQueries">isUnionAll	^operation = #'UNION ALL'.</body><body package="GlorpQueries">shortCircuitEmptyReturn	^false.</body><body package="GlorpQueries">useANSIJoins: aBoolean	queries do: [:each | each useANSIJoins: aBoolean].</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>printing</category><body package="GlorpQueries">printCompoundSelectAliasesOn: aStream	"The caller has already checked that we need a wrapper query and that the platform supportsAliasInCompoundQuery so we do not need to check it again here.  If there are no ordering or grouping fields, we merely use the first aliased table name (which will almost certainly be the first table name - an exception is if a RecursiveQuery has forced the unaliased recursion table name into the tablesToPrint).  If there are, the ordering and/or grouping fields may not all be on one table.  We use the aliased table that has the largest number and rename the aliases of any others while printing the ordering and grouping SQL, so all fields refer to the compound alias."	| tracedExpressionFields compoundAliasTable switchedAliases |	tracedExpressionFields := IdentityDictionary new.	ordering isNil ifFalse:		[ordering do:			[:each |			each hasField ifTrue:				[(tracedExpressionFields at: each field asField table ifAbsentPut: [OrderedCollection new]) add: each]]].	grouping isNil ifFalse:		[grouping do:			[:each |			each hasField ifTrue:				[(tracedExpressionFields at: each field asField table ifAbsentPut: [OrderedCollection new]) add: each]]].	tracedExpressionFields isEmpty		ifTrue:	"the first table that is not the unaliased recursion table will do"			[compoundAliasTable := primaryQuery tablesToPrint				detect: [:each | each isAliased]				ifNone: [self halt: 'This should not happen']]		ifFalse:	"choose the table with the most ordering or grouping fields"			[compoundAliasTable := ((2 to: tracedExpressionFields size)				inject: tracedExpressionFields values first				into: [:prev :index || next | next := tracedExpressionFields values at: index.					prev size &lt; next size ifTrue: [next] ifFalse: [prev]]) first field asField table.			tracedExpressionFields removeKey: compoundAliasTable].	aStream nextPutAll: ' '.	compoundAliasTable printSQLOn: aStream withParameters: nil.	"If not all fields are on the same table, switch the alias while printing."	switchedAliases := IdentityDictionary new.	tracedExpressionFields keys do:		[:aliasedTable |		switchedAliases at: aliasedTable put: aliasedTable name.		aliasedTable name: compoundAliasTable name].	[super printCompoundSelectAliasesOn: aStream]		ensure: [switchedAliases keysAndValuesDo:				[:aliasedTable :aliasName |				aliasedTable name: (switchedAliases at: aliasedTable)]].</body><body package="GlorpQueries">printOperationOn: aCommand	aCommand space.	aCommand nextPutAll: (self platform compoundOperationFor: operation).	aCommand space.</body><body package="GlorpQueries">sqlString	"Mostly for debugging"	^(self sqlWith: #()) sqlString.</body><body package="GlorpQueries">tablesToPrint	^primaryQuery tablesToPrint</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>preparing</category><body package="GlorpQueries">addBoundExpressionsIn: aCommand	queries do: [:each | each addBoundExpressionsIn: aCommand].</body><body package="GlorpQueries">aliasDuplicateFieldNames: anOrderedCollection 	queries do: [:each | each aliasDuplicateFieldNames: anOrderedCollection ]</body><body package="GlorpQueries">copyOfBuilders	^primaryQuery copyOfBuilders</body><body package="GlorpQueries">prepare	"Aliasing must be done after sub-query preparation, so each query's 'fields' instvar is set, and after ordering and grouping, since the user must themselves alias same-name fields if they use them for either.  Absurdly, Oracle, SQLServer and MySQL will not tolerate two unaliased fields in different tables but of the same name in a compound query, so aliasing may also be used merely to avoid that issue."	| aliasing |	aliasing := OrderedCollection new.	queries do: [:each | each session: session].	queries do: [:each | each prepare].	ordering isNil ifFalse:		[ordering := ordering collect:			[:each || orderingExpression |			orderingExpression := (self expressionBlockFor: each) asGlorpExpressionOn: primaryQuery baseExpression.			orderingExpression class == PseudoColumnFunction				ifFalse: [orderingExpression]				ifTrue:					[aliasing add: ((FieldExpression forField: orderingExpression field basedOn: primaryQuery baseExpression) alias: orderingExpression alias).					FieldExpression forField: (orderingExpression field copy name: orderingExpression alias) basedOn: primaryQuery baseExpression]]].	grouping isNil ifFalse:		[grouping := grouping collect:			[:each |			(self expressionBlockFor: each) asGlorpExpressionOn: primaryQuery baseExpression]].	(aliasing isEmpty and: [self platform supportsDuplicateFieldNamesInCompoundQueries]) ifFalse:		[queries do: [:each | each aliasDuplicateFieldNames: aliasing]].</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>sql generation</category><body package="GlorpQueries">rewriteExcept	"Rewrite any EXCEPT operation we have into a NOT EXISTS test with a correlated subselect. Only a CompoundQuery would have an EXCEPT"		| |	operation == #EXCEPT ifFalse: [^self].	queries := queries collect: [:each | each rewriteExcept].	^self rewriteSetOperationUsing: #notExists:</body><body package="GlorpQueries">rewriteIntersect	"Rewrite any INTERSECT operation we have into an EXISTS test for a correlated subselect. Only a CompoundQuery would have an intersect"		| |	operation == #INTERSECT ifFalse: [^self].	queries := queries collect: [:each | each rewriteIntersect].	^self rewriteSetOperationUsing: #exists:</body><body package="GlorpQueries">rewriteSetOperationUsing: aSelector	"Rewrite any INTERSECT OR EXCEPT operation we have into a correlated EXISTS or NOT EXISTS test, respectively. We take the sub-query, and AND into it a constraint that its base expression is equal to the first queries base expression, and then do either an exists: or a notExists:, depending on aSelector."		| newQuery |	newQuery := primaryQuery copy.	2 to: queries size do:		[:i || q expression mainExpression | q := (queries at: i) copy.		expression := RelationExpression new			relation: #=; leftChild: newQuery baseExpression; rightChild: q baseExpression.		mainExpression := RelationExpression new			relation: #AND; leftChild: q whereClause; rightChild: expression.		q whereClause: mainExpression.		newQuery AND: [:each | each perform: aSelector with: q]].	^newQuery</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>copying</category><body package="GlorpQueries">copyOfBuildersFor: aGlorpCursoredStream	"If my queries return a constant, do not assume it has the same value in each query;  change the builder to show this."	^self copyOfBuilders collect: 		[:each | each onCompoundCursor: aGlorpCursoredStream]</body><body package="GlorpQueries">postCopy	super postCopy.	queries := queries collect: [:each | each copy].	primaryQuery := queries first.</body></methods><methods><class-id>Glorp.CompoundQuery</class-id> <category>initializing</category><body package="GlorpQueries">initialize	super initialize.	requiresDistinct := true.	queries := OrderedCollection new: 3.</body><body package="GlorpQueries">setUpBaseFromSession: aSession	primaryQuery setUpBaseFromSession: aSession.</body></methods><methods><class-id>Glorp.CompoundQuery class</class-id> <category>instance creation</category><body package="GlorpQueries">newIntersect	^self new operation: #INTERSECT.</body><body package="GlorpQueries">newMinus	^self new operation: #EXCEPT.</body><body package="GlorpQueries">newUnionAll	^self new operation: #'UNION ALL'.</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>preparing</category><body package="GlorpQueries">addBoundExpressionsIn: aCommand	unionQuery addBoundExpressionsIn: aCommand.	super addBoundExpressionsIn: aCommand.</body><body package="GlorpQueries">prepare	unionQuery prepare.	super prepare.</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>executing</category><body package="GlorpQueries">ancestorMappingVia: aDescriptor to: anotherDescriptor	"If we have a complete set of primary key fields from the ancestor, set up a back-mapping to them."	| ancestralPrimaryKeyExpressions recursionTable referenceTable ancestralMappingExpressions |	recursionTable := aDescriptor table.	referenceTable := anotherDescriptor table.	ancestralMappingExpressions := retrievalMappingExpressions select:		[:each |		each class == MappingExpression and:			[each allSatisfy: [:eachBase | eachBase class ~~ MappingExpression or: [eachBase name ~= mappingToCloseOver attributeName]]]].	ancestralPrimaryKeyExpressions := ancestralMappingExpressions select:		[:each |		each mapping field table == referenceTable		and: [(anotherDescriptor table hasPrimaryKeyConstraints not or: [each mapping field isPrimaryKey])		and: [fetchBaseExpression isNil				ifTrue: [each base base == nil]	"use printString for safety till we get fetchBaseExpression from the right place"				ifFalse: [each base printString = fetchBaseExpression printString]]]].	ancestralPrimaryKeyExpressions size = 1	"check it is primaryKey or table has only one field"		ifTrue: [ancestralPrimaryKeyExpressions := ancestralPrimaryKeyExpressions first]	"cheat for now"		ifFalse: [ancestralPrimaryKeyExpressions isEmpty				ifFalse: [self halt: 'Tell Niall to finish this method']				ifTrue: [^self]]	"user did not provide retrievals for it so does not want it".	(anotherDescriptor newMapping: RecursiveMapping)		beForPseudoVariable;		attributeName: mappingToCloseOver attributeName, 'Recursively';	"attributeName converts param to symbol, so we need not"		referenceClass: mappingToCloseOver referenceClass;		collectionType: GlorpRecursiveCollection;		useLinkTable;	"i.e. use the recursion table"		join: (Join from: ancestralPrimaryKeyExpressions mapping field to: (recursionTable fieldNamed: ancestralPrimaryKeyExpressions commonTableExpressionName));		reverseJoin: (Join from: (anotherDescriptor mappingForAttributeNamed: #recursed) field to: ancestralPrimaryKeyExpressions mapping field).</body><body package="GlorpQueries">executeWithParameters: parameterArray in: aSession	"Clone the system so we can add recursion mappings to its model during the run without affecting any other holder of the original system instance.  Conveniently, CompoundQueries do not use the 'prepare' instvar;  we therefore use it to mark whether we have prepared the recursive system.  (This should in fact overlap with having prepared my contained queries in all but pathological cases.)	DB2Platform objects to ANSI joins in a recursive query so we force them off.  (Note that this prevents DB2 from combining recursion and OUTER JOINS since it also replies false to #useMicrosoftOuterJoins.)"	| initialQuery recursionDescriptor iterativeQuery referenceClass referenceDescriptor referenceExpression |	session := aSession.	primaryQuery session: session.	unionQuery session: session.	aSession platform supportsANSIJoinsWithRecursion ifFalse: [primaryQuery useANSIJoins: false].	unionQuery useANSIJoins: primaryQuery useANSIJoins.	prepared ifTrue:		[^session			useSystem: unionQuery queries last baseExpression descriptor system			while: [super executeWithParameters: parameterArray in: aSession]].	^session		useSystem: session system copy postCopyForRecursion		while:	"ensure base is set (it already will be if fetchBaseExpression isGlorpExpression) ..."			[primaryQuery baseExpression isNil ifTrue: [primaryQuery setUpBaseFromSession: session].			primaryQuery baseExpression descriptor:	"... and its descriptor uses the copied system"				((session system descriptorFor: primaryQuery resultClass) system: session system).			fetchBaseExpression isNil				ifTrue:					[referenceClass := primaryQuery resultClass.	"or should we use initialQuery resultClass?"					referenceExpression := primaryQuery baseExpression]				ifFalse:					[fetchBaseExpression := fetchBaseExpression asGlorpExpressionOn: primaryQuery baseExpression.					referenceClass := fetchBaseExpression referenceClass.					referenceExpression := fetchBaseExpression].			initialQuery := unionQuery queries first.			initialQuery session: session.			referenceDescriptor := self session system cloneDescriptorOfClass: referenceClass for: referenceClass.			primaryQuery resultClass == referenceDescriptor describedClass ifTrue:				[primaryQuery baseExpression descriptor: referenceDescriptor].			"The recursion mapping (and more) may be added to the cloned system just for this recursion."						"Check isSymbol as a performance tweak - we could instead call the ifFalse branch"			mappingToCloseOver := mappingDefiner isNil				ifFalse: [mappingDefiner value: referenceDescriptor]				ifTrue: [mappingToCloseOver isSymbol						ifTrue: [referenceDescriptor mappingForAttributeNamed: mappingToCloseOver]						ifFalse: [((self expressionBlockFor: mappingToCloseOver) asGlorpExpressionOn: referenceExpression) mapping]].			initialQuery setUpExpressions.			retrievalMappingExpressions := initialQuery tracing allTracings last: retrievalMappingExpressions size.				"I act as a dummy result class for the recursion table, thus 'for: self' in the next line."			recursionDescriptor := (self session system cloneDescriptorOfClass: referenceClass for: self)				asRecursiveDescriptorOnMapping: mappingToCloseOver				retrievingAll: retrievalMappingExpressions.			iterativeQuery := unionQuery queries last.			iterativeQuery session: session.			iterativeQuery baseExpression descriptor: recursionDescriptor.			iterativeQuery initResultClass: self whereClause: iterativeQuery whereClause singleObject: iterativeQuery readsOneObject.			self recursedBackMappingFrom: referenceDescriptor to: recursionDescriptor.			self ancestorMappingVia: recursionDescriptor to: referenceDescriptor.			prepared := true.	"exploit the non-use of 'prepared' by compound queries"			super executeWithParameters: parameterArray in: aSession]</body><body package="GlorpQueries">recursedBackMappingFrom: aDescriptor to: anotherDescriptor	"Create a 'recursed' mapping from the recursion target back to the recursion table.  (We could use #reverseMapping to get it from the 'recurse' mapping, but for now, create it in parts for greater control and clarity.)"	| recursionBackJoin localClassModel recursionBackAttribute recursionBackMapping |	recursionBackJoin := (anotherDescriptor mappingForAttributeNamed: 'recurse' asSymbol) join inverseJoin.	localClassModel := aDescriptor classModel.	recursionBackAttribute := localClassModel attributeNamed: 'recursed'.	recursionBackMapping := aDescriptor oneToOneMapping.	recursionBackMapping attributeName: recursionBackAttribute name.	recursionBackMapping referenceClass: self.	recursionBackMapping join: recursionBackJoin.	recursionBackMapping beForPseudoVariable.</body><body package="GlorpQueries">sqlWith: aDictionary	self prepare.	^RecursiveCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>accessing</category><body package="GlorpQueries">mappingDefiner: aOneArgBlock	"The parameter is the cloned referenceDescriptor.  If no suitable mapping for the recursion exists in the system, use ...defineThenFollow:... instead of ...thenFollow: ... to call this method.  The parameter must returns a mapping when evaluated with value the reference descriptor.  The block may also extract the system from the recferenceDescriptor and add mappings for the recursion to exploit if desired."	mappingDefiner := aOneArgBlock.</body><body package="GlorpQueries">mappingToCloseOver	^mappingToCloseOver</body><body package="GlorpQueries">mappingToCloseOver: aSymbolOrBlock	"An existing mapping is identified by its name (a symbol) or by a block that defines a mapping expression.  If no suitable mapping for the recursion exists in the system, use ...defineThenFollow:... instead of ...thenFollow: ..."		mappingToCloseOver := aSymbolOrBlock.</body><body package="GlorpQueries">retrievalMappingExpressions: someSymbols	retrievalMappingExpressions := someSymbols.</body><body package="GlorpQueries">unionQuery	^unionQuery</body><body package="GlorpQueries">unionQuery: aCompoundQuery	unionQuery := aCompoundQuery.</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>recursing</category><body package="GlorpQueries">asRecursiveQuery	^self</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>testing</category><body package="GlorpQueries">glorpCanHaveDescriptorDirectly	"Use myself as the class mapped by my recursive table, simply to have an object for the descriptor system."	^true</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>printing</category><body package="GlorpQueries">name	"This can get called if users inspect the recursive mapping or class model or iterativeQuery in my compoundQuery that use me as their describedClass or resultClass.  Avoid an error in #printOn: by providing something."	^self printString</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>sql generation</category><body package="GlorpQueries">ensureRecursionTableToPrint	"Ensure we join to the recursion table.  If there is no use of the #recursed mapping in the whereClause, the ordering, the grouping or the retrievals then add it to the mainQuery.  We do not bother to alias the recursion table in this case since we know it has no reference other than the one we are now inserting.  (The coding assumes the mainQuery is a SimpleQuery or a CompoundQuery whose primaryQuery is a SimpleQuery.)	A side effect of this is to initialize 'tablesToPrint' early.  In #printANSITablesOn:, the lazy computation of #tablesToPrint would be, by a few statements, just too lazy (i.e. too late) to supply the JoinPrinter with the correct join list in the case that we add a join if our tablesToPrint does not already include the recursion table, so it is good we force the computation early."	| otherTablesToPrint |	otherTablesToPrint := primaryQuery tablesToPrint.	"ASSUMES primaryQuery is simple - fix with #primaryQuery method on CompoundQuery and Query"	(otherTablesToPrint anySatisfy:		[:eachTable || eachParentName | eachParentName := eachTable unaliasedName.		12 &lt; eachParentName size and:	"unlikely a table would be named _part_ of the match, e.g. 'Recursion' but guard against index error"			[(1 to: 12) allSatisfy:				[:eachIndex |				('RecursionOn_' at: eachIndex) = (eachParentName at: eachIndex)]]])		ifFalse:	"add a join to the recursion table in the primaryQuery"			[([:each | each recursed] asGlorpExpressionOn:					(fetchBaseExpression isNil ifTrue: [primaryQuery baseExpression] ifFalse: [primaryQuery tracing allTracings last]))				additionalExpressions do:					[:each |					(primaryQuery addJoin: each) do:						[:eachJoin | eachJoin allTablesToPrint do:							[:eachTable |							(otherTablesToPrint includes: eachTable) ifFalse: [otherTablesToPrint add:eachTable]]]]].	^otherTablesToPrint</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>boolean operations</category><body package="GlorpQueries">AND: anExpression	"Apply to the anchor query (but not the recursive one) and all the main queries.  (if the parameter is an expression, not a block, the  ANDing will rebase it, thus avoiding identity - leading to wrong table aliases and bound expressions - across queries.)"	unionQuery queries first AND: anExpression.	super AND: anExpression.</body><body package="GlorpQueries">unionAll: aQuery	operation isNil ifFalse: [^super unionAll: aQuery].	aQuery shortCircuitEmptyReturn ifTrue: [^self].	"self requiresDistinct: true.	we assume not;  to review"	self operation: #'UNION ALL'.	queries add: aQuery.	"^self"</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>converting</category><body package="GlorpQueries">fetchBaseExpression: aBlockClosureOrExpression	fetchBaseExpression := aBlockClosureOrExpression.</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>copying</category><body package="GlorpQueries">postCopy	"Copying re-validates my queries' whereClauses, which may contain recursion mappings undefined in the main system. As they have been and/or will be validated at the proper time, just resume any validation errors raised.  TBR:  should we check that the last characters of the error's message text are 'Recursively' or 'recurse or whatever (as this is the case where the error will not signify)?"	[unionQuery := unionQuery copy.	super postCopy]		on: ValidationError		do: [:ex | ex resume]</body></methods><methods><class-id>Glorp.RecursiveQuery</class-id> <category>initialize-release</category><body package="GlorpQueries">start: initialQuery retrieveAll: anArray recursivelyRetrievingAll: anotherArray	"This convenience protocol simplifies setting these three interrelated parameters in a cascade."	self		retrievalMappingExpressions: anArray;		unionQuery:			(CompoundQuery newUnionAll				requiresDistinct: false;				addQuery: (initialQuery retrieveAll: anArray);				addQuery: ((initialQuery class read: self resultClass)							retrieveAll: anotherArray;							yourself)).</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^true.</body><body package="GlorpDatabaseTypes">hasWidth	"Return true if this type has a width attribute - basically meaning it's a string or LOB type. Note that this is different from the isVariableWidth test, which tells us if a field has fixed vs. varying width. So a CHAR field hasWidth=&gt;true, but isVariableWidth=&gt;false, while a VARCHAR field hasWidth=&gt;true isVariableWidth=&gt;false, and a NUMBER has both false."	^true.</body><body package="GlorpDatabaseTypes">isStringType	^true.</body><body package="GlorpDatabaseTypes">isVariableWidth	self subclassResponsibility.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#String.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	(aClass includesBehavior: Boolean) ifTrue: [^self platform converterNamed: #booleanToStringTF].	(aClass includesBehavior: Symbol) ifTrue: [^self platform converterNamed: #symbolToString].	width isNil ifFalse: [		(aClass includesBehavior: String) ifTrue: [^self platform converterNamed: #stringToString]].	(aClass includesBehavior: Integer) ifTrue: [^self platform converterNamed: #integerToString].	^super converterForStType: aClass.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^String.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">queryType	queryType isNil ifTrue: [^self].	^queryType.</body><body package="GlorpDatabaseTypes">queryType: aType	queryType := aType</body><body package="GlorpDatabaseTypes">width	^width.</body><body package="GlorpDatabaseTypes">width: anInteger	width := anInteger = 0 ifTrue: [nil] ifFalse: [anInteger]</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">typeString	typeString isNil		ifTrue:			[typeString := self typeName.			width isNil				ifFalse: [typeString := typeString , '(' , width printString , ')']].	^typeString.</body><body package="GlorpDatabaseTypes">typeString: aString	"If we set the typeString, we are presumably setting it to the non-parameterized name as well"	typeString := aString.	super typeString: aString.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>private</category><body package="GlorpDatabaseTypes">typeName	^typeString.</body><body package="GlorpDatabaseTypes">typeName: aString	typeString := aString.</body></methods><methods><class-id>Glorp.GlorpAbstractStringType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes">= aType	super = aType ifFalse: [^false].	self width = aType width ifFalse: [^false].	self queryType == self ifFalse: [		self queryType = aType queryType ifFalse: [^false]].	^true.</body><body package="GlorpDatabaseTypes">hash	^self queryType == self		ifTrue: [super hash bitXor: self width hash]		ifFalse: [(super hash bitXor: self width hash) bitXor: self queryType hash]</body></methods><methods><class-id>Glorp.GlorpTextType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#LargeString.</body></methods><methods><class-id>Glorp.GlorpTextType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">isVariableWidth	^true.</body></methods><methods><class-id>Glorp.GlorpTextType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'text'.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>testing</category><body package="GlorpDatabase">canBind: aValue to: aType	"Return true if this platform can bind the value to a bind marker in the SQL instead of writing the value in the SQL.  For a subclass that usesArrayBindingToGroupWrite, this must remain true for all values (or usesArrayBindingToGroupWrite must become false for commands whose rows include unbindable values)."	^true</body><body package="GlorpDatabase">canRecurse	"Do I support RecursiveQuery (see its comment for details).  For all databases that do, the answer will be version-specific."	^false</body><body package="GlorpDatabase">canUseInWhereClause: aValue type: aType	(Dialect isFloatingPoint: aValue) ifTrue: [^false].	^true.</body><body package="GlorpDatabase">isAccessPlatform	^false</body><body package="GlorpDatabase">isDB2Platform	^false</body><body package="GlorpDatabase">isMySQLPlatform	^false.</body><body package="GlorpDatabase">isODBCPlatform	^false</body><body package="GlorpDatabase">isOcelotPlatform	^false</body><body package="GlorpDatabase">isOraclePlatform	^false</body><body package="GlorpDatabase">isPostgreSQLPlatform	^false</body><body package="GlorpDatabase">isSQLServerPlatform	^false</body><body package="GlorpDatabase">isSQLite3Platform	^false</body><body package="GlorpDatabase">maximumQueryValueSize	"If there's a limit on how big a bound input parameter can be for a query, return it here. By default, no maximum. "	^536870911 "VisualWorks SmallInteger maxVal. Lacking infinity, this will do as a default."</body><body package="GlorpDatabase">measuresStringFieldWidthsInBytes	"Return true if we measure the width of a string in bytes rather than characters. So, a 255-character field can hold 255 bytes worth of string, not 255 characters. This is important with encodings"	^false.</body><body package="GlorpDatabase">requiresCastsForNullsInUnions	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."	^false.</body><body package="GlorpDatabase">reusePreparedStatements	"The ordinary choice is to initialize the accessor to reuse statements whenever binding is being used."	^true</body><body package="GlorpDatabase">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^false.</body><body package="GlorpDatabase">supportsANSIJoinsWithRecursion	"Usually, a platform that supports the ANSI JOIN syntax does so in all cases, but a platform can support it for ordinary queries but not for recursive queries."	^self supportsANSIJoins</body><body package="GlorpDatabase">supportsAliasInCompoundQuery	"Return true if, when we have a subselect, we can (and/or must) alias the result with a table name. Access doesn't like the table name"	^true.</body><body package="GlorpDatabase">supportsBinding	"Return true if this platform supports binding parameters rather than printing them as strings into the SQL statement"	^false.</body><body package="GlorpDatabase">supportsCaseInsensitiveLike	^false.</body><body package="GlorpDatabase">supportsCompositeKeyArgsForOperand: aSymbol	"Do we support rows, not just single values, in comparisons:  do we allow expressions like		 (t1.NAME, t1.USER_ID) IN (SELECT s1t1.NAME, s1t1.USER_ID FROM ... )and/or		 (t1.NAME, t1.USER_ID) = (SELECT s1t1.NAME, s1t1.USER_ID FROM ... LIMIT 1)in where clauses.  The trio of comparison operator symbols #= #&lt;&gt; and #IN are the only ones for which this matters at the moment;  see the guard in #rewriteEquality."	^false</body><body package="GlorpDatabase">supportsConstraints	"Ideally, this method would be called supportsAddDropConstraintStatements.  It returns true if we support constraints, and specifically constraint add or drop statements.  If a platfiorm supports integrity constraints, i.e. foreign key, primary key or unique constraints, but does not support add or drop statements (e.g. they must be in the table create or column add statements) then it must return false to this method and override its callers as appropriate - see e.g. SQLitePlatform."	^true</body><body package="GlorpDatabase">supportsCorrelatedSubqueriesInOrderBy	"Return true if this platform supports correlated subqueries in the ORDER BY clause."	^true</body><body package="GlorpDatabase">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place"	^true.</body><body package="GlorpDatabase">supportsDuplicateFieldNamesInCompoundQueries	"Absurdly, Oracle, SQLServer and MySQL will not tolerate two unaliased fields in different tables but of the same name in a compound query, so the second (and subsequent) such fields must be aliased."	^true</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	"Return true if this platform can send multiple rows to the server in a single round trip, whether by sending multiple semi-colon-separated commands, or by sending multiple comma-separated values with a single command, or by binding an array of values to a single command.  When overriding this method in subclasses, consider whether groups of rows can be written to that platform both bound and unbound, or only in one of these states.  If the subclass returns true to #usesIdentityColumns, consider whether groups of rows can be written to a table that includes an identity column (i.e. one whose values are server-generated ids), or only to tables that do not.	In cases where the platform has chosen the command subclass (i.e. the InsertCommand subclass), the command, not the platform, can be asked if it e.g. supportsGroupWritingValues, since the platform must support it for a command that does to have been instantiated.	This can only be called on a command created in #commandForHomogeneousRows:.  That creation sets this command's useBinding to be the same as its session's platform's useBinding, which is this platform.  Hence we need only check the platform's binding in subclasses where that is relevant."	^false</body><body package="GlorpDatabase">supportsGroupWritingValues	"Return true if we support multiple rows in a single INSERT statement, like this:	INSERT INTO table (id, city, state) VALUES (1, 'Boston', 'MA'), (2, 'New York',  'NY'), (3, 'San Francisco', 'CA')."	^false</body><body package="GlorpDatabase">supportsInformationSchema	^true.</body><body package="GlorpDatabase">supportsIntersect	"Do we support the INTERSECT or MINUS operations."	^true.</body><body package="GlorpDatabase">supportsLimit	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"	^false.</body><body package="GlorpDatabase">supportsMultipleOpenCursors	"Can this database support multiple open cursors at once"	^true.</body><body package="GlorpDatabase">supportsOffset	"Do we support anything analogous to the postgresql OFFSET, skipping the first N rows"	^false.</body><body package="GlorpDatabase">supportsRowCountFor: aRowBasedCommand	"The parameter can be a RowBasedCommand (currently, only an UpdateCommand using optimistic locking) or a QueryDeleteCommand.  Do not use optimistic locking where this method returns false."	^true</body><body package="GlorpDatabase">supportsSchemas	"Return true if this platform supports schemas. Access and SQLite 3 do not."	^true</body><body package="GlorpDatabase">supportsSettingSequenceIncrement	"Return true if this platform can support creating a sequence with an increment other than 1."	^false</body><body package="GlorpDatabase">supportsSingleQueryHorizontalInheritance	"Can this database support a single query for horizontal inheritance."	^true.</body><body package="GlorpDatabase">supportsStringQueryOnBlobs	^true.</body><body package="GlorpDatabase">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL.""Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^false</body><body package="GlorpDatabase">useBinding	"Return true if we should use binding"	self supportsBinding ifFalse: [^false].	useBinding isNil ifTrue: [useBinding := self class useBindingIfSupported].	^useBinding</body><body package="GlorpDatabase">useBinding: aBoolean	useBinding := aBoolean.</body><body package="GlorpDatabase">useMicrosoftOuterJoins	"Return true if we use the Microsoft x *= y syntax for outer joins"	^false.</body><body package="GlorpDatabase">useOracleOuterJoins	"Return true if we use the old Oracle x = y (+) syntax for outer joins"	^false.</body><body package="GlorpDatabase">usesArrayBindingToGroupWrite	"Return true if we use array binding for bound grouped writes rather than printing the SQL multiple times.  Only applies if we support grouped writes.  Requires that #canBind:to: be true for all values."	^false</body><body package="GlorpDatabase">usesIdentityColumns	"When a row is inserted into a table with a serial-type column, some servers post-assign the id value, i.e. the id is a _result_ of inserting a row and so cannot easily be known beforehand.  Glorp needs to know such ids to maintain the map between an object and row(s) written for it.  This can complicate group-writing insert statements:  if the table has a serial type and the platform uses identity columns, either a post-insert query to discover the ids must be wrapped into a grouped insert, or individual inserts, immediately succeeded by post-insert query for the id, are needed.  See #postWriteAssignSequencesUsing: versus #preWriteAssignSequencesUsing: and their call chain."	^false</body><body package="GlorpDatabase">usesInformationSchema	^false</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	"Glorp provides arguments start position and end position to SUBSTR by default but in some databases this function wants arguments (start) position and length."	^false</body><body package="GlorpDatabase">usesPrimaryKeyUniqueConstraintNames	"When dropping/creating primary key constraints, do they have distinguished names."	^true.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>types</category><body package="GlorpDatabase">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new].</body><body package="GlorpDatabase">boolean	"By default, we represent booleans as small integers."	^self smallint.</body><body package="GlorpDatabase">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new].</body><body package="GlorpDatabase">char: anInteger	^self char width: anInteger.</body><body package="GlorpDatabase">character	^self char</body><body package="GlorpDatabase">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new].</body><body package="GlorpDatabase">date	"Return the type we use to represent dates. By default, we use the same type as for timestamps."	^self timestamp.</body><body package="GlorpDatabase">datetime	^self timestamp</body><body package="GlorpDatabase">double	^self subclassResponsibility.</body><body package="GlorpDatabase">generatorFor: aType withBlock: aBlock	"Don't cache this, because we want to return different instances depending on aType"	^VersionType underlyingType: aType generator: (AdHocVersionGenerator block: aBlock).</body><body package="GlorpDatabase">inMemorySequence	^self typeNamed: #inMemorySequence ifAbsentPut: [		GlorpInMemorySequenceDatabaseType representedBy: self int4].</body><body package="GlorpDatabase">int	^self integer.</body><body package="GlorpDatabase">int2	^self subclassResponsibility</body><body package="GlorpDatabase">int4	^self subclassResponsibility</body><body package="GlorpDatabase">int8	^self subclassResponsibility</body><body package="GlorpDatabase">integer	^self typeNamed: #integer ifAbsentPut: [GlorpIntegerType new].</body><body package="GlorpDatabase">number	^self typeNamed: #number ifAbsentPut: [GlorpNumericType new].</body><body package="GlorpDatabase">numeric	^self number.</body><body package="GlorpDatabase">nvarchar	^self subclassResponsibility.</body><body package="GlorpDatabase">sequence	^self subclassResponsibility</body><body package="GlorpDatabase">serial	self subclassResponsibility.</body><body package="GlorpDatabase">serial: aNumber	^self serial increment: aNumber</body><body package="GlorpDatabase">smallint	^self typeNamed: #smallint ifAbsentPut: [GlorpSmallIntType new].</body><body package="GlorpDatabase">text	^self clob.</body><body package="GlorpDatabase">time	self subclassResponsibility.</body><body package="GlorpDatabase">timestamp	self subclassResponsibility.</body><body package="GlorpDatabase">typeNamed: aSymbol ifAbsentPut: aBlock	| type |	type := self types at: aSymbol ifAbsentPut: [		| newType |		newType := aBlock value.		newType platform: self.		newType selector: aSymbol].	type hasParameters ifTrue: [type := type copy].	^type.</body><body package="GlorpDatabase">typeWithDatabaseName: aString characterWidth: aNumber	"Return our type which matches the database name for the type.  If we have no parameters, reuse the instance we hold to save space;  if we have, return a copy, since callers may set values in it, though here we only set the width if present."	| baseType matchingTypes simpleTypes |	matchingTypes := self typesWithValues values asArray select: [:each | each typeName asLowercase = aString asLowercase].	matchingTypes isEmpty ifTrue:		[Transcript cr; show: 'Cannot find type ', aString, ' using integer instead.'.		^self integer].	"We may get generated and non-generated both matching, e.g. inMemorySequence and int. Prefer the non-generated."	simpleTypes := matchingTypes reject: [:each | each isGenerated].	baseType := simpleTypes isEmpty ifTrue: [matchingTypes first] ifFalse: [simpleTypes first].	baseType hasParameters ifTrue: [baseType := baseType copy].	baseType hasWidth ifTrue: [baseType width: aNumber].	^baseType</body><body package="GlorpDatabase">typeWithDatabaseName: aString characterWidth: aNumber extraInformation: anythingElse	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	^self typeWithDatabaseName: aString characterWidth: aNumber.</body><body package="GlorpDatabase">types	^types</body><body package="GlorpDatabase">varChar	^self varchar.</body><body package="GlorpDatabase">varChar: anInt	^self varchar width: anInt.</body><body package="GlorpDatabase">varbinary	^self subclassResponsibility.</body><body package="GlorpDatabase">varbinary: anInteger	^self varbinary width: anInteger.</body><body package="GlorpDatabase">varchar	^self subclassResponsibility.</body><body package="GlorpDatabase">varchar: anInt	^self varchar width: anInt.</body><body package="GlorpDatabase">versionFieldFor: aType	"Don't cache this, because we want to return different instances depending on aType"	^(VersionType underlyingType: aType) generatesOverExistingValues: true; platform: self.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated	self subclassResponsibility.</body><body package="GlorpDatabase">batchWriteStatementTerminatorString	"^&lt;String&gt; This statement return the string to be used to devide several statement during batch write ..."	^';'</body><body package="GlorpDatabase">capitalWritingOfColumnName	"^&lt;Boolean&gt; This method returns true, if the dbms wants to have column 	names written in capital letters"	^false</body><body package="GlorpDatabase">capitalWritingOfCreatorName	"^&lt;Boolean&gt; This method returns true, if the dbms wants to have column 	names written in capital letters"	^true</body><body package="GlorpDatabase">capitalWritingOfSQLCommands	"^&lt;Boolean&gt;"	^true</body><body package="GlorpDatabase">capitalWritingOfTableName	^true</body><body package="GlorpDatabase">charactersThatNeedEscaping	^#($')</body><body package="GlorpDatabase">columnNameSeparatorString	"^&lt;String&gt; This statement return the string to be used to devide several columns ..."	^','</body><body package="GlorpDatabase">defaultOptimalINClauseLimit	"Databases have limits on the number if values allowed in an IN clause. 	However, if you research their user forums, you'll find that there is quite a difference between the	vendor's hard upper limit and the discovered opmimal limit. 	Sometimes the 'real' limit is further degraded because of the total size in characters of the final SQL statement.	This value represents a common realistic default.	Subclasses may override this for better values for their platform."	^500</body><body package="GlorpDatabase">deleteViewWithTableSyntax	^false</body><body package="GlorpDatabase">endColumnAddString	"The string we use as a suffix when adding a colum"	^''.</body><body package="GlorpDatabase">hasSubtransaction	"^&lt;Boolean&gt; This method returns true, if the used dbms is able to execute multiple sql-statements	transferred via a command line transmitted from client to server - otherwise I return false"	^true</body><body package="GlorpDatabase">initializeReservedWords	reservedWords := Set new.</body><body package="GlorpDatabase">maxSQLBufferLength	"^&lt;Integer&gt; I return the maximum length of a sql command stream"	^8192</body><body package="GlorpDatabase">maximumLengthOfColumnName	"I am only used in the calculation of recursive column names.  However if I should ever differ from #maximumLengthOfTableName (which is used in all other cases) on some database platform, I can be used in revised truncation logic."	^18</body><body package="GlorpDatabase">maximumLengthOfTableName	^18</body><body package="GlorpDatabase">nameForPrimaryKeyConstraintsWhenDropping	"Return the name we use to describe a constraint when dropping them. This is required because MySQL wants you to use 'DROP PRIMARY KEY' rather than the ANSI 'DROP CONSTRAINT'."	^'CONSTRAINT'.</body><body package="GlorpDatabase">parenthesizeAllButFirstCommandInCompoundQuery	"Access wants parenthesies around all but the first SELECT in a UNION query."	^false</body><body package="GlorpDatabase">parenthesizeCommandsInCompoundQuery: aQuery	^true</body><body package="GlorpDatabase">postfixTableNameBeforeDeleting	^false</body><body package="GlorpDatabase">prefixQualifierBeforeCreatingAndDeleting	^true</body><body package="GlorpDatabase">prefixQualifierSeparatorString	"^&lt;String&gt; This statement return the string to be used to separate the qualifier and the table/column name"	^'.'</body><body package="GlorpDatabase">prefixTableNameBeforeDeleting	^false</body><body package="GlorpDatabase">primaryKeysAreAutomaticallyUnique	"Return false if, in addition to specifying something as a primary key, we must separately specify it as unique"	^false.</body><body package="GlorpDatabase">requiresTransactionForTableOperations	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"	^true.</body><body package="GlorpDatabase">reservedWords	^reservedWords</body><body package="GlorpDatabase">sqlTextCurrentServerUTCTimestamp	self subclassResponsibility</body><body package="GlorpDatabase">sqlTextForBeginTransaction	"comment"	^'BEGIN'</body><body package="GlorpDatabase">sqlTextForDEFAULT: defaultValue	"Answer the column DEFAULT clause as a string with the given value.  This is used in CREATE TABLE statements as part of each column specification."		| strm |	^defaultValue		ifNotNil:			[strm := String new writeStream.			strm nextPutAll: 'DEFAULT '.			defaultValue glorpPrintSQLOn: strm.			strm contents]		ifNil: ['']</body><body package="GlorpDatabase">sqlTextForNOTNULLAttributeConstraint	"^&lt;String&gt;"	^'NOT NULL'</body><body package="GlorpDatabase">sqlTextForNOTNULLWithDefaultAttributeConstraint	"^&lt;String&gt;"	^'NOT NULL WITH DEFAULT'</body><body package="GlorpDatabase">sqlTextForNOTUNIQUEAttributeConstraint	^''.</body><body package="GlorpDatabase">sqlTextForNULLAttributeConstraint	"^&lt;String&gt;"	^'NULL'</body><body package="GlorpDatabase">sqlTextForUNIQUEAttributeConstraint	^'UNIQUE'.</body><body package="GlorpDatabase">sqlWildcardForMultipleCharacters	"^&lt;String&gt; This method returns the used wildcard string for multiple characters"		^'%'</body><body package="GlorpDatabase">sqlWildcardForSingleCharacter	"^&lt;String&gt; This method returns the used wildcard string for single characters"		^'_'</body><body package="GlorpDatabase">startColumnAddString	"The string we use as a prefix when adding a colum"	^' COLUMN '.</body><body package="GlorpDatabase">supportsAuthentication	^true</body><body package="GlorpDatabase">supportsMillisecondsInTimes	self subclassResponsibility.</body><body package="GlorpDatabase">supportsVariableSizedNumerics	"Return true if this platform can support numbers with a varying size and number of decimal places. Access, notably, doesn't seem to be able to"	^true.</body><body package="GlorpDatabase">usesNullForEmptyStrings	"Return true if this database is likely to use nil as an empty string value"	^false.</body><body package="GlorpDatabase">usesNullForFalse	"This has been inlined away in subclass callers;  it is left purely for information.  Return true if this database treats NULL as meaning FALSE when occurring in a boolean column, or an integer column where 1 signifies TRUE and 0 (or NULL) false."	^false</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase">booleanToBooleanConverter	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToDBBoolean:for:		fromDbToSt: #convertDBBooleanToBoolean:for:.</body><body package="GlorpDatabase">booleanToIntegerConverter	^DelegatingDatabaseConverter		named: #booleanToInteger		hostedBy: self		fromStToDb: #convertBooleanToInteger:for:		fromDbToSt: #convertIntegerToBoolean:for:.</body><body package="GlorpDatabase">booleanToStringTFConverter	^DelegatingDatabaseConverter		named: #booleanToString		hostedBy: self		fromStToDb: #convertBooleanToTF:for:		fromDbToSt: #convertTFToBoolean:for:.</body><body package="GlorpDatabase">booleanToStringYNConverter	^DelegatingDatabaseConverter		named: #booleanToString		hostedBy: self		fromStToDb: #convertBooleanToYN:for:		fromDbToSt: #convertYNToBoolean:for:.</body><body package="GlorpDatabase">booleanToStringYesNoConverter	^DelegatingDatabaseConverter		named: #booleanToString		hostedBy: self		fromStToDb: #convertBooleanToYesNo:for:		fromDbToSt: #convertYesNoToBoolean:for:.</body><body package="GlorpDatabase">convertBooleanToDBBoolean: aBoolean for: aType	"Some databases do not treat TRUE and FALSE as first-class types, so may override me to return 1 and 0 or similar (or, when there is not even a bi-valued type to substitute, they may instead override my sender)."	^aBoolean</body><body package="GlorpDatabase">convertBooleanToInteger: aBoolean for: aType	aBoolean isNil ifTrue: [^nil].	^aBoolean ifTrue: [1] ifFalse: [0].</body><body package="GlorpDatabase">convertBooleanToTF: aBoolean for: aType	aBoolean isNil ifTrue: [^aBoolean].	^aBoolean ifTrue: ['T'] ifFalse: ['F'].</body><body package="GlorpDatabase">convertBooleanToYN: aBoolean for: aType	aBoolean isNil ifTrue: [^aBoolean].	^aBoolean ifTrue: ['Y'] ifFalse: ['N'].</body><body package="GlorpDatabase">convertBooleanToYesNo: aBoolean for: aType	aBoolean isNil ifTrue: [^aBoolean].	^aBoolean ifTrue: ['YES'] ifFalse: ['NO'].</body><body package="GlorpDatabase">convertDBBooleanToBoolean: aDBBoolean for: aType	"Databases that lack a first-class boolean type may return 1 and 0 or similar as aDBBoolean."	^aDBBoolean</body><body package="GlorpDatabase">convertIntegerToBoolean: anInteger for: aType	anInteger isNil ifTrue: [^anInteger].	anInteger = 1 ifTrue: [^true].	anInteger = 0 ifTrue: [^false].	self error: 'invalid boolean conversion'.</body><body package="GlorpDatabase">convertTFToBoolean: aString for: aType	aString isNil ifTrue: [^aString].	aString = 'T' ifTrue: [^true].	aString = 'F' ifTrue: [^false].	self error: 'invalid boolean conversion'.</body><body package="GlorpDatabase">convertYNToBoolean: aString for: aType	aString isNil ifTrue: [^aString].	aString = 'Y' ifTrue: [^true].	aString = 'N' ifTrue: [^false].	self error: 'invalid boolean conversion'.</body><body package="GlorpDatabase">convertYesNoToBoolean: aString for: aType	aString isNil ifTrue: [^aString].	aString asUppercase = 'YES' ifTrue: [^true].	aString asUppercase = 'NO' ifTrue: [^false].	self error: 'invalid boolean conversion'.</body><body package="GlorpDatabase">printBoolean: aBoolean for: aType	"Not all database platforms accept TRUE and FALSE, T and F, etc.  Override this in those cases (and ensure the platform's converter named #booleanToBoolean conforms)."	| stream |	stream := WriteStream on: String new.	aBoolean glorpPrintSQLOn: stream.	^stream contents</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase">asTimestamp: anObject for: aType	anObject isNil ifTrue: [^nil].	^anObject class = Time		ifTrue: [Dialect newTimestampFromDate: Date today time: anObject]		ifFalse: [anObject asTimestamp].</body><body package="GlorpDatabase">dateConverter	^DelegatingDatabaseConverter		named: #date		hostedBy: self		fromStToDb: #toDate:for:		fromDbToSt: #readDate:for:.	"#printDate:for:"</body><body package="GlorpDatabase">printDate: aTimestamp isoFormatOn: stream	"Print the date as yyyy-mm-dd"	| monthNumber dayOfMonth |	aTimestamp isNil ifTrue: [^'NULL'].	aTimestamp year printOn: stream.	stream nextPut: $-.	monthNumber := aTimestamp monthIndex.	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: monthNumber).	stream nextPut: $-.	dayOfMonth := aTimestamp dayOfMonth.	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: dayOfMonth).</body><body package="GlorpDatabase">printTime: aTime isoFormatOn: aStream 	self		printTime: aTime		isoFormatOn: aStream		milliseconds: self supportsMillisecondsInTimes.	^self</body><body package="GlorpDatabase">printTime: aTimestamp isoFormatOn: stream milliseconds: aBoolean	"Print the time as hh:mm:ss.mmm"	| ms |	aTimestamp isNil ifTrue: [^nil].	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: aTimestamp hours).	stream nextPut: $:.	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: aTimestamp minutes).	stream nextPut: $:.	stream nextPutAll: (GlorpDatabaseType padToTwoDigits: aTimestamp seconds).	aBoolean ifFalse: [^self].	ms := aTimestamp milliseconds.	ms = 0 ifTrue: [^self].	stream nextPut: $..	stream nextPutAll: (GlorpDatabaseType padToThreeDigits: ms).</body><body package="GlorpDatabase">printTimestamp: aTimestamp on: aStream for: aType	aTimestamp isNil ifTrue: [aTimestamp glorpPrintSQLOn: aStream. ^self].	aStream nextPut: $'; nextPutAll: aTimestamp printString; nextPut: $'.</body><body package="GlorpDatabase">readDate: anObject for: aType	"format '2003-03-13"	anObject isNil ifTrue: [^nil].	anObject class == Date ifTrue: [^anObject].	anObject isString ifTrue: [		^self readDateFromStream: (ReadStream on: anObject) for: aType].	^anObject asDate.</body><body package="GlorpDatabase">readDateFromStream: aStream for: aType	"Seems like we get to do this ourselves, in a lowest common denominator kind of way. Translate into GMT if we've got a timezone."	"assumes ISO format.	self readTimestamp: '2003-03-03 15:29:28.337-05' for: nil.	self readTimestamp: '2003-03-03 19:29:28.337-05' for: nil"	|  years months days |	years := (aStream upTo: $-) asNumber.	months := (aStream upTo: $-) asNumber.	days := (aStream upTo: $ ) asNumber.	^Dialect newDateWithYears: years months: months days: days.</body><body package="GlorpDatabase">readTime: anObject for: aType	"format 15:29:28.337-05  (timezone optional)"	anObject isNil ifTrue: [^nil].	anObject class == Time ifTrue: [^anObject].	anObject isString ifTrue: [		^self readTimeFromStream: (ReadStream on: anObject) for: aType].	^anObject asTime.</body><body package="GlorpDatabase">readTimeFromStream: aStream for: aType	"Seems like we get to do this ourselves, in a lowest common denominator kind of way. Ignore timezones right now"	"assumes ISO format.	self readTimestamp: '2003-03-03 15:29:28.337-05' for: nil.	self readTimestamp: '2003-03-03 19:29:28.337-05' for: nil"	| hours minutes seconds milliseconds timeZoneOffset millisecondAccumulator |	hours := (aStream upTo: $:) asNumber.	minutes := (aStream upTo: $:) asNumber.	seconds := (aStream next: 2) asNumber.	(aStream peek = $.) 		ifTrue: [			aStream next.			millisecondAccumulator := WriteStream on: String new.			[aStream atEnd not and: [aStream peek isDigit]] whileTrue: [				millisecondAccumulator nextPut: aStream next].			milliseconds := millisecondAccumulator contents asNumber]		ifFalse: [milliseconds := 0].	timeZoneOffset := aStream upToEnd asNumber.	^Dialect newTimeWithHours: hours minutes: minutes seconds: seconds milliseconds: milliseconds.	"^Dialect addSeconds: (timeZoneOffset * -1* 60 * 60) to: aTime."</body><body package="GlorpDatabase">readTimestamp: anObject for: aType	"Seems like we get to do this ourselves, in a lowest common denominator kind of way. Translate into GMT if we've got a timezone."	"assumes ISO format.	self readTimestamp: '2003-03-03 15:29:28.337-05' for: nil.	self readTimestamp: '2003-03-03 19:29:28.337-05' for: nil"	anObject isNil ifTrue: [^nil].	anObject class == Dialect timestampClass ifTrue: [^anObject].	anObject isString		ifTrue:			[| stream |			stream := ReadStream on: anObject.			^self readTimestampFromStream: stream for: aType].	^anObject asTimestamp.</body><body package="GlorpDatabase">readTimestampFromStream: aStream for: aType	| years months days hours minutes seconds millisecondAccumulator milliseconds timeZoneOffset |	years := (aStream upTo: $-) asNumber.	months := (aStream upTo: $-) asNumber.	days := (aStream upTo: $ ) asNumber.	hours := (aStream upTo: $:) asNumber.	minutes := (aStream upTo: $:) asNumber.	seconds := (aStream next: 2) asNumber.	(aStream peek = $.) 		ifTrue: [			aStream next.			millisecondAccumulator := WriteStream on: String new.			[aStream atEnd not and: [aStream peek isDigit]] whileTrue: [				millisecondAccumulator nextPut: aStream next].			milliseconds := millisecondAccumulator contents asNumber]		ifFalse: [milliseconds := 0].	timeZoneOffset := aStream upToEnd asNumber.	timeZoneOffset isNil ifTrue: [timeZoneOffset := 0].	timeZoneOffset := timeZoneOffset * 60 * 60.	^Dialect 		newTimestampWithYears: years		months: months		days: days		hours: hours		minutes: minutes		seconds: seconds		milliseconds: milliseconds		offset:timeZoneOffset.</body><body package="GlorpDatabase">timeConverter	^DelegatingDatabaseConverter		named: #time		hostedBy: self		fromStToDb: #toTime:for:		fromDbToSt: #readTime:for:.	"#printTime:for:"</body><body package="GlorpDatabase">timestampConverter	^DelegatingDatabaseConverter		named: #timestamp		hostedBy: self		fromStToDb: #toTimestamp:for:		fromDbToSt: #readTimestamp:for:.	"#printTimestamp:for:"</body><body package="GlorpDatabase">timestampToDateConverter	^DelegatingDatabaseConverter		named: #timestampToDate		hostedBy: self		fromStToDb: #toTimestamp:for:		fromDbToSt: #readDate:for:.</body><body package="GlorpDatabase">toDate: anObject for: aType	"SQL supports adding an integer to a date, meaning incrementing the date by that number of days, so we pass integer values here as well as dates."	anObject isNil ifTrue: [^nil].	anObject class = Date ifTrue: [^anObject].	anObject isInteger ifTrue: [^anObject].	^anObject asDate</body><body package="GlorpDatabase">toTime: anObject for: aType	anObject isNil ifTrue: [^nil].	anObject class = Time ifTrue: [^anObject].	^anObject asTime.</body><body package="GlorpDatabase">toTimestamp: anObject for: aType	"SQL supports adding an integer to a date, meaning incrementing the date by that number of days.  Oracle and SQLServer use Timestamp and Date as synonyms, so we pass integer values here as well as in #toDate:for:."	anObject isNil ifTrue: [^nil].	anObject class = Dialect timestampClass ifTrue: [^anObject].	anObject isInteger ifTrue: [^anObject].	^anObject asTimestamp</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseIdentitySequenceClass	"This method applies only to classes that have both types--database sequences and identity columns.	Currently, only DB2 has both types. The sequence is prefered, and the identity type has minimal support."	self databaseSequenceClass</body><body package="GlorpDatabase">databaseSequenceClass	self subclassResponsibility.</body><body package="GlorpDatabase">newDatabaseIdentitySequenceNamed: aString	"Return an identity sequence, with the given name. This method is useful for platforms	which provide regular sequence objects as well as identity column objects. Glorp uses	sequences when they are available, but pre-existing DB2 tables may contain identity	columns, so we need to be able to recognize them."	^self databaseIdentitySequenceClass named: aString</body><body package="GlorpDatabase">newDatabaseSequenceNamed: aString	"Return a sequence of the type we use, with the given name"	^self databaseSequenceClass named: aString.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>type converters</category><body package="GlorpDatabase">converterNamed: aSymbol	^self converters at: aSymbol ifAbsentPut: [		| converter |		converter := self perform: (aSymbol, 'Converter') asSymbol.		converter name: aSymbol]</body><body package="GlorpDatabase">converters	^converters</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-numbers</category><body package="GlorpDatabase">convertToDouble: aNumber for: type 	aNumber isNil ifTrue: [^nil].	^Dialect coerceToDoublePrecisionFloat: aNumber</body><body package="GlorpDatabase">convertToFloat: aNumber for: aType 	aNumber isNil ifTrue: [^nil].	^aNumber asFloat.</body><body package="GlorpDatabase">convertToInteger: aNumber for: aType 	^aNumber isNil ifTrue: [aNumber] ifFalse: [aNumber asNumber asInteger].</body><body package="GlorpDatabase">convertToNumber: aNumber for: aType	"Convert to an arbitrary numeric type. Make sure our precision matches. *Hate* floating point"	| exponent result |	aNumber isNil ifTrue: [^nil].	aType precision isNil ifTrue: [^aNumber].	aType scale isNil ifTrue: [^aNumber].	(Dialect isScaleOf: aNumber lessThanOrEqualTo: aType scale) ifTrue: [^aNumber].	exponent := Dialect coerceToDoublePrecisionFloat: (10 raisedToInteger: aType precision).	result := (aNumber * exponent) rounded / exponent.	^aNumber isInteger ifTrue: [result rounded] ifFalse: [result]</body><body package="GlorpDatabase">numberToDoubleConverter	^DelegatingDatabaseConverter		named: #numberToDouble		hostedBy: self		fromStToDb: #convertToDouble:for:		fromDbToSt: #convertToDouble:for:.</body><body package="GlorpDatabase">numberToFloatConverter	^DelegatingDatabaseConverter		named: #numberToFloat		hostedBy: self		fromStToDb: #convertToFloat:for:		fromDbToSt: #convertToFloat:for:.</body><body package="GlorpDatabase">numberToIntegerConverter	^DelegatingDatabaseConverter		named: #numberToInteger		hostedBy: self		fromStToDb: #convertToInteger:for:		fromDbToSt: #convertToInteger:for:.</body><body package="GlorpDatabase">numberToNumberConverter	^DelegatingDatabaseConverter		named: #numberToNumber		hostedBy: self		fromStToDb: #convertToNumber:for:		fromDbToSt: #convertToNumber:for:.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-null</category><body package="GlorpDatabase">nullConversion: anObject for: aType	^anObject.</body><body package="GlorpDatabase">nullConverter	^NullConverter new		name: #null.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>general services</category><body package="GlorpDatabase">predefinedKeywords	"Return a list of preserved keywords (strings), which should not be used in database-, table or column names or any othe names in the platform system."	^OrderedCollection new</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">byteArrayToString: aByteArray for: aType	^aByteArray isNil ifTrue: [nil] ifFalse: [Dialect convert: aByteArray toStringWithEncoding: self characterEncoding].</body><body package="GlorpDatabase">byteArrayToStringConverter	^DelegatingDatabaseConverter		named: #byteArrayToString		hostedBy: self		fromStToDb: #convertStringToByteArray:for:		fromDbToSt: #convertByteArrayToString:for:.</body><body package="GlorpDatabase">convertByteArrayToSQLString: aByteArray for: aType	"This is a slightly misleading name. Really what we want is conversion to a Blob-type of field. So if it's a bytearray, we can just let the driver take care of that conversion, but if we're given a string, we should convert it."	^aByteArray isString		ifTrue:			[Dialect				convert: aByteArray				toByteArrayWithEncoding: self characterEncoding]		ifFalse: [aByteArray].</body><body package="GlorpDatabase">convertByteArrayToString: aByteArray for: aType	^aByteArray asString.</body><body package="GlorpDatabase">convertStringToByteArray: aString for: aType	^aString asByteArray.</body><body package="GlorpDatabase">escapeFor: aCharacter	aCharacter = $' ifTrue: [^''''''].	^String with: $\ with: aCharacter.</body><body package="GlorpDatabase">integerToString: anInteger for: aType	anInteger isNil ifTrue: [^nil].	^self padString: anInteger printString for: aType.</body><body package="GlorpDatabase">integerToStringConverter	^DelegatingDatabaseConverter		named: #integerToString		hostedBy: self		fromStToDb: #integerToString:for:		fromDbToSt: #stringToInteger:for:.</body><body package="GlorpDatabase">padString: aString for: aType	"Between 0.3.140.1 and 7.10 inclusive, Glorp trimmed strings that were too long for fixed-length fields.  This is no longer done, so such strings (sometimes too long only because the database platform measuresStringFieldWidthsInBytes and the string has multi-byte characters) will normally cause database errors (intentionally:  overlong strings should not be submitted to such fields)."	| padding |	aString isNil ifTrue: [^nil].	aString isString ifFalse: [self error: 'Invalid data type'].	(self usesNullForEmptyStrings and: [aString isEmpty]) ifTrue: [^nil].	(aType isVariableWidth or: [aString size &gt;= aType width]) ifTrue: [^aString].	padding := String new: aType width - aString size.	padding atAllPut: self paddingCharacter.	^aString , padding</body><body package="GlorpDatabase">padTrimmedString: aString for: aType	| padding trimmed |	aString isNil ifTrue: [^nil].	aString isString ifFalse: [self error: 'Invalid data type'].	(self usesNullForEmptyStrings and: [aString isEmpty]) ifTrue: [^nil].	trimmed := self trimString: aString for: aType.					(aType isVariableWidth or: [trimmed size = aType width]) ifTrue: [^trimmed].	padding := String new: aType width - aString size.	padding atAllPut: self paddingCharacter.	^aString , padding</body><body package="GlorpDatabase">paddingCharacter	^1 asCharacter.</body><body package="GlorpDatabase">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	aStream nextPutAll: 'X'''.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].	aStream nextPut: $'.</body><body package="GlorpDatabase">printEscapedString: aString on: aCommand	"In this method, aCommand only needs its polymorphic stream protocol, but the parameter is sure to be a command, not a stream, if this method is called."	| charsToEscape |	charsToEscape := self charactersThatNeedEscaping.	1 to: aString size do:		[:i || char | char := aString at: i.		(charsToEscape includes: char)			ifTrue: [aCommand nextPutAll: (self escapeFor: char)]			ifFalse: [aCommand nextPut: char]].</body><body package="GlorpDatabase">stringToByteArray: aString for: aType	| string |	string := self unpadString: aString for: aType.	^string isNil ifTrue: [nil] ifFalse: [Dialect convert: string toByteArrayWithEncoding: self characterEncoding].</body><body package="GlorpDatabase">stringToInteger: aString for: aType	| string |	string := self unpadString: aString for: aType.	^string isNil ifTrue: [nil] ifFalse: [string asNumber truncated].</body><body package="GlorpDatabase">stringToStringConverter	^DelegatingDatabaseConverter		named: #stringToString		hostedBy: self		fromStToDb: #padString:for:		fromDbToSt: #unpadString:for:.</body><body package="GlorpDatabase">stringToSymbol: aString for: aType	| string |	string := self unpadString: aString for: aType.	^string isNil ifTrue: [nil] ifFalse: [string asSymbol].</body><body package="GlorpDatabase">stringToTrimmedStringConverter	"Between 0.3.140.1 and 7.10 inclusive, Glorp routinely trimmed strings that were too long for fixed-length fields in the stringToString converter.  It no longer does this, but if a particular Mapping wants trimming (e.g. StoreProperty has a searchString summary field for its comment's text blob, so the longest initial length of text that can be written to the search field is always OK), then assign this converter to the Mapping in the descriptor."	^DelegatingDatabaseConverter		named: #stringToTrimmedString		hostedBy: self		fromStToDb: #padTrimmedString:for:		fromDbToSt: #unpadString:for:</body><body package="GlorpDatabase">symbolToString: aSymbol for: aType	aSymbol isNil ifTrue: [^nil].	^self padString: aSymbol asString for: aType.</body><body package="GlorpDatabase">symbolToStringConverter	^DelegatingDatabaseConverter		named: #symbolToString		hostedBy: self		fromStToDb: #symbolToString:for:		fromDbToSt: #stringToSymbol:for:.</body><body package="GlorpDatabase">toGlorpType: aGlorpType fromString: aString	"Return a Smalltalk instance of the type indicated by aGlorpType."		| aClass |	^aString		ifNotNil:			[aClass := aGlorpType impliedSmalltalkType.			aClass readFrom: aString readStream]</body><body package="GlorpDatabase">trimString: aString for: aType 	| trimmedString length excess |	aType width isNil ifTrue: [^aString].	self measuresStringFieldWidthsInBytes ifFalse: [		^aString size &gt; aType width ifTrue: [aString copyFrom: 1 to: aType width] ifFalse: [aString]].	"If our characters are less than half the number of bytes it can hold, assume it will fit and don't try to do this"	(aString size &lt; (aType width // 2)) ifTrue: [^aString].	"If we're doing defaults that don't map characters to multi-bytes, don't do this"	(#(ascii default) includes: self characterEncoding) ifTrue: [		^aString size &gt; aType width ifTrue: [aString copyFrom: 1 to: aType width] ifFalse: [aString]].	trimmedString := aString.	[length := (Dialect convert: trimmedString toByteArrayWithEncoding: self characterEncoding) size.	excess := length - aType width.	excess &gt; 0 		"Try to be careful and trim as little as possible, while still keeping the number of steps reasonable for large excesses"		ifTrue: [trimmedString := trimmedString copyFrom: 1 to: trimmedString size - ((excess // 2) max: 1)]		ifFalse: [^trimmedString].	true] whileTrue.</body><body package="GlorpDatabase">unpadString: aString for: aType	aString isNil ifTrue: [^nil].	^aType isVariableWidth 		ifTrue: [aString]		ifFalse: [(ReadStream on: aString) upTo: self paddingCharacter]</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>exdi specific</category><body package="GlorpDatabase">exdiTypeForBoolean	^#Boolean</body><body package="GlorpDatabase">exdiTypeForDate	^#Date</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>database-specific</category><body package="GlorpDatabase">compoundOperationFor: aSymbol	"Return the platform specific version of a compound statement symbol."	^aSymbol</body><body package="GlorpDatabase">printOffset: anInteger on: aCommand	"By default, do nothing"</body><body package="GlorpDatabase">printPostLimit: anInteger on: aCommand	"By default, do nothing"</body><body package="GlorpDatabase">printPreLimit: anInteger on: aCommand	"By default, do nothing"</body><body package="GlorpDatabase">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"If aQuery has operations that we don't support, rewrite it to do them in terms of lower level operations. In particular, rewrite INTERSECT/EXCEPT operations into EXISTS clauses in a single query. Pass the new query to aBlock."	^self.</body><body package="GlorpDatabase">withRecursive	"Return the platform-specific version of the keyword(s) that precede a recursive common table expression."	^'WITH'</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>binding</category><body package="GlorpDatabase">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^self subclassResponsibility</body><body package="GlorpDatabase">maximumSizeToGroupWriteFor: aRowBasedCommand	"If we are going to group write, how many rows of this command should we do it for at once."	^aRowBasedCommand allRows size</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>functions</category><body package="GlorpDatabase">functions	^functions</body><body package="GlorpDatabase">initializeFunctions	"Subclasses should override to add database-specific functions"	functions := FunctionExpression createBasicFunctionsFor: self.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services tables</category><body package="GlorpDatabase">createDropTableStatementFor: aTableNameString	"^&lt;String&gt; This method returns a string which can be used to drop a database table ..."	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll: 'DROP TABLE';		space;		nextPutAll: aTableNameString.	^sqlStatementStream contents</body><body package="GlorpDatabase">createTableIndexStatementStringFor: aGLORPDatabaseTable index: aGlorpDatabaseIndex	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream nextPutAll: 'CREATE INDEX '.	sqlStatementStream nextPutAll: aGlorpDatabaseIndex name.	sqlStatementStream nextPutAll: ' ON '.	self printDDLTableNameFor: aGLORPDatabaseTable on: sqlStatementStream.	aGlorpDatabaseIndex printStatementOn: sqlStatementStream platform: self.	^sqlStatementStream contents</body><body package="GlorpDatabase">createTableStatementStringFor: aGLORPDatabaseTable 	"This method returns a string which can be used to create a database table ..."	| sqlStatementStream tmpString |	tmpString := 'create table'.	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll: (self capitalWritingOfSQLCommands 			ifTrue: [tmpString asUppercase]			ifFalse: [tmpString]);		space.	self printDDLTableNameFor: aGLORPDatabaseTable on: sqlStatementStream.	"Now print the columns specification for each field in the table ..."	self 		printColumnsSpecificationFor: aGLORPDatabaseTable		on: sqlStatementStream.	self supportsConstraints ifTrue:		[aGLORPDatabaseTable hasPrimaryKeyConstraints ifTrue: 			[sqlStatementStream nextPutAll: ', '.			(aGLORPDatabaseTable primaryKeyConstraints creationStringFor: self)				do: [ :each | sqlStatementStream nextPutAll: each.]				separatedBy: [sqlStatementStream nextPut: $,]].		aGLORPDatabaseTable hasUniqueConstraints ifTrue:			[sqlStatementStream nextPutAll: ', '.			aGLORPDatabaseTable uniqueConstraints do:				[:each | sqlStatementStream nextPutAll: (each creationString)]				separatedBy: [sqlStatementStream nextPut: $,]]].	sqlStatementStream		nextPut: $).	^sqlStatementStream contents</body><body package="GlorpDatabase">ddlTableNameFor: aTableOrString	"	Either a databaseTable or a string can be passed in the argument.	"	^ aTableOrString isString		ifTrue: [ self capitalWritingOfTableName 			ifTrue: [ aTableOrString asUppercase ] 			ifFalse:[ aTableOrString ] ]		ifFalse: [ self ddlTableNameFor: aTableOrString qualifiedName ]</body><body package="GlorpDatabase">printDDLTableNameFor: aGLORPDatabaseTable on: sqlStatementStream	"This method just writes the name of a table to a stream, in a way appropriate for DDL statements."		sqlStatementStream nextPutAll:		(self capitalWritingOfTableName			ifTrue: [aGLORPDatabaseTable qualifiedName asUppercase]			ifFalse: [aGLORPDatabaseTable qualifiedName]).</body><body package="GlorpDatabase">printSqlStatementToListTablesInSchema: schemaString on: aStream	" Not standardized, although SQL Server, MySQL and PostgreSQL use the INFORMATION_SCHEMA "	| lowerSchema |	self usesInformationSchema		ifFalse: [^self subclassResponsibility].	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT table_name FROM information_schema.tables ';		nextPutAll: 'WHERE table_type = ';		nextPut: $';		nextPutAll: 'BASE TABLE';		nextPut: $'.	(lowerSchema notNil and: [lowerSchema notEmpty])		ifTrue: [			aStream				nextPutAll: ' AND lower(table_schema) = ';				nextPut: $';				nextPutAll: lowerSchema;				nextPut: $'.].	aStream nextPut: $;</body><body package="GlorpDatabase">printSqlStatementToRenameTable: aDatabaseTable to: newTableName on: aStream	" Tje default SQL statement is	ALTER TABLE &lt;oldTableName&gt; RENAME TO &lt;newTableName&gt;.	Different platforms may use another form. Override in subclasses if necessary.	"	aStream		nextPutAll: 'ALTER TABLE ';		nextPutAll: (self ddlTableNameFor: aDatabaseTable);		nextPutAll: ' RENAME TO ';		nextPutAll: newTableName</body><body package="GlorpDatabase">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	" Not standardized, although SQL Server, MySQL and PostgreSQL use the INFORMATION_SCHEMA "	| lowerTableName lowerSchema |	self usesInformationSchema		ifFalse: [^self subclassResponsibility].	lowerTableName := tableName asLowercase.	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT count(*) FROM information_schema.tables ';		nextPutAll: 'WHERE lower(table_name) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $'.	(lowerSchema notNil and: [lowerSchema notEmpty])		ifTrue: [			aStream				nextPutAll: ' AND lower(table_schema) = ';				nextPut: $';				nextPutAll: lowerSchema;				nextPut: $'.].	aStream		nextPutAll: ' AND table_type = ';		nextPut: $';		nextPutAll: 'BASE TABLE';		nextPut: $';		nextPut: $;</body><body package="GlorpDatabase">sqlStatementToListTablesInSchema: schemaString	| stream |	stream := WriteStream on: String new.	self printSqlStatementToListTablesInSchema: schemaString on: stream.	^stream contents</body><body package="GlorpDatabase">sqlStatementToRenameTable: aDatabaseTable to: newTableName	| stream |	stream := WriteStream on: String new.	self printSqlStatementToRenameTable: aDatabaseTable to: newTableName on: stream.	^ stream contents</body><body package="GlorpDatabase">sqlStatementToTestExistenceOfTable: tableName inSchema: schemaString	| stream |	stream := WriteStream on: String new.	self printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: stream.	^stream contents</body><body package="GlorpDatabase">tableNameFor: aStringRepresentingATableName	"Return the table name, as modified to be used in a database statement."	^aStringRepresentingATableName.</body><body package="GlorpDatabase">validateTableName: tableNameString	" &lt;Boolean&gt; I return true, if the choosen tableNameString is valid for the platform" 	^( tableNameString size &lt;= self maximumLengthOfTableName ) 			and: [ (self predefinedKeywords includes: tableNameString asLowercase) not ]</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>accessing</category><body package="GlorpDatabase">characterEncoding	^characterEncoding</body><body package="GlorpDatabase">characterEncoding: anEncodingName	characterEncoding := anEncodingName.</body><body package="GlorpDatabase">vwConnectionClass	^self isODBCPlatform		ifTrue: [self vwODBCConnectionClass]		ifFalse: [self vwEXDIConnectionClass]</body><body package="GlorpDatabase">vwEXDIConnectionClass	^self subclassResponsibility</body><body package="GlorpDatabase">vwODBCConnectionClass	"Prefer Threaded over not if nothing is loaded, but use whatever is loaded if there is anything"	'ODBCThreadedConnection' asQualifiedReference ifDefinedDo:		[:class | ^class].	'ODBCConnection' asQualifiedReference ifDefinedDo:		[:class | ^class].		^'ODBCThreadedConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'ODBCThapiEXDI'</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services columns</category><body package="GlorpDatabase">createAddColumnStatementFor: aField	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: stream.	stream		space;		nextPutAll: ' ADD ';		nextPutAll: self startColumnAddString.	self  printColumn: aField on: stream.	stream nextPutAll: self endColumnAddString.	^stream contents</body><body package="GlorpDatabase">createAlterColumnStatement: aField newType: aType	^self createAlterColumnStatement: aField newType: aType usingExpression: nil</body><body package="GlorpDatabase">createAlterColumnStatement: aField newType: aType usingExpression: expression	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  ' TYPE ';		nextPutAll: aType typeString.	expression ifNotNil: [ sqlStatementStream nextPutAll: ' USING ', expression ].	^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatement: aField setDefault: anObject	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'SET DEFAULT';		space.	anObject printOn: sqlStatementStream.		^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementDropDefault: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DROP DEFAULT '.	^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementDropNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DROP';		space;		nextPutAll:  self sqlTextForNOTNULLAttributeConstraint.		^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementSetNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'SET';		space;		nextPutAll:  self sqlTextForNOTNULLAttributeConstraint.		^sqlStatementStream contents</body><body package="GlorpDatabase">createDropColumnStatementFor: aField	| stream |	stream := WriteStream on: String new.	stream 		nextPutAll: 'ALTER TABLE';		space.	self printDDLTableNameFor: aField table  on: stream.	stream		space;		nextPutAll: 'DROP COLUMN';		space;		nextPutAll: (self nameForColumn: aField name).			^stream contents</body><body package="GlorpDatabase">endColumnQuote	"Return the character used to stop quoting the name of a column so that we can avoid conflicts with reserved names. ANSI says to use double quotes, so that's the default."	^'"'.</body><body package="GlorpDatabase">nameForColumn: aColumnString	| upper |	upper := self capitalWritingOfColumnName ifTrue: [aColumnString asUppercase] ifFalse: [aColumnString].	(self reservedWords includes: aColumnString asLowercase) ifFalse: [^upper].	^self startColumnQuote, upper, self endColumnQuote.</body><body package="GlorpDatabase">printColumn: eachGlorpDatabaseField on: sqlStatementStream	"Print the column specification for the CREATE TABLE statement.  Don't show a default value for serial columns, since their semaitics are different."	sqlStatementStream		nextPutAll: (self nameForColumn: eachGlorpDatabaseField name);		space;		nextPutAll: eachGlorpDatabaseField typeString;		space;		nextPutAll: (eachGlorpDatabaseField type isSerial					ifTrue: ['']					ifFalse: [self sqlTextForDEFAULT: eachGlorpDatabaseField dbDefaultValue]);		space;		nextPutAll: (eachGlorpDatabaseField isNullable					ifTrue: [self sqlTextForNULLAttributeConstraint]					ifFalse: [self sqlTextForNOTNULLAttributeConstraint]);		space;		nextPutAll: (eachGlorpDatabaseField isUnique					ifTrue: [self sqlTextForUNIQUEAttributeConstraint]					ifFalse: [self sqlTextForNOTUNIQUEAttributeConstraint]).</body><body package="GlorpDatabase">printColumnsSpecificationFor: aGlorpDatabaseTable on: sqlStatementStream	aGlorpDatabaseTable fields isEmpty not		ifTrue:			[| sepFlag |			sqlStatementStream				space;				nextPut: $(.			sepFlag := false.			aGlorpDatabaseTable fields				do:					[:eachGlorpDatabaseField | 					sepFlag						ifTrue:							[sqlStatementStream nextPutAll: self columnNameSeparatorString].					self printColumn: eachGlorpDatabaseField on: sqlStatementStream.					sepFlag := true]].</body><body package="GlorpDatabase">printSqlStatementToCopyDataFromColumn: fromColumn to: toColumn on: aStream	"	Example:	UPDATE test_bank_acct	SET close_balance = balance	WHERE close_balance IS NULL OR close_balance &lt;&gt; balance	"	| toColumnName fromColumnName |	toColumnName := self nameForColumn: toColumn name.	fromColumnName := self nameForColumn: fromColumn name.	aStream		nextPutAll: 'UPDATE ';		nextPutAll: (self ddlTableNameFor: fromColumn table);		nextPutAll: ' SET ';		nextPutAll: toColumnName;		nextPutAll: ' = ';		nextPutAll: fromColumnName;		nextPutAll: ' WHERE ';		nextPutAll: toColumnName;		nextPutAll: ' IS NULL OR ';		nextPutAll: toColumnName;		nextPutAll: ' &lt;&gt; ';		nextPutAll: fromColumnName</body><body package="GlorpDatabase">printSqlStatementToCopyDataFromTable: fromTable to: toTable on: aStream	aStream		nextPutAll: 'INSERT INTO ';		nextPutAll: (self ddlTableNameFor: toTable);		nextPutAll: ' ( '.	GlorpHelper 		print: [:each | self nameForColumn: each name]		on: aStream		for: fromTable fields		separatedBy: ','.	aStream		nextPutAll: ' ) ';		nextPutAll: ' SELECT '.	GlorpHelper 		print: [:each | self nameForColumn: each name]		on: aStream		for: fromTable fields		separatedBy: ','.	aStream		nextPutAll: ' FROM ';		nextPutAll: (self ddlTableNameFor: fromTable)</body><body package="GlorpDatabase">printSqlStatementToPopulateColumn: aDatabaseField with: aValue on: aStream	| converter dbValue |	converter := aDatabaseField converterForStType: aValue class.	dbValue := converter		convert: aValue		toDatabaseRepresentationAs: aDatabaseField type.	aStream		nextPutAll: 'UPDATE ';		nextPutAll: (self ddlTableNameFor: aDatabaseField table);		nextPutAll: ' SET ';		nextPutAll: (self nameForColumn: aDatabaseField name);		nextPutAll: ' = ';		nextPutAll: dbValue printString;		nextPutAll: ' WHERE (';		nextPutAll: ( self nameForColumn: aDatabaseField name);		nextPutAll: ' IS NULL OR ';		nextPutAll: (self nameForColumn: aDatabaseField name);		nextPutAll: ' &lt;&gt; ';		nextPutAll: dbValue printString;		nextPutAll: ')'</body><body package="GlorpDatabase">printSqlStatementToRenameColumn: oldColumn to: newColumnName on: aStream	aStream		nextPutAll: 'ALTER TABLE ';		nextPutAll: (self ddlTableNameFor: oldColumn table);		nextPutAll: ' RENAME ';		nextPutAll:  (self nameForColumn:  oldColumn name);		nextPutAll: ' TO ';		nextPutAll:  (self nameForColumn: newColumnName).</body><body package="GlorpDatabase">sqlStatementToCopyDataFromColumn: fromDatabaseField to: toDatabaseField	| stream |	stream := WriteStream on: String new.	self		printSqlStatementToCopyDataFromColumn: fromDatabaseField		to: toDatabaseField		on: stream.	^ stream contents</body><body package="GlorpDatabase">sqlStatementToCopyDataFromTable: fromDatabaseTable to: toDatabaseTable	| stream |	stream := WriteStream on: String new.	self		printSqlStatementToCopyDataFromTable: fromDatabaseTable		to: toDatabaseTable		on: stream.	^ stream contents</body><body package="GlorpDatabase">sqlStatementToPopulateColumn: aDatabaseField with: aValue	| stream |	stream := WriteStream on: String new.	self		printSqlStatementToPopulateColumn: aDatabaseField		with: aValue		on: stream.	^ stream contents</body><body package="GlorpDatabase">sqlStatementToRenameColumn: oldColumn to: newColumnName	| stream |	stream := WriteStream on: String new.	self		printSqlStatementToRenameColumn: oldColumn		to: newColumnName		on: stream.	^ stream contents</body><body package="GlorpDatabase">startColumnQuote	"Return the character used to start quoting the name of a column so that we can avoid conflicts with reserved names. ANSI says to use double quotes, so that's the default."	^'"'.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>type helpers</category><body package="GlorpDatabase">typesWithValues	"Return our types list, after making sure it has at least basic types in it."	self varchar.	self int4.	self integer.	self int.	self number.	self timestamp.	self char.	self blob.	self clob.	self serial.	self text.	self boolean.	^self types</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>services constraints</category><body package="GlorpDatabase">createConstraintAddStatement:  aConstraint	| sqlStatementStream |	self supportsConstraints ifFalse: [^''].	aConstraint shouldCreateInDatabase ifFalse: [^''].	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aConstraint table on: sqlStatementStream.	(aConstraint creationStringFor: self)		do: [ :each | sqlStatementStream nextPutAll: ' ADD ', each.]		separatedBy: [sqlStatementStream nextPut: $,].	^sqlStatementStream contents</body><body package="GlorpDatabase">createConstraintDropStatement: aConstraint	| aStream |	self supportsConstraints ifFalse: [^''].	aConstraint shouldCreateInDatabase ifFalse: [^''].	aStream := WriteStream on: (String new: 50).	aStream nextPutAll: 'ALTER TABLE '.	self printDDLTableNameFor: aConstraint table on: aStream.	aStream nextPutAll: ' DROP '.	self writeConstraintToDrop: aConstraint onStream: aStream.	^aStream contents.</body><body package="GlorpDatabase">createForeignKeyConstraintAddStatement: aForeignKeyConstraint	"Callback from the ForeignKeyConstraint. Returns collection of statements "	| ws |	aForeignKeyConstraint shouldCreateInDatabase ifFalse: [^#('')].	ws := WriteStream on: (String new: 50).	ws		nextPutAll: 'CONSTRAINT ';		nextPutAll: aForeignKeyConstraint name;		nextPutAll: ' FOREIGN KEY ('.	GlorpHelper print: [:each | each name] on: ws for: aForeignKeyConstraint sourceFields separatedBy: ','.	ws 	nextPutAll: ') REFERENCES ';		nextPutAll: aForeignKeyConstraint targetTable qualifiedName;		nextPutAll: ' ('.	GlorpHelper print: [:each | each name] on: ws for: aForeignKeyConstraint targetFields separatedBy: ','.	ws nextPutAll: ')'.	aForeignKeyConstraint suffixExpression isNil		ifFalse:			[ws				space;				nextPutAll: aForeignKeyConstraint suffixExpression].	^OrderedCollection with: ws contents.</body><body package="GlorpDatabase">createPrimaryKeyConstraintAddStatement: aPrimaryKeyConstraint	"Callback from the PrimaryKeyConstraint. Returns collection of statements "	| aStream statements |	aPrimaryKeyConstraint shouldCreateInDatabase ifFalse: [^''].	statements := OrderedCollection new.	aStream := WriteStream on: String new.	aStream nextPutAll: 'CONSTRAINT '.	aStream nextPutAll: aPrimaryKeyConstraint name.	aStream nextPutAll: ' PRIMARY KEY  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: aPrimaryKeyConstraint primaryKeyFields		separatedBy: ','.	aStream nextPut: $).	statements add: aStream contents.	self primaryKeysAreAutomaticallyUnique ifTrue: [^statements].	aStream reset.	aStream nextPutAll: ' CONSTRAINT '.	aStream nextPutAll: (self usesPrimaryKeyUniqueConstraintNames 							ifTrue: [aPrimaryKeyConstraint table name, '_UNIQ'] 							ifFalse: ['']).	aStream nextPutAll: ' UNIQUE  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: aPrimaryKeyConstraint  primaryKeyFields		separatedBy: ','.	aStream nextPut: $).	statements add: aStream contents.	^statements</body><body package="GlorpDatabase">createUniqueConstraintAddStatement: aUniqueConstraint	"Callback from the UniqueConstraint. Returns collection of statements "		| stream |	aUniqueConstraint shouldCreateInDatabase ifFalse: [^#('')].	stream := WriteStream on: (String new: 50).	stream		nextPutAll: 'CONSTRAINT ';		nextPutAll: aUniqueConstraint name;		nextPutAll: ' UNIQUE ('.	GlorpHelper 		print: [:each | each name] 		on: stream 		for: aUniqueConstraint fields 		separatedBy: ','.	stream nextPutAll: ')'.	^OrderedCollection with: stream contents</body><body package="GlorpDatabase">writeConstraintToDrop: aConstraint onStream: aStream	aStream		nextPutAll: 'CONSTRAINT ';		nextPutAll: aConstraint name.</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>obsolete</category><body package="GlorpDatabase">printPrimaryKeyConstraintsOn: sqlStatementStream for: aTable 	"This method print the constraint specification on sqlStatementStream"	aTable primaryKeyFields isEmpty ifTrue: [^self].	(self createPrimaryKeyConstraintAddStatement: aTable primaryKeyConstraints)		do: [ :each | sqlStatementStream nextPutAll: each].</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"Database servers and clients have configuration parameters.  We may need to read or set them."</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	^InsertCommand		forRows: aCollectionOfDatabaseRows		useBinding: aBoolean		session: aSession</body><body package="GlorpDatabase">relativeUpdateCommand	"Subclasses override me if they can not only write a relative update but also return the post-updated value of the field.  Those that cannot do so must use this command, and trust users to know that the actual value of a relatively-updated field must be re-read explicitly, or the objects holding the no-longer-trustworthy relatively-updated values discarded."	^RelativeUpdateCommand</body><body package="GlorpDatabase">updateCommandForRow: aDatabaseRow binding: aBoolean session: aSession	^(aDatabaseRow fields anySatisfy: [:each | each type isRelativeType])		ifFalse: [UpdateCommand forRow: aDatabaseRow useBinding: aBoolean session: aSession]		ifTrue: [self relativeUpdateCommand forRow: aDatabaseRow useBinding: aBoolean session: aSession]</body><body package="GlorpDatabase">updateCommandForRows: someDatabaseRows binding: aBoolean session: aSession	^(someDatabaseRows first fields anySatisfy: [:each | each type isRelativeType])		ifFalse: [UpdateCommand forRows: someDatabaseRows useBinding: aBoolean session: aSession]		ifTrue: [self relativeUpdateCommand forRows: someDatabaseRows useBinding: aBoolean session: aSession]</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>utility</category><body package="GlorpDatabase">isVersion: aReferenceIntegerArray notNewerThan: aCurrentIntegerOrStringArray	"In order, look for a number in the first parameter that is either higher or lower than that in the same place in the second parameter, continuing to the next pair if the current pair are equal.  Return true if we reach the end of the first array without finding an unequal pair.  Return false if the first parameter is longer than the second."	1 to: aReferenceIntegerArray size do:		[:index || eachVersionNumber eachReferenceNumber |		aCurrentIntegerOrStringArray size &lt; index ifTrue: [^false].		eachVersionNumber := (aCurrentIntegerOrStringArray at: index) asNumber.		eachReferenceNumber := aReferenceIntegerArray at: index.		eachVersionNumber = eachReferenceNumber ifFalse:			[^eachVersionNumber &gt; eachReferenceNumber]].	^true</body></methods><methods><class-id>Glorp.DatabasePlatform</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"We hope the characterEncoding will be set appropriately for the connection, but make sure the default is fairly harmless, and will in most cases complain rather than write characters incorrectly."	characterEncoding := #ascii.	types := IdentityDictionary new.	converters := IdentityDictionary new.	self initializeReservedWords.	self initializeFunctions.</body></methods><methods><class-id>Glorp.DatabasePlatform class</class-id> <category>*eoglorp</category><body package="GlorpDatabase">createLoginFromConnectionDictionary: aDict 	self subclassResponsibility</body><body package="GlorpDatabase">loginWithConnectionDictionary: aDict 	| platformClass |	platformClass := self allSubclasses		detect: [:cls | cls understandsConnectionDictionary: aDict].	^platformClass isNil ifFalse:		[platformClass createLoginFromConnectionDictionary: aDict]</body><body package="GlorpDatabase">understandsConnectionDictionary: aDict	^false</body></methods><methods><class-id>Glorp.DatabasePlatform class</class-id> <category>testing</category><body package="GlorpDatabase">useBindingByDefault	^true</body><body package="GlorpDatabase">useBindingIfSupported	"If I am nil (the default), each platform that supportsBinding lazily initializes to its defaultUseBinding value.  If I have a value, I force lazy initialization of each platform that supportsBinding to my value.  Normally, a value is set only for specific testing purposes."	UseBindingIfSupported isNil ifTrue: [^self useBindingByDefault].	^UseBindingIfSupported</body><body package="GlorpDatabase">useBindingIfSupported: aBooleanOrNil	"If I am nil (the default), each platform that supportsBinding lazily initializes to its defaultUseBinding value.  If I have a value, I force lazy initialization of each platform that supportsBinding to my value.  Normally, a value is set only for specific testing purposes."	UseBindingIfSupported := aBooleanOrNil.</body></methods><methods><class-id>Glorp.DatabasePlatform class</class-id> <category>constants</category><body package="GlorpDatabase">allReservedWords	| words |	words := IdentityDictionary new.	self allSubclasses do: [:each | words at: each put: each reservedWords].	^words</body><body package="GlorpDatabase">reservedWords		^Set new.</body></methods><methods><class-id>Glorp.DatabasePlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	"Answer a string showing representing the type of DMBS for which the receiver provides services.  Return nil if the class is abstract, not itself usable to connect to a database.  The kind symbol is also be used to sort lists of platform classes."	^nil</body></methods><methods><class-id>Glorp.DatabasePlatform class</class-id> <category>instance creation</category><body package="GlorpDatabase">new	^super new initialize</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated	^false.</body><body package="GlorpDatabase">charactersThatNeedEscaping	^#($' $\)</body><body package="GlorpDatabase">defaultOptimalINClauseLimit	"MySQL users report that anything over 100 degrades performance significantly"	^100</body><body package="GlorpDatabase">initializeReservedWords	super initializeReservedWords.	reservedWords 		add: 'key'.</body><body package="GlorpDatabase">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)	Don't know the answer for this platform;  make something large up."	^64</body><body package="GlorpDatabase">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	"Don't know, make something large up."	^64</body><body package="GlorpDatabase">nameForPrimaryKeyConstraintsWhenDropping	"Return the name we use to describe a constraint when dropping them. This is required because MySQL wants you to use 'DROP PRIMARY KEY' rather than the ANSI 'DROP CONSTRAINT'."	^'PRIMARY KEY'.</body><body package="GlorpDatabase">supportsMillisecondsInTimes	^false.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>types</category><body package="GlorpDatabase">blob	"Return the MySQL type for long blob."	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'LONGBLOB'].</body><body package="GlorpDatabase">boolean	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'integer']</body><body package="GlorpDatabase">clob	"Return the MySQL type for long text."	^self typeNamed: #clob ifAbsentPut: [GlorpMySQLClobType new typeString: 'LONGTEXT'].</body><body package="GlorpDatabase">date	"Return the type we use to represent dates."	^self typeNamed: #date ifAbsentPut: [GlorpDateType new].</body><body package="GlorpDatabase">double	^self typeNamed: #double ifAbsentPut: [GlorpDoubleType new typeString: 'double' ].</body><body package="GlorpDatabase">float	^self typeNamed: #float ifAbsentPut: [GlorpFloatType new typeString: 'float' ].</body><body package="GlorpDatabase">float4	^self float.</body><body package="GlorpDatabase">float8	^self double.</body><body package="GlorpDatabase">int2	^self smallint</body><body package="GlorpDatabase">int4	^self typeNamed: #int4 ifAbsentPut: [GlorpIntegerType new typeString: 'int'].</body><body package="GlorpDatabase">int8	^self typeNamed: #int8 ifAbsentPut: [GlorpIntegerType new typeString: 'bigint'].</body><body package="GlorpDatabase">integer	^self typeNamed: #integer ifAbsentPut: [GlorpIntegerType new typeString: 'int'].</body><body package="GlorpDatabase">number	^self typeNamed: #number ifAbsentPut: [GlorpNumericType new typeString: 'decimal'].</body><body package="GlorpDatabase">sequence	^self serial.</body><body package="GlorpDatabase">serial	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'int AUTO_INCREMENT'].</body><body package="GlorpDatabase">smallint	^self typeNamed: #smallint ifAbsentPut: [GlorpSmallIntType new typeString: 'SMALLINT'].</body><body package="GlorpDatabase">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time'].</body><body package="GlorpDatabase">timestamp	"Although MySQL has a type called 'timestamp', 'datetime' is more suitable."	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'DATETIME'].</body><body package="GlorpDatabase">typeWithDatabaseName: aString characterWidth: aNumber extraInformation: extraValue	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now.  If the type is integer, return integer type, not boolean for now."	extraValue = 'auto_increment' ifTrue: [^self serial].	aString asLowercase = 'integer' ifTrue: [^self integer].	^super typeWithDatabaseName: aString characterWidth: aNumber</body><body package="GlorpDatabase">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new].</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>testing</category><body package="GlorpDatabase">canUseInWhereClause: aValue type: aType	"This is mostly for test support purposes. If we know we can't use a particular kind of value in the where clause on some database, don't try."	(super canUseInWhereClause: aValue type: aType) ifFalse: [^false].	"On MySQL we don't seem to be able to compare constants against blobs."	aType = self blob ifTrue: [^false].	^true.</body><body package="GlorpDatabase">isMySQLPlatform	^true.</body><body package="GlorpDatabase">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^true.</body><body package="GlorpDatabase">supportsBinding	"MySQL supports binding, although early versions didn't."	^true.</body><body package="GlorpDatabase">supportsCompositeKeyArgsForOperand: aSymbol	"In MySQL			composite-row = subquery LIMIT 1passes but	composite-row IN subquery LIMIT 1fails with:	This version of MySQL doesn''t yet support ''LIMIT &amp; IN/ALL/ANY/SOME subqueryThe first query does exactly the same uses LIMIT in a subquery but in the special case of 1 and =.  That means we can handle #readOneOf: cases but not general setting of #limit: with alsoFetch using IN.  For IN we must use the longhand solution: ANDed single-key queries."	^aSymbol ~~ #IN	"We assume aSymbol can only be #IN or #= or #&lt;&gt;"</body><body package="GlorpDatabase">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place"	^false.</body><body package="GlorpDatabase">supportsDuplicateFieldNamesInCompoundQueries	"Absurdly, Oracle, SQLServer and MySQL will not tolerate two unaliased fields in different tables but of the same name in a compound query, so the second (and subsequent) such fields must be aliased."	^false</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	"MySQL does not support batched statements, i.e. cannot do INSERT ...; INSERT ...; INSERT... , but since version 5.0 it does support value sequences, i.e. it can do INSERT INTO table (id, c) VALUES (1,'1'), (2,'2'), (3,'3')."	^aCommand supportsGroupWriting and: [aCommand supportsGroupWritingValues]</body><body package="GlorpDatabase">supportsGroupWritingValues	"Return true if we support multiple rows in a single INSERT statement, like this:	INSERT INTO table (id, city, state) VALUES (1, 'Boston', 'MA'), (2, 'New York',  'NY'), (3, 'San Francisco', 'CA')."	^supportsGroupWritingValues ifNil: [false]</body><body package="GlorpDatabase">supportsIntersect	"Do we support operations like UNION ALL And INTERSECT."	^false.</body><body package="GlorpDatabase">supportsLimit	"Do we support LIMIT ... (or something analogous to it), returning only the first N rows."	^true</body><body package="GlorpDatabase">supportsOffset	"Do we support OFFSET ... (or something analogous to it), skipping the first N rows."	^true</body><body package="GlorpDatabase">usesIdentityColumns	^true.</body><body package="GlorpDatabase">usesInformationSchema	^true</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	^true</body><body package="GlorpDatabase">usesPrimaryKeyUniqueConstraintNames	"When dropping/creating primary key constraints, do they have distinguished names."	^false.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services tables</category><body package="GlorpDatabase">endColumnQuote	"Return the character used to start quoting the name of a column so that we can avoid conflicts with reserved names. The default MySQL quoting is to use backquotes rather than the ANSI style."	^'`'.</body><body package="GlorpDatabase">startColumnQuote	"Return the character used to start quoting the name of a column so that we can avoid conflicts with reserved names. The default MySQL quoting is to use backquotes rather than the ANSI style."	^'`'.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>binding</category><body package="GlorpDatabase">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase">printDate: aDate for: aType	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $".	self		printDate: aDate		isoFormatOn: stream.	stream nextPut: $".	^stream contents.</body><body package="GlorpDatabase">printTime: aTime for: aType	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $".	self		printTime: aTime		isoFormatOn: stream		milliseconds: false.	stream nextPut: $".	^stream contents.</body><body package="GlorpDatabase">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPut: $".	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ' '.	self		printTime: aTimestamp		isoFormatOn: stream		milliseconds: false.	stream nextPut: $".</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">stringToByteArrayOneWayConverter	"This is a special converter for MySQL that is a null conversion on the way out, but converts the byte arrays that we get back from blobs into strings."	^DelegatingDatabaseConverter		named: #stringToByteArrayOneWay		hostedBy: self		fromStToDb: #nullConversion:for:		fromDbToSt: #byteArrayToString:for:.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseSequenceClass	^MySQLSequence.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>database-specific</category><body package="GlorpDatabase">printOffset: anInteger on: aCommand	"MySQL cannot have an offset without a limit.  A very large number, like 256T, is equivalent to an infinite limit. We only print it here if there is no limit, but there is an offset."	aCommand query hasLimit ifFalse:		[self printPostLimit: SmallInteger maxVal on: aCommand].	aCommand nextPutAll: ' OFFSET '.	anInteger printOn: aCommand.</body><body package="GlorpDatabase">printPostLimit: anInteger on: aCommand    aCommand        nextPutAll: ' LIMIT '.    anInteger printOn: aCommand.</body><body package="GlorpDatabase">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"If aQuery has operations that we don't support, rewrite it to do them in terms of lower level operations. In particular, rewrite INTERSECT/EXCEPT operations into EXISTS clauses in a single query. Pass the new query to aBlock."	| newQuery |	newQuery := aQuery rewriteIntersect.	newQuery := newQuery rewriteExcept.	newQuery == aQuery ifFalse: [aBlock value: newQuery].</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>accessing</category><body package="GlorpDatabase">vwEXDIConnectionClass	^'MySQLConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'MySQLEXDI'</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>services constraints</category><body package="GlorpDatabase">writeConstraintToDrop: aConstraint onStream: aStream	"Return the term we use to describe a constraint when dropping them.  This is required because MySQL wants you to use		'DROP PRIMARY KEY' for primary key constraints (and then says don't name the constraint name in the drop statement!)		'DROP FOREIGN KEY'  for foreign key constraints		'DROP KEY' for unique constraints (it also supports DROP INDEX for this)	rather than the ANSI 'DROP CONSTRAINT'."	aConstraint isForeignKeyConstraint ifTrue: [aStream nextPutAll: 'FOREIGN KEY'].	aConstraint isPrimaryKeyConstraint ifTrue: [aStream nextPutAll: 'PRIMARY KEY'].	aConstraint isUniqueConstraint ifTrue: [aStream nextPutAll: 'KEY'].	aConstraint isPrimaryKeyConstraint ifFalse:		[aStream			nextPut: $ ;			nextPutAll: aConstraint name].</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>functions</category><body package="GlorpDatabase">initializeFunctions	super initializeFunctions.	functions at: #regexMatches: put: (InfixFunction named: 'REGEXP').</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	"I cannot group ;-separated INSERT statements but (if I am new enough - version 5 or later) I can group ,-separated values following a single INSERT statement.  I answer true to usesIdentityColumns;  if I am writing to a serial type (an identity column), the server will assign the value(s) and I must use a command that knows how to retrieve and assign them."	^self supportsGroupWritingValues		ifFalse: [InsertCommand forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession]		ifTrue: [InsertIdentityColumnCommand				forRows: aCollectionOfDatabaseRows				useBinding: aBoolean				session: aSession				ifNoIdentityColumn: InsertMultiValuesCommand]</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"MySQL has been supporting group writing with the VALUES clause at least since version 5.0."	| dbmsMajorVersion |	dbmsMajorVersion := (aDatabaseAccessor connection dbmsVersion readStream upTo: $.) asNumber.	supportsGroupWritingValues := dbmsMajorVersion &gt;= 5.</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase">booleanToBooleanConverter	"MySQL uses integers to represent booleans in the database.  Therefore this conversion between Glorp boolean and database boolean actually converts between boolean and integer."	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToInteger:for:		fromDbToSt: #convertIntegerToBoolean:for:</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>exdi specific</category><body package="GlorpDatabase">exdiTypeForBoolean	"MySQL has no boolean type.  MySQLEXDI maps booleans to in8s on writing, but not back on reading."	^#Integer</body></methods><methods><class-id>Glorp.MySQLPlatform</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"MySQL has been supporting group writing with the VALUES clause at least since version 5.0.  For safety, we initialize to false, resetting in postLoginInitializeFromAccessor:."	super initialize.	supportsGroupWritingValues := false.</body></methods><methods><class-id>Glorp.MySQLPlatform class</class-id> <category>constants</category><body package="GlorpDatabase">reservedWords	^#('accessible' 'add' 'all' 'alter' 'analyze' 'and' 'as' 'asc' 'asensitive' 'before' 'between' 'bigint' 'binary' 'blob' 'both' 'by' 'call' 'cascade' 'case' 'change' 'char' 'character' 'check' 'collate' 'column' 'condition' 'constraint' 'continue' 'convert' 'create' 'cross' 'current_date' 'current_time' 'current_timestamp' 'current_user' 'cursor' 'database' 'databases' 'day_hour' 'day_microsecond' 'day_minute' 'day_second' 'dec' 'decimal' 'declare' 'default' 'delayed' 'delete' 'desc' 'describe' 'deterministic' 'distinct' 'distinctrow' 'div' 'double' 'drop' 'dual' 'each' 'else' 'elseif' 'enclosed' 'escaped' 'exists' 'exit' 'explain' 'false' 'fetch' 'float' 'float4' 'float8' 'for' 'force' 'foreign' 'from' 'fulltext' 'grant' 'group' 'having' 'high_priority' 'hour_microsecond' 'hour_minute' 'hour_second' 'if' 'ignore' 'in' 'index' 'infile' 'inner' 'inout' 'insensitive' 'insert' 'int' 'int1' 'int2' 'int3' 'int4' 'int8' 'integer' 'interval' 'into' 'is' 'iterate' 'join' 'key' 'keys' 'kill' 'leading' 'leave' 'left' 'like' 'limit' 'linear' 'lines' 'load' 'localtime' 'localtimestamp' 'lock' 'long' 'longblob' 'longtext' 'loop' 'low_priority' 'master_ssl_verify_server_cert' 'match' 'mediumblob' 'mediumint' 'mediumtext' 'middleint' 'minute_microsecond' 'minute_second' 'mod' 'modifies' 'natural' 'no_write_to_binlog' 'not' 'null' 'numeric' 'on' 'optimize' 'option' 'optionally' 'or' 'order' 'out' 'outer' 'outfile' 'precision' 'primary' 'procedure' 'purge' 'range' 'read' 'read_write' 'reads' 'real' 'references' 'regexp' 'release' 'rename' 'repeat' 'replace' 'require' 'restrict' 'return' 'revoke' 'right' 'rlike' 'schema' 'schemas' 'second_microsecond' 'select' 'sensitive' 'separator' 'set' 'show' 'smallint' 'spatial' 'specific' 'sql' 'sql_big_result' 'sql_calc_found_rows' 'sql_small_result' 'sqlexception' 'sqlstate' 'sqlwarning' 'ssl' 'starting' 'straight_join' 'table' 'terminated' 'then' 'tinyblob' 'tinyint' 'tinytext' 'to' 'trailing' 'trigger' 'true' 'undo' 'union' 'unique' 'unlock' 'unsigned' 'update' 'usage' 'use' 'using' 'utc_date' 'utc_time' 'utc_timestamp' 'values' 'varbinary' 'varchar' 'varcharacter' 'varying' 'when' 'where' 'while' 'with' 'write' 'xor' 'year_month' 'zerofill') asSet.</body></methods><methods><class-id>Glorp.MySQLPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'MySQL Native Driver'</body></methods><methods><class-id>Glorp.MySQLODBCPlatform</class-id> <category>testing</category><body package="GlorpDatabase">isODBCPlatform	^true.</body></methods><methods><class-id>Glorp.MySQLODBCPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'MySQL ODBC Driver'</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>testing</category><body package="GlorpDatabase">generateOverExistingValues	generatesOverExistingValues := true.</body><body package="GlorpDatabase">generatesOverExistingValues	"Do we generate our value even if there's alread one present in the field"	^generatesOverExistingValues.</body><body package="GlorpDatabase">generatesOverExistingValues: aBoolean	"Do we generate our value even if there's alread one present in the field"	generatesOverExistingValues := aBoolean.</body><body package="GlorpDatabase">hasParameters	"Instances of this class are not cached, so this implementor is less often than others.  However the method is also used by regenerators to determine bracketting."	^true</body><body package="GlorpDatabase">isGenerated	^true.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>accessing</category><body package="GlorpDatabase">generator	^generator</body><body package="GlorpDatabase">generator: aDatabaseValueGenerator	generator := aDatabaseValueGenerator</body><body package="GlorpDatabase">underlyingType	^underlyingType</body><body package="GlorpDatabase">underlyingType: aDatabaseType	underlyingType := aDatabaseType.	platform := aDatabaseType platform.	generator := self generatorFor: aDatabaseType.</body><body package="GlorpDatabase">underlyingType: aDatabaseType generator: aGenerator	underlyingType := aDatabaseType.	platform := aDatabaseType platform.	generator := aGenerator.</body><body package="GlorpDatabase">width	^self underlyingType width.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>initializing</category><body package="GlorpDatabase">generatorFor: aDatabaseType	aDatabaseType impliedSmalltalkType == Integer ifTrue: [^VersionNumberVersionGenerator new].	aDatabaseType impliedSmalltalkType == Dialect timestampClass ifTrue: [^TimestampVersionGenerator new].	self error: 'unknown version type'.</body><body package="GlorpDatabase">initialize	super initialize.	generatesOverExistingValues := false.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>SQL</category><body package="GlorpDatabase">print: aValue on: aStream	self underlyingType print: aValue on: aStream.</body><body package="GlorpDatabase">typeString	^underlyingType typeString.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>sequencing</category><body package="GlorpDatabase">preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	^generator preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>exdi specific</category><body package="GlorpDatabase">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^self underlyingType exdiType.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>converting</category><body package="GlorpDatabase">converterForStType: aClass	^underlyingType converterForStType: aClass.</body></methods><methods><class-id>Glorp.VersionType class</class-id> <category>instance creation</category><body package="GlorpDatabase">underlyingType: aDatabaseType	^self new underlyingType: aDatabaseType.</body><body package="GlorpDatabase">underlyingType: aDatabaseType generator: aGenerator	^self new underlyingType: aDatabaseType generator: aGenerator.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>accessing</category><body package="GlorpMappings">beForPseudoVariable	"Make me a pseudo-variable:  one which is neither read nor written, and doesn't have a corresponding instance variable, but is usable in a Query's whereClause (or its ordering or grouping, etc.)."	canRead := false.	canWrite := false.</body><body package="GlorpMappings">canRead	^canRead</body><body package="GlorpMappings">canRead: aBoolean	canRead := aBoolean</body><body package="GlorpMappings">canWrite	^canWrite</body><body package="GlorpMappings">canWrite: aBoolean	canWrite := aBoolean</body><body package="GlorpMappings">classModel	^classModel</body><body package="GlorpMappings">classModel: aGlorpClassModel	classModel := aGlorpClassModel</body><body package="GlorpMappings">collectionType	^collectionType</body><body package="GlorpMappings">collectionType: aClass	collectionType := aClass</body><body package="GlorpMappings">keyType	^keyType</body><body package="GlorpMappings">keyType: aClass	keyType := aClass</body><body package="GlorpMappings">name	^name isNil ifTrue: [''] ifFalse: [name]</body><body package="GlorpMappings">name: aSymbol	| symbol |	symbol := aSymbol isNil ifTrue: [aSymbol] ifFalse: [aSymbol asSymbol].	name := symbol.</body><body package="GlorpMappings">system	classModel isNil ifTrue: [^nil].	^classModel system.</body><body package="GlorpMappings">type	^type</body><body package="GlorpMappings">type: aClass	type := aClass</body><body package="GlorpMappings">useDirectAccess: aBoolean	useDirectAccess := aBoolean.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>testing</category><body package="GlorpMappings">isForPseudoVariable	"Return true if this is a pseudo-variable - one which is neither read nor written, and doesn't have a corresponding instance variable, but is only used for queries."	^(canRead not &amp; canWrite not) or: [self isValid not].</body><body package="GlorpMappings">useDirectAccess	useDirectAccess isNil ifFalse: [^useDirectAccess].	self system isNil ifTrue: [^true].  "A global default, although only applicable if we're not in a valid setup"	^self system useDirectAccessForMapping.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>private</category><body package="GlorpMappings">directGetValueFrom: anObject 	| index |	index := self instVarIndexIn: anObject.	index = 0 ifTrue: [self raiseInvalidAttributeError].	^anObject instVarAt: index</body><body package="GlorpMappings">directSetValueIn: anObject to: aValue 	| index |	index := self instVarIndexIn: anObject.	index = 0 ifTrue: [self raiseInvalidAttributeError].	^anObject instVarAt: index put: aValue</body><body package="GlorpMappings">instVarIndex	| soughtName |	attributeIndex == nil ifFalse: [^attributeIndex].	soughtName := Dialect instVarNameFor: name.	^attributeIndex := self classModel describedClass allInstVarNames 				indexOf: soughtName</body><body package="GlorpMappings">instVarIndexIn: anObject 	^self instVarIndex</body><body package="GlorpMappings">isValid	^name notNil and: [classModel notNil].</body><body package="GlorpMappings">newCollection	collectionType == GlorpVirtualCollection ifTrue: [^OrderedCollection new].	^collectionType isBehavior ifTrue: [collectionType new] ifFalse: [collectionType copyEmpty].</body><body package="GlorpMappings">privateAndbasicSetInstVarIndex: anInteger	"Our superclass may use our mapping conditionally but be unable to set the index."	attributeIndex := anInteger.</body><body package="GlorpMappings">privateUseDirectAccess	^useDirectAccess.</body><body package="GlorpMappings">raiseInvalidAttributeError	self error: 'Invalid attribute: ', classModel printString, '&gt;&gt;', name printString.</body><body package="GlorpMappings">setSelector	setSelector  == nil ifTrue: [setSelector := (name, ':') asSymbol].	^setSelector.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>printing</category><body package="GlorpMappings">printOn: aStream	aStream nextPutAll: self classModel printString, '&gt;&gt;', self name.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>get/set</category><body package="GlorpMappings">checkTargetType: anObject	"Check that anObject's type corresponds to something we know how to handle for this attribute. We expect this to be a real object, not a collection."	self checkTargetType: anObject against: self type.</body><body package="GlorpMappings">checkTargetType: anObject against: aClass	"Check that anObject's type corresponds to aClass, which we expect as our values. We expect this to be a real object, not a collection."	| targetModel |	anObject yourSelf isNil ifTrue: [^self].	aClass isNil ifTrue: [self error: 'No type to check against in class model'].	anObject glorpIsCollection ifTrue: [(GlorpInvalidTypeError new object: anObject; expectedType: self collectionType) signal].	targetModel := self system classModelFor: aClass.	targetModel notNil ifTrue: [		(targetModel matches: anObject)			ifFalse: [(GlorpInvalidTypeError new object: anObject; expectedType: aClass) signal]].</body><body package="GlorpMappings">checkTargetTypeForKey: aKey value: anObject	"Check that anObject's type corresponds to something we know how to handle for this attribute. We expect this to be a real object, not a collection. This is the version used for checking a dictionary, where we check both key and value, but only if they correspond to mapped classes."	(self system classModelFor: self keyType) isNil 		ifFalse: [self checkTargetType: aKey against: self keyType].	(self system classModelFor: self type) isNil		ifFalse: [self checkTargetType: anObject against: type].</body><body package="GlorpMappings">checkType: anObject	(self classModel matches: anObject)		ifFalse: [self error: 'Wrong type of object'].</body><body package="GlorpMappings">getValueFrom: anObject	| real |	real := anObject yourSelf.	self checkType: real.	self useDirectAccess ifTrue: [^self directGetValueFrom: real].	^real perform: self name.</body><body package="GlorpMappings">setValueIn: anObject to: aValue 	| real |	self isValid ifFalse: [^aValue].	real := anObject yourSelf.	self checkType: real.	self useDirectAccess ifTrue: [^self directSetValueIn: real to: aValue].	^real perform: self setSelector with: aValue</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>validation</category><body package="GlorpMappings">isCollectionAttribute	^collectionType notNil.</body><body package="GlorpMappings">isReadable	"An attribute can be:		- readable from the database, i.e. settable on its object		- writable to the database, i.e. gettable from its object		- both (the default)		- neither, i.e. a pseudoVariable, usable in a Glorp block but not on its objectWe check that reading from the database is authorised, and that a setter is implemented on the object."	self canRead ifFalse: [^false].	^self useDirectAccess 		ifTrue: [self instVarIndex &gt; 0]		ifFalse: [self classModel describedClass canUnderstand: self setSelector]</body><body package="GlorpMappings">isWritable	"An attribute can be:		- readable from the database, i.e. settable on its object		- writable to the database, i.e. gettable from its object		- both (the default)		- neither, i.e. a pseudoVariable, usable in a Glorp block but not on its objectWe check that writing to the database is authorised, and that a getter is implemented on the object."	self canWrite ifFalse: [^false].	^self useDirectAccess 		ifTrue: [self instVarIndex &gt; 0]		ifFalse: [self classModel describedClass canUnderstand: self name]</body><body package="GlorpMappings">validate	name isEmpty ifTrue: [self error: 'Invalid attribute name']</body><body package="GlorpMappings">validateCanRead	self isReadable ifFalse: [self raiseInvalidAttributeError]</body><body package="GlorpMappings">validateCanWrite	self isWritable ifFalse: [self raiseInvalidAttributeError]</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>knitting</category><body package="GlorpMappings">add: anObject to: aCollection in: ourObject	"If this is an array we can't just add to it, we must concatenate and re-set the value"	| newCollection |	aCollection class == Array 		ifTrue: [				newCollection := aCollection, (Array with: anObject).			self setValueIn: ourObject to: newCollection.			^self].	(anObject class == Association and: [anObject key == nil])		ifFalse: [aCollection add: anObject].</body><body package="GlorpMappings">knit: ourObject to: anotherObject 	"Set up the relationship from our object to another one, indicated by our mapping.  If we ae setting a new collection, add the objects to the collection before seting the collection on the owning object, in case we are not using direct access and the setter expects to iterate over them."	self isCollectionAttribute		ifFalse: [self setValueIn: ourObject to: anotherObject]		ifTrue:			[| collection | collection := self getValueFrom: ourObject.			(collection isGlorpProxy and: [collection isInstantiated not])				ifTrue:					[collection := self newCollection.					self add: anotherObject to: collection in: ourObject.					self setValueIn: ourObject to: collection]				ifFalse:					[(collection includes: anotherObject) ifFalse:						[self add: anotherObject to: collection in: ourObject]]].</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>mapping</category><body package="GlorpMappings">isDictionaryAttribute	^collectionType isBehavior and: [collectionType includesBehavior: Dictionary].</body><body package="GlorpMappings">loopOver: mightBeACollection doing: aBlock	"It is possible that the value for a dictionary attribute is nil. If so, do not map it back"	| index |	self isCollectionAttribute ifFalse: [self checkTargetType: mightBeACollection. ^aBlock value: 1 value: mightBeACollection].	mightBeACollection isNil ifTrue: [^nil].	self isDictionaryAttribute ifTrue: [^mightBeACollection keysAndValuesDo: [:key :value |		self checkTargetTypeForKey: key value: value. 		value ifNotNil: [aBlock value: key value: value]]].	index := 1.	mightBeACollection glorpIsCollection ifFalse: [		(GlorpInvalidTypeError new object: mightBeACollection; expectedType: self collectionType) signal].	mightBeACollection		do:			[:each |			| object | 			object := each glorpRealObject. 			self checkTargetType: object.			aBlock value: index value: object.			index := index + 1].</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>initialization</category><body package="GlorpMappings">initialize	canRead := true.	canWrite := true.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>copying</category><body package="GlorpMappings">copyFrom: anAttributeModel	"Copy over the attributes if it defines them and we don't"	anAttributeModel isNil ifTrue: [^self].	self type isNil ifTrue: [self type: anAttributeModel type].	self collectionType isNil		ifTrue: [self collectionType: anAttributeModel collectionType].	self privateUseDirectAccess isNil		ifTrue: [useDirectAccess := anAttributeModel privateUseDirectAccess].	canRead := anAttributeModel canRead.	canWrite := anAttributeModel canWrite.</body></methods><methods><class-id>Glorp.GlorpAttributeModel class</class-id> <category>instance creation</category><body package="GlorpMappings">named: aSymbol	^self new name: aSymbol.</body><body package="GlorpMappings">named: aSymbol collection: aCollectionClass of: aClass	^(self new)		name: aSymbol;		type: aClass;		collectionType: aCollectionClass.</body><body package="GlorpMappings">named: aSymbol collectionOf: aClass	^self named: aSymbol collection: OrderedCollection of: aClass.</body><body package="GlorpMappings">named: aSymbol dictionary: dictionaryClass from: keyClass to: valueClass	^(self new)		name: aSymbol;		type: valueClass;		keyType: keyClass;		collectionType: dictionaryClass.</body><body package="GlorpMappings">named: aSymbol dictionaryFrom: keyClass to: valueClass	^self named: aSymbol dictionary: Dictionary from: keyClass to: valueClass.</body><body package="GlorpMappings">named: aSymbol type: aClass	^self new name: aSymbol; type: aClass.</body><body package="GlorpMappings">new	^super new initialize.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>fields</category><body package="GlorpExpressions">aliasedTableFor: aDatabaseTable 	self hasTableAliases ifFalse: [^aDatabaseTable].	aDatabaseTable isAliased ifTrue: [^aDatabaseTable].	^tableAliases		at: aDatabaseTable		ifAbsent:			[(self tables includes: aDatabaseTable)					ifTrue: [self error: 'Bug. Expression has only partially aliased tables']				ifFalse: [(self mappingExpressions							at: aDatabaseTable							ifAbsent: [^aDatabaseTable])								aliasedTableFor: aDatabaseTable]]</body><body package="GlorpExpressions">aliasedTableFor: aDatabaseTable ifAbsent: aBlock	self hasTableAliases ifFalse: [^aBlock value].	aDatabaseTable isAliased ifTrue: [^aDatabaseTable].	^tableAliases at: aDatabaseTable ifAbsent: [aBlock value].</body><body package="GlorpExpressions">controlsTables	self subclassResponsibility.</body><body package="GlorpExpressions">findFieldNamed: aString	| fields |	fields := OrderedCollection new: 1.	self tables do: [:each |		| field |		field := each fieldNamed: aString ifAbsent: [nil].		field isNil ifFalse: [fields add: field]].	fields isEmpty ifTrue: [self error: 'No field named ', aString, ' in ', self printString].	fields size &gt; 1 ifTrue: [self error: 'Ambiguous field ', aString, ' in ', self printString].	^fields at: 1.</body><body package="GlorpExpressions">newFieldExpressionFor: aField	^FieldExpression forField: aField basedOn: self</body><body package="GlorpExpressions">translateField: aDatabaseField	| newTable rebuilt |	rebuilt := aDatabaseField isGlorpExpression		ifTrue: [aDatabaseField asGlorpExpressionOn: self withUltimateBase: self ultimateBaseExpression]		ifFalse: [aDatabaseField].	newTable := self aliasedTableFor: rebuilt table.	newTable == rebuilt table ifTrue: [^rebuilt].	^self fieldAliases at: aDatabaseField ifAbsentPut: [rebuilt withTable: newTable].</body><body package="GlorpExpressions">translateFields: anOrderedCollection	"DO NOT override in subclasses (or not without care).  This is now the sole plural implementor and exists solely for convenience.  All specific subclass and delegate behaviour is in the singular #translateField: implementors."	^anOrderedCollection collect: [:each | self translateField: each]</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>accessing</category><body package="GlorpExpressions">fieldAliases	fieldAliases isNil ifTrue: [fieldAliases := IdentityDictionary new].	^fieldAliases.</body><body package="GlorpExpressions">mappingExpressions	mappingExpressions isNil ifTrue: [mappingExpressions := IdentityDictionary new].	^mappingExpressions.</body><body package="GlorpExpressions">mappingExpressions: anIdentityDictionary	mappingExpressions := anIdentityDictionary.</body><body package="GlorpExpressions">system	self subclassResponsibility.</body><body package="GlorpExpressions">table	self subclassResponsibility.</body><body package="GlorpExpressions">tableAliases	^tableAliases</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>printing</category><body package="GlorpExpressions">printTableAliasesOn: aStream 	self hasTableAliases 		ifTrue: 			[aStream nextPutAll: ' '.			tableAliases keysAndValuesDo: [:eachKey :eachValue | 				aStream nextPutAll: eachKey name, '-&gt;', eachValue name , ' ']]</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>testing</category><body package="GlorpExpressions">canTranslateFields	"Return true if we are a mapping expression and can thus translate from fields into their aliased version for a particular query. More generally, do we respond to translateField:"	^true.</body><body package="GlorpExpressions">hasField	^false.</body><body package="GlorpExpressions">hasTableAliases	"I test for notEmpty as well as notNil since (very rarely) my tableAliases instance may have been preemptively initialized to the same instance as another expression (see the comment in #privateTableAliases:)."	^tableAliases notNil and: [tableAliases notEmpty]"In theory, another expression could populate a shared instance with tables, but not with mine, and I could then be sent this method before I was sent #assignTableAliasesStartingAt:prefix:.  In practice, all expressions in a SimpleQuery assign at the same time in #assignTableAliases and there is no sharing of a tableAlias instance beyond the confines of a SimpleQuery.  Against the very unlikely event that future refactoring ever altered that, I record here that I tested	^tableAliases notNil and: [tableAliases includesKey: self table]This only tests for my main table since tableAliases are set only in #assignTableAliasesStartingAt:prefix: and that does them all if it does any (and it will not set them if I do not controlTables, so we need not consider that).  For now, I rate such a test as overcautious;  given Glorp's the order of processing, it suffices to check [tableAliases notEmpty]."</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>api</category><body package="GlorpExpressions">get: aSymbol	"Return the mapping expression corresponding to the named attribute."	| reallyASymbol functionExpression |	reallyASymbol := aSymbol asSymbol.	functionExpression := self getFunction: aSymbol withArguments: #().	functionExpression isNil ifFalse: [^functionExpression].	^self mappingExpressions		at: reallyASymbol		ifAbsentPut: [MappingExpression named: reallyASymbol basedOn: self]</body><body package="GlorpExpressions">get: aSymbol withArguments: anArray 	| specialExpression functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	specialExpression := self performSpecialExpression: aSymbol withArguments: anArray.	specialExpression isNil ifFalse: [^specialExpression].	anArray isEmpty ifTrue: [^self get: aSymbol].	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body><body package="GlorpExpressions">getConstant: anObject	"Allows us to refer to a constant object easily. This is most useful for subselects, where I can already write something like   [:each | (each count: subQuery) = 5]but since the subselect part might be very verbose, I might prefer to put the constant value first. I can't write   [:each | 5 = (each count: subQuery)]because then the left-hand side expression doesn't refer back to the block argument, and we can't build the expression correctly. So I can write   [:each | (each getConstant: 5) = (each count: subQuery)]"	^anObject asGlorpExpressionOn: self.</body><body package="GlorpExpressions">getConstant: anObject alias: aSymbol	"This utility method makes it easier to set the name (i.e. alias) for a field in a recursion table when it is initialized to a constant value, not some field or mapping that already has a name."	^(anObject asGlorpExpressionOn: self)		alias: aSymbol value;		yourself</body><body package="GlorpExpressions">getField: aField	| realField |	realField := aField isString		ifTrue: [self findFieldNamed: aField]		ifFalse: [aField].	"This might be an expression, most notably a constant expression, in which case it either contains a string or a field. This is awfully ugly"	realField isGlorpExpression		ifTrue:			[realField class == ConstantExpression				ifTrue:					[realField := realField value isString						ifTrue: [realField := self findFieldNamed: realField value]						ifFalse: [realField]]].	^self getFieldKnownNotToBeAName: realField.</body><body package="GlorpExpressions">getFieldKnownNotToBeAName: aField	"The public getField method may, for convenience, be passed a string or a constant expression with a string that is a field name. This is a mess, and can be confused with a constant value. This method does not allow that."	| realField |	realField := aField.	realField isGlorpExpression		ifTrue:			[realField class == ConstantExpression ifTrue: [^realField].			realField class == ParameterExpression				ifTrue: [realField := realField field]].	^self getFieldThatsAnActualFieldObject: realField.</body><body package="GlorpExpressions">getFieldThatsAnActualFieldObject: aField	"If the field isn't from our table, do a getTable first. If we don't know, assume we can get it directly."	self controlsTables ifFalse: [^self base getFieldThatsAnActualFieldObject: (self translateField: aField)].	^((self hasDescriptor not) or: [self tables includes: aField table])		ifTrue:			[self mappingExpressions				at: aField				ifAbsentPut: [self newFieldExpressionFor: aField]]		ifFalse: [(self getTable: aField table) getField: aField].</body><body package="GlorpExpressions">getMapping: aMapping named: aString	"Get a mapping expression given the actual mapping (this is most useful for an anonymous mapping that isn't named or in our descriptor). Only if you really know what you're doing!. Short circuit looking up the mapping, checking for functions, and so on."	^self mappingExpressions at: aString		ifAbsentPut: [ | expression |			expression := MappingExpression named: aString basedOn: self.			expression mapping: aMapping.			expression].</body><body package="GlorpExpressions">getParameter: aDatabaseField 	^ParameterExpression forField: aDatabaseField basedOn: self.</body><body package="GlorpExpressions">getTable: aTable	"This can take a string, a constantExpression containing a string, or a table object"	| realTable |	realTable := aTable isString		ifTrue: [self system tableNamed: aTable]		ifFalse: [aTable].	"This might be an expression, most notably a constant expression, in which case it either contains a string or a field"	realTable isGlorpExpression		ifTrue:			[realTable value isString				ifTrue: [realTable := self system tableNamed: realTable value]				ifFalse: [realTable := realTable value]].	^self mappingExpressions		at: realTable		ifAbsentPut: [TableExpression forTable: realTable basedOn: self].</body><body package="GlorpExpressions">referenceClass	"Return the class that our mapping refers to, if we have a mapping. If we're a base expression, just return our class, and if we're a table expression, just return nil."	^self subclassResponsibility.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>preparing</category><body package="GlorpExpressions">assignTableAliasesStartingAt: anInteger prefix: aString	"Very rarely, my tableAliases' instance may be shared with another expression that has already populated it with tables, but not necessarily with all of mine.  I therefore iterate over my tables, ensuring all are aliased, regardless of whether I already have some aliases."	| myTables tableNumber prefix |	self controlsTables ifFalse: [^anInteger].	(myTables := self tables) isEmpty ifTrue: [^anInteger].	tableNumber := anInteger.	prefix := aString isNil ifTrue: ['t'] ifFalse: [aString].	tableAliases isNil ifTrue:		[tableAliases := IdentityDictionary new: myTables size].	myTables do:		[:each |		tableAliases at: each ifAbsentPut:			[| newTable | newTable := each copy.			newTable parent: each.			newTable schema: ''.			newTable name: prefix , tableNumber printString.			tableNumber := tableNumber + 1.			newTable]].	^tableNumber		"incremented if any tables were aliased, still equal to anInteger if not"</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>internal</category><body package="GlorpExpressions">anySatisfyDefault: anExpression 	^(self system isNil or: [self system useJoinsForAnySatisfy])		ifTrue: [self anySatisfyJoin: anExpression]		ifFalse: [self anySatisfyExists: anExpression].</body><body package="GlorpExpressions">anySatisfyExists: anExpression 	| newExpression |	anExpression isConstantExpression ifTrue: [self error: 'The argument to anySatisfy: must be a block evaluating to a boolean condition.'].	newExpression := SubSelectExpression 		named: #anySatisfy:		basedOn: self		withArguments: (Array with: anExpression).	^newExpression.</body><body package="GlorpExpressions">anySatisfyJoin: anExpression 	| newExpression |	anExpression isConstantExpression ifTrue: [self error: 'The argument to anySatisfy: must be a block evaluating to a boolean condition.'].	self base requiresDistinct: true.	newExpression := CollectionExpression 		named: #anySatisfy:		basedOn: self		withArguments: (Array with: anExpression).	self base removeMappingExpression: self.	^newExpression.</body><body package="GlorpExpressions">includes: anObject	"Allow us to specify includes: as a shortcut for (anySatisfy: [:each | each = anObject]). Rather than just call anySatisfy:, we need to go through the get: mechanism, both to avoid the anySatisfy: method on expressions that treats them like a collection, and to make sure we get the default mechanism for anySatisfy: (either joins or exists)"	^self get: #anySatisfy: withArguments: (Array with: ([:each | each = anObject] asGlorpExpressionOn: self)).</body><body package="GlorpExpressions">noneSatisfy: anExpression 	| newExpression |	newExpression := SubSelectExpression 		named: #noneSatisfy:		basedOn: self		withArguments: (Array with: anExpression).	^newExpression.</body><body package="GlorpExpressions">noneSatisfyExists: anExpression 	| newExpression |	newExpression := SubSelectExpression 		named: #noneSatisfy:		basedOn: self		withArguments: (Array with: anExpression).	^newExpression.</body><body package="GlorpExpressions">oneArgumentSpecialSelectors	^#(#anySatisfyDefault: #anySatisfyJoin: #anySatisfyExists: #getTable: #getField: #getMappings: #fieldNamed: #parameter: #noneSatisfy: #noneSatisfyExists: #getConstant: #count: #sum: #min: #max: #average: #sqlSelect: #includes:)</body><body package="GlorpExpressions">performSpecialExpression: aSymbol withArguments: anArray	| symbolToPerform |	symbolToPerform := self specialSymbolToPerformFor: aSymbol.	(self zeroArgumentSpecialSelectors includes: symbolToPerform) ifTrue: [^self perform: symbolToPerform].	(self oneArgumentSpecialSelectors includes: symbolToPerform) ifTrue: [^self perform: symbolToPerform with: anArray first ].	(self twoArgumentSpecialSelectors includes: symbolToPerform) ifTrue: [^self perform: symbolToPerform with: (anArray at: 1) with: (anArray at: 2)].	^nil.</body><body package="GlorpExpressions">specialSymbolToPerformFor: aSymbol	"Avoid polymorphism between things you can send to an expression inside a query block and things you can do to an expression to iterate over an expression true"	aSymbol == #anySatisfy: ifTrue: [^#anySatisfyDefault:].	aSymbol == #select: ifTrue: [^#sqlSelect:].	^aSymbol.</body><body package="GlorpExpressions">twoArgumentSpecialSelectors	^#(#aggregate:as: #getConstant:alias:)</body><body package="GlorpExpressions">zeroArgumentSpecialSelectors	"In 8.2, #asOuterJoin is deprecated;  when it is removed in 9.0, remove its symbol from here."	^#(#beOuterJoin #bePhantom #sqlCount #sqlSum #sqlMin #sqlMax #sqlAverage #sqlAvg #isEmpty #notEmpty #asDate #asTimestamp #asOuterJoin)</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>private/accessing</category><body package="GlorpExpressions">privateTableAliases: anIdentityDictionary	"Table aliases are lazily initialized when populated.  Use this setter (to bypass that lazy initialization) when an expression prompts the adding of other expressions (during Glorp's internal query rewriting - users are not expected to do this) that need to share its alias list (so that later, when the alis list is computed for a query, they will use the same name (e.g. t2 or s1t1) for a table, not create their own clashing names)."	tableAliases := anIdentityDictionary.</body><body package="GlorpExpressions">removeMappingExpression: anExpression	"Private. Normally you would never do this, but in the case of an anySatisfy: or allSatisfy: we want to have each of them as distinct joins, so we will remove the entry from the mappingExpression of the base, making sure that relationship will not be used for anything else. Since any/allSatisfy: is the only valid use of a collection relationship, we don't have to worry about whether it was used for something else earlier."	self mappingExpressions removeKey: anExpression name.</body><body package="GlorpExpressions">requiresDistinct	^requiresDistinct</body><body package="GlorpExpressions">requiresDistinct: aBoolean 	requiresDistinct := aBoolean</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>initialize</category><body package="GlorpExpressions">initialize	super initialize.	requiresDistinct := false.</body></methods><methods><class-id>Glorp.ObjectExpression</class-id> <category>api-aggregates</category><body package="GlorpExpressions">aggregate: anExpression as: aggregateFunctionName	^self aggregate: anExpression as: aggregateFunctionName where: nil.</body><body package="GlorpQueries">aggregate: anExpression as: aggregateFunctionName where: whereExpression	"This is the most general form of aggregation convenience method, and other aggregations, e.g. sqlCount, are implemented in terms of it.  This method creates a subselect out of the expression that is our argument (anExpression), returning an aggregation expression based on it.  For example,	session read: GlorpCustomer where:		[:each | (each aggregate: each accounts as: #countStar where: [:acct | acct price &gt; 1000]) = 1].would find all customers who had exactly one account whose value exceeded 1000."	| q expression next objectExpression retrievalExpression basicExpression |	"We may be passed an expression corresponding to either a field, or to a full object, depending on the aggregate function. In either case, build backwards from the first full object"	objectExpression := anExpression mapping isRelationship		ifTrue: [anExpression] ifFalse: [anExpression base].	q := Query read: objectExpression referenceClass.	expression := q baseExpression.	next := objectExpression.	[next base isNil or: [next class == SubSelectBaseExpression]] whileFalse:		[expression := next mapping addPhantomMappingExpressionOn: expression.		next := next base].	"We have to force construct the equality expression, because we don't want 'self' rebuilt onto the other base"	expression := RelationExpression new relation: #=; leftChild: expression; rightChild: self.	q whereClause: expression.	"We need to rebuild the thing we're using to retrieve in the right context. Also, if we're called directly, the symbol may be wrapped as a constantExpression. Unwrap it"	basicExpression := anExpression rebuildOn: q baseExpression startingFrom: objectExpression.	retrievalExpression := (basicExpression get: aggregateFunctionName asGlorpExpression value).	q retrieve: retrievalExpression.	whereExpression == nil ifFalse:		[q AND: (whereExpression asGlorpExpressionOn: basicExpression)].	^q asGlorpExpressionOn: self ultimateBaseExpression.</body><body package="GlorpExpressions">asDate	"Cast the receiver to be a date"	^self getFunction: #cast: withArguments: (Array with: self system platform date asGlorpExpression).</body><body package="GlorpExpressions">asTimestamp	"Cast the receiver to be a timestamp"	^self getFunction: #cast: withArguments: (Array with: self system platform timestamp asGlorpExpression).</body><body package="GlorpExpressions">average: anExpression	^self aggregate: anExpression as: #average.</body><body package="GlorpExpressions">count: anExpression	"Make a subselect of the expression that is our argument, returning a count(*). e.g.session read: GlorpCustomer where: 	[:each |  (each count: [:eachCust | eachCust accounts]) = 1]."	^self aggregate: anExpression as: #countStar.</body><body package="GlorpExpressions">count: anExpression where: filterExpression	"Make a subselect of the expression that is our argument, returning a count(*). e.g.session read: GlorpCustomer where: 	[:each |  (each count: [:eachCust | eachCust accounts]) = 1]."	^self aggregate: anExpression as: #countStar where: filterExpression.</body><body package="GlorpQueries">existenceCheck: anExpression as: functionName	"Make a subselect of the expression that is our argument, returning it wrapped in either an exists or a not exists, e.g. 		session read: GlorpCustomer where:			[:each | each existenceCheck: eachCust accounts as: #exists:].This is the most general form of existence checking convenience method, others are implemented in terms of it. It is similar to #aggregate:as:where:, but simpler."	| q expression next objectExpression |	"We may be passed an expression corresponding to either a field, or to a full object, depending on the aggregate function. In either case, build backwards from the first full object"	objectExpression := anExpression mapping isRelationship 		ifTrue: [anExpression] ifFalse: [anExpression base].	q := Query read: objectExpression mapping referenceClass.	expression := q baseExpression.	next := objectExpression.	[next base isNil] whileFalse: [		expression := next mapping addPhantomMappingExpressionOn: expression.		next := next base].	"We have to force construct the equality expression, because we don't want 'self' rebuilt onto the other base"	expression := RelationExpression new relation: #=; leftChild: expression; rightChild: self.	q whereClause: expression.	"Here, in synch with #initializeFunctions (for the relevant platforms), we use 'x' to name the data being retrieved."	q retrieve: ([:each | 'x' ] asGlorpExpression getFunction: #distinct withArguments: #()).	^self get: functionName withArguments: (Array with: (q asGlorpExpressionOn: self ultimateBaseExpression)).</body><body package="GlorpExpressions">max: anExpression	^self aggregate: anExpression as: #max.</body><body package="GlorpExpressions">min: anExpression	^self aggregate: anExpression as: #min.</body><body package="GlorpExpressions">sqlAverage	"Make a subselect of the expression that is our argument, returning an avg(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlAverage &gt; 100]."	^self queryLevelBaseExpression average: self.</body><body package="GlorpExpressions">sqlAvg	"Make a subselect of the expression that is our argument, returning an avg(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlAvg &gt; 100]."	^self queryLevelBaseExpression average: self.</body><body package="GlorpExpressions">sqlCount	"Make a subselect of the expression that is our argument, returning a count(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts sqlCount = 1]."	^self queryLevelBaseExpression count: self.</body><body package="GlorpExpressions">sqlCountWhere: filterExpression	"Make a subselect of the expression that is our argument, returning a count(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts sqlCount = 1]."	^self queryLevelBaseExpression count: self where: filterExpression.</body><body package="GlorpExpressions">sqlMax	"Make a subselect of the expression that is our argument, returning a max(). e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlMax = 1]."	^self queryLevelBaseExpression max: self.</body><body package="GlorpExpressions">sqlMin	"Make a subselect of the expression that is our argument, returning a minimum. e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlMin = 1]."	^self queryLevelBaseExpression min: self.</body><body package="GlorpExpressions">sqlSum	"Make a subselect of the expression that is our argument, returning a count(*). e.g.session read: GlorpCustomer where: 	[:each |  each accounts balance sqlSum = 1]."	^self queryLevelBaseExpression sum: self.</body><body package="GlorpExpressions">sum: anExpression	"Make a subselect of the expression that is our argument, returning a sum. e.g.session read: GlorpCustomer where: 	[:each |  (each sum: [:eachCust | eachCust accounts id]) &gt; 5]."	^self aggregate: anExpression as: #sum.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>testing</category><body package="GlorpExpressions">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^self mapping canBeUsedForRetrieve.</body><body package="GlorpExpressions">canKnit	"Return true if, when building objects, we can knit the object corresponding to this expression to a related object. Roughly speaking, is this a mapping expression"	^true.</body><body package="GlorpExpressions">canPrint	"Return true if we can print into a where clause"	^self hasField.</body><body package="GlorpExpressions">hasImpliedClauses	^self mapping notNil and: [self mapping hasImpliedClauses].</body><body package="GlorpExpressions">mapsSimpleObject	^self mapping mapsSimpleObject.</body><body package="GlorpExpressions">representsDerivedObject	^self mapping isRelationship.</body><body package="GlorpExpressions">returnsDictionary	"Return true if we represent a mapping to a dictionary."	^self mapping isToManyRelationship and: [self mapping collectionType == Dictionary].</body><body package="GlorpExpressions">willPrintAsWhereClause	^self hasField.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>preparing</category><body package="GlorpExpressions">additionalExpressions	^self additionalExpressionsOn: self.</body><body package="GlorpExpressions">additionalExpressionsOn: anExpression	"We can get hijacked, so pass in the expression to use rather than just using self"	| exp |	self mapping isNil ifTrue: [^#()].	exp := self mapping joinExpressionFor: anExpression.	outerJoin ifTrue: [exp beOuterJoin].	^(self multipleTableExpressionsOn: anExpression), (exp isNil ifTrue: [#()] ifFalse: [Array with: exp]).</body><body package="GlorpExpressions">allControlledTables	"Return all the tables that we control, directly or indirectly. Basically, if we are a mapping expression with a link table, return the link table as well as any tables of ours."	| all join |	self controlsTables ifFalse: [^#()].	all := Set new.	all addAll: self tables.	mapping := self mapping.	mapping isNil 		ifFalse: [			join := mapping join.			join isNil ifFalse: [all addAll: join allControlledTables]].	^all.</body><body package="GlorpExpressions">allRelationsFor: rootExpression do: aBlock andBetweenDo: anotherBlock	"We might have multiple clauses to print, depending on our mapping"	self mapping 		allRelationsFor: rootExpression		do: aBlock		andBetweenDo: anotherBlock.</body><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| newBase |	newBase := base asExpressionJoiningSource: source toTarget: target.	^newBase getMapping: self mapping named: name.</body><body package="GlorpExpressions">fieldsForSelectStatement		^self mapping fieldsForSelectStatement.</body><body package="GlorpExpressions">mustReGetMappingIfRebuildingOn: newBase	"Return true if we need to do a full get: when rebuilding, rather than being able to preserve the mapping that we had before."	"If we didn't have a mapping yet, then just do a get"	mapping isNil ifTrue: [^true].	"If this is a phantom mapping, we must not try to re-get it."	self phantom ifTrue: [^false].	"Otherwise, we're a normal mapping, and we don't need to re-get the mapping unless the class is different, probably because of inheritance. But note that in some cases we may not know our descriptor yet."	self base hasDescriptor ifFalse: [^false].	self base descriptor isNil ifTrue: [^false].	^self base descriptor ~= newBase descriptor.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| expression newBase |	self == anExpression ifTrue: [^aBaseExpression].	newBase := base		rebuildOn: aBaseExpression		startingFrom: anExpression		withOuterScopeBase: ultimateBaseExpression.	"For phantom mappings we have to pass through our mapping since they can't compute their own. For the normal case, if we have a mapping, and our base class hasn't changed, then just re-use the same mapping as an optimization."	expression := (mapping isNil or: [self mustReGetMappingIfRebuildingOn: newBase])		ifTrue: [newBase get: name]		ifFalse: [newBase getMapping: self mapping named: name].	outerJoin ifTrue: [expression beOuterJoin].	expression phantom: self phantom.	^expression</body><body package="GlorpExpressions">rewriteBooleanEquality: relation	"If we are a boolean that doesn't have a comparison relation on top of us, replace us with an ' = true'"	"Only rewrite booleans"	(self mapping notNil and: [self mapping attribute type = Boolean]) ifFalse: [^self].	"See if we're already part of an equality comparison, don't rewrite twice"	(relation = #= | (relation = #&lt;&gt;) | (relation = #IN)) ifTrue: [^self].	"If we're a boolean function, we don't need or want the comparison. e.g. EXISTS. This is a bit hard to test for."	(self mapping field isGlorpExpression and: [self mapping field field isNil]) ifTrue: [^self].	^self get: #= withArguments: (Array with: true asGlorpExpression).</body><body package="GlorpExpressions">tablesToPrint	self hasDescriptor ifFalse: [^#()].	^self tables collect: [:each |		self aliasedTableFor: each].</body><body package="GlorpExpressions">validate	self mappingFromMeOrSubclasses isNil ifTrue:		[ValidationError signal: 'No mapping for ', self printString].</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>accessing</category><body package="GlorpExpressions">allSourceFields	"If we are sending this, then we're treating the expression as a join, for a complex (and probably read-only) relationship. So in that case we want to treat the source fields as the parameters that this expression takes, and specifically the parameters that are based on fields."	^self inject: OrderedCollection new into: [:sum :each |		each addToTargetFields: sum.		sum].</body><body package="GlorpExpressions">allTargetFields	"If we are sending this, then we're treating the expression as a join, for a complex (and probably read-only) relationship. So in that case we want to treat the target fields as being the source fields of the bottom-most mapping. That is, the fields we'll use to connect to the thing we want are the things that our expression's base (which represents the thing we want) would use to connect to the first level mapping arising from it."	^self penultimateBaseExpression join allSourceFields.</body><body package="GlorpExpressions">beOuterJoin	outerJoin := true.</body><body package="GlorpExpressions">bePhantom	phantom := true.</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions">descriptor	| system theMapping |	system := self system.	system isNil ifTrue: [^nil].	theMapping := self mappingFromMeOrSubclasses.	theMapping isNil ifTrue: [^nil].	^system descriptorFor: theMapping referenceClass.</body><body package="GlorpExpressions">field	self mapping isNil ifTrue: [self error: '"', name, '" is not a mapped property name in ', base descriptor describedClass name].	self hasDescriptor ifTrue: [		"If we have a descriptor, then either we're a mapping to a full object, in which case we can't answer this properly, or we're a direct to-many mapping, in which case we can."		self mapping mapsSimpleObject			ifTrue: [^self translateField: self mapping field]			ifFalse: [self error: '"',name, 				'" is not an attribute that resolves to a field in the mapped tables for ', 					base descriptor describedClass name]].	^base translateField: self mapping field.</body><body package="GlorpExpressions">fieldFromMeOrSubclasses	"Return the field for this mapping, but if the field is not mapped here, and the class uses inheritance, check for subclasses, and use the first subclass mapping we find."	| subMapping |	subMapping := self mappingFromMeOrSubclasses.	^subMapping isNil		ifTrue: [self field]		ifFalse: [base translateField: subMapping field]</body><body package="GlorpExpressions">hasDescriptor	"Does the object that we describe have its own descriptor"	| myMapping |	myMapping := self mapping.	^myMapping notNil and: [myMapping isRelationship]</body><body package="GlorpExpressions">hasField	self mapping isNil ifTrue: [^false]."If we have a descriptor, then either we're a mapping to a full object, in which case we can't answer this properly, or we're a direct to-many mapping, in which case we can."	self hasDescriptor ifTrue: [		^self mapping mapsSimpleObject].	^true.</body><body package="GlorpExpressions">join	self mapping isNil ifTrue: [^nil].	^self mapping join.</body><body package="GlorpExpressions">mappedFields		self mapping isNil ifTrue: [^#()].	self mapping isRelationship ifTrue: [self error: '"',name, '" is not an attribute that resolves to a field in the mapped tables for ', base descriptor describedClass name].	^self mapping mappedFields collect: [:each | base translateField: each].</body><body package="GlorpExpressions">mappingFromMeOrSubclasses	"Return the mapping for me, but if the field is not mapped here, and the class uses inheritance, check for subclasses, and use the first subclass mapping we find."	| subclassDescriptors |	self mapping isNil ifFalse: [^self mapping].	self sourceDescriptor isNil ifTrue: [^self mapping].	subclassDescriptors := self sourceDescriptor typeResolver		descriptorsRequiringIndependentQueriesFor: self sourceDescriptor describedClass.	subclassDescriptors do:		[:each || subMapping |		subMapping := each mappingForAttributeNamed: name.		subMapping isNil ifFalse: [^subMapping]].	"If subclasses didn't work, just fall through to the normal error processing."	^self mapping</body><body package="GlorpExpressions">mappingSequenceName	"Return my name concatenated with the names of the prior mappings that connect me to my base, i.e. all the names from my penultimate base to mine.  (Used to construct common table expressions in recursive queries.)"	^base mappingSequenceName, name</body><body package="GlorpExpressions">multipleTableExpressions	^self multipleTableExpressionsOn: self.</body><body package="GlorpExpressions">multipleTableExpressionsOn: anExpression	^self mapping multipleTableExpressionsFor: anExpression.</body><body package="GlorpExpressions">name	^name.</body><body package="GlorpExpressions">phantom	^phantom</body><body package="GlorpExpressions">phantom: aBoolean	phantom := aBoolean</body><body package="GlorpExpressions">sourceDescriptor	^base descriptor.</body><body package="GlorpExpressions">system	^base system.</body><body package="GlorpExpressions">table	self hasDescriptor ifTrue: [^self descriptor primaryTable].	^self field table.</body><body package="GlorpExpressions">tables	self controlsTables ifFalse: [^#()].	^self tablesContainingMe.</body><body package="GlorpExpressions">tablesContainingMe	"Return a list of tables that contain this object, whether or not we control them. This is mostly the same as tables, but will differ for embedded mappings."	| set |	self descriptor isNil ifTrue: [^#()].	set := self descriptor tables asSet.	^set.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>private/initialization</category><body package="GlorpExpressions">mapping: aMapping	mapping := aMapping.</body><body package="GlorpExpressions">named: aSymbol basedOn: anExpression	name := aSymbol.	base := anExpression.	outerJoin := false.</body><body package="GlorpExpressions">privateAndBasicResetMapping: aMapping	mapping := aMapping.	name := aMapping attributeName.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>api</category><body package="GlorpExpressions">asOuterJoin	"The implementation of this in 8.1 and earlier is the implementation of #beOuterJoin in 8.2 and later.  Thus all existing callers of #asOuterJoin can convert to calling #beOuterJoin in 8.2 as a pure refactoring.  However if they are to work in 8.1 and earlier then this class' #beOuterJoin must be backported AND its symbol added to #zeroArgumentSpecialSelectors.	The 8.2 implementation of #asOuterJoin is what #asOuterJoin should have been for consistency with Glorp API.  When used in #alsoFetch: expressions, #asOuterJoin and #beOuterJoin give the same outcome;  because #beOuterJoin does not copy, it is trivially faster."	self deprecated: #(#version '8.2' #sunset '9.0' #use #beOuterJoin).	^self copy beOuterJoin</body><body package="GlorpExpressions">base	^base.</body><body package="GlorpExpressions">isEmpty	"Only useful for mappings that represent collections. This checks to see if the collection has elements by building a not exists subselect."		^self base existenceCheck: self as: #notExists:</body><body package="GlorpExpressions">notEmpty	"Only useful for mappings that represent collections. This checks to see if the collection has elements by building a not exists subselect."		^self base existenceCheck: self as: #exists:</body><body package="GlorpExpressions">referenceClass	"Return the class that our mapping refers to, if we have a mapping. If we're a base expression, just return our class, and if we're a table expression, just return nil."	^self mapping referenceClass.</body><body package="GlorpExpressions">sqlSelect: anExpression	"Only useful for mappings that represent collections. This restricts the range of values in a variable. Most useful as part of an aggregation. e.g.     read: SomeClass where: [:each | (each collection select: [:eachItem | eachItem attribute = someValue]) sqlCount &gt; 10]"	"We may be passed an expression corresponding to either a field, or to a full object, depending on the aggregate function. In either case, build backwards from the first full object"	| objectExpression newMapping previousJoin |	objectExpression := self mapping isRelationship 		ifTrue: [self] ifFalse: [self base].	newMapping := self mapping class new.	newMapping attributeName: #temporaryAttributeFromSubselect.	newMapping referenceClass: self mapping referenceClass.	newMapping descriptor: self mapping descriptor.	newMapping linkFields: self mapping linkFields.	newMapping usesLinkTable: self mapping usesLinkTable.	previousJoin := self mapping join.	newMapping join: ((anExpression rebuildOn: previousJoin ultimateBaseExpression startingFrom: self) AND: previousJoin asGlorpExpression).	^objectExpression base getMapping: newMapping named: ( 'a temporary restricted mapping for #select: based on ', self mapping attributeName).</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>navigating</category><body package="GlorpExpressions">penultimateBaseExpression	"Return the one from the last base expression in our tree. Useful if we want to find the first mapping involved in the expression"	self base base isNil ifTrue: [^self].	^self base penultimateBaseExpression.</body><body package="GlorpExpressions">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>printing</category><body package="GlorpExpressions">printOnlySelfOn: aStream	aStream nextPutAll: name.	self printTableAliasesOn: aStream.</body><body package="GlorpExpressions">printTreeOn: aStream 	aStream		print: base;		nextPut: $.;		nextPutAll: (name isString ifTrue: [name] ifFalse: [name printString])</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>fields</category><body package="GlorpExpressions">aliasedTableFor: aDatabaseTable 	^self controlsTables 		ifTrue: [super aliasedTableFor: aDatabaseTable]		ifFalse: [base aliasedTableFor: (self mapping translateTable: aDatabaseTable)]</body><body package="GlorpExpressions">aliasedTableFor: aDatabaseTable ifAbsent: aBlock	^self controlsTables 		ifTrue: [super aliasedTableFor: aDatabaseTable ifAbsent: aBlock]		ifFalse: [base aliasedTableFor: aDatabaseTable ifAbsent: aBlock]</body><body package="GlorpExpressions">controlsTables	| theMapping |	theMapping := self mappingFromMeOrSubclasses.	theMapping isNil ifTrue: [^true].	^theMapping controlsTables</body><body package="GlorpExpressions">translateField: aDatabaseField	^super translateField: (self mapping translateField: aDatabaseField)</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary 	self hasField ifFalse: [^self].	self field asField printSelectSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary 	self hasField ifFalse: [^self].	self field asField printSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions">printUnqualifiedSQLOn: aStream withParameters: aDictionary 	self field asField printUnqualifiedSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>converting</category><body package="GlorpExpressions">convertedDbValueOf: anObject	^self mapping convertedDbValueOf: anObject.</body><body package="GlorpExpressions">convertedStValueOf: anObject	^self mapping convertedStValueOf: anObject.</body><body package="GlorpExpressions">expandConditionalLeftChildOf: aRelationExpression 	"We are the base (left child) of aRelationExpression.  Our mapping is a ConditionalMapping so we must be expanded to check all our cases.  This simple implementation - to be developed further - works for nil / notNil comparisons."	| expression rightChild |	rightChild := aRelationExpression rightChild.	(rightChild isConstantExpression and: [rightChild value isNil]) ifFalse: [^self error: 'Conditionals can only compare to nil as yet'].	self mapping casesDo:		[:eachCase || leftChild clause |		leftChild := self shallowCopy privateAndBasicResetMapping: eachCase.		clause := aRelationExpression shallowCopy leftChild: leftChild; rightChild: rightChild.		expression := leftChild mapping class == ConstantMapping			ifFalse: [aRelationExpression relation = #&lt;&gt; ifTrue: [clause OR: expression] ifFalse: [clause AND: expression]]			ifTrue: [expression]].	^expression</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder	^self valueInBuilder: anElementBuilder as: self base.</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder as: anExpression	^self mapping valueIn: anElementBuilder as: anExpression.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>private/accessing</category><body package="GlorpExpressions">requiresDistinct: aBoolean	super requiresDistinct: aBoolean.	base requiresDistinct: aBoolean.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>internal</category><body package="GlorpExpressions">allRelationsFor: rootExpression	^self mapping allRelationsFor: rootExpression.</body><body package="GlorpExpressions">mapping	mapping isNil ifTrue: [		| descriptor |		descriptor := self sourceDescriptor.		descriptor isNil ifTrue: [^nil].		mapping := descriptor mappingForAttributeNamed: name].	^mapping.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree"	| myField |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.	(self hasField and: [(myField := self field) isGlorpExpression])		ifTrue: [myField do: aBlock skipping: aSet].</body><body package="GlorpExpressions">mappableFieldsDo: aBlock	"Used when we are emulating a Join"	self allSourceFields with: self allTargetFields do: [:source :target |		source isMappable ifTrue: [aBlock value: source value: target]].</body><body package="GlorpExpressions">mappableSourceFieldsDo: aBlock	"Used when we are emulating a Join"	self allSourceFields do: [:source |		source isMappable ifTrue: [aBlock value: source]].</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>initialize</category><body package="GlorpExpressions">initialize	super initialize.	phantom := false.</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>inspecting</category><body package="GlorpExpressions">inspectorChildren	^Array with: base</body></methods><methods><class-id>Glorp.MappingExpression</class-id> <category>recursion</category><body package="GlorpExpressions">createMappingToFieldInRecursionTable: aDatabaseTable	"The commented-out code is trebly erroneous.  Firstly, it mismatches due to uppercase/lowercase clashes between original field and recursion table field.  Secondly, where the original field is a relationship, the recursion table concatenates the name, leaving potentially wrong set primaryKey fields if e.g. we have an ancestor primaryKey field which will have the same value in many rows.  Finally it is clear (on postgres at least) that recursion tables ignore primaryKey fields."	| newField newMapping |	newField := aDatabaseTable		createFieldNamed: self commonTableExpressionName		type: self mapping field type.	"(self mapping field name = newField name		and: [self mapping field isPrimaryKey])			ifTrue: [newField bePrimaryKey]."	newMapping := self mapping isRelationship		ifTrue: [DirectMapping new]		ifFalse: [self mapping copy].	newMapping field: newField.	^newMapping</body></methods><methods><class-id>Glorp.MappingExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">named: aSymbol basedOn: anExpression	^self new		named: aSymbol		basedOn: anExpression.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase">bindReturningVariableAt: index forStatement: statement	"See accessors where this is defined for guidance in how to define it on others."	^self subclassResponsibility</body><body package="GlorpDatabase">connection	^connection</body><body package="GlorpDatabase">connection: aPlatformDatabaseConnection	connection := aPlatformDatabaseConnection</body><body package="GlorpDatabase">connectionClass	^self connectionClassForLogin: currentLogin</body><body package="GlorpDatabase">connectionClassForLogin: aLogin	^self subclassResponsibility.</body><body package="GlorpDatabase">currentLogin	^currentLogin</body><body package="GlorpDatabase">currentLogin: aLogin 	currentLogin := aLogin</body><body package="GlorpDatabase">deniedCommands	^deniedCommands.</body><body package="GlorpDatabase">encoding	"The connection is specific to the dialect;  some dialects will need to override this method."	^connection encoding</body><body package="GlorpDatabase">encoding: aSymbol	"The platform is a Glorp databasePlatform, so its setter code is generic across all dialects.  The connection is specific to the dialect;  some dialects will need to override how its encoding is set.  In the hope that most dialects will find this works for them, and that coders porting to dialects in which it does not will benefit from seeing the walkback and knowing they have something to do, we attempt to set both at top level."	self platform characterEncoding: aSymbol.	connection encoding: aSymbol.</body><body package="GlorpDatabase">numberOfPreparedStatements	^0</body><body package="GlorpDatabase">platform	^currentLogin database.</body><body package="GlorpDatabase">returnRowCount: aBoolean	^self.</body><body package="GlorpDatabase">reusePreparedStatements	^reusePreparedStatements and: [self useBinding]</body><body package="GlorpDatabase">reusePreparedStatements: aBoolean	reusePreparedStatements := aBoolean.</body><body package="GlorpDatabase">schema	^ self currentLogin schema</body><body package="GlorpDatabase">useBinding	^self platform useBinding.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase">isLoggedIn	^self subclassResponsibility</body><body package="GlorpDatabase">login	"In 8.1 and earlier, this return nil.  It now returns self, as #loginIfError: does."	self loginIfError: [:ex | ex pass].</body><body package="GlorpDatabase">loginIfError: aBlock	self subclassResponsibility.</body><body package="GlorpDatabase">logout	^self subclassResponsibility.</body><body package="GlorpDatabase">reLogin	"Attempt to re-login to a database that's not responding. Give it a maximum of 5 attempts."	| attempts |	attempts := 0.	[attempts &lt; 5 and: [self isLoggedIn not]] whileTrue: [		attempts := attempts + 1.		self loginIfError: [:ex | nil]].</body><body package="GlorpDatabase">showDialog: aString	self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>copying</category><body package="GlorpDatabase">copy	^self shallowCopy postCopy.</body><body package="GlorpDatabase">postCopy</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>logging</category><body package="GlorpDatabase">endLogging	self logger: nil.	self logging: false.	self logOnly: false.</body><body package="GlorpDatabase">log: aStringOrBlock	"Log an arbitrary string"	| string |	self logging ifFalse: [^self].	string := aStringOrBlock isString		ifTrue: [aStringOrBlock]		ifFalse: [aStringOrBlock value].	self logString: string.</body><body package="GlorpDatabase">logCommand: aDatabaseCommand bound: aBoolean	"Log the execution of a command"	| string |	self changed: #command: with: aDatabaseCommand.	self logging ifFalse: [^self].	string := aDatabaseCommand sqlString. 	aBoolean ifTrue: [string := string , '  ' , aDatabaseCommand bindings printString].	self logString: string.</body><body package="GlorpDatabase">logError: anErrorObject 	self log: anErrorObject printString</body><body package="GlorpDatabase">logOnly	logOnly ifNil: [logOnly := false].	^logOnly and: [self logging]</body><body package="GlorpDatabase">logOnly: aBoolean	logOnly := aBoolean</body><body package="GlorpDatabase">logOnlyOn: aTextCollector	"logOnly implies you're logging and that you have a logger, so combine setting them into a single method (inverse is #endLogging)."	self logger: aTextCollector.	self logging: true.	self logOnly: true.</body><body package="GlorpDatabase">logTime: aTimeOrBlock	| time |	self logOnly ifTrue: [^self].	self changed: #time: with: aTimeOrBlock.	self logging ifFalse: [^self].	time := (Dialect isBlock: aTimeOrBlock)		ifTrue: [aTimeOrBlock value]		ifFalse: [aTimeOrBlock].	self logString: '(' , (time / 1000.0) printString , ' s)'.</body><body package="GlorpDatabase">logger	^logger ifNil: [Transcript]</body><body package="GlorpDatabase">logger: aTextCollector	logger := aTextCollector</body><body package="GlorpDatabase">logging	logging isNil ifTrue: [^self class loggingEnabled].	^logging.</body><body package="GlorpDatabase">logging: aBoolean 	logging := aBoolean</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase">addConstraint: aConstraint 		^self 		addConstraint: aConstraint		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Add constraint &lt;1s&gt; ERROR: (&lt;2s&gt;) ' expandMacrosWith: aConstraint name with: msg).				ex return: nil].</body><body package="GlorpDatabase">addConstraint: aConstraint ifError: aBlock	| addString |	addString := self platform createConstraintAddStatement: aConstraint.	addString isEmpty ifTrue: [^self].	"If platform does not support constraints, silently do nothing."	^self		executeInDDLOperation: [self executeSQLStringNoResult: addString]		ifError: aBlock</body><body package="GlorpDatabase">addFields: aCollection 	self 		addFields: aCollection 		ifError: [ :ex  | 	| msg |				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Add field ERROR: (&lt;2s&gt;) ' expandMacrosWith: msg).				ex return: nil]</body><body package="GlorpDatabase">addFields: aCollection ifError: aBlock	aCollection		do: 	[:aField | 			self execute: [self executeSQLStringNoResult: (self platform createAddColumnStatementFor: aField)]				ifError: aBlock ].</body><body package="GlorpDatabase">alterField: aField newType: aType 	^self 		alterField: aField 		newType: aType 		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column &lt;1s&gt; to set new type &lt;2s&gt; ERROR: (&lt;3s&gt;) ' expandMacrosWith: aField name with: aType sqlString with: msg).				ex return: nil].</body><body package="GlorpDatabase">alterField: aField newType: aType ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatement: aField newType: aType)]			ifError: aBlock ]</body><body package="GlorpDatabase">alterField: aField setDefault: aType	self 		alterField: aField 		setDefault: aType 		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column  &lt;1s&gt; to set default &lt;2s&gt;  ERROR: (&lt;2s&gt;) ' expandMacrosWith: aField name with: aType sqlString with: msg).				ex return: nil].</body><body package="GlorpDatabase">alterField: aField setDefault: anObject ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatement: aField setDefault: anObject )]			ifError: aBlock ]</body><body package="GlorpDatabase">alterFieldDropDefault: aField	self 		alterFieldDropDefault: aField 		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column  &lt;1s&gt; to drop default ERROR: (&lt;2s&gt;) ' expandMacrosWith: aField name  with: msg).				ex return: nil].</body><body package="GlorpDatabase">alterFieldDropDefault: aField ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatementDropDefault: aField)]			ifError: aBlock ]</body><body package="GlorpDatabase">alterFieldDropNotNull: aField	self 		alterFieldDropNotNull: aField 		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column  &lt;1s&gt; to drop not null ERROR: (&lt;2s&gt;) ' expandMacrosWith: aField name  with: msg).				ex return: nil].</body><body package="GlorpDatabase">alterFieldDropNotNull: aField ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatementDropNotNull: aField)]			ifError: aBlock ]</body><body package="GlorpDatabase">alterFieldSetNotNull: aField		self 		alterFieldSetNotNull: aField		ifError: [ :ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Alter column  &lt;1s&gt; to set not null ERROR: (&lt;2s&gt;) ' expandMacrosWith: aField name  with: msg).				ex return: nil].</body><body package="GlorpDatabase">alterFieldSetNotNull: aField ifError: aBlock	^self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: 						(self platform createAlterColumnStatementSetNotNull: aField)]			ifError: aBlock ]</body><body package="GlorpDatabase">basicExecuteSQLString: aString	self subclassResponsibility.</body><body package="GlorpDatabase">basicExecuteSQLString: aString bindingArray: aBindingArray	self subclassResponsibility.</body><body package="GlorpDatabase">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock	^self subclassResponsibility</body><body package="GlorpDatabase">basicExecuteSQLStringNoResult: aString doing: aBlock	^self basicExecuteSQLString: aString returnResult: false binding: nil doing: aBlock.</body><body package="GlorpDatabase">copyDataFromField: fromField toField: toField ifError: errorBlock	self		executeInDDLOperation: [ self executeSQLStringNoResult: (self platform sqlStatementToCopyDataFromColumn: fromField to: toField )]		ifError: errorBlock</body><body package="GlorpDatabase">copyDataFromTable: fromTable toTable: anotherTable ifError: errorBlock	self		executeInDDLOperation: [ self executeSQLStringNoResult: (self platform sqlStatementToCopyDataFromTable: fromTable to: anotherTable) ]		ifError: errorBlock</body><body package="GlorpDatabase">createIndex: aGlorpDatabaseIndex forTable: aGlorpDatabaseTable ifError: aBlock	self 		execute:			[self executeSQLStringNoResult:				(self platform 					createTableIndexStatementStringFor: aGlorpDatabaseTable					index: aGlorpDatabaseIndex)]		ifError: aBlock.</body><body package="GlorpDatabase">createSequence: aDatabaseSequence ifError: aBlock 	self		executeInDDLOperation: [ self executeSQLStringNoResult: aDatabaseSequence creationString]		ifError: aBlock</body><body package="GlorpDatabase">createTable: aGlorpDatabaseTable ifError: aBlock 	"This method should be used to create a database table from aTable"	aGlorpDatabaseTable isImaginary ifTrue: [^self].	self		executeInDDLOperation: [			self executeSQLStringNoResult: (self platform createTableStatementStringFor: aGlorpDatabaseTable)]		ifError: aBlock</body><body package="GlorpDatabase">createTableFKConstraints: aGLORBDatabaseTable ifError: aBlock 	"This method should be used to define foreign key constraints for a database table from aTable"	aGLORBDatabaseTable foreignKeyConstraintsForCreation		do: [ :each | self addConstraint: each ifError: aBlock ].</body><body package="GlorpDatabase">createTableIndexes: aGlorpDatabaseTable ifError: aBlock	"Create all indexes for this table"	aGlorpDatabaseTable indexes do: 		[:eachIndex |		self createIndex: eachIndex forTable: aGlorpDatabaseTable ifError: aBlock].</body><body package="GlorpDatabase">dropConstraint: aConstraint	^self 		dropConstraint: aConstraint 		ifError: [ :ex || msg |				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'no error message provided for top level exception'].				self log: ('Drop constraint &lt;1s&gt; ERROR: (&lt;2s&gt;'  expandMacrosWith: aConstraint name with: msg).				ex return: nil].</body><body package="GlorpDatabase">dropConstraint: aConstraint ifError: aBlock	| dropString |	dropString := self platform createConstraintDropStatement: aConstraint.	dropString isEmpty ifTrue: [^self].	self		executeInDDLOperation: [ self executeSQLStringNoResult: dropString ]		ifError:aBlock</body><body package="GlorpDatabase">dropFields: aCollection 	self 		dropFields: aCollection 		ifError: [ :ex  | 	| msg |				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Drop field ERROR: (&lt;2s&gt;) ' expandMacrosWith: msg).				ex return: nil]</body><body package="GlorpDatabase">dropFields: aCollection ifError: aBlock	aCollection		do: 	[:aField | 			self execute: [self executeSQLStringNoResult: (self platform createDropColumnStatementFor: aField)]				ifError: aBlock ].</body><body package="GlorpDatabase">dropForeignKeyConstraintsForTable: aTable ifError: aBlock 	aTable isImaginary ifTrue: [^self].	aTable foreignKeyConstraints do: [:each | self dropConstraint: each ifError: [ :ex | aBlock value: ex]].</body><body package="GlorpDatabase">dropSequence: aDatabaseSequence ifAbsent: aBlock 	self		executeInDDLOperation: [ self executeSQLStringNoResult: aDatabaseSequence dropString ]		ifError: aBlock</body><body package="GlorpDatabase">dropSequences: anArray	anArray do:		[:each |		self			dropSequence: each			ifAbsent:				[:ex | 				self log: (ex messageText ifNil: [ex printString]).				ex return: nil]].</body><body package="GlorpDatabase">dropTable: aTable ifError: aBlock 	aTable isImaginary ifTrue: [^self].	self dropForeignKeyConstraintsForTable: aTable ifError: aBlock.	self dropTableDefinition: aTable ifError: aBlock.</body><body package="GlorpDatabase">dropTableDefinition: aTable ifError: aBlock	"The dropping of the primary key constraints (a singular object not a collection, despite its name) is probably not needed before dropping the table by any database platform.  If 'platform supportsConstraints' is false then it will not be done, since dropConstraint:ifError: assumes it is called on a foreign key constraint (the case in all other callers) and does nothing if the platform does not support them."	aTable isImaginary ifTrue: [^self].	aTable hasPrimaryKeyConstraints ifTrue: [self dropConstraint: aTable  primaryKeyConstraints ifError: [:ex | aBlock value: ex]].	self dropTableNamed: aTable qualifiedName ifAbsent: aBlock.</body><body package="GlorpDatabase">dropTableNamed: aString 	self 		dropTableNamed: aString 		ifAbsent: [:ex | 	| msg|				msg := ex messageText.				msg isEmpty ifTrue: [msg := 'No error message provided for top level exception.'].				Transcript cr; show: ('Drop table &lt;1s&gt; ERROR: (&lt;2s&gt;) ' expandMacrosWith: aString with: msg).				ex return: nil]</body><body package="GlorpDatabase">dropTableNamed: aString ifAbsent: aBlock 	self doDDLOperation: [		self 			execute: [self executeSQLStringNoResult: (self platform createDropTableStatementFor: aString )]			ifError: aBlock].</body><body package="GlorpDatabase">dropTables: anArray	anArray do: [:eachTable |				eachTable foreignKeyConstraints					do: [:eachConstraint | self dropConstraint: eachConstraint]].	anArray do: [:each |				self dropTableDefinition: each					ifError: [ :ex || msg |							msg := ex messageText.							msg isEmpty ifTrue: [msg := 'no error message provided for top level exception'].							self log: 'ERROR : (', msg, ' )'.							ex return: nil]].</body><body package="GlorpDatabase">errorsToCatch	^Dialect error.</body><body package="GlorpDatabase">execute: aBlock	^self execute: aBlock ifError: [:ex | ex pass].</body><body package="GlorpDatabase">execute: aBlock ifError: errorBlock	^aBlock on: self errorsToCatch do: errorBlock.</body><body package="GlorpDatabase">executeCommand: command	^self executeCommand: command returnCursor: false.</body><body package="GlorpDatabase">executeCommand: command returnCursor: aBoolean	^mutex		critical:			[| result |			self checkPermissionFor: command.			result := [(self useBinding and: [command useBinding])				ifTrue: [command executeBoundIn: self]				ifFalse: [command executeUnboundIn: self]]				on: Dialect error				do: [:ex | self handleError: ex for: command].			aBoolean ifTrue: [result] ifFalse: [result upToEnd]].</body><body package="GlorpDatabase">executeCommandBound: command	"By default, we don't handle binding"	^command executeUnboundIn: self.</body><body package="GlorpDatabase">executeCommandUnbound: aCommand	| cursor |	self logCommand: aCommand sqlString bound: false.	self logOnly ifTrue: [^self].	cursor := self basicExecuteSQLString: aCommand sqlString.	cursor command: aCommand.	^cursor.</body><body package="GlorpDatabase">executeSQLString: aString	| result block time |	self log: aString.	self logOnly ifTrue: [^self].	block := [result := (self basicExecuteSQLString: aString) upToEnd].	time := self logging		ifTrue: [Time millisecondsToRun: block]		ifFalse:			[block value.			0].	self logTime: time.	^result.</body><body package="GlorpDatabase">executeSQLString: aString binding: aBindingArray	| result block time |	self log: aString.	self logOnly ifTrue: [^self].	block := [ 		result := (self basicExecuteSQLString: aString binding: aBindingArray) upToEnd].	time := self logging		ifTrue: [Time millisecondsToRun: block]		ifFalse:			[block value.			0].	self logTime: time.	^result.</body><body package="GlorpDatabase">executeSQLStringNoResult: aString	^self		executeSQLStringNoResult: aString		doing: []		forCommand: nil.</body><body package="GlorpDatabase">executeSQLStringNoResult: aString doing: aBlock forCommand: aCommand	"Execute the string and discard the result. Evaluate aBlock before releasing the statement's answer stream"	| block time |	aCommand isNil ifTrue: [self log: aString] ifFalse: [self logCommand: aCommand bound: false].	self logOnly ifTrue: [^self].	block := [self basicExecuteSQLStringNoResult: aString doing: aBlock].	time := self logging		ifTrue: [Time millisecondsToRun: block]		ifFalse:			[block value.			0].	self logTime: time.</body><body package="GlorpDatabase">executeSQLStringsNoResult: aString	"Executing an empty string returns an empty result, which then DNUs when sent #first, arguably a bug but while it exists we must avoid it.  We therefore check the supplied parameter size (to check for nil or empty) and exit quietly if so."	aString size = 0 ifTrue: [^self].	(aString tokensBasedOn: $;)		do: [:each | each notEmpty ifTrue: [self executeSQLStringNoResult: each]].</body><body package="GlorpDatabase">externalDatabaseErrorSignal	self subclassResponsibility.</body><body package="GlorpDatabase">handleError: exception for: command	"Signal a GlorpDatabase... error.  If it is handled to return true (any handler or defaultAction had better not return true in response to an error that logging in or logging out could reraise and on which it would again return true) and we have a reusable login, try to logout and in again and restart, otherwise exit."	| errorClass error |	errorClass := command isReadCommand		ifTrue: [GlorpDatabaseReadError]		ifFalse: [GlorpDatabaseWriteError].	error := errorClass new.	error command: command.	error databaseError: (self innerExceptionFor: exception).	error accessor: self.	(error signal ~~ true or: [currentLogin isNil or: [currentLogin secure]])		ifTrue: [exception return: nil]		ifFalse:			[self reset.			self logout.			self reLogin.			exception restart].</body><body package="GlorpDatabase">innerExceptionFor: exception	^exception parameter.</body><body package="GlorpDatabase">populateField: aDatabaseField with: aValue ifError: errorBlock	self		executeInDDLOperation: [			self executeSQLStringNoResult: (self platform sqlStatementToPopulateColumn: aDatabaseField with: aValue) ]		ifError: errorBlock</body><body package="GlorpDatabase">renameField: aDatabaseField to: nameString ifError: errorBlock	self		executeInDDLOperation: [ self executeSQLStringNoResult: (self platform sqlStatementToRenameColumn: aDatabaseField to: nameString) ]		ifError: errorBlock</body><body package="GlorpDatabase">renameTable: aDatabaseTable to: newTableName inPlatform: aDatabasePlatform ifError: errorBlock	| sqlStatement |	sqlStatement := aDatabasePlatform sqlStatementToRenameTable: aDatabaseTable to: newTableName.		self		executeInDDLOperation: [ self executeSQLStringNoResult: sqlStatement ]		ifError: errorBlock</body><body package="GlorpDatabase">rowCount	^self subclassResponsibility</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>permissions</category><body package="GlorpDatabase">allowCommand: aCommand during: aBlock	"If deniedCommands is nil, everything is already permitted;  just evaluate the block.  Otherwise, permit the command and any subclasses, evaluate the block, then revert."	| oldCommands |	oldCommands := deniedCommands ifNil: [^aBlock value].	aCommand withAllSubclasses do:		[:each |		(deniedCommands includes: each) ifTrue:			[deniedCommands := deniedCommands copyWithout: aCommand]].	^aBlock ensure: [deniedCommands := oldCommands]</body><body package="GlorpDatabase">alsoDenyCommand: aCommand	"Use this method, not denyCommand: when you want to add to, not override, the current permissions state."	self deniedCommands isNil		ifTrue: [self denyCommand: aCommand]		ifFalse: [deniedCommands := deniedCommands , aCommand withAllSubclasses].</body><body package="GlorpDatabase">beReadOnly	self denyWrites.</body><body package="GlorpDatabase">checkPermissionFor: command	deniedCommands isNil ifTrue: [^self].	(deniedCommands includes: command class)		ifTrue: [(GlorpIllegalCommand new command: command) signal].</body><body package="GlorpDatabase">denyCommand: aCommand	"Use this method, not alsoDenyCommand: when you want to override, not just add to, the current permissions state."	deniedCommands := aCommand withAllSubclasses.</body><body package="GlorpDatabase">denyCommands: databaseCommandClasses	"It seems unlikely someone would deliberately with to deny a command but permit its subclass.  We can defer offering an accessor for that until the case arises."	deniedCommands := (databaseCommandClasses		inject: (OrderedCollection new: databaseCommandClasses size * 6)		into: [:all :each | all addAll: each withAllSubclasses. all])			asArray.</body><body package="GlorpCore">denyReads	deniedCommands := SelectCommand allSubclasses.</body><body package="GlorpCore">denyWrites	deniedCommands := RowBasedCommand allSubclasses.</body><body package="GlorpCore">insertOnly	deniedCommands := Array with: UpdateCommand withAllSubclasses with: DeleteCommand.</body><body package="GlorpCore">permitEverything	"Note that nil is treated as a flag indicating that all commands are allowed"	deniedCommands := nil.</body><body package="GlorpCore">permitEverythingDuring: aBlock	| oldCommands |	oldCommands := self deniedCommands.	self permitEverything.	^aBlock ensure: [deniedCommands := oldCommands]</body><body package="GlorpCore">permitNothing	deniedCommands := DatabaseCommand allSubclasses asArray.</body><body package="GlorpCore">permitNothingDuring: aBlock	| oldCommands |	oldCommands := self deniedCommands.	self permitNothing.	^aBlock ensure: [deniedCommands := oldCommands]</body><body package="GlorpCore">permitsInserts	deniedCommands isNil ifTrue: [^true].	^(deniedCommands includes: InsertCommand) not.</body><body package="GlorpCore">permitsUpdates	deniedCommands isNil ifTrue: [^true].	^(deniedCommands includes: UpdateCommand) not.</body><body package="GlorpDatabase">resetPermissions	self permitEverything.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>cursors</category><body package="GlorpDatabase">completedCommand: aCommand	"Indicate that we've completed the command. Release associated resources."	^self.</body><body package="GlorpDatabase">cursorFor: aStream	^GlorpCursoredStream on: aStream accessor: self.</body><body package="GlorpDatabase">cursorFor: answerStream command: aCommand	^aCommand isNil		ifTrue: [self cursorFor: answerStream]		ifFalse: [GlorpCursoredStream on: answerStream for: aCommand accessor: self].</body><body package="GlorpDatabase">isCursorAtEnd: aCursor	"Return true if aCursor is at its end. This implementation may not work for all, but it seems like a reasonable default"	^aCursor atEnd.</body><body package="GlorpDatabase">upToEndOfResultSet: aGlorpCursoredStream	"The statement may have multiple result sets.  If the caller sends #upToEnd, the aggressive releasing of the cursor in #atEnd will lose any remaining result sets.  We therefore read the current result set and advance the underlying cursor to the next result set, releasing the Glorp cursor if we're called on the last result set.  (N.B. 'the next result set' does not necessarily mean the return of the next statement;  in a sequence of statements, some may return result sets while others return #noAnswerStream and these will be skipped)."	^self subclassResponsibility</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>notification</category><body package="GlorpDatabase">myDependents	^dependents.</body><body package="GlorpDatabase">myDependents: aCollection	dependents := aCollection.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase">beginTransaction	^self subclassResponsibility.</body><body package="GlorpDatabase">commitTransaction	^self subclassResponsibility.</body><body package="GlorpDatabase">doDDLOperation: aBlock	"Execute DDL SQL - something which creates/drops/modifies tables or other schema information. The main reason for this method is that some databases require a transaction, while others don't require it, and still others don't allow it. Try to do the right thing."		^self platform requiresTransactionForTableOperations		ifTrue: [self inTransactionDo: aBlock]		ifFalse: aBlock.</body><body package="GlorpDatabase">executeInDDLOperation: aBlock ifError: errorBlock	"Execute DDL SQL - something which creates/drops/modifies tables or other schema information. The main reason for this method is that some databases require a transaction, while others don't require it, and still others don't allow it. Try to do the right thing."	^ self doDDLOperation: [		self			execute: aBlock			ifError: errorBlock ]</body><body package="GlorpDatabase">inTransactionDo: aBlock	"Execute aBlock in a database transaction. If one is already in progress, just continue. If not, start a transaction."	| alreadyInTransaction result |	[ 	alreadyInTransaction := self isInTransaction.	alreadyInTransaction ifFalse: [self beginTransaction].	result := aBlock numArgs = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value].	alreadyInTransaction ifFalse: [self commitTransaction]]		ifCurtailed:			[alreadyInTransaction ifFalse: [self rollbackTransaction]].	^result.</body><body package="GlorpDatabase">isInTransaction	^self subclassResponsibility.</body><body package="GlorpDatabase">rollbackTransaction	^self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>obsolete</category><body package="GlorpCore">createConstraint: aConstraint	^self addConstraint: aConstraint</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	deniedCommands := nil.	mutex := Semaphore forMutualExclusion.</body><body package="GlorpDatabase">reset	"Don't reset the permissions, because the replicator wants to reset sessions without changing their characteristics""	self permitEverything."</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>testing</category><body package="GlorpDatabase">isExistingTable: tableName inSchema: schemaName	"When the platform is SQL Server, the statement returned is of the formSELECT count(*) FROM schema_name.INFORMATION_SCHEMA.TABLES WHERE lower(table_name) = 'tw_databaseidentifier';If schema_name is absent, the above statement produces an error (e.g. an unableToExecuteSQLSignal in VW).  The correct and dialect-neutral fix is for this method to guard-test for owner/schema existence where used."	| databasePlatform sqlStatement result targetSchemaName |	databasePlatform := self currentLogin platform.	targetSchemaName := databasePlatform supportsInformationSchema		ifTrue: [schemaName]		ifFalse: [''].	databasePlatform isSQLServerPlatform ifTrue:		[sqlStatement := databasePlatform sqlStatementToTestExistenceOfSchema: schemaName.			result := self executeSQLString: sqlStatement.		result notEmpty ifTrue:			[result first first &gt; 0 ifFalse: [^false]]].	sqlStatement := databasePlatform sqlStatementToTestExistenceOfTable: tableName inSchema: targetSchemaName.	result := self executeSQLString: sqlStatement.	^result notEmpty		ifTrue: [result first first &gt; 0]		ifFalse: [false]</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>queries metadata</category><body package="GlorpDatabase">listTableNamesInSchemaNamed: schemaString	| databasePlatform sqlStatement result |	databasePlatform := self currentLogin platform.	sqlStatement := databasePlatform sqlStatementToListTablesInSchema: schemaString.	result := self executeSQLString: sqlStatement.	^result isEmpty		ifTrue: [#()]		ifFalse: [result collect: [:ea| ea first]]</body></methods><methods><class-id>Glorp.DatabaseAccessor</class-id> <category>private</category><body package="GlorpDatabase">logString: aString	| stringToLog |	stringToLog := aString size &gt; 4000 		ifTrue: [aString copyFrom: 1 to: 4000]		ifFalse: [aString].	self logger		cr;		show: stringToLog.	(self logOnly and: [stringToLog notEmpty and: [stringToLog last ~= $;]])		ifTrue: [self logger show: ';'].</body></methods><methods><class-id>Glorp.DatabaseAccessor class</class-id> <category>instance creation</category><body package="GlorpDatabase">classForThisPlatform	Dialect isVisualWorks ifTrue: [^Dialect smalltalkAt: #'Glorp.VWDatabaseAccessor'].	Dialect isObjectStudio ifTrue: [^Dialect smalltalkAt: #ObjectStudioDatabaseAccessor].	Dialect isGNU ifTrue: [^Dialect smalltalkAt: #JdmDatabaseAccessor].	Dialect isSqueak ifTrue: [^Dialect smalltalkAt: #SqueakDatabaseAccessor].	Dialect isVisualAge ifTrue: [^Dialect smalltalkAt: #VADatabaseAccessor].	Dialect isDolphin ifTrue: [^Dialect smalltalkAt: #DolphinDatabaseAccessor].	self error: 'unknown dialect'.	^self</body><body package="GlorpDatabase">forLogin: aLogin 	^self classForThisPlatform new currentLogin: aLogin</body><body package="GlorpDatabase">new	^super new initialize.</body></methods><methods><class-id>Glorp.DatabaseAccessor class</class-id> <category>accessing</category><body package="GlorpDatabase">loggingEnabled	LoggingEnabled isNil ifTrue: [LoggingEnabled := false].	^LoggingEnabled</body><body package="GlorpDatabase">loggingEnabled: aBoolean 	LoggingEnabled := aBoolean</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase">basicExecuteSQLString: aString	^self basicExecuteSQLString: aString binding: nil</body><body package="GlorpDatabase">executeCommandUnbound: aCommand	| answerStream |	self log: aCommand sqlString.	"change to self logCommand: aCommand sqlString bound: false."	self logOnly ifTrue: [^self].	answerStream := self		basicExecuteSQLStringWithResult: aCommand sqlString		doing: [].	"See new method #answerForCommand:fromDBSession: in VWDatabaseAccessor - it _may_ be advantageous to use something similar here "	aCommand needsRowCount ifTrue:		[aCommand rowCount:			((self platform supportsRowCountFor: aCommand)				ifTrue: [answerStream rowCount]				ifFalse: [1])].	^self cursorFor: answerStream command: aCommand</body><body package="GlorpDatabase">externalDatabaseErrorSignal	^self class externalDatabaseErrorSignal.</body><body package="GlorpDatabase">innerExceptionFor: exception	^exception exception.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase">returnRowCount: aBoolean	connection isNil ifFalse: [connection queryRowCount: true].</body><body package="GlorpDatabase">rowCount	^connection rowCount.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase">beginTransaction	self log: 'Begin Transaction'.	isInTransaction := true.	self logOnly ifTrue: [^self].	self connection beginUnitOfWork.</body><body package="GlorpDatabase">commitTransaction	self log: 'Commit Transaction'.	isInTransaction := false.	self logOnly ifTrue: [^self].	self connection commitUnitOfWorkIfError: 			[:err |			self log: 'Commit Transaction failed.'. 			self connection autoCommit: true.			self todo: 'Need to handle this error somehow....'.			"errorBlock value: err"].</body><body package="GlorpDatabase">isInTransaction	^isInTransaction</body><body package="GlorpDatabase">rollbackTransaction	self log: 'Rollback Transaction'.	isInTransaction := false.	self logOnly ifTrue: [^self].	self connection rollbackUnitOfWork.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase">connectionClassForLogin: aLogin 	aLogin database isDB2Platform ifTrue: [^ Smalltalk at: #AbtIbmCliDatabaseManager].	aLogin database class == OraclePlatform 		ifTrue: [^Smalltalk at: #AbtOracle10DatabaseManager].	aLogin database isODBCPlatform 		ifTrue: [^Smalltalk at: #AbtOdbcDatabaseManager].	aLogin database isPostgreSQLPlatform 		ifTrue: [self error: 'PostgreSQL is not yet supported under VA'].	self error: 'Unknown database platform' , aLogin database printString</body><body package="GlorpDatabase">isLoggedIn	^connection notNil</body><body package="GlorpDatabase">logStream	^Transcript</body><body package="GlorpDatabase">loginIfError: aBlock 	"		This method creates a NEW database connection.	"	| dbMgrClass anAbtDatabaseLogonSpec anAbtDatabaseConnectionSpec aliasNameString baseAliasName |	self log: 'Login'.	self logOnly ifTrue: [^self].	aliasNameString := baseAliasName := currentLogin connectString.	"		We try to generate a unique alias name to get a new connection and to 		prevent the normal VAST behaviour to reuse a connection	"		[((Smalltalk at: #AbtDbmSystem) 		activeDatabaseConnectionWithAlias: aliasNameString) notNil] 			whileTrue: 				[aliasNameString := baseAliasName , Time millisecondClockValue printString].	"		Get the native VA class responsible for doing the work against the		three special connections available in VA	"	dbMgrClass := self connectionClass.	"		Get the logon specification for the database ... do not use		any server information	"	anAbtDatabaseLogonSpec := (Smalltalk at: #AbtDatabaseLogonSpec) 				id: currentLogin username				password: currentLogin password				server: self serverName.	"			Get the specification for the connection ...    "	anAbtDatabaseConnectionSpec := (Smalltalk at: #AbtDatabaseConnectionSpec) 				forDbmClass: dbMgrClass				dataSourceName: self databaseName.	connection := anAbtDatabaseConnectionSpec 				connectUsingAlias: aliasNameString				logonSpec: anAbtDatabaseLogonSpec				ifError: 					[:error | 					"throw away the connection ..."					connection := nil.					aBlock value: error].	connection isNil ifFalse: [		connection databaseMgr errorBlock: [:err | self externalDatabaseErrorSignal signalWith: err]].</body><body package="GlorpDatabase">logout	self isLoggedIn ifFalse: [^self].	self log: 'Logout'.	self logOnly ifTrue: [^self].	"disconnectIfError: doesn't properly catch errors."	[	[connection disconnectIfError: [:ex | self logError: ex]]		ensure:	[connection := nil]]		  on: Dialect error		  do: [:ex | ex return: nil].	self log: 'Logout finished'</body><body package="GlorpDatabase">showDialog: aString	(Smalltalk at: #CwMessagePrompter) warn: aString.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>As yet unclassified</category><body package="GlorpDatabase">basicExecuteSQLString: aString binding: aBindingArray	"VA does not return results for as many statements as VW.  Some calls that take returnResult: true in VWdo not want to return a result in the basic VA RDB framework that we call.  We therefore check the String andonly ask for a return if it is a select statement.  (This is experimental and could be reviewed.)"	^self		basicExecuteSQLString: aString		returnResult: (aString copyFrom: 1 to: (6 min: aString size)) asUppercase = 'SELECT'		binding: aBindingArray		doing: []</body><body package="GlorpDatabase">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock	"^&lt;GlorpCursoredStream | empty readStream&gt; This method executes a general SQL command against the connection.If a result is requested, it returns a GlorpCursoredStream wrapping an AbtResultTable that (should) hold an AbtCursor.  Ifnot, it returns self to cursorFor: which returns an empty readStream since along one calling route VA does not provide aresult if the string is not a select whereas VW does in general, and the caller sends upToEnd.	Later, develop to use GlorpPreparedStatements (c.f. this method in VW) and resultTableFromQuerySpec:withValues:...VW creates an SQLStringCommand to put in the cursor."	^self cursorFor:  (returnResult		"was check if aString was SELECT statement, now moved to a caller"		ifFalse:			[connection				executeSQLStatement: aString				ifError: [:err | GlorpError signalWith: err].			aBlock value.			self]					"must return self to be handled in cursorFor:"		ifTrue:			[self basicExecuteSQLStringWithResult: aString doing: aBlock])</body><body package="GlorpDatabase">basicExecuteSQLStringNoResult: aString doing: aBlock	^self basicExecuteSQLString: aString returnResult: false binding: nil doing: aBlock.</body><body package="GlorpDatabase">basicExecuteSQLStringWithResult: aString doing: aBlock	"^&lt;AbtResultTable | self&gt; This VA-specific method returns an AbtResultTable unless it fails.  Later,add a binding: parameter and call resultTableFromQuerySpec:withValues:ifError:"	| resultTable |	resultTable := connection		resultTableFromQuerySpec: ((Smalltalk at: #AbtQuerySpec) new statement: aString)		ifError: [:err | GlorpError signalWith: err].	^resultTable isAbtError		ifTrue: 			[GlorpError signalWith: resultTable.			#() readStream]		ifFalse:			[aBlock value.			resultTable]</body><body package="GlorpDatabase">databaseName	"connect string looks like  hostname:portNumber_db-name. :portNumber is optional.	If the string is zero, return nil."	| str dbIndex |	str := self currentLogin connectString.	dbIndex := str indexOf: $_.	^str copyFrom: dbIndex + 1 to: str size</body><body package="GlorpDatabase">serverName	"connect string looks like  hostname:portNumber_db-name. The :portNumber is optional;	for the moment, we ignore it.  If the hostName is empty, return nil."	| str dbIndex "portIndex index" |	str := self currentLogin connectString."	portIndex := index := str indexOf: $:."	dbIndex := str indexOf: $_."	index = 0 ifTrue: [index := dbIndex]."	^dbIndex = 0 ifFalse: [str copyFrom: 1 to: dbIndex - 1]</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>initialize</category><body package="GlorpDatabase">initialize	super initialize.	isInTransaction := false.</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>development</category><body package="GlorpDatabase">todo: aString	^self</body></methods><methods><class-id>Glorp.VADatabaseAccessor</class-id> <category>cursors</category><body package="GlorpDatabase">cursorFor: aStream	"basicExecuteSQLString: binding: sets returnResult: to false if aString does not begin with 'SELECT' butits non-VA-specific caller executeSQLString:binding: sends upToEnd to what it returns, expecting the moreusual behaviour of returnResult always being true on that branch.  Thu we return an empty readStream, likethe VW implementation of this method in other no-return cases."	aStream == self ifTrue: [^#() readStream].	aStream onFinalizeDo: #close.	"In V8Beta, the finalize cycle has not always been run by the time the database' databaseMgr has been nilled,	causing a DNU when trying to get the error block (that it will not run).  If this persists, replace #close above with		Message selector: #closeIfError: arguments: (Array with: aStream errorBlock)	so we get the block when we know we can."	^super cursorFor: aStream.</body><body package="GlorpDatabase">isCursorAtEnd: aCursor	"Return true if aCursor is at its end."	^aCursor actuallyAtEnd.</body><body package="GlorpDatabase">releaseCursor: aCursor in: aPreparedStatement	aCursor close.</body></methods><methods><class-id>Glorp.VADatabaseAccessor class</class-id> <category>initialization</category><body package="GlorpDatabase">initializeDatabaseErrorSignal	databaseErrorSignal := ((Smalltalk at: #SystemExceptions) at: 'ExError') newChild.	databaseErrorSignal markReadOnly: false;		description: 'Database error';		resumable: true;		defaultHandler: nil;		markReadOnly: true</body></methods><methods><class-id>Glorp.VADatabaseAccessor class</class-id> <category>accessing</category><body package="GlorpDatabase">externalDatabaseErrorSignal	databaseErrorSignal isNil ifTrue: [self initializeDatabaseErrorSignal ].	^databaseErrorSignal</body></methods><methods><class-id>Glorp.UnmanagedCache</class-id> <category>private</category><body package="GlorpCore">basicAt: key ifAbsent: aBlock	^items at: key ifAbsent: aBlock</body><body package="GlorpCore">do: aBlock	items do: aBlock.</body><body package="GlorpCore">expiredInstanceFor: key	"Return the expired value.  Used for refreshing so that we don't recursively try and refresh when we get the instance to be refreshed."	| item |	item := self basicAt: key ifAbsent: [self error: 'No expired instance found'].	(self hasItemExpired: item) ifFalse: [self error: 'No expired instance found'].	^policy contentsOf: item</body><body package="GlorpCore">markAsCurrentAtKey: key	| item |	item := self basicAt: key ifAbsent: [^false].	^policy markEntryAsCurrent: item in: self</body><body package="GlorpCore">markEntryAsCurrent: anItem	"The policy has told us to mark an item as current. This is only really useful for weak policies, which tell us to keep an additional pointer to the object in a (presumably) fixed-size collection."	extraReferences isNil ifFalse: [extraReferences add: anItem].</body></methods><methods><class-id>Glorp.UnmanagedCache</class-id> <category>lookup</category><body package="GlorpCore">at: key ifAbsent: aBlock	| item value |	item := self basicAt: key ifAbsent: [^aBlock value].	value := policy contentsOf: item.	(self hasItemExpired: item) ifTrue:		[policy takeExpiryActionForKey: key withValue: value in: self.		item := self basicAt: key ifAbsent: [^aBlock value].		value := policy contentsOf: item].	self markEntryAsCurrent: value.	^value</body><body package="GlorpCore">at: key ifAbsentPut: aBlock	^self at: key ifAbsent: [self at: key put: aBlock value]</body><body package="GlorpCore">expireAll	items do: [:each | policy expire: each].</body><body package="GlorpCore">expireKey: key ifAbsent: aBlock	| item |	item := self basicAt: key ifAbsent: [^aBlock value].	policy expire: item</body><body package="GlorpCore">hasExpired: key	| item |	item := self basicAt: key ifAbsent: [^false].	^self hasItemExpired: item</body><body package="GlorpCore">hasItemExpired: anItem	^policy hasExpired: anItem</body><body package="GlorpCore">includesKey: key	"Return true if we include the object. Don't listen to any expiry policy"	self basicAt: key ifAbsent: [^false].	^true</body><body package="GlorpCore">includesKey: key as: anObject	"Return true if we include the object, and it matches the given object. If we include a different object with the same key, raise an exception. Don't listen to any expiry policy"	| item value |	item := self basicAt: key ifAbsent: [^false].	value := policy contentsOf: item.	value == anObject ifFalse: [		(DuplicatePrimaryKeyException new: anObject existing: value) signal].	^true</body><body package="GlorpCore">includesKey: key withClass: aClass	"Return true if we include the object, and it matches our class. Don't listen to any expiry policy"	| item value |	item := self basicAt: key ifAbsent: [^false].	value := policy contentsOf: item.	^value isKindOf: aClass</body><body package="GlorpCore">removeKey: key ifAbsent: aBlock	^items removeKey: key ifAbsent: aBlock</body></methods><methods><class-id>Glorp.UnmanagedCache</class-id> <category>initialize</category><body package="GlorpCore">initializeCache	items := policy newItemsIn: self.	extraReferences := policy collectionForExtraReferences.</body><body package="GlorpCore">release	policy release: self.	extraReferences := nil.</body></methods><methods><class-id>Glorp.UnmanagedCache</class-id> <category>accessing</category><body package="GlorpCore">at: key put: anObject	"Get an item for anObject (the item may be just anObject) and put it in the dictionary, being sure to return anObject, not the item."	| newItem |	newItem := policy cacheEntryFor: anObject.	items at: key put: newItem.	self markEntryAsCurrent: anObject.	^anObject</body><body package="GlorpCore">cachePolicy	^policy</body><body package="GlorpCore">cachePolicy: aCachePolicy	policy := aCachePolicy.	self initializeCache.</body><body package="GlorpCore">numberOfElements	^items size</body><body package="GlorpCore">session	"I am a freestanding cache with no CacheManager and so no session or descriptor system;  return nil and assume the caller will be OK with that as they are using me, not my subclass.  (See GlorpPreparedStatement&gt;&gt;glorpNoticeOfExpiryIn: for an example caller.)"	^nil</body><body package="GlorpCore">willRemoveItems	^policy willRemoveItems</body></methods><methods><class-id>Glorp.UnmanagedCache</class-id> <category>finalization</category><body package="GlorpCore">mournKeyOf: anEphemeron	policy takeExpiryActionForKey: anEphemeron key withValue: anEphemeron value in: self.</body></methods><methods><class-id>Glorp.Cache</class-id> <category>accessing</category><body package="GlorpCore">mainCache	^mainCache</body><body package="GlorpCore">mainCache: aCacheManager	mainCache := aCacheManager</body><body package="GlorpCore">session	^mainCache session</body></methods><methods><class-id>Glorp.Cache</class-id> <category>lookup</category><body package="GlorpCore">hasItemExpired: anItem	^(super hasItemExpired: anItem) and:		[(mainCache session isRegistered: (policy contentsOf: anItem)) not]</body></methods><methods><class-id>Glorp.Cache class</class-id> <category>instance creation</category><body package="GlorpCore">newFor: aClass in: aCacheManager	| newCache descriptor |	newCache := Cache new.	newCache mainCache: aCacheManager.	descriptor := aCacheManager system descriptorFor: aClass.	descriptor isNil		ifTrue: [newCache cachePolicy: CachePolicy default]		ifFalse: [newCache cachePolicy: descriptor cachePolicy].	^newCache</body></methods><methods><class-id>Glorp.FieldValueWrapper</class-id> <category>public</category><body package="GlorpUnitOfWork">containedBy	^containedBy.</body><body package="GlorpUnitOfWork">contents	^contents.</body><body package="GlorpUnitOfWork">contents: anObject	(hasValue and: [contents ~= anObject]) ifTrue: [self error: 'Inconsistent values in field'].	self privateSetContents: anObject.</body><body package="GlorpUnitOfWork">hasValue	^hasValue.</body><body package="GlorpUnitOfWork">initialize	hasValue := false.</body><body package="GlorpUnitOfWork">printOn: aStream	aStream 		nextPutAll: '&lt;&lt;'.	self hasValue ifTrue: [aStream print: self contents].	aStream		nextPutAll: '&gt;&gt;'.</body><body package="GlorpUnitOfWork">privateSetContents: anObject	contents := anObject.	hasValue := true.</body></methods><methods><class-id>Glorp.FieldValueWrapper</class-id> <category>accessing</category><body package="GlorpUnitOfWork">allInnerWrappers	^#().</body><body package="GlorpUnitOfWork">basicContents	"Return the un-transformed contents"	^self contents.</body><body package="GlorpUnitOfWork">innerWrapper	^self.</body></methods><methods><class-id>Glorp.FieldValueWrapper</class-id> <category>unifying</category><body package="GlorpUnitOfWork">containsWrapper: aFieldValueWrapper	^self == aFieldValueWrapper.</body><body package="GlorpUnitOfWork">replaceWith: aFieldValueWrapper	containedBy isNil ifTrue: [^nil].	containedBy		keysAndValuesDo:			[:eachField :eachListOfRows | eachListOfRows do: [:eachRow | eachRow wrapperAt: eachField put: aFieldValueWrapper]].</body><body package="GlorpUnitOfWork">unifyWith: targetWrapper	(self containsWrapper: targetWrapper) ifTrue: [^self].	(targetWrapper containsWrapper: self) ifTrue: [^self].	targetWrapper hasValue ifFalse: [^targetWrapper replaceWith: self].	self hasValue ifFalse: [^self replaceWith: targetWrapper].	self contents = targetWrapper contents		ifFalse: [self error: 'Conflicting values in rows'].	targetWrapper replaceWith: self.</body></methods><methods><class-id>Glorp.FieldValueWrapper</class-id> <category>containing</category><body package="GlorpUnitOfWork">isNowContainedBy: aRow and: aField	"Optimize this for memory consumption with the common case of one container. If we're contained by nothing, make it a single association. Otherwise, use a dictionary"	| shortCircuit thisFieldsEntries |	shortCircuit := false.	containedBy == nil ifTrue: [containedBy := aField -&gt; ((IdentitySet new: 2) add: aRow; yourself). ^self].	containedBy class == Association 		ifTrue: [		containedBy key == aField			ifTrue: [thisFieldsEntries := containedBy value]			ifFalse: [ | newContainedBy |				newContainedBy := IdentityDictionary new. 				newContainedBy at: containedBy key put: containedBy value.				containedBy := newContainedBy]].	thisFieldsEntries isNil ifTrue: [		thisFieldsEntries := containedBy at: aField ifAbsentPut: [shortCircuit := true. (IdentitySet new: 2) add: aRow; yourself]].	shortCircuit ifTrue: [^self].	(thisFieldsEntries includes: aRow) ifFalse: [thisFieldsEntries add: aRow].</body></methods><methods><class-id>Glorp.FieldValueWrapper class</class-id> <category>public</category><body package="GlorpUnitOfWork">new	^super new initialize.</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>accessing</category><body package="GlorpMappings">concreteMembers	^concreteMembers isNil 		ifTrue: [ concreteMembers := OrderedCollection new ]		ifFalse: [ concreteMembers]</body><body package="GlorpMappings">rootClass	^rootClass</body><body package="GlorpMappings">rootClass: anObject	rootClass := anObject</body><body package="GlorpMappings">rootDescriptor	^rootDescriptor isNil		ifTrue: [ rootDescriptor := self system descriptorFor: self rootClass ]		ifFalse: [ rootDescriptor ]</body><body package="GlorpMappings">subclassDescriptorsBuilt	^subclassDescriptorsBuilt isNil		ifTrue: [ subclassDescriptorsBuilt := false ]		ifFalse: [ subclassDescriptorsBuilt ]</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>registering</category><body package="GlorpMappings">register: aDescriptor abstract: abstract	super register: aDescriptor abstract: abstract.	abstract ifFalse: [ self concreteMembers add: aDescriptor ]</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>other</category><body package="GlorpMappings">rootDescriptor: anObject	rootDescriptor := anObject</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>private</category><body package="GlorpMappings">allDescribedConcreteClasses	self subclassDescriptorsBuilt ifFalse: [self forceSubclassDescriptorLoads].	^self concreteMembers collect: [ :each | each describedClass ]</body><body package="GlorpMappings">forceSubclassDescriptorLoads	self rootClass allSubclassesDo: [ :each | self system descriptorFor: each ].	subclassDescriptorsBuilt := true</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>type resolution</category><body package="GlorpMappings">typeMappingRootDescriptor	^self rootDescriptor</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>testing</category><body package="GlorpMappings">usesInheritance	^true.</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>validation</category><body package="GlorpMappings">validate	| tables sequences |	super validate.	tables := self concreteMembers collect: [:each | each primaryTable].	sequences := tables inject: #() into: [:sum :each | sum, ((each primaryKeyFields) collect: [:eachField | eachField type sequence])].	sequences asSet size &gt; 1 ifTrue: [self error: 'When using inheritance, all tables must use the same sequence. Otherwise, the primary key references will be ambiguous.'].</body></methods><methods><class-id>Glorp.FilteredTypeResolver</class-id> <category>accessing</category><body package="GlorpMappings">allTablesFor: aDescriptor	"Return all tables used by this descriptor or its subclasses. Since all our subclasses use a single table, this is the same as for a normal descriptor."	^aDescriptor tables.</body><body package="GlorpMappings">classesRequiringIndependentQueriesFor: aClass	^Array with: aClass</body><body package="GlorpMappings">descriptorsRequiringIndependentQueriesFor: aClass	"A FilteredTypeResolver holds all its subclasses' data in a single table, so should never require independent queries;  thus the only descriptor is that for aClass, and this should never need to be called.	It is possible that some fields in the table are only meaningful for some subclasses, and so are only defined in the descriptors of some subclasses.  If a query using the field is made (presumably by mistake) for a class without the mapping, #mappingFromMeOrSubclasses will call this method in a (vain) attempt to find defined for FilteredTypeResolver, thence return nil and so enable #mappingFromMeOrSubclasses to fall through to the normal error processing (as its last comment says).	Therefore we define this method, although expecting it will only ever be called en route to an error."	^members select: [:each | each describedClass = aClass]</body></methods><methods><class-id>Glorp.FilteredTypeResolver</class-id> <category>type resolving</category><body package="GlorpMappings">askConcreteMembersForConcreteClassFor: row withBuilder: builder	concreteMembers do: [:each |		each describedConcreteClassFor: row withBuilder: builder].</body><body package="GlorpMappings">describedConcreteClassFor: row withBuilder: builder descriptor: aDescriptor	^aDescriptor typeMapping describedConcreteClassFor: row withBuilder: builder</body><body package="GlorpMappings">fieldsForSelectStatement	"Return fields that are needed in a select statement - i.e. return all inherited fields that are part of the tables we are already selecting for this object, but not in the main descriptor"	| fields rootFields |	fields := OrderedCollection new.	rootFields := self rootDescriptor mappedFields asSet.	self concreteMembers do: [:each |		each == self rootDescriptor ifFalse: [			each mappedFields do: [:eachSubField |				(rootFields includes: eachSubField) ifFalse: [					fields add: eachSubField]]]].	^fields.</body><body package="GlorpMappings">isAbstract: aDescriptor	^aDescriptor == self rootDescriptor</body></methods><methods><class-id>Glorp.FilteredTypeResolver</class-id> <category>registering</category><body package="GlorpMappings">register: aDescriptor abstract: aBoolean	super register: aDescriptor abstract: aBoolean.	aBoolean		ifTrue:			[| fakeTypeMapping |			fakeTypeMapping := FilteredTypeMapping to: nil keyedBy: nil.			fakeTypeMapping attribute name: #filteredTypeResolverFilterMapping.			fakeTypeMapping readOnly: true.			aDescriptor typeMapping: fakeTypeMapping].</body><body package="GlorpMappings">register: aDescriptor keyedBy: aKey field: aField	self register: aDescriptor abstract: false.	aDescriptor typeMapping: (FilteredTypeMapping to: aField keyedBy: aKey).</body></methods><methods><class-id>Glorp.FilteredTypeResolver class</class-id> <category>instance creation</category><body package="GlorpMappings">forRootClass: aClass	^self new		rootClass: aClass;		yourself.</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">isVariableWidth	^false.</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">typeString	^self typeName, '(', width printString, ')'.</body></methods><methods><class-id>Glorp.GlorpCharType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'char'.</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>preparing</category><body package="GlorpExpressions">additionalExpressionsOn: anExpression	^#().</body><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^source.</body><body package="GlorpExpressions">availableSubSelectNumber	availableSubSelectNumber := availableSubSelectNumber isNil ifTrue: [1] ifFalse: [availableSubSelectNumber + 1].	^availableSubSelectNumber.</body><body package="GlorpExpressions">controlsTables	^true.</body><body package="GlorpExpressions">fieldsForSelectStatement	^self descriptor mappedFields.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	anExpression isNil ifTrue: [^aBaseExpression].	anExpression == self ifTrue: [^aBaseExpression].	^ultimateBaseExpression isNil ifTrue: [self] ifFalse: [ultimateBaseExpression].</body><body package="GlorpExpressions">tablesToPrint	"We derive the base's tables from the fields that are being selected, but make sure that at least the primary table is listed."	self descriptor tables isEmpty ifTrue: [^#()].	^Array with: (self aliasedTableFor: self descriptor primaryTable).</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>testing</category><body package="GlorpExpressions">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^true.</body><body package="GlorpExpressions">canPrint	"Return true if we can print into a where clause"	^false.</body><body package="GlorpExpressions">mapsSimpleObject	"Try to do a fast test for this, to look for the pseudo-descriptors that direct to-many mappings use."	^self descriptor mappings size = 1 and: [(self descriptor mappingForAttributeNamed: #myValue) notNil].</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>accessing</category><body package="GlorpExpressions">additionalExpressions	| expressions |	expressions := OrderedCollection new.	self descriptor typeMapping addTypeMappingCriteriaTo: expressions in: self.	expressions addAll: self multipleTableExpressions.	^expressions</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. We don't have a base, but we *are* a base, so return true"	^true.</body><body package="GlorpExpressions">descriptor	^descriptor</body><body package="GlorpExpressions">descriptor: aDescriptor	descriptor := aDescriptor</body><body package="GlorpExpressions">hasDescriptor	^self descriptor notNil.</body><body package="GlorpExpressions">mappedFields	^self descriptor mappedFields collect: [:each | self translateField: each].</body><body package="GlorpExpressions">mappingSequenceName	"Terminate the concatenation."	^''</body><body package="GlorpExpressions">multipleTableExpressions	^self descriptor multipleTableJoin 		collect: [:each | each asExpressionJoiningSource: self toTarget: self]</body><body package="GlorpExpressions">system	self descriptor isNil ifTrue: [^nil].	^self descriptor system.</body><body package="GlorpExpressions">table	^self descriptor primaryTable.</body><body package="GlorpExpressions">tables	^self descriptor isNil ifTrue: [#()] ifFalse: [self descriptor tables].</body><body package="GlorpExpressions">targetDescriptor	self halt</body><body package="GlorpExpressions">trueBase	^self.</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>printing</category><body package="GlorpExpressions">className	^'Base'.</body><body package="GlorpExpressions">printOn: aStream 	aStream		nextPutAll: self className;		nextPut: $(.	self printTreeOn: aStream.	aStream nextPut: $)</body><body package="GlorpExpressions">printOnlySelfOn: aStream 	self descriptor isNil ifTrue: [aStream nextPutAll: 'Empty Base'. ^self].	aStream print: self descriptor describedClass.	self printTableAliasesOn: aStream</body><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary 	"Normally, we're not printable, but we might be if we're inverting a direct to-many mapping. In that case, there should only be one mapped field"	self descriptor mappedFields do: [:each | (self translateField: each) printSQLOn: aStream withParameters: aDictionary].</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary 	"Do nothing. We're not printable"</body><body package="GlorpExpressions">printTreeOn: aStream 	aStream 		print: (self descriptor isNil ifTrue: [nil] ifFalse: [self descriptor describedClass])</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>api</category><body package="GlorpExpressions">base	^nil.</body><body package="GlorpExpressions">getMappings: aGlorpConstantExpression	"We do not protect if aSymbolArray is of size 1 or size zero.  If the array is empty, let's see it for now - it may be a coding error.  If the array is of size 1, better to have sent the symbol as a method in the usual way, but converting to a size 1 expression group should cause no problems.  Note that the last line is safe as ExpressionGroup&gt;&gt;add: returns self."	| aSymbolOrBlockArray expressionBlock |	aSymbolOrBlockArray   := aGlorpConstantExpression value.	expressionBlock :=	"Alternatively, we could call Query basicNew expressionBlockFor:"		[:element |		element isSymbol			ifTrue: [self get: element withArguments: #()]			ifFalse: [element asGlorpExpressionOn: self]].	^(2 to: aSymbolOrBlockArray size)		inject: (expressionBlock value: aSymbolOrBlockArray first) asExpressionGroup		into: [:expressionGroup :index || mappingExpression |			mappingExpression := expressionBlock value: (aSymbolOrBlockArray at: index).			expressionGroup add: mappingExpression]</body><body package="GlorpExpressions">getParameter: aDatabaseField 	^ParameterExpression forField: aDatabaseField basedOn: self.</body><body package="GlorpExpressions">referenceClass	"Return the class that our mapping refers to, if we have a mapping. If we're a base expression, just return our class, and if we're a table expression, just return nil."	^self descriptor describedClass.</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>navigating</category><body package="GlorpExpressions">queryLevelBaseExpression	^self</body><body package="GlorpExpressions">ultimateBaseExpression	^self</body></methods><methods><class-id>Glorp.BaseExpression</class-id> <category>mapping</category><body package="GlorpExpressions">valueInBuilder: anElementBuilder	"If we ever get here, this is because we're being used as the reverse of a direct to-many mapping, so we expect to have a descriptor with only one mapping, named #myValue"	| mapping |	mapping := self descriptor mappingForAttributeNamed: #myValue.	^mapping valueInBuilder: anElementBuilder as: (self get: #myValue) field.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase">bindReturningVariableAt: index forStatement: statement	"Return the bound variable at the specified index, which is expected to contain bound output data.  (This feature is currently only supported in OracleEXDI.)"	^statement statement bindVariable: index</body><body package="GlorpDatabase">createSession	"For Oracle, we set the defaultDisplayLobSize:.	For DB2, set the sesssion's setDataChunkSize:"	| session |	session := connection getSession.	(session respondsTo: #defaultDisplayLobSize:) ifTrue: [		session defaultDisplayLobSize: DatabaseCommand new maximumLobSizeToRetrieveDirectly]. 	(session respondsTo: #setDataChunkSize:) ifTrue: [		session setDataChunkSize: DatabaseCommand new maximumLobSizeToRetrieveDirectly]. 	session blockFactor: 100.  "We don't know, so make it big"	^session.</body><body package="GlorpDatabase">createSessionFor: aCommand	"For Oracle, we set the defaultDisplayLobSize:.	For DB2, set the sesssion's setDataChunkSize:"	| session types |	session := connection getSession.	(session respondsTo: #defaultDisplayLobSize:) ifTrue: [		session defaultDisplayLobSize: aCommand maximumLobSizeToRetrieveDirectly]. 	(session respondsTo: #setDataChunkSize:) ifTrue: [		session setDataChunkSize: DatabaseCommand new maximumLobSizeToRetrieveDirectly]. 	session blockFactor: aCommand blockFactor.	types := aCommand bindingTypesForEXDI.	types isEmpty ifFalse: [session bindTemplate: types].	^session.</body><body package="GlorpDatabase">currentLogin: aLogin	self reusePreparedStatements: aLogin database reusePreparedStatements.	super currentLogin: aLogin.</body><body package="GlorpDatabase">driverSession	driverSession isNil ifTrue: [driverSession := self createSession].	^driverSession.</body><body package="GlorpDatabase">encoding	^connection encoding.</body><body package="GlorpDatabase">numberOfPreparedStatements	^preparedStatements numberOfElements.</body><body package="GlorpDatabase">rowCount	"BE AWARE:  firstly, we no longer protect this call with a check of whether the driver supports it - callers now do that;  scondly, this assumes we know that we've executed no SQL since the last statement."	^self driverSession rowCount</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase">beginTransaction	self log: 'Begin Transaction'.	self logOnly ifTrue: [^self].	mutex critical: [connection begin]</body><body package="GlorpDatabase">commitTransaction	self log: 'Commit Transaction'.	self logOnly ifTrue: [^self].	mutex critical: [connection commit]</body><body package="GlorpDatabase">isInTransaction	"This needs a logOnly guard but what the appropriate return value should be is less obvious than for the other guards in this class.  Returning true avoids code that would otherwise seek to create a transaction."	self logOnly ifTrue: [^true].	^connection inTransactionMode</body><body package="GlorpDatabase">rollbackTransaction	self log: 'Rollback Transaction'.	self logOnly ifTrue: [^self].	mutex critical: [connection rollback]</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase">answerForCommand: aCommand fromDBSession: aSession	"This may only be called immediately after execute.  Return the first answer that is not #noAnswerStream (normally, the first answer that is either an ExternalDatabaseAnswerStream or #noMoreAnswers).  This will simply be the first answer unless aCommand produces multiple SQL-statements (e.g. INSERT ...; SELECT ....;  the INSERT returns #noAnswerStream, then the SELECT returns an answer stream).  If the command needs a count of rows affected (to measure if it succceeded or not), sum the rowCount of all #noAnswerStream statements.  (UPDATE, DELETE and INSERT return #noAnswerStream but we do not bother to track the row count of INSERT.  For batched update and query-delete commands, we check the row count to verify success)."	| ans needsRowCount |	ans := aSession answer.	"Do not use optimistic locking if supportsRowCountFor: is false"	ans == #noAnswerStream ifFalse: [^ans].	(needsRowCount := aCommand needsRowCount and: [self platform supportsRowCountFor: aCommand])		ifTrue: [aCommand rowCount: aSession rowCount].	"	ifFalse, leave aCommand rowCount unset:			- aCommand rowCount: nil would make clear it's not a valid value, but rowCount should be nil anyway.			- aCommand rowCount: aCommand expectedNumberOfModifiedRows would pretend we knew it worked."	[(ans := aSession answer) == #noAnswerStream] whileTrue:		[needsRowCount ifTrue: [aCommand rowCount: aCommand rowCount + aSession rowCount]].	^ans</body><body package="GlorpDatabase">basicExecuteSQLString: aString	^self basicExecuteSQLString: aString binding: nil.</body><body package="GlorpDatabase">basicExecuteSQLString: aString binding: aBindingArray 	^self basicExecuteSQLString: aString returnResult: true binding: aBindingArray doing: [].</body><body package="GlorpDatabase">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock	"Duplicate some of the logic of command execution, primarily because of the need to do special treatment depending if we want a result or not, and to execute the block. Put the statement into the driverSession (ugh) so that we can check the rowCount if necessary."	| answerStream command statement session |	answerStream := nil.	command := SQLStringCommand new.	command setSQLString: aString.	command parameters: aBindingArray.	(aBindingArray isNil or: [aBindingArray class ~= Association and: [aBindingArray isEmpty]]) ifTrue: [command useBinding: false].	statement := self preparedStatementFor: command.	session := statement statement.	driverSession := session.	command useBinding ifTrue: [		session bindInput: aBindingArray].	session execute.	"Always do this, because at least with ODBC, if we don't ask for the answer, we don't get errors, and subsequent statements get them"	answerStream := session answer.	aBlock value.	returnResult		ifTrue: [| cursor |			cursor := self cursorFor: answerStream command: command.			cursor statement: statement.			^cursor]		ifFalse:	"The answer usually, not always, returns #noMoreAnswers, meaning state is #prepared, so the disconnect has less to do, which some EXDIs check"			[answerStream == #noAnswerStream ifTrue: [session answer].			session disconnect].</body><body package="GlorpDatabase">basicExecuteSQLStringNoResult: aString doing: aBlock	^self basicExecuteSQLString: aString returnResult: false binding: nil doing: aBlock.</body><body package="GlorpDatabase">disconnect	self reset.	^connection disconnect</body><body package="GlorpDatabase">errorsToCatch	^self class errorsToCatch.</body><body package="GlorpDatabase">executeCommand: aCommand inDBSession: aSession	"Execute the command, given a database session which has already been prepared for this command."	| answerStream cursor |	aSession execute.	answerStream := self answerForCommand: aCommand fromDBSession: aSession.	cursor := self cursorFor: answerStream command: aCommand.	cursor statement: (GlorpPreparedStatement new statement: aSession).	^cursor</body><body package="GlorpDatabase">executeCommandBound: aCommand	| statement cursor time block |	self logCommand: aCommand bound: true.	self logOnly ifTrue: [^#() readStream].	block := [		statement := self statementFor: aCommand.		statement statement bindInput: aCommand bindings.		cursor := self executeCommand: aCommand inDBSession: statement statement.		cursor statement: statement].	time := Time millisecondsToRun: block.	self logTime: time.	^cursor.</body><body package="GlorpDatabase">executeCommandUnbound: aCommand	| statement cursor block time |	self logCommand: aCommand bound: false.	self logOnly ifTrue: [^self].	block := [		statement := self statementFor: aCommand.		cursor := self executeCommand: aCommand inDBSession: statement statement.		cursor statement: statement].	time := Time millisecondsToRun: block.	self logTime: time.	^cursor.</body><body package="GlorpDatabase">externalDatabaseErrorSignal	^connection class externalDatabaseErrorSignal.</body><body package="GlorpDatabase">innerExceptionFor: exception	(exception parameter isKindOf: GenericException) ifTrue: [^exception parameter].	^exception.</body><body package="GlorpDatabase">newPreparedStatementFor: aCommand	| newSession |	newSession := self createSessionFor: aCommand.	aCommand useBinding		ifTrue: [newSession prepare: aCommand sqlString]		ifFalse: [newSession prepareWithoutBinding: aCommand sqlString].	^(GlorpPreparedStatement new)		signature: aCommand signature;		statement: newSession;		busy: true.</body><body package="GlorpDatabase">preparedStatementFor: aCommand	| wasMarkedBusyForUs statement |	wasMarkedBusyForUs := false.	statement := preparedStatements		at: aCommand signature		ifAbsentPut:			[wasMarkedBusyForUs := true.			self newPreparedStatementFor: aCommand].	(wasMarkedBusyForUs not and: [statement busy])		ifTrue: [statement := self newPreparedStatementFor: aCommand].	^statement</body><body package="GlorpDatabase">statementFor: aCommand	^self reusePreparedStatements		ifTrue: [self preparedStatementFor: aCommand]		ifFalse: [self newPreparedStatementFor: aCommand].</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase">connectionClassForLogin: aLogin 	^aLogin vwConnectionClass</body><body package="GlorpDatabase">isLoggedIn	connection isNil ifTrue: [^false].	^connection isConnected</body><body package="GlorpDatabase">loginIfError: aBlock	"If the Login is secure, call the connection in its equivalent pattern (#connect:), otherwise set its password and call via #connect."	self log: 'Login'.	self logOnly ifTrue: [^self].	connection := self connectionClass new.	currentLogin preLoginInitializeFromAccessor: self.	self		execute:			[self currentLogin secure				ifTrue: [connection connect: currentLogin password]				ifFalse: [connection connect].			currentLogin postLoginInitializeFromAccessor: self]		ifError: aBlock.	self log: 'Login finished'</body><body package="GlorpDatabase">logout	self isLoggedIn ifFalse: [^self].	self log: 'Logout'.	self logOnly ifTrue: [^self].	self execute: [connection disconnect. self reset] ifError: [:ex | ex return: nil].	self log: 'Logout finished'</body><body package="GlorpDatabase">showDialog: aString	(Smalltalk at: #Dialog) warn: aString.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>copying</category><body package="GlorpDatabase">postCopy	super postCopy.	self initializePreparedStatementCache.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>cursors</category><body package="GlorpDatabase">cursorFor: answerStream	answerStream == #noAnswerStream ifTrue: [^#() readStream].	answerStream == #noMoreAnswers ifTrue: [^#() readStream].	^ super cursorFor: answerStream</body><body package="GlorpDatabase">cursorFor: answerStream command: aCommand	| stream |	stream := answerStream.	answerStream == #noAnswerStream ifTrue: [stream := #() readStream].	answerStream == #noMoreAnswers ifTrue: [stream := #() readStream].	^ super cursorFor: stream command: aCommand</body><body package="GlorpDatabase">releaseCursor: aCursor in: aPreparedStatement	"Release the cursor. We're trapping exceptions, so return true or false to indicate success/failure"	aCursor isNil ifTrue: [^self].	aPreparedStatement isNil ifTrue: [		 ^(aCursor class ~~ ReadStream) ifTrue: [self halt] ifFalse: [self]].	[aPreparedStatement statement isNil or: [aPreparedStatement statement answer == #noMoreAnswers]] whileFalse.	^[aCursor close. true] on: Dialect error do: [:ex | ex return: false].</body><body package="GlorpDatabase">upToEndOfResultSet: aGlorpCursoredStream	"The statement may have multiple result sets.  If the caller sends #upToEnd, the aggressive releasing of the cursor in #atEnd will lose any remaining result sets.  We therefore read the current result set and advance the underlying cursor to the next result set, releasing the Glorp cursor if we're called on the last result set.  (N.B. 'the next result set' does not necessarily mean the return of the next statement;  in a sequence of statements, some may return result sets while others return #noAnswerStream and these will be skipped).	When releasing a non-nil underlying cursor, #release loops until #noMoreAnswers is returned;  it would loop forever if we called #release after receiving that result and without nilling the underlying cursor."	| nextUnderlyingCursor resultSetContents |	resultSetContents := aGlorpCursoredStream cursor upToEnd.	[nextUnderlyingCursor := aGlorpCursoredStream statement statement answer.	nextUnderlyingCursor == #noAnswerStream] whileTrue.	nextUnderlyingCursor == #noMoreAnswers		ifTrue: [aGlorpCursoredStream cursor: nil; release]		ifFalse: [aGlorpCursoredStream cursor: nextUnderlyingCursor].	^resultSetContents</body><body package="GlorpDatabase">upToEndOfReturningResultSet: aGlorpCursoredStream	"Ask the relative type how to assign returned value(s) to the target column(s) of my rows.  As result returns an array of arrays, we need the inner array.  If relative fields and values are not the same size, #with:do: will raise an error."	| nextUnderlyingCursor resultSetContents aCommand latestResultRowCount|	aCommand := aGlorpCursoredStream command.	(aCommand needsRowCount and: [aCommand rowCount isNil]) ifTrue: [aCommand rowCount: 0].	resultSetContents := aGlorpCursoredStream cursor upToEnd.	"With SQL Server, we are allowed to capture rowCount after answer has been acquired."	aCommand needsRowCount				ifTrue: [latestResultRowCount := aGlorpCursoredStream statement statement rowCount.						aCommand shouldUseGroupWriting							ifTrue: [aCommand rowCount: aCommand rowCount + latestResultRowCount ]							ifFalse: [aCommand rowCount: latestResultRowCount ]].	[nextUnderlyingCursor := aGlorpCursoredStream statement statement answer.	nextUnderlyingCursor == #noAnswerStream] whileTrue: [].	nextUnderlyingCursor == #noMoreAnswers		ifTrue: [				aGlorpCursoredStream cursor: nil; release]		ifFalse: [aGlorpCursoredStream cursor: nextUnderlyingCursor].	^resultSetContents</body></methods><methods><class-id>Glorp.VWDatabaseAccessor</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	super initialize.	reusePreparedStatements := true.	self initializePreparedStatementCache.</body><body package="GlorpCore">initializePreparedStatementCache	"The preparedStatements cache holds only GlorpPreparedStatement instances.  As there is no descriptor-system-related collection of classes to be managed, and no session, we have no need of a CacheManager to contain this class, so use an UnmanagedCache."	| policy |	policy := CachePolicy default.	policy numberOfElements: 20.	policy expiryAction: #notifyAndRemove.	preparedStatements := UnmanagedCache new.	preparedStatements cachePolicy: policy.</body><body package="GlorpDatabase">reset	super reset.	preparedStatements release.	self initializePreparedStatementCache.	driverSession := nil.</body></methods><methods><class-id>Glorp.VWDatabaseAccessor class</class-id> <category>exception handling</category><body package="GlorpDatabase">errorsToCatch	| pgError |	pgError := Smalltalk at: #PostgreSQLEXDIException ifAbsent: [^Error].	^Error, pgError.</body></methods><methods><class-id>Glorp.GlorpFloatType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'float4'.</body></methods><methods><class-id>Glorp.GlorpFloatType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Float.</body></methods><methods><class-id>Glorp.GlorpFloatType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	^self platform converterNamed: #numberToFloat.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Float.</body></methods><methods><class-id>Glorp.TimedExpiryCachePolicy</class-id> <category>accessing</category><body package="GlorpCore">timeout	^timeout</body><body package="GlorpCore">timeout: seconds	timeout := seconds</body></methods><methods><class-id>Glorp.TimedExpiryCachePolicy</class-id> <category>wrap/unwrap</category><body package="GlorpCore">cacheEntryFor: anObject	^Array with: self totalSeconds with: anObject.</body><body package="GlorpCore">contentsOf: aCacheEntry	^aCacheEntry at: 2.</body><body package="GlorpCore">expire: aCacheEntry	^aCacheEntry at: 1 put: 0.</body><body package="GlorpCore">hasExpired: aCacheEntry	^(self totalSeconds - (aCacheEntry at: 1)) &gt;= timeout.</body><body package="GlorpCore">markEntryAsCurrent: aCacheEntry in: aCache	aCacheEntry at: 1 put: self totalSeconds.</body></methods><methods><class-id>Glorp.TimedExpiryCachePolicy</class-id> <category>utility</category><body package="GlorpCore">totalSeconds	^Dialect totalSeconds.</body></methods><methods><class-id>Glorp.TimedExpiryCachePolicy</class-id> <category>initialize</category><body package="GlorpCore">initialize	super initialize.	timeout := 300.</body></methods><methods><class-id>Glorp.GlorpRelativeValueType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes">= aType	^underlyingType = aType</body><body package="GlorpDatabaseTypes">hash	^underlyingType hash</body></methods><methods><class-id>Glorp.GlorpRelativeValueType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">hasParameters	^underlyingType hasParameters</body><body package="GlorpDatabaseTypes">isIntegerType	^underlyingType isInteger</body></methods><methods><class-id>Glorp.GlorpRelativeValueType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	^underlyingType converterForStType: aClass</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^underlyingType impliedSmalltalkType</body></methods><methods><class-id>Glorp.GlorpRelativeValueType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">isRelativeType	^true</body><body package="GlorpDatabaseTypes">nilOldValueEquivalent	"This choice of default matches our use of plus and minus as the operation connecting current value to fieldValue to oldValue;  if we generalise the operation, generalise this value."	^0</body><body package="GlorpDatabaseTypes">precision	^underlyingType precision</body><body package="GlorpDatabaseTypes">precision: anInteger	underlyingType precision: anInteger</body><body package="GlorpDatabaseTypes">scale	^underlyingType scale</body><body package="GlorpDatabaseTypes">scale: anInteger	underlyingType scale: anInteger</body><body package="GlorpDatabaseTypes">underlyingType	"I have no actual need to call this but since my super defines it to return self, this prevents infinite loops if a developer accidentally calls it."	^underlyingType</body><body package="GlorpDatabaseTypes">underlyingType: aDatabaseType	underlyingType := aDatabaseType.</body></methods><methods><class-id>Glorp.GlorpRelativeValueType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">print: aValue on: aCommand	underlyingType print: aValue on: aCommand.</body><body package="GlorpDatabaseTypes">printValueForField: aField inRow: aRow on: aCommand	"Get the old and new values, then write the template with them.  If the old value was nil, make it zero (this choice of default matches our use of plus and minus as the operation connecting current value to fieldValue to oldValue;  if we generalise the operation, generalise this hardcoded default)."	| oldValue fieldValue |	oldValue := aRow		oldVersionAt: aField		ifAbsent: [self nilOldValueEquivalent].	oldValue isNil ifTrue: [oldValue := self nilOldValueEquivalent].	fieldValue := aRow at: aField ifAbsent:		[^super printValueForField: aField inRow: aRow on: aCommand].	aCommand		nextPutAll: (self platform nameForColumn: aField name);		nextPutAll: ' + '.	(aCommand canBind: fieldValue to: self)		ifTrue: [aCommand nextPutBindMarkerIn: nil]		ifFalse: [underlyingType print: fieldValue on: aCommand].	aCommand nextPutAll: ' - '.	(aCommand canBind: fieldValue to: self)		ifTrue: [aCommand nextPutBindMarkerIn: nil]		ifFalse: [underlyingType print: oldValue on: aCommand].</body><body package="GlorpDatabaseTypes">typeName	^underlyingType typeName.</body><body package="GlorpDatabaseTypes">typeString	^underlyingType typeString.</body></methods><methods><class-id>Glorp.GlorpRelativeValueType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	^underlyingType exdiType.</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'blob'</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>types</category><body package="GlorpDatabaseTypes">converterForStType: aClass	(aClass includesBehavior: String) ifTrue: [^self platform converterNamed: #byteArrayToString].	self platform isPostgreSQLPlatform ifTrue: [^self platform converterNamed: #byteArrayToSQLString].	self platform isOcelotPlatform ifTrue: [^self platform converterNamed: #blobDataToStream].	^self platform nullConverter</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^ByteArray.</body><body package="GlorpDatabaseTypes">queryType	"Return the type that we can cast an argument to in order to match against this"	queryType isNil ifTrue: [^self].	^queryType.</body><body package="GlorpDatabaseTypes">queryType: aType	"Set the type that we can cast an argument to in order to match against this"	queryType := aType.</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#ByteArray.</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">print: aValue on: aStream	self platform printBlob: (aValue isNil ifTrue: [nil] ifFalse: [aValue asByteArray]) on: aStream for: self.</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes">= aType	super = aType ifFalse: [^false].	self queryType == self ifTrue: [^true].	self queryType = aType queryType		 ifFalse: [^false].	^true.</body><body package="GlorpDatabaseTypes">hash	^self queryType == self		ifTrue: [super hash]		ifFalse: [super hash bitXor: self queryType hash]</body></methods><methods><class-id>Glorp.GlorpBlobType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">requiresConvertToVarbinary	"This is a hack for testing against SQL Server"	^true.</body></methods><methods><class-id>Glorp.AdabasLikePlatform</class-id> <category>testing</category><body package="GlorpDatabase">supportsConstraints	^false</body></methods><methods><class-id>Glorp.DatabaseSequence</class-id> <category>sequencing</category><body package="GlorpDatabase">creationString	^'Create sequence ', self qualifiedName.</body><body package="GlorpDatabase">dropString	^'Drop string unspecified for this type of sequence'.</body><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession 	self subclassResponsibility.</body><body package="GlorpDatabase">hasReservedNumbers	^reservedNumbers notNil and: [reservedNumbers isEmpty not].</body><body package="GlorpDatabase">nextReservedNumber	^reservedNumbers removeFirst.</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor	self subclassResponsibility.</body><body package="GlorpDatabase">preWriteAssignSequenceValueFor: aField in: aRow using: anAccessor	self hasReservedNumbers		ifTrue: [aRow at: aField put: self nextReservedNumber]		ifFalse:			[self				getSequenceValueFromDatabaseFor: aField				in: aRow				using: anAccessor].</body></methods><methods><class-id>Glorp.DatabaseSequence</class-id> <category>initialize/release</category><body package="GlorpDatabase">initialize</body></methods><methods><class-id>Glorp.DatabaseSequence</class-id> <category>accessing</category><body package="GlorpDatabase">reservedNumbers	reservedNumbers isNil ifTrue: [reservedNumbers := OrderedCollection new: 50].	^reservedNumbers.</body></methods><methods><class-id>Glorp.DatabaseSequence</class-id> <category>testing</category><body package="GlorpDatabase">isIdentityColumn	^false.</body></methods><methods><class-id>Glorp.DatabaseSequence class</class-id> <category>instance creation</category><body package="GlorpDatabase">named: aString	^self new name: aString.</body><body package="GlorpDatabase">new	^super new initialize.</body></methods><methods><class-id>Glorp.NamedSequence</class-id> <category>accessing</category><body package="GlorpDatabase">name	^name.</body><body package="GlorpDatabase">name: aString	name := aString.</body><body package="GlorpDatabase">qualifiedName	^(schema isNil or: [schema isEmpty]) ifTrue: [name] ifFalse: [schema, '.', name].</body><body package="GlorpDatabase">schema	^schema</body><body package="GlorpDatabase">schema: aString	schema := aString</body></methods><methods><class-id>Glorp.NamedSequence</class-id> <category>SQL</category><body package="GlorpDatabase">availableReservedNumbers	^self reservedNumbers size.</body><body package="GlorpDatabase">maximumToReserveAtOnce		^1000.</body><body package="GlorpDatabase">reserveSequenceNumbers: anInteger in: aSession for: aTable	| numberNeeded numberToReserve |	numberNeeded := anInteger - self availableReservedNumbers.	numberNeeded &lt;= 0 ifTrue: [^self].	self		reserveViaTableSelect: numberNeeded		in: aSession		for: aTable.	[anInteger - self availableReservedNumbers &gt;0 ] whileTrue: [		numberToReserve := (anInteger - self availableReservedNumbers) min: (self maximumToReserveAtOnce).		self reserveViaBackupMechanism: numberToReserve in: aSession].</body><body package="GlorpDatabase">reserveViaTableSelect: anInteger in: aSession for: aTable	| rows command |	command := self		tableSelectCommandFor: (self tableToSelectFromIn: aSession for: aTable)		in: aSession		reserving: anInteger.	command parameters: (Array with: anInteger).	rows := aSession accessor executeCommand: command.	rows do: [:each | self reservedNumbers add: each first].</body><body package="GlorpDatabase">tableSelectCommandFor: aTable in: aSession reserving: anObject	self subclassResponsibility.</body><body package="GlorpDatabase">tableToSelectFromFor: aTable	"Sometimes it's inefficient to select sequence values against our own table and we can use a database-specific system table instead to be much faster. Subclasses can override where this is the case"	^aTable.</body></methods><methods><class-id>Glorp.NamedSequence</class-id> <category>sequencing</category><body package="GlorpDatabase">dropString	^'Drop sequence ', self qualifiedName.</body></methods><methods><class-id>Glorp.NamedSequence</class-id> <category>printing</category><body package="GlorpDatabase">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: (name isNil ifTrue: ['unnamed'] ifFalse: [name]);		nextPut: $).</body></methods><methods><class-id>Glorp.DB2IdentitySequence</class-id> <category>SQL</category><body package="GlorpDatabase">reserveSequenceNumbers: anInteger in: aSession for: aTable	"No real sequences here, just identity columns, which we can't pre-allocate"</body></methods><methods><class-id>Glorp.DB2IdentitySequence</class-id> <category>sequencing</category><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aDatabaseField in: aDatabaseRow using: anAccessor	"I do nothing, but I am here for subclassResponsibility reasons"</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor 	aDatabaseRow at: aDatabaseField		put: (((anAccessor 				executeSQLString: 'VALUES IDENTITY_VAL_LOCAL()') first atIndex: 1) asInteger).</body></methods><methods><class-id>Glorp.DB2IdentitySequence</class-id> <category>testing</category><body package="GlorpDatabase">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>copying</category><body package="GlorpQueries">copy	^self shallowCopy postCopy.</body><body package="GlorpQueries">copyAndGrowBy: anInteger	"For VA compatibility"	^super glorpShallowCopy.</body><body package="GlorpQueries">copyFrom: start to: stop	^self realObjects copyFrom: start to: stop.</body><body package="GlorpQueries">postCopy	query := query copy.	realObjects := nil.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>testing</category><body package="GlorpQueries">isEmpty	^self realObjects isEmpty.</body><body package="GlorpQueries">isInstantiated	^realObjects notNil.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>enumerating</category><body package="GlorpQueries">collect: aBlock	^self realObjects collect: aBlock</body><body package="GlorpQueries">do: aBlock	self realObjects do: aBlock.</body><body package="GlorpQueries">reject: aBlock	^self copy AND: [:each | (aBlock value: each) not].</body><body package="GlorpQueries">select: aBlock	^self isInstantiated ifTrue: [self realObjects select: aBlock] ifFalse: [self copy AND: aBlock].</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>removing</category><body package="GlorpQueries">remove: oldObject ifAbsent: anExceptionBlock	self readOnlyError.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>accessing</category><body package="GlorpQueries">first	^self realObjects first.</body><body package="GlorpQueries">last	^self realObjects last.</body><body package="GlorpQueries">orderBy: aBlockOrExpression	query orderBy: aBlockOrExpression.</body><body package="GlorpQueries">parameters: aCollection	parameters := aCollection</body><body package="GlorpQueries">setQuery: aQuery	"Semi-private. Set the internal query"	query := aQuery.</body><body package="GlorpQueries">setSession: aSession	"Semi-private. Set the session"	session := aSession.</body><body package="GlorpQueries">size	^self realObjects size.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>private</category><body package="GlorpQueries">AND: aBlock	query AND: aBlock.</body><body package="GlorpQueries">getQuery	^query.</body><body package="GlorpQueries">readOnlyError	self error: 'Virtual collections are read-only'.</body><body package="GlorpQueries">realObjects	realObjects isNil ifTrue: [	realObjects := query executeWithParameters: parameters in: session].	^realObjects.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>printing</category><body package="GlorpQueries">printOn: aStream	self isInstantiated		ifTrue: [super printOn: aStream]		ifFalse:			[aStream nextPutAll: 'a virtual collection of '.			query notNil ifTrue: [aStream nextPutAll: query resultClass name]].</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>adding</category><body package="GlorpQueries">add: newObject	self readOnlyError.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection</class-id> <category>initialize-release</category><body package="GlorpQueries">on: aClass in: aSession	query := Query read: aClass.	session := aSession.</body></methods><methods><class-id>Glorp.GlorpVirtualCollection class</class-id> <category>instance creation</category><body package="GlorpQueries">on: aClass in: aSession	^self new on: aClass in: aSession.</body></methods><methods><class-id>Glorp.IIF</class-id> <category>printing</category><body package="GlorpExpressions">printBasicSQLOn: aStream withParameters: aDictionary forSelect: aBoolean	"Example: IIF(Condition, ReturnIfTrue, ReturnIfValue)		IIF ( base? = arg1, arg2, arg3 ) AS alias"		aStream		nextPutAll: 'IIF( '.	aBoolean		ifTrue: [base printSelectSQLOn: aStream withParameters: aDictionary]		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].	aStream nextPutAll: ' ='.	arguments size ~= 3 ifTrue: [self error].	1 to: 3 do: [:i| |argument argumentType|			argument := arguments at: i.			argumentType := argumentTypes at: i.		"Our printing of constants with types is unfortunately tied up with relation expressions, so we shortcircuit some of the logic and just have the types print directly. This will not let us e.g. bind parameters to this function, but we don't expect to be doing that right now."		argumentType print: argument on: aStream.		i = 3 ifFalse: [aStream nextPutAll: ', ']].	aStream nextPutAll: ' ) '.	alias notNil		ifTrue: [aStream				nextPutAll: ' AS ';				nextPutAll: alias]</body></methods><methods><class-id>Glorp.IIF</class-id> <category>initializing</category><body package="GlorpExpressions">initialize	super initialize.	function := 'IIF'.	separator := ' '.	argumentTypes := OrderedCollection new: 3.</body></methods><methods><class-id>Glorp.IIF</class-id> <category>As yet unclassified</category><body package="GlorpExpressions">argumentTypes: anArray 	argumentTypes := anArray.</body></methods><methods><class-id>Glorp.VersionGenerator</class-id> <category>sequencing</category><body package="GlorpDatabase">nextValueFor: aField in: aRow	self subclassResponsibility.</body><body package="GlorpDatabase">preWriteAssignSequenceValueFor: aField in: aRow using: anAccessor	"Overwrite a pre-existing value in the field if necessary"	aRow at: aField forcePut: (self nextValueFor: aField in: aRow).</body></methods><methods><class-id>Glorp.AdHocVersionGenerator</class-id> <category>accessing</category><body package="GlorpDatabase">block	^block</body><body package="GlorpDatabase">block: aBlock	block := aBlock.	numberOfArguments := Dialect argumentCountFor: block.</body></methods><methods><class-id>Glorp.AdHocVersionGenerator</class-id> <category>sequencing</category><body package="GlorpDatabase">nextValueFor: aField in: aRow	"Get the next value by evaluating the block. If it doesn't care about the field or row, don't pass them as arguments. If it does, then give it both."	numberOfArguments = 0 ifTrue: [^block value] ifFalse: [^block value: aField value: aRow].</body></methods><methods><class-id>Glorp.AdHocVersionGenerator class</class-id> <category>instance creation</category><body package="GlorpDatabase">block: aBlock	^self new block: aBlock.</body></methods><methods><class-id>Glorp.JoinBaseExpression</class-id> <category>preparing</category><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^target.</body></methods><methods><class-id>Glorp.DatabaseConverter</class-id> <category>converting</category><body package="GlorpDatabase">convert: anObject fromDatabaseRepresentationAs: aDatabaseType 	self subclassResponsibility</body><body package="GlorpDatabase">convert: anObject toDatabaseRepresentationAs: aDatabaseType 	self subclassResponsibility</body></methods><methods><class-id>Glorp.DatabaseConverter</class-id> <category>printing</category><body package="GlorpDatabase">printOn: aString	aString nextPutAll: 'DatabaseConverter(', name, ')'.</body></methods><methods><class-id>Glorp.DatabaseConverter</class-id> <category>initialize</category><body package="GlorpDatabase">initialize	name := #unnamed.</body></methods><methods><class-id>Glorp.DatabaseConverter</class-id> <category>accessing</category><body package="GlorpDatabase">name	^name.</body><body package="GlorpDatabase">name: aString	name := aString.</body></methods><methods><class-id>Glorp.DatabaseConverter class</class-id> <category>instance creation</category><body package="GlorpDatabase">new	^super new initialize.</body></methods><methods><class-id>Glorp.PluggableDatabaseConverter</class-id> <category>converting</category><body package="GlorpDatabase">convert: anObject fromDatabaseRepresentationAs: aDatabaseType 	^dbToSt isNil ifTrue: [anObject] ifFalse: [dbToSt value: anObject]</body><body package="GlorpDatabase">convert: anObject toDatabaseRepresentationAs: aDatabaseType 	^stToDb isNil ifTrue: [anObject] ifFalse: [stToDb value: anObject]</body></methods><methods><class-id>Glorp.PluggableDatabaseConverter</class-id> <category>accessing</category><body package="GlorpDatabase">dbToSt	^dbToSt</body><body package="GlorpDatabase">dbToStConverter: aBlock	dbToSt := aBlock.</body><body package="GlorpDatabase">stToDb	^stToDb</body><body package="GlorpDatabase">stToDbConverter: aBlock	stToDb := aBlock.</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>api</category><body package="GlorpMappings">collectionType	^self attribute collectionType.</body><body package="GlorpMappings">collectionType: aClass	self attribute collectionType: aClass.</body><body package="GlorpMappings">orderBy	^orderBy.</body><body package="GlorpMappings">orderBy: aBlockOrSelector	orderBy isNil ifTrue: [orderBy := OrderedCollection new].	orderBy add: aBlockOrSelector.</body><body package="GlorpMappings">shouldWriteTheOrderField	^shouldWriteTheOrderField</body><body package="GlorpMappings">shouldWriteTheOrderField: aBoolean	shouldWriteTheOrderField := aBoolean.</body><body package="GlorpMappings">writeTheOrderField	shouldWriteTheOrderField := true.</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>mapping</category><body package="GlorpMappings">buildGeneralQueryIn: anObjectBuilder	| newQuery |	newQuery := super buildGeneralQueryIn: anObjectBuilder.	orderBy isNil ifFalse: [orderBy do: [:each | newQuery orderBy: each]].	^newQuery.</body><body package="GlorpMappings">buildQuery	| builtQuery |	builtQuery := super buildQuery.	orderBy isNil ifFalse: [orderBy do: [:each | builtQuery orderBy: each]].	^builtQuery</body><body package="GlorpMappings">keyForOrderingFrom: anObject to: target	self usesLinkTable ifFalse: [^target].	^self orderField table == self linkTable ifTrue: [target] ifFalse: [anObject].</body><body package="GlorpMappings">writeExtraInformationInto: aRowMap atKey: rowMapKey forSourceObject: sourceObject targetObject: targetObject atIndex: index	shouldWriteTheOrderField		ifTrue:			[| keyForOrdering |			keyForOrdering := self keyForOrderingFrom: sourceObject to: rowMapKey.			aRowMap				at: self orderField				key: keyForOrdering				put: index].</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>private/expressions</category><body package="GlorpMappings">linkTable	| referenceKeys |	self usesLinkTable ifFalse: [^nil].	referenceKeys := self join targetKeys asOrderedCollection.	^referenceKeys first table</body><body package="GlorpMappings">orderField	| exp |	exp := Query new expressionBlockFor: orderBy first.	^(exp asGlorpExpressionOn: (BaseExpression new descriptor: self referenceDescriptor)) field.</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>testing</category><body package="GlorpMappings">hasValueThatCanProvideField: aField from: anObject	"Return true if we have enough information in ourselves to populate our fields. The only time this won't be true is if we're either holding an uninstantiated proxy or have a to-many relationship mapping with an empty collection. Inline the superclass implementation to avoid fetching the value twice."	| value |	(super hasValueThatCanProvideField: aField from: anObject) ifFalse: [^false].	value := self getValueFrom: anObject.	^value isEmpty not.</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>initialize/release</category><body package="GlorpMappings">defaultCollectionType	^OrderedCollection.</body><body package="GlorpMappings">initialize	super initialize.	shouldWriteTheOrderField := false.</body><body package="GlorpMappings">initializeAttribute	"This is where we can initialize aspects of the attribute, if required. The motivating example is initializing the collection type of the attribute if it wasn't set. We need it to have some type, but we don't want to initialize it while we're doing basic initialization and aren't yet properly attached to a descriptor or class model"	super initializeAttribute.	self attribute collectionType isNil		ifTrue: [self attribute collectionType: self defaultCollectionType].</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>validation</category><body package="GlorpMappings">validate	| targetClassModel |	super validate.	(self collectionType = GlorpCursoredStream and: [self shouldUseFilteredRead]) ifTrue: [self error: 'Filtered mappings can cause duplicates and so cannot return cursors'].	(shouldWriteTheOrderField and: [orderBy isNil]) ifTrue: [self error: 'Mapping tries to write the collection order to a field, but has no order by field specified'].	(shouldWriteTheOrderField &amp; usesLinkTable)		ifTrue: [ | targetTable |			targetTable := (self linkTableJoin allTargetFields collect: [:each | each table]) first.			targetTable primaryKeyFields isEmpty ifTrue: [self error: 'A mapping with a link table and which writes the order field must define primary key fields and must not include the order field as a primary key']].		orderBy isNil ifTrue: [^self].	targetClassModel := self system classModelFor: attribute type.	"Note that this will only validate when the orderBy is a symbol - not a block, expression, or field"	orderBy do: [:attributeName |		attributeName isSymbol ifTrue: [			(targetClassModel hasAttributeNamed: attributeName) ifFalse: [				self error: attribute printString, ' is attempting to order by #', attributeName, ' which is not a mapped attribute of ', targetClassModel describedClass name]]].</body></methods><methods><class-id>Glorp.SQLite3PragmaMapping</class-id> <category>public</category><body package="GlorpMappings">setValueIn: anObject to: aValue	"This method serves as a hook to do special work for the collection objects, #fields and #foreignKeysData.	It connects the objects to their owning tables (a SQLite3DatabaseTable object), and also resets the field	type for a primary key field whose owning table has 'AUTOINCREMENT' declared for its pkey field. Such	a field has type #serial. It would be nicer if that info were available elsewhere, but right now, this is where	the table and field first meet (and where that info can now be shared)."	self canRead ifFalse: [^self].	self attribute setValueIn: anObject to: aValue.	self attribute name = #fields		ifTrue: 			[aValue do: 					[:fld |					fld table: anObject.					fld isPrimaryKey						ifTrue: [anObject hasAutoIncrement ifTrue: [fld type: self descriptor system platform serial]]]].	self attribute name = #foreignKeysData		ifTrue: [aValue do: [:fld | fld sourceTableName: anObject name]]</body></methods><methods><class-id>Glorp.SQLite3PragmaMapping</class-id> <category>mapping</category><body package="GlorpMappings">buildQuery	| toMany builtQuery |	toMany := self attribute isCollectionAttribute.	builtQuery := toMany		ifTrue: [SQLite3PragmaQuery read: self referenceClass where: self join]		ifFalse: [SQLite3PragmaQuery readOneOf: self referenceClass where: self join].	builtQuery session: self session.	builtQuery baseExpression descriptor: (self session descriptorFor: self referenceClass).	builtQuery collectionType: self collectionType.	self usesLinkTable ifTrue:		[builtQuery AND: (self expressionFromLinkToReferenceTableWithBase: builtQuery baseExpression)].	orderBy isNil ifFalse: [orderBy do: [:each | builtQuery orderBy: each]].	^builtQuery</body></methods><methods><class-id>Glorp.RecursiveMapping</class-id> <category>mapping</category><body package="GlorpMappings">knitFromBuilder: sourceBuilder toBuilder: targetBuilder	"We assume we are being alsoFetched and are otherwise ignored, marked as non-readable, so we ignore canRead.  TO CONSIDER."	sourceBuilder instance perform: self attribute setSelector with: targetBuilder instance.</body></methods><methods><class-id>Glorp.NullConverter</class-id> <category>converting</category><body package="GlorpDatabase">convert: anObject fromDatabaseRepresentationAs: aDatabaseType	^anObject.</body><body package="GlorpDatabase">convert: anObject toDatabaseRepresentationAs: aDatabaseType	^anObject.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>types</category><body package="GlorpDatabase">bit	"An integer whose values can only be 1 or 0.  No case for this type unless something like INSERT 0 INTO bitcol can be parsed by SQLServer."	^self typeNamed: #bit ifAbsentPut: [GlorpIntegerType new typeString: 'bit']</body><body package="GlorpDatabase">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'varbinary(max)'; queryType: (self varbinary)].</body><body package="GlorpDatabase">boolean	"An boolean can be read from a type BIT column because ODBCEXDI knows the type of the column it reads _from_ and does the conversion.  But it cannot tell the type of the column it is writing _to_, unlike Glorp, so Glopr must do the conversion INSERT CONVERT( BIT, 0) INTO columnOfTypeBIT.  See my #printBoolean:for: and #booleanToBooleanConverter for details."	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'bit']</body><body package="GlorpDatabase">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new].</body><body package="GlorpDatabase">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'varchar(max)'].</body><body package="GlorpDatabase">date	"SQL Server does not compare a timestamp that's cast to a date as being equal to a date, which is the behaviour we expect. Its dates are really timestamps internally, so just treat date and timestamp as the same."	^self timestamp.</body><body package="GlorpDatabase">decimal	^self numeric.</body><body package="GlorpDatabase">double	^self float.</body><body package="GlorpDatabase">float	^self typeNamed: #float ifAbsentPut: [GlorpMSSQLFloatType new].</body><body package="GlorpDatabase">float4	^self float.</body><body package="GlorpDatabase">float8	^self float.</body><body package="GlorpDatabase">int	^self integer.</body><body package="GlorpDatabase">int2	^self smallint.</body><body package="GlorpDatabase">int4	^self integer.</body><body package="GlorpDatabase">int8	^self numeric.</body><body package="GlorpDatabase">integer	^self typeNamed: #integer ifAbsentPut: [GlorpIntegerType new typeString: 'int'].</body><body package="GlorpDatabase">nchar	^self typeNamed: #nchar ifAbsentPut: [GlorpCharType new typeString: 'nchar']</body><body package="GlorpDatabase">nclob	^self typeNamed: #nclob ifAbsentPut: [GlorpClobType new typeString: 'nvarchar(max)'].</body><body package="GlorpDatabase">ntext	^self typeNamed: #ntext ifAbsentPut: [GlorpClobType new typeString: 'ntext']</body><body package="GlorpDatabase">numeric	^self typeNamed: #numeric ifAbsentPut: [GlorpNumericType new].</body><body package="GlorpDatabase">nvarchar	^self typeNamed: #nvarchar ifAbsentPut: [GlorpVarCharType new typeString: 'nvarchar'].</body><body package="GlorpDatabase">real	^self float.</body><body package="GlorpDatabase">sequence	^self serial.</body><body package="GlorpDatabase">serial	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'int  IDENTITY (1, 1) '].</body><body package="GlorpDatabase">text	^super text queryType: self varchar.</body><body package="GlorpDatabase">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'datetime'].</body><body package="GlorpDatabase">timeStampTypeString	^'datetime'.</body><body package="GlorpDatabase">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'datetime'].</body><body package="GlorpDatabase">tinyint	^self typeNamed: #tinyInt ifAbsentPut: [GlorpIntegerType new typeString: 'tinyint'].</body><body package="GlorpDatabase">typeWithDatabaseName: aString characterWidth: aNumber extraInformation: extraValue	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now."	extraValue = 'IDENTITY' ifTrue: [^self serial].	^super typeWithDatabaseName: aString characterWidth: aNumber.</body><body package="GlorpDatabase">varbinary	^self typeNamed: #varbinary ifAbsentPut: [GlorpVarBinaryType new].</body><body package="GlorpDatabase">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new].</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated^false</body><body package="GlorpDatabase">capitalWritingOfTableName	^false</body><body package="GlorpDatabase">initializeReservedWords	super initializeReservedWords.	reservedWords add: 'key'.</body><body package="GlorpDatabase">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^128</body><body package="GlorpDatabase">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^128</body><body package="GlorpDatabase">requiresTransactionForTableOperations	"SQL Server, over ODBC doesn't support DDL transactions reliably, since the current transaction can be rolled back without notice. So we avoid this."	^false.</body><body package="GlorpDatabase">sqlTextCurrentServerUTCTimestamp	^'SELECT GETUTCDATE()'</body><body package="GlorpDatabase">startColumnAddString	"The string we use as a prefix when adding a colum.	Override the superclass default because MS doesn't use COLUMN."	^' '.</body><body package="GlorpDatabase">supportsMillisecondsInTimes	"I'm guessing here"	^true.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase">dateConverter	"SQL server doesn't have plain dates, and doesn't accept them"	^DelegatingDatabaseConverter		named: #date		hostedBy: self		fromStToDb: #dateToTimestampConversion:for:		fromDbToSt: #readDate:for:.	"#printDate:for:"</body><body package="GlorpDatabase">dateToTimestampConversion: aDate for: aType	aDate isNil ifTrue: [^aDate].	^aDate asTimestamp.</body><body package="GlorpDatabase">printDate: aDate for: aType	"Print a date (or timestamp) as yyyy-mm-dd"	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: '{ d '''.	self		printDate: aDate		isoFormatOn: stream.	stream nextPutAll: ''' }'.	^stream contents.</body><body package="GlorpDatabase">printTime: aTime for: aType	"Print a time (or timestamp) as hh:mm:ss.fff"	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: '{ t '''.	self		printTime: aTime		isoFormatOn: stream		milliseconds: self supportsMillisecondsInTimes.	stream nextPutAll: ''' }'.	^stream contents.</body><body package="GlorpDatabase">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPutAll: '{ ts '''.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ' '.	self		printTime: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ''' }'.</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>testing</category><body package="GlorpDatabase">canRecurse	^canRecurse</body><body package="GlorpDatabase">isODBCPlatform	^true</body><body package="GlorpDatabase">isSQLServerPlatform	^true</body><body package="GlorpDatabase">reusePreparedStatements	^false</body><body package="GlorpDatabase">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^true.</body><body package="GlorpDatabase">supportsBinding	"Binding works only with VW EXDI so far.  Reuse of prepared statements is set to false by default (see my class-side)."	^Dialect isVisualWorks.</body><body package="GlorpDatabase">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place"	^false.</body><body package="GlorpDatabase">supportsDuplicateFieldNamesInCompoundQueries	"Absurdly, Oracle, SQLServer and MySQL will not tolerate two unaliased fields in different tables but of the same name in a compound query, so the second (and subsequent) such fields must be aliased."	^false</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	^aCommand supportsGroupWriting and:		[self useBinding or: [aCommand needsRowCount not]]</body><body package="GlorpDatabase">supportsGroupWritingValues	"I support it in version 10 and after."	^supportsGroupWritingValues ifNil: [false]</body><body package="GlorpDatabase">supportsLimit	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"	^true.</body><body package="GlorpDatabase">supportsMultipleOpenCursors	"Can this database support multiple open cursors at once"	^false.</body><body package="GlorpDatabase">supportsRowCountFor: aRowBasedCommand	"SQLServer can send batched or array-bound insert and update statements to the server but if it is not bound then ODBC 2.0 will only return the result set and rowCount of the last statement in the batch, whereas ODBC 3.0 will return multiple result sets and the session can be asked its rowCount after each, and the result used only for the relevant statement or summed as desired.	When it sends batched selects, both ODBC 2.0 and ODBC 3.0 can recover the answer sets for each select _but_ this rowCount is the total of rows read so far from the answer stream, not the total of rows found.  Only after the answer stream has been exhausted will the row count equal the number of matching rows that the select found to return.  Before any rows are read, the rowCount is -1, not zero;  it will be zero if the first attempt to read shows no rows were found.  (This typically showed as he last select in the batch having -1 rowCount, having been reached by Glorp processing and then the session queried for rowCount before that answer stream was read.)	Thus this platform's rowCount is unreliable when unbound if being accessed over ODBC 2.0 and more than one batched statement is involved: a batch of several attempted UPDATEs will return a rowCount of 0 or 1 for the last UPDATE only, and will return #noMoreAnswers if #answer is sent again.  In ODBC 3.0 it is reliable."	^(self useBinding and: [aRowBasedCommand useBinding])		or: [self supportsUnboundRowCount			or: [aRowBasedCommand expectedNumberOfModifiedRows &lt; 2]]</body><body package="GlorpDatabase">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL.""Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^true</body><body package="GlorpDatabase">supportsUnboundRowCount	"I support it in ODBC 3.0 and after."	^supportsUnboundRowCount ifNil: [false]</body><body package="GlorpDatabase">useMicrosoftOuterJoins	"Return true if we use the Microsoft x *= y syntax for outer joins"	^false.</body><body package="GlorpDatabase">usesArrayBindingToGroupWrite	"SQLServer supports array binding to group-write when bound.  As it is the most performant way to group-write, we use it in that case."	^true</body><body package="GlorpDatabase">usesIdentityColumns	^true.</body><body package="GlorpDatabase">usesInformationSchema	^true</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	^true</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">charactersThatNeedEscaping	"There seem to be all kind of contradictory bits of information about what sql server does/requires for escaped characters, all of which differ from standard sql. Empirically the only thing that requires escaping appears to be single quote"	^#($' ).</body><body package="GlorpDatabase">escapeFor: aCharacter	^String with: $' with: aCharacter."	^'\', (aCharacter asInteger printStringRadix: 16)."</body><body package="GlorpDatabase">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	aStream nextPutAll: '0x'.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].</body><body package="GlorpDatabase">removeNestedParensFromString: aString	"Return a Smalltalk instance of the type indicated by aGlorpType.  SQL-Server wraps aString in parentheses, so uwrap it first.  If aString is nil, ensure we return nil."	| debracket |	aString size &lt; 2 ifTrue: [^aString].	"relies on nil size = 0"	debracket := aString copy.	[debracket first = $( and: [debracket last = $)]]		whileTrue: [debracket := debracket copyFrom: 2 to: debracket size - 1].	^debracket</body><body package="GlorpDatabase">toGlorpType: aGlorpType fromString: aString	"Since SQL-Server wraps the string in parentheses, uwrap it first."	^super		toGlorpType: aGlorpType		fromString: (self removeNestedParensFromString: aString)</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase">convertBooleanToDBBoolean: aBoolean for: aType	"I use the bivalued type BIT to hold booleans."	aBoolean isNil ifTrue: [^nil].	"Is this nil-check needed?  I believe yes it is."	^aBoolean ifTrue: [1] ifFalse: [0]"SQLServer also accepts TRUE' and 'FALSE' but it is simpler to use 1 and 0"</body><body package="GlorpDatabase">convertDBBooleanToBoolean: aBit for: aType	"I map database type BIT (values 1 and 0) to image type boolean (values true and false).  ODBCEXDI knows the source is a BIT column type, and has already converted to the bit to a Boolean."	aBit isNil ifTrue: [^nil].		^aBit "= 1"</body><body package="GlorpDatabase">printBoolean: aBoolean for: aType	"If the platform is MS SQL Server, a boolean object in a SELECT needs to be converted to  BIT type, since T, Y, or true make SQLServer complain."		| string |	aBoolean isNil ifTrue: [^'NULL'].	"We may be getting passed something that's already 1 or 0, or something else instead of a boolean. That probably shouldn't be happening, but let's handle it gracefully. We define gracefully to mean 1 is true, and everything else is false"	string := (aBoolean == 1 or: [aBoolean = true]) 		ifTrue: ['1'] 		ifFalse: ['0'].	^'CONVERT( BIT, ' , string , ' )'."SQLServer also accepts CONVERT(BIT, 'TRUE')"</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>exdi specific</category><body package="GlorpDatabase">exdiTypeForDate	^#Timestamp</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>database-specific</category><body package="GlorpDatabase">compoundOperationFor: aSymbol	"Return the platform specific version of a compound statement symbol"	aSymbol == #INTERSECT ifTrue: [^'WHERE EXISTS'].	aSymbol == #MINUS ifTrue: [^'WHERE NOT EXISTS'].	^aSymbol.</body><body package="GlorpDatabase">printPreLimit: anInteger on: aCommand	aCommand		nextPutAll: ' TOP '.	anInteger printOn: aCommand.	aCommand nextPutAll: ' '.</body><body package="GlorpDatabase">printReturningFieldsOn: aCommand	"Return current field value from an UPDATE statement, e.g.		UPDATE my_able SET field = field + 10 OUTPUT INSERTED.field WHERE id=2returns the post-update (incremented by 10) value of field."	aCommand nextPutAll: ' OUTPUT '.	GlorpHelper		do: [:nextField | aCommand nextPutAll: 'INSERTED.', nextField name]		for: aCommand relativeFields		separatedBy: [aCommand nextPut: $,; space].</body><body package="GlorpDatabase">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"If aQuery has operations that we don't support, rewrite it to do them in terms of lower level operations. In particular, rewrite INTERSECT/EXCEPT operations into EXISTS clauses in a single query. Pass the new query to aBlock."	| newQuery |	newQuery := aQuery rewriteIntersect.	newQuery := newQuery rewriteExcept.	newQuery == aQuery ifFalse: [aBlock value: newQuery].</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>binding</category><body package="GlorpDatabase">bindingsForGroupWritingFor: aCommand	^aCommand arrayBindings</body><body package="GlorpDatabase">maximumSizeToGroupWriteFor: aRowBasedCommand	^250 min: (super maximumSizeToGroupWriteFor: aRowBasedCommand)</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>functions</category><body package="GlorpDatabase">initializeFunctions	| baseExists dbSpecificExists selectList baseNotExists dbSpecificNotExists |	super initializeFunctions.	functions		at: #, put: (InfixFunction named: '+');		at: #copyFrom:to: put: (SubstringFunction named: 'SUBSTRING');		at: #objectId put: (PrefixFunction named: 'OBJECT_ID');		at: #columnPropertySchema:property: put: ((PrefixFunction named: 'COLUMNPROPERTY') type: self integer);		"SQLServer does not support TO_CHAR, but a cast to a large varchar has the same effect."		at: #toChar: put: ((Cast named: 'CAST') separator: 'AS'; arguments: (Array with: (self varchar: 2048)));		at: #convertTo: put: ((PrefixFunction named: 'CONVERT')); "CONVERT(toType, aThing)"		at: #prepend: put: (ReversingFunction named: '+').	"Like Oracle, SQL Server doesn't allow functions like EXISTS in a field list, but will allow a select there as an argument to a function, such as CASE, so print it that way if we're in the select list."	baseExists := functions at: #exists:.	dbSpecificExists := DualRoleFunction new.	dbSpecificExists function: '#exists:'.	dbSpecificExists whereClauseVersion: baseExists.	selectList := Case new argumentTypes: (Array with: (self varchar: 1) with: self boolean with: self boolean).	selectList argumentModifierBlock:	"the argument 'x' synchronises with 'x' at the end of #existenceCheck:as:"		[:function :args |		function base: args first.		Array with: 'x' with: true with: false].	dbSpecificExists selectListVersion: selectList.	dbSpecificExists type: self boolean.	functions at: #exists: put: dbSpecificExists.	"And similarly NOT EXISTS"	baseNotExists := functions at: #notExists:.	dbSpecificNotExists := DualRoleFunction new.	dbSpecificNotExists function: '#notExists:'.	dbSpecificNotExists whereClauseVersion: baseNotExists.	selectList := Case new argumentTypes: (Array with: (self varchar: 1) with: self boolean with: self boolean).	selectList argumentModifierBlock:	"the argument 'x' synchronises with 'x' at the end of #existenceCheck:as:"		[:function :args |		function base: args first.		Array with: 'x' with: false with: true].	dbSpecificNotExists selectListVersion: selectList.	dbSpecificNotExists type: self boolean.	functions at: #notExists: put: dbSpecificNotExists.	"Overwrite existing LENGTH() function as LEN()."	functions at: #length put: ((PrefixFunction named: 'LEN') type: self integer).</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services columns</category><body package="GlorpDatabase">createAlterColumnStatement: aField newType: aType usingExpression: expression	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll: aType typeString.	expression ifNotNil: [ sqlStatementStream nextPutAll: ' USING ', expression ].	^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatement: aField setDefault: anObject	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DEFAULT';		space.	anObject printOn: sqlStatementStream.	sqlStatementStream		space;		nextPutAll:  'WITH VALUES'.	^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementDropDefault: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DEFAULT NULL'.	^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementDropNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll: aField type typeString;		space;		nextPutAll:  'NULL'.		^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementSetNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll: aField type typeString;		space;		nextPutAll:  self sqlTextForNOTNULLAttributeConstraint.		^sqlStatementStream contents</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseSequenceClass	"My AccessPlatform subclass has a hardcoded check in StoreDescriptorSystem&gt;&gt;sequenceFor: to ignore this method in favour of calling #justSelectTheMaximumCurrentValueAndAddOneSequenceFor: for AccessPlatform.  Can we retire that?"	^SQLServerSequence</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services tables</category><body package="GlorpDatabase">printSqlStatementToListTablesInSchema: schemaString on: aStream	"Not standardized"	| schema |	self usesInformationSchema		ifFalse: [^self subclassResponsibility].	schema := (schemaString isNil or: [schemaString isEmpty])		ifTrue: ['']		ifFalse: [schemaString, '.'].	aStream		nextPutAll: 'SELECT TABLE_NAME FROM ' ;		nextPutAll: schema;		nextPutAll: 'INFORMATION_SCHEMA.TABLES ';		nextPut: $;</body><body package="GlorpDatabase">printSqlStatementToTestExistenceOfSQLServerDatabase: schemaString on: aStream	"This query will check only for the existence of a database that the logged on user has access to (eg., NEWBERN1)."	aStream		nextPutAll: 'SELECT count(*) FROM ';		nextPutAll: 'sys.databases WHERE name = ';		nextPut: $';		nextPutAll: schemaString;		nextPut: $'</body><body package="GlorpDatabase">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	"This query will test only for tables that the logged on user has access to..  Glorp supports case-preserving creation of tables in SQLServer (see capitalWritingOfTableName) but this tests case-insensitively, compatibly with its polymorphs in this hierarchy."	| lowerTableName schema |	lowerTableName := tableName asLowercase.	schema := schemaString isNil		ifTrue: ['']		ifFalse: [schemaString, '.'].	aStream		nextPutAll: 'SELECT count(*) FROM ' ;		nextPutAll: schema;		nextPutAll: 'INFORMATION_SCHEMA.TABLES ';		nextPutAll: 'WHERE lower(TABLE_NAME) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $';		nextPut: $;</body><body package="GlorpDatabase">sqlStatementToTestExistenceOfSchema: schemaString	"Although the method name indicates 'schema', the equivalent in SQL Server is called a 'database', and yet there is also a schema concept in SQL Server, which is more like 'owner', and can include mutliple databases. For example, BERN might be the owner and also the schema, which would include databases NEWBERN1, NEWBERN2.  This method presumes that the sender is interested in databases, and the query will test only for databases that the logged on user has access to."	| stream |	stream := WriteStream on: String new.	self printSqlStatementToTestExistenceOfSQLServerDatabase: schemaString on: stream.	^stream contents</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>type helpers</category><body package="GlorpDatabase">typesWithValues	self nvarchar.	self nchar.	self ntext.	^super typesWithValues</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"SQL Server began supporting group writing with the VALUES clause in version 10.0, and recursion in version 10.5.  We began supporting ODBC 3.0 in VisualWorks 8.2.1."	| dbmsVersion dbAccessorConnection |	dbAccessorConnection := aDatabaseAccessor connection.	dbmsVersion := dbAccessorConnection dbmsVersion tokensBasedOn: $..	supportsGroupWritingValues := dbmsVersion first asNumber &gt; 9.	supportsUnboundRowCount := dbAccessorConnection odbcVersion &gt; 2.	canRecurse := self isVersion: #(10 5) notNewerThan: dbmsVersion	"10.5 is 2008 R2"</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	"I can group ;-separated INSERT statements or (if I am new enough - version 10 or later) ,-separated values following a single INSERT statement.  When bound, the same applies but I can also bind an array of values to a single INSERT statement. As array binding is fastest, use an array of values when bound, a sequence of values when unbound.  I answer true to usesIdentityColumns;  if I am writing to a serial type (an identity column), the server will assign the value(s) which I retrieve in the same round-trip (when the round trip has multiple rows, retrieving assigned values in the same round trip is the only way I can retrieve them)."	^(aBoolean or: [self supportsGroupWritingValues])		ifTrue: [InsertSelectRowsCommand				forRows: aCollectionOfDatabaseRows				useBinding: aBoolean				session: aSession				ifNoIdentityColumn: InsertMultiValuesCommand]		ifFalse: [InsertSelectRowCommand				forRows: aCollectionOfDatabaseRows				useBinding: aBoolean				session: aSession				ifNoIdentityColumn: InsertCommand]</body><body package="GlorpDatabase">relativeUpdateCommand	"SQLServer inserts 'OUTPUT ...' before its WHERE clause to return the updated value, unlike the more common approach of RETURNING after rest of the update statement, so its relative-update-and-return command is not ReturningUpdateCommand."	^OutputUpdateCommand</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>services constraints</category><body package="GlorpDatabase">createConstraintAddStatement: aConstraint	| sqlStatementStream strings |	aConstraint shouldCreateInDatabase ifFalse: [^''].	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll: 'ALTER TABLE';		space.	self printDDLTableNameFor: aConstraint table on: sqlStatementStream.	strings := aConstraint creationStringFor: self.	sqlStatementStream nextPutAll: ' ADD ' , strings first.	(strings allButFirst: 1) do:		[:each |		sqlStatementStream			nextPut: $,;			nextPutAll: each].	^sqlStatementStream contents</body><body package="GlorpDatabase">createConstraintDropStatement: aConstraint	"On SQLServerPlatform, if aConstraint is a primary key constraint then there will also be a unique constraint."	| nonPkConstraintDropString |	nonPkConstraintDropString := super createConstraintDropStatement: aConstraint.	nonPkConstraintDropString isEmpty ifTrue: [^nonPkConstraintDropString].	"If it's not a primary key, we're done."	aConstraint isPrimaryKeyConstraint ifFalse: [^nonPkConstraintDropString].	^(String new: 32) writeStream		nextPutAll: nonPkConstraintDropString;		nextPutAll: ', CONSTRAINT ';		nextPutAll: aConstraint table name;		nextPutAll: '_UNIQ';		contents</body></methods><methods><class-id>Glorp.SQLServerPlatform</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"SQL Server began supporting group writing with the VALUES clause in version 10.0, and recursion in version 10.5.  For safety, we initialize to false, resetting in postLoginInitializeFromAccessor:."	super initialize.	canRecurse := false.	supportsGroupWritingValues := false.</body></methods><methods><class-id>Glorp.SQLServerPlatform class</class-id> <category>constants</category><body package="GlorpDatabase">reservedWords	^#('@@identity' 'add' 'all' 'alter' 'and' 'any' 'as' 'asc' 'authorization' 'avg' 'backup' 'begin' 'between' 'break' 'browse' 'bulk' 'by' 'cascade' 'case' 'check' 'checkpoint' 'close' 'clustered' 'coalesce' 'collate' 'column' 'commit' 'compute' 'constraint' 'contains' 'containstable' 'continue' 'convert' 'count' 'create' 'cross' 'current' 'current_date' 'current_time' 'current_timestamp' 'current_user' 'cursor' 'database' 'databasepassword' 'dateadd' 'datediff' 'datename' 'datepart' 'dbcc' 'deallocate' 'declare' 'default' 'delete' 'deny' 'desc' 'disk' 'distinct' 'distributed' 'double' 'drop' 'dump' 'else' 'encryption' 'end' 'errlvl' 'escape' 'except' 'exec' 'execute' 'exists' 'exit' 'expression' 'fetch' 'file' 'fillfactor' 'for' 'foreign' 'freetext' 'freetexttable' 'from' 'full' 'function' 'goto' 'grant' 'group' 'having' 'holdlock' 'identity' 'identity_insert' 'identitycol' 'if' 'in' 'index' 'inner' 'insert' 'intersect' 'into' 'is' 'join' 'key' 'kill' 'left' 'like' 'lineno' 'load' 'max' 'min' 'national' 'nocheck' 'nonclustered' 'not' 'null' 'nullif' 'of' 'off' 'offsets' 'on' 'open' 'opendatasource' 'openquery' 'openrowset' 'openxml' 'option' 'or' 'order' 'outer' 'over' 'percent' 'plan' 'precision' 'primary' 'print' 'proc' 'procedure' 'public' 'raiserror' 'read' 'readtext' 'reconfigure' 'references' 'replication' 'restore' 'restrict' 'return' 'revoke' 'right' 'rollback' 'rowcount' 'rowguidcol' 'rule' 'save' 'schema' 'select' 'session_user' 'set' 'setuser' 'shutdown' 'some' 'statistics' 'sum' 'system_user' 'table' 'textsize' 'then' 'to' 'top' 'tran' 'transaction' 'trigger' 'truncate' 'tsequal' 'union' 'unique' 'update' 'updatetext' 'use' 'user' 'values' 'varying' 'view' 'waitfor' 'when' 'where' 'while' 'with' 'writetext')		asSet</body></methods><methods><class-id>Glorp.SQLServerPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Microsoft SQL Server'</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>SQL</category><body package="GlorpDatabase">supportsVariableSizedNumerics	"Return true if this platform can support numbers with a varying size and number of decimal places. Access, notably, doesn't seem to be able to"	^false.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated	^false.</body><body package="GlorpDatabase">initializeReservedWords	super initializeReservedWords.	reservedWords		add: 'timestamp';		add: 'key'</body><body package="GlorpDatabase">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^64</body><body package="GlorpDatabase">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^64</body><body package="GlorpDatabase">parenthesizeAllButFirstCommandInCompoundQuery	^true</body><body package="GlorpDatabase">sqlTextCurrentServerUTCTimestamp	"This isn't UTC, but ACCESS is a local server anyway, and doesn't appear to support UTC."	^'SELECT NOW()'</body><body package="GlorpDatabase">sqlTextForDEFAULT: defaultValue	"We don't support DEFAULT statements"	^''</body><body package="GlorpDatabase">supportsAuthentication	^false</body><body package="GlorpDatabase">supportsMillisecondsInTimes	^false.</body><body package="GlorpDatabase">usesNullForFalse	"I use NULL to meaning FALSE when occurring in a boolean column."	^true</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>testing</category><body package="GlorpDatabase">canBind: aValue to: aType	(Dialect isVisualWorks		and: [aValue class == Dialect fixedPointClass]) ifTrue: [^false].	(Dialect isVisualWorks and: 			[#(#LargePositiveInteger #LargeNegativeInteger)				includes: aValue class name asSymbol])		ifTrue: [aType = self int8 ifTrue: [^false]].	^super canBind: aValue to: aType</body><body package="GlorpDatabase">canRecurse	^false</body><body package="GlorpDatabase">canUseInWhereClause: aValue type: aType	"This is mostly for test support purposes. If we know we can't use a particular kind of value in the where clause on some database, don't try."	(super canUseInWhereClause: aValue type: aType) ifFalse: [^false].	"With MS Access (Jet db engine) we don't seem to be able to compare constants against blobs."	aType = self blob ifTrue: [^false].	^true.</body><body package="GlorpDatabase">isAccessPlatform	^true</body><body package="GlorpDatabase">isSQLServerPlatform	^false</body><body package="GlorpDatabase">requiresCastsForNullsInUnions	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."	^false.</body><body package="GlorpDatabase">supportsCorrelatedSubqueriesInOrderBy	"Access supports only a field list in the ORDER BY clause--no subqueries whatsoever."	^false</body><body package="GlorpDatabase">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place"	^true.</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	^false</body><body package="GlorpDatabase">supportsGroupWritingValues	"Untested, so assume false until shown otherwise."	^false</body><body package="GlorpDatabase">supportsInformationSchema	^false.</body><body package="GlorpDatabase">supportsSchemas	^false</body><body package="GlorpDatabase">supportsSingleQueryHorizontalInheritance	"Can this database support a single query for horizontal inheritance."	^false.</body><body package="GlorpDatabase">supportsStringQueryOnBlobs	"Return true if we can do string queries on parts of blobs."	^false.</body><body package="GlorpDatabase">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL.""Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^false</body><body package="GlorpDatabase">useMicrosoftOuterJoins	"Return true if we use the Microsoft x *= y syntax for outer joins. Oddly enough, false for access 2k"	^false.</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	^false</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase">convertBooleanToDBBoolean: aBoolean for: aType	"I use NULL to meaning FALSE in a boolean column."	aBoolean isNil ifTrue: [^false].	^aBoolean</body><body package="GlorpDatabase">convertDBBooleanToBoolean: aDBBoolean for: aType	"I treat NULL as false;  a value write as nil by the image will be returned as fals when read."	^aDBBoolean</body><body package="GlorpDatabase">printBoolean: aBoolean for: aType	"Like MS SQL Server, Access requires that a boolean object in a SELECT be converted to bit-valued type, since T, Y, or true raise an error, but the conversion code differs."		| string |	aBoolean isNil ifTrue: [^'NULL'].	"We may be getting passed something that's already 1 or 0, or something else instead of a boolean. That probably shouldn't be happening, but let's handle it gracefully. We define gracefully to mean 1 is true, and everything else is false"	string := (aBoolean == 1 or: [aBoolean = true]) 		ifTrue: ['1'] 		ifFalse: ['0'].	^'CBOOL( ' , string , ' )'.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>types</category><body package="GlorpDatabase">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'longbinary'].</body><body package="GlorpDatabase">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'memo'].</body><body package="GlorpDatabase">longText	^self typeNamed: #longText ifAbsentPut: [GlorpClobType new typeString: 'memo'].</body><body package="GlorpDatabase">memo	^self typeNamed: #memo ifAbsentPut: [GlorpClobType new typeString: 'memo'].</body><body package="GlorpDatabase">nclob	"Access uses the same type for strings and unicode strings."	^self typeNamed: #nclob ifAbsentPut: [GlorpClobType new typeString: 'memo']</body><body package="GlorpDatabase">ntext	"Access uses the same type for strings and unicode strings."	^self typeNamed: #ntext ifAbsentPut: [GlorpClobType new typeString: 'longtext']</body><body package="GlorpDatabase">serial	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'autoincrement'].</body><body package="GlorpDatabase">text	^self typeNamed: #text ifAbsentPut: [GlorpClobType new typeString: 'longtext'].</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>services tables</category><body package="GlorpDatabase">endColumnQuote	^']'.</body><body package="GlorpDatabase">startColumnQuote	^'['.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>functions</category><body package="GlorpDatabase">initializeFunctions	"See AccessCast class comments for more info on cast limitations."	| baseExists dbSpecificExists selectList baseNotExists dbSpecificNotExists |	"Ignore SQLServer functions by starting with the defaults."	functions := FunctionExpression createBasicFunctionsFor: self.	functions		at: #, put: (InfixFunction named: '+');		at: #copyFrom:to: put: (SubstringFunction named: 'MID');		at: #cast: put: ((AccessCast named: 'template') separator: ' ').	"Like Oracle, MS Access doesn't allow functions like EXISTS in a field list,	but will allow a select there as an argument to a function, such as IIF.	So print it that way if we're in the select list."	baseExists := functions at: #exists:.	dbSpecificExists := DualRoleFunction new.	dbSpecificExists function: '#exists:'.	dbSpecificExists whereClauseVersion: baseExists.	selectList := IIF new argumentTypes: (Array with: (self varchar: 1) with: self integer with: self integer).	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 1 asGlorpExpression with: 0 asGlorpExpression].	dbSpecificExists selectListVersion: selectList.	dbSpecificExists type: self integer.	functions at: #exists: put: dbSpecificExists.	"And similarly NOT EXISTS"	baseNotExists := functions at: #notExists:.	dbSpecificNotExists := DualRoleFunction new.	dbSpecificNotExists function: '#notExists:'.	dbSpecificNotExists whereClauseVersion: baseNotExists.	selectList := IIF new argumentTypes: (Array with: (self varchar: 1) with: self integer with: self integer).	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 0 asGlorpExpression with: 1 asGlorpExpression].	dbSpecificNotExists selectListVersion: selectList.	dbSpecificNotExists type: self integer.	functions at: #notExists: put: dbSpecificNotExists.</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>type helpers</category><body package="GlorpDatabase">typesWithValues	"Remove types applicable to my SQLServerPlatform superclass but not to me."	super typesWithValues.	types removeKey: #nvarchar ifAbsent: [].	types removeKey: #nchar ifAbsent: [].	self nclob.	^types</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	^InsertCommand		forRows: aCollectionOfDatabaseRows		useBinding: aBoolean		session: aSession</body></methods><methods><class-id>Glorp.AccessPlatform</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"No need to set supportsGroupWritingValues to false as my getter returns false anyway."</body></methods><methods><class-id>Glorp.AccessPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Access'</body></methods><methods><class-id>Glorp.TypeMapping</class-id> <category>mapping</category><body package="GlorpMappings">addTypeMappingCriteriaTo: collection in: expression	^self</body><body package="GlorpMappings">allDescribedConcreteClasses	^Array with: (self describedClass)</body><body package="GlorpMappings">describedClass	^self descriptor describedClass</body><body package="GlorpMappings">describedConcreteClassFor: aRow withBuilder: builder	^self mappedClass</body><body package="GlorpMappings">descriptorForSuperclass	^self system descriptorFor: self mappedClass superclass</body><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap	"do  nothing"</body><body package="GlorpMappings">mapObject: anObject inElementBuilder: anElementBuilder	"do  nothing"</body><body package="GlorpMappings">referencedIndependentObjectsFrom: anObject	^#().</body><body package="GlorpMappings">typeMappingRoot	^self isTypeMappingRoot 		ifTrue: [self mappedClass]		ifFalse: [self descriptorForSuperclass typeMapping typeMappingRoot]</body></methods><methods><class-id>Glorp.TypeMapping</class-id> <category>testing</category><body package="GlorpMappings">canBeTypeMappingParent	^true</body><body package="GlorpMappings">hasAttribute	"Return true if this maps an attribute, which is normally true"	^false.</body><body package="GlorpMappings">isAbstract	self subclassResponsibility</body><body package="GlorpMappings">isRelationship	^false.</body><body package="GlorpMappings">isTypeMapping	^true</body><body package="GlorpMappings">isTypeMappingRoot	| superClassDescriptor |	superClassDescriptor := self descriptorForSuperclass.	^superClassDescriptor isNil or: [ superClassDescriptor typeMapping canBeTypeMappingParent not ]</body></methods><methods><class-id>Glorp.TypeMapping</class-id> <category>accessing</category><body package="GlorpMappings">mappedClass	^self descriptor describedClass</body></methods><methods><class-id>Glorp.TypeMapping</class-id> <category>validation</category><body package="GlorpMappings">validateAttribute	" TypeMapping doesn't use the attribute, validation would therefore fail. Probably should introduce AttributeMapping as sibling to TypeMapping "</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>mapping</category><body package="GlorpMappings">addTypeMappingCriteriaTo: collection in: base	"Convert the specific subclass (of the root class) that the query requests to the appropriate value of the filter field in the root class' horizontally-filtered table.  Give this generated field the name of this class (a Symbol) as alias, so #isNeutralInPrimaryKeyExpression can recognise it (using ==) as generated."	| singleRightValue r l |	singleRightValue := self keys size = 1.	r := ConstantExpression for: (singleRightValue								ifTrue: [self keys asArray first]								ifFalse: [self keys]).	r alias: FilteredTypeMapping name.	l := FieldExpression forField: self field basedOn: base.	collection add: (singleRightValue ifTrue: [l equals: r] ifFalse: [l in: r]).</body><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap	| row |	self canWrite ifFalse: [^self].	row := aRowMap findOrAddRowForTable: self field table withKey: anObject.	row at: field put: key.</body><body package="GlorpMappings">trace: aTracing context: anExpression	^self.</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject	^self keyDictionary keyAtValue: anObject class</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>accessing</category><body package="GlorpMappings">field	"If we don't have this, look it up from one of our sub-mappings"	| concrete |	field isNil ifTrue: [		concrete := self descriptor typeResolver concreteMembers detect: [:each | each typeMapping field notNil].		field := concrete typeMapping field].	^field.</body><body package="GlorpMappings">keyDictionary	keyDictionary isNil ifTrue: [ self buildKeyDictionary ].	^keyDictionary</body><body package="GlorpMappings">keyedBy	^key</body><body package="GlorpMappings">keyedBy: aKey	key := aKey</body><body package="GlorpMappings">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	^Array with: self field.</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>types</category><body package="GlorpMappings">describedConcreteClassFor: aRow withBuilder: builder	^self keyDictionary at: (aRow atIndex: (builder translateFieldPosition: field))</body><body package="GlorpMappings">keys	^self keyDictionary keys</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>initialize-release</category><body package="GlorpMappings">buildKeyDictionary	keyDictionary := Dictionary new.	key isNil ifFalse: [keyDictionary at: key put: descriptor describedClass].	descriptor describedClass allSubclasses do:		[:each || subclassDescriptor |		subclassDescriptor := descriptor system descriptorFor: each.		(subclassDescriptor isNil or:				[subclassDescriptor typeMapping keyedBy isNil])			ifFalse: [keyDictionary						at: subclassDescriptor typeMapping keyedBy						put: subclassDescriptor describedClass]].</body><body package="GlorpMappings">field: aField keyedBy: aKey	field := aField.	key := aKey.</body></methods><methods><class-id>Glorp.FilteredTypeMapping class</class-id> <category>instance creation</category><body package="GlorpMappings">to: field keyedBy: key	^self new		field: field		keyedBy: key</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>public</category><body package="GlorpDatabase">creationString	^self sequenceIncrement &gt; 1		ifFalse: ['create sequence ', self qualifiedName]		ifTrue: ['create sequence ', self qualifiedName, ' increment by ', self sequenceIncrement printString]</body><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aField in: aRow using: anAccessor 	aRow at: aField put: (self nextSequenceNumber: anAccessor)</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>accessing</category><body package="GlorpDatabase">name: aString	name := aString copyFrom: 1 to: (aString size min: OraclePlatform new maximumLengthOfTableName).</body><body package="GlorpDatabase">sequenceIncrement	^sequenceIncrement</body><body package="GlorpDatabase">sequenceIncrement: aNumber 	sequenceIncrement := aNumber</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>testing</category><body package="GlorpDatabase">alwaysGetFromDb	^sequenceIncrement = 1</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>private</category><body package="GlorpCore">backupReserveCommand: anInteger in: aSession	| command stream |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select '.	stream nextPutAll: self qualifiedName.	stream nextPutAll: '.nextval from SYS.ALL_OBJECTS '.	stream nextPutAll: ' WHERE rownum &lt;= '.	stream		nextPutAll:			(aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body><body package="GlorpDatabase">nextSequenceNumber: anAccessor 	accessProtect critical: 			[count := count + 1.			^(self alwaysGetFromDb or: [count \\ sequenceIncrement = 1]) 				ifTrue: 					[count := (anAccessor 								executeSQLString: self nextSequenceNumberSelectString) first 								first]				ifFalse: [count]]</body><body package="GlorpDatabase">nextSequenceNumberSelectString	^'SELECT ' , self qualifiedName , '.NEXTVAL FROM DUAL'</body><body package="GlorpDatabase">reserveViaBackupMechanism: anInteger in: aSession	"The regular mechanism didn't work, (probably because there weren't enough rows in the table), try a different technique. Oracle doesn't repeatedly evaluate nextval if we do it multiple times on a line, so instead guess at a table we know should have lots of rows in Oracle and use it"	| rows command |	command := self backupReserveCommand: anInteger in: aSession.	command blockFactor: anInteger.	rows := aSession accessor executeCommand: command.	rows do: [:each | self reservedNumbers add: each first].</body><body package="GlorpDatabase">reserveViaTableSelect: anInteger in: aSession for: aTable	"In Oracle, there can be performance issues selecting against our tables, which we don't seem to get if we just use SYS.ALLOBJECTS. I'm suspicious the problem is if we have fragmentation of the file containing the table, but regardless, ALLOBJECTS seems consistently fast, so always use it"	self reserveViaBackupMechanism: anInteger in: aSession."	| rows command |	command := self		tableSelectCommandFor: aTable		in: aSession		reserving: anInteger.	command parameters: (Array with: anInteger).	rows := aSession accessor executeCommand: command.	rows do: [:each | self reservedNumbers add: each first]."</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>initalize-release</category><body package="GlorpDatabase">initialize	super initialize.	count := 0.	sequenceIncrement := 1.	"This seems to hang on the semaphore in ObjectStudio. Fake around it"	accessProtect := Dialect isObjectStudio ifTrue: [nil] ifFalse: [Semaphore forMutualExclusion].</body></methods><methods><class-id>Glorp.OracleSequence</class-id> <category>SQL</category><body package="GlorpCore">tableSelectCommandFor: aTable in: aSession reserving: anInteger	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select '.			stream nextPutAll: self qualifiedName.			stream nextPutAll: '.nextval from '.			stream nextPutAll: aTable name.			stream nextPutAll: ' WHERE rownum &lt;= '.			stream nextPutAll: (aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand blockFactor: anInteger.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>accessing</category><body package="GlorpDatabase">name: aString	name := aString copyFrom: 1 to: (aString size min: DB2Platform new maximumLengthOfTableName).</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>private</category><body package="GlorpCore">backupReserveCommand: anInteger in: aSession	"syscat.tables is a public view of all the tables.	Don't bind the number in the fetch first nn clause."	| command stream |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select next value for '.	stream nextPutAll: self qualifiedName.	stream nextPutAll: ' from SYSCAT.TABLES'.	stream nextPutAll: ' fetch first '.	stream nextPutAll: anInteger printString.	stream nextPutAll: ' rows only'.	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body><body package="GlorpDatabase">nextSequenceNumberSelectString	"Using SYSIBM is not ideal because it's supposed to be internal, but it seems to be accepted."	^'SELECT NEXT VALUE FOR ' , self qualifiedName , ' FROM SYSIBM.SYSDUMMY1'</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>public</category><body package="GlorpDatabase">creationString	^'create sequence ', self qualifiedName.</body></methods><methods><class-id>Glorp.DB2Sequence</class-id> <category>SQL</category><body package="GlorpCore">tableSelectCommandFor: aTable in: aSession reserving: anInteger	"Don't bind the number in the fetch first nn clause."	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select next value for '.			stream nextPutAll: self qualifiedName.			stream nextPutAll: ' from '.			stream nextPutAll: aTable name.			stream nextPutAll: ' fetch first '.			stream nextPutAll: anInteger printString.			stream nextPutAll: ' rows only'.			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand blockFactor: anInteger.			tableSelectCommand session: aSession].	^tableSelectCommand.</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>types</category><body package="GlorpDatabase">boolean	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'boolean'].</body><body package="GlorpDatabase">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'clob'].</body><body package="GlorpDatabase">date	^self typeNamed: #date ifAbsentPut: [GlorpDateType new].</body><body package="GlorpDatabase">double	^self float8</body><body package="GlorpDatabase">float	^self float4.</body><body package="GlorpDatabase">float4	^self typeNamed: #float4 ifAbsentPut: [GlorpFloatType new typeString: 'float'].</body><body package="GlorpDatabase">float8	^self typeNamed: #float8 ifAbsentPut: [GlorpDoubleType new typeString: 'double precision'].</body><body package="GlorpDatabase">int2	^self smallint.</body><body package="GlorpDatabase">int4	^self integer.</body><body package="GlorpDatabase">int8	^self integer</body><body package="GlorpDatabase">numeric	^self typeNamed: #numeric ifAbsentPut: [GlorpNumericType new].</body><body package="GlorpDatabase">sequence	^self inMemorySequence</body><body package="GlorpDatabase">serial	^self sequence</body><body package="GlorpDatabase">text	^self clob.</body><body package="GlorpDatabase">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time'].</body><body package="GlorpDatabase">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'timestamp'].</body><body package="GlorpDatabase">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new].</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated^false</body><body package="GlorpDatabase">primaryKeysAreAutomaticallyUnique	^true.</body><body package="GlorpDatabase">sqlTextForNULLAttributeConstraint	"^&lt;String&gt;"	^''</body><body package="GlorpDatabase">supportsMillisecondsInTimes	"I'm guessing here"	^true.</body><body package="GlorpDatabase">usesNullForEmptyStrings	"Return true if this database is likely to use nil as an empty string value"	^false.</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>testing</category><body package="GlorpDatabase">isOcelotPlatform	^true</body><body package="GlorpDatabase">isODBCPlatform	^true</body><body package="GlorpDatabase">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^true</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">paddingCharacter	^32 asCharacter.</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>conversion times</category><body package="GlorpDatabase">printDate: aDate for: aType	| stream |	aDate isNil ifTrue: [^nil].	stream := WriteStream on: String new.	stream nextPutAll: 'date '''.	self		printDate: aDate		isoFormatOn: stream.	stream nextPutAll: ''''.	^stream contents.</body><body package="GlorpDatabase">printTime: aTime for: aType	| stream |	aTime isNil ifTrue: [^nil].	stream := WriteStream on: String new.	stream nextPutAll: 'time '''.	self		printTime: aTime		isoFormatOn: stream.	stream nextPutAll: ''''.	^stream contents.</body><body package="GlorpDatabase">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPutAll: 'timestamp '''.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPut: $ .	self		printTime: aTimestamp		isoFormatOn: stream.	"	milliseconds: true."	stream nextPutAll: ''''.</body></methods><methods><class-id>Glorp.OcelotPlatform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseSequenceClass	^InMemorySequence.</body></methods><methods><class-id>Glorp.OcelotPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Ocelot'</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated	^true</body><body package="GlorpDatabase">initializeReservedWords	reservedWords := Set new.	reservedWords 		add: 'type';		add: 'value';		add: 'password';		add: 'unique';		add: 'date';		add: 'current';		add: 'order';		add: 'active';		add: 'action';		add: 'database';		add: 'table';		add: 'timestamp';		add: 'position'.</body><body package="GlorpDatabase">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^31</body><body package="GlorpDatabase">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^31</body><body package="GlorpDatabase">requiresTransactionForTableOperations	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"	^false.</body><body package="GlorpDatabase">supportsMillisecondsInTimes	^false.</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseSequenceClass	^FirebirdSequence.</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>types</category><body package="GlorpDatabase">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'blob sub_type text'].</body><body package="GlorpDatabase">sequence	^self typeNamed: #sequence ifAbsentPut: [GlorpSerialType new typeString: (self integer typeString)].</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>binding</category><body package="GlorpDatabase">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings.</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>testing</category><body package="GlorpDatabase">isODBCPlatform	"IBEXDI defines an EXDI connection class, not an ODBC one." 	^false</body><body package="GlorpDatabase">measuresStringFieldWidthsInBytes	^true</body><body package="GlorpDatabase">reusePreparedStatements	"Firebird/InterBase supports binding of parameters (i.e. instead of printing them as strings within the SQL statement);  indeed, when handling Blobs, the current IBEXDI implementation demands it.  However if RowBasedCommands (INSERT, DELETE, UPDATE) attempt to reuse bound statements, there are failures;  every 79th or 358th or whatever reuse of such a statement returns bad data.  (SELECT statements are fine.)  This was hidden when failure to release the GlorpCursor in RowBasedCommands left statements busy, so unreusable;  the fix (first made in Glorp 0.3.181) revealed it.  We return false here so that reusePreparedStatements is initialized to false for any accessor whose login uses this platform."	^false"To study further:  is it that prepared-statement-signature-matching needs to distingush the types of the contents of an EqualOnContentsReadStream, or does the database need a bug fix, or does the IBEXDI need to handle Blobs differently?  If the problems with RowBaseCommands cannot be resolved, can we / should we distinguish between reusing them and reusing SELECT statements?"</body><body package="GlorpDatabase">supportsBinding	"Firebird/InterBase supports binding in all statements (indeed its EXDI appears to require it for blobs) and can also reuse SELECT statements, but reuse of RowBasedCommands (INSERT, DELETE, UPDATE) for Blobs is unreliable although binding of such statements is essential (see my #reusePreparedStatementsIfSupported method comment)."	^true</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>conversion</category><body package="GlorpDatabase">blobDataToStreamConverter	^DelegatingDatabaseConverter		named: #blobDataToStream		hostedBy: self		fromStToDb: #convertBlobData:for:		fromDbToSt: #nullConversion:for:.</body><body package="GlorpDatabase">convertBlobData: aData for: aType	"From standard Store getBlobData called in writeSession;  Firebird seems to need it.  Glorp needs to think that two such streams on the same data are equal."	^EqualOnContentReadStream on: aData</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>accessing</category><body package="GlorpDatabase">vwEXDIConnectionClass	^'InterBaseConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'IBEXDI'</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>services tables</category><body package="GlorpDatabase">printSqlStatementToListTablesInSchema: schemaString on: aStream	"Firebird uses the same table for tables, views and possibly other stuff.  It does not support schemas within a database "	aStream		nextPutAll: 'SELECT rdb$relation_name as table_name FROM rdb$relations ';		nextPutAll: 'WHERE rdb$view_blr is null and (rdb$system_flag is null or rdb$system_flag = 0);'</body><body package="GlorpDatabase">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	"Firebird uses the same table for tables, views and possibly other stuff, does NOT support schemas. 	As currently written, this query will not test for existence of views OR system tables."	aStream		nextPutAll: 'SELECT count(*) FROM rdb$relations ';		nextPutAll: 'WHERE rdb$relation_name = ';		nextPut: $';		nextPutAll: tableName;		nextPut: $';		nextPutAll: ' AND rdb$view_blr is null AND (rdb$system_flag is null OR rdb$system_flag = 0);'</body></methods><methods><class-id>Glorp.FirebirdPlatform</class-id> <category>functions</category><body package="GlorpDatabase">initializeFunctions	"Firebird 2.5 and later supports the ANSI SQL 'SIMILAR TO' form of regex, in which the % and _ of SQL's LIKE predicate replace the corresponding * and ? of regex."	super initializeFunctions.	functions at: #similarTo: put: (InfixFunction named: 'SIMILAR TO').</body></methods><methods><class-id>Glorp.FirebirdPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Firebird'</body></methods><methods><class-id>Glorp.TransformingFieldValueWrapper</class-id> <category>accessing</category><body package="GlorpUnitOfWork">allInnerWrappers	^innerWrapper allInnerWrappers, (Array with: innerWrapper).</body><body package="GlorpUnitOfWork">basicContents	"Return the un-transformed contents"	^innerWrapper contents.</body><body package="GlorpUnitOfWork">contents	^forwardTransformation value: innerWrapper contents.</body><body package="GlorpUnitOfWork">contents: anObject	innerWrapper contents: (inverseTransformation value: anObject).</body><body package="GlorpUnitOfWork">forwardTransformation	^forwardTransformation</body><body package="GlorpUnitOfWork">forwardTransformation: aBlock	forwardTransformation := aBlock</body><body package="GlorpUnitOfWork">hasValue	^innerWrapper hasValue.</body><body package="GlorpUnitOfWork">innerWrapper	^innerWrapper</body><body package="GlorpUnitOfWork">innerWrapper: aFieldValueWrapper	innerWrapper := aFieldValueWrapper</body><body package="GlorpUnitOfWork">inverseTransformation	^inverseTransformation</body><body package="GlorpUnitOfWork">inverseTransformation: aBlock	inverseTransformation := aBlock</body><body package="GlorpUnitOfWork">privateSetContents: anObject	innerWrapper privateSetContents: (inverseTransformation value: anObject).</body></methods><methods><class-id>Glorp.TransformingFieldValueWrapper</class-id> <category>unifying</category><body package="GlorpUnitOfWork">containsWrapper: aFieldValueWrapper	^self == aFieldValueWrapper or: [innerWrapper == aFieldValueWrapper		or: [aFieldValueWrapper innerWrapper == self			or: [aFieldValueWrapper innerWrapper == self innerWrapper]]].</body><body package="GlorpUnitOfWork">replaceWith: aFieldValueWrapper	innerWrapper replaceWith: aFieldValueWrapper.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>accessing</category><body package="GlorpExpressions">base	^base.</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions">printsTable	^true.</body><body package="GlorpExpressions">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions">system	^base system</body><body package="GlorpExpressions">table	^table.</body><body package="GlorpExpressions">tables	^Array with: table.</body><body package="GlorpExpressions">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>preparing</category><body package="GlorpExpressions">aliasedTableFor: aDatabaseTable 	^self controlsTables 		ifTrue: [super aliasedTableFor: aDatabaseTable]		ifFalse: [base aliasedTableFor: aDatabaseTable]</body><body package="GlorpExpressions">aliasedTableFor: aDatabaseTable ifAbsent: aBlock	^self controlsTables 		ifTrue: [super aliasedTableFor: aDatabaseTable ifAbsent: aBlock]		ifFalse: [base aliasedTableFor: aDatabaseTable ifAbsent: aBlock]</body><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^(source tablesContainingMe includes: table) ifTrue: [source] ifFalse: [target getTable: table].</body><body package="GlorpExpressions">controlsTables	"We can end up with a table expression built on top of a base that has the same table. If so, we don't count as controlling that table"	base isNil ifTrue: [^true].	base hasDescriptor ifFalse: [^true].	^(base descriptor tables includes: table) not.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	self == anExpression ifTrue: [^aBaseExpression].	^(base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression) getTable: table.</body><body package="GlorpExpressions">tablesToPrint	self controlsTables ifFalse: [^#()].	^Array with: (self aliasedTableFor: table).</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>printing</category><body package="GlorpExpressions">printOnlySelfOn: aStream	table printSQLOn: aStream withParameters: #().	self printTableAliasesOn: aStream.</body><body package="GlorpExpressions">printTreeOn: aStream 	base printOn: aStream.	aStream nextPut: $..	table printSQLOn: aStream withParameters: #()</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>initialize/release</category><body package="GlorpExpressions">table: aDatabaseTable base: aBaseExpression	table := aDatabaseTable.	base := aBaseExpression.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree"	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>api</category><body package="GlorpExpressions">getFieldThatsAnActualFieldObject: aField	^self mappingExpressions at: aField ifAbsentPut: [self newFieldExpressionFor: aField].</body><body package="GlorpExpressions">getTable: aTable	self error: 'getting a table from a table expression doesn''t make sense'.</body><body package="GlorpExpressions">referenceClass	"Return the class that our mapping refers to, if we have a mapping. If we're a base expression, just return our class, and if we're a table expression, just return nil."	^nil.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>testing</category><body package="GlorpExpressions">canPrint	"Return true if we can print into a where clause"	^false.</body></methods><methods><class-id>Glorp.TableExpression</class-id> <category>inspecting</category><body package="GlorpExpressions">inspectorChildren	^Array with: base</body></methods><methods><class-id>Glorp.TableExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">forTable: aDatabaseTable basedOn: aBaseExpression	^self new table: aDatabaseTable base: aBaseExpression; yourself</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>private</category><body package="GlorpMappings">embeddedObjectsFor: anObject	"Return all the objects embedded into this one"	| embedded descriptor |	descriptor := self descriptorFor: anObject.	descriptor isNil ifTrue: [^#()].	embedded := OrderedCollection new: 3.	descriptor mappings do: [:each |		(each class == EmbeddedValueOneToOneMapping) ifTrue: [			embedded add: (each getValueFrom: anObject)]].	^embedded.</body><body package="GlorpCore">expiredInstanceOf: aClass key: key	^cache expiredInstanceOf: aClass key: key.</body><body package="GlorpCore">markAsCurrentOfClass: aClass key: key	cache markAsCurrentOfClass: aClass key: key.</body><body package="GlorpCore">privateGetCache	^cache.</body><body package="GlorpCore">privateGetCurrentUnitOfWork	^currentUnitOfWork.</body><body package="GlorpCore">privateRegisterAsNew: anObject 	"Register the object as one which is not already in cache. Private! Normally just use the register: operation."	currentUnitOfWork isNil ifTrue: [^self].	currentUnitOfWork registerAsNew: anObject.</body><body package="GlorpCore">privateRegisterAsOld: anObject 	"Register the object as something we already read from the database, skipping the isNew: test. Private! Normally you would just use register:"	| realObject |	currentUnitOfWork isNil ifTrue: [^self].	realObject := self realObjectFor: anObject ifNone: [^self].	currentUnitOfWork register: realObject</body><body package="GlorpCore">realObjectFor: anObject 	"If this is a proxy, return the contents (if available). Otherwise, return nil"	^self realObjectFor: anObject ifNone: [nil].</body><body package="GlorpCore">realObjectFor: anObject ifNone: aBlock	"If this is a proxy, return the contents (if available). Otherwise, evalute the block"	^anObject isGlorpProxy 		ifTrue: [anObject isInstantiated ifTrue: [anObject getValue] ifFalse: [aBlock value]]		ifFalse: [anObject]</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>caching</category><body package="GlorpCore">cacheAt: aKey  forClass: aClass ifNone: failureBlock	^cache lookupClass: aClass key: aKey ifAbsent: failureBlock.</body><body package="GlorpCore">cacheAt: keyObject put: valueObject 	^cache at: keyObject insert: valueObject</body><body package="GlorpCore">cacheContainsObject: anObject	| descriptor key |	(descriptor := self descriptorFor: anObject) isNil ifTrue: [^false].	(key := descriptor primaryKeyFor: anObject) isNil ifTrue: [^false].	^[self cacheContainsObject: anObject key: key] on: DuplicatePrimaryKeyException do: [:ex | false]</body><body package="GlorpCore">cacheContainsObject: anObject key: aKey 	"Just test containment, don't return the result or trigger anything due to expiration"	aKey isNil ifTrue: [^false].	^cache		containsObject: anObject		key: aKey.</body><body package="GlorpCore">cacheContainsObjectForClass: aClass key: aKey 	"Just test containment, don't return the result or trigger anything due to expiration"	aKey isNil ifTrue: [^false].	^cache		containsObjectForClass: aClass		key: aKey.</body><body package="GlorpCore">cacheContainsObjectForRow: aDatabaseRow	^self 		cacheContainsObjectForClass: aDatabaseRow owner class		key: aDatabaseRow primaryKey</body><body package="GlorpCore">cacheLookupForClass: aClass key: aKey 	^self 		cacheAt: aKey		forClass: aClass		ifNone: [nil]</body><body package="GlorpCore">cacheLookupObjectForRow: aDatabaseRow	^self 		cacheLookupForClass: aDatabaseRow owner class		key: aDatabaseRow primaryKey</body><body package="GlorpCore">cacheRemoveObject: anObject	| key |	key := (self descriptorFor: anObject) primaryKeyFor: anObject.	cache removeClass: anObject class key: key ifAbsent: [].</body><body package="GlorpCore">hasExpired: aClass key: key	^cache hasExpired: aClass key: key.</body><body package="GlorpCore">hasObjectExpiredOfClass: aClass withKey: key	^cache hasObjectExpiredOfClass: aClass withKey: key.</body><body package="GlorpCore">isRegistered: anObject	currentUnitOfWork isNil ifTrue: [^false].	^currentUnitOfWork isRegistered: anObject.</body><body package="GlorpCore">lookupRootClassFor: aClass	| descriptor |	descriptor := self system descriptorFor: aClass.	^descriptor notNil			ifTrue: [ descriptor typeMappingRootDescriptor describedClass ]			ifFalse: [ aClass ]</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>accessing</category><body package="GlorpCore">accessor	^accessor</body><body package="GlorpCore">accessor: aDatabaseAccessor 	accessor := aDatabaseAccessor.	system isNil ifFalse: [system platform: (accessor platform)].</body><body package="GlorpCore">addToReaper: aProxy	aProxy class == TimedProxy ifFalse: [^self].	self reaper add: aProxy.</body><body package="GlorpCore">applicationData	^applicationData</body><body package="GlorpCore">applicationData: anObject		applicationData := anObject</body><body package="GlorpCore">cacheFor: anObject	^cache cacheFor: anObject.</body><body package="GlorpCore">cacheForClass: aClass	^cache cacheForClass: aClass.</body><body package="GlorpCore">currentLogin	^accessor currentLogin</body><body package="GlorpCore">currentServerUTCTimestampOrNil	"This is kind of ugly, but it is Smalltalk Dialect neutral"	| sqlString result |	sqlString := [self platform sqlTextCurrentServerUTCTimestamp]		on: Dialect error		do:  [:exception | exception return: nil].	sqlString == nil ifTrue: [^nil].	result := [self accessor executeSQLString: sqlString]		on: Dialect error		do:  [:exception | exception return: nil].	^result == nil		ifTrue: [nil]		ifFalse: 			[(result first isEmpty or: [(result first first isKindOf: Dialect timestampClass) not])				ifTrue: [nil]				ifFalse: [result first first]]</body><body package="GlorpMappings">databaseTableClass	^system databaseTableClass</body><body package="GlorpCore">errorAction	^errorAction</body><body package="GlorpCore">errorAction: aThreeArgumentBlockExceptionSessionCommand	errorAction := aThreeArgumentBlockExceptionSessionCommand.</body><body package="GlorpCore">modificationTracker	"If we killed off the tracker due to a session reset, then bring it back again."	modificationTracker == #needed ifTrue: [self useModificationTracker].	^modificationTracker</body><body package="GlorpCore">modificationTracker: aGlorpModificationTrackingPolicy	modificationTracker := aGlorpModificationTrackingPolicy</body><body package="GlorpCore">platform	^self system platform.</body><body package="GlorpCore">reaper	reaper isNil ifTrue: [self initializeReaper].	^reaper.</body><body package="GlorpCore">reusePreparedStatements: aBoolean	accessor reusePreparedStatements: aBoolean.</body><body package="GlorpCore">schema	^ self accessor schema</body><body package="GlorpCore">system	^system</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>api/transactions</category><body package="GlorpCore">beginTransaction	"Start a database transaction, to be in sole control of when and whether data is saved to the database."	accessor beginTransaction.</body><body package="GlorpCore">beginUnitOfWork	"Start a UnitOfWork, to organize your updates."	self hasUnitOfWork ifTrue: [self error: 'Cannot nest units of work yet'].	currentUnitOfWork := UnitOfWork new.	currentUnitOfWork session: self.</body><body package="GlorpCore">commitTransaction	"Commit the current database connection transaction."	accessor commitTransaction.</body><body package="GlorpCore">commitUnitOfWork	"Send updates to the database, in an already-existing Transaction if present, otherwise in a newly-created one. A newly-created Transaction is committed.  An existing Transaction is left for the surrounding code (i.e. that created it) to commit or rollback."	[self isInTransaction		ifTrue: [currentUnitOfWork commit]		ifFalse: [self inTransactionDo: [currentUnitOfWork commit]]] 	ifCurtailed: [self rollbackUnitOfWork].	currentUnitOfWork := nil.</body><body package="GlorpCore">commitUnitOfWorkAndContinue	"Commit the current unit of work, but then keep going with the same set of registered objects, with their state updated to reflect current values."	| registeredObjects |		currentUnitOfWork isNil ifTrue: [^self error: 'Not in unit of work'].	registeredObjects := currentUnitOfWork registeredObjects.	currentUnitOfWork deletedObjects do: [:each | registeredObjects remove: each].	self commitUnitOfWork.	self beginUnitOfWork.	self registerAll: registeredObjects.</body><body package="GlorpCore">doDDLOperation: aBlock	"Execute DDL SQL - something which creates/drops/modifies tables or other schema information. The main reason for this method is that some databases require a transaction, while others don't require it, and still others don't allow it. Try to do the right thing."		^self accessor doDDLOperation: aBlock.</body><body package="GlorpCore">hasUnitOfWork	^currentUnitOfWork notNil.</body><body package="GlorpCore">inTransactionDo: aBlock	"Execute aBlock in a database transaction. If one is already in progress, evaluate aBlock and return. If not, start a transaction, evaluate aBlock and commit or rollback the transaction before returning."	^self accessor inTransactionDo: aBlock</body><body package="GlorpCore">inUnitOfWorkDo: aBlock	"Evaluate aBlock within a UnitOfWork. This method will only commit or rollback a unit of work that it creates. If there is an ongoing unit of work, the sender must commit or rollback. Likewise, if there is an ongoing transaction, the sender must commit or rollback the transaction. See the class comment for more details."	| result myUnitOfWork |	[myUnitOfWork := self hasUnitOfWork not.	myUnitOfWork ifTrue: [self beginUnitOfWork].	result := aBlock numArgs = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value].	myUnitOfWork ifTrue: [self commitUnitOfWork]]		ifCurtailed:			[myUnitOfWork ifTrue: [self rollbackUnitOfWork]].	^result</body><body package="GlorpCore">isInTransaction	^accessor isInTransaction.</body><body package="GlorpCore">modify: anObject in: aBlock	"Evaluate aBlock inside a unit of work. Start a database transaction at the beginning and commit it at the end. If we don't terminate normally, roll everything back. Register anObject before starting. Explicitly circumvent the registration of  the block result at the end, because that can cause problems if we're doing things like delete and re-insert and end up returning e.g. the deleted object"	| result |	self transact: [		self register: anObject.		result := aBlock value.		nil].	^result.</body><body package="GlorpCore">requireUnitOfWork	"Start a unit of work if there isn't one already."	self hasUnitOfWork ifFalse: [self beginUnitOfWork].</body><body package="GlorpCore">rollbackTransaction	"Rollback the current database connection transaction."	accessor execute: [accessor rollbackTransaction].</body><body package="GlorpCore">rollbackUnitOfWork	currentUnitOfWork isNil ifTrue: [^self].	currentUnitOfWork abort.	currentUnitOfWork := nil.</body><body package="GlorpCore">rollbackUnitOfWorkAndContinue	"Rollback the current unit of work, but then keep going with the same set of existing objects (but not new ones) as were registered, with their state reverted to their at-registration state.  (If a user wants the newObjects, they can get them before sending #rollbackAndContinue, and then #registerAsNew: them after doing so.  That is their decision.)"	| registeredObjects |		currentUnitOfWork isNil ifTrue: [^self error: 'Not in unit of work'].	registeredObjects := currentUnitOfWork registeredObjects.	currentUnitOfWork newObjects do: [:each | registeredObjects remove: each].	self rollbackUnitOfWork.	self beginUnitOfWork.	self registerAll: registeredObjects.</body><body package="GlorpCore">rollbackUnitOfWorkFor: anObject	currentUnitOfWork abort: anObject</body><body package="GlorpCore">save: anObject 	"Make sure anObject will be written to the database by starting a unit of work if we aren't already in one, and registering the object. This is in most ways the same as just registering an object, but it tells us to disregard whether/how the object has changed and to save all of its fields. This is useful if we need to register an object *after* changes have occurred, and can be used to implement something more like an object by object save facility. Still somewhat experimental."	| realObject |	realObject := self realObjectFor: anObject ifNone: [^self].	self hasUnitOfWork		ifTrue: [currentUnitOfWork registerAsNew: realObject]		ifFalse: [self inUnitOfWorkDo:				[currentUnitOfWork registerAsNew: realObject]].</body><body package="GlorpCore">transact: aBlock	"Evaluate aBlock inside a transaction and inside a unit of work. This could be called inUnitOfWorkInsideTransactionDo: (but that's too verbose) because we start both a transaction and/or a unit of work if we are not in either or both already.  We commit or rollback only what we started. Otherwise, the sender controls commit/rollback. (Comparing this method with #inUnitOfWorkDo:, in the latter, if there is not already an ongoing transaction a transaction will not get started until the UnitOfWork commits.)"	| alreadyInTransaction alreadyInUnitOfWork result |	[[alreadyInUnitOfWork := false.	alreadyInTransaction := self isInTransaction.	alreadyInTransaction ifFalse: [self beginTransaction].	alreadyInUnitOfWork := self hasUnitOfWork.	alreadyInUnitOfWork ifFalse: [self beginUnitOfWork].	result := aBlock numArgs = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value].	self register: result.	alreadyInUnitOfWork ifFalse: [self commitUnitOfWork].	alreadyInTransaction ifFalse: [self commitTransaction]]		ifCurtailed: [alreadyInUnitOfWork ifFalse: [self rollbackUnitOfWork]]]			ifCurtailed: [alreadyInTransaction ifFalse: [self rollbackTransaction]].	^result</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>api/queries</category><body package="GlorpCore">count: aClass	^self execute: (SimpleQuery count: aClass).</body><body package="GlorpCore">count: aClass where: anExpression	^self execute: (SimpleQuery count: aClass where: anExpression).</body><body package="GlorpCore">delete: anObject	| realObject |	"Get the real object, instantiating if necessary"	realObject := anObject glorpRealObject.	self hasUnitOfWork		ifTrue: [currentUnitOfWork delete: realObject]		ifFalse:			[self inUnitOfWorkDo: [				currentUnitOfWork delete: realObject]].</body><body package="GlorpCore">delete: aClass where: aBlock	"Delete all instances in the database satisfying the query block."		"DELETE THEM FROM THE CACHE AS WELL, OR ELSE HAVE VERY LARGE WARNING THAT YOU'RE NOT GOING TO"	| q |	q := Query readOneOf: aClass where: aBlock.	^self deleteAllSatisfying: q.</body><body package="GlorpCore">deleteAll: aCollection 	aCollection do: [:each | self delete: each].</body><body package="GlorpCore">deleteAllSatisfying: aQuery	^aQuery deleteWithParameters: #() in: self.</body><body package="GlorpCore">execute: aQuery	^aQuery executeWithParameters: #() in: self.</body><body package="GlorpCore">hasExpired: anObject 	^cache hasExpired: anObject.</body><body package="GlorpCore">read: aClass	"Return an array of instances of aClass, each one from a row of its corresponding database table."	^self execute: (SimpleQuery read: aClass)</body><body package="GlorpCore">read: aClass limit: anInteger	"Return an array of not more than anInteger of instances of aClass, each one from a row of its corresponding database table."	^self execute: (SimpleQuery read: aClass limit: anInteger)</body><body package="GlorpCore">read: aClass orderBy: aCriteria	"aCriteria can be a block, such as [:each | each id], or a symbol (that Glorp can translate into such a block), such as #id."	| query |	query := SimpleQuery read: aClass.	query orderBy: aCriteria.	^self execute: query</body><body package="GlorpCore">read: aClass where: aBlock	"aBlock should return a boolean, for example, [:each | each lastname = 'Doe']."	^self execute: (SimpleQuery read: aClass where: aBlock)</body><body package="GlorpCore">read: aClass where: aBlock limit: anInteger	"Return an array of up to anInteger instances of aClass for which aBlock returns true, each from a row from its table."	^self execute:		(SimpleQuery			read: aClass			where: aBlock			limit: anInteger)</body><body package="GlorpCore">readManyOf: aClass	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:).	^self read: aClass</body><body package="GlorpCore">readManyOf: aClass limit: anInteger	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:).	^self read: aClass limit: anInteger</body><body package="GlorpCore">readManyOf: aClass orderBy: aCriteria	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:orderBy:).	^self read: aClass orderBy: aCriteria</body><body package="GlorpCore">readManyOf: aClass where: aBlock	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:).	^self read: aClass where: aBlock</body><body package="GlorpCore">readManyOf: aClass where: aBlock limit: anInteger	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:limit:).	^self read: aClass where: aBlock limit: anInteger</body><body package="GlorpCore">readOneOf: aClass	"Return a single instance of aClass from a row of its table."	^self execute: (SimpleQuery readOneOf: aClass)</body><body package="GlorpCore">readOneOf: aClass where: aBlock	"aBlock should return a boolean, for example, [:each | each title='Report']."	^self execute: (SimpleQuery readOneOf: aClass where: aBlock)</body><body package="GlorpCore">refresh: anObject	"Reload anObject from the corresponding row of its table. Return the refreshed instance."	| exp query realObject descriptor |	realObject := self realObjectFor: anObject ifNone: [^self].	descriptor := self descriptorFor: realObject.	descriptor isNil		ifTrue: [self error: 'Cannot refresh an object with no descriptor'].	exp := descriptor				primaryKeyExpressionFor: realObject				basedOn: (BaseExpression new  descriptor: (self descriptorFor: realObject class))				relation: #=.	query := Query readOneOf: realObject class where: exp.	query shouldRefresh: true.	^self execute: query</body><body package="GlorpCore">undelete: anObject	self undelete: anObject ifNotDeleted: [self error: 'Trying to undelete something that was not deleted'].</body><body package="GlorpCore">undelete: anObject ifNotDeleted: aBlock	| realObject |	"Get the real object, instantiating if necessary"	realObject := anObject glorpRealObject.	self hasUnitOfWork		ifTrue: [currentUnitOfWork undelete: realObject ifNotDeleted: aBlock]		ifFalse:			[self error: 'Can only undelete while the unit of work is in progress'].</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>copying</category><body package="GlorpCore">copy	^self shallowCopy postCopy.</body><body package="GlorpCore">postCopy	super postCopy.	self initializeCache.	currentUnitOfWork := nil.	accessor := accessor copy.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>api</category><body package="GlorpCore">descriptorFor: aClassOrInstance	"If the parameter is a class that my DescriptorSystem includes, but its descriptor doesn't exist yet, an initial descriptor for it will be created.  If my DescriptorSystem has neither descriptor nor class, I return nil."	^system descriptorFor: aClassOrInstance</body><body package="GlorpCore">forceSaveOf: anObject 	"This is the same as registering an object, but it tells us to disregard whether/how the object has changed and to save all of its fields. This is useful if we need to register an object after changes have occurred, and can be used to implement something more like an object by object save facility. Still somewhat experimental."	| realObject |	realObject := self realObjectFor: anObject ifNone: [^self].		self inUnitOfWorkDo: [currentUnitOfWork registerAsNew: realObject].</body><body package="GlorpCore">hasDescriptorFor: aClass	"This returns false only if my DescriptorSystem has neither the requested descriptor nor the requesting class.  (If the parameter is a class that my DescriptorSystem includes, but its descriptor doesn't exist yet, an initial descriptor for it will be created and true returned.)"	^system hasDescriptorFor: aClass</body><body package="GlorpCore">register: anObject	"Register the object with our current unit of work. We need to do this *before* making changes to the object.  (If an object is read from the database, changed and then registered, and later written back to the database, the pre-registration change may be lost.)"	| realObject |	currentUnitOfWork isNil ifTrue: [^self].	realObject := self realObjectFor: anObject ifNone: [^self].	(self isNew: realObject) 		ifTrue: [currentUnitOfWork registerAsNew: realObject]		ifFalse: [currentUnitOfWork register: realObject].</body><body package="GlorpCore">registerAll: aCollection	aCollection do: [:ea | self register: ea].</body><body package="GlorpCore">registerForDelete: anObject 	"Register the object with our current unit of work, with intent to delete it."	| realObject |	currentUnitOfWork isNil ifTrue: [^self].	realObject := self realObjectFor: anObject ifNone: [^self].	currentUnitOfWork registerForDelete: realObject.</body><body package="GlorpCore">system: aDescriptorSystem	aDescriptorSystem session: self.	accessor isNil ifFalse: [aDescriptorSystem platform: accessor currentLogin database].	system := aDescriptorSystem.	system validateDescriptorSystem		ifTrue: [system validate]		ifFalse: [system initializeRuntimeMappings].</body><body package="GlorpCore">useSystem: newSystem while: aBlock	"We may modify the descriptor system in the block to achieve some end.  Just in case this instance is used elsewhere, use a copy and restore after."	| oldSystem |	oldSystem := system.	system := newSystem.	^aBlock ensure: [system := oldSystem]</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>internal/writing</category><body package="GlorpCore">commandForRow: aDatabaseRow	(aDatabaseRow forDeletion) ifTrue: [^DeleteCommand forRow: aDatabaseRow useBinding: self useBinding session: self].	^(self shouldInsert: aDatabaseRow)		ifTrue: [InsertCommand forRow: aDatabaseRow useBinding: self useBinding session: self]		ifFalse: [self platform				updateCommandForRow: aDatabaseRow				binding: self useBinding				session: self]</body><body package="GlorpCore">createDeleteRowsFor: anObject in: rowMap	"Create records for rows that require deletion"	(self descriptorFor: anObject) createDeleteRowsFor: anObject in: rowMap.</body><body package="GlorpCore">createRowsFor: anObject in: rowMap	| descriptor |	(descriptor := self descriptorFor: anObject class) isNil		ifFalse: [descriptor createRowsFor: anObject in: rowMap].</body><body package="GlorpCore">shouldInsert: aDatabaseRow	"We may have forced this to explicitly be an update"	| isMappedObjectRow |	(currentUnitOfWork notNil and: [currentUnitOfWork forcesUpdateFor: aDatabaseRow]) ifTrue: [^false].	"If this is for a mapped object, so not a link table, then we are an insert if there is no corresponding row in the cache that we read from the database, and an update if there is such a row." 	isMappedObjectRow := (RowMap new isRowMapKey: aDatabaseRow owner) not.	isMappedObjectRow ifTrue: [		^(self cacheContainsObjectForRow: aDatabaseRow) not].	"This is a link table row. If the relationship existed before registration, then this will have an old version and we should update it. If there's no old version, then it's an insert."	^aDatabaseRow hasOldVersion not</body><body package="GlorpCore">tablesInCommitOrder	^system tablesInCommitOrder.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>events</category><body package="GlorpCore">sendPostFetchEventTo: anObject	^anObject glorpPostFetch: self.</body><body package="GlorpCore">sendPostFetchValidateEventTo: anObject	^anObject glorpPostFetchValidate: self.</body><body package="GlorpCore">sendPostWriteEventTo: anObject	anObject glorpPostWrite: self.</body><body package="GlorpCore">sendPreWriteEventTo: anObject	anObject glorpPreWrite: self.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>virtual collections</category><body package="GlorpCore">virtualCollectionOf: aClass	^GlorpVirtualCollection on: aClass in: self.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>initialize</category><body package="GlorpCore">dontUseModificationTracker	modificationTracker release.	modificationTracker := nil.</body><body package="GlorpCore">initialize		self initializeCache.</body><body package="GlorpCore">initializeCache	cache release.	cache := CacheManager forSession: self.</body><body package="GlorpCore">initializeReaper	self releaseReaper.	reaper := TimedProxyReaper new.</body><body package="GlorpCore">releaseReaper	reaper release.</body><body package="GlorpCore">reset	self initializeCache.	self releaseReaper.	accessor reset.	currentUnitOfWork := nil.	modificationTracker release.	modificationTracker isNil ifFalse: [modificationTracker := #needed].</body><body package="GlorpCore">resetPermissions	accessor isNil ifFalse: [accessor resetPermissions].</body><body package="GlorpCore">shouldUseModificationTracker: aBoolean	aBoolean		ifTrue: [modificationTracker isNil ifTrue: [self useModificationTracker]]		ifFalse: [modificationTracker := nil].</body><body package="GlorpCore">useModificationTracker	Dialect isVisualWorks ifFalse: [^self].	modificationTracker := (Smalltalk		at: #'Glorp.GlorpVWWriteBarrierTracker'		ifAbsent: [^self]) new.	modificationTracker session: self.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>testing</category><body package="GlorpCore">isNew: anObject 	"When registering, do we need to add this object to the collection of new objects? New objects are treated specially when computing what needs to be written, since we don't have their previous state.  (The parameter cannot be a proxy - use #isNewObjectOrInstantiatedProxy: if it legitimately could be.)"	| key descriptor |	(currentUnitOfWork notNil and: [currentUnitOfWork isRegistered: anObject]) ifTrue: [^false].	descriptor := self descriptorFor: anObject.	descriptor isNil ifTrue: [^false].	"For embedded values we assume that they are not new. This appears to work. I can't really justify it."	self needsWork: 'cross your fingers'.	descriptor mapsPrimaryKeys ifFalse: [^false].	key := descriptor primaryKeyFor: anObject.	key isNil ifTrue: [^true].	"If the cache contains the object, but the existing entry is due to be deleted, then count this entry as a new one being added with the same primary key (ick) as the old one"	^[(self cacheContainsObject: anObject key: key) not]		on: DuplicatePrimaryKeyException		do: [:ex |			(currentUnitOfWork notNil and: [currentUnitOfWork willDelete: ex existingObject]) 				ifTrue:					[self cacheRemoveObject: ex existingObject.					ex return: true]				ifFalse: [ex pass]].</body><body package="GlorpCore">isNewObjectOrInstantiatedProxy: anObjectOrProxy	"Is anObjectOrProxy a new object or an instantiated proxy holding a new object?  Use #isNew:, not this method, when the caller's usage pattern already ensures the parameter cannot be a proxy;  this is merely a convenience method for when that is not so.  (Any caller can instead call	session isNew: someObject yourSelfif they do not care about the ifNone: case.)"	^self isNew: (self realObjectFor: anObjectOrProxy ifNone: [^false])</body><body package="GlorpCore">isUninstantiatedProxy: anObject	^anObject isGlorpProxy and: [anObject isInstantiated not].</body><body package="GlorpCore">reusePreparedStatements	^accessor reusePreparedStatements</body><body package="GlorpCore">useBinding	self accessor isNil ifTrue: [^false].	^self accessor useBinding.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>read/write</category><body package="GlorpCore">commandForHomogeneousRows: aCollectionOfDatabaseRows	"Create the command for this set of rows. These are assumed to be homogeneous (i.e. they are all for the same table) and all the same type of operation (i.e. all insert or all update).  This is called when we know we have more than one row;  we may be able to send them to the database as a group (only insert commands at present).  We choose the insert command that knows how to write that group."	| aDatabaseRow |	aDatabaseRow := aCollectionOfDatabaseRows first.	"Just a representativeRow"	aDatabaseRow forDeletion ifTrue: [self error: 'invalid way of handling deletes (this should never happen)'].	^(self shouldInsert: aDatabaseRow)		ifFalse: [self platform updateCommandForRows: aCollectionOfDatabaseRows binding: self useBinding session: self]		ifTrue: [self platform insertCommandForRows: aCollectionOfDatabaseRows binding: self useBinding session: self]"My binding boolean is obtained from the accessor's platform's binding value whereas the session's platform is derived from the system's;  later, review whether and when these differ."</body><body package="GlorpCore">filterDeletionFrom: anObject	self hasUnitOfWork ifFalse: [^anObject].	currentUnitOfWork shouldFilterDeletions ifFalse: [^anObject].	(currentUnitOfWork willDelete: anObject)		ifTrue: [^nil].	^anObject.</body><body package="GlorpCore">groupWrite: aCollectionOfDatabaseRows	| command |	aCollectionOfDatabaseRows isEmpty ifTrue: [^true].	aCollectionOfDatabaseRows first shouldBeWritten ifFalse: [^true].	aCollectionOfDatabaseRows do: [:each | each preWriteAssignSequencesUsing: self].	command := self commandForHomogeneousRows: aCollectionOfDatabaseRows.	accessor executeCommand: command.	^command succeeded or:		[GlorpWriteFailure new			command: command;			object: (aCollectionOfDatabaseRows collect: [:each | each owner]);			signal]</body><body package="GlorpCore">writeHomogeneousRows: aCollectionOfDatabaseRows	"Write out a collection of rows belonging to a single table.  We could call groupWrite: even when the collection has only a single row.  Calling writeRow: sets 'row' but not 'allRows' in the RowBasedCommand, making it easier for the accessor to see that it need not check the platform's group-writing ability/preferences.  (However, this could be pushed down to RowBasedCommand command creation protocol.)"	^aCollectionOfDatabaseRows size = 1		ifTrue: [self writeRow: aCollectionOfDatabaseRows first]		ifFalse: [self groupWrite: aCollectionOfDatabaseRows]</body><body package="GlorpCore">writeRow: aDatabaseRow	| command |	aDatabaseRow shouldBeWritten ifFalse: [^true].	aDatabaseRow preWriteAssignSequencesUsing: self.	command := self commandForRow: aDatabaseRow.	accessor executeCommand: command.	^command succeeded or:		[GlorpWriteFailure new			command: command;			object: (Array with: aDatabaseRow owner);			signal]</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>login</category><body package="GlorpCore">isLoggedIn	^accessor isLoggedIn.</body><body package="GlorpCore">login	self isLoggedIn ifTrue: [^nil].	^self loginIfError: [:ex | ex pass]</body><body package="GlorpCore">loginIfError: aBlock	| result |	result := self accessor loginIfError: aBlock.	system platform characterEncoding: accessor encoding.	^result.</body><body package="GlorpCore">logout	^self accessor logout.</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>table creation</category><body package="GlorpCore">createTables	"Create the tables for our descriptor system. This will fail if the tables already exist. Use recreateTables for that."	self createTables: system allTables.</body><body package="GlorpCore">createTables: aCollection	"Create the tables for our descriptor system. This will fail if the tables already exist. Use recreateTables for that."	| sequences |	system platform areSequencesExplicitlyCreated		ifTrue:			[sequences := self system allSequencesFor: aCollection.			sequences do: [:each | accessor createSequence: each ifError: [:ex | self halt]]].	aCollection do: [:each | accessor createTable: each ifError: [:ex | self halt]].	aCollection do: [:each | accessor createTableIndexes: each ifError: [:ex | self halt]].	self platform supportsConstraints ifTrue: [aCollection do: [:each | accessor createTableFKConstraints: each ifError: [:ex | self halt]]].</body><body package="GlorpCore">dropTables	"Drop the tables for our descriptor system, and their associated sequences."	self dropTables: system allTables.</body><body package="GlorpCore">dropTables: aCollection	"Drop the tables for our descriptor system, and their associated sequences."	| sequences |	accessor dropTables: ((TableSorter for: aCollection) sort reverse).	system platform areSequencesExplicitlyCreated ifTrue: [		sequences := system allSequencesFor: aCollection.		accessor dropSequences: sequences].</body><body package="GlorpCore">migrateFromSystem: from toSystem: to	| fromTables toTables toDelete toAdd toModify newVersion |	fromTables := from allTables copy.	toTables := to allTables copy.	toDelete := fromTables reject: [:each | 		toTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toAdd := toTables reject: [:each | 		fromTables anySatisfy: [:otherTable | otherTable sqlString sameAs: each sqlString]].	toModify := fromTables reject: [:each | (toDelete includes: each) or: [toAdd includes: each]].	self doDDLOperation: [		self createTables: toAdd.		self dropTables: toDelete.		toModify do: [:each | 			newVersion := to tableNamed: each sqlString.			self updateTableFrom: each to: newVersion]].</body><body package="GlorpCore">migrateFromVersion: fromVersionNumber toVersion: toVersionNumber 	self halt.	"Get the class name of our system, strip off version number, replace with to and from, create systems for them."</body><body package="GlorpCore">recreateTables	"Drop and re-create the tables for our descriptor system, and their associated sequences."	self recreateTables: system allTables.</body><body package="GlorpCore">recreateTables: aCollection	"Drop the tables for our descriptor system, and their associated sequences."	| sequences |	accessor dropTables: (TableSorter for: aCollection) sort reverse.	system platform areSequencesExplicitlyCreated		ifTrue:			[			sequences := self system allSequencesFor: aCollection.			accessor dropSequences: sequences.			sequences				do: [:each | accessor createSequence: each ifError: [:ex | self halt]]].	aCollection do: [:each | accessor createTable: each ifError: [:ex | self halt]].	aCollection do: [:each | accessor createTableIndexes: each ifError: [:ex | self halt]].	self platform supportsConstraints ifTrue: [aCollection do: [:each | accessor createTableFKConstraints: each ifError: [:ex | self halt]]].</body><body package="GlorpCore">recreateTables: aCollection ifError: aBlock	"Drop the tables for our descriptor system, and their associated sequences."	(TableSorter for: aCollection) sort reverse		do: [ :table | accessor dropTable: table ifError: [ :ex | ex "so we can insert a breakpoint"] ].	system platform areSequencesExplicitlyCreated		ifTrue: [(self system allSequencesFor: aCollection)					do: [:each | 						accessor dropSequence: each ifAbsent: [:ex | ex "so we can insert a breakpoint" ].						accessor createSequence: each ifError: [:ex | ^aBlock value: ex ]]].	aCollection do: [:each | accessor createTable: each ifError: [:ex | ^aBlock value: ex]].	aCollection do: [:each | accessor createTableIndexes: each ifError: [:ex | ^aBlock value: ex ]].	self platform supportsConstraints ifTrue: [aCollection do: [:each | accessor createTableFKConstraints: each ifError: [:ex | ^aBlock value: ex]]].</body><body package="GlorpCore">recreateTablesIfError: aBlock	"Drop and re-create the tables for our descriptor system, and their associated sequences."	self recreateTables: system allTables ifError: aBlock .</body><body package="GlorpCore">updateTableFrom: aTable to: newTable	"Update the given table based on the metadata."		| newFields deletedFields modifiedFields newFKConstraints deletedFKConstraints newUniqueConstraints deletedUniqueConstraints |	newFKConstraints := newTable foreignKeyConstraints reject: 		[:each | aTable hasForeignKeyConstraintMatching: each].	deletedFKConstraints := aTable foreignKeyConstraints reject: 		[:each | newTable hasForeignKeyConstraintMatching: each].	newUniqueConstraints := newTable uniqueConstraints reject: 		[:each | aTable hasUniqueConstraintMatching: each].	deletedUniqueConstraints := aTable uniqueConstraints reject: 		[:each | newTable hasUniqueConstraintMatching: each].	"So far, we just handle adding and deleting fields, not changing them."	newFields := newTable fields reject: 		[:each | aTable hasFieldNamed: each name].	deletedFields := aTable fields reject: 		[:each | newTable hasFieldNamed: each name].	modifiedFields := newTable fields reject: 		[:each | newFields includes: each].	modifiedFields := modifiedFields reject: 		[:each | (aTable fieldNamed: each name) isTheSameAs: each].		"Cheap version, for modified fields, drop and re-add them."	newFields addAll: modifiedFields.	deletedFields addAll: modifiedFields.	deletedFKConstraints do: [:each | accessor dropConstraint: each].	deletedUniqueConstraints do: [:each | accessor dropConstraint: each].	accessor dropFields: deletedFields.	accessor addFields: newFields.	newFKConstraints do: [:each | accessor addConstraint: each].	newUniqueConstraints do: [:each | accessor addConstraint: each]</body></methods><methods><class-id>Glorp.GlorpSession</class-id> <category>synonyms</category><body package="GlorpCore">rollbackAndContinue	"A shorter synonym"	^self rollbackUnitOfWorkAndContinue</body><body package="GlorpCore">saveAndContinue	"A shorter synonym"	^self commitUnitOfWorkAndContinue</body></methods><methods><class-id>Glorp.GlorpSession class</class-id> <category>instance creation</category><body package="GlorpCore">forSystem: aSystem 	^self new system: aSystem</body><body package="GlorpCore">new	^super new initialize.</body></methods><methods><class-id>Glorp.Join</class-id> <category>preparing</category><body package="GlorpExpressions">additionalExpressions	^#()</body><body package="GlorpExpressions">additionalExpressionsIn: aQuery 	^#()</body><body package="GlorpExpressions">addToTargetFields: aCollection	"If we can provide target fields, add them to the collection"	aCollection addAll: targets.</body><body package="GlorpExpressions">allTablesToPrint	^targets inject: Set new into: [:sum :each | 		sum add: each table. sum].</body><body package="GlorpUnitOfWork">condenseBooleanEquality	^self.</body><body package="GlorpUnitOfWork">condenseBooleanEqualityExpressions	^self.</body><body package="GlorpExpressions">onlyJoinParts	"Strip out any generic parts, leaving only the things that are actually joins"		^self.</body><body package="GlorpExpressions">prepareIn: aQuery	"The whereClause is a Join.  Convert it to an expression and prepare that expression.  (The assumption is that this implementor is only ever reached by #prepareIn: being sent to a 'whereClause' that contains a join)."	aQuery whereClause: self asGeneralGlorpExpression.	aQuery whereClause prepareIn: aQuery."Is it always the case that after calling the above,	aQuery shouldExpressionBeJoin: aQuery whereClause.will inevitably return true?  If so, should the above instead be	aQuery addJoin: self asGeneralGlorpExpression.so that platforms that only support ANSI outer joins will handle it correctly."</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	^self asGlorpExpressionOn: aBaseExpression.</body><body package="GlorpExpressions">removeNonJoinParts	"Remove anything that's not an actual join. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to use the general ones, because they're not field level."	^self.</body><body package="GlorpExpressions">replaceJoinsWithInverse	"Replace any actual Join objects we have with their inverse. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to mess with the general ones, because they're not field-level. As actual joins, we ignore this, because it will be done at the parent level"	^self.</body><body package="GlorpUnitOfWork">rewriteEquality	^self.</body><body package="GlorpExpressions">sourceForTarget: aField ifNone: aBlock	| index |	index := targets indexOf: aField.	index = 0 ifTrue: [^aBlock value].	^sources at: index</body><body package="GlorpExpressions">targetForSource: aField	| index |	index := sources indexOf: aField.	index = 0 ifTrue: [^nil].	^targets at: index.</body><body package="GlorpExpressions">targetForSource: aField value: aBlock	"Only evaluate the block if this join includes the source field.  My polymorph in VariableJoin relies on the value of the block being the target value of the join's mapping."	| index |	index := sources indexOf: aField.	index = 0 ifTrue: [^nil].	aBlock value.	^targets at: index</body></methods><methods><class-id>Glorp.Join</class-id> <category>accessing</category><body package="GlorpExpressions">allControlledTables	^self allTables.</body><body package="GlorpExpressions">allSourceFields	^sources</body><body package="GlorpExpressions">allTables	^(targets collect: [:each | each table]) asSet.</body><body package="GlorpExpressions">allTargetFields	^targets</body><body package="GlorpExpressions">base	^base.</body><body package="GlorpExpressions">base: aBaseExpression	base := aBaseExpression.</body><body package="GlorpExpressions">from: aField to: anotherField	^self addSource: aField target: anotherField.</body><body package="GlorpExpressions">hasDescriptor	^false.</body><body package="GlorpExpressions">numberOfParameters	^sources size</body><body package="GlorpExpressions">outerJoin: aBoolean	outerJoin := aBoolean.</body><body package="GlorpExpressions">queryLevelBaseExpression	^self ultimateBaseExpression.</body><body package="GlorpExpressions">targetKeys	^targets.</body><body package="GlorpExpressions">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.Join</class-id> <category>printing</category><body package="GlorpExpressions">printOn: aStream	sources with: targets do: [:source :target |		aStream nextPut: $(.		source printSQLOn: aStream withParameters: #().		aStream nextPutAll: ' = '.		target printSQLOn: aStream withParameters: #().		aStream nextPutAll: ') ']</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary 	1 to: sources size		do: 			[:i | 			| eachTarget eachSource sourceValue |			eachTarget := targets at: i.			eachSource := sources at: i.			eachTarget printSQLOn: aStream withParameters: aDictionary.			sourceValue := (self isConstant: eachSource) ifTrue: [eachSource value] ifFalse: [aDictionary at: eachSource].			sourceValue isNil 				ifTrue: [aStream nextPutAll: ' IS NULL ']				ifFalse: 					[aStream nextPutAll: ' = '.					sourceValue printOn: aStream].			i = targets size ifFalse: [aStream nextPutAll: ' AND ']]</body></methods><methods><class-id>Glorp.Join</class-id> <category>api</category><body package="GlorpQueries">addSource: aField target: anotherField 	| sourceValue targetValue |	sourceValue := (self isConstant: aField) 		ifTrue: [ConstantExpression for: aField]		ifFalse: [aField].	sources add: sourceValue.	targetValue := anotherField class == SimpleQuery		ifTrue: [anotherField asGlorpExpressionOn: base] 		ifFalse: [anotherField].	"isConstant: returns true to a block so we have this very debatable protection;	should we instead handle it as we do a SimpleQuery above? (to be reviewed)"	((self isConstant: targetValue) and: [(Dialect isBlock: targetValue) not]) ifTrue:			[self error: 'You are attempting to set a constant value as the target of a relationship. I suspect you want to set it on the source instead. Either that or you''re trying to use a field name where a field object is required.'].	targets add: targetValue.</body><body package="GlorpExpressions">asGlorpExpression	^self.</body><body package="GlorpExpressions">asGlorpExpressionForDescriptor: aDescriptor	base descriptor: aDescriptor.</body><body package="GlorpExpressions">asGlorpExpressionOn: aBaseExpression	| copy |	copy := self copy.	copy base: aBaseExpression.	copy outerJoin: outerJoin.	^copy.</body><body package="GlorpExpressions">asOuterJoin	"This has always been correctly implemented (see the comment in its polymorph MappingExpression&gt;&gt;asOuterJoin), but appears to have no callers, and no reason why it should not be inlined in any caller.  Unless callers appear, it will be renoved when its polymorph is removed."	self deprecated: #(#version '8.2' #sunset '9.0' #use #beOuterJoin).	^self copy beOuterJoin</body><body package="GlorpExpressions">beOuterJoin	"If you want the table you're joining to to be optional, this must be set."	outerJoin := true.</body><body package="GlorpUnitOfWork">mapFromSource: sourceObject andTarget: targetObject intoRowsIn: aRowMap	(sourceObject isNil or: [targetObject isNil]) ifTrue: [^self].	1		to: sources size		do:			[:i | 			| eachSourceField eachTargetField |			eachSourceField := sources at: i.			eachTargetField := targets at: i.			(self isConstant: eachSourceField)				ifTrue: [aRowMap at: eachTargetField key: targetObject put: eachSourceField value]				ifFalse:					[aRowMap						unifyField: eachSourceField						key: sourceObject						withField: eachTargetField						key: targetObject]].</body></methods><methods><class-id>Glorp.Join</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Joins act as if they don't have children, and just evaluate for themselves"	| |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	aBlock value: self.</body><body package="GlorpExpressions">fieldsDo: aBlock	sources with: targets do: aBlock.</body><body package="GlorpExpressions">mappableFieldsDo: aBlock	sources with: targets do: [:source :target |		source isMappable ifTrue: [aBlock value: source value: target]].</body><body package="GlorpExpressions">mappableSourceFieldsDo: aBlock	sources do: [:source  |		source isMappable ifTrue: [aBlock value: source]].</body></methods><methods><class-id>Glorp.Join</class-id> <category>testing</category><body package="GlorpExpressions">isEmptyExpression	^sources isEmpty.</body><body package="GlorpExpressions">isGlorpExpression	^true.</body><body package="GlorpExpressions">isJoin	^true.</body><body package="GlorpExpressions">isOuterJoin	^outerJoin.</body><body package="GlorpExpressions">shortCircuitOnNullComparison: parameters	"Return true if we represent an expression that compares null to a non-nullable value (in any of our clauses), so we don't ever need to really evaluate it"	self fieldsDo: [:source :target |		(target isNullable not and: [(parameters at: source) isNil]) ifTrue: [^true]].	^false.</body></methods><methods><class-id>Glorp.Join</class-id> <category>initialize</category><body package="GlorpExpressions">initialize	sources := OrderedCollection new: 2.	targets := OrderedCollection new: 2.	base := BaseExpression new.	outerJoin := false.</body><body package="GlorpExpressions">sourceFields: sourceFields targetFields: targetFields	sources := sourceFields.	targets := targetFields.</body></methods><methods><class-id>Glorp.Join</class-id> <category>comparing</category><body package="GlorpExpressions">= aJoin	aJoin class == self class ifFalse: [^false].	aJoin allSourceFields = sources ifFalse: [^false].	aJoin allTargetFields = targets ifFalse: [^false].	^true.</body></methods><methods><class-id>Glorp.Join</class-id> <category>converting</category><body package="GlorpExpressions">, aJoin	| newJoin |	aJoin isNil ifTrue: [^self].	aJoin == self ifTrue: [^self].	newJoin := (self class fromAll: (sources, aJoin allSourceFields) toAll: (targets, aJoin targetKeys)) removeDuplicates.	"If either one of the contributors is an outer join, make the result be an outer join"	newJoin outerJoin: (self isOuterJoin | aJoin isOuterJoin).	^newJoin</body><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| sourceFieldExpression targetFieldExpression completeExpression relationExpression |	completeExpression := EmptyExpression new base: base.	sources with: targets do:		[:sourceField :targetField | 		sourceFieldExpression := source getFieldKnownNotToBeAName: sourceField.		targetFieldExpression := target getFieldKnownNotToBeAName: targetField.		relationExpression := sourceFieldExpression equals: targetFieldExpression.		completeExpression := relationExpression AND: completeExpression].	outerJoin ifTrue: [completeExpression beOuterJoin].	^completeExpression</body><body package="GlorpExpressions">asGeneralGlorpExpression	"Convert this to a 'normal' expression representing the same information"	| main clause |	main := EmptyExpression new base: base.	sources with: targets		do: 			[:eachSource :eachTarget | 			| srcExp targetExp |			srcExp := self sourceExpressionFor: eachSource.			targetExp := self targetExpressionFor: eachTarget.			"Reversing the order is important because the source is the parameter, and sql won't accept '27 = FOO' "			clause := targetExp equals: srcExp.			main := main AND: clause].	outerJoin ifTrue: [main beOuterJoin].	^main</body><body package="GlorpExpressions">asGeneralGlorpExpressionWithFields	"The normal conversion of a join is to an expression equating fields and parameters. Instead, generate one with field to field comparisons"	| main clause |	main := nil.	sources with: targets		do: 			[:eachSource :eachTarget | 			| srcExp targetExp |			srcExp := self targetExpressionFor: eachSource.			targetExp := self targetExpressionFor: eachTarget.			clause := srcExp equals: targetExp.			main := main == nil ifTrue: [clause] ifFalse: [main AND: clause]].	outerJoin ifTrue: [main beOuterJoin].	^main</body><body package="GlorpExpressions">generalExpressionPart	^nil.</body><body package="GlorpExpressions">inverseJoin	| inverse |	inverse := self class new		base: base;		sourceFields: targets		targetFields: sources.	inverse owningMapping: self owningMapping.	^inverse.</body><body package="GlorpExpressions">isConstant: aTarget	"The target can be either a constant (which gets turned into a ConstantExpression) or (usually) a DatabaseField, representing a parameter to the query.  However it could be a subselect (which would return false)."	(aTarget class == DatabaseField) ifTrue: [^false].	^aTarget isGlorpExpression not		or: [aTarget isConstantExpression]</body><body package="GlorpExpressions">removeDuplicates	| existing newSources newTargets |	existing := Set new.	newSources := OrderedCollection new: sources size.	newTargets := OrderedCollection new: targets size.	sources		with: targets		do:			[:eachSource :eachTarget | 			| association |			association := eachSource -&gt; eachTarget.			(existing includes: association)				ifFalse:					[existing add: association.					newSources add: eachSource.					newTargets add: eachTarget]].	sources := newSources.	targets := newTargets.</body><body package="GlorpExpressions">replacing: aTable withEquivalenceFrom: aJoin	"Create a new join by sliding my sources along the source-to-target lines of aJoin.  Each of my sources that uses fields in aTable is replaced with that source's target in aJoin (any others get discarded).  The code assumes that aTable references are in the sources of aJoin (the caller can send #inverseJoin to the parameter if polarity is reversed)."	| newSources newTargets newSource |	newSources := OrderedCollection new.	newTargets := OrderedCollection new.	self fieldsDo:	"do not guard eachSource isGlorpExpression but instead assume expression understands #table"		[:eachSource :eachTarget |		eachSource table = aTable ifTrue:			[newSource := aJoin targetForSource: eachSource.			newSource isNil ifFalse:				[newSources add: newSource.				newTargets add: eachTarget]]].	^self class fromAll: newSources toAll: newTargets"If not one valid source is found, this will uncomplainingly return an empty join (almost certainly indicating a mistaken call that will cause errors later)."</body><body package="GlorpExpressions">sourceExpressionFor: source	"The source might be a subselect, hence the isMappable check."	^((self isConstant: source) or: [source isMappable not])		ifTrue: [source asGlorpExpressionOn: base]		ifFalse: [base getParameter: source]</body><body package="GlorpExpressions">targetExpressionFor: eachTarget	^(self isConstant: eachTarget)		ifTrue: [eachTarget]		ifFalse: [eachTarget isGlorpExpression				ifTrue: [eachTarget asGlorpExpressionOn: base]				ifFalse: [(base getTable: eachTarget table) getField: eachTarget]].</body></methods><methods><class-id>Glorp.Join</class-id> <category>primary keys</category><body package="GlorpExpressions">primaryKeyFromDictionary: aDictionary	"Given a set of parameters, return a primary key suitable for retrieving our target. Return either a value for the key, nil for no key found, or an array for compound keys."		sources size = 1 ifTrue: [^aDictionary at: sources first ifAbsent: [nil]].	^sources collect: [:each | aDictionary at: each ifAbsent: [nil]].</body></methods><methods><class-id>Glorp.Join</class-id> <category>debugging</category><body package="GlorpExpressions">owningMapping	"Return the mapping (if there is one) that is responsible for. Not needed for the code, but might be a useful debugging aid if trying to figure out where a @#%#@% join came from"	^owningMapping.</body><body package="GlorpExpressions">owningMapping: aMapping	owningMapping := aMapping.</body></methods><methods><class-id>Glorp.Join</class-id> <category>As yet unclassified</category><body package="GlorpExpressions">rebuildOn: aGlorpMappingExpression 	^self asGlorpExpressionOn: aGlorpMappingExpression.</body></methods><methods><class-id>Glorp.Join class</class-id> <category>instance creation</category><body package="GlorpExpressions">from: aField to: anotherField	^self new		addSource: aField target: anotherField.</body><body package="GlorpExpressions">from: from1Field to: to1Fieldfrom: from2Field to: to2Field	^self new		addSource: from1Field target: to1Field;		addSource: from2Field target: to2Field.</body><body package="GlorpExpressions">from: from1Field to: to1Fieldfrom: from2Field to: to2Fieldfrom: from3Field to: to3Field	^self new		addSource: from1Field target: to1Field;		addSource: from2Field target: to2Field;		addSource: from3Field target: to3Field.</body><body package="GlorpExpressions">from: from1Field to: to1Fieldfrom: from2Field to: to2Fieldfrom: from3Field to: to3Fieldfrom: from4Field to: to4Field	^self new		addSource: from1Field target: to1Field;		addSource: from2Field target: to2Field;		addSource: from3Field target: to3Field;				addSource: from4Field target: to4Field</body><body package="GlorpExpressions">from: from1Field to: to1Fieldfrom: from2Field to: to2Fieldfrom: from3Field to: to3Fieldfrom: from4Field to: to4Fieldfrom: from5Field to: to5Field	^self new		addSource: from1Field target: to1Field;		addSource: from2Field target: to2Field;		addSource: from3Field target: to3Field;				addSource: from4Field target: to4Field;		addSource: from5Field target: to5Field.</body><body package="GlorpExpressions">fromAll: sourceFields toAll: targetFields	^self new		sourceFields: sourceFields targetFields: targetFields.</body><body package="GlorpExpressions">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpVarBinaryType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^true.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^ByteArray.</body><body package="GlorpDatabaseTypes">isVariableWidth	"Return true if this type allows varying length data within a particular instance. e.g., this is true for a varchar, but false for a fixed size character field"	^true.</body></methods><methods><class-id>Glorp.GlorpVarBinaryType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	^#ByteArray.</body></methods><methods><class-id>Glorp.GlorpVarBinaryType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">width	^width.</body><body package="GlorpDatabaseTypes">width: anInteger	width := anInteger</body></methods><methods><class-id>Glorp.GlorpVarBinaryType</class-id> <category>initialize-release</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'varbinary'</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>mapping</category><body package="GlorpMappings">applicableMappingForConditionalValue: rowValue	cases		do:			[:each | 			((Dialect isBlock: each key)				ifTrue: [each key value: rowValue]				ifFalse: [self descriptor system perform: each key with: rowValue])				ifTrue: [^each value]].	^otherwiseCase.</body><body package="GlorpMappings">applicableMappingForObject: anObject	| conditionalValue |	conditionalValue := self conditionalValueFor: anObject.	^self applicableMappingForConditionalValue: conditionalValue.</body><body package="GlorpMappings">applicableMappingForRow: anArray in: anElementBuilder	"If a conditional field has been specified, then pass in its value for the element builder's row. Otherwise pass in the whole row."	| rowValue |	rowValue := conditionalField isNil		ifFalse: [anElementBuilder valueOfField: conditionalField]		ifTrue: [anElementBuilder row].	^self applicableMappingForConditionalValue: rowValue</body><body package="GlorpMappings">conditionalValueFor: anObject	^(Dialect isBlock: conditionalMethod)		ifTrue: [conditionalMethod value: anObject]		ifFalse: [anObject perform: conditionalMethod].</body><body package="GlorpMappings">knitFromBuilder: anotherElementBuilder toBuilder: anElementBuilder	(self applicableMappingForRow: anotherElementBuilder row in: anotherElementBuilder)		knitFromBuilder: anotherElementBuilder toBuilder: anElementBuilder.</body><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap 	self canWrite ifFalse: [^self].	(self applicableMappingForObject: anObject) 		mapFromObject: anObject		intoRowsIn: aRowMap.	conditionalFieldMapping isNil ifTrue: [^self].	conditionalFieldMapping 		mapFromObject: (self conditionalValueFor: anObject)		intoRowsIn: aRowMap</body><body package="GlorpMappings">mapObject: anObject inElementBuilder: anElementBuilder	(self applicableMappingForRow: anElementBuilder row in: anElementBuilder)		mapObject: anObject		inElementBuilder: anElementBuilder.</body><body package="GlorpMappings">newMapping: aMappingClass	"Implement this so that we can create our sub-mappings without having them added to the parent descriptor as independent mappings"	| mapping |	mapping := aMappingClass new.	mapping descriptor: self descriptor.	descriptor resetMappedFields.	^mapping.</body><body package="GlorpMappings">referencedIndependentObjectsFrom: anObject	^(self applicableMappingForObject: anObject)		referencedIndependentObjectsFrom: anObject</body><body package="GlorpMappings">translateField: aDatabaseField	^self representativeMapping translateField: aDatabaseField</body><body package="GlorpMappings">valueIn: anElementBuilder as: aMappingExpression	^(self applicableMappingForRow: anElementBuilder row in: anElementBuilder)		valueIn: anElementBuilder as: aMappingExpression</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>initialize/release</category><body package="GlorpMappings">initialize		super initialize.	cases := OrderedCollection new.</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>accessing</category><body package="GlorpMappings">attributeName	^self representativeMapping attributeName.</body><body package="GlorpMappings">cases	^cases.</body><body package="GlorpMappings">casesDo: aBlock	cases do: [:each | aBlock value: each value].	otherwiseCase isNil ifFalse: 		[aBlock value: otherwiseCase].</body><body package="GlorpMappings">conditionalField	^conditionalField</body><body package="GlorpMappings">conditionalField: aField	(conditionalField notNil and: [conditionalField ~~ aField]) ifTrue: [self error: 'You can only test one field in a conditional mapping'].	conditionalField := aField.</body><body package="GlorpMappings">conditionalFieldMapping	^conditionalFieldMapping</body><body package="GlorpMappings">conditionalFieldMapping: aMapping	"This is a write-only mapping for the conditional field value, which writes out the result of performing the conditional method"	conditionalFieldMapping := aMapping.	descriptor isNil ifFalse: [aMapping descriptor: descriptor].	(descriptor mappings includes: aMapping) ifTrue: [self error: 'Mapping is part of a conditional and part of the main descriptor. Be sure to send newMapping: to the conditional, not to the descriptor'].</body><body package="GlorpMappings">conditionalMethod: aSymbolOrOneArgBlock	"Performing the symbol on the object or evaluating the block with the object returns the value that is tested against the cases when writing.  When reading, the conditional field value is tested.  As the same cases are tested both reading and writing, this method must return either the value that gets mapped to the field, or something sufficiently compatible with it to give the same result when tested (e.g. if the tests are #valueIsNil:/#valueNotNil: then we would merely require the result to be nil/notNil when the value written to the conditionalField will be nil/notNil).	If a conditionalFieldMapping is set, the value this returns will be written (but not read) by that mapping, over and above whatever is written by the matching case.  This is an optional way of recording the discriminating value in an additional field to help keep writing and reading in synch."	conditionalMethod := aSymbolOrOneArgBlock.</body><body package="GlorpMappings">descriptor: aDescriptor	super descriptor: aDescriptor.	cases do: [:each | each value descriptor: aDescriptor].	otherwiseCase isNil ifFalse: [otherwiseCase descriptor: aDescriptor].	conditionalFieldMapping isNil ifFalse: [conditionalFieldMapping descriptor: aDescriptor].</body><body package="GlorpMappings">field	^self mappedFields asArray first.</body><body package="GlorpMappings">join	"The representativeMapping join is inadequate if an outer join:  #condensePrimaryKeyComparisons, inside #adjustWhereClause, rewrites to cut out the other cases, ignoring that it is an outer join and so should be part of an OR.  Returning a nonce GlorpExpression that aborts that check does not work either.  We may need to return the OR of all the cases joins.  TDB."	^self representativeMapping join</body><body package="GlorpMappings">mappedFields	"This returns a set while polymorphs return an array or ordered collection.  For now, leave it so, but review."	| all |	all := Set new.	conditionalFieldMapping isNil 		ifTrue: [all add: conditionalField]		ifFalse: [all addAll: conditionalFieldMapping mappedFields].	self casesDo: [:each | all addAll: each mappedFields].	^all "asArray"</body><body package="GlorpMappings">otherwise	^otherwiseCase.</body><body package="GlorpMappings">referenceClass	^self representativeMapping referenceClass.</body><body package="GlorpMappings">representativeMapping	"At some points we may need to have this mapping behave some way without knowing yet which of its cases is satisfied. We assume that there is some basic level of similarity so that we can use one mapping as a representative to discover, e.g. what the reference class is. This works all right for cases where we have a mapping or a constant. It wouldn't work very well if we have a one to one mapping to one class in case (a) but a many-many to an entirely different class in the other"	^cases first value.</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>conditions</category><body package="GlorpMappings">forField: aField attribute: attributeBlock if: testBlock useMapping: aMapping	self conditionalField: aField.	self conditionalMethod: attributeBlock.	self if: testBlock then: aMapping.</body><body package="GlorpMappings">if: conditionSelector then: aMapping	cases add: (Association key: conditionSelector value: aMapping).	descriptor isNil ifFalse: [aMapping descriptor: descriptor].	(descriptor mappings includes: aMapping) ifTrue: [self error: 'Mapping is part of a conditional and part of the main descriptor. Be sure to send newMapping: to the conditional, not to the descriptor'].</body><body package="GlorpMappings">otherwise: aMapping	otherwiseCase := aMapping.	descriptor isNil ifFalse: [otherwiseCase descriptor: descriptor].	(descriptor mappings includes: aMapping) ifTrue: [self error: 'Mapping is part of a conditional and part of the main descriptor. Be sure to send newMapping: to the conditional, not to the descriptor'].</body><body package="GlorpMappings">trace: aTracing context: anExpression	"To make a join, we need to look at all of our possible cases"	conditionalFieldMapping isNil ifFalse: [		conditionalFieldMapping trace: aTracing context: anExpression].	cases do: [:each |		each value trace: aTracing context: anExpression].</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>testing</category><body package="GlorpMappings">controlsTables	self casesDo:		[:each | each controlsTables ifTrue: [^true]].	^false</body><body package="GlorpMappings">hasField	"We used to ignore the otherwise case in mappedFields, now do not, so maybe this should just check the cases fields or otherwise continue returning the same results - TBD."	^self mappedFields size = 1</body><body package="GlorpMappings">hasValueThatCanProvideField: aField from: anObject	^(self applicableMappingForObject: anObject)		hasValueThatCanProvideField: aField from: anObject</body><body package="GlorpMappings">isRelationship	"Returning true means that an ObjectBuilder, not an ElementBuilder, will be provided to handle the applicableMapping.  We can nevertheless include DirectMappings in our cases provided the representativeMapping maps primary keys.  This allows ObjectBuilder&gt;&gt;canBuild to recognise that it cannot treat the DirectMapping - which will have nil key - as a relationship mapping.  The representativeMapping must therefore say it maps primary keys for the direct mapping to build (which may indicate something to fix, but that is the state for now)."	^self representativeMapping isRelationship</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject ifNone: aBlock	^(self applicableMappingForObject: anObject)		valueOfField: aField fromObject: anObject ifNone: aBlock</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>validation</category><body package="GlorpMappings">validateAttribute	cases do: [:each | each value validateAttribute].	otherwiseCase isNil ifFalse: [otherwiseCase validateAttribute].	conditionalFieldMapping isNil ifFalse: [conditionalFieldMapping validateAttribute].</body></methods><methods><class-id>Glorp.ConditionalMapping</class-id> <category>preparing</category><body package="GlorpMappings">joinExpressionFor: anExpression	^self representativeMapping joinExpressionFor: anExpression.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>accessing</category><body package="GlorpMappings">attributeName: anAttributeName	^self attributeName: anAttributeName referenceClass: nil.</body><body package="GlorpMappings">attributeName: anAttributeName referenceClass: aClass	"In addition to setting the attribute, use that information to further configure our faked-up descriptor. We can pass in a reference class here, although this is only really useful if we don't already have an explicit classModel."	| model |	super attributeName: anAttributeName.	aClass isNil ifFalse: [attribute type: aClass].	model := GlorpClassModel for: super referenceClass.	"We add a mapping for our value. We don't normally use this, because we expect people to refer directly to the attribute, but it means, for example, that the field shows up in our mapped fields without us having to fake it up. And you could write a query referring to anAttribute myValue if you wanted"	model newAttributeNamed: #myValue type: self attribute type.	self referenceDescriptor classModel: model.</body><body package="GlorpMappings">buildQuery	| builtQuery |	builtQuery := super buildQuery.	builtQuery retrieve: [:x | x getField: resultField].	^builtQuery</body><body package="GlorpMappings">descriptor: aDescriptor	super descriptor: aDescriptor.	aDescriptor system privateAndBasicAddDescriptorFor: self as: self pseudoDescriptor.</body><body package="GlorpMappings">field	^resultField.</body><body package="GlorpMappings">join: aJoin	"In addition to setting up the join, use that information to configure our faked up descriptor"	| tables |	super join: aJoin.	tables := self targetTables asArray.	tables size &gt; 1		ifTrue: [self error: 'Cannot have multiple tables for a direct toMany'].	self referenceDescriptor table: tables first.	"We add a mapping for our value. We don't normally use this, because we expect people to refer directly to the attribute, but it means, for example, that the field shows up in our mapped fields without us having to fake it up. And you could write a query referring to anAttribute myValue if you wanted"	(self referenceDescriptor newMapping: DirectMapping) 		from: #myValue to: resultField.</body><body package="GlorpMappings">referenceClass	"Return ourselves as the reference class, as a sort of a proxy for what we really want, which is a primitive, and varies according to the relationship anyway. Note that we have stuffed in a descriptor in the system, with ourselves (this instance) as the class."	^self.</body><body package="GlorpMappings">resultField	^resultField.</body><body package="GlorpMappings">resultField: aField	resultField := aField.</body><body package="GlorpMappings">writeExtraInformationInto: aRowMap atKey: rowMapKey forSourceObject: sourceObject targetObject: targetObject atIndex: index	super		writeExtraInformationInto: aRowMap		atKey: rowMapKey		forSourceObject: sourceObject		targetObject: targetObject		atIndex: index.	aRowMap		at: self resultField		key: rowMapKey		put: targetObject.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>mapping</category><body package="GlorpMappings">buildRowMapKeyForSource: source target: target index: index	"What should this do??? We want to distinguish the entries in e.g. # (1 2 3 3 4 3 5). Or do we? They aren't distinguishable in the DB. Does that mean we always want to write the order field? Or what? What if this is a set in memory. Then we really can't have two entries"	^MultipleRowMapKey		with: target yourSelf		with: source yourSelf		with: index.</body><body package="GlorpMappings">pseudoDescriptor	"Return a pretend descriptor for our reference class. Since that class is a primitive, it won't have a real descriptor, and it may vary by usage anyway"	| pseudoDescriptor |	pseudoDescriptor := Descriptor new.	pseudoDescriptor system: descriptor system.	^pseudoDescriptor.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>testing</category><body package="GlorpMappings">glorpCanHaveDescriptorDirectly	"We allow instances of ourselves to have a descriptor, which normally only classes can do. This is so that we can have multiple different descriptors in use for e.g. String, depending on the particular usage."	^true.</body><body package="GlorpMappings">mapsSimpleObject	^true.</body><body package="GlorpMappings">needsSpecialRowMapKey	"Return true if we have to use a special key object for the row map, rather than just our target. We always do, because our target may not have identity."	^true.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>converting</category><body package="GlorpMappings">convertedDbValueOf: anObject	"It may be that we need to introduce a converter here, the same as with a regular direct mapping"	^anObject.</body></methods><methods><class-id>Glorp.DirectToManyMapping</class-id> <category>validation</category><body package="GlorpMappings">validate	super validate.	"We have to write the order field. Otherwise, we get confused e.g. on deletion, because we don't have a way of telling the rows in the rowmap apart when the indexes have changed"	(self readOnly not and: [shouldWriteTheOrderField not]) ifTrue: [self error: 'To-many mappings to simple types must write an order field so that we have some way to tell the rows apart'].	"If we're for a pseudo-variable, we're neither reading nor writing, so we don''t need the order."	self isForPseudoVariable ifTrue: [^self].	orderBy isNil ifTrue: [self error: 'To-many mappings to simple types must specify and write an order field so that we have some way to tell the rows apart'].</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>executing</category><body package="GlorpDatabase">executeBoundIn: anAccessor	^anAccessor executeCommandBound: self.</body><body package="GlorpDatabase">executeUnboundIn: anAccessor	^anAccessor executeCommandUnbound: self.</body><body package="GlorpDatabase">nextPutBindMarkerIn: aRelationExpressionOrNil	self nextPut: $?.</body><body package="GlorpDatabase">printSQL	self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>stream behaviour</category><body package="GlorpDatabase">contents	^stream contents.</body><body package="GlorpDatabase">cr	stream cr.</body><body package="GlorpDatabase">nextPut: aCharacter	^stream nextPut: aCharacter.</body><body package="GlorpDatabase">nextPutAll: aString	^stream nextPutAll: aString.</body><body package="GlorpDatabase">nextPutString: aString	^self nextPutAll: aString.</body><body package="GlorpDatabase">policy	^stream policy.</body><body package="GlorpDatabase">print: anObject	anObject printOn: self</body><body package="GlorpDatabase">space	stream space.</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>accessing</category><body package="GlorpDatabase">bindings	self subclassResponsibility.</body><body package="GlorpDatabase">bindingTypes	self subclassResponsibility.</body><body package="GlorpDatabase">bindingTypesForEXDI	^self bindingTypes collect: [:each | each exdiType].</body><body package="GlorpDatabase">blockFactor	^5  "A reasonable default if we don't know"</body><body package="GlorpDatabase">maximumLobSizeToRetrieveDirectly	^32768.</body><body package="GlorpDatabase">parameterTypeSignature	self subclassResponsibility.</body><body package="GlorpDatabase">platform: aDatabasePlatform	self error: 'This API is obsolete. Pass the session instead'.</body><body package="GlorpDatabase">query	^nil.</body><body package="GlorpDatabase">session	^session.</body><body package="GlorpDatabase">signature	^self sqlString, self parameterTypeSignature.</body><body package="GlorpDatabase">sqlString	sqlString isNil ifTrue: [		stream isNil ifTrue: [stream := WriteStream on: (String new: 100)].		self printSQL.		sqlString := stream contents.		stream := nil].	^sqlString.</body><body package="GlorpDatabase">system	self session isNil ifTrue: [^nil].	^self session system.</body><body package="GlorpDatabase">useBinding	^useBinding</body><body package="GlorpDatabase">useBinding: aBoolean	useBinding := aBoolean</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>testing</category><body package="GlorpDatabase">canBind: aValue to: aType	useBinding ifFalse: [^false].	^self platform canBind: aValue to: aType underlyingType.</body><body package="GlorpDatabase">hasMultipleRows	^false.</body><body package="GlorpDatabase">isDeleteCommand	^false</body><body package="GlorpDatabase">isReadCommand	^false.</body><body package="GlorpDatabase">needsRowCount 	^false.</body><body package="GlorpDatabase">shouldUseGroupWriting	^self hasMultipleRows and: [self platform supportsGroupWritingFor: self]</body><body package="GlorpDatabase">succeeded	^self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>initializing</category><body package="GlorpDatabase">initialize	useBinding := true.	stream := WriteStream on: (String new: 100).</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>reporting</category><body package="GlorpDatabase">tables	"Return a list of the tables we will affect"	^self subclassResponsibility.</body></methods><methods><class-id>Glorp.DatabaseCommand</class-id> <category>As yet unclassified</category><body package="GlorpDatabase">platform	self session isNil ifTrue: [^nil].	^self session platform.</body><body package="GlorpDatabase">session: aGlorpSession	session := aGlorpSession.</body></methods><methods><class-id>Glorp.DatabaseCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase">new	^super new initialize.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>testing</category><body package="GlorpDatabase">hasMultipleRows	^allRows notNil and: [allRows size &gt; 1].</body><body package="GlorpDatabase">maximumBoundWriteSize	"How many bound rows can we send to the DB in a single trip."	^self system maximumSizeToGroupWriteFor: self</body><body package="GlorpDatabase">maximumUnboundWriteSize	"How many values can we write at once. This is only really applicable when not doing binding and concatenating many statements together for one trip to the DB"	^1000 min: (self system maximumSizeToGroupWriteFor: self)</body><body package="GlorpDatabase">succeeded	^failed not.</body><body package="GlorpDatabase">supportsGroupWriting	"Return true if array binding of values to a single statement, or batching of multiple statements, or concatenation of values to a single statement (or other similar mechanism) can be used to execute this command with multiple rows in a single round trip to the database."	^false</body><body package="GlorpDatabase">supportsGroupWritingValues	"The version of the INSERT command that can concatenate values onto a command (as one way of group-writing) is only supported by some database platforms in some versions.  Only if the platform supports it will an instance of an InsertCommand subclass that supports it be created."	^false</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>accessing</category><body package="GlorpDatabase">allRows	^allRows.</body><body package="GlorpDatabase">allRows: aCollectionOfDatabaseRows	allRows := aCollectionOfDatabaseRows.</body><body package="GlorpDatabase">parameterTypeSignature	"Return a string indicating the parameter types. Complicated by the possibility of multiple rows, and of null values"	| result |	result := WriteStream on: String new.	self hasMultipleRows		ifTrue:			[row				keysAndValuesDo:					[:eachKey :eachValInFirstRow| 					| nextValue |					eachValInFirstRow notNil						ifTrue: [result nextPutAll: eachValInFirstRow class name]						ifFalse:							[allRows								do:									[:eachRow | 									(nextValue := eachRow at: eachKey ifAbsent: [nil]) notNil										ifTrue: [result nextPutAll: nextValue class name]]]]]		ifFalse:			[row				keysAndValuesDo:					[:eachKey :eachValue | result nextPutAll: eachValue class name]].	^result contents.</body><body package="GlorpDatabase">row	^row.</body><body package="GlorpDatabase">row: aDatabaseRow	row := aDatabaseRow.	sqlString := nil.</body><body package="GlorpDatabase">rowCount	^rowCount.</body><body package="GlorpDatabase">rowCount: anInteger	rowCount := anInteger.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>executing</category><body package="GlorpDatabase">allRowsGrouped: maxSizeInteger evaluate: aBlock	"Set me to hold each of the first n * maximum row subgroups in turn, then set me to hold the final maximum-or-less residue of rows.  Do the whileTrue: compare using &lt;, not &lt;=, to ensure I will have some rows remaining for the post-loop run.  At the end, reset me to my start state (if debugging, be aware that we do not do this final reset inside an #ensure: block, instead assuming that any actual rerun will begin sufficiently far up the stack to ensure the command is recomputed;  a safe assumption?)."	| startPosition endPosition theRows |	maxSizeInteger &lt; allRows size ifFalse: [^aBlock value].	"no splitting needed"	theRows := allRows.	startPosition := 1.	endPosition := maxSizeInteger.	[endPosition &lt; theRows size] whileTrue:	"set me to hold the next maxSize rows"		[allRows := theRows copyFrom: startPosition to: endPosition.		self row: allRows first.		aBlock value.		startPosition := endPosition + 1.		endPosition := endPosition + maxSizeInteger].	"Set me to hold the remaining maxSize-or-less rows"	allRows := theRows copyFrom: startPosition to: theRows size.	self row: allRows first.	aBlock value.	"We're finished;  reset me back to my start state."	allRows := theRows.	self row: allRows first.</body><body package="GlorpDatabase">allRowsSinglyEvaluate: aBlock	"Run each row singly, nilling allRows during the run so no code in aBlock can imagine it should run grouped."	| theRows |	theRows := allRows.	allRows := nil.	theRows do:		[:each |		self row: each.		aBlock value].	"We're finished;  reset me back to my start state."	allRows := theRows.	self row: allRows first.</body><body package="GlorpDatabase">executeBoundIn: anAccessor	self hasMultipleRows		ifFalse: [self executeBoundInRoundTrip: anAccessor]		ifTrue: [self shouldUseGroupWriting				ifFalse: [self allRowsSinglyEvaluate: [self executeBoundInRoundTrip: anAccessor]]				ifTrue: [self						allRowsGrouped: self maximumBoundWriteSize						evaluate: [self executeBoundInRoundTrip: anAccessor]]].	^anAccessor cursorFor: #() readStream	"insert results aren't interesting so return an empty cursor"</body><body package="GlorpDatabase">executeBoundInRoundTrip: anAccessor	"Send one or more rows to the database in a single round trip, bound to an array of values.  The array will be  two-dimensional (arrayBindings) or one-dimensional (batchStatementBindings)."	| result |	result := anAccessor executeCommandBound: self.	result release.	failed := self needsRowCount and: [rowCount ~= self expectedNumberOfModifiedRows].</body><body package="GlorpDatabase">executeUnboundIn: anAccessor	anAccessor returnRowCount: self needsRowCount.	self hasMultipleRows		ifFalse:  [self executeUnboundInRoundTrip: anAccessor]		ifTrue: [self shouldUseGroupWriting				ifFalse: [self allRowsSinglyEvaluate: [self executeUnboundInRoundTrip: anAccessor]]				ifTrue: [self						allRowsGrouped: self maximumUnboundWriteSize						evaluate: [self executeUnboundInRoundTrip: anAccessor]]].	^#() readStream	"Results aren't interesting"</body><body package="GlorpDatabase">executeUnboundInRoundTrip: anAccessor	"Only an UpdateCommand with lock field(s) can return true to #needsRowCount.  Thus we call answer on the session in the #doing: block only if an UpdateCommand writes multiple optimistically-locked rows batched (must be batched as we are unbound and there is no way to write two or more such rows otherwise except via a bound call with #usesArrayBindingToGroupWrite).  The accessor has already called answer once, for the first row, and obtained the rowCount (one if optimistic locking succeeded, zero if it failed).  The second and subsequent rows will each return #noAnswerStream to successive calls of answer, plus the rowCount which we aggregate.  If the rowCount total is the total number of rows written, optimistic locking succeeded, otherwise we had one or more failures.  The index when any call of answer is followed by a rowCount of zero corresponds to the number in allRows of the row for which optimistic locking failed (i.e. someone had updated the row between this image's reading and writing of it).	BE AWARE:  the caller has cached the answer stream, which will be #noAnswerStream in the sole case where needsRowCount is true (an update of rows with lock fields), and so we raise an error if we do not exit with the answer stream still being #noAnswerStream, letting the caller continue safely."	anAccessor		executeSQLStringNoResult: self sqlString		doing: [failed := failed or:				[self needsRowCount and:		"if rowCount unsupported, we cannot tell if it worked, so assume it did but leave rowCount nil"					[(anAccessor platform supportsRowCountFor: self) and:						[rowCount := anAccessor rowCount.						2 to: self expectedNumberOfModifiedRows do:							[:index |							anAccessor driverSession answer == #noAnswerStream								ifFalse: [self error: 'Tell Niall:  platform does not support batched rowCount']								ifTrue: [rowCount := rowCount + anAccessor rowCount]].						rowCount ~= self expectedNumberOfModifiedRows]]]]		forCommand: self.</body><body package="GlorpDatabase">expectedNumberOfModifiedRows	^allRows isNil		ifTrue: [1]		ifFalse: [allRows size]</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>bound values</category><body package="GlorpDatabase">arrayBindings	"Return bindings in a form suitable for Oracle array binding, i.e. an array of arrays.  The outer array has one position for each field;  each position holds an array of values of that field, one for each row."	| allBindings fields |	fields := self arrayBoundFields.	allBindings := (1 to: fields size) collect: [:each | Array new: allRows size].	1 to: allRows size do:		[:rowNumber || inputRow | inputRow := allRows at: rowNumber.		1 to: fields size do:			[:columnNumber |			(allBindings at: columnNumber)				at: rowNumber				put: (inputRow at: (fields at: columnNumber) ifAbsent: [nil])]].	^allBindings asArray</body><body package="GlorpDatabase">arrayBoundFields	"Return the list of fields to be bound in the SQL string we will use for array binding or (despite my name) for batch statement binding."	^self subclassResponsibility</body><body package="GlorpDatabase">batchStatementBindings	"Return our bindings, which we assume are for multiple rows, as one big array, one statement after the other"	| bound fields |	fields := self arrayBoundFields.	bound := OrderedCollection new: allRows size * fields size.	allRows do: [:eachRow | 		fields do: [:each | 			| fieldValue |			fieldValue := eachRow at: each ifAbsent: [nil].			(self canBind: fieldValue to: each type) ifTrue: [bound add: fieldValue]]].	^bound asArray.</body><body package="GlorpDatabase">bindings	^self shouldUseGroupWriting		ifTrue: [self platform bindingsForGroupWritingFor: self]		ifFalse: [self singleRowBindings]</body><body package="GlorpDatabase">bindingTypes	"It is not functionally necessary to check usesArrayBindingRatherThanGroupWriting since the first part of the longer row is what the bindTemplate needs for a bound array and the rest is just ignored.  We check for (trivial) performance and for code clarity."	| all basic size |	^self shouldUseGroupWriting		ifTrue:			[basic := self arrayBoundFields collect: [:each | each type].			self platform usesArrayBindingToGroupWrite				ifTrue: [basic]				ifFalse:					[size := basic size.					all := Array new: allRows size * size.					0 to: allRows size - 1 do:						[:i || index | index := i * size.						all replaceElementsFrom: index + 1 to: index + size withArray: basic startingAt: 1].					all]]		ifFalse: [self singleRowBoundFields collect: [:each | each type]]</body><body package="GlorpDatabase">singleRowBindings	| bound |	bound := OrderedCollection new.	self singleRowBoundFields		do:			[:each | 			| fieldValue |			fieldValue := row at: each ifAbsent: [nil].			(self canBind: fieldValue to: each type) ifTrue: [bound add: fieldValue]].	^bound asArray.</body><body package="GlorpDatabase">singleRowBoundFields	"Return the list of fields to be bound in the SQL string we will use for a single operation. We only need to include those fields that actually have values in the particular row we're operating on"	self subclassResponsibility.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>initializing</category><body package="GlorpDatabase">initialize	super initialize.	failed := false.</body></methods><methods><class-id>Glorp.RowBasedCommand</class-id> <category>reporting</category><body package="GlorpDatabase">tables	^Array with: self row table.</body></methods><methods><class-id>Glorp.RowBasedCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase">forRow: aDatabaseRow useBinding: aBoolean session: aSession	"The caller knows there is only one row, thus #allRows: is not called and not set.  We set row last in case subclasses use its (re)setting to configure in ways that require session and/or binding."	^self new		useBinding: aBoolean;		session: aSession;		row: aDatabaseRow;			yourself.</body><body package="GlorpDatabase">forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession	"The calling path ensures there is more than one row."	^(self forRow: aCollectionOfDatabaseRows first useBinding: aBoolean session: aSession)		allRows: aCollectionOfDatabaseRows;		yourself</body></methods><methods><class-id>Glorp.UpdateCommand</class-id> <category>bound values</category><body package="GlorpDatabase">arrayBindings	"We must handle the special case of lock keys.  A lock key field appears twice in the UPDATE command:  with its (current) to-write value and (in the WHERE clause) with its (prior) was-read value (see class comment).  Thanks to #allRowsGrouped:evaluate:, my first row's lockKeyFields' nil/nonNil state is true for all my rows if and when this is called.  As we are using array binding, I can bind any nonNil value to a lock field, so need only consider nil values when coordinating with the where clause SQL."	| basicBindings lockKeyNonNilFields lockKeyWhereClauseBindings |	basicBindings := super arrayBindings.	lockKeyNonNilFields := self lockKeyFields select:		[:each | each isNullable not or: [(row oldVersionAt: each ifAbsent: [nil]) notNil]].	lockKeyNonNilFields isEmpty ifTrue: [^basicBindings].	lockKeyWhereClauseBindings := (1 to: lockKeyNonNilFields size) collect: [:each | Array new: allRows size].	1 to: allRows size do:		[:rowNumber || inputRow | inputRow := allRows at: rowNumber.		1 to: lockKeyNonNilFields size do:			[:columnNumber |			(lockKeyWhereClauseBindings at: columnNumber)				at: rowNumber				put: (inputRow						oldVersionAt: (lockKeyNonNilFields at: columnNumber)						ifAbsent: [self error: 'invalid grouping:  in where clause, group has both nonNil and nil values for Lock ', (lockKeyNonNilFields at: columnNumber) printString])]].	^basicBindings, lockKeyWhereClauseBindings</body><body package="GlorpDatabase">arrayBoundFields	"Array binding binds one or more values to the same SQL so all rows must agree which fields need update.  We also have to bind any optimistic lock field twice, once here with its current to-write value and once in the where clause with its older was-read value;  this second where-clause bind is appended by the caller.  (Lock fields are always written.)  We need only check the first row to see which fields are being updated because #allRowsGrouped:evaluate: ensures all rows in a given group have the same set of changed fields."	| basicFields |	basicFields := self fieldsNeedingUpdate: row.	^basicFields, row table primaryKeyFields asArray</body><body package="GlorpDatabase">batchStatementBindings	"As the super implementation but we add the where clause bindings for any lock fields."	| bound fields lockKeyFields |	lockKeyFields := self lockKeyFields.	lockKeyFields isEmpty ifTrue: [^super batchStatementBindings].	fields := self arrayBoundFields.	bound := OrderedCollection new: allRows size * (fields size + lockKeyFields size).	allRows do:		[:eachRow |		fields do:			[:each || fieldValue | fieldValue := eachRow at: each ifAbsent: [nil].			(self canBind: fieldValue to: each type) ifTrue: [bound add: fieldValue]].		lockKeyFields do:	"this is the only real change from the super implementation"			[:each || fieldValue | fieldValue := eachRow oldVersionAt: each ifAbsent: [nil].			(fieldValue notNil and: [self canBind: fieldValue to: each type]) ifTrue: [bound add: fieldValue]]].	^bound asArray</body><body package="GlorpDatabase">bindingTypes	"In a where clause, the SQL for a null-valued lock field must be WHERE ... IS NULL, not WHERE ... =NULL.  (Because SQL is one of the many languages that get it wrong where Smalltalk gets it right.  Unlike nil, which is equal and identical to itself, NULL means undefined and never equals itself:  NULL=NULL is always false;  you must use IS NULL.)	A lock field appears in the UPDATE clause, with its to-write value, and again in the WHERE clause, with its was-read value, so my #printSQL method writes IS NULL if a lock field's read value is nil (see #printLockEqualityForField:on:, which leads through a RelationalEpression to #printWithNullOn:).  If there is only one lock field then its final nil binding value would have no bind marker and could just be ignored (as happened in older Glorp).  If there were two lock fields (a rare case - how likely is it?), a nil read value for the first gets bound to the second's ? in the SQL, its own value being ignored.  Therefore avoid binding nil to a lock field."	| lockKeyWhereClauseBindingTypes lockType |	self lockKeyFields isEmpty ifTrue: [^super bindingTypes].	lockKeyWhereClauseBindingTypes := OrderedCollection new: self lockKeyFields size.	self lockKeyFields do:		[:each || fieldValue | fieldValue := row oldVersionAt: each ifAbsent: [nil].		(fieldValue notNil and: [self canBind: fieldValue to: (lockType := each type)])			ifTrue: [lockKeyWhereClauseBindingTypes add: lockType]].	^super bindingTypes , lockKeyWhereClauseBindingTypes</body><body package="GlorpDatabase">lockKeyFields	^row lockKeyFields</body><body package="GlorpDatabase">singleRowBindings	"In an update command, lock fields appear twice, once in the UPDATE clause, with (current) to-write value, and again in the WHERE clause, with (prior) was-read value;  add these where clause values (see class comment)."	| lockKeyWhereClauseBindings |	self lockKeyFields isEmpty ifTrue: [^super singleRowBindings].	lockKeyWhereClauseBindings := OrderedCollection new: row lockKeyFields size.	row lockKeyFields do:		[:each || fieldValue | fieldValue := row oldVersionAt: each ifAbsent: [nil].		(fieldValue notNil and: [self canBind: fieldValue to: each type]) ifTrue:			[lockKeyWhereClauseBindings add: fieldValue]].	^super singleRowBindings, lockKeyWhereClauseBindings</body><body package="GlorpDatabase">singleRowBoundFields	"We will actually have to bind one more thing than this, the optimistic lock fields (if present). That's handled in the caller."	| basicFields |	basicFields := self fieldsNeedingUpdate: row.	^basicFields , row table primaryKeyFields asArray</body></methods><methods><class-id>Glorp.UpdateCommand</class-id> <category>testing</category><body package="GlorpDatabase">needsRowCount	"We need to know whether any of the rows we attempted to update were not updated, i.e. whether any of them had changed lock key values from when we read them, so did not match their where clause, so did not update."	^self lockKeyFields isEmpty not</body><body package="GlorpDatabase">shouldUpdateOnlyChangedFields	"In an update statement, should we write out only changed fields or all of them?  The tradeoff is that writing only the changed ones will produce less SQL but make more variations of the statement, so require us to keep more prepared statements around if we're using binding.  DescriptorSystem returns true as the default, but a specific descriptor system can make #shouldUpdateOnlyChangedFieldsFor return	aCommand useBinding notif they prefer more SQL and fewer prepared statements."	^self system shouldUpdateOnlyChangedFieldsFor: self.</body><body package="GlorpDatabase">supportsGroupWriting	^true</body></methods><methods><class-id>Glorp.UpdateCommand</class-id> <category>accessing</category><body package="GlorpDatabase">fieldsNeedingUpdate: aDatabaseRow	^self shouldUpdateOnlyChangedFields 		ifTrue: [aDatabaseRow fieldsNeedingUpdate]		ifFalse: [aDatabaseRow nonPrimaryKeyFields]</body></methods><methods><class-id>Glorp.UpdateCommand</class-id> <category>executing</category><body package="GlorpDatabase">allRowsGrouped: maxSizeInteger evaluate: aBlock	"If we are array binding and are updating only changed fields or have nullable lock fields, we need to group our rows into subsets that generate the same SQL into which values can be bound.  The SQL in the SET clause must have the same fields to uopdate for all rows.  Each lock field's initial value will appear in the where clause comparison, along with the primary key values, but whereas primary keys cannot be null, lock fields just might be.  In each group we write, each lock field must have either no nil values or all nil values so that the SQL in the where clause can be either ... lockField IS NULL or else ... lockField=?, with ? never being bound to nil value.	If we are batch binding, it is possible to print the row-by-row-varying SQL and compute the corresponding row-by-row-varying bindings, but it is far simpler to group the rows into subsets as above, and so compute the bindings one per subset."	| theRows nullableLockKeyFields compatibleRowGroups compatibleRowKeys |	self useBinding ifFalse:	"unbound SQL can handle row-by-row variation in which fields to update and/or which lock fields are nil"		[^super allRowsGrouped: maxSizeInteger evaluate: aBlock].	nullableLockKeyFields := self lockKeyFields select: [:each | each isNullable].	"if no lock field can be nil, can't have rows with clashing nil states.  If all fields are updated, can't have differing field lists."	(nullableLockKeyFields isEmpty and: [self shouldUpdateOnlyChangedFields not]) ifTrue:		[^super allRowsGrouped: maxSizeInteger evaluate: aBlock].	"Sort the rows into compatible groups.  Collect the keys as well as the groups, instead of just using #groupedBy:, to preserve order as much as possible."	compatibleRowGroups := Dictionary new.	compatibleRowKeys := OrderedCollection new.	nullableLockKeyFields isEmpty		ifTrue: [self shouldUpdateOnlyChangedFields				ifFalse: [^super allRowsGrouped: maxSizeInteger evaluate: aBlock]				ifTrue: [allRows do:						[:eachRow || eachKey | eachKey := eachRow fieldsNeedingUpdate.						(compatibleRowGroups at: eachKey ifAbsentPut:							[compatibleRowKeys add: eachKey.							OrderedCollection new: allRows size]) add: eachRow]]]		ifFalse: [self shouldUpdateOnlyChangedFields				ifFalse: [allRows do:						[:eachRow || eachKey |						eachKey := nullableLockKeyFields collect:							[:eachLockField | (eachRow oldVersionAt: eachLockField ifAbsent: [nil]) isNil].						(compatibleRowGroups at: eachKey ifAbsentPut:							[compatibleRowKeys add: eachKey.							OrderedCollection new: allRows size]) add: eachRow]]				ifTrue: [allRows do:						[:eachRow || eachKey |						eachKey := eachRow fieldsNeedingUpdate.						eachKey addAll: (nullableLockKeyFields collect:							[:eachLockField | (eachRow oldVersionAt: eachLockField ifAbsent: [nil]) isNil]).						(compatibleRowGroups at: eachKey ifAbsentPut:							[compatibleRowKeys add: eachKey.							OrderedCollection new: allRows size]) add: eachRow]]].	compatibleRowKeys size = 1 ifTrue:	"all rows have same update-field and lockKey-nil key;  no splitting needed"		[^super allRowsGrouped: maxSizeInteger evaluate: aBlock].	theRows := allRows.	compatibleRowKeys do:		[:key || compatibleRows | compatibleRows := compatibleRowGroups at: key.		allRows := compatibleRows.		self row: allRows first.		super allRowsGrouped: maxSizeInteger evaluate: aBlock].	"We're finished;  reset me back to my start state."	allRows := theRows.	self row: allRows first.</body><body package="GlorpDatabase">printSQL	self printSQLForFirstRow: row.	self hasMultipleRows ifFalse: [^self].	(self useBinding and: [self platform usesArrayBindingToGroupWrite]) ifTrue: [^self].	2 to: self allRows size do:		[:i | self printSQLForNextRow: (allRows at: i)].</body><body package="GlorpDatabase">printSQLForFirstRow: aRow	| bodyFields |	self nextPutAll: 'UPDATE '.	aRow table printSQLOn: self withParameters: #().	self nextPutAll: ' SET '.	bodyFields := self fieldsNeedingUpdate: aRow.	GlorpHelper		do: [:field | aRow printEqualityTemplateForField: field on: self]		for: bodyFields		separatedBy: [self nextPut: $,].	self nextPutAll: ' WHERE '.	aRow printPrimaryKeyTemplateOn: self.	self lockKeyFields do:		[:field | self nextPutAll: ' AND '.		aRow printLockEqualityForField: field on: self].</body><body package="GlorpDatabase">printSQLForNextRow: aRow	self nextPut: $;.	self space.	self printSQLForFirstRow: aRow.</body></methods><methods><class-id>Glorp.RelativeUpdateCommand</class-id> <category>bound values</category><body package="GlorpDatabase">arrayBindings	"We must handle the special case of relative fields.  A relative field appears twice in the UPDATE command:  with its (current) to-write value and with its (prior) was-read value (or non-nil default if the old value was nil).  The SQL template has two bind markers for each relative field, with the operation (usually a minus sign) between them, and the new and old values are written to these two markers."	| basicBindings relativeFieldBindings arrayBoundFields relativeFieldIndex allBindings |	basicBindings := super arrayBindings.	relativeFields isEmpty ifTrue: [^basicBindings].	relativeFieldBindings := (1 to: relativeFields size) collect: [:each | Array new: allRows size].	1 to: allRows size do:		[:rowNumber || inputRow |		inputRow := allRows at: rowNumber.		1 to: relativeFields size do:			[:columnNumber || relativeField |			relativeField := relativeFields at: columnNumber.			(relativeFieldBindings at: columnNumber)				at: rowNumber				put: (inputRow						oldVersionAt: relativeField						ifAbsent: [relativeField type nilOldValueEquivalent])]].	"Now sort the basicBindings and relativeFieldBindings into their proper orders."	arrayBoundFields := self arrayBoundFields.	relativeFieldIndex := 0.	"If we will not be using the where clause lock keys already in the basic bindings, reduce our array size."	allBindings := Array new: basicBindings size + relativeFieldBindings size.	1 to: arrayBoundFields size do: 		[:boundFieldIndex || boundField |		boundField := arrayBoundFields at: boundFieldIndex.		allBindings			at: boundFieldIndex + relativeFieldIndex			put: (basicBindings at: boundFieldIndex).		boundField type isRelativeType ifTrue:			[relativeFieldIndex := relativeFieldIndex + 1.			allBindings				at: boundFieldIndex + relativeFieldIndex				put: (relativeFieldBindings at: relativeFieldIndex)]].	"The lock field where-clause values, if any, belong at the end of our array and are the trailing basicBindings values.	However, if there are ONLY relative field updates, don't include the lock fields in the where clause. They have	already been excluded from the singleRowBindings, via &gt;&gt;fieldsNeedingUpdate."	self lockKeyFields isEmpty ifFalse:		[0 to: basicBindings size - arrayBoundFields size - 1 do:			[:i || index |			index := allBindings size - i.			allBindings at: index put: (basicBindings at: basicBindings size - i)]].	^allBindings</body><body package="GlorpDatabase">batchStatementBindings	"As the super implementation but we add the relative fields' old values, and the where clause bindings for any lock fields.  If we are using this command we must have at least one relative field, so we never call super."	| bound fields  |	fields := self arrayBoundFields.	bound := OrderedCollection new: allRows size * (fields size + relativeFields size+ lockKeyFields size).	allRows do:		[:eachRow |		fields do:			[:each || fieldValue | fieldValue := eachRow at: each ifAbsent: [nil].			(self canBind: fieldValue to: each type) ifTrue: 				[bound add: fieldValue.				"the statement below is the only real change from the super implementation"				each type isRelativeType ifTrue:	"fieldValue was bindable so old value must also be bindable"					[bound add: (eachRow oldVersionAt: each ifAbsent: [each type nilOldValueEquivalent])]]].		lockKeyFields do:			[:each || fieldValue | fieldValue := eachRow oldVersionAt: each ifAbsent: [nil].			(fieldValue notNil and: [self canBind: fieldValue to: each type]) ifTrue: [bound add: fieldValue]]].	^bound asArray</body><body package="GlorpDatabase">bindingTypes	"Each relative type is doubly represented, once for the new and once for the old value."	| result |	result := OrderedCollection new.	super bindingTypes do:		[:each |		result add: each.		each isRelativeType ifTrue: [result add: each]].	^result</body><body package="GlorpDatabase">singleRowBindings	"Insert a binding for the relative field's old value after each relative field's (new value) binding."	| basicBindings relativeFieldBindings relativeFieldIndex rowBindings boundFields |	basicBindings := super singleRowBindings.	"This includes trailing lock keys, which we will remove if unused."	relativeFields isEmpty ifTrue: [^basicBindings].	relativeFieldBindings := Array new: relativeFields size.	"Put relative fields' corresponding oldValues into the relativeFieldBindings array."	1 to: relativeFields size do:		[:columnNumber || relativeField |		relativeField := relativeFields at: columnNumber.		relativeFieldBindings			at: columnNumber			put: (row					oldVersionAt: relativeField					ifAbsent: [relativeField type nilOldValueEquivalent])].	"Now merge the basicBindings and relativeFieldBindings into their proper orders."	boundFields := self singleRowBoundFields.	"(or, does &gt;&gt;arrayBoundFields work better?)"	relativeFieldIndex := 0.	"If we will not be using the where clause lock keys already in the basic bindings, reduce our array size."	rowBindings := Array new: basicBindings size + relativeFieldBindings size.	1 to: boundFields size do:		[:boundFieldIndex || boundField |		boundField := boundFields at: boundFieldIndex.		rowBindings			at: boundFieldIndex + relativeFieldIndex			put: (basicBindings at: boundFieldIndex).		boundField type isRelativeType ifTrue:			[relativeFieldIndex := relativeFieldIndex + 1.			rowBindings				at: boundFieldIndex + relativeFieldIndex				put: (relativeFieldBindings at: relativeFieldIndex)]].	"The lock field where-clause values, if any, belong at the end of our array and are the trailing basicBindings values.	However, if there are ONLY relative field updates, don't include the lock fields in the where clause. They have	already been excluded from the singleRowBindings, via &gt;&gt;fieldsNeedingUpdate."	self lockKeyFields isEmpty ifFalse:		[0 to: basicBindings size - boundFields size - 1 do:			[:i || index |			index := rowBindings size - i.			rowBindings at: index put: (basicBindings at: basicBindings size - i)]].	^rowBindings</body></methods><methods><class-id>Glorp.RelativeUpdateCommand</class-id> <category>accessing</category><body package="GlorpDatabase">lockKeyFields	"Am I updating non-relative (and non-lock key) fields.  If not, this will be empty though my rows may have such fields."		^lockKeyFields</body><body package="GlorpDatabase">relativeFields	^relativeFields</body><body package="GlorpDatabase">row: aDatabaseRow	"Find the relative fields whose new and old values we will write for this row.  A primary key field cannot be a relative field so we need only check the #fieldsNeedingUpdate: fields.  If we are not changing a relative field, we are not writing either its new value or its old value.	We only write lock fields if we are writing at least one non-relative field.  We do not check whether all lockKey fields generate or not but assume the user does not want lock key fields written when there are no non-relative fields being updated, even if they supplied a new lockKey field value.	Here alone we cannot use lockkeyFields being emty if we only update relatrive fields because here is where we see if we doing that or not"	| updatesOnlyRelativeFields |	relativeFields := OrderedCollection new.	lockKeyFields := OrderedCollection new.	updatesOnlyRelativeFields := true.	super row: aDatabaseRow.	(self fieldsNeedingUpdate: row) do:		[:each | each type isRelativeType				ifTrue: [relativeFields add: each]				ifFalse: [each isLockKey ifFalse:						[updatesOnlyRelativeFields := false]]].	updatesOnlyRelativeFields		ifTrue: [aDatabaseRow revertLockKeyFields]		ifFalse: [lockKeyFields := aDatabaseRow lockKeyFields].	"If there are lock key fields, they will always be incremented from the retrieved row. We need to exclude them	if there are no changed normal fields in the row, then we return only the changed relative fields."	"EVEN IF WE WERE writing all fields, not just changed ones, i.e. not shouldUpdateOnlyChangedFields, we would still want to suppress lockField update if only relative field values had changed.  Also the computation of normal fields from calling this and vice versa creates issues of circularity -  we call super in other methods and so on"</body></methods><methods><class-id>Glorp.RelativeUpdateCommand</class-id> <category>executing</category><body package="GlorpDatabase">allRowsGrouped: maxSizeInteger evaluate: aBlock	"If we have no lock keys, there is nothing to do here.  If we do then - since we must have some relative type fields- we sort into the two groups of those whose relative fields only are updated and those with at least one absiolute field updated.  If there are lock key fields, they will have been incremented for every row by this point. If there are no changed normal fields in that row, then we return only the changed relative fields. EVEN IF WE WERE writing all fields, not just changed ones, i.e. not shouldUpdateOnlyChangedFields, we would still want to suppress lockField update if only relative field values had changed. See further comments in &gt;&gt;row:."	| theRows nonRelativeFields absolutelyUpdatedRows relativelyUpdatedRows |	"We ask our row, not our cache, because if our row's table has lockKeyfields, other rows might need them or not whether this one does or not"	row lockKeyFields isEmpty ifTrue:		[^super allRowsGrouped: maxSizeInteger evaluate: aBlock].	nonRelativeFields := OrderedCollection new.	"We cache lockkeyFields and relativefields - should we cache these too?"	row fieldsDo: [:each | (each isPrimaryKey or: [each isLockKey or: [each type isRelativeType]]) ifFalse: [nonRelativeFields add: each]].	nonRelativeFields isEmpty ifTrue:		[^super allRowsGrouped: maxSizeInteger evaluate: aBlock].	"Sort the rows into compatible groups.  Collect the keys as well as the groups, instead of just using #groupedBy:, to preserve order as much as possible."	absolutelyUpdatedRows := OrderedCollection new: allRows size.	relativelyUpdatedRows := OrderedCollection new: allRows size.	allRows do:		[:eachRow |		(nonRelativeFields allSatisfy:			[:eachField | (eachRow oldVersionAt: eachField ifAbsent: [self class missingFieldIndicator]) = (eachRow at: eachField)])			ifTrue: [relativelyUpdatedRows add: eachRow revertLockKeyFields]			ifFalse: [absolutelyUpdatedRows add: eachRow]].	theRows := allRows.	absolutelyUpdatedRows isEmpty ifFalse:		[allRows := absolutelyUpdatedRows.		self row: allRows first.		super allRowsGrouped: maxSizeInteger evaluate: aBlock].	"Now handle rows where the lockkey fields do not matter."	relativelyUpdatedRows isEmpty ifFalse:		[allRows := relativelyUpdatedRows.		self row: allRows first.		"lockKeyFields := #().	setting row will do that"		super allRowsGrouped: maxSizeInteger evaluate: aBlock].	"We're finished;  reset me back to my start state."	allRows := theRows.	self row: allRows first.</body></methods><methods><class-id>Glorp.ReturningUpdateCommand</class-id> <category>executing</category><body package="GlorpDatabase">executeBoundInRoundTrip: anAccessor	"An updated row may have relative field columns; if so get their post-update DB values, which could differ from those we wrote."	| result |	result := anAccessor executeCommandBound: self.	relativeFields isEmpty ifFalse:		[self postWriteAssignReturnValuesUsing: result.		result release].	failed := self needsRowCount and: [rowCount ~= self expectedNumberOfModifiedRows].</body><body package="GlorpDatabase">executeUnboundInRoundTrip: anAccessor	"An updated row may have relative field columns; if so get their post-update DB values, which could differ from those we wrote.  Batch updates require fetching one answer per updated row."	| result |	result := anAccessor executeCommandUnbound: self.	relativeFields isEmpty ifFalse:		[self postWriteAssignReturnValuesUsing: result.		result release].	failed := self needsRowCount and: [rowCount ~= self expectedNumberOfModifiedRows].</body><body package="GlorpDatabase">postWriteAssignReturnValuesUsing: answerStream	"Ask the relative type how to assign returned value(s) to the target column(s) of my rows.  As result returns an array of arrays, we need the inner array.  If relative fields and values are not the same size, #with:do: will raise an error."	allRows isNil		ifTrue:			[relativeFields with: answerStream upToEndOfReturningResultSet first do:				[:field :value | row at: field forcePut: value]]		ifFalse:			[allRows do:				[:aRow |	"A failed update due to a bad lock will return an empty collection, with rowCount = 0."				relativeFields with: answerStream upToEndOfReturningResultSet first do:					[:field :aValue | aRow at: field forcePut: aValue]]].</body><body package="GlorpDatabase">printSQLForFirstRow: aRow	super printSQLForFirstRow: aRow.	self relativeFields isEmpty ifFalse:		[self platform printReturningFieldsOn: self].</body></methods><methods><class-id>Glorp.OutputUpdateCommand</class-id> <category>executing</category><body package="GlorpDatabase">printSQLForFirstRow: aRow	| bodyFields |	self nextPutAll: 'UPDATE '.	aRow table printSQLOn: self withParameters: #().	self nextPutAll: ' SET '.	bodyFields := self fieldsNeedingUpdate: aRow.	GlorpHelper		do: [:field | aRow printEqualityTemplateForField: field on: self]		for: bodyFields		separatedBy: [self nextPut: $,].	self relativeFields isEmpty ifFalse: [self platform printReturningFieldsOn: self].	self nextPutAll: ' WHERE '.	aRow printPrimaryKeyTemplateOn: self.	self lockKeyFields do:		[:field | self nextPutAll: ' AND '.		aRow printLockEqualityForField: field on: self].</body></methods><methods><class-id>Glorp.FixedSizeQueue</class-id> <category>printing</category><body package="GlorpCore">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: items size printString.	aStream nextPut: $/.	aStream nextPutAll: maximumSize printString.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.FixedSizeQueue</class-id> <category>accessing</category><body package="GlorpCore">maximumSize	^maximumSize</body><body package="GlorpCore">maximumSize: anInteger	maximumSize := anInteger.	items := OrderedCollection new: maximumSize + 1.</body></methods><methods><class-id>Glorp.FixedSizeQueue</class-id> <category>api</category><body package="GlorpCore">add: anObject	items add: anObject.	items size &gt; maximumSize ifTrue: [items removeFirst].</body></methods><methods><class-id>Glorp.FixedSizeQueue class</class-id> <category>instance creation</category><body package="GlorpCore">maximumSize: anInteger	^self basicNew maximumSize: anInteger.</body><body package="GlorpCore">new	self error: 'must supply a size'.</body><body package="GlorpCore">new: anInteger	^self maximumSize: anInteger.</body></methods><methods><class-id>Glorp.SelectCommand</class-id> <category>accessing</category><body package="GlorpDatabase">blockFactor: anInteger	blockFactor := anInteger.</body><body package="GlorpDatabase">parameters	^parameters</body><body package="GlorpDatabase">parameters: aDictionary	parameters := aDictionary</body><body package="GlorpDatabase">parameterTypeSignature	| result |	result := WriteStream on: String new.	self bindings do: [:each | result nextPutAll: each class name].	^result contents.</body></methods><methods><class-id>Glorp.SelectCommand</class-id> <category>testing</category><body package="GlorpDatabase">canBind: aValue to: aType	aValue isNil ifTrue: [^false].	^super canBind: aValue to: aType.</body><body package="GlorpDatabase">isReadCommand	^true.</body><body package="GlorpDatabase">succeeded	^true.</body></methods><methods><class-id>Glorp.SelectCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase">forQuery: aQuery parameters: aDictionary	^(self new)		query: aQuery;		parameters: aDictionary;		yourself.</body><body package="GlorpDatabase">forQuery: aQuery parameters: aDictionary useBinding: aBoolean session: aSession	^(self new)		query: aQuery;		parameters: aDictionary;		useBinding: aBoolean;		session: aSession;		yourself.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>accessing</category><body package="GlorpMappings">addMapping: aMapping 	self basicAddMapping: aMapping.	aMapping hasAttribute ifTrue: [		(aMapping classModel attributeNamed: aMapping attribute name) == aMapping attribute ifFalse: [self error: 'If you have a classModel you must use newMapping: rather than addMapping:']].</body><body package="GlorpMappings">addMultipleTableJoin: anExpression 	self multipleTableJoin add: anExpression</body><body package="GlorpMappings">addTable: aDatabaseTable 	tables add: aDatabaseTable.</body><body package="GlorpMappings">allMappingsForField: aField 	"Return all of the mappings that use this field"	^mappings select: [:each | each mappedFields includes: aField]</body><body package="GlorpMappings">allTables	"Return all tables used by this descriptor or its subclasses. For a non-inheritance descriptor, this is the same as tables."	^self typeResolver allTablesFor: self.</body><body package="GlorpMappings">basicAddMapping: aMapping 	mappings := mappings, (Array with: aMapping).	aMapping descriptor: self.	self resetMappedFields.	^aMapping</body><body package="GlorpMappings">cachePolicy	cachePolicy isNil ifTrue: [^system cachePolicy].	^cachePolicy</body><body package="GlorpMappings">cachePolicy: aCachePolicy	cachePolicy:= aCachePolicy</body><body package="GlorpMappings">classModel	^classModel</body><body package="GlorpMappings">classModel: aGlorpClassModel	classModel := aGlorpClassModel</body><body package="GlorpMappings">describedClass	^classModel describedClass.</body><body package="GlorpMappings">describedClass: aClass	classModel := self system classModelFor: aClass.</body><body package="GlorpMappings">directMappingForField: aField 	"Return a direct mapping for this field if there is one (there could be more than one, but they would all point to the same field so would all have to agree as far as the value is concerned).  Exclude pseudoVariable mappings by ensuring that the detected mapping can be read from the database (i.e. to be written to the object;  to exclude a full pseudoVariable, we could instead check #canWrite, which goes the other way, or check both, but setting the value on the object is the usual follow-on from calling this method)."	^(self mappingsForFields at: aField ifAbsent: [^nil])		detect: [:each | each isRelationship not &amp; each canRead]		ifNone: [nil]</body><body package="GlorpMappings">directMappingsForField: aField 	"Return all the relationship mappings that use this field"	^(self mappingsForFields at: aField ifAbsent: [^#()]) 		reject: [:each | each isRelationship].</body><body package="GlorpMappings">fieldsForSelectStatement	| myFields inheritedFields |	myFields := self mappedFields.	inheritedFields := self typeResolver fieldsForSelectStatement.	^inheritedFields isEmpty ifTrue: [myFields] ifFalse: [myFields, inheritedFields].</body><body package="GlorpMappings">imaginaryTableIsDefinedByRelationFrom: sourceAttributeName to: targetAttributeName	self imaginaryTableReplacements add: (Array with: sourceAttributeName with: targetAttributeName).</body><body package="GlorpMappings">imaginaryTableReplacements	imaginaryTableReplacements isNil ifTrue: [imaginaryTableReplacements := OrderedCollection new: 4].	^imaginaryTableReplacements.</body><body package="GlorpMappings">keyFields	"Return the fields we use as primary keys for caching purposes. Typically, these are just going to be the primary keys of our primary table. Objects intended to be embedded won't map the primary keys at all. Weird objects may supply their own keys (e.g. functions rather than fields directly)"	^keyFields == nil		ifTrue:			[self mapsPrimaryKeys				ifTrue: [self primaryTable primaryKeyFields]				ifFalse: [nil]]		ifFalse: [keyFields].</body><body package="GlorpMappings">keyFields: aFieldCollection	"Set the fields we use as primary keys for caching purposes. Typically, these are just going to be the primary keys of our primary table"	keyFields := aFieldCollection.</body><body package="GlorpMappings">mappedFields	"Return all the fields that are mapped, in the order that they occur in the table. This specifically omits fields that are not in the selected set of tables (so e.g. even if a mapping uses a link table field, if it's not in the list of tables to select from, we don't want it). We also include mapped, non-constant expressions, which we would normally expect to be functions"	mappedFields isNil ifTrue: [		| fieldSet |		fieldSet := IdentitySet new: mappings size.		mappings do: [:each | fieldSet addAll: each fieldsForDescriptorSelectStatement].		mappedFields := OrderedCollection new.		tables do: [:each |			each fields do: [:eachField | (fieldSet includes: eachField) ifTrue: [mappedFields add: eachField]]].		fieldSet do: [:each |  			(each isGlorpExpression and: [each isConstantExpression not]) ifTrue: [mappedFields add: each]]].	^mappedFields.</body><body package="GlorpMappings">mappingForAttributeNamed: aSymbol	"This returns nil if there is no mapping of that name."	^mappings		detect: [:each | each attributeName == aSymbol]		ifNone:			[self isForAssociation ifTrue:				[self valueDescriptor mappingForAttributeNamed: aSymbol]]</body><body package="GlorpMappings">mappingForField: aField	^(self mappingsForFields at: aField ifAbsent: [^nil]) first.</body><body package="GlorpMappings">mappingsForFields	"Return a dictionary from fields to the mappings that contain them. This specifically omits fields that are not in the selected set of tables (so e.g. even if a mapping uses a link table field, if it's not in the list of tables to select from, we don't want it). We also include mapped, non-constant expressions, which we would normally expect to be functions"	mappingsForFields isNil ifTrue: [		mappingsForFields := IdentityDictionary new: mappings size.		mappings do: [:eachMapping | 			eachMapping mappedFields do: [:eachField | 				(mappingsForFields at: eachField ifAbsentPut: [OrderedCollection new]) add: eachMapping]]].	^mappingsForFields.</body><body package="GlorpMappings">multipleTableJoin	multipleTableJoin isNil		ifTrue: [multipleTableJoin := OrderedCollection new: 1].	^multipleTableJoin.</body><body package="GlorpMappings">primaryTable	tables isEmpty ifTrue: [^nil].	^tables first.</body><body package="GlorpMappings">relationshipMappingForField: aField 	"Return a single, direct mapping for this field. There may conceivably be more than one, but they all have to agree, so it shouldn't matter as far as the value. There may also be none."	^(self mappingsForFields at: aField ifAbsent: [^nil]) 		detect: [:each | each isRelationship]		ifNone: [nil]</body><body package="GlorpMappings">relationshipMappingsForField: aField 	"Return all the relationship mappings that use this field, excluding pseudoVariable mappings"	^(self mappingsForFields at: aField ifAbsent: [^#()]) 		select: [:each | each isRelationship &amp; each canRead ].</body><body package="GlorpMappings">removeMapping:  aMapping	mappings := mappings copyWithout: aMapping</body><body package="GlorpMappings">resetMappedFields	mappedFields := nil.</body><body package="GlorpMappings">session	^system session.</body><body package="GlorpMappings">system	^system</body><body package="GlorpMappings">system: aDescriptorSystem	system := aDescriptorSystem.</body><body package="GlorpMappings">table	tables isEmpty ifTrue: [^nil].	^tables first.</body><body package="GlorpMappings">table: aDatabaseTable		| table |	table := aDatabaseTable isString		ifTrue: [table := self system tableNamed: aDatabaseTable]		ifFalse: [aDatabaseTable].	tables add: table.</body><body package="GlorpMappings">tables	^tables</body><body package="GlorpMappings">typeMapping	^mappings detect: [ :each | each isTypeMapping ] ifNone: [		| mapping |		mapping := IdentityTypeMapping new.		self addMapping: mapping.		mapping]</body><body package="GlorpMappings">typeMapping: aMapping	self addMapping: aMapping</body><body package="GlorpMappings">typeResolver	typeResolver isNil		ifTrue: [  IdentityTypeResolver new register: self  ].	^typeResolver</body><body package="GlorpMappings">typeResolver: anObject	typeResolver := anObject</body><body package="GlorpMappings">valueDescriptor	| valueMapping |	valueMapping := self mappingForAttributeNamed: #value.	valueMapping isNil ifTrue: [^nil].	^valueMapping referenceDescriptor.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>tracing</category><body package="GlorpMappings">setupTracing: aTracing	"Find all the other objects that need to be read when this one is read"	self trace: aTracing context: aTracing base.</body><body package="GlorpMappings">trace: aTracing context: anExpression	"For each mapping, check if the relationship is involved in the set of thingsto be read"	mappings do: [:each |		each trace: aTracing context: anExpression].</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>type mapping</category><body package="GlorpMappings">allDescribedConcreteClasses	^ self typeMapping allDescribedConcreteClasses</body><body package="GlorpMappings">registerTypeResolver: aResolver	self registerTypeResolver: aResolver abstract: false</body><body package="GlorpMappings">registerTypeResolver: aResolver abstract: shouldBeAbstract	shouldBeAbstract ifFalse: [ self beAbstract ].	aResolver register: self.</body><body package="GlorpMappings">typeMappingCriteriaIn: base	| r l |	r := ConstantExpression for: self typeMapping keys.	l := FieldExpression forField: self typeMapping field basedOn: base.	^l in: r</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>internal</category><body package="GlorpMappings">buildReplacementTableSelect	"We have an imaginary table which is defined by selecting from our attributes instead of from the table. Build the query for that."	| sourceMappings targetMappings mainQuery subQuery |	mainQuery := nil.	sourceMappings := imaginaryTableReplacements		collect: [:each | self mappingForAttributeNamed: each first].	targetMappings := imaginaryTableReplacements		collect: [:each | self mappingForAttributeNamed: each last].	sourceMappings		with: targetMappings		do:			[:eachSourceMapping :eachTargetMapping | 			subQuery := self				buildReplacementTableSelectFrom: eachSourceMapping				to: eachTargetMapping.			mainQuery := mainQuery isNil				ifTrue: [subQuery]				ifFalse: [mainQuery unionAll: subQuery]].	mainQuery session: self session.	self primaryTable replacementSubSelect: mainQuery.</body><body package="GlorpMappings">buildReplacementTableSelectFrom: sourceMapping to: targetMapping	"Build a select statement that combines the two mappings. We expect that both are relationships from a single object whose table is imaginary, so we need to knit together the information from the mappings to join the real tables directly together."	| fullJoin targetJoin sourceJoin subQuery join |	subQuery := Query read: sourceMapping referenceClass.	subQuery session: self session.		subQuery setUpExpressions.	"Invert because these will both start with the imaginary one on the left and we want to merge them together"	sourceJoin := (sourceMapping join		replacing: self primaryTable		withEquivalenceFrom: targetMapping join) inverseJoin.	targetJoin := targetMapping join		replacing: self primaryTable		withEquivalenceFrom: sourceMapping join.	fullJoin := sourceJoin = targetJoin		ifTrue: [sourceJoin]		ifFalse: [sourceJoin , targetJoin].	join := fullJoin asGeneralGlorpExpression asExpressionJoiningSource: subQuery baseExpression toTarget: subQuery baseExpression.	subQuery addJoin: join.	sourceMapping usesLinkTable ifTrue: [subQuery addJoin: (sourceMapping  expressionFromLinkToReferenceTableWithBase: subQuery baseExpression)].	targetMapping usesLinkTable ifTrue: [subQuery addJoin: (targetMapping  expressionFromLinkToReferenceTableWithBase: subQuery baseExpression)].	self		setRetrievalExpressionsInReplacementTableForQuery: subQuery		fromMapping: sourceMapping		toMapping: targetMapping.	^subQuery.</body><body package="GlorpMappings">describedConcreteClassFor: row withBuilder: builder	"Lookup the class that is represented by the row when there is a possibility		of this row representing any class within a hierarchy. "	^self typeResolver describedConcreteClassFor: row withBuilder: builder descriptor: self</body><body package="GlorpMappings">readBackNewRowInformationFor: anObject</body><body package="GlorpMappings">referencedIndependentObjectsFrom: anObject do: aBlock	mappings do: [:each |		(each referencedIndependentObjectsFrom: anObject) do: [:eachReferencedObject |			aBlock value: eachReferencedObject]].</body><body package="GlorpMappings">referencedIndependentObjectsWithMappingsFrom: anObject do: aBlock	mappings do: [:each |		(each referencedIndependentObjectsFrom: anObject) do: [:eachReferencedObject |			aBlock value: eachReferencedObject value: each]].</body><body package="GlorpMappings">setRetrievalExpressionsInReplacementTableForQuery: subQuery fromMapping: sourceMapping toMapping: targetMapping	self primaryTable fields do:		[:each || replacement expression |		replacement := sourceMapping join targetForSource: each.		replacement isNil ifTrue: 			[replacement := targetMapping join targetForSource: each].		expression := replacement isGlorpExpression			ifTrue: [replacement]			ifFalse: [(BaseExpression new getTable: replacement table) getField: replacement].		expression alias: each name.		subQuery retrieve: expression].</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>testing</category><body package="GlorpMappings">computeMapsPrimaryKeys	| primaryKeyFields |	self tables isEmpty ifTrue: [^false].	primaryKeyFields := self primaryTable primaryKeyFields.	primaryKeyFields isEmpty ifTrue: [^false].	primaryKeyFields		do: [:each | (self mappedFields anySatisfy: [ :eachMappedField |			eachMappedField = each]) ifFalse: [^false]].	^true.</body><body package="GlorpMappings">isForAssociation	^self describedClass == Association.</body><body package="GlorpMappings">isTypeMappingRoot	^self typeResolver isTypeMappingRoot: self</body><body package="GlorpMappings">mapsPrimaryKeys	mapsPrimaryKeys isNil ifTrue: [mapsPrimaryKeys := self computeMapsPrimaryKeys].	^mapsPrimaryKeys</body><body package="GlorpMappings">supportsOrdering	typeResolver isNil ifTrue: [^true].	^typeResolver supportsOrderingFor: self.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>mapping</category><body package="GlorpMappings">createRowsFor: anObject in: aRowMap	| row |	anObject class == self describedClass ifFalse:		[self error: 'wrong descriptor for this object'].	mappings do: [:each | each stopIfDebuggingWrite.				each mapFromObject: anObject intoRowsIn: aRowMap].	"If we haven't written out our primary keys, then make sure we do so, but if absolutely none of our mappings have written anything, then just ignore it."	row := aRowMap rowForTable: self primaryTable withKey: anObject ifAbsent: [^self].	self primaryTable primaryKeyFields do:		[:each | self setFieldValue: each in: row from: anObject].	"This is a bit of a hack/heuristic. If the multiple table join is an outer join, and the row doesn't exist yet, then assume we won't need it and don't do the join. It means none of our mappings wrote to it. Hope that in that case no one else's will. It seems reasonable that we wouldn't map an object to multiple tables unless we planned to map some field within it, but it's still a bit of a risk."	self multipleTableJoin do: [:each | 		(each isOuterJoin not or: [each allTables anySatisfy: [:eachTable | 			aRowMap includesRowForTable: eachTable withKey: anObject]]) 				ifTrue: [each						mapFromSource: anObject						andTarget: anObject						intoRowsIn: aRowMap]].</body><body package="GlorpMappings">mappings	^ReadStream on: mappings</body><body package="GlorpMappings">populateObject: anObject inBuilder: anElementBuilder	"Answer an object using the values for the specified fields."	mappings		do: [:each | 			each stopIfDebuggingRead.			each mapObject: anObject inElementBuilder: anElementBuilder].</body><body package="GlorpMappings">primaryKeyCollectionFor: anObject	"Find the primary key for anObject. Always return it as a collection."	| fields |	anObject yourSelf class == self describedClass		ifFalse: [self error: 'Wrong descriptor for this object'].	fields := self primaryTable primaryKeyFields.	^fields collect: [:each | self valueOfField: each fromObject: anObject].</body><body package="GlorpMappings">primaryKeyExpressionFor: anObject basedOn: anExpression relation: aSymbol	"The parameter anObject can be either a real domain object, or a constant expression containing it, or an expression representing the object.  Temp 'expression' begins the iteration with value nil and is gradually built up as successive primaryKeys are applied."	| expression value pkMappings firstPrimaryKey |	value := anObject isGlorpExpression		ifTrue: [anObject isConstantExpression ifTrue: [anObject value] ifFalse: [anObject]]		ifFalse: [anObject class == self describedClass				ifFalse: [self error: 'Wrong descriptor for this object'].			anObject].	self isForAssociation ifTrue:	"We just rewrite as self value = x"		[^((anExpression get: #value) get: aSymbol withArguments: (Array with:  value)) rewriteEquality].	pkMappings := self primaryKeyMappings.	firstPrimaryKey := pkMappings isEmpty		ifTrue: [(pkMappings := self mappings) next]		ifFalse: [pkMappings removeFirst].	expression := firstPrimaryKey		expressionFor: value		basedOn: anExpression		relation: aSymbol.	pkMappings do:		[:each || clause|	"If we get here, we have a composite key:  for a subselect, either the platform accepts a composite LHS or we must clone the RHS"		(value class == GeneralSubSelectExpression and: [(self system platform supportsCompositeKeyArgsForOperand: aSymbol) not]) ifTrue:			[value := value shallowCopy query: value query cloneWithinQuery; yourself].		clause := each expressionFor: value basedOn: anExpression relation: aSymbol.		(value class == GeneralSubSelectExpression and: [self system platform supportsCompositeKeyArgsForOperand: aSymbol])			ifFalse: [expression := aSymbol = #&lt;&gt; ifTrue: [clause OR: expression] ifFalse: [clause AND: expression]]			ifTrue: [expression leftChild: (expression leftChild asExpressionGroup add: clause leftChild)]].	^expression</body><body package="GlorpMappings">primaryKeyFor: anObject	"Find the primary key for anObject. If it's a single field, just return a single value. Otherwise, return a collection. Caller is expected to know what to expect."	| fields |	anObject class == self describedClass		ifFalse: [self error: 'Wrong descriptor for this object'].	fields := self primaryTable primaryKeyFields.	^fields size = 1		ifTrue: [self valueOfField: (fields at: 1) fromObject: anObject]		ifFalse:			[fields collect: [:each | self valueOfField: each fromObject: anObject]].</body><body package="GlorpMappings">primaryKeyMappings	"Return things that map to our primary key fields. Prefer direct mappings"	| fields pkMappings |	fields := self primaryTable primaryKeyFields.	pkMappings := OrderedCollection new: fields size.	fields do: [:each |  | mapping |		mapping := self directMappingForField: each.		mapping isNil ifTrue: [mapping := self mappingForField: each].		mapping isNil ifFalse: [pkMappings add: mapping]].	^pkMappings.</body><body package="GlorpMappings">readBackNewRowInformationFor: anObject in: aRowMap 	anObject yourSelf class == self describedClass ifFalse: [self error: 'wrong descriptor for this object'].	mappings do: [:each | each readBackNewRowInformationFor: anObject fromRowsIn: aRowMap]</body><body package="GlorpMappings">setFieldValue: each in: row from: anObject	"Try to set the value of the field, which is normally a primary key field, in the row, based on data in the object. Useful for the case where we have only a relationship mapping to the object that holds our primary key, and it is uninstantiated"	| value |	(row wrapperAt: each ifAbsent: [FieldValueWrapper new]) hasValue		ifFalse:			[value := self valueOfField: each fromObject: anObject ifNone: [^self].			"We're using this to get primary key fields. Nil is not a useful answer."			value isNil ifTrue: [^self].			row at: each put: value].</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject	^self valueOfField: aField fromObject: anObject ifNone: [nil].</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject ifNone: aBlock	"If the mapping is direct then the ifNone: parameter is ignored, since we cannot fail to get a value."	| directMapping notFound |	directMapping := self directMappingForField: aField.	directMapping isNil ifFalse:		[^directMapping valueOfField: aField fromObject: anObject].	notFound := Object new.	(self relationshipMappingsForField: aField) do:		[:each || candidate |		(each hasValueThatCanProvideField: aField from: anObject) ifTrue:			[candidate := each valueOfField: aField fromObject: anObject ifNone: [notFound].			candidate == notFound ifFalse: [^candidate]]].	^aBlock value</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>type resolution</category><body package="GlorpMappings">classesRequiringIndependentQueries	^ self typeResolver classesRequiringIndependentQueriesFor: self describedClass</body><body package="GlorpMappings">typeMappingRoot	^self typeResolver typeMappingRoot</body><body package="GlorpMappings">typeMappingRootDescriptor	^self typeResolver typeMappingRootDescriptor</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>printing</category><body package="GlorpMappings">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	self describedClass printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>creating mappings</category><body package="GlorpMappings">adHocMapping	^self newMapping: AdHocMapping</body><body package="GlorpMappings">directMapping	^self newMapping: DirectMapping.</body><body package="GlorpMappings">directMappingFor: attributeName	"Create a direct mapping from the attribute of this name to the field in the table with a matching name. For convenience when there's a good correspondence between the field and instance variable names."	| field |	self tables do: [:each |		field := each fieldNamed: attributeName ifAbsent: [nil] caseSensitive: false].	field isNil ifTrue: [self error: 'Cannot find field named ', attributeName printString].	^self directMapping from: attributeName to: field.</body><body package="GlorpMappings">fieldFor: aFieldOrString	"We allow either a field or a string naming the field, and return the appropriate field object."	aFieldOrString isString ifFalse: [^aFieldOrString].	self tables do: [:each |		| field | 		field := each fieldNamed: aFieldOrString.		field isNil ifFalse: [^field]].	self error: 'Cannot find field ', aFieldOrString, '. Please pass in the field object'.</body><body package="GlorpMappings">manyToManyMapping	^self newMapping: ManyToManyMapping</body><body package="GlorpMappings">newMapping: aClass	| mapping |	mapping := aClass new.	^self basicAddMapping: mapping</body><body package="GlorpMappings">oneToOneMapping	^self newMapping: OneToOneMapping"The superclass of OneToManyMapping is ToManyMapping, a valid concrete class giving the same behaviour, returned by #toManyMapping, so noone uses OneToManyMapping except for b/w compatibility.  There is no equivalent ToOneMapping concrete superclass.  That is why we have utility methods #toManyMapping and #oneToOneMapping."</body><body package="GlorpMappings">toManyMapping	^self newMapping: ToManyMapping"The class OneToManyMapping adds no behaviour to its superclass ToManyMapping;  it remains for b/w compatibility.  Thus no #oneToManyMapping utility method is provided."</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>deleting</category><body package="GlorpMappings">createDeleteRowFor: anObject table: aTable in: aRowMap	"Create records for rows that require deletion"	(self primaryKeyMappingsFor: aTable)		do: [:each | 			each first mapFromObject: anObject intoRowsIn: aRowMap].</body><body package="GlorpMappings">createDeleteRowsFor: anObject in: aRowMap	"Create records for rows that require deletion."	anObject class == self describedClass ifFalse: [self error: 'wrong descriptor for this object'].	"If we don't map primary keys, then we're something that gets embedded, and a delete isn't necessary"	self mapsPrimaryKeys ifFalse: [^self].	self tables do:		[:eachTable |		self createDeleteRowFor: anObject table: eachTable in: aRowMap.		aRowMap rowForTable: eachTable withKey: anObject ifPresent: [:eachRow | eachRow forDeletion: true]].	"If we do not have any direct mapping for a secondary table's primary keys (rare but possible), use	the multiple table join(s) to specify them (and if we do, the statement below doesn't do any harm)."	self multipleTableJoin do:		[:each |		each mapFromSource: anObject andTarget: anObject intoRowsIn: aRowMap.		each allTables do:			[:eachTable |			aRowMap rowForTable: eachTable withKey: anObject ifPresent: [:eachRow | eachRow forDeletion: true]]].	self mappings do: [:each | each createDeleteRowFor: anObject in: aRowMap].</body><body package="GlorpMappings">primaryKeyMappingsFor: aTable	"Return our primary key mappings as a collection of mappings, one collection per primary key"	| allMappings |	allMappings := Dictionary new: aTable primaryKeyFields size.	aTable primaryKeyFields		do: [:each | 			| mappingsForField |			mappingsForField := self mappingsForFields at: each ifAbsent: [nil].			mappingsForField isNil ifFalse: [allMappings at: each put: mappingsForField]].	^allMappings.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>validation</category><body package="GlorpMappings">initializeRuntimeMappings	"Do any setups we need to make sure that my mappings are initialized for runtime"	self mappings do: [:eachMapping | eachMapping initializeRuntimeMappings]</body><body package="GlorpMappings">validate	"Do any tests we can to make sure that this definition makes sense in this context"	| readableMappings attributeNames |	self system validateDescriptor: self.	self mappings do: [:eachMapping |		eachMapping validate].	"Validate that we have at most one readable mapping for an instance variable"	readableMappings := self mappings select: [:each | each canRead and: [each isTypeMapping not and: [each attributeName isEmpty not]]].	attributeNames := readableMappings collect: [:each | each attributeName].	(attributeNames asSet size = readableMappings size) 		ifFalse: [MultipleMappingsForInstanceVariable new					model: self describedClass;					readableMappings: readableMappings;					raiseRequest].	self typeResolver validate.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>recursion</category><body package="GlorpMappings">asRecursiveDescriptorOnMapping: originalMapping retrievingAll: mappingExpressions	"The recursive mapping must be a self mapping, direct or via a link table, so both initial source and final target are fields in the same single table.  (Later. we may generalise this.)"	| recursionMapping recursionTable recursionJoin originalTable originalClassModel recursionClassModel recursionMappingExpressions recursionTargetFields temporarySourceJoin temporaryTargetJoin recursionAttribute |	originalTable := self table.	originalClassModel := self classModel copy.	self postCopyForRecursion.	self classModel: (recursionClassModel := originalClassModel initialize).	self table: (recursionTable := DatabaseTable named: 'RecursionOn_' , originalTable name).	"Needs generalising;  for now, assume all our target fields are directly mapped in our mappings."	mappingExpressions do:		[:each || newMapping newAttribute |		newMapping := each createMappingToFieldInRecursionTable: recursionTable.		newAttribute := newMapping attribute copy.		newAttribute name: newMapping field name.		recursionClassModel addAttribute: newAttribute.		newMapping descriptor: nil.	"prevents the next line from adding the old name to the new class model"		newMapping attributeName: newAttribute name.		self addMapping: newMapping].	"now we add the renamed attribute to the class model"	"Get the mapping expressions that start from the recursion mapping"	recursionMappingExpressions := mappingExpressions select:		[:each |	"An aliased constant, or a cast of an aliased constant, indicates a computed field"		(each isConstantExpression or: [each base isConstantExpression]) not and:			[each anySatisfy: [:eachBase | eachBase class == MappingExpression and: [eachBase name = originalMapping attributeName]]]].	recursionTargetFields := originalMapping join allTargetFields collect:		[:eachField || recursionMappingExpression |		recursionMappingExpression := recursionMappingExpressions			detect:				[:each || penultimateMapping penultimateField |				penultimateMapping := originalMapping.				penultimateField := penultimateMapping class == DictionaryMapping					ifTrue: [penultimateMapping join allTargetFields first]					ifFalse: [originalMapping field].				"Because GlorpExpression equality is not yet defined (i.e. is identity) send #asField to get self for field,				underlying field for Prefix/PostfixExpression.  Later, define = on FieldExpression and FunctionExpression				(and others yet later as needed, and drop #asField from the line below)."				penultimateField asField = eachField asField]			ifNone: [self halt: 'recursion field not in retrievals;  revise code to add it automatically?'].		recursionTable			fieldNamed: recursionMappingExpression commonTableExpressionName			ifAbsent: [self halt: 'Impossible (i.e. coding error) as we added it above']			caseSensitive: false].	temporarySourceJoin := Join new.	originalMapping join allSourceFields with: recursionTargetFields do:		[:eachField :eachTargetField | temporarySourceJoin addSource: eachField target: eachTargetField].	recursionJoin := originalMapping class == DictionaryMapping		ifTrue: [temporarySourceJoin inverseJoin]		ifFalse: [originalMapping join				replacing: originalTable				withEquivalenceFrom: temporarySourceJoin].	originalMapping usesLinkTable ifTrue:		[temporaryTargetJoin := Join new.		originalMapping join allTargetFields with: originalMapping reverseJoin allTargetFields do:			[:eachField :eachTargetField | temporaryTargetJoin addSource: eachField target: eachTargetField].		originalMapping join allTargetFields do:			[:each |			recursionJoin := (recursionJoin inverseJoin				replacing: each table				withEquivalenceFrom: temporaryTargetJoin) inverseJoin]].	recursionAttribute := originalMapping attribute copy.	recursionAttribute name: 'recurse'.	recursionClassModel addAttribute: recursionAttribute.	recursionMapping := originalMapping class == DictionaryMapping			ifTrue: [self newMapping: OneToOneMapping]			ifFalse: [self newMapping: originalMapping class].	recursionMapping attributeName: recursionAttribute name.	recursionMapping join: recursionJoin.	originalMapping class = DictionaryMapping ifTrue:		[recursionAttribute type: recursionAttribute keyType].</body><body package="GlorpMappings">postCopyForRecursion	"Copy anything whose identity would make for problems constructing the recursive expressions"	self initialize.	mapsPrimaryKeys := nil.	keyFields := nil.	mappedFields := nil.		"force recompute using only the recursive mappings"	mappingsForFields := nil.	multipleTableJoin := nil.	"for now;  later check if recursive mapping's source or target is in the join"	typeResolver := nil.	"assume we are targetting a single temporary table whatever our original did"</body><body package="GlorpMappings">privateAndBasicSetMapsPrimaryKeys: aBoolean	"A conditional mapping may cause a descriptor to appear to map primary keys even when the object it describes usually does not.  In this case only, set the desired value explicitly instead of letting it be set lazily."	mapsPrimaryKeys := aBoolean.</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>initialize-release</category><body package="GlorpMappings">initialize	mappings := Array new.	tables := OrderedCollection new: 1.</body></methods><methods><class-id>Glorp.Descriptor class</class-id> <category>instance creation</category><body package="GlorpMappings">new	^super new initialize.</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>accessing</category><body package="GlorpUnitOfWork">addAllKeys: aKeyCollection	keys addAll: aKeyCollection.</body><body package="GlorpUnitOfWork">addKey: aKey	keys add: aKey.</body><body package="GlorpUnitOfWork">keys	^keys.</body><body package="GlorpUnitOfWork">keys: aCollection	keys := (aCollection asSortedCollection: self sortBlock).</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>printing</category><body package="GlorpUnitOfWork">printOn: aStream	aStream nextPutAll: 'KEY('.	self hash printOn: aStream.	aStream nextPutAll: '):'.	keys printOn: aStream.</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork">adjustIn: aCorrespondenceMap	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted keys: (keys collect: [:each | aCorrespondenceMap at: each ifAbsent: [each]]).	^adjusted.</body><body package="GlorpUnitOfWork">reverseAdjustIn: aRowMapForMementos	"Adjust ourselves to refer to the originals rather than the copies"	| adjusted |	adjusted := self copy.	adjusted keys: (keys collect: [:each | 		aRowMapForMementos reversedCorrespondenceMap at: each ifAbsent: [each]]).	^adjusted.</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>initialize-release</category><body package="GlorpUnitOfWork">initialize	keys := (SortedCollection new: 4) sortBlock: self sortBlock.</body><body package="GlorpUnitOfWork">sortBlock	^[:a :b | a identityHash &lt;= b identityHash].</body></methods><methods><class-id>Glorp.MultipleRowMapKey</class-id> <category>comparing</category><body package="GlorpUnitOfWork">= aRowMapKey	aRowMapKey class == self class ifFalse: [^false].	aRowMapKey keys size = keys size ifFalse: [^false].	"We can't rely on the order being the same because of the obscure but real case of two different related objects with the same identityHash"	aRowMapKey keys do: [:each |		(keys includes: each) ifFalse: [^false]].	^true.</body><body package="GlorpUnitOfWork">hash	"Note: the two things with the same identity hash problem is OK here because if they do then the hashes are (by definition) the same, and the order doesn't matter"	| increment hash |	increment := 14 // keys size.	hash := 0.	keys doWithIndex: [:each :index |		hash := hash bitXor: (each identityHash bitShift: increment * index)].	^hash.</body></methods><methods><class-id>Glorp.MultipleRowMapKey class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="GlorpUnitOfWork">with: key1 with: key2 with: key3	(key1 isNil or: [key2 isNil or: [key3 isNil]]) ifTrue: [self error: 'Nil key in row map, probably indicates an invalid object structure'].	^self new 		addKey: key1;		addKey: key2;		addKey: key3;		yourself.</body><body package="GlorpUnitOfWork">withAll: aCollection		^self new 		addAllKeys: aCollection;		yourself.</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>testing</category><body package="GlorpMisc">ancestorOf: anExceptionThingy	"VA Compatibility"	^self handles: anExceptionThingy</body><body package="GlorpMisc">isResumable	^self class mayResume.</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>accessing</category><body package="GlorpMisc">databaseError"rh 8/1/2004 21:26 for #getMessageText"	^self class name</body><body package="GlorpMisc">getMessageText	"This is horribly ugly. Not only are dialects inconsistent, but behaviour between types of exceptions is inconsistent within dialects"		Dialect isVisualWorks ifTrue: [^self getVisualWorksMessageText].	Dialect isVisualAge ifTrue: [^self getVisualAgeMessageText].	Dialect isSqueak ifTrue: [^self databaseError].	^self printString.</body><body package="GlorpMisc">getVisualAgeMessageText		| tempTag |	tempTag := self basicTag.	^tempTag isNil ifTrue: [self printString] ifFalse: [tempTag errorText].</body><body package="GlorpMisc">getVisualWorksMessageText	"In VisualWorks, we can get arrays of ExternalDatabaseExceptions, whose parameter is an array of ExternalDatabaseError objects. Or we might just get an exception, or we might get nil or something else entirely, in which case we fall back to a default error message."	| dbError |	self databaseError isNil ifTrue: [^messageText := self defaultMessageText].	dbError := self databaseError.	dbError glorpIsCollection ifTrue: [dbError := dbError first].	messageText := [dbError dbmsErrorString] on: Error do: [:ex | nil].	messageText isNil ifFalse: [^messageText].	messageText := [dbError description] on: Error do: [:anotherEx | self defaultMessageText].	^messageText</body><body package="GlorpMisc">messageText	(messageText isNil or: [messageText isEmpty]) ifTrue: [		messageText := self getMessageText].	^messageText.</body><body package="GlorpMisc">session	"We don't know what our session is, return nil by default."	^nil.</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>ANSI</category><body package="GlorpMisc">signal	"VisualWorks has non-ANSI semantics for this method. Re-implement to do the standard thing"	^Dialect isVisualWorks ifTrue: [self raise] ifFalse: [super signal].</body><body package="GlorpMisc">signal: aString	"VisualWorks has non-ANSI semantics for this method. Re-implement to do the standard thing"	^Dialect isVisualWorks		ifTrue:			[self messageText: aString.			self raise]		ifFalse: [super signal: aString].</body></methods><methods><class-id>Glorp.GlorpError</class-id> <category>printing</category><body package="GlorpMisc">description	"Make sure that we've populated our messageText before calling the superclass implementation."	self messageText.	^super description</body></methods><methods><class-id>Glorp.GlorpError class</class-id> <category>exception compatibility</category><body package="GlorpMisc">ancestorOf: anExceptionThingy	"VA Compatibility"	^self exceptionalEvent handles: anExceptionThingy</body></methods><methods><class-id>Glorp.GlorpError class</class-id> <category>ANSI</category><body package="GlorpMisc">signal	^self new signal.</body><body package="GlorpMisc">signal: aString	^self new signal: aString.</body></methods><methods><class-id>Glorp.GlorpError class</class-id> <category>testing</category><body package="GlorpMisc">mayResume	"This is a VisualWorks convention. Reimplement this here so that it will also be found in other dialects that don't have it in the superclass."	^false</body></methods><methods><class-id>Glorp.GlorpWriteFailure</class-id> <category>accessing</category><body package="GlorpMisc">command	^command</body><body package="GlorpMisc">command: anObject	command := anObject</body><body package="GlorpMisc">defaultMessageText	^'Database write failed'.</body><body package="GlorpMisc">object	^object</body><body package="GlorpMisc">object: anObject	object := anObject</body><body package="GlorpMisc">session	^self command session.</body></methods><methods><class-id>Glorp.GlorpWriteFailure</class-id> <category>constants</category><body package="GlorpMisc">defaultResumeValue	"If we resume, we encounter boolean-checking code.  It is pointless to resume and immediately meet a MustBeBoolean.  By default, resume with false, leading to a GlorpTransactionFailure."	^false</body></methods><methods><class-id>Glorp.GlorpWriteFailure class</class-id> <category>testing</category><body package="GlorpMisc">mayResume	^true.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>private</category><body package="GlorpUnitOfWork">deletedObjects	^deletedObjects.</body><body package="GlorpUnitOfWork">notFilteringDeletesDo: aBlock	"Execute aBlock, with filtering of deletes turned off. This is useful if we are in the process of deleting an object. Suppose we are deleting an object that has a link table relationship, but we have already deleted one of the linked objects. We need to make sure we also delete the link table entry, which means we need to know about that linked object, so we don't want Glorp filtering it out for us."	| oldCommitPhase |	[oldCommitPhase := commitPhase.	commitPhase := #registering.	aBlock value] ensure: [commitPhase := oldCommitPhase].</body><body package="GlorpUnitOfWork">privateGetRowMap	^rowMap</body><body package="GlorpUnitOfWork">privateGetTransaction	^transaction.</body><body package="GlorpUnitOfWork">registerAsNew: anObject 	anObject isNil ifTrue: [^nil].	commitPhase == #building ifTrue: [self halt]. "Should not happen. Probably indicates that we're triggering proxies while firing the mappings"	self newObjects add: anObject.	self register: anObject.	^anObject</body><body package="GlorpUnitOfWork">sendPostWriteNotification	self 		registeredObjectsDo: [:eachObject | session sendPostWriteEventTo: eachObject]</body><body package="GlorpUnitOfWork">sendPreWriteNotification	self 		registeredObjectsDo: [:eachObject | session sendPreWriteEventTo: eachObject]</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>accessing</category><body package="GlorpUnitOfWork">correspondenceMap	^transaction undoMap</body><body package="GlorpUnitOfWork">newObjects	newObjects isNil ifTrue: [newObjects := IdentitySet new].	^newObjects</body><body package="GlorpUnitOfWork">numberOfRows	^commitPlan size + deletePlan size.</body><body package="GlorpUnitOfWork">rowsToWrite	^commitPlan.</body><body package="GlorpUnitOfWork">session	^session</body><body package="GlorpUnitOfWork">session: aGlorpSession	session := aGlorpSession</body><body package="GlorpUnitOfWork">system	^session system.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>deletion</category><body package="GlorpUnitOfWork">computeCollectionDeletes	"If we have objects that are part of exclusive collections, and they have been removed from those collections, then they must be deleted. Note that we do this *before* we register the transitive closure at the end of the unit of work. That means we won't know about any new objects yet, but we don't care because new objects won't be deleted in this way. And that way if we delete and then add another object with (ick) the same primary key, we shouldn't have a clash because the delete will already have been issued."	self registeredObjects do: [:each |		| descriptor |		(descriptor := session descriptorFor: each class) isNil			ifFalse: [descriptor mappings do: [:eachMapping |				self computeCollectionDeletesFor: eachMapping inObject: each]]].</body><body package="GlorpUnitOfWork">computeCollectionDeletesFor: aMapping inObject: anObject	"If aMapping is exclusive and is to a collection, any objects removed from that collection during this transaction should be deleted.  We therefore compare the state of the collection at the start of the transaction to its current state (ignoring any uninstantiated proxies;  we filter the current and memento collections for these in separate iterations, not in a double iteration, as it is much faster)."	| memento currentObjects mementoObjects currentObjectSet |	aMapping isExclusive ifFalse: [^self].	aMapping attribute isCollectionAttribute ifFalse: [^self].	currentObjects := self session		realObjectFor: (aMapping getValueFrom: anObject)		ifNone: [^self].	(aMapping isValidTarget: currentObjects) ifFalse: [^self].	memento := transaction mementoFor: anObject.	mementoObjects := transaction collectionMementoFor:		(self session realObjectFor: (aMapping getValueFrom: memento)).	"Now that we have the state of the new collection and the original collection, we can look for differences."	currentObjectSet := IdentitySet new: (currentObjects size * 4 // 3) + 1.	currentObjects isNil ifFalse:		[currentObjects do:			[:each |			(each isGlorpProxy not or: [each isInstantiated]) ifTrue:				[currentObjectSet add: each yourSelf]]].	mementoObjects do:		[:each |		(each isGlorpProxy not or: [each isInstantiated]) ifTrue:			[(currentObjectSet includes: each yourSelf)				ifFalse: [session delete: each]]].</body><body package="GlorpUnitOfWork">delete: anObject	(self isRegistered: anObject) ifFalse: [session registerForDelete: anObject].	deletedObjects add: anObject.	(session embeddedObjectsFor: anObject) do: [:each | self delete: each].</body><body package="GlorpUnitOfWork">hasPendingDeletions	^deletedObjects isEmpty not.</body><body package="GlorpUnitOfWork">undelete: anObject ifNotDeleted: aBlock	deletedObjects remove: anObject ifAbsent: aBlock.	(session embeddedObjectsFor: anObject) do: [:each | self undelete: each].</body><body package="GlorpUnitOfWork">willDelete: anObject	"Return true if we will delete anObject when we commit."		^(deletedObjects includes: anObject) or: [deleting includes: anObject].</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>registering</category><body package="GlorpUnitOfWork">isRegistered: anObject	^transaction isRegistered: anObject.</body><body package="GlorpUnitOfWork">register: anObject 	| realObject |	commitPhase == #building ifTrue: [self halt]. "Should not happen. Probably indicates that we're triggering proxies while firing the mappings"	realObject := transaction register: anObject.	self registerTransitiveClosureFrom: realObject.</body><body package="GlorpUnitOfWork">registerForDelete: anObject 	"Register anObject with intent to delete it."	[deleting add: anObject.	self register: anObject] ensure: [deleting remove: anObject ifAbsent: []].</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>begin/commit/abort</category><body package="GlorpUnitOfWork">abort	self reinitialize.</body><body package="GlorpUnitOfWork">abort: anObject	transaction abort: anObject</body><body package="GlorpUnitOfWork">begin	self reinitialize.</body><body package="GlorpUnitOfWork">commit	[self preCommit.	self writeRows] ifCurtailed: [succeeded := false].	succeeded		ifTrue: [self postCommit]		ifFalse:			[GlorpTransactionFailure signal].</body><body package="GlorpUnitOfWork">createMementoRowMapFor: objects 	"Create a rowmap for the objects whose state was already known. We subtract this from the rowmap of all known objects to get the rows that need to be written. New objects are also registered, so we only generate rows here for non-new objects"	| localRowMap |	localRowMap := RowMapForMementos 				withCorrespondenceMap: self correspondenceMap.	localRowMap collectionMementos: transaction collectionMementos.	objects keysAndValuesDo: 			[:original :memento | 			(self newObjects includes: original) 				ifFalse: [session createRowsFor: memento in: localRowMap]].	^localRowMap</body><body package="GlorpUnitOfWork">createRowMapFor: objects	| localRowMap |	localRowMap := RowMap new: objects size.	objects do: [:each | session createRowsFor: each in: localRowMap].	^localRowMap</body><body package="GlorpUnitOfWork">createRows	self createRowsForPartialWrites.</body><body package="GlorpUnitOfWork">createRowsForCompleteWrites	"reference implementation. not called from anywhere"	self registeredObjectsDo: [:eachObject | session createRowsFor: eachObject in: rowMap].	deletedObjects do: [:eachObject | session createDeleteRowsFor: eachObject in: rowMap].</body><body package="GlorpUnitOfWork">createRowsForPartialWrites	| registeredObjectsRowMap mementoObjectsRowMap |	registeredObjectsRowMap := self createRowMapFor: self registeredObjects.	deletedObjects 		do: [:eachObject | session createDeleteRowsFor: eachObject in: registeredObjectsRowMap].	mementoObjectsRowMap := self createMementoRowMapFor: self mementoObjects.	rowMap := registeredObjectsRowMap differenceFrom: mementoObjectsRowMap.</body><body package="GlorpUnitOfWork">mementoObjects	"Warning: Excessive cleverness!!! The mementoObjects we want to iterate over are the values in the correspondenceMap dictionary. We were getting the values and returning them, but if all we need to do is iterate, then the dictionary itself works fine"	^self correspondenceMap.</body><body package="GlorpUnitOfWork">postCommit	self sendPostWriteNotification.	self updateSessionCache.	self validateRowsPostWrite.</body><body package="GlorpUnitOfWork">preCommit	commitPhase := #registering.	self registerTransitiveClosure.	commitPhase := #building.	self createRows.	linkRowsForUpdate := rowMap collapseMatchingInsertsAndDeletes.	self buildCommitPlan.	commitPhase := nil.	self sendPreWriteNotification.	self validateRows.</body><body package="GlorpUnitOfWork">propagateDeletes	"If we have objects which are to be deleted, and they have exclusive relationships to other objects, then we must also delete those other objects."	| deletionQueue |	deletionQueue := OrderedCollection new: deletedObjects size.	deletionQueue addAll: deletedObjects.	[deletionQueue isEmpty]		whileFalse:			[| each |			each := deletionQueue removeFirst.			(self session descriptorFor: each) mappings				do:					[:eachMapping | 					eachMapping isExclusive						ifTrue:							[eachMapping								loopOverAttributeOf: each								doing:									[:index :subObject | 									| realSubObject |									realSubObject := subObject yourSelf.									(realSubObject notNil and: [(deletedObjects includes: realSubObject) not])										ifTrue:											[session delete: subObject.											deletionQueue add: realSubObject]]]]].</body><body package="GlorpUnitOfWork">registeredObjects	^self correspondenceMap keys</body><body package="GlorpUnitOfWork">registerTransitiveClosure	"Look for new objects reachable from currently registered objects, and propagate deletions"	self computeCollectionDeletes.	self		registeredObjectsDo:			[:eachObject | self registerTransitiveClosureFrom: eachObject].	self propagateDeletes.</body><body package="GlorpUnitOfWork">rollback	self abort.</body><body package="GlorpUnitOfWork">validateRows	"Perform basic validation. Always test for equal named but non-identical tables, a sign of a malformed  system or other loss of identity. Also delegate to the descriptorSystem, which may have useful application-specific validations to do."		| tables tableNames |	tables := Set new.	rowMap rowsDo: [:each |		tables add: each table].	tableNames := tables collect: [:each | each qualifiedName].	tables asSet size = tableNames asSet size ifFalse: [self error: 'multiple table objects with the same name'].	self system validateRows: self.</body><body package="GlorpUnitOfWork">validateRowsPostWrite	"Perform basic validation after writing is done. It's better to validate beforehand, but some things are easier to catch afterwards"		self system validateRowsPostWrite: self.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>private/mapping</category><body package="GlorpUnitOfWork">addObject: eachObject toCacheKeyedBy: key 	| tracker |		self session cacheAt: key put: eachObject.	tracker := self session modificationTracker.	tracker isNil ifFalse: [tracker track: eachObject]</body><body package="GlorpUnitOfWork">addToCommitPlan: aRow	aRow shouldBeWritten ifFalse: [^self].	commitPlan add: aRow.</body><body package="GlorpUnitOfWork">addToDeletePlan: aRow		deletePlan add: aRow.</body><body package="GlorpUnitOfWork">assignSequenceNumbers	commitPlan do: [:each | each preWriteAssignSequencesUsing: self session].</body><body package="GlorpUnitOfWork">buildCommitPlan	| tablesInCommitOrder |	commitPlan := OrderedCollection new.	deletePlan := OrderedCollection new.	tablesInCommitOrder := session tablesInCommitOrder.	tablesInCommitOrder do: 			[:eachTable | 			self rowsForTable: eachTable				do: 					[:eachRow | 					eachRow forDeletion 						ifTrue: [self addToDeletePlan: eachRow]						ifFalse: [self addToCommitPlan: eachRow]]].	self sortCommitPlanRows.</body><body package="GlorpUnitOfWork">instantiateIfRequiredFor: anObject mapping: eachMapping	"Sometimes we have to instantiate the targets if they weren't. Specifically, if there's a relationship where the target has a foreign key to us. e.g. if X has a 1-many to Y, and we don't instantiate the collection of Y, but then replace it with some other collection. The Y's keys have to be updated, so we need to make sure they're read. There are other cases, too"	| originalTarget targetObject mapping instantiated |	mapping := eachMapping applicableMappingForObject: anObject.	mapping isRelationship ifFalse: [^false].	mapping readOnly ifTrue: [^false].	targetObject := mapping getValueFrom: anObject.	(self isNewObject: anObject)		ifTrue:			[^self instantiateIfRequiredForNewObjectReferenceTo: targetObject].	instantiated := (self willDelete: anObject)		ifTrue:			[self instantiateIfRequiredForDeletedObjectReferencing: targetObject from: anObject in: eachMapping]		ifFalse: [false].	originalTarget := self originalValueFor: anObject mapping: mapping.	^instantiated or: [self		instantiateIfRequiredForReferenceChangedFrom: originalTarget		to: targetObject].</body><body package="GlorpUnitOfWork">instantiateIfRequiredForDeletedObjectReferencing: targetObject from: anObject in: aMapping	"If we are deleted, then we need to have at least one mapping for each of our primary keys instantiated. If we're lucky, there's a direct mapping, and it's easy. Note that this only looks for the primary table. This might not be correct, but it's not clear, and for secondary tables there's a multiple table join that can be used without needing a mapping. And I'm not prepared to think about secondary tables whose keys are mapped only as relationships. In addition, if we use a link table, then we need to instantiate the reference, because we'll need to have enough information to delete the link table entry/entries."	| mappingsToUseForPrimaryKeys |	aMapping mapsPrimaryKeys ifFalse: [^false].		aMapping usesLinkTable ifTrue: [		"Make sure we get the non-filtered version, and return false so that if the reference has changed, we'll also get the original version."		self notFilteringDeletesDo: [targetObject yourSelf]. ^false].	mappingsToUseForPrimaryKeys := aMapping descriptor primaryKeyMappingsFor: aMapping descriptor primaryTable.	"For any of the fields we map, is there anyone else who can get us the value. If not, instantiate us. It might be better to optimize this a bit to look for e.g. one-one mappings before to-many."	aMapping mappedFields do: [:each |		| mappings |		mappings := mappingsToUseForPrimaryKeys at: each ifAbsent: [nil].		mappings isNil ifFalse: [			(mappings allSatisfy: [:eachMapping | 				(eachMapping hasValueThatCanProvideField: each from: anObject) not])					ifTrue: [						targetObject yourSelf.						^true]]].	^false.</body><body package="GlorpUnitOfWork">instantiateIfRequiredForNewObjectReferenceTo: targetObject	"If it's a new object, then we always need to instantiate"	targetObject isGlorpProxy ifFalse: [^false].	targetObject getValue.	^true.</body><body package="GlorpUnitOfWork">instantiateIfRequiredForReferenceChangedFrom: originalTarget to: newTarget	"For an existing relationship, we need to instantiate if the object we're referring to changed, and either was or is now a proxy. Actually we might get away without if it used to be, but now isn't, but better safe than sorry."	| wasProxy  |	originalTarget == newTarget ifTrue: [^false].	wasProxy := false.	self notFilteringDeletesDo: [		originalTarget isGlorpProxy ifTrue: [wasProxy := true. originalTarget getValue].		newTarget isGlorpProxy ifTrue: [wasProxy := true. newTarget getValue]].	^wasProxy.</body><body package="GlorpUnitOfWork">originalValueFor: anObject mapping: eachMapping	| memento |	memento := transaction undoMap at: anObject.	^eachMapping getValueFrom: memento.</body><body package="GlorpUnitOfWork">readBackNewRowInformation	| changedObjects |	changedObjects := rowMap objects.	changedObjects		do: 			[:each | 			| descriptor |			descriptor := session descriptorFor: each.			descriptor isNil ifFalse: [descriptor readBackNewRowInformationFor: each in: rowMap]]</body><body package="GlorpUnitOfWork">registerTransitiveClosureFrom: anObject	| descriptor |	anObject glorpIsCollection ifTrue:		[anObject glorpIsDictionary			ifFalse: [anObject do: [:each | session register: each]]			ifTrue: [anObject keysAndValuesDo:					[:eachKey :eachValue |					session register: eachKey; register: eachValue]].		^self].	descriptor := session descriptorFor: anObject class.	descriptor isNil ifTrue: [^self].	descriptor mappings do:		[:eachMapping |		self instantiateIfRequiredFor: anObject mapping: eachMapping].	descriptor referencedIndependentObjectsFrom: anObject do:		[:eachObject | session register: eachObject].</body><body package="GlorpUnitOfWork">relatedRowsFor: each	| rows extraRows |	rows := each relatedRowsIn: rowMap.	extraRows := self session system additionalRelatedRowsFor: each in: rowMap.	extraRows isNil ifFalse: [rows addAll: extraRows].	^rows select: [:eachRelatedRow | eachRelatedRow status notNil].</body><body package="GlorpUnitOfWork">reserveSequenceNumbers	rowsByTable := commitPlan glorpGroupedBy: [:each | each table].	rowsByTable keysAndValuesDo: [:eachTable :rows | 		eachTable sequences do: [:eachSequence | 			eachSequence 				reserveSequenceNumbers: (					rows inject: 0 into: [:sum :each | 						(each needsValueFromSequence: eachSequence) 							ifTrue: [sum + 1] ifFalse: [sum]])					in: self session					for: eachTable]]</body><body package="GlorpUnitOfWork">sortCommitPlanRows	| sorter |	sorter := GlorpRowSorter new		getChildrenVia: [:each | self relatedRowsFor: each].	commitPlan := sorter sort: commitPlan.	sorter := GlorpRowSorter new		getChildrenVia: [:each | self relatedRowsFor: each].	deletePlan := sorter sort: deletePlan.</body><body package="GlorpUnitOfWork">updateSessionCache	rowMap		keysAndValuesDo: [:eachObject :eachRow | 			eachRow shouldBeWritten ifTrue: [				self updateSessionCacheFor: eachObject withRow: eachRow]].	deletedObjects do: [:each |		session cacheRemoveObject: each].	linkRowsForUpdate do: [:eachRow |		eachRow shouldBeWritten ifTrue: [			self updateSessionCacheFor: eachRow owner withRow: eachRow]].</body><body package="GlorpUnitOfWork">updateSessionCacheFor: anObject withRow: aRow 	| key |	(rowMap isRowMapKey: anObject) ifTrue: [^self].  "Not cachable"	key := aRow primaryKey.	key isNil ifTrue: [^self].	(session cacheContainsObjectForClass: anObject class key: key) 		ifFalse: [self addObject: anObject toCacheKeyedBy: key].</body><body package="GlorpUnitOfWork">writeRows	succeeded := true.	self reserveSequenceNumbers.	self assignSequenceNumbers.	self session tablesInCommitOrder do: [:eachTable | self writeRowsForTable: eachTable].	deletePlan reverseDo: [:eachRow | | rowSucceeded |		rowSucceeded := session writeRow: eachRow.		succeeded := succeeded &amp; rowSucceeded].	self readBackNewRowInformation.</body><body package="GlorpUnitOfWork">writeRowsForTable: aTable	"No isEmpty check is needed as the writeHomogeneousRows: method checks it.  Return is not used."	| rows rowsByOperation |	rows := rowsByTable at: aTable ifAbsent: [^self].	rowsByOperation := rows glorpGroupedBy: [:eachRow | session shouldInsert: eachRow].	rowsByOperation do:		[:eachListOfHomogeneousRows |		succeeded := succeeded &amp;			(session writeHomogeneousRows: eachListOfHomogeneousRows)].</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>enumerating</category><body package="GlorpUnitOfWork">registeredObjectsDo: aBlock	transaction registeredObjectsDo: [:each |		(each glorpIsCollection or: [session hasDescriptorFor: each]) ifTrue: [			aBlock value: each]].</body><body package="GlorpUnitOfWork">rowsForTable: aTable do: aBlock	rowMap rowsForTable: aTable do: aBlock.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>initializing</category><body package="GlorpUnitOfWork">initialize	transaction := ObjectTransaction new.	self reinitialize</body><body package="GlorpUnitOfWork">reinitialize	rowMap := RowMap new.	commitPhase := nil.	deletedObjects := IdentitySet new.	deleting := IdentitySet new.	commitPlan := OrderedCollection new.	deletePlan := OrderedCollection new.	transaction abort.</body></methods><methods><class-id>Glorp.UnitOfWork</class-id> <category>testing</category><body package="GlorpUnitOfWork">forcesUpdateFor: aDatabaseRow	^linkRowsForUpdate notNil and: [linkRowsForUpdate includes: aDatabaseRow].</body><body package="GlorpUnitOfWork">isNewObject: anObject 	^self newObjects includes: anObject.</body><body package="GlorpUnitOfWork">shouldFilterDeletions	"Should we filter deleted objects from the results of queries. We don't do this if we're in the process of registering the transitive closure, because any fetches we do there are in order to get information we need for the commit (e.g. primary keys). If we filtered the deleted objects, then we may not be able to figure out primary keys for the objects to be deleted"	^commitPhase ~~ #registering.</body></methods><methods><class-id>Glorp.UnitOfWork class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpAbstractIntegerType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	(aClass includesBehavior: Boolean) ifTrue: [^self platform converterNamed: #booleanToInteger].	^self platform converterNamed: #numberToInteger.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Integer.</body></methods><methods><class-id>Glorp.GlorpAbstractIntegerType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Integer.</body></methods><methods><class-id>Glorp.GlorpPreparedStatement</class-id> <category>accessing</category><body package="GlorpDatabase">busy	^busy.</body><body package="GlorpDatabase">busy: aBoolean	busy := aBoolean.</body><body package="GlorpDatabase">signature	^signature</body><body package="GlorpDatabase">signature: aString	signature := aString</body><body package="GlorpDatabase">statement	^statement</body><body package="GlorpDatabase">statement: aStatementHandle	statement := aStatementHandle</body></methods><methods><class-id>Glorp.GlorpPreparedStatement</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	busy := false.</body></methods><methods><class-id>Glorp.GlorpPreparedStatement</class-id> <category>As yet unclassified</category><body package="GlorpDatabase">glorpNoticeOfExpiryIn: aSession	self release.</body><body package="GlorpDatabase">release	super release.	statement isNil ifFalse: [		| stmt |		stmt := statement.		statement := nil.		stmt disconnect].</body></methods><methods><class-id>Glorp.GlorpPreparedStatement class</class-id> <category>instance creation</category><body package="GlorpDatabase">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.PostfixFunction</class-id> <category>printing</category><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary		base printSQLOn: aStream withParameters: aDictionary.	self printsIntoJoins ifFalse: [^self].	aStream nextPutAll: ' '; nextPutAll: function.</body><body package="GlorpExpressions">printUnqualifiedSQLOn: aStream withParameters: aDictionary		base printUnqualifiedSQLOn: aStream withParameters: aDictionary.	aStream nextPutAll: ' '; nextPutAll: function.</body></methods><methods><class-id>Glorp.SQLServerSequence</class-id> <category>sequencing</category><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	"SELECT SCOPE_IDENTITY() is more robust so is now used instead whenever a group of rows are written to an SQLServer database version 9 or earlier (i.e. one that does not support value sequences).  This method will only be called when a single row is written.  Later, use SELECT SCOPE_IDENTITY() in that case too."	aDatabaseRow		at: aDatabaseField		put: ((anAccessor executeSQLString: 'SELECT @@IDENTITY') first atIndex: 1) asInteger"SQLServer returned the value as a FixedPoint (bizarre! - perhaps the SELECT @@IDENTITY mechanism can return Fixed Points in another usage scenario and so used this as its generic return type).  Thus the value comes back as a FixedPoint but is of course an integer.  This did not cause problems until we began binding arrays of columns for insert. Without the &gt;&gt;asInteger, it is possible for an array from Store to have FixedPoint values mingled with Integer values, which violates the ODBC api's expected type."</body><body package="GlorpDatabase">reserveSequenceNumbers: anInteger in: aSession for: aTable	"No real sequences here, just identity columns, which we can't pre-allocate"</body></methods><methods><class-id>Glorp.SQLServerSequence</class-id> <category>testing</category><body package="GlorpDatabase">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>testing</category><body package="GlorpDatabase">isDistinct	^false.</body><body package="GlorpDatabase">isGenerated	^type isGenerated or: [imDefaultValue notNil]</body><body package="GlorpDatabase">isIndexed	^self table hasIndexForField: self.</body><body package="GlorpDatabase">isLockKey	^isLockKey</body><body package="GlorpDatabase">isMappable	"Return true if we're something that can be returned in a select statement. Always true for fields"	^true.</body><body package="GlorpDatabase">isNullable		^isNullable.</body><body package="GlorpDatabase">isPrimaryKey	"Private - Answer the value of the receiver's ''isPrimaryKey'' instance variable."	^isPrimaryKey yourSelf.</body><body package="GlorpDatabase">isUnique	isUnique isNil ifTrue: [isUnique := false].	^isUnique.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>querying</category><body package="GlorpDatabase">qualifiedName	^table isNil 		ifTrue: [self name]		ifFalse: [self table qualifiedName, '.', self name].</body><body package="GlorpDatabase">quotedQualifiedName	| basicName |	basicName := self platform nameForColumn: self name.	^table isNil 		ifTrue: [basicName]		ifFalse: [self table qualifiedName, '.', basicName].</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>converting</category><body package="GlorpDatabase">asDistinctFieldOn: anExpression	^(anExpression getField: self) asDistinctFieldOn: anExpression.</body><body package="GlorpDatabase">asField	^self.</body><body package="GlorpDatabase">asGlorpExpression	^ParameterExpression forField: self basedOn: nil.</body><body package="GlorpDatabase">asGlorpExpressionOn: anExpression	^ParameterExpression forField: self basedOn: anExpression.</body><body package="GlorpDatabase">converterForStType: aClass	^self type converterForStType: (aClass isBehavior ifTrue: [aClass] ifFalse: [aClass class]).</body><body package="GlorpDatabase">parentTableField	| parentTable |	parentTable := self table parent.	^parentTable isNil		ifTrue: [self]		ifFalse: [parentTable fieldNamed: self name]</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>configuring</category><body package="GlorpDatabase">beIndexed	self table addIndex: (self table indexClass forField: self).</body><body package="GlorpDatabase">beLockKey	"Make lock fields non-nullable wherever possible:  when writing bound updates (especially when group-writing), the need to consider whether a lock field's prior value could be NULL complicates handling.   (Lock fields are typically of type VersionType with generatesOverExistingValues set, so Glorp will never naturally offer a nil value to a lock field;  usually, it is only legacy issues or non-Glorp access that could make it necessary to let a lock field be null)."	isLockKey := true.	isNullable := false.	"but caller may reset this;  see comment above"	self table isNil ifFalse: [self table addAsLockKeyField: self].</body><body package="GlorpDatabase">beNullable: aBoolean	self isPrimaryKey ifFalse: [ isNullable := aBoolean ]</body><body package="GlorpDatabase">bePrimaryKey	isPrimaryKey := true.	isNullable := false.	self table isNil ifFalse: [self table addAsPrimaryKeyField: self]</body><body package="GlorpDatabase">beRelative	"Since NULL + VALUE is NULL in SQL, relatively updates could be lost if it were possible to NULL the field without our knowing it.  Therefore use this method to make a not-null relative field, with a default value set in the database if a row with no entry for the field is written."	isNullable := false.	type := type beRelative.	dbDefaultValue isNil ifTrue:		[dbDefaultValue := type nilOldValueEquivalent]."If a nullable field is wanted, send #beRelative directly to the type, not to the field, e.g.	(aTable createFieldNamed: 'QTY' type: platform int4 beRelative)		dbDefaultValue: whatever - a db default value is optionalThe field can then be NULLed by setting NULL as the relative update value, since field = field + NULL;  obviously, the user who does this must be aware it will lose later relative updates.  Likewise, inserted rows must be given values for the field, or a dbDefaultValue must be set for it."</body><body package="GlorpDatabase">dbDefaultValue: anObject	"'Set a default value for this column in the database;  used in table (re)creation and when reading metadata.  Note the difference between this and Glorp having an image-set default value, which is handled by imDefaultValue."	dbDefaultValue := anObject.</body><body package="GlorpDatabase">defaultValue: anObject	"For backward compatibility and/or (excessive?) safety.  Before 8.2, my single 'defaultValue' instvar both set the value in the image before writing a no-value-for-me row and created a column with the same default value in the database.  Now we have two instvars to handle these two cases.  This setter preserves the pre-8.2 behaviour by setting both instvars to the same value.  Users are invited to decide which means of setting a default that they wish to use for any given call, and so replace calls of this method in their code with calls of the appropriate instvar's setter."	imDefaultValue := anObject.	dbDefaultValue := anObject.</body><body package="GlorpDatabase">imDefaultValue: anObject	"Glorp will insert this value into any row without a value for this field before writing to the database.  Note this is an alternative to or override of a default value on the database column;  use when the database does not have a default value or else has a different default value."	imDefaultValue := anObject.</body><body package="GlorpDatabase">isUnique: aBoolean	isUnique := aBoolean.</body><body package="GlorpDatabase">type: aDatabaseType	"There is very little chance of someone needing a serial column that is not part of the primary key, so we ensure its being a primaryKey here as the default."	type := aDatabaseType.	(type notNil and: [type isSerial]) ifTrue: [self bePrimaryKey]."If a user wanted to a serial type not to be a primaryKey, e.g. during a migration, then we would need a method to revert that state here in the field and to nil the primaryKeyFields instvar in its table.  Alternatively, we could defer the above assignment of primaryKey status to serial-type fields until table&gt;&gt;postInitializeIn: (for example), whereupon, if there were no other primaryKey columns, any serial column would be made the primaryKey (see AR 56006)."</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>accessing</category><body package="GlorpDatabase">dbDefaultValue	"'If this is not nil, the database has a default value for this column.  Note the difference between that and Glorp having an image-set default value, which is handled by imDefaultValue."	^dbDefaultValue</body><body package="GlorpDatabase">foreignKeyConstraints	^self table foreignKeyConstraints select: [:each | each sourceFields includes: self].</body><body package="GlorpDatabase">imDefaultValue	"Glorp will insert this value into any row without a value for this field before writing to the database.  Note this is an alternative to or override of a default value on the database column."	^imDefaultValue</body><body package="GlorpDatabase">impliedSmalltalkType	"Return the default Smalltalk type corresponding to our database type"	^self type impliedSmalltalkType.</body><body package="GlorpDatabase">name	"Private - Answer the value of the receiver's ''name'' instance variable."	^name</body><body package="GlorpDatabase">name: aString	"Private - Set the value of the receiver's ''name'' instance variable to the argument, anObject."	name := aString asString.</body><body package="GlorpDatabase">platform	^self type platform.</body><body package="GlorpDatabase">position	^position</body><body package="GlorpDatabase">position: anObject	position := anObject</body><body package="GlorpDatabase">table	^table</body><body package="GlorpDatabase">table: anObject	table := anObject</body><body package="GlorpDatabase">tablesToPrint	^Array with: table</body><body package="GlorpDatabase">type	^type</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>printing</category><body package="GlorpDatabase">printOn: aStream		aStream nextPutAll: 'Field'.	aStream 		nextPutAll: '(';		nextPutAll: (table isNil ifTrue: [''] ifFalse: [table name]);		nextPutAll: '.';		nextPutAll: name;		nextPutAll: ')'.</body><body package="GlorpDatabase">printSelectSQLOn: aStream withParameters: anArray 	self printSQLOn: aStream withParameters: anArray.</body><body package="GlorpDatabase">printSQLOn: aStream withParameters: anArray 	aStream nextPutAll: self quotedQualifiedName.</body><body package="GlorpDatabase">printUnqualifiedSQLOn: aStream withParameters: anArray 	aStream nextPutAll: self name.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>database</category><body package="GlorpDatabase">typeString	^type typeString</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>copying</category><body package="GlorpDatabase">withTable: aTable	"Return a copy of ourselves, with the table set to aTable. Presumably aTable is an aliased version of our table"	^self copy table: aTable.</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>comparing</category><body package="GlorpDatabase">&lt; aField	"This assists my being part of sorting multiple fields."	^self name &lt; aField name</body><body package="GlorpDatabase">&lt;= aField	^self name &lt;= aField name</body><body package="GlorpDatabase">basicMatchesField: aField	"Return true if I match aField, ignoring our table names."	self name asUppercase = aField name asUppercase ifFalse: [^false].	self isPrimaryKey = aField isPrimaryKey ifFalse: [^false].	self isNullable = aField isNullable ifFalse: [^false].	self isUnique = aField isUnique ifFalse: [^false].	^true</body><body package="GlorpDatabase">isSameAliasedFieldAs: aField	"Return true if we are the same as another aliased field. For non-aliased fields, identity is assured, so this is redundant. Note that we == the string. This will work because we know these must both be shallow copies of the same thing"	self class == aField class ifFalse: [^false].	^self table == aField table and: [self name == aField name].</body><body package="GlorpDatabase">isSimilarField: aField	"Return true if I match aField, ignoring our tables' names."	self name asUppercase = aField name asUppercase ifFalse: [^false].	self isPrimaryKey = aField isPrimaryKey ifFalse: [^false].	self isNullable = aField isNullable ifFalse: [^false].	self isUnique = aField isUnique ifFalse: [^false].	^true</body><body package="GlorpDatabase">isTheSameAs: aDatabaseField	"Validate that two fields are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method. If the field is part of the primary key, ignore the default value since duplicates are illegal. Beyond that, the platform vendor may impose its own default, ignoring ours. For example, MySQL automatically assigns varchar pkeys to have an empty string default value."	(self isSimilarField: aDatabaseField) ifFalse: [^false].	(self isTheSameTypeAs: aDatabaseField) ifFalse: [^false].	self isLockKey = aDatabaseField isLockKey ifFalse: [^false].	self isPrimaryKey ifFalse:		[self imDefaultValue = aDatabaseField imDefaultValue ifFalse: [^false].		self dbDefaultValue = aDatabaseField dbDefaultValue ifFalse: [^false]].	^true</body><body package="GlorpDatabase">isTheSameTypeAs: aDatabaseField	| myType aType |	self isPrimaryKey		ifTrue:		   [myType := self type.		   aType := aDatabaseField type.		   ^(myType = aType 				or: [(myType isSerial or: [aType isSerial ]) 					and: [myType impliedSmalltalkType = aType impliedSmalltalkType ]]) ].			^self type = aDatabaseField type</body><body package="GlorpDatabase">matchesField: aField	^self table name = aField table name		and: [self isSimilarField: aField]</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>obsolete</category><body package="GlorpDatabase">asConstraintReferenceString	^table name, ' (', self name, ')'.</body><body package="GlorpDatabase">printForConstraintNameOn: aStream maxLength: maxLength 	| constraintName |	constraintName := table name , '_' , name.	constraintName size &gt; maxLength 		ifTrue: [constraintName := constraintName copyFrom: 1 to: maxLength].	aStream nextPutAll: constraintName</body><body package="GlorpDatabase">printNameOn: aStream withParameters: anArray 	aStream nextPutAll: self name</body><body package="GlorpDatabase">printQualifiedSQLOn: aStream withParameters: aDictionary 	aStream nextPutAll: self qualifiedName</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	isPrimaryKey := false.	isNullable := true.	isUnique := false.	isLockKey := false.</body><body package="GlorpDatabase">postInitializeIn: aDescriptorSystem	"Any initialization that has to be delayed until we're in the table"	type initializeForField: self in: aDescriptorSystem.</body></methods><methods><class-id>Glorp.DatabaseField class</class-id> <category>instance creation</category><body package="GlorpDatabase">named: aString	^self error: 'type needed'</body><body package="GlorpDatabase">named: aString type: dbType	^super new initialize		name: aString;		type: dbType</body><body package="GlorpDatabase">new	^self error: 'dbType needed'</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>accessing</category><body package="GlorpExpressions">allSourceFields	"If we are sending this, then we're treating the expression as a join, for a complex (and probably read-only) relationship. So in that case we want to treat the source fields as the parameters that this expression takes, and specifically the parameters that are based on fields."	^self inject: OrderedCollection new into: [:sum :each |		each addToTargetFields: sum.		sum].</body><body package="GlorpExpressions">allTargetFields	"If we are sending this, then we're treating the expression as a join, for a complex (and probably read-only) relationship. So in that case we want to treat the target fields as being the source fields of the bottom-most mapping. That is, the fields we'll use to connect to the thing we want are the things that our expression's base (which represents the thing we want) would use to connect to the first level mapping arising from it. If we have a relation, that's a bit of a mess, but guess that we want the left child's information."	^self leftChild allTargetFields.</body><body package="GlorpExpressions">beOuterJoin	outerJoin := true.	leftChild beOuterJoin.	rightChild beOuterJoin.</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions">isOuterJoin	^outerJoin</body><body package="GlorpExpressions">leftChild	^leftChild</body><body package="GlorpExpressions">leftChild: anExpression 	leftChild := anExpression</body><body package="GlorpExpressions">outerJoin: aBoolean	outerJoin := aBoolean.</body><body package="GlorpExpressions">relation	^relation.</body><body package="GlorpExpressions">relation: aSymbol	relation := aSymbol.</body><body package="GlorpExpressions">rightChild	^rightChild</body><body package="GlorpExpressions">rightChild: anExpression	rightChild := anExpression</body><body package="GlorpExpressions">table	^rightChild table isNil		ifTrue: [leftChild table]		ifFalse: [self halt: 'Join expression is relation whose RHS is not simple enough?']</body><body package="GlorpExpressions">targetKeys	"Assume that part of us is a join, and the rest doesn't count"	^self inject: OrderedCollection new into: [:sum :each |		each isJoin ifTrue: [sum addAll: each targetKeys].		sum].</body><body package="GlorpExpressions">type	"Assume that we can derive our type from our children's type. Not guaranteed to be true, but seems like it should work for the common cases."	^self leftChild type.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>navigating</category><body package="GlorpExpressions">queryLevelBaseExpression	^leftChild canHaveBase ifTrue: [leftChild queryLevelBaseExpression] ifFalse: [rightChild queryLevelBaseExpression].</body><body package="GlorpExpressions">ultimateBaseExpression	^leftChild canHaveBase ifTrue: [leftChild ultimateBaseExpression] ifFalse: [rightChild ultimateBaseExpression].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>printing</category><body package="GlorpExpressions">printOnlySelfOn: aStream	aStream nextPutAll: relation.</body><body package="GlorpExpressions">printTreeOn: aStream 	aStream		print: leftChild;		space;		nextPutAll: relation;		space;		print: rightChild</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>iterating</category><body package="GlorpExpressions">convertValueOf: anObject in: aDictionary	| translated convertedValue |	translated := anObject isGlorpExpression 		ifTrue: [anObject valueIn: aDictionary]		ifFalse: [anObject].	translated isGlorpExpression ifTrue: [^translated].	convertedValue := self expectsCollectionArgument 		ifTrue: [translated collect: [:each | self leftChild convertedDbValueOf: each]]		ifFalse: [self leftChild convertedDbValueOf: translated].	^convertedValue.</body><body package="GlorpExpressions">do: aBlock skipping: aSet	| clauses |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	leftChild hasImpliedClauses		ifTrue:			[clauses := leftChild allRelationsFor: self.			clauses do: [:each | each do: aBlock skipping: aSet]]		ifFalse:			[leftChild do: aBlock skipping: aSet.			rightChild do: aBlock skipping: aSet.			aBlock value: self.].</body><body package="GlorpExpressions">mappableSourceFieldsDo: aBlock	"Used when we are emulating a Join"	self allSourceFields do: [:source |		source isMappable ifTrue: [aBlock value: source]].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>preparing</category><body package="GlorpExpressions">addBoundExpressionsIn: aCommand	"If our right-child can be used for binding, add it to the list. We need to do this at this level because the expressions themselves don't know what type they'll be matched against"	| translated |	rightChild canBind ifFalse: [^self].	(aCommand boundExpressions includes: self) ifTrue: [^self].	translated := self convertValueOf: rightChild in: aCommand parameters.	(self useBindingFor: translated to: leftChild type in: aCommand) ifTrue: [aCommand boundExpressions add: self].</body><body package="GlorpExpressions">additionalExpressions	^#().</body><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| left right |	left := leftChild asExpressionJoiningSource: source toTarget: target.	right := rightChild asExpressionJoiningSource: source toTarget: target.	^self class new 		relation: relation;		leftChild: left;		rightChild: right.</body><body package="GlorpExpressions">bindingIn: aCommand	^self convertValueOf: rightChild in: aCommand parameters.</body><body package="GlorpExpressions">bindingType	"If we're to be used for binding, return the field type to be bound to"	^self leftChild bindingType.</body><body package="GlorpExpressions">condenseBooleanEquality	(relation = #AND | (relation = #OR)) ifFalse: [^self].	(leftChild isGlorpExpression and: [leftChild isConstantExpression])		ifTrue: [			(relation = #AND and: [leftChild value = true]) ifTrue: [^rightChild].			(relation = #AND and: [leftChild value = false]) ifTrue: [^leftChild].			(relation = #OR and: [leftChild value = true]) ifTrue: [^leftChild].			(relation = #OR and: [leftChild value = false]) ifTrue: [^rightChild]].	(rightChild isGlorpExpression and: [rightChild isConstantExpression])		ifTrue: [			(relation = #AND and: [rightChild value = true]) ifTrue: [^leftChild].			(relation = #AND and: [rightChild value = false]) ifTrue: [^rightChild].			(relation = #OR and: [rightChild value = true]) ifTrue: [^rightChild].			(relation = #OR and: [rightChild value = false]) ifTrue: [^leftChild]].	^self.</body><body package="GlorpExpressions">condenseBooleanEqualityExpressions	leftChild := leftChild condenseBooleanEquality.	rightChild := rightChild condenseBooleanEquality.</body><body package="GlorpDatabase">condensePrimaryKeyComparison	"This tries to condense expressions of the form		something relatedObject id = xinto		something foreignKeyToRelatedObjectId = xso saving a join (and making the thing work at all, in the case where x = nil).  If the join thus saved is an outer join, the expression should also be - and must be moved from the whereClause to the 'joins' instvar later in query preparation if ANSI syntax is to represent it so."	| fieldBeingCompared baseObjectExpression join sourceField condensedExpression |	(relation = #= or: [relation = #&lt;&gt;]) ifFalse: [^self].	self leftChild mappedFields size = 1 ifFalse: [^self].	fieldBeingCompared := self leftChild field.	fieldBeingCompared class == DatabaseField ifFalse: [^self].	fieldBeingCompared isPrimaryKey ifFalse: [^self].	baseObjectExpression := self leftChild base.	baseObjectExpression representsDerivedObject ifFalse: [^self].	"If we have an expression for a join, don't even try."	baseObjectExpression join isJoin ifFalse: [^self].	join := baseObjectExpression join				asGlorpExpressionOn: baseObjectExpression base.	sourceField := join sourceForTarget: fieldBeingCompared ifNone: [^self].	"OK, we've got a match, replace ourselves with the shortcut."	condensedExpression := (sourceField isGlorpExpression				and: [sourceField isConstantExpression])					ifTrue: 						[self rightChild get: relation withArguments: (Array with: sourceField)]					ifFalse: 						[(self leftChild base base getField: sourceField) get: relation							withArguments: (Array with: self rightChild)].	join isOuterJoin ifTrue: [condensedExpression beOuterJoin].	^condensedExpression</body><body package="GlorpExpressions">condensePrimaryKeyComparisons	"Because we're replacing the expression, we need to do it at the parent and replace the previous child"	leftChild := leftChild condensePrimaryKeyComparison.	rightChild := rightChild condensePrimaryKeyComparison.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| expression |	self == anExpression ifTrue: [^aBaseExpression].	expression := (leftChild rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression)		get: relation		withArguments:			(Array				with:					(self rightChildToRebuild rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression)).	self isOuterJoin ifTrue: [expression beOuterJoin].	^expression.</body><body package="GlorpExpressions">removeNonJoinParts	"Remove anything that's not an actual join. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to use the general ones, because they're not field level. Also only meaningful to remove this for ANDs and ORs, not sub-components."	(relation = #AND or: [relation = #OR]) ifFalse: [^self].	leftChild := leftChild isJoin ifTrue: [leftChild] ifFalse: [true asGlorpExpression].	rightChild := rightChild isJoin ifTrue: [rightChild] ifFalse: [true asGlorpExpression].</body><body package="GlorpExpressions">replaceJoinsWithInverse	"Replace any actual Join objects we have with their inverse. Only useful if we have something that has mixed joins and general expressions, where we assume we don't want to mess with the general ones, because they're not field-level"	leftChild isJoin ifTrue: [leftChild := leftChild inverseJoin].	rightChild isJoin ifTrue: [rightChild := rightChild inverseJoin].</body><body package="GlorpExpressions">rewriteEquality	| keyEquality descriptor describedClass |	leftChild := leftChild rewriteBooleanEquality: relation.	(relation = #= or: [relation = #&lt;&gt; or: [relation = #IN]]) ifFalse: [^self].	leftChild class = ExpressionGroup ifTrue:		[^leftChild asMultipleExpressionRelationOf: self].	"This restrictive handling of conditionals will be developed later."	leftChild class = MappingExpression ifTrue:		[leftChild mapping class = ConditionalMapping ifTrue:			[^leftChild expandConditionalLeftChildOf: self]].	leftChild hasDescriptor ifFalse: [^self].	"A slightly convoluted way of checking if this is a pseudo-descriptor for a primitive type used in something like a DirectToManyMapping, in which case we can't rewrite. But if it's a pseudo-descriptor for a dictionary mapping where we actually use the mapping as the key rather than a class, then we're ok. It'd be nice if the code for this were more expressive."	descriptor := leftChild descriptor.	describedClass := descriptor describedClass.	(describedClass ~~ Association		and: [(descriptor session descriptorFor: describedClass) isNil])			ifTrue: [^self].	keyEquality := descriptor		primaryKeyExpressionFor: rightChild		basedOn: leftChild		relation: relation.	^keyEquality</body><body package="GlorpExpressions">rewriteEqualityExpressions	leftChild := leftChild rewriteEquality.	rightChild := rightChild rewriteEquality.</body><body package="GlorpExpressions">rewriteFunctionArguments	"If a function needs to adjust its arguments, do that here. The motivating example is one where a string argument is rewritten into a form that's of a different length, e.g. the Postgresql driver does that to strings in Blobs."	leftChild rewriteFunctionArgumentsWith: rightChild.</body><body package="GlorpExpressions">rightChildToRebuild	^rightChild.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions">printBasicSQLOn: aCommand withParameters: aDictionary 	aCommand nextPut: $(.	leftChild printSQLOn: aCommand withParameters: aDictionary.	self 		printComparisonTo: rightChild		withParameters: aDictionary		on: aCommand.	self printOracleOuterJoinOn: aCommand.	aCommand nextPut: $).</body><body package="GlorpExpressions">printBasicUnqualifiedSQLOn: aCommand withParameters: aDictionary 	aCommand nextPut: $(.	leftChild printUnqualifiedSQLOn: aCommand withParameters: aDictionary.	self 		printUnqualifiedComparisonTo: rightChild		withParameters: aDictionary		on: aCommand.	self printOracleOuterJoinOn: aCommand.	aCommand nextPut: $).</body><body package="GlorpExpressions">printComparisonTo: value withParameters: aDictionary on: aStream	"Horribly convoluted logic to handle the cases where the value might be a constant, an expression that results in a value (constant or parameter) or a regular expression, with the caveat that any value that turns out to be null has to be printed with IS NULL rather than = NULL."	| translated |	translated := self convertValueOf: value in: aDictionary.	translated isGlorpExpression		ifTrue:			[			translated canPrint ifTrue: [				self printRelationOn: aStream.				translated					printSQLOn: aStream					withParameters: aDictionary]]		ifFalse:			[self				printSimpleValueComparisonTo: translated				on: aStream].</body><body package="GlorpExpressions">printForANSIJoinTo: table on: aCommand	"Print ourselves as table {LEFT OUTER} JOIN otherTable ON criteria."	self isOuterJoin		ifTrue: [aCommand nextPutAll: ' LEFT OUTER JOIN ']		ifFalse: [aCommand nextPutAll: ' INNER JOIN '].	aCommand nextPutAll: table sqlTableName.	aCommand nextPutAll: ' ON '.	self printSQLOn: aCommand withParameters: aCommand parameters."ANSI makes shorter forms avaliable:  all or most compliant databases will accept JOIN for INNER JOIN and LEFT for LEFT OUTER JOIN.  ANSI also makes other forms available: RIGHT (long form RIGHT OUTER JOIN) swaps which table's unmatching rows are shown, while FULL (long form FULL OUTER JOIN) will show all the unmatched rows of both tables, and CROSS (long form CROSS JOIN) provides a cartesian product of the two tables.  The syntax 'table JOIN otherTable USING fieldNameList' can be used when the field names are common to both tables, while 'table JOIN otherTable NATURAL' means that all field names common to both tables define the join."</body><body package="GlorpExpressions">printMicrosoftOuterJoinOn: aCommand	self isOuterJoin ifFalse: [^self].	aCommand platform useMicrosoftOuterJoins ifTrue: [		aCommand nextPutAll: '*'].</body><body package="GlorpExpressions">printOracleOuterJoinOn: aCommand	self isOuterJoin ifFalse: [^self].	(self leftChild class == self class and: [self leftChild isOuterJoin]) ifTrue: [^self].	(self rightChild class == self class and: [self rightChild isOuterJoin]) ifTrue: [^self].	aCommand platform useOracleOuterJoins ifTrue: [		aCommand nextPutAll: ' (+) '].</body><body package="GlorpExpressions">printRelationOn: aStream	aStream space.	self printMicrosoftOuterJoinOn: aStream.	aStream 		nextPutAll: self relation;		space.</body><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions">printSimpleValueComparisonTo: value on: aStream	value isNil		ifTrue: [self printWithNullOn: aStream]		ifFalse:			[self printRelationOn: aStream.			self printValue: value on: aStream].</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	self leftChild hasImpliedClauses		ifTrue:			[| impliedClauses |			impliedClauses := self leftChild allRelationsFor: self.			impliedClauses outerJoin: self isOuterJoin.			impliedClauses				printSQLOn: aStream				withParameters: aDictionary]		ifFalse:			[self				printBasicSQLOn: aStream				withParameters: aDictionary].</body><body package="GlorpExpressions">printUnqualifiedComparisonTo: value withParameters: aDictionary on: aStream	"Horribly convoluted logic to handle the cases where the value might be a constant, an expression that results in a value (constant or parameter) or a regular expression, with the caveat that any value that turns out to be null has to be printed with IS NULL rather than = NULL."	| translated |	translated := self convertValueOf: value in: aDictionary.	translated isGlorpExpression		ifTrue:			[			translated canPrint ifTrue: [				self printRelationOn: aStream.				translated					printUnqualifiedSQLOn: aStream					withParameters: aDictionary]]		ifFalse:			[self				printSimpleValueComparisonTo: translated				on: aStream].</body><body package="GlorpExpressions">printUnqualifiedSQLOn: aStream withParameters: aDictionary	self leftChild hasImpliedClauses		ifTrue:			[| impliedClauses |			impliedClauses := self leftChild allRelationsFor: self.			impliedClauses outerJoin: self isOuterJoin.			impliedClauses				printUnqualifiedSQLOn: aStream				withParameters: aDictionary]		ifFalse:			[self				printBasicUnqualifiedSQLOn: aStream				withParameters: aDictionary].</body><body package="GlorpExpressions">printValue: value on: aCommand	"Glorp manipulations in a QuerySelectCommand may have caused me to be referenced from two places inside a larger expression, in which case, if binding, I must use the same bind marker in both places."	| type |	type := [self leftChild type]		on: Dialect error		do: [:ex | self error: 'Invalid comparison operation: ' , self printString].	(self useBindingFor: value to: type in: aCommand)		ifTrue: [^aCommand nextPutBindMarkerIn: self].	self expectsCollectionArgument		ifTrue: [type printCollection: value on: aCommand]		ifFalse: [type print: value on: aCommand].</body><body package="GlorpExpressions">printWithNullOn: aStream	aStream nextPutAll: ' IS '.	self relation = #&lt;&gt; ifTrue: [		aStream nextPutAll: 'NOT '].	aStream nextPutAll: 'NULL'.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>api</category><body package="GlorpExpressions">get: aSymbol withArguments: anArray	"We treat NOT as a function, so we have to check for functions here"	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^anArray size = 1		ifTrue: [RelationExpression named: aSymbol basedOn: self withArguments: anArray]		ifFalse: ["This is either an error, or something defined as a selector on relation expressions"			self perform: aSymbol withArguments: anArray.].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>converting</category><body package="GlorpExpressions">asField	^self</body><body package="GlorpExpressions">asGeneralGlorpExpression	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	| result |	result := self copy.	result leftChild: leftChild asGeneralGlorpExpression.	result rightChild: rightChild asGeneralGlorpExpression.	^result.</body><body package="GlorpExpressions">asGeneralGlorpExpressionWithFields	"Convert the result to a general (tree-format) expression, if it's the more limited join expression."	| result |	result := self copy.	result leftChild: leftChild asGeneralGlorpExpressionWithFields.	result rightChild: rightChild asGeneralGlorpExpressionWithFields.	^result.</body><body package="GlorpExpressions">asIndependentJoins	"If this is an ANDed clause whose two sides refer to two different (sets of) tables, split it into independent joins.  If both sides refers to the same tables, or one side's tables are a proper subset of the other (which could arise if one side compares to a constant), keep it together."	| oneSidesTables otherSidesTables temp |	relation == #AND ifFalse: [^Array with: self].	oneSidesTables := leftChild tablesForANSIJoin.	otherSidesTables := rightChild tablesForANSIJoin.	oneSidesTables size &gt; otherSidesTables size ifTrue:		[temp := otherSidesTables. otherSidesTables := oneSidesTables. oneSidesTables := temp].	(oneSidesTables allSatisfy: [:each | otherSidesTables includes: each])		ifTrue: [^Array with: self].	^(OrderedCollection withAll: leftChild asIndependentJoins)		addAll: rightChild asIndependentJoins;		yourself</body><body package="GlorpExpressions">asJoin	| leftField rightField |	leftField := self leftChild field.	rightField := self rightChild field.	(leftField notNil and: [rightField notNil]) ifTrue: [^Join from: leftField to: rightField].	^leftChild asJoin, rightChild asJoin.</body><body package="GlorpExpressions">convertedDbValueOf: anObject	"Assume that our types match, so we can ask either child to do the conversion. That isn't guaranteed, but should at least work for the common cases."	^leftChild convertedDbValueOf: anObject.</body><body package="GlorpDatabase">generalExpressionPart	| left right |	left := leftChild generalExpressionPart.	right := rightChild generalExpressionPart.	(left isNil and: [right isNil]) ifTrue: [^nil].	left isNil ifTrue: [^right].	right isNil ifTrue: [^left].	^self.</body><body package="GlorpExpressions">sourceForTarget: aField ifNone: aBlock	relation = #= ifFalse:		[^leftChild			sourceForTarget: aField			ifNone: [rightChild						sourceForTarget: aField						ifNone: aBlock]].	rightChild field == aField ifTrue: [^leftChild field].	leftChild field == aField ifTrue: [^rightChild field].	^aBlock value</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>copying</category><body package="GlorpExpressions">createFor: arguments withBase: anExpression symbol: aSymbol	"Create a copy of our expression with the given parameters. Used in function creation, for 'functions' like isNil that really just turn into relations."	^self class		named: relation		basedOn: anExpression		withArguments: (Array with: rightChild).</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>private/initializing</category><body package="GlorpExpressions">named: aSymbol basedOn: anExpression withArguments: anArray	| base right rightBase |	relation := self operationFor: aSymbol.	leftChild := anExpression.	"The only time we don't expect anExpression to have a base is if it's a constant, in which case the other side should be a variable expression and thus have a base."	base := anExpression canHaveBase ifTrue: [anExpression ultimateBaseExpression] ifFalse: [anArray first ultimateBaseExpression].	right := anArray first.	right isGlorpExpression ifFalse: [rightChild := right asGlorpExpressionOn: base. ^self].	rightBase := right ultimateBaseExpression.	rightChild := rightBase ~= base		ifTrue: [			right asGlorpExpressionOn: ((rightBase notNil and: [rightBase hasDescriptor]) ifTrue: ["Correlated subselect" rightBase] ifFalse: [base])]		ifFalse: [right].</body><body package="GlorpExpressions">operationFor: aSymbol	"Simple translation of operators"	aSymbol == #AND: ifTrue: [^#AND].	aSymbol == #&amp; ifTrue: [^#AND].	aSymbol == #OR: ifTrue: [^#OR].	aSymbol == #| ifTrue: [^#OR].	aSymbol == #~= ifTrue: [^#&lt;&gt;].	 aSymbol == #like: ifTrue: [^#LIKE].	 aSymbol == #ilike: ifTrue: [^#ILIKE].		"Case-insensitive variant of LIKE. Only supported on PostgreSQL at the moment"	 aSymbol == #in: ifTrue: [^#IN].	 aSymbol == #notIn: ifTrue: [^#'NOT IN'].	"ObjectStudio compatibility"       aSymbol == #os_LessThan: ifTrue: [^#&lt;].       aSymbol == #os_LessEqualThan: ifTrue: [^#&lt;=].       aSymbol == #os_Equal: ifTrue: [^#=].       aSymbol == #os_GreaterThan: ifTrue: [^#&gt;].       aSymbol == #os_GreaterEqualThan: ifTrue: [^#&gt;=].	^aSymbol.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>testing</category><body package="GlorpExpressions">canUseBinding	"Return true if we can use binding for our right child's value"	^self expectsCollectionArgument not.</body><body package="GlorpExpressions">expectsCollectionArgument	^self relationsWithCollectionArguments includes: relation.</body><body package="GlorpExpressions">isNeutralInPrimaryKeyExpression	"If subclasses are mapped to a horizontally-filtered table in which a field (or fields) filters which row holds data for which subclass, then Glorp will add it to query.  Such a field need not be a primaryKey.  For example, in a hierarchy of Vehicle subclassed to Car and Van, Glorp could convert Query read: Car where: [:e | e type = 'Jaguar'] into SQL 'SELECT ... FROM VEHICLE t1 WHERE t1.subcategory = 'C' AND t1.type = 'Jaguar'.  If field 'type' is the sole primaryKey of table VEHICLE - i.e filter field 'subcategory' is not part of the a primaryKey - then it is nevertheless quite safe (i.e. is unique) to look in the cache and accept a hit on an instance of Car whose type instVar holds 'Jaguar'.  The 'subcategory' field is neutral in the primaryKey expression.  It is not needed, because its value is already determined by the subclass, but it's presence does not mean the query is too detailed to be satisfied by a primaryKey check."	^rightChild class = ConstantExpression		and: [rightChild alias == FilteredTypeMapping name		and: [leftChild field isPrimaryKey not]]</body><body package="GlorpExpressions">shortCircuitOnNullComparison: parameters	"Return true if we represent an expression that compares null to a non-nullable value, so we don't ever need to really evaluate it.This could be more sophisticated and test if any part of an ANDed and not NOTed clause does such a comparison. But this will do for the most important cases"	| value |	outerJoin ifTrue: [^false].	value := rightChild valueIn: parameters.	^(relation == #=		and: [value isNil and: [leftChild field isNullable not]])</body><body package="GlorpExpressions">useBindingFor: aValue to: aType in: aCommand	"Return true if we can use binding for our right child's value, in the context of this command"	aCommand useBinding ifFalse: [^false].	self expectsCollectionArgument ifTrue: [^false].	^aCommand canBind: aValue to: aType.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>mapping</category><body package="GlorpExpressions">mappedFields	^Array with: self</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder	^self leftChild valueInBuilder: anElementBuilder as: self</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder as: anExpression	^self leftChild valueInBuilder: anElementBuilder as: anExpression</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>primary keys</category><body package="GlorpExpressions">assembleCompositePrimaryKeyFrom: anArray and: anotherArray	"The arrays will be the same size, unless one is neutral in primaryKey expressions (e.g. generated by a FilteredTypeMapping) in which case the parameter value will be DatabaseRow emptySlot.  If both have non-nil values in a given slot, those values will be the same.  This is caused by the calling method; the array is the size the table's composite primary key must be and the values are the values are derived from the field positions."	anArray == DatabaseRow emptySlot ifTrue: [^anotherArray].	anotherArray == DatabaseRow emptySlot ifTrue: [^anArray].	1 to: anotherArray size do:		[:index || other | other := anotherArray at: index.		other == DatabaseRow emptySlot ifFalse: [anArray at: index put: other]].	^anArray</body><body package="GlorpExpressions">primaryKeyFromDictionary: aDictionary	"Given a set of parameters, return a primary key suitable for retrieving our target. Do this only if the expression is for a primary key, and has no other conditions than the primary key one.  If the table's primary key is composite, return the array that will be needed with the found values in the right position and nils elsewhere.	A query that also has non-primaryKey values will throw away this attempt to get a cache-matching primary key, returning nil.  If it only has primaryKey fields but the set is incomplete, this method will return that set, with unmatchable values in the missing primaryKey rows (not nils:  if there were primaryKey fields unreferenced in the query but all were nillable, the incomplete set could accidentally match.)"	| left right field primaryKeyFields |	relation = #AND ifTrue:		[left := leftChild primaryKeyFromDictionary: aDictionary.		left isNil ifTrue: [^nil].		right := rightChild primaryKeyFromDictionary: aDictionary.		right isNil ifTrue: [^nil].		^self assembleCompositePrimaryKeyFrom: left and: right].	self isNeutralInPrimaryKeyExpression ifTrue: [^DatabaseRow emptySlot].	relation = #= ifFalse: [^nil].	field := leftChild fieldFromMeOrSubclasses.	field isNil ifTrue: [^nil].	field isGlorpExpression ifTrue: [^nil].	field isPrimaryKey ifFalse: [^nil].	primaryKeyFields := field table primaryKeyFields.	^primaryKeyFields size &gt; 1		ifFalse: [rightChild valueIn: aDictionary]		ifTrue:	"field table may be alias with PK fields of original, so (field table primaryKeyFields indexOf: field) would not find"			[(Array new: primaryKeyFields size withAll: DatabaseRow emptySlot)				at: ((1 to: primaryKeyFields size) detect: [:i | (primaryKeyFields at: i) position = field position])				put: (rightChild valueIn: aDictionary);				yourself]</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>inspecting</category><body package="GlorpExpressions">inspectorChildren	^Array with: leftChild with: rightChild</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>initialize-release</category><body package="GlorpExpressions">initialize	outerJoin := false.</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>joining</category><body package="GlorpExpressions">tableToJoinFrom: aTableCollection	"Return a table we could legitimately use at this point to write as an ANSI join, meaning that all but one must be already used and thus available, with one that isn't, where aTableCollection lists the used ones."	| possibleTables |	possibleTables := self tablesForANSIJoin select:		[:each | (aTableCollection includes: each) not].	^possibleTables size = 1 ifTrue: [possibleTables any]	"return nil otherwise"</body><body package="GlorpExpressions">tablesForANSIJoin	"Which tables will we join. Assumes this is a single-level join"	^self inject: Set new into: [:sum :each |		each tableForANSIJoin isNil ifFalse: [sum add: each tableForANSIJoin].		sum].</body></methods><methods><class-id>Glorp.RelationExpression</class-id> <category>constants</category><body package="GlorpExpressions">relationsWithCollectionArguments	^#(#IN #'NOT IN')</body></methods><methods><class-id>Glorp.RelationExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">named: aSymbol basedOn: anExpression withArguments: anArray	^self new		named: aSymbol		basedOn: anExpression		withArguments: anArray.</body></methods><methods><class-id>Glorp.CollectionExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary 	"Don't print the left child or ourselves, just the expression that is the right side.e.g. aPerson addresses anySatisfy: [:each | each city='Ottawa'] prints aswhere (address.city = 'Ottawa')The relation 'aPerson addresses' will ensure that the join gets printed"	rightChild printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.CollectionExpression</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Because our argument is a block, and the thing passed to it is our left child, we can assume that our left child will be referenced via that block. So we'll ignore it. This will help when condensing out primary key expressions, because otherwise us iterating over them forces them to stay around."	| |	(aSet includes: self) ifTrue: [^self].	aSet add: self.	rightChild do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>accessing</category><body package="GlorpQueries">= anObject	"In VA we inherit this as identity. Need to override"	^anObject = self getValue.</body><body package="GlorpQueries">isKindOf: aClass	self isInstantiated ifTrue: [^value isKindOf: aClass].	^false</body><body package="GlorpQueries">uninstantiate	value := nil.	isInstantiated := false.</body><body package="GlorpQueries">~= anObject 	^(self = anObject) not</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>overrides</category><body package="GlorpQueries">basicSize	^self getValue basicSize.</body><body package="GlorpQueries">hash	^self getValue hash.</body><body package="GlorpQueries">inspect	^self getValue inspect.</body><body package="GlorpQueries">isImmutable	^self getValue isImmutable.</body><body package="GlorpQueries">store	"For Object Studio compatibility"	^self inspectorString.</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>printing</category><body package="GlorpQueries">basicPrintOn: aStream 	aStream nextPut: ${.	isInstantiated 		ifTrue: [self getValue basicPrintOn: aStream]		ifFalse: [aStream nextPutAll: 'uninstantiated proxy'].	aStream nextPut: $}</body><body package="GlorpQueries">basicPrintString	| aStream |	aStream := WriteStream on: String new.	self basicPrintOn: aStream.	^aStream contents</body><body package="GlorpQueries">printOn: aStream 	aStream nextPut: ${.	isInstantiated 		ifTrue: [self getValue printOn: aStream]		ifFalse: [aStream nextPutAll: 'uninstantiated proxy'].	aStream nextPut: $}</body><body package="GlorpQueries">printString	| aStream |	aStream := WriteStream on: (String new: 16).	self printOn: aStream.	^aStream contents</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>api</category><body package="GlorpQueries">getValue	self subclassesMustImplement</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>notification</category><body package="GlorpQueries">glorpPostFetch: aSession</body><body package="GlorpQueries">glorpPostFetchValidate: aSession</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>dnu handling</category><body package="GlorpQueries">doesNotUnderstand: aMessage	^self getValue perform: aMessage selector withArguments: aMessage arguments.</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>initialize</category><body package="GlorpQueries">proxyInitialize	isInstantiated := false.</body></methods><methods><class-id>Glorp.AbstractProxy</class-id> <category>testing</category><body package="GlorpQueries">isGlorpProxy	^true.</body><body package="GlorpQueries">isInstantiated	isInstantiated isNil ifTrue: [isInstantiated := false].	^isInstantiated</body></methods><methods><class-id>Glorp.AbstractProxy class</class-id> <category>instance creation</category><body package="GlorpQueries">new	^super new proxyInitialize.</body></methods><methods><class-id>Glorp.AdHocProxy</class-id> <category>api</category><body package="GlorpQueries">getValue	self isInstantiated ifTrue: [^value].	[value := readBlock value] ensure: [isInstantiated := true].	^value</body><body package="GlorpQueries">glorpReadBlock: aZeroArgumentBlock	readBlock := aZeroArgumentBlock</body></methods><methods><class-id>Glorp.AdHocProxy</class-id> <category>printing</category><body package="GlorpQueries">printOn: aStream 	aStream nextPut: ${.	isInstantiated 		ifTrue: [self getValue printOn: aStream]		ifFalse: [aStream nextPutAll: 'uninstantiated AdHocProxy'].	aStream nextPut: $}</body></methods><methods><class-id>Glorp.AdHocProxy</class-id> <category>initialize</category><body package="GlorpQueries">proxyInitialize	super proxyInitialize.	readBlock := [nil]</body></methods><methods><class-id>Glorp.AdHocProxy</class-id> <category>accessing</category><body package="GlorpQueries">class	^AdHocProxy</body></methods><methods><class-id>Glorp.AdHocProxy class</class-id> <category>instance creation</category><body package="GlorpQueries">readBlock: aZeroArgumentBlock	^self new glorpReadBlock: aZeroArgumentBlock</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>attributes</category><body package="GlorpMappings">attributesDo: aBlock	attributes do: aBlock</body><body package="GlorpMappings">newAttributeNamed: aSymbol	^self addAttribute: (GlorpAttributeModel named: aSymbol).</body><body package="GlorpMappings">newAttributeNamed: aSymbol collection: collectionClass of: aClass	^self addAttribute: (GlorpAttributeModel named: aSymbol collection: collectionClass of: aClass).</body><body package="GlorpMappings">newAttributeNamed: aSymbol collectionOf: aClass	^self addAttribute: (GlorpAttributeModel named: aSymbol collectionOf: aClass).</body><body package="GlorpMappings">newAttributeNamed: aSymbol dictionaryFrom: keyClass to: valueClass	^self addAttribute: (GlorpAttributeModel named: aSymbol dictionaryFrom: keyClass to: valueClass).</body><body package="GlorpMappings">newAttributeNamed: aSymbol type: aClass	^self addAttribute: (GlorpAttributeModel named: aSymbol type: aClass).</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>accessing</category><body package="GlorpMappings">addAttribute: anAttributeDescription	attributes add: anAttributeDescription.	anAttributeDescription classModel: self.	^anAttributeDescription.</body><body package="GlorpMappings">attributeNamed: aSymbol	^attributes detect: [:each | each name = aSymbol] ifNone: [self newAttributeNamed: aSymbol].</body><body package="GlorpMappings">attributeNamed: aSymbol type: aClass	^attributes		detect:			[:each | each name = aSymbol and: [each type isNil or: [each type = aClass]]]		ifNone: [self newAttributeNamed: aSymbol type: aClass].</body><body package="GlorpMappings">attributeNamed: aSymbol type: aClass collectionType: collectionClass	^attributes		detect:			[:each | 			| collectionTypeMatches typeMatches nameMatches |			nameMatches := each name = aSymbol.			typeMatches := each type isNil or: [each type = aClass].			collectionTypeMatches := each collectionType isNil				or: [each collectionType = collectionClass].			nameMatches &amp; typeMatches &amp; collectionTypeMatches]		ifNone: [self newAttributeNamed: aSymbol type: aClass].</body><body package="GlorpMappings">attributes	^attributes.</body><body package="GlorpMappings">describedClass	^describedClass</body><body package="GlorpMappings">describedClass: aClass	describedClass := aClass.	subclasses := aClass allSubclasses isEmpty ifTrue: [nil] ifFalse: [aClass allSubclasses asArray].</body><body package="GlorpMappings">hasAttributeNamed: aSymbol	attributes do: [:attribute | attribute name = aSymbol ifTrue: [^true]].	^false</body><body package="GlorpMappings">privateAndBasicSetDescribedClass: aClass	"In theory, my parameter could answer true to glorpCanHaveDescriptorDirectly yet not understand subclasses. At time of writing, this is only possible in recursive queries."	aClass isBehavior		ifTrue: [self describedClass: aClass]		ifFalse: [describedClass := aClass].</body><body package="GlorpMappings">system	^system</body><body package="GlorpMappings">system: aDescriptorSystem	system := aDescriptorSystem.</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>printing</category><body package="GlorpMappings">printOn: aStream	aStream nextPutAll: '~~'.	self describedClass isNil ifFalse: [aStream nextPutAll: self describedClass name].	aStream nextPutAll: '~~'.</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>initializing</category><body package="GlorpMappings">initialize	attributes := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>validation</category><body package="GlorpMappings">matches: anObject	"Try to optimize this check as much as possible. We cache the list of subclasses, and inline the check for isKindOf:"	| theClass |	theClass := anObject glorpRealObject class.	describedClass == theClass ifTrue: [^true].	nil == subclasses ifTrue: [^false].	1 to: subclasses size do: [:i | theClass == (subclasses at: i)		ifTrue: [^true]].	^false.</body><body package="GlorpMappings">validateIn: aDescriptorSystem 	attributes do: [:each | each validate]</body></methods><methods><class-id>Glorp.GlorpClassModel class</class-id> <category>instance creation</category><body package="GlorpMappings">for: aClass	^self new describedClass: aClass.</body><body package="GlorpMappings">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpInvalidTypeError</class-id> <category>accessing</category><body package="GlorpMisc">defaultMessageText	^'Object being written does not match the type of the attribute: ''', self object printString,  ''' ~= ''' , self expectedType printString, ''''.</body><body package="GlorpMisc">expectedType	^expectedType</body><body package="GlorpMisc">expectedType: aGlorpClassModel	expectedType := aGlorpClassModel</body><body package="GlorpMisc">object	^object</body><body package="GlorpMisc">object: anObject	object := anObject</body></methods><methods><class-id>Glorp.QuerySelectCommand</class-id> <category>accessing</category><body package="GlorpDatabase">bindings	self useBinding ifFalse: [^#()].	self findBoundExpressions.	^boundExpressions collect: [:each | each bindingIn: self].</body><body package="GlorpDatabase">bindingTypes	self useBinding ifFalse: [^#()].	self findBoundExpressions.	^boundExpressions collect: [:each | each bindingType].</body><body package="GlorpDatabase">blockFactor	blockFactor isNil ifTrue: [blockFactor := query expectedRows].	^blockFactor.</body><body package="GlorpDatabase">boundExpressions	^boundExpressions</body><body package="GlorpDatabase">boundExpressions: anObject	boundExpressions := anObject</body><body package="GlorpDatabase">findBoundExpressions	self useBinding ifFalse: [^nil].	boundExpressions isNil ifFalse: [^nil].	boundExpressions := OrderedCollection new.	query addBoundExpressionsIn: self.</body><body package="GlorpDatabase">maximumLobSizeToRetrieveDirectly	^query isNil		ifTrue: [super maximumLobSizeToRetrieveDirectly]		ifFalse: [query maximumLobSizeToRetrieveDirectly].</body><body package="GlorpDatabase">printSQL	"We find bound expressions first, before processing any part of the statement;  see #testRetrieveComputed for an example of a bound expression in a select field.  We may be a subselect inside a statement which has already found all bound expressions of that statament (not just ours) and set us to have them, in which case, do not get them again."	self findBoundExpressions.	stream nextPutAll: 'SELECT '.	query printSelectFieldsOn: self.	query printTablesOn: self.	query printWhereClauseOn: self.	query printJoinsOn: self.	query printGroupingOn: self.	query printOrderingOn: self.	query printPostLimitOn: self.	query printOffsetOn: self.</body><body package="GlorpDatabase">query	^query.</body><body package="GlorpDatabase">query: aQuery	query := aQuery.</body></methods><methods><class-id>Glorp.QuerySelectCommand</class-id> <category>printing</category><body package="GlorpDatabase">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	query printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.QuerySelectCommand</class-id> <category>reporting</category><body package="GlorpDatabase">tables	^(self query tablesToPrint collect: [:each | each parent]) asSet.</body></methods><methods><class-id>Glorp.QuerySelectCommand</class-id> <category>executing</category><body package="GlorpDatabase">nextPutBindMarkerIn: aRelationExpression	"The ifAbsent case should probably raise an error - certainly it should if any are present."	| bindInteger |	bindInteger := self boundExpressions		indexOf: aRelationExpression		ifAbsent: [^super nextPutBindMarkerIn: aRelationExpression].	self nextPut: $:.	self nextPutAll: bindInteger printString.</body></methods><methods><class-id>Glorp.CompoundSelectCommand</class-id> <category>accessing</category><body package="GlorpCore">commands	commands isNil ifTrue: [commands := query queries collect: [:each | each sqlWith: parameters]].	^commands.</body><body package="GlorpCore">parameters: aDictionary	parameters := aDictionary.	commands := nil.</body></methods><methods><class-id>Glorp.CompoundSelectCommand</class-id> <category>testing</category><body package="GlorpCore">hasGrouping	^self query hasGrouping</body><body package="GlorpCore">hasOrdering	^self query hasOrdering</body><body package="GlorpCore">requiresDistinct	^self query requiresDistinct.</body><body package="GlorpCore">requiresWrapperQuery	^self requiresDistinct		or: [self hasOrdering			or: [self hasGrouping]]</body></methods><methods><class-id>Glorp.CompoundSelectCommand</class-id> <category>executing</category><body package="GlorpCore">printSQL	"Access doesn't like parentheses around the first in a group of compound commands.  A CompoundQuery can have a single command (usually only arises with recursive queries), which likewise allows (though it does not require) dropping the outer parentheses."	| skipFirst printParentheses |	self requiresWrapperQuery		ifTrue: [			self nextPutAll: 'SELECT '.			self requiresDistinct				ifTrue:  [ self nextPutAll: 'DISTINCT '].			self nextPutAll: '* FROM '.			self platform supportsAliasInCompoundQuery ifTrue: [self nextPut: $( ]].	skipFirst := self commands size &lt; 2 or: [self platform parenthesizeAllButFirstCommandInCompoundQuery].	printParentheses := self platform parenthesizeCommandsInCompoundQuery: query.	self findBoundExpressions.	GlorpHelper		do:			[:each |			each boundExpressions: self boundExpressions.			(printParentheses and: [skipFirst not])				ifTrue: [self nextPut: $(].			self nextPutAll: each sqlString.			(printParentheses and: [skipFirst not])				ifTrue: [self nextPut: $)].			skipFirst := false]		for: self commands		separatedBy: [query printOperationOn: self].	(self requiresWrapperQuery and: [self platform supportsAliasInCompoundQuery])		ifFalse:			[query printOrderingOn: self.			query printGroupingOn: self]		ifTrue: 			[self nextPut: $).			query printCompoundSelectAliasesOn: self].</body></methods><methods><class-id>Glorp.RecursiveCommand</class-id> <category>executing</category><body package="GlorpCore">printSQL	| recursionTable |	self nextPutAll: self platform withRecursive; space.	self platform isSQLite3Platform ifTrue:	"SQLite unions can only have limits at the end"		[self query unionQuery queries first limit: nil].	recursionTable := self query unionQuery queries last baseExpression descriptor table.	self nextPutAll: recursionTable name.	self nextPut: $(.	GlorpHelper		do: [:each | self nextPutAll: each name]		for: recursionTable fields		separatedBy: [self nextPut: $,; space].	self nextPut: $).	self nextPutAll: ' AS '.	self query ensureRecursionTableToPrint.	"We find boundExpressions earlier so as to have them before the recursive union prints."	self findBoundExpressions.	self recursiveUnionCommand boundExpressions: self boundExpressions.	self cr; nextPut: $(.	self nextPutAll: self recursiveUnionCommand sqlString.	self nextPut: $); cr.	super printSQL.</body></methods><methods><class-id>Glorp.RecursiveCommand</class-id> <category>accessing</category><body package="GlorpCore">recursiveUnionCommand	recursiveUnionCommand isNil ifTrue: [recursiveUnionCommand := query unionQuery sqlWith: parameters].	^recursiveUnionCommand</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">isVariableWidth	"Return true if this type allows varying length data within a particular instance. e.g., this is true for a varchar, but false for a fixed size character field"	^true.</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'varchar'.</body></methods><methods><class-id>Glorp.GlorpVarCharType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">typeString		^self typeName,   ( width ifNil: [''] ifNotNil: [ :w |'(', w printString, ')'])</body></methods><methods><class-id>Glorp.MySQLSequence</class-id> <category>sequencing</category><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	"A zero value indicates either the INSERT failed, or there is no IDENTITY column in the insert:  either way, an error."	| value |	value := anAccessor connection lastAutoIncrementValue asInteger.	value = 0 ifTrue: [self error: 'Bad IDENTITY column insert.'].	^aDatabaseRow at: aDatabaseField put: value</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aDatabaseField inRows: someDatabaseRows using: anAccessor	| firstValue |	firstValue := anAccessor connection lastAutoIncrementValue asInteger."The SQL equivalent to the above is	(anAccessor executeSQLString: 'SELECT LAST_INSERT_ID()') first atIndex: 1.We use the above to avoid the cost of a second round trip."	someDatabaseRows do:		[:ithrow |		ithrow at: aDatabaseField put: firstValue.		firstValue := firstValue + 1].</body><body package="GlorpDatabase">reserveSequenceNumbers: anInteger in: aSession for: aTable	"No real sequences here, just identity columns, which we can't pre-allocate"</body></methods><methods><class-id>Glorp.MySQLSequence</class-id> <category>testing</category><body package="GlorpDatabase">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>executing</category><body package="GlorpQueries">hasFieldTranslations	^self fieldTranslations notNil</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>accessing</category><body package="GlorpQueries">canCauseDuplicateRows	^false.</body><body package="GlorpQueries">cursor	^cursor</body><body package="GlorpQueries">cursor: aGlorpCursoredStream	cursor := aGlorpCursoredStream</body><body package="GlorpQueries">expression	^expression</body><body package="GlorpQueries">expression: anExpression	expression := anExpression.</body><body package="GlorpQueries">fieldTranslations	^fieldTranslations</body><body package="GlorpQueries">fieldTranslations: aDictionary 	fieldTranslations := aDictionary.</body><body package="GlorpQueries">instance	^instance</body><body package="GlorpQueries">instanceValue	^instance</body><body package="GlorpQueries">query	^query</body><body package="GlorpQueries">query: aQuery 	query := aQuery</body><body package="GlorpQueries">requiresDistinct	^expression requiresDistinct.</body><body package="GlorpQueries">requiresPopulating	^true</body><body package="GlorpQueries">returnValueIn: aCursoredStream	^self instance</body><body package="GlorpQueries">row	^row</body><body package="GlorpQueries">row: anArray	"Since nil is a possible key value, use self as a special marker to indicate we haven't found the key yet.  Logically we could check equality, not identity, of row and anArray - that would equally well guarantee that the primaryKey value(s), if present, were the same.  However a row could be huge and equality comparison very slow.  It is arguably both safer and quicker to re-extract the primaryKey value(s) from anArray if it is not identical to the prior row."	row == anArray ifFalse: [key := self].	row := anArray.</body><body package="GlorpQueries">session	^expression descriptor session.</body><body package="GlorpQueries">subBuilders	^#().</body><body package="GlorpQueries">system	^self session system.</body><body package="GlorpQueries">withAllSubBuilders	^Array with: self.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>building objects</category><body package="GlorpQueries">buildObjectFrom: anArray 	self subclassResponsibility.</body><body package="GlorpQueries">didValidationFail: validateResult	^validateResult == false.</body><body package="GlorpQueries">findInstanceForRow: aRow proxyType: proxyType	self subclassResponsibility.</body><body package="GlorpQueries">knitResultIn: aSimpleQuery	"Connect up our built object with any other builders that use the same thing"	^self.</body><body package="GlorpQueries">registerObjectInUnitOfWork	"If there is a current unit of work, then we must register in it, after population because that way the state is already in place. The nil checks are mostly for safety during unit tests, as those conditions should never occur in real use"	query isNil ifTrue: [^self].	query session isNil ifTrue: [^self].	query session register: instance.</body><body package="GlorpQueries">sendPostFetchValidateIn: aSession onFailureDo: aBlock	| validateResult |	validateResult := aSession sendPostFetchValidateEventTo: self instance.	(self didValidationFail: validateResult) ifTrue: aBlock.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries">fieldsForSelectStatement	^self subclassResponsibility.</body><body package="GlorpQueries">fieldsFromMyPerspective	self subclassResponsibility.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>translating fields</category><body package="GlorpQueries">translateFieldPosition: aDatabaseField 	fieldTranslations isNil ifTrue: [^aDatabaseField position].	^fieldTranslations at: aDatabaseField.</body><body package="GlorpDatabase">valueOf: anExpression	^expression valueInBuilder: self.</body><body package="GlorpDatabase">valueOfField: aField	"aField is either a database field, or a constant expression containing a non-varying value that isn't derived from the row"	(aField class == ConstantExpression) ifTrue: [^aField value].	^self row atIndex: (self translateFieldPosition: aField).</body><body package="GlorpDatabase">valueOfField: aField in: aRow	"The elementBuilder holds the row, so #valueOfField: is the recommended protocol in all ordinary cases.  An AdHocProxy's readBlock could be set by an AdHocMapping at one point, then evaluated later, after the ElementBuilder had been assigned another row.  This protocol remains for that case -  see #testReadAdHocProxied."	(aField class == ConstantExpression) ifTrue: [^aField value].	^aRow atIndex: (self translateFieldPosition: aField).</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>initializing</category><body package="GlorpQueries">initialize</body><body package="GlorpQueries">setup	"Do any initialization required once we've got our parameters"	^self.</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>copying</category><body package="GlorpQueries">copy	^self shallowCopy postCopy.</body><body package="GlorpQueries">onCompoundCursor: aGlorpCursoredStream	"This implementor returns self;  subimplementors may not."	^self cursor: aGlorpCursoredStream</body><body package="GlorpQueries">postCopy	instance := nil.	row := nil.	requiresPopulating := false.	isExpired := false.</body><body package="GlorpQueries">reconcileWithBuilders: oldCollection andCopy: newCollection</body></methods><methods><class-id>Glorp.ElementBuilder</class-id> <category>testing</category><body package="GlorpQueries">buildsObjects	^false.</body><body package="GlorpQueries">hasSetPrimaryKey	"I set key to self when I get a row (which we assume has happened before this is called).  Has it been reset to the row's primaryKey?"	^key ~~ self</body></methods><methods><class-id>Glorp.ElementBuilder class</class-id> <category>instance creation</category><body package="GlorpQueries">basicFor: anExpression in: aQuery	^(self basicClassFor: anExpression in: aQuery) new		expression: anExpression;		query: aQuery;		setup.</body><body package="GlorpQueries">for: anExpression in: aQuery	^(self classFor: anExpression in: aQuery) new		expression: anExpression;		query: aQuery;		setup.</body><body package="GlorpQueries">new	^super new initialize.</body></methods><methods><class-id>Glorp.ElementBuilder class</class-id> <category>private</category><body package="GlorpQueries">basicClassFor: anExpression in: aQuery	(anExpression hasDescriptor and: [anExpression mapsSimpleObject not]) ifFalse: [^DataElementBuilder].	anExpression canKnit ifFalse: [^ObjectBuilder].	anExpression mapping class == ConditionalMapping ifTrue: [^ConditionalBuilder].	anExpression mapping class == RecursiveMapping ifTrue: [^RecursiveBuilder].	^ObjectBuilder</body><body package="GlorpQueries">classFor: anExpression in: aQuery		((aQuery returnsDictionary and: [anExpression == aQuery baseExpression])		or: [anExpression returnsDictionary])			ifTrue: [^DictionaryBuilder].	^self basicClassFor: anExpression in: aQuery.</body></methods><methods><class-id>Glorp.SelectingElementBuilder</class-id> <category>building objects</category><body package="GlorpQueries">buildObjectFrom: anArray	^self.</body><body package="GlorpQueries">findInstanceForRow: aRow proxyType: proxyType	^self.</body><body package="GlorpQueries">returnValueIn: aCursoredStream	| builder |	builder := aCursoredStream privateGetBuilders		detect:			[:each |			each instance notNil and:				[each expression ~~ aCursoredStream command query baseExpression]]		ifNone:			[self error: 'Internal error in computing horizontal inheritance query.'].	^builder instance</body></methods><methods><class-id>Glorp.SelectingElementBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries">fieldsForSelectStatement	^#().</body><body package="GlorpQueries">fieldsFromMyPerspective	^#().</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>testing</category><body package="GlorpQueries">hasLimit	^self limit notNil.</body><body package="GlorpQueries">hasOffset	^self offset notNil and: [self offset &gt; 0].</body><body package="GlorpQueries">hasTracing	"Return true if we've given this query a tracing already"	^false.</body><body package="GlorpQueries">limitMakesSense	^self hasLimit not or: [self limit &gt; 0].</body><body package="GlorpQueries">requiresFullQuery	^false.</body><body package="GlorpQueries">returnTimedProxies	^proxyType == TimedProxy</body><body package="GlorpQueries">shortCircuitEmptyReturn	"If we have a literal false for criteria, we never need to go to the database.	We also don't need to go to database if limit doesnt make sense in terms of knowing beforehand that no results will be returned"	(whereClause class == EmptyExpression and: [whereClause isFalse]) ifTrue: [^true].	self limitMakesSense ifFalse: [^true].	^false.</body><body package="GlorpQueries">shortCircuitEmptyReturn: parameters	"If we have a literal false for criteria, we never need to go to the database.	We also don't need to go to database if limit doesnt make sense in terms of knowing beforehand that no results will be returned"	(whereClause class == EmptyExpression and: [whereClause isFalse])		ifTrue: [^true].	self limitMakesSense ifFalse: [^true].	self prepare.	(whereClause shortCircuitOnNullComparison: parameters) ifTrue: [^true].	^false.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>accessing</category><body package="GlorpQueries">baseExpression	^base.</body><body package="GlorpQueries">baseExpression: aBaseExpression	base := aBaseExpression.</body><body package="GlorpQueries">defaultTracing	| defaultTracing |	defaultTracing := Tracing new.	defaultTracing base: base.	^defaultTracing</body><body package="GlorpQueries">descriptor	^session descriptorFor: resultClass.</body><body package="GlorpQueries">expectedRows	"If we have set a limit, we cannot expect to get more rows back."	^self limit isNil		ifTrue: [super expectedRows]		ifFalse: [self limit]</body><body package="GlorpQueries">limit	^limit.</body><body package="GlorpQueries">limit: anInteger	limit := anInteger.</body><body package="GlorpQueries">offset	^offset</body><body package="GlorpQueries">offset: anObject	offset := anObject.</body><body package="GlorpQueries">proxyType	"Answer the type of proxies the receiver should build when instantiating objects:		nil - Do not build proxies.		TimedProxy - Build TimedProxies.		Proxy - Build Proxies."	^proxyType</body><body package="GlorpQueries">proxyType: aClass		proxyType := aClass.</body><body package="GlorpQueries">resultClass	^resultClass</body><body package="GlorpQueries">resultType	"Return the database type that we are expecting to return from this query. This only makes sense if we're returning a single field. If we return a collection of types, just return nil here. If we return a mapped object, the #type message will cause an exception."	self tracing retrievalExpressions size = 1 ifFalse: [^nil].	^self tracing retrievalExpressions asArray first type.</body><body package="GlorpQueries">returnProxies	^proxyType notNil</body><body package="GlorpQueries">returnProxies: aBoolean		aBoolean ifTrue: [proxyType := Proxy] ifFalse: [proxyType := nil].</body><body package="GlorpQueries">returnTimedProxies: aBoolean	aBoolean ifTrue: [proxyType := TimedProxy] ifFalse: [proxyType := nil]</body><body package="GlorpQueries">setUpBase	base := whereClause isGlorpExpression		ifTrue: [whereClause queryLevelBaseExpression]		ifFalse: [BaseExpression new].</body><body package="GlorpQueries">shouldRefresh	^shouldRefresh</body><body package="GlorpQueries">shouldRefresh: aBoolean	shouldRefresh := aBoolean</body><body package="GlorpQueries">tracing	tracing isNil ifTrue: [tracing := self defaultTracing].	^tracing.</body><body package="GlorpQueries">tracing: aTracing	tracing := aTracing.	tracing updateBase: base.	tracing setup.</body><body package="GlorpQueries">whereClause	^whereClause</body><body package="GlorpQueries">whereClause: anExpression	whereClause := anExpression.	self setUpBase.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>initialize</category><body package="GlorpQueries">initialize		super initialize.	proxyType := nil.	shouldRefresh := false.</body><body package="GlorpQueries">initResultClass: aClass whereClause: theCriteria singleObject: aBoolean 	resultClass := aClass.	self whereClause: ((theCriteria isNil or: [theCriteria = true or: [theCriteria = false]]) ifTrue: [EmptyExpression on: theCriteria] ifFalse: [theCriteria]).	readsOneObject := aBoolean.	aBoolean ifTrue: [self limit: 1].</body><body package="GlorpQueries">setUpBaseFromSession: aSession	"The parameter session should at least have the identical descriptor system instance as the session later supplied in the #execute: call, and this system should have its platform set.  Obviously, it is prudent simply to use the same session instance whenever possible.	The usual reason for calling this method will be to let the query be sent #retrieve: blocks and/or AND:/OR: blocks that contain aggregation functions (essential) and/or functions with platform-specificexpoansions (essential if the platform's expansion is not the default one)."    self session: aSession.    self setUpBase.    base descriptor:        (aSession system descriptorFor: self resultClass).</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>converting</category><body package="GlorpQueries">asFullQuery	^self.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>executing</category><body package="GlorpQueries">deleteFromDatabaseWithParameters: anArray	| command |	self descriptor classesRequiringIndependentQueries size &gt;1 ifTrue: [self error: 'Delete with where clause not yet supported for classes that cross tables.'].	self class ~~ SimpleQuery ifTrue: [self error: 'Non-simple queries not yet supported for deletes with where clauses'].	command := self deleteSqlWith: anArray.	"Should this duplicate the error handling in rowsFromDatabasewithParameters:?"	session accessor executeCommand: command returnCursor: false.	^command rowCount.</body><body package="GlorpQueries">deleteWithParameters: parameterArray in: aSession 	| |	session := aSession.	self checkValidity.	self setUpExpressions.	self setupTracing.	^self deleteFromDatabaseWithParameters: parameterArray.</body><body package="GlorpQueries">executeWithParameters: parameterArray in: aSession 	| |	session := aSession.	self requiresFullQuery 		ifTrue: [^self asFullQuery executeWithParameters: parameterArray in: aSession].	self checkValidity.	self setUpExpressions.	self checkCacheWithParameters: parameterArray ifPresent: [:hit | session register: hit. ^hit].	self setupTracing.	^self 		readFromDatabaseWithParameters: parameterArray.</body><body package="GlorpQueries">readFromDatabaseWithParameters: anArray	| answerStream result |	answerStream := self rowsFromDatabaseWithParameters: anArray.	^readsOneObject		ifTrue: [result := answerStream next. answerStream release. result]		ifFalse: [self resultCollectionFor: answerStream].</body><body package="GlorpQueries">rowsFromDatabaseWithParameters: anArray	self subclassResponsibility.</body><body package="GlorpQueries">setUpExpressions	(whereClause isGlorpExpression and: [whereClause queryLevelBaseExpression notNil])		ifTrue:			[base := whereClause queryLevelBaseExpression.			base hasDescriptor				ifFalse: [base descriptor: (session descriptorFor: resultClass)]]		ifFalse:			[base isNil ifTrue: [base := BaseExpression new].			base descriptor: (session descriptorFor: resultClass).			whereClause := whereClause asGlorpExpressionOn: base in: self].	ordering isNil		ifFalse:			[ordering := ordering				collect:					[:each | (self expressionBlockFor: each) asGlorpExpressionOn: base in: self]].	grouping isNil 		ifFalse:			[grouping := grouping				collect:					[:each | (self expressionBlockFor: each) asGlorpExpressionOn: base in: self]].			tracing isNil ifFalse: [tracing updateBase: base].	base descriptor typeResolver setUpExpressionsForQuery: self.</body><body package="GlorpQueries">validateWhereClause	resultClass glorpCanHaveDescriptorDirectly ifFalse: [self error: 'Invalid result class for query'].	whereClause isJoin ifFalse: [		whereClause do: [:each | each validate]].	tracing isNil ifTrue: [^self].	tracing allTracings do: [:eachTracing |		eachTracing do: [:eachExpressionNode | eachExpressionNode validate]].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>private</category><body package="GlorpQueries">privateAnd: anExpression	"AND these two together without checking for common bases, rebuilding, etc. Everything had better be right"	whereClause := whereClause AND: anExpression.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>copying</category><body package="GlorpQueries">copyAttributesTo: newQuery	"We're creating a new query similar to ourselves, but not a direct copy. Copy over the relevant attributes."	super copyAttributesTo: newQuery.	newQuery limit: self limit.	newQuery offset: self offset.	newQuery proxyType: self proxyType.	newQuery shouldRefresh: self shouldRefresh.</body><body package="GlorpQueries">postCopy	super postCopy.	base := BaseExpression new.	whereClause := whereClause asGlorpExpressionOn: base.	session isNil ifFalse: [self setUpExpressions].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>boolean operations</category><body package="GlorpQueries">AND: anExpression	"Allows you to send OR: directly to a query to build up a query dynamically without needing to mess with the criteria explicitly.  If anExpression is a block calling platform-specific functions, or aggregation functions such as #sqlCount or #isEmpty, you must set up the base (by sending #setUpBaseFromSession:) before calling this, but usually this will not be needed."	whereClause := (anExpression asGlorpExpressionOn: base)		AND: ((whereClause asGlorpExpressionOn: base) asGeneralGlorpExpression).</body><body package="GlorpQueries">except: aQuery	^self minus: aQuery.</body><body package="GlorpQueries">intersect: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^aQuery].	self shortCircuitEmptyReturn ifTrue: [^self].	^CompoundQuery newIntersect addQuery: self; addQuery: aQuery.</body><body package="GlorpQueries">minus: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^self].	self shortCircuitEmptyReturn ifTrue: [^aQuery].	^CompoundQuery newMinus addQuery: self; addQuery: aQuery.</body><body package="GlorpQueries">OR: anExpression	"Allows you to send OR: directly to a query to build up a query dynamically without needing to mess with the criteria explicitly.  If anExpression is a block calling platform-specific functions, or aggregation functions such as #sqlCount or #isEmpty, you must set up the base (by sending #setUpBaseFromSession:) before calling this, but usually this will not be needed."	whereClause := (anExpression asGlorpExpressionOn: base)		OR: (whereClause asGlorpExpressionOn: base) asGeneralGlorpExpression.</body><body package="GlorpQueries">unionAll: aQuery	aQuery shortCircuitEmptyReturn ifTrue: [^self].	self shortCircuitEmptyReturn ifTrue: [^aQuery].	^CompoundQuery newUnionAll addQuery: self; addQuery: aQuery.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>specifying retrievals</category><body package="GlorpQueries">alsoFetch: anExpression	self tracing alsoFetch: (self expressionBlockFor: anExpression).</body><body package="GlorpQueries">retrieve: anExpression	self tracing retrieve: (self expressionBlockFor: anExpression).</body><body package="GlorpQueries">retrieveAll: someExpressions	someExpressions do: [:each | self retrieve: each].</body><body package="GlorpQueries">retrieveMax: anExpression	self tracing retrieve: ((self expressionBlockFor: anExpression) asGlorpExpression get: #max).</body><body package="GlorpQueries">retrieveMin: anExpression	self tracing retrieve: ((self expressionBlockFor: anExpression) asGlorpExpression get: #min).</body><body package="GlorpQueries">retrieveSum: anExpression	self tracing retrieve: ((self expressionBlockFor: anExpression) asGlorpExpression get: #sum).</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>caching</category><body package="GlorpQueries">checkCacheWithParameters: aDictionary ifPresent: aBlock	| primaryKey result filteredResult |	readsOneObject ifFalse: [^nil].	self shouldRefresh ifTrue: [^nil].	"Check if we have retrieval expressions for something other than the base. If so, we're not actually reading this object, or at least not just this object"	self tracing retrievalExpressions do: [:each | each base isNil ifFalse: [^self]].	primaryKey := self primaryKeyFrom: aDictionary.	"The query did not specify all primary key fields or had other fields as well or similar."	primaryKey isNil ifTrue: [^nil].	"The query is for a horizontally-filtered subclass and had no fields (is Query readOneOf: MySubClass ?)."	primaryKey == DatabaseRow emptySlot ifTrue: [^nil].	"The query has null (or a null-equivalent value) in a foreign-key field (see #shouldForeignKeyValueBeTreatedAsNull). So we've found the entry, and we know it's nil."	primaryKey = #() ifTrue: [^aBlock value: nil].	"If it is expired, make sure we do the read but still refresh."  	(session hasExpired: resultClass key: primaryKey) ifTrue: [		self shouldRefresh: true.		^nil].	result := session 		cacheAt: primaryKey		forClass: resultClass		ifNone: [^nil].	filteredResult := session filterDeletionFrom: result.	^filteredResult isNil ifFalse:		[(session system shouldResetExpiryTimeForObjectOfClass: filteredResult class readFrom: self)			ifTrue: [self session markAsCurrentOfClass: filteredResult class key: primaryKey].		aBlock value: filteredResult].</body><body package="GlorpQueries">primaryKeyFrom: aDictionary	"Construct a primary key from the given parameters."	self prepare.	(aDictionary		anySatisfy:			[:each | self session system shouldForeignKeyValueBeTreatedAsNull: each])		ifTrue: [^#()].	^self whereClause primaryKeyFromDictionary: aDictionary.</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>preparing</category><body package="GlorpQueries">adjustWhereClause	^self.</body><body package="GlorpQueries">prepare	prepared ifTrue: [^self].	self setupTracing.	prepared := true.</body><body package="GlorpQueries">shouldExpressionBeJoin: anExpression	"Return true if the expression should be a join in our context (which means it refers only to tables we have in our from list) or if it should be ANDed into the where clause). Only relevant if we're using ANSI joins"	^anExpression		allSatisfy:			[:eachNode | 			| queryBase |			queryBase := eachNode queryLevelBaseExpression.			queryBase isNil or: [	queryBase = self baseExpression]].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>tracing</category><body package="GlorpQueries">setupTracing	self setUpExpressions.	self tracing setup.	self tracing additionalExpressions do:		[:each |		each hasDescriptor ifTrue:			[each descriptor trace: self tracing context: each].		each validate].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>validation</category><body package="GlorpQueries">checkValidity	resultClass glorpCanHaveDescriptorDirectly ifFalse: [self error: 'resultClass must be a class'].	self descriptor isNil ifTrue: [self error: 'No descriptor for ', self resultClass name].	(ordering notNil and: [self descriptor supportsOrdering not]) ifTrue: [self error: 'The descriptor for ', self resultClass name, ' does not support ordering in queries'].</body></methods><methods><class-id>Glorp.AbstractReadQuery</class-id> <category>recursing</category><body package="GlorpQueries">alsoFetchRecursively: aBlock retrieveAll: anArray defineThenFollow: aSymbol recursivelyRetrievingAll: anotherArray	"Make me the final query of a recursive read in which resultClass is not the base of recursion but something that alsoFetches that base.  (For now, this coding assumes that the most recent retrieve or alsoFetch call was the command to alsoFetch this base;  it just gets my last tracing as the recursionBase.)  Compute my initialQuery usng my resultClass and whereClause (but not my alsoFetch or retrieve).  The retrieve... array parameters will likely both contain a direct reference to that base' ancestral primaryKey(s), to allow syncronising returned rows with ancestral owning objects.  Likewise I will likely have a command ordering returned rows by that value and by their depth."	| initialQuery recursionBase |	initialQuery := self class read: self resultClass where: (self whereClause asGlorpExpressionOn: BaseExpression new).	self copyAttributesTo: initialQuery.	recursionBase := self tracing allTracings last.	self alsoFetch: aBlock.	^self asRecursiveQuery		fetchBaseExpression: recursionBase;		mappingDefiner: aSymbol;		retrievalMappingExpressions: anArray;		unionQuery:			(CompoundQuery newUnionAll				requiresDistinct: false;				addQuery: (initialQuery retrieveAll: anArray);				addQuery: ((initialQuery class read: self resultClass)							retrieveAll: anotherArray;							yourself));		yourself</body><body package="GlorpQueries">alsoFetchRecursively: aBlock retrieveAll: anArray thenFollow: aSymbol recursivelyRetrievingAll: anotherArray	"Make me the final query of a recursive read in which resultClass is not the base of recursion but something that alsoFetches that base.  (For now, this coding assumes that the most recent retrieve or alsoFetch call was the command to alsoFetch this base;  it just gets my last tracing as the recursionBase.)  Compute my initialQuery usng my resultClass and whereClause (but not my alsoFetch or retrieve).  The retrieve... array parameters will likely both contain a direct reference to that base' ancestral primaryKey(s), to allow syncronising returned rows with ancestral owning objects.  Likewise I will likely have a command ordering returned rows by that value and by their depth."	| initialQuery recursionBase |	initialQuery := self class read: self resultClass where: (self whereClause asGlorpExpressionOn: BaseExpression new).	self copyAttributesTo: initialQuery.	recursionBase := self tracing allTracings last.	self alsoFetch: aBlock.	^self asRecursiveQuery		fetchBaseExpression: recursionBase;		mappingToCloseOver: aSymbol;		retrievalMappingExpressions: anArray;		unionQuery:			(CompoundQuery newUnionAll				requiresDistinct: false;				addQuery: (initialQuery retrieveAll: anArray);				addQuery: ((initialQuery class read: self resultClass)							retrieveAll: anotherArray;							yourself));		yourself</body><body package="GlorpQueries">asRecursiveQuery	"Return a RecursiveQuery with my values.  Only call within a larger method that provides the additional values I will then need."	| newQuery |	newQuery := RecursiveQuery new.	newQuery requiresDistinct: false.	newQuery addQuery: self.	^newQuery</body><body package="GlorpQueries">retrieve: aSymbolOrBlock defineThenFollow: aSymbol recursivelyRetrieving: anotherSymbolOrBlock intersect: aQuery	"Convenience protocol - just a singular version of retrieveAll:...recursivelyRetrievingAll:..."	^self		retrieveAll: (Array with: aSymbolOrBlock)		defineThenFollow: aSymbol		recursivelyRetrievingAll: (Array with: anotherSymbolOrBlock)		intersect: aQuery</body><body package="GlorpQueries">retrieve: aSymbolOrBlock thenFollow: aSymbol recursivelyRetrieving: anotherSymbolOrBlock intersect: aQuery	"Convenience protocol - just a singular version of retrieveAll:...recursivelyRetrievingAll:..."	^aQuery asRecursiveQuery		mappingToCloseOver: aSymbol;		retrievalMappingExpressions: (Array with: aSymbolOrBlock);		unionQuery: (CompoundQuery newUnionAll					requiresDistinct: false;					addQuery: (self retrieve: aSymbolOrBlock);					addQuery: ((self class read: self resultClass)								retrieve: anotherSymbolOrBlock;								yourself));		yourself</body><body package="GlorpQueries">retrieveAll: anArray defineThenFollow: aSymbol recursiveQuery: aRecursionQuery retrievingAll: anotherArray intersect: aQuery	"As for retrieveAll:thenFollow:recursivelyRetrievingAll:where:intersect. but allowing a more detailed management of the recursion step, e.g. using the recurse mapping in the whereClause."	^aQuery asRecursiveQuery		mappingDefiner: aSymbol;		retrievalMappingExpressions: anArray;		unionQuery:			(CompoundQuery newUnionAll				requiresDistinct: false;				addQuery: (self retrieveAll: anArray);				addQuery: (aRecursionQuery retrieveAll: anotherArray));		yourself</body><body package="GlorpQueries">retrieveAll: anArray defineThenFollow: aSymbol recursivelyRetrievingAll: anotherArray intersect: aQuery	"Define the mapping in the recursive system, otherwise as for #retrieveAll:thenFollow:..."	^aQuery asRecursiveQuery		mappingDefiner: aSymbol;		retrievalMappingExpressions: anArray;		unionQuery:			(CompoundQuery newUnionAll				requiresDistinct: false;				addQuery: (self retrieveAll: anArray);				addQuery: ((self class read: self resultClass)							retrieveAll: anotherArray;							yourself));		yourself</body><body package="GlorpQueries">retrieveAll: anArray thenFollow: aSymbol recursiveQuery: aRecursionQuery retrievingAll: anotherArray intersect: aQuery	"As for retrieveAll:thenFollow:recursivelyRetrievingAll:where:intersect. but allowing a more detailed management of the recursion step, e.g. using the recurse mapping in the whereClause."	^aQuery asRecursiveQuery		mappingToCloseOver: aSymbol;		retrievalMappingExpressions: anArray;		unionQuery:			(CompoundQuery newUnionAll				requiresDistinct: false;				addQuery: (self retrieveAll: anArray);				addQuery: (aRecursionQuery retrieveAll: anotherArray));		yourself</body><body package="GlorpQueries">retrieveAll: anArray thenFollow: aSymbol recursivelyRetrievingAll: anotherArray intersect: aQuery	"Make me the initial query of a recursive read.  The retrieveAll array is an array of mapping names, all direct.  The mappingToCloseOver symbol is a self mapping that uses (all or some of) these direct mappings: it is the mapping whose closure we seek.  The retrieve arrays hold symbols or blocks (usually the latter) selecting what the iterative step will retrieve from the recursion table and/or, via the recurse mapping, from the main table(s).  Since both retrievals populate the same table, the two arrays must correspond in size and in ability to populate the same fields."	^aQuery asRecursiveQuery		mappingToCloseOver: aSymbol;		retrievalMappingExpressions: anArray;		unionQuery:			(CompoundQuery newUnionAll				requiresDistinct: false;				addQuery: (self retrieveAll: anArray);				addQuery: ((self class read: self resultClass)							retrieveAll: anotherArray;							yourself));		yourself</body></methods><methods><class-id>Glorp.AbstractReadQuery class</class-id> <category>instance creation</category><body package="GlorpQueries">newQuery	^SimpleQuery new.</body><body package="GlorpQueries">read: aClass	^self read: aClass where: nil</body><body package="GlorpQueries">read: aClass limit: anInteger	^self read: aClass where: nil limit: anInteger.</body><body package="GlorpQueries">read: aClass where: anExpression	^self read: aClass where: anExpression limit: nil</body><body package="GlorpQueries">read: aClass where: anExpression limit: anInteger	^(self newQuery)		limit: anInteger;		initResultClass: aClass whereClause: anExpression singleObject: false;		yourself</body><body package="GlorpQueries">readManyOf: aClass limit: anInteger	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:limit:).	^self read: aClass limit: anInteger</body><body package="GlorpQueries">readManyOf: aClass where: anExpression limit: anInteger	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:limit:).	^self read: aClass where: anExpression limit: anInteger</body><body package="GlorpQueries">readOneOf: aClass	^self readOneOf: aClass where: nil.</body><body package="GlorpQueries">readOneOf: aClass where: anExpression	^self newQuery		initResultClass: aClass		whereClause: anExpression		singleObject: true.</body><body package="GlorpQueries">returningManyOf: aClass	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:).	^self read: aClass</body><body package="GlorpQueries">returningManyOf: aClass limit: anInteger	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:limit:).	^self read: aClass limit: anInteger</body><body package="GlorpQueries">returningManyOf: aClass where: anExpression	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:).	^self read: aClass where: anExpression</body><body package="GlorpQueries">returningManyOf: aClass where: anExpression limit: anInteger	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:limit:).	^self read: aClass where: anExpression limit: anInteger</body><body package="GlorpQueries">returningOneOf: aClass	"returningOneOf: is a synonym of readOneOf:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #readOneOf:).	^self readOneOf: aClass.</body><body package="GlorpQueries">returningOneOf: aClass where: anExpression	"returningOneOf: is a synonym of readOneOf:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #readOneOf:where:).	^self readOneOf: aClass where: anExpression</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	aClass = Date ifTrue: [^self platform converterNamed: #timestampToDate].	^self platform converterNamed: #timestamp.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Dialect timestampClass.</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Timestamp.</body></methods><methods><class-id>Glorp.GlorpTimeStampType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">print: aValue on: aStream	"SQL in Oracle and SQLServer (which use type timestamp for dates as well as timestamps) supports adding an integer to a date, meaning incrementing the date by that number of days.  A bound integer value will go directly to the database layer;  an unbound value will go through here."	aValue isInteger ifTrue: [^self platform integer print: aValue on: aStream].	self platform printTimestamp: aValue on: aStream for: self.</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>types</category><body package="GlorpDatabase">bigint	^self typeNamed: #bigint ifAbsentPut: [GlorpIntegerType new typeString: 'bigint'].</body><body package="GlorpDatabase">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'bytea'].</body><body package="GlorpDatabase">boolean	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'boolean'].</body><body package="GlorpDatabase">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new typeName: 'character'].</body><body package="GlorpDatabase">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'text'].</body><body package="GlorpDatabase">date	^self typeNamed: #date ifAbsentPut: [GlorpDateType new typeString: 'date'].</body><body package="GlorpDatabase">decimal	^self numeric.</body><body package="GlorpDatabase">double	^self float8</body><body package="GlorpDatabase">float	^self float4.</body><body package="GlorpDatabase">float4	^self typeNamed: #float4 ifAbsentPut: [GlorpFloatType new].</body><body package="GlorpDatabase">float8	^self typeNamed: #float8 ifAbsentPut: [GlorpDoubleType new].</body><body package="GlorpDatabase">int	^self int4</body><body package="GlorpDatabase">int2	^self typeNamed: #int2 ifAbsentPut: [GlorpIntegerType new typeString: 'int2'].</body><body package="GlorpDatabase">int4	^self typeNamed: #int4 ifAbsentPut: [GlorpIntegerType new typeString: 'int4'].</body><body package="GlorpDatabase">int8	^self typeNamed: #int8 ifAbsentPut: [GlorpIntegerType new typeString: 'int8'].</body><body package="GlorpDatabase">numeric	^self typeNamed: #numeric ifAbsentPut: [GlorpNumericType new].</body><body package="GlorpDatabase">real	^self float4</body><body package="GlorpDatabase">sequence	^self serial</body><body package="GlorpDatabase">serial	"For postgresql, we use sequences, and explicitly get the values ourselves, so just tell the database that they're integers."	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'integer'].</body><body package="GlorpDatabase">smallint	^self int2</body><body package="GlorpDatabase">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time'].</body><body package="GlorpDatabase">timeStampTypeString	^'timestamp'.</body><body package="GlorpDatabase">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'timestamp without time zone'].</body><body package="GlorpDatabase">timestamptz	^self typeNamed: #timestamptz ifAbsentPut: [GlorpPGTimestampWithTimeZoneType new]</body><body package="GlorpDatabase">timetz	^self typeNamed: #timetz ifAbsentPut: [GlorpPGTimeWithTimeZoneType new].</body><body package="GlorpDatabase">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new typeName: 'character varying'].</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">byteArrayToSQLStringConverter	^DelegatingDatabaseConverter		named: #byteArrayToSQLString		hostedBy: self		fromStToDb: #convertByteArrayToSQLString:for:		fromDbToSt: #convertSQLStringToByteArray:for:.</body><body package="GlorpDatabase">convertSQLStringToByteArray: aString for: aType	| aStream str | 	aString isNil ifTrue: [^nil].	aStream := (ByteArray new: aString size // 4) writeStream.	str := aString readStream.	[str atEnd] whileFalse: [ |nextChar|		nextChar := str next.		aStream nextPut: (nextChar = $\								ifTrue: [str peek = $\											ifTrue: [str next asInteger]											ifFalse: [Number readFrom: (str next: 3) base: 8]]								ifFalse: [nextChar asInteger])	].	aStream close.	^aStream contents</body><body package="GlorpDatabase">encodeAsBase64String: aByteArray	"Pure inline of Base64FastCoder's method."	| output thirdTripletIndex firstQuartetIndex firstOfThree secondOfThree thirdOfThree remainder |	output := ByteString new: (aByteArray size / 3) ceiling * 4.	thirdTripletIndex := 3.	firstQuartetIndex := 1.	"Process all complete triplets."	[thirdTripletIndex &gt; aByteArray size] whileFalse: 			[firstOfThree := aByteArray at: thirdTripletIndex - 2.			secondOfThree := aByteArray at: thirdTripletIndex - 1.			thirdOfThree := aByteArray at: thirdTripletIndex.			output at: firstQuartetIndex				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'						at: ((firstOfThree bitAnd: 2r11111100) bitShift: -2) + 1).			output at: firstQuartetIndex + 1				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'						at: (((firstOfThree bitAnd: 2r00000011) bitShift: 4)								bitOr: ((secondOfThree bitAnd: 2r11110000) bitShift: -4)) + 1).			output at: firstQuartetIndex + 2				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'						at: (((secondOfThree bitAnd: 2r00001111) bitShift: 2)								bitOr: ((thirdOfThree bitAnd: 2r11000000) bitShift: -6)) + 1).			output at: firstQuartetIndex + 3				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'						at: (thirdOfThree bitAnd: 2r00111111) + 1).			thirdTripletIndex := thirdTripletIndex + 3.			firstQuartetIndex := firstQuartetIndex + 4].	"Process any final incomplete triplet."	remainder := thirdTripletIndex - aByteArray size.	remainder = 3 ifTrue: [^output].	firstOfThree := aByteArray at: thirdTripletIndex - 2.	output at: firstQuartetIndex		put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'				at: ((firstOfThree bitAnd: 2r11111100) bitShift: -2) + 1).	output at: firstQuartetIndex + 3 put: $=.	remainder = 1		ifFalse: 			["the byte array is missing two values of another triplet"			output at: firstQuartetIndex + 1				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'						at: ((firstOfThree bitAnd: 2r00000011) bitShift: 4) + 1).			output at: firstQuartetIndex + 2 put: $=]		ifTrue: 			["the byte array is only missing one value of another triplet"			secondOfThree := aByteArray at: thirdTripletIndex - 1.			output at: firstQuartetIndex + 1				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'						at: (((firstOfThree bitAnd: 2r00000011) bitShift: 4)								bitOr: ((secondOfThree bitAnd: 2r11110000) bitShift: -4)) + 1).			output at: firstQuartetIndex + 2				put: ('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'						at: ((secondOfThree bitAnd: 2r00001111) bitShift: 2) + 1)].	^output</body><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"If we cannot get the standard_conforming_strings state, assume the database is too old to understand it."	| standardConformingStrings |	charactersThatNeedEscaping isNil ifFalse: [^self].	standardConformingStrings :=		[aDatabaseAccessor executeSQLString: 'SHOW standard_conforming_strings']			on: Dialect error			do: [:ex |				(ex description indexOfSubCollection: 'standard_conforming_strings' startingAt: 1) = 0					ifFalse: [#(('off'))]					ifTrue: [ex pass]].	standardConformingStrings = #(('on'))		ifTrue: [charactersThatNeedEscaping := '''']	"escape single quote characters only"		ifFalse: [charactersThatNeedEscaping := '''\'].	"escape single quote and backslash"</body><body package="GlorpDatabase">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	Dialect isSqueak ifTrue: [^self squeakPrintBlob: aByteArray on: aStream for: aType].	aStream nextPutAll: (self encodeAsBase64String: aByteArray) printString</body><body package="GlorpDatabase">squeakPrintBlob: aByteArray on: aStream for: aType	aStream nextPut: $'.	aByteArray do: [:each |		aStream nextPutAll: '\\'.		each asInteger printOn: aStream paddedWith: $0 to: 3 base: 8].	aStream nextPutAll: '''::bytea'.</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase">printDate: aDate for: aType	"Print a date (or timestamp) as yyyy-mm-dd"	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $'.	self		printDate: aDate		isoFormatOn: stream.	stream nextPut: $'.	^stream contents.</body><body package="GlorpDatabase">printTime: aTime for: aType	"Print a time (or timestamp) as hh:mm:ss.fff"	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $'.	self		printTime: aTime		isoFormatOn: stream.	stream nextPut: $'.	^stream contents.</body><body package="GlorpDatabase">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPut: $'.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPutAll: ' '.	self		printTime: aTimestamp		isoFormatOn: stream.	stream nextPut: $'.</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>services tables</category><body package="GlorpDatabase">tableNameFor: aStringRepresentingATableName	"Return the table name, as modified to be used in a database statement."		^(aStringRepresentingATableName		detect: [:each | each isUppercase]		ifNone: [nil]) isNil	ifTrue: [aStringRepresentingATableName]	ifFalse: ['"' , aStringRepresentingATableName , '"'].</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>functions</category><body package="GlorpDatabase">initializeFunctions	"Postgres supports standard regex and also the ANSI SQL 'SIMILAR TO' form of regex, in which the % and _ of SQL's LIKE predicate replace the corresponding * and ? of regex."	super initializeFunctions.	functions at: #similarTo: put: (InfixFunction named: 'SIMILAR TO').	functions at: #regexMatches: put: (InfixFunction named: '~').</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated	^true.</body><body package="GlorpDatabase">charactersThatNeedEscaping	"We use the instvar's being set as a guard for all postInitialize values being set, so never set it alone.  The ifNil: value is a string containing a single quote."	^charactersThatNeedEscaping ifNil: ['''']</body><body package="GlorpDatabase">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^31</body><body package="GlorpDatabase">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^31</body><body package="GlorpDatabase">requiresTransactionForTableOperations	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"	^false.</body><body package="GlorpDatabase">sqlTextCurrentServerUTCTimestamp	^'SELECT CURRENT_TIMESTAMP AT TIME ZONE ''UTC'' '</body><body package="GlorpDatabase">supportsMillisecondsInTimes	"I think this depends on settings, but it's easier right now to just turn it off"	^false.</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>testing</category><body package="GlorpDatabase">isPostgreSQLPlatform	^true.</body><body package="GlorpDatabase">measuresStringFieldWidthsInBytes	"Return true if we measure the width of a string in bytes rather than characters. So, a 255-character field can hold 255 bytes worth of string, not 255 characters. This is important with encodings"	^true.</body><body package="GlorpDatabase">requiresCastsForNullsInUnions	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."	^true.</body><body package="GlorpDatabase">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax."	^true.</body><body package="GlorpDatabase">supportsBinding	"Binding works only with VW EXDI so far"	^Dialect isVisualWorks.</body><body package="GlorpDatabase">supportsCaseInsensitiveLike	^true.</body><body package="GlorpDatabase">supportsCompositeKeyArgsForOperand: aSymbol	"Strictly, the answer is		^#(#= #IN #&lt;&gt;) includes: aSymbolbut we take it for granted that we are never called on aSymbol that is not one of these values;  see the guard in #rewriteEquality.."	^true</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	"The 2.0 driver never supported binding but only pretended that it did to the upper-level EXDI API, reinserting the bound values as strings into an SQL stream that it then sent unbound to the server.  Thus it can inherit this unaltered.  The 3.0 drivers can group statements unbound.  If the serverVersion is 8.2 or newer, they can also group values in a single insert statement and they can do this unbound or bound."	^aCommand supportsGroupWriting</body><body package="GlorpDatabase">supportsLimit	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"	^true.</body><body package="GlorpDatabase">supportsOffset	"Do we support anything analogous to the postgresql OFFSET, skipping the first N rows"	^true.</body><body package="GlorpDatabase">supportsStringQueryOnBlobs	"If we are bound, the bytea = text comparison is illegal."	^self useBinding not</body><body package="GlorpDatabase">usesInformationSchema	^true</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	^true</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>type helpers</category><body package="GlorpDatabase">typesWithValues	super typesWithValues.	self bigint.	self date.	self decimal.	self double.	self float.	self float4.	self float8.	self int2.	self int.	self integer.	self numeric.	self real.	self sequence.	self serial.	self timetz.	self timestamptz.	^self types</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseSequenceClass	^PGSequence.</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>binding</category><body package="GlorpDatabase">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings.</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>database-specific</category><body package="GlorpDatabase">printOffset: anInteger on: aCommand	aCommand		nextPutAll: ' OFFSET '.	anInteger printOn: aCommand.</body><body package="GlorpDatabase">printPostLimit: anInteger on: aCommand	aCommand		nextPutAll: ' LIMIT '.	anInteger printOn: aCommand.</body><body package="GlorpDatabase">printReturningFieldsOn: aCommand	"Return current field value from an UPDATE statement, e.g.		UPDATE my_able SET field = field + 10 RETURNING fieldreturns the post-update (incremented by 10) value of field."	aCommand nextPutAll: ' RETURNING '.	GlorpHelper		do: [:nextField | aCommand nextPutAll: nextField name]		for: aCommand relativeFields		separatedBy: [aCommand nextPut: $,; space].</body><body package="GlorpDatabase">withRecursive	"Return the platform specific version of a common table expression that will recurse."	^'WITH RECURSIVE'</body></methods><methods><class-id>Glorp.PostgresPlatform</class-id> <category>commands</category><body package="GlorpDatabase">relativeUpdateCommand	"I can append to an update expression such that the post-update value will be returned in the same unit of work.  I use this ability when updating relative fields."	^ReturningUpdateCommand</body></methods><methods><class-id>Glorp.PostgresPlatform class</class-id> <category>constants</category><body package="GlorpDatabase">reservedWords	^#('all' 'analyse' 'analyze' 'and' 'any' 'array' 'as' 'asc' 'asymmetric' 'both' 'case' 'cast' 'check' 'collate' 'column' 'constraint' 'create' 'current_catalog' 'current_date' 'current_role' 'current_time' 'current_timestamp' 'current_user' 'default' 'deferrable' 'desc' 'distinct' 'do' 'else' 'end' 'except' 'false' 'fetch' 'for' 'foreign' 'from' 'grant' 'group' 'having' 'in' 'initially' 'intersect' 'into' 'leading' 'limit' 'localtime' 'localtimestamp' 'not' 'null' 'offset' 'on' 'only' 'or' 'order' 'placing' 'primary' 'references' 'returning' 'select' 'session_user' 'some' 'symmetric' 'table' 'then' 'to' 'trailing' 'true' 'union' 'unique' 'user' 'using' 'variadic' 'when' 'where' 'window' 'with')		asSet</body></methods><methods><class-id>Glorp.PostgresPlatform class</class-id> <category>testing</category><body package="GlorpDatabase">useBindingByDefault	^false</body></methods><methods><class-id>Glorp.PostgresSocketPlatform</class-id> <category>accessing</category><body package="GlorpDatabase">vwEXDIConnectionClass	^'PostgresSocketConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'PostgreSQL3EXDI'</body></methods><methods><class-id>Glorp.PostgresSocketPlatform</class-id> <category>testing</category><body package="GlorpDatabase">canRecurse	^canRecurse</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	"I can group statements unbound.  If the serverVersion is 8.2 or newer, I can also group bound (or unbound) values following a single insert statement."	^(super supportsGroupWritingFor: aCommand) and:		[self useBinding not or: [aCommand supportsGroupWritingValues]]</body><body package="GlorpDatabase">supportsGroupWritingValues	"Postgres versions earlier than 8.2 do not support a single INSERT statement followed by multiple VALUES statements;  read the version after login and cache whether the specific database installation that I represent does or not."	^supportsGroupWritingValues ifNil: [false]	"false is functionally safe, just slower"</body><body package="GlorpDatabase">supportsMultipleOpenCursors	"I appear to support interleaved readihg from two or more cursors on the same connection only because the EXDI layer connection buffers an executing session whenever another session asks to execute on the same connection."	^true</body></methods><methods><class-id>Glorp.PostgresSocketPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	| standardConformingStrings dbmsVersion |	charactersThatNeedEscaping isNil ifFalse: [^self].	"All values are set first time round, so we need only check one."	"Only the VWDatabaseAccessor calls this method at the moment, so we need not check	Dialect isVisualWorks ifFalse: [^super postLoginInitializeFromAccessor: aDatabaseAccessor]."	standardConformingStrings := aDatabaseAccessor connection standardConformingStrings.	standardConformingStrings = 'on'		ifTrue: [charactersThatNeedEscaping := '''']	"escape single quote characters only"		ifFalse: [charactersThatNeedEscaping := '''\'].	"escape single quote and backslash"	dbmsVersion := aDatabaseAccessor connection serverVersion tokensBasedOn: $..	supportsGroupWritingValues := self isVersion: #(8 2) notNewerThan: dbmsVersion.	canRecurse := self isVersion: #(8 4) notNewerThan: dbmsVersion.</body></methods><methods><class-id>Glorp.PostgresSocketPlatform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	"When unbound, Postgres can group ;-separated INSERT statements or (in 8.2 and after) ,-separated values following a single INSERT statement.  When bound, only the latter works.  We group using values in both cases, because we must when bound and to minimise the length of the round-trip SQL when unbound."	^(self supportsGroupWritingValues ifFalse: [InsertCommand] ifTrue: [InsertMultiValuesCommand])		forRows: aCollectionOfDatabaseRows		useBinding: aBoolean		session: aSession</body></methods><methods><class-id>Glorp.PostgresSocketPlatform</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"I have supported group writing since version 8.2 and recursion since 8.4.  For safety, we initialize to false, resetting in postLoginInitializeFromAccessor:."	super initialize.	canRecurse := false.	supportsGroupWritingValues := false.</body></methods><methods><class-id>Glorp.PostgresSocketPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Postgres Socket'</body></methods><methods><class-id>Glorp.SQLStringSelectCommand</class-id> <category>accessing</category><body package="GlorpDatabase">bindings	"We're not actually sure if we're part of a query with a where clause, or being used in a more ad hoc way. So if we have a query, use either our pre-set parameters, or the query's bindings, whichever produces more. In a tie, pick the query's bindings."	| queryBindings |	query isNil ifTrue: [^parameters].	queryBindings := super bindings.	^queryBindings size &gt;= parameters size 		ifTrue: [queryBindings]		ifFalse: [parameters].</body><body package="GlorpDatabase">bindingTypes	^query isNil ifTrue: [#()] ifFalse: [super bindingTypes].</body><body package="GlorpDatabase">blockFactor	blockFactor isNil ifTrue: [		blockFactor := query isNil ifTrue: [5] ifFalse: [super blockFactor]].	^blockFactor.</body><body package="GlorpDatabase">setSQLString: aString	sqlString := aString.</body></methods><methods><class-id>Glorp.SQLStringSelectCommand</class-id> <category>reporting</category><body package="GlorpDatabase">tables	^query isNil ifTrue: [Array with: #Unknown] ifFalse: [super tables].</body></methods><methods><class-id>Glorp.SQLStringSelectCommand</class-id> <category>sql</category><body package="GlorpDatabase">printSQL	"We assume the SQL is provided."	^self.</body></methods><methods><class-id>Glorp.SQLStringSelectCommand class</class-id> <category>As yet unclassified</category><body package="GlorpDatabase">sqlString: aString parameters: aDictionaryOrArray useBinding: aBoolean session: aSession	^(self new)		setSQLString: aString;		parameters: aDictionaryOrArray;		useBinding: aBoolean;		session: aSession.</body></methods><methods><class-id>Glorp.SQLite3PragmaCommand</class-id> <category>sql</category><body package="GlorpDatabase">printSQL	stream nextPutAll: 'PRAGMA '.	query resultClass = DatabaseField		ifTrue: [stream nextPutAll: 'table_info ('].	query resultClass = Glorp.SQLite3ForeignKeyData		ifTrue: [stream nextPutAll: 'foreign_key_list('].	query resultClass = Glorp.SQLite3IndexData		ifTrue: [stream nextPutAll: 'index_list('].	query resultClass = Glorp.SQLite3IndexColumnData		ifTrue: [stream nextPutAll: 'index_info('].	"query printSelectFieldsOn: self."	self findBoundExpressions.	"query printTablesOn: self."	query printWhereClauseOn: self.	stream nextPutAll: ')'	"query printJoinsOn: self.	query printOrderingOn: self.	query printGroupByOn: self.	query printPostLimitOn: self.	query printOffsetOn: self."</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>navigating</category><body package="GlorpExpressions">queryLevelBaseExpression	^self</body><body package="GlorpExpressions">ultimateBaseExpression	^trueBase ultimateBaseExpression</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>accessing</category><body package="GlorpExpressions">additionalExpressions	"We effectively take over the join for the thing we're based on, because we want it to happen in the subselect, not in the main one."	^trueBase additionalExpressionsOn: self.</body><body package="GlorpExpressions">base	^trueBase base.</body><body package="GlorpExpressions">descriptor	^trueBase descriptor.</body><body package="GlorpExpressions">field	^self trueBase mapping field.</body><body package="GlorpExpressions">join	^self trueBase join.</body><body package="GlorpExpressions">table	^self trueBase table.</body><body package="GlorpExpressions">trueBase	^trueBase</body><body package="GlorpExpressions">trueBase: aBaseExpression	trueBase := aBaseExpression.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>preparing</category><body package="GlorpExpressions">additionalExpressionsOn: anExpression	^trueBase additionalExpressionsOn: anExpression.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| newBase |	anExpression isNil ifTrue: [^aBaseExpression].	anExpression == self ifTrue: [^aBaseExpression].	newBase := trueBase rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	"If newBase == self, we've already reached this node on another branch and handled it - nothing more to do."	newBase == self ifFalse: [self trueBase: newBase].	^self</body><body package="GlorpExpressions">validate	super validate.	trueBase validate.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>testing</category><body package="GlorpExpressions">representsDerivedObject	^self trueBase representsDerivedObject</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>printing</category><body package="GlorpExpressions">className	^'SubSelectBase'.</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	"If I'm ever going to print this directly, it's because I'm participating in a direct to-many relationship, so I do have a valid field"	(self translateField: self field) printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression</class-id> <category>converting</category><body package="GlorpExpressions">convertedDbValueOf: anObject	^self trueBase mapping convertedDbValueOf: anObject.</body></methods><methods><class-id>Glorp.SubSelectBaseExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">on: aBaseExpression	^self new trueBase: aBaseExpression.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>testing</category><body package="GlorpQueries">hasEmptyWhereClause	"If we have regular where clause entries, or if we have joins that aren't going to be printed in the tables portion, then we're not empty"	whereClause willPrintAsWhereClause ifTrue: [^false].	self useANSIJoins ifTrue: [^true].	^joins isEmpty.</body><body package="GlorpQueries">hasTracing	"Return true if we've given this query a tracing already"	^builders notNil.</body><body package="GlorpQueries">mightHaveDuplicateRows	^builders anySatisfy: [:each | each canCauseDuplicateRows].</body><body package="GlorpQueries">requiresFullQuery	| descriptor independent |	descriptor := self descriptor.	"This isn't even a valid query."	descriptor isNil ifTrue: [^false].	independent := descriptor classesRequiringIndependentQueries.	^(independent size ~= 1) or: [(independent at: 1) ~= descriptor describedClass].</body><body package="GlorpQueries">useANSIJoins	useANSIJoins isNil ifTrue:		[useANSIJoins := self session platform supportsANSIJoins].	^useANSIJoins</body><body package="GlorpQueries">useANSIJoins: aBoolean	"On DB2, recursive expressions cannot use ANSI join syntax even though ordinary expressions can.  This allows a recursive query to set this limitation on its subqueries.  It can also be used to force the generated SQL to be written on the older syntax, which can be easier to read when debugging."	useANSIJoins := aBoolean.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>sql generation</category><body package="GlorpQueries">computeTablesToPrint	| allTables stoppingPoint |	allTables := Set new.	fields do: [:each | allTables addAll: each tablesToPrint].	stoppingPoint := base.	allTables		addAll:			(stoppingPoint isNil				ifTrue: [whereClause allTablesToPrint]				ifFalse: [whereClause allTablesToPrintStoppingAt: stoppingPoint]).	joins		do:			[:eachJoin | 			allTables				addAll:					(stoppingPoint isNil						ifTrue: [eachJoin allTablesToPrint]						ifFalse: [eachJoin allTablesToPrintStoppingAt: stoppingPoint])].	ordering isNil		ifFalse: [ordering do: [:each | 			each field isNil ifFalse: [allTables add: each field table]]].	grouping isNil		ifFalse: [grouping do: [:each |			each field isNil ifFalse: [allTables add: each field table]]].	self tracing allTracings		do: [:each | allTables addAll: each allTablesToPrint].	^allTables asSortedCollection.</body><body package="GlorpQueries">printANSITablesOn: aCommand	"Print ourselves using the JOIN... USING syntax. Note that we have to put the joins in the right order because we're not allowed to refer to tables not mentioned yet. Great syntax. Reminds me of Pascal. And so easy to deal with."	| printer |	printer := JoinPrinter for: self.	printer printJoinsOn: aCommand.</body><body package="GlorpQueries">printJoinsOn: aCommand	| noLeadIn|	self useANSIJoins ifTrue: [^self].	joins isEmpty ifTrue: [^self].	noLeadIn := whereClause isEmptyExpression.	noLeadIn ifFalse: [aCommand nextPutAll: ' AND ('].	GlorpHelper 			do: [:each | each printSQLOn: aCommand withParameters: aCommand parameters]			for: joins			separatedBy: [aCommand nextPutAll: ' AND '].	noLeadIn ifFalse: [aCommand nextPut: $)].</body><body package="GlorpQueries">printNormalTablesOn: aCommand	self printNormalTablesOn: aCommand excluding: #().</body><body package="GlorpQueries">printNormalTablesOn: aCommand excluding: aCollection	aCollection do: [:each | self tablesToPrint remove: each].	GlorpHelper		print: [:table | table sqlTableName]		on: aCommand		for: self tablesToPrint		separatedBy: ', '.	^self tablesToPrint.</body><body package="GlorpQueries">printOffsetOn: aCommand	self hasOffset ifFalse: [^self].	self platform printOffset: self offset on: aCommand.</body><body package="GlorpQueries">printPostLimitOn: aCommand	self hasLimit ifFalse: [^self].	self platform printPostLimit: self limit on: aCommand.</body><body package="GlorpQueries">printPreLimitOn: aCommand	self hasLimit ifFalse: [^self].	self platform printPreLimit: self limit on: aCommand.</body><body package="GlorpQueries">printSelectFields: aCollection on: stream	"A union of alsoFetching queries could have two fields of the same name (on different tables of course), which is an issue on SQLServer, Oracle and MySQL.  These platforms require the field to be aliased."	| fieldsToPrint fieldNames isDistinct |	isDistinct := false.	fieldNames := OrderedCollection new.	fieldsToPrint := aCollection collect:		[:each |		each isDistinct			ifFalse: [each]			ifTrue: [isDistinct := true.  each asField]].	isDistinct ifTrue: [stream nextPutAll: 'DISTINCT '].	self printPreLimitOn: stream.	"SQLServer needs TOP to come between DISTINCT and the fields."	GlorpHelper		do: [:field | field printSelectSQLOn: stream withParameters: fieldNames]		for: fieldsToPrint		separatedBy: [stream nextPut: $,; space].</body><body package="GlorpQueries">printSelectFieldsOn: stream      self printSelectFields: fields on: stream</body><body package="GlorpQueries">printTablesOn: aCommand	aCommand		cr;		nextPutAll: ' FROM '.	self useANSIJoins		ifTrue: [self printANSITablesOn: aCommand]		ifFalse: [self printNormalTablesOn: aCommand].</body><body package="GlorpQueries">printUnqualifiedNormalTablesOn: aCommand	self printUnqualifiedNormalTablesOn: aCommand excluding: #().</body><body package="GlorpQueries">printUnqualifiedNormalTablesOn: aCommand excluding: aCollection	aCollection do: [:each | self tablesToPrint remove: each].	GlorpHelper		print: [:table | table unqualifiedSqlTableName]		on: aCommand		for: self tablesToPrint		separatedBy: ', '.	^self tablesToPrint.</body><body package="GlorpQueries">printUnqualifiedTablesOn: aCommand	aCommand		cr;		nextPutAll: ' FROM '.	self printUnqualifiedNormalTablesOn: aCommand.</body><body package="GlorpQueries">printUnqualifiedWhereClauseOn: aCommand	self hasEmptyWhereClause		ifFalse:			[aCommand				cr;				nextPutAll: ' WHERE '.			whereClause printUnqualifiedSQLOn: aCommand withParameters: aCommand parameters].</body><body package="GlorpQueries">printWhereClauseOn: aCommand	self hasEmptyWhereClause		ifFalse:			[aCommand				cr;				nextPutAll: ' WHERE '.			whereClause printSQLOn: aCommand withParameters: aCommand parameters].</body><body package="GlorpQueries">signature	session useBinding ifFalse: [^''].	^self sqlWith: Dictionary new.</body><body package="GlorpQueries">sqlString	"Mostly for debugging"	^(self sqlWith: #()) sqlString.</body><body package="GlorpQueries">tablesToPrint	tablesToPrint isNil ifTrue: [tablesToPrint := self computeTablesToPrint].	^tablesToPrint.</body><body package="GlorpQueries">tablesToPrint: aCollection	tablesToPrint := aCollection.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>executing</category><body package="GlorpQueries">computeFields	builders 		do: [:each | self computeFieldsFor: each]</body><body package="GlorpQueries">computeFieldsFor: anElementBuilder 	| translatedFields |	translatedFields := self 		addFields: anElementBuilder fieldsForSelectStatement		returningTranslationForFields: anElementBuilder fieldsFromMyPerspective		distinct: anElementBuilder requiresDistinct.	anElementBuilder fieldTranslations: translatedFields.</body><body package="GlorpCore">deleteSqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copy.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^QueryDeleteCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body><body package="GlorpQueries">rowsFromDatabaseWithParameters: anArray	| alreadyTriedAction command |	(self shortCircuitEmptyReturn: anArray) ifTrue: [^session accessor cursorFor: (ReadStream on: #()) command: (self sqlWith: anArray)].	alreadyTriedAction := false.	command := self sqlWith: anArray.	^[session accessor		executeCommand: command		returnCursor: true] 	on: GlorpDatabaseReadError 	do: [:ex | 		alreadyTriedAction ifTrue: [ex pass] ifFalse: [alreadyTriedAction := true].		session errorAction isNil 			ifTrue: [ex pass] 			ifFalse: [				session errorAction value: ex value: session value: self.					ex retry]].</body><body package="GlorpQueries">setUpExpressions	super setUpExpressions.	self validateWhereClause.</body><body package="GlorpCore">sqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copy.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^QuerySelectCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>preparing</category><body package="GlorpQueries">addAllOrderingsForBuilder: aBuilder		| expression fieldExpressions |	expression := aBuilder expression.	fieldExpressions := expression descriptor primaryTable primaryKeyFields collect: [:each | expression getField: each].	fieldExpressions do: [:each | self addSingleOrderingForBuilder: each].</body><body package="GlorpQueries">addBoundExpressionsIn: aCommand	self joins , self fields , (Array with: self whereClause) do:		[:eachBigExpression |		eachBigExpression isGlorpExpression ifTrue:			[eachBigExpression do:				[:eachIndividualExpressionNode |				eachIndividualExpressionNode addBoundExpressionsIn: aCommand]]].</body><body package="GlorpQueries">addJoin: anExpression	^joins addAll: anExpression asIndependentJoins.</body><body package="GlorpQueries">addOrderingForToManyJoins	"If we have a join to a to-many relation, then we need for all the joined bits to be grouped together in order in the result set.  If we alsoFetch a to-many relation, we avoid limiting the alsoFetch and preserve its order."	| toManyBuilders baseBuilders fetchedToManyExpressions |	toManyBuilders := builders select: [:each | each canCauseDuplicateRows].	baseBuilders := toManyBuilders collect:		[:each |		builders			detect: [:eachBuilder | eachBuilder expression == each expression base]			ifNone: [nil]].	baseBuilders do: [:each | each isNil ifFalse: [self addAllOrderingsForBuilder: each]].	fetchedToManyExpressions := tracing alsoFetchExpressions select:		[:exp | toManyBuilders anySatisfy: [:each | exp = each expression]].	fetchedToManyExpressions isEmpty ifTrue: [^self].	"Fetching a toMany mapping interacts with setting a limit;  each base row can fetch many others."	self rewriteLimitFetchingToMany.	"A fetched toMany expression may be innately ordered in the descriptor system, even if not in the query."	fetchedToManyExpressions do:		[:alsoFetchExp || orderFields | orderFields := alsoFetchExp mapping orderBy.		orderFields isNil ifFalse:			[orderFields do:				[:orderField || orderExp | orderExp := self expressionBlockFor: orderField.				self addSingleOrderingForBuilder: (orderExp asGlorpExpressionOn: alsoFetchExp)]]].</body><body package="GlorpQueries">addSingleOrderingForBuilder: aFieldExpression	"Add the ordering to the query, as long as we don't already have an equivalent ordering there."		ordering isNil ifTrue: [^self orderBy: aFieldExpression].	ordering 		detect: [:eachExistingOrdering | 			eachExistingOrdering = aFieldExpression 				or: [eachExistingOrdering field = aFieldExpression field and: [eachExistingOrdering base = aFieldExpression base]]]		ifNone: [self orderBy: aFieldExpression].</body><body package="GlorpQueries">adjustWhereClause	"Make any adjustments to the where clause. This includes adjusting direct object equality expressions to be primary key comparisons, removing primary key comparisons where we can compare a foreign key, and condensing boolean constants out of expressions."	whereClause := whereClause rewriteEquality. "Special because otherwise we'd be throwing away the top-level one"	whereClause := whereClause rewriteBooleanEquality: nil.	whereClause do: [:each | each rewriteEqualityExpressions].	whereClause do: [:each | each condensePrimaryKeyComparisons].	whereClause := whereClause condensePrimaryKeyComparison.	whereClause := whereClause condenseBooleanEquality.	whereClause do: [:each | each condenseBooleanEqualityExpressions].	(whereClause isConstantExpression and: [whereClause value = true]) ifTrue:		[whereClause := EmptyExpression on: whereClause value.		whereClause base: base].	whereClause do: [:each | each rewriteFunctionArguments].</body><body package="GlorpQueries">aliasDuplicateFieldNames: orderedAliasingFieldExpressions	"On any database, ordering  a compound query by two same-name fields cannot be done.  Absurdly, Oracle, SQLServer and MySQL will not tolerate two unaliased fields in different tables but of the same name in a compound query, so aliasing may be needed merely to avoid that issue.  Alias the fields to avoid this after query preparation - so my 'fields' instvar is set."	| fieldNames |	fieldNames := OrderedCollection new.	1 to: self fields size do:		[:index || eachField aliasedFieldExpression | eachField := self fields at: index.		eachField class = DatabaseField ifTrue: 			[aliasedFieldExpression := orderedAliasingFieldExpressions				detect: [:eachExpression | eachExpression field = eachField or: [eachExpression field = eachField parentTableField]]				ifNone: [nil].			aliasedFieldExpression isNil ifTrue:	"if false, we've aliased it so no need to put its name in fieldNames"				[(fieldNames includes: eachField name)					ifFalse: [fieldNames add: eachField name]					ifTrue:						[aliasedFieldExpression :=							(FieldExpression forField: eachField basedOn: base) alias: eachField table name , eachField name, '_GEN']].			aliasedFieldExpression isNil ifFalse: [self fields at: index put: aliasedFieldExpression]]].</body><body package="GlorpQueries">assignTableAliases	| tableNumber allExpressions |	whereClause isJoin ifTrue: [^self].	tableNumber := 1.	allExpressions := whereClause asExpressionGroup.	allExpressions addAll: ordering.	allExpressions addAll: grouping.	allExpressions addAll: joins.	builders do: [:each | allExpressions add: each expression].	allExpressions do:		[:each | tableNumber := each assignTableAliasesStartingAt: tableNumber prefix: self tablePrefix].	"We've aliased tables, joins may now become independent"	joins := joins inject: OrderedCollection new into: [:sum :each | (sum addAll: each asIndependentJoins). sum].</body><body package="GlorpQueries">copyOfBuilders 	"Copy the builders, but make sure that subBuilders also get matched up"	| newBuilders |	newBuilders := builders collect: [:each | each copy].	newBuilders do: [:each | each reconcileWithBuilders: builders andCopy: newBuilders].	^newBuilders.</body><body package="GlorpQueries">fixJoins	| pseudoJoins realJoins |	pseudoJoins := joins select: [:each | each tablesForANSIJoin size &lt; 2].	pseudoJoins do: [:each | whereClause := each AND: whereClause].	realJoins :=  joins select: [:each| each tablesForANSIJoin size &gt;= 2].	joins := realJoins.</body><body package="GlorpQueries">isPrepared	^prepared.</body><body package="GlorpQueries">prepare	prepared ifTrue: [^self].	self setupTracing.	whereClause prepareIn: self.	self assignTableAliases.	self fixJoins.	self computeFields.	prepared := true.</body><body package="GlorpQueries">rewriteLimitFetchingToMany	"If we are reading just a single object but also fetching one (or more) one-to-many relationships, we need to get an unknown number of rows, not just one.   We can do this by matching an unlimited outer query (that fetches) to a limit 1 inner query (that does not fetch) by converting me from  e.g.	myQuery := Query readOneOf: MyClass where: [my query code].	myQuery alsoFetch: #myToManyMapping.to	myQuery := Query readOneOf: MyClass where:		[:each | each = (Query readOneOf: MyClass where: [my query code])].	myQuery alsoFetch: #myToManyMapping.	myQuery limit: nil.which works unless MyClass maps to a composite primaryKey (see the commented error clause near the start of this method).  By having a limit only on the inner query, we return the right number of rows:  the single row of the inner query is joined to however many rows match it in the alsoFetched table(s).  The inner query must not fetch so the each = expression will return only the primaryKey column and so match.  (If readsOneObject and: [limit ~= 1], we assume the user has already written the query in safe form, so do not rewrite:.)	We shallowCopy ourselves (without tracing, to drop the alsoFetches), wrap the copy in a GeneralSubSelectExpression, then rebuild the copyied query's whereClause (and other contents) so they are all re-based to a SubSelectBaseExpression on the phantom mapping.  (Arguably the creation of the subselect should have done this rebasing of contents, but it doesn't;  perhaps it assumes the whereClause will always still be a block at this point, not a glorp expression?)  We use basicRebuildOn:..., not rebuildOn:... to ensure content update while avoiding making another copy of the query (the phantom mapping already exists and has the first copy as its name)."	| subSelect |	"If we don't support limit, we may be inefficient but we can't hit this problem."	self platform supportsLimit ifFalse: [^self].	"For now, only fix the readsOneObject case to do what's intended;  ignore other limits."	self readsOneObject ifFalse: [^self].	"A limit 1 is initialized by readOneOf:.  If it has been reset by the user, hope they meant what they set!"	self limit = 1 ifFalse:	[^self].	"(nil is OK, but anInteger gets that many rows, not that many objects)"	"We were unable to alsoFetch a toMany relationship from a composite-keyed base when RelationExpression&gt;&gt;rewriteEquality could not handle that case for #=	self baseExpression descriptor primaryTable primaryKeyFields size &gt; 1 ifTrue:		[GlorpInvalidExpressionError signal: 'Cannot both limit query and alsoFetch a toMany relationship from a base whose table hasCompositePrimaryKey'].	This has now been fixed for almost all modern platforms, so we assume it is OK and omit the [primaryKeyFields size check.]"	"Set our copy's tracing to be nil, to get rid of the alsoFetched expressions."	subSelect := self cloneWithinQuery asGlorpExpressionOn: self baseExpression.	subSelect query		basicRebuildOn: subSelect query baseExpression		startingFrom: subSelect base		withOuterScopeBase: nil.	whereClause := RelationExpression		named: #=		basedOn: self baseExpression		withArguments: (Array with: subSelect).	self limit: nil.</body><body package="GlorpQueries">setupTracing	| |	builders isNil ifFalse: [^self].	"Already been done"	super setupTracing.	builders := tracing allTracings asArray		inject: #()		into:			[:sum :each | sum , (ElementBuilder for: each in: self) withAllSubBuilders].	self addOrderingForToManyJoins.</body><body package="GlorpQueries">traceExpressionInContextFor: anExpression	^anExpression rebuildOn: base.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>accessing</category><body package="GlorpQueries">builders	^builders.</body><body package="GlorpQueries">command: aDatabaseCommand	"Explicitly set the database command we will use. This is normally used in order to provide a SQLStringSelectCommand, and specify the sql for the query."	customCommand := aDatabaseCommand.</body><body package="GlorpQueries">elementBuilderFor: anExpression 	^builders detect: [:each | each expression == anExpression] ifNone: [nil].</body><body package="GlorpQueries">fields	fields isNil ifTrue: [self prepare].	^fields</body><body package="GlorpQueries">joins	^joins.</body><body package="GlorpQueries">queries	"A hack so you can write things that manipulate both this and compound queries the same way"	^Array with: self.</body><body package="GlorpQueries">sql: aString	"Specify the sql string to use for this query, instead of having it be generated. Note that doing this will override the normal sql generation mechanisms."	self command: (SQLStringSelectCommand new setSQLString: aString).</body><body package="GlorpQueries">tablePrefix	^tablePrefix</body><body package="GlorpQueries">tablePrefix: aString	tablePrefix := aString.</body><body package="GlorpQueries">where: anExpression	self deprecated: #(#version '8.2' #sunset '9.0' #use #whereClause:).	self whereClause: anExpression."Rewriting	Query read: MyClass where: [:each | ...]as	(Query read: MyClass) where: [:each | ...]can obscure that an initialEmptyExpression where clause is set, so we prefer	(Query read: MyClass) whereClause: [:each | ...]in the latter case.  The point is of no great importance;  we have (very debatably) chosen instance-side consistency (whereClause:) over class-creation/instance-manipulation consistency."</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>fields</category><body package="GlorpQueries">addFields: aliasedFields returningTranslationForFields: originalFields distinct: isDistinct	"The query has computed a set of fields the way the mappings see them, which are then transformed to account for field aliasing in embedded mappings. Add those to our collection, and set up the translation which knows which fields are at which index in the resulting row. If necessary, note that those fields are selected as distinct."	| translation |	translation := IdentityDictionary new.	aliasedFields with: originalFields do:		[:aliased :original || position fieldToAdd |		position := self findPositionOfAliasedField: aliased.		position = 0 ifTrue:			[fieldToAdd := isDistinct ifTrue: [aliased asDistinctFieldOn: self baseExpression] ifFalse: [aliased].			fields add: fieldToAdd.			position := fields size].		translation at: original put: position].	^translation</body><body package="GlorpQueries">findPositionOfAliasedField: aField	1 to: fields size do:		[:i || existingField | existingField := fields at: i.		(existingField asField isNil			ifTrue: [existingField isSameAliasedFieldAs: aField]			ifFalse: [existingField asField isSameAliasedFieldAs: aField]) ifTrue: [^i]].	^0</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>initialize</category><body package="GlorpQueries">flushTracing	tracing := nil.</body><body package="GlorpQueries">initResultClass: aClass whereClause: anExpression singleObject: aBoolean 	super 		initResultClass: aClass		whereClause: anExpression		singleObject: aBoolean.	prepared := false.	fields := OrderedCollection new.	joins := OrderedCollection new.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>printing</category><body package="GlorpQueries">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' for '.	aStream nextPutAll: (resultClass isNil ifTrue: ['nil'] ifFalse: [resultClass name]).</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>converting</category><body package="GlorpQueries">asFullQuery	| newQuery |	newQuery := ReadQuery new		initResultClass: resultClass whereClause: whereClause singleObject: readsOneObject.	self copyAttributesTo: newQuery.	newQuery setOrdering: ordering.	newQuery setGrouping: grouping.	^newQuery.</body><body package="GlorpQueries">asGlorpExpression	^self asGlorpExpressionOn: BaseExpression new.</body><body package="GlorpMappings">asGlorpExpressionOn: anExpression	"If we're being converted into an expression, that means we're a subselect inside an expression block. We don't actually have any relationship to anExpression, so create our own base and make a pseudo-mapping with no join to describe the relationship. Don't even give it a string-name, just use ourselves as the key"		| expression localBase phantomMapping phantomExpression |	phantomMapping := OneToOneMapping new		referenceClass: self resultClass;		attributeName: #temporaryAttributeFromSubselect;		join: Join new;		descriptor: (anExpression system descriptorFor: self resultClass).	phantomExpression := anExpression getMapping: phantomMapping named: self.	expression := GeneralSubSelectExpression 		basedOn: phantomExpression.	expression query: self.	localBase := SubSelectBaseExpression on: phantomExpression.	self baseExpression: localBase.	self tablePrefix: ('s', anExpression ultimateBaseExpression availableSubSelectNumber printString, 't').	^expression.</body><body package="GlorpQueries">asGlorpExpressionOn: anExpression basedOn: aMessageArchiver withUltimateBase: aBaseExpression	^self asGlorpExpressionOn: anExpression</body><body package="GlorpQueries">basicRebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	"Rebuild the query, which is part of a subselect expression, into the new context. The only thing that really matters here is that we get correlated subselect pieces inside the query right. The rest is independent of our main expression"	prepared := false.	builders := nil.	base := SubSelectBaseExpression on: (base trueBase rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression).	whereClause := whereClause asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression.	joins := joins collect: [:each | each asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression].	ordering isNil ifFalse: [ordering := ordering collect: [:each | each asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression]].	grouping isNil ifFalse: [grouping := grouping collect: [:each | each asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression]]."	fields := fields collect: [:each | each isGlorpExpression 		ifTrue: [each asGlorpExpressionOn: base withUltimateBase: ultimateBaseExpression]		ifFalse: [each]]."	fields := OrderedCollection new.</body><body package="GlorpQueries">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	"Rebuild the query, which is part of a subselect expression, into the new context. Don't do it if it's not necessary. But if it is necessary, also the copy the query. Otherwise two mappings using the same subselect query will mess each other up."	self == anExpression ifTrue: [^aBaseExpression].	self baseExpression ultimateBaseExpression == ultimateBaseExpression ifTrue: [^self].	^self shallowCopy basicRebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>private</category><body package="GlorpQueries">privateAddBuilder: anElementBuilder	builders := builders copyWith: anElementBuilder.</body><body package="GlorpQueries">privateReplaceBuilderWith: anElementBuilder	| oldBuilder |	oldBuilder := self elementBuilderFor: anElementBuilder expression.	oldBuilder isNil ifTrue: [self error: 'No builder found to replace.'].	builders at: (builders indexOf: oldBuilder) put: anElementBuilder.</body><body package="GlorpQueries">privateSetFields: aCollection	fields := aCollection.</body></methods><methods><class-id>Glorp.SimpleQuery</class-id> <category>copying</category><body package="GlorpQueries">cloneWithinQuery	"Clone me to assist in rewriting an expression.  Make minimal changes to the shallowCopy's internals so the clone will not accidentally acquire later changes that only pertain to the original.  Specifically, flush the trace to drop any alsoFetch: (either we rewrite to pair the original query with a copy that does not fetch, or fetching is irrelevant) and copy the fields collection so any later changes to it will not be on the same collection."	^self shallowCopy		flushTracing;		privateSetFields: self fields shallowCopy;		yourself</body><body package="GlorpQueries">postCopy	super postCopy.	fields := OrderedCollection new.	joins := OrderedCollection new.	builders := nil.	tablesToPrint := nil.</body></methods><methods><class-id>Glorp.SQLite3PragmaQuery</class-id> <category>sql generation</category><body package="GlorpQueries">printWhereClauseOn: aCommand	self hasEmptyWhereClause		ifFalse: 			[whereClause rightChild printSQLOn: aCommand withParameters: aCommand parameters]</body><body package="GlorpQueries">sqlWith: aDictionary	| result |	self prepare.	customCommand isNil ifFalse: [		result := customCommand copy.		result query: self; parameters: aDictionary; useBinding: session useBinding; session: session.		^result].	^SQLite3PragmaCommand		forQuery: self		parameters: aDictionary		useBinding: session useBinding		session: session.</body></methods><methods><class-id>Glorp.SQLite3PragmaQuery class</class-id> <category>instance creation</category><body package="GlorpQueries">newQuery	^SQLite3PragmaQuery new	"^super newQuery"</body></methods><methods><class-id>Glorp.DelegatingDatabaseConverter</class-id> <category>initialize-release</category><body package="GlorpDatabase">hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector	host := anObject.	stToDbSelector := stDbSelector.	dbToStSelector := dbStSelector</body><body package="GlorpDatabase">named: aSymbol hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector	name := aSymbol.	host := anObject.	stToDbSelector := stDbSelector.	dbToStSelector := dbStSelector</body></methods><methods><class-id>Glorp.DelegatingDatabaseConverter</class-id> <category>converting</category><body package="GlorpDatabase">convert: anObject fromDatabaseRepresentationAs: aDatabaseType 	^host perform: dbToStSelector with: anObject with: aDatabaseType</body><body package="GlorpDatabase">convert: anObject toDatabaseRepresentationAs: aDatabaseType 	^host perform: stToDbSelector with: anObject with: aDatabaseType.</body></methods><methods><class-id>Glorp.DelegatingDatabaseConverter class</class-id> <category>instance creation</category><body package="GlorpDatabase">hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector	^self new		hostedBy: anObject		fromStToDb: stDbSelector		fromDbToSt: dbStSelector</body><body package="GlorpDatabase">named: aSymbol hostedBy: anObject fromStToDb: stDbSelector fromDbToSt: dbStSelector	^self new		named: aSymbol		hostedBy: anObject		fromStToDb: stDbSelector		fromDbToSt: dbStSelector.</body></methods><methods><class-id>Glorp.SqueakDatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase">connectionArgsFromCurrentLogin	"connect string looks like  hostname:portNumber_db-name. :portNumber is optional"	| str portIndex index dbIndex |	str := self currentLogin connectString.	portIndex := index := str indexOf: $:.	dbIndex := str indexOf: $_.	index = 0 ifTrue: [index := dbIndex].	^(Dialect smalltalkAt: #PGConnectionArgs)		hostname: (str copyFrom: 1 to: index - 1)		portno: (portIndex = 0 ifTrue: [5432] ifFalse: [(str copyFrom: portIndex + 1 to: dbIndex - 1) asNumber])		databaseName: (str copyFrom: dbIndex + 1 to: str size)		userName: self currentLogin username		password: self currentLogin password</body><body package="GlorpDatabase">connectionClassForLogin: aLogin 	aLogin database class == PostgreSQLPlatform		ifTrue: [^ Smalltalk at: #PGConnection].	self error: 'Unknown database: ' , aLogin database</body><body package="GlorpDatabase">isLoggedIn	connection isNil		ifTrue: [^ false].	^ connection isConnected</body><body package="GlorpDatabase">loginIfError: aBlock 	self log: 'Login'.	self logOnly ifTrue: [^self].	connection := self connectionClass new.	connection connectionArgs: self connectionArgsFromCurrentLogin.	self		execute: [connection startup]		ifError: aBlock.	self log: 'Login finished'</body><body package="GlorpDatabase">logout	self isLoggedIn ifFalse: [^self].	self log: 'Logout'.	self logOnly ifTrue: [^self].	self execute: [connection terminate].	self log: 'Logout finished'</body><body package="GlorpDatabase">showDialog: aString 	"Do 'Smalltalk at: #PopUpMenu' so that the code will compile in other dialects, even if it won't run"	(Smalltalk at: #PopUpMenu) inform: aString</body></methods><methods><class-id>Glorp.SqueakDatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase">beginTransaction	self log: 'Begin Transaction'.	isInTransaction := true.	self logOnly ifTrue: [^self].	connection execute: 'BEGIN TRANSACTION'</body><body package="GlorpDatabase">commitTransaction	self log: 'Commit Transaction'.	isInTransaction := false.	self logOnly ifTrue: [^self].	connection execute: 'COMMIT TRANSACTION'</body><body package="GlorpDatabase">isInTransaction	^ isInTransaction</body><body package="GlorpDatabase">rollbackTransaction	self log: 'Rollback Transaction'.	isInTransaction := false.	self logOnly ifTrue: [^self].	connection execute: 'ROLLBACK TRANSACTION'</body></methods><methods><class-id>Glorp.SqueakDatabaseAccessor</class-id> <category>initialize</category><body package="GlorpDatabase">initialize	super initialize.	isInTransaction := false</body></methods><methods><class-id>Glorp.SqueakDatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase">basicExecuteSQLString: aString	| result rowCollection |	self log: aString.	self logOnly ifTrue: [^self].	result := connection execute: aString.	result errorResponse notNil		ifTrue:			[self externalDatabaseErrorSignal signal: result errorResponse value].	rowCollection := OrderedCollection new.	result rows do: [:ea | rowCollection add: ea data asArray]. 	^rowCollection asArray</body><body package="GlorpDatabase">basicExecuteSQLStringNoResult: aString doing: aBlock	| a |	a := self basicExecuteSQLString: aString.	aBlock value.	^a</body><body package="GlorpDatabase">disconnect	^ connection disconnect</body><body package="GlorpDatabase">executeCommandUnbound: aCommand	| answerStream |	self log: aCommand sqlString.	self logOnly ifTrue: [^self].	answerStream := ReadStream on: (self basicExecuteSQLString: aCommand sqlString).	"See new method #answerForCommand:fromDBSession: in VWDatabaseAccessor - it _may_ be advantageous to use something similar here "	aCommand needsRowCount ifTrue:		[aCommand rowCount:			((self platform supportsRowCountFor: aCommand)				ifTrue: [answerStream rowCount]				ifFalse: [1])].	^self cursorFor: answerStream command: aCommand</body><body package="GlorpDatabase">externalDatabaseErrorSignal	^ Dialect error</body><body package="GlorpDatabase">innerExceptionFor: exception	"I don't know how to get the inner error in Squeak"	^exception messageText.</body><body package="GlorpDatabase">releaseCursor: aCursor in: aPreparedStatement	"Release the cursor. We're trapping exceptions, so return true or false to indicate success/failure"	aCursor isNil ifTrue: [^self].	^[aCursor close. true] on: Dialect error do: [:ex | ex return: false].</body><body package="GlorpDatabase">rowCount	|count|	count := 0.	connection result resultSets		do: [:each| count := count + 			(each completedResponse value subStrings: (Array with: Character space)) last asInteger].	^count</body></methods><methods><class-id>Glorp.DuplicatePrimaryKeyException</class-id> <category>accessing</category><body package="GlorpCore">defaultMessageText	^'Duplicate objects with same primary key'.</body><body package="GlorpCore">existingObject	^existingObject</body><body package="GlorpCore">existingObject: anObject	existingObject := anObject</body><body package="GlorpCore">newObject	^newObject</body><body package="GlorpCore">newObject: anObject	newObject := anObject</body></methods><methods><class-id>Glorp.DuplicatePrimaryKeyException class</class-id> <category>instance creation</category><body package="GlorpCore">new: newObject existing: existingObject	^self new		newObject: newObject;		existingObject: existingObject;		yourself.</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^false.</body><body package="GlorpDatabaseTypes">isVariableWidth	^true.</body><body package="GlorpDatabaseTypes">requiresCast	^(self platform isPostgreSQLPlatform) or: [self platform isSQLServerPlatform]</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#LargeString.</body></methods><methods><class-id>Glorp.GlorpClobType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'text'.	width := nil.</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	^self platform converterNamed: #date.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Date.</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"VisualWorks EXDI assigns different symbols to dates on different platforms."	^self platform exdiTypeForDate</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'date'</body></methods><methods><class-id>Glorp.GlorpDateType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">print: aValue on: aStream	"SQL in Postgres and other databases supports adding an integer to a date, meaning incrementing the date by that number of days, so we can be presented with an integer value."	aValue isInteger ifTrue: [^self platform integer print: aValue on: aStream].	aStream nextPutAll: (self platform printDate: aValue for: self).</body></methods><methods><class-id>Glorp.GlorpSmallIntType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'smallint'.</body></methods><methods><class-id>Glorp.IdentityTypeMapping</class-id> <category>mapping</category><body package="GlorpMappings">mappedFields	^#()</body><body package="GlorpMappings">trace: aTracing context: anExpression	"do nothing"</body></methods><methods><class-id>Glorp.IdentityTypeMapping</class-id> <category>testing</category><body package="GlorpMappings">canBeTypeMappingParent	^false</body><body package="GlorpMappings">isAbstract	^false</body><body package="GlorpMappings">isTypeMappingRoot	^true</body></methods><methods><class-id>Glorp.InsertCommand</class-id> <category>accessing</category><body package="GlorpDatabase">arrayBoundFields	"For array binding, include all the fields, except if we're inserting into a database with identity columns, where we must omit those columns"	^self platform usesIdentityColumns		ifTrue: [row table fields reject: [:each | each type isIdentityColumn]]		ifFalse: [row table fields].</body><body package="GlorpDatabase">singleRowBoundFields	"Include only the fields that have values in our particular row"	^row nonGeneratedFieldsWithValues</body></methods><methods><class-id>Glorp.InsertCommand</class-id> <category>testing</category><body package="GlorpDatabase">supportsGroupWriting	^true</body></methods><methods><class-id>Glorp.InsertCommand</class-id> <category>executing</category><body package="GlorpDatabase">executeBoundInRoundTrip: anAccessor	"An inserted row may have a column whose value is set by the server;  get it."	super executeBoundInRoundTrip: anAccessor.	self postWriteAssignSequencesUsing: anAccessor.</body><body package="GlorpDatabase">executeUnboundInRoundTrip: anAccessor	"An inserted row may have a column whose value is set by the server;  get it."	super executeUnboundInRoundTrip: anAccessor.	self postWriteAssignSequencesUsing: anAccessor.</body><body package="GlorpDatabase">postWriteAssignSequencesUsing: anAccessor	"The default insert command does not check whether it has an identity column (a column whose value is set by the server) and cannot recover the set value in the same round trip.  Instead we iterate over the row's fields and make a follow-up query if needed to get the value.  The default approach gets the value in a follow-up query and so uses the Accessor."	row postWriteAssignSequencesUsing: anAccessor.</body><body package="GlorpDatabase">printSQL	self printSQLForFirstRow: row.	self hasMultipleRows ifFalse: [^self].	(self useBinding and: [self platform usesArrayBindingToGroupWrite]) ifTrue: [^self].	2 to: self allRows size do:		[:i | self printSQLForNextRow: (allRows at: i)].</body><body package="GlorpDatabase">printSQLForFirstRow: aRow	| fields |	self nextPutAll: 'INSERT INTO '.	aRow table printSQLOn: self withParameters: #().	fields := self shouldUseGroupWriting		ifTrue: [self arrayBoundFields]		ifFalse: [aRow nonGeneratedFieldsWithValues].	self space; nextPut: $(.	GlorpHelper		do: [:each | self nextPutAll: (self platform nameForColumn: each name)]		for: fields		separatedBy: [self nextPut: $,].	self nextPut: $).	self nextPutAll: '  VALUES ('.	GlorpHelper		do: [:each | (self canBind: (aRow at: each ifAbsent: [nil]) to: each type)					ifTrue: [self nextPutBindMarkerIn: nil]					ifFalse: [aRow printValueOfField: each on: self]]		for: fields		separatedBy: [self nextPut: $,].	self nextPut: $).</body><body package="GlorpDatabase">printSQLForNextRow: aRow	self nextPut: $;.	self space.	self printSQLForFirstRow: aRow.</body></methods><methods><class-id>Glorp.GlorpPGTimestampWithTimeZoneType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'TIMESTAMP WITH TIME ZONE'.</body></methods><methods><class-id>Glorp.GlorpPGTimestampWithTimeZoneType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	^#Timestamptz</body></methods><methods><class-id>Glorp.GlorpPGTimestampWithTimeZoneType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">print: aValue on: aStream	"Print as though we were a regular timestamp field, since we have no time zone information."	self platform timestamp print: aValue on: aStream.</body></methods><methods><class-id>Glorp.GlorpPGTimestampWithTimeZoneType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Dialect timestampClass</body></methods><methods><class-id>Glorp.InsertMultiValuesCommand</class-id> <category>executing</category><body package="GlorpDatabase">printConcatenatedValuesSQLFor: aRow	"Print the next row by concatenation, as in INSERT INTO table ... VALUES (row1), (row2), (row3).  Used in subclasses."	| fields |	fields := self arrayBoundFields.	self nextPut: $(.	GlorpHelper		do:			[:each |			(self canBind: (aRow at: each ifAbsent: [nil]) to: each type)				ifTrue: [self nextPutBindMarkerIn: nil]				ifFalse: [aRow printValueOfField: each on: self]]		for: fields		separatedBy: [self nextPut: $,].	self nextPut: $).</body><body package="GlorpDatabase">printSQLForNextRow: aRow	"For platforms where #usesArrayBindingToGroupWrite returns true, I will only be called if 'useBinding' is false."	self nextPut: $,.	self space.	self printConcatenatedValuesSQLFor: aRow.</body></methods><methods><class-id>Glorp.InsertMultiValuesCommand</class-id> <category>testing</category><body package="GlorpDatabase">supportsGroupWritingValues	"The version of the INSERT command that can concatenate values onto a command (as one way of group-writing) is only supported by some database platforms in some versions.  If the platform does, it will create an instance of me, or of a subclass that supportsGroupWriting, when asked to insert.  Logically, this should be implemented as	^self supportsGroupWritingnot just as true, but all callers will have already checked that."	^true</body></methods><methods><class-id>Glorp.InsertIdentityColumnCommand</class-id> <category>accessing</category><body package="GlorpDatabase">identityColumn: aDatabaseField	identityColumn := aDatabaseField.</body></methods><methods><class-id>Glorp.InsertIdentityColumnCommand</class-id> <category>executing</category><body package="GlorpDatabase">postWriteAssignSequencesUsing: anAccessor	"Ask the serial type how to assign multiple server-generated IDs to the IDENTITY column of my rows."	identityColumn type		postWriteAssignSequenceValueFor: identityColumn		inRows: allRows		using: anAccessor.</body></methods><methods><class-id>Glorp.InsertIdentityColumnCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase">forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession ifNoIdentityColumn: anInsertCommandClass	| identityColumn |	identityColumn := aCollectionOfDatabaseRows first table fields		detect: [:each | each type isIdentityColumn]		ifNone: [^anInsertCommandClass forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession].	^(self forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession)		identityColumn: identityColumn</body></methods><methods><class-id>Glorp.Case</class-id> <category>printing</category><body package="GlorpExpressions">printBasicSQLOn: aStream withParameters: aDictionary forSelect: aBoolean	"This prints e.g.		CASE base WHEN arg1 THEN arg2 ELSE arg3 END AS alias(the AS alias is optional).  Typically it appears in the Select statements of queries that are returning collection checks (e.g. retrieving an isEmpty boolean) that do not allow direct booleans in Select lists.	Our printing of constants with types is unfortunately tied up with relation expressions, so we shortcircuit some of the logic and just have the types print directly via		argumentType print: argument on: aStreamThis will not let us e.g. bind parameters to this function, but we don't expect to be doing that right now.  If the arguments are booleans, we expect them to be values, not boolean-valued ConstantExpressions;  see, for example, the #exists function in SQLPlatform&gt;&gt;initializeFunctions, and SQLPlatform&gt;&gt;printBoolean:for:.  In cases where there is no platform-handling behaviour and both value and ConstantExpression on value return the same to printSQL..., it does not matter."		aStream		nextPutAll: function;		nextPut: $(.	aBoolean		ifTrue: [base printSelectSQLOn: aStream withParameters: aDictionary]		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].	aStream nextPut: $).	1 to: arguments size do:		[:i || keyword argument argumentType |		keyword := #(' WHEN ' ' THEN ' ' ELSE ') at: i.		argument := arguments at: i.		argumentType := argumentTypes at: i.		aStream nextPutAll: keyword.		argumentType print: argument on: aStream].	aStream nextPutAll: ' END '.	alias notNil ifTrue:		[aStream			nextPutAll: 'AS ';			nextPutAll: alias].</body></methods><methods><class-id>Glorp.Case</class-id> <category>initialize-release</category><body package="GlorpExpressions">argumentTypes: anArray 	argumentTypes := anArray.</body><body package="GlorpExpressions">initialize	super initialize.	function := 'CASE'.	separator := ' '.	argumentTypes := OrderedCollection new: 3.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>accessing</category><body package="GlorpExpressions">alias	^alias</body><body package="GlorpExpressions">alias: aString	"What column name, if anything, should we print for 'as X' when retrieving"	alias := aString</body><body package="GlorpExpressions">base	^base.</body><body package="GlorpExpressions">basicField	^field.</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions">converterForStType: aClass	^self field converterForStType: aClass.</body><body package="GlorpExpressions">field	^base translateField: field</body><body package="GlorpExpressions">fieldExpression	^self.</body><body package="GlorpExpressions">impliedSmalltalkType	^self field impliedSmalltalkType.</body><body package="GlorpExpressions">name	^field name.</body><body package="GlorpExpressions">table	^self field table.</body><body package="GlorpExpressions">type	^self field type.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>navigating</category><body package="GlorpExpressions">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>printing</category><body package="GlorpExpressions">printOnlySelfOn: aStream 	base printsTable		ifTrue: [field printUnqualifiedSQLOn: aStream withParameters: #()]		ifFalse: [field printSQLOn: aStream withParameters: #()]</body><body package="GlorpExpressions">printTreeOn: aStream 	base printOn: aStream.	aStream nextPut: $..	base printsTable 		ifTrue: [field printUnqualifiedSQLOn: aStream withParameters: #()]		ifFalse: [field printSQLOn: aStream withParameters: #()]</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>As yet unclassified</category><body package="GlorpExpressions">convertedDbValueOf: anObject	"We don't do any conversion"	^anObject</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| result |	self == anExpression ifTrue: [^aBaseExpression].	result := (base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression) getField: field.	result alias: self alias.	^result.</body><body package="GlorpExpressions">tableForANSIJoin	^self field table.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters:aDictionary.	alias notNil ifTrue: [aStream nextPutAll: ' AS '; nextPutAll: alias].</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	self field printSQLOn: aStream withParameters:aDictionary.</body><body package="GlorpExpressions">printUnqualifiedSQLOn: aStream withParameters: aDictionary	self field printUnqualifiedSQLOn: aStream withParameters:aDictionary.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>initializing</category><body package="GlorpExpressions">field: aField base: anObjectExpression	field := aField.	base := anObjectExpression.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>preparing</category><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	| newTarget |	newTarget := (target allControlledTables includes: field table) 		ifTrue: [target]		ifFalse: [base asExpressionJoiningSource: source toTarget: target].	^newTarget getField: field.</body><body package="GlorpExpressions">tables	^base tables.</body><body package="GlorpExpressions">tablesToPrint	^Array with: self table</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree"	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>api</category><body package="GlorpExpressions">get: aSymbol withArguments: anArray	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	anArray isEmpty ifTrue: [self error: 'Field expressions do not have attributes'].	^RelationExpression named: aSymbol basedOn: self withArguments: anArray.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>testing</category><body package="GlorpExpressions">canBeUsedForRetrieve	"Return true if this is a valid argument for a retrieve: clause"	^true.</body><body package="GlorpExpressions">hasField	^true.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>copying</category><body package="GlorpExpressions">withTable: aTable	"Modify (do not copy) ourselves to use aTable. Presumably aTable is an aliased version of our table"	field := field withTable: aTable.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>mapping</category><body package="GlorpExpressions">mappedFields	^Array with: self field.</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder	^self valueInBuilder: anElementBuilder as: self field.</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder as: anExpression	^anElementBuilder valueOfField: anExpression.</body></methods><methods><class-id>Glorp.FieldExpression</class-id> <category>inspecting</category><body package="GlorpExpressions">inspectorChildren	^Array with: base</body></methods><methods><class-id>Glorp.FieldExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">forField: aField basedOn: anObjectExpression	^self new field: aField base: anObjectExpression; yourself</body></methods><methods><class-id>Glorp.InsertMultiValuesTablesCommand</class-id> <category>executing</category><body package="GlorpDatabase">printSQL	"This command works bound or unbound but for performance reasons is only ever run unbound, ensured by Oracle returning true to #usesArrayBindingToGroupWrite;  that would have to return false (and OraclePlatform&gt;&gt;bindingsForGroupWriting would need to call #batchStatementBindings) for it to run bound.  As Oracle is bound by default, this command is seldom run."	self nextPutAll: 'INSERT ALL '.	super printSQL.	self nextPutAll: ' SELECT * FROM DUAL'.</body><body package="GlorpDatabase">printSQLForFirstRow: aRow	"This class can only be used if shouldUseGroupWriting is true, so code in the super implementation that checks that has been inlined to true here."	| fields |	self nextPutAll: 'INTO '.	aRow table printSQLOn: self withParameters: #().	fields := self arrayBoundFields.	self space; nextPut: $(.	GlorpHelper		do: [:each | self nextPutAll: (self platform nameForColumn: each name)]		for: fields		separatedBy: [self nextPut: $,].	self nextPut: $).	self nextPutAll: '  VALUES ('.	GlorpHelper		do: [:each | (self canBind: (aRow at: each ifAbsent: [nil]) to: each type)					ifTrue: [self nextPutBindMarkerIn: nil]					ifFalse: [aRow printValueOfField: each on: self]]		for: fields		separatedBy: [self nextPut: $,].	self nextPut: $).</body><body package="GlorpDatabase">printSQLForNextRow: aRow	self space.	self printSQLForFirstRow: aRow.</body></methods><methods><class-id>Glorp.InsertMultiValuesTablesCommand</class-id> <category>testing</category><body package="GlorpDatabase">supportsGroupWritingValues	"The version of the INSERT command that can concatenate values onto a command (as one way of group-writing) is only supported by some database platforms in some versions.  If the platform does, it will create an instance of me, or of a subclass that supportsGroupWriting, when asked to insert.  Logically, this should be implemented as	^self supportsGroupWritingnot just as true, but all callers will have already checked that."	^true</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>accessing</category><body package="GlorpExpressions">base: anExpression	base := anExpression.</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions">descriptor	^base system descriptorFor: query resultClass.</body><body package="GlorpExpressions">mappedFields	"Ensure the subselect query is prepared;  its fields are the mapped fields."	query session: base descriptor session.	query prepare.	^query fields</body><body package="GlorpExpressions">query	^query</body><body package="GlorpExpressions">query: aQuery	query := aQuery</body><body package="GlorpExpressions">type	^query resultType.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>navigating</category><body package="GlorpExpressions">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>printing</category><body package="GlorpExpressions">printOnlySelfOn: aStream	" *** This method was defined by Glorp.GlorpExpression as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	| command |	aStream nextPutAll: '('.	self query session: aStream query session.	command := self query sqlWith: aDictionary.	command boundExpressions: aStream boundExpressions.	aStream nextPutAll: command sqlString.	aStream nextPutAll: ')'.</body><body package="GlorpExpressions">printTreeOn: aStream	aStream nextPutAll: 'subselect('.	query printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>converting</category><body package="GlorpExpressions">asJoin	" *** This method was defined by Glorp.GlorpExpression as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpExpressions">convertedDbValueOf: anObject	^anObject.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>preparing</category><body package="GlorpExpressions">addBoundExpressionsIn: aCommand	self query session: aCommand query session.	self query prepare.	self query addBoundExpressionsIn: aCommand</body><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	" *** This method was defined by Glorp.GlorpExpression as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuiltBase rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	rebuiltBase := base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	rebuilt := self copy.	rebuilt base: rebuiltBase.	rebuilt query: (query rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression).	^rebuilt."	^query asGlorpExpressionOn: aBaseExpression."</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>api</category><body package="GlorpExpressions">base	^base</body><body package="GlorpExpressions">get: aSymbol withArguments: anArray 	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body><body package="GlorpExpressions">getField: aField	"This is rather a hack on the use of get:, but I think it should be all right because we should never run into one of these in normal expression generation. The issue is that if we do an expression of the form (x = aQuery) where the query returns an object of the same class as X. We want to rewrite that into a primary key comparison for the database, so we want to do a get: against aQuery. But the only thing that seems to sensibly translate into is a retrieve: clause and return the query. That will only work for a single level get:, but I think that a multi-level one, from converting a block, shouldn't ever get to a general sub-select."	query retrieve: [:each | each getField: aField].</body><body package="GlorpExpressions">getMapping: aMapping named: aSymbol	"Suppose we do an expression of the form (x = aQuery) where the query returns an object of the same class as X. We want to rewrite that into a primary key comparison for the database, so we want to do a getMapping:named: against aQuery. But the only thing that seems to sensibly translate into is a retrieve: clause and return the query. That will only work for a single level get:, but I think that a multi-level one, from converting a block, shouldn't ever get to a general sub-select."	query retrieve: aSymbol.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>testing</category><body package="GlorpExpressions">isMappable	"Return true if we're something that can be returned in a select statement."	^false.</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression</class-id> <category>As yet unclassified</category><body package="GlorpExpressions">valueInBuilder: aGlorpDataElementBuilder 	"If we get here, it means we're being used in a #retrieve: or similar clause, which is only going to work if we have a single field, so assume that."	^self valueInBuilder: aGlorpDataElementBuilder as: query fields first</body><body package="GlorpExpressions">valueInBuilder: anElementBuilder as: anExpression	^anElementBuilder valueOfField: anExpression</body></methods><methods><class-id>Glorp.GeneralSubSelectExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">basedOn: anExpression	"The defining characteristic of a general subselect is that it doesn't care what it's based on. The base is just a convenient place to hang an independent expression. So make sure we're built on a true base, which won't print confusing stuff for us"	^self new base: anExpression ultimateBaseExpression.</body></methods><methods><class-id>Glorp.SQLite3Sequence</class-id> <category>sequencing</category><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession</body><body package="GlorpDatabase">name: aString	"We ignore names"</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	| value |	value := anAccessor connection lastAutoIncrementValue asInteger.	^aDatabaseRow at: aDatabaseField put: value</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aDatabaseField inRows: someDatabaseRows using: anAccessor	| lastValue |	lastValue := anAccessor connection lastAutoIncrementValue asInteger.	someDatabaseRows reverseDo:		[:ithrow |		ithrow at: aDatabaseField put: lastValue.		lastValue := lastValue - 1].</body><body package="GlorpDatabase">reserveSequenceNumbers: anInteger in: aSession for: aTable	"No real sequences here, just identity columns, which we can't pre-allocate"</body><body package="GlorpDatabase">schema: aString	"This is SQLite - we don't have schemas"</body></methods><methods><class-id>Glorp.SQLite3Sequence</class-id> <category>testing</category><body package="GlorpDatabase">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries">fieldsForSelectStatement	^self fieldsFromThePerspectiveOfTheMainSelect: self fieldsFromMyPerspective.</body><body package="GlorpQueries">fieldsFromMyPerspective	^query returnProxies 		ifTrue: [self descriptor table primaryKeyFields]		ifFalse: [self descriptor fieldsForSelectStatement]</body><body package="GlorpQueries">fieldsFromThePerspectiveOfTheMainSelect: aCollection	^expression translateFields: aCollection.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>printing</category><body package="GlorpQueries">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	expression printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>building objects</category><body package="GlorpQueries">buildObjectFrom: anArray	self row: anArray.	self requiresPopulating ifTrue: [self populateInstance].	(self system shouldResetExpiryTimeForObjectOfClass: instance class readFrom: self query)		ifTrue: [self session markAsCurrentOfClass: instance class key: self primaryKey].</body><body package="GlorpQueries">canBuild	"If we have a regular object with a nil primary key, or if we have an embedded object whose values are all nil, we can't build anything.  This could be due to an outer join, or to a ConditionalMapping whose representativeMapping is a relationship but whose current case is not."	^self descriptor mapsPrimaryKeys		ifTrue: [self primaryKey notNil]		ifFalse: [true]</body><body package="GlorpQueries">canCache	| keyFields |	keyFields := self descriptor keyFields.	^keyFields notNil and: [keyFields notEmpty].</body><body package="GlorpQueries">createObjectOfClass: aClass	"Try to create objects using new, so initialization can run. But if we can't do it, then just use basicNew."	^[aClass new] on: Error do: [:ex | ex return: aClass basicNew].</body><body package="GlorpQueries">findInstanceForRow: aRow proxyType: proxyType	instance := nil.	self row: aRow.	self canBuild ifFalse: [^self].	(self shouldProxyInstanceFor: proxyType)		ifTrue: [^self newProxyWithNewQueryForClass: proxyType].	self lookupCachedObject.	self instanceExistsButIsDeleted		ifTrue:			[instance := nil.			^self].	instance isNil		ifFalse:			[requiresPopulating := requiresPopulating | query shouldRefresh.			^self].	requiresPopulating := true.	instance := self createObjectOfClass: (self descriptor		describedConcreteClassFor: self row		withBuilder: self).	self canCache ifTrue: [self session cacheAt: self primaryKey put: instance].</body><body package="GlorpQueries">instanceDescriptor	"Return the descriptor for the instance we're going to build. Note that we have to look it up by instance in order to find subclass. "	| basicDescriptor |	instance isNil ifTrue: [^nil].	basicDescriptor := self system descriptorFor: instance.	basicDescriptor isNil ifFalse: [^basicDescriptor].	^expression descriptor.</body><body package="GlorpQueries">instanceExistsButIsDeleted	instance isNil ifTrue: [^false].	instance := self session filterDeletionFrom: instance.	^instance isNil.</body><body package="GlorpQueries">knitResultIn: aCursoredStream 	"Connect up our built object with any other objects that reference it. Used if we retrieve more than one thing in the same query"	| relatedBuilder |	expression canKnit ifFalse: [^self].	relatedBuilder := aCursoredStream objectBuilderFor: expression base.	(relatedBuilder isNil or: [relatedBuilder instance isNil]) 		ifFalse: 			[expression mapping knitFromBuilder: relatedBuilder toBuilder: self]</body><body package="GlorpQueries">lookupCachedObject	| resultClass |	self canBuild ifFalse: [^self].	self canCache ifTrue:		[resultClass := expression descriptor describedClass.		(self session hasExpired: resultClass key: self primaryKey)			ifTrue:				[instance := self session expiredInstanceOf: resultClass key: self primaryKey.				requiresPopulating := true.				isExpired := true]			ifFalse:				[instance := self session cacheLookupForClass: resultClass key: self primaryKey.				requiresPopulating := instance isNil]].</body><body package="GlorpQueries">newProxyWithNewQueryForClass: aClass	| parameters |	parameters := IdentityDictionary new.	self descriptor primaryTable primaryKeyFields		do:			[:eachField | parameters at: eachField put: (self valueOfField: eachField)].	instance := aClass new		session: self session;		parameters: parameters;		query: self queryForNewProxy.	self session addToReaper: instance.	^self.</body><body package="GlorpQueries">populateInstance	| tracker |	key isNil ifTrue: [^self].	self instanceDescriptor populateObject: instance inBuilder: self.	tracker := self session modificationTracker.	tracker isNil ifFalse: [tracker track: instance].</body><body package="GlorpQueries">queryForNewProxy	"Create a proxy with a primary key query in which the parameters are the primary key fields. We can't just reuse a mapping's query, it has to be a new primary key one, because the mapping's query has just run and been told to return proxies. This kind of stinks"	| whereExpression |	whereExpression := Join new.	self descriptor primaryTable primaryKeyFields do: [:eachField | 		whereExpression addSource: eachField target: eachField].	^Query		readOneOf: query resultClass 		where: whereExpression</body><body package="GlorpQueries">shouldProxyInstanceFor: proxyType	^proxyType notNil.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>accessing</category><body package="GlorpQueries">cachedQueryFor: aMapping	^self queryCache at: aMapping ifAbsent: [nil].</body><body package="GlorpQueries">cachedQueryFor: aMapping is: aQuery	"Save a query which we will use when constructing filtered queries"	self queryCache at: aMapping put: aQuery.</body><body package="GlorpQueries">canCauseDuplicateRows	^expression class == MappingExpression and: [expression mapping isToManyRelationship].</body><body package="GlorpQueries">command	^cursor command.</body><body package="GlorpQueries">descriptor		^expression descriptor.</body><body package="GlorpQueries">instance: anObject	instance := anObject</body><body package="GlorpQueries">primaryKey	"We use self as a special guard value to indicate that we have not already found the key."	key == self ifFalse: [^key].	self canCache ifFalse: [^nil].	key := self descriptor keyFields collect: [:each | self valueOfField: each].	"If we get here, we have a collection of one or more primaryKey values.  If there is only one, key is set to be that sole value (to be economical and performant - or, it might be claimed, 'clever').  Of course, this means we must make all accesses robust to the fact that it might be a value or a collection of values.  Here we ensure that a nil check also works when the original was #(nil nil ... nil) as well as when it was #(nil).  Arguably we need only check the first value for nil since a primaryKey value should not be NULL, but let's let any cases of e.g. #(nil 27) proceed since they would probably indicates errors we want to see and fix."	key size = 1		ifTrue: [key := key first]		ifFalse: [(key allSatisfy: [:each | each isNil]) ifTrue: [key := nil]].	^key</body><body package="GlorpQueries">queryCache	queryCache isNil ifTrue: [queryCache := IdentityDictionary new: 5].	^queryCache.</body><body package="GlorpQueries">requiresPopulating	^requiresPopulating and: [self returnProxies not].</body><body package="GlorpQueries">requiresPopulating: aBoolean	requiresPopulating := aBoolean</body><body package="GlorpQueries">returnProxies	^query returnProxies.</body><body package="GlorpQueries">returnValueIn: aCursoredStream	"If we're a to-many relationship, what we retrieve: is the collection containing us, not the individual items"	| relatedBuilder |	expression canKnit ifFalse: [^self instance].	expression mapping isToManyRelationship ifFalse: [^self instance].	relatedBuilder := aCursoredStream elementBuilderFor: expression base.	(relatedBuilder isNil or: [relatedBuilder instance isNil]) ifTrue: [^self instance].	^expression mapping getValueFrom: relatedBuilder instance.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>initializing</category><body package="GlorpQueries">initialize	requiresPopulating := false.	isExpired := false.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>copying</category><body package="GlorpQueries">postCopy	super postCopy.	queryCache := nil.</body></methods><methods><class-id>Glorp.ObjectBuilder</class-id> <category>testing</category><body package="GlorpQueries">buildsObjects	^true.</body></methods><methods><class-id>Glorp.ConditionalBuilder</class-id> <category>accessing</category><body package="GlorpQueries">fieldTranslations: aDictionary	"We need the conditionalField to deduce our mapping for each row.  If that fields is not in the dictionary then (it probably means the representativeMapping is an EmbeddedOneToOneMapping, and) we must add it.  The code that adds it below is an extract from	SimpleQuery&gt;&gt;#addFields:returningTranslationForFields:distinct:and assumes that the conditionalField, being missing from an embedded mapping, must be a field in the real table within which that mapping's fields were embedded."	super fieldTranslations: aDictionary.	aDictionary at: expression mapping conditionalField ifAbsentPut:		[query findPositionOfAliasedField: (expression base translateField: expression mapping conditionalField)].	"expression mapping conditionalFieldMapping isNil ifFalse:		[self halt: 'TBC: need to translate conditionalFieldMapping field(s)?'].An alternative to ensuring the conditionalField is translated here would be to have new method	ConditionalBuilder&gt;&gt;fieldsFromMyPerspectivein which the field were added if missing;  it would then be translated along with the others."</body><body package="GlorpQueries">row: anArray	"Any field translations we have relate to our representativeMapping case.  We probably want those of another builder but for now, as a hack, just assume whatever field(s) our conditional uses are not translated."	super row: anArray.	rowMapping := expression mapping applicableMappingForRow: row in: self.</body></methods><methods><class-id>Glorp.ConditionalBuilder</class-id> <category>copying</category><body package="GlorpQueries">postCopy	super postCopy.	rowMapping := nil.</body></methods><methods><class-id>Glorp.ConditionalBuilder</class-id> <category>building objects</category><body package="GlorpQueries">canBuild	"So far, this is only tested for the case that our rowMapping is our representativeMapping.  (Our field translations are set up for our representativeMapping only at present;  more work would be needed to build any other)."	^(row isNil or:		[rowMapping isRelationship])			ifTrue: [super canBuild]			ifFalse: [requiresPopulating := false]</body><body package="GlorpQueries">canCache	"So far, this is only tested for the case that our rowMapping is ourrepresentativeMapping.  (Our field translations are set up for our representativeMapping only at present;  more work would be needed to build any other)."	^(row isNil or:		[rowMapping isRelationship])			and: [super canCache]</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>internal</category><body package="GlorpExpressions">named: aSymbol basedOn: anExpression withArguments: anArray	| right |	outerJoin := false.	relation := self operationFor: aSymbol.	leftChild := anExpression base.	localBase := SubSelectBaseExpression on: anExpression.	right := anArray first.	rightChild := right rebuildOn: localBase startingFrom: anExpression.</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>accessing</category><body package="GlorpExpressions">descriptor	^self leftChild descriptor.</body><body package="GlorpQueries">initializeQuery	query := Query		read: localBase descriptor describedClass		where: rightChild.	query tablePrefix: ('s', localBase ultimateBaseExpression availableSubSelectNumber printString, 't')."	query baseExpression: localBase."	query session: localBase descriptor session.	localBase descriptor tables do: [:eachTable |		eachTable primaryKeyFields do: [:each | query retrieve: [:base | base getField: each]]].</body><body package="GlorpExpressions">query	query isNil ifTrue: [self initializeQuery].	^query.</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>preparing</category><body package="GlorpExpressions">addBoundExpressionsIn: aCommand	self query prepare.	self query addBoundExpressionsIn: aCommand.</body><body package="GlorpDatabase">condensePrimaryKeyComparison	"Relies on this having been called after the children are condensed. If the child has had its reference to our base condensed away, then we aren't necessary, the comparison is at the same level and no longer needs a subselect"	^leftChild queryLevelBaseExpression == rightChild queryLevelBaseExpression ifTrue: [rightChild] ifFalse: [self].</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| expression left |	self == anExpression ifTrue: [^aBaseExpression].	"We've swallowed our left child, so we have to unswallow it before rebuilding"	left := localBase trueBase rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	expression := left 		get: relation		withArguments:			(Array				with:					(self rightChildToRebuild rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression)).	self isOuterJoin ifTrue: [expression beOuterJoin].	^expression.</body></methods><methods><class-id>Glorp.SubSelectExpression</class-id> <category>printing SQL</category><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary 	| command toPrint |	toPrint := relation = #noneSatisfy: ifTrue: ['NOT EXISTS ('] ifFalse: [' EXISTS ('].	aStream nextPutAll: toPrint.	command := self query sqlWith: aDictionary.	command boundExpressions: aStream boundExpressions.	aStream nextPutAll: command sqlString.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initializeForField: aDatabaseField in: aDescriptorSystem	sequence isNil ifFalse: [^self].	sequence := aDescriptorSystem databaseSequenceNamed: (aDescriptorSystem sequenceNameForField: aDatabaseField).	aDatabaseField platform supportsSettingSequenceIncrement ifTrue:		[increment := aDatabaseField type increment isNil ifFalse:			[sequence sequenceIncrement: increment]].	sequence schema: aDatabaseField table schema.</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">hasSequence	^true.</body><body package="GlorpDatabaseTypes">isIdentityColumn	^self sequence isIdentityColumn.</body><body package="GlorpDatabaseTypes">isSerial	"answer if this is a database-generated primary key column"	^true</body><body package="GlorpDatabaseTypes">printSelectSQLOn: aCommand withParameters: aDictionary	"We record our type as serial, but that isn't really useful for a cast. We assume serials are integers, so just print a generic integer type instead."	self platform integer printSelectSQLOn: aCommand withParameters: aDictionary.</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">beRelative	self error: 'Serial and Identity types do not support relative attribute.'</body><body package="GlorpDatabaseTypes">hasParameters	^true.</body><body package="GlorpDatabaseTypes">increment	^increment</body><body package="GlorpDatabaseTypes">increment: anInteger	increment := anInteger.</body><body package="GlorpDatabaseTypes">isGenerated	^true</body><body package="GlorpDatabaseTypes">sequence	^sequence.</body><body package="GlorpDatabaseTypes">sequence: aDatabaseSequence	sequence := aDatabaseSequence.</body></methods><methods><class-id>Glorp.GlorpSerialType</class-id> <category>sequencing</category><body package="GlorpDatabaseTypes">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	^sequence postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor.</body><body package="GlorpDatabaseTypes">postWriteAssignSequenceValueFor: aDatabaseField inRows: someDatabaseRows using: anAccessor	^sequence postWriteAssignSequenceValueFor: aDatabaseField inRows: someDatabaseRows using: anAccessor</body><body package="GlorpDatabaseTypes">preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	^sequence preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>files</category><body package="GlorpMisc">contentsOfFileNamed: aString 	"Given a text file name, read its contents"	| stream contents fileClass |	Dialect isVisualWorks ifTrue: [^aString asFilename contentsOfEntireFile].	Dialect isSqueak ifTrue: [		stream := (Dialect smalltalkAt: #CrLfFileStream) oldFileNamed: aString.		[contents := stream contents] ensure: [stream close].		^contents].	fileClass := Dialect isVisualAge 				ifTrue: [self smalltalkAt: #CfsReadFileStream]				ifFalse: 					[Dialect isDolphin ifTrue: [self smalltalkAt: #File] ifFalse: [self halt]].	stream := fileClass read: aString.	[contents := stream contents] ensure: [stream close].	^contents</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>strings</category><body package="GlorpMisc">convert: aString toByteArrayWithEncoding: encodingName	self isVisualWorks ifTrue: [^aString asByteArrayEncoding: encodingName].	self error: 'Not yet implemented'.</body><body package="GlorpMisc">convert: aByteArray toStringWithEncoding: encodingName	self isVisualWorks ifTrue: [^aByteArray asStringEncoding: encodingName].	self error: 'Not yet implemented'.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>reflection</category><body package="GlorpMisc">selectorsFor: aClass do: aBlock	"Stupid dialects"	self isVisualWorks ifTrue: [^aClass selectorsAndMethodsDo: [:key :value | aBlock value: key]].	self isVisualAge ifTrue: [^ aClass methodDictionary keysDo: aBlock].	self isSqueak ifTrue: [^aClass methodDict keysDo: aBlock].	self error: 'Not yet implemented'.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>private</category><body package="GlorpExtensions">basicIsDolphin	^Smalltalk includesKey: #DolphinSplash.</body><body package="GlorpExtensions">basicIsGNU	^Smalltalk includesKey: #BindingDictionary.</body><body package="GlorpExtensions">basicIsObjectStudio	^Smalltalk class name == #SmalltalkClass.</body><body package="GlorpExtensions">basicIsSqueak	^ (Smalltalk respondsTo: #vmVersion) and: [(Smalltalk vmVersion copyFrom: 1 to: 6) = 'Squeak'.]</body><body package="GlorpExtensions">basicIsVisualAge	^ Smalltalk class name == #EsSmalltalkNamespace	"	| sys |	sys := Smalltalk at: #System ifAbsent: [^false].	(sys respondsTo: #vmType) ifFalse: [^false].	^sys vmType = 'ES'"</body><body package="GlorpExtensions">basicIsVisualWorks	^Smalltalk class name == #NameSpace"We've decided to trust that no other Smalltalk dialect uses NameSpace (e.g. in VASmalltalk, Smalltalk class name returns #EsSmalltalkNamespace).  However if we ever need a better check, one option is to add (or replace with) the following:	Smalltalk selectors do:		[:s | (s == #version and:			[(Smalltalk version copyFrom: 1 to: 11) = 'VisualWorks']) 		    	ifTrue: [^true]].	^false"</body><body package="GlorpExtensions">basicIsVisualWorksWithoutNamespaces	^Smalltalk class name == #SystemDictionary</body><body package="GlorpExtensions">determineDialect	self basicIsDolphin ifTrue: [^ dialectName := #Dolphin].	self basicIsGNU ifTrue: [^ dialectName := #GNU].	self basicIsVisualAge ifTrue: [^ dialectName := #VisualAge].	self basicIsVisualWorks ifTrue: [^ dialectName := #VisualWorks].	self basicIsSqueak ifTrue: [^ dialectName := #Squeak].	self basicIsObjectStudio ifTrue: [^dialectName := #ObjectStudio].	self basicIsVisualWorksWithoutNamespaces ifTrue: [^dialectName := #VisualWorks].	self error: 'I don''t know what dialect this is'.	^ self</body><body package="GlorpExtensions">lookedUpNames	lookedUpNames isNil ifTrue: [lookedUpNames := IdentityDictionary new].	^lookedUpNames.</body><body package="GlorpExtensions">reset	"self reset"	lookedUpNames := nil.	timestampClass := nil.	dialectName := nil.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>dates</category><body package="GlorpExtensions">addSeconds: seconds to: aTime	self isVisualWorks ifTrue: [^ Time fromSeconds: aTime asSeconds + seconds].	self isDolphin ifTrue: [^ self addTimeForDolphin: aTime seconds: seconds].	self isGNU ifTrue: [^ aTime addSeconds: seconds].	self isVisualAge ifTrue: [^Time fromSeconds: aTime asSeconds + seconds].	self error: 'not implemented'.	^ self</body><body package="GlorpExtensions">addTimeForDolphin: aTime seconds: seconds	"Dolphin's time/date arithmetic is pretty weak, especially for timestamps. Hack around it. This is likely only to work for seconds &lt;24 hours"	| result |	^ aTime class == Time		ifTrue: [Time fromMilliseconds: (aTime asMilliseconds + (seconds * 1000)) \\ 86400000.]		ifFalse: [			result := self timestampClass date: aTime date				time: (self addTimeForDolphin: aTime time seconds: seconds).			(seconds &gt; 0 and: [result time &lt; aTime time.])				ifTrue: [result date: (result date addDays: 1).].			(seconds &lt; 0 and: [result time &gt; aTime time.])				ifTrue: [result date: (result date addDays: -1).].			^ result		]</body><body package="GlorpExtensions">newDateWithYears: years months: months days: days	(self isVisualWorks or: [self isSqueak]) ifTrue: [^ Date newDay: days monthNumber: months year: years].	self isGNU ifTrue: [^ Date newDay: days monthIndex: months year: years].	self isVisualAge ifTrue: [^Date newDay: days monthIndex: months year: years].	self isObjectStudio ifTrue: [^Date newDay: days imonth: months year: years].	self error: 'not implemented'.	^ self</body><body package="GlorpExtensions">newTimeWithHours: hours minutes: minutes seconds: seconds milliseconds: milliseconds	self isGNU ifTrue: [^ Time fromSeconds: hours * 60 * 60 + (minutes * 60) + seconds].	(self isVisualWorks or: [self isSqueak]) ifTrue: [^ Time fromSeconds: hours * 60 * 60 + (minutes * 60) + seconds].	self isVisualAge		ifTrue: [			^ Time fromMilliseconds: ((hours * 60 * 60) + (minutes * 60) + seconds) * 1000 + milliseconds		].	self isObjectStudio ifTrue: [^Time hour: hours minute: minutes second: seconds millisecond: milliseconds].	self error: 'Not implemented yet'.	^ self</body><body package="GlorpExtensions">newTimestampFromDate: aDate time: aTime	self isVisualWorks ifTrue: [^self timestampClass fromDate: aDate andTime: aTime].	self error: 'Not yet implemented'.</body><body package="GlorpExtensions">newTimestampWithYears: years	months: months	days: days	hours: hours	minutes: minutes	seconds: seconds	milliseconds: millis	offset: offset	| date time ts |	self isGNU		ifTrue: [			^ self timestampClass year: years				month: months				day: days				hour: hours				minute: minutes				second: seconds				offset: ((Dialect smalltalkAt: #Duration) fromSeconds: offset)		].	date := self newDateWithYears: years months: months days: days.	time := self newTimeWithHours: hours minutes: minutes seconds: seconds milliseconds: millis.	self isVisualWorks		ifTrue: [^ (self timestampClass fromDate: date andTime: time) addMilliseconds: millis].	self isSqueak		ifTrue: [ts := self timestampClass date: date time: time.			ts time addSeconds: (millis / 1000) asInteger.				^ts]. 	self isVisualAge		ifTrue: [^(Dialect smalltalkAt: #AbtTimestamp) date: date time: time].	self isObjectStudio ifTrue: [^self timestampClass newDate: date time: time].	self error: 'not implemented'.	^ self</body><body package="GlorpExtensions">readFixedPointFrom: aString	self isVisualWorks ifTrue: [^ (self smalltalkAt: #FixedPoint) readFrom: (ReadStream on: aString)].	(self isDolphin or: [self isSqueak]) ifTrue: [^ Number readFrom: (ReadStream on: aString , 's')].	self isGNU		ifTrue: [			^ (Number readFrom: (ReadStream on: aString)) asScaledDecimal:				aString size - (aString indexOf: $. ifAbsent: [aString size.])		].	self isVisualAge ifTrue: [ ^(self smalltalkAt: #Decimal) fromString: aString].	self isObjectStudio ifTrue: [^(self smalltalkAt: #Decimal) newString: aString].	self error: 'not implemented'.	^ self</body><body package="GlorpExtensions">supportsMillisecondsInTimeStamps	self isGNU ifTrue: [^ false].	self isVisualWorks ifTrue: [^ true].	self isDolphin ifTrue: [^ true].	self isVisualAge ifTrue: [^ true].	self isObjectStudio ifTrue: [^true].	self error: 'not yet implemented'.	^ self</body><body package="GlorpExtensions">supportsMillisecondsInTimes	self isGNU ifTrue: [^ false].	self isVisualWorks ifTrue: [^ false].	self isSqueak ifTrue: [^false].	self isDolphin ifTrue: [^ true].	self isVisualAge ifTrue: [^ true].	self isObjectStudio ifTrue: [^true]. "Sort of. Supports hundredths of a second"	^ self</body><body package="GlorpExtensions">timeOffsetFromGMT	self isVisualWorks ifTrue: [^(self smalltalkAt: #TimeZone) default secondsFromGMT / (60 * 60)].	self isGNU ifTrue: [Time timezoneBias / (60 * 60)].	^ 0</body><body package="GlorpExtensions">timestampClass	timestampClass == nil ifFalse: [^ timestampClass].	Dialect isVisualWorks ifTrue: [^ timestampClass := self smalltalkAt: #Timestamp].	Dialect isObjectStudio ifTrue: [^timestampClass := self smalltalkAt: #Timestamp].	Dialect isGNU ifTrue: [^ timestampClass := self smalltalkAt: #DateTime].	(Dialect isSqueak or: [Dialect isDolphin.])		ifTrue: [^ timestampClass := self smalltalkAt: #TimeStamp].	Dialect isVisualAge ifTrue: [^ timestampClass := self smalltalkAt: #Timestamp].	self error: 'Not yet implemented'.	^ self</body><body package="GlorpExtensions">timestampNow	Dialect isGNU ifTrue: [^ self timestampClass dateAndTimeNow].	Dialect isSqueak ifTrue: [^ self timestampClass current].	Dialect isVisualWorks ifTrue: [^ self timestampClass now].	Dialect isDolphin ifTrue: [^ self timestampClass current].	Dialect isVisualAge ifTrue: [^ self timestampClass now].	Dialect isObjectStudio ifTrue: [^self timestampClass now].	self error: 'Not yet implemented'.	^ self</body><body package="GlorpExtensions">timestampNowUTC	Dialect isVisualWorks ifTrue: [^ (self smalltalkAt: #Timestamp) fromSeconds: Time secondClock].	Dialect isDolphin ifTrue: [self error: 'not supported'].	Dialect isGNU ifTrue: [^ self timestampClass utcDateAndTimeNow].	self error: 'Not yet implemented'.	^ self</body><body package="GlorpExtensions">totalSeconds	self isGNU ifTrue: [^ Time utcSecondClock].	self isVisualAge ifTrue: [^ (self smalltalkAt: #AbtTimestamp) now totalSeconds].	^ Time totalSeconds</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>numbers</category><body package="GlorpExtensions">coerceToDoublePrecisionFloat: aNumber	self isVisualWorks ifTrue: [^ aNumber asDouble].	self isVisualAge ifTrue: [^ aNumber asFloat].	self isSqueak ifTrue: [^aNumber asFloat].	self isGNU ifTrue: [^ aNumber asFloatD].	^ aNumber</body><body package="GlorpExtensions">doublePrecisionFloatClass	self isVisualWorks ifTrue: [^ self smalltalkAt: #Double].	self isGNU ifTrue: [^ self smalltalkAt: #FloatD].	^ Float</body><body package="GlorpExtensions">fixedPointClass	Dialect isVisualWorks ifTrue: [^self smalltalkAt: #FixedPoint].</body><body package="GlorpExtensions">isFloatingPoint: aNumber	^aNumber class == self doublePrecisionFloatClass or: [aNumber class == Float or: [aNumber class == self smallDoublePrecisionFloatClass]].</body><body package="GlorpExtensions">isScaleOf: aNumber lessThanOrEqualTo: aScale	^aNumber class == self fixedPointClass and: [aNumber scale &lt;= aScale].</body><body package="GlorpExtensions">singlePrecisionFloatClass	^ Float</body><body package="GlorpExtensions">smallDoublePrecisionFloatClass	self isVisualWorks		ifTrue: 			[^self smalltalkAt: #SmallDouble ifAbsent: [self doublePrecisionFloatClass]].	^self doublePrecisionFloatClass</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>general portability</category><body package="GlorpExtensions">argumentCountFor: aBlock	Dialect isVisualWorks ifTrue: [^aBlock numArgs].	Dialect isObjectStudio ifTrue: [^aBlock numArgs].	Dialect isVisualAge ifTrue: [^aBlock argumentCount].	Dialect isDolphin ifTrue: [^aBlock argumentCount].	Dialect isSqueak ifTrue: [^aBlock numArgs].	"argumentCount would also work"	Dialect isGNU ifTrue: [^ self error: 'not implemented yet'].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions">error	"If VASmalltalk 8 has switched entirely to ANSI exceptions, perhaps we can retire this.Meanwhile, it is used in some Glorp on:do: calls."	^Dialect isVisualAge		ifTrue: [Error, (Dialect smalltalkAt: #ExError)]		ifFalse: [Error]</body><body package="GlorpExtensions">fitHashIntoSmallInteger: aNumber	"Truncate the number to fit into smallinteger range. Mostly useful for ObjectStudio where hashes have to be 16 bits or less"	^Dialect isObjectStudio ifTrue: [aNumber hash] ifFalse: [aNumber].</body><body package="GlorpExtensions">garbageCollect	Dialect isVisualWorks ifTrue: [^ ObjectMemory quickGC].	Dialect isObjectStudio ifTrue: [^(self smalltalkAt: #System) garbageCollect].	Dialect isGNU ifTrue: [^ ObjectMemory globalGarbageCollect].	Dialect isVisualAge ifTrue: [^ (self smalltalkAt: #System) globalGarbageCollect].	Dialect isSqueak ifTrue: [^Smalltalk garbageCollect].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions">instVarNameFor: aName	Dialect isGNU ifTrue: [^ aName asSymbol].	^ aName asString</body><body package="GlorpExtensions">isBlock: anObject	"Return true if this is a block"	self isVisualAge ifTrue: [^anObject isKindOf: (self smalltalkAt: #Block)].	^anObject class == [] class.</body><body package="GlorpExtensions">isHeadless	"Dialect isHeadless"	Dialect isVisualWorks ifTrue: [^ (Smalltalk at: 'WindowingSystem' ifAbsent: [^true]) isHeadless].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions">quitTheImage	"Quit the entire image"	self isVisualWorks ifTrue: [^(self smalltalkAt: #ObjectMemory) quit].	self isSqueak ifTrue: [^(self smalltalkAt: #SmalltalkImage) current snapshot: false andQuit: true].	self isDolphin ifTrue: [^(self smalltalkAt: #SessionManager) current quit].	self isVisualAge ifTrue: [^  self error: 'Not implemented yet'.].	self isObjectStudio ifTrue: [^ self error: 'Not implemented yet'.].	self isGNU ifTrue: [^ self error: 'Not implemented yet'.].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions">tokensBasedOn: aString in: stringToTokenize	self isVisualWorks ifTrue: [^ stringToTokenize tokensBasedOn: aString first].	self isSqueak ifTrue: [^ stringToTokenize findTokens: aString].	self isDolphin ifTrue: [^ stringToTokenize subStrings: aString].	self isVisualAge ifTrue: [^ (stringToTokenize subStrings: aString first)].	self isObjectStudio ifTrue: [^(stringToTokenize asArrayOfSubstringsDelimiter: aString first)].	self isGNU ifTrue: [^ stringToTokenize subStrings: aString first].	self error: 'not implemented yet'.	^ self</body><body package="GlorpExtensions">weakValueDictionaryClass	Dialect isVisualWorks ifTrue: [^self smalltalkAt: #EphemeralValueDictionary].	Dialect isSqueak ifTrue: [^self smalltalkAt: #WeakValueDictionary].	self error: 'Not yet implemented for this dialect'.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>forward references</category><body package="GlorpExtensions">glorpConstantExpressionClass	^ConstantExpression.</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>identifying</category><body package="GlorpExtensions">dialectName	dialectName isNil ifTrue: [self determineDialect.].	^ dialectName</body><body package="GlorpExtensions">dialectVersion	"Glorp does not need to consult dialect versions at the moment.  This method is currently made available purely as a precaution, in case Glorp experimenters should wish to add a dialect-version-requiring feature."	self isVisualWorks ifTrue: [^self dialectName, ' ' , (self smalltalkAt: #'Kernel.SystemUtils') systemVersion].	self isDolphin ifTrue: [^self dialectName, ' ' , (self smalltalkAt: #SessionManager) current versionString].	self isObjectStudio ifTrue: [^self dialectName , ' ' , (self smalltalkAt: #'ObjectStudio.Globals.System') version].	self isSqueak ifTrue: [^(self smalltalkAt: #SystemVersion) current version].	self isVisualAge ifTrue:		[(self	"This only works if VAAssist is loaded;  find a more robust way"			smalltalkAt: #VisualAgeAssistApp			ifAbsent: [^self dialectName, ' Unknown Version']) releaseName].	^self dialectName, ' Unknown Version'</body><body package="GlorpExtensions">isDolphin	^ self dialectName = #Dolphin</body><body package="GlorpExtensions">isGNU	^ self dialectName = #GNU</body><body package="GlorpExtensions">isNamespaceAware	isNamespaceAware isNil ifTrue: [isNamespaceAware := self basicIsVisualWorks].	^isNamespaceAware</body><body package="GlorpExtensions">isObjectStudio	^ self dialectName = #ObjectStudio</body><body package="GlorpExtensions">isSqueak	^ self dialectName = #Squeak</body><body package="GlorpExtensions">isVWWithNameSpaces	"For cases where our hacked backports of asQualifiedReference and etc. to VW3 are not sufficient."	^self isVisualWorks and: [self isNamespaceAware]</body><body package="GlorpExtensions">isVisualAge	^ self dialectName = #VisualAge</body><body package="GlorpExtensions">isVisualWorks	^ self dialectName = #VisualWorks</body></methods><methods><class-id>Glorp.Dialect class</class-id> <category>class lookup</category><body package="GlorpExtensions">lookupClassNamed: aString inContextOf: aClass	"Look up the class by name, but use the namespace of the class. Mostly useful if we're trying to guess from unqualified names in dialects with namespaces."	^self lookupClassNamed: aString inContextOf: aClass ifAbsent: [nil].</body><body package="GlorpExtensions">lookupClassNamed: aString inContextOf: aClass ifAbsent: aBlock	"Look up the class by name, but use the namespace of the class. Mostly useful if we're trying to guess from unqualified names in dialects with namespaces."	self isVisualWorks ifFalse: [^self smalltalkAt: aString ifAbsent: aBlock].	^aClass environment at: aString ifAbsent:		[aClass namesAndBindingsDo:			[:varName :variable | aString asSymbol == varName ifTrue: [^variable value]].			aBlock value]</body><body package="GlorpExtensions">removeObsolete	| workingNames |	self isVisualWorks ifFalse: [^self].	(workingNames := self lookedUpNames) copy keysAndValuesDo: 		[:key :value |		value isObsolete ifTrue: [workingNames removeKey: key ifAbsent: nil]]</body><body package="GlorpExtensions">smalltalkAssociationAt: aName	^ self smalltalkAssociationAt: aName ifAbsent: [self error: 'element not found'.]</body><body package="GlorpExtensions">smalltalkAssociationAt: aName ifAbsent: aBlock	self isVisualWorks ifTrue: [^ aName asQualifiedReference].	^ Smalltalk associationAt: aName asSymbol ifAbsent: aBlock</body><body package="GlorpExtensions">smalltalkAt: aName	^ self smalltalkAt: aName ifAbsent: [self error: 'element not found'].</body><body package="GlorpExtensions">smalltalkAt: aName ifAbsent: aBlock	"We may look these names up a lot, so cache them in a small, local dictionary.  In VisualWorks (only, at the moment), we check isObsolete on cached NmeSpaces and Classes."	| cached value symbol |	symbol := aName asSymbol.	cached := self lookedUpNames at: symbol ifAbsent: [nil].	cached isNil ifFalse: 		[self isVisualWorks			ifTrue:				[((cached isBehavior or: [cached isNameSpace]) and: [cached isObsolete]) 					ifTrue: [self removeObsolete]					ifFalse: [^cached]]			ifFalse: [^cached]].	value := self isVisualWorks		ifTrue: 			[((symbol includes: $.)				ifTrue: [symbol asStrictReference]				ifFalse: [symbol asQualifiedReference]) valueOrDo: 					[^aBlock value]]		ifFalse: [Smalltalk at: symbol ifAbsent: aBlock].	self lookedUpNames at: symbol put: value.	^value</body></methods><methods><class-id>Glorp.Login</class-id> <category>accessing</category><body package="GlorpDatabase">= aLogin 	^self class == aLogin class 		and: [self database class = aLogin database class 		and: [self username = aLogin username 		and: [self connectString = aLogin connectString		and: [self schema = aLogin schema]]]]</body><body package="GlorpDatabase">connectString	^connectString</body><body package="GlorpDatabase">connectString: aString 	connectString := aString</body><body package="GlorpDatabase">database	^database</body><body package="GlorpDatabase">database: aDatabasePlatform 	database := aDatabasePlatform</body><body package="GlorpDatabase">hash	^self name hash + self database class hash + self username hash + self connectString hash</body><body package="GlorpDatabase">name	name isNil ifTrue: [^self connectString] ifFalse: [^name].</body><body package="GlorpDatabase">name: aString	name := aString.</body><body package="GlorpDatabase">password	"Return the password for this login. If we are in a secure mode, then erase the password as soon as it is accessed."	| returnValue |	returnValue := password.	secure ifTrue: [password := nil].	^returnValue.</body><body package="GlorpDatabase">password: aString 	password := aString</body><body package="GlorpDatabase">platform	^self database.</body><body package="GlorpDatabase">schema	^schema</body><body package="GlorpDatabase">schema: aString	schema := aString.</body><body package="GlorpDatabase">secure	^secure</body><body package="GlorpDatabase">secure: aBoolean	secure := aBoolean</body><body package="GlorpDatabase">username	^username</body><body package="GlorpDatabase">username: aString 	username := aString</body></methods><methods><class-id>Glorp.Login</class-id> <category>printing</category><body package="GlorpDatabase">printOn: aStream	aStream nextPutAll: 'a Login('.	database printOn: aStream.	aStream nextPutAll: ', '.	username printOn: aStream.	aStream nextPutAll: ', '.	connectString printOn: aStream.	aStream nextPutAll: ', '.	schema printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.Login</class-id> <category>session creation</category><body package="GlorpDatabase">sessionForDescriptorSystem: aDescriptorSystemClass	"Create a session for this login, using aDescriptorSystemClass for its metadata"	^aDescriptorSystemClass sessionForLogin: self.</body><body package="GlorpDatabase">vwConnectionClass	^self database vwConnectionClass</body></methods><methods><class-id>Glorp.Login</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"My schema supplies the schema to my accessor, to its session and to that session's descriptor system.  Since a DatabaseTable's schema is initialized to the empty string, not nil (and that of a StoreLogin must never be nil), initialize to the empty string here, so that calling code need not check for nil.	Initialize secure to true, so that only if the creating code then explicitly resets it to false will the login keep the password in the image beyond the point of first use."	schema := ''.	secure := true.</body></methods><methods><class-id>Glorp.Login</class-id> <category>converting</category><body package="GlorpDatabase">asGlorpLogin	"Polymorph with objects that know how to convert themselves to Logins, e.g. Store ConnectionProfiles."	^self</body></methods><methods><class-id>Glorp.Login</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	self database postLoginInitializeFromAccessor: aDatabaseAccessor.</body><body package="GlorpDatabase">preLoginInitializeFromAccessor: anAccessor	anAccessor connection initializeFromLogin: self.</body></methods><methods><class-id>Glorp.Login class</class-id> <category>instance creation</category><body package="GlorpDatabase">new	^super new initialize.</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>binding</category><body package="GlorpDatabase">bindingsForGroupWritingFor: aCommand	^aCommand arrayBindings.</body><body package="GlorpDatabase">maximumSizeToGroupWriteFor: aRowBasedCommand	^250 min: (super maximumSizeToGroupWriteFor: aRowBasedCommand)</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>conversion-times</category><body package="GlorpDatabase">printDate: aDate for: aType	"Print a date (or timestamp) as yyyy-mm-dd"	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPut: $'.	self		printDate: aDate		isoFormatOn: stream.	stream nextPut: $'.	^stream contents.</body><body package="GlorpDatabase">printTime: aTime for: aType	"Print a time (or timestamp) as hh:mm:ss.fff"	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: 'TIME( '''.	self		printTime: aTime		isoFormatOn: stream		milliseconds: self supportsMillisecondsInTimes.	stream nextPutAll: ''' )'.	^stream contents.</body><body package="GlorpDatabase">printTimestamp: aTimestamp on: stream for: aType	"In DB2, we could use TIMESTAMP for up to microseconds;  (Times do not even support milliseconds in DB2.)"	aTimestamp isNil ifTrue:		[stream nextPutAll: 'NULL'.		^self].	stream nextPut: $'.	self printDate: aTimestamp isoFormatOn: stream.	stream nextPutAll: ' '.	self		printTime: aTimestamp		isoFormatOn: stream		milliseconds: true.	stream nextPut: $'.</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>types</category><body package="GlorpDatabase">blob	^self typeNamed: #blob ifAbsentPut: [GlorpBlobType new typeString: 'BLOB'].</body><body package="GlorpDatabase">boolean	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'integer']</body><body package="GlorpDatabase">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new typeString: 'CHARACTER'].</body><body package="GlorpDatabase">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'CLOB'].</body><body package="GlorpDatabase">date	"Return the type we use to represent dates."	^self typeNamed: #date ifAbsentPut: [GlorpDateType new].</body><body package="GlorpDatabase">decimal	^self numeric.</body><body package="GlorpDatabase">double	^self typeNamed: #double ifAbsentPut: [GlorpDoubleType new typeString: 'DOUBLE' ].</body><body package="GlorpDatabase">float	^self typeNamed: #float ifAbsentPut: [GlorpFloatType new typeString: 'REAL' ].</body><body package="GlorpDatabase">float4	^self float.</body><body package="GlorpDatabase">float8	^self double.</body><body package="GlorpDatabase">int	^self integer.</body><body package="GlorpDatabase">int2	^self smallint.</body><body package="GlorpDatabase">int4	^self integer.</body><body package="GlorpDatabase">int8	^self typeNamed: #int8 ifAbsentPut: [GlorpIntegerType new typeString: 'BIGINT'].</body><body package="GlorpDatabase">nclob	^self typeNamed: #nclob ifAbsentPut: [GlorpClobType new typeString: 'dbclob'].</body><body package="GlorpDatabase">number	"DB2 NUMERIC columns default to precision=5, scale=0."		^self typeNamed: #number ifAbsentPut: [GlorpNumericType new typeString: 'DECIMAL']</body><body package="GlorpDatabase">nvarchar	^self typeNamed: #nvarchar ifAbsentPut: [GlorpVarCharType new typeString: 'nvarchar'].</body><body package="GlorpDatabase">real	^self float.</body><body package="GlorpDatabase">sequence	^self serial.</body><body package="GlorpDatabase">serial	"This is the sequence based type used by Glorp."	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: (self integer typeString)].</body><body package="GlorpDatabase">serialIdentity	"This is the identity column type used by DB2, but not supported by Glorp. It is here just	so that we can recognize identity columns when they are encountered."	^self typeNamed: #serialIdentity ifAbsentPut: [DB2IdentityType new typeString: 'integer generated always as identity '].</body><body package="GlorpDatabase">text	^super text queryType: self varchar.</body><body package="GlorpDatabase">time	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'TIME'].</body><body package="GlorpDatabase">timeStampTypeString	^'datetime'.</body><body package="GlorpDatabase">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'TIMESTAMP'].</body><body package="GlorpDatabase">tinyint	^self typeNamed: #tinyInt ifAbsentPut: [GlorpIntegerType new typeString: 'SMALLINT'].</body><body package="GlorpDatabase">varbinary	^self typeNamed: #varbinary ifAbsentPut: [GlorpVarBinaryType new].</body><body package="GlorpDatabase">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new typeString: 'VARCHAR'].</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated	^true</body><body package="GlorpDatabase">databaseIdentitySequenceClass	"Uses the IDENTITY column mechanism."	^DB2IdentitySequence</body><body package="GlorpDatabase">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the max. length of a column name"	^128</body><body package="GlorpDatabase">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^128</body><body package="GlorpDatabase">sqlTextForNULLAttributeConstraint	"^&lt;String&gt;"	^''</body><body package="GlorpDatabase">supportsMillisecondsInTimes	"Use TIMESTAMP for up to microseconds;  Times do not even support milliseconds in DB2."	^false</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">charactersThatNeedEscaping	"There seem to be all kind of contradictory bits of information about what sql server does/requires for escaped characters, all of which differ from standard sql. Empirically the only thing that requires escaping appears to be single quote"	^#($' ).</body><body package="GlorpDatabase">escapeFor: aCharacter	^String with: $' with: aCharacter."	^'\', (aCharacter asInteger printStringRadix: 16)."</body><body package="GlorpDatabase">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	aStream nextPutAll: 'BLOB(X'''.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].	aStream nextPutAll: ''') '."	aStream nextPutAll: 'CAST(X'''.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].	aStream nextPutAll: ''' AS BLOB) '."</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>testing</category><body package="GlorpDatabase">canRecurse	^canRecurse</body><body package="GlorpDatabase">canUseInWhereClause: aValue type: aType	"This is mostly for test support purposes. If we know we can't use a particular kind of value in the where clause on some database, don't try."	(super canUseInWhereClause: aValue type: aType) ifFalse: [^false].	"In DB2 we don't seem to be able to compare lobs against anything.	But if you convert the lob itself, that works sometimes. Eg.,		... WHERE CHAR(clb) = 'abcdefghijklmnop'.		... WHERE SUBSTR(clb,1, 16) LIKE 'abcdefghijklmnop'.		... WHERE CHAR(SUBSTR(clb,1, 16)) = 'abcdefghijklmnop'.	Note that LIKE works with SUBSTR(), but = works with CHAR()."	((Set with: (self blob) with: (self clob) with: (self nclob)) includes: aType) ifTrue: [^false].	^true.</body><body package="GlorpDatabase">isDB2Platform	^true</body><body package="GlorpDatabase">maximumQueryValueSize	"If there's a limit on how big a bound input parameter can be for a query, return it here.	For literal strings and lobs, at least, the DB2 limit is 32K. Not sure about bound objects.	If those can be larger, then we can indicate that fact by introducing a companion method	later. Note that we write literal LOBs as 2-byte hex chars per byte. So, the limit is	actually 16384-9-1, eg., blob(X'0A41') makes 9 extras."	^16374</body><body package="GlorpDatabase">requiresCastsForNullsInUnions	"If we have explicit nulls in a query which is unioned, do we need to cast them to the appropriate type in order to keep the database happy."	^true.</body><body package="GlorpDatabase">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax. Currently hard-coded, but may also vary by database version"	^true.</body><body package="GlorpDatabase">supportsANSIJoinsWithRecursion	^false</body><body package="GlorpDatabase">supportsBinding	"Binding works only with VW EXDI so far"	^Dialect isVisualWorks.</body><body package="GlorpDatabase">supportsCompositeKeyArgsForOperand: aSymbol	"In DB2,		composite-row IN subquery LIMIT 1is OK but it rejects composite		composite-row = subquery LIMIT 1with error	[IBM][CLI Driver][DB2/NT64] SQL0412N  Multiple columns are returned from a subquery that is allowed only one column. SQLSTATE=42823I take this to mean that DB2 supports LIMIT in subquery - it does not _say_ it does not - so it _should_ accept		composite-row = subquery LIMIT 1since it allows the semantically identical		composite-row IN subquery LIMIT 1The fact that it does not allow it _may_ means they implement = or IN error-checking code in an overly crude way. (We could raise a bug report to DB2.)  Obviously, since IN ... LIMIT 1 is allowed, we could in theory handle all cases, including #readOneOf:, by giving the RelationExpression a composite LHS, the IN operator, and rewriting the subquery of required;  in practise, for now, we return false for = (and for &lt;&gt; - the assumption is that it will fail there too, not yet tested) and so get the longhand solution: ANDed single-key queries."	^aSymbol == #IN</body><body package="GlorpDatabase">supportsCorrelatedSubqueriesInOrderBy	"DB2 doesn't support correlated subqueries in the ORDER BY clause."	^false</body><body package="GlorpDatabase">supportsDecimalsOnAllNumerics	"Return true if a general 'numeric' type will allow numbers after the decimal place.	NUMERIC(5) will not store 321.12 (it'll keep 321.)."	^false.</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	"DB2 does not support batched statements, i.e. cannot do INSERT ...; INSERT ...; INSERT... , but since version 8.0 it does support value sequences, i.e. it can do INSERT INTO table (id, c) VALUES (1,'1'), (2,'2'), (3,'3')."	^aCommand supportsGroupWriting and:		[self useBinding or: [aCommand supportsGroupWritingValues]]</body><body package="GlorpDatabase">supportsGroupWritingValues	"I support it in version 8 and after."	^supportsGroupWritingValues</body><body package="GlorpDatabase">supportsLimit	"Do we support anything analogous to the postgresql LIMIT, returning only the first N rows"	^true.</body><body package="GlorpDatabase">supportsTableOwners	"Return true if this platform supports table owners, i.e. expects table names of the form Bern.TW_* rather than just TW_* in its SQL.""Access, Firebird and PostGreSQL do not, Oracle does, others I know not."	^true</body><body package="GlorpDatabase">typeWithDatabaseName: aString characterWidth: aNumber extraInformation: extraValue	"Return our type which matches the database name for the type. Assumes all variable width fields are strings right now.  If the type is integer, return integer type, not boolean for now."	extraValue = 'IDENTITY' ifTrue: [^self serialIdentity].	aString asLowercase = 'integer' ifTrue: [^self integer].	^super typeWithDatabaseName: aString characterWidth: aNumber.</body><body package="GlorpDatabase">useMicrosoftOuterJoins	"Return true if we use the Microsoft x *= y syntax for outer joins"	^false.</body><body package="GlorpDatabase">usesArrayBindingToGroupWrite	"DB2 supports array binding to group-write when bound.  As it is the most performant way to group-write, we use it in that case."	^true</body><body package="GlorpDatabase">usesIdentityColumns	"In fact, DB2 supports identity columns but DB2 sequences were implemented early and used instead, so we never implemented it.  The two ways to handle this are (1) SQLServerPlatform, or (2) MySQLPlatform and SQLitePlatform - look at their implementations of #insertCommandForRows:binding:session: to see the two approaches."	^false</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	^true</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>database-specific</category><body package="GlorpDatabase">compoundOperationFor: aSymbol	"Return the platform specific version of a compound statement symbol"	aSymbol == #INTERSECT ifTrue: [^'WHERE EXISTS'].	aSymbol == #MINUS ifTrue: [^'WHERE NOT EXISTS'].	^aSymbol.</body><body package="GlorpDatabase">printPostLimit: anInteger on: aCommand		aCommand nextPutAll: ' FETCH FIRST  '.	anInteger printOn: aCommand.	aCommand nextPutAll: ' ROWS ONLY '</body><body package="GlorpDatabase">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"If aQuery has operations that we don't support, rewrite it to do them in terms of lower level operations. In particular, rewrite INTERSECT/EXCEPT operations into EXISTS clauses in a single query. Pass the new query to aBlock."	| newQuery |	newQuery := aQuery rewriteIntersect.	newQuery := newQuery rewriteExcept.	newQuery == aQuery ifFalse: [aBlock value: newQuery].</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>accessing</category><body package="GlorpDatabase">vwEXDIConnectionClass	^'DB2Connection' asQualifiedReference valueIfUndefinedLoadFrom: 'DB2EXDI'</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase">booleanToBooleanConverter	"DB2 doesnât support a boolean type.  By default, we map a boolean (true, false) in the image to an integer (1, 0) in the database."	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToInteger:for:		fromDbToSt: #convertIntegerToBoolean:for:</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>type helpers</category><body package="GlorpDatabase">typesWithValues	self date.	self double.	self int8.	self decimal.	self real.	^super typesWithValues</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>services columns</category><body package="GlorpDatabase">createAlterColumnStatement: aField newType: aType usingExpression: expression	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' ALTER COLUMN';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  ' SET DATA TYPE ';		nextPutAll: aType typeString.	expression ifNotNil: [ sqlStatementStream nextPutAll: ' USING ', expression ].	^sqlStatementStream contents</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseSequenceClass	"Use the SEQUENCE generator instead of the IDENTITY column mechanism."	^DB2Sequence</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>services constraints</category><body package="GlorpDatabase">createConstraintAddStatement: aConstraint	| sqlStatementStream |	aConstraint shouldCreateInDatabase ifFalse: [^''].	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll: 'ALTER TABLE';		space.	self printDDLTableNameFor: aConstraint table on: sqlStatementStream.	(aConstraint creationStringFor: self)		do: [:each | sqlStatementStream nextPutAll: ' ADD ' , each]		separatedBy: [sqlStatementStream nextPut: Character space].	^sqlStatementStream contents</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>functions</category><body package="GlorpDatabase">initializeFunctions	"DB2 doesn't allow CAST(date AS timestamp), but it does have a TIMESTAMP function."	| baseExists dbSpecificExists selectList baseNotExists dbSpecificNotExists |	super initializeFunctions.	functions		at: #, put: (InfixFunction named: '||');	"can use || or CONCAT"		at: #timestamp: put: ((PrefixFunction named: 'TIMESTAMP') type: self timestamp); "TIMESTAMP(date, time)"		at: #time0 put: ((StandaloneFunction named: 'TIME(''00:00:00'')') type: self time);		at: #castTo: put: ((PrefixFunction named: 'CAST') separator: ' AS '). "CAST(aThing AS aType)"		"at: #like: put: (InfixFunction named: 'LIKE').		at: #copyFrom:to: put: (SubstringFunction named: 'SUBSTRING');"	"Like Oracle, DB2 doesn't allow functions like EXISTS in a field list,	but will allow a select there as an argument to a function, such as CASE.	So print it that way if we're in the select list."	baseExists := functions at: #exists:.	dbSpecificExists := DualRoleFunction new.	dbSpecificExists function: '#exists:'.	dbSpecificExists whereClauseVersion: baseExists.	selectList := Case new argumentTypes: (Array with: (self varchar: 1) with: self integer with: self integer).	selectList argumentModifierBlock:		[:function :args | 		function base: args first.		Array with: 'x' with: 1 with: 0].	 "the argument 'x' synchronises with 'x' at the end of #existenceCheck:as:"	dbSpecificExists selectListVersion: selectList.	dbSpecificExists type: self integer.	functions at: #exists: put: dbSpecificExists.	"And similarly NOT EXISTS"	baseNotExists := functions at: #notExists:.	dbSpecificNotExists := DualRoleFunction new.	dbSpecificNotExists function: '#notExists:'.	dbSpecificNotExists whereClauseVersion: baseNotExists.	selectList := Case new argumentTypes: (Array with: (self varchar: 1) with: self integer with: self integer).	selectList argumentModifierBlock:		[:function :args | 		function base: args first.		Array with: 'x' with: 0 with: 1].	 "the argument 'x' synchronises with 'x' at the end of #existenceCheck:as:"	dbSpecificNotExists selectListVersion: selectList.	dbSpecificNotExists type: self integer.	functions at: #notExists: put: dbSpecificNotExists."Duration arithmetic functions - DB2 does not tolerate direct combinations of integers and dates / timestamps.  First we list the functions that extract integers from summed or differences dates, e.g.	(each endDate - each startDate) year &gt; 3would return rows where the difference exceeded three years."	functions		at: #microsecond put: ((PrefixFunction named: 'MICROSECOND') type: self integer);		at: #second put: ((PrefixFunction named: 'SECOND') type: self integer);		at: #minute put: ((PrefixFunction named: 'MINUTE') type: self integer);		at: #hour put: ((PrefixFunction named: 'HOUR') type: self integer);		at: #day put: ((PrefixFunction named: 'DAY') type: self integer);		at: #month put: ((PrefixFunction named: 'MONTH') type: self integer);		at: #year put: ((PrefixFunction named: 'YEAR') type: self integer)."If a column holds integers which in fact signify durations, use the following functions to convert to durations in expressions, e.g.	each startDate + each daysToBonus days &lt; Date todaywould return rows where elapsed time from start exceeded the bonus duration."	functions		at: #microseconds put: ((PostfixFunction named: 'MICROSECONDS') type: self date);		at: #seconds put: ((PostfixFunction named: 'SECONDS') type: self date);		at: #minutes put: ((PostfixFunction named: 'MINUTES') type: self date);		at: #hours put: ((PostfixFunction named: 'HOURS') type: self date);		at: #days put: ((PostfixFunction named: 'DAYS') type: self date);		at: #months put: ((PostfixFunction named: 'MONTHS') type: self date);		at: #years put: ((PostfixFunction named: 'YEARS') type: self date).</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>services tables</category><body package="GlorpDatabase">printSqlStatementToListTablesInSchema: schemaString on: aStream	"Not standardized"	| lowerSchema |	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream nextPutAll: 'SELECT table_name FROM sysibm.tables '.	(lowerSchema notNil and: [lowerSchema notEmpty]) ifTrue:		[aStream			nextPutAll: 'WHERE lower(table_schema) = ';			nextPut: $';			nextPutAll: lowerSchema;			nextPut: $']</body><body package="GlorpDatabase">printSqlStatementToRenameTable: aDatabaseTable to: newTableName on: aStream	" The DB2 SQL statement is	RENAME TABLE &lt;oldTableName&gt; TO &lt;newTableName&gt;."	aStream		nextPutAll: 'RENAME TABLE ';		nextPutAll: (self ddlTableNameFor: aDatabaseTable);		nextPutAll: ' TO ';		nextPutAll: newTableName</body><body package="GlorpDatabase">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	" This query will test only for tables that the logged on user has access to... "	| upperTableName upperSchema |	upperTableName := tableName asUppercase.	upperSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asUppercase].	aStream		nextPutAll: 'SELECT count(*) FROM sysibm.tables ';		nextPutAll: 'WHERE table_name = ';		nextPut: $';		nextPutAll: upperTableName;		nextPut: $'.	(upperSchema notNil and: [upperSchema notEmpty]) ifTrue:		[aStream			nextPutAll: ' AND table_schema = ';			nextPut: $';			nextPutAll: upperSchema;			nextPut: $']</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"DB2 has been supporting group writing with the VALUES clause at least since version 8.0, and supporting recursion since version 7.0."	| dbmsVersion |	dbmsVersion := aDatabaseAccessor connection dbmsVersion tokensBasedOn: $..	supportsGroupWritingValues := dbmsVersion first asNumber &gt; 7.	canRecurse := dbmsVersion first asNumber &gt; 6.</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	"I cannot group ;-separated INSERT statements but (if I am new enough - version 8 or later) I can group ,-separated values following a single INSERT statement when unbound.  When bound, the same applied but I can also bind an array of values to a single INSERT statement. As array binding is fastest, I use it when bound, values when unbound."	^(aBoolean		ifTrue: [InsertCommand]		ifFalse: [self supportsGroupWritingValues				ifFalse: [InsertCommand]				ifTrue: [InsertMultiValuesCommand]])		forRows: aCollectionOfDatabaseRows		useBinding: aBoolean		session: aSession</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>api</category><body package="GlorpDatabase">migrationExceptionBlockFor: aMigrationOperation accessor: anAccessor	"This method should return a new copy of the block(s), with a new copy of #first method var.	The #first var changes to False after innerBlock has executed once, and stays that way to prevent an endless loop.	The outer block (the thing we actually return) expects one parameter, the exception object."	| first innerBlock |	first := ValueHolder with: true.	innerBlock :=			[:ex :accessor :isFirst :operation |			(isFirst value and: [self isDB2TableReorgException: ex])				ifTrue: 					[accessor doDDLOperation: 							[accessor								executeSQLStringNoResult: 'Call Sysproc.admin_cmd(''REORG TABLE '										, (operation tableName copyWithout: $') , ''')'].					isFirst value: false.					ex retry]				ifFalse: [operation exceptionBlock value: ex]].	^[:ex| innerBlock valueWithArguments: (Array with: ex with: anAccessor with: first with: aMigrationOperation)].</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>exdi specific</category><body package="GlorpDatabase">exdiTypeForBoolean	"DB2 has no boolean type and DB2EXDI has no support for it."	^#Integer</body></methods><methods><class-id>Glorp.DB2Platform</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"DB2 has been supporting group writing with the VALUES clause at least since version 8.0, and supporting recursion since version 7.0.  For safety, we initialize to false, resetting in postLoginInitializeFromAccessor:."	super initialize.	canRecurse := false.	supportsGroupWritingValues := false.</body></methods><methods><class-id>Glorp.DB2Platform class</class-id> <category>constants</category><body package="GlorpDatabase">reservedWords		^#('add' 'after' 'all' 'allocate' 'allow' 'alter' 'and' 'any' 'as' 'asensitive' 'associate' 'asutime' 'at' 'audit' 'aux' 'auxiliary' 'before' 'begin' 'between' 'bufferpool' 'by' 'call' 'capture' 'cascaded' 'case' 'cast' 'ccsid' 'char' 'character' 'check' 'clone' 'close' 'cluster' 'collection' 'collid' 'column' 'comment' 'commit' 'concat' 'condition' 'connect' 'connection' 'constraint' 'contains' 'content' 'continue' 'create' 'current' 'current_date' 'current_lc_ctype' 'current_path' 'current_schema' 'current_time' 'current_timestamp' 'cursor' 'data' 'database' 'day' 'days' 'dbinfo' 'declare' 'default' 'delete' 'descriptor' 'deterministic' 'disable' 'disallow' 'distinct' 'do' 'document' 'double' 'drop' 'dssize' 'dynamic' 'editproc' 'else' 'elseif' 'encoding' 'encryption' 'end' 'end-exec2' 'ending' 'erase' 'escape' 'except' 'exception' 'execute' 'exists' 'exit' 'explain' 'external' 'fenced' 'fetch' 'fieldproc' 'final' 'first' 'for' 'free' 'from' 'full' 'function' 'generated' 'get' 'global' 'go' 'goto' 'grant' 'group' 'handler' 'having' 'hold' 'hour' 'hours' 'if' 'immediate' 'in' 'inclusive' 'index' 'inherit' 'inner' 'inout' 'insensitive' 'insert' 'intersect' 'into' 'is' 'isobid' 'iterate' 'jar' 'join' 'keep' 'key' 'label' 'language' 'last' 'lc_ctype' 'leave' 'left' 'like' 'local' 'locale' 'locator' 'locators' 'lock' 'lockmax' 'locksize' 'long' 'loop' 'maintained' 'materialized' 'microsecond' 'microseconds' 'minute' 'minutes' 'modifies' 'month' 'months' 'next' 'nextval' 'no' 'none' 'not' 'null' 'nulls' 'numparts' 'obid' 'of' 'old' 'on' 'open' 'optimization' 'optimize' 'or' 'order' 'organization' 'out' 'outer' 'package' 'padded' 'parameter' 'part' 'partition' 'partitioned' 'partitioning' 'path' 'period' 'piecesize' 'plan' 'precision' 'prepare' 'prevval' 'prior' 'priqty' 'privileges' 'procedure' 'program' 'psid' 'public' 'query' 'queryno' 'reads' 'references' 'refresh' 'release' 'rename' 'repeat' 'resignal' 'restrict' 'result' 'result_set_locator' 'return' 'returns' 'revoke' 'right' 'role' 'rollback' 'round_ceiling' 'round_down' 'round_floor' 'round_half_down' 'round_half_even' 'round_half_up' 'round_up' 'row' 'rowset' 'run' 'savepoint' 'schema' 'scratchpad' 'second' 'seconds' 'secqty' 'security' 'select' 'sensitive' 'sequence' 'session_user' 'set' 'signal' 'simple' 'some' 'source' 'specific' 'standard' 'statement' 'static' 'stay' 'stogroup' 'stores' 'style' 'summary' 'synonym' 'sysfun' 'sysibm' 'sysproc' 'system' 'table' 'tablespace' 'then' 'to' 'trigger' 'truncate' 'type' 'undo' 'union' 'unique' 'until' 'update' 'user' 'using' 'validproc' 'value' 'values' 'variable' 'variant' 'vcat' 'view' 'volatile' 'volumes' 'when' 'whenever' 'where' 'while' 'with' 'wlm' 'xmlcast' 'xmlexists' 'xmlnamespaces' 'year' 'years' 'zone') asSet.</body></methods><methods><class-id>Glorp.DB2Platform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'DB2'</body></methods><methods><class-id>Glorp.GlorpIntegerType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'integer'.</body></methods><methods><class-id>Glorp.GlorpIntegerType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes">= aType	(aType class == self platform numeric class and: [aType isIntegerType]) ifTrue: [^true].	^super = aType</body><body package="GlorpDatabaseTypes">hash	"Our hash must be identical to GlorpNumericType's hash when it is an #isInteger"	^self platform hash bitXor: self impliedSmalltalkType hash</body></methods><methods><class-id>Glorp.CannotFindSession</class-id> <category>printing</category><body package="GlorpMisc">defaultMessageText	^'Cannot find the right session to use - send the #session: message first.'.</body></methods><methods><class-id>Glorp.CannotFindSession class</class-id> <category>testing</category><body package="GlorpMisc">mayResume	^true.</body></methods><methods><class-id>Glorp.DataElementBuilder</class-id> <category>building objects</category><body package="GlorpQueries">buildObjectFrom: anArray	self row: anArray.	instance := self valueOf: expression.</body><body package="GlorpQueries">didValidationFail: validateResult	"In other words, don't treat the result of the validation send to the object as a failure if the object was the boolean false, so returning self would normally be interpreted as the failure"	validateResult == self instance ifTrue: [^false].	^super didValidationFail: validateResult.</body><body package="GlorpQueries">findInstanceForRow: aRow proxyType: proxyType	^self.</body></methods><methods><class-id>Glorp.DataElementBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries">fieldsForSelectStatement	^Array with: expression.</body><body package="GlorpQueries">fieldsFromMyPerspective	^expression mappedFields.</body></methods><methods><class-id>Glorp.DataElementBuilder</class-id> <category>copying</category><body package="GlorpQueries">onCompoundCursor: aGlorpCursoredStream	^expression class == ConstantExpression		ifFalse: [super onCompoundCursor: aGlorpCursoredStream]		ifTrue: [CompoundConstantBuilder new postCopy				expression: expression;				query: query;				fieldTranslations: fieldTranslations;				cursor: aGlorpCursoredStream]</body></methods><methods><class-id>Glorp.CompoundConstantBuilder</class-id> <category>translating fields</category><body package="GlorpQueries">valueOf: anExpression	^self row atIndex: (self translateFieldPosition: expression)</body><body package="GlorpQueries">valueOfField: aField	"The parameter aField is either a database field or a constant expression containing a non-varying value that isn't derived from the database row but was written to the select statement and so returned as a value in the row.  As I am a builder of a compound query, whose subqueries could have different values for tha constant, get the value returned by the row."	^self row atIndex: (self translateFieldPosition: aField)</body><body package="GlorpQueries">valueOfField: aField in: aRow	"The elementBuilder holds the row, so #valueOfField: is the recommended protocol in all ordinary cases.  An AdHocProxy's readBlock could be set by an AdHocMapping at one point, then evaluated later, after the ElementBuilder had been assigned another row.  This protocol remains for that rare case -  see #testReadAdHocProxied.	The parameter aField is either a database field or a constant expression containing a non-varying value that isn't derived from the database row but was written to the select statement and so returned as a value in the row.  As I am a builder of a compound query, whose subqueries could have different values for tha constant, get the value returned by the row."	^aRow atIndex: (self translateFieldPosition: aField)</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseSequenceClass	^OracleSequence.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>SQL</category><body package="GlorpDatabase">isOraclePlatform	^true</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>types</category><body package="GlorpDatabase">boolean	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString: 'integer']</body><body package="GlorpDatabase">char	^self typeNamed: #char ifAbsentPut: [GlorpCharType new].</body><body package="GlorpDatabase">clob	^self typeNamed: #clob ifAbsentPut: [GlorpClobType new typeString: 'clob'].</body><body package="GlorpDatabase">date	^self typeNamed: #date ifAbsentPut: [GlorpTimeStampType new typeString: 'date'].</body><body package="GlorpDatabase">double	^self float8</body><body package="GlorpDatabase">float	^self typeNamed: #float ifAbsentPut: [GlorpFloatType new typeString: 'FLOAT']</body><body package="GlorpDatabase">float4	"Conveniently, Oracle 10 is the first version that both supportsGroupWritingValues and supports BINARY_FLOAT."	^self		typeNamed: #float4		ifAbsentPut:			[self supportsGroupWritingValues				ifTrue: [GlorpFloatType new typeString: 'BINARY_FLOAT']				ifFalse: [GlorpFloatType new typeString: 'float']]</body><body package="GlorpDatabase">float8	"Conveniently, Oracle 10 is the first version that both supportsGroupWritingValues and supports BINARY_DOUBLE."	^self		typeNamed: #float8		ifAbsentPut:			[self supportsGroupWritingValues				ifTrue: [GlorpFloatType new typeString: 'BINARY_DOUBLE']				ifFalse: [GlorpFloatType new typeString: 'double precision']]</body><body package="GlorpDatabase">int	^self integer</body><body package="GlorpDatabase">int2	^self integer</body><body package="GlorpDatabase">int4	^self integer</body><body package="GlorpDatabase">int8	^self integer</body><body package="GlorpDatabase">longRaw	^self typeNamed: #longRaw ifAbsentPut: [GlorpBlobType new typeString: 'Long Raw'].</body><body package="GlorpDatabase">number	^self typeNamed: #number ifAbsentPut: [GlorpNumericType new typeString: 'number'].</body><body package="GlorpDatabase">raw	^self typeNamed: #raw ifAbsentPut: [GlorpBlobType new typeString: 'raw'].</body><body package="GlorpDatabase">sequence	^self serial.</body><body package="GlorpDatabase">serial	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: (self integer typeString)].</body><body package="GlorpDatabase">text	^self clob.</body><body package="GlorpDatabase">time	^self timestamp.</body><body package="GlorpDatabase">timestamp	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'date'].</body><body package="GlorpDatabase">varchar	^self typeNamed: #varchar ifAbsentPut: [GlorpVarCharType new typeName: 'varchar2'].</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>table creation</category><body package="GlorpDatabase">printNumericFieldOfSize: anInteger on: aStream	aStream 		nextPutAll: 'number('.	anInteger printOn: aStream.	aStream nextPutAll: ')'.</body><body package="GlorpDatabase">printStringFieldOfSize: anInteger on: aStream	aStream 		nextPutAll: 'varchar2('.	anInteger printOn: aStream.	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated	^true.</body><body package="GlorpDatabase">endColumnAddString	"The string we use as a suffix when adding a colum"	^' ) '.</body><body package="GlorpDatabase">initializeReservedWords	super initializeReservedWords.	reservedWords add: 'number'.</body><body package="GlorpDatabase">maximumLengthOfColumnName	"^&lt;Integer&gt; I return the maximum length of a column name.  (I am not sent at present;  I am here so that if I and #maximumLengthOfTableName (which is sent) should ever differ on some database platform, I can be used in revised truncation logic.)"	^30</body><body package="GlorpDatabase">maximumLengthOfTableName	"^&lt;Integer&gt; I return the max. length of a table name"	^30</body><body package="GlorpDatabase">primaryKeysAreAutomaticallyUnique	"Return false if, in addition to specifying something as a primary key, we must separately specify it as unique"	^true.</body><body package="GlorpDatabase">requiresTransactionForTableOperations	"Return true if we need a transaction in order to do table creation, deletion, and so forth. Some databases require it. Others don't like it"	^false.</body><body package="GlorpDatabase">sqlTextCurrentServerUTCTimestamp	^'SELECT SYS_EXTRACT_UTC(CURRENT_TIMESTAMP) FROM DUAL'</body><body package="GlorpDatabase">startColumnAddString	"The string we use as a prefix when adding a colum"	^' ( '.</body><body package="GlorpDatabase">supportsMillisecondsInTimes	^false.</body><body package="GlorpDatabase">usesNullForEmptyStrings	"Return true if this database is likely to use nil as an empty string value"	^true.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>conversion-times</category><body package="GlorpDatabase">printDate: aDate for: aType	| stream |	aDate isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: 'to_date('''.	self		printDate: aDate		isoFormatOn: stream.	stream nextPutAll: ''','''.	stream nextPutAll: 'YYYY-MM-DD'.	stream nextPutAll: ''')'.	^stream contents.</body><body package="GlorpDatabase">printTime: aTime for: aType	| stream |	aTime isNil ifTrue: [^'NULL'].	stream := WriteStream on: String new.	stream nextPutAll: 'to_date('''.	self		printTime: aTime		isoFormatOn: stream.	stream nextPutAll: ''','''.	stream nextPutAll: 'HH24:MI:SS'.	stream nextPutAll: ''')'.	^stream contents.</body><body package="GlorpDatabase">printTimestamp: aTimestamp on: stream for: aType	aTimestamp isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	stream nextPutAll: 'to_date('''.	self		printDate: aTimestamp		isoFormatOn: stream.	stream nextPut: $ .	self		printTime: aTimestamp		isoFormatOn: stream		milliseconds: false.	stream nextPutAll: ''','''.	stream nextPutAll: 'YYYY-MM-DD HH24:MI:SS'.	stream nextPutAll: ''')'.</body><body package="GlorpDatabase">timestampConverter	^DelegatingDatabaseConverter		named: #timestamp		hostedBy: self		fromStToDb: #asTimestamp:for:		fromDbToSt: #readTimestamp:for:.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>testing</category><body package="GlorpDatabase">canRecurse	^canRecurse</body><body package="GlorpDatabase">canUseInWhereClause: aValue type: aType	"This is mostly for test support purposes. If we know we can't use a particular kind of value in the where clause on some database, don't try."	(super canUseInWhereClause: aValue type: aType) ifFalse: [^false].	"On Oracle we effectively can't compare constants against blobs."	aType = self blob ifFalse: [^true].	aValue isNil ifTrue: [^true].	^false.</body><body package="GlorpDatabase">maximumQueryValueSize	"If there's a limit on how big a bound input parameter can be for a query, return it here. By default, no maximum. "	^4001</body><body package="GlorpDatabase">measuresStringFieldWidthsInBytes	"Return true if we measure the width of a string in bytes rather than characters. So, a 255-character field can hold 255 bytes worth of string, not 255 characters. This is important with encodings."	^true</body><body package="GlorpDatabase">supportsBinding	"Binding works only with VW EXDI so far"	^Dialect isVisualWorks.</body><body package="GlorpDatabase">supportsCompositeKeyArgsForOperand: aSymbol	"Strictly, the answer is		^#(#= #IN #&lt;&gt;) includes: aSymbolbut we take it for granted that we are never called on aSymbol that is not one of these values;  see the guard in #rewriteEquality.."	^true</body><body package="GlorpDatabase">supportsDuplicateFieldNamesInCompoundQueries	"Absurdly, Oracle, SQLServer and MySQL will not tolerate two unaliased fields in different tables but of the same name in a compound query, so the second (and subsequent) such fields must be aliased."	^false</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	"Oracle supports array binding.  When unbound, it does not support batched statements, i.e. cannot do INSERT ...; INSERT ...; INSERT... , but since version 9.0 it does support value sequences, i.e. it can do INSERT ALL INTO table (id, c) VALUES (1,'1') INTO table (id, c) VALUES (2,'2') INTO table (id, c) VALUES (3,'3'). Note that unbound, there is a 4000-byte limit on blobs."	^aCommand supportsGroupWriting and:		[self useBinding or: [aCommand supportsGroupWritingValues]]</body><body package="GlorpDatabase">supportsGroupWritingValues	"Conveniently, Oracle 10 is the first version that both supportsGroupWritingValues and supports BINARY_FLOAT and BINARY_DOUBLE, so we use this value for both cases."	^supportsGroupWritingValues ifNil: [false]</body><body package="GlorpDatabase">supportsSettingSequenceIncrement	"Return true if this platform can support creating a sequence with an increment other than 1."	^true.</body><body package="GlorpDatabase">supportsTableOwners	^true</body><body package="GlorpDatabase">useOracleOuterJoins	"Return true if we use the old Oracle x = y (+) syntax for outer joins"	^true.</body><body package="GlorpDatabase">usesArrayBindingToGroupWrite	"When bound, Oracle can group-write by array binding."	^true</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	^true</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">printBlob: aByteArray on: aStream for: aType	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	aStream nextPutAll: 'HEXTORAW('''.	aByteArray do: [:each |		each printOn: aStream paddedWith: $0 to: 2 base: 16].	aStream nextPutAll: ''')'.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>binding</category><body package="GlorpDatabase">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand arrayBindings.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>database-specific</category><body package="GlorpDatabase">compoundOperationFor: aSymbol	"Return the platform specific version of a compound statement symbol"	aSymbol == #EXCEPT ifTrue: [^'MINUS'].	^aSymbol.</body><body package="GlorpDatabase">printReturningFieldsOn: aCommand	"Return current field value from an UPDATE statement, bound as a PLSQL output parameter, e.g.		UPDATE my_table SET field = field + ? WHERE id=? RETURNING field INTO ?	returns the post-update value of 'field' (i.e. incremented by the value bound) in the output parameter :field."	"The first part is just as for Postgres ..."	aCommand nextPutAll: ' RETURNING '.	GlorpHelper		do: [:nextField | aCommand nextPutAll: nextField name]		for: aCommand relativeFields		separatedBy: [aCommand nextPut: $,; space].	"... but we need to add the bound parameters to accommodate Oracle."	aCommand nextPutAll: ' INTO '.	GlorpHelper		do: [:nextField | aCommand nextPutBindMarkerIn: nil]		for: aCommand relativeFields		separatedBy: [aCommand nextPut: $,; space].</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>accessing</category><body package="GlorpDatabase">vwEXDIConnectionClass	"Prefer Threaded over not if nothing is loaded, but use whatever is loaded if there is anything"	'OracleThreadedConnection' asQualifiedReference ifDefinedDo:		[:class | ^class].	'OracleConnection' asQualifiedReference ifDefinedDo:		[:class | ^class].			^'OracleThreadedConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'OracleThapiEXDI'</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>functions</category><body package="GlorpDatabase">initializeFunctions	| baseExists dbSpecificExists selectList baseNotExists dbSpecificNotExists |	super initializeFunctions.	functions at: #regexMatches: put: (PrefixFunction named: 'REGEXP_LIKE').	"Oracle doesn't allow functions like EXISTS in a field list, but will allow a select there as an argument to a function, such as DECODE. So print it that way if we're in the select list."	baseExists := functions at: #exists:.	dbSpecificExists := DualRoleFunction new.	dbSpecificExists function: '#exists:'.	dbSpecificExists whereClauseVersion: baseExists.	selectList := PrefixFunction named: 'DECODE'.	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 1 asGlorpExpression with: 0 asGlorpExpression].	selectList type: baseExists type.	dbSpecificExists selectListVersion: selectList.	dbSpecificExists type: baseExists type.	functions at: #exists: put: dbSpecificExists.	"And similarly NOT EXISTS"	baseNotExists := functions at: #notExists:.	dbSpecificNotExists := DualRoleFunction new.	dbSpecificNotExists function: '#notExists:'.	dbSpecificNotExists whereClauseVersion: baseNotExists.	selectList := PrefixFunction named: 'DECODE'.	selectList argumentModifierBlock: [:function :args | 		function base: args first.		Array with: 'x' asGlorpExpression with: 0 asGlorpExpression with: 1 asGlorpExpression].	selectList type: baseNotExists type.	dbSpecificNotExists selectListVersion: selectList.	dbSpecificNotExists type: baseExists type.	functions at: #notExists: put: dbSpecificNotExists.</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>services columns</category><body package="GlorpDatabase">createAlterColumnStatement: aField newType: aType usingExpression: expression	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll: aType typeString, ')'.	^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatement: aField setDefault: anObject	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.	self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DEFAULT';		space.	anObject printOn: sqlStatementStream.	sqlStatementStream		nextPutAll:  ')'.		^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementDropDefault: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'DEFAULT NULL)'.	^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementDropNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  'NULL)'.		^sqlStatementStream contents</body><body package="GlorpDatabase">createAlterColumnStatementSetNotNull: aField	| sqlStatementStream |	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll:  'ALTER TABLE';		space.		self printDDLTableNameFor: aField table on: sqlStatementStream.	sqlStatementStream		nextPutAll:  ' MODIFY (';		space;		nextPutAll: (self nameForColumn: aField name);		space;		nextPutAll:  self sqlTextForNOTNULLAttributeConstraint;		nextPutAll: ')'.		^sqlStatementStream contents</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>services tables</category><body package="GlorpDatabase">printSqlStatementToListTablesInSchema: schemaString on: aStream	"Not standardized"	| lowerSchema |	lowerSchema := (schemaString isNil or: [schemaString isEmpty])		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT table_name FROM all_tables '.	(lowerSchema notNil and: [lowerSchema notEmpty]) ifTrue:		[aStream 			nextPutAll: 'WHERE lower(owner) = ';			nextPut: $';			nextPutAll: lowerSchema;			nextPut: $']</body><body package="GlorpDatabase">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	" This query will test only for tables that the logged on user has access to... "	| lowerTableName lowerSchema |	lowerTableName := tableName asLowercase.	lowerSchema := schemaString isNil		ifTrue: [schemaString]		ifFalse: [schemaString asLowercase].	aStream		nextPutAll: 'SELECT count(*) FROM all_tables ';		nextPutAll: 'WHERE lower(table_name) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $';		nextPutAll: ' AND lower(owner) = ';		nextPut: $';		nextPutAll: lowerSchema;		nextPut: $'</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"Oracle has been supporting group writing with the VALUES clause at least since version 9.0.  A typical version string is: 'Oracle Database 11g Express Edition Release 11.2.0.2.0 - Production'."	| dbmsVersionIntegerArray |	dbmsVersionIntegerArray := Array		with: ((aDatabaseAccessor connection getServerVersion readStream upTo: $.) reverse readStream upTo: $ ) reverse asNumber	"dbmsMajorVersion"		with: ((aDatabaseAccessor connection getServerVersion readStream upTo: $.; upTo: $.) reverse readStream upTo: $.) reverse asNumber.	"dbmsMinorVersion"	supportsGroupWritingValues := dbmsVersionIntegerArray first &gt; 9.	canRecurse := self isVersion: #(11 2) notNewerThan: dbmsVersionIntegerArray.	"11.2.0.1 is 11g"</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	"I cannot group ;-separated INSERT statements but (if I am new enough - version 8 or later) I can group ,-separated values following a single INSERT statement when unbound.  When bound, the same applied but I can also bind an array of values to a single INSERT statement. As array binding is fastest, use it when bound, values when unbound."	^(aBoolean		ifTrue: [InsertCommand]		ifFalse: [self supportsGroupWritingValues				ifFalse: [InsertCommand]				ifTrue: [InsertMultiValuesTablesCommand]])		forRows: aCollectionOfDatabaseRows		useBinding: aBoolean		session: aSession</body><body package="GlorpDatabase">relativeUpdateCommand	"When binding, I can append to an update expression such that the post-update value will be returned in the same unit of work.  I use this ability when updating relative fields."	^BoundParametersUpdateCommand</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase">booleanToBooleanConverter	"Oracle doesnât support a boolean type.  By default, we map a boolean (true, false) in the image to an integer (1, 0) in the database."	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToInteger:for:		fromDbToSt: #convertIntegerToBoolean:for:</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>exdi specific</category><body package="GlorpDatabase">exdiTypeForBoolean	"Oracle has no boolean type.  OracleEXDI has no support for it."	^#Integer</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>type helpers</category><body package="GlorpDatabase">typesWithValues	self raw.	self longRaw.	^super typesWithValues</body></methods><methods><class-id>Glorp.OraclePlatform</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"Oracle has been supporting group writing with the VALUES clause at least since version 9.0 and recursion since 11.2.  For safety, we initialize to false, resetting in postLoginInitializeFromAccessor:."	super initialize.	canRecurse := false.	supportsGroupWritingValues := false.</body></methods><methods><class-id>Glorp.OraclePlatform class</class-id> <category>constants</category><body package="GlorpDatabase">reservedWords	^#('access' 'account' 'activate' 'add' 'admin' 'advise' 'after' 'all' 'all_rows' 'allocate' 'alter' 'analyze' 'and' 'any' 'archive' 'archivelog' 'array' 'as' 'asc' 'at' 'audit' 'authenticated' 'authorization' 'autoextend' 'automatic' 'backup' 'become' 'before' 'begin' 'between' 'bfile' 'bitmap' 'blob' 'block' 'body' 'by' 'cache' 'cache_instances' 'cancel' 'cascade' 'cast' 'cfile' 'chained' 'change' 'char' 'char_cs' 'character' 'check' 'checkpoint' 'choose' 'chunk' 'clear' 'clob' 'clone' 'close' 'close_cached_open_cursors' 'cluster' 'coalesce' 'column' 'columns' 'comment' 'commit' 'committed' 'compatibility' 'compile' 'complete' 'composite_limit' 'compress' 'compute' 'connect' 'connect_time' 'constraint' 'constraints' 'contents' 'continue' 'controlfile' 'convert' 'cost' 'cpu_per_call' 'cpu_per_session' 'create' 'curren_user' 'current' 'current_schema' 'cursor' 'cycle' 'dangling' 'database' 'datafile' 'datafiles' 'dataobjno' 'date' 'dba' 'dbhigh' 'dblow' 'dbmac' 'deallocate' 'debug' 'dec' 'decimal' 'declare' 'default' 'deferrable' 'deferred' 'degree' 'delete' 'deref' 'desc' 'directory' 'disable' 'disconnect' 'dismount' 'distinct' 'distributed' 'dml' 'double' 'drop' 'dump' 'each' 'else' 'enable' 'end' 'enforce' 'entry' 'escape' 'except' 'exceptions' 'exchange' 'excluding' 'exclusive' 'execute' 'exists' 'expire' 'explain' 'extent' 'extents' 'externally' 'failed_login_attempts' 'false' 'fast' 'file' 'first_rows' 'flagger' 'float' 'flob' 'flush' 'for' 'force' 'foreign' 'freelist' 'freelists' 'from' 'full' 'function' 'global' 'global_name' 'globally' 'grant' 'group' 'groups' 'hash' 'hashkeys' 'having' 'header' 'heap' 'identified' 'idgenerators' 'idle_time' 'if' 'immediate' 'in' 'including' 'increment' 'ind_partition' 'index' 'indexed' 'indexes' 'indicator' 'initial' 'initially' 'initrans' 'insert' 'instance' 'instances' 'instead' 'int' 'integer' 'intermediate' 'intersect' 'into' 'is' 'isolation' 'isolation_level' 'keep' 'key' 'kill' 'label' 'layer' 'less' 'level' 'library' 'like' 'limit' 'link' 'list' 'lob' 'local' 'lock' 'locked' 'log' 'logfile' 'logging' 'logical_reads_per_call' 'logical_reads_per_session' 'long' 'manage' 'master' 'max' 'maxarchlogs' 'maxdatafiles' 'maxextents' 'maxinstances' 'maxlogfiles' 'maxloghistory' 'maxlogmembers' 'maxsize' 'maxtrans' 'maxvalue' 'member' 'min' 'minextents' 'minimum' 'minus' 'minvalue' 'mls_label_format' 'mlslabel' 'mode' 'modify' 'mount' 'move' 'mts_dispatchers' 'multiset' 'national' 'nchar' 'nchar_cs' 'nclob' 'needed' 'nested' 'network' 'new' 'next' 'noarchivelog' 'noaudit' 'nocache' 'nocompress' 'nocycle' 'noforce' 'nologging' 'nomaxvalue' 'nominvalue' 'none' 'noorder' 'nooverride' 'noparallel' 'noreverse' 'normal' 'nosort' 'not' 'nothing' 'nowait' 'null' 'number' 'numeric' 'nvarchar2' 'object' 'objno' 'objno_reuse' 'of' 'off' 'offline' 'oid' 'oidindex' 'old' 'on' 'online' 'only' 'opcode' 'open' 'optimal' 'optimizer_goal' 'option' 'or' 'order' 'organization' 'oslabel' 'overflow' 'own' 'package' 'parallel' 'partition' 'password' 'password_grace_time' 'password_life_time' 'password_lock_time' 'password_reuse_max' 'password_reuse_time' 'password_verify_function' 'pctfree' 'pctincrease' 'pctthreshold' 'pctused' 'pctversion' 'percent' 'permanent' 'plan' 'plsql_debug' 'post_transaction' 'precision' 'preserve' 'primary' 'prior' 'private' 'private_sga' 'privilege' 'privileges' 'procedure' 'profile' 'public' 'purge' 'queue' 'quota' 'range' 'raw' 'rba' 'read' 'readup' 'real' 'rebuild' 'recover' 'recoverable' 'recovery' 'ref' 'references' 'referencing' 'refresh' 'rename' 'replace' 'reset' 'resetlogs' 'resize' 'resource' 'restricted' 'return' 'returning' 'reuse' 'reverse' 'revoke' 'role' 'roles' 'rollback' 'row' 'rowid' 'rownum' 'rows' 'rule' 'sample' 'savepoint' 'sb4' 'scan_instances' 'schema' 'scn' 'scope' 'sd_all' 'sd_inhibit' 'sd_show' 'seg_block' 'seg_file' 'segment' 'select' 'sequence' 'serializable' 'session' 'session_cached_cursors' 'sessions_per_user' 'set' 'share' 'shared' 'shared_pool' 'shrink' 'size' 'skip' 'skip_unusable_indexes' 'smallint' 'snapshot' 'some' 'sort' 'specification' 'split' 'sql_trace' 'standby' 'start' 'statement_id' 'statistics' 'stop' 'storage' 'store' 'structure' 'successful' 'switch' 'synonym' 'sys_op_enforce_not_null$' 'sys_op_ntcimg$' 'sysdate' 'sysdba' 'sysoper' 'system' 'table' 'tables' 'tablespace' 'tablespace_no' 'tabno' 'temporary' 'than' 'the' 'then' 'thread' 'time' 'timestamp' 'to' 'toplevel' 'trace' 'tracing' 'transaction' 'transitional' 'trigger' 'triggers' 'true' 'truncate' 'tx' 'type' 'ub2' 'uba' 'uid' 'unarchived' 'undo' 'union' 'unique' 'unlimited' 'unlock' 'unrecoverable' 'until' 'unusable' 'unused' 'updatable' 'update' 'usage' 'use' 'user' 'using' 'validate' 'validation' 'value' 'values' 'varchar' 'varchar2' 'varying' 'view' 'when' 'whenever' 'where' 'with' 'without' 'work' 'write' 'writedown' 'writeup' 'xid' 'year' 'zone') asSet.</body></methods><methods><class-id>Glorp.OraclePlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Oracle Native Driver'</body></methods><methods><class-id>Glorp.OracleODBCPlatform</class-id> <category>testing</category><body package="GlorpDatabase">isODBCPlatform	^true.</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	^false</body></methods><methods><class-id>Glorp.OracleODBCPlatform</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"Oracle has been supporting group writing with the VALUES clause at least since version 9.0 and recursion since 11.2.  A typical version string is: 'Oracle Database 11g Express Edition Release 11.2.0.2.0 - Production'."	| dbmsVersion |	dbmsVersion := aDatabaseAccessor connection dbmsVersion tokensBasedOn: $..	supportsGroupWritingValues := dbmsVersion first asNumber &gt; 9.	canRecurse := self isVersion: #(11 2) notNewerThan: dbmsVersion.</body></methods><methods><class-id>Glorp.OracleODBCPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Oracle ODBC Driver'</body></methods><methods><class-id>Glorp.InsertSelectRowCommand</class-id> <category>executing</category><body package="GlorpDatabase">executeBoundInRoundTrip: anAccessor	"Send one or more rows to the database in a single round trip, bound to an array of values.  The array will be  two-dimensional (arrayBindings) or one-dimensional (batchStatementBindings)."	| result |	result := anAccessor executeCommandBound: self.	self postWriteAssignSequenceInRoundTrip: result.	result release."	failed := false.The instvar 'failed' is initialized to false.  The last line could be	failed := failed &amp; (self needsRowCount and: [rowCount ~= self expectedNumberOfModifiedRows]).but that's needless until failed could ever be true.  Only update commands, not insert comands, need to check that the number of rows reported by the DB is the number expected, so this can just be false - unless we wish to set the number of rows returned by the select as rowCount and make these subclasses return true to #needsRowCount."</body><body package="GlorpDatabase">executeUnboundInRoundTrip: anAccessor	"We have multiple rows unbound, which we will write as a single row with many values."	| result |	result := anAccessor executeCommandUnbound: self.	self postWriteAssignSequenceInRoundTrip: result.	result release."	failed := failed &amp; false.The instvar 'failed' is initialized to false.  This line can remain commented out until failed could ever be true.  Only UpdateCommands with lock fields, never InsertCommands, need to check that the number of rows that the DB reports affected is the number expected."</body><body package="GlorpDatabase">postWriteAssignSequenceInRoundTrip: result	"Just the one row to get.  Using atIndex: instead of #first avoids needless isEmpty check."	| id |	id := result upToEnd.	self row		at: identityColumn		put: (id first atIndex: 1) asInteger.</body><body package="GlorpDatabase">printSQL	"Adjust the SQL to get the identity column value in the same round trip."	super printSQL.	self nextPutAll: self selectAddedIdentityColumnValues.</body></methods><methods><class-id>Glorp.InsertSelectRowCommand</class-id> <category>testing</category><body package="GlorpDatabase">supportsGroupWriting	^false</body></methods><methods><class-id>Glorp.InsertSelectRowCommand</class-id> <category>private-accessing</category><body package="GlorpDatabase">selectAddedIdentityColumnValues	"This select must be run in the same round trip as the insert that added the values.  It reads the table defined in #declareTableOfIdentitiesStatement, which was populated by the OUTPUT ... expression added in #outputAddedIdentityColumValuesIntoTable:."	^'; SELECT SCOPE_IDENTITY()'</body></methods><methods><class-id>Glorp.SAPDBPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'SAP'</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>accessing</category><body package="GlorpExpressions">add: anExpression	anExpression isNil ifTrue: [^self].	children add: anExpression.</body><body package="GlorpExpressions">addAll: anExpressionCollection	"Unlike other addAll:, this returns self, not its parameter, and callers use this.  (Rename it, to avoid confusion with the base parameter-returning addAll: in code-checking tools.)"	anExpressionCollection isNil ifTrue: [^self].	children addAll: anExpressionCollection.</body><body package="GlorpExpressions">canHaveBase	^self children anySatisfy: [:each | each canHaveBase]</body><body package="GlorpExpressions">children	^children.</body><body package="GlorpExpressions">isEmpty	^self size = 0.</body><body package="GlorpExpressions">size	^children size.</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>initialize</category><body package="GlorpExpressions">initialize	super initialize.	children := OrderedCollection new.</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	aSet add: self.	children do: [:each | each do: aBlock skipping: aSet].	aBlock value: self.</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>printing</category><body package="GlorpExpressions">printTreeOn: aStream	children do: [:each |		aStream nextPut: $(.		each printOn: aStream.		aStream nextPut: $).		aStream cr].</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>converting</category><body package="GlorpExpressions">asExpressionGroup	^self</body><body package="GlorpExpressions">asMultipleExpressionRelationOf: aRelationExpression	"We are the base (left child) of aRelationExpression whose relation is one of = , &lt;&gt; or IN.  (We were probably constructed explicitly using #getMappings: for lack of a descriptor whose primaryKeys matched our requirements.)  If we have two or more children and our platform does not allow composites for our relation, or our right-hand side is not a subselect, then we must be rewritten as a conjuction of AND:s or OR:s.  The expression intentionally begins unset, i.e. as nil, since we can AND: and OR: to nil parameter."	| expression orderedRetrievals tracing |	self size &lt; 2 ifTrue: [^aRelationExpression].	(aRelationExpression rightChild class == GeneralSubSelectExpression ifTrue:		[self queryLevelBaseExpression system platform supportsCompositeKeyArgsForOperand: aRelationExpression relation])			ifTrue: [^aRelationExpression]			ifFalse:				[tracing := aRelationExpression rightChild query tracing.				orderedRetrievals := tracing allTracings select:					[:each | tracing retrievalExpressions includes: each]].	1 to: children size do:		[:index || leftChild rightChild clause |		leftChild := children at: index.		rightChild := aRelationExpression rightChild.		rightChild class == GeneralSubSelectExpression ifTrue:			[rightChild := rightChild shallowCopy query: rightChild query cloneWithinQuery; yourself.			rightChild query retrieve: (orderedRetrievals at: index)].		clause := aRelationExpression shallowCopy leftChild: leftChild; rightChild: rightChild.		expression := aRelationExpression relation = #&lt;&gt; ifTrue: [clause OR: expression] ifFalse: [clause AND: expression]].	^expression</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>navigating</category><body package="GlorpExpressions">queryLevelBaseExpression	^(self children		detect: [:each | each canHaveBase]		ifNone: [^nil]) queryLevelBaseExpression</body><body package="GlorpExpressions">ultimateBaseExpression	^(self children		detect: [:each | each canHaveBase]		ifNone: [^nil]) ultimateBaseExpression</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>mapping</category><body package="GlorpExpressions">mappedFields	^self children		inject: OrderedCollection new		into: [:all :each | all addAll: each mappedFields. all]</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>printing SQL</category><body package="GlorpExpressions">printSQLOn: aStream withParameters: anArray	aStream nextPutAll: '('.	GlorpHelper 		do: [:expr | expr printSQLOn: aStream withParameters: anArray]		for: self children		separatedBy: [aStream nextPutAll: ', '].	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.ExpressionGroup</class-id> <category>api</category><body package="GlorpExpressions">get: aSymbol withArguments: anArray	"This is a direct clone of the code in ObjectExpression which is what MappingExpression inherits (If the ExpressionGroup has a single child, it would usually be a mapping expression), minus behaviours we suspect are not relevant to functiona groups and/or should be pushed within them to relevant members of the group."	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	"specialExpression := self performSpecialExpression: aSymbol withArguments: anArray.	specialExpression isNil ifFalse: [^specialExpression].	anArray isEmpty ifTrue: [^self get: aSymbol]."	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body></methods><methods><class-id>Glorp.ExpressionGroup class</class-id> <category>instance creation</category><body package="GlorpExpressions">with: anExpression	^self new add: anExpression.</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>initializing</category><body package="GlorpUnitOfWork">initialize	self initializeUndoMap.</body><body package="GlorpUnitOfWork">initializeUndoMap	undoMap := IdentityDictionary new: 1000.	collectionMementos := IdentityDictionary new: 200.</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>begin/commit/abort</category><body package="GlorpUnitOfWork">abort	undoMap keysAndValuesDo: [:original :copy | self restoreStateOf: original toThatOf: copy]</body><body package="GlorpUnitOfWork">abort: original	| copy |	copy := undoMap at: original ifAbsent: [^self].	self restoreStateOf: original toThatOf: copy</body><body package="GlorpUnitOfWork">begin	self initializeUndoMap</body><body package="GlorpUnitOfWork">commit	self initializeUndoMap</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>accessing</category><body package="GlorpUnitOfWork">collectionMementoFor: anObject	anObject isNil ifTrue: [^#()].	^collectionMementos at: anObject ifAbsent: [self mementoFor: anObject].</body><body package="GlorpUnitOfWork">collectionMementos	^collectionMementos.</body><body package="GlorpUnitOfWork">mementoFor: anObject	^undoMap at: anObject.</body><body package="GlorpUnitOfWork">undoMap	^undoMap</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>private/registering</category><body package="GlorpUnitOfWork">shallowCopyOf: anObject ifNotNeeded: aBlock	| copy |	copy := anObject shallowCopy.	^copy == anObject 		ifTrue: [aBlock value]		ifFalse: [copy]</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>private/restoring</category><body package="GlorpUnitOfWork">isShapeOf: original differentThanThatOf: copy	^original class ~~ copy class or: [original glorpBasicSize ~= copy glorpBasicSize]</body><body package="GlorpUnitOfWork">restoreIndexedInstanceVariablesOf: original toThoseOf: copy	copy glorpStartOfIndexedInstVars to: copy glorpEndOfIndexedInstVars do: [:index |		original isString 			ifTrue: [original at: index put: (copy at: index)]			ifFalse: [original basicAt: index put: (copy basicAt: index)]].</body><body package="GlorpUnitOfWork">restoreNamedInstanceVariablesOf: original toThoseOf: copy	1 to: copy class instSize do: [:index |		original instVarAt: index put: (copy instVarAt: index)]</body><body package="GlorpUnitOfWork">restoreShapeOf: original toThatOf: copy	| newOriginal |	(copy class isBits or: [copy class isVariable])		ifTrue: [newOriginal := copy class basicNew: copy glorpBasicSize]		ifFalse: [newOriginal := copy class basicNew].	original become: newOriginal.</body><body package="GlorpUnitOfWork">restoreStateOf: original toThatOf: copy	"The functional need for the [original = copy ifTrue: [^self]] guard is to avoid attempting to rewrite immutables (the guard also gives a performance gain).  The optional GlorpVWWriteBarrierTracker uses immutability to auto-register objects that are read and then changed, so we cannot simply ban immutables from the register.  However Doubles, FixedPoints and Strings are not immediates (so can be in the register) but can be literals, and thus immutable;  rolling back a unit of work (if, as is usually the case, its session is not using a GlorpVWWriteBarrierTracker to track changes) would cause an error if we did not have the guard:  the following statements would attempt to rewrite the internals of these immutables.  Using #isImmutableLiteral as the guard would catch objects (e.g. literal arrays) that could have been changed when GlorpVWWriteBarrierTracker was in use.  We therefore use #isString and #respondsToArithmetic (immediates never get this far, so that catches FixedPoints and LimitedPrecisionReals - and Points FWIW)."	(self isShapeOf: original differentThanThatOf: copy)		ifTrue: [self restoreShapeOf: original toThatOf: copy]		ifFalse: [(original isString or: [original respondsToArithmetic]) ifTrue:				[original = copy ifTrue: [^self]]].	self restoreNamedInstanceVariablesOf: original toThoseOf: copy.	self restoreIndexedInstanceVariablesOf: original toThoseOf: copy.</body></methods><methods><class-id>Glorp.ObjectTransaction</class-id> <category>registering</category><body package="GlorpUnitOfWork">isRegistered: anObject 	"Note: We can never have a situation where a proxy is registered but its contents aren't, so we don't have to worry about that ambiguous case."	| realObject |	realObject := self realObjectFor: anObject ifNone: [^false].	^undoMap includesKey: realObject.</body><body package="GlorpUnitOfWork">realObjectFor: anObject 	"If this is a proxy, return the contents (if available). Otherwise, return nil"	^self realObjectFor: anObject ifNone: [nil].</body><body package="GlorpUnitOfWork">realObjectFor: anObject ifNone: aBlock	"If this is a proxy, return the contents (if available). Otherwise, evaluate the block"	^anObject isGlorpProxy 		ifTrue: [anObject isInstantiated ifTrue: [anObject getValue] ifFalse: [aBlock value]]		ifFalse: [anObject]</body><body package="GlorpUnitOfWork">register: anObject	"Make anObject be a member of the current transaction. Return the object if registered, nil otherwise"	| copy realObject |	realObject := self realObjectFor: anObject ifNone: [^nil].	"The next line inlines #isRegistered: - we just got the real object so need not get it again."	(undoMap includesKey: realObject) ifTrue: [^nil].	copy := self shallowCopyOf: realObject ifNotNeeded: [^nil].	undoMap at: realObject put: copy.	self registerTransientInternalsOfCollection: realObject.	^realObject</body><body package="GlorpUnitOfWork">registeredObjectsDo: aBlock	"Iterate over all our objects. Note that this will include objects without descriptors. Be sure we're iterating over a copy of the keys, because this will add objects to the undoMap. Allow the block to return a collection which we will then add to the list of things to process, until there's nothing further"	| newAdditions previousVersion |	newAdditions := undoMap keys.	previousVersion := newAdditions.	[newAdditions isEmpty]		whileFalse:			[newAdditions do: aBlock.			newAdditions := OrderedCollection new.			undoMap				keysDo:					[:eachKey | (previousVersion includes: eachKey) ifFalse: [newAdditions add: eachKey]].			newAdditions isEmpty ifFalse: [previousVersion := undoMap keys]].</body><body package="GlorpUnitOfWork">registerTransientInternalsOfCollection: aCollection	"If this is a collection, then we may need to register any internal structures it has, e.g. an internal array. This is implementation dependent for the collection. We will also explicitly exclude strings"	aCollection glorpIsCollection ifFalse: [^self].	aCollection class isBits ifTrue: [^self].	collectionMementos at: aCollection put: aCollection copy.	aCollection glorpRegisterCollectionInternalsIn: self."For this to work, the dialect must not copy collections so shallowly that internals are reused identically.In VW, Dictionary copy calls postCopy, which copies the associations or value collection (but not thekeys).  Without this, mementos added to the original would also be added to the copy.  In VA, sendingcopy to a Dictionary does a shallow copy.  In VA, inline the call of copy to shallowCopy and send thepostCopy call to it explicitly to get the behaviour we need without changing Dictionary copy behaviourin VA, which might have side-effects.  This feature's tests have been altered to check this copy safety."</body></methods><methods><class-id>Glorp.ObjectTransaction class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork">new	^super new initialize</body></methods><methods><class-id>Glorp.RecursiveBuilder</class-id> <category>building objects</category><body package="GlorpMappings">knitResultIn: aCursoredStream	"My rows more immediately knit to eich other than to the related builder instance, it being an ancestor ofthe recursion."	| relatedBuilder |	expression canKnit ifFalse: [^self].	relatedBuilder := aCursoredStream objectBuilderFor: expression base.	(relatedBuilder isNil or: [relatedBuilder instance isNil]) ifFalse:		[expression mapping knitFromBuilder: relatedBuilder toBuilder: self].</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>accessing</category><body package="GlorpMappings">allClasses	allClasses isEmpty ifTrue: [allClasses := self constructAllClasses].	^allClasses</body><body package="GlorpMappings">allClassModels	^self allClasses collect: [:each | 		self classModelFor: each].</body><body package="GlorpMappings">allDescriptors	^self allClasses collect: [:each | 		self descriptorFor: each].</body><body package="GlorpMappings">allSequences	sequences isEmpty ifFalse: [^sequences].	sequences := self allSequencesFor: self allTables.	^sequences.</body><body package="GlorpMappings">allSequencesFor: aCollection	"Find all the sequences associated with aCollectionOfTables"	| result |	result := Dictionary new.	aCollection do: [:each |		each allSequences keysAndValuesDo: [:eachName :eachSequence |				result at: eachName put: eachSequence]].	^result.</body><body package="GlorpMappings">allTableNames	"Return a list of all the table names that this system uses."	^#().</body><body package="GlorpMappings">allTables	tables isEmpty ifTrue: [self constructAllTables].	^tables.</body><body package="GlorpMappings">cachePolicy	"Return the default cache policy that will be used for descriptors that don't specify their own policy"	cachePolicy isNil ifTrue: [cachePolicy := CachePolicy default].	^cachePolicy.</body><body package="GlorpMappings">cachePolicy: aCachePolicy	cachePolicy := aCachePolicy.</body><body package="GlorpMappings">databaseSchema	"See deferentialSetSchema: for states in which this will DNU."	^self session schema</body><body package="GlorpMappings">platform	^platform</body><body package="GlorpMappings">platform: dbPlatform	platform := dbPlatform</body><body package="GlorpMappings">session	^session</body><body package="GlorpMappings">session: anObject	session := anObject</body><body package="GlorpMappings">useDirectAccessForMapping	^useDirectAccessForMapping</body><body package="GlorpMappings">useDirectAccessForMapping: anObject	useDirectAccessForMapping := anObject</body><body package="GlorpMappings">validateDescriptorSystem	^self class validateDescriptorSystem</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>api</category><body package="GlorpMappings">addClassModelFor: aClass	^classModels		at: aClass		ifAbsentPut: [self newClassModelFor: aClass]</body><body package="GlorpMappings">classModelFor: aClass	(self allClasses includes: aClass) ifFalse: [^nil].	^classModels		at: aClass		ifAbsentPut: [self newClassModelFor: aClass]</body><body package="GlorpMappings">createMappingsFromClassModelIn: aDescriptor 	aDescriptor classModel attributesDo: 			[:each | 			(aDescriptor mappingForAttributeNamed: each name) isNil 				ifTrue: 					[self createMappingIn: aDescriptor						fromClassModelForAttributeNamed: each name]]</body><body package="GlorpMappings">databaseIdentitySequenceNamed: aString	^self databaseSequenceNamed: aString</body><body package="GlorpMappings">databaseSequenceNamed: aString	^sequences at: aString asUppercase ifAbsentPut: [platform newDatabaseSequenceNamed: aString].</body><body package="GlorpMappings">databaseSequenceNamed: aString ifAbsentPut: aBlock	^sequences at: aString asUppercase ifAbsentPut: aBlock.</body><body package="GlorpMappings">databaseTableClass	^self class databaseTableClass</body><body package="GlorpMappings">descriptorFor: aClassOrObject 	| theClass newDescriptor |	aClassOrObject == Proxy ifTrue: [self error: 'Cannot find descriptor for the class Proxy. Pass in the instance'].	theClass := aClassOrObject glorpCanHaveDescriptorDirectly 				ifTrue: [aClassOrObject]				ifFalse: [aClassOrObject isGlorpProxy 							ifTrue: [aClassOrObject getValue class]							ifFalse: [aClassOrObject class]].	^descriptors		at: theClass		ifAbsent: [			(self allClasses includes: theClass) ifTrue: [				newDescriptor := self newDescriptorFor: theClass.				descriptors at: theClass put: newDescriptor.				self initializeDescriptor: newDescriptor.				newDescriptor.			]].</body><body package="GlorpMappings">existingTableNamed: aString	^tables at: aString asUppercase ifAbsent: [self error: 'missing table'].</body><body package="GlorpMappings">findDescriptorForTable: aTable	"Return a descriptor that uses aTable. If there is more than one, the choice is random."	^descriptors detect: [:each | each tables includes: aTable] ifNone: [nil].</body><body package="GlorpMappings">findDescriptorsForTable: aTable	"Return all descriptors that use aTable."	^descriptors select: [:each | each tables includes: aTable].</body><body package="GlorpMappings">flushAllClasses	allClasses := OrderedCollection new.</body><body package="GlorpMappings">hasDescriptorFor: aClassOrObject 	^(self descriptorFor: aClassOrObject) notNil.</body><body package="GlorpMappings">sequenceTypeNamed: aString	"Return a sequence type whose sequence has the given name."	^self platform sequence sequence: (self databaseSequenceNamed: aString).</body><body package="GlorpMappings">tableNamed: aString	^self tableNamed: aString ifNone: [NoTableFound new parameter: aString; raiseRequest].</body><body package="GlorpMappings">tableNamed: aString ifNone: aBlock	^tables at: aString asString asUppercase		ifAbsent: 			[| newTable |			newTable := self databaseTableClass new.			newTable name: aString.			tables at: aString asUppercase put: newTable.			self initializeTable: newTable.			newTable isEmpty				ifTrue: 					[tables removeKey: aString asUppercase.					^aBlock value].			newTable]</body><body package="GlorpMappings">typeResolverFor: aClassOrObject 	| theClass |	aClassOrObject == Proxy ifTrue: [self error: 'Cannot find type resolver for the class Proxy. Pass in the instance'].	theClass := aClassOrObject glorpCanHaveDescriptorDirectly 				ifTrue: [aClassOrObject]				ifFalse: [aClassOrObject isGlorpProxy ifTrue: [aClassOrObject getValue class] ifFalse: [aClassOrObject class]].	^typeResolvers at: theClass ifAbsentPut: [self newTypeResolverFor: theClass]</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>private</category><body package="GlorpMappings">converterBetweenStType: aClass andField: aField 	| selector |	selector := ('converterBetween' , aClass name , 'AndField:') asSymbol.	(self respondsTo: selector) ifTrue: [^self perform: selector with: aField].	^aField converterForStType: aClass</body><body package="GlorpMappings">createMappingIn: aDescriptor fromClassModelForAttributeNamed: aSymbol 	| attribute referenceModel |	attribute := aDescriptor classModel attributeNamed: aSymbol.	referenceModel := self classModelFor: attribute type.	referenceModel isNil 		ifTrue: 			[^(aDescriptor newMapping: DirectMapping) from: aSymbol				to: (aDescriptor table 						fieldNamed: (self fieldNameForAttributeName: aSymbol))]		ifFalse: 			[attribute isCollectionAttribute 				ifTrue: [^(aDescriptor newMapping: ToManyMapping) attributeName: aSymbol]				ifFalse: [^(aDescriptor newMapping: OneToOneMapping) attributeName: aSymbol]]</body><body package="GlorpMappings">deferentialSetSchema: newTable	"If the table already has a schema, do not overwrite it.  Avoiding an ill-constructed login setting a schema to nil.  (DatabaseTable initializes schema to the empty string, not nil, although its code allows for nil schemas so making this convenient rather than essential)."	| temp |	newTable schema isEmpty ifFalse: [^self].	(temp := self session) isNil ifTrue: [^self].	(temp := temp accessor) isNil ifTrue: [^self].	(temp := temp currentLogin) isNil ifTrue: [^self].	(temp := temp schema) isNil ifTrue: [^self].	newTable schema: temp.</body><body package="GlorpMappings">initializeClassModel: aClassModel	| selector |	selector := ('classModelFor' , aClassModel describedClass name , ':')		asSymbol.	(self respondsTo: selector)		ifTrue: [^self perform: selector with: aClassModel].	(aClassModel describedClass respondsTo: #glorpSetupClassModel:forSystem:)		ifTrue:			[^aClassModel describedClass				glorpSetupClassModel: aClassModel				forSystem: self].	"Otherwise, just initialize it dynamically, so that old code with only descriptors will still work"	^aClassModel.</body><body package="GlorpMappings">initializeDescriptor: aDescriptor 	| selector |	selector := ('descriptorFor' , aDescriptor describedClass name , ':') asSymbol.	(self respondsTo: selector) 		ifTrue: [self perform: selector with: aDescriptor]		ifFalse: [			(aDescriptor describedClass respondsTo: #glorpSetupDescriptor:forSystem:)				ifTrue: [aDescriptor describedClass								glorpSetupDescriptor: aDescriptor								forSystem: self]				ifFalse: [self noDescriptorInitializerFound: aDescriptor]].</body><body package="GlorpMappings">initializeTable: newTable	| initializerName |	initializerName := ('tableFor' , (newTable name asUppercase) , ':') asSymbol.	(self respondsTo: initializerName)		ifTrue: [self perform: initializerName with: newTable]		ifFalse: [self noTableInitializerFound: newTable].	newTable postInitializeIn: self.	self deferentialSetSchema: newTable.</body><body package="GlorpMappings">newClassModelFor: aClass	| newClassModel |	newClassModel := GlorpClassModel new.	newClassModel system: self.	newClassModel describedClass: aClass.	self initializeClassModel: newClassModel.	^newClassModel.</body><body package="GlorpMappings">newDescriptorFor: aClass	| newDescriptor |	(self allClasses includes: aClass) ifFalse: [^nil].	newDescriptor := Descriptor new.	newDescriptor system: self.	newDescriptor classModel: (self classModelFor: aClass).	^newDescriptor.</body><body package="GlorpMappings">newTypeResolverFor: aClass 	| selector |	(self allClasses includes: aClass) ifFalse: [^nil].	selector := ('typeResolverFor' , aClass name) asSymbol.	^(self respondsTo: selector) 		ifTrue: [self perform: selector]		ifFalse: [aClass glorpTypeResolver]</body><body package="GlorpMappings">privateAndBasicAddDescriptorFor: anObject as: aDescriptor	"Just add the descriptor and don't try to validate. anObject may not actually even be a class. Assume the descriptor is already properly initialized"	descriptors at: anObject put: aDescriptor.	aDescriptor system: self.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>initialization</category><body package="GlorpMappings">addClassesFromDescriptorMethodsFor: aClass	| match |	match := 'descriptorFor'.	Dialect selectorsFor: aClass do: 			[:each | 			(each copyFrom: 1 to: (match size min: each size)) = match				ifTrue:					[| className actualClass |					className := each copyFrom: match size + 1 to: each size - 1.					actualClass := Dialect						lookupClassNamed: className						inContextOf: self class						ifAbsent: [nil].					actualClass isNil ifFalse: [allClasses add: actualClass]]].</body><body package="GlorpMappings">addTablesFromInitializeMethodsFor: aClass	| match |	match := 'tableFor'. 	Dialect selectorsFor: aClass do:			[:each | 			(each copyFrom: 1 to: (match size min: each size)) = match				ifTrue:					[| tableName |					tableName := each copyFrom: match size + 1 to: each size - 1.					self tableNamed: tableName]].</body><body package="GlorpMappings">constructAllClasses	"Subclasses can override this method to add classes. But by default we also look for all descriptor methods in our system, and add them to the class list, so if the methods are written there, then we don't need to do anything further. If the descriptor methods are defined on the classes themselves, then we'll still have to construct the class list manually."	self constructClassesFromDescriptorMethods.	^allClasses.</body><body package="GlorpMappings">constructAllTables	"Subclasses can override this method to add tables to the list. But by default we also look for all table methods in our system, and add them to the class list, so if the methods are written there, then we don't need to do anything further. If the table methods are defined on the classes themselves, then we'll still have to construct the list manually."	self allTableNames do: [:each | 		self tableNamed: each asString].	self constructTablesFromInitializeMethods.	^tables.</body><body package="GlorpMappings">constructClassesFromDescriptorMethods	"This might be better done in reverse - more general then more specific - but of couse we must not add what will then be overridden.  In Store, we get all classes here then list them in subclasses - so the effect is to puplicate all classes, triplicating or quadruplicating if there are subsubclasses with specific overrides."	self withAllSuperclassesDo: [:aClass | self addClassesFromDescriptorMethodsFor: aClass].	self class includeAllClassesWithDescriptorMethods		ifTrue:			[Object withAllSubclasses				do:					[:each | 					(each class						compiledMethodAt: #glorpSetupDescriptor:forSystem:						ifAbsent: [nil]) isNil ifFalse: [allClasses add: each]]].</body><body package="GlorpMappings">constructTablesFromInitializeMethods	self withAllSuperclassesDo: [:aClass | self addTablesFromInitializeMethodsFor: aClass].</body><body package="GlorpMappings">initialize	descriptors := Dictionary new.	tables := Dictionary new.	classModels := Dictionary new.	typeResolvers := Dictionary new.	sequences := Dictionary new.	useDirectAccessForMapping := true.	allClasses := OrderedCollection new.</body><body package="GlorpMappings">postCopyForRecursion	"If we add classModels, descriptors or tables, make sure these added items do not appear in the original."	classModels := classModels copy.	descriptors := descriptors copy.	tables := tables copy."These are not changed in our current usage; copy them if later needed	typeResolvers := typeResolvers copy.	sequences := sequences copy.	allClasses := allClasses copy."</body><body package="GlorpMappings">setUpDefaults	"For systems that are configurable:  configure them with the default settings for their application."</body><body package="GlorpMappings">withAllSuperclassesDo: aBlock	| currentClass |	currentClass := self class.	[currentClass == Object]		whileFalse:			[aBlock value: currentClass.			currentClass := currentClass superclass].</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>settings</category><body package="GlorpMappings">shouldForeignKeyValueBeTreatedAsNull: aValue	"Return true if this foreign key value should be treated as null, meaning there's no relationship. Normally this means just nil, but descriptor systems can override if they have special values which they use (e.g. 0) that indicate a missing relationship. This can improve performance by avoiding unnecessary queries to the database for things we know will never return a result"	^aValue isNil.</body><body package="GlorpMappings">shouldResetExpiryTimeForObjectOfClass: aClass readFrom: aQuery	"Return true if, when an object is read from a query, even if it's not refreshing. we 'touch' it, resetting its expiry time. By default, we do this if the cache policy for that type of object will remove from the cache. The rationale is that this means we're using the object. Removing an object in use is a very bad thing, and can cause loss of identity and other bad things. However, if expiry only indicates a need to refresh, we don't need to touch the object. Subclasses can override to provide different behaviour."	aQuery shouldRefresh ifTrue: [^true].	aQuery returnProxies ifTrue: [^false].	^(self session cacheForClass: aClass)  willRemoveItems</body><body package="GlorpMappings">useJoinsForAnySatisfy	useJoinsForAnySatisfy isNil ifTrue: [useJoinsForAnySatisfy := false].	^useJoinsForAnySatisfy.</body><body package="GlorpMappings">useJoinsForAnySatisfy: aBoolean	useJoinsForAnySatisfy := aBoolean.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>validation</category><body package="GlorpMappings">initializeRuntimeMappings	session isNil ifFalse: [session system == self ifFalse: [InvalidSessionSetup raiseErrorString: 'Invalid session setup']].	self allTables.	self allDescriptors do: [:each | each initializeRuntimeMappings]</body><body package="GlorpMappings">noDescriptorInitializerFound: aDescriptor	self error: 'No descriptor initializer found for ', aDescriptor printString.</body><body package="GlorpMappings">noTableInitializerFound: aDatabaseTable	self error: 'No table initializer found for ', aDatabaseTable printString.</body><body package="GlorpMappings">unmappedInstanceVariables	"Return a list, for all of our classes, of instance variables with no mappings. This can be used by inspection to see if we're missing mappings we think we ought to have."	"self unmappedInstanceVariables"	| unmapped |	unmapped := Dictionary new.	self allClasses do: [:eachClass |		eachClass allInstVarNames do: [:eachInstVarName |			((self descriptorFor: eachClass) mappingForAttributeNamed: eachInstVarName asSymbol)				isNil ifTrue: [					(unmapped at: eachClass ifAbsentPut: [OrderedCollection new])						add: eachInstVarName]]].	^unmapped.</body><body package="GlorpMappings">validate	session isNil ifFalse: [session system == self ifFalse: [InvalidSessionSetup  raiseErrorString:  'Invalid session setup']].	self allTables do: [:each | each validateIn: self].	self allClassModels do: [:each | each validateIn: self].	self allDescriptors do: [:each | each validate].</body><body package="GlorpMappings">validateDescriptor: aDescriptor	"Validate aDescriptor in the context of this system, doing any specific validations that need the full environment information or rely on subclass-specific information here."</body><body package="GlorpMappings">validateRows: aUnitOfWork	"This is a hook to allow the system to do application-specific validation of the rows to be written. I suppose it's also possible to modify the rows here. Subclasses can override if they have useful work to do here. This will be called after the rows are generated, pre-write notification has been sent, rows have been sorted for writing, and and just before sequence numbers (if pre-write) are assigned, and writing starts"</body><body package="GlorpMappings">validateRowsPostWrite: aUnitOfWork	"Validate after writing. This is a bit late, but some things may not be catchable ahead of time"</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>optimization parameters</category><body package="GlorpMappings">maximumSizeToGroupWriteFor: aRowBasedCommand	"If we are going to group write, how many rows of the command should we do it for at once. Normally we delegate this to the platform, but we allow the system to intervene if desired.  For example, a system that knows it does not use serial types can ignore the question of identity columns."	^platform maximumSizeToGroupWriteFor: aRowBasedCommand</body><body package="GlorpMappings">shouldUpdateOnlyChangedFieldsFor: aCommand	"Return true if we should write only changed fields out in an update statement, or if we should write all of them. There are various tradeoffs.  Writing only the changed fields will produce less SQL for any one statement, but may create more variations of the statement over time:  if we routinely update different subsets of fields in normal use, each such subset needs its own statement (so more prepared statements are cached if we're using binding);  if we group-write updates, Glorp must divide each group into compatible subgroups before sending each subgroup to the database.  As against this, a system may have permissions set limiting the columns that can be updated, so may only ever want to update the changed fields."	^true"The default was	aCommand useBinding notthis could be restored at release, after the new default above has caused sufficient in-house testing."</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>callbacks</category><body package="GlorpMappings">additionalRelatedRowsFor: aRow in: aRowMap	"This method serves as a hook. It is called when sorting rows before writing to the database, and can be used to return a list of additional related rows that aren't found by the normal foreign key constraints. These rows will act as an ordering constraint, and will have to be written before aRow."	^nil.</body><body package="GlorpMappings">fieldNameForAttributeName: aSymbol 	^aSymbol asString asUppercase</body><body package="GlorpMappings">joinFor: aMapping toTables: toTables fromConstraints: fromConstraints toConstraints: toConstraints	"Return the join to be used for aMapping. The set of tables we expect this to be related to, and the constraints from this table, and to this table are provided as possibly useful input."	| numberOfConstraints |	numberOfConstraints := (Set new addAll: toConstraints; addAll: fromConstraints; yourself) size.	numberOfConstraints = 0 ifTrue: [		CannotAutomaticallyDetermineJoin new 			tables: toTables;			constraints: (toConstraints, fromConstraints);			signal: 'Cannot automatically determine join, no constraints found.'].	numberOfConstraints &gt; 1 ifTrue: [		CannotAutomaticallyDetermineJoin new			tables: toTables;			constraints: (toConstraints, fromConstraints);			signal: 'Cannot automatically determine join, too many constraints found.'].	^toConstraints isEmpty ifTrue: [fromConstraints first asReverseJoin] ifFalse: [toConstraints first asJoin].</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>session creation</category><body package="GlorpMappings">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system. This is the easiest way to get a full blown session going."	| newSession |	platform isNil ifTrue: [self platform: aGlorpLogin database].	aGlorpLogin database class = self platform class ifFalse: [self error: 'Login is incompatible with the database specified in the descriptor system'].	session isNil ifFalse: [InvalidSessionSetup raiseErrorString: 'DescriptorSystem already has a session; resume this error if this was intended.'].	newSession := GlorpSession new.	newSession accessor: (DatabaseAccessor forLogin: aGlorpLogin).	newSession system: self.	^newSession</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>internal/writing</category><body package="GlorpMappings">tablesInCommitOrder	^(TableSorter for: self allTables) sort.</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>sequences</category><body package="GlorpMappings">sequenceNameForField: aDatabaseField	"Return the name of the sequence we will use for a field. Subclasses can override to use different naming conventions."	^(aDatabaseField table sqlString), '_', (aDatabaseField name), '_seq'</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>recursion</category><body package="GlorpMappings">cloneDescriptorOfClass: aGlorpCanHaveDescriptorDirectly for: anotherGlorpCanHaveDescriptorDirectly	| newDescriptor |	newDescriptor := (session system descriptorFor: aGlorpCanHaveDescriptorDirectly) copy.	newDescriptor system: self.	newDescriptor classModel: newDescriptor classModel copy.	newDescriptor classModel system: self.	newDescriptor classModel		privateAndBasicSetDescribedClass: anotherGlorpCanHaveDescriptorDirectly.	self		privateAndBasicAddDescriptorFor: anotherGlorpCanHaveDescriptorDirectly		as: newDescriptor.	^newDescriptor</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>instance creation</category><body package="GlorpMappings">forPlatform: dbPlatform	^super new initialize;		platform: dbPlatform</body><body package="GlorpMappings">new	^super new initialize.</body><body package="GlorpMappings">sessionForLogin: aGlorpLogin	"Create a session associated with the given login, and using us as a descriptor system. This is the easiest way to get a full blown session going."	| system session |	system := self forPlatform: aGlorpLogin database.	session := GlorpSession new.	session accessor: (DatabaseAccessor forLogin: aGlorpLogin).	session system: system.	^session.</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>configuration</category><body package="GlorpMappings">includeAllClassesWithDescriptorMethods	"If this is true, the descriptor system will automatically include all classes that define the #glorpSetupDescriptor:forSystem: method on the class side. If false, it will only include classes which have descriptor methods defined in this class, or those explicitly added in the #constructAllClasses method."	^false.</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>utility</category><body package="GlorpMappings">createTablesFor: aLogin	"Create the tables for this descriptor system in the given database. This will fail if the tables already exist. Use recreateTables for that."	| session |	session := self sessionForLogin: aLogin.	session login.	[session createTables] ensure: 		[session logout].</body><body package="GlorpMappings">dropTablesFor: aLogin	"Drop the tables for this descriptor system in the given database."	| session |	session := self sessionForLogin: aLogin.	session login.	[session dropTables] ensure: [session logout].</body><body package="GlorpMappings">recreateTablesFor: aLogin	"Drop and recreate the tables for this descriptor system in the given database."	| session |	session := self sessionForLogin: aLogin.	session login.	[session recreateTables] ensure: [session logout].</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>class defaults</category><body package="GlorpMappings">databaseTableClass	^DatabaseTable</body><body package="GlorpMappings">defaultValidateValue	"Subclasses can define this not answer #always, and to set it to be things like #firstTime, #never, etc."	^#always</body><body package="GlorpMappings">validateDescriptorSystem	"Subclasses can define this to do other things, and add their own behavior to do things like only first time, never, etc."	validateDescriptorSystem isNil ifTrue: [self validateDescriptorSystem: self defaultValidateValue].	^validateDescriptorSystem == #always</body><body package="GlorpMappings">validateDescriptorSystem: aSymbol	"Typical values are #always and #never"	validateDescriptorSystem := aSymbol</body></methods><methods><class-id>Glorp.DynamicDescriptorSystem</class-id> <category>accessing</category><body package="GlorpMappings">addEmptyDescriptorFor: aClass 	| descriptor |	descriptor := Descriptor new.	descriptor system: self.	self privateDescriptorAt: aClass put: descriptor.	descriptor classModel: (self classModelFor: aClass).	^descriptor</body><body package="GlorpMappings">addEmptyTableNamed: aString 	| table |	table := self databaseTableClass named: aString.	self privateTableAt: aString put: table.	^table</body><body package="GlorpMappings">allClasses	^descriptors keys</body><body package="GlorpMappings">allTableNames	^tables keys</body><body package="GlorpMappings">attributeNameToFieldNameBlock: aBlock	attributeNameToFieldNameBlock := aBlock</body><body package="GlorpMappings">initializeClassModel: aClassModel	"Assume we'll initialize it either before or after this"</body></methods><methods><class-id>Glorp.DynamicDescriptorSystem</class-id> <category>private</category><body package="GlorpMappings">privateDescriptorAt: aClass put: aDescriptor	"Normally you don't want to be setting tables explicitly, as it may defeat the identity management but it's here if needed"	descriptors at: aClass put: aDescriptor.</body><body package="GlorpMappings">privateTableAt: aString put: aTable	"Normally you don't want to be setting tables explicitly, as it may defeat the identity management but it's here if needed"	tables at: aString asUppercase put: aTable.</body></methods><methods><class-id>Glorp.DynamicDescriptorSystem</class-id> <category>hooks</category><body package="GlorpMappings">fieldNameForAttributeName: aSymbol 	attributeNameToFieldNameBlock isNil  		ifTrue: [^super fieldNameForAttributeName: aSymbol].	^attributeNameToFieldNameBlock value: aSymbol</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>testing</category><body package="GlorpDatabase">canRecurse	^canRecurse</body><body package="GlorpDatabase">isSQLite3Platform	^true</body><body package="GlorpDatabase">requiresTransactionForTableOperations	^false</body><body package="GlorpDatabase">supportsANSIJoins	"Do we support the JOIN &lt;tableName&gt; USING &lt;criteria&gt; syntax."	^true.</body><body package="GlorpDatabase">supportsBinding	"Return true if this platform supports binding parameters rather than printing them as strings into the SQL statement"	^true.</body><body package="GlorpDatabase">supportsConstraints	"Return false, because this platform does not support constraint add or drop statements.	However, foreign key constraints can be created as part of the create table statement.	Also, a foreign key constraint can be created in the statement that adds that column to	the table. (Eg., ALTER TABLE ADD COLUMN ...)."	^false</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	"SQLite does not support batched statements, i.e. cannot do INSERT ...; INSERT ...; INSERT... , but since version 3.7.11 it does support value sequences, i.e. it can do INSERT INTO table (id, c) VALUES (1,'1'), (2,'2'), (3,'3')."	^aCommand supportsGroupWriting and: [aCommand supportsGroupWritingValues]</body><body package="GlorpDatabase">supportsGroupWritingValues	"Return true if we support multiple rows in a single INSERT statement, like this:	INSERT INTO table (id, city, state) VALUES (1, 'Boston', 'MA'), (2, 'New York',  'NY'), (3, 'San Francisco', 'CA')."	^supportsGroupWritingValues ifNil: [false]</body><body package="GlorpDatabase">supportsLimit	"Do we support LIMIT ... (or something analogous to it), returning only the first N rows."	^true</body><body package="GlorpDatabase">supportsOffset	"Do we support OFFSET ... (or something analogous to it), skipping the first N rows"	^true</body><body package="GlorpDatabase">supportsSchemas	^false</body><body package="GlorpDatabase">supportsStringQueryOnBlobs	"This is something of a guess but I see no evidence that SQLite does and the relevant test certainly fails."	^false</body><body package="GlorpDatabase">usesIdentityColumns	^true.</body><body package="GlorpDatabase">usesLengthNotEndPosInSubstring	^true</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>constants</category><body package="GlorpDatabase">areSequencesExplicitlyCreated	^false</body><body package="GlorpDatabase">canBind: aValue to: aType	"See #supportsVariableSizedNumerics comment."	(Dialect isVisualWorks and: [aValue class == Dialect fixedPointClass]) ifTrue: [^false].	^super canBind: aValue to: aType</body><body package="GlorpDatabase">maximumLengthOfColumnName	"It is the boast of SQLite that their limits are only for stability purposes:  if it fits in 32 bits then they will handle it.  Since the maximum length of an SQL statement is limited to SQLITE_MAX_LENGTH (defaults to 1000000, cannot be higher than 1073741824), column names had better be shorter and in normal use should be much shorter.  I chose the number below at random;  change it if it causes you any inconvenience."	^128</body><body package="GlorpDatabase">maximumLengthOfTableName	"It is the boast of SQLite that their limits are only for stability purposes:  if it fits in 32 bits then they will handle it.  Since the maximum length of an SQL statement is limited to SQLITE_MAX_LENGTH (defaults to 1000000, cannot be higher than 1073741824), table names had better be shorter and in normal use should be much shorter.  I chose the number below at random;  change it if it causes you any inconvenience."	^128</body><body package="GlorpDatabase">parenthesizeCommandsInCompoundQuery: aQuery	^(aQuery isUnionAll or: [(aQuery isIntersect) or: [aQuery isMinus ]]) not</body><body package="GlorpDatabase">supportsAuthentication	"SQLite does not support authentication:  anyone can login with any username and password.  The only security is that provided by the OS for the file being used as the database."	^false</body><body package="GlorpDatabase">supportsMillisecondsInTimes	"The only time-type-related functions in SQLite are CURRENT_TIME format HH:MM:SS and CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SS, neither of which support milliseconds.  As against that, since we map to and from strings, we can easily include milliseconds in these strings.  For now, I go with the SQLite function choice and say no, but I have verified that tests work fine when I set this to true."	^false</body><body package="GlorpDatabase">supportsVariableSizedNumerics	"SQLite supports a single 8-byte IEEE floating point type:  e.g. give it 321.12s and it will return 321.12d.  Perhaps clever Glorp converters could arrange for Glorp to know which fields are really FixedPoint numbers, as we do for Date, Time and Timestamp (which SQLite also does not support) but I'll leave that until there's demand for it (ee also #canBind:to:)."	^false</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>types</category><body package="GlorpDatabase">boolean	^self typeNamed: #boolean ifAbsentPut: [GlorpBooleanType new typeString:  'integer']</body><body package="GlorpDatabase">date	"SQLite does not support any time-related types;  use text as the type and convert in readDate.../toDate..."	^self typeNamed: #date ifAbsentPut: [GlorpDateType new typeString: 'date']</body><body package="GlorpDatabase">double	^self typeNamed: #double ifAbsentPut: [GlorpDoubleType new typeString: 'double' ].</body><body package="GlorpDatabase">float4	"The only kind of REAL that SQLite supports is an 8-byte IEEE floating point number, so we just map float4 to float8."	^self double</body><body package="GlorpDatabase">float8	"The only kind of REAL that SQLite supports is an 8-byte IEEE floating point number."	^self double</body><body package="GlorpDatabase">int2	^self smallint.</body><body package="GlorpDatabase">int4	^self typeNamed: #int4 ifAbsentPut: [GlorpIntegerType new typeString: 'int'].</body><body package="GlorpDatabase">int8	^self int4.</body><body package="GlorpDatabase">nvarchar	^self text</body><body package="GlorpDatabase">sequence	^self serial</body><body package="GlorpDatabase">serial	"In SQLLite, the column declared as INTEGER PRIMARY KEY will default to ROWID, unless the inserted value is not null. But in Sqlite3 a declaration like: INTEGER PRIMARY KEY AUTOINCREMENT will cause ROWID to be fetched from the sqlite_sequence table, which provides always increasing values."	^self typeNamed: #serial ifAbsentPut: [GlorpSerialType new typeString: 'INTEGER PRIMARY KEY AUTOINCREMENT'].</body><body package="GlorpDatabase">text	^self typeNamed: #nvarchar ifAbsentPut: [GlorpTextType new typeString: 'text']</body><body package="GlorpDatabase">time	"SQLite does not support any time-related types;  use text as the type and convert in readTime.../toTime..."	^self typeNamed: #time ifAbsentPut: [GlorpTimeType new typeString: 'time']</body><body package="GlorpDatabase">timestamp	"SQLite does not support any time-related types;  use text as the type and convert in readTimestamp.../toTimestamp..."	^self typeNamed: #timestamp ifAbsentPut: [GlorpTimeStampType new typeString: 'timestamp']</body><body package="GlorpDatabase">typeWithDatabaseName: aString characterWidth: aNumber	"Since this is SQLite, let the type names be more flexible.  In addition, SQLite has no BOOLEAN type:  a particular integer column may in fact be used as a boolean column, storing just 1s and 0s, but we always return the platform's integer type, not its boolean type, when gererating the schema automatically. (The user can alter it later if it is desired that 1 and 0 in that column be mapped as true and false in the image.)"	| aTypeName total block |	block := [:sum :name | sum + (aString asLowercase findString: name startingAt: 1)].	aTypeName := aString.	total := #('char' 'clob' 'text') inject: 0 into: block.	total &gt; 0		ifTrue: [aTypeName := 'text']		ifFalse: 			[total := #('num' 'double' 'float') inject: 0 into: block.			total &gt; 0				ifTrue: [aTypeName := 'numeric']				ifFalse: 					[total := #('int') inject: 0 into: block.					total &gt; 0						ifTrue: [aTypeName := 'integer']						ifFalse: 							[total := #('blob') inject: 0 into: block.							total &gt; 0 ifTrue: [aTypeName := 'blob']]]].	aString isEmpty ifTrue: [aTypeName := 'blob'].	aTypeName asLowercase = 'integer' ifTrue: [^self integer].	^super typeWithDatabaseName: aTypeName characterWidth: aNumber</body><body package="GlorpDatabase">varbinary	" *** This method was defined by Glorp.DatabasePlatform as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpDatabase">varchar	^self text.</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>conversion-times</category><body package="GlorpDatabase">printDate: aDateString for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form '1959-09-30'."	aDateString isNil ifTrue: [^'NULL'].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aDateString class = Date ifTrue: [self error: 'SQLite does not support date types;  this should have been a String'].	^aDateString printString</body><body package="GlorpDatabase">printTime: aTimeString for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form 10:20:23."	aTimeString isNil ifTrue: [^'NULL'].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aTimeString class = Time ifTrue: [self error: 'SQLite does not support time types;  this should have been a String'].	^aTimeString printString</body><body package="GlorpDatabase">printTimestamp: aTimestampString on: stream for: aType	"SQLite does not suppport any time-related types.  We convert them all to strings via the to... methods, so parameters to this method should be Strings of the form '1959-03-27 10:20:23'."	aTimestampString isNil ifTrue: [stream nextPutAll: 'NULL'. ^self].	"The next line is checking code and can be dropped when SQLite is sufficiently tested."	aTimestampString class = Timestamp ifTrue: [self error: 'SQLite does not support timestamp types;  this should have been a String'].	stream nextPut: $'.	stream nextPutAll: aTimestampString.	stream nextPut: $'.</body><body package="GlorpDatabase">toDate: anObject for: aType	"SQLite does not handle timestamps;  all such must be treated as strings and the to... and read... formats must agree.  SQLite does use column-default-value UTC functions:	CURRENT_DATE format YYYY-MM-DD	CURRENT_TIME format HH:MM:SS	CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SSso our string conversions must agree with these formats."	| stream |	anObject isNil ifTrue: [^nil].	stream := String new writeStream.	self		printDate: (super toDate: anObject for: aType)		isoFormatOn: stream.	^stream contents</body><body package="GlorpDatabase">toTime: anObject for: aType	"SQLite does not handle timestamps;  all such must be treated as strings and the to... and read... formats must agree.  SQLite does use column-default-value UTC functions:	CURRENT_DATE format YYYY-MM-DD	CURRENT_TIME format HH:MM:SS	CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SSso our string conversions must agree with these formats."	| stream |	anObject isNil ifTrue: [^nil].	stream := String new writeStream.	self		printTime: (super toTime: anObject for: aType)		isoFormatOn: stream.	^stream contents</body><body package="GlorpDatabase">toTimestamp: anObject for: aType	"SQLite does not handle timestamps;  all such must be treated as strings and the to... and read... formats must agree.  SQLite does use column-default-value UTC functions:	CURRENT_DATE format YYYY-MM-DD	CURRENT_TIME format HH:MM:SS	CURRENT_TIMESTAMP format YYYY-MM-DD HH:MM:SSso our string conversions must agree with these formats."	| stream timestampObject |	anObject isNil ifTrue: [^nil].	stream := String new writeStream.	timestampObject := super toTimestamp: anObject for: aType.	self		printDate: timestampObject		isoFormatOn: stream.	stream space.	self		printTime: timestampObject		isoFormatOn: stream.	^stream contents</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>binding</category><body package="GlorpDatabase">bindingsForGroupWritingFor: aCommand	"Return the bindings array for a group write. This can be in different formats, depending on the database and perhaps the mechanism in place."	^aCommand batchStatementBindings</body><body package="GlorpDatabase">maximumSizeToGroupWriteFor: aRowBasedCommand	"SQLite does not allow more than 500 rows in a single trip, so cap the super call to that.  However it also limits the number of bound values in a single trip, so reduce the maximum further if needed.  We use 999 because that is the (bizarre! - why not 1000) maximum number of bound values in most implementations;  0.3.13 on Mac is at least one exception where 5000 is the (more sensible) limit."	| unboundLimit |	unboundLimit := 500 min: (super maximumSizeToGroupWriteFor: aRowBasedCommand).	^aRowBasedCommand useBinding		ifFalse: [unboundLimit]		ifTrue: [unboundLimit min: 999 // aRowBasedCommand arrayBoundFields size]"The line above can underestimate the possible rows (equally, can overestimate the number of bound values):  see #batchStatementBindings for how the number of arrayBoundFields maps to the overall number of bound values.  However it seems the most efficient way to get a maximum."</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>accessing</category><body package="GlorpDatabase">vwEXDIConnectionClass	^'SQLite3Connection' asQualifiedReference valueIfUndefinedLoadFrom: 'SQLite3EXDI'</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>sequences</category><body package="GlorpDatabase">databaseSequenceClass	^SQLite3Sequence</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>conversion-boolean</category><body package="GlorpDatabase">booleanToBooleanConverter	"SQLite uses integers to represent booleans in the database.  Therefore this conversion between Glorp boolean and database boolean actually converts between boolean and integer."	^DelegatingDatabaseConverter		named: #booleanToBoolean		hostedBy: self		fromStToDb: #convertBooleanToInteger:for:		fromDbToSt: #convertIntegerToBoolean:for:</body><body package="GlorpDatabase">convertIntegerToBoolean: anInteger for: aType	"This method accomodates an error in earlier SQLite 3 dlls. For the table_info() PRAGMA, 99 means True as well as 1."	anInteger isNil ifTrue: [^anInteger].	^anInteger &gt; 0</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>services tables</category><body package="GlorpDatabase">createTableStatementStringFor: aGLORPDatabaseTable 	"This method returns a string which can be used to create a database table ..."	| sqlStatementStream tmpString fkeys |	tmpString := 'create table'.	sqlStatementStream := WriteStream on: String new.	sqlStatementStream		nextPutAll: (self capitalWritingOfSQLCommands 					ifTrue: [tmpString asUppercase]					ifFalse: [tmpString]);		space.	self printDDLTableNameFor: aGLORPDatabaseTable on: sqlStatementStream.	"Now print the columns specification for each field in the table ..."	self printColumnsSpecificationFor: aGLORPDatabaseTable		on: sqlStatementStream.	"Print the primary key constraint, unless using serial pkeys, since it would be a redundant declaration."	(aGLORPDatabaseTable hasPrimaryKeyConstraints and: [aGLORPDatabaseTable primaryKeyFields first type isSerial not])			ifTrue: [sqlStatementStream nextPutAll: ', '.					(aGLORPDatabaseTable primaryKeyConstraints creationStringFor: self)						do: [ :each | sqlStatementStream nextPutAll: each.]						separatedBy: [sqlStatementStream nextPut: $,]].	fkeys := aGLORPDatabaseTable foreignKeyConstraintsForCreation.	fkeys notEmpty			ifTrue: [sqlStatementStream nextPutAll: ', '.					(fkeys collect: [:each| self createForeignKeyConstraintAddStatement: each])						do: [ :each | sqlStatementStream nextPutAll: each first]						separatedBy: [sqlStatementStream nextPut: $,]].	sqlStatementStream		nextPut: $).	^sqlStatementStream contents</body><body package="GlorpDatabase">printSqlStatementToListTablesInSchema: schemaString on: aStream	"SQLite3 uses a readonly system table "	aStream		nextPutAll: 'SELECT name as table_name FROM sqlite_master ';		nextPutAll: 'WHERE type = ';		nextPut: $';		nextPutAll: 'table';		nextPut: $';		nextPut: $;</body><body package="GlorpDatabase">printSqlStatementToTestExistenceOfTable: tableName inSchema: schemaString on: aStream	"SQLite3 uses a readonly system table and doesn't support schemas, as far as I know"	| lowerTableName |	lowerTableName := tableName asLowercase.	aStream		nextPutAll: 'SELECT count(*) FROM sqlite_master ';		nextPutAll: 'WHERE lower(name) = ';		nextPut: $';		nextPutAll: lowerTableName;		nextPut: $';		nextPutAll: ' AND type = ';		nextPut: $';		nextPutAll: 'table';		nextPut: $';		nextPut: $;</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>database-specific</category><body package="GlorpDatabase">printOffset: anInteger on: aCommand	"SQLite cannot have an offset without a limit.  A negative limit is treated as an infinite limit.  We cannot set it as an actual limit value;  that would hit limitMakesSense optimisation and abort the trip to the database.  So we add it here."	aCommand query hasLimit ifFalse:		[self printPostLimit: -1 on: aCommand].	aCommand nextPutAll: ' OFFSET '.	anInteger printOn: aCommand.</body><body package="GlorpDatabase">printPostLimit: anInteger on: aCommand	aCommand		nextPutAll: ' LIMIT '.	anInteger printOn: aCommand.</body><body package="GlorpDatabase">queryWithUnsupportedOperationsEliminatedFrom: aQuery do: aBlock	"SQLite3 does not allow LIMIT{OFFSET} in subqueries.  As far as is known at time of writing (2011jun07), Glorp will only generate such queries in the case of a readOneOf: on a superclass which is mapped by horizontal inheritance to its subclasses' tables:  if shouldUseSingleQuery is true, it will present a series of UNION ALLed subselects on each subclass table where only one is expected to match.To handle this case, we make the assumption that whenever all the subqueries' limits and offsets match those of the compound query, they are an artefact of the compound query's values being copied to the subqueries and really apply to the compound.  We therefore nil them for all but the last subselect.  This trick causes SQLite to interpret the resulting single LIMIT{OFFSET} at the end of the SQL string as applying to the whole UNIONed compound statement.In the general case, there is no algorithmic way to convert subselect limits and offsets into a single limit and offset on the whole statement, and so we cannot handle the statement.  We assume no such statements will occur.  If they do, we let them go on to their inevitable failure, so it will be visible."	| subQueries |	subQueries := aQuery queries.	(subQueries allSatisfy: [:each | each limit = aQuery limit and: [each offset = aQuery offset]])"		ifFalse: [just carry on and let it fail - don't hide the problem]"		ifTrue: [1 to: subQueries size - 1 do:				[:index | (subQueries at: index) limit: nil; offset: nil]].</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>functions</category><body package="GlorpDatabase">initializeFunctions	"The REGEXP operator is a special syntax for the regexp() user function in SQLite. No regexp() user function is defined by default and so use of the REGEXP operator will normally result in an error message. If a application-defined SQL function named 'regexp' is added at run-time, that function will be called in order to implement the REGEXP operator.  (See sqlite.org/lang_expr.html#regexp for details.)"	super initializeFunctions.	functions at: #regexMatches: put: (InfixFunction named: 'REGEXP').</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>login</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	"SQLite has been supporting group writing with the VALUES clause since version 3.7.11 inclusive.  It supports recursive queries in version 3.8.3 and after."	| dbmsVersion |	dbmsVersion := aDatabaseAccessor connection dbmsVersion tokensBasedOn: $..	supportsGroupWritingValues := self isVersion: #(3 7 11) notNewerThan: dbmsVersion.	canRecurse := self isVersion: #(3 8 3) notNewerThan: dbmsVersion.</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	"I cannot group ;-separated INSERT statements but (if I am new enough - version 3.7.11 or later) I can group ,-separated values following a single INSERT statement.  I answer true to usesIdentityColumns;  if I am writing to a serial type (an identity column), the server will assign the value(s) and I must use a command that knows how to retrieve and assign them."	^self supportsGroupWritingValues		ifFalse: [InsertCommand forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession]		ifTrue: [InsertIdentityColumnCommand				forRows: aCollectionOfDatabaseRows				useBinding: aBoolean				session: aSession				ifNoIdentityColumn: InsertMultiValuesCommand]</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>exdi specific</category><body package="GlorpDatabase">exdiTypeForBoolean	"SQLite has no boolean type.  SQLite3EXDI has no support for it."	^#Integer</body></methods><methods><class-id>Glorp.SQLite3Platform</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"SQLite has been supporting group writing with the VALUES clause since version 3.7.11 inclusive.  It supports recursive queries in version 3.8.3 and after.  For safety, we initialize to false, resetting in postLoginInitializeFromAccessor:."	super initialize.	canRecurse := false.	supportsGroupWritingValues := false.</body></methods><methods><class-id>Glorp.SQLite3Platform class</class-id> <category>constants</category><body package="GlorpDatabase">reservedWords	^#('abort' 'action' 'add' 'after' 'all' 'alter' 'analyze' 'and' 'as' 'asc' 'attach' 'autoincrement' 'before' 'begin' 'between' 'by' 'cascade' 'case' 'cast' 'check' 'collate' 'column' 'commit' 'conflict' 'constraint' 'create' 'cross' 'current_date' 'current_time' 'current_timestamp' 'database' 'default' 'deferrable' 'deferred' 'delete' 'desc' 'detach' 'distinct' 'drop' 'each' 'else' 'end' 'escape' 'except' 'exclusive' 'exists' 'explain' 'fail' 'for' 'foreign' 'from' 'full' 'glob' 'group' 'having' 'if' 'ignore' 'immediate' 'in' 'index' 'indexed' 'initially' 'inner' 'insert' 'instead' 'intersect' 'into' 'is' 'isnull' 'join' 'key' 'left' 'like' 'limit' 'match' 'natural' 'no' 'not' 'notnull' 'null' 'of' 'offset' 'on' 'or' 'order' 'outer' 'plan' 'pragma' 'primary' 'query' 'raise' 'references' 'regexp' 'reindex' 'release' 'rename' 'replace' 'restrict' 'right' 'rollback' 'row' 'savepoint' 'select' 'set' 'table' 'temp' 'temporary' 'then' 'to' 'transaction' 'trigger' 'union' 'unique' 'update' 'using' 'vacuum' 'values' 'view' 'virtual' 'when' 'where')		asSet</body></methods><methods><class-id>Glorp.SQLite3Platform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'SQLite3'</body></methods><methods><class-id>Glorp.AddingWriteStream</class-id> <category>accessing</category><body package="GlorpExtensions">contents	^target.</body><body package="GlorpExtensions">nextPut: anObject	target add: anObject.</body><body package="GlorpExtensions">nextPutAll: aCollection	target glorpAddAll: aCollection.</body><body package="GlorpExtensions">on: aSet	target := aSet.</body><body package="GlorpExtensions">target	^target</body><body package="GlorpExtensions">target: aCollection	target := aCollection</body></methods><methods><class-id>Glorp.AddingWriteStream class</class-id> <category>instance creation</category><body package="GlorpExtensions">on: aCollection	^self new target: aCollection.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>debugging</category><body package="GlorpQueries">asText	^self basicPrintString asText.</body><body package="GlorpQueries">basicPrintString	^self printString.</body><body package="GlorpQueries">class	^MessageArchiver</body><body package="GlorpQueries">displayString	"For use in by-hand debugging.  For more general use if the dialect has a #displayString implementation in Object that returns printString.  (If everything else is nil, we assume the receiver is too and we're the result of a	MessageArchiver newcall at the base of the expression, but we print the receiver uppercase, both to distinguish this base case from any other nil and just in case it is not nil.)"	| str |	query isNil ifFalse: [^query printString].	(mySelector isNil and: [myArguments isNil]) ifTrue:		[^myReceiver displayString asUppercase].	(str := (String new: 64) writeStream)		nextPutAll: myReceiver displayString;		space;		nextPutAll: mySelector.	myArguments do:		[:each |		str crtab; nextPutAll:			(each displayString				copyReplaceAll: (Array with: Character cr)				with: (Array with: Character cr with: Character tab))].	^str contents</body><body package="GlorpQueries">halt	"Support this so that we can debug inside query blocks. For portability, send it to a different object so that we don't have to care how halt is implemented"	(Array with: self) halt.</body><body package="GlorpQueries">inspect	"Not exactly the intended semantics, but should be portable"	(Array with: self) inspect.</body><body package="GlorpQueries">inspectorSize  ^2</body><body package="GlorpQueries">mustBeBoolean	nil error: 'mustBeBoolean - this probably indicates you are trying to use an optimized message like and: or ifTrue: inside a Glorp expression block. Use AND: or &amp; instead.'</body><body package="GlorpQueries">printOn: aStream	aStream nextPutAll: self printString.</body><body package="GlorpQueries">printString	"Hard-code this for maximum dialect portability"	^'a MessageArchiver'.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>expression creation</category><body package="GlorpQueries">asGlorpExpression	^self asGlorpExpressionOn: BaseExpression new</body><body package="GlorpQueries">asGlorpExpressionOn: aBaseExpression 	| arguments |	myReceiver == nil ifTrue: [^query isNil ifTrue: [aBaseExpression] ifFalse: [query baseExpression]].	arguments := myArguments collect: [:each | each asGlorpExpressionOn: aBaseExpression].	^self sendMessageTo: (myReceiver asGlorpExpressionOn: aBaseExpression) withArguments: arguments.</body><body package="GlorpQueries">asGlorpExpressionOn: aBaseExpression basedOn: aMessageArchiver withUltimateBase: ultimateBaseExpression	"We know we are built from aMessageArchiver, but parts of us may refer to an outer scope. Those parts should be built on ultimateBaseExpression rather than aBaseExpression. e.g. consider  [:each | each amount amount = ((Query readManyOf: GlorpBankTransaction			where: [:eachTrans | eachTrans owner = each owner]) 				retrieve: [:eachTrans | eachTrans amount amount max])]."	| arguments |	self == aMessageArchiver ifTrue: [^aBaseExpression].	myReceiver == nil ifTrue: [^query isNil ifTrue: [ultimateBaseExpression] ifFalse: [query baseExpression]].	arguments := myArguments		collect:			[:each | 			each				asGlorpExpressionOn: aBaseExpression				basedOn: aMessageArchiver				withUltimateBase: ultimateBaseExpression].	^self 		sendMessageTo: (myReceiver			asGlorpExpressionOn: aBaseExpression			basedOn: aMessageArchiver			withUltimateBase: ultimateBaseExpression)		withArguments: arguments.</body><body package="GlorpQueries">sendMessageTo: anExpression withArguments: arguments	"Build our node by sending our message to anExpression"	^anExpression get: mySelector withArguments: arguments.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>doesNotUnderstand</category><body package="GlorpQueries">= anObject	"Needed because VA's abtObservableWrapper implements =. Should be portable."	^MessageArchiver 		receiver: self		selector: #= 		arguments: (Array with: anObject).</body><body package="GlorpQueries">basicDoesNotUnderstand: aMessage 	"Invoke this to avoid infinite recursion in the case of internal errors. We want a dialect-independent way of getting a walkback window, so we'll invoke it against a different object"	(Array with: self) doesNotUnderstand: aMessage.</body><body package="GlorpQueries">doesNotUnderstand: aMessage 	| sel |	sel := aMessage selector.	sel == #doesNotUnderstand: ifTrue: [self basicDoesNotUnderstand: aMessage].	(sel size &gt;= 8 and: [(sel copyFrom: 1 to: 8) = 'perform:']) 		ifTrue: 			[^self get: aMessage arguments first				withArguments: (aMessage arguments copyFrom: 2 to: aMessage arguments size)].	^self get: sel withArguments: aMessage arguments.</body><body package="GlorpQueries">os_Equal: anObject	^self = anObject</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>private/accessing</category><body package="GlorpQueries">privateGlorpQuery	^query.</body><body package="GlorpQueries">privateGlorpQuery: aQuery	query := aQuery.</body><body package="GlorpQueries">privateGlorpReceiver	^myReceiver</body><body package="GlorpQueries">privateGlorpSelector	^mySelector</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>testing</category><body package="GlorpQueries">glorpIsBlock	^false.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>initialize</category><body package="GlorpQueries">receiver: aMessageCollector selector: aSymbol arguments: aCollection	myReceiver := aMessageCollector.	mySelector := aSymbol.	myArguments := aCollection.</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>expression protocol</category><body package="GlorpQueries">get: aSymbol 	^MessageArchiver receiver: self		selector: aSymbol		arguments: #().</body><body package="GlorpQueries">get: aSymbol withArguments: anArray 	| arguments |	arguments := anArray collect: [:each | each glorpIsBlock 		ifTrue: [(Dialect argumentCountFor: each) = 1			ifTrue: [each value: self]			ifFalse: [each value]]		ifFalse: [each]].	^MessageArchiver receiver: self		selector: aSymbol		arguments: arguments.</body><body package="GlorpQueries">getMapping: aMapping named: aString	"In this case, the name may actually be a string rather than a symbol."	^MessageArchiverForGetMapping		receiver: self		selector: aString		arguments: (Array with: aMapping with: aString).</body></methods><methods><class-id>Glorp.MessageArchiver</class-id> <category>As yet unclassified</category><body package="GlorpQueries">inspectorClasses	^Array with: (Dialect smalltalkAt: 'Tools.Trippy.BasicInspector')</body></methods><methods><class-id>Glorp.MessageArchiver class</class-id> <category>instance creation</category><body package="GlorpQueries">receiver: aMessageCollector selector: aSymbol arguments: aCollection	^self new		receiver: aMessageCollector		selector: aSymbol		arguments: aCollection.</body></methods><methods><class-id>Glorp.GlorpMSSQLSysnameType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">typeString	^'sysname'.</body></methods><methods><class-id>Glorp.GlorpMSSQLSysnameType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">isStringType	^true.</body></methods><methods><class-id>Glorp.GlorpMSSQLSysnameType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">impliedSmalltalkType	^String.</body></methods><methods><class-id>Glorp.GlorpMSSQLSysnameType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#String.</body></methods><methods><class-id>Glorp.Cast</class-id> <category>initialize-release</category><body package="GlorpExpressions">initialize	super initialize.	function := 'CAST'.	separator := ' AS '.</body></methods><methods><class-id>Glorp.Cast</class-id> <category>preparing</category><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	^super rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression."	| rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	rebuilt := (base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression).	rebuilt := self class value: base as: arguments first.	rebuilt alias: self alias.	^rebuilt."</body></methods><methods><class-id>Glorp.Cast</class-id> <category>accessing</category><body package="GlorpExpressions">type	^arguments last value.</body></methods><methods><class-id>Glorp.Cast</class-id> <category>recursion</category><body package="GlorpExpressions">createMappingToFieldInRecursionTable: aDatabaseTable	"If we have cast our base to a type, that is the type we want for its field in the recursion table.  Glorp fails to generate brackets around an aliased constant value when printing SQL. e.g. in	CAST('(1)' AS path AS character varying(75))is invalid SQL as the distinct uses of AS are not parsable - it should probably be	CAST(('(1)' AS path) AS character varying(75))Until this is fixed, we cannot proceed to SQL generation with an aliased constant base.  We therefore nil it after using it."	| impliedGlorpType newMapping |	impliedGlorpType := arguments last value.	newMapping := DirectMapping new.	newMapping field:		(aDatabaseTable createFieldNamed: base alias type: impliedGlorpType).	base isConstantExpression		ifTrue: [base alias: nil].	^newMapping</body></methods><methods><class-id>Glorp.Cast class</class-id> <category>instance creation</category><body package="GlorpExpressions">value: anObject as: aDatabaseType	self error: 'this is work in progress, you probably shouldn''t use it yet'.	(anObject isNil or: [anObject isGlorpExpression and: [anObject isConstantExpression and: [anObject value isNil]]])		ifTrue: [^anObject].	^self new base: anObject asGlorpExpression; arguments: (Array with: aDatabaseType asGlorpExpression).</body></methods><methods><class-id>Glorp.AccessCast</class-id> <category>initialize-release</category><body package="GlorpExpressions">initialize	super initialize.	function := 'CAST'.	separator := ''.</body></methods><methods><class-id>Glorp.AccessCast</class-id> <category>printing</category><body package="GlorpExpressions">printBasicSQLOn: aStream withParameters: aDictionary forSelect: aBoolean	aStream		nextPutAll: self castFunctionName;		nextPut: $(.	aBoolean		ifTrue: [base printSelectSQLOn: aStream withParameters: aDictionary]		ifFalse: [base printSQLOn: aStream withParameters: aDictionary].	aStream nextPut: $).	alias notNil		ifTrue:			[aStream				nextPutAll: ' AS ';				nextPutAll: alias].</body></methods><methods><class-id>Glorp.AccessCast</class-id> <category>functions</category><body package="GlorpExpressions">castFunctionName	| targetType conversionFunctions |	conversionFunctions := (Dictionary new)				at: #timestamp put: 'CVDATE';				at: #date put: 'CDATE';				at: #integer put: 'CLNG';				at: #double put: 'CDBL';				at: #string put: 'CSTR';				at: #boolean put: 'CBOOL';				yourself.	targetType := arguments first.	^conversionFunctions at: targetType value selector</body></methods><methods><class-id>Glorp.IdentityTypeResolver</class-id> <category>type resolution</category><body package="GlorpMappings">classesRequiringIndependentQueriesFor: aClass	^Array with: aClass</body></methods><methods><class-id>Glorp.IdentityTypeResolver</class-id> <category>accessing</category><body package="GlorpMappings">allTablesFor: aDescriptor	"Return all tables used by this descriptor or its subclasses. For a non-inheritance descriptor, this is the same as tables."	^aDescriptor tables.</body><body package="GlorpMappings">describedConcreteClassFor: aRow withBuilder: builder descriptor: aDescriptor	^aDescriptor describedClass</body><body package="GlorpMappings">descriptorsRequiringIndependentQueriesFor: aClass	^members.</body><body package="GlorpMappings">typeMappingRootDescriptor	^members first</body></methods><methods><class-id>Glorp.ConditionalToManyMapping</class-id> <category>conditions</category><body package="GlorpMappings">conditionalField: aField	self conditional conditionalField: aField.</body><body package="GlorpMappings">conditionalMethod: aSymbol	self conditional conditionalMethod: aSymbol.</body><body package="GlorpMappings">forField: aField attribute: attributeBlock if: testBlock useMapping: aMapping	self conditionalField: aField.	self conditionalMethod: attributeBlock.	self if: testBlock then: aMapping.</body><body package="GlorpMappings">if: conditionSelector then: aMapping	self conditional if: conditionSelector then: aMapping.</body><body package="GlorpMappings">otherwise: aMapping	self conditional otherwise: aMapping.</body></methods><methods><class-id>Glorp.ConditionalToManyMapping</class-id> <category>accessing</category><body package="GlorpMappings">conditional	conditional isNil ifTrue: [conditional := self newMapping: ConditionalMapping].	^conditional.</body><body package="GlorpMappings">conditional: anObject	conditional := anObject</body><body package="GlorpMappings">mappedFields	^self conditional mappedFields</body><body package="GlorpMappings">newMapping: aMappingClass	"Implement this so that we can create our sub-mappings without having them added to the parent descriptor as independent mappings"	| mapping |	mapping := aMappingClass new.	mapping descriptor: self descriptor.	descriptor resetMappedFields.	^mapping.</body></methods><methods><class-id>Glorp.ConditionalToManyMapping</class-id> <category>mapping</category><body package="GlorpMappings">applicableMappingForObject: anObject	"We can actually be called here with our parent object, but in the contexts in which that happens we basically just want to do nothing, so return a dummy mapping that replies false to isRelationship.  Give its value text about its origins in case anyone finds themselves examining it in some unexpected context."	[self attribute checkTargetType: anObject]		on: GlorpInvalidTypeError		do: [:ex | ^ConstantMapping new constantValue: 'ConditionalToManyMapping&gt;&gt;applicableMappingForObject: called on parent, so did nothing and handled ', ex getMessageText].	^self conditional applicableMappingForObject: anObject</body><body package="GlorpMappings">applicableMappingForRow: anArray in: anElementBuilder	^self conditional applicableMappingForRow: anArray in: anElementBuilder.</body><body package="GlorpMappings">buildQuery	| builtQuery |	builtQuery := CompositeQuery new.	self conditional casesDo:		[:each | builtQuery addQuery: each query].	^builtQuery</body><body package="GlorpMappings">mapOneFromObject: sourceObject toTarget: targetObject intermediate: aRowMapKey atPosition: index puttingRowsIn: aRowMap		(self applicableMappingForObject: targetObject) mapOneFromObject:			sourceObject toTarget: targetObject intermediate: aRowMapKey atPosition:			index puttingRowsIn: aRowMap.</body><body package="GlorpMappings">parametersIn: anElementBuilder	| parameters |	self shouldUseFilteredRead ifTrue: [^anElementBuilder command parameters].	parameters := IdentityDictionary new.	self conditional casesDo: [:each |		each join mappableSourceFieldsDo:			[:eachSource | parameters at: eachSource put: (anElementBuilder valueOfField: eachSource)]].	^parameters.</body><body package="GlorpMappings">rowMapKeyForSource: source target: target index: index	^(self applicableMappingForObject: target) rowMapKeyForSource: source target: target index: index.</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>accessing</category><body package="GlorpQueries">addQuery: aQuery	queries add: aQuery.</body><body package="GlorpQueries">baseExpression	^queries first baseExpression.</body><body package="GlorpQueries">collectionType	^self primaryQuery collectionType.</body><body package="GlorpQueries">primaryQuery	^queries first.</body><body package="GlorpQueries">proxyType	^self primaryQuery proxyType.</body><body package="GlorpQueries">proxyType: aClass		"We currently ignore proxy types and use the ones from our main query."	^self.</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>preparing</category><body package="GlorpQueries">copyOfBuilders 	^self primaryQuery copyOfBuilders.</body><body package="GlorpQueries">prepare	queries do: [:each | each session: session].	queries do: [:each | each prepare].</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>initialize</category><body package="GlorpQueries">initialize	super initialize.	queries := OrderedCollection new.</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>executing</category><body package="GlorpQueries">executeWithParameters: parameterArray in: aSession	| results |	results := self collectionType new writeStream.	queries do: [:each |		results nextPutAll: (each executeWithParameters: parameterArray in: aSession)].	^results contents.</body></methods><methods><class-id>Glorp.CompositeQuery</class-id> <category>copying</category><body package="GlorpQueries">postCopy	super postCopy.	queries := queries collect: [:each | each copy].</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>executing</category><body package="GlorpQueries">executeSubQueries: subQueries withParameters: anArray	^self shouldUseSingleQuery		ifTrue: [self executeSubQueriesCombined: subQueries withParameters: anArray]		ifFalse: [self executeSubQueriesIndividually: subQueries withParameters: anArray].</body><body package="GlorpQueries">executeSubQueriesCombined: subQueries withParameters: anArray	"Execute our sub queries as a single query with a UNION ALL between the sub-queries. Then select from the results the one which has a value for that row. Used for horizontal inheritance queries."	| combinedQuery |	combinedQuery := CompoundQuery newUnionAll.	self copyAttributesTo: combinedQuery.	combinedQuery requiresDistinct: false.	subQueries do: [:eachQuery | combinedQuery addQuery: eachQuery].	^combinedQuery executeWithParameters: anArray in: session.</body><body package="GlorpQueries">executeSubQueriesIndividually: subQueries withParameters: anArray	| result |	result := OrderedCollection new.	subQueries do: [:eachQuery |		| individualResult |		individualResult := eachQuery readFromDatabaseWithParameters: anArray.		eachQuery readsOneObject			ifTrue: [individualResult isNil ifFalse: [^result add: individualResult]]			ifFalse: [result addAll: individualResult]].	^self readsOneObject		ifTrue: [result isEmpty ifTrue: [nil] ifFalse: [result first]]		ifFalse: [result].</body><body package="GlorpQueries">readFromDatabaseWithParameters: anArray	"A query of a class in an inheritance hierarchy may be able to use a single query even if subclasses with distinct mappings are involved."	| subQueries |	subQueries := self descriptor classesRequiringIndependentQueries collect:		[:eachClass |		self shouldUseSingleQuery			ifTrue: [self asQueryWithNullsForOtherClasses: eachClass]			ifFalse:				[(self asSimpleQueryFor: eachClass)					setupTracing;					assignTableAliases;					yourself]].	^self executeSubQueries: subQueries withParameters: anArray</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>accessing</category><body package="GlorpQueries">shouldUseSingleQuery	^self descriptor typeResolver shouldUseSingleQuery.</body></methods><methods><class-id>Glorp.ReadQuery</class-id> <category>converting</category><body package="GlorpQueries">asQueryWithNullsForOtherClasses: aClass	"Construct a specialized form of the query that's set up to retrieve instances of aClass, but with a bunch of empty fields that get populated with nulls, so we can retrieve several different classes at the same go."	| newQuery nullField fieldsToIgnore markerExpression fieldsMinusTheConstant pseudoMappingName newBase tablesToIgnore |	newQuery := self asSimpleQueryFor: aClass.	"We need to rebuild the where clause to refer to one of the subclass pseudo-mappings, because that's what we're retrieving. We don't want it against the actual class we're querying for, because we need the fields to be exactly the same for each of the sub-queries."	pseudoMappingName := self descriptor typeResolver		pseudoAttributeNameForClass: aClass.	newBase := newQuery baseExpression get: pseudoMappingName.	newBase bePhantom.	newQuery whereClause: (newQuery whereClause rebuildOn: newBase).		"We don't want it to try and retrieve the parent class. Instead, we alsoFetch: each of the subclasses, and insert a special builder that will select from among the valid results. To prevent it from trying to do anything with the main class itself, remove that from the tracing, and replace it with a special constant marker that we know will generate only one field, that we can remove later."	newQuery tracing retrievalExpressions remove: newQuery tracing base.	newQuery tracing allTracings remove: newQuery tracing base.	markerExpression := ConstantExpression for: 'ignore me'.	newQuery tracing retrievalExpressions add: markerExpression.	newQuery tracing allTracings add: markerExpression.	newQuery prepare.	newQuery		privateReplaceBuilderWith:			(SelectingElementBuilder new expression: markerExpression).		"For each retrieval that isn't our class, change the fields being returned to nulls, and wrap a cast around them so that SQL doesn't complain. First, we figure out which fields those are."	fieldsToIgnore := IdentityDictionary new.	newQuery tracing alsoFetchExpressions		do:			[:each | 			each mapping referenceClass = aClass				ifFalse:					[each fieldAliases						do: [:eachFieldAlias | fieldsToIgnore at: eachFieldAlias put: each]]].		"Now we remove the constant field we know we caused to be generated earlier, and replace the others that we don't want with nulls"	fieldsMinusTheConstant := newQuery fields		copyFrom: 1		to: newQuery fields size - 1.	newQuery		privateSetFields:			(fieldsMinusTheConstant				collect:					[:eachField | 					(fieldsToIgnore includesKey: eachField)						ifFalse: [eachField]						ifTrue:							[nullField := self nullFieldFor: eachField.							nullField]]).		"Supress all tables except the one(s) we actually want."	newQuery prepare.	tablesToIgnore := (fieldsToIgnore keys collect: [:each | each table]) asSet asArray.	tablesToIgnore := tablesToIgnore, (newQuery baseExpression tablesToPrint).	newQuery tablesToPrint: (newQuery tablesToPrint reject: [:each | tablesToIgnore includes: each]) asArray.		^newQuery.</body><body package="GlorpQueries">asSimpleQueryFor: aClass	| newQuery newCriteria newBase |	"Rebuild the expression, because this means a full query is being split into multiple sub-queries, e.g. for an inheritance read. The expression may get prepared differently in each case (e.g. table aliases), so we can't share"	newBase := BaseExpression new.	newBase descriptor: (session system descriptorFor: aClass).	newCriteria := whereClause rebuildOn: newBase startingFrom: newBase withOuterScopeBase: newBase.	newQuery := SimpleQuery new		initResultClass: aClass		whereClause: newCriteria		singleObject: readsOneObject.	self copyAttributesTo: newQuery.	newQuery session: session.	newQuery setOrdering: ordering.	newQuery setGrouping: grouping.	newQuery setUpExpressions.	newQuery tracing: tracing copy.	^newQuery.</body><body package="GlorpQueries">nullFieldFor: eachField	self platform requiresCastsForNullsInUnions ifFalse: [^(ConstantExpression for: nil) alias: eachField table name, 'nullField', eachField position printString].	^FunctionExpression		for: #cast:		withArguments: (Array with: (ConstantExpression for: eachField type))		basedOn: (ConstantExpression for: nil).</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>initializing</category><body package="GlorpQueries">setUp	availableTables := Set new.</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>printing</category><body package="GlorpQueries">nextJoin	^joinsToProcess detect: [:eachJoinExpression |		eachJoinExpression tablesForANSIJoin anySatisfy: [:eachTable |			availableTables includes: eachTable]].</body><body package="GlorpQueries">printJoinsOn: aCommand	"This is pretty hideous. Figure out an order in which to print these stupid joins. As a bonus, they may be circular, so we may have to collapse joins together. And if we collapse, we can't print as we go because we don't know how many parentheses to add, so store them up and print them all at the end"	| allJoins |	joinsToProcess := query joins copy.	availableTables := Set with: self rootTable.	allJoins := OrderedCollection new.	[joinsToProcess isEmpty] whileFalse: [		| next nextTable allRelatedJoins fullJoin|		next := self nextJoin.		joinsToProcess remove: next.		nextTable := next tableToJoinFrom: availableTables.		allRelatedJoins := joinsToProcess select: [:each | (each tableToJoinFrom: availableTables) = nextTable].		fullJoin := allRelatedJoins inject: next into: [:sum :each | sum AND: each].		joinsToProcess removeAll: allRelatedJoins.		allJoins add: (fullJoin-&gt;nextTable).		availableTables addAll: (next tablesForANSIJoin)].	allJoins size timesRepeat: [aCommand nextPut: $(].	aCommand nextPutAll: self rootTable sqlTableName.	allJoins do: [:each | 		each key printForANSIJoinTo: each value on: aCommand.		aCommand nextPut: $)].	self printLeftoverTablesOn: aCommand.</body><body package="GlorpQueries">printLeftoverTablesOn: aCommand	"Now there might be leftover tables whose joins were implied directly by the where clause"	| leftOverTables |	leftOverTables := self allTables asSet copy.	availableTables do: [:each | leftOverTables remove: each ifAbsent: []].	leftOverTables isEmpty ifFalse: [aCommand nextPutAll: ', '].	GlorpHelper		print: [:each | each sqlTableName]		on: aCommand		for: leftOverTables		separatedBy: ', '.</body></methods><methods><class-id>Glorp.JoinPrinter</class-id> <category>accessing</category><body package="GlorpQueries">allTables	^query tablesToPrint.</body><body package="GlorpQueries">query: aQuery	query := aQuery.		self setUp.</body><body package="GlorpQueries">rootTable	"Pick a table to start with"	^self allTables first.</body></methods><methods><class-id>Glorp.JoinPrinter class</class-id> <category>instance creation</category><body package="GlorpQueries">for: aQuery	^self new query: aQuery.</body></methods><methods><class-id>Glorp.DatabaseTableConstraint</class-id> <category>accessing</category><body package="GlorpDatabase">fields	^fields</body><body package="GlorpDatabase">fields: anObject	fields := anObject</body><body package="GlorpDatabase">generateName	^self subclassResponsibility</body><body package="GlorpDatabase">name	name isNil ifTrue: [name := self generateName].	^name.</body><body package="GlorpDatabase">name: aString	name := aString.</body><body package="GlorpDatabase">shouldCreateInDatabase	^shouldCreateInDatabase ifNil: [true]</body><body package="GlorpDatabase">shouldCreateInDatabase: aBoolean	"If false, then this is a constraint that we use for in-memory ordering, but it should not be created in the database, possibly for performance, or because it might cause a cycle"	shouldCreateInDatabase := aBoolean</body><body package="GlorpDatabase">table	^table</body><body package="GlorpDatabase">table: anObject	table := anObject</body></methods><methods><class-id>Glorp.DatabaseTableConstraint</class-id> <category>printing</category><body package="GlorpDatabase">creationString	^(self creationStringFor: self table platform) first.</body><body package="GlorpDatabase">creationStringFor: aPlatform	^self subclassResponsibility</body><body package="GlorpDatabase">dropString	^self dropStringFor:  self table platform</body><body package="GlorpDatabase">dropStringFor: aPlatform	^aPlatform createConstraintDropStatement: self</body><body package="GlorpDatabase">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: self name;		nextPut: $).</body></methods><methods><class-id>Glorp.DatabaseTableConstraint</class-id> <category>initializing</category><body package="GlorpDatabase">forTable: aTable	table := aTable</body><body package="GlorpDatabase">initialize	shouldCreateInDatabase := true.</body></methods><methods><class-id>Glorp.DatabaseTableConstraint</class-id> <category>testing</category><body package="GlorpDatabase">isForeignKeyConstraint	^false</body><body package="GlorpDatabase">isPrimaryKeyConstraint	^false</body><body package="GlorpDatabase">isUniqueConstraint	^false</body></methods><methods><class-id>Glorp.DatabaseTableConstraint class</class-id> <category>instance creation</category><body package="GlorpDatabase">forTable: aDatabaseTable	^self new		forTable: aDatabaseTable;		yourself</body><body package="GlorpDatabase">new	^super new initialize.</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>initializing</category><body package="GlorpDatabase">forTable: aTable	super forTable: aTable.	name := self primaryKeyConstraintName.	self primaryKeyFields:  table primaryKeyFields</body><body package="GlorpDatabase">forTable: aDatabaseTable fields: collDatabaseFields	self forTable: aDatabaseTable.	self primaryKeyFields: collDatabaseFields</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>printing</category><body package="GlorpDatabase">creationStringFor: aPlatform	^aPlatform createPrimaryKeyConstraintAddStatement: self</body><body package="GlorpDatabase">generateName	^self table name, '_PK'.</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>accessing</category><body package="GlorpDatabase">primaryKeyConstraintName	^self table name, '_PK'.</body><body package="GlorpDatabase">primaryKeyFields	^fields</body><body package="GlorpDatabase">primaryKeyFields: aCollection	fields := aCollection</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>testing</category><body package="GlorpDatabase">isPrimaryKeyConstraint	^true</body><body package="GlorpDatabase">matchesPrimaryKeyConstraint: aConstraint	name = aConstraint name ifFalse: [^false].	self primaryKeyFields size = aConstraint primaryKeyFields size ifFalse: [^false].	self primaryKeyFields with: aConstraint primaryKeyFields do:		[ :field1 :field2 | (field1 matchesField: field2) ifFalse: [^false]].	^true</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint</class-id> <category>comparing</category><body package="GlorpDatabase">isTheSameAs: aPrimaryKeyConstraint	"Validate that two constraints are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aPrimaryKeyConstraint name asUppercase ifFalse: [^false].	self primaryKeyFields size = aPrimaryKeyConstraint primaryKeyFields size ifFalse: [^false].	self primaryKeyFields asSortedCollection with: aPrimaryKeyConstraint primaryKeyFields asSortedCollection do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		self shouldCreateInDatabase = aPrimaryKeyConstraint shouldCreateInDatabase ifFalse: [^false].	^true.</body></methods><methods><class-id>Glorp.PrimaryKeyConstraint class</class-id> <category>instance creation</category><body package="GlorpDatabase">forTable: aDatabaseTable fields: collDatabaseFields	^self new		forTable: aDatabaseTable  fields: collDatabaseFields;		yourself</body></methods><methods><class-id>Glorp.JustSelectTheMaximumSequenceValueAndAddOne</class-id> <category>other</category><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession	| stream rows value |	"I repeat: ick"	stream := WriteStream on: (String new: 50).	stream nextPutAll: 'SELECT MAX('.	aField printSQLOn: stream withParameters: #().	stream nextPutAll: ') FROM '.	aRow table printSQLOn: stream withParameters: #().	rows := aSession accessor executeSQLString: stream contents.	value := rows first first isNil ifTrue: [1] ifFalse: [rows first first + 1].	aRow at: aField put: value.	^value.</body><body package="GlorpDatabase">reserveSequenceNumbers: anInteger in: anAccessor for: aTable	| numberNeeded firstNumber fakeRow |	numberNeeded := anInteger - self availableReservedNumbers.	numberNeeded &lt;= 0 ifTrue: [^self].	fakeRow := DatabaseRow newForTable: self field table.	firstNumber := self		getSequenceValueFromDatabaseFor: self field		in: fakeRow		using: anAccessor.	self reservedNumbers addAll: (firstNumber to: firstNumber + numberNeeded - 1).</body></methods><methods><class-id>Glorp.JustSelectTheMaximumSequenceValueAndAddOne</class-id> <category>accessing</category><body package="GlorpDatabase">field	field isNil ifTrue: [field := table primaryKeyFields first].	^field.</body><body package="GlorpDatabase">field: aDatabaseField	field := aDatabaseField.</body><body package="GlorpDatabase">table: aTable	table := aTable.</body></methods><methods><class-id>Glorp.HorizontalTypeMapping</class-id> <category>initializing</category><body package="GlorpMappings">mappedClass: aClass	mappedClass := aClass</body></methods><methods><class-id>Glorp.HorizontalTypeMapping</class-id> <category>mapping</category><body package="GlorpMappings">allDescribedConcreteClasses	| col |	col := OrderedCollection new		add: self describedClass;		addAll: self describedClass allSubclasses;		yourself.	self needsWork: 'This belongs in someone else''s responsibility'.	^col select:		[:each |		(self system descriptorFor: each) typeMapping isAbstract not].</body><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap	"do nothing"</body><body package="GlorpMappings">mappedFields	^#()</body><body package="GlorpMappings">trace: aTracing context: anExpression	^self</body></methods><methods><class-id>Glorp.HorizontalTypeMapping</class-id> <category>accessing</category><body package="GlorpMappings">beAbstract	isAbstract := true</body><body package="GlorpMappings">isAbstract	^isAbstract isNil ifTrue: [ isAbstract := false ] ifFalse: [ isAbstract ]</body></methods><methods><class-id>Glorp.HorizontalTypeMapping class</class-id> <category>instance creation</category><body package="GlorpMappings">forClass: aClass	^self new		mappedClass: aClass;		yourself</body></methods><methods><class-id>Glorp.ValidationError</class-id> <category>accessing</category><body package="GlorpMisc">model	^self parameter</body><body package="GlorpMisc">model: aClass	self parameter: aClass</body></methods><methods><class-id>Glorp.ValidationError</class-id> <category>printing</category><body package="GlorpMisc">description	^self messageText</body></methods><methods><class-id>Glorp.ValidationError class</class-id> <category>testing</category><body package="GlorpMisc">mayResume	^true</body></methods><methods><class-id>Glorp.SubstringFunction</class-id> <category>accessing</category><body package="GlorpExpressions">type	| aPlatform |	^(aPlatform := self ultimateBaseExpression system platform) isDB2Platform		ifTrue: [super type]		ifFalse: [aPlatform varchar: 255]</body></methods><methods><class-id>Glorp.SubstringFunction</class-id> <category>rewriting</category><body package="GlorpExpressions">rewriteForOracleBlobsWith: mainArgument	"For Oracle blobs, we can't query with a normal substring function, but rather have to use the DBMS_LOB function, whose arguments are backwards. Further, we don't seem to be able to compare to byte-arrays, so turn it into a string."	| oldBase template startPosition length |	(mainArgument isGlorpExpression and: [mainArgument isConstantExpression]) ifFalse: [^self].	function := 'UTL_RAW.CAST_TO_VARCHAR2'.	startPosition := arguments first value.	arguments last value.	length := arguments last value.	arguments := #().	oldBase := base.	template := PrefixFunction named: 'DBMS_LOB.SUBSTR'.	base := template createFor: (Array with: length asGlorpExpression with: startPosition asGlorpExpression) withBase: oldBase symbol: #dbmsLobSubstr.</body><body package="GlorpExpressions">rewriteForPostgresqlBase64BlobsWith: mainArgument	"This is pretty awful. We expect our main argument to be a string, and we're a substring function, but we know that for some types, the string representation comes out differently in the database. In particular, the Postgresql driver stores strings into lobs in Base64. So, if our previous argument = the string size, rewrite it to the database size. This makes it work if we do    (someObject blob copyFrom: 1 to: 3) = 'abc'when in fact, the length of that string in the blob will be 4."	| stream actualArgument base64Length base64Start |	(mainArgument isGlorpExpression and: [mainArgument isConstantExpression]) ifFalse: [^self].	self field type = self field platform blob ifFalse: [^self].	(mainArgument value size \\ 3) = 0 ifFalse: [self error: 'Sorry, but you will need to use a number of characters that base64 encodes exactly'].	base64Length := (mainArgument value size // 3) * 4.	arguments at: 2 put: base64Length asGlorpExpression.	base64Start := ((arguments first value // 3) * 4) + 1.	arguments at: 1 put: base64Start asGlorpExpression.	stream := WriteStream on: String new.	self field type print: mainArgument value on: stream.	actualArgument := (ReadStream on: stream contents) skip: 1; upTo: $'.	mainArgument value: actualArgument.</body><body package="GlorpExpressions">rewriteFunctionArgumentsWith: mainArgument	"This is pretty awful. We expect our main argument to be a string, and we're a substring function, but we know that for some types, the string representation comes out differently in the database. In particular, the Postgresql driver stores strings into lobs in Base64. So, if our previous argument = the string size, rewrite it to the database size. This makes it work if we do    (someObject blob copyFrom: 1 to: 3) = 'abc'when in fact, the length of that string in the blob will be 4."	| platform fieldType |	platform := base ultimateBaseExpression system platform.	(platform isPostgreSQLPlatform and: [self field type = platform blob]) ifTrue: [^self rewriteForPostgresqlBase64BlobsWith: mainArgument].	platform isOraclePlatform ifFalse: [^self].	fieldType := self field type.	fieldType = platform longRaw ifTrue: [^self rewriteForOracleBlobsWith: mainArgument].	fieldType = platform blob ifTrue: [^self rewriteForOracleBlobsWith: mainArgument].</body></methods><methods><class-id>Glorp.SubstringFunction</class-id> <category>preparing</category><body package="GlorpExpressions">rewriteFunctionArguments	"SUBSTR wants arguments position and length rather than (start) position and end position in Postgres, Oracle (not OracleODBC), MySQL, SQL Server and DB2.  If the arguments are all constants, we just compute the new last argument's value.  If not, we generate an expression for it.  Ideally, we would then symbolically evaluate this expression to null out same-value terms, e.g. by converting	LENGTH(...) - (LENGTH(...) - 2 + 1)into	0 - (0 - 2) + 1so the we could evaluate it, as for constants.  For now, we leave this and just send the whole thing to the database to evaluate."	| rewrittenExpression |	base ultimateBaseExpression system platform usesLengthNotEndPosInSubstring ifFalse: [^self].	"Nothing to do"	(arguments allSatisfy: [:each | each isConstantExpression]) ifTrue:	"set value of last constant to length (from endPosition)"		[^arguments last value: arguments last value - arguments first value + 1].	"Not all constants, so compute an expression for last - first ..."	rewrittenExpression := RelationExpression		named: #-		basedOn: arguments last		withArguments: (Array with: arguments first).	" ... + 1"	rewrittenExpression leftChild isConstantExpression		ifTrue: [rewrittenExpression leftChild value: rewrittenExpression leftChild value + 1]		ifFalse: [rewrittenExpression rightChild isConstantExpression				ifTrue: [rewrittenExpression rightChild value: rewrittenExpression rightChild value - 1]				ifFalse: [rewrittenExpression := RelationExpression						named: #+						basedOn: rewrittenExpression						withArguments: (Array with: 1)]].	arguments at: arguments size put: rewrittenExpression.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>printing</category><body package="GlorpExpressions">printOnlySelfOn: aStream	aStream print: value</body><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary	self value glorpPrintSelectSQLOn: aStream.	alias notNil ifTrue: [		aStream 			nextPutAll: ' AS ';			nextPutAll: alias].</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	self value glorpPrintSQLOn: aStream.</body><body package="GlorpExpressions">printTreeOn: aStream 	aStream print: value</body><body package="GlorpExpressions">printUnqualifiedSQLOn: aStream withParameters: aDictionary	self printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>testing</category><body package="GlorpExpressions">canBind	"Return true if this represents a value that can be bound into a prepared statement"	^true.</body><body package="GlorpExpressions">isConstantExpression	^true.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>accessing</category><body package="GlorpExpressions">alias	^alias</body><body package="GlorpExpressions">alias: anObject	alias := anObject</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^false.</body><body package="GlorpExpressions">field	^self.</body><body package="GlorpExpressions">table	^nil</body><body package="GlorpExpressions">ultimateBaseExpression	^nil.</body><body package="GlorpExpressions">value	^value</body><body package="GlorpExpressions">value: anObject	value := anObject</body><body package="GlorpExpressions">valueIn: aDictionary	^value</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>preparing</category><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^self.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	^self.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>converting</category><body package="GlorpExpressions">asGlorpExpressionForDescriptor: aDescriptor	"This should only get sent to us if we're the top level of an expression. And since we don't have children, we're also the bottom level. This is only useful for the case where the expression is [:each | true] or [:each | false]."	^(EmptyExpression on: value)		rebuildOn: (BaseExpression new descriptor: aDescriptor).</body><body package="GlorpExpressions">asGlorpExpressionOn: aBaseExpression	^self.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>api</category><body package="GlorpExpressions">get: aSymbol withArguments: anArray	| functionExpression |	functionExpression := self getFunction: aSymbol withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^RelationExpression		named: aSymbol		basedOn: self		withArguments: anArray</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>mapping</category><body package="GlorpExpressions">mappedFields	^Array with: self.</body><body package="GlorpExpressions">valueInBuilder: aBuilder	^value.</body><body package="GlorpExpressions">valueInBuilder: aBuilder as: anExpression	^value.</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>recursion</category><body package="GlorpExpressions">createMappingToFieldInRecursionTable: aDatabaseTable	"Recursion table fields are not assigned types in the database, but Glorp DNUs on a nil type during recursion definition, and will send #exdiType if binding (that call will survive a return of nil but must not return #subclassResponsibility).  Thus we seek a specific Glorp type for the recursion table field.	The commented-out ifNone: block indicates a viable alternative or backstop arrangement - to return a nonce type (that we do not add it to the platform's type dictionary).  If the deed arises, uncomment this (and define GlorpNonceType subclass of GlorpDatabaseType, with GlorpNonceType&gt;&gt;exdiType returning nil)."	| impliedGlorpType newMapping |	impliedGlorpType := aDatabaseTable platform typesWithValues		detect:			[:each || stClass | stClass := each impliedSmalltalkType.			stClass ~~ Object and: [value isKindOf: stClass]].		"ifNone:			[GlorpNonceType new				typeString: 'recursionConstant';				platform: aDatabaseTable platform]"	newMapping := DirectMapping new.	newMapping field:		(aDatabaseTable createFieldNamed: alias type: impliedGlorpType).	^newMapping</body></methods><methods><class-id>Glorp.ConstantExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">for: anObject	^self new value: anObject.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>api</category><body package="GlorpExpressions">AND: anExpression	anExpression isNil ifTrue: [^self].	^anExpression asGlorpExpression.</body><body package="GlorpExpressions">OR: anExpression	anExpression isNil ifTrue: [^self].	^anExpression</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>accessing</category><body package="GlorpExpressions">base	^base.</body><body package="GlorpExpressions">base: aBaseExpression	base := aBaseExpression.</body><body package="GlorpExpressions">isFalse	^value not</body><body package="GlorpExpressions">isTrue	^value</body><body package="GlorpExpressions">value: aValue	"a value is expected to be nil, true, or false. we treat nil as true"	value := aValue isNil ifTrue: [true] ifFalse: [aValue].</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>testing</category><body package="GlorpExpressions">canHaveBase	^true.</body><body package="GlorpExpressions">canPrint	"Return true if we can print into a where clause"	^false.</body><body package="GlorpExpressions">isEmptyExpression	^true.</body><body package="GlorpExpressions">willPrintAsWhereClause	^false.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>As yet unclassified</category><body package="GlorpExpressions">printSQLOn: aCommand withParameters: aDictionary	^self.</body><body package="GlorpExpressions">tablesForANSIJoin	^#().</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>printing</category><body package="GlorpExpressions">printTreeOn: aStream 	aStream nextPutAll: 'empty expression'.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree"	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| copy |	self == anExpression ifTrue: [^aBaseExpression].	self base == ultimateBaseExpression ifTrue: [^self].	copy := self copy.	copy base: aBaseExpression.	^copy.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>navigating</category><body package="GlorpExpressions">ultimateBaseExpression	base isNil ifTrue: [base := BaseExpression new].	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.EmptyExpression</class-id> <category>initialize</category><body package="GlorpExpressions">initialize	super initialize.	value := true.</body></methods><methods><class-id>Glorp.EmptyExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">on: aValue	^self new value: aValue.</body></methods><methods><class-id>Glorp.DB2IdentityType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initializeForField: aDatabaseField in: aDescriptorSystem	sequence isNil ifFalse: [^self].	sequence := aDescriptorSystem				databaseIdentitySequenceNamed: (aDescriptorSystem sequenceNameForField: aDatabaseField).	sequence schema: aDatabaseField table schema</body></methods><methods><class-id>Glorp.DB2IdentityType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">isIdentityColumn	^true</body></methods><methods><class-id>Glorp.MessageArchiverForGetMapping</class-id> <category>expression creation</category><body package="GlorpQueries">sendMessageTo: anExpression withArguments: arguments	"Send our own particular message. Note that our arguments will have been wrapped as constant expressions, and we don't want that, so unwrap them"	^anExpression getMapping: arguments first value named: (arguments at: 2) value.</body></methods><methods><class-id>Glorp.GlorpRecursiveCollection</class-id> <category>adding</category><body package="GlorpQueries">add: aStoreBlob	self halt: 'Are we in fact behaving like a collection?'.	^firstItem isNil		ifTrue: [firstItem := aStoreBlob]		ifFalse: [firstItem next: aStoreBlob]</body></methods><methods><class-id>Glorp.GlorpRecursiveCollection</class-id> <category>accessing</category><body package="GlorpQueries">contents	"Respond to collection protocol with the first item in the chain."	^firstItem</body><body package="GlorpQueries">nextPutAll: aSequenceableCollection	"For now, we hardcode #next: as the parameter-returning successor method.  Later, we may provide a block or similar and or switch from class-side new: to instance-side copyEmpty{:} as the means to get instances."	aSequenceableCollection isEmpty ifTrue: [self halt: 'empty blob chain'].	"remove when testing complete"	(2 to: aSequenceableCollection size)		inject: (firstItem := aSequenceableCollection first)		into: [:eachPrev :eachIndex |			eachPrev next: (aSequenceableCollection at: eachIndex)].</body></methods><methods><class-id>Glorp.GlorpRecursiveCollection</class-id> <category>testing</category><body package="GlorpQueries">includes: aStoreBlob	| currentItem |	self halt: 'Are we in fact behaving like a collection?'.	currentItem := firstItem.	[currentItem isNil] whileFalse:		[currentItem == aStoreBlob ifTrue: [^true]].	^false</body></methods><methods><class-id>Glorp.GlorpRecursiveCollection</class-id> <category>streams</category><body package="GlorpQueries">writeStream	"Return self - I'll be my own pseudo-writeStream on my own pseudo-collection."</body></methods><methods><class-id>Glorp.GlorpRecursiveCollection class</class-id> <category>instance creation</category><body package="GlorpQueries">new: aSize	"I wrap a chain, not a collection, so cannot usefully pre-size anything."	^self new</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>converting</category><body package="GlorpExpressions">asField	"If we correspond to a single field, return it. This is a bit of a hack having this only here, because for some functions it doesn't work."	^self.</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>preparing</category><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."		| newArguments |	newArguments := arguments collect: [:each | each asExpressionJoiningSource: source toTarget: target].	^(super asExpressionJoiningSource: source toTarget: target) arguments: newArguments.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuilt newArgs |	self == anExpression ifTrue: [^aBaseExpression].	base == aBaseExpression ifTrue: [^self].	newArgs := arguments collect: [:each | each rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression].	rebuilt := (base rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression) get: self symbol withArguments: newArgs.	rebuilt alias: self alias.	^rebuilt.</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>printing</category><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	| translated |	base printSQLOn: aStream withParameters: aDictionary.	self printsIntoJoins ifFalse: [^self].	1 to: self functionParts size do: [:i |		aStream 			nextPut: $ ;			nextPutAll: (self functionParts at: i);			nextPut: $ .		i &gt; arguments size ifFalse: [ 			translated := self convertValueOf: (arguments at: i) in: aDictionary.			translated isGlorpExpression				ifTrue: [translated printSQLOn: aStream withParameters: aDictionary]				ifFalse: [self type print: translated on: aStream]]].</body><body package="GlorpExpressions">printTreeOn: aStream 	base printOn: aStream.	aStream		nextPutAll: ' ', function, ' '.	arguments printOn: aStream.</body><body package="GlorpExpressions">printUnqualifiedSQLOn: aStream withParameters: aDictionary	"The initial call of functionParts guarantees its (lazy) initialization, after which we can safely refer to the instvar directly."	base printUnqualifiedSQLOn: aStream withParameters: aDictionary.	self functionParts with: arguments do:		[:functionPart :arg |		aStream 			nextPut: $ ;			nextPutAll: functionPart;			nextPut: $ .		arg printUnqualifiedSQLOn: aStream withParameters: aDictionary].</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>accessing</category><body package="GlorpExpressions">argument	^arguments first.</body><body package="GlorpExpressions">argument: anObject	arguments := Array with: anObject.</body><body package="GlorpExpressions">arguments	^arguments.</body><body package="GlorpExpressions">arguments: anArray	arguments := anArray.</body><body package="GlorpExpressions">functionParts	functionParts isNil ifTrue: [functionParts := Array with: function].	^functionParts.</body><body package="GlorpExpressions">functionParts: anArray	functionParts := anArray.</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	super do: aBlock skipping: aSet.	arguments do: [:each | each do: aBlock skipping: aSet].</body></methods><methods><class-id>Glorp.InfixFunction</class-id> <category>mapping</category><body package="GlorpExpressions">valueInBuilder: anElementBuilder	^anElementBuilder valueOfField: self"Example:  an InfixFunction	Base(Glorp.ASCustomer) NOT EXISTS #(subselect(a SimpleQuery for ASOrder))results from the #retrieve: block in	 query := Query read: ASCustomer where:		[:cust | cust name = 'Informing AG' AND: [cust orders notEmpty]].	query setUpBaseFromSession: session.	query retrieve:[:each | each orders isEmpty].	query executeIn: session.In anElementBuilder's fieldTranslations, this function keys 1 (in the example, it is the first - and only - retrieval).  Therefore it extracts the first value from the row (which will be false in the example)."</body></methods><methods><class-id>Glorp.InfixFunction class</class-id> <category>instance creation</category><body package="GlorpExpressions">named: aStringOrArray	| instance trimmedName |	instance := self new.	aStringOrArray isString		ifTrue: [instance function: aStringOrArray]		ifFalse: [			instance functionParts: aStringOrArray.			trimmedName := aStringOrArray copyFrom: 2 to: aStringOrArray size.			instance function: (trimmedName inject: aStringOrArray first into: [:sum :each | sum, ' ', each])].	^instance.</body></methods><methods><class-id>Glorp.ReversingFunction</class-id> <category>printing</category><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	"Print the function in reverse, arguments first then base.  It is unlikely there would be more than one argument;  if there were, they would also be printed in reverse."	| translated |	self printsIntoJoins ifFalse:	"this guard clause may be needless"		[^base printSQLOn: aStream withParameters: aDictionary].	self functionParts size to: 1 do:		[:i |	"In reverse order print each argument ..."		i &gt; arguments size ifFalse:			[translated := self convertValueOf: (arguments at: i) in: aDictionary.			translated isGlorpExpression				ifTrue: [translated printSQLOn: aStream withParameters: aDictionary]				ifFalse: [self type print: translated on: aStream]].		aStream	"... then each function part ..."			nextPut: $ ;			nextPutAll: (functionParts at: i);			nextPut: $ ].	"... and finally, the base."	base printSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions">printTreeOn: aStream	"I assume the function has only has one part.  Method #printUnqualifiedSQLOn:withParameters: assumes it may have many parts and an equal number of arguments.  Method #printSQLOn:withParameters: assumes it may have many arguments and even more parts.  These discrepancies exactly reflect the super implementations, which are under review."	arguments reverse printOn: aStream.	aStream		nextPut: $ ;		nextPutAll: function;		nextPut: $ .	base printOn: aStream.</body><body package="GlorpExpressions">printUnqualifiedSQLOn: aStream withParameters: aDictionary	self functionParts size to: 1 do:		[:index || arg functionPart |		arg := arguments at: index.		functionPart := functionParts at: index.		arg printUnqualifiedSQLOn: aStream withParameters: aDictionary.		aStream			nextPut: $ ;			nextPutAll: functionPart;			nextPut: $ ].	base printUnqualifiedSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.DolphinDatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase">loginIfError: aBlock	self		execute:			[connection := ((Smalltalk at: #DBConnection) new)				dsn: currentLogin connectString;				uid: currentLogin username;				pwd: currentLogin password;				connect.]		ifError: aBlock</body><body package="GlorpDatabase">logout	connection notNil		ifTrue:			[[connection close.] ensure: [connection := nil]].</body><body package="GlorpDatabase">showDialog: aString	(Smalltalk at: #MessageBox) warning: aString.</body></methods><methods><class-id>Glorp.DolphinDatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase">beginTransaction	connection beginRWTxn.</body><body package="GlorpDatabase">commitTransaction	self log: 'Commit Transaction'.	self logOnly ifTrue: [^self].	connection commitTxn</body><body package="GlorpDatabase">isInTransaction	^connection isInTransaction</body><body package="GlorpDatabase">rollbackTransaction	self log: 'Rollback Transaction'.	self logOnly ifTrue: [^self].	connection rollbackTxn</body></methods><methods><class-id>Glorp.DolphinDatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase">isLoggedIn	^connection notNil.</body></methods><methods><class-id>Glorp.DolphinDatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase">basicExecuteSQLString: aString	| resultSet array |	self log: aString.	self logOnly ifTrue: [^self].	resultSet := connection query: aString.	"Write statements don't like asArray if there's not result. DDL statements don't even like the isEmpty test"	array := [resultSet isEmpty ifTrue: [#()] ifFalse: [resultSet asArray]]		on: Dialect error		do: [:ex | ex return: #()].	resultSet		close;		free.	^ReadStream on: array read.</body><body package="GlorpDatabase">externalDatabaseErrorSignal	^Smalltalk at: #DBError</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">preWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor	aDatabaseRow at: aDatabaseField put: self class next.</body><body package="GlorpDatabaseTypes">typeName	^representationType typeName.</body><body package="GlorpDatabaseTypes">typeString	^representationType typeString</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">isGenerated	^true</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Integer.</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>initialize-release</category><body package="GlorpDatabaseTypes">representedBy: dbType	representationType := dbType</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^representationType exdiType.</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType class</class-id> <category>instance creation</category><body package="GlorpDatabaseTypes">representedBy: dbType	^super new		representedBy: dbType</body></methods><methods><class-id>Glorp.GlorpInMemorySequenceDatabaseType class</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">next	(count isNil)	ifTrue: [count := 0].	count := count + 1.	^count</body><body package="GlorpDatabaseTypes">reset	count := 0</body></methods><methods><class-id>Glorp.Proxy</class-id> <category>accessing</category><body package="GlorpQueries">class	^Proxy	"self isInstantiated ifTrue: [^value class].	query isNil ifTrue: [^Proxy].	query resultClass isNil ifTrue: [^Proxy].	^query resultClass."</body><body package="GlorpQueries">isKindOf: aClass	self isInstantiated ifTrue: [^value isKindOf: aClass].	query isNil ifTrue: [^false].	query resultClass isNil ifTrue: [^false].	query resultClass isBehavior ifFalse: [^false].	^query resultClass includesBehavior: aClass.</body><body package="GlorpQueries">parameters	^parameters</body><body package="GlorpQueries">parameters: aDictionary	parameters := aDictionary.</body><body package="GlorpQueries">query	^query</body><body package="GlorpQueries">query: aQuery 	query := aQuery</body><body package="GlorpQueries">session	^session</body><body package="GlorpQueries">session: aSession 	session := aSession</body></methods><methods><class-id>Glorp.Proxy</class-id> <category>printing</category><body package="GlorpQueries">printOn: aStream 	aStream nextPut: ${.	isInstantiated 		ifTrue: [self getValue printOn: aStream]		ifFalse: 			[aStream nextPutAll: 'uninstantiated '.			query isNil				ifTrue: [aStream nextPutAll: '???']				ifFalse: [					query readsOneObject ifFalse: [aStream nextPutAll: 'collection of '].					aStream nextPutAll: query resultClass name]].	aStream nextPut: $}</body></methods><methods><class-id>Glorp.Proxy</class-id> <category>proxy actions</category><body package="GlorpQueries">glorpOwner	"Return the object for which this proxy was created. Note that this is not kept track of unless we have a proxy action."	action isNil ifTrue: [^nil].	^action key.</body><body package="GlorpQueries">glorpOwner: anObject	"If we don't have an action, the owner is unnecessary. Ignore it. If we do have one, put it in as the key of an association with the action block following it."	action isNil ifTrue: [^self].	action key: anObject.</body><body package="GlorpQueries">glorpProxyAction	"Return the block we expect to evaluate when the proxy is fired."	action isNil ifTrue: [^nil].	^action value.</body><body package="GlorpQueries">glorpProxyAction: aTwoArgumentBlock	"Set the action we'll take when the proxy fires. This is a two argument block that takes the owning object and the value of the proxy as arguments."	aTwoArgumentBlock isNil ifTrue: [^action := nil].	action := nil -&gt; aTwoArgumentBlock.</body><body package="GlorpQueries">glorpTriggerProxyAction: target	"Evaluate our action with the owner and the newly retrieved target."	| owner block |	action isNil ifTrue: [^self].	owner := action key.	block := action value.	block value: owner value: target.</body></methods><methods><class-id>Glorp.Proxy</class-id> <category>api</category><body package="GlorpQueries">getValue	self isInstantiated ifTrue: [^value].	parameters isNil ifTrue: [parameters := Dictionary new: 0].	[value := query isNil		ifTrue: [nil]		ifFalse: [query executeWithParameters: parameters in: session]]		ensure: [isInstantiated := true].	self glorpTriggerProxyAction: value.	^value.</body></methods><methods><class-id>Glorp.Proxy class</class-id> <category>instance creation</category><body package="GlorpQueries">read: aClass where: aBlock	^self new query: (Query read: aClass where: aBlock)</body><body package="GlorpQueries">read: aClass where: aBlock in: aSession	^self new		query: (Query read: aClass where: aBlock);		session: aSession</body><body package="GlorpQueries">readOneOf: aClass where: aBlock	^self new query: (Query readOneOf: aClass where: aBlock)</body><body package="GlorpQueries">readOneOf: aClass where: aBlock in: aSession	^self new		query: (Query readOneOf: aClass where: aBlock);		session: aSession.</body><body package="GlorpQueries">returningManyOf: aClass where: aBlock	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:).	^self read: aClass where: aBlock</body><body package="GlorpQueries">returningManyOf: aClass where: aBlock in: aSession	"readManyOf: and returningManyOf: are synonyms of read:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #read:where:).	^self read: aClass where: aBlock in: aSession</body><body package="GlorpQueries">returningOneOf: aClass where: aBlock	"returningOneOf: is a synonyms of readOneOf:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #readOneOf:where:).	^self readOneOf: aClass where: aBlock</body><body package="GlorpQueries">returningOneOf: aClass where: aBlock in: aSession	"returningOneOf: is a synonyms of readOneOf:. This now seems more natural to me, to be consistent with session API."	self deprecated: #(#version '7.10' #sunset '8.0' #use #readOneOf:where:).	^self readOneOf: aClass where: aBlock in: aSession</body></methods><methods><class-id>Glorp.SQLite3Proxy</class-id> <category>proxy actions</category><body package="GlorpQueries">glorpTriggerProxyAction: target	"Evaluate our action with the owner and the newly retrieved target.	Return the result of this evaluation, or self if there is no action.	Since the return value has ambiguous semantics, this needs work."	| owner block |	action isNil ifTrue: [^self].	owner := action key.	block := action value.	^block value: owner value: target.</body></methods><methods><class-id>Glorp.SQLite3Proxy</class-id> <category>api</category><body package="GlorpQueries">getValue	"This method further modifies the retrieved value using the action block."	self isInstantiated ifTrue: [^value].	parameters isNil ifTrue: [parameters := Dictionary new: 0].		[value := query isNil				ifTrue: [nil]				ifFalse: [query executeWithParameters: parameters in: session]]			ensure: [isInstantiated := true].	value := self glorpTriggerProxyAction: value.	^value</body></methods><methods><class-id>Glorp.SQLite3Proxy</class-id> <category>accessing</category><body package="GlorpQueries">class	^SQLite3Proxy</body></methods><methods><class-id>Glorp.BoundParametersUpdateCommand</class-id> <category>bound values</category><body package="GlorpDatabase">arrayBindings	"For Oracle, we get the updated relative field values as final parameters via output buffers.	Append each returning field's template value here so that they are added to our exdi buffers.	These buffers are just receptacles for the returned data, so their content merely needs the	correct type. Their value is ignored by Oracle, and will be overwritten with return content."	| arrayBindings |	arrayBindings := super arrayBindings asOrderedCollection.	1 to: relativeFields size		do: 			[:columnNumber |			| relativeField sampleValue |			relativeField := relativeFields at: columnNumber.			sampleValue := row at: relativeField ifAbsent: [nil].			sampleValue isNil ifTrue: [sampleValue := relativeField type nilOldValueEquivalent].			arrayBindings addLast: (Array new: (allRows size) withAll: sampleValue)].	^arrayBindings asArray</body><body package="GlorpDatabase">bindingTypes	"Use my superclass bindTemplate, and then append one more entry for each relative field, for the return values."	| result |	result := super bindingTypes.	self singleRowBoundFields do:		[:each |		each type isRelativeType ifTrue: [result add: each type]].	^result</body><body package="GlorpDatabase">singleRowBindings	"For Oracle, we get the updated relative field values as final parameters via output buffers.	Append each returning field's template value here so that they are added to our exdi buffers.	These buffers are just receptacles for the returned data, so their content merely needs the	correct type. Their value is ignored by Oracle, and will be overwritten with return content."	| rowBindings |	rowBindings := super singleRowBindings asOrderedCollection.	1 to: relativeFields size		do: 			[:columnNumber |			| relativeField sampleValue |			relativeField := relativeFields at: columnNumber.			sampleValue := row at: relativeField ifAbsent: [nil].			sampleValue isNil ifTrue: [sampleValue := relativeField type nilOldValueEquivalent].			rowBindings addLast: sampleValue].	^rowBindings asArray</body></methods><methods><class-id>Glorp.BoundParametersUpdateCommand</class-id> <category>executing</category><body package="GlorpDatabase">postWriteAssignReturnValuesUsing: answerStream	"Ask the relative type how to assign returned value(s) to the target column(s) of my rows.  As result returns an array of arrays, we need the inner array.  If relative fields and values are not the same size, #with:do: will raise an error."	| index |	allRows isNil		ifTrue:			[index := self singleRowBindings size - relativeFields size + 1.	"position of first output value"			relativeFields do:				[:field || value |				value := answerStream accessor					bindReturningVariableAt: index					forStatement: answerStream statement.			 	row at: field forcePut: value.				index := index + 1]]		ifFalse:			[index := self arrayBindings size - relativeFields size + 1.	"position of first output array"			relativeFields do:				[:field || valueArray |				valueArray := answerStream accessor					bindReturningVariableAt: index					forStatement: answerStream statement.		"IF allRows size = 1, row == allRows first AND SO we could use the branch above;  can we nil allRows beforehand?"				(allRows size = 1 and: [valueArray glorpIsCollection not]) ifTrue:	"With just one row (after grouping), not an array."					[valueArray := Array with: valueArray].			 	allRows with: valueArray do:					[:eachRow :eachValue| eachRow at: field forcePut: eachValue].				index := index + 1]].</body></methods><methods><class-id>Glorp.BoundParametersUpdateCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase">forRow: aDatabaseRow useBinding: aBoolean session: aSession	"If we are not binding, we cannot return values."	^aBoolean		ifTrue: [super forRow: aDatabaseRow useBinding: aBoolean session: aSession]		ifFalse: [RelativeUpdateCommand				forRow: aDatabaseRow				useBinding: aBoolean				session: aSession]</body><body package="GlorpDatabase">forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession	"If we are not binding, we cannot return values."	^aBoolean		ifTrue: [super forRows: aCollectionOfDatabaseRows useBinding: aBoolean session: aSession]		ifFalse: [RelativeUpdateCommand				forRows: aCollectionOfDatabaseRows				useBinding: aBoolean				session: aSession]</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>testing</category><body package="GlorpDatabaseTypes">hasParameters	"Return true if this has modifiable parameters. That is, when we return one of these, should we return a copy rather than trying to save space be re-using instances"	^true.</body><body package="GlorpDatabaseTypes">isIntegerType	"If we have no precision and no scale, we're effectively an Integer"	^self precision isNil and: [self scale isNil]</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>accessing</category><body package="GlorpDatabaseTypes">beRelative	^super beRelative		precision: self precision;		scale: self scale;		yourself</body><body package="GlorpDatabaseTypes">precision	^precision.</body><body package="GlorpDatabaseTypes">precision: anInteger	precision := anInteger.</body><body package="GlorpDatabaseTypes">scale	^scale.</body><body package="GlorpDatabaseTypes">scale: anInteger	scale := anInteger.</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'numeric'.</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	"Can we do better than this??"	^#FixedPoint</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	(aClass includesBehavior: Boolean) ifTrue: [^self platform converterNamed: #booleanToInteger].	^self platform converterNamed: #numberToNumber.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	self isIntegerType ifTrue: [^Integer].	^super impliedSmalltalkType</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">typeString	| w |	platform supportsVariableSizedNumerics ifFalse: [^typeString].	w := WriteStream on: String new.	w nextPutAll: typeString.	precision isNil 		ifFalse: 			[w nextPutAll: '(' , precision printString.			scale isNil ifFalse: [w nextPutAll: ',' , scale printString].			w nextPutAll: ')'].	^w contents</body></methods><methods><class-id>Glorp.GlorpNumericType</class-id> <category>comparing</category><body package="GlorpDatabaseTypes">= aType	"We do a special case check here that something that reads back as numeric with no scale/precision counts as being the same as an integer type"	((aType class == self platform integer class) and: [self isIntegerType]) ifTrue: [^true].	super = aType ifFalse: [^false].	self precision = aType precision ifFalse: [^false].	self scale = aType scale ifFalse: [^false].	^true.</body><body package="GlorpDatabaseTypes">hash	"A very special case here, if we're effectively an Integer, then we need to hash in a way compatible with GlorpIntegerType"	self isIntegerType ifTrue: [^self platform hash bitXor: self impliedSmalltalkType hash].	^(super hash bitXor: self precision hash) bitXor: self scale hash</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>accessing</category><body package="GlorpCore">classModel	^self descriptor classModel</body><body package="GlorpCore">descriptor	^self session descriptorFor: self class</body><body package="GlorpCore">session	session isNil ifTrue: [session := self class getSession].	^session.</body><body package="GlorpCore">session: aGlorpSession	session := aGlorpSession</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>actions</category><body package="GlorpCore">bePersistent	"Queue our object to be saved to the database upon commit."	self session		requireUnitOfWork;		register: self</body><body package="GlorpCore">commitUnitOfWork	"Commit the entire unit of work; this may include objects other than myself."	self session hasUnitOfWork ifFalse: [^self].	self session commitUnitOfWork</body><body package="GlorpCore">delete	"Queue our object to be removed from the database on commit."	self session delete: self</body><body package="GlorpCore">refresh	"Refresh our object from the database and rollback any changes registered in the unit of work."	self rollback.	self session refresh: self</body><body package="GlorpCore">rollback	"Rollback our entries in the queue so that we are not involved in the commit."	self session hasUnitOfWork ifFalse: [^self].	self session rollbackUnitOfWorkFor: self</body><body package="GlorpCore">rollbackUnitOfWork	"Rollback the entire unit of work; this may include objects other than myself."	self session hasUnitOfWork ifFalse: [^self].	self session rollbackUnitOfWork</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>finding objects</category><body package="GlorpCore">find	"This is a query by example facility. We take whichever fields are filled in the object and read back any objects in the database that match."		| instances |	instances := GlorpVirtualCollection on: self class in: self session.	self descriptor mappings do: [:eachMapping | 		instances := self findMapping: eachMapping in: instances].	^instances.</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>private</category><body package="GlorpCore">findMapping: aMapping in: aVirtualCollection		aMapping hasAttribute not ifTrue: [^aVirtualCollection].	aMapping attribute name = #session ifTrue: [^aVirtualCollection].	^(aMapping attribute getValueFrom: self)		ifNil: [aVirtualCollection]		ifNotNil: [:value | aVirtualCollection select: [:each | self matchAttribute: (each get: aMapping attribute name) to: value]].</body><body package="GlorpCore">matchAttribute: anExpression to: value	"We match expressions differently depending on what type they are."		^(value isString and: [value includes: $%]) 		ifTrue: [anExpression like: value] 		ifFalse: [anExpression = value].</body></methods><methods><class-id>Glorp.PersistentObject</class-id> <category>comparing</category><body package="GlorpCore">= anObject	"Implement equality to compare primary keys if they are set. Make sure that if we have proxies, we check through them."	| descriptor myKey |	self class = anObject yourSelf class ifFalse: [^false].	descriptor := self descriptor.		"If the primary keys aren't equal, then we know for sure we are unequal. Otherwise we have to check further."	myKey := descriptor primaryKeyCollectionFor: self.	myKey = (descriptor primaryKeyCollectionFor: anObject)		ifFalse: [^false].	"If the primary key contains nils, then fall back to the default equality comparison. If they don't, and are equal, then the objects are equal."	^(myKey includes: nil) 		ifTrue: [super = anObject yourSelf]		ifFalse: [true].</body><body package="GlorpCore">hash	"Implement hash to compare primary keys if they are set. Make sure that if we have proxies, we check through them."	| myKey |	"If the primary key contains nils, then fall back to the default hash. If they don't, hash the collection."	myKey := self descriptor primaryKeyCollectionFor: self.	^(myKey includes: nil) 		ifTrue: [super hash]		ifFalse: [myKey hash]</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>finding objects</category><body package="GlorpCore">count	"Count the number of objects in the database"	"Person count"	^ self getSession count: self</body><body package="GlorpCore">find: primaryKey	"Query the database for an object whose primary key = the given value."	"Person find: 1"	| session |	session := self getSession.	^session execute: (self query: primaryKey).</body><body package="GlorpCore">findAll	"Query the database for all objects of this class."	"Person findAll"	^self getSession read: self.</body><body package="GlorpCore">findWhere: aBlock	"Query the database for all objects of this class satisfying aBlock. The block has to be a query block, meaning you can't execute arbitrary code, but rather it will be analyzed and used to generate SQL."	"Person findWhere: [:each | (each name = 'John Doe') &amp; (each address houseNum = 1000)]"	^self getSession read: self where: aBlock.</body><body package="GlorpCore">query: primaryKey	"Return a query object that will query the database for an object whose primary key = the given value. If you want to just return the object, use find: instead. The advantage of this is that you can use this to get a basic query, but then modify it before executing it."	"Person query: 1"	| pkAttribute session |	session := self getSession.	pkAttribute := (session system descriptorFor: self) primaryKeyMappings first attribute name.	^Query readOneOf: self where: [:each | (each perform: pkAttribute) = primaryKey].</body><body package="GlorpCore">queryAll	"Return a query object that will query the database for all objects of this class. If you want to just return the object, use find: instead. The advantage of this is that you can use this to get a basic query, but then modify it before executing it."	"Person queryAll"	^Query read: self.</body><body package="GlorpCore">queryWhere: aBlock	"Return a Query object that will query the database for all objects of this class satisfying aBlock. The block has to be a query block, meaning you can't execute arbitrary code, but rather it will be analyzed and used to generate SQL. If you want to just return the objects, use findWhere: instead. The advantage of this is that you can use this to get a basic query, but then modify it before executing it, e.g. using AND: or OR:."	"Person queryWhere: [:each | (each name = 'John Doe') &amp; (each address houseNum = 1000)]"	^Query read: self where: aBlock.</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>accessing</category><body package="GlorpCore">classModel	^self descriptor classModel</body><body package="GlorpCore">descriptor	^self getSession descriptorFor: self</body><body package="GlorpCore">table	^self descriptor ifNotNil: [:descriptor | descriptor table]</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>instance creation</category><body package="GlorpCore">new	^super new initialize.</body></methods><methods><class-id>Glorp.PersistentObject class</class-id> <category>session</category><body package="GlorpCore">getSession	"Return the session to be used for the current query. In general, we don't know how to find our session. Callers can catch the CannotFindSession exception and resume it, or subclasses can implement this method to find the session using mechanisms like process environment, a global, or whatever else they have available."	^CannotFindSession raise.</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>private/caching</category><body package="GlorpCore">cacheFor: anObject	"Get the cache for a particular object. Since this could conceivably be passed a proxy, check for that. The cache for an uninstantiated proxy is kind of ambiguous, treat it as nil.  This could also be a class"	| nonMetaClass |	nonMetaClass := anObject isBehavior ifTrue: [anObject] ifFalse: [anObject class].	^nonMetaClass == Proxy		ifTrue: [anObject isInstantiated ifTrue: [self cacheFor: anObject getValue] ifFalse: [nil]]		ifFalse: [self cacheForClass: nonMetaClass].</body><body package="GlorpCore">expiredInstanceOf: aClass key: aKey	^(self cacheForClass: aClass) expiredInstanceFor: aKey.</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>querying</category><body package="GlorpCore">containsObject: anObject key: aKey	| cache |	cache := self cacheForClass: anObject class.	^cache includesKey: aKey as: anObject.</body><body package="GlorpCore">containsObjectForClass: aClass key: aKey	| cache |	cache := self cacheForClass: aClass.	^cache includesKey: aKey.</body><body package="GlorpCore">expireAll	subCaches do: [:each | each expireAll].</body><body package="GlorpCore">expireClass: aClass key: aKey	^self expireClass: aClass key: aKey ifAbsent: [self error: 'Object not in cache'].</body><body package="GlorpCore">expireClass: aClass key: aKey ifAbsent: failBlock 	| cache |	cache := self cacheForClass: aClass.	(cache includesKey: aKey withClass: aClass) ifFalse: [^failBlock value].	cache expireKey: aKey ifAbsent: [ failBlock value ].</body><body package="GlorpCore">hasExpired: anObject	| key cache |	key := (session descriptorFor: anObject) primaryKeyFor: anObject.	cache := self cacheFor: anObject.	cache isNil ifTrue: [^false].  "We have an uninstantiated proxy."	^cache hasExpired: key.</body><body package="GlorpCore">hasExpired: aClass key: key	| cache |	cache := self cacheFor: aClass.	^cache hasExpired: key.</body><body package="GlorpCore">hasObjectExpiredOfClass: aClass withKey: key	| cache |	cache := self cacheForClass: aClass.	^cache hasExpired: key.</body><body package="GlorpCore">lookupClass: aClass key: aKey	^self lookupClass: aClass key: aKey ifAbsent: [self error: 'cache miss'].</body><body package="GlorpCore">lookupClass: aClass key: aKey ifAbsent: failBlock	| object |	object := (self cacheForClass: aClass) at: aKey ifAbsent: failBlock.	^(object isKindOf: aClass)		ifTrue: [ object ]		ifFalse: [ failBlock value ].</body><body package="GlorpCore">lookupClass: aClass key: aKey ifAbsentPut: failBlock	^(self cacheForClass: aClass) at: aKey ifAbsentPut: failBlock.</body><body package="GlorpCore">markAsCurrentOfClass: aClass key: key	| cache |	aClass == Proxy ifTrue: [^self].	cache := self cacheForClass: aClass.	cache markAsCurrentAtKey: key.</body><body package="GlorpCore">removeClass: aClass key: aKey	^self removeClass: aClass key: aKey ifAbsent: [self error: 'Object not in cache'].</body><body package="GlorpCore">removeClass: aClass key: aKey ifAbsent: failBlock 	| cache |	cache := self cacheForClass: aClass.	(cache includesKey: aKey withClass: aClass) ifFalse: [^failBlock value].	cache removeKey: aKey ifAbsent: [ failBlock value ].</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>adding</category><body package="GlorpCore">at: aKey insert: anObject	"Return the object in the cache, whoch may be the parameter or may be its cached equivalent."	| subCache |	subCache := self cacheForClass: anObject class.	^subCache at: aKey ifAbsentPut: [anObject]</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>accessing</category><body package="GlorpCore">numberOfElements	^subCaches inject: 0 into: [:sum :each |		sum + each numberOfElements].</body><body package="GlorpCore">session	^session.</body><body package="GlorpCore">session: aSession 	session := aSession.</body><body package="GlorpCore">system	^self session system.</body></methods><methods><class-id>Glorp.CacheManager</class-id> <category>initialize/release</category><body package="GlorpCore">cacheForClass: aClass	"the call of makeCacheFor: will put it in the cache, obviating need for at:ifAbsentPut: here - indeed, it can be dangerous if two hash values colide."		^subCaches at: aClass ifAbsent: [self makeCacheFor: aClass]</body><body package="GlorpCore">initialize	subCaches := IdentityDictionary new: 100.</body><body package="GlorpCore">makeCacheFor: aClass	"If I am called, we already know that aClass does not key an existing cache.  However, if aClass is not its own rootClass then a shared rootClass cache may already be keyed by the rootClass (and one or more other classes sharing that root class).  So we get the existing or new cache, key it by aClass (definitely needed) and key it by the rootClass if also needed."	| rootClass cache |	rootClass := session lookupRootClassFor: aClass.	cache := rootClass == aClass		ifTrue: [Cache newFor: rootClass in: self]		ifFalse: [subCaches				at: rootClass				ifAbsentPut: [Cache newFor: rootClass in: self]].	subCaches at: aClass put: cache.	^cache</body><body package="GlorpCore">release	subCaches do: [:each | each release].</body></methods><methods><class-id>Glorp.CacheManager class</class-id> <category>instance creation</category><body package="GlorpCore">forSession: aSession	"A CacheManager must have a session;  use an UnmanagedCache, not a CacheManager, if there is a single class and no session."	^self new session: aSession</body><body package="GlorpCore">new	"A CacheManager must have a session;  use an UnmanagedCache if there is a single class and no session."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpTransactionFailure</class-id> <category>accessing</category><body package="GlorpMisc">defaultMessageText	^'Optimistic Lock Conflict'.</body></methods><methods><class-id>Glorp.GlorpDatabaseWriteError</class-id> <category>accessing</category><body package="GlorpMisc">accessor	^accessor</body><body package="GlorpMisc">accessor: anObject	accessor := anObject</body><body package="GlorpMisc">command	^command</body><body package="GlorpMisc">command: aDatabaseCommand	command := aDatabaseCommand</body><body package="GlorpMisc">databaseError	^databaseError</body><body package="GlorpMisc">databaseError: aDatabaseErrorObject	databaseError := aDatabaseErrorObject</body><body package="GlorpMisc">session	^command session.</body></methods><methods><class-id>Glorp.GlorpDatabaseWriteError</class-id> <category>initialize-release</category><body package="GlorpMisc">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	command := nil.	databaseError := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>GlorpHelper class</class-id> <category>helpers</category><body package="GlorpMisc">do: aBlock for: aCollection separatedBy: separatorBlock	| array |	array := aCollection asArray.	1 to: array size do: [:i |		| each |		each := array at: i.		aBlock value: each.		i = array size ifFalse: [			separatorBlock value]].</body><body package="GlorpMisc">print: printBlock on: stream for: aCollection separatedBy: separatorString	| array |	array := aCollection asArray.	1 to: array size do: [:index |		stream nextPutAll: (printBlock value: (array at: index)).		index == array size ifFalse: [			stream nextPutAll: separatorString]].</body><body package="GlorpMisc">separate: aCollection by: aOneArgumentBlock	^aCollection inject: Dictionary new into: [:dict :each |		| val |		val := aOneArgumentBlock value: each.		(dict at: val ifAbsentPut: [OrderedCollection new]) add: each].</body></methods><methods><class-id>GlorpHelper class</class-id> <category>classes</category><body package="GlorpMisc">dialect	"Provide a way to refer to the dialect class from an extension or class that doesn't include the Glorp namespace, while still avoiding explicit namespace imports (which confuse other dialects when the 'pool dictionaries' don't exist)."	| glorpNamespace |	glorpNamespace := Smalltalk at: #Glorp ifAbsent: [nil].	^((glorpNamespace isNil ifTrue: [Smalltalk] ifFalse: [glorpNamespace]) at: #Dialect ifAbsent: [Smalltalk at: #Dialect]).</body><body package="GlorpMisc">glorpConstantExpressionClass	^self dialect glorpConstantExpressionClass</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>preparing</category><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	| rebuilt |	self == anExpression ifTrue: [^aBaseExpression].	"Rebuilding just one of them will rebuild our whole structure, since it all comes from the same definition."	rebuilt := whereClauseVersion rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression.	rebuilt == whereClauseVersion ifTrue: [^self].	rebuilt arguments: (self arguments collect: [:each | each rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression]).	^rebuilt.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>printing</category><body package="GlorpExpressions">printSelectSQLOn: aStream withParameters: aDictionary	selectListVersion printSelectSQLOn: aStream withParameters: aDictionary.</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	whereClauseVersion printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>accessing</category><body package="GlorpExpressions">arguments	^arguments.</body><body package="GlorpExpressions">arguments: anArray	arguments := anArray.	whereClauseVersion arguments: anArray.	selectListVersion arguments: anArray.</body><body package="GlorpExpressions">base: anExpression	base := anExpression.	"whereClauseVersion base: anExpression."	selectListVersion base: anExpression.</body><body package="GlorpExpressions">basicArguments: anArray	arguments := anArray.</body><body package="GlorpExpressions">basicBase: anExpression	base := anExpression.</body><body package="GlorpExpressions">field	^whereClauseVersion field.</body><body package="GlorpExpressions">selectListVersion	^selectListVersion.</body><body package="GlorpExpressions">selectListVersion: aFunctionExpression	selectListVersion := aFunctionExpression.</body><body package="GlorpExpressions">symbol: aSymbol	symbol := aSymbol.	whereClauseVersion symbol: aSymbol.	selectListVersion symbol: aSymbol.</body><body package="GlorpExpressions">type: aSymbol	super type: aSymbol.	whereClauseVersion type: aSymbol.	selectListVersion type: aSymbol.</body><body package="GlorpExpressions">whereClauseVersion	^whereClauseVersion.</body><body package="GlorpExpressions">whereClauseVersion: aFunctionExpression	whereClauseVersion := aFunctionExpression.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>converting</category><body package="GlorpExpressions">asField	^self.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	"Iterate over the expression tree. Keep track of who has already been visited, so we don't get trapped in cycles or visit nodes twice."	(aSet includes: self) ifTrue: [^self].	super do: aBlock skipping: aSet.	arguments do: [:each |		each do: aBlock skipping: aSet].</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>copying</category><body package="GlorpExpressions">copy	| new |	new := super copy.	"We need to make sure we copy these before the base gets set. This is horribly ugly."	new selectListVersion: selectListVersion copy.	new whereClauseVersion: whereClauseVersion copy.	^new.</body><body package="GlorpExpressions">createFor: argumentList withBase: anExpression symbol: aSymbol	| new newBase newArgument newFunction |	new := super createFor: argumentList withBase: anExpression symbol: aSymbol.	"For the where clause version, we've got a dualRoleFunction. We can't just rebuild the whole thing, so rebuild the children, and then re-assemble it recreating from the template."	newBase := new whereClauseVersion base isNil ifTrue: [anExpression] ifFalse: [new whereClauseVersion base rebuildOn: anExpression].	newArgument := new whereClauseVersion argument rebuildOn: anExpression.	newFunction := self whereClauseVersion copy.	newFunction symbol: aSymbol.	newFunction base: newBase.	newFunction argument: newArgument.	new whereClauseVersion: newFunction.	"Don't try to rebuild the selectListVersion at all, because at least for the motivating case we have, it's just a shell, not a full blown expression, and it will already have been copied."	^new.</body></methods><methods><class-id>Glorp.DualRoleFunction</class-id> <category>mapping</category><body package="GlorpExpressions">valueInBuilder: anElementBuilder	^anElementBuilder valueOfField: self</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>accessing</category><body package="GlorpDatabase">fields	^fields.</body><body package="GlorpDatabase">name	name isNil ifTrue: [name := self generateName].	^name.</body><body package="GlorpDatabase">name: aString	name := aString.</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>testing</category><body package="GlorpDatabase">indexesField: aField	^fields includes: aField.</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>initializing</category><body package="GlorpDatabase">addField: aField	^fields add: aField</body><body package="GlorpDatabase">addFields: aCollection	fields addAll: aCollection</body><body package="GlorpDatabase">initialize	fields := OrderedCollection new: 2.</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>printing</category><body package="GlorpDatabase">generateName	"Generate a name for this index that will fit within the size limits of the database. This only takes into account the first field being used. If there's more than one that has multiple columns and the same first one, then the user will have to manually provide a name"	| stream maxLength tableLength roomToBeVerbose minTableLength maxTableLength |	maxLength := fields first table platform maximumLengthOfTableName.	minTableLength := ((maxLength - 8) // 2) min: 10.	maxTableLength := (maxLength // 2) - 1.	roomToBeVerbose := minTableLength &gt;= 10.	tableLength := roomToBeVerbose ifTrue: [maxTableLength] ifFalse: [minTableLength].	stream := WriteStream on: (String new: 100).	stream nextPutAll: (fields first table name copyFrom: 1 to: ((fields first table name size) min: tableLength)).	stream nextPutAll: '_'.	stream nextPutAll: (fields first name copyFrom: 1 to: ((fields first name size) min: tableLength)).	stream nextPutAll: (maxLength - stream position &gt;= 4 ifTrue: ['_IDX'] ifFalse: ['X']).	^stream contents.</body><body package="GlorpDatabase">printStatementOn: aStream	aStream nextPut: $(.	fields do: [ :f | aStream nextPutAll: f name; nextPut: $, ].	aStream skip: -1; nextPut: $)</body><body package="GlorpDatabase">printStatementOn: aStream platform: aPlatform	"Some platforms need to quote some column names."	aStream nextPut: $(.	fields do: [ :f | aStream nextPutAll: (aPlatform nameForColumn: f name); nextPut: $, ].	aStream skip: -1; nextPut: $)</body></methods><methods><class-id>Glorp.DatabaseIndex</class-id> <category>comparing</category><body package="GlorpDatabase">isSimilarIndex: aDatabaseIndex	"Validate that two indexes have exactly the same fields."	self fields size = aDatabaseIndex fields  size ifFalse: [^false].	self fields asSortedCollection with: aDatabaseIndex fields asSortedCollection do: [:a :b | (a isSimilarField: b) ifFalse: [^false]].	^true</body><body package="GlorpDatabase">isTheSameAs: aDatabaseIndex	"Validate that two indexes are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aDatabaseIndex name asUppercase ifFalse: [^false].	self fields size = aDatabaseIndex fields size ifFalse: [^false].	self fields with: aDatabaseIndex fields  do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		^true</body></methods><methods><class-id>Glorp.DatabaseIndex class</class-id> <category>instance creation</category><body package="GlorpDatabase">forField: aField	^(self new initialize)		addField: aField;		yourself</body><body package="GlorpDatabase">forFields: aCollection	^(self new)		addFields: aCollection;		yourself</body><body package="GlorpDatabase">new	^super new initialize.</body></methods><methods><class-id>Glorp.DeleteCommand</class-id> <category>accessing</category><body package="GlorpDatabase">arrayBoundFields	"For a delete, it makes no difference, we only ever include the primary key fields"	^self singleRowBoundFields.</body><body package="GlorpDatabase">blockFactor	^1.</body><body package="GlorpDatabase">singleRowBoundFields	| fields |	fields := row table primaryKeyFields.	fields isEmpty ifTrue: [fields := row fields].	^fields asArray</body></methods><methods><class-id>Glorp.DeleteCommand</class-id> <category>executing</category><body package="GlorpDatabase">printSQL	self nextPutAll: 'DELETE FROM '.	row table printSQLOn: self withParameters: #().	self nextPutAll: ' WHERE '.	row printPrimaryKeyTemplateOn: self.</body></methods><methods><class-id>Glorp.DeleteCommand</class-id> <category>bound values</category><body package="GlorpDatabase">bindingTypes	"This was pushed down from the superclass when refactoring changed that for the other command subclasses.  In the simplest case, we need only write and only bind the primaryKey fields to delete, but review this command and QueryDeleteCommand before attempting any simplifications here."	| all basic size |	^self shouldUseGroupWriting		ifTrue:			[basic := self row nonGeneratedFields collect: [:each | each type].			size := basic size.			all := Array new: (allRows size * size).			0 to: allRows size - 1 do:				[:i || index | index := i * size.				all replaceElementsFrom: index + 1 to: index + size withArray: basic startingAt: 1].			all]		ifFalse: [self singleRowBoundFields collect: [:each | each type]]</body></methods><methods><class-id>Glorp.TimedProxyReaper</class-id> <category>accessing</category><body package="GlorpCore">delay	"Answer the delay, in seconds, between runs of the reaper process."	^delay</body><body package="GlorpCore">delay: seconds	"Set delay between runs of the reaper process in seconds."	delay := seconds</body><body package="GlorpCore">maximumWork	"Answer the maximum amount of time the reaper thread will run for before yielding."	^maximumWork</body><body package="GlorpCore">maximumWork: milliseconds	"Set the maximum amount of time the reaper thread will run for before yielding."	maximumWork := milliseconds</body><body package="GlorpCore">nextSequenceNumber	| id |	id := nextId.	nextId := nextId + 1.	^id</body></methods><methods><class-id>Glorp.TimedProxyReaper</class-id> <category>reaping</category><body package="GlorpCore">finish"	Transcript cr; show: 'Done', (Time millisecondClockValue // 1000) printString."	done := true.</body><body package="GlorpCore">forkReaperThread	| block |	block := [		[done] whileFalse: [			(Delay forSeconds: self delay) wait.			self reapExpiredObjects]].	reaperThread := block forkAt: Processor userBackgroundPriority</body><body package="GlorpCore">mournKeyOf: anEphemeron	"Don't really need to do anything."	anEphemeron value uninstantiate.</body><body package="GlorpCore">privateReapObjects	"Private - Go through all of the objects (sorted by time) and remove those which have expired from the receiver's weakValueDictionary.	Answer the number of objects reaped."	| numberReaped timesUp |	startTime := Time millisecondClockValue.	numberReaped := 0.	timesUp := false.	[(Delay forMilliseconds: 100) wait.	timesUp := true] forkAt: Processor activePriorityPlusOne.	keysSortedByExpiryTime		do:			[:association | 			done | timesUp ifTrue: [^numberReaped].			(self shouldReap: association)				ifTrue:					[| timedProxy |					numberReaped := numberReaped + 1.					association key isNil						ifFalse:							["Been touched in the meantime. Just skip over it, but don't reap"							timedProxy := weakValueDictionary								removeKey: association key								ifAbsent: [nil].							timedProxy class == TimedProxy ifTrue: [timedProxy uninstantiate]]]				ifFalse: [^numberReaped]].	^numberReaped.</body><body package="GlorpCore">reapExpiredObjects	| numberReaped |	[mutex wait.	keysSortedByExpiryTime isEmpty ifTrue: [self finish].	done ifTrue: [^self].	numberReaped := self privateReapObjects.	"If the cache is empty, shut down"	numberReaped timesRepeat: [keysSortedByExpiryTime removeFirst].	indexOffset := indexOffset + numberReaped] ensure: [mutex signal].</body><body package="GlorpCore">restartIfNecessary	[mutex wait.	done		ifTrue:			["Transcript cr; show: 'Restarting', (Time millisecondClockValue // 1000) printString."			done := false.			self forkReaperThread]] ensure: [mutex signal].</body><body package="GlorpCore">shouldReap: anAssociation	"Check that either we've passed the start time, or that there's been a wraparound in the millisecond value and we're now larger than it by some ridiculous margin, which we'll call 24 hours."	| expireTime milliseconds shouldReap |	anAssociation key isNil ifTrue: [^true].  "It's been touched. Skip over but don't reap, handled elsewhere"	expireTime := anAssociation value.	milliseconds := "24 * 60 * 60 * 1000" 86400000.	shouldReap := expireTime &lt;= startTime or: [expireTime - milliseconds &gt; startTime].	^shouldReap.</body></methods><methods><class-id>Glorp.TimedProxyReaper</class-id> <category>caching</category><body package="GlorpCore">add: aTimedProxy	[mutex wait.	self noWaitAdd: aTimedProxy] ensure: [mutex signal].	self restartIfNecessary.</body><body package="GlorpCore">at: id ifAbsent: errorBlock	| result |	[mutex wait.	result := weakValueDictionary at: id ifAbsent: [^errorBlock value]]		ensure: [mutex signal].	^result.</body><body package="GlorpCore">includes: aTimedProxy	self at: aTimedProxy glorpId ifAbsent: [^false].	^true</body><body package="GlorpCore">noWaitAdd: aTimedProxy	| association id |	aTimedProxy glorpId isNil ifTrue: [aTimedProxy glorpId: self nextSequenceNumber].	id := aTimedProxy glorpId.		association := Association key: id value: aTimedProxy glorpTimeToDie.	weakValueDictionary at: id put: aTimedProxy.	aTimedProxy glorpAssociation: association.	keysSortedByExpiryTime add: association.	aTimedProxy glorpReaper: self.</body><body package="GlorpCore">remove: aTimedProxy ifAbsent: errorBlock	^self removeKey: aTimedProxy glorpId ifAbsent: errorBlock.</body><body package="GlorpCore">removeKey: key ifAbsent: errorBlock	"Note: The key is NOT removed from keysSortedByExpiryTime. The reaper	will eventually reap the given key, and ignore it since it is already gone.	Removing objects from the middle of keysSortedByExpiryTime will screw	up the indexing of objects that are registered later. Don't do it."	| result |	[mutex wait.	result := weakValueDictionary removeKey: key ifAbsent: [^errorBlock value]]		ensure: [mutex signal].	^result.</body><body package="GlorpCore">touch: aTimedProxy	[| association |	mutex wait.	association := aTimedProxy glorpAssociation.	association isNil ifTrue: [^self].	association key: nil.	"This indicates that the key should not be reaped at this time."	self noWaitAdd: aTimedProxy] ensure: [mutex signal].</body></methods><methods><class-id>Glorp.TimedProxyReaper</class-id> <category>initializing</category><body package="GlorpCore">initialize	done := false.	self delay: 5. "seconds"	self maximumWork: 100. "milliseconds"	nextId := 1.	weakValueDictionary := Dialect weakValueDictionaryClass new.	weakValueDictionary manager: self.	"Note: The sort used by keysSortedByExpiryTime _must_ be stable."	keysSortedByExpiryTime := SortedCollection sortBlock: [:associationA :associationB | associationA value "timeToDie" &lt;= associationB value].	indexOffset := 0.	mutex := Semaphore forMutualExclusion.	self forkReaperThread</body><body package="GlorpCore">release	done := true.	maximumWork := 0.	reaperThread notNil ifTrue: [reaperThread terminate].	reaperThread := nil.</body></methods><methods><class-id>Glorp.TimedProxyReaper class</class-id> <category>As yet unclassified</category><body package="GlorpCore">delay: seconds	^self new delay: seconds</body><body package="GlorpCore">delay: seconds maximumWork: milliseconds	^self new delay: seconds; maximumWork: milliseconds</body><body package="GlorpCore">new	^super new initialize</body></methods><methods><class-id>Glorp.AdabasDPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Adabas'</body></methods><methods><class-id>Glorp.QueryDeleteCommand</class-id> <category>accessing</category><body package="GlorpDatabase">bindingTypes	^#().</body><body package="GlorpDatabase">bindings	^#().</body><body package="GlorpDatabase">expectedNumberOfModifiedRows	"For polymorphism with DeleteCommand;  return the same guestimated number as expectedRows in a standard Select command."	^100</body><body package="GlorpDatabase">printSQL	stream nextPutAll: 'DELETE '.	query printUnqualifiedTablesOn: self.	query printUnqualifiedWhereClauseOn: self.</body><body package="GlorpDatabase">query	^query</body><body package="GlorpDatabase">query: aSimpleQuery	query := aSimpleQuery</body><body package="GlorpDatabase">rowCount	^rowCount</body><body package="GlorpDatabase">rowCount: anInteger	rowCount := anInteger</body><body package="GlorpDatabase">useBinding	"For simplicity, we don't use binding.  If we did, we would need to compute #bindings and #bindingTypes - doable but, for the moment, we pass."	^false</body></methods><methods><class-id>Glorp.QueryDeleteCommand</class-id> <category>executing</category><body package="GlorpDatabase">executeUnboundIn: anAccessor	"We leave the rowCount nil if the platform does not support it, to make clear it's not a valid value."	anAccessor returnRowCount: true.	anAccessor		executeSQLStringNoResult: self sqlString		doing: [(anAccessor platform supportsRowCountFor: self)				ifTrue: [self rowCount: anAccessor rowCount]]		forCommand: self.	^#() readStream</body></methods><methods><class-id>Glorp.QueryDeleteCommand</class-id> <category>testing</category><body package="GlorpDatabase">isDeleteCommand	^true</body><body package="GlorpDatabase">needsRowCount	"Because I override #useBinding to return false, and #executeUnboundIn: to handle rowCount, this is never called.  It is left here to show up if searching for commands that get rowCount, and in case I ever allow binding.  I need rowCount solely to return it to callers of #delete:where: (at the moment, no known callers use this)."	^true</body></methods><methods><class-id>Glorp.QueryDeleteCommand</class-id> <category>reporting</category><body package="GlorpDatabase">tables	^(self query tablesToPrint collect: [:each | each parent]) asSet.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>private/mapping</category><body package="GlorpUnitOfWork">adjustForMementos: objects	^self.</body><body package="GlorpUnitOfWork">collectionMementoFor: aCollection	^aCollection.</body><body package="GlorpUnitOfWork">dictionaryClassRequiredForKey: anObject	^(self isRowMapKey: anObject)		ifTrue: [Dictionary]		ifFalse: [IdentityDictionary].</body><body package="GlorpUnitOfWork">reverseLookup: anObject	^anObject.</body><body package="GlorpUnitOfWork">rowsForKey: aKey	"Return a collection of all rows for any table which are keyed by aKey"	| rowsForKey |	rowsForKey := OrderedCollection new: 5.	rowDictionary		do:			[:each | 			| row |			row := each at: aKey ifAbsent: [nil].			(row notNil and: [(self isDeleted: row) not]) ifTrue: [rowsForKey add: row]].	^rowsForKey.</body><body package="GlorpUnitOfWork">subMapForTable: aTable		^self subMapForTable: aTable withKey: nil.</body><body package="GlorpUnitOfWork">subMapForTable: aTable ifAbsent: aBlock 	^rowDictionary at: aTable ifAbsent: aBlock</body><body package="GlorpUnitOfWork">subMapForTable: aTable withKey: anObject 	anObject isGlorpProxy ifTrue: [self halt].	^rowDictionary at: aTable		ifAbsentPut: [(self dictionaryClassRequiredForKey: anObject) new]</body><body package="GlorpUnitOfWork">tables	^rowDictionary keys.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>iterating</category><body package="GlorpUnitOfWork">keysAndValuesDo: aBlock 	self tables do: [:each | 		(self subMapForTable: each) keysAndValuesDo: aBlock].</body><body package="GlorpUnitOfWork">objects	| objects |	objects := IdentitySet new.	self tables do: [:each | objects addAll: (self subMapForTable: each) keys].	^objects</body><body package="GlorpUnitOfWork">objectsAndRowsDo: aTwoArgumentBlock	rowDictionary		do:			[:eachObjectToRowDictionary | 			eachObjectToRowDictionary				keysAndValuesDo:					[:key :value | 					(self isDeleted: value)						ifFalse: [aTwoArgumentBlock value: key value: value]]].</body><body package="GlorpUnitOfWork">objectsAndRowsForTable: aTable do: aTwoArgumentBlock	^(self subMapForTable: aTable)		keysAndValuesDo:			[:key :value | 			(self isDeleted: value)				ifFalse: [aTwoArgumentBlock value: key value: value]].</body><body package="GlorpUnitOfWork">objectsDo: aBlock	self tables		do:			[:each | 			(self subMapForTable: each)				keysAndValuesDo:					[:key :value | (self isDeleted: value) ifFalse: [aBlock value: key]]].</body><body package="GlorpUnitOfWork">rowsDo: aBlock 	self tables do: [:each | self rowsForTable: each do: aBlock]</body><body package="GlorpUnitOfWork">rowsForTable: aTable do: aBlock	^(self subMapForTable: aTable)		keysAndValuesDo:			[:key :value | (self isDeleted: value) ifFalse: [aBlock value: value]].</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>testing</category><body package="GlorpUnitOfWork">isEmpty	self compress.	self rowsDo: [:each | (self isDeleted: each) ifFalse: [^false]].	^true.</body><body package="GlorpUnitOfWork">notEmpty	^self isEmpty not</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>lookup</category><body package="GlorpUnitOfWork">addRow: aRow	^self addRow: aRow forTable: aRow table withKey: aRow owner.</body><body package="GlorpUnitOfWork">addRow: aRow forTable: aTable withKey: aKey 	| submap |	aKey isGlorpProxy ifTrue: [self halt].	submap := self subMapForTable: aTable withKey: aKey.	submap at: aKey put: aRow.	^aRow.</body><body package="GlorpUnitOfWork">deleteRowForTable: aTable withKey: aKey ifAbsent: aBlock	"Don't actually delete, the fixup of the hash tables is too expensive. Mark invisible instead, overloading the status variable that we know we're not using until later"	| row |	row := (self subMapForTable: aTable) at: aKey ifAbsent: aBlock.	row isNil ifFalse: [self privateDeleteRow: row].</body><body package="GlorpUnitOfWork">includesRowForTable: aTable withKey: aKey	| row |	row := (self subMapForTable: aTable ifAbsent: [^false]) at: aKey ifAbsent: [^false].	^(self isDeleted: row) not.</body><body package="GlorpUnitOfWork">rowForTable: aTable withKey: aKey 	^self rowForTable: aTable withKey: aKey ifAbsent: [self error: 'missing element'].</body><body package="GlorpUnitOfWork">rowForTable: aTable withKey: aKey ifAbsent: aBlock	| row |	row := (self subMapForTable: aTable) at: aKey ifAbsent: aBlock.	^(self isDeleted: row) ifTrue: [aBlock value] ifFalse: [row].</body><body package="GlorpUnitOfWork">rowForTable: aTable withKey: aKey ifPresent: aBlock	^(self subMapForTable: aTable)		at: aKey		ifPresent:			[:row | (self isDeleted: row) ifTrue: [nil] ifFalse: [aBlock value: row]].</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>set operations</category><body package="GlorpUnitOfWork">additiveDifferencesFrom: aRowMap into: differencesMap	"Add everything which is in us, but not in aRowMap into differencesMap"	| newRow |	self objectsAndRowsDo: [:object :row |		| correspondingRow |		correspondingRow := aRowMap			rowForTable: row table			withKey: object			ifAbsent: [DatabaseRow new].		(row equals: correspondingRow)			ifFalse:				[newRow := differencesMap					addRow: (row withAllFieldsIn: correspondingRow)					forTable: row table					withKey: object.				newRow forDeletion: row forDeletion]].</body><body package="GlorpUnitOfWork">differenceFrom: aMementoRowMap	| differencesMap |	differencesMap := RowMap new.	self additiveDifferencesFrom: aMementoRowMap into: differencesMap.	self subtractiveDifferencesFrom: aMementoRowMap into: differencesMap.	^differencesMap</body><body package="GlorpUnitOfWork">subtractiveDifferencesFrom: aRowMap into: differencesMap	"Figure out which things are in aRowMap but not in us. These should be flagged as delete rows. Since we have no further use for aRowMap after this, we can compute this destructively by removing everything that's in us"	self objectsAndRowsDo: [:object :row |		aRowMap			deleteRowForTable: row table			withKey: object			ifAbsent: []].	aRowMap		objectsAndRowsDo:			[:object :row | 			| adjustedObject |			adjustedObject := (aRowMap reverseLookup: object).			row forDeletion: true.			differencesMap				addRow: row				forTable: row table				withKey: adjustedObject].</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>api</category><body package="GlorpUnitOfWork">at: aField key: anObject put: aValue	(self findOrAddRowForTable: aField table withKey: anObject) at: aField put: aValue.</body><body package="GlorpUnitOfWork">findOrAddRowForTable: aTable withKey: aKey	| submap row |	submap := self subMapForTable: aTable withKey: aKey.	row := submap		at: aKey		ifAbsentPut: [DatabaseRow newForTable: aTable withOwner: aKey].	^(self isDeleted: row)		ifTrue:			[| newRow |			newRow := DatabaseRow newForTable: aTable withOwner: aKey.			submap at: aKey put: newRow.			newRow]		ifFalse: [row].</body><body package="GlorpUnitOfWork">isRowMapKey: anObject	^anObject class == RowMapKey or: [anObject class == MultipleRowMapKey].</body><body package="GlorpUnitOfWork">mementoFor: anObject	^anObject.</body><body package="GlorpUnitOfWork">unifyField: eachSourceField key: sourceObject withField: eachTargetField key: targetObject	| sourceRow targetRow |	sourceRow := self findOrAddRowForTable: eachSourceField table withKey: sourceObject.	targetRow := self findOrAddRowForTable: eachTargetField table withKey: targetObject.	sourceRow unifyField: eachSourceField withField: eachTargetField inRow: targetRow.</body><body package="GlorpUnitOfWork">unifyField: sourceField key: sourceObject withField: targetField key: targetObject transformationForward: forwardTransformation inverse: inverseTransformation	| sourceRow targetRow existingWrapper newWrapper |	sourceRow := self findOrAddRowForTable: sourceField table withKey: sourceObject.	targetRow := self findOrAddRowForTable: targetField table withKey: targetObject.	sourceRow unifyField: sourceField withField: targetField inRow: targetRow.	existingWrapper := targetRow wrapperAt: targetField.	(existingWrapper class == TransformingFieldValueWrapper and: [		existingWrapper forwardTransformation == forwardTransformation and: [			existingWrapper inverseTransformation == inverseTransformation]])				ifTrue: [^self].	newWrapper := (TransformingFieldValueWrapper new)		innerWrapper: existingWrapper;		forwardTransformation: forwardTransformation;		inverseTransformation: inverseTransformation.	targetRow wrapperAt: targetField put: newWrapper.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>initialize/release</category><body package="GlorpUnitOfWork">initialize      self initialize: 17</body><body package="GlorpUnitOfWork">initialize: size	rowDictionary := IdentityDictionary new: size.	hasDeletions := false.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>counting</category><body package="GlorpUnitOfWork">numberOfEntries	self compress.	^rowDictionary inject: 0 into: [:sum :each | sum + each size]</body><body package="GlorpUnitOfWork">numberOfEntriesForTable: aTable	self compress.	^(self subMapForTable: aTable) size.</body></methods><methods><class-id>Glorp.RowMap</class-id> <category>private/deletion</category><body package="GlorpUnitOfWork">collapseMatchingInsertsAndDeletes	^rowDictionary		inject: IdentitySet new		into:			[:sum :eachTablesRowList | 			sum addAll: (self collapseMatchingInsertsAndDeletesFor: eachTablesRowList).			sum].</body><body package="GlorpUnitOfWork">collapseMatchingInsertsAndDeletesFor: eachTablesRows	"Find any inserts and deletes for these rows which have the same primary key.  (Typically, these are link table rows, because for rows that map to objects, Glorp-managed object identity ensures this only ever happens by user intent:  a user can explicitly delete an object and add another, giving it the same key, in the same transaction.)  Force the insert to be an update instead (by returning it to the calling method, which will force that to happen) and remove the deletion."	| deletions updates matchedDeletions deletion |	(self isSuitableForCollapsing: eachTablesRows) ifFalse: [^#()].	deletions := Dictionary new: 50.	updates := OrderedCollection new.	eachTablesRows do: [:each | each forDeletion ifTrue:		[deletions at: each primaryKey put: each]].	deletions isEmpty ifTrue: [^#()].	matchedDeletions := IdentitySet new: deletions size.	eachTablesRows do:		[:each || pk | pk := each primaryKey.		((deletions includesKey: pk) and: [each forDeletion not]) ifTrue:			[deletion := deletions at: pk.			(matchedDeletions includes: deletion) ifFalse:				["If we trusted the user always to delete the right object, or one with no field values accidentally matching a changed new row value, then we could do				each withAllFieldsIn: deletion. then add				each fieldsNeedingUpdate isEmpty or:to the no-op check following.  Lacking this certainty, we do not set the deletion row to be the oldVersion of the 'each' row, thus ensuring the update command will update all the non-primaryKey fields whether they differ between deletion and each or not."				each table primaryKeyFields size = each fields size ifTrue:					["Now here's a very special case.  If there are no non-primary key fields, then we collapse this down to a no-op. We've deleted and re-inserted with exactly the same information.  However, we still leave it in the list of updated rows, because we want it to be put into the session cache if it's not already there at the end."					self privateDeleteRow: each].				"Make the row an update, with the deletion as its old value."				updates add: each.				matchedDeletions add: deletion.				self privateDeleteRow: deletion]]].	^updates</body><body package="GlorpUnitOfWork">compress	"Remove all deleted rows and rebuild"	| newDictionary |	hasDeletions ifFalse: [^self].	hasDeletions := false.	newDictionary := IdentityDictionary new: rowDictionary size.	rowDictionary keysAndValuesDo: [:eachTable :eachRowDict |		| newRowDict |		newRowDict := IdentityDictionary new: eachRowDict size.		eachRowDict keysAndValuesDo: [:eachObject :eachRow |			(self isDeleted: eachRow) ifFalse: [				newRowDict at: eachObject put: eachRow]].		newDictionary at: eachTable put: newRowDict].	rowDictionary := newDictionary.</body><body package="GlorpUnitOfWork">isDeleted: row	^row status == #invisible.</body><body package="GlorpUnitOfWork">isSuitableForCollapsing: eachTablesRows	"Return true if this set of rows are suitable for collapsing the inserts and deletes together. It's suitable if this is a link table, and if there is a primary key defined which we can use to decide if the rows match or not"	eachTablesRows isEmpty ifTrue: [^false].	eachTablesRows		keysAndValuesDo:			[:eachKey :eachRow | 				"(self isRowMapKey: eachKey) ifFalse: [^false]."				eachRow table primaryKeyFields isEmpty ifTrue: [^false].				^true ].</body><body package="GlorpUnitOfWork">privateDeleteRow: row	row status: #invisible.	hasDeletions := true.</body></methods><methods><class-id>Glorp.RowMap class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork">forRows: aCollection	"Convenience - construct a row map from a given set of rows"	| map |	map := self new.	aCollection do: [:each | map addRow: each].	^map.</body><body package="GlorpUnitOfWork">new	^super new initialize.</body><body package="GlorpUnitOfWork">new: size	^super new initialize: size.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>accessing</category><body package="GlorpMappings">basicReferenceDescriptor	^self system descriptorFor: self basicReferenceClass.</body><body package="GlorpMappings">field	^self valueField.</body><body package="GlorpMappings">keyField	^keyMapping field.</body><body package="GlorpMappings">keyField: aDatabaseField	keyMapping := self newMapping: DirectMapping.	keyMapping attributeName: #key.	keyMapping from: #key to: aDatabaseField.</body><body package="GlorpMappings">keyMapping	^keyMapping</body><body package="GlorpMappings">keyMapping: aMapping	keyMapping := aMapping</body><body package="GlorpMappings">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	| fields |	fields := super mappedFields copy.	fields addAll: keyMapping mappedFields.	valueMapping isNil ifFalse: [		fields addAll: valueMapping mappedFields].	^fields.</body><body package="GlorpMappings">name	"This can get called when we're masquerading as a class, for purposes of indexing descriptors, so just print something useful."	^self printString</body><body package="GlorpMappings">referenceClass	"Return ourselves as the reference class, as a sort of a proxy for what we really want, which is a primitive, and varies according to the relationship anyway. Note that we have stuffed in a descriptor in the system, with ourselves (this instance) as the class.""	^self mapsSimpleObject ifTrue: [self] ifFalse: [super referenceClass]."	^self.</body><body package="GlorpMappings">referenceDescriptor	| ref |	ref := super referenceDescriptor.	^ref isNil 		ifTrue: [			"This means we haven't yet added our fake descriptor, and are in initialization, so just return the descriptor for the 'real' reference class"			self system descriptorFor: self basicReferenceClass]		ifFalse: [ref].</body><body package="GlorpMappings">valueField	^valueMapping field.</body><body package="GlorpMappings">valueField: aDatabaseField	| mapping |	mapping := self newMapping: DirectMapping.	mapping attributeName: #value.	mapping from: #value to: aDatabaseField.	self valueMapping: mapping.</body><body package="GlorpMappings">valueMapping	^valueMapping.</body><body package="GlorpMappings">valueMapping: aMapping	valueMapping := aMapping.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>mapping</category><body package="GlorpMappings">associationClassModel	| model |	model := GlorpClassModel for: Association.	model newAttributeNamed: #key.	model newAttributeNamed: #value.	^model.</body><body package="GlorpMappings">associationDescriptor	associationDescriptor isNil ifTrue: [		associationDescriptor := Descriptor new.		associationDescriptor system: self system.		associationDescriptor classModel: self associationClassModel.		associationDescriptor classModel system: self system].	^associationDescriptor.</body><body package="GlorpMappings">buildQuery	"I used to set the 'query' instVar in the first line, after which I set the temp 'keyExpression' in the second line by calling my sibling method #keyExpression, which checked that 'query' was not nil and returned its baseExpression (see that method's comment).  This behaviour is now inlined into me, which lets me delegate setting 'query' to my caller."	| builtQuery keyExpression valueExpression refDescKeyMapping notAddedByKeyMapping |	builtQuery := super buildQuery.	"next line is inlined from #keyExpression in the case query is not nil"	keyExpression := builtQuery baseExpression getMapping: self keyMapping named: #key.	valueExpression := self valueExpression.	builtQuery retrieveDictionaryWithKey: keyExpression value: valueExpression.	"Do we have enough information from the value mapping to get rows from which extracting the key merely requires adding to the list of fields selected from the existing tables (if that)? ..."	self keyMapping controlsTables ifFalse: [^builtQuery].	"a direct mapping will not control tables"	(self descriptor tables includes: self keyMapping mappedFields first table)		ifTrue: [^builtQuery].	(self usesLinkTable and: [self join allTables includes: self keyMapping mappedFields first table])		 ifTrue: [^builtQuery].	"... If we get here, the answer is no:  the user has defined a keyMapping that controls tables, i.e. they don't think the overall descriptor already controls all necessary tables (or they forgot to change the value from true - its default - to for-this-case false).  Our key mapping is acting like a second link table:  it must have a join from the key (which is otherwise outside the zone of this descriptor) to the value.  As the keyMapping's join is from the key to the value, we do not need to reverse it (i.e. as is done in expressionFromLinkToReferenceTableWithBase which otherwise guided the code below).  Trivially, we initialize to non-nil (empty) all existing experessions' tableAliases, so we can see which ones are still nil after we extend the where clause, and so are the ones added by the key mapping.  We share aliases from the key mapping to all such added expressions, so ensuring the key part of the expression will sync with the main query's value part of the expression."	notAddedByKeyMapping := builtQuery baseExpression mappingExpressions values.	"values makes a copy - we must copy"	"An alternative to the ANDs below could be to AND		(self referenceDescriptor mappingForAttributeNamed: #key) buildQuery whereClause	along with replacing the parameter element in the above whereClause with the main query's join element(s) for the value's primaryKey."	refDescKeyMapping := self referenceDescriptor mappingForAttributeNamed: #key.	builtQuery AND:		(refDescKeyMapping join asGlorpExpressionOn: builtQuery baseExpression) asGeneralGlorpExpressionWithFields.	refDescKeyMapping usesLinkTable ifTrue:		[builtQuery AND:			(refDescKeyMapping expressionFromLinkToReferenceTableWithBase: builtQuery baseExpression)].	"Initialize the the keyExpression table alias dictionary, then initialize the expressions it added to use the same instance."	keyExpression tableAliases isNil ifTrue:		[keyExpression privateTableAliases: (IdentityDictionary new: 3)].	builtQuery baseExpression mappingExpressions do:		[:each |		(notAddedByKeyMapping includes: each) ifFalse:			[each privateTableAliases: keyExpression tableAliases]].	^builtQuery</body><body package="GlorpMappings">buildRowMapKeyForSource: source target: target index: index	^self mapsSimpleObject 		ifTrue: [			MultipleRowMapKey				with: target yourSelf				with: source yourSelf				with: index]		ifFalse: [super buildRowMapKeyForSource: source target: target index: index].</body><body package="GlorpMappings">chooseBaseForMapping: aMapping from: base and: phantomExpression	aMapping isNil ifTrue: [^base].	^(aMapping mappedFields		allSatisfy: [:each | base tables includes: each table])		ifTrue: [base]		ifFalse: [phantomExpression].</body><body package="GlorpMappings">keyExpression	"Return the expression to use for our key. In a prior version, the key could be built only using data from either the target object, or from the link table, so we built a fresh expression on one or the other, as appropriate, ignoring the fact that the base expression (for the association descriptor) already had a key mapping.  In this version, we get it from the base expression, since the mapping may be to a third table that joins to the value table.  For hierarchy/type resolver situations (the outer ifTrue: branch), we continue to use the old code."		^(query isNil	"former caller #buildQuery must take the ifFalse: branch, so inlines it"		ifFalse: [query baseExpression]	"base(associationDescriptor) already has the mapping"		ifTrue:						"see call of #setGeneralQueryRetrievalIn:basedOn:phantom:"			[| base | base := BaseExpression new.			(self descriptor tables includes: self keyMapping mappedFields first table)				ifTrue: [base] 				ifFalse: [base getTable: keyMapping mappedFields first table]])		getMapping: self keyMapping named: #key</body><body package="GlorpMappings">newMapping: aMappingClass	"Implement this so that we can create our sub-mappings without having them added to the parent descriptor as independent mappings"	| mapping |	mapping := aMappingClass new.	mapping descriptor: self associationDescriptor.	descriptor resetMappedFields.	^mapping.</body><body package="GlorpMappings">pseudoDescriptor	"Return a pretend descriptor for our reference class. Since that class is a primitive, it won't have a real descriptor, and it may vary by usage anyway"	| pseudoDescriptor |	pseudoDescriptor := Descriptor new.	pseudoDescriptor system: descriptor system.	^pseudoDescriptor.</body><body package="GlorpMappings">setGeneralQueryRetrievalIn: newQuery basedOn: base phantom: phantomExpression	| keyExpression valueExpression collType keyExpressionBase valueExpressionBase |	self descriptor primaryKeyMappings		do:			[:eachMapping | newQuery retrieve: (phantomExpression get: eachMapping attributeName)].	keyExpressionBase := self		chooseBaseForMapping: keyMapping		from: base		and: phantomExpression.	keyExpression := self keyExpression asGlorpExpressionOn: keyExpressionBase.	valueExpressionBase := self		chooseBaseForMapping: valueMapping		from: base		and: phantomExpression.	valueExpression := self valueExpression		asGlorpExpressionOn: valueExpressionBase.	collType := (GlorpDictionaryDescription new)		keyExpression: keyExpression;		valueExpression: valueExpression.	newQuery collectionType: collType.	newQuery retrieve: base.</body><body package="GlorpMappings">valueExpression	 | base intermediate |	valueMapping isNil ifTrue: [ ^[:each | each value] ].	base := BaseExpression new.	intermediate := (self descriptor tables includes: valueMapping mappedFields first table)		ifTrue: [base] 		ifFalse: [base getTable: valueMapping mappedFields first table].	^intermediate getMapping: valueMapping named: #value.</body><body package="GlorpMappings">writeExtraInformationInto: aRowMap atKey: rowMapKey forSourceObject: sourceObject targetObject: targetObject atIndex: eachKey	"A dictionary association has an owner (the sourceObject) plus a key (the eachKey parameter, sometimes called the index) one-one-related to a value (the targetObject).  The owner and value have already been mapped to rows by the time we get here.  For the key, write out any additional information that goes in the value's link table or else the target table, or in other key-specific table(s) and linkTable(s), if necessary. If we have a specific value mapping, rather than just using the normal attributes of this mapping, then write any necessary information for it as well (usually, we only have a value mapping when our value is simple).	* If the key mapping is in the scope of the value mapping (i.e. we're just putting into a dictionary some data we already have from the owner, link and value tables) then the key mapping writes to the link table or to the (value's) target table(s).		- If it writes to the link table, then myTarget within this method is the row map key (as usual - rowMapKeys are used to target rows for linkTables).  If it does not, but the value is simple, we still use the rowMapKey.		- If the value is mapped to table(s) then the key is either mapped to one or more of them, in which case the value is myTarget within this method, or it isn't (rowMapConstructorBlock being used?).	* If the key mapping is outside the scope of owner, link and value, then it may write to entirely separate table(s) joined from the value.  In that case, the value is mySource and the key is myTarget."	| myTarget mySource |	keyMapping controlsTables		ifFalse:	"key is in scope of existing owner -&gt; dict -&gt; value tables and link table"			[mySource := eachKey -&gt; nil.			myTarget := (keyMapping mappedTables includes: self linkTable)	"the key is mapped to the link table"				ifTrue: [rowMapKey]				ifFalse: [self mapsSimpleObject		"the key is mapped to the value"						ifTrue: [rowMapKey]			" - which is simple, no table(s)"						ifFalse:					" - which has table(s) ..."							[(keyMapping mappedTables anySatisfy: [:each | self targetTables includes: each])								ifTrue: [targetObject]	"... to which the key is mapped"								ifFalse: [eachKey]]]]		"... but the key is not mapped to them (key is computed in rowMapKeyConstructorBlock?)"		ifTrue:	"the key is mapped to table(s) beyond the scope of the non-key part of this mapping"			[mySource := targetObject.	"the value is the source of the key mapping"			myTarget := eachKey].		"the key is the target of the mapping"	keyMapping		mapFromObject: mySource		toTarget: myTarget		puttingRowsIn: aRowMap.	valueMapping isNil ifTrue: [^self].	"I'm not sure this will ever be relevant.  If the value mapping goes to the link table, then does that mean the key is really the value?  And if so, why not just consider the other one to be the link?  If we do get here, be aware myTarget is now my value mapping's target whereas above it was my key mapping's target."	myTarget := (valueMapping mappedTables includes: self linkTable)		ifTrue: [rowMapKey]		ifFalse: [self mapsSimpleObject ifTrue: [rowMapKey] ifFalse: [targetObject]].	valueMapping		mapFromObject: nil -&gt; targetObject		toTarget: myTarget		puttingRowsIn: aRowMap.</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>testing</category><body package="GlorpMappings">glorpCanHaveDescriptorDirectly	"We allow instances of ourselves to have a descriptor, which normally only classes can do. This is so that we can have multiple different descriptors in use for e.g. String, depending on the particular usage.""	^self mapsSimpleObject."	^true.</body><body package="GlorpMappings">mapsSimpleObject	^valueMapping notNil and: [valueMapping mapsSimpleObject].</body><body package="GlorpMappings">needsSpecialRowMapKey	^super needsSpecialRowMapKey or: [		self mapsSimpleObject].</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>initializing</category><body package="GlorpMappings">defaultCollectionType	^Dictionary.</body><body package="GlorpMappings">initialize	super initialize.	usesLinkTable := true.</body><body package="GlorpMappings">initializeKeyMappingJoin	self keyMapping mapsSimpleObject		ifTrue: [self referenceDescriptor directMapping				from: #key to: self keyField]		ifFalse: [self referenceDescriptor oneToOneMapping				attributeName: #key;					linkFields: self keyMapping linkFields;				usesLinkTable: self keyMapping usesLinkTable;				join: self keyMapping join;				controlsTables: self keyMapping controlsTables].</body><body package="GlorpMappings">initializeValueMapping	| referenceDescriptor |	self descriptor system privateAndBasicAddDescriptorFor: self as: self associationDescriptor.	(self associationDescriptor classModel attributeNamed: #key) type: self attribute keyType.	(self associationDescriptor classModel attributeNamed: #value) type: self attribute type.	referenceDescriptor := self referenceDescriptor.	(referenceDescriptor isNil or: [referenceDescriptor tables isEmpty]) ifTrue:		[self initializeValueMappingJoin.		self initializeKeyMappingJoin].</body><body package="GlorpMappings">initializeValueMappingJoin	| tables |	"We don't know which of these will come first in the descriptor, so call the other initialization if it looks like we have enough information, and it hasn't been done"	self referenceDescriptor isNil ifTrue: [self initializeValueMapping].	"Have we already done this?"	self referenceDescriptor tables isEmpty ifFalse: [^self].	tables := self targetTables asArray.	tables do: [:each | self referenceDescriptor addTable: each].	self mapsSimpleObject		ifTrue: [self referenceDescriptor directMapping				from: #value to: self valueField]		ifFalse: [self referenceDescriptor oneToOneMapping				attributeName: #value;				linkFields: self linkFields;				usesLinkTable: self usesLinkTable;				join: self join;				controlsTables: false].</body></methods><methods><class-id>Glorp.DictionaryMapping</class-id> <category>validation</category><body package="GlorpMappings">initializeRuntimeMappings	super initializeRuntimeMappings.	self initializeValueMapping.</body><body package="GlorpMappings">validate	self initializeValueMapping.	super validate.	self attribute isDictionaryAttribute		ifFalse: [self error: 'Dictionary Mapping that does not have a dictionary type in the attribute'].	"The reason you can't do this, is that we end up throwing away the primary key of the target table when we read in the objects, and we have no way to properly do deletes/updates without that information"	(self usesLinkTable and: [self mapsSimpleObject]) ifTrue: [self error: 'Dictionary mappings to simple objects cannot use a link table'].</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>conversion-times</category><body package="GlorpDatabaseTypes">converterForStType: aClass	^self platform converterNamed: #time.</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">print: aValue on: aStream	aStream nextPutAll: (self platform printTime: aValue for: self).</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Time.</body></methods><methods><class-id>Glorp.GlorpTimeType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Time.</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>testing</category><body package="GlorpMappings">controlsTables	^false</body><body package="GlorpMappings">hasImpliedClauses	"We may imply more than one clause, or a clause which is different from the one directly implied by the relationship"	^true</body><body package="GlorpMappings">isRelationship	"True when the mapping associates different persistent classes."	^false</body><body package="GlorpMappings">isStoredInSameTable	^true.</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>printing SQL</category><body package="GlorpMappings">allRelationsFor: rootExpression	"We may have multiple relationships."	| tables rows result rightChild rightHandSide |	tables := self mappedTables.	rows := Dictionary new.	tables do: [:each | rows at: each put: (DatabaseRow newForTable: each)].	rightChild := rootExpression rightChild.	rightHandSide := rightChild isConstantExpression ifTrue: [rightChild value] ifFalse: [rightChild].	toDbMappingBlock value: rows value: rightHandSide value: Dictionary new. 	result := nil.	rows do: [:eachRow |		| table |		table := rootExpression leftChild base getTable: eachRow table.		eachRow fieldsAndValidValuesDo: [:eachField :eachValue |  | newExp |			newExp := (table getField: eachField) get: rootExpression relation withArguments: (Array with: eachValue).			result := newExp AND: result.]].	^result.</body><body package="GlorpMappings">convertedDbValueOf: anObject	| tables rows |	tables := self mappedTables.	rows := Dictionary new.	tables do: [:each | rows at: each put: (DatabaseRow newForTable: each)].	toDbMappingBlock value: rows value: anObject.	rows keysAndValuesDo: [:eachTable :eachRow |		^eachRow at: mappedFields first].</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>mapping</category><body package="GlorpMappings">field	| fields |	fields := self mappedFields.	fields size = 1 ifFalse: [self error: 'This mapping does not correspond to exactly one field'].	^fields first.</body><body package="GlorpMappings">mappedFields	^mappedFields.</body><body package="GlorpMappings">referencedIndependentObjectsFrom: anObject	"Assumes that the only object this might affect is our primary attribute. That's probably valid. I think."	| object otherDescriptor |	object := self getValueFrom: anObject.	(object isGlorpProxy and: [object isInstantiated not]) ifTrue: [^#()].	otherDescriptor := self system descriptorFor: object.	^otherDescriptor isNil ifTrue: [#()] ifFalse: [Array with: object].</body><body package="GlorpMappings">trace: aTracing context: anExpression	^self.</body><body package="GlorpMappings">valueIn: anElementBuilder as: anExpression	^fromDbMappingBlock		value: anElementBuilder row		value: anElementBuilder		value: anExpression.</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>public</category><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap	| target sourceRows targetRows valueDescriptor |	self canWrite ifFalse: [^self].	target := self getValueFrom: anObject.	target := self session realObjectFor: target.	target := aRowMap mementoFor: target.	sourceRows := Dictionary new: 3.	targetRows := Dictionary new: 3.	descriptor tables do: [:each |		sourceRows at: each put: (aRowMap findOrAddRowForTable: each withKey: anObject)].	valueDescriptor := self system descriptorFor: target.	valueDescriptor isNil ifFalse: [		valueDescriptor tables do: [:each |			targetRows at: each put: (aRowMap findOrAddRowForTable: each withKey: target)]].	toDbMappingBlock value: sourceRows value: target value: targetRows.</body><body package="GlorpMappings">mapObject: anObject inElementBuilder: anElementBuilder	"Because anElementBuilder could be assigned another row between the setting of my proxy's block and the evaluation of that block, we extract the row here and pass it into the block separately, even though anElementBuilder (which we also pass in) knows the row at the moment.  Code in the fromDbMappingBlock may find it prudent to call protocol that uses the supplied row instead of obtaining it from anElementBuilder - see #descriptorForGlorpTransformedTime: and #testReadAdHocProxied for an example.  (Of course, if we are not proxying, it makes no difference.)"	| row |	row := anElementBuilder row.	self setValueIn: anObject to:		(self shouldProxy			ifFalse: [fromDbMappingBlock value: row value: anElementBuilder value: BaseExpression new]			ifTrue: [AdHocProxy readBlock: [fromDbMappingBlock value: row value: anElementBuilder value: BaseExpression new]])</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>accessing</category><body package="GlorpMappings">shouldProxy	^shouldProxy.</body><body package="GlorpMappings">shouldProxy: aBoolean	shouldProxy := aBoolean.</body></methods><methods><class-id>Glorp.AdHocMapping</class-id> <category>initialize-release</category><body package="GlorpMappings">forAttribute: aSymbol fromDb: fromBlock toDb: toBlock mappingFields: aFieldCollection	self		setAttribute: aSymbol		fromDb: fromBlock		toDb: toBlock		mappingFields: aFieldCollection.</body><body package="GlorpMappings">initialize	"Proxying requires the user to think about any possible state changes in the element builder or context between the creation and the evaluation of the AdHocProxy block."	super initialize.	self shouldProxy: false.</body><body package="GlorpMappings">setAttribute: aSymbol fromDb: fromBlock toDb: toBlock mappingFields: aFieldCollection 	self attributeName: aSymbol.	fromDbMappingBlock := fromBlock.	toDbMappingBlock := toBlock.	mappedFields := aFieldCollection.</body></methods><methods><class-id>Glorp.AdHocMapping class</class-id> <category>instance creation</category><body package="GlorpMappings">forAttribute: aSymbol fromDb: fromBlock toDb: toBlock mappingFields: aFieldCollection 	^super new 		setAttribute: aSymbol		fromDb: fromBlock		toDb: toBlock		mappingFields: aFieldCollection</body></methods><methods><class-id>Glorp.NoTableFound</class-id> <category>printing</category><body package="GlorpMisc">printOn: aStream	aStream nextPutAll: self messageText</body></methods><methods><class-id>Glorp.NoTableFound</class-id> <category>accessing</category><body package="GlorpMisc">expectedTables	^expectedTables</body><body package="GlorpMisc">expectedTables: aCollection	expectedTables := aCollection</body><body package="GlorpMisc">messageText	messageText ifNotNil: [^messageText].	self model isString ifTrue: [^'No table &lt;1s&gt; found' expandMacrosWith: self model].	^'No table found for &lt;1s&gt;, expected to see one of  &lt;2s&gt;' expandMacrosWith: self model name with: self expectedTables printString</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>mapping</category><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap</body><body package="GlorpMappings">mapObject: anObject inElementBuilder: anElementBuilder	| value |	value := anElementBuilder isNil		ifTrue: [constantValue]		ifFalse: [self constantValueIn: anElementBuilder session].	self setValueIn: anObject to: value.</body><body package="GlorpMappings">referencedIndependentObjectsFrom: anObject	^#().</body><body package="GlorpMappings">trace: aTracing context: anExpression	^self.</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>accessing</category><body package="GlorpMappings">constantValue	^constantValue.</body><body package="GlorpMappings">constantValue: anObject	constantValue := anObject.</body><body package="GlorpMappings">constantValueIn: aSession	^valueIsSession		ifTrue: [aSession]		ifFalse: [constantValue].</body><body package="GlorpMappings">constantValueIsSession	valueIsSession := true.</body><body package="GlorpMappings">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	^#().</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>testing</category><body package="GlorpMappings">controlsTables	"Return true if this type of method 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	^false</body><body package="GlorpMappings">hasValueThatCanProvideField: aField from: anObject	"A constant mapping cannot provide a field value since it knows its attribute but not its field."	^false</body><body package="GlorpMappings">isRelationship	^false</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>api</category><body package="GlorpMappings">getValueFrom: anObject	^constantValue.</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>initialize/release</category><body package="GlorpMappings">initialize	super initialize.	valueIsSession := false.</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>validation</category><body package="GlorpMappings">validateAttribute	^self.</body></methods><methods><class-id>Glorp.TableBasedSequence</class-id> <category>accessing</category><body package="GlorpDatabase">sequenceTableName	"Private - Answer the value of the receiver's ''sequenceTableName'' instance variable."	^sequenceTableName</body><body package="GlorpDatabase">sequenceTableName: aString	sequenceTableName := aString</body></methods><methods><class-id>Glorp.TableBasedSequence</class-id> <category>testing</category><body package="GlorpDatabase">isIdentityColumn	^true.</body></methods><methods><class-id>Glorp.TableBasedSequence class</class-id> <category>defaults</category><body package="GlorpDatabase">default	^self new sequenceTableName: 'SEQUENCE'.</body></methods><methods><class-id>Glorp.ManyToManyMapping</class-id> <category>initializing</category><body package="GlorpMappings">initialize	super initialize.	usesLinkTable := true.</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion.	With Boolean, some platforms implement a Boolean column type (e.g. Postgres), or an acceptable equivalent (e.g. SQLServer provides Bit, requiring integer conversion). MySQLEXDI maps booleans to integers on writing but not on reading (MySQL has no boolean type so the EXDI can only see the column is an int8 when reading).  DB2 and Oracle have no.boolean type and their EXDIs do not support it."	^self platform exdiTypeForBoolean</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">converterForStType: aClass	(aClass includesBehavior: Boolean) ifTrue: [^self platform converterNamed: #booleanToBoolean].	^self platform nullConverter.</body><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Boolean.</body></methods><methods><class-id>Glorp.GlorpBooleanType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">print: aValue on: aStream	aStream nextPutAll: (self platform printBoolean: aValue for: self).</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>executing</category><body package="GlorpDatabase">basicExecuteSQLString: aString	| result cursor records |	result := connection execSql: aString.	records := result records.	"Fix up nulls"	records do: [:each |		1 to: each size do: [:i |			(each at: i) == #'(NULL)' ifTrue: [each at: i put: nil]]].	cursor := self cursorFor: (ReadStream on: result records).	cursor statement: result.	^cursor.</body><body package="GlorpDatabase">basicExecuteSQLString: aString bindingArray: aBindingArray	" *** This method was defined by Glorp.DatabaseAccessor as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body><body package="GlorpDatabase">basicExecuteSQLString: aString returnResult: returnResult binding: aBindingArray doing: aBlock	^connection execSql: aString.</body><body package="GlorpDatabase">externalDatabaseErrorSignal	^Error.</body><body package="GlorpDatabase">isInTransaction	^inTransaction.</body><body package="GlorpDatabase">releaseCursor: aCursor in: aPreparedStatement</body><body package="GlorpDatabase">rowCount	^connection rowsProcessed.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>login</category><body package="GlorpDatabase">isLoggedIn	connection isNil ifTrue: [^false].	^connection isActive</body><body package="GlorpDatabase">loginIfError: aBlock	| |"	connection :=self connectionClass 		name: currentLogin connectString		alias: currentLogin connectString		password: currentLogin password		drive: 'c'		comment: currentLogin connectString		create: false."	connection := self connectionClass		logOnServer: currentLogin connectString		 user: currentLogin username		 password: currentLogin password		 alias: currentLogin connectString.	(connection isKindOf: Message)		ifTrue: [^self errorBoxMessage: connection asString].	connection start.</body><body package="GlorpDatabase">logout	connection class logOff.</body><body package="GlorpDatabase">rollbackTransaction	inTransaction := false.	^connection rollback.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>transactions</category><body package="GlorpDatabase">beginTransaction	inTransaction := true.	^connection beginTran.</body><body package="GlorpDatabase">commitTransaction	inTransaction := false.	^connection commit.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>accessing</category><body package="GlorpDatabase">connectionClassForLogin: aLogin	aLogin database class == OraclePlatform		ifTrue: [^Smalltalk at: #OracleOCIDatabase ifAbsent: [self error: 'no such driver']].	aLogin database isODBCPlatform ifTrue: [^Smalltalk at: #ODBCDatabase].	self error: 'Unknown database: ' , aLogin database name.</body></methods><methods><class-id>Glorp.ObjectStudioDatabaseAccessor</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	inTransaction := false.</body><body package="GlorpDatabase">showDialog: aString	" *** This method was defined by Glorp.DatabaseAccessor as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Glorp.TimedProxy</class-id> <category>accessing</category><body package="GlorpQueries">class	^TimedProxy.</body><body package="GlorpQueries">doesNotUnderstand: aMessage	self glorpTouch.	^super doesNotUnderstand: aMessage</body><body package="GlorpQueries">glorpAssociation	^association</body><body package="GlorpQueries">glorpAssociation: anAssociation	association := anAssociation</body><body package="GlorpQueries">glorpId	^id</body><body package="GlorpQueries">glorpId: uniqueInteger	id := uniqueInteger</body><body package="GlorpQueries">glorpReaper: aTimedProxyReaper	reaper := aTimedProxyReaper</body><body package="GlorpQueries">glorpSecondsToLive	"Answer the number of seconds the receiver should live after having been instantiated or sent a message."	^secondsToLive</body><body package="GlorpQueries">glorpSecondsToLive: seconds	secondsToLive := seconds.	self updateExpiryTime.	reaper notNil ifTrue: [self glorpTouch]</body><body package="GlorpQueries">glorpTimeToDie	"Answer the time at which the receiver is scheduled to die."	^timeToDie</body><body package="GlorpQueries">glorpTouch	self updateExpiryTime.	reaper isNil ifFalse: [reaper touch: self].</body><body package="GlorpQueries">proxyInitialize	super proxyInitialize.	secondsToLive := 30.	self updateExpiryTime.</body><body package="GlorpQueries">uninstantiate	super uninstantiate.	association := nil.</body><body package="GlorpQueries">updateExpiryTime	timeToDie := Time millisecondClockValue + (secondsToLive * 1000).</body></methods><methods><class-id>Glorp.RowMapForMementos</class-id> <category>private/mapping</category><body package="GlorpUnitOfWork">collectionMementoFor: aCollection	aCollection glorpIsCollection ifFalse: [^aCollection].	^collectionMementos at: aCollection ifAbsent: [correspondenceMap at: aCollection].</body><body package="GlorpUnitOfWork">originalObjectFor: anObject	^correspondenceMap at: anObject.</body><body package="GlorpUnitOfWork">reverseLookup: anObject      (self isRowMapKey: anObject) ifTrue: [            ^anObject reverseAdjustIn: self].      ^ self reversedCorrespondenceMap at: anObject.</body></methods><methods><class-id>Glorp.RowMapForMementos</class-id> <category>accessing</category><body package="GlorpUnitOfWork">collectionMementos: aDictionary	collectionMementos := aDictionary.</body><body package="GlorpUnitOfWork">correspondenceMap	^correspondenceMap</body><body package="GlorpUnitOfWork">correspondenceMap: anObject	correspondenceMap := anObject</body></methods><methods><class-id>Glorp.RowMapForMementos</class-id> <category>api</category><body package="GlorpUnitOfWork">adjustForMementos: objects	"We may be being passed row map keys that refer to originals when they should refer to mementos. Fix.This is horribly ugly."	1 to: objects size do: [:i | | possibleRowMapKey |		possibleRowMapKey := objects at: i.		(self isRowMapKey: possibleRowMapKey) ifTrue: [			objects at: i put: (possibleRowMapKey adjustIn: correspondenceMap)]].	^objects.</body><body package="GlorpUnitOfWork">deleteRowForTable: aTable withKey: aKey ifAbsent: aBlock	^super deleteRowForTable: aTable withKey: (self mementoFor: aKey) ifAbsent: aBlock.</body><body package="GlorpUnitOfWork">findOrAddRowForTable: aTable withKey: aKey 	^super findOrAddRowForTable: aTable withKey: (self mementoFor: aKey).</body><body package="GlorpUnitOfWork">mementoFor: aKey	^(self isRowMapKey: aKey)		ifTrue: [aKey adjustIn: correspondenceMap]		ifFalse: [correspondenceMap at: aKey ifAbsent: [aKey]].</body><body package="GlorpUnitOfWork">reversedCorrespondenceMap	(reversedCorrespondenceMap isNil		or: [reversedCorrespondenceMap size ~= correspondenceMap size])		ifTrue:			[reversedCorrespondenceMap := IdentityDictionary				new: correspondenceMap size.			correspondenceMap				keysAndValuesDo: [:k :v | reversedCorrespondenceMap at: v put: k]].	^reversedCorrespondenceMap.</body><body package="GlorpUnitOfWork">rowForTable: aTable withKey: aKey ifAbsent: aBlock	^super		rowForTable: aTable		withKey: (self mementoFor: aKey)		ifAbsent: aBlock.</body></methods><methods><class-id>Glorp.RowMapForMementos class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork">withCorrespondenceMap: aDictionary	^self new		correspondenceMap: aDictionary.</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>selecting fields</category><body package="GlorpQueries">fieldsForSelectStatement	^#()</body><body package="GlorpQueries">fieldsFromMyPerspective	^#()</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>accessing</category><body package="GlorpQueries">canCauseDuplicateRows	^expression class == MappingExpression and: [expression mapping isToManyRelationship].</body><body package="GlorpQueries">instanceValue	^self instance value</body><body package="GlorpQueries">subBuilders	^Array with: keyBuilder with: valueBuilder.</body><body package="GlorpQueries">withAllSubBuilders	^Array with: self with: keyBuilder with: valueBuilder.</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>building objects</category><body package="GlorpQueries">buildObjectFrom: anArray	"We just build an association out of the sub-builders "	| |	self row: anArray.</body><body package="GlorpQueries">findInstanceForRow: aRow proxyType: proxyType	instance := Association new.</body><body package="GlorpQueries">knitResultIn: aCursoredStream	"Connect up our built object with any other objects that reference it. Used if we retrieve more than one thing in the same query"	| relatedBuilder |	instance key: keyBuilder instance.	instance value: valueBuilder instance.	"Code from ObjectBuilder&gt;&gt;knitResultIn:"	expression canKnit ifFalse: [^self].	relatedBuilder := aCursoredStream objectBuilderFor: expression base.	(relatedBuilder isNil or: [relatedBuilder instance isNil]) 		ifFalse: 			[expression mapping knitFromBuilder: relatedBuilder toBuilder: self]</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>copying</category><body package="GlorpQueries">postCopy</body><body package="GlorpQueries">reconcileWithBuilders: oldCollection andCopy: newCollection	"Fix up references to our internal sub-builders"	| keyIndex valueIndex |	keyIndex := oldCollection indexOf: keyBuilder.	keyBuilder := newCollection at: keyIndex.	valueIndex := oldCollection indexOf: valueBuilder.	valueBuilder := newCollection at: valueIndex.</body></methods><methods><class-id>Glorp.DictionaryBuilder</class-id> <category>initialize-release</category><body package="GlorpQueries">setup	"Do any initialization once we've got our parameters"	| base collectionType |	base := query baseExpression.	collectionType := expression == base ifTrue: [query collectionType] ifFalse: [expression mapping query collectionType].	keyBuilder := ElementBuilder for: (collectionType keyExpression asGlorpExpressionOn: expression) in: query.	valueBuilder := ElementBuilder basicFor: (collectionType valueExpression asGlorpExpressionOn: expression) in: query.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>accessing</category><body package="GlorpExpressions">base	^base</body><body package="GlorpExpressions">canHaveBase	"Return true if this type of expression can have a base expression on which other things can be built. Doesn't say whether we actually have a valid one or not."	^true.</body><body package="GlorpExpressions">field	^lookupKey</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>navigating</category><body package="GlorpExpressions">queryLevelBaseExpression	^base queryLevelBaseExpression.</body><body package="GlorpExpressions">ultimateBaseExpression	^base ultimateBaseExpression.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>testing</category><body package="GlorpExpressions">canBind	"Return true if this represents a value that can be bound into a prepared statement"	^true.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>printing</category><body package="GlorpExpressions">convertedDbValueOf: anObject	"We don't do any conversion"	^anObject</body><body package="GlorpExpressions">printOn: aStream 	aStream nextPutAll: 'Parameter('.	self printTreeOn: aStream.	aStream nextPut: $)</body><body package="GlorpExpressions">printOnlySelfOn: aStream	lookupKey printSQLOn: aStream withParameters: #()</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	self field type print: (self valueIn: aDictionary) on: aStream.</body><body package="GlorpExpressions">printTreeOn: aStream 	[lookupKey printSQLOn: aStream withParameters: #()] on: Dialect error do: [:ex | lookupKey printOn: aStream].</body><body package="GlorpExpressions">valueIn: aDictionary 	^aDictionary at: lookupKey.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>iterating</category><body package="GlorpExpressions">do: aBlock skipping: aSet	(aSet includes: self) ifTrue: [^self].	aSet add: self.	base do: aBlock skipping: aSet.	aBlock value: self.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>api</category><body package="GlorpExpressions">get: aSelector withArguments: anArray	| functionExpression |	functionExpression := self getFunction: aSelector withArguments: anArray.	functionExpression isNil ifFalse: [^functionExpression].	^RelationExpression		named: aSelector		basedOn: self		withArguments: anArray</body><body package="GlorpExpressions">getMapping: aMapping named: aSymbol	"Get an expression given the actual mapping. Only if you really know what you're doing! In this case, what we're probably doing is rewriting a parameter that's a mapped object into a set of parameters, one for each of its primary keys."	| expression |	expression := nil.	aMapping mappedFields do: [:each |		expression := (each asGlorpExpressionOn: self) AND: expression].	^expression.</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>preparing</category><body package="GlorpExpressions">addToTargetFields: aCollection	"If we can provide target fields, add them to the collection"	lookupKey class == DatabaseField ifTrue: [		aCollection add: lookupKey].</body><body package="GlorpExpressions">asExpressionJoiningSource: source toTarget: target	"Create a general expression which represents this relationship where the values of the targets (which are normally parameters) are supplied out of the context provided by 'target' and the source fields are referencing things out of the context of source. Produces something suitable for ANDing into an expression when doing a join   Example: If we had CUSTOMER.ADDRESS_ID = ADDRESS.ID as a parameter, and we want to AND this into an expression [:customer | customer address street = 'Main'] then we have customer as a base, and we get 	(customer.ADDRESS.STREET = 'Main') AND (customer.CUSTOMER.ADDRESS_ID = customer.ADDRESS.ID)	The primary key expression for the relationship has been translated into field references into the customer and address tables in a particular context."	^source getField: lookupKey.</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	self == anExpression ifTrue: [^aBaseExpression].	self base == ultimateBaseExpression ifTrue: [^self].	^aBaseExpression getParameter: lookupKey.</body><body package="GlorpExpressions">tableForANSIJoin	^self field table</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>initialize/release</category><body package="GlorpExpressions">field: aDatabaseField base: aBaseExpression 	lookupKey := aDatabaseField.	base := aBaseExpression</body></methods><methods><class-id>Glorp.ParameterExpression</class-id> <category>inspecting</category><body package="GlorpExpressions">inspectorChildren	^Array with: base</body></methods><methods><class-id>Glorp.ParameterExpression class</class-id> <category>instance creation</category><body package="GlorpExpressions">forField: aField basedOn: anObjectExpression	^self new field: aField base: anObjectExpression; yourself</body></methods><methods><class-id>Glorp.NullSequence</class-id> <category>sequencing</category><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aField in: aRow</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor</body><body package="GlorpDatabase">preWriteAssignSequenceValueFor: aField in: aRow</body></methods><methods><class-id>Glorp.NullSequence</class-id> <category>public</category><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession</body></methods><methods><class-id>Glorp.NullSequence class</class-id> <category>instance creation</category><body package="GlorpDatabase">new	Singleton isNil ifTrue: [Singleton := self basicNew].	^Singleton.</body></methods><methods><class-id>Glorp.NullSequence class</class-id> <category>defaults</category><body package="GlorpDatabase">default	^self new.</body></methods><methods><class-id>Glorp.GlorpDatabaseReadError</class-id> <category>accessing</category><body package="GlorpMisc">accessor	^accessor</body><body package="GlorpMisc">accessor: aDatabaseAccessor	accessor := aDatabaseAccessor</body><body package="GlorpMisc">command	^command</body><body package="GlorpMisc">command: aDatabaseCommand	command := aDatabaseCommand</body><body package="GlorpMisc">databaseError	^databaseError</body><body package="GlorpMisc">databaseError: aDatabaseErrorObject	databaseError := aDatabaseErrorObject</body><body package="GlorpMisc">session	^command session.</body></methods><methods><class-id>Glorp.GlorpDatabaseReadError class</class-id> <category>initialize-release</category><body package="GlorpMisc">mayResume	^true.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>accessing</category><body package="GlorpQueries">addExpression: anExpression	self addExpression: anExpression andDo: [:ignore |].</body><body package="GlorpQueries">addExpression: anExpression andDo: aBlock	| exp |	exp := anExpression asGlorpExpressionOn: self base in: query.	(allTracings includes: exp) ifFalse: [		allTracings add: exp.		aBlock value: exp].</body><body package="GlorpQueries">additionalExpressions	| all |	alsoFetchExpressions isEmpty ifTrue: [^retrievalExpressions].	all := OrderedCollection new.	all addAll: self retrievalExpressions.	all addAll: self alsoFetchExpressions.	^all.</body><body package="GlorpQueries">allTracings	^allTracings.</body><body package="GlorpQueries">alsoFetchExpressions	^alsoFetchExpressions</body><body package="GlorpQueries">base	^query isNil ifTrue: [base] ifFalse: [query baseExpression].</body><body package="GlorpQueries">base: anExpression 	base := anExpression</body><body package="GlorpQueries">retrievalExpressions	^retrievalExpressions.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>setup</category><body package="GlorpQueries">setup	"We have been put into a query. If we aren't to trace anything else, trace the base"	retrievalExpressions isEmpty ifTrue: [		allTracings addFirst: base.		retrievalExpressions add: base].</body><body package="GlorpQueries">updateBase: aBaseExpression	"Make sure we have the same base as the query."	| transformed |	base == aBaseExpression ifTrue: [^self].	transformed := IdentityDictionary new.	base := aBaseExpression.	allTracings := allTracings collect:		[:each || new | new := each asGlorpExpressionOn: base.		transformed at: each put: new.		new].	retrievalExpressions := retrievalExpressions collect:		[:each | transformed at: each].	alsoFetchExpressions := alsoFetchExpressions collect:		[:each | transformed at: each].</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>initialize</category><body package="GlorpQueries">initialize	base := BaseExpression new.	allTracings := OrderedCollection new: 2.	retrievalExpressions := Set new: 3.	alsoFetchExpressions := Set new: 3.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>api</category><body package="GlorpQueries">alsoFetch: anExpression 	"Add the expression as something which will be explicitly retrieved and knit together with other results, but NOT included in the result list"	self addExpression: anExpression andDo: [:exp |		alsoFetchExpressions add: exp].</body><body package="GlorpQueries">retrieve: anExpression 	"Add the expression as something which will be explicitly retrieved and knit together with other results, and included in the result list"	self addExpression: anExpression andDo: [:exp |		retrievalExpressions add: exp].</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>querying</category><body package="GlorpQueries">tracesThrough: aMapping	^aMapping isStoredInSameTable.</body></methods><methods><class-id>Glorp.Tracing</class-id> <category>copying</category><body package="GlorpQueries">copy	^self shallowCopy postCopy.</body><body package="GlorpQueries">postCopy	allTracings := allTracings copy.	retrievalExpressions := retrievalExpressions copy.	alsoFetchExpressions := alsoFetchExpressions copy.</body></methods><methods><class-id>Glorp.Tracing class</class-id> <category>instance creation</category><body package="GlorpQueries">for: aQuery	^self new base: aQuery whereClause ultimateBaseExpression.</body><body package="GlorpQueries">new	^super new initialize.</body></methods><methods><class-id>Glorp.PostgresLibpqPlatform</class-id> <category>accessing</category><body package="GlorpDatabase">vwEXDIConnectionClass	^'PostgresLibpqConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'PostgreSQL3EXDI'</body></methods><methods><class-id>Glorp.PostgresLibpqPlatform</class-id> <category>testing</category><body package="GlorpDatabase">canRecurse	^canRecurse</body><body package="GlorpDatabase">supportsGroupWritingFor: aCommand	"I can group statements unbound.  If the serverVersion is 8.2 or newer, I can also group bound (or unbound) values following a single statement.  If the command needsRowCount then the clause in supportsRowCount: i.e. aCommand expectedNumberOfModifiedRows &lt; 2 can never be true in this method, since it must be greater than one to pass the #shouldUseGroupWriting call's check of hasMultipleRows."	^(super supportsGroupWritingFor: aCommand) and:		[aCommand supportsGroupWritingValues or:			[self useBinding not and: [aCommand needsRowCount not and: [aCommand class ~= ReturningUpdateCommand]]]]</body><body package="GlorpDatabase">supportsGroupWritingValues	"Postgres versions earlier than 8.2 do not support a single INSERT statement followed by multiple VALUES statements;  read the version after login and cache whether the specific database installation that I represent does or not."	^supportsGroupWritingValues ifNil: [false]	"false is functionally safe, just slower"</body><body package="GlorpDatabase">supportsMultipleOpenCursors	"To be reviewed."	^false</body><body package="GlorpDatabase">supportsRowCountFor: aRowBasedCommand	"If libpq is not bound then it can send batched statements to te server but will only return the result set and rowCount of the last statement in the batch.  Thus its rowCount is unreliable when unbound if more than one statement is involved: a batch of several attempted UPDATEs wil return a rowCount of 0 or 1 for the last UPDATE only.  (By contrast, PostgresSocket returns a result set - which may be just #noAnswerStream - for each statement in a batch, so the rowCounts can be queried and aggregated.)"	^(self useBinding and: [aRowBasedCommand useBinding])		or: [aRowBasedCommand expectedNumberOfModifiedRows &lt; 2]</body></methods><methods><class-id>Glorp.PostgresLibpqPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">postLoginInitializeFromAccessor: aDatabaseAccessor	| standardConformingStrings dbmsVersion |	charactersThatNeedEscaping isNil ifFalse: [^self].	"All values are set first time round, so we need only check one."	"Only the VWDatabaseAccessor calls this method at the moment, so we need not check	Dialect isVisualWorks ifFalse: [^super postLoginInitializeFromAccessor: aDatabaseAccessor]."	standardConformingStrings := aDatabaseAccessor connection standardConformingStrings.	standardConformingStrings = 'on'		ifTrue: [charactersThatNeedEscaping := '''']	"escape single quote characters only"		ifFalse: [charactersThatNeedEscaping := '''\'].	"escape single quote and backslash"	dbmsVersion := aDatabaseAccessor connection serverVersion tokensBasedOn: $..	supportsGroupWritingValues := self isVersion: #(8 2) notNewerThan: dbmsVersion.	canRecurse := self isVersion: #(8 4) notNewerThan: dbmsVersion.</body></methods><methods><class-id>Glorp.PostgresLibpqPlatform</class-id> <category>commands</category><body package="GlorpDatabase">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	"When unbound, Postgres can group ;-separated INSERT statements or (in 8.2 and after) ,-separated values following a single INSERT statement.  When bound, only the latter works.  We group using values in both cases, because we must when bound and to minimise the length of the round-trip SQL when unbound."	^(self supportsGroupWritingValues ifFalse: [InsertCommand] ifTrue: [InsertMultiValuesCommand])		forRows: aCollectionOfDatabaseRows		useBinding: aBoolean		session: aSession</body></methods><methods><class-id>Glorp.PostgresLibpqPlatform</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	"I have supported group writing since version 8.2 and recursion since 8.4.  For safety, we initialize to false, resetting in postLoginInitializeFromAccessor:."	super initialize.	canRecurse := false.	supportsGroupWritingValues := false.</body></methods><methods><class-id>Glorp.PostgresLibpqPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Postgres via Libpq I/F'</body></methods><methods><class-id>Glorp.FilteringQuery</class-id> <category>accessing</category><body package="GlorpQueries">collectBlock	^collectBlock</body><body package="GlorpQueries">collectBlock: aBlock	collectBlock:= aBlock.</body><body package="GlorpQueries">collection	^collection</body><body package="GlorpQueries">collection: aCollection	aCollection class == GlorpVirtualCollection ifTrue: [collectionType := aCollection getQuery collectionType].	collection := aCollection.</body><body package="GlorpQueries">filter	^filter</body><body package="GlorpQueries">filter: aBlock	filter := aBlock</body><body package="GlorpQueries">resultClass	collection class == GlorpVirtualCollection ifTrue: [^collection getQuery resultClass].	^(collection detect: [:each | true] ifNone: [nil]) class</body></methods><methods><class-id>Glorp.FilteringQuery</class-id> <category>executing</category><body package="GlorpQueries">collectionTypesAgree: aCollection	^self collectionType new class == aCollection class</body><body package="GlorpQueries">executeWithParameters: parameterArray in: aSession	| filtered result |	session := aSession.	collection class == GlorpVirtualCollection		ifTrue:			[collection setSession: aSession.			collection parameters: parameterArray.			collection := collection realObjects].	filtered := self filterResultsForParameters: parameterArray.	result := self transformsValues		ifTrue: [filtered collect: [:each | self valueFor: each]]		ifFalse: [filtered].	result := (self collectionTypesAgree: result) ifTrue: [result] ifFalse: [self resultCollectionFor: result readStream].	^self readsOneObject		ifTrue: [result detect: [:each | true] ifNone: [nil]]		ifFalse: [result].</body><body package="GlorpQueries">filterResultsForParameters: parameterArray	| passing seen |	seen := IdentitySet new.	passing := collection		select:			[:each | 			| passes new value |			passes := filter value: each value: parameterArray.			value := self valueFor: each.			passes				ifTrue:					[new := (seen includes: value) not.					new ifTrue: [seen add: value]].			passes and: [new]].	^passing.</body><body package="GlorpQueries">transformsValues	^collectBlock notNil.</body><body package="GlorpQueries">valueFor: anObject	collectBlock isNil ifTrue: [^anObject].	^collectBlock value: anObject.</body></methods><methods><class-id>Glorp.FilteringQuery</class-id> <category>testing</category><body package="GlorpQueries">shortCircuitEmptyReturn: parameters	^false.</body></methods><methods><class-id>Glorp.FilteringQuery class</class-id> <category>instance creation</category><body package="GlorpQueries">on: aCollection filter: aBlock	^self new		collection: aCollection; 		filter: aBlock.</body></methods><methods><class-id>Glorp.VersionNumberVersionGenerator</class-id> <category>sequencing</category><body package="GlorpDatabase">nextValueFor: aField in: aRow	| oldValue |	oldValue := aRow at: aField ifAbsent: [0].	^(oldValue isNil ifTrue: [0] ifFalse: [oldValue]) + 1</body></methods><methods><class-id>Glorp.CannotAutomaticallyDetermineJoin</class-id> <category>accessing</category><body package="GlorpMisc">constraints	constraints isNil ifTrue: [constraints := #()].	^constraints</body><body package="GlorpMisc">constraints: aCollection	constraints := aCollection</body><body package="GlorpMisc">defaultMessageText	^'Cannot calculate the join automatically, not enough information.'.</body><body package="GlorpMisc">tables	^tables</body><body package="GlorpMisc">tables: databaseTables	tables := databaseTables</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>accessing</category><body package="GlorpDatabase">allSequences	"Return a dictionary of all the sequences associated with this table, indexed by name."	| result |	result := Dictionary new.	self fields do: [:eachField |  		eachField type hasSequence ifTrue:			[result at: eachField type sequence name put: eachField type sequence]].	^result.</body><body package="GlorpDatabase">creator	^self schema</body><body package="GlorpDatabase">creator: aString	"For backward-compatibility. Use schema: instead."	self schema: aString.</body><body package="GlorpDatabase">fields	^fields</body><body package="GlorpDatabase">foreignKeyConstraints	"Private - Answer the value of the receiver's ''foreignKeyConstraints'' instance variable."	^foreignKeyConstraints</body><body package="GlorpDatabase">foreignKeyConstraintsForCreation	"Return the foreign key constraints that should actually be created in the database. Omit those that refer to imaginary tables"	^foreignKeyConstraints select: [:each |		each isImaginary not and: [each shouldCreateInDatabase]].</body><body package="GlorpDatabase">indexClass	^DatabaseIndex</body><body package="GlorpDatabase">isAliased	^parent notNil.</body><body package="GlorpDatabase">isImaginary	^isImaginary.</body><body package="GlorpDatabase">isImaginary: aBoolean	isImaginary := aBoolean.</body><body package="GlorpDatabase">lockKeyFields	^lockKeyFields</body><body package="GlorpDatabase">name	^name</body><body package="GlorpDatabase">name: anObject	name := anObject</body><body package="GlorpDatabase">nonPrimaryKeyFields	^self fields reject: [:each | each isPrimaryKey].</body><body package="GlorpDatabase">parent	^parent.</body><body package="GlorpDatabase">parent: aDatabaseTable	parent := aDatabaseTable.</body><body package="GlorpDatabase">platform	fields do: [:each | ^each type platform].	^nil.</body><body package="GlorpDatabase">primaryKeyConstraints	"Answer the value of the receiver's ''PrimaryKeyConstraints'' instance variable."	^self hasPrimaryKeyConstraints		ifTrue: [ PrimaryKeyConstraint forTable: self ]		ifFalse: [ nil ]</body><body package="GlorpDatabase">primaryKeyFields	primaryKeyFields isNil ifTrue: [primaryKeyFields := fields select: [:each | each isPrimaryKey yourSelf "might be a proxy"]].	^primaryKeyFields.</body><body package="GlorpDatabase">qualifiedName	^(schema isNil or: [schema isEmpty]) ifTrue: [name] ifFalse: [schema, '.', name].</body><body package="GlorpDatabase">replacementSubSelect: aQuery	replacementSubSelect := aQuery.</body><body package="GlorpDatabase">schema	^schema</body><body package="GlorpDatabase">schema: aString	schema := aString.	parent isNil ifTrue: [		self sequences do: [:each | each schema: aString]].</body><body package="GlorpDatabase">sequences	"Return a collection (which is likely either empty or of size 1) of all the sequences we use."	| sequences |	sequences := OrderedCollection new: 2.	self primaryKeyFields do: [:each | each type hasSequence ifTrue: [sequences add: each type sequence]].	^sequences.</body><body package="GlorpDatabase">shouldBeWritten	^isImaginary not.</body><body package="GlorpDatabase">uniqueConstraints	"Private - Answer the value of the receiver's ''uniqueConstraints'' instance variable."	^uniqueConstraints</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>fields</category><body package="GlorpDatabase">addField: aField	fields add: aField.	aField isPrimaryKey ifTrue: [		self addAsPrimaryKeyField: aField].	aField table: self.	aField position: fields size.	^aField.</body><body package="GlorpDatabase">addForeignKeyFrom: sourceField to: targetField	^self		addForeignKeyFrom: sourceField		to: targetField		suffixExpression: nil.</body><body package="GlorpDatabase">addForeignKeyFrom: sourceField to: targetField from: sourceField2 to: targetField2	^self		addForeignKeyFromAll: (Array with: sourceField with: sourceField2)		toAll: (Array with: targetField with: targetField2)		suffixExpression: nil.</body><body package="GlorpDatabase">addForeignKeyFrom: sourceField to: targetField from: sourceField2 to: targetField2 from: sourceField3 to: targetField3	^self		addForeignKeyFromAll: (Array with: sourceField with: sourceField2 with: sourceField3)		toAll: (Array with: targetField with: targetField2 with: targetField3)		suffixExpression: nil.</body><body package="GlorpDatabase">addForeignKeyFrom: sourceField to: targetField suffixExpression: suffixExpression	| newFK |	newFK := ForeignKeyConstraint					sourceField: sourceField					targetField: targetField					suffixExpression: suffixExpression.	newFK name: (newFK name , (foreignKeyConstraints size + 1) printString).	foreignKeyConstraints add: newFK.	^newFK.</body><body package="GlorpDatabase">addForeignKeyFrom: sourceField toTable: targetTable	^self		addForeignKeyFrom: sourceField		to: (targetTable fieldNamed: 'ID' ifAbsent: [^nil])</body><body package="GlorpDatabase">addForeignKeyFromAll: sourceFields toAll: targetFields	^self addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: nil.</body><body package="GlorpDatabase">addForeignKeyFromAll: sourceFields toAll: targetFields suffixExpression: suffixExpression	| newFK |	newFK := ForeignKeyConstraint					sourceFields: sourceFields					targetFields: targetFields					suffixExpression: suffixExpression.	newFK name: (newFK name , (foreignKeyConstraints size + 1) printString).	^foreignKeyConstraints add: newFK.</body><body package="GlorpDatabase">addUniqueConstraintFor: sourceFields	| newConstraint |	newConstraint := UniqueConstraint		forTable: self		fields: sourceFields.	^uniqueConstraints add: newConstraint</body><body package="GlorpDatabase">createFieldNamed: aString type: dbType	"If there's already a field of this name, raise an error.  If we do not find one, make a new one, add it to me and return it."	fields		detect: [:each | each name = aString]		ifNone: [^self addField: (DatabaseField named: aString type: dbType)].	self error: 'field ', aString, ' already exists'.</body><body package="GlorpDatabase">fieldNamed: aString	^self fieldNamed: aString ifAbsent: [self error: 'No field ', aString, ' in ', self name].</body><body package="GlorpDatabase">fieldNamed: aString ifAbsent: aBlock	^self fieldNamed: aString ifAbsent: aBlock caseSensitive: false.</body><body package="GlorpDatabase">fieldNamed: aString ifAbsent: aBlock caseSensitive: aBoolean	| fieldName |	fieldName := aBoolean ifTrue: [aString asString] ifFalse: [aString asUppercase].	^fields		detect:			[:each | (aBoolean ifTrue: [each name] ifFalse: [each name asUppercase]) = fieldName]		ifNone: aBlock.</body><body package="GlorpDatabase">newFieldNamed: aString	^self error: 'use #createFieldNamed:type:'</body><body package="GlorpDatabase">removeFieldNamed: aString	^self removeFieldNamed: aString ifAbsent: [self error: 'No such field'].</body><body package="GlorpDatabase">removeFieldNamed: aString ifAbsent: aBlock	| removedField |	removedField := fields remove: (self fieldNamed: aString ifAbsent: aBlock).	1 to: fields size do: [:i | (fields at: i) position: i].	^removedField</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>printing</category><body package="GlorpDatabase">imaginaryReplacementName	| stream |	stream := WriteStream on: (String new: 100).	stream nextPut: $(.	stream nextPutAll: (replacementSubSelect sqlWith: #()) sqlString.	stream nextPut: $); space.	^stream contents</body><body package="GlorpDatabase">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: '(';		nextPutAll: ((schema isNil or: [schema isEmpty]) ifTrue: [''] ifFalse: [schema, '.']);		nextPutAll: (name isNil ifTrue: [''] ifFalse: [name]);		nextPutAll: ')'.</body><body package="GlorpDatabase">printSQLOn: aWriteStream withParameters: aDictionary	aWriteStream nextPutAll: self qualifiedName</body><body package="GlorpDatabase">sqlString	^name.</body><body package="GlorpDatabase">sqlTableName	"Our name, as appropriate for the list of tables in a SQL statement. Take into account aliasing"	^parent isNil		ifTrue:			[self isImaginary				ifTrue: [self imaginaryReplacementName]				ifFalse: [self qualifiedName]]		ifFalse: [parent sqlTableName , ' ' , self qualifiedName].</body><body package="GlorpDatabase">unaliasedName	"The name of the underlying table, whether we are an alias of it or not."	^parent isNil		ifTrue: [self name]		ifFalse: [parent name]</body><body package="GlorpDatabase">unqualifiedSqlTableName	"Our name, as appropriate for the list of tables in a SQL statement. Take into account aliasing"	^parent isNil		ifTrue:			[self isImaginary				ifTrue: [self imaginaryReplacementName]				ifFalse: [self qualifiedName]]		ifFalse: [parent sqlTableName].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>testing</category><body package="GlorpDatabase">constraintsToAnyOf: aCollectionOfTables	^self foreignKeyConstraints select:		[:eachConstraint |		aCollectionOfTables anySatisfy:			[:eachTable | eachConstraint refersToTable: eachTable]]</body><body package="GlorpDatabase">hasCompositePrimaryKey	^primaryKeyFields size &gt; 1.</body><body package="GlorpDatabase">hasConstraints	^self hasForeignKeyConstraints or: [self hasPrimaryKeyConstraints or: [self hasUniqueConstraints]]</body><body package="GlorpDatabase">hasConstraintsTo: aTable	self foreignKeyConstraints		do: [:each | (each refersToTable: aTable) ifTrue: [^true]].	^false.</body><body package="GlorpDatabase">hasConstraintsToAnyOf: aCollectionOfTables	aCollectionOfTables do: [:each |		(self hasConstraintsTo: each) ifTrue: [^true]].	^false.</body><body package="GlorpDatabase">hasFieldNamed: aString	^(self fieldNamed: aString ifAbsent: [nil] caseSensitive: false) notNil.</body><body package="GlorpCore">hasForeignKeyConstraintMatching: aConstraint	^self foreignKeyConstraints		anySatisfy: [:each | (each matchesForeignKeyConstraint: aConstraint)].</body><body package="GlorpCore">hasForeignKeyConstraintTheSameAs: aConstraint	^self foreignKeyConstraints anySatisfy: [:each | (each isTheSameAs: aConstraint)].</body><body package="GlorpDatabase">hasForeignKeyConstraints	^foreignKeyConstraints isEmpty not</body><body package="GlorpDatabase">hasIndexNamed: aString	^indexes contains: [:each | each name = aString]</body><body package="GlorpDatabase">hasPrimaryKeyConstraints	^self primaryKeyFields isEmpty not.</body><body package="GlorpCore">hasUniqueConstraintMatching: aConstraint		^self uniqueConstraints anySatisfy: [:each | each matchesUniqueConstraint: aConstraint]</body><body package="GlorpDatabase">hasUniqueConstraints	^uniqueConstraints isEmpty not</body><body package="GlorpDatabase">isEmpty	^fields isEmpty.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>private/fields</category><body package="GlorpDatabase">addAsLockKeyField: aField 	lockKeyFields add: aField</body><body package="GlorpDatabase">addAsPrimaryKeyField: aField	(fields includes: aField) ifFalse: [self error: 'Primary key field not part of the table'].	aField isPrimaryKey ifFalse: ["Somebody is calling this as API, since there's an example out on the net that does it that way - just do the right thing instead"		^aField bePrimaryKey].	(primaryKeyFields notNil and: [primaryKeyFields includes: aField]) ifTrue: [^self].	primaryKeyFields := primaryKeyFields isNil ifTrue: [Array with: aField] ifFalse: [primaryKeyFields, (Array with: aField)].</body><body package="GlorpDatabase">foreignKeyFields	"Answer the receiver's fields which are part of any foreign key constraints.  (This was called by DatabaseRow&gt;&gt;canUpdateRow:, now discarded as a needless check for a never-naturally-occurring condition, but is left as a utility method.)"	^self foreignKeyConstraints		inject: IdentitySet new		into: [:sum :eachConstraint |			sum addAll: eachConstraint sourceFields.			sum]</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>validation</category><body package="GlorpDatabase">validateIn: aDescriptorSystem	"Do any tests we can to make sure that this definition makes sense in this context"</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>indexes</category><body package="GlorpDatabase">addIndex: aDatabaseIndex	^indexes add: aDatabaseIndex.</body><body package="GlorpDatabase">addIndexForField: aField	^indexes add: (self indexClass forField: aField).</body><body package="GlorpDatabase">addIndexForField: aField and: anotherField	^self addIndexForFields: (Array with: aField with: anotherField).</body><body package="GlorpDatabase">addIndexForField: aField and: anotherField and: thirdField	^self addIndexForFields: (Array with: aField with: anotherField with: thirdField).</body><body package="GlorpDatabase">addIndexForFields: aFieldCollection	^indexes add: (self indexClass forFields: aFieldCollection).</body><body package="GlorpDatabase">hasIndexForField: aField	^(indexes detect: [:each | each indexesField: aField] ifNone: [nil]) notNil.</body><body package="GlorpDatabase">indexes	^indexes.</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>constraints</category><body package="GlorpDatabase">foreignKeyConstraintsForField: aField	^self foreignKeyConstraints select: [:each | each sourceFields includes: aField].</body><body package="GlorpDatabase">hasForeignKeyConstraintsForField: aField	^self foreignKeyConstraints anySatisfy: [:each | each sourceFields includes: aField].</body><body package="GlorpDatabase">hasForeignKeyConstraintsForTargetField: aField	^self foreignKeyConstraints anySatisfy: [:each | each targetFields includes: aField].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>initialize</category><body package="GlorpDatabase">initialize	schema := ''.	fields := OrderedCollection new.	foreignKeyConstraints := OrderedCollection new: 4.	uniqueConstraints := OrderedCollection new.	lockKeyFields := OrderedCollection new.	indexes := OrderedCollection new.	isImaginary := false.</body><body package="GlorpDatabase">postInitializeIn: aDescriptorSystem	"Any initialization that happens after all the fields have been added"	1 to: fields size do: [:i |		| each | 		"If fields were read from the database, set their position now"		each := fields at: i.		each table: self.		each position: i.		each postInitializeIn: aDescriptorSystem].</body><body package="GlorpDatabase">setSchemaAndNamesCaseFromTable: aDatabaseTable onPlatform: aDatabasePlatform	"Initialize this table with case-matching names from aDatabaseTable when their spelling is otherwise identical.  On MySQL, we must do more:  MySQL will not match a constraints if the requested name is not the same including case, although (like other platforms), it will not allow two constraints differing only in case.  Thus we must take the constraint names of the database table if they match our up to case, but not exactly.	As we have in any case gone wrong if I and the parameter are not a lot alike, we do not bother to check whether two constraints whose names match up to case also satisfy #isSimilarForeignKeyConstraint: - we assume it is so."	| dbFkcNames dbUcNames |	self		name: aDatabaseTable name;		"caller ensures it must already be the same up to case"		schema: aDatabaseTable schema.	aDatabasePlatform isMySQLPlatform ifFalse: [^self].	dbFkcNames := aDatabaseTable foreignKeyConstraints collect: [:each | each name].	self foreignKeyConstraints do:		[:aConstraint || matchedName |		matchedName := dbFkcNames			detect: [:each | each asUppercase = aConstraint name asUppercase]			ifNone: [nil].		(matchedName isNil or: [matchedName = aConstraint name])		"or: [aConstraint isSimilarForeignKeyConstraint: aDatabaseTableForeignKeyConstraint) not]"			ifFalse: [aConstraint name: matchedName]].	dbUcNames := aDatabaseTable uniqueConstraints collect: [:each | each name].	self uniqueConstraints do:		[:aConstraint || matchedName |		matchedName := dbUcNames			detect: [:each | each asUppercase = aConstraint name asUppercase]			ifNone: [nil].		(matchedName isNil or: [matchedName = aConstraint name])			ifFalse: [aConstraint name: matchedName]].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>comparing</category><body package="GlorpDatabase">&lt;= aTable	^self qualifiedName &lt;= aTable qualifiedName.</body><body package="GlorpDatabase">isTheSameAs: aDatabaseTable	"Validate that two tables are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method."	self name asUppercase = aDatabaseTable name asUppercase ifFalse: [^false].	"For the test purposes, we won't worry about schema right now.""	self schema = aDatabaseTable schema ifFalse: [^false]."	self fields size = aDatabaseTable fields size ifFalse: [^false].	self fields asSortedCollection with: aDatabaseTable fields asSortedCollection do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].	self foreignKeyConstraints size = aDatabaseTable foreignKeyConstraints size ifFalse: [^false].	self foreignKeyConstraints with: aDatabaseTable foreignKeyConstraints do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		self indexes with: aDatabaseTable indexes do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].	self lockKeyFields with: aDatabaseTable lockKeyFields do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].		self primaryKeyFields size = aDatabaseTable primaryKeyFields size ifFalse: [^false].	self primaryKeyFields asSortedCollection with: aDatabaseTable primaryKeyFields asSortedCollection do: [:a :b | (a isTheSameAs: b) ifFalse: [^false]].	self isImaginary = aDatabaseTable isImaginary ifFalse: [^false].	^true.	"Note, we ignore parent and replacementSubselect"</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>obsolete</category><body package="GlorpDatabase">addFields: aCollection fromAccessor: aDatabaseAccessor	| stream |	aCollection		do:			[:each | 			aDatabaseAccessor				execute:					[stream := WriteStream on: String new.					stream						nextPutAll: 'ALTER TABLE ';						nextPutAll: self name;						nextPutAll: ' ADD ';						nextPutAll: self platform startColumnAddString.					self platform printColumn: each on: stream.					stream nextPutAll: self platform endColumnAddString.					aDatabaseAccessor executeSQLStringNoResult: stream contents]				ifError: [:ex | ex pass]].</body><body package="GlorpDatabase">dropFields: aCollection fromAccessor: aDatabaseAccessor	aCollection		do:			[:each | 			aDatabaseAccessor				execute:					[aDatabaseAccessor						executeSQLStringNoResult:							'ALTER TABLE ' , self name , ' DROP COLUMN ' , each name]				ifError: [:ex | ex pass]].</body><body package="GlorpDatabase">dropForeignKeyConstraintsFromAccessor: aDatabaseAccessor 	self foreignKeyConstraints 		do: [:each | aDatabaseAccessor dropConstraint: each]</body><body package="GlorpDatabase">dropFromAccessor: aDatabaseAccessor	aDatabaseAccessor dropTable: self  ifError: [].</body><body package="GlorpDatabase">dropPrimaryKeyConstraintsFromAccessor: aDatabaseAccessor	(self primaryKeyFields isEmpty not and: [self platform usesPrimaryKeyUniqueConstraintNames])		ifTrue: [			aDatabaseAccessor	execute:				[aDatabaseAccessor						executeSQLStringNoResult:							'ALTER TABLE ' , self name , ' DROP '								, self platform nameForPrimaryKeyConstraintsWhenDropping , ' '								, self primaryKeyUniqueConstraintName]				ifError:					[:ex | 					Transcript show: ex messageText.					ex return: nil].		aDatabaseAccessor execute: [			aDatabaseAccessor executeSQLStringNoResult:					'ALTER TABLE ' , self name , ' DROP '						, self platform nameForPrimaryKeyConstraintsWhenDropping , ' '						, self primaryKeyConstraintName]			ifError: [:ex | 				Transcript show: ex messageText.				ex return: nil]].</body><body package="GlorpDatabase">primaryKeyConstraintName	^self name, '_PK'.</body><body package="GlorpDatabase">primaryKeyUniqueConstraintName	^self platform usesPrimaryKeyUniqueConstraintNames ifTrue: [self name, '_UNIQ'] ifFalse: [''].</body><body package="GlorpDatabase">printAddPrimaryKeyConstraintsOn: aStream for: aDatabaseAccessor 	self primaryKeyFields isEmpty ifTrue: [^self].	aStream nextPutAll: 'ALTER TABLE ' , self name.	aStream nextPutAll: ' ADD CONSTRAINT '.	aStream nextPutAll: self primaryKeyConstraintName.	aStream nextPutAll: ' PRIMARY KEY  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: self primaryKeyFields		separatedBy: ','.	aStream nextPut: $).	aStream		nextPutAll: ',';		cr.	aStream nextPutAll: ' ADD CONSTRAINT '.	aStream nextPutAll: self primaryKeyUniqueConstraintName.	aStream nextPutAll: ' UNIQUE  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: self primaryKeyFields		separatedBy: ','.	aStream nextPut: $)</body><body package="GlorpDatabase">printDelimiterOn: aStream		aStream		nextPut: $,;		cr</body><body package="GlorpDatabase">printPrimaryKeyConstraintsOn: aStream for: aDatabaseAccessor 	self primaryKeyFields isEmpty ifTrue: [^self].	aStream nextPutAll: 'CONSTRAINT '.	aStream nextPutAll: self primaryKeyConstraintName.	aStream nextPutAll: ' PRIMARY KEY  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: self primaryKeyFields		separatedBy: ','.	aStream nextPut: $).	aStream		nextPutAll: ',';		cr.	aStream nextPutAll: 'CONSTRAINT '.	aStream nextPutAll: self primaryKeyUniqueConstraintName.	aStream nextPutAll: ' UNIQUE  ('.	GlorpHelper 		print: [:each | each name]		on: aStream		for: self primaryKeyFields		separatedBy: ','.	aStream nextPut: $)</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>deprecated</category><body package="GlorpDatabase">addForeignKeyFrom: sourceField toField: targetField	self deprecated: #(#version '8.0' #sunset '8.1' #use #addForeignKeyFrom:to:).	^self addForeignKeyFrom: sourceField to: targetField</body></methods><methods><class-id>Glorp.DatabaseTable class</class-id> <category>instance creation</category><body package="GlorpDatabase">named: aString	^self new name: aString.</body><body package="GlorpDatabase">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpIllegalCommand</class-id> <category>accessing</category><body package="GlorpMisc">command	^command</body><body package="GlorpMisc">command: aDatabaseCommand	command := aDatabaseCommand</body><body package="GlorpMisc">defaultMessageText	^'Illegal Command'</body><body package="GlorpMisc">session	^command session.</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>testing</category><body package="GlorpDatabase">canBind: aValue to: aType	"In 7.10, the Postgres protocol 2.0 EXDI can accept Timestamp and Number formats for binding.  Date and time formats have not yet been handled."	aType = self date ifTrue: [^false].	aType = self time ifTrue: [^false].	aType = self timetz ifTrue: [^false].	^super canBind: aValue to: aType</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>conversion-strings</category><body package="GlorpDatabase">printBlob: aByteArray on: aStream for: aType	| encoderStream base64String |	aByteArray isNil ifTrue: [^aStream nextPutAll: 'NULL'].	Dialect isSqueak ifTrue: [^self squeakPrintBlob: aByteArray on: aStream for: aType].	base64String := String new: (aByteArray size * 3/2) rounded.	encoderStream := Dialect	"briefly set the encoderStream to its class"		smalltalkAt: #Base64EncodingWriteStream		ifAbsent: [nil].	encoderStream isNil		ifTrue:	"VisualWorks base:  set the encoder's lineLength to ensure no line breaks added to base64 string."			[encoderStream := (base64String withEncoding: 'Base64') writeStream.			encoderStream encoder  lineLength: aByteArray size * 3.			encoderStream nextPutAll: aByteArray; close.			aStream nextPutAll: encoderStream encodedContents printString]		ifFalse:			[encoderStream := encoderStream on: base64String.			encoderStream disableLineBreaks.			encoderStream nextPutAll: aByteArray.			encoderStream close.			aStream nextPutAll: encoderStream contents printString].</body></methods><methods><class-id>Glorp.PostgreSQLPlatform</class-id> <category>accessing</category><body package="GlorpDatabase">vwEXDIConnectionClass	^'PostgreSQLEXDIConnection' asQualifiedReference valueIfUndefinedLoadFrom: 'PostgreSQLEXDI'</body></methods><methods><class-id>Glorp.PostgreSQLPlatform class</class-id> <category>accessing</category><body package="GlorpDatabase">kind	^'Postgres via old Socket I/F'</body></methods><methods><class-id>Glorp.MultipleMappingsForInstanceVariable</class-id> <category>accessing</category><body package="GlorpMisc">attributeNames	^attributeNames</body><body package="GlorpMisc">attributeNames: anObject	attributeNames := anObject</body><body package="GlorpMisc">messageText	^'Multiple readable mappings for one instance variable:&lt;1s&gt;' expandMacrosWith: self readableMappings  printString</body><body package="GlorpMisc">readableMappings	^readableMappings</body><body package="GlorpMisc">readableMappings: anObject	readableMappings := anObject</body></methods><methods><class-id>Glorp.GlorpDictionaryDescription</class-id> <category>accessing</category><body package="GlorpQueries">keyExpression	^keyExpression</body><body package="GlorpQueries">keyExpression: anExpression	keyExpression := anExpression</body><body package="GlorpQueries">valueExpression	^valueExpression</body><body package="GlorpQueries">valueExpression: anExpression	valueExpression := anExpression</body></methods><methods><class-id>Glorp.GlorpDictionaryDescription</class-id> <category>instance creation</category><body package="GlorpQueries">copyEmpty: anInteger	"Masquerade as a instance of a collection :-)"	^Dictionary new: anInteger.</body><body package="GlorpQueries">new	"Masquerade as a class"	^Dictionary new.</body><body package="GlorpQueries">new: anInteger	"Masquerade as a class"	^Dictionary new: anInteger.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>converting</category><body package="GlorpExpressions">asGeneralGlorpExpression	"We know that we represent querying for an abstract class, so we don't want to convert ourselves to a join form, but rather just to a source mapping form. There are some assumptions in here, but it should work for the basic cases anyway."	| base expression anyJoin descriptor |	anyJoin := self anyJoin.	base := anyJoin base.	descriptor := base system findDescriptorForTable: anyJoin allTargetFields first table.	expression := EmptyExpression new base: base.	anyJoin mappableFieldsDo: [:source :target |		| mapping thingToCompare |		mapping := descriptor mappingForField: target.		thingToCompare := mapping isNil			ifTrue: [base getField: target]			ifFalse: [base get: mapping attributeName].		expression := expression AND: (thingToCompare get: #= withArguments: (Array with: (source asGlorpExpressionOn: base)))].	^expression.</body><body package="GlorpExpressions">asGeneralGlorpExpressionWithFields	"The normal conversion of a join is to an expression equating fields and parameters. Instead, generate one with field to field comparisons."	| base expression mappingName anyJoin descriptor |	anyJoin := self anyJoin.	base := anyJoin base.	descriptor := base system findDescriptorForTable: anyJoin allTargetFields first table.	expression := EmptyExpression new base: base.	anyJoin mappableFieldsDo: [:source :target |		mappingName := (descriptor mappingForField: target) attributeName.		expression := expression AND: ((base get: mappingName) get: #= withArguments: (Array with: (self targetExpressionFor: source)))].	^expression.</body><body package="GlorpExpressions">asGlorpExpressionOn: aBaseExpression	| copy |	copy := self copy.	copy joins: (copy joins collect: [:each | each asGlorpExpressionOn: aBaseExpression]).	^copy.</body><body package="GlorpExpressions">isConstant: aTarget	"The target can be either a constant (which gets turned into a ConstantExpression) or (usually) a DatabaseField, representing a parameter to the query."	(aTarget class == DatabaseField) ifTrue: [^false].	^aTarget isGlorpExpression not		or: [aTarget isConstantExpression]</body><body package="GlorpExpressions">targetExpressionFor: eachTarget 	^(self isConstant: eachTarget)		ifTrue: [eachTarget]		ifFalse: [eachTarget isGlorpExpression 				ifTrue: [eachTarget asGlorpExpressionOn: self anyJoin base] 				ifFalse: [(self anyJoin base getTable: eachTarget table) getField: eachTarget]].</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>accessing</category><body package="GlorpExpressions">addJoinFor: aClass as: aJoin	joins at: aClass put: aJoin.</body><body package="GlorpExpressions">allSourceFields	"We assume that variable joins vary in the targets, not the in sources."	^self anyJoin allSourceFields</body><body package="GlorpExpressions">allTargetFields	^joins inject: OrderedCollection new into: [:sum :each | sum addAll: each allTargetFields. sum].</body><body package="GlorpExpressions">anyJoin	^joins detect: [:each | true].</body><body package="GlorpExpressions">generalExpressionPart	^nil.</body><body package="GlorpExpressions">joins	^joins.</body><body package="GlorpExpressions">joins: aCollection	joins := aCollection.</body><body package="GlorpExpressions">mappableSourceFieldsDo: aBlock	self anyJoin mappableSourceFieldsDo: aBlock.</body><body package="GlorpExpressions">queryLevelBaseExpression	^self ultimateBaseExpression.</body><body package="GlorpExpressions">ultimateBaseExpression	^self anyJoin base.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>printing</category><body package="GlorpExpressions">printOn: aStream	[aStream query] on: Error do: [:ex | ^super printOn: aStream].	(joins at: aStream query resultClass) printOn: aStream.</body><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary 	[aStream query] on: Error do: [:ex | ^super printOn: aStream].	(joins at: aStream query resultClass) printSQLOn: aStream withParameters: aDictionary.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>initialize-release</category><body package="GlorpExpressions">initialize	joins := IdentityDictionary new.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>testing</category><body package="GlorpExpressions">isGlorpExpression	^true.</body><body package="GlorpExpressions">isJoin	^true.</body><body package="GlorpExpressions">isOuterJoin	"It must be all or nothing (or much additional thinking is needed)."	^joins allSatisfy: [:each | each isOuterJoin]</body><body package="GlorpExpressions">shortCircuitOnNullComparison: anIdentityDictionary 	joins do: [:each |		(each shortCircuitOnNullComparison: anIdentityDictionary)			ifFalse: [^false]].	^true.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>preparing</category><body package="GlorpExpressions">asExpressionJoiningSource: sourceExpression toTarget: targetExpression	| expression |	joins do:		[:each |		expression := (each asExpressionJoiningSource: sourceExpression toTarget: targetExpression) OR: expression].	^expression</body><body package="GlorpExpressions">prepareIn: aQuery	"There was a significant problem with horizontal inheritance where a VariableJoin was getting converted into a full expression in a query before that query had time to be converted to a full query and then back into sub-queries. When we did this, it lost information, so the sub-queries would get generated with each one talking to the same sub-table. We therefore delay conversion by not having VariableJoin convert itself to a general expression (so this method is now a no-op instead of	aQuery whereClause: self asGeneralGlorpExpression.as it used to be) which required implementing a bit more protocol on VariableJoin (these changes were integrated in Glorp (0.4.162) on 23oct2007).	This also exposed a subtle bug with subselects where we had a join whose base was not a base expression, and so asking it for ultimateBaseExpression gave the wrong answer. This was fixed by also sending ultimateBaseExpression to the result."</body><body package="GlorpExpressions">rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression	^(self joins at: aBaseExpression descriptor describedClass) 		rebuildOn: aBaseExpression startingFrom: anExpression withOuterScopeBase: ultimateBaseExpression</body><body package="GlorpExpressions">sourceForTarget: aDatabaseField ifNone: aBlock	"Our target fields vary but our source fields are the same;  any match will do"	| eachSourceField |	joins do:		[:each |		eachSourceField := each sourceForTarget: aDatabaseField ifNone: [nil].		eachSourceField isNil ifFalse: [^eachSourceField]].	^aBlock value</body><body package="GlorpExpressions">targetForSource: aField value: aBlock	"Preserve the Join&gt;&gt;targetForSource: behaviour of returning nil if aField is not in my sources.  Since we may assume (see #allSourceFields) that variable joins vary in their targets, not in their sources, treat any nil target as meaning no match.  I rely on the value of the block being the target value of the join's mapping."	| targetsForSource |	targetsForSource := self joins collect: [:each | each targetForSource: aField].	^targetsForSource		detect: [:each | each isNil]		ifNone: [targetsForSource at: aBlock value class ifAbsent: [^nil]]</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>api</category><body package="GlorpExpressions">mapFromSource: sourceObject andTarget: targetObject intoRowsIn: aRowMap	(sourceObject isNil or: [targetObject isNil]) ifTrue: [^self].	^(joins at: targetObject class)		mapFromSource: sourceObject		andTarget: targetObject		intoRowsIn: aRowMap.</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>primary keys</category><body package="GlorpExpressions">primaryKeyFromDictionary: anIdentityDictionary 	^self anyJoin primaryKeyFromDictionary: anIdentityDictionary.</body></methods><methods><class-id>Glorp.VariableJoin class</class-id> <category>instance creation</category><body package="GlorpExpressions">new	^super new initialize.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>accessing</category><body package="GlorpDatabase">at: aField	^self at: aField ifAbsent: [self error: 'missing field'].</body><body package="GlorpDatabase">at: aField ifAbsent: absentBlock	^(self wrapperAt: aField ifAbsent: [^absentBlock value]) contents.</body><body package="GlorpDatabase">at: aField ifAbsentPut: absentBlock	| old |	old := contents at: aField position.	old == self class emptySlot 		ifTrue: absentBlock		ifFalse: [^old contents].</body><body package="GlorpUnitOfWork">at: aField put: aValue 		"For generated fields, we expect the real value to be provided later by the database, so don't write a nil value"		| wrapper |"	aValue isGlorpExpression ifTrue: [self error: 'cannot store expressions in rows']."	aField table == self table ifFalse: [self error: 'Invalid table'].	wrapper := self contentsAt: aField ifAbsentPut: [FieldValueWrapper new].	(aValue isNil and: [aField isGenerated]) ifFalse: [wrapper contents: aValue].	wrapper isNowContainedBy: self and: aField.	^wrapper.</body><body package="GlorpDatabase">atFieldNamed: aString	| field |	field := table fieldNamed: aString.	^self at: field</body><body package="GlorpDatabase">atFieldNamed: aString ifAbsent: aBlock	| field |	field := table fieldNamed: aString ifAbsent: aBlock.	^self at: field ifAbsent: aBlock.</body><body package="GlorpDatabase">atFieldNamed: aString put: anObject	| field |	field := table fieldNamed: aString.	^self at: field put: anObject</body><body package="GlorpDatabase">contentsAt: aField ifAbsentPut: absentBlock	| old newValue |	old := contents at: aField position.	^old == self class emptySlot 		ifTrue: [			newValue := absentBlock value.			contents at: aField position put: newValue.			newValue]		ifFalse: [old].</body><body package="GlorpDatabase">doesNotUnderstand: aMessage	^self atFieldNamed: aMessage selector asString ifAbsent: [super doesNotUnderstand: aMessage].</body><body package="GlorpDatabase">fields	^self table fields select: [:each | (self includesField: each)].</body><body package="GlorpDatabase">forDeletion	^forDeletion.</body><body package="GlorpDatabase">forDeletion: aBoolean	forDeletion := aBoolean.</body><body package="GlorpDatabase">includesField: aField	^(contents at: aField position) ~~ self class emptySlot.</body><body package="GlorpDatabase">lockKeyFields	^table lockKeyFields</body><body package="GlorpDatabase">nonGeneratedFields	"Return a list of our fields that are not generated"	| result |	result := OrderedCollection new: contents size.	self table fields do: [:field | 		field isGenerated not ifTrue: [result add: field]].	^result.</body><body package="GlorpDatabase">nonGeneratedFieldsWithValues	"Return a list of our fields that a) are not generated or b) have values. That is, exclude values we expect the database to generate"	| result |	result := OrderedCollection new: contents size.	self fieldsAndValidValuesDo: [:field :value | 		(value notNil or: [field isGenerated not]) ifTrue: [result add: field]].	^result.</body><body package="GlorpDatabase">nonPrimaryKeyFields	| result |	result := OrderedCollection new: contents size.	self fieldsDo: [:field | 		field isPrimaryKey ifFalse: [result add: field]].	^result.</body><body package="GlorpUnitOfWork">numberOfFields	^contents		inject: 0		into:			[:sum :each | sum + (each == self class emptySlot ifTrue: [0] ifFalse: [1])].</body><body package="GlorpDatabase">oldVersionAt: aField ifAbsent: aBlock	oldVersion isNil ifTrue: [^aBlock value].	^oldVersion at: aField ifAbsent: aBlock.</body><body package="GlorpDatabase">owner	^owner.</body><body package="GlorpDatabase">owner: anObject	owner := anObject.</body><body package="GlorpDatabase">parent	^parent</body><body package="GlorpDatabase">parent: aDatabaseRow	parent := aDatabaseRow.</body><body package="GlorpDatabase">primaryKey	self table primaryKeyFields isEmpty ifTrue: [^nil].	^self table hasCompositePrimaryKey 		ifTrue: [self table primaryKeyFields collect: [:each | self at: each]]		ifFalse: [self at: self table primaryKeyFields first ifAbsent: [nil]]</body><body package="GlorpDatabase">status	^status</body><body package="GlorpDatabase">status: aSymbol	status := aSymbol</body><body package="GlorpDatabase">table	"Private - Answer the value of the receiver's ''table'' instance variable."	^table</body><body package="GlorpDatabase">values	| result |	result := OrderedCollection new.	self keysAndValuesDo: [:key :value |		result add: value].	^result</body><body package="GlorpDatabase">wrapperAt: aField	^self wrapperAt: aField ifAbsent: [self error: 'Field not found'].</body><body package="GlorpDatabase">wrapperAt: aField ifAbsent: aBlock	| thing |	contents isNil ifTrue: [^aBlock value].	thing := contents at: aField position.	^thing == self class emptySlot ifTrue: aBlock ifFalse: [thing].</body><body package="GlorpDatabase">wrapperAt: aField put: aWrapper	| old |	old := contents at: aField position.	old == aWrapper ifTrue: [^self].	contents at: aField position put: aWrapper.	aWrapper isNowContainedBy: self and: aField.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>printing</category><body package="GlorpDatabase">fieldsNeedingUpdate	"Return a list of the fields that are different from the previous version (if we know what that was)"	| result |	oldVersion isNil ifTrue: [^self nonPrimaryKeyFields].	result := OrderedCollection new: contents size.	self fieldsDo: 			[:each | 			each isPrimaryKey 				ifFalse: 					[(oldVersion at: each ifAbsent: [self class missingFieldIndicator]) 						= (self at: each) ifFalse: [result add: each]]].	^result</body><body package="GlorpDatabase">hasOldVersion	^oldVersion notNil</body><body package="GlorpDatabase">printEqualityTemplateForField: aDatabaseField on: aCommand	"This is used by the UpdateCommand and DeleteCommand hierarchies.  We ask the platform for a field's column name to get capitalisation, avoid reserved words, etc., and to avoid a PostgreSQL bug that a qualified name cannot appear in a SET expression."	aCommand nextPutAll: (aDatabaseField platform nameForColumn: aDatabaseField name).	aCommand nextPutAll: ' = '.	aDatabaseField type printValueForField: aDatabaseField inRow: self on: aCommand.</body><body package="GlorpDatabase">printFieldNamesOn: aWriteStream 	GlorpHelper 		do: [:each | aWriteStream nextPutAll: each name]		for: self table fields		separatedBy: [aWriteStream nextPutAll: ','].</body><body package="GlorpDatabase">printLockEqualityForField: aDatabaseField on: aStream	| expression |	expression := ((BaseExpression new getTable: aDatabaseField table) getField: aDatabaseField) get: #= withArguments: (Array with: (oldVersion at: aDatabaseField)).	expression printSQLOn: aStream withParameters: #().</body><body package="GlorpDatabase">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , ((table isNil or: [table name isNil]) ifTrue: [''] ifFalse: [table name]),  ')'.	aStream cr.	self fieldsAndValuesDo: [:eachField :eachWrapper |		aStream nextPutAll: '    '.		eachField printOn: aStream.		aStream nextPutAll: '-&gt;'.		eachWrapper printOn: aStream.		aStream cr.].</body><body package="GlorpDatabase">printPrimaryKeyTemplateOn: aStream	"If there is no primary key (i.e. this is a link table) use all the values that we have"	| fields |	fields := table primaryKeyFields isEmpty 		ifTrue: [self fields]		ifFalse: [table primaryKeyFields].	GlorpHelper		do:  [:eachField |			self printEqualityTemplateForField: eachField on: aStream]		for: fields		separatedBy: [aStream nextPutAll: ' AND '].</body><body package="GlorpDatabase">printValueOfField: aDatabaseField on: aCommand	"This is used by the InsertCommand hierarchy."	aDatabaseField type print: (self at: aDatabaseField ifAbsent: [nil]) on: aCommand.</body><body package="GlorpDatabase">revertLockKeyFields	"We are inly updating relative key fields so will revert the updating of lockKeyFields.  What to do if no oldValue - self class missingFieldIndicator ?"	"oldVersion isNil ifTrue: [self halt: 'think about this'].	to be thought about - do we nil them or not?  Can it happen/matter?"	self lockKeyFields do:		[:each | self at: each forcePut: (oldVersion at: each ifAbsent: [self halt: 'think about this'])].	"^self"</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>initializing</category><body package="GlorpDatabase">fieldsAndValidValuesDo: aBlock 	"If iterating over fields and values, we include wrappers with no value assigned yet. This might or might not be what we want. This one just iterates over ones with actual values"	self isEmpty ifTrue: [^self].	table fields do: [:each |  | value |		value := self at: each ifAbsent: [self class missingFieldIndicator].		value == self class missingFieldIndicator ifFalse: [			aBlock value: each value: value]].</body><body package="GlorpDatabase">fieldsAndValuesDo: aBlock 	table isNil ifTrue: [^self].	table fields do: [:each | aBlock value: each value: (self at: each ifAbsent: [self class missingFieldIndicator])]</body><body package="GlorpDatabase">initialize	shouldBeWritten := true.	forDeletion := false.	generated := false.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>configuring</category><body package="GlorpDatabase">shouldBeWritten: aBoolean 	shouldBeWritten := aBoolean</body><body package="GlorpDatabase">table: aDatabaseTable	table := aDatabaseTable.	contents := Array new: (aDatabaseTable fields size).	contents atAllPut: self class emptySlot.</body><body package="GlorpDatabase">withAllFieldsIn: aRow 	"aRow represents our original state. Make sure that we have all the fields in aRow, using nil values for any that are missing. This is needed if, e.g. we have been removed from a 1-many relationship, so we don't get a value generated for our foreign key, but we should still write it as a nil. We have to distinguish this from the case of a value that simply hasn't changed."	aRow isEmpty ifTrue: [^self].	oldVersion := aRow.	self numberOfFields = table fields size ifTrue: [^self].	aRow fieldsAndValidValuesDo: 			[:eachField :eachValue | 			(self includesField: eachField) ifFalse: [self at: eachField put: nil]].	^self</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>querying</category><body package="GlorpDatabase">expectsToGetValueFor: aField	"Are we constrained to a field which is presumably going to get a value, which for the moment must mean it's a serial type. This is primarily required for identity column databases, because in other cases we will pre-allocate sequence numbers, and this should never come up"	| wrapper innerWrappers testBlock containing |	wrapper := self wrapperAt: aField ifAbsent: [^false].	innerWrappers := wrapper allInnerWrappers.	testBlock := [:eachField | (eachField ~~ aField and: [eachField type isSerial]) ifTrue: [^true]].	(Array with: wrapper), innerWrappers do: [:eachWrapper |		containing := eachWrapper containedBy.		containing glorpIsCollection 			ifTrue: [containing keysDo: testBlock]			ifFalse: [testBlock value: containing key]].	^false.</body><body package="GlorpDatabase">hasValueFor: aField	^(self wrapperAt: aField ifAbsent: [^false]) hasValue.</body><body package="GlorpDatabase">shouldBeWritten	table isNil ifTrue: [^shouldBeWritten].	^shouldBeWritten and: [table shouldBeWritten].</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>sequencing</category><body package="GlorpDatabase">needsValueFromSequence: aSequence 	self table fields do: 			[:each | 			((self shouldGenerateValueFor: each) and: [each type sequence == aSequence]) 				ifTrue: [^true]].	^false</body><body package="GlorpDatabase">postWriteAssignSequencesUsing: anAccessor	self table fields do: [:each |		(self hasValueFor: each) ifFalse: [			each type postWriteAssignSequenceValueFor: each in: self using: anAccessor]].</body><body package="GlorpDatabase">preWriteAssignSequencesUsing: aSession	"Skip if we've already been generated"	generated ifTrue: [^self].	self table fields do: 			[:each | 			(self shouldGenerateValueFor: each in: aSession) 				ifTrue: 					[each type 						preWriteAssignSequenceValueFor: each						in: self						using: (aSession isNil ifTrue: [nil] ifFalse: [aSession accessor])]].	generated := true.</body><body package="GlorpDatabase">shouldGenerateValueFor: aField	^self shouldGenerateValueFor: aField in: nil.</body><body package="GlorpDatabase">shouldGenerateValueFor: aField in: aSession	| isInsert |	aField isGenerated ifFalse: [^false].	aField type generatesOverExistingValues ifTrue: [^true].	"If nil is the value of a field that's not NULLable but has an (image) default, the preWriteAssignSequenceValueFor:in:using: is intended to write the default value instead of nil."	(self shouldMapNilToImDefaultValueFor: aField) ifTrue:[^true].	"For those that don't write over existing values, only update them if this is an insert. Otherwise we can't tell the difference between an empty column and one which we're just not updating in this unit of work. This requires the session, but the session may be nil - if so, default to true, because that usage is just for reserving sequence numbers, and it's better to err on the side of too many."	isInsert := aSession isNil ifTrue: [true] ifFalse: [aSession shouldInsert: self].	^isInsert and: [(self hasValueFor: aField) not].</body><body package="GlorpDatabase">shouldMapNilToImDefaultValueFor: aField	| value |	value := self at: aField ifAbsent: [^false].	^value isNil and: [aField isNullable not and: [aField imDefaultValue notNil]]</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>relationships</category><body package="GlorpDatabase">relatedRowsIn: aRowMap	"This sorting of the rows backs up the sorting that has already occurred in #tablesInCommitOrder.  Although it works via the 'containedBy' of the wrappers, note that it depends on the foreign key constraints.  If a wrapper's 'containedBy' points to another row (e.g. the Smalltalk line	employee1 manager: managerA.causes the 'ManagerID' field's  value in a row for employee1 to be containedBy the 'ID' field's value of a row for managerA, be aware that unless a foreign key relation (in Glorp - it does not have to be also in the database, though that is the default) connects 'ManagerID' and 'ID', this method will not enter rowsRelatedTo: and find that wrapper relation.  This is logical:  if the database has the foreign key constraint, misordering the rows might block the write, otherwise it should not matter.  However if one of a table's fields (key or otherwise) is also an IdentityColumn (i.e. post-write-assigned) primary key of another table, then a Glorp-only foreign key may be of use in getting the post-write-assigned value for the related row(s)."	| relatedRows |	relatedRows := OrderedCollection new.	self table foreignKeyConstraints do:		[:eachConstraint | relatedRows addAll: (eachConstraint rowsRelatedTo: self)].	^relatedRows</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>testing</category><body package="GlorpDatabase">equals: aRow 	self forDeletion = aRow forDeletion ifFalse: [^false].	self fieldsAndValuesDo: 			[:eachField :eachWrapper | 			| otherValue |			otherValue := aRow at: eachField ifAbsent: [self class missingFieldIndicator].			eachWrapper = otherValue ifFalse: [^false]].	^true</body><body package="GlorpDatabase">hash	| basic |	basic := self table hash.	self fieldsAndValuesDo: 			[:eachField :eachValue | 			basic := basic bitXor: eachField hash.			basic := basic bitXor: eachValue hash].	^basic.</body><body package="GlorpDatabase">isEmpty	| empty |	contents isNil ifTrue: [^true].	empty := self class emptySlot.	contents do: [:each | each == empty ifFalse: [^false]].	^true.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>enumerating</category><body package="GlorpDatabase">fieldsDo: aBlock 	1 to: contents size do: [:i |		| value |		value := contents at: i.		(value == self class emptySlot) ifFalse: [aBlock value: (self table fields at: i)]].</body><body package="GlorpDatabase">fieldValuesDo: aBlock 	contents do: [:each | each == self class emptySlot ifFalse: [aBlock value: each]].</body><body package="GlorpDatabase">keysAndValuesDo: aBlock	1 to: contents size do: [:i |		| value | 		value := contents at: i.		value == self class emptySlot ifFalse: [			aBlock value: (self table fields at: i) value: value contents]].</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>comparing</category><body package="GlorpDatabase">= aRow	self class == aRow class ifFalse: [^false].	^self equals: aRow.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>private</category><body package="GlorpUnitOfWork">at: aField forcePut: aValue 	"Write the value. If there's a previous value, overwrite it. Use with extreme caution."	| wrapper |	aValue isGlorpExpression ifTrue: [self error: 'cannot store expressions in rows'].	aField table == self table ifFalse: [self error: 'Invalid table'].	wrapper := self contentsAt: aField ifAbsentPut: [FieldValueWrapper new].	wrapper privateSetContents: aValue.	^wrapper.</body></methods><methods><class-id>Glorp.DatabaseRow</class-id> <category>api</category><body package="GlorpUnitOfWork">unifyField: eachSourceField withField: eachTargetField inRow: targetRow	| sourceWrapper targetWrapper |	sourceWrapper := self wrapperAt: eachSourceField ifAbsent: [nil].	targetWrapper := targetRow wrapperAt: eachTargetField ifAbsent: [nil].	sourceWrapper isNil		ifTrue:			[targetWrapper isNil				ifTrue:					[targetWrapper := FieldValueWrapper new.					targetRow wrapperAt: eachTargetField put: targetWrapper].			^self wrapperAt: eachSourceField put: targetWrapper].	targetWrapper isNil ifTrue: [^targetRow wrapperAt: eachTargetField put: sourceWrapper].	sourceWrapper unifyWith: targetWrapper.</body></methods><methods><class-id>Glorp.DatabaseRow class</class-id> <category>private</category><body package="GlorpDatabase">emptySlot	emptySlot == nil ifTrue: [emptySlot := Object new].	^emptySlot.</body><body package="GlorpDatabase">missingFieldIndicator	missingFieldIndicator == nil ifTrue: [missingFieldIndicator := Object new].	^missingFieldIndicator.</body></methods><methods><class-id>Glorp.DatabaseRow class</class-id> <category>instance creation</category><body package="GlorpDatabase">new	^super new initialize.</body><body package="GlorpDatabase">newForTable: aTable	^self new table: aTable.</body><body package="GlorpDatabase">newForTable: aTable withOwner: anObject	^self new table: aTable; owner: anObject.</body></methods><methods><class-id>Glorp.UniqueConstraint</class-id> <category>accessing</category><body package="GlorpDatabase">generateName	| stream maxLength tableLength roomToBeVerbose shortTableLength longTableLength |	(self fields isNil or: [self fields isEmpty]) ifTrue: [^'INVALID CONSTRAINT'].	"Figure out if we have room for verbose separators or if we should maximize the space for the table/field names"	maxLength := self fields first table platform maximumLengthOfTableName.	shortTableLength := ((maxLength - 7) // 2) min: 10.	longTableLength := (maxLength - 7).	roomToBeVerbose := shortTableLength &gt;= 10.	tableLength := roomToBeVerbose ifTrue: [longTableLength] ifFalse: [shortTableLength].	stream := WriteStream on: (String new: 100).	self printForConstraintNames: self fields on: stream maxLength: tableLength.	stream nextPutAll: (roomToBeVerbose ifTrue: ['_UNIQ'] ifFalse: ['U']).	^stream contents.</body></methods><methods><class-id>Glorp.UniqueConstraint</class-id> <category>printing</category><body package="GlorpDatabase">creationStringFor: aPlatform	^aPlatform createUniqueConstraintAddStatement: self</body><body package="GlorpDatabase">printForConstraintNames: aCollection on: aStream maxLength: maxLength 	| constraintName |	constraintName := self table name.	aCollection do:		[:each | constraintName := constraintName, each name].	constraintName size &gt; maxLength 		ifTrue: [constraintName := constraintName copyFrom: 1 to: maxLength].	aStream nextPutAll: constraintName</body></methods><methods><class-id>Glorp.UniqueConstraint</class-id> <category>testing</category><body package="GlorpDatabase">isUniqueConstraint	^true</body><body package="GlorpDatabase">matchesUniqueConstraint: aConstraint	name asUppercase = aConstraint name asUppercase ifFalse: [^false].	self fields size = aConstraint fields size ifFalse: [^false].	self fields with: aConstraint fields do:		[:each :other | (each matchesField: other) ifFalse: [^false]].	^true</body></methods><methods><class-id>Glorp.UniqueConstraint</class-id> <category>instance creation</category><body package="GlorpDatabase">forTable: aTable fields: aCollectionOfFields	self table: aTable.	self fields: aCollectionOfFields</body></methods><methods><class-id>Glorp.UniqueConstraint class</class-id> <category>instance creation</category><body package="GlorpDatabase">forTable: aTable fields: aCollectionOfFields	| instance |	instance := self new.	instance forTable: aTable fields: aCollectionOfFields.	^instance</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>building objects</category><body package="GlorpQueries">buildersThatReturnResults	"In late 2004, Alan Knight wrote here, 'For some bizarre reason, #includes: fails on ObjectStudio for this', to explain why he used #detect:ifNone: instead of #include. to find a builder's expression in the query's retrievalExpressions.  This is no longer the case:  tests on ObjectStudio 8.9 indicate #includes: is safe to use.  However, although the collection iterated over is a Set, not an IdentitySet, Alan uses ==, not = in both the #detect:ifNone: and the #anySatisfy:.  Currently, that makes no difference for GlorpExpression and subclasses, in which = is never overridden.  Nevetheless it would be inconsistent to check = in one statement and == in the next statement.  I have therefore kept the use of #detect:ifNone: for now.  If GlorpExpression&gt;&gt;= is ever overridden, this comment can guide changes."	buildersThatReturnResults isNil ifTrue:		[buildersThatReturnResults := OrderedCollection new.		builders do:			[:each || expression shouldNotBeRetrieved |			expression := each expression.			shouldNotBeRetrieved := (self query tracing retrievalExpressions				detect: [:foo | foo == expression] ifNone: [nil]) isNil.			(shouldNotBeRetrieved or:				[buildersThatReturnResults anySatisfy:					[:eachBuilder | eachBuilder expression == expression]])				ifFalse: [buildersThatReturnResults add: each]].		buildersThatReturnResults := buildersThatReturnResults asArray].	^buildersThatReturnResults</body><body package="GlorpQueries">buildObjectsForRow: aRow	self query isNil ifTrue: [^aRow].	builders		do:			[:each | each findInstanceForRow: aRow proxyType: self query proxyType].	builders do: [:each | each buildObjectFrom: aRow].	builders		do:			[:each | 			each				sendPostFetchValidateIn: self session 				onFailureDo: [each instance: nil]].	builders		do: [:each | each instance == nil ifFalse: [each knitResultIn: self]].	builders do: [:each | self session sendPostFetchEventTo: each instance].	^self buildersThatReturnResults size = 1		ifTrue: [self buildersThatReturnResults first returnValueIn: self]		ifFalse:			[self buildersThatReturnResults collect: [:each | each returnValueIn: self]].</body><body package="GlorpQueries">collectionTypeFor: aCollectionType	"Make sure that we can reasonably return aCollectionType. If not, default to something we can"	aCollectionType class == GlorpDictionaryDescription ifFalse: [^aCollectionType].	self buildersThatReturnResults size = 1 ifTrue: [^aCollectionType].	^Array.</body><body package="GlorpQueries">elementBuilderFor: anExpression 	^builders detect: [:each | each expression == anExpression] ifNone: [nil].</body><body package="GlorpQueries">hasCompleteAnswerFor: objects	"If we are alsoFetching a toMany relationship, multiple rows can have the same data for the source of that relationship, differing only in their data for its targets.  If the source has primaryKeys, these second and subsequent rows will obtain the identically same instance and that comparison suffices. If a builder that returns a result has a primaryKey with which to fetch an instance out of the cache and its next answer is in fact the same object as its last answer, built from a row of the same data (with, presumably, differing alsoFetch data further along), it will be the identically-same object, otherwise it will merely be an equal but non-identical object."	| nextAnswer |	self atEnd ifTrue: [^true].	self mightHaveDuplicateRows ifFalse: [^true].	nextAnswer := self peek.	"Access instvar directly to avoid its lazy initialization accessor (obviously, for the first line)."	buildersThatReturnResults isNil ifTrue: [^objects ~= nextAnswer].	buildersThatReturnResults size = 1 ifTrue:		[^buildersThatReturnResults first hasSetPrimaryKey			ifTrue: [objects ~~ nextAnswer]			ifFalse: [objects ~= nextAnswer]].	1 to: buildersThatReturnResults size do:		[:index |		(buildersThatReturnResults at: index) hasSetPrimaryKey			ifTrue: [(objects at: index) ~~ (nextAnswer at: index) ifTrue: [^true]]			ifFalse: [(objects at: index) ~= (nextAnswer at: index) ifTrue: [^true]]].	^buildersThatReturnResults isEmpty	"probably needless in actual production to use this instead of false;  makes development safer"</body><body package="GlorpQueries">newCollectionOfSize: aSize for: aCollectionType	"Make sure that we can reasonably return aCollectionType. If not, default to something we can"	| theType |	theType := self collectionTypeFor: aCollectionType.	^theType isBehavior ifTrue: [theType new: aSize] ifFalse: [theType copyEmpty: aSize].</body><body package="GlorpQueries">nextAnswer	| result |	peekBuffer isNil ifFalse: [		result := peekBuffer.		peekBuffer := nil.		^result].	^self nextAnswerFromUnderlyingCursor.</body><body package="GlorpQueries">nextAnswerFromUnderlyingCursor	| objects |	rawPeekBuffer isNil ifTrue: [rawPeekBuffer := cursor next].	rawPeekBuffer isNil ifTrue: [^nil].	objects := self buildObjectsForRow: rawPeekBuffer.	rawPeekBuffer := nil.	^objects.</body><body package="GlorpQueries">objectBuilderFor: anExpression 	"Return the builder for this expression, but only those that directly build compound objects. Most importantly, exclude dictionary builders"	^builders detect: [:each | 		each buildsObjects and: [each expression == anExpression]] ifNone: [nil].</body><body package="GlorpQueries">registerInstances	self session isNil ifTrue: [^self].	builders do: [:each | self session register: each instance].</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>accessing</category><body package="GlorpQueries">command	^command</body><body package="GlorpQueries">command: aDatabaseCommand	command := aDatabaseCommand.	aDatabaseCommand isNil ifTrue: [^self].	aDatabaseCommand query isNil ifTrue: [^self].	databaseAccessor := aDatabaseCommand query session accessor.	builders := self query copyOfBuildersFor: self.</body><body package="GlorpQueries">contents	self shouldNotImplement.</body><body package="GlorpQueries">cursor	^cursor</body><body package="GlorpQueries">cursor: aStream	cursor := aStream</body><body package="GlorpQueries">databaseAccessor: aDatabaseAccessor	databaseAccessor := aDatabaseAccessor</body><body package="GlorpQueries">flush	^self.</body><body package="GlorpQueries">mightHaveDuplicateRows	mightHaveDuplicateRows isNil ifTrue: [mightHaveDuplicateRows := self query isNil ifTrue: [false] ifFalse: [self query mightHaveDuplicateRows]].	^mightHaveDuplicateRows.</body><body package="GlorpQueries">next	| answer session |	self atEnd ifTrue: [^nil].	session := self session.	[self atEnd ifTrue: [^nil].	answer := self nextAnswer.	answer == nil] 		whileTrue.	[self hasCompleteAnswerFor: answer] whileFalse: [self nextAnswer].	session == nil ifFalse: [session privateRegisterAsOld: answer].	^answer.</body><body package="GlorpQueries">next: anInteger	| result |	Dialect isObjectStudio ifFalse: [^super next: anInteger].	result := OrderedCollection new: anInteger.	anInteger timesRepeat: [result add: self next].	^result.</body><body package="GlorpQueries">nextPut: anObject	self shouldNotImplement.</body><body package="GlorpQueries">peek	peekBuffer = nil ifFalse: [^peekBuffer].	peekBuffer := self nextAnswer.	^peekBuffer.</body><body package="GlorpQueries">privateGetBuilders	^builders.</body><body package="GlorpQueries">query	command isNil ifTrue: [^nil].	^command query.</body><body package="GlorpQueries">query: x</body><body package="GlorpQueries">session	^self query isNil ifTrue: [nil] ifFalse: [self query session].</body><body package="GlorpQueries">statement	^statement.</body><body package="GlorpQueries">statement: aGlorpPreparedStatement	statement := aGlorpPreparedStatement.</body><body package="GlorpQueries">upToEnd	| result |	result := WriteStream on: (Array new: 100).	[self atEnd] whileFalse: [			| nextValue |			"Stupid VA's cursors don't deal with atEnd or isEmpty nicely, so check for nil"			nextValue := self next.			nextValue == nil ifFalse: [	result nextPut: nextValue]].	^result contents</body><body package="GlorpQueries">upToEndOfResultSet	"If our statement has multiple result sets, we must use this call, not #upToEnd, to avoid the aggressive releasing of the cursor in #atEnd which would lose any remaining result sets.  This reads the current result set and advances the underlying cursor to the next result set.  (N.B. 'the next result set' does not necessarily mean the return of the next statement;  in a sequence of statements, some may return result sets while others return #noAnswerStream and these will be skipped.)  The cursor is released as part of reading the last result set."	^self accessor upToEndOfResultSet: self</body><body package="GlorpQueries">upToEndOfReturningResultSet	"If our statement has multiple result sets, we must use this call, not #upToEnd, to avoid the aggressive releasing of the cursor in #atEnd which would lose any remaining result sets.  This reads the current result set and advances the underlying cursor to the next result set.  (N.B. 'the next result set' does not necessarily mean the return of the next statement;  in a sequence of statements, some may return result sets while others return #noAnswerStream and these will be skipped.)  The cursor is released as part of reading the last result set."	^self accessor upToEndOfReturningResultSet: self</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>testing</category><body package="GlorpQueries">accessor	^databaseAccessor.</body><body package="GlorpDatabase">atEnd	"Release ourselves fairly aggressively when we hit the end"	| accessor |	peekBuffer isNil ifFalse: [^false].	rawPeekBuffer isNil ifFalse: [^false].	cursor isNil ifTrue: [^true].	"For test purposes, fabricate an accessor if we don't have one, it's not really needed for a non-db stream"	accessor := self accessor isNil ifTrue: [DatabaseAccessor new] ifFalse: [self accessor].	^([accessor isCursorAtEnd: cursor] on: Dialect error do: [:ex | databaseAccessor handleError: ex for: command])		ifTrue:			[self release.			true]		ifFalse: [	"We have to do this, because VA won't answer true to atEnd until we've read past end"			self rawPeek isNil].</body><body package="GlorpQueries">isReadable	^true.</body><body package="GlorpQueries">isWritable	^false.</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>iterating</category><body package="GlorpQueries">collect: aBlock 	| newStream |	newStream := WriteStream on: (Array new: 100).	[self atEnd] whileFalse: [newStream nextPut: (aBlock value: self next)].	^newStream contents</body><body package="GlorpQueries">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone: [self error: 'not found']</body><body package="GlorpQueries">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="GlorpQueries">do: aBlock 	"Evaluate aBlock for each of the elements of the receiver."	[self atEnd]		whileFalse: [aBlock value: self next]</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>initializing</category><body package="GlorpQueries">initialize</body><body package="GlorpQueries">release	super release.	self releaseCursor.	cursor := nil.	rawPeekBuffer := nil.	peekBuffer := nil.	statement isNil		ifFalse:			[databaseAccessor reusePreparedStatements				ifTrue: [statement busy: false]				ifFalse: [statement release].			statement := nil].	databaseAccessor := nil.</body><body package="GlorpQueries">releaseCursor		self accessor isNil		ifFalse:			[self accessor releaseCursor: cursor in: statement.			self accessor completedCommand: command].</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>debugging</category><body package="GlorpQueries">rows	"This will extract all the rows and replace the internal stream with a regular stream on the rows. This is useful for debugging, but in real use rather destroys the purpose of the cursored stream"	| rows |	rows := cursor upToEnd.	self releaseCursor.	cursor := rows readStream.	^rows.</body></methods><methods><class-id>Glorp.GlorpCursoredStream</class-id> <category>private</category><body package="GlorpDatabase">rawPeek	"Peek at the underlying rows, but don't build objects"	rawPeekBuffer isNil ifFalse: [^rawPeekBuffer].	rawPeekBuffer := cursor next.	^rawPeekBuffer.</body></methods><methods><class-id>Glorp.GlorpCursoredStream class</class-id> <category>instance creation</category><body package="GlorpQueries">on: aStream	^self basicNew cursor: aStream.</body><body package="GlorpQueries">on: aStream accessor: aDatabaseAccessor	^(self on: aStream)		databaseAccessor: aDatabaseAccessor.</body><body package="GlorpQueries">on: aStream for: aCommand	^(self on: aStream)		command: aCommand.</body><body package="GlorpQueries">on: aStream for: aCommand accessor: aDatabaseAccessor	^(self on: aStream)		command: aCommand;		databaseAccessor: aDatabaseAccessor.</body></methods><methods><class-id>Glorp.SQLStringCommand</class-id> <category>accessing</category><body package="GlorpDatabase">arrayBoundFields	"Don't have enough information to do this, I don't think"	^#()</body><body package="GlorpDatabase">bindings	^parameters.</body><body package="GlorpDatabase">bindingTypes	^#()</body><body package="GlorpDatabase">maximumLobSizeToRetrieveDirectly	^maximumBlobSizeToRetrieveDirectly</body><body package="GlorpDatabase">maximumLobSizeToRetrieveDirectly: anInteger	maximumBlobSizeToRetrieveDirectly := anInteger</body><body package="GlorpDatabase">parameters	^parameters.</body><body package="GlorpDatabase">parameters: anArray	parameters := anArray</body><body package="GlorpDatabase">parameterTypeSignature	^''</body><body package="GlorpDatabase">setSQLString: aString	sqlString := aString.</body></methods><methods><class-id>Glorp.SQLStringCommand</class-id> <category>executing</category><body package="GlorpDatabase">printSQL	" *** This method was defined by Glorp.DatabaseCommand as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Glorp.SQLStringCommand</class-id> <category>testing</category><body package="GlorpDatabase">succeeded	" *** This method was defined by Glorp.DatabaseCommand as a subclass responsibility.	Replace its body with a proper implementation. *** "	self error: 'Subclass responsibility stub not reimplemented'</body></methods><methods><class-id>Glorp.SQLStringCommand</class-id> <category>initialize-release</category><body package="GlorpDatabase">initialize	super initialize.	maximumBlobSizeToRetrieveDirectly := super maximumLobSizeToRetrieveDirectly.</body></methods><methods><class-id>Glorp.SQLStringCommand class</class-id> <category>instance creation</category><body package="GlorpDatabase">for: aString	^self new setSQLString: aString.</body></methods><methods><class-id>Glorp.PseudoColumnFunction</class-id> <category>printing</category><body package="GlorpExpressions">printSQLOn: aStream withParameters: aDictionary	"I present a RelationExpression as a field to a FieldExpression.  The rightChild of a RelationExpression could be a bound value, but I cannot handle binding.  Even if FieldExpression&gt;&gt;addBoundExpressionsIn: were extended to call me (which would require DatabaseField&gt;&gt;addBoundExpressionIn: to understand it as well, as a no-op) the FieldExpression will call #translateField: on me and rebuild me on its base, so the boundExpression into which I write a bindMarker within the call below will be the same but _not_ identical to the boundExpression cached earlier to find the bind count.  We therefore keep things simple by switching off binding as we print."	"aStream nextPut: $(."	| outerBindingState |	outerBindingState := aStream useBinding.	[aStream useBinding: false.	base printSelectSQLOn: aStream withParameters: aDictionary]		ensure: [aStream useBinding: outerBindingState].	"aStream nextPut: $)."</body><body package="GlorpExpressions">printTreeOn: aStream	aStream nextPutAll: self class name.	aStream nextPut: $(.	alias isNil ifFalse: [aStream nextPutAll: alias].	aStream nextPut: $,; nextPut: $ .	base printTreeOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.PseudoColumnFunction</class-id> <category>testing</category><body package="GlorpExpressions">printsIntoJoins	"The alias is only needed (or wanted) when the expression is printed in a SELECT field list.  As the bug which cased aliases to be printed elsewhere for PrefixFunctions is now fixed, arguably this method is no longer needed, but it serves to abort printing earlier."	^false</body></methods><methods><class-id>Glorp.PseudoColumnFunction</class-id> <category>accessing</category><body package="GlorpExpressions">mappingSequenceName	^base mappingSequenceName</body><body package="GlorpExpressions">table	^self base table</body></methods><methods><class-id>Glorp.PseudoColumnFunction</class-id> <category>copying</category><body package="GlorpExpressions">createFor: arguments withBase: anExpression symbol: aSymbol	arguments isEmpty ifTrue:	"we've set our alias;  normal machinery will handle it"		[^super createFor: #() withBase: anExpression symbol: aSymbol].	anExpression class == RelationExpression ifTrue:			[^(super createFor: #() withBase: anExpression symbol: aSymbol)			alias: arguments first value].	anExpression class == MappingExpression ifTrue:			[^(super createFor: #() withBase: anExpression symbol: aSymbol)			alias: arguments first value].	"assume anExpression has an alias instvar; just set it"	^anExpression alias: arguments first value</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	^#Timetz</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'TIME WITH TIME ZONE'.</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>converting-times</category><body package="GlorpDatabaseTypes">converterForStType: aClass	"Convert as though we were a regular time field, since our Smalltalk object has no time zone information."	^self platform converterNamed: #time.</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Time</body></methods><methods><class-id>Glorp.GlorpPGTimeWithTimeZoneType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">print: aValue on: aStream	"Print as though we were a regular time field, since our Smalltalk object has no time zone information."	self platform time print: aValue on: aStream.</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>As yet unclassified</category><body package="GlorpDatabase">reserveViaBackupMechanism: anInteger in: aSession	"For interbase, the generator mechanism should always work"	self error: 'This should never happen'.</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>sequencing</category><body package="GlorpDatabase">dropString	^'DELETE FROM RDB$GENERATORS        WHERE RDB$GENERATOR_NAME=''', self qualifiedName, ''''.</body><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aDatabaseField in: aDatabaseRow using: anAccessor 	| statement rows pk |	statement := 'select gen_id(' , self qualifiedName 				, ',1) from rdb$database'.	rows := anAccessor executeSQLString: statement.	pk := rows first first.	aDatabaseRow at: aDatabaseField put: pk</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor</body><body package="GlorpDatabase">reserveViaTableSelect: anInteger in: aSession for: aTable	"Interbase returns the top of the generated range in a single row. Do the iteration ourselves"	| rows command max |	command := self		tableSelectCommandFor: aTable		in: aSession		reserving: anInteger.	command parameters: (Array with: anInteger).	command useBinding: false.	rows := aSession accessor executeCommand: command.	max := rows first first.	max - anInteger + 1 to: max do: [:i | self reservedNumbers add: i].</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>public</category><body package="GlorpDatabase">creationString	^'create generator ' , self qualifiedName.</body></methods><methods><class-id>Glorp.FirebirdSequence</class-id> <category>SQL</category><body package="GlorpCore">tableSelectCommandFor: aTable in: aSession reserving: anInteger	"Since tableSelectCommand was never nilled, a second pundle version reusing this sequence used to get an SQL string embedding the first's integer value.  If it was a version of a different pundle, its integer probably differed;  when a call to reserve e.g. 1233 returns a maximum got by reusing the prior version's call to reserve e.g. 85, the result is 1148 duplicate keys.  If #insertOnly was set,  replication failed on an illegal command.  If we reached one of the fix-up states where it was not, then our cache assured us we were updating and we happily overwrote e.g. the blob for a class definition with that for a method definition (as I experienced :-/).  As sequences are set in the descriptor system and reused, this persisted until the session was discarded or its system was revised.  We now check the integer."	| stream useBinding |	"Binding into this doesn't seem to work"	useBinding := false.	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:		[stream := WriteStream on: (String new: 200).		stream nextPutAll: 'select gen_id('.		stream nextPutAll: self qualifiedName.		stream nextPut: $,.		stream nextPutAll: (useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).		stream nextPutAll: ') from rdb$database'.		tableSelectCommand := SQLStringSelectCommand new.		tableSelectCommand parameters: (Array with: anInteger).		tableSelectCommand setSQLString: stream contents.		tableSelectCommand session: aSession].	^tableSelectCommand</body></methods><methods><class-id>Glorp.PGSequence</class-id> <category>SQL</category><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aDatabaseField in: aDatabaseRow using: anAccessor	| statement rows pk |	"this could be made smarter by aggregating keys to fetch into a single sql query - maybe later -tb"	statement := 'select nextval(''',  self qualifiedName, ''')'.	rows := anAccessor executeSQLString: statement.	pk := rows first first.	aDatabaseRow at: aDatabaseField put: pk.</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aDatabaseField in: aDatabaseRow using: anAccessor"No-op;  for user information, we show, commented, the code that was provided here circa Glorp 0.2.*.	aDatabaseRow at: aDatabaseField		put: (aSession accessor 				executeSQLString: 'SELECT CURRVAL(' , self qualifiedName 	, ')')."</body><body package="GlorpDatabase">reserveViaBackupMechanism: anInteger in: aSession	"The regular mechanism didn't work, (probably because there weren't enough rows in the table), try a different technique."	| command row |	command := self backupReserveCommand: anInteger in: aSession.	row := (aSession accessor executeCommand: command) first.	self reservedNumbers addAll: row.</body><body package="GlorpCore">tableSelectCommandFor: aTable in: aSession reserving: anInteger	| stream |	(tableSelectCommand notNil and: [tableSelectCommand parameters includes: anInteger]) ifFalse:			[stream := WriteStream on: (String new: 200).			stream nextPutAll: 'select nextval('.			self qualifiedName printOn: stream.			stream nextPutAll: ') from ' , aTable name.			stream nextPutAll: ' limit '.			stream nextPutAll: (aSession useBinding ifTrue: ['?'] ifFalse: [anInteger printString]).			tableSelectCommand := SQLStringSelectCommand new.			tableSelectCommand parameters: (Array with: anInteger).			tableSelectCommand setSQLString: stream contents.			tableSelectCommand session: aSession].	^tableSelectCommand.</body><body package="GlorpDatabase">tableToSelectFromIn: session for: aTable	"Sometimes it's inefficient to select sequence values against our own table and we can use a database-specific system table instead to be much faster. Subclasses can override where this is the case"	^(session databaseTableClass named: 'pg_attribute').</body></methods><methods><class-id>Glorp.PGSequence</class-id> <category>private</category><body package="GlorpCore">backupReserveCommand: anInteger in: aSession	| stream command |	stream := WriteStream on: (String new: 200).	stream nextPutAll: 'select '.	GlorpHelper		print: [:i | 'nextval(''' , self qualifiedName , ''')']		on: stream		for: (1 to: anInteger)		separatedBy: ','.	command := SQLStringSelectCommand new.	command setSQLString: stream contents.	command parameters: (Array with: anInteger).	command session: aSession.	^command.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>accessing</category><body package="GlorpDatabase">addSourceField: aField	(self sourceFields allSatisfy: [:each | aField table = each table]) ifFalse: [self error: 'Fields in foreign key constraints must all have the same source table'].	self sourceFields add: aField.</body><body package="GlorpDatabase">addTargetField: aField	(self targetFields allSatisfy: [:each | aField table = each table]) ifFalse: [self error: 'Fields in foreign key constraints must all have the same target table'].	self targetFields add: aField.</body><body package="GlorpDatabase">someSourceField	"Return any one of our source fields"	^self sourceFields first</body><body package="GlorpDatabase">sourceField: aField	self sourceFields isEmpty ifFalse: [self error: 'Adding a field to a non-empty constraint'].	self sourceFields add: aField.</body><body package="GlorpDatabase">sourceFields	^sourceFields</body><body package="GlorpDatabase">sourceFields: aCollection		sourceFields := aCollection.</body><body package="GlorpDatabase">sourceTable	"All the source fields have to come from the same table, so just pick one"	^self someSourceField table</body><body package="GlorpDatabase">suffixExpression	^suffixExpression</body><body package="GlorpDatabase">suffixExpression: anObject	suffixExpression := anObject.</body><body package="GlorpDatabase">table	^self sourceTable.</body><body package="GlorpDatabase">targetField: aField	self targetFields isEmpty ifFalse: [self error: 'Adding a field to a non-empty constraint'].	self targetFields add: aField.</body><body package="GlorpDatabase">targetFields	^targetFields</body><body package="GlorpDatabase">targetFields: aCollection	targetFields := aCollection.</body><body package="GlorpDatabase">targetTable	"All the target fields have to come from the same table, so just pick one"	^self targetFields isEmpty ifTrue: [nil] ifFalse: [self targetFields first table].</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>initializing</category><body package="GlorpDatabase">initialize	self sourceFields: (OrderedCollection new: 2).	targetFields := OrderedCollection new: 2.</body><body package="GlorpDatabase">sourceField: aDatabaseField targetField: anotherDatabaseField	self		sourceField: aDatabaseField		targetField: anotherDatabaseField		suffixExpression: nil.</body><body package="GlorpDatabase">sourceField: aDatabaseField targetField: anotherDatabaseField suffixExpression: suffixExpressionString	self		sourceField: aDatabaseField;		targetField: anotherDatabaseField;		suffixExpression: suffixExpressionString.</body><body package="GlorpDatabase">sourceFields: sourceFieldCollection targetFields: targetFieldCollection suffixExpression: suffixExpressionString	self		sourceFields: sourceFieldCollection;		targetFields: targetFieldCollection;		suffixExpression: suffixExpressionString.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>testing</category><body package="GlorpDatabase">isForeignKeyConstraint	^true</body><body package="GlorpDatabase">isImaginary	^self targetTable isImaginary or: [self sourceTable isImaginary].</body><body package="GlorpDatabase">refersToTable: aTable	^self targetTable yourself == aTable.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>comparing</category><body package="GlorpDatabase">isSimilarForeignKeyConstraint: aConstraint	"We need to sort source and target fields in unison because the ordering of source and targets is fixed. Example,		FK1 source(X, Y) =&gt; target(A, B)		FK2 source(Y, X) =&gt; target(A, B)Sorting the fields individually would hide the fact that X=&gt;A in FK1, whereas X=&gt;B in FK2.  But, not sorting,		FK1 source(X, Y) =&gt; target(A, B)		FK2 source(Y, X) =&gt; target(B, A)would miss the fact that these two fkeys are the same."	| fieldSize sortedSelfIndexes sortedConsIndexes |	"No need to check target fields as sizes always equal, so source good means both good"	(fieldSize := self sourceFields size) = aConstraint sourceFields size ifFalse: [^false].	"An = result in the last line of the sort should never happen since two identical constraints makes no sense"	sortedSelfIndexes := (1 to: fieldSize) sorted:		[:a :b |		(self sourceFields at: a) &lt; (self sourceFields at: b) or:			[(self sourceFields at: a) = (self sourceFields at: b) and:				[(self targetFields at: a) &lt; (self targetFields at: b)]]].	sortedConsIndexes := (1 to: fieldSize) sorted:		[:a :b |		(aConstraint sourceFields at: a) &lt; (aConstraint sourceFields at: b) or:			[(aConstraint sourceFields at: a) = (aConstraint sourceFields at: b) and:				[(aConstraint targetFields at: a) &lt; (aConstraint targetFields at: b)]]].	sortedSelfIndexes with: sortedConsIndexes do:		[:selfIndex :conIndex |		(((self sourceFields at: selfIndex) matchesField: (aConstraint sourceFields at: conIndex)) and:			[(self targetFields at: selfIndex) matchesField: (aConstraint targetFields at: conIndex)])				ifFalse: [^false]].	^true</body><body package="GlorpDatabase">isTheSameAs: aForeignKeyConstraint	"Validate that two constraints are exactly the same. Most useful for testing purposes, rather than normal usage, which is why we don't just use the #= method.	All the code after the #shouldCreateInDatabase check is identical to the #isSimilarForeignKeyConstraint: method, except that it uses #matchesField: where we use #isTheSameAs:.  Ideally, we would merge the two methods and eliminate the nearly-cloned code."	| fieldSize sortedSelfIndexes sortedConsIndexes |	self name asUppercase = aForeignKeyConstraint name asUppercase ifFalse: [^false].	self suffixExpression = aForeignKeyConstraint suffixExpression ifFalse: [^false].	self shouldCreateInDatabase = aForeignKeyConstraint shouldCreateInDatabase ifFalse: [^false].	"No need to check target fields as sizes always equal, so source good means both good"	(fieldSize := self sourceFields size) = aForeignKeyConstraint sourceFields size ifFalse: [^false].	"An = result in the last line of the sort should never happen since two identical constraints makes no sense"	sortedSelfIndexes := (1 to: fieldSize) sorted:		[:a :b |		(self sourceFields at: a) &lt; (self sourceFields at: b) or:			[(self sourceFields at: a) = (self sourceFields at: b) and:				[(self targetFields at: a) &lt; (self targetFields at: b)]]].	sortedConsIndexes := (1 to: fieldSize) sorted:		[:a :b |		(aForeignKeyConstraint sourceFields at: a) &lt; (aForeignKeyConstraint sourceFields at: b) or:			[(aForeignKeyConstraint sourceFields at: a) = (aForeignKeyConstraint sourceFields at: b) and:				[(aForeignKeyConstraint targetFields at: a) &lt; (aForeignKeyConstraint targetFields at: b)]]].	sortedSelfIndexes with: sortedConsIndexes do:		[:selfIndex :conIndex |		(((self sourceFields at: selfIndex) isTheSameAs: (aForeignKeyConstraint sourceFields at: conIndex)) and:			[(self targetFields at: selfIndex) isTheSameAs: (aForeignKeyConstraint targetFields at: conIndex)])				ifFalse: [^false]].	^true.</body><body package="GlorpDatabase">matchesForeignKeyConstraint: aConstraint	"This expects the constraints to have their fields in the same order.  To compare constraints that may be the same up to having been defined in different orders, use #isTheSameAs: or #isSimilarForeignKeyConstraint:."	name asUppercase = aConstraint name asUppercase ifFalse: [^false].	self sourceFields size = aConstraint sourceFields size ifFalse: [^false].	self sourceFields with: aConstraint sourceFields do:		[:field1 :field2 | (field1 matchesField: field2) ifFalse: [^false]].	self targetFields size = aConstraint targetFields size ifFalse: [^false].	self targetFields with: aConstraint targetFields do:		[:field1 :field2 | (field1 matchesField: field2) ifFalse: [^false]].	^true</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>converting</category><body package="GlorpDatabase">asJoin	^Join fromAll: self sourceFields toAll: self targetFields.</body><body package="GlorpDatabase">asReverseJoin	^Join fromAll: self targetFields toAll: self sourceFields.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>printing</category><body package="GlorpDatabase">creationStringFor: aPlatform	^aPlatform createForeignKeyConstraintAddStatement: self</body><body package="GlorpDatabase">generateName	| stream maxLength tableLength roomToBeVerbose shortTableLength longTableLength |	self sourceFields isEmpty ifTrue: [^'INVALID CONSTRAINT'].	"Figure out if we have room for verbose separators or if we should maximize the space for the table/field names"	maxLength := self sourceFields first table platform maximumLengthOfTableName.	shortTableLength := ((maxLength - 8) // 2) min: 10.	longTableLength := (maxLength // 2) - 1.	roomToBeVerbose := shortTableLength &gt;= 10.	tableLength := roomToBeVerbose ifTrue: [shortTableLength] ifFalse: [longTableLength].	stream := WriteStream on: (String new: 100).	self printForConstraintName: self sourceFields first on: stream maxLength: tableLength.	roomToBeVerbose ifTrue: [stream nextPutAll: '_TO_'].	self printForConstraintName: self targetFields first on: stream maxLength: tableLength.	stream nextPutAll: (roomToBeVerbose ifTrue: ['_REF'] ifFalse: ['R']).	^stream contents.</body><body package="GlorpDatabase">printForConstraintName: aField on: aStream maxLength: maxLength 	| constraintName |	constraintName := aField table name , '_' , aField name.	constraintName size &gt; maxLength 		ifTrue: [constraintName := constraintName copyFrom: 1 to: maxLength].	aStream nextPutAll: constraintName</body></methods><methods><class-id>Glorp.ForeignKeyConstraint</class-id> <category>relationships</category><body package="GlorpDatabase">rowsRelatedTo: aRow	| myWrapper relatedRows sourceField targetField allWrappers |	"Note that we don't care which field, as presumably all of them must point the same place for a composite key, so grab the first pair"	sourceField := self sourceFields first.	targetField := self targetFields first.	myWrapper := aRow wrapperAt: sourceField ifAbsent: [nil].	myWrapper isNil ifTrue: [^#()].	relatedRows := Set new: 5.	allWrappers := OrderedCollection with: myWrapper.	allWrappers addAll: myWrapper allInnerWrappers.	allWrappers		do: [:eachWrapper |			(eachWrapper containedBy glorpAtIdentity: targetField ifAbsent: [#()])				do: [:eachRow | eachRow == aRow ifFalse: [relatedRows add: eachRow]]].	^relatedRows.</body></methods><methods><class-id>Glorp.ForeignKeyConstraint class</class-id> <category>instance creation</category><body package="GlorpDatabase">sourceField: aDatabaseField targetField: anotherDatabaseField	^self		sourceField: aDatabaseField		targetField: anotherDatabaseField		suffixExpression: nil.</body><body package="GlorpDatabase">sourceField: aDatabaseField targetField: anotherDatabaseField suffixExpression: suffixExpression	^(self new)		sourceField: aDatabaseField targetField: anotherDatabaseField suffixExpression: suffixExpression;		yourself.</body><body package="GlorpDatabase">sourceFields: sourceFields targetFields: targetFields	^self		sourceFields: sourceFields		targetFields: targetFields		suffixExpression: nil.</body><body package="GlorpDatabase">sourceFields: sourceFields targetFields: targetFields suffixExpression: suffixExpression	^(self new)		sourceFields: sourceFields targetFields: targetFields suffixExpression: suffixExpression;		yourself.</body></methods><methods><class-id>Glorp.InsertSelectRowsCommand</class-id> <category>executing</category><body package="GlorpDatabase">allRowsGrouped: maxSizeInteger evaluate: aBlock	"An ad-hoc mapping can create a situation in which the identity column value that the server will assign to one row is transformed into another value in another row in this same batch of rows.  Rather than try to compute which batches can be safely run in which order, we immediately give up and revert to running each row singly.  The typical case is an array of chained blobs; see the calling chain above and below #blobToDatabaseForRows:nextBlob:nextBlobRows: for an example."	self identityColumnValueReusedInLaterRow		ifTrue: [self allRowsSinglyEvaluate: aBlock]		ifFalse: [super allRowsGrouped: maxSizeInteger evaluate: aBlock].</body><body package="GlorpDatabase">allRowsSinglyEvaluate: aBlock	"Run each row singly."	| theRows |	theRows := allRows.	allRows := nil.	theRows do:		[:each |		self row: each.		allRows := Array with: each.		aBlock value].	"We're finished;  reset me back to my start state."	allRows := theRows.	self row: allRows first.</body><body package="GlorpDatabase">postWriteAssignSequenceInRoundTrip: result	"Capture the IDs generated by SQL Server for the IDENTITY column.  For reasons unknown, SQL Server unbound and batch-bound returns all the IDs in a single answer stream, whereas array-bound returns them in separate answer streams, one for each inserted row."	(useBinding and: [session platform usesArrayBindingToGroupWrite])		ifTrue:			[allRows do:				[:ithrow |				ithrow					at: identityColumn					put: (result upToEndOfResultSet first atIndex: 1)]]		ifFalse:			[allRows with: result upToEnd do:				[:ithrow :ithid |				ithrow					at: identityColumn					put: (ithid atIndex: 1)]].</body><body package="GlorpDatabase">printSQL	"Declare a pseudo-table with column to hold the server-generated identity column values, so we can select them."	self nextPutAll: self declareTableOfIdentitiesStatement.	super printSQL.</body><body package="GlorpDatabase">printSQLForFirstRow: aRow	"The same SQL as the super call except with insertion of OUTPUT of the server-generated identity column ids to the declared table () ."	| fields |	self nextPutAll: 'INSERT INTO '.	aRow table printSQLOn: self withParameters: #().	fields := self arrayBoundFields.	self space; nextPut: $(.	GlorpHelper		do: [:each | self nextPutAll: (self platform nameForColumn: each name)]		for: fields		separatedBy: [self nextPut: $,].	self nextPut: $).	"Except for inlining the shouldUseGroupWriting call, the following line is the only change from super"	self nextPutAll: (self outputAddedIdentityColumnValuesIntoTable: identityColumn).	self nextPutAll: '  VALUES ('.	GlorpHelper		do: [:each | (self canBind: (aRow at: each ifAbsent: [nil]) to: each type)					ifTrue: [self nextPutBindMarkerIn: nil]					ifFalse: [aRow printValueOfField: each on: self]]		for: fields		separatedBy: [self nextPut: $,].	self nextPut: $).</body></methods><methods><class-id>Glorp.InsertSelectRowsCommand</class-id> <category>private-accessing</category><body package="GlorpDatabase">declareTableOfIdentitiesStatement	"There is a technique offered for SQL Server array inserts to tables with an identity column.	The automatically inserted identity values are returned to Glorp for updating the row values.	The technique uses three separate but related queries, with the second one resembling the usual	insert statement (with an OUTPUT clause imposed). Here's a typical example:		INSERT INTO dbo.TAX (NAME,TYPE,TAX_ID) VALUES (?,?,?)	becomes:		'DECLARE @TableOfIdentities TABLE (IdentValue INT);		INSERT INTO dbo.TAX (NAME,TYPE,TAX_ID) OUTPUT Inserted.ID INTO @TableOfIdentities(IdentValue)  VALUES (?,?,?);		SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue'	This method returns the first line above."	^'DECLARE @TableOfIdentities TABLE (IdentValue INT); '</body><body package="GlorpDatabase">outputAddedIdentityColumnValuesIntoTable: idFieldName	"This addition to the INSERT statement puts the server-added ids into a table (see #declareTableOfIdentitiesStatement)."	^'  OUTPUT Inserted.', idFieldName name, ' INTO @TableOfIdentities(IdentValue)'</body><body package="GlorpDatabase">selectAddedIdentityColumnValues	"This select must be run in the same round trip as the insert that added the values.  It reads the table defined in #declareTableOfIdentitiesStatement, which was populated by the OUTPUT ... expression added in #outputAddedIdentityColumValuesIntoTable:."	^'; SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue'</body></methods><methods><class-id>Glorp.InsertSelectRowsCommand</class-id> <category>testing</category><body package="GlorpDatabase">identityColumnValueReusedInLaterRow	"Do I have a server-assigned id that will be reused in another row in this batch.  If so, it may be unsafe to group the values."	allRows do:		[:each || sameTableContainers | sameTableContainers := false.		(each wrapperAt: identityColumn) containedBy keysAndValuesDo:			[:eachKey :eachValue |			sameTableContainers ifTrue: [^true].	"two rows use this value;  unsafe to group"			eachKey table = each table ifTrue: [sameTableContainers := true]]].	^false</body><body package="GlorpDatabase">supportsGroupWriting	^true</body></methods><methods><class-id>Glorp.InsertSelectRowsCommand</class-id> <category>accessing</category><body package="GlorpDatabase">arrayBoundFields	"For the special case where our array has only one row, use singleRowBoundFields."	^self shouldUseGroupWriting		ifTrue: [super arrayBoundFields]		ifFalse: [self singleRowBoundFields]</body></methods><methods><class-id>Glorp.GlorpRowSorter</class-id> <category>sorting</category><body package="GlorpUnitOfWork">childrenOf: anItem	^childCache at: anItem ifAbsentPut: [		childSelector isSymbol			ifTrue: [anItem perform: childSelector]			ifFalse: [childSelector value: anItem]].</body><body package="GlorpUnitOfWork">currentChildren	^self childrenOf: current.</body><body package="GlorpUnitOfWork">currentItemIsDone	^current status = #done.</body><body package="GlorpUnitOfWork">currentItemIsInProgress	^current status = #visitedOnce.</body><body package="GlorpUnitOfWork">currentItemIsNew	^current status = #notVisited.</body><body package="GlorpUnitOfWork">hasSomethingToProcess	self next.	^current notNil.</body><body package="GlorpUnitOfWork">initialVisit	| children |	children := self currentChildren select: [:each  | each status == #notVisited].	children do: [:each | each parent: current].	queue addAll: children.	current status: #visitedOnce.	children isEmpty ifTrue: [queue add: current].</body><body package="GlorpUnitOfWork">next	queue isEmpty ifTrue: [		| candidate |		candidate := items detect: [:each | each status == #notVisited] ifNone: [nil].		candidate isNil ifTrue: [			"We're probably at the end, but check again for part-way done nodes, which can happen if there are heavy cycles"			items reset. 			candidate := items detect: [:each | each status == #visitedOnce] ifNone: [nil]].		candidate isNil ifFalse: [queue add: candidate]].	current := queue isEmpty ifTrue: [nil] ifFalse: [queue removeFirst].</body><body package="GlorpUnitOfWork">processCurrent	self currentItemIsNew ifTrue: [^self initialVisit].	self currentItemIsInProgress ifTrue: [^self secondVisit].	self currentItemIsDone ifTrue: [^self].	self error: 'Unknown item status'.</body><body package="GlorpUnitOfWork">secondVisit	sorted add: current.	current status: #done.	current parent isNil		ifFalse:			[((self childrenOf: current parent)				allSatisfy: [:each | each status == #done])				ifTrue: [queue add: current parent].			current parent: nil].</body><body package="GlorpUnitOfWork">sort: aCollection	items := aCollection readStream.	aCollection do: [:each | each status: #notVisited].	[self hasSomethingToProcess] whileTrue: [self processCurrent].	^sorted.</body></methods><methods><class-id>Glorp.GlorpRowSorter</class-id> <category>accessing</category><body package="GlorpUnitOfWork">getChildrenVia: aSelector	childSelector := aSelector.</body></methods><methods><class-id>Glorp.GlorpRowSorter</class-id> <category>initializing</category><body package="GlorpUnitOfWork">initialize	queue := OrderedCollection new: 100.	sorted := OrderedCollection new: 100.	childCache := IdentityDictionary new: 100.</body></methods><methods><class-id>Glorp.GlorpRowSorter class</class-id> <category>instance creation</category><body package="GlorpUnitOfWork">new	^super new initialize.</body></methods><methods><class-id>Glorp.TimestampVersionGenerator</class-id> <category>sequencing</category><body package="GlorpDatabase">nextValueFor: aField in: aRow	"If a platform maps the timestamp class to something else (e.g. SQLite maps timestamps to strings as it has no support for time-related types), then it must be allowed to do so here as well.  For most platforms, the wrapping #toTimestamp:for: call will be a noop."	^aField type platform		toTimestamp: Dialect timestampNow		for: aField type</body></methods><methods><class-id>Glorp.GlorpMSSQLFloatType</class-id> <category>SQL</category><body package="GlorpDatabaseTypes">converterForStType: aClass	^self platform converterNamed: #numberToDouble.</body><body package="GlorpDatabaseTypes">typeString	^'float'.</body></methods><methods><class-id>Glorp.GlorpMSSQLFloatType</class-id> <category>converting</category><body package="GlorpDatabaseTypes">impliedSmalltalkType	^Float.</body></methods><methods><class-id>Glorp.GlorpMSSQLFloatType</class-id> <category>exdi specific</category><body package="GlorpDatabaseTypes">exdiType	"Return a symbol that the VisualWorks EXDI uses to indicate the database type -- this is a symbol which is often the name of a Smalltalk class, but with variations for multiple db types that correspond to the same Smalltalk symbol. It also varies by Database. This is equivalent to the values returned by methods like #odbcConversion or #oracleConversion"	^#Float.</body></methods><methods><class-id>Glorp.GlorpMSSQLFloatType</class-id> <category>initialize</category><body package="GlorpDatabaseTypes">initialize	super initialize.	typeString := 'float'.</body></methods><methods><class-id>Glorp.HorizontalTypeResolver</class-id> <category>testing</category><body package="GlorpMappings">isTypeMappingRoot: aDescriptor	^aDescriptor == rootDescriptor</body><body package="GlorpMappings">supportsOrderingFor: aDescriptor	concreteMembers detect: [:each | each == aDescriptor] ifNone: [^false].	^true.</body><body package="GlorpMappings">supportsUsingSingleQuery	"Return true if we should attempt to combine queries for multiple subclasses in disjoint tables into one."	^system platform supportsSingleQueryHorizontalInheritance</body></methods><methods><class-id>Glorp.HorizontalTypeResolver</class-id> <category>accessing</category><body package="GlorpMappings">allTablesFor: aDescriptor	"Return all tables used by this descriptor or its subclasses."	^(self descriptorsRequiringIndependentQueriesFor: aDescriptor describedClass) inject: OrderedCollection new into: [:sum :eachDescriptor |		sum addAll: ((eachDescriptor == aDescriptor) ifTrue: [eachDescriptor tables] ifFalse: [eachDescriptor allTables]).		sum].</body><body package="GlorpMappings">classesRequiringIndependentQueriesFor: aClass	^(self descriptorsRequiringIndependentQueriesFor: aClass) collect: [:each |		each describedClass].</body><body package="GlorpMappings">describedConcreteClassFor: row withBuilder: builder descriptor: aDescriptor	^aDescriptor describedClass</body><body package="GlorpMappings">descriptorsRequiringIndependentQueriesFor: aClass	^self concreteMembers select: [ :each | each describedClass includesBehavior: aClass ].</body><body package="GlorpMappings">shouldUseSingleQuery	"Return true if we should attempt to combine queries for multiple subclasses in disjoint tables into one."	shouldUseSingleQuery isNil ifTrue: [shouldUseSingleQuery := false].	^shouldUseSingleQuery.</body><body package="GlorpMappings">useSingleQuery: aBoolean	shouldUseSingleQuery := aBoolean</body><body package="GlorpMappings">useSingleQueryIfPossible: aBoolean	"Use single query if the platform allows it. Otherwise, don't."	shouldUseSingleQuery := aBoolean and: [self supportsUsingSingleQuery]</body></methods><methods><class-id>Glorp.HorizontalTypeResolver</class-id> <category>query setup</category><body package="GlorpMappings">mappingForSubclass: aDescriptor connectTo: existingSubclassMapping	"Create a pseudo-mapping for the subclass."	| attributeName mapping newJoin |	attributeName := self pseudoAttributeNameForClass: aDescriptor describedClass.	mapping := self rootDescriptor mappingForAttributeNamed: attributeName.	mapping isNil ifTrue: [		rootDescriptor classModel newAttributeNamed: attributeName type: aDescriptor describedClass.		mapping := (rootDescriptor newMapping: OneToOneMapping)			attributeName: attributeName.		mapping beForPseudoVariable.		existingSubclassMapping isNil ifFalse: [			newJoin := Join new.			mapping join: newJoin]].	^mapping.</body><body package="GlorpMappings">pseudoAttributeNameForClass: aClass	^('subclassPseudoVariable', aClass name) asSymbol.</body><body package="GlorpMappings">setUpExpressionsForQuery: aQuery	| mapping firstMapping allDescriptors |	(self concreteMembers includes: aQuery resultClass) ifTrue: [^self].	self shouldUseSingleQuery ifFalse: [^self].	allDescriptors := self		descriptorsRequiringIndependentQueriesFor: aQuery resultClass.	allDescriptors size = 1 ifTrue: [^self].	allDescriptors do:		[:eachSubclassDescriptor | 		mapping := self			mappingForSubclass: eachSubclassDescriptor			connectTo: firstMapping.		firstMapping isNil ifTrue: [firstMapping := mapping].		aQuery alsoFetch:			[:object | (object getMapping: mapping named: mapping attribute name) bePhantom beOuterJoin]].</body></methods><methods><class-id>Glorp.HorizontalTypeResolver class</class-id> <category>instance creation</category><body package="GlorpMappings">forRootClass: aClass	^self new		rootClass: aClass;		yourself.</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>testing</category><body package="GlorpMappings">controlsTables	"Return true if this type of method 'owns' the tables it's associated with, and expression nodes using this mapping should alias those tables where necessary"	^false</body><body package="GlorpMappings">isRelationship	"True when the mapping associates different persistent classes."	^false</body><body package="GlorpMappings">isStoredInSameTable	^true</body><body package="GlorpMappings">mappedFields	"Return a collection of fields that this mapping will write into any of the containing object's rows"	^Array with: self field</body><body package="GlorpMappings">mapsSimpleObject	^true.</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>mapping</category><body package="GlorpMappings">buildQuery	"We just want to read our main object back again. So we create a join from our primary key fields to themselves. One side will remain field references, the other side will turn into parameters when it's converted to a where clause."	| whereClause builtQuery |	whereClause := Join new.	descriptor primaryTable primaryKeyFields do:		[:each | whereClause addSource: each target: each].	builtQuery := Query readOneOf: descriptor describedClass where: whereClause.	builtQuery retrieve: self attribute name.	builtQuery session: self session.	^builtQuery</body><body package="GlorpMappings">convertValueToDatabaseForm: aValue		converter isNil ifTrue: [^aValue].	^converter convertedDbValueOf: aValue.</body><body package="GlorpMappings">expressionFor: anObject basedOn: anExpression relation: aSymbol	"Return our expression using the object's values. e.g. if this was a direct mapping from id-&gt;ID and the object had id: 3, then return TABLE.ID=3"	| value |	value := anObject isNil		ifTrue: [nil]		ifFalse:			[anObject isGlorpExpression				ifTrue: [anObject getMapping: self named: self attributeName]				ifFalse: [anObject glorpIsCollection					ifTrue: [anObject collect: [:each | attribute getValueFrom: each]]					ifFalse: [attribute getValueFrom: anObject]]].	^(anExpression get: self attribute name) get: aSymbol withArguments: (Array with: value).</body><body package="GlorpMappings">mapFromObject: anObject intoRowsIn: aRowMap	^self mapFromObject: anObject toTarget: anObject puttingRowsIn: aRowMap.</body><body package="GlorpMappings">mapFromObject: anObject toTarget: target puttingRowsIn: aRowMap	| dbValue value row |	self canWrite ifFalse: [^self].	value := self getValueFrom: anObject.	value := self session realObjectFor: value ifNone: [^self].	dbValue := self convertedDbValueOf: value.	row := aRowMap findOrAddRowForTable: self field table withKey: target.	row at: field put: dbValue.</body><body package="GlorpMappings">mapObject: anObject inElementBuilder: anElementBuilder	| value |	self shouldProxy ifTrue: [		^self setValueIn: anObject to: ((self newProxyIn: anElementBuilder)						session: descriptor session;						parameters: (self parametersIn: anElementBuilder);						glorpOwner: anObject)].	value := self valueInBuilder: anElementBuilder.	self setValueIn: anObject to: value.</body><body package="GlorpMappings">parametersIn: anElementBuilder	| parameters |	parameters := IdentityDictionary new.	descriptor primaryTable primaryKeyFields do: [:each | parameters at: each put: (anElementBuilder valueOfField: each)].	^parameters.</body><body package="GlorpMappings">query	query isNil ifTrue: [query := self buildQuery].	^query</body><body package="GlorpMappings">queryFor: anObjectBuilder	"If we have a specific query we should use in this case, rather than our general one, construct it. Right now that only applies if we're using filtered reads"	^self query.</body><body package="GlorpMappings">readBackNewRowInformationFor: anObject fromRowsIn: aRowMap	"If the database server assigned the value (i.e. the field is an identity column, or has a default value) or is relative, we need to write the value back into the image objects."	| value row |	(field isGenerated or: [field type isRelativeType]) ifFalse: [^self].	self canWrite ifFalse: [^false].	row := aRowMap findOrAddRowForTable: self field table withKey: anObject.	value := self convertedStValueOf: (row at: field ifAbsent: [^self]).	attribute setValueIn: anObject to: value</body><body package="GlorpMappings">trace: aTracing context: anExpression	^self.</body><body package="GlorpMappings">valueIn: anElementBuilder as: anExpression	| dbValue valueToGet |	valueToGet := anExpression canTranslateFields 		ifTrue: [anExpression translateField: field] 		ifFalse: [anExpression].	dbValue := anElementBuilder		valueOfField: valueToGet.	^self convertedStValueOf: dbValue.</body><body package="GlorpMappings">valueInBuilder: anElementBuilder	^self valueInBuilder: anElementBuilder as: field.</body><body package="GlorpMappings">valueInBuilder: anElementBuilder as: anExpression	| dbValue |	dbValue := anElementBuilder valueOfField: anExpression.	^self convertedStValueOf: dbValue.</body><body package="GlorpMappings">valueOfField: aField fromObject: anObject	field = aField ifFalse: [self error: 'Mapping doesn''t describe field'].	^self convertedDbValueOf: (self getValueFrom: anObject).</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>accessing</category><body package="GlorpMappings">converter	^converter.</body><body package="GlorpMappings">converter: aDatabaseConverter	converter := aDatabaseConverter.</body><body package="GlorpMappings">field	^field</body><body package="GlorpMappings">field: aDatabaseFieldOrExpression	field := (Dialect isBlock: aDatabaseFieldOrExpression)		ifTrue: [			self beReadOnly.			aDatabaseFieldOrExpression asGlorpExpressionOn: (BaseExpression new descriptor: descriptor)]		ifFalse: [aDatabaseFieldOrExpression].</body><body package="GlorpMappings">fieldsForDescriptorSelectStatement	"Return a collection of fields that this mapping will read from a row when the containing object is read, as opposed to when we're specifically told to use this field. Normally it amounts to the same thing, but if a direct mapping is proxied, we don't want its field when the parent is read"	^self shouldProxy ifTrue: [self descriptor primaryTable primaryKeyFields] ifFalse: [super fieldsForDescriptorSelectStatement].</body><body package="GlorpMappings">shouldProxy	^shouldProxy.</body><body package="GlorpMappings">shouldProxy: aBoolean	shouldProxy := aBoolean.</body><body package="GlorpMappings">type: aClass	self attribute type: aClass.	field isNil ifFalse: [		self setConverterBetween: aClass and: field].</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>private</category><body package="GlorpMappings">convertedDbValueOf: stValue 	^converter isNil		ifTrue: [stValue]		ifFalse: [converter convert: stValue toDatabaseRepresentationAs: self field type]</body><body package="GlorpMappings">convertedStValueOf: dbValue 	^converter isNil		ifTrue: [dbValue]		ifFalse: [converter convert: dbValue fromDatabaseRepresentationAs: self field type]</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>enumerating</category><body package="GlorpMappings">referencedIndependentObjectsFrom: anObject	^#().</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>printing SQL</category><body package="GlorpMappings">printSQLOn: aStream withParameters: aDictionary	self field printSQLOn: aStream withParameters:aDictionary.</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>validation</category><body package="GlorpMappings">validate	super validate.	(field isGlorpExpression and: [self readOnly not]) ifTrue: [self error: 'Mappings to functions cannot be written'].</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>initialize-release</category><body package="GlorpMappings">from: anAttributeName to: aField	| type |	self attributeName: anAttributeName.	self field: (descriptor fieldFor: aField).	type := self attribute type isNil ifTrue: [field impliedSmalltalkType] ifFalse: [self attribute type].	self type: type.</body><body package="GlorpMappings">from: anAttributeName type: aClass to: aField	self		attributeName: anAttributeName;		field: aField;		type: aClass.</body><body package="GlorpMappings">fromPseudoVariable: anAttributeName to: aField	^self fromPseudoVariable: anAttributeName		type: aField impliedSmalltalkType		to: aField</body><body package="GlorpMappings">fromPseudoVariable: anAttributeName type: aClass to: aField	self from: anAttributeName type: aClass to: aField.	self beForPseudoVariable.</body><body package="GlorpMappings">initialize	super initialize.	shouldProxy := false.</body><body package="GlorpMappings">setConverterBetween: aClass and: aDbField 	aClass isNil ifTrue: [^self].	converter := descriptor ifNotNil: 					[descriptor system converterBetweenStType: aClass andField: aDbField]				ifNil: [aDbField converterForStType: aClass]</body></methods><methods><class-id>Glorp.DirectMapping class</class-id> <category>instance creation</category><body package="GlorpMappings">from: attributeName to: field	^self from: attributeName		type: field impliedSmalltalkType		to: field</body><body package="GlorpMappings">from: attributeName type: aClass to: field	^self new		attributeName: attributeName;		field: field;		type: aClass.</body><body package="GlorpMappings">fromPseudoVariable: attributeName to: field	^self fromPseudoVariable: attributeName		type: field impliedSmalltalkType		to: field</body><body package="GlorpMappings">fromPseudoVariable: attributeName type: aClass to: field	^self new		attributeName: attributeName;		field: field;		beForPseudoVariable.</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>accessing</category><body package="GlorpUnitOfWork">key1	^key1</body><body package="GlorpUnitOfWork">key1: anObject	key1 := anObject</body><body package="GlorpUnitOfWork">key2	^key2</body><body package="GlorpUnitOfWork">key2: anObject	key2 := anObject</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>comparing</category><body package="GlorpUnitOfWork">= aRowMapKey	aRowMapKey class == self class ifFalse: [^false].	^(key1 == aRowMapKey key1 and: [key2 == aRowMapKey key2]) or: [		key2 == aRowMapKey key1 and: [key1 == aRowMapKey key2]].</body><body package="GlorpUnitOfWork">hash	| hash1 hash2 hash1Temp longHash |	hash1 := key1 identityHash.	hash2 := key2 identityHash.	hash1 &gt; hash2 ifTrue: [		hash1Temp := hash1.		hash1 := hash2.		hash2 := hash1Temp].	longHash := (hash1 bitShift: 8) bitXor: hash2.	^Dialect fitHashIntoSmallInteger: longHash.</body></methods><methods><class-id>Glorp.RowMapKey</class-id> <category>adjusting</category><body package="GlorpUnitOfWork">adjustIn: aCorrespondenceMap	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted key1: (aCorrespondenceMap at: key1 ifAbsent: [key1]).	adjusted key2: (aCorrespondenceMap at: key2 ifAbsent: [key2]).	^adjusted.</body><body package="GlorpUnitOfWork">reverseAdjustIn: aRowMapForMementos	"Adjust ourselves to refer to the copies rather than the originals"	| adjusted |	adjusted := self copy.	adjusted key1: (aRowMapForMementos reversedCorrespondenceMap at: key1 ifAbsent: [key1]).	adjusted key2: (aRowMapForMementos reversedCorrespondenceMap at: key2 ifAbsent: [key2]).	^adjusted.</body></methods><methods><class-id>Glorp.InMemorySequence</class-id> <category>sequencing</category><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aField in: aRow</body><body package="GlorpDatabase">postWriteAssignSequenceValueFor: aField in: aRow using: anAccessor</body><body package="GlorpDatabase">preWriteAssignSequenceValueFor: aField in: aRow	aRow at: aField put: (count := count + 1).</body></methods><methods><class-id>Glorp.InMemorySequence</class-id> <category>initialize/release</category><body package="GlorpDatabase">initialize	super initialize.	count := 0.</body></methods><methods><class-id>Glorp.InMemorySequence</class-id> <category>public</category><body package="GlorpDatabase">getSequenceValueFromDatabaseFor: aField in: aRow using: aSession	aRow at: aField put: (count := count + 1).</body></methods><methods><class-id>Glorp.InMemorySequence class</class-id> <category>defaults</category><body package="GlorpDatabase">default	^self new.</body></methods><methods><class-id>ProtoObject</class-id> <category>doesNotUnderstand</category><body package="GlorpQueries">asGlorpExpression	^GlorpHelper glorpConstantExpressionClass for: self.</body><body package="GlorpQueries">asGlorpExpressionOn: anExpression	^self asGlorpExpression.</body><body package="GlorpQueries">asGlorpExpressionOn: anExpression basedOn: aMessageArchiver withUltimateBase: aBaseExpression	^self asGlorpExpression.</body></methods><methods><class-id>ProtoObject</class-id> <category>testing</category><body package="GlorpQueries">isGlorpExpression	^false.</body></methods><methods><class-id>ProtoObject</class-id> <category>doesNotUnderstand</category><body package="GlorpQueries">isGlorpProxy	^false.</body><body package="GlorpQueries">isKindOf: aClass	^self class includesBehavior: aClass.</body></methods><methods><class-id>Core.Object</class-id> <category>glorp</category><body package="GlorpExtensions">asGlorpExpression	^GlorpHelper glorpConstantExpressionClass for: self.</body><body package="GlorpExtensions">asGlorpExpressionOn: anExpression	^self asGlorpExpression.</body><body package="GlorpExtensions">asGlorpExpressionOn: anExpression basedOn: aMessageArchiver withUltimateBase: aBaseExpression	^self asGlorpExpression.</body><body package="GlorpExtensions">glorpBasicSize	^self basicSize.</body><body package="GlorpExtensions">glorpCanHaveDescriptorDirectly	^self isBehavior.</body><body package="GlorpExtensions">glorpIsCollection	^false.</body><body package="GlorpExtensions">glorpPostFetch: aSession	"This is a selector that objects can implement in order to receive notification when Glorp has read them."</body><body package="GlorpExtensions">glorpPostFetchValidate: aSession	"This allows us to do post-read notification of the objects. Note that if this method explicitly returns a false, then we will treat that as meaning that the object is invalid and should not be read. Yes, this is kind of a hack."</body><body package="GlorpExtensions">glorpPostWrite: aSession</body><body package="GlorpExtensions">glorpPreWrite: aSession	"This is a selector that objects can implement in order to receive notification when Glorp is about to write them. Only objects that have pending modifications will receive this notice. However, note that because of that, the data to be written will have already been calculated before this method is called, which makes it difficult to use this to update the method. If you want to put in audit information (e.g. the time at which the object was written, the associated username) then you probably want to use a generator associated with the field instead. See, for example GlorpRecordWithUpdate in the test suite."</body><body package="GlorpExtensions">glorpPrintSelectSQLOn: aCommand	self glorpPrintSQLOn: aCommand.</body><body package="GlorpExtensions">glorpPrintSQLOn: aCommand	self printOn: aCommand.</body><body package="GlorpExtensions">glorpRealObject	"Return the real object. Will force instantiation of a proxy, even on compilers which inline yourself"	^self.</body><body package="GlorpExtensions">isGlorpExpression	^false.</body><body package="GlorpExtensions">isGlorpProxy	^false.</body><body package="GlorpExtensions">needsWork: aString	^self.</body><body package="GlorpExtensions">todo	"marker"</body><body package="GlorpExtensions">yourSelf	"Return the real object. Will force instantiation of a proxy, even on compilers which inline yourself"	^self.</body></methods><methods><class-id>Core.String</class-id> <category>glorp</category><body package="GlorpExtensions">glorpIsCollection	"For our purposes, these aren't collections, but rather a simple database type"	^false.</body><body package="GlorpExtensions">glorpPrintSQLOn: aCommand	| platform |	aCommand nextPut: $'.		platform := [aCommand platform] on: MessageNotUnderstood do: [:ex | ex return: nil].	platform isNil		ifFalse: [platform printEscapedString: self on: aCommand]		ifTrue: [aCommand nextPutAll: self].	aCommand nextPut: $'.</body><body package="GlorpExtensions">like: aPattern 	"This uses, with permission, the code from ObjectStudio that implements this."	^self 		likePattern: aPattern		from: 1		sourceStart: 1	":Section Reference							like: aPattern		Description:        	Returns true if the receiver contains a string being                   	 			matched by the parameter 'aPattern'. Using the wildcard					  		$% serves as placeholder for 0-n $_ as a placeholder					  		for a single matched character.		Assumptions:        	'aPattern' is expected to be of class String.		Return Value:       	true or false.		Receiver Modified:  	No.		Examples:			('abcdefg' like: 'abc%') -&gt; true							('abcdefg' like: 'abc__fg') -&gt; true  							('abcdefg' like: '_defg') -&gt; false	:End"</body><body package="GlorpExtensions">likePattern: aPattern from: patternStart sourceStart: sourceStart 	"Note that this uses, with permission, the code from ObjectStudio that does this. It's a recursive implementation, but this is primarily for in-memory mimicking of database operations so the performance limitations shouldn't be a big issue."	| c |	patternStart &gt; aPattern size ifTrue: [^sourceStart &gt; self size].	c := aPattern at: patternStart.	c == $% 		ifTrue: 			[sourceStart to: self size + 1				do: 					[:ind | 					(self 						likePattern: aPattern						from: patternStart + 1						sourceStart: ind) ifTrue: [^true]].			^false].	sourceStart &gt; self size ifTrue: [^false].	(c == $_ or: [c == (self at: sourceStart)]) 		ifTrue: 			[^self 				likePattern: aPattern				from: patternStart + 1				sourceStart: sourceStart + 1].	^false	":Section Reference							likePattern: aPattern from: patternStart sourceStart: sourceStart		Description:        	Returns true if the receiver contains a string being                    				matched by the parameter 'aPattern'. Using the wildcard					  		$% serves as placeholder for 0-n $_ as a placeholder					  		for a single matched character.		Assumptions:        'aPattern' is expected to be of class String.		Return Value:       true or false.		Receiver Modified:  No.	:End"</body></methods><methods><class-id>Core.Collection</class-id> <category>adding</category><body package="GlorpExtensions">glorpAddAll: aCollection	^self addAll: aCollection.</body><body package="GlorpExtensions">glorpAddAllToDictionary: aDictionary	"Assumes that we are a collection of associations"	self do: [:each | aDictionary add: each].</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GlorpExtensions">glorpGroupedBy: aBlock	"(Same as VW groupedBy:. This is too useful not to be able to use, but we don't want to conflict with other dialects/extensions that might implement, so make our own prefixed version.)  Return a dictionary whose keys are the result of evaluating aBlock for all elements in the collection, and the value for each key is the collection of elements that evaluated to that key. e.g.		#(1 2 3 4 5) groupedBy: [:each | each odd]returns a Dictionary with values		true ---&gt; #(1 3 5)		false --&gt; #(2 4)"	| result |	result := Dictionary new.	self do:		[:each || key collection |		key := aBlock value: each.		collection := result at: key ifAbsentPut: [OrderedCollection new].		collection add: each].	self species ~~ OrderedCollection ifTrue:		["Convert the result collections to be the right type.  It is safe to modify the		  dictionary while iterating because we only replace values for existing keys"		result keysAndValuesDo:			[:key :value | result at: key put: (self species withAll: value)]].	^result</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="GlorpExtensions">glorpIsCollection	^true.</body><body package="GlorpExtensions">glorpIsDictionary	^false</body></methods><methods><class-id>Core.Collection</class-id> <category>glorp</category><body package="GlorpExtensions">glorpPrintSQLOn: aCommand	aCommand nextPut: $(.	self isEmpty		ifTrue: [aCommand nextPutAll: 'NULL']		ifFalse:			[GlorpHelper				do: [:each | each glorpPrintSQLOn: aCommand]				for: self				separatedBy: [aCommand nextPutAll: ', ']].	aCommand nextPut: $).</body><body package="GlorpExtensions">glorpPrintSQLOn: aStream for: aType	aStream nextPut: $(.	self isEmpty		ifTrue: [aStream nextPutAll: 'NULL']		ifFalse:			[GlorpHelper				do: [:each | aType print: each on: aStream]				for: self				separatedBy: [aStream nextPutAll: ', ']].	aStream nextPut: $).</body><body package="GlorpExtensions">glorpRegisterCollectionInternalsIn: anObjectTransaction 	"Explicitly register any internal structures (e.g. a VW identity dictionary's valueArray) with the transaction. Assume we can safely register everything inside the collection reflectively. The obvious exceptions would be dependents and sortblocks. This is a cheat, and for peculiar cases you'll need to override this in the subclass"	| names |	names := self class allInstVarNames.	(1 to: names size) do: 			[:index | 			(#('dependents' 'sortBlock') includes: (names at: index)) 				ifFalse: [anObjectTransaction register: (self instVarAt: index)]]</body></methods><methods><class-id>Core.Collection</class-id> <category>streams</category><body package="GlorpExtensions">writeStream	^AddingWriteStream on: self</body></methods><methods><class-id>Core.SortedCollection</class-id> <category>streams</category><body package="GlorpExtensions">writeStream	^AddingWriteStream on: self.</body></methods><methods><class-id>Core.ByteArray</class-id> <category>testing</category><body package="GlorpExtensions">glorpIsCollection	"For our purposes, these aren't collections, but rather a simple database type"	^false.</body></methods><methods><class-id>Core.ByteArray</class-id> <category>glorp</category><body package="GlorpExtensions">glorpPrintSQLOn: aCommand	|strm|	strm := WriteStream on: String new.	strm nextPutAll: '0x'.	strm nextPutAll: self asHexString.	aCommand nextPutAll: strm contents</body></methods><methods><class-id>Core.Dictionary</class-id> <category>adding</category><body package="GlorpExtensions">glorpAddAll: aCollection	"An addAll: that can work for either a dictionary argument or a collection of associations"	aCollection glorpAddAllToDictionary: self.</body></methods><methods><class-id>Core.Dictionary</class-id> <category>testing</category><body package="GlorpExtensions">glorpIsDictionary	^true</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>printing</category><body package="GlorpExtensions">glorpPrintSQLOn: aCommand	aCommand nextPutAll: 'NULL'.</body></methods><methods><class-id>Core.Association</class-id> <category>accessing</category><body package="GlorpExtensions">glorpAtIdentity: aKey ifAbsent: aBlock	"A cheat to let use use this like an identity dictionary"	^key == aKey ifTrue: [value] ifFalse: aBlock.</body><body package="GlorpExtensions">keysAndValuesDo: aBlock	"A memory allocation hack. Let us use a single association in place of a dictionary"	aBlock value: key value: value.</body></methods><methods><class-id>Core.ReadStream</class-id> <category>Not categorized</category><body package="GlorpExtensions">actuallyAtEnd	"For working around a VA cursor problem"	^self atEnd</body><body package="GlorpExtensions">collect: aBlock	| newStream |	newStream := collection species new writeStream.	[self atEnd] whileFalse: [newStream nextPut: (aBlock value: self next)].	^newStream contents"Use #writeStream, not WriteStream on: collection species, for portability;  VA cannot stream over all AdditiveSequenceableCollections."</body></methods><methods><class-id>Core.ReadStream</class-id> <category>building objects</category><body package="GlorpExtensions">collectionTypeFor: aClass	^aClass.</body></methods><methods><class-id>Core.ReadStream</class-id> <category>Not categorized</category><body package="GlorpExtensions">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone: [self error: 'not found']</body><body package="GlorpExtensions">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="GlorpExtensions">includes: anObject	self do: [:each | each = anObject ifTrue: [^true]].	^false.</body><body package="GlorpExtensions">newCollectionOfSize: aSize for: aCollectionType	^aCollectionType isBehavior ifTrue: [aCollectionType new: aSize] ifFalse: [aCollectionType copyEmpty: aSize].</body><body package="GlorpExtensions">select: aBlock	| newStream |	newStream := collection species new writeStream.	[self atEnd] whileFalse: [		| current |		current := self next.		(aBlock value: current) ifTrue: [newStream nextPut: current]].	^newStream contents"Use #writeStream, not WriteStream on: collection species, for portability;  VA cannot stream over all AdditiveSequenceableCollections."</body><body package="GlorpExtensions">statement: aGlorpPreparedStatement	"This is the statement used to create us. If it's coming back to a simple read stream, then we must have already used all its data, and can thus reuse it"	aGlorpPreparedStatement busy: false.</body></methods><methods><class-id>Core.Time</class-id> <category>printing</category><body package="GlorpExtensions">glorpPadToTwoDigits: anInteger	| string |	string := anInteger truncated printString.	^string size = 1 ifTrue: ['0', string] ifFalse: [string].</body><body package="GlorpExtensions">glorpPrintSQLOn: aCommand	"Print as 24 hour time"	aCommand 		nextPut: $';		nextPutAll: 	(self glorpPadToTwoDigits: self hours);		nextPut: $:;		nextPutAll: (self glorpPadToTwoDigits: self minutes);		nextPut: $:;		nextPutAll: (self glorpPadToTwoDigits: self seconds);		nextPut: $'.</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>accessing</category><body package="GlorpExtensions">glorpAtIdentity: aKey ifAbsent: aBlock	^self at: aKey ifAbsent: aBlock.</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="GlorpExtensions">glorpPrintSQLOn: aCommand	"Print the date in ISO format. 'yyyy-mm-dd'  Don't rely on any dialect-specific formatting or padding mechanisms"	| monthString dayString |	aCommand 		nextPut: $';		print: self year;		nextPut: $-.	monthString := self monthIndex printString.	monthString size = 1 ifTrue: [aCommand nextPut: $0 ].	aCommand nextPutAll: monthString.	aCommand nextPut: $-.	dayString := self dayOfMonth printString.	dayString size = 1 ifTrue: [aCommand nextPut: $0 ].	aCommand nextPutAll: dayString.	aCommand nextPut: $'.</body></methods><initialize><class-id>Glorp.FunctionExpression</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SortedCollection</name><environment>Core</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>sortBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ProtoObject</name><environment>Smalltalk</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpVWPort</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class></st-source>