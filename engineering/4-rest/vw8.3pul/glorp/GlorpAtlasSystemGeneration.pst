<?xml version="1.0"?><st-source><!-- Name: GlorpAtlasSystemGenerationNotice: Copyright 2013-2016 Cincom Systems, Inc.  All rights reserved.Comment: Load and use this programmatic utility in VisualWorks only, not in ObjectStudio.  (ObjectStudio's modelling and mapping tools provide a UI on a more powerful version of the same capability.)This supports generating a DescriptorSystem subclass, with classFor<Name>:, descriptorFor<Name>: and tableFor<Name>: methods, from a descriptor system.  Typically, this will be a descriptor system created when a DB's metadata is read by GlorpAtlasSystemGeneration or GlorpActiveRecord.  The API is	WriteAtlasHelper system: aDescriptorSystem.		"sets value used during generation"	aDescriptorSystem		writeAtlas: aClassNamePrefixString		"see #atlasNameExtension"		in: anExistingNameSpace				"see #classBase"		package: aNewOrExistingPackageNameThis utility does not (yet) handle all cases in all possible schemas.  Use and experience will add to what it can handle, and improve the warnings that are offered for cases it cannot.  Post-generation hand-editing will be essential in such cases, and useful in most cases:  generation is meant to speed development of a descriptor system subclass for an existing database, not wholly to replace hand-coding.DbIdentifier: bear73DbTrace: 484413DbUsername: nrossDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'GlorpActiveRecord' '') #(#any 'Visibility-Bindings' '') #(#any 'GlorpAtlasSystemsInVW' ''))PackageName: GlorpAtlasSystemGenerationParcel: #('GlorpAtlasSystemGeneration')ParcelName: GlorpAtlasSystemGenerationPrerequisiteDescriptions: #(#(#name 'GlorpActiveRecord' #componentType #package) #(#name 'Visibility-Bindings' #componentType #package) #(#name 'GlorpAtlasSystemsInVW' #componentType #package))PrerequisiteParcels: #(#('GlorpActiveRecord' '') #('Visibility-Bindings' '') #('GlorpAtlasSystemsInVW' ''))PrintStringCache: (8.2 - 1,nross)Version: 8.2 - 1Date: 12:56:08 PM February 5, 2016 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (feb16.1) of February 5, 2016 on February 5, 2016 at 12:56:08 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WriteAtlasHelper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system fkc foreignKeyHelper </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasSystemGeneration</package></attributes></class><comment><class-id>Glorp.WriteAtlasHelper</class-id><body>Instance Variables	system	&lt;Object&gt; undocumented	fkc	&lt;OrderedCollection&gt; ForeignKey constraintsClass Instance Variables	current	&lt;Object&gt; </body></comment><class><name>ForeignKeyConstraintHelper</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dict </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Atlas</category><attributes><package>GlorpAtlasSystemGeneration</package></attributes></class><methods><class-id>Glorp.WriteAtlasHelper</class-id> <category>accessing</category><body package="GlorpAtlasSystemGeneration">foreignKeyHelper	^foreignKeyHelper</body><body package="GlorpAtlasSystemGeneration">foreignKeyHelper: aHelper	foreignKeyHelper := aHelper</body><body package="GlorpAtlasSystemGeneration">system	^system</body><body package="GlorpAtlasSystemGeneration">system: anObject	system := anObject</body></methods><methods><class-id>Glorp.WriteAtlasHelper</class-id> <category>initialize-release</category><body package="GlorpAtlasSystemGeneration">initialize	super initialize.	system := nil.</body></methods><methods><class-id>Glorp.WriteAtlasHelper</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">writeDirection: aString fields: aFieldList on: aStream	aStream		cr; tab; tab; nextPutAll: aString;		cr; tab; tab; tab; nextPutAll: '(OrderedCollection new'.	aFieldList do: 		[:aField |		aStream			cr; tab; tab; tab; tab;			nextPutAll: 'add: ((self tableNamed: ''';			nextPutAll: aField table name;			nextPutAll: ''') fieldNamed: ''';			nextPutAll: aField name;			nextPutAll: ''');'].	aStream cr; tab; tab; tab; tab; nextPutAll: 'yourself)'.</body><body package="GlorpAtlasSystemGeneration">writeForeignKeysOn: aStream	"Use ...From:to: if there are three fields or less, otherwise ...FromAll:toAll:."	self isEmpty ifTrue: [^self].	self foreignKeyHelper current keys do:		[:aFkc |		(self foreignKeyTablesExistInSystem: aFkc) ifTrue:			[aStream cr; tab; nextPutAll: 'aTable'.			aFkc sourceFields size &gt; 3				ifTrue:					[self writeDirection: 'addForeignKeyFromAll:' fields: aFkc sourceFields on: aStream.					self writeDirection: 'toAll:' fields: aFkc targetFields on: aStream]				ifFalse:					[aFkc sourceFields with: aFkc targetFields do:						[:eachSourceField :eachTargetField |						aStream							cr; tab; tab;							nextPutAll: 'addForeignKeyFrom: ((self tableNamed: ''';							nextPutAll: eachSourceField table name;							nextPutAll: ''') fieldNamed: ''';							nextPutAll: eachSourceField name;							nextPutAll: ''') to: ((self tableNamed: ''';							nextPutAll: eachTargetField table name;							nextPutAll: ''') fieldNamed: ''';							nextPutAll: eachTargetField name;							nextPutAll: ''')']]].			aStream  nextPut: $.].</body></methods><methods><class-id>Glorp.WriteAtlasHelper</class-id> <category>testing</category><body package="GlorpAtlasSystemGeneration">foreignKeyTablesExistInSystem: aFkc	^(self system tables includes: aFkc table) and:		[self system tables includes: aFkc targetTable]</body><body package="GlorpAtlasSystemGeneration">isEmpty	^self foreignKeyHelper isEmpty</body></methods><methods><class-id>Glorp.WriteAtlasHelper class</class-id> <category>accessing</category><body package="GlorpAtlasSystemGeneration">current	current ifNil: [current := self new].	^current</body><body package="GlorpAtlasSystemGeneration">reset	current := nil</body><body package="GlorpAtlasSystemGeneration">resetFkc: aTable	self current foreignKeyHelper: (ForeignKeyConstraintHelper newFor: aTable)</body><body package="GlorpAtlasSystemGeneration">system	^self current system</body><body package="GlorpAtlasSystemGeneration">system: aDescriptorSystem	self current system: aDescriptorSystem</body></methods><methods><class-id>Glorp.WriteAtlasHelper class</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">writeForeignKeysOn: aStream	self current writeForeignKeysOn: aStream.</body></methods><methods><class-id>Glorp.WriteAtlasHelper class</class-id> <category>instance creation</category><body package="GlorpAtlasSystemGeneration">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.ForeignKeyConstraintHelper</class-id> <category>testing</category><body package="GlorpAtlasSystemGeneration">isEmpty	^dict isEmpty</body></methods><methods><class-id>Glorp.ForeignKeyConstraintHelper</class-id> <category>accessing</category><body package="GlorpAtlasSystemGeneration">buildDictForTable: aDatabaseTable	| val |	val := aDatabaseTable foreignKeyConstraints.	val notNil ifTrue: [val do: [:aFkc | dict at: aFkc ifAbsentPut: [false]]]</body><body package="GlorpAtlasSystemGeneration">dict	^dict</body><body package="GlorpAtlasSystemGeneration">dict: anObject	dict := anObject</body><body package="GlorpAtlasSystemGeneration">keys	^self dict keys</body></methods><methods><class-id>Glorp.ForeignKeyConstraintHelper</class-id> <category>initialize-release</category><body package="GlorpAtlasSystemGeneration">initialize	dict := IdentityDictionary new.</body></methods><methods><class-id>Glorp.ForeignKeyConstraintHelper class</class-id> <category>instance creation</category><body package="GlorpAtlasSystemGeneration">current	^current</body><body package="GlorpAtlasSystemGeneration">current: anObject	current := anObject</body><body package="GlorpAtlasSystemGeneration">isEmpty	^self current isEmpty</body><body package="GlorpAtlasSystemGeneration">new	self current: (self basicNew) initialize; yourself.</body><body package="GlorpAtlasSystemGeneration">newFor: aDatabaseTable	| |	self new.	current buildDictForTable: aDatabaseTable.</body></methods><methods><class-id>Glorp.GlorpClassModel</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'classModelFor';		nextPutAll: self describedClass name asString;		nextPutAll: ': aClassModel';		cr;		tab.	self attributes		do: [:anAttribute | anAttribute asAtlasDefinitionMethod: stream].	^stream contents</body></methods><methods><class-id>Glorp.DirectMapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	stream		nextPutAll: '(aDescriptor newMapping: DirectMapping)';		cr;tab;tab;		nextPutAll: 'from: #';		nextPutAll: self attribute name asString;		cr;tab;tab;		nextPutAll: 'to: (table';		nextPutAll: self determineTableIndex printString;		nextPutAll: ' fieldNamed: ''';		nextPutAll: self field name;		nextPutAll: ''')'.	(converter notNil and: [converter name first = $@]) ifTrue: 		[stream			nextPut: $;;			cr; tab; tab;			nextPutAll: 'converter: (PluggableDatabaseConverter new';			cr; tab; tab; tab;			nextPutAll: 'name: ''';			nextPutAll: converter name;			nextPutAll: ''';';			cr; tab; tab; tab;			nextPutAll: 'dbToStConverter: [:aValue | aValue ';			nextPutAll: converter determineInMethod;			nextPutAll: '];';			cr; tab; tab; tab;			nextPutAll: 'stToDbConverter: [:aValue | aValue ';			nextPutAll: converter determineOutMethod;			nextPutAll: '];';			cr; tab; tab; tab;			nextPutAll: 'yourself)'].	self asAtlasDebugDefinitionMethod: stream.</body><body package="GlorpAtlasSystemGeneration">determineTableIndex	^self descriptor tables indexOf: self field table</body></methods><methods><class-id>Glorp.FilteredTypeMapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	"When FilteredTypeResolver&gt;&gt;register:abstract: is called with 2nd param true, it creates a fakeTypeMapping with nil field (and nil key).  We therefore use nil field to discriminate abstract and concrete registrations."	stream		nextPutAll: '(self typeResolverFor: ';		nextPutAll: self descriptor typeResolver rootClass name asString;		nextPutAll: ') register: aDescriptor '.	field isNil ifTrue:	"we're abstract"		[stream nextPutAll: 'abstract: true.'.		^self].	"we're concrete"	stream		nextPutAll: 'keyedBy: ';		nextPutAll: key printString;		nextPutAll: ' field: ((self tableNamed: ';		nextPutAll: field table name printString;		nextPutAll: ') fieldNamed: ';		nextPutAll: field name printString;		nextPutAll: ').'</body></methods><methods><class-id>Glorp.ToManyMapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	stream		nextPutAll: '(aDescriptor newMapping: ToManyMapping)';		cr; tab; tab; 		nextPutAll: 'attributeName: #';		nextPutAll: self attribute name asString;		nextPut: $;;		cr; tab; tab;		nextPutAll: 'join: (';		nextPutAll: self join asAtlasDefinitionMethod;		nextPut: $).	self asAtlasDebugDefinitionMethod: stream</body></methods><methods><class-id>Glorp.Descriptor</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'descriptorFor';		nextPutAll: self describedClass name asString;		nextPutAll: ': aDescriptor'; crtab;		nextPutAll: '| '.	1 to: self tables size do:		[:idx | stream nextPutAll: 'table'; nextPutAll: idx printString].	stream nextPut: $|; crtab.	1 to: self tables size do:		[:idx | 		stream			nextPutAll: 'table';			nextPutAll: idx printString;			nextPutAll: ' := self tableNamed: ''';			nextPutAll: (self tables at: idx) name;			nextPutAll: '''.'; crtab;			nextPutAll: 'aDescriptor table: table';			nextPutAll: idx printString;			nextPut: $.; cr; crtab].	self multipleTableJoin do: [ :aJoin | aJoin asMultiTableAtlasDefinitionMethod: stream].	self mappings do: [ :aMapping | aMapping asAtlasDefinitionMethod: stream].	^stream contents</body></methods><methods><class-id>Glorp.ManyToManyMapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	stream		nextPutAll: '(aDescriptor newMapping: ManyToManyMapping)';		cr; tab; tab;		nextPutAll: 'attributeName: #';		nextPutAll: self attribute name asString;		nextPut: $;;		cr; tab; tab;		nextPutAll: 'join: (';		nextPutAll: self join asAtlasDefinitionMethod;		nextPutAll: ');';		cr; tab; tab; 		nextPutAll: 'reverseJoin: (';		nextPutAll: self reverseJoin asAtlasDefinitionMethod;		nextPut: $).	self asAtlasDebugDefinitionMethod: stream</body></methods><methods><class-id>Glorp.GlorpDatabaseType</class-id> <category>accessing</category><body package="GlorpAtlasSystemGeneration">asAtlasTypeDefinitionMethodInExpressionOn: aStream	"Provide brackets if they will be needed in an expression, i.e. if the type hasParameters and they are not the initialize values."	| needsBrackets |	needsBrackets := self hasParameters and:		[self ~= (self platform types at: self selector ifAbsent: [nil])].	needsBrackets ifTrue: [aStream nextPut: $(].	aStream nextPutAll: 'platform '.	self asAtlasTypeDefinitionMethodOn: aStream.	needsBrackets ifTrue: [aStream nextPut: $)].</body><body package="GlorpAtlasSystemGeneration">asAtlasTypeDefinitionMethodOn: aStream	aStream nextPutAll: self platformSelector</body></methods><methods><class-id>Glorp.TypeResolver</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod	^self subclassResponsibility"Once we have methods for the whole subclass hierarchy, refactor them to take the stream as parameter and make this	| stream |	stream := WriteStream on: String new.	self asAtlasDefinitionMethodOn: stream.	^stream contents"</body></methods><methods><class-id>Glorp.OneToOneMapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	stream		nextPutAll: '(aDescriptor newMapping: ';		nextPutAll: self class fullName;		nextPut:  $);		cr; tab; tab;		nextPutAll: 'attributeName: #';		nextPutAll: self attribute name asString;		nextPut: $;;		cr; tab; tab;		nextPutAll: self atlasDefinitionJoinString;		nextPutAll: ' (';		nextPutAll: self atlasDefinitionJoinMethod asAtlasDefinitionMethod;		nextPut: $).	self asAtlasDebugDefinitionMethod: stream</body><body package="GlorpAtlasSystemGeneration">atlasDefinitionJoinMethod	^self join</body><body package="GlorpAtlasSystemGeneration">atlasDefinitionJoinString	^'join:'</body></methods><methods><class-id>Glorp.PluggableDatabaseConverter</class-id> <category>converting</category><body package="GlorpAtlasSystemGeneration">determineInMethod	| pos |	pos := name indexOf: $|.	^name copyFrom: 2 to: (pos - 1)</body><body package="GlorpAtlasSystemGeneration">determineOutMethod	| pos |	pos := name indexOf: $|.	^name copyFrom: (pos + 1) to: name size</body></methods><methods><class-id>Glorp.Join</class-id> <category>printing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod	"Use from:to: if there are four fields or less, otherwise fromAll:toAll:."	| stream |	stream := WriteStream on: String new.	stream nextPutAll: self class name.	self allSourceFields size &gt; 4		ifTrue:			[self asAtlasDefinitionMethodDirection: 'fromAll:' fields: self allSourceFields on: stream.			self asAtlasDefinitionMethodDirection: 'toAll:' fields: self allTargetFields on: stream]		ifFalse:			[self allSourceFields with: self allTargetFields do: 				[:eachSourceField :eachTargetField |				stream cr; tab; tab; tab; tab.				stream nextPutAll: 'from: '.				eachSourceField asAtlasFieldInJoin: stream.				stream nextPutAll: ' to: '.				eachTargetField asAtlasFieldInJoin: stream]].	^stream contents</body><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethodDirection: aString fields: fields on: stream	stream		cr; tab; tab; tab; tab;		nextPutAll: aString;		cr;tab;tab;tab;tab;tab;		nextPutAll: '(OrderedCollection new'.	fields do:		[:aField |		stream cr;tab;tab;tab;tab;tab;tab.		stream nextPutAll: 'add: '.		aField asAtlasFieldInJoin: stream.		stream nextPutAll: ';'].	stream		cr;tab;tab;tab;tab;tab;tab;		nextPutAll: 'yourself)'.</body><body package="GlorpAtlasSystemGeneration">asMultiTableAtlasDefinitionMethod: stream	stream nextPutAll: 		'aDescriptor addMultipleTableJoin: (';		cr; tab; tab; 		nextPutAll: self asAtlasDefinitionMethod;		nextPutAll: ').';		cr; tab</body></methods><methods><class-id>Glorp.BasicTypeResolver</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'typeResolverFor';		nextPutAll: rootClass name;		cr;tab;		nextPut: $^.	self asAtlasDefinitionMethodOn: stream.	^stream contents</body><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethodOn: stream	stream		nextPutAll: self class name;		nextPutAll: ' forRootClass: ';		nextPutAll: rootClass name.</body></methods><methods><class-id>Glorp.ConstantMapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	stream		nextPutAll: '(aDescriptor newMapping: ConstantMapping)';		cr;		tab;		tab;		nextPutAll: 'constantValueIsSession;';		cr;		tab;		tab;		nextPutAll: 'attributeName: #session'.	self asAtlasDebugDefinitionMethod: stream</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem class</class-id> <category>instance creation</category><body package="GlorpAtlasSystemGeneration">atlasNameExtension	^'ActiveRecordDescriptorSystem'</body></methods><methods><class-id>Glorp.ActiveRecords.ActiveRecordDescriptorSystem</class-id> <category>export</category><body package="GlorpAtlasSystemGeneration">classBase	^ActiveRecordDescriptorSystem</body></methods><methods><class-id>Glorp.EmbeddedValueOneToOneMapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	"If hand-coding, we would only set the referenceClass of this kind of mapping when the attribute was first created;  later references to the same attribute of the same descriptor class model would not repeat the #referenceClass: &lt;aClass&gt; line.  However, until we can give our generator a test for whether we've already written a definition method (that would be executed earlier) for this attribute name, we must endure the duplication."	stream		nextPutAll: '(aDescriptor newMapping: ';		nextPutAll: self class fullName;		nextPut:  $);		cr; tab; tab;		nextPutAll: 'attributeName: #';		nextPutAll: self attribute name asString;		nextPut: $;;		cr; tab; tab;		nextPutAll: 'referenceClass: ';		nextPutAll: self attribute type fullName.	self fieldTranslation isNil ifFalse:		[stream			nextPut:  $;;			cr; tab; tab;		nextPutAll: 'fieldTranslation: (';		nextPutAll: self fieldTranslation asAtlasDefinitionMethod;		nextPutAll: ')'].	self asAtlasDebugDefinitionMethod: stream.</body></methods><methods><class-id>Glorp.GlorpAttributeModel</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	self type		ifNotNil: 			[stream				nextPutAll: 'aClassModel newAttributeNamed: #';				nextPutAll: self name;				nextPutAll: (self collectionType							ifNil: [' type: ']							ifNotNil: [' collectionOf: ']);				nextPutAll: self type name asString;				nextPut: $.;				cr;				tab	]</body></methods><methods><class-id>Glorp.GlorpExpression</class-id> <category>os-printing</category><body package="GlorpAtlasSystemGeneration">asAtlasFieldInJoin: stream	"Top-level default for expressions we do not yet handle when they appear in joins:  insert a halt to prompt the user to do it."	stream		nextPutAll: '(self halt: ''expression generation unhandled for ';		nextPutAll: self class name;		nextPut: $';		nextPut: $);		space;		nextPut: $";		nextPutAll: self printString;		nextPut: $".</body></methods><methods><class-id>Glorp.DatabaseField</class-id> <category>os-printing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	stream		cr;		tab.	self asAtlasFieldDefinitionMethod: stream.	stream nextPut: $..</body><body package="GlorpAtlasSystemGeneration">asAtlasFieldDefinitionMethod: stream	self isPrimaryKey ifTrue: [stream nextPut: $(].	stream		nextPutAll: 'aTable';		cr; tab; tab;		nextPutAll: 'createFieldNamed: ''';		nextPutAll: self name;		nextPut: $';		cr; tab; tab;		nextPutAll: 'type: '.	type asAtlasTypeDefinitionMethodInExpressionOn: stream.	self isPrimaryKey ifTrue: [stream nextPutAll: ') bePrimaryKey'].</body><body package="GlorpAtlasSystemGeneration">asAtlasFieldInJoin: stream	stream		nextPutAll: '((self tableNamed: ''';		nextPutAll: self table name;		nextPutAll: ''') fieldNamed: ''';		nextPutAll: self name;		nextPutAll: ''')'.</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>accessing</category><body package="GlorpAtlasSystemGeneration">atlasNameExtension	^'DescriptorSystem'</body></methods><methods><class-id>Glorp.DescriptorSystem</class-id> <category>export</category><body package="GlorpAtlasSystemGeneration">atlasMethodAllClassesAsVisibleIn: aNameSpace	"Do not qualify class names unless they are not visible in aNameSpace."	| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'allClasses'; crtab;		nextPutAll: 'allClasses isEmpty ifTrue:'; crtab: 2;		nextPutAll: '[allClasses := Array new: ';		nextPutAll: self allClasses size printString;		nextPut: $.; crtab: 2;		nextPutAll: 'allClasses'; crtab:3.	1 to: self allClasses size do: 		[:ndx || ndxClass | ndxClass := allClasses at: ndx.		stream			nextPutAll: 'at: ';			nextPutAll: ndx printString;			nextPutAll: ' put: ';			nextPutAll: ((ndxClass isVisibleIn: aNameSpace) ifTrue: [ndxClass name] ifFalse: [ndxClass fullName]) asString;			nextPut: $;; crtab: 3].	stream		nextPutAll: 'yourself].'; crtab;		nextPutAll: '^allClasses'.	^stream contents</body><body package="GlorpAtlasSystemGeneration">atlasMethodAllTableNames		| stream |	stream := WriteStream on: String new.	stream		nextPutAll: 'allTableNames';		cr;		tab;		nextPutAll: '^#('.	self tables		do:			[:aTable | 			stream				nextPut: $ ;				nextPut: $';				nextPutAll: aTable name;				nextPut: $'].	stream		nextPut: $);		cr.	^stream contents</body><body package="GlorpAtlasSystemGeneration">classBase	"If #writeAtlas:in: is sent to an instance of a subclass to (re)generate a descriptor system class and methods from that instance, what should be the superclass of the generated class?  Override this in subclasses whenever I am not the right answer."	^DescriptorSystem</body><body package="GlorpAtlasSystemGeneration">importString: aNamespace	"The Glorp namespace imports Smalltalk publicly, so ensuring private visibility of Glorp ensures private visibility of Smalltalk.  If the scope can see Glorp.Join then it can see Smalltalk in all non-pathalogical cases so we need no ifTrue: branch here."	| importStream |	importStream := String new writeStream.	(Glorp.Join isVisibleIn: aNamespace) ifFalse:		[importStream			nextPutAll: 'private ';			nextPutAll: Smalltalk.Glorp name;			nextPutAll: '.*'].	^importStream contents</body><body package="GlorpAtlasSystemGeneration">writeAtlas: aName in: aNamespace	^self writeAtlas: aName superclass: self classBase in: aNamespace</body><body package="GlorpAtlasSystemGeneration">writeAtlas: aName in: aNamespace package: aString	| package |	package := Store.Registry packageNamedOrCreate: aString.	Store.Policies packagePolicy		forcePackage: package		while: [self writeAtlas: aName in: aNamespace].</body><body package="GlorpAtlasSystemGeneration">writeAtlas: aName superclass: aClass in: aNamespace	^(aNamespace		defineClass: aName , aClass atlasNameExtension		superclass: aClass fullName asStrictReference		indexedType: #none		private: false		instanceVariableNames: String new		classInstanceVariableNames: String new		imports: (self importString: aNamespace)		category: 'Generated System')			ifNotNil: 				[:descriptorClass |				self writeAtlasTables: descriptorClass.				self writeAtlasClasses: descriptorClass.				self writeFilteredResolvers: descriptorClass.				self writeAtlasDescriptors: descriptorClass.				descriptorClass]</body><body package="GlorpAtlasSystemGeneration">writeAtlasClasses: descriptorClass	descriptorClass		compile: (self atlasMethodAllClassesAsVisibleIn: descriptorClass asNameSpace)		classified: #classes.	self allClasses do:		[:aClass |		descriptorClass			compile: (self classModelFor: aClass) asAtlasDefinitionMethod			classified: #classes].</body><body package="GlorpAtlasSystemGeneration">writeAtlasDescriptors: descriptorClass		self allClasses		do:			[:aClass | 			descriptorClass				compile: (self descriptorFor: aClass) asAtlasDefinitionMethod				classified: #descriptors].</body><body package="GlorpAtlasSystemGeneration">writeAtlasTables: descriptorClass	descriptorClass		compile: self atlasMethodAllTableNames		classified: #tables.	self tables do:		[:aTable | 		descriptorClass			compile: aTable asAtlasDefinitionMethod			classified: #tables].</body><body package="GlorpAtlasSystemGeneration">writeFilteredResolvers: descriptorClass		typeResolvers do: [:aTypeResolver |		descriptorClass				compile: aTypeResolver asAtlasDefinitionMethod				classified: #resolvers]</body></methods><methods><class-id>Glorp.ConstantExpression</class-id> <category>os-printing</category><body package="GlorpAtlasSystemGeneration">asAtlasFieldInJoin: stream	self printOn: stream.</body></methods><methods><class-id>Glorp.VersionType</class-id> <category>accessing</category><body package="GlorpAtlasSystemGeneration">asAtlasTypeDefinitionMethodInExpressionOn: aStream	super asAtlasTypeDefinitionMethodInExpressionOn: aStream.	self generatesOverExistingValues ifTrue:		[aStream nextPutAll: ' generateOverExistingValues'].</body><body package="GlorpAtlasSystemGeneration">asAtlasTypeDefinitionMethodOn: aStream	"The approach to getting the source of the block in the ifTrue: branch may need development (or replacing with a guaranteed DNU telling the user to add it by hand)."	generator class == AdHocVersionGenerator		ifFalse:			[aStream nextPutAll: 'versionFieldFor: '.			self underlyingType asAtlasTypeDefinitionMethodInExpressionOn: aStream]		ifTrue:			[aStream nextPutAll: 'generatorFor: '.			self underlyingType asAtlasTypeDefinitionMethodInExpressionOn: aStream.			aStream nextPutAll: ' withBlock: '.			aStream nextPutAll: self generator block method decompiledSource].</body></methods><methods><class-id>Glorp.DatabaseTable</class-id> <category>os-printing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod	| stream |	WriteAtlasHelper resetFkc: self.	stream := WriteStream on: String new.	stream		nextPutAll: 'tableFor';		nextPutAll: self name;		nextPutAll: ': aTable'.	self schema isEmpty ifFalse:		[stream			crtab;			nextPutAll: 'aTable schema: ''';			nextPutAll: self schema;			nextPutAll: '''.'; cr].	self fields do: [:aField | aField asAtlasDefinitionMethod: stream].	WriteAtlasHelper writeForeignKeysOn: stream.	^stream contents</body></methods><methods><class-id>Glorp.VariableJoin</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod	"A VariableJoin is a dictionary of joins, each keyed by the class so joined."	| stream |	stream := WriteStream on: String new.	stream nextPutAll: self class name.	self joins keysAndValuesDo:		[:eachClass :eachJoin |		stream			cr; tab; tab; tab; tab;			nextPutAll: 'addJoinFor: '; nextPutAll: eachClass fullName;			cr;tab; tab; tab; tab;			nextPutAll: 'as: ('; nextPutAll: eachJoin asAtlasDefinitionMethod; nextPutAll: ');'].	stream		cr;tab;tab;tab;tab;tab;		nextPutAll: 'yourself'.	^stream contents</body></methods><methods><class-id>Glorp.Mapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDebugDefinitionMethod: stream	(self debugRead or: [self debugWrite]) ifTrue:		[stream			nextPut: $;; crtab: 2;			nextPutAll: 'debugRead: ';			nextPutAll: self debugRead;			nextPut: $;; crtab: 2;			nextPutAll: 'debugWrite: ';			nextPutAll: self debugWrite].	stream  nextPut: $.; crtab.</body><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	"superclass default, called on mappings we do not yet handle;  until we do, insert a halt to prompt the user to do it."	stream		nextPutAll: 'self halt: ''mapping generation unhandled for ';		nextPutAll: self class name;		nextPut: $';		nextPut: $.;		space;		nextPut: $";		nextPutAll: self printString;		nextPut: $";		crtab.</body></methods><methods><class-id>Glorp.HorizontalTypeResolver</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethodOn: stream	"Handle case when useSingleQuery: has non-default setting."	self shouldUseSingleQuery ifTrue:		[stream nextPut: $(].	super asAtlasDefinitionMethodOn: stream.	self shouldUseSingleQuery ifTrue:		[stream			cr;tab;tab;			nextPutAll: 'useSingleQueryIfPossible: true;';			cr;tab;tab;			nextPutAll: 'yourself';			nextPut: $)].</body></methods><methods><class-id>Glorp.IdentityTypeMapping</class-id> <category>writing</category><body package="GlorpAtlasSystemGeneration">asAtlasDefinitionMethod: stream	self attribute ifNotNil: [	]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TypeResolver</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>members system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>GlorpDatabaseType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform selector typeString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabaseTypes</package></attributes></class><class><name>Mapping</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptor attribute debugRead debugWrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>ConstantMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constantValue valueIsSession </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>ActiveRecordDescriptorSystem</name><environment>Glorp.ActiveRecords</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>metadataSession inflector currentDescriptor deferredDescriptorOperations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpActiveRecord</category><attributes><package>GlorpActiveRecord</package></attributes></class><class><name>GlorpAttributeModel</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type collectionType keyType classModel attributeIndex useDirectAccess setSelector canRead canWrite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><class><name>DatabaseField</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>table name isPrimaryKey position type isNullable isUnique isLockKey defaultValue dbDefaultValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>Descriptor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tables mappings system mappedFields cachePolicy typeResolver mapsPrimaryKeys keyFields classModel multipleTableJoin imaginaryTableReplacements mappingsForFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>GlorpExpression</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><class><name>ConstantExpression</name><environment>Glorp</environment><super>Glorp.GlorpExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value alias </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-Expressions</category><attributes><package>GlorpExpressions</package></attributes></class><class><name>DirectMapping</name><environment>Glorp</environment><super>Glorp.Mapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field converter shouldProxy query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>OneToOneMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>EmbeddedValueOneToOneMapping</name><environment>Glorp</environment><super>Glorp.OneToOneMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldTranslation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>FilteredTypeMapping</name><environment>Glorp</environment><super>Glorp.TypeMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>field key keyDictionary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><class><name>ToManyMapping</name><environment>Glorp</environment><super>Glorp.RelationshipMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderBy shouldWriteTheOrderField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>ManyToManyMapping</name><environment>Glorp</environment><super>Glorp.ToManyMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>BasicTypeResolver</name><environment>Glorp</environment><super>Glorp.TypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>concreteMembers subclassDescriptorsBuilt rootDescriptor rootClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>VersionType</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingType generator generatesOverExistingValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>HorizontalTypeResolver</name><environment>Glorp</environment><super>Glorp.BasicTypeResolver</super><private>false</private><indexed-type>none</indexed-type><inst-vars>shouldUseSingleQuery </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>IdentityTypeMapping</name><environment>Glorp</environment><super>Glorp.TypeMapping</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><class><name>PluggableDatabaseConverter</name><environment>Glorp</environment><super>Glorp.DatabaseConverter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stToDb dbToSt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-PostgreSQL</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>GlorpClassModel</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system describedClass subclasses attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpMappings</package></attributes></class><class><name>DatabaseTable</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name schema fields foreignKeyConstraints indexes parent lockKeyFields primaryKeyFields isImaginary replacementSubSelect uniqueConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>Join</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sources targets base outerJoin owningMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpExpressions</package></attributes></class><class><name>VariableJoin</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>joins </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpExpressions</package></attributes></class></st-source>