<?xml version="1.0"?><st-source><!-- Name: GlorpVWPortNonBaseNotice: Copyright 2000-2014  Alan KnightThis dialect-specific prereq component is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: I hold Glorp VW behaviour that we do not want in the base, now that Store uses Glorp, but which conscious users of Glorp will want.	- *EXDI overrides to switch off threading.  These are performance enhancements.  When you hit the DB often for small calls, as Glorp does, threading is slower.  However we do not want base users to be forced into being non-threaded for these calls when they may think they are threaded.	- WriteBarriers:  methods to invoke them are in base Glorp but unused, and the sole reference to GlorpVWWriteBarrierTracker is indirected for portability.  (WebVelocity uses WriteBarriers).DbIdentifier: bear73DbTrace: 446544DbUsername: nrossDbVersion: 8.0 - 1DevelopmentPrerequisites: #(#(#any 'Regex11' '') #(#any 'ODBCEXDI' '') #(#any 'OracleEXDI' '') #(#any 'ODBCThapiEXDI' '') #(#any 'OracleThapiEXDI' '') #(#any 'GlorpVWPort' ''))PackageName: GlorpVWPortNonBaseParcel: #('GlorpVWPortNonBase')ParcelName: GlorpVWPortNonBasePrerequisiteDescriptions: #(#(#name 'Regex11') #(#name 'ODBCEXDI' #applicability #store) #(#name 'OracleEXDI' #applicability #store) #(#name 'ODBCThapiEXDI' #applicability #store) #(#name 'OracleThapiEXDI' #applicability #store) #(#name 'GlorpVWPort' #componentType #package))PrerequisiteParcels: #(#('Regex11' '') #('GlorpVWPort' ''))PrintStringCache: (8.0 - 1,nross)Version: 8.0 - 1Date: 10:44:48 AM September 2, 2014 --><time-stamp>From VisualWorksÂ®, 8.0 of September 2, 2014 on September 2, 2014 at 10:44:48 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>GlorpVWWriteBarrierTracker</name><environment>Glorp</environment><super>Core.ModificationTracker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ephemeronForSession </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpVWPortNonBase</package></attributes></class><comment><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id><body>This is used in conjunction with the WriteBarriers package to use the Cincom Smalltalk Immutability feature to implement register-on-write functionality. Objects read from the database are marked as read-only. When they are modified, this object is notified, and will register them with the current unit of work if they're not registered already, and start a unit of work if there isn't one pending. One tracker exists per GlorpSession and the tracker for that session is responsible for all objects read from the database using that session.Use an ephemeron to hold the GlorpSession, so that a session can be garbage collected. Otherwise, my strong reference will prevent the session from ever being GC'd.Instance Variables	ephemeronForSession	&lt;Ephemeron holding a GlorpSession&gt;	The session with which we register objects when they are modified.</body></comment><methods><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id> <category>private</category><body package="GlorpVWPortNonBase">applyModificationTo: anObject selector: selector index: index value: value	" anObject has been modified. #isTracking: ensures that anObject was read by our session and is in our cache. Now we can put it in to a unit of work and allow the changes to be recordered. "	(self session isRegistered: anObject) ifFalse:		[self session requireUnitOfWork.		self session register: anObject].	super applyModificationTo: anObject selector: selector index: index value: value.</body><body package="GlorpVWPortNonBase">privateTrack: anObject	"Responsibility inherited from our superclass. Do nothing. We already know about all the objects we're tracking."</body><body package="GlorpVWPortNonBase">privateUntrack: anObject	"Responsibility inherited from our superclass. Do nothing. We already know about all the objects we're tracking."</body></methods><methods><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id> <category>private-releasing</category><body package="GlorpVWPortNonBase">mournKeyOf: anEphemeron	"My GlorpSession is no longer referenced, except by me and perhaps other ephemerons. To allow it to be garbage collected, I will release my reference to the GlorpSession. Also, since I need no longer track anything, I tell the session release myself from the list of Trackers."	self session dontUseModificationTracker.	anEphemeron key: nil.	ephemeronForSession := nil.</body></methods><methods><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id> <category>API</category><body package="GlorpVWPortNonBase">isTracking: anObject	"anObject is being modified. One tracker exists per session, so we answer true if anObject is in our cache. "	anObject isGlorpProxy ifTrue: [^false].	ephemeronForSession isNil ifTrue: [^false].	^self session cacheContainsObject: anObject</body></methods><methods><class-id>Glorp.GlorpVWWriteBarrierTracker</class-id> <category>accessing</category><body package="GlorpVWPortNonBase">session	^ephemeronForSession key.</body><body package="GlorpVWPortNonBase">session: aGlorpSession	"Hold my session in an ephemeron, so that I can release the session when necessary. I will be ephemeron's the manager."	ephemeronForSession := Ephemeron key: aGlorpSession value: nil.	ephemeronForSession manager: self</body></methods><methods><class-id>Database.ODBCSession class</class-id> <category>accessing</category><body package="GlorpVWPortNonBase">nonThreadedConnectionClass	"Answer the class to use for connection objects associated with receiver."	^ODBCConnection</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-answer set</category><body package="GlorpVWPortNonBase">describeAnswerColumns	"Fill in the columnDescriptions array."	| xif descrs cbColNameMax columnDescriptionClass szColName pcbColName pfSqlType pcbColDef pibScale pfNullable rc precision colDesc fSqlType longType |	xif := self class xifNonThreaded.	descrs := Array new: self numColumns.	cbColNameMax := (self connection getInformationType: #SQL_MAX_COLUMN_NAME_LEN) + 1.	columnDescriptionClass := self connection class columnDescriptionClass.	[ "Begin unwind protection."	szColName := (xif charDataTypeUnicode: self connection isUnicodeEncoding) perform: xif mallocSelector with: cbColNameMax.	pcbColName := xif SWORD perform: xif mallocSelector with: 1.	pfSqlType := xif SWORD perform: xif mallocSelector with: 1.	pcbColDef := xif UDWORD perform: xif mallocSelector with: 1.	pibScale := xif SWORD perform: xif mallocSelector with: 1.	pfNullable := xif SWORD perform: xif mallocSelector with: 1.	1 to: self numColumns do:		[ :aColumn |		self connection isUnicodeEncoding ifTrue: [			rc := xif SQLDescribeColW: self hstmt					with: aColumn					with: szColName					with: cbColNameMax					with: pcbColName					with: pfSqlType					with: pcbColDef					with: pibScale					with: pfNullable.		] ifFalse: [			rc := xif SQLDescribeCol: self hstmt					with: aColumn					with: szColName					with: cbColNameMax					with: pcbColName					with: pfSqlType					with: pcbColDef					with: pibScale					with: pfNullable.		].		precision := pcbColDef contents.		( traceLevel &gt;= 2) ifTrue:			[ (self traceStream)				print: rc;  nextPutAll: ' = SQLDescribeCol( hstmt=';				nextPutAll: (self  hstmt referentAddress printStringRadix: 16);				nextPutAll: ', icol =';  print: aColumn;				nextPutAll:  ', szColName: '; print: szColName copyCStringFromHeap;				nextPutAll:  ', cbColName: '; print: pcbColName contents;				nextPutAll:  ', fSQLType: '; print: pfSqlType contents;				nextPutAll:  ', cbColDef: '; print: precision;				nextPutAll:  ', ibScale: ';  print: pibScale contents;				nextPutAll:  ', fNullable: ';  print: pfNullable contents;				nextPutAll:  ' )'.			self class trace: self emitTrace ].		( rc == xif SQL_SUCCESS		or: [ rc == xif SQL_SUCCESS_WITH_INFO] ) ifFalse:			[ | errs |		  	errs := self getStatementErrors.			^self class connectionClass unableToDescribeSignal raiseWith: errs errorString: errs first dbmsErrorString ].		"If this is a SQL Native client, a varchar(max), varbinary(max), or nvarchar(max) column has precision = 0.		If so, then reset its precision and sql type to make this column appear to be a LONG."		fSqlType := pfSqlType contents.		(precision = 0 and: [self isSQLNativeClient])			ifTrue: [(longType := self getLongTypeFor: fSqlType) notNil				ifTrue: [precision := self getMaxLongData.						fSqlType := longType]].		(colDesc := columnDescriptionClass new) 			index: aColumn;			name: (szColName copyCStringFromHeap: self encoding);			fSqlType: fSqlType;			type: (xif class fSqlTypeToConversionMap at: colDesc fSqlType);			maxColumnConstraint: precision;			precision: precision;			scale: pibScale contents;			nullable: (pfNullable contents == xif SQL_NULLABLE).		descrs at: aColumn put: colDesc ]	"End unwind protection." ]		ensure:			[ szColName notNil ifTrue: [ szColName freePointer ].			pcbColName notNil ifTrue: [ pcbColName freePointer ].			pfSqlType notNil ifTrue: [ pfSqlType freePointer ].			pcbColDef notNil ifTrue: [ pcbColDef freePointer ].			pibScale notNil ifTrue: [ pibScale freePointer ].			pfNullable notNil ifTrue: [ pfNullable freePointer ] ].	self columnDescriptions: descrs</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-execution</category><body package="GlorpVWPortNonBase">freeStatementExternal: releaseOption	"Release resources associated with a session."	| xif rc |	(self hstmt isNil or: [self hstmt isValid not]) ifTrue: [^self].	xif := self class xifNonThreaded.	rc := xif SQLFreeStmt: self hstmt with: (xif perform: releaseOption).	traceLevel &gt;= 3		ifTrue: 			[(self traceStream)				print: rc;				nextPutAll: ' = SQLFreeStmt( hstmt = ';				nextPutAll: (self hstmt referentAddress printStringRadix: 16);				nextPutAll: ', ';				print: releaseOption;				nextPutAll: ')'.			self class trace: self emitTrace].	rc == xif SQL_SUCCESS		ifFalse: 			[| errs |			errs := self getStatementErrors.			self class connectionClass unableToFreeResourceSignal raiseRequestWith: errs				errorString: errs first dbmsErrorString]</body></methods><methods><class-id>Database.ODBCSession</class-id> <category>private-answer set</category><body package="GlorpVWPortNonBase">hasAnswerSetExternal	| xif rc pccol |	xif := self class xifNonThreaded.	self numColumns: 0. "default to none"	[ "Begin unwind protection."	pccol := xif SWORD perform: xif mallocSelector with: 1.	rc := xif SQLNumResultCols: self hstmt with: pccol.	( traceLevel &gt;= 3 ) ifTrue:		[ (self traceStream)			print: rc;  nextPutAll: ' = SQLNumResultCols( hstmt=';			nextPutAll: (self hstmt referentAddress printStringRadix: 16);			nextPutAll: ', *pccol =';  print: pccol contents;			nextPutAll: ' )'.		self class trace: self emitTrace ].	rc == xif SQL_SUCCESS ifFalse:		[ | errs |		errs := self getStatementErrors.		^self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].	self numColumns: pccol contents.	"End unwind protection." ]		ensure: 			[ pccol notNil ifTrue: [ pccol freePointer ] ].	self numColumns &gt; 0 ifTrue:		[ ^true ].	"Simulate auto-commit transaction behavior?"	self handleAutoCommit.	^false</body></methods><methods><class-id>Database.ExternalDatabaseSession class</class-id> <category>accessing</category><body package="GlorpVWPortNonBase">xifNonThreaded	"Answer the ExternalInterface subclass instance in use."	^self nonThreadedConnectionClass xif</body></methods><methods><class-id>Database.OracleSession class</class-id> <category>accessing</category><body package="GlorpVWPortNonBase">nonThreadedConnectionClass	"Answer the connection class for sessions"		^OracleConnection</body></methods><methods><class-id>Database.OracleSession</class-id> <category>private-answer set</category><body package="GlorpVWPortNonBase">cancelAnswerSetExternal	"Explicity cancel current or previous query results."	| xif  rtval errs hstmt herr |	xif := self class xifNonThreaded.	hstmt := self hstmt.	herr := self herr.	self useStatementCaching ifTrue: [		rtval := xif OCIStmtFetch2: hstmt				with: herr				with: 0				with: xif OCI_FETCH_NEXT				with: 1				with: xif OCI_DEFAULT.	traceLevel &gt;= 2 		ifTrue: 			[(self traceStream)				print: rtval;				nextPutAll: ' = OCIStmtFetch2( hstmt =';				nextPutAll: (hstmt referentAddress printStringRadix: 16);				nextPutAll: ', herr = ';				nextPutAll: (herr referentAddress printStringRadix: 16);				nextPutAll: ' , nrows = 0 ';				nextPutAll: ' , orientation = OCI_FETCH_NEXT ';				nextPutAll: ' , fetchOffset = 1 ';				nextPutAll: ' , mode = OCI_DEFAULT)'.			self class trace: self emitTrace].	] ifFalse: [		rtval := xif OCIStmtFetch: hstmt 						with: herr 						with: 0						with: xif OCI_FETCH_NEXT					     with: xif OCI_DEFAULT.		(traceLevel &gt;= 2) ifTrue: 			[ (self traceStream)			print: rtval; nextPutAll: ' = OCIStmtFetch( hstmt =';			nextPutAll: (hstmt referentAddress printStringRadix: 16);			nextPutAll: ', herr = ';			nextPutAll: (herr referentAddress printStringRadix: 16);			nextPutAll: ' , nrows = 0 ';			nextPutAll: ' , orientation = OCI_FETCH_NEXT '; 			nextPutAll: ' , mode = OCI_DEFAULT)'.			self class trace: self emitTrace].	].	(rtval == xif OCI_NO_DATA)		ifTrue: [	"Try to flush the server's error list"				self getStatementErrors.			     	^nil.  ].	(rtval == xif OCI_SUCCESS	or: [rtval == xif OCI_SUCCESS_WITH_INFO])		ifFalse: [ errs := self getStatementErrors.			       ^self class connectionClass unableToFetchDataSignal raiseWith: errs errorString: errs first dbmsErrorString ].				 	^self</body><body package="GlorpVWPortNonBase">defineRowBufferExternal: aColumn buffer: aBuffer	| xif rtval |	xif := self class xifNonThreaded.	self definePointer isNil ifTrue: [		self definePointer: (xif OCIDefine pointerType perform: xif mallocSelector with: 1).		self definePointer contents: (xif OCIDefine pointerType cast: nil). "This is essential!!"	].	rtval := xif 				OCIDefineByPos: self hstmt				with: self definePointer				with: self herr				with: aColumn				with: aBuffer pointer				with: aBuffer elementSize				with: aBuffer databaseType				with: aBuffer indicatorsPointer				with: aBuffer lengthsPointer				with: aBuffer rcodesPointer				with: xif OCI_DEFAULT.	rtval == xif OCI_SUCCESS 		ifFalse: 			[| errs |			errs := connection getErrors.			^self connection class unableToBindSignal raiseWith: errs errorString: errs first dbmsErrorString].	(self isUnicodeEncoding or: [ aBuffer isUnicodeColumn ]) ifTrue: [		self connection setAttribute: xif SQLCS_NCHAR type: #OCI_ATTR_CHARSET_FORM 				descriptor: self definePointer contents type: #OCI_HTYPE_DEFINE	].</body></methods><methods><class-id>Database.OracleThreadedConnection class</class-id> <category>private-accessing</category><body package="GlorpVWPortNonBase">xifNonThreaded	^self superclass xif.</body></methods><methods><class-id>Database.OracleConnection class</class-id> <category>private-accessing</category><body package="GlorpVWPortNonBase">xifNonThreaded	"Answer the ExternalInterface subclass instance to use."	^self xif.</body></methods><methods><class-id>Database.OracleConnection</class-id> <category>private-execution</category><body package="GlorpVWPortNonBase">getAttributeExternal: attributePointer type: attributeType length: attributeLengthPointer descriptor: descriptor  type: descriptorType	| xif rtval |	xif := self class xifNonThreaded.		rtval := xif OCIAttrGet: descriptor				    with:  (xif perform: descriptorType  )				    with:  attributePointer 				    with:  attributeLengthPointer				    with: (xif perform: attributeType )				    with: self herr.	(traceLevel &gt;= 3) ifTrue:	[ (self traceStream)	print: rtval;  nextPutAll: ' = OCIAttribGet( descriptor = ';	nextPutAll: (descriptor referentAddress printStringRadix: 16);	nextPutAll: ',  descriptorType = '; 	nextPutAll: descriptorType printString;	nextPutAll: ', attribute  = ';	nextPutAll: (attributePointer referentAddress printStringRadix: 16);	nextPutAll: ', attributeType  = ';      nextPutAll: attributeType  printString;	nextPutAll: ', length  = '; print: attributeLengthPointer contents;	nextPutAll: ', herr = ';	nextPutAll: (self herr referentAddress printStringRadix: 16);	nextPutAll: ')'.	self class trace: self emitTrace ].	(rtval == xif OCI_SUCCESS) ifFalse: 		[ | errs |		errs := self getErrors.	        ^self class unableToRetrieveDescriptorInfoSignal raiseWith: errs errorString: errs first dbmsErrorString  ]</body><body package="GlorpVWPortNonBase">getSchemaObjectAttributeFromDescriptorExternal: hDescriptor type: descriptorType startingAt: position	"Retrieve parameter descriptor for the ."	| xif  rtval herr schemaObjectAttribute |	xif := self class xifNonThreaded.	herr := self herr.	((self parameterPointer isNil) or: [ self parameterPointer isValid not ]) ifTrue:  [		self parameterPointer: ( xif OCIParam pointerType perform: xif mallocSelector with: 1).		self parameterPointer contents: (xif OCIParam pointerType cast: nil ).	].	rtval := xif OCIParamGet: hDescriptor						with: (xif perform: descriptorType)						with: herr 						with: self parameterPointer						with: position.	(rtval == xif OCI_NO_DATA)		ifTrue: [ ^nil ].	(rtval == xif OCI_SUCCESS)		ifFalse: [ ^nil ].	schemaObjectAttribute := self parameterPointer contents.	^schemaObjectAttribute</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>OracleConnection</name><environment>Database</environment><super>Database.ExternalDatabaseConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>henvHolder herrHolder hsvcctxHolder hsrvrHolder hsessHolder htxnHolder executionMode transactionMode authenticationMode useStatementCaching attributeLengthPointerHolder attributePointerHolder parameterPointerHolder descriptorPointerHolder unicodeEncoding oracleEncodingId oracleUnicodeEncodingId </inst-vars><class-inst-vars>signalMap libraryInitialized </class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class><class><name>ModificationTracker</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ODBCSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hstmtHolder resultsCache bindValuePointers mustResendQueryHolder fetchLongResultsAnyOrder maxLongData sqlStatementOptionCache queryIsPROC unicode encoding unicodeEncoding lobBufferSize currentRowIndex rowsInBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-ODBC</category><attributes><package>ODBCEXDI</package></attributes></class><class><name>OracleSession</name><environment>Database</environment><super>Database.ExternalDatabaseSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultsCache hstmtHolder herrHolder bindValuePointersHolder maxLongBytes queryIsPLSQL currentRowIndex totalRows rowsInBlock dependentLobs sqlPointerHolder maxBindSize answerLobProxy defaultDisplayLobSize isReleasedFromCacheHolder lobBufferSize reuseColumnBuffers definePointerHolder bindPointerHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Database-Oracle</category><attributes><package>OracleEXDI</package></attributes></class></st-source>