<?xml version="1.0"?><st-source><!-- Name: GlorpVWPortNotice: Copyright 2000-2014  Alan KnightThis dialect-specific prereq component is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This is a dialect-specific pre-req component for the GLORP system, an open-source library for persisting Smalltalk objects in relational databases.DbIdentifier: bear73DbTrace: 475239DbUsername: nrossDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'Browser-Refactorings' ''))Namespace: GlorpPackageName: GlorpVWPortParcel: #('GlorpVWPort')ParcelName: GlorpVWPortPrerequisiteDescriptions: #(#(#name 'Browser-Refactorings' #applicability #store))PrintStringCache: (8.2 - 1,nross)Version: 8.2 - 1Date: 12:18:13 PM October 23, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (oct15.3) of October 16, 2015 on October 23, 2015 at 12:18:13 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Glorp</name><environment>Smalltalk</environment><private>false</private><imports>			Smalltalk.*			</imports><category>GlorpMisc</category><attributes><package>GlorpVWPort</package></attributes></name-space><class><name>ProtoObject</name><environment>Smalltalk</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpVWPort</package></attributes></class><comment><class-id>ProtoObject</class-id><body>This is an abstract superclass for Proxies and other objects that subclass nil and implement a doesNotUnderstand: handler. Some dialects (e.g. Dolphin) provide this directly. For others it needs to be provided in the Glorp&lt;Dialect&gt;Port package/Application and provided with the appropriate set of methods.</body></comment><class><name>EqualOnContentReadStream</name><environment>Core</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>GlorpVWPort</package></attributes></class><comment><class-id>Core.EqualOnContentReadStream</class-id><body>Two EqualAdapterReadStreams are equal if their collections are equal.  This is the sole point of the class:  to avoid obstructing equality checks when using streams to adapt objects.</body></comment><class><name>EphemeralValue</name><environment>Kernel</environment><super>Kernel.Ephemeron</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Support</category><attributes><package>GlorpVWPort</package></attributes></class><comment><class-id>Kernel.EphemeralValue</class-id><body>This is like an ephemeron, but the value rather than the key is the ephemeral thing. Implement key/key: and value/value: to swap the inst var usage. This can be confusing in inspectors.</body></comment><class><name>EphemeralValueDictionary</name><environment>Core</environment><super>Core.EphemeronDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>keepAround </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>GlorpVWPort</package></attributes></class><comment><class-id>Core.EphemeralValueDictionary</class-id><body>This is a weak equality dictionary where the values are the weak things, not the keys. So if no one references the value any longer, it will be deleted. </body></comment><methods><class-id>ProtoObject</class-id> <category>As yet unclassified</category><body package="GlorpVWPort">== anObject	"Answer true if the receiver and the argument are the same object (have the same	object pointer) and false otherwise.  Do not redefine the message == in any	other class!  No Lookup."	&lt;primitive: 110&gt;	self primitiveFailed</body><body package="GlorpVWPort">basicAt: index	"Answer the value of an indexable field in the receiver. Fail if the	argument index is not an Integer or is out of bounds. Do not override this	message in any subclass."	&lt;primitive: 60&gt;	index isInteger ifTrue: [^self subscriptBoundsErrorFor: #basicAt: index: index].	index respondsToArithmetic		ifTrue: [^self basicAt: index asSmallInteger]		ifFalse: [^self nonIntegerIndexError: index]</body><body package="GlorpVWPort">basicSize	"Answer the number of indexable fields in the receiver. This value is the	same as the largest legal subscript. Do not override in any subclass."	&lt;primitive: 62&gt;	"The number of indexable fields of fixed-length objects is 0"	^0</body><body package="GlorpVWPort">beImmutable	"Set the receiver to be immutable"	self isImmutable: true.	^self</body><body package="GlorpVWPort">beMutable	"Set the receiver to be mutable"	self isImmutable: false.	^self</body><body package="GlorpVWPort">become: otherObject 	"Copy the regular VisualWorks primBecome:"	"Swap the instance data and appropriate header information of the receiver and the	 argument, otherObject. In other words, transform the receiver into the argument and	 vice-versa.  Fail if either object is an immediate or a MethodContext or a	 BlockContext or if there is insufficient memory to perform the become, or if either	 object is immutable. Answer with the argument which is now the semantic equivalent	 of the object that formerly denoted the receiver."	&lt;primitive: 72 errorCode: errCode&gt;	^(errCode ~~ nil	   and: [errCode name = #'no modification'])		ifTrue: [self noModificationErrorFor: #primBecome: index: nil value: otherObject]		ifFalse: [self handleFailedBecome: otherObject]</body><body package="GlorpVWPort">class	^ProtoObject</body><body package="GlorpVWPort">doesNotUnderstand: aMessage 	3 error: 'dNU on ProtoObject. This should never happen'.</body><body package="GlorpVWPort">identityHash	&lt;primitive: 75&gt;	self primitiveFailed</body><body package="GlorpVWPort">inspect	"Create and schedule an Inspector in which the user can examine the	receiver's variables."	Tools.Trippy.Inspector useSimpleInspector		ifTrue: [Inspector openOn: self]		ifFalse: [Tools.Trippy.Inspector openOn: self]</body><body package="GlorpVWPort">instVarAt: index	"Answer with a fixed variable in an object.  The numbering of the variables	corresponds to the named instance variables.  Fail if the index is not an	Integer or is not the index of a fixed variable."	&lt;primitive: 73&gt;	"Access beyond fixed variables."	^self basicAt: index - self class instSize</body><body package="GlorpVWPort">instVarAt: anInteger put: anObject	"Store a value into a fixed variable in the receiver.  The numbering of	the variables corresponds to the named instance variables.  Fail if	the index is not an Integer or is not the index of a fixed variable.	Answer with the value stored as the result.  (Using this message	violates the principle that each object has sovereign control over the	storing of values into its instance variables.)."	&lt;primitive: 74&gt;	"Access beyond fixed fields"	^self basicAt: anInteger - self class instSize put: anObject</body><body package="GlorpVWPort">isImmediate	^false.</body><body package="GlorpVWPort">isImmutable	"Answer if the receiver is immutable.  This is always true of immediates.	 Cannot fail."	&lt;primitive: 1063&gt;	^false</body><body package="GlorpVWPort">isImmutable: aBoolean	"Set the receiver's immutability.   Answer if the receiver was	 previously immutable.  Fail if the argument is not a boolean	 or if the receiver is immediate and the argument is false."	&lt;primitive: 1064 errorCode: error&gt;	^self primitiveFailed</body><body package="GlorpVWPort">nextObject	"Answer with the next object following the receiver in	the enumeration of all non-immediate objects. Fail if there is no such	object or if the receiver is an immediate object. See ObjectMemory class	someObject."	&lt;primitive: 531&gt;	^0</body><body package="GlorpVWPort">nilFields</body><body package="GlorpVWPort">noModificationErrorFor: selector index: index value: value	^(NoModificationError receiver: self selector: selector index: index value: value) raiseRequest</body><body package="GlorpVWPort">nonIntegerIndexError: index	"Raise a signal indicating that an improper object was used as an index."	^Object nonIntegerIndexSignal raiseWith: index</body><body package="GlorpVWPort">performMethod: method	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver."	^self performMethod: method arguments: #()</body><body package="GlorpVWPort">performMethod: method arguments: args	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other argument is the list of arguments of the method.	The number of arguments expected by the method must match the size of the	Array."	^method valueWithReceiver: self arguments: args</body><body package="GlorpVWPort">performMethod: method with: arg1	"Evaluate the first argument, a CompiledMethod, with the receiver as	receiver.  The other argument is the argument of the method. The method	must be expecting one argument."	^self performMethod: method arguments: (Array with: arg1)</body><body package="GlorpVWPort">primitiveFailed	"Announce that a primitive has failed and there is no appropriate 	Smalltalk code to run."	3 error: (#errPrimitiveFailed &lt;&lt; #dialogs &gt;&gt; 'a primitive has failed')</body><body package="GlorpVWPort">subscriptBoundsErrorFor: selector index: index	"Raise a signal indicating that an improper index was used as an index in a send of selector with index."	^(SubscriptOutOfBoundsError receiver: self selector: selector index: index value: nil) raiseRequest</body><body package="GlorpVWPort">whileMutableDo: aBlock	aBlock value.</body></methods><methods><class-id>ProtoObject</class-id> <category>printing</category><body package="GlorpVWPort">forStackDumpPrintUsing: aPolicy	^aPolicy printObject: self</body></methods><methods><class-id>ProtoObject</class-id> <category>overrides</category><body package="GlorpVWPort">inspectorActions	"Answer a collection of Action instances listing the common actions	a user might want to perform on an object. They are added to the 	inspector's Object menu."	^#()</body><body package="GlorpVWPort">inspectorClasses	^self getValue inspectorClasses.</body><body package="GlorpVWPort">inspectorCollaborators	"Answer a collection of Collaborator instances listing the important other	objects a person looking at this one might want to see. For example,	collaborators of a view would be its model and the controller.	Collaborators are added to the inspector's Go menu."	^#()</body><body package="GlorpVWPort">inspectorExtraAttributes	^#()</body><body package="GlorpVWPort">inspectorHierarchies	^#()</body><body package="GlorpVWPort">inspectorSize	^0</body><body package="GlorpVWPort">inspectorString	"For Object Studio compatibility"	^self printString.</body></methods><methods><class-id>ProtoObject</class-id> <category>doesNotUnderstand</category><body package="GlorpVWPort">_isProxy	^true.</body></methods><methods><class-id>ProtoObject class</class-id> <category>accessing</category><body package="GlorpVWPort">toolListIcon	^BehaviorIcons Proxy</body></methods><methods><class-id>Core.EqualOnContentReadStream</class-id> <category>comparing</category><body package="GlorpVWPort">= anObject	^self class = anObject class and:		[self collection = anObject collection]</body><body package="GlorpVWPort">hash	^collection hash</body></methods><methods><class-id>Core.EqualOnContentReadStream</class-id> <category>private</category><body package="GlorpVWPort">collection	"Our hierarchy has this (with heavy warning against use) in some dialects, not in others.  We don't need the warning, given the limited use of this class, and must have it, so provide it in case it's not there in a superclass."	^collection</body></methods><methods><class-id>Kernel.EphemeralValue</class-id> <category>accessing</category><body package="GlorpVWPort">key	^value.</body><body package="GlorpVWPort">key: anObject	value := anObject</body><body package="GlorpVWPort">key: aKey value: anObject 	"Store the arguments as the variables of the receiver."	self key: aKey.	self value: anObject</body><body package="GlorpVWPort">value	^key.</body><body package="GlorpVWPort">value: anObject	key := anObject.</body></methods><methods><class-id>Kernel.EphemeralValue</class-id> <category>comparing</category><body package="GlorpVWPort">= anAssociation 	"Answer whether the receiver is equal to the argument."	^self class = anAssociation class and: [self key == anAssociation key]</body><body package="GlorpVWPort">hash	"I implement identity based comparison, rather than equality variant implemented in the superclass chain. We return a hash value here that is consistent with our local = method. See Object&gt;&gt;hash for more info on the hash/comparison invariant. Note that we are sneakily switching our key and value, which is why the reference to key needs to be a message send."	^self key identityHash</body></methods><methods><class-id>Core.EphemeralValueDictionary</class-id> <category>accessing</category><body package="GlorpVWPort">createKey: key value: value	^(EphemeralValue key: key value: value) manager: manager</body></methods><methods><class-id>Core.EphemeralValueDictionary</class-id> <category>finalization</category><body package="GlorpVWPort">mournKeyOf: anEphemeron	"We always remove from the dictionary, whether or not we have an explicit manager"	manager == nil ifTrue:		[self error: (#noManagerToMourn &lt;&lt; #dialogs &gt;&gt; 'no manager to mourn')].	self removeKey: anEphemeron key ifAbsent: [].	manager == self ifFalse: [manager mournKeyOf: anEphemeron].</body></methods><methods><class-id>Core.EphemeralValueDictionary</class-id> <category>private</category><body package="GlorpVWPort">findKeyOrNil: key  	"We want an equality dictionary, but ephemeron dictionaries are by identity. Override findKeyOrNil: back again to the super super implementation."	| location length probe pass |	length := self basicSize.	pass := 1.	location := self initialIndexFor: key hash boundedBy: length.	[(probe := self basicAt: location) == nil or: [probe key = key]]		whileFalse: 			[(location := location + 1) &gt; length				ifTrue: 					[location := 1.					pass := pass + 1.					pass &gt; 2 ifTrue: [^self grow findKeyOrNil: key]]].	^location</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GlorpVWPort">atIndex: anIndex	"This method offers a way of providing polymorphism between me and classes that want to imitate me but cannot override #at: safely.  It is useful in cross-dialect applications such as Glorp.  Use at:, not this method, unless this polymorphism is wanted."	^self at: anIndex</body></methods><methods><class-id>Refactory.Browser.RenameObjectAndMethodsRefactoring</class-id> <category>preconditions</category><body package="GlorpVWPort">classNameInSelectorPatternsGlorp	"Glorp framework methods requiring rename if matching classes are renamed."	&lt;classNameInSelectorPatterns: #('classModelFor&lt;1s&gt;:' 'descriptorFor&lt;1s&gt;:')&gt;</body></methods><methods><class-id>Core.Number</class-id> <category>printing</category><body package="GlorpVWPort">glorpPrintSQLOn: aCommand	"VisualWorks appends 's' to the printString of a FixedPoint.  A Double's printString will have either an internal or a suffixing 'd'.  This happens way down in the guts of the printing, so it's hard to avoid.  If there is a suffixing letter, skip it;  if not, convert any internal 'd' to an 'e'."	| vwPrintString |	vwPrintString := self printString.	aCommand nextPutAll:		(vwPrintString last isDigit			ifFalse: [vwPrintString allButLast: 1]			ifTrue: [vwPrintString collect: [:char | char = $d ifFalse: [char] ifTrue: [$e]]]).</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>glorp</category><body package="GlorpVWPort">asGlorpExpression	^self asGlorpExpressionOn: BaseExpression new.</body><body package="GlorpVWPort">asGlorpExpressionForDescriptor: aDescriptor	| base |	base := BaseExpression new.	base descriptor: aDescriptor.	^self asGlorpExpressionOn: base.</body><body package="GlorpVWPort">asGlorpExpressionOn: anExpression 	^(self value: MessageArchiver new) asGlorpExpressionOn: anExpression</body><body package="GlorpVWPort">asGlorpExpressionOn: anExpression in: aQuery 	^(self value: (MessageArchiver new privateGlorpQuery: aQuery)) asGlorpExpressionOn: anExpression.</body><body package="GlorpVWPort">asGlorpExpressionOn: anExpression withUltimateBase: aBaseExpression	"Build the expression, knowing that some parts of it may refer to an outer context based on aBaseExpression. This is primarily useful for subselect blocks"	| archiver tree |	archiver := MessageArchiver new.	tree := self value: archiver.	^tree asGlorpExpressionOn: anExpression basedOn: archiver withUltimateBase: aBaseExpression.</body><body package="GlorpVWPort">glorpIsBlock	^true.</body></methods><methods><class-id>Core.Fraction</class-id> <category>printing</category><body package="GlorpVWPort">glorpPrintSQLOn: aCommand	"Convert Fractions to FixedPoints (more robust over the whole possible range than either asFloat or asDouble) with up to 15 digits of scale beyond their first or second significant digit (similar to Double) and print that.  (If we wanted the precision of Float, we would preserve 6, not 15.  Changing the precision of the 2 log: 10 value from Float, i.e. 0.30103, to Double does not not seem to be a significant driver, in part because the next couple of digits round to zero.)"	| reducedSelf |	reducedSelf := self reduced.	reducedSelf := reducedSelf asFixedPoint:		(((reducedSelf denominator highBit - reducedSelf numerator highBit) max: 0) * 0.30103) floor + 15.	^reducedSelf glorpPrintSQLOn: aCommand</body></methods><methods><class-id>Core.Date</class-id> <category>printing</category><body package="GlorpVWPort">months	^self monthIndex.</body></methods><methods><class-id>Core.Timestamp</class-id> <category>accessing</category><body package="GlorpVWPort">days	^self day</body><body package="GlorpVWPort">monthIndex	^month</body><body package="GlorpVWPort">months	^self month</body><body package="GlorpVWPort">years	^self year</body></methods><methods><class-id>Core.Object</class-id> <category>glorp</category><body package="GlorpVWPort">glorpEndOfIndexedInstVars	"Return the index at which indexed instance variables start. The same as basicSize for most dialects, but funny for ObjectStudio"	^self basicSize.</body><body package="GlorpVWPort">glorpIsBlock	^false.</body><body package="GlorpVWPort">glorpStartOfIndexedInstVars	"Return the index at which indexed instance variables start. 1 for most dialects, but funny for ObjectStudio"	^1.</body></methods><methods><class-id>Core.Text</class-id> <category>printing</category><body package="GlorpVWPort">glorpPrintSQLOn: aCommand    self asString glorpPrintSQLOn: aCommand.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>RenameObjectAndMethodsRefactoring</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RenameObjectRefactoring</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodRefactorings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Browser-Refactorings</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Ephemeron</name><environment>Kernel</environment><super>Kernel.WeakKeyAssociation</super><private>false</private><indexed-type>ephemeron</indexed-type><inst-vars>manager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Support</category><attributes><package>System-Support</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>EphemeronDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>accessLock manager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>