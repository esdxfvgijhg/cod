<?xml version="1.0"?><st-source><!-- Name: GlorpTestNotice: Copyright 2000-2015 Alan Knight, Niall RossThese tests are made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.BundleName: GlorpTestBundleStructure: a Store.BundleForParcelComment: To set the database against which these tests will be run, put its login in the	GlorpDatabaseLoginResource.DefaultLoginshared variable.  Example logins for various databases are in methods on the class side of GlorpDatabaseLoginResource.When the tests are first run, the GlorpDemoTablePopulatorResource creates tables required, then sets a status variable so this is not redone in later runs.  To unset this variable and force removal and recreation of the test tables, do	GlorpDemoTablePopulatorResource invalidateSetupSome tests will not pass on some databases;  usually, this is noted in their comments.DevelopmentPrerequisites: #(#(#any 'Glorp' '') #(#any 'SUnit' ''))Parcel: nilParcelName: GlorpTestPrerequisiteParcels: #(#('Glorp' '') #('SUnit' ''))Version: 8.3 - 27Date: 3:31:37 PM June 30, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.5) of June 30, 2017 on June 30, 2017 at 3:31:37 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>GlorpTestNamespace</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></name-space><class><name>GlorpDocument</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id whatever attachments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AAGlorp</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDemoTablePopulatorResource</name><environment>Glorp</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>login </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpMockAccessor</name><environment>Glorp</environment><super>Glorp.DatabaseAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTravelFolder</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name files unordered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTypeTestsModelClass</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id test </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>AnySatisfyTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.AnySatisfyTest</class-id><body>This test verifies that nested #anySatisfy: blocks do not throw an exception.  It also tests #isEmpty and #sqlCount in #retrieve: blocks, and in ANDed and ORed queries.</body></comment><class><name>GlorpTestCase</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpRelativeFieldTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpRelativeFieldTest</class-id><body>An alternative to optimistic locking is to write an incremental update, not an absolute value, to a field.  My various tests check the writing of these values and/or whether Glorp then recovers the post-write actual values.</body></comment><class><name>GlorpAlphaSystemTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>glorpDBAccessor glorpSession </inst-vars><class-inst-vars></class-inst-vars><imports>			Glorp.*			</imports><category></category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpAlphaSystemTest</class-id><body>I hold tests for some user-observed issues.  These tests use the AlphaARsDescriptorSystem (so named because it is a schematic model of alphabetised class and instVar names created to illustrate these issues).  They use the standard GlorpTest resources to create the tables but connect via their own accessor and session.  The tests have names but also numbers to connect them to the original issues.Instance Variables:	glorpDBAccessor	&lt;DatabaseAccessor&gt;	accessor for test, created from DefaultLogin	glorpSession		&lt;GlorpSession&gt;	session for test, created from DefaultLogin</body></comment><class><name>GlorpRowMapTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowMap a1 b1 table1 row2 platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpHorizontalInheritanceTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDatabasePlatformTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpConstantMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mappingToClass mappingToRow mappingToSession slot </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDatabaseBasedTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpSessionBasedTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpObjectMappedToImaginaryTableTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>example example2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpRowMapUnificationTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>t1 t2 t3 f1 f2 f3 o1 o2 o3 rowMap platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpMultipleGroupingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpMultipleGroupingTest</class-id><body>Previously, grouping in Glorp Queries only accepted a single expression. It is of course easy to write a multiple groupBy: that would return conflicting values for one of the returned fields.  (When run, this raises an error demanding omission or aggregation of that field.)  Except for this need for greater care in relating the query groupings to the data searched and the fields/aggregates requested for retrieval, multiple groupings are very like multiple orderings.  The facility has therefore been added.</body></comment><class><name>GlorpSortedCollectionTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpOptimisticLockingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpOptimisticLockingTest</class-id><body>In #tableForBOOK: we provide a lock key field 'VERSION' whose generated value is incremented whenever a row is updated.  This tests that clashing updates are blocked and legitimate ones are allowed.  Contrary to the (8.2 and after) lock field default, we make the lock field nullable so we can test updates to a NULL lock field.</body></comment><class><name>GlorpDatabaseSequenceTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sequence table row2 row1 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpMediaType</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name mimeType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTestUpdatingTimestampInRecord</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>DefaultableThing</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id boolean integer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpOrderedDeleteTest</name><environment>Smalltalk</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Glorp.*			private XProgramming.SUnit.*			</imports><category></category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>GlorpOrderedDeleteTest</class-id><body>Test deleting objects with ordered links to others.  If the link table were to have an order field and no primary key, Glorp would compute the primary key to include the order field, but deletion from within the ordered collection would then automatically recompute the order field numbers of all later items.  We verify</body></comment><class><name>ClassO</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassO attrBClassO attrCClassO attrDClassO </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpObjectMappedToFunctionTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpMessage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>folder user subject contents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpReservation</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id passenger passengers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpProxyEqualityTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session proxy proxy2 stub2 stub </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpWarehouse</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id address currentItem items </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpWorkingStiff</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpWorkingStiff</class-id><body>Abstract 'worker' superclass object, named to avoid clash with more ordinary names for such a class.Instance Variables	id	&lt;Integer&gt;		name	&lt;String&gt;</body></comment><class><name>GlorpSalariedEmployee</name><environment>Glorp</environment><super>Glorp.GlorpWorkingStiff</super><private>false</private><indexed-type>none</indexed-type><inst-vars>salary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpSalariedEmployee</class-id><body>GlorpSalariedEmployee is currently a standalone class unrelated to the rest of its hierarchy.Instance Variables:	salary	&lt;Number&gt;	to test immutable literal values</body></comment><class><name>GlorpWorker</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name pendingJobs finishedJobs priorityJobs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTestDescriptorSystem</name><environment>Glorp</environment><super>Glorp.DescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTestDescriptorSystem</class-id><body>This is an abstract superclass for all descriptor systems whose tables should be set up as part of the standard GLORP testing process. See GlorpDemoTablePopulatorResource.</body></comment><class><name>GlorpVideoDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpVideoDescriptorSystem</class-id><body>This descriptor system represents a video rental/sales store which sells both online and in a physical store. The interesting bit is that there is no customer table, but there is a customer object. In the database, orders and credit status are linked directly to the store. We synthesize a customer object out of those relationships.</body></comment><class><name>GlorpTestModelClass</name><environment>Glorp</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTestModelClass</class-id><body>An abstract superclass providing convenience methods for domain objects to facilitate testing.</body></comment><class><name>GlorpVideoPurchase</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title price inStore customer store </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCompositeKeyDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id><body>This is a system designed to test the use of composite keys. Its model is an email message system, where we have users, folders, keyed by name and owning user, and messages, keyed by a message id, folder name, and owning user.</body></comment><class><name>GlorpWorkerDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpExpressionJoiningTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source target base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTaskedWorker</name><environment>Glorp</environment><super>Glorp.GlorpWorkingStiff</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tasks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTableTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>descriptors dbPlatform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpPrimaryKeyExpressionWithConstantTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression compoundExpression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpCommitOrderTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>t1 t2 t3 t1id t2id t3id platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpInventoryItem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpExpressionTableAliasingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>ClassB</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassB attrBClassB attrCClassB attrDClassB </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDescriptorTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTravelAgency</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name agents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTravelAgency</class-id><body>This represents a travel agency. The interesting persistence feature of these is that they are embedded in the agent table, but also treated as unique objects with their own relationships.Instance Variables:	agents	&lt;Collection of: GlorpTravelAgent&gt;	description of agents	name	&lt;String&gt;	description of name</body></comment><class><name>GlorpDatabaseTypeIndividualDBTests</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type stType connection session table </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpNumeric52Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTreeNode</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id children parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTreeNode</class-id><body>I model a parent-child relationships to test them in orderinary SQL and in recursive SQL.Instance Variables:	children	&lt;Collection&gt;	child tree nodes	id	&lt;Integer&gt;	unique id for tree node	parent	&lt;GlorpTreeNode&gt;	parent tree node</body></comment><class><name>GlorpPublisherEmployee</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name jobTitle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpItemWithQty</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name qty totalSales </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpItemWithQty</class-id><body>GlorpItemWithQty works with a table having a "relative field", that is a field whose true value is irrelevant to the client, who only needs to add or subtract from whatever that column holds. A relatvie field allows for blind incrementing and decrementing, where even optimistic locking is unecessary, eliminating the need for round trips (if the lock were to detect a stale cache).Instance Variables:	id	&lt;Integer&gt;	The item id (pkey).	name &lt;String&gt;	The item name.	qty	&lt;Integer&gt;	The number of items currently presumed in stock.	totalSales &lt;Double&gt; The total revenue from sales (perhaps renamed to #totalRevenue).</body></comment><class><name>GlorpFilteringQueryTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTinyPublisher</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name titles titlesWithNumberInStock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>IdentityHashPrintingObject</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.IdentityHashPrintingObject</class-id><body>This is just an object we can easily identify by identity, used for transaction test debugging. We can put these into a transaction and easily distinguish them from their copies.</body></comment><class><name>GlorpCursoredCollectionTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpBreadthFirstTopologicalSortItem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent id relatedItems status </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDBTypeTestsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTypeTests</package></attributes></class><comment><class-id>Glorp.GlorpDBTypeTestsPackage</class-id><body>This class represents package information for the GlorpDBTypeTests package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>ClassE</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassE attrBClassE </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>ClassG</name><environment>Glorp</environment><super>Glorp.ClassE</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassG </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTax</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name taxes supertax </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpSurcharge</name><environment>Glorp</environment><super>Glorp.GlorpTax</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseTypeDBTests</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type stType connection session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTypeComparisonTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpEncyclopediaDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id><body>This is a set of test descriptors for dealing with different variations of dictionary mappings.</body></comment><class><name>GlorpEncyclopediaConditionalTestSystem</name><environment>Glorp</environment><super>Glorp.GlorpEncyclopediaDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpEncyclopediaConditionalTestSystem</class-id><body>I add a conditional mapping to an entry and another to an author.  These mappings are either to an actual entry or to a pseudo-entry held by the encylopedia, depending on the size of the text supplied.</body></comment><class><name>GlorpNonperishableItem</name><environment>Glorp</environment><super>Glorp.GlorpInventoryItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serialNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpUnassembledItem</name><environment>Glorp</environment><super>Glorp.GlorpNonperishableItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>assemblyCost </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpEmployee</name><environment>Glorp</environment><super>Glorp.GlorpWorkingStiff</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpEmployee</class-id><body>I am the root class of a FilteredType-resolved hierarchy.</body></comment><class><name>GlorpManager</name><environment>Glorp</environment><super>Glorp.GlorpEmployee</super><private>false</private><indexed-type>none</indexed-type><inst-vars>branch </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>AbstractLOBTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp-DBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpClobTest</name><environment>Glorp</environment><super>Glorp.AbstractLOBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTypeTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpDemoDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpLinkTableAnywhereDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpDemoDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpLinkTableAnywhereDescriptorSystem</class-id><body>This is the same as the demo descriptor system, but with small modifications to use link tables in different places.</body></comment><class><name>GlorpTextTest</name><environment>Glorp</environment><super>Glorp.AbstractLOBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTimestampTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTimestampWithTimeZoneTest</name><environment>Glorp</environment><super>Glorp.GlorpTimestampTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>priorTimeZone </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpObjectComparisonJoinsTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>itinerary1 itinerary2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpObjectComparisonSubselectTest</name><environment>Glorp</environment><super>Glorp.GlorpObjectComparisonJoinsTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>ClassC</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassC attrBClassC </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBankAccount</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id accountNumber accountHolders eventsReceived </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>ClassA</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassA attrBClassA attrCClassA attrDClassA attrEClassA attrFClassA attrGClassA attrHClassA </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.ClassA</class-id><body>ClassAInstance Variables:	attrAClassA	&lt;MessageForwarder | Object | ProtoObject | ProtoObject | Proxy&gt;	description of attrAClassA	attrBClassA	&lt;MessageForwarder | Object | ProtoObject | ProtoObject | Proxy&gt;	description of attrBClassA	attrCClassA	&lt;MessageForwarder | Object | ProtoObject | ProtoObject | Proxy&gt;	description of attrCClassA	attrDClassA	&lt;MessageForwarder | Object | ProtoObject | ProtoObject | Proxy&gt;	description of attrDClassA	attrEClassA	&lt;Boolean&gt;	proxied boolean (a very unusual case, for test 03;  normally, booleans are direct unproxied mappings)	attrFClassA	&lt;Collection&gt;	some ClassBs	attrGClassA	&lt;Collection&gt;	some ClassIs	attrHClassA	&lt;Boolean&gt;	unproxied boolean (the standard case)</body></comment><class><name>ASOrderLineItem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>posNo quantity item price order </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>ClassJ</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassJ attrBClassJ attrCClassJ </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCompressedMoney</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id array </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseSessionTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>ASItem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name bonuses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpReadingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpReadingTest</class-id><body>This tests the full reading mechanism, writing out some rows manually and then doing various read operations.Instance Variables:	session	&lt;Session&gt;		system	&lt;GlorpDemoDescriptorSystem&gt;	</body></comment><class><name>GlorpDeleteTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpDeleteTest</class-id><body>This tests deletions.</body></comment><class><name>GlorpDatabaseLoginTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>login accessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpReadingDifferentCollectionsTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system session singleQuery allQuery singleResult allResult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpPartialWritesTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpVarchar4Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpReadQueryTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpBooleanTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpFloat4Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>ClassI</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassI attrBClassI </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpFloat8Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpPassenger</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name frequentFlyerMiles airline </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDateTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpBankTransaction</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id owner amount serviceCharge </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpVarchar2Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpCitiesGraph</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>city nextCity distance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>GlorpCitiesGraph</class-id><body>CitiesGraph models a link table of cities and neighbor cities, and their distances. Using this class, we can build a recursive query which determines the shortest path between two cities.Instance Variables:	city	&lt;GlorpCity&gt; The city where we are.	nextCity	&lt;GlorpCity&gt;	Another city.	distance	&lt;Float&gt;	The distance between the cities.What follows is some preliminary data, and a SQL-only query example, which we would like to accommodate using Glorp. Note that special care is needed when developing recursive queries to ensure that the database server doesn't go into an endless loop--you need to ensure a terminating condition.conn := PostgresSocketConnection new.conn username: 'tester';	password: 'tester';	environment: 'testing'.conn connect.results := OrderedCollection new.ansBlock := [[(ans:= sess answer) = #noMoreAnswers]	whileFalse:		[(ans = #noAnswerStream) ifFalse: [results addAll: ans upToEnd]]].sess := conn getSession.sess prepare:  'CREATE TABLE cities				(id INTEGER PRIMARY KEY, name VARCHAR(25))'.sess execute.ansBlock value.sess prepareWithoutBinding:	'INSERT INTO cities VALUES(1, ''Boston'');	INSERT INTO cities VALUES(2, ''New York'');	INSERT INTO cities VALUES(3, ''Cinncinati'');	INSERT INTO cities VALUES(4, ''Chicago'');	INSERT INTO cities VALUES(5, ''St. Louis'');	INSERT INTO cities VALUES(6, ''Kansas City'');	INSERT INTO cities VALUES(7, ''Denver'');	INSERT INTO cities VALUES(8, ''Houston'');	INSERT INTO cities VALUES(9, ''Dallas'');	INSERT INTO cities VALUES(10, ''Phoenix'');	INSERT INTO cities VALUES(11, ''New Orleans'');	INSERT INTO cities VALUES(12, ''Atlanta'');	INSERT INTO cities VALUES(13, ''Seattle'');	INSERT INTO cities VALUES(14, ''Portland'');	INSERT INTO cities VALUES(15, ''Miami'');	INSERT INTO cities VALUES(16, ''Baltimore'');	INSERT INTO cities VALUES(17, ''Nashville'');	INSERT INTO cities VALUES(18, ''Salt Lake City'');	INSERT INTO cities VALUES(19, ''Reno'');	INSERT INTO cities VALUES(20, ''San Francisco'');	INSERT INTO cities VALUES(21, ''Los Angeles'')'.sess execute.ansBlock value.sess prepare:  'CREATE TABLE cities_graph				(id INTEGER, link INTEGER, distance FLOAT)'.sess execute.ansBlock value.sess prepareWithoutBinding:	'INSERT INTO cities_graph VALUES(1, 2, 200);	INSERT INTO cities_graph VALUES(1, 3, 420);	INSERT INTO cities_graph VALUES(2, 3, 350);	INSERT INTO cities_graph VALUES(3, 4, 400);	INSERT INTO cities_graph VALUES(4, 5,  300);	INSERT INTO cities_graph VALUES(5, 6, 300);	INSERT INTO cities_graph VALUES(6, 7, 500);	INSERT INTO cities_graph VALUES(7, 8, 1000);	INSERT INTO cities_graph VALUES(7, 10, 300)	INSERT INTO cities_graph VALUES(7, 18, 360)	INSERT INTO cities_graph VALUES(8, 9, 400);	INSERT INTO cities_graph VALUES(9, 10, 600);	INSERT INTO cities_graph VALUES(10, 11, 2000);	INSERT INTO cities_graph VALUES(11, 12, 400);	INSERT INTO cities_graph VALUES(12, 13, 3800);	INSERT INTO cities_graph VALUES(13, 14, 220);	INSERT INTO cities_graph VALUES(14, 15, 4000);	INSERT INTO cities_graph VALUES(15, 16, 1100);	INSERT INTO cities_graph VALUES(16, 17, 400);	INSERT INTO cities_graph VALUES(17, 18, 2000);	INSERT INTO cities_graph VALUES(18, 19, 400);	INSERT INTO cities_graph VALUES(19, 20, 220);	INSERT INTO cities_graph VALUES(20, 21, 400);	INSERT INTO cities_graph VALUES(21, 14, 1200)'.sess execute.anssBlock value.conn disconnect.conn connect.sess := conn getSession.results := OrderedCollection new.sess prepare:	'WITH RECURSIVE search_graph(id, link, distance, depth, path, cycle) AS	(		SELECT g.id, g.link, g.distance, 1, ARRAY[g.id], false		FROM cities_graph g		WHERE g.id = 1	UNION ALL		SELECT g.id, g.link, g.distance+sg.distance, sg.depth + 1, path || g.id, g.id = ANY(path)		FROM cities_graph g, search_graph sg		WHERE g.id = sg.link AND (NOT cycle) AND (not g.id = 20)	)	SELECT * FROM search_graph sg WHERE sg.link = 20'.sess execute.ansBlock value.results.conn disconnect.</body></comment><class><name>GlorpRegionalManager</name><environment>Glorp</environment><super>Glorp.GlorpManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>region </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBankBranch</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accounts branchNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpVariableTypeTestSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpVariableTypeTestSystem</class-id><body>This is a system for testing variable relationships. That is, where we have a relationship that might be one type of object, or might be another, depending on some criteria. The objects are not related by inheritance. Our example is a relationship to images, where if the images are small we retrieve them directly, but if they are larger we only retrieve minimal information about them.  Conditional mappings are tested by this system.</body></comment><class><name>GlorpPictureReview</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>picture sequence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PolyTest</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpPictureReview</class-id><body>GlorpPictureReview holds a picture (the one nominally review) and a sequence number:  is it the first, second, third, fourth, fifth or what'th review of the picture?  In real use, it would also hold some text (the actual review of teh picture) but we ignore that in this test example.Instance Variables:	picture	&lt;GlorpTaggableObject&gt;	sequence	&lt;Integer&gt;</body></comment><class><name>GlorpLockingDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBankAccountNumber</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bankCode branchNumber accountNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpEncyclopediaStockDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>Station</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id successor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>FeederStation</name><environment>Glorp</environment><super>Glorp.Station</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>CustomerStation</name><environment>Glorp</environment><super>Glorp.Station</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpVariableTypeTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpVariableTypeTest</class-id><body>This exercises trying to map to objects that might be of multiple types, not related by inheritance. </body></comment><class><name>GlorpRowMapForMementosCollectionTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction rowMap collection newCollection copy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDatabaseTableTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpOwnerSlaveTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDatabaseIndexTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>ASOrder</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>orderNo lineItems customer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpOneToOneDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person personId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>BatchTestPlatform</name><environment>Glorp</environment><super>Glorp.SQLServerPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.BatchTestPlatform</class-id><body>I am a test platform for batch insert and update code.  This code, when bound, is nowhere used, since my superclass, which did use it, now always uses array binding. </body></comment><class><name>GlorpManyToManyDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>customer customerId accountId1 accountId2 accountId3 treeNodeClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpJob</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpQueryTableAliasingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query expression elementBuilder session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpMoney</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currency amount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpSessionResource</name><environment>Glorp</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDBTestsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpDBTestsPackage</class-id><body>This class represents package information for the GlorpDBTests package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>GlorpMockSession</name><environment>Glorp</environment><super>Glorp.GlorpSession</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rows </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpMockConnection</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpMockConnection</class-id><body>GlorpMockConnection allows any checks which pass through GlorpMockAccessor to work OK..</body></comment><class><name>GlorpQueryStub</name><environment>Glorp</environment><super>Glorp.AbstractReadQuery</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpQueryStub</class-id><body>A test class. This behaves like a query, but doesn't go to the database, it just returns whatever it was told to return on its creation, regardless of the parameters or session.Instance Variables:	result	&lt;Object&gt;	The thing we should return.</body></comment><class><name>GlorpTravelFile</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpTravelFile</class-id><body>The GlorpTravelFolder and GlorpTravelFile test classes are not (at time of creation) connected to GlorpTravelAgent and the other long-established Glorp test classes;  they have a separate descriptor system, etc..  Their names were chosen just to make it obvious that they are also test objects.</body></comment><class><name>GlorpExpressionBasicPropertiesTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>base </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpBasicMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping person </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpCommandTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpErrorTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpMessageCollectorTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTracingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tracing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpVirtualCollectionBasicTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpMappingFromClassModelTests</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system platform </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTests</package></attributes></class><class><name>TestCommandPermission</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpStringTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpStringTest</class-id><body>Test string extensions in Glorp.</body></comment><class><name>GlorpQueryUnionTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpQueryUnionTest</class-id><body>This tests the ability to do a union operation on queries, returning results corresponding to multiple different queries.</body></comment><class><name>GlorpConditionalMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping descriptor mapping1 mapping2 mapping3 newMapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpConditionalMappingTest</class-id><body>This tests the conditional mapping basic API without going to the database.</body></comment><class><name>ASCustomer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name orders customer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDictionaryMappingErrorTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpDictionaryMappingErrorTest</class-id><body>Ensure that warning/error messages are raised by invalid acts in dictionary mappings.</body></comment><class><name>Successor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id successorCustomer successorFeeder station </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>InheritanceQueryTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.InheritanceQueryTest</class-id><body>Test queries within queries on collections of subclasses in an inheritance tree.</body></comment><class><name>GlorpTransformedTime</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id time </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTransformedTime</class-id><body>This class just holds a time, but that time is transformed into a representation in seconds in the database.Instance Variables:	id	&lt;Integer&gt;	The primary key	time	&lt;Time&gt;	The time</body></comment><class><name>GlorpDirectMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>BatchTestUpdateCommand</name><environment>Glorp</environment><super>Glorp.UpdateCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.BatchTestUpdateCommand</class-id><body>No platform we support uses batch binding in update today, so we do not complicate implementors of #bindingTypes in UpdateCommand and subclasses with that case but instead have this test-only mock command to exercise it.</body></comment><class><name>ClassK</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassK attrBClassK attrCClassK </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpExampleSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBankExampleSystem</name><environment>Glorp</environment><super>Glorp.GlorpExampleSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpAirlineMeal</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id description ingredients </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTag</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id key label </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PolyTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpItemRelativeLocks</name><environment>Glorp</environment><super>Glorp.GlorpItemWithQty</super><private>false</private><indexed-type>none</indexed-type><inst-vars>lock1 lock2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpItemRelativeLocks</class-id><body>My superclass tests relative fields.  I add two lock fields to test the combination of relative and lock fields.Instance Variables:	lock1	&lt;Integer&gt;	VersionType - values are generated	lock2	&lt;Integer&gt;	GlorpIntegerType ?all values are provided by the user?</body></comment><class><name>GlorpCollectionTypesDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCollectionTypeModels</category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><class><name>GlorpUnitOfWorkTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpConstantValueInRelationshipTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpChar2Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpVarchar1Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpImageLink</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title thumbnailBits fullImage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTimeTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTestClassInNamespace</name><environment>GlorpTestNamespace</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpInt2Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpEmailAddress</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id user host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpNumeric5Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpEncyclopedia</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name entries biographicalEntries entriesByAuthor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpObjectWithNoAccessors</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpBasicTax</name><environment>Glorp</environment><super>Glorp.GlorpTax</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDictionaryDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>ClassExample</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id trace value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.ClassExample</class-id><body>I am a data-storing test object.  I trace to myself, to allow examination of the case where the class model value is nil but the database column has a default value (e.g. of 0).Instance Variables:	id		&lt;Integer&gt;		the primary key	trace		&lt;Example | nil&gt;	the previous version	value	&lt;String&gt;			the data</body></comment><class><name>GlorpTaggableObject</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tags id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PolyTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpPortrait</name><environment>Glorp</environment><super>Glorp.GlorpTaggableObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subjectFullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PolyTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDescriptorSystemWithNamespaces</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			GlorpTestNamespace.*			</imports><category>GlorpTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpPerishableItem</name><environment>Glorp</environment><super>Glorp.GlorpInventoryItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>age </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpPoultry</name><environment>Glorp</environment><super>Glorp.GlorpPerishableItem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>featherColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpTransientEmployee</name><environment>Glorp</environment><super>Glorp.GlorpEmployee</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTransientEmployee</class-id><body>GlorpTransientEmployee is used to test that not all subclasses need to be persistent in inheritance mapping.</body></comment><class><name>GlorpVideoCustomer</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name dateOfBirth onlinePurchases inStorePurchases inStoreRentals store creditStatus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpLineWorker</name><environment>Glorp</environment><super>Glorp.GlorpEmployee</super><private>false</private><indexed-type>none</indexed-type><inst-vars>productionLine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpContractor</name><environment>Glorp</environment><super>Glorp.GlorpEmployee</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hourlyRate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpContractor</class-id><body>I exercise embedded mappings in subclasses of FilteredType-resolved hierarchies.Instance Variables:	hourlyRate	&lt;GlorpMoney&gt;	to test how embedded mappings work with filtered type resolution</body></comment><class><name>GlorpCollectionTypesWithClassModelsDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpCollectionTypesDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCollectionTypeModels</category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><class><name>GlorpGallery</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name images </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpRowDifferencingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session currentObject currentObjectRowMap correspondenceMap differenceMap mementoObject mementoObjectRowMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpServiceCharge</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description amount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpOwner</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id slave slaves </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpUser</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name folders </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp TestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpWorkerTask</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpEncyclopediaEntry</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id text title mediaType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpCollectionTypeModelsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><comment><class-id>Glorp.GlorpCollectionTypeModelsPackage</class-id><body>This class represents package information for the GlorpCollectionTypeModels package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>GlorpThingWithLotsOfDifferentCollections</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id array orderedCollection set bag sortedCollection name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCollectionTypeModels</category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><class><name>GlorpThingOne</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCollectionTypeModels</category><attributes><package>GlorpCollectionTypeModels</package></attributes></class><comment><class-id>Glorp.GlorpThingOne</class-id><body>This just exists to be put in collections.Instance Variables:	id	&lt;SmallInteger&gt;	description of id	name	&lt;String&gt;	description of name</body></comment><class><name>GlorpTimedProxyReaperTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reaper </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpAttributeModelTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpRowMapForMementosTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowMap a1 a2 b1 b2 table1 row1 row2 transaction c1 c2 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpObjectTransactionTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>transaction objects </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDialectTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			GlorpTestNamespace.*			</imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpDialectTest</class-id><body>Tests the portability methods in the Dialect class.</body></comment><class><name>GlorpCoreExtensionsTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpCursoredCollectionDBTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpSelectCommandTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>ClassL</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassL attrBClassL attrCClassL attrDClassL </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpGettingPrimaryKeyFromMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpItinerary</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id reservation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpItinerary</class-id><body>An itinerary holds onto a single reservation. It may not make much sense, but we need to test another layer of indirection.</body></comment><class><name>GlorpCompositeKeyTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>ASBonus</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name credits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpFilteringQueryDBTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpAttachmentBytes</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>content </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AAGlorp</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpFolder</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>user name messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpVideoStore</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name customers purchases rentals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpEncyclopediaAuthor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpEncyclopediaAuthor</class-id><body>Represents the author of an encyclopedia entry. Used to exercise object-&gt;object dictionary mappings.</body></comment><class><name>GlorpInheritanceDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpMappings</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id><body>I define two inheitance-using systems, a small one for subclasses of GlorpTaggableObject and a larger one ubclasses of GlorpInventoryItem.</body></comment><class><name>GlorpCustomer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name transactions accounts accountsSortedById accountsSortedByIdDescending eventsReceived seenPostFetch seenPreWrite seenPostWrite seenExpiry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDocumentDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AAGlorp</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpDocumentDescriptorSystem</class-id><body>This is a test descriptor system for documents with attachments that have their attachment bytes in a separate table, so reading them can be deferred. Neither attachments nor attachmentBytes have references to their containing document, but do have primary keys as foreign keys to it. When writing, this exhibited a problem that if you didn't read the bytes, then the attachment was written properly, because it could get its documentId primary key component from the proxy to the attachmentBytes. But if you had read the attachmentBytes, then it tried to get the value from the attachmentBytes object, which didn't know about that value. So it couldn't find the primary key of the attachment, and therefore assumed it was new.</body></comment><class><name>GlorpVideoCreditStatus</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>customer balanceOwing dateOwing comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpVideoCreditStatus</class-id><body>There is a possibility of one of these for each customer in a Store. If there is no credit owing or owed, then there is no record. Otherwise the record exists and records the total amount. This is pretty unlikely as a model of credit, but suits our purposes by providing a 1-1 relationship that may or may not exist.Instance Variables:	balanceOwing	&lt;Number&gt;		comments	&lt;String&gt;		customer	&lt;Customer&gt;	dateOwing	&lt;Date&gt;</body></comment><class><name>GlorpImage</name><environment>Glorp</environment><super>Glorp.GlorpTaggableObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>location </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PolyTest</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>InheritanceQueryDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.InheritanceQueryDescriptorSystem</class-id><body>The abstract class Station and its concrete subclasses CustomerStation and FeederStation are each represented in itheir own table.  The tables for the concrete subclasses include a link to the table of the abstract superclass.  (Because this descriptor system exists solely for test purposes, neither the superclass nor the subclass tables have any other columns.)Stations are connected by the successor relation.</body></comment><class><name>GlorpExpressionTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpOrderedLinkDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpSessionTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpJoinTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression compoundExpression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rowMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpCacheTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cache session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpAttachment</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index mimeType attachmentBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>AAGlorp</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpAdHocMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mapping person descriptor table money rowMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>ClassQ</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassQ attrBClassQ </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpQueryCopyingTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>query expression elementBuilder session newQuery </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpPerson</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name address emailAddresses hasEmail </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpEncyclopediaBioEntry</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>owner title text </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDescriptorSystemWithNamespacePoolDictionaryDeclarer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDescriptorValidationTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpBookstoreCustomer</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name accountNumber booksOnOrder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpFakeElementBuilder</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpNoProxyCollectionReadTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpBreadthFirstTopologicalSortTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unsorted sorted groupA groupB groupC </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpNullCommand</name><environment>Glorp</environment><super>Glorp.DatabaseCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpNullCommand</class-id><body>This represents a command with no additional syntax, basically just a stream. Useful for testing the generation of chunks of SQL.</body></comment><class><name>GlorpFilteredInheritanceTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session allEmployees </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTransformedFieldValueWrapperTest</name><environment>Glorp</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inner outer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpExpressionRebuildingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>original newBase rebuilt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTestsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpTestsPackage</class-id><body>This class represents package information for the GlorpTests package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>GlorpRelativeFieldWithLocksTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpExpressionIterationTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDeleteInUnitOfWorkTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unitOfWork </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTimedExpiryCacheTest</name><environment>Glorp</environment><super>Glorp.GlorpCacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpSQLPrintingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpTimedStrongCacheTest</name><environment>Glorp</environment><super>Glorp.GlorpCacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpDatabaseAccessorTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpMatchDeleteInsertTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTests</package></attributes></class><comment><class-id>Glorp.GlorpMatchDeleteInsertTest</class-id><body>Users can delete an object from their database and then create another object with the same primary key all in the same unit of work.  Glorp does the same thing for link tables.  In both cases, Glorp attempts to replace the matching delete and insert statements with an update statement.  However Glorp expects to set the keys itself in link tables and will complain if they are already there.  Test that user-forced delete and insert with the same primary keys works for objects, but that invalid link table delete and insert will be caught.</body></comment><class><name>GlorpWeakCacheTest</name><environment>Glorp</environment><super>Glorp.GlorpCacheTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mourned </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTests</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpPublisher</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name titles titlesWithNumberInStock titlesWithNumberInStockLink employees differentBunchOfEmployeesById </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpDictionaryMappingTest</name><environment>Glorp</environment><super>Glorp.GlorpSessionBasedTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpTests</package></attributes></class><class><name>GlorpRootNode</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id root </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpRootNode</class-id><body>My sole purpose is to link to GlorpTreeNode, to investigate alsoFetching recursively.Instance Variables:	id	&lt;Integer&gt;	unique id for me, the root instance	root	&lt;GlorpTreeNode&gt;	the root tree node held by me</body></comment><class><name>GlorpBlobTest</name><environment>Glorp</environment><super>Glorp.AbstractLOBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTypeTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpTestModelsPackage</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTestModelsPackage</class-id><body>This class represents package information for the GlorpTestModels package, for systems that don't have things like package properties to store things.  It is unused in VisualWorks.</body></comment><class><name>GlorpTimeWithTimeZoneTest</name><environment>Glorp</environment><super>Glorp.GlorpTimeTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>priorTimeZone </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpCity</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name priorCities nextCities </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>GlorpCity</class-id><body>City models a table with city name and id. Instance Variables:	id	&lt;Integer&gt; The city's id.	name	&lt;String&gt;	The city's name.	nextCities	&lt;Dictionary&gt; A dictionary of other cities that we can directly reach from this city.	priorCities	&lt;Dictionary&gt;	A dictionary of other cities with a direct link to this city.</body></comment><class><name>ClassM</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassM </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpImageFile</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title bits thumbnailBits </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpProxyTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session proxy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpBook</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id description copiesInStock version title author </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpSimpleQueryTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpDatabaseBasicTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpReadingDifferentCollectionsThroughMappingsTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpReadingPersonWithEmailAddressesTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session personRow addressRow emailAddress1Row emailAddress2Row id1 id2 oldReuseState </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpWritingTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpNumeric5ZeroTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpInsertUpdateTest</name><environment>Glorp</environment><super>Glorp.GlorpTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpInt8Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpVarchar10Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpChar4Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>ClassH</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassH attrBClassH attrCClassH attrDClassH </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpInt4Test</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpRecordWithUpdateTime</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name updateTime updateSomeOtherThing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpRecordWithUpdateTime</class-id><body>This is a model class that has a timestamp which is updated each time it is written.Instance Variables:	id	&lt;Integer&gt;	The primary key	name	&lt;String&gt;	a name	updateTime	&lt;Timestamp&gt;	When we were last updated.</body></comment><class><name>GlorpNumericTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpEmailDomain</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id topLevelDomain addresses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpEmailDomain</class-id><body>This represents an email domain, used for exercising substring matches versus email addresses. Because the email addresses already separate out the host, we try to exercise the matching on the top level domain, which is a little silly, but it's just a test example.Instance Variables:	addresses	&lt;OrderedCollection of: GlorpEmailAddress&gt;	The list of addresses	id	&lt;Integer&gt;		topLevelDomain	&lt;String&gt;	</body></comment><class><name>GlorpIntegerTest</name><environment>Glorp</environment><super>Glorp.GlorpDatabaseTypeIndividualDBTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTypeTests</package></attributes></class><class><name>GlorpSlave</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpOffice</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id employees street employeeOfMonth </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>ASItemBonus</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>item bonus </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>AlphaDescriptorSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.AlphaDescriptorSystem</class-id><body>My model consists of classes ClassA, ClassB and so on, with attributes #attrAClassA, #attrBClassA, ..., #attrAClassB, #attrBClassB, ..., etc. (hence my name).  I am used by tests that illustrate some Glorp issues unearthed in live use and fixed by various ARs.</body></comment><class><name>GlorpVideoRental</name><environment>Glorp</environment><super>Glorp.GlorpTestModelClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id title dueDate price customer store </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTestModels</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>AnySatisfyDescrSystem</name><environment>Glorp</environment><super>Glorp.GlorpTestDescriptorSystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.AnySatisfyDescrSystem</class-id><body>This is a system for testing nested #anySatisfy: blocks.</body></comment><class><name>ClassF</name><environment>Glorp</environment><super>Glorp.ClassE</super><private>false</private><indexed-type>none</indexed-type><inst-vars>attrAClassF </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpConditionalMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpConditionalMappingDBTest</class-id><body>When an object is registered, either at top-level or as part of completing the transitive closure of registration, and that object's descriptor includes a ConditionalMapping, neither the conditional mapping nor its resolved mapping for that object adds itself to the transitive closure.  Thus only simple direct mappings can be conditional.  Write a test that shows this, thus fix it.</body></comment><class><name>GlorpRecursionTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpRecursionTest</class-id><body>All my tests fail on SQLite and MySQL (they do not yet support recursion).I test storing read data in common table expression and using it for recursive reads.  Use	GlorpRecursionTest new writeCitiesNoCyclesor	GlorpRecursionTest new writeCitiesWithCyclesto populate the database if you need to study the test code in situ.  Then do	GlorpDemoTablePopulatorResource invalidateSetup.and run one of my tests to remove it.</body></comment><class><name>GlorpEmbeddedMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><comment><class-id>Glorp.GlorpEmbeddedMappingDBTest</class-id><body>This exercises the EmbeddedValueOneToOneMapping.</body></comment><class><name>GlorpAirline</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpReadingDifferentCollectionsThroughMappingsWithClassModelsTest</name><environment>Glorp</environment><super>Glorp.GlorpReadingDifferentCollectionsThroughMappingsTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDBTests</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpTravelAgent</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id name agency </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpTravelAgent</class-id><body>This represents a travel agent. Travel agents are very simple, but have their agency embedded in their table, even though we expect the agencies to be unique instances, and to have multiple agents.Instance Variables:	agency	&lt;GlorpTravelAgency&gt;	description of agency	id	&lt;Integer&gt;	description of id	name	&lt;String&gt;	description of name</body></comment><class><name>GlorpDirectMappingDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person personId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpAddress</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id street number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest-Domain Models</category><attributes><package>GlorpTestModels</package></attributes></class><class><name>GlorpOneToManyDBTest</name><environment>Glorp</environment><super>Glorp.GlorpMappingDBTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>person personId emailId1 emailId2 emailId3 </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><class><name>GlorpEncyclopediaFeature</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encyclopedia featured </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GlorpTestModels</package></attributes></class><comment><class-id>Glorp.GlorpEncyclopediaFeature</class-id><body>I associate an encyclopedia with some featured entry that is either from that encyclopedia or the reification of an inline text field into an entry.  I help test conditional mappings.Instance Variables:	encyclopedia	&lt;GlorpEncyclopedia&gt;	featured	&lt;GlorpEncyclopediaEntry&gt;</body></comment><class><name>GlorpDatabaseLoginResource</name><environment>Glorp</environment><super>XProgramming.SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessor login </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpTest</category><attributes><package>GlorpDBTests</package></attributes></class><shared-variable><name>DefaultLogin</name><environment>Glorp.GlorpDatabaseLoginResource</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>GlorpDBTests</package></attributes></shared-variable><shared-variable><name>Default</name><environment>Glorp.GlorpDemoDescriptorSystem</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>GlorpTestModels</package></attributes></shared-variable><shared-variable><name>NeedsSetup</name><environment>Glorp.GlorpDemoTablePopulatorResource</environment><private>false</private><constant>false</constant><category>(none)</category><attributes><package>GlorpDBTests</package></attributes></shared-variable><methods><class-id>Glorp.GlorpDocument</class-id> <category>accessing</category><body package="GlorpTestModels">attachments	^attachments</body><body package="GlorpTestModels">attachments: anObject	attachments := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpDocument</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	attachments := OrderedCollection new.	whatever := 3.</body></methods><methods><class-id>Glorp.GlorpDocument class</class-id> <category>glorp</category><body package="GlorpTestModels">glorpSetupClassModel: model forSystem: system 	model		newAttributeNamed: #id;		newAttributeNamed: #whatever;		newAttributeNamed: #attachments			collection: OrderedCollection			of: GlorpAttachment</body><body package="GlorpTestModels">glorpSetupDescriptor: aDesc forSystem: system 	| t |	t := system tableNamed: 'document'.	aDesc table: t.	(aDesc newMapping: DirectMapping) from: #id to: (t fieldNamed: 'id').	(aDesc newMapping: DirectMapping) from: #whatever to: (t fieldNamed: 'whatever').	(aDesc newMapping: OneToManyMapping)		attributeName: #attachments;		orderBy: [:ea | ea index]</body></methods><methods><class-id>Glorp.GlorpDemoTablePopulatorResource</class-id> <category>setup</category><body package="GlorpDBTests">populateStuffTable 	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (12,''abc'')'.	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (13, ''hey nonny nonny'')'.	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (42, ''yabba dabba doo'')'.	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (9625, ''the band played on'')'.	login accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (113141, ''Smalltalk'')'.</body><body package="GlorpDBTests">setUp	super setUp.	login := GlorpDatabaseLoginResource current.	self class needsSetup ifFalse: [^self].	login accessor doDDLOperation:		[GlorpTestDescriptorSystem allSubclasses do:			[:eachSystemClass |			self setUpSystem: (eachSystemClass forPlatform: login platform) setUpDefaults].		self populateStuffTable].</body><body package="GlorpDBTests">setUpSystem: system 	| errorBlock |	login accessor dropTables: ((TableSorter for: system allTables) sort reverse).	errorBlock := [:ex | Transcript show: ex description; cr. ex pass].	system platform areSequencesExplicitlyCreated ifTrue: [		login accessor dropSequences: system allSequences.		system allSequences do: [:each |			login accessor createSequence: each ifError: errorBlock]].	system allTables do: [:each | 			login accessor createTable: each				ifError: errorBlock].	system allTables do: [:each |			login accessor createTableIndexes: each ifError: errorBlock]. 	"SQLite3 doesn't support adding/dropping constraints."	system platform supportsConstraints ifTrue: [		system allTables do: [:each | 				login accessor createTableFKConstraints: each ifError: errorBlock]].	self class needsSetup: false</body></methods><methods><class-id>Glorp.GlorpDemoTablePopulatorResource class</class-id> <category>setup</category><body package="GlorpDBTests">invalidateSetup	"GlorpDemoTablePopulatorResource invalidateSetup"	NeedsSetup := true.	self reset.</body><body package="GlorpDBTests">needsSetup	NeedsSetup isNil ifTrue: [NeedsSetup := true].	^NeedsSetup</body><body package="GlorpDBTests">needsSetup: aBoolean	NeedsSetup := aBoolean.</body><body package="GlorpDBTests">resources	^Array with: GlorpDatabaseLoginResource.</body></methods><methods><class-id>Glorp.GlorpMockAccessor</class-id> <category>executing</category><body package="GlorpDBTests">basicExecuteSQLString: aString	^ReadStream on: #(#(3)).</body><body package="GlorpDBTests">executeCommand: aCommand returnCursor: aBoolean	| result |	result := #(#(3)).	^aBoolean ifTrue: [result readStream] ifFalse: [result].</body><body package="GlorpDBTests">executeSQLString: aString	^#((3)).</body></methods><methods><class-id>Glorp.GlorpMockAccessor</class-id> <category>accessing</category><body package="GlorpDBTests">schema	^''</body></methods><methods><class-id>Glorp.GlorpTravelFolder</class-id> <category>accessing</category><body package="GlorpDBTests">files	^files</body><body package="GlorpDBTests">files: anObject	files := anObject</body><body package="GlorpDBTests">id	^id</body><body package="GlorpDBTests">id: anObject	id := anObject</body><body package="GlorpDBTests">name	^name</body><body package="GlorpDBTests">name: anObject	name := anObject</body><body package="GlorpDBTests">unordered	^unordered</body><body package="GlorpDBTests">unordered: anObject	unordered := anObject</body></methods><methods><class-id>Glorp.GlorpTravelFolder</class-id> <category>initialize-release</category><body package="GlorpDBTests">initialize	files := OrderedCollection new.	unordered := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpTravelFolder class</class-id> <category>instance creation</category><body package="GlorpDBTests">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpTypeTestsModelClass</class-id> <category>As yet unclassified</category><body package="GlorpDBTests">test	^test.</body><body package="GlorpDBTests">test: anObject	test:= anObject.</body></methods><methods><class-id>Glorp.AnySatisfyTest</class-id> <category>example data</category><body package="GlorpDBTests">createTestData: aSession	| bonus itemBonus |	aSession inUnitOfWorkDo:		[| item order lineItem customer |		customer := aSession readOneOf: ASCustomer where: [:cust | cust id = 5].		customer ifNil:			[customer := ASCustomer new id: 5; name: 'Informing AG' yourself.			aSession register: customer].		customer orders isEmpty			ifTrue: 				[order := ASOrder new orderNo: 10; customer: customer; yourself.				aSession register: order.				customer orders add: order]			ifFalse: [order := customer orders first].		item := aSession readOneOf: ASItem where: [:itm | itm id = 20].		item ifNil:			[item := ASItem new id: 20; name: 'ost'; yourself.			aSession register: item].		order lineItems isEmpty ifTrue: 			[lineItem := ASOrderLineItem new posNo: 30; quantity: 15; price: 25; item: item; order: order; yourself.			aSession register: lineItem.			order lineItems add: lineItem].		bonus := aSession readOneOf: ASBonus where: [:bos | bos id = 27].		bonus ifNil:			[bonus := ASBonus new id: 27; name: 'BigTimeSavings'; credits: 100; yourself.			aSession register: bonus].		item bonuses isEmpty ifTrue:			[itemBonus := ASItemBonus new item: item; bonus: bonus; yourself.			aSession register: itemBonus.			item bonuses add: itemBonus]].</body></methods><methods><class-id>Glorp.AnySatisfyTest</class-id> <category>running</category><body package="GlorpDBTests">setUp	session := GlorpSessionResource current newSession.	session system: (AnySatisfyDescrSystem forPlatform: session platform).	self createTestData: session.</body><body package="GlorpDBTests">testANDedQueryEmptyCheck	"To test empty (an aggregate call) in the AND: block, we must have the descriptor set on the base.  For this, the query's base needs to know its descriptor, which it gets from the system which the query gets from its session.  Thus the session that will be used to execute the query (or one using the identically-equal system) must be provided earlier and the base set up from it."	| customer query |	 query := Query readOneOf: ASCustomer where:		[:cust | cust name = 'Informing AG'].	query setUpBaseFromSession: session.	query AND: [:cust | cust orders notEmpty].	customer := query execute.	self assert: customer name = 'Informing AG'.	self deny: customer orders isEmpty.</body><body package="GlorpDBTests">testANDedQuerySqlCount	"To do a count (an aggregate call) in an OR: block appended to a query, we must have the descriptor set on the base.  For this, the query needs to know the system which it gets from the session, so the session that will be used to execute the query must be provided earlier, and the base set from it."	| customer query |	 query := Query readOneOf: ASCustomer where:		[:cust | cust name = 'Informing AG'].	query setUpBaseFromSession: session.	query AND: [:cust | cust orders sqlCount = 1].	customer := query execute.	self assert: customer name = 'Informing AG'.	self assert: customer orders size = 1.</body><body package="GlorpDBTests">testAnySatisfyNested	| customer |	customer := session readOneOf: ASCustomer where:		[:cust |		cust orders anySatisfy: 			[:order |			order lineItems anySatisfy:				[:lineItem | (lineItem item name like: 'os%') &amp; (lineItem quantity &gt; 0)]]].	self assert: (customer orders anySatisfy:				[:order | order lineItems anySatisfy:					[:lineItem | (lineItem item name like: 'os%') and: [lineItem quantity &gt; 0]]])		description: 'Nested where-block anySatisfy: does not agree with image anySatisfy:'.</body><body package="GlorpDBTests">testAnySatisfyTwiceNested	| customer |	customer := session readOneOf: ASCustomer where:		[:cust |		cust name = 'Informing AG' AND:			[cust orders anySatisfy:				[:order |				order lineItems anySatisfy:					[:lineItem |					lineItem item bonuses anySatisfy:						[:itemBonus | itemBonus bonus credits &gt; 50]]]]].	self assert: customer name = 'Informing AG'.	self assert: (customer orders anySatisfy:				[:order | order lineItems anySatisfy:					[:lineItem | lineItem item bonuses anySatisfy:						[:itemBonus | itemBonus bonus credits &gt; 50]]])		description: 'Three-deep where-block anySatisfy: does not agree with image anySatisfy:'.</body><body package="GlorpDBTests">testORedQueryEmptyCheck	"To test empty (an aggregate call) in the OR: block, we must have the descriptor set on the base.  For this, the query needs to know the system which it gets from the session, so the session that will be used to execute the query must be provided earlier."	| customer query |	 query := Query readOneOf: ASCustomer where:		[:cust | cust name = 'Informing AG'].	query setUpBaseFromSession: session.	query OR: [:cust | cust orders isEmpty].	customer := query execute.	"These assertions assume there are no customers without orders."	self assert: customer name = 'Informing AG'.	self deny: customer orders isEmpty.</body><body package="GlorpDBTests">testRetrieveIsEmpty	"To test empty (an aggregate call) in a retrieve block, we must have the descriptor set on the base.  For this, the query's base needs to know its descriptor, which it gets from the system which the query gets from its session.  Thus the session that will be used to execute the query (or one using the identically-equal system) must be provided earlier and the base set up from it."	| query resultArray |	 query := Query readOneOf: ASCustomer where:		[:cust | cust name = 'Informing AG' AND: [cust orders notEmpty]].	query setUpBaseFromSession: session.	query retrieve: [:each | each name].	query retrieve: [:each | each orders isEmpty].	resultArray := query execute.	self assert: resultArray first = 'Informing AG'.	self deny: (self convertToBoolean: resultArray last)		description: 'We read a customer with orders but retrieved no orders'.</body><body package="GlorpDBTests">testRetrieveSqlCount	"To do a count (an aggregate call) in a retrieve block, we must have the descriptor set on the base.  For this, the query needs to know the system which it gets from the session, so the session that will be used to execute the query must be provided earlier, and the base set from it."	| query resultArray |	 query := Query readOneOf: ASCustomer where:		[:cust | cust name = 'Informing AG' AND: [cust orders notEmpty]].	query setUpBaseFromSession: session.	query retrieve: [:each | each name].	query retrieve: [:each | each orders sqlCount].	resultArray := query execute.	self assert: resultArray first = 'Informing AG'.	self assert: resultArray last = 1.</body></methods><methods><class-id>Glorp.AnySatisfyTest</class-id> <category>utility</category><body package="GlorpDBTests">convertToBoolean: anObject	"Not all databases support explicit true/false.  Provide an explicit conversion until/unless we complete automatic conversion."	| platformBoolType platformBoolConverter |	platformBoolType := session platform boolean.	platformBoolConverter := platformBoolType converterForStType: Boolean.	^platformBoolConverter convert: anObject fromDatabaseRepresentationAs: platformBoolType</body></methods><methods><class-id>Glorp.AnySatisfyTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpTestCase</class-id> <category>hacks</category><body package="GlorpTestModels">knownFailure	"This does nothing, but makes it easier to search for known failures."	^self.</body><body package="GlorpTestModels">unfinished</body></methods><methods><class-id>Glorp.GlorpTestCase class</class-id> <category>testing</category><body package="GlorpTestModels">isAbstract	^self sunitName = #GlorpTestCase</body></methods><methods><class-id>Glorp.GlorpRelativeFieldTest</class-id> <category>running</category><body package="GlorpTests">setUp	| itemRow1 itemRow2 |	super setUp.	session := GlorpSessionResource current newSession.	session beginTransaction.	itemRow1 := session system exampleItemWithQtyRow1.	itemRow2 := session system exampleItemWithQtyRow2.	session writeRow: itemRow1.	session writeRow: itemRow2.	session commitTransaction</body><body package="GlorpTests">supportsReturningValuesForSession: aSession	"Oracle supports returning values, but only if the command is bound."		^(aSession platform relativeUpdateCommand includesBehavior: ReturningUpdateCommand)		and: [aSession platform isOraclePlatform not or: [DatabasePlatform useBindingIfSupported]].</body><body package="GlorpTests">tearDown	session delete: GlorpItemWithQty where: [:item | item id &gt;= 0].	session reset.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpRelativeFieldTest</class-id> <category>test-multiple fields</category><body package="GlorpTests">testMultiRelativeFieldsImageDBConsistencyAfterParallelUpdates	"This test investigates possible discrepancy between the image after updating a relative field if it has also been updated in another session. Oracle cannot return values if unbound."	| session1 session2 session3 query1 query2 query3 items1 items2 items3 |	session1 := GlorpSessionResource current newSession.	(self supportsReturningValuesForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 		["Read the current values in the first session. Values are #(100 500s) and #(50 0s)"		query1 := Query read: GlorpItemWithQty.		query1 orderBy: [:item | item id].		items1 := session1 execute: query1.			session2 := GlorpSessionResource current newSession.		session2 inUnitOfWorkDo: 			["Read the items, and then update their quantities, undetected by session1."			query2 := Query read: GlorpItemWithQty.			query2 orderBy: [:item | item id].			items2 := session2 execute: query2.			items2 do: [:each| each qty: 125; totalSales: 100.0]].		"Set the target qty to 125, sales to 100.00."		"Use the already-cached items from session1, whose values are still #(100 50)"		items1 do: [:each | each qty: 300; totalSales: 25.0]].	"Update the quantity. (update +200, update +250), (+25.0, -475.0)."	"Both updates have now been applied to the database;  items2 do not know of later updates ..."	self assert: items2 first qty = 125 description: 'Session2 first should still have value 125' resumable: true.	self assert: items2 first totalSales = 100s description: 'Session2 first sales should still have value 100.00' resumable: true.	self assert: items2 last qty = 125 description: 'Session2 last should still have value 125' resumable: true.	self assert: items2 last totalSales = 100s description: 'Session2 last  sales should still have value 100.00' resumable: true.	"... . but items1 do know the actual final value at the end of writing their increments to the DB."	self assert: items1 first qty = 325 description: 'Session1 first lacks post-write value 325' resumable: true.	self assert: items1 last qty = 375 description: 'Session1 last lacks post-write value 375' resumable: true.	"... and so their values are no longer the ones they wrote."	self deny: items1 first qty = 300 description: 'Session1 first still has pre-write value 300' resumable: true.	self deny: items1 last qty = 300 description: 'Session1 last still has its pre-write value 300' resumable: true.	"Determine the actual quantities."	session3 := GlorpSessionResource current newSession.	query3 := Query read: GlorpItemWithQty.	query3 orderBy: [:item | item id].	items3 := session3 execute: query3.	self assert: items3 first qty = 325 description: 'Re-read first lacks final value 325' resumable: true.	self assert: items3 first totalSales = 125s description: 'Re-read first lacks final value 325' resumable: true.	self assert: items3 last qty = 375 description: 'Re-read last lacks final value 375'.	"no point resuming last assert"	self assert: items3 last totalSales = -375s description: 'Re-read last lacks final value 375'.	"no point resuming last assert"</body><body package="GlorpTests">testMultipleRelativeFieldsNormalUsage	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each qty: 125; totalSales: 100.0]].	"We wrote values in setUp and updated them; check values."	session2 := GlorpSessionResource current newSession.	query := Query read: GlorpItemWithQty.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.	self assert: items first totalSales = 100.	self assert: items last totalSales = 100.</body><body package="GlorpTests">testSecondRelativeFieldOnlyUsage	"Update the 2nd relative field, leaving the first unchanged (so it's contents won't be part of our update query)."	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each totalSales: 200.0]].		"Set the target totalSales to 125."	session2 := GlorpSessionResource current newSession.	"SetUp has already written these values to the db, so update their quantities."	query := Query read: GlorpItemWithQty.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first totalSales = 200.0.	self assert: items last totalSales = 200.0.</body><body package="GlorpTests">testSecondRelativeFieldOnlyUsageSingleRow	"Update the 2nd relative field, leaving the first unchanged (so it's contents won't be part of our update query).	This test only updates one row, so it won't use array-binding (if that is available for the current platform)."	| query session1 session2 itemWritten itemRead|	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query readOneOf: GlorpItemWithQty.		itemWritten := session1 execute: query.		itemWritten totalSales: 200.0].		"Set the target totalSales to 125."	session2 := GlorpSessionResource current newSession.	"SetUp has already written these values to the db, so update their quantities."	query := Query readOneOf: GlorpItemWithQty where: [:each| each id = itemWritten id].	itemRead := session2 execute: query.	self assert: itemRead totalSales = 200.0.</body></methods><methods><class-id>Glorp.GlorpRelativeFieldTest</class-id> <category>test-updating</category><body package="GlorpTests">testRelativeAndOrdinaryFields	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each name: (each name, 'new').	"Include a non-relative field to make sure it gets through."						each qty: 125]].					"Set the target qty to 125."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values, including the changed non-relative fields."	query := Query read: GlorpItemWithQty.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.	self assert: (items first name findString: 'new' startingAt: 1) &gt; 0.	self assert: (items last name findString: 'new' startingAt: 1) &gt; 0.</body><body package="GlorpTests">testRelativeFieldDecrementUsage	| session1 session2 query items |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each | each qty: 10]].		"Set the target qty to 10."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemWithQty.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 10.	self assert: items last qty = 10.</body><body package="GlorpTests">testRelativeFieldManyRowUpdate	"This test inserts, then updates, an array of data to ensure that relative field works with multiple row update."	| session1 session2 session3 data1 data2 data3 |	session1 := GlorpSessionResource current newSession.	data1 := OrderedCollection new		add: (GlorpItemWithQty new id: 3; name: 'a'; qty: 10);		add: (GlorpItemWithQty new  id: 4; name: 'b'; qty: 11);		add: (GlorpItemWithQty new  id: 5; name: 'c'; qty: 12);		add: (GlorpItemWithQty new  id: 6; name: 'd'; qty: 13);		yourself.	session1 inUnitOfWorkDo: [session1 registerAll: data1].	session2 := GlorpSessionResource current newSession.	session2 inUnitOfWorkDo:		[data2 := session2 read: GlorpItemWithQty.		self assert: data2 size = 6.		data2 do: [:each| each qty: 35]].	session3 := GlorpSessionResource current newSession.	data3 := session3 read: GlorpItemWithQty.	self assert: data3 size = 6 .	data3 do: [:each| self assert: each qty = 35].</body><body package="GlorpTests">testRelativeFieldNormalUsage	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each qty: 125]].		"Set the target qty to 125."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemWithQty.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.</body><body package="GlorpTests">testRelativeFieldNullWrite	"We created the qty field to be not-NULLable, but the totalSales field can hold NULL.  Of course, once we NULL a relative field, we cannot insert any value (at least, not via that mapping)."	| session1 session2 query items session3 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo:		"read, check values, set to nil"		[query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session1 execute: query.		self assert: items first totalSales = 0.		self assert: items last totalSales = 500s.		items do: [:each | each totalSales: nil].		items do: [:each | self assert: each totalSales isNil]].	session2 := GlorpSessionResource current newSession.	session2 inUnitOfWorkDo:		"read, check values are nil, set to 20"		[query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session2 execute: query.		self assert: items first totalSales isNil.		self assert: items last totalSales isNil.		items do: [:each | each totalSales: 20].		"Before we write, we hold the values we set."		items do: [:each | self assert: each totalSales = 20]].	"After we write, we are syched with the database, so are nil again (if we are a returning command, not otherwise)."	(self supportsReturningValuesForSession: session1)		ifTrue: [items do: [:each | self assert: each totalSales isNil]].	"read, check values are still nil"	session3 := GlorpSessionResource current newSession.	query := Query read: GlorpItemWithQty.	query orderBy: [:item| item id].	items := session3 execute: query.	self assert: items first totalSales isNil.	self assert: items last totalSales isNil.</body><body package="GlorpTests">testRelativeFieldOneRowNULLOneNotNULL	"Have a null and a non-null row.  This passes on Postgres unbound and bound but the bound only works because Postgres bound does not group."	| session1 session2 query items session3 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo:		"read, check values, set to nil"		[query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session1 execute: query.		self assert: items first totalSales = 0.		self assert: items last totalSales = 500s.		items first totalSales: nil.		items last totalSales: 250].	session2 := GlorpSessionResource current newSession.	session2 inUnitOfWorkDo:		"read, check values are nil, set to 20"		[query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session2 execute: query.		self assert: items first totalSales isNil.		self assert: items last totalSales = 250.		items do: [:each | each totalSales: 20].		"Before we write, we hold the values we set."		items do: [:each | self assert: each totalSales = 20]].	"After we write, we are syched with the database, so are nil again (if we are a returning command, not otherwise)."	(self supportsReturningValuesForSession: session1) ifTrue:		[self assert: items first totalSales isNil.		self assert: items last totalSales = 20].	"read, check values are still nil"	session3 := GlorpSessionResource current newSession.	query := Query read: GlorpItemWithQty.	query orderBy: [:item| item id].	items := session3 execute: query.	self assert: items first totalSales isNil.	self assert: items last totalSales = 20s.</body><body package="GlorpTests">testRelativeFieldParallelDecrements	"This test validates the behavior of relative field updates, which don't need to know the current values of their target fields. They do know the relative change in value between when their session read them and wrote them, which is what gets added to the target in the database. This test uses 2 separate sessions, oblivious about each other, and involves several steps.	Step 1: The first session loads values from the Db. It sees qty #(100 50) for the two rows.	Step 2: The second session does the same, and updates these values to #(10 10).	Step 3: The first session now updates the qty from #(100 50), unaware these are stale numbers, to (300 300).	Step 4: The transaction commits, and the database qty is now #(325 375),			since (300-100=200)+10=210  and (300-50=250)+10=260.	Step 5: A fresh session reads from the database and confirms these values."	| session1 session2 session3 query1 query2 query3 items1 items2 items3 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 			["Read the current values in the first session. Values are #(100 50)"			query1 := Query read: GlorpItemWithQty.			query1 orderBy: [:item | item id].			items1 := session1 execute: query1.						session2 := GlorpSessionResource current newSession.			session2 inUnitOfWorkDo: 					["Read the items, and then update their quantities, undetected by session1."					query2 := Query read: GlorpItemWithQty.					query2 orderBy: [:item | item id].					items2 := session2 execute: query2.					items2 do: [:each | each qty: 10]].	"Set the target qty to 10. (update -90, update -40)."			"Use the already-cached items from session1, whose values are still #(100 50)"			items1 do: [:each | each qty: 300]].	"Update the quantity. (update +200, update +250)."	"Determine the actual quantities."	session3 := GlorpSessionResource current newSession.	query3 := Query read: GlorpItemWithQty.	query3 orderBy: [:item | item id].	items3 := session3 execute: query3.	self assert: items3 first qty = 210.	self assert: items3 last qty = 260.</body><body package="GlorpTests">testRelativeFieldParallelIncrements	"Read values, apply two updates in separate sessions, then read again from the database and verify values are the summary of the two differences."	| session1 session2 session3 query1 query2 query3 items1 items2 items3 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 			["Read the current values in the first session. Values are #(100 50)"			query1 := Query read: GlorpItemWithQty.			query1 orderBy: [:item | item id].			items1 := session1 execute: query1.						session2 := GlorpSessionResource current newSession.			session2 inUnitOfWorkDo: 					["Read the items, and then update their quantities, undetected by session1."					query2 := Query read: GlorpItemWithQty.					query2 orderBy: [:item | item id].					items2 := session2 execute: query2.					items2 do: [:each | each qty: 125]].	"Set the target qty to 125. (update +25, update +75)."			"Use the already-cached items from session1, whose values are still #(100 50)"			items1 do: [:each | each qty: 300]].	"Update the quantity. (update +200, update +250)."	"Determine the actual quantities."	session3 := GlorpSessionResource current newSession.	query3 := Query read: GlorpItemWithQty.	query3 orderBy: [:item | item id].	items3 := session3 execute: query3.	self assert: items3 first qty = 325.	self assert: items3 last qty = 375</body></methods><methods><class-id>Glorp.GlorpRelativeFieldTest</class-id> <category>support</category><body package="GlorpTests">item1	^GlorpItemWithQty new		id: 1;		name: 'Thingamabob 1';		qty: 100;		totalSales: 0.0;		yourself</body><body package="GlorpTests">item2	^GlorpItemWithQty new		id: 2;		name: 'Gizmo 2';		qty: 50;		totalSales: 500.0;		yourself</body></methods><methods><class-id>Glorp.GlorpRelativeFieldTest</class-id> <category>test-returning</category><body package="GlorpTests">testImageDBConsistencyAfterParallelUpdates	"This test investigates possible discrepancy between the image after updating a relative field if it has also been updated in another session."	| session1 session2 session3 query1 query2 query3 items1 items2 items3 |	session1 := GlorpSessionResource current newSession.	(self supportsReturningValuesForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 		["Read the current values in the first session. Values are #(100 50)"		query1 := Query read: GlorpItemWithQty.		query1 orderBy: [:item | item id].		items1 := session1 execute: query1.			session2 := GlorpSessionResource current newSession.		session2 inUnitOfWorkDo: 			["Read the items, and then update their quantities, undetected by session1."			query2 := Query read: GlorpItemWithQty.			query2 orderBy: [:item | item id].			items2 := session2 execute: query2.			items2 do: [:each | each qty: 125]].	"Set the target qty to 125. (update +25, update +75)."		"Use the already-cached items from session1, whose values are still #(100 50)"		items1 do: [:each | each qty: 300]].	"Update the quantity. (update +200, update +250)."	"Both updates have now been applied to the database;  items2 do not know of later updates ..."	self assert: items2 first qty = 125 description: 'Session2 first should still have value 125' resumable: true.	self assert: items2 last qty = 125 description: 'Session2 last should still have value 125' resumable: true.	"... . but items1 do know the actual final value at the end of writing their increments to the DB."	self assert: items1 first qty = 325 description: 'Session1 first lacks post-write value 325' resumable: true.	self assert: items1 last qty = 375 description: 'Session1 last lacks post-write value 375' resumable: true.	"... and so their values are no longer the ones they wrote."	self deny: items1 first qty = 300 description: 'Session1 first still has pre-write value 300' resumable: true.	self deny: items1 last qty = 300 description: 'Session1 last still has its pre-write value 300' resumable: true.	"Determine the actual quantities."	session3 := GlorpSessionResource current newSession.	query3 := Query read: GlorpItemWithQty.	query3 orderBy: [:item | item id].	items3 := session3 execute: query3.	self assert: items3 first qty = 325 description: 'Re-read first lacks final value 325' resumable: true.	self assert: items3 last qty = 375 description: 'Re-read last lacks final value 375'.	"no point resuming last assert"</body><body package="GlorpTests">testRelativeFieldNonUsage	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo:		["Read the items and update a normal field but ignore the relative field."		query := Query read: GlorpItemWithQty.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each name: 'Smith']].	"We wrote values to the db in setUp; check their quantities are unchanged."	session2 := GlorpSessionResource current newSession.	query := Query read: GlorpItemWithQty.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first name = 'Smith'.	self assert: items first qty = 100.	self assert: items last name = 'Smith'.	self assert: items last qty = 50.</body></methods><methods><class-id>Glorp.GlorpRelativeFieldTest class</class-id> <category>accessing</category><body package="GlorpTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpAlphaSystemTest</class-id> <category>accessing</category><body package="GlorpDBTests">glorpDBAccessor	^glorpDBAccessor</body><body package="GlorpDBTests">glorpDBAccessor: aDatabaseAccessor	glorpDBAccessor := aDatabaseAccessor.</body><body package="GlorpDBTests">glorpSession	^glorpSession</body><body package="GlorpDBTests">glorpSession: aGlorpSession	glorpSession := aGlorpSession.</body></methods><methods><class-id>Glorp.GlorpAlphaSystemTest</class-id> <category>running</category><body package="GlorpDBTests">setUp	| login dbAccessor |	login := GlorpDatabaseLoginResource defaultLogin copy.	"use the same database as GlorpTest"	dbAccessor := DatabaseAccessor forLogin: login.	dbAccessor login.	self glorpDBAccessor: dbAccessor.	self glorpSession: self newGlorpSession.</body><body package="GlorpDBTests">tearDown	self glorpDBAccessor ifNotNil: [:dbAccessor | dbAccessor logout].	self glorpDBAccessor: nil.	self glorpSession: nil.</body><body package="GlorpDBTests">testAlsoFetchCollection09a	"If we #readOneOf: some class and #alsoFetch: a collection attribute of that class then only the first value in the collection attribute is obtained.  In this test, the code produced isSELECT t1.ATTRACLASSJ, t1.ATTRBCLASSJ, t2.ATTRACLASSK, t2.ATTRBCLASSK, t2.ATTRCCLASSK FROM (TBLJ t1 INNER JOIN TBLK t2 ON (t1.ATTRACLASSJ = t2.ATTRCCLASSK)) WHERE (t1.ATTRACLASSJ = 10) ORDER BY t1.ATTRACLASSJ LIMIT 1when in fact we would need the last characters to be LIMIT 10, not LIMIT 1 since there are 10 TBLK rows linked to the sole TBLJ row we are reading.  To fix this, Glorp must recognise the situation and rewrite to an outer query that alsoFetches and an inner query that is limited but does not alsoFetch.  This is now fixed for the readOneOf: (i.e. LIMIT 1) case."	| query myClassJ |	self glorpSession inUnitOfWorkDo: [:session | self class createDataForClassJAndK: session].	self tearDown; setUp.	"Read a classJ but do not fetch its classK collection in the same query."	query := Query readOneOf: ClassJ where: [:classJ | classJ attrAClassJ = 10].	myClassJ := self glorpSession execute: query.	self assert: myClassJ attrCClassJ size = 10.	self tearDown; setUp.	"clear the cache, ensuring we do not get an already-read object"	"Read a classJ again;  this time, _do_ fetch its classK collection in the same query."	query := Query readOneOf: ClassJ where: [:classJ | classJ attrAClassJ = 10].	query alsoFetch: #attrCClassJ.	self glorpDBAccessor logging: true.	myClassJ := self glorpSession execute: query.	self assert: myClassJ attrCClassJ size = 10.	"#readOneOf test fails here"</body><body package="GlorpDBTests">testAlsoFetchOrderedMapping09	"Problem/Question: In TestDescriptorSystem&gt;&gt;descriptorForClassJ: we define attrCClassJ of ClassJ  to return its collection in descending order.  The ordering was not working when the attribute was alsoFetch:ed in a query for ClassJs instead of by instantiating the proxy later.  The SQL being issued by Glorp (and written to the Transcript by this test) was:SELECT t1.ATTRACLASSJ, t1.ATTRBCLASSJ, t2.ATTRACLASSK, t2.ATTRBCLASSK, t2.ATTRCCLASSK FROM (TBLJ t1 INNER JOIN TBLK t2 ON (t1.ATTRACLASSJ = t2.ATTRCCLASSK)) WHERE (t1.ATTRACLASSJ = 10) ORDER BY t1.ATTRACLASSJIt should instead have been:SELECT t1.ATTRACLASSJ, t1.ATTRBCLASSJ, t2.ATTRACLASSK, t2.ATTRBCLASSK, t2.ATTRCCLASSK FROM (TBLJ t1 INNER JOIN TBLK t2 ON (t1.ATTRACLASSJ = t2.ATTRCCLASSK)) WHERE (t1.ATTRACLASSJ = 10) ORDER BY t1.ATTRACLASSJ, t2.ATTRBCLASSK DESCsince we are recovering ClassJ objects and its oneToMany mapping to ClassK has an order.  The fix in AR 64830 remedies this."	| query myClassJ |	self glorpSession inUnitOfWorkDo: [:session | self class createDataForClassJAndK: session].	self tearDown; setUp.	"Read a ClassJ but do not fetch its ClassK collection in the same query;  instantiate the proxy lazily."	query := Query read: ClassJ where: [:classJ | classJ attrAClassJ = 10].	myClassJ := (self glorpSession  execute: query) first.	self assert: myClassJ attrCClassJ size = 10.	self assert: (myClassJ attrCClassJ collect: [:each | each attrBClassK]) =		((myClassJ attrCClassJ collect: [:each | each attrBClassK])			asSortedCollection: [:a :b | a &gt; b]) asOrderedCollection		description: 'Proxy of ordered relationship did not instantiate contents in order'.	self tearDown; setUp.	"clear the cache, ensuring we do not get an already-read object"	"Read a classJ again;  this time, _do_ fetch its classK collection in the same query."	query := Query read: ClassJ where: [:classJ | classJ attrAClassJ = 10].	query alsoFetch: #attrCClassJ.	self glorpDBAccessor logging: true.	myClassJ := (self glorpSession execute: query) first.	self assert: myClassJ attrCClassJ size = 10.	self assert: (myClassJ attrCClassJ collect: [:each | each attrBClassK]) =		((myClassJ attrCClassJ collect: [:each | each attrBClassK])			asSortedCollection: [:a :b | a &gt; b]) asOrderedCollection		description: 'Fetch of ordered relationship did not retrieve contents in order'.</body><body package="GlorpDBTests">testCachePurgeReread05	"Problem/Question: Is there a way to clear all the objects in cache?  No code was provided with this - just a question to us.  The test constructed illustrates approaches to cache issues.  The first, using refresh: preserves object identity and is generally safe.  The others require the user to clean up references (and note that they do not combine well with refresh, which assumes that object identity in the cache remains the same)."	| query readClassA cachedClassA |	self glorpSession inUnitOfWorkDo:		[:session | self class createDataForClassA: session].	self tearDown; setUp.	"SCENARIO 1:  refresh - safe because object identity does not change"	query:= Query readOneOf: ClassA where: [:each | each attrAClassA = 'recA1'].	query session: self glorpSession.	cachedClassA := query checkCacheWithParameters: #() ifPresent: [:hit | hit].	self assert: cachedClassA isNil.	"nothing in the cache yet"	readClassA := self glorpSession execute: query.	cachedClassA := query checkCacheWithParameters: #() ifPresent: [:hit | hit].	self assert: cachedClassA == readClassA.	"cache was populated by read"	self deny: cachedClassA attrHClassA.	readClassA attrHClassA: true.	self assert: cachedClassA attrHClassA.	self deny: cachedClassA attrFClassA isInstantiated.	self assert: cachedClassA attrFClassA size = 0.	self assert: cachedClassA attrFClassA isInstantiated.	query shouldRefresh: true.	"force the query to ignore the cache"	readClassA := self glorpSession execute: query.	self deny: readClassA attrHClassA.	"Our _value_, re-read from the DB, is false again"	self deny: readClassA attrFClassA isInstantiated.	"and our proxy is uninstantiated"	self assert: cachedClassA == readClassA.	"BUT we're still the same object, still in cache"	self deny: cachedClassA attrHClassA.		"just with our values updated there."	"SCENARIO 2:  purge from cache - unsafe if you do not discard or update all references to the purged object"	query shouldRefresh: false.	"revert the query to normal state"	readClassA attrHClassA: true.	self assert: readClassA attrFClassA size = 0.	self assert: readClassA attrFClassA isInstantiated.	self glorpSession cacheRemoveObject: readClassA.	self assert: cachedClassA == readClassA.	readClassA := self glorpSession execute: query.	self deny: readClassA attrFClassA isInstantiated.	self deny: readClassA attrHClassA.	"We have been re-read from the DB - we're"	self deny: cachedClassA == readClassA.	"not the same object.  The old object is"	self assert: cachedClassA attrHClassA.	"unchanged, but no longer in the cache"	self deny: cachedClassA == (query checkCacheWithParameters: #() ifPresent: [:hit | hit])		description: 'Object purged from cache is still in cache'.	self assert: readClassA == (query checkCacheWithParameters: #() ifPresent: [:hit | hit])		description: 'Newly-read object not in cache'.	"SCENARIO 3:  reset the session, and so the cache - unsafe if you do not discard or update all references to all previously-cached objects"	cachedClassA := query checkCacheWithParameters: #() ifPresent: [:hit | hit].	readClassA attrHClassA: true.	self assert: readClassA attrFClassA size = 0.	self assert: readClassA attrFClassA isInstantiated.	self assert: cachedClassA == readClassA.	self glorpSession reset.	readClassA := self glorpSession execute: query.	self deny: readClassA attrFClassA isInstantiated.	self deny: readClassA attrHClassA.	"We have been re-read from the DB - we're"	self deny: cachedClassA == readClassA.	"not the same object.  The old object is"	self assert: cachedClassA attrHClassA.	"unchanged, but no longer in the cache"	self deny: cachedClassA == (query checkCacheWithParameters: #() ifPresent: [:hit | hit])		description: 'Object purged from cache is still in cache'.	self assert: readClassA == (query checkCacheWithParameters: #() ifPresent: [:hit | hit])		description: 'Newly-read object not in cache'.</body><body package="GlorpDBTests">testCompositeCacheHit04	"Problem/Question: In AlphaDescriptorSystem&gt;&gt;tableForTBLB:, the table TBLB has composite primary key: ATTRACLASSB, ATTRBCLASSB and ATTRDCLASSB.  This test ensures Glorp looks in the cache (like e.g. ClassA which has single primary key) before issuing the sql statement to the database, which was not the case prior to the fix."	| query myClassB |	self glorpSession inUnitOfWorkDo:		[:session | self class createDataForClassB: session].	self tearDown; setUp.	self glorpDBAccessor logging: true.	query := Query		readOneOf: ClassB		where: [:classB | classB attrAClassB = 'recB1'					&amp; (classB attrBClassB attrAClassA = 'recA10')					&amp; (classB attrDClassB attrAClassC = 10)].	myClassB := glorpSession execute: query.	self assert: (query				checkCacheWithParameters: #()				ifPresent: [:hit | hit]) == myClassB		description: 'I read a multi-field primaryKey object whose cache key was then not found'.</body><body package="GlorpDBTests">testDateArithmetic14	"Problem/Question: We want to form the following sql:SELECT * FROM EMP t1 WHERE (t1.JOINEDON + t1.BONUSDAYS) &gt;= TO_DATE ('2012-4-3', 'YYYY-MM-DD');For this we write query in smalltalk:SimpleQuery read: Employee where: [:emp | (emp joinedOn + emp bonusDays) &gt;= Date today].         Unfortunately this does not work. Does Glorp support this kind of query? If yes could you show us how. If it does not, is it possible to have this feature in Glorp?"	| myClassA |	self glorpSession inUnitOfWorkDo:		[:session | self class createDataForClassA: session].	self tearDown; setUp.	myClassA := self glorpSession		readOneOf: ClassA		where: [:classA | classA attrCClassA + classA attrDClassA &gt;= 25].	self assert: myClassA attrCClassA + myClassA attrDClassA &gt;= 25.	self assert: myClassA attrCClassA days + myClassA attrDClassA days &gt;= 25 days.	"either or both of the attributes could be of type date instead of using #days"</body><body package="GlorpDBTests">testDeleteReAddSameKey12	"Problem/Question: UHE: link table entry requiring update is only partially populated.  Fixed in 65120."	| kObj |	self glorpSession inUnitOfWorkDo:		[:sess | self class createDataForClassJAndK: sess].	self tearDown; setUp.	self glorpSession beginUnitOfWork.	kObj := self glorpSession readOneOf: ClassK where: [:obj | obj attrAClassK = 1].	self glorpSession delete: kObj.	kObj := ClassK new.	kObj		attrAClassK: 1;		attrBClassK: 11.	self glorpSession register: kObj.	self glorpSession commitUnitOfWork.</body><body package="GlorpDBTests">testDeleteReAddSameKey12a	"Problem/Question: UHE: link table entry requiring update is only partially populated."	| lObj mObj |	self glorpSession inUnitOfWorkDo:		[:sess |		mObj := sess readOneOf: ClassM where: [:obj | obj attrAClassM = 100].		mObj ifNil:			[mObj := ClassM new.			mObj attrAClassM: 100.			sess register: mObj].		lObj := sess readOneOf: ClassL where: [:obj | obj attrAClassL = 10].		lObj ifNil:			[lObj := ClassL new.			lObj				attrAClassL: 10;				attrBClassL: 'test';				attrCClassL: 125;				attrDClassL: mObj.		sess register: lObj]].	self tearDown; setUp.	self glorpSession beginUnitOfWork.	lObj := self glorpSession			readOneOf: ClassL			where: [:obj | obj attrAClassL = 10].	self glorpSession delete: lObj.	lObj := ClassL new.	lObj		attrAClassL: 10;		attrBClassL: 'test'.	self glorpSession register: lObj.	self glorpSession commitUnitOfWork.</body><body package="GlorpDBTests">testDeleteReAddSameKey12b	"Problem/Question: UHE: link table entry requiring update is only partially populated."	| oObj |	self glorpSession inUnitOfWorkDo:		[:sess |		oObj := sess readOneOf: ClassO where: [:obj | obj attrAClassO = 10].		oObj ifNil:			[oObj := ClassO new.			oObj				attrAClassO: 10;				attrBClassO: 'test';				attrCClassO: 125;				attrDClassO: 100.			sess register: oObj]].	self tearDown; setUp.	self glorpSession beginUnitOfWork.	oObj := self glorpSession		readOneOf: ClassO		where: [:obj | obj attrAClassO = 10].	self glorpSession delete: oObj.	oObj := ClassO new.	oObj		attrAClassO: 10;		attrBClassO: 'test'.	self glorpSession register: oObj.	self glorpSession commitUnitOfWork.</body><body package="GlorpDBTests">testFilteredInheritanceCacheHit07	"Problem/Question: ClassE has two concrete sub classes ClassF and ClassG, mapped by filtered inheritance to a single TableE where the filter field is not part of the primary key. When fetching instances of ClassF, Glorp adds the filer field to the primary key and then fails ti recognise this when looking in the cache, thus does not find the object in cache.  It will find it if the filter field is made part of the primaryKey (and the issue tested in 07a is fixed, as has now been done).  To avoid it maing this mistake when the filter field is not part of the primary key (e.g. when we do not want allow a ClassF to have the same key value as a ClassG), we must label the glorp-generated filter field expression and treat it as neutral when constructing the key."	| query myClassF |	self glorpSession inUnitOfWorkDo: [:session | self class createDataForClassFAndG: session].	self tearDown; setUp.	self glorpDBAccessor logging: true.	query := Query readOneOf: ClassF where: [:classF | classF attrAClassE = 1].	myClassF := self glorpSession execute: query.	self assert: (query				checkCacheWithParameters: #()				ifPresent: [:hit | hit]) == myClassF		description: 'I read a horizontal-filtered object whose cache key was then not found'.	"Running the line below will cause a second print of the SQL to the Transcript if the cached object was not found, i.e. it should either run without printing to the Transcript or it should not be run because the assert above failed (but may be run in debug to verify)."	self glorpSession readOneOf: ClassF where: [:classF | classF attrAClassE = 1].</body><body package="GlorpDBTests">testFilteredInheritancePrimaryKey07a	"Problem/Question: ClassE has two concrete sub classes ClassF and ClassG, all using the same table via a FilteredTypeResolver.  If we made the type resolver's field part of the primaryKey (to show that workaround for the problem of test 07), we at first saw a DNU when ClassQ had a foreign-key reference to ClassF;  this test was added to show it.  The fix was to Implement the method	FilteredTypeMapping&gt;&gt;valueOfField:fromObject:which had been accidentally omitted from the Glorp framework."	| query myClassQ |	self glorpSession inUnitOfWorkDo: [:session | self class createDataForClassFAndG: session].	self glorpSession inUnitOfWorkDo: [:session | self class createDataForClassQ: session].	self tearDown; setUp.	self glorpDBAccessor logging: true.	query := Query readOneOf: ClassQ where: [:classQ | classQ attrAClassQ = 1].	myClassQ := self glorpSession execute: query.	self assert: myClassQ attrBClassQ yourSelf class == ClassF		description: 'This test was just to see if an error was raised;  for this assert to fail instead of erroring is odd'.</body><body package="GlorpDBTests">testManyCursors10	"Problem/Question: Database cursors are not closed when executing direct sql's. Depending on the number of allowed open cursors on the database, you would get an oracle database exception: ORA-01000 maximum open cursors exceededTo view number of open cursors, execute the following statement in an Oracle sql executor tool (login using SYSTEM):select a.value, s.username, s.sid, s.serial#from v$sesstat a, v$statname b, v$session swhere a.statistic# = b.statistic#  and s.sid=a.sidand b.name = 'opened cursors current'"		10000 timesRepeat:		[1 to: 10 do:			[:idx || pkVal | pkVal := 'recA' , idx printString.			self glorpSession				readOneOf: ClassA				where: [:classA | classA attrAClassA = pkVal].			self glorpDBAccessor executeSQLString: 'select * from TBLA where ATTRACLASSA = '					, (Time now asNanoseconds / 10000000) asInteger printString printString]].</body><body package="GlorpDBTests">testOSMethods02	"Problem/Question: In the method, RelationExpression&gt;&gt;operationFor:, ObjectStudio methods like os_comma:, os_Equal: etc. were missing.  These have been added, after which this was still failing with a base expression that does not understand sytem in a default type, due to incorrect bracketting of the expression in the where clause.  This test-code-caused failure has been fixed;  this now passes."	self glorpSession inUnitOfWorkDo:		[:session | self class createDataForClassA: session].	self tearDown; setUp.	self glorpSession inUnitOfWorkDo:		[:session || classAs |		classAs := session read: ClassA where:			[:classA | classA attrAClassA = ('rec' , 'A1')].		self assert: classAs size = 1].</body><body package="GlorpDBTests">testOSTable01	"Problem/Question: Why does ObjectStudio.Table exists in descriptor system allClasses instance variable? Would it cause troubles?"	self deny: ((self glorpSession system allClasses collect: [:each | each name asString]) includes: 'Table')		description: 'Why is ObjectStudio.Table in system allClasses'.</body><body package="GlorpDBTests">testProxiedBoolean03	"Problem/Question: When an attribute of boolean type is defined as proxy, you get an UHE: 'NonBoolean receiver--proceed for truth.', when #and: is sent to it, because and: is inlined and so bypasses the Glorp proxy DNU mechanism to get the value.  This is a known feature of Glorp, hence the use of AND:/OR: instead of and:/or: in where clauses, etc. - one can also use &amp; and | to avoid the problem whenever the lazy-evaluation of and: is not required.  The test passes as we check for the raise of MustBeBoolean in the final line that demonstrates the issue.  The default workarounds is simply never to set any boolean attribute as shouldProxy: true (there seems no reason why one ever should), or to send #yourSelf to the value in the getter or in callers as shown below."	| loadedObj |	self glorpSession inUnitOfWorkDo:		[:session | self class createDataForClassA: session].	self tearDown; setUp.	loadedObj := self glorpSession		readOneOf: ClassA		where: [:classA | classA attrAClassA = 'recA1'].	self deny: (loadedObj attrHClassA and: [true])		description: 'What''s this? Unproxied false and: [true] not false!'.	self assert: loadedObj attrEClassA &amp; true		description: 'What''s this?  Proxy true &amp; true not true!'.	self assert: (loadedObj attrEClassA yourSelf and: [true])		description: 'What''s this?  Proxy yourSelf true and: [true] not true!'.	self should: [loadedObj attrEClassA and: [true]]		raise: MustBeBoolean	"comment out this line to see the failure that prompted this test"		description: 'Proxy of boolean survived being sent #and: and should not have, since #and: is optimised!'.</body><body package="GlorpDBTests">testRefreshCompositeObject11	"Problem/Question: When doing a refresh: on an object with complex primary key, you get UHE: Wrong type of object.  Now fixed."	| classIObj |	self glorpSession inUnitOfWorkDo:		[:session | self class createDataForClassI: session].	self tearDown; setUp.	classIObj := self glorpSession readOneOf: ClassI.	self glorpSession refresh: classIObj.</body><body package="GlorpDBTests">testRepeatSQLUpdate08	"Problem/Question: UHE: bad argument 4 when executing direct sql update statement more than once."	2 timesRepeat:		[self glorpDBAccessor			beginTransaction;			executeSQLString: 'update TBLA set ATTRECLASSA = 0';			commitTransaction].	2 timesRepeat:	"Test 3 expects ATTRECLASSA to be true."		[self glorpDBAccessor			beginTransaction;			executeSQLString: 'update TBLA set ATTRECLASSA = 1';			commitTransaction].</body><body package="GlorpDBTests">testTraceUpdate	"the test will trigger a bug in Glorp in 8.1.1 and earlier, where a foreign key is set to &lt;nil&gt; in Smalltalk and it should be written as 0 on the database (because the column has that default value).  The bug writes the value as NULL to the database.  If the column has the constraint to be NON NULL, this will fail.  Upon insert the 0 is correctly written (first #transact:). Upon update, it is NOT (third #transact:) which shows the bug."	| version1 version2 |	version1 := ClassExample withValue: '1'.	self glorpSession transact: [version1].	version2 := ClassExample withValue: '2'.	version2 trace: version1.	self glorpSession transact: [version2].	self glorpSession transact:		[self glorpSession register: version2.		version2 trace: nil].</body></methods><methods><class-id>Glorp.GlorpAlphaSystemTest</class-id> <category>utilities</category><body package="GlorpDBTests">newGlorpSession	| cache descrSystem |	cache := CachePolicy default.	cache numberOfElements: 5.	descrSystem := AlphaDescriptorSystem forPlatform:		self glorpDBAccessor currentLogin database.	descrSystem cachePolicy: cache.	^GlorpSession new		system: descrSystem;		accessor: self glorpDBAccessor;		yourself</body></methods><methods><class-id>Glorp.GlorpAlphaSystemTest class</class-id> <category>test data</category><body package="GlorpDBTests">createDataForClassA: session	| newObj |	1 to: 10 do:		[:idx || pkVal |		pkVal := 'recA' , idx printString.		newObj := session readOneOf: ClassA where: [:classA | classA attrAClassA = pkVal].		newObj ifNil:			[newObj := ClassA new.			newObj				attrAClassA: pkVal;				attrBClassA: 'some text for ' , idx printString;				attrCClassA: idx * 10;				attrDClassA: idx * 2.55;				attrEClassA: true;				attrHClassA: false.			session register: newObj]].	^newObj</body><body package="GlorpDBTests">createDataForClassB: session	| pkVal classAObj classCObj |	classAObj := self createDataForClassA: session.	classCObj := self createDataForClassC: session.	1 to: 5 do:		[:idx |		pkVal := 'recB' , idx printString.		(classAObj hasClassBWithPK: pkVal) ifFalse:			[classAObj newClassB				attrAClassB: pkVal;				attrCClassB: 'some text' , idx printString;				attrDClassB: classCObj]].</body><body package="GlorpDBTests">createDataForClassC: session	| newObj |	1 to: 10 do:		[:idx |		newObj := session readOneOf: ClassC where: [:classC | classC attrAClassC = idx].		newObj ifNil:			[newObj := ClassC new.			newObj				attrAClassC: idx;				attrBClassC: 'descr for ' , idx printString.			session register: newObj]].	^newObj</body><body package="GlorpDBTests">createDataForClassFAndG: session	| newObj objClass |	1 to: 10 do:		[:idx |		objClass := idx &gt; 5 ifTrue: [ClassG] ifFalse: [ClassF].		newObj := session readOneOf: objClass where: [:obj | obj attrAClassE = idx].		newObj ifNil:			[newObj := objClass new.			newObj				attrAClassE: idx;				attrBClassE: 'common descr ' , idx printString.			(newObj isKindOf: ClassF)				ifTrue: [newObj attrAClassF: 'concrete descr ' , idx printString]				ifFalse: [newObj attrAClassG: 'concrete descr ' , idx printString].		session register: newObj]].	^newObj</body><body package="GlorpDBTests">createDataForClassH: session	| newObj |	1 to: 10 do:		[:idx |		newObj := session readOneOf: ClassH where: [:classH | classH attrAClassH = idx].		newObj ifNil:			[newObj := ClassH new.			newObj				attrAClassH: idx;				attrBClassH: 'descr for ' , idx printString;				attrCClassH: 'secondary table ' , idx printString;				attrDClassH: 'secondary table ' , idx printString.			session register: newObj]].	^newObj</body><body package="GlorpDBTests">createDataForClassI: session	| classAObj classCObj |	classAObj := self createDataForClassA: session.	classCObj := self createDataForClassC: session.	(classAObj hasClassIWithClassC: classCObj) ifFalse:		[classAObj newClassI attrBClassI: classCObj].</body><body package="GlorpDBTests">createDataForClassJAndK: session	|  jObjects |	jObjects := (1 to: 10) collect:		[:idx || jObj |		jObj := session readOneOf: ClassJ where: [:obj | obj attrAClassJ = idx].		jObj ifNil:			[jObj := ClassJ new.			jObj				attrAClassJ: idx;				attrBClassJ: 'descr ' , idx printString.			session register: jObj].		jObj].	1 to: 10 do:		[:idx || kObj |		kObj := session readOneOf: ClassK where: [:obj | obj attrAClassK = idx].		kObj ifNil:			[kObj := ClassK new.			kObj				attrAClassK: idx;				attrBClassK: idx + 10].		jObjects last addK: kObj].	^jObjects</body><body package="GlorpDBTests">createDataForClassQ: session	| newObj classFObj |	1 to: 10 do:		[:idx |		classFObj := session readOneOf: ClassF where: [:obj | obj attrAClassE = 1].		newObj := session readOneOf: ClassQ where: [:obj | obj attrAClassQ = idx].		newObj ifNil:			[newObj := ClassQ new.			newObj				attrAClassQ: idx;				attrBClassQ: classFObj.			session register: newObj]].	^newObj</body></methods><methods><class-id>Glorp.GlorpAlphaSystemTest class</class-id> <category>accessing</category><body package="GlorpDBTests">resources	^Array with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpRowMapTest</class-id> <category>tests</category><body package="GlorpTests">testCollapseMatchingInsertsAndDeletes	| c1 key1 key2 row1 remainingRow updates |	c1 := Object new.	key1 := RowMapKey new key1: a1; key2: b1.	key2 := RowMapKey new key1: a1; key2: c1.	row1 := rowMap findOrAddRowForTable: table1 withKey: key1.	row1 atFieldNamed: 'ONE_ID' put: 99.	row1 atFieldNamed: 'OTHER_ID' put: 98.	row1 atFieldNamed: 'KEY' put: 5.	row2 := rowMap findOrAddRowForTable: table1 withKey: key2.	row2 atFieldNamed: 'ONE_ID' put: 99.	row2 atFieldNamed: 'OTHER_ID' put: 14.	row2 atFieldNamed: 'KEY' put: 5.	row1 forDeletion: true.	updates := rowMap collapseMatchingInsertsAndDeletes.	self assert: rowMap numberOfEntries = 1.	self assert: updates size = 1.	self assert: updates asArray first = row2.	remainingRow := rowMap rowForTable: table1 withKey: key2 ifAbsent: [self assert: false].	rowMap rowForTable: table1 withKey: key1 ifPresent: [:shouldntBeThereAnyMore | self assert: false].	self assert: (remainingRow atFieldNamed: 'ONE_ID') = 99.	self assert: (remainingRow atFieldNamed: 'OTHER_ID') = 14.	self assert: (remainingRow atFieldNamed: 'KEY') = 5.	self assert: remainingRow owner = key2.</body><body package="GlorpTests">testCollapseMatchingInsertsAndDeletesWithUnknownFields	"In 8.1, we no longer throw an error for unknown values in the update row, believing the condition can never happen in real life.  This test sets up the condition and now checks that no error is raised by it.  It stays here just as info, and for reuse if our assumption is ever wrong."	| c1 key1 key2 row1 |	c1 := Object new.	key1 := RowMapKey new key1: a1; key2: b1.	key2 := RowMapKey new key1: a1; key2: c1.	row1 := rowMap findOrAddRowForTable: table1 withKey: key1.	row1 atFieldNamed: 'ONE_ID' put: 99.	row1 atFieldNamed: 'OTHER_ID' put: 98.	row1 atFieldNamed: 'KEY' put: 5.	row2 := rowMap findOrAddRowForTable: table1 withKey: key2.	row2 atFieldNamed: 'ONE_ID' put: 99.	row2 atFieldNamed: 'KEY' put: 5.	row1 forDeletion: true.	self shouldnt: [rowMap collapseMatchingInsertsAndDeletes] raise: Dialect error.</body><body package="GlorpTests">testRowForTableSingle	| rowMapKey row |	rowMapKey := RowMapKey new.	rowMapKey key1: a1; key2: b1.	row := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row2 := rowMap rowForTable: table1 withKey: rowMapKey.	self assert: row == row2.</body></methods><methods><class-id>Glorp.GlorpRowMapTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	a1 := IdentityHashPrintingObject new.	b1 := IdentityHashPrintingObject new.	rowMap := RowMap new.	table1 := DatabaseTable new name: 'SomeTable'.	platform := OraclePlatform new.	table1 addField: (DatabaseField named: 'ONE_ID' type: platform integer) bePrimaryKey.	table1 addField: (DatabaseField named: 'OTHER_ID' type: platform integer).	table1 addField: (DatabaseField named: 'KEY' type: platform integer) bePrimaryKey.	row2 := 'row2'.</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest</class-id> <category>tests</category><body package="GlorpTests">testClassSelection	| classes |	classes := (session system descriptorFor: GlorpInventoryItem) classesRequiringIndependentQueries collect: [:each | each name ].	self assert: classes size = 3.	#(#GlorpNonperishableItem #GlorpPerishableItem #GlorpUnassembledItem) do: [:name |		self assert: (classes includes: name) ].	classes := (session system descriptorFor: GlorpPerishableItem) classesRequiringIndependentQueries collect: [:each | each name ].	self assert: classes size = 1.	#(#GlorpPerishableItem) do: [:name |		self assert: (classes includes: name) ].	classes := (session system descriptorFor: GlorpNonperishableItem) classesRequiringIndependentQueries collect: [:each | each name ].	self assert: classes size = 2.	#(#GlorpNonperishableItem #GlorpUnassembledItem) do: [:name |		self assert: (classes includes: name)].</body><body package="GlorpTests">testDirectQuery	| items query item |	self writeTestHarness.	query := Query read: GlorpInventoryItem				where: [:each | each name = 'TV'].	items := session execute: query.	self assert: items size = 1.	self assert: (items select: [:emp | emp isMemberOf: GlorpNonperishableItem]) size = 1.	session reset.	items := session read: GlorpInventoryItem				where: [:each | each name = 'bicycle'].	self assert: items size = 1.	self assert: (items select: [:emp | emp isMemberOf: GlorpUnassembledItem]) size = 1.	session reset.	items := session read: GlorpPerishableItem				where: [:each | each name = 'bicycle'].	self assert: items size = 0.	session reset.	item := session readOneOf: GlorpPerishableItem		where: [:each | each name = 'bicycle'].	self assert: item isNil.	item := session readOneOf: GlorpInventoryItem		where: [:each | each name = 'something that does not exist'].	self assert: item isNil.</body><body package="GlorpTests">testDirectSingleQueryForSubclasses	| items query |	self writeTestHarness.	(session system descriptorFor: GlorpInventoryItem) typeResolver useSingleQueryIfPossible: true.	query := Query read: GlorpInventoryItem				where: [:each | each name = 'TV'].	items := session execute: query.	self assert: items size = 1.	self assert: (items select: [:emp | emp isMemberOf: GlorpNonperishableItem]) size = 1.	session reset.	items := session read: GlorpInventoryItem				where: [:each | each name = 'bicycle'].	self assert: items size = 1.	self assert: (items select: [:emp | emp isMemberOf: GlorpUnassembledItem]) size = 1.	session reset.	items := session read: GlorpPerishableItem				where: [:each | each name = 'bicycle'].	self assert: items size = 0.</body><body package="GlorpTests">testDirectSingleQueryForSubclassesNoWhereClause	| items query normalResult filtered |	self writeTestHarness.	(session system descriptorFor: GlorpInventoryItem) typeResolver useSingleQueryIfPossible: true.	query := Query read: GlorpInventoryItem.	items := session execute: query.	self assert: items size = 7.	GlorpInventoryItem allSubclasses do: [:each |		normalResult := session read: each.		filtered := items select: [:other | other isKindOf: each].		self assert: normalResult size = filtered size].</body><body package="GlorpTests">testNilVariableJoin	| warehouse |	self writeTestHarness.	warehouse := session readOneOf: GlorpWarehouse				where: [:each | each address = '123 Some Ave.'].	session beginUnitOfWork.	session register: warehouse.	warehouse currentItem: nil.	session commitUnitOfWork.	session reset.	warehouse := session readOneOf: GlorpWarehouse				where: [:each | each address = '123 Some Ave.'].	self assert: warehouse currentItem isNil</body><body package="GlorpTests">testOrderBy	"We can't use database-level ordering in horizontal inheritance because it does multiple queries. We could, I suppose, sort after the fact, but we don't right now"	| items query |	query := Query read: GlorpInventoryItem				where: [:each | each id &lt;= 4].	query orderBy: #name.	self should: [items := session execute: query] raise: Dialect error.</body><body package="GlorpTests">testReadNonAbstractPolymorphic	"This test excercises a problem that existed with MappingExpression caching its mapping	and which was then copied to the newly created MappingExpressions for subclasses.	This isn't a problem when reading from an abstract class since there are no mappings to cache."	| wagon |		self writeTestHarness.	wagon := session readOneOf: GlorpNonperishableItem where: [:each | each name = 'wagon'].	self should: [wagon serialNumber = 99958]</body><body package="GlorpTests">testReadRelationship	| warehouse |		self writeTestHarness.	warehouse := session readOneOf: GlorpWarehouse				where: [:each | each address = '123 Some Ave.'].	self assert: warehouse address = '123 Some Ave.'.	self assert: warehouse currentItem name = 'squash'.	self assert: (warehouse items collect: [:each | each name]) asSortedCollection asArray = #('apples' 'bicycle' 'fridge').</body><body package="GlorpTests">testReadRelationshipSingleQuery	| warehouse |	(session system descriptorFor: GlorpInventoryItem) typeResolver useSingleQueryIfPossible: true.		self writeTestHarness.	warehouse := session readOneOf: GlorpWarehouse				where: [:each | each address = '123 Some Ave.'].	self assert: warehouse address = '123 Some Ave.'.	self assert: warehouse currentItem name = 'squash'.	self assert: (warehouse items collect: [:each | each name]) asSortedCollection asArray = #('apples' 'bicycle' 'fridge').</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest</class-id> <category>tests - tags</category><body package="GlorpTests">testForwardLookup	| image |	self writeTestHarnessForTags.	image := session				readOneOf: GlorpImage				where: [:each | each location = 'testlocation'].	self assert: image tags size = 2.	self assert: (image tags contains: [:tag| tag key = 'first']).	self assert: (image tags contains: [:tag| tag key = 'second']).</body><body package="GlorpTests">testReverseLookup	| image |	self writeTestHarnessForTags.	image := session				readOneOf: GlorpImage				where: [:each | each tags anySatisfy: [:tag| tag key = 'third']].	self assert: image tags size = 2.	self assert: (image tags contains: [:tag| tag key = 'first'])not.	self assert: (image tags contains: [:tag| tag key = 'second']).</body><body package="GlorpTests">testTagObjectLookup	| image |	self writeTestHarnessForTags.	image := session				readOneOf: GlorpTaggableObject				where: [:each | each tags						anySatisfy: [:tag | tag key = 'third']].	self assert: image tags size = 2.	self assert: (image tags			contains: [:tag | tag key = 'first']) not.	self		assert: (image tags				contains: [:tag | tag key = 'second'])</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	session system: (GlorpInheritanceDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database).	session beginTransaction.</body><body package="GlorpTests">tearDown	session rollbackTransaction.	super tearDown.	session reset.</body><body package="GlorpTests">writeTestHarness	| squash apples fridge bicycle warehouse |	session inUnitOfWorkDo: [	session register: (squash := GlorpPerishableItem new id: 1; name: 'squash'; age: 10; yourself).	session register: (GlorpPerishableItem new id: 2; name: 'zucchini'; age: 14; yourself).	session register: (apples := GlorpPerishableItem new id: 3; name: 'apples'; age: 4; yourself).	session register: (GlorpNonperishableItem new id: 4; name: 'TV'; serialNumber: 56893; yourself).	session register: (fridge := GlorpNonperishableItem new id: 5; name: 'fridge'; serialNumber: 12345; yourself).	session register: (bicycle := GlorpUnassembledItem new id: 6; name: 'bicycle'; serialNumber: 83754; assemblyCost: 100; yourself).	session register: (GlorpUnassembledItem new id: 7; name: 'wagon'; serialNumber: 99958; assemblyCost: 20; yourself).	warehouse := GlorpWarehouse new.	warehouse address: '123 Some Ave.'.	warehouse currentItem: squash.	warehouse items: (Array with: apples with: fridge with: bicycle).	session register: warehouse].	session reset.</body><body package="GlorpTests">writeTestHarnessForPictureReviews	| image1 portrait2 rev1 rev2 rev3 rev4 |	session inUnitOfWorkDo:		[image1 := GlorpImage new location: 'testlocation'.		session register: image1.		portrait2 := GlorpPortrait new id: -1; subjectFullName: 'TestSomeone'.		session register: portrait2.		rev1 := GlorpPictureReview new sequence: 1; picture: image1.		rev2 := GlorpPictureReview new sequence: 2; picture: image1.		rev3 := GlorpPictureReview new sequence: 1; picture: portrait2.		rev4 := GlorpPictureReview new sequence: 2; picture: portrait2.		session register: rev1.		session register: rev2.		session register: rev3.		session register: rev4].	session reset.</body><body package="GlorpTests">writeTestHarnessForTags	| tag1 tag2 tag3 image1 image2 |	session inUnitOfWorkDo: [		tag1 := GlorpTag new label: 'First'; generateKeyFromLabel.		tag2 := GlorpTag new label: 'Second'; generateKeyFromLabel.		tag3 := GlorpTag new label: 'Third'; generateKeyFromLabel.		image1 := GlorpImage new location: 'testlocation'.		session register: image1.			image1 tags add: tag1.		image1 tags add: tag2.			image2 := GlorpImage new location: 'testlocation2'.		session register: image2.			image2 tags add: tag2.		image2 tags add: tag3].	session reset.</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest</class-id> <category>tests - reviews</category><body package="GlorpTests">testReadReviews	"Just read the class and verify we got the numbers the test hardness wrote."	| reviews |	self writeTestHarnessForPictureReviews.	reviews := session read: GlorpPictureReview.	self assert: reviews size = 4.	(reviews glorpGroupedBy: [:each | each picture yourself class]) do:		[:each | self assert: each size = 2].</body><body package="GlorpTests">testReadReviewsOfOnePortrait	"Just read a portrait and verify we got the numbers the test hardness wrote."	| reviews portrait query |	self writeTestHarnessForPictureReviews.	portrait := session		readOneOf: GlorpPortrait		where: [:e | e subjectFullName = 'TestSomeone'].	query := Query		read: GlorpPictureReview		where: [:each | each picture = portrait].	query useANSIJoins: false.	reviews := session execute: query.	self assert: reviews size = 2."This fails and should be looked at.  The LHS thinks it is a GlorpTaggableObject, so complains it has no primaryKey.  The right side knows it is a GlorpPortrait subclass with primary key.session read: GlorpPictureReview where:		[:each || q |		q := Query readOneOf: GlorpPortrait where:			[:e | e subjectFullName = 'TestSomeone'].		each picture = q].The Schema is	GlorpTaggableObject -* PictureReview		Portrait		ImageEither the ID's sequence must be shared across all subclasses of GlorpTaggableObject or PictureReview must hold the taggable objects subclass-specific key as well as its ID if it is to link to the taggable object subclass."</body></methods><methods><class-id>Glorp.GlorpHorizontalInheritanceTest class</class-id> <category>resources</category><body package="GlorpTests">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpDatabasePlatformTest</class-id> <category>tests</category><body package="GlorpTests">addToString: aString	"Append a couple of special characters. The result will utf-8 encode to be 3 characters longer than its number of characters"	^aString, (String with: (Character value: 16r2022) "bullet point" with: (Character value: 16r0131) "Turkish i with no dot")"If PostgreSQL, or another DB returning true to measuresStringFieldWidthsInBytes, is provided in VA, this test must alter tohandle incompatible protocol between VW, which lacks Character&gt;&gt;asString and VA, in which String&gt;&gt;with:with: will not handledouble-byte entries.  The VA could be implemented as	^aString, (Character value: 16r2022) asString, (Character value: 16r0131) asString"</body><body package="GlorpTests">helpTestPrintTimestamp: aTimestampString	| aStream ts timestamp |	ts := DatabasePlatform new readTimestamp: aTimestampString for: nil.	aStream := WriteStream on: String new.	DatabasePlatform new printDate: ts isoFormatOn: aStream.	aStream nextPut: Character space.	DatabasePlatform new printTime: ts isoFormatOn: aStream milliseconds: true.	timestamp := aStream contents.	self assert: timestamp = aTimestampString.</body><body package="GlorpTests">string20	| platform |	platform := Dialect isVisualAge		ifTrue:			[Transcript cr; show: self class name, '&gt;&gt;string20: testing Oracle, not PostgreSQL'.			OraclePlatform new]		ifFalse: [PostgresSocketPlatform new].	platform characterEncoding: #'utf-8'.	^platform varchar: 20.</body><body package="GlorpTests">testNumericCoercion	| type platform num |	type := GlorpNumericType new scale: 5; precision: 2.	platform := DatabasePlatform new.	num := Dialect coerceToDoublePrecisionFloat: (123456 / 100).	self assert: (platform convertToNumber: num for: type) = num.	num := Dialect coerceToDoublePrecisionFloat: (123450 / 100).	self assert: (platform convertToNumber: num for: type) = num.	num := Dialect coerceToDoublePrecisionFloat: (123450 / 1000).	self assert: (platform convertToNumber: num for: type) = num.	num := Dialect coerceToDoublePrecisionFloat: (123456 / 1000).	self deny: (platform convertToNumber: num for: type) = num.</body><body package="GlorpTests">testPrintTimestamp	| strings |	strings := #( '2005-01-01 21:29:28.337'  '2005-01-01 01:02:00.037'  '2005-01-01 21:29:28.002'  '2005-01-01 21:29:28.001').	strings do: [:each |		self helpTestPrintTimestamp: each].</body><body package="GlorpTests">testReadTimestamp	| ts |	ts := DatabasePlatform new readTimestamp: '2003-03-03 15:29:28.337-05' for: nil.	self assert: ts asSeconds = 3224158168.	self assert: ([ts asMilliseconds = 3224158168337 ]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #asMilliseconds ]).	ts := DatabasePlatform new readTimestamp: '2003-03-13 15:29:28.337-05' for: nil.	self assert: ts asSeconds = 3225022168.	self assert: ([ts asMilliseconds = 3225022168337]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #asMilliseconds ])</body><body package="GlorpTests">testReadTimestampNoMS	| ts |	ts := DatabasePlatform new readTimestamp: '2003-03-03 15:29:28-05' for: nil.	self assert: ts year = 2003.	self assert: ts monthIndex = 3.	self assert: ts dayOfMonth = 3.	self assert: ts hours = 15.	self assert: ts minutes = 29.	self assert: ts seconds truncated = 28.	self assert: ([ ts milliseconds = 0 ]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #milliseconds ])</body><body package="GlorpTests">testReadTimestampNoMSNoTZ	| ts |	ts := DatabasePlatform new readTimestamp: '2003-03-03 15:29:28' for: nil.	self assert: ts year = 2003.	self assert: ts monthIndex = 3.	self assert: ts dayOfMonth = 3.	self assert: ts hours = 15.	self assert: ts minutes = 29.	self assert: ts seconds truncated = 28.	self assert: ([ ts milliseconds = 0 ]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #milliseconds ])</body><body package="GlorpTests">testReadTimestampNoTZ	| ts |	ts := DatabasePlatform new readTimestamp: '1975-08-13 21:29:28.337' for: nil.	self assert: ts year = 1975.	self assert: ts monthIndex = 8.	self assert: ts dayOfMonth = 13.	self assert: ts hours = 21.	self assert: ts minutes = 29.	self assert: ts seconds truncated = 28.	self assert: ([ ts milliseconds =  337]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #milliseconds ])</body><body package="GlorpTests">testReadTimestampOverflowDays	| ts |	ts := DatabasePlatform new readTimestamp: '1975-08-13 21:29:28.337-05' for: nil.	self assert: ts year = 1975.	self assert: ts monthIndex = 8.	self assert: ts dayOfMonth = 13.	self assert: ts hours = 21.	self assert: ts minutes = 29.	self assert: ts seconds truncated = 28.	self assert: ([ ts milliseconds = 337 ]		on: MessageNotUnderstood		do: [ :mnu | mnu return: mnu message selector = #milliseconds ])</body><body package="GlorpTests">testTrimString1	"Normal ascii"	| type plat |	type := self string20.	plat := type platform.	self assert: (plat trimString: 'abcdefghi' for: type) = 'abcdefghi'.	self assert: (plat trimString: 'abcdefghijklmnopqrst' for: type) = 'abcdefghijklmnopqrst'.	self assert: (plat trimString: 'abcdefghijklmnopqrstu' for: type) = 'abcdefghijklmnopqrst'.	self assert: (plat trimString: 'abcdefghijklmnopqrstuvwxy' for: type) = 'abcdefghijklmnopqrst'.</body><body package="GlorpTests">testTrimString2	"Some special characters"	| type plat string |	Dialect isVisualAge ifTrue: [Transcript cr; show: self class name; show: '&gt;&gt;testTrimString2 skipped in VA'. ^self].	type := self string20.	plat := type platform.	string := self addToString: 'abcdefghi'.	self assert: (plat trimString: string for: type) = string.	string := self addToString: 'abcdefghijklmno'.	self assert: (plat trimString: string for: type) = string.	string := self addToString: 'abcdefghijklmnop'.	self assert: (plat trimString: string for: type) = (string copyFrom: 1 to: string size -1).	string := self addToString: 'abcdefghijklmnopq'.	self assert: (plat trimString: string for: type) = (string copyFrom: 1 to: string size -1).	string := (String new: 100000) atAllPut: $a.	self assert: (plat trimString: string for: type) = 'aaaaaaaaaaaaaaaaaaaa'</body></methods><methods><class-id>Glorp.GlorpConstantMappingTest</class-id> <category>tests</category><body package="GlorpTests">testConstantInClass	slot := nil.	mappingToClass mapObject: self inElementBuilder: nil.	self assert: slot = 34.</body><body package="GlorpTests">testConstantInClassDoesNotWriteToRow	"Would raise an exception if it tried to write into nil"	mappingToClass mapFromObject: self intoRowsIn: nil.</body><body package="GlorpTests">testGetValue	slot := nil.	self assert: (mappingToClass getValueFrom: self) = 34.</body><body package="GlorpTests">testSessionValue	mappingToClass constantValueIsSession.	self assert: (mappingToClass constantValueIn: 38)== 38.</body></methods><methods><class-id>Glorp.GlorpConstantMappingTest</class-id> <category>support</category><body package="GlorpTests">setUp	| descriptor |	super setUp.	mappingToClass := ConstantMapping new		attributeName: #slot;		constantValue: 34.	descriptor := Descriptor new.	descriptor classModel: (GlorpClassModel for: self class).	descriptor addMapping: mappingToClass.	mappingToRow := ConstantMapping new.	mappingToSession := ConstantMapping new</body></methods><methods><class-id>Glorp.GlorpDatabaseBasedTest</class-id> <category>support</category><body package="GlorpTests">assert: aBrackettedString equalsIgnoringOuterBrackets: anotherString	self assert: aBrackettedString =		(anotherString first = $(			ifTrue: [anotherString]			ifFalse: ['(', anotherString, ')'])</body><body package="GlorpDBTests">setUp	system := GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database.	system session: GlorpMockSession new.	system session system: system.</body></methods><methods><class-id>Glorp.GlorpSessionBasedTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	system session: session.	session system: system.</body><body package="GlorpDBTests">tearDown	session isNil ifFalse: [session reset. session resetPermissions].	session := nil.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpSessionBasedTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpDatabaseLoginResource with: GlorpSessionResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpObjectMappedToImaginaryTableTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	system := GlorpVideoDescriptorSystem forPlatform: session platform.	session system: system.	session beginTransaction.	example := system exampleStore1.	example2 := system exampleStore2.	session inUnitOfWorkDo: [session register: example. session register: example2.].	session reset.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpObjectMappedToImaginaryTableTest</class-id> <category>tests</category><body package="GlorpDBTests">db2testReadWithDateArithmeticInWhereClause	"DB2 appears fussy in how it allows date arithmetic.  Constant durations must be labelled (i.e. + 2 days, not just + 2, and the root of an expression with a duration must be a date or timestamp.  This could be read to mean that	dueDate - 2 days - 2 hoursshould be OK and	dueDate - (2 days + 2 hours)should not be (making it impossible to compute the printing of any multi-part duration expression) but in fact tests suggest that no arrangement of brackets will allow even	dueDate - 2 days - 2 hoursand we must write only a single labelled duration expression	dueDate - 2 daysWe therefore provide functions for DB2's duration syntax and require users of DB2 to write their clauses to use them;  see DB2Platform&gt;&gt;initializeFunctions."	| rentals paramKey query |	Transcript cr; show: 'On DB2, testReadWithDateArithmeticInWhereClause only tests a limited range of date arithmetic.'.	paramKey := DatabaseField named: #dayNum type: session platform integer.	query := Query		read: GlorpVideoRental		where: [:each | each dueDate + (each parameter: paramKey) days &gt; Date today].	rentals := query		executeWithParameters: (Dictionary new at: paramKey put: 1; yourself)		in: session.	self deny: rentals isEmpty.	rentals := session		read: GlorpVideoRental		where: [:each | each dueDate + each id days &gt; Date today].	self deny: rentals isEmpty.</body><body package="GlorpDBTests">queryForComplexSubselectRead2: anInteger	"This exercises doubly-nested subselects, which caused a problem in a user application with joining to the wrong table. The gist of the query is stores where more than anInteger different customers have made rentals"	| q1 q2 q3 |	q1 := Query		read: GlorpVideoStore		where: [:store | 			q2 := Query				count: GlorpVideoCustomer				where: [:customer | 					q3 := Query						read: GlorpVideoRental						where: [:rental | rental customer = customer AND: (rental store = store)].					q3 retrieve: [:trade | trade customerName].					customer name in: q3].			(store getConstant: anInteger) &lt;= q2].	^q1.</body><body package="GlorpDBTests">queryForComplexSubselectRead: anInteger	"This exercises doubly-nested subselects, which caused a problem in a user application with joining to the wrong table. The gist of the query is stores where more than anInteger different customers have made rentals"	| q1 q2 q3 |	q1 := Query		read: GlorpVideoStore		where: [:store | 			q2 := Query				count: GlorpVideoCustomer				where: [:customer | 					q3 := Query						read: GlorpVideoRental						where: [:rental | rental store = store].					q3 retrieve: [:trade | trade customerName].					customer name in: q3].			(store getConstant: anInteger) &lt;= q2].	^q1.</body><body package="GlorpDBTests">testComplexSubselectRead	"This exercises doubly-nested subselects, which caused a problem in a user application with joining to the wrong table"	| |	self assert: (session execute: (self queryForComplexSubselectRead: 3)) size = 1.	self assert: (session execute: (self queryForComplexSubselectRead: 4)) size = 0.</body><body package="GlorpDBTests">testComplexSubselectRead2	"This exercises doubly-nested subselects, which caused a problem in a user application with joining to the wrong table"	| |	self assert: (session execute: (self queryForComplexSubselectRead2: 1)) size = 1.	self assert: (session execute: (self queryForComplexSubselectRead2: 0)) size = 2.</body><body package="GlorpDBTests">testReadBackAllCustomer	| customers |	customers := session read: GlorpVideoCustomer.	self assert: ((customers collect: [:each | each name]) asSortedCollection asArray) = #('Adrian' 'Bob' 'Carol' 'David' 'Eleanor' 'Francois' 'George' 'Hieronymous').</body><body package="GlorpDBTests">testReadBackEntireExample	| store |	store := session readOneOf: GlorpVideoStore where: [:each | each id = 1].	example assertEqual: store.</body><body package="GlorpDBTests">testReadCustomerWhere	| customers |	customers := session read: GlorpVideoCustomer where: [:each | each name like: '%an%'].	self assert: ((customers collect: [:each | each name]) asSortedCollection asArray) = #('Adrian'  'Eleanor' 'Francois').</body><body package="GlorpDBTests">testReadCustomerWhereWithJoin	| customers |	customers := session read: GlorpVideoCustomer where: [:each | each onlinePurchases anySatisfy: [:eachPurchase | eachPurchase price &gt; 2]].	self assert: ((customers collect: [:each | each name]) asSortedCollection asArray) = #('Adrian'  'George' ).</body><body package="GlorpDBTests">testReadWithDateArithmeticInWhereClause	"Test date arithmetic using constant expressions and field expressions.  Trivially, we use the id field to get a positive integer - aim is just to verify the expression runs and returns the rows.  The rental data is set up and torn down each time the test is run so (ignoring cross-midnight runs) their dates will always be today's date.	This test does not pass on SQLite."	| rentals |	"Check date +/- integer expressions;  DB2 will not accept this unlabelled, so is tested separately."	session platform class == DB2Platform ifTrue:		[^self db2testReadWithDateArithmeticInWhereClause].	rentals := session read: GlorpVideoRental where:		[:each | each dueDate + 1 &gt; Date today].	self deny: rentals isEmpty.	rentals := session read: GlorpVideoRental where:		[:each | each dueDate - (each id + each id) &lt; Date today].	self deny: rentals isEmpty.</body><body package="GlorpDBTests">testRefreshItemWithMappedPrimaryKeys	"Prior to vw8.0, Glorp would DNU if trying to refresh an object whose table's primaryKeys were values mapped to other objects, not directly to its instVars.  The primaryKeys of VIDEO_CREDIT_STATUS are mapped to objects in the instVars of its class GlorpVideoCreditStatus.  The refresh: now uses a base that knows its object's descriptor so no longer DNUs in this test."	| creditStatus |	creditStatus := session readOneOf: GlorpVideoCreditStatus.	session refresh: creditStatus.</body><body package="GlorpDBTests">testSelectByBoolean	| inStore notInStore inStoreImplied notInStoreImplied |	inStore := session read: GlorpVideoPurchase where: [:each | each inStore = true].	notInStore := session read: GlorpVideoPurchase where: [:each | each inStore = false].	self assert: inStore size = 7.	self assert: notInStore size = 3.	inStoreImplied := session read: GlorpVideoPurchase where: [:each | each inStore].	notInStoreImplied := session read: GlorpVideoPurchase where: [:each | each inStore not].	self assert: inStoreImplied size = 7.	self assert: notInStoreImplied size = 3.</body><body package="GlorpDBTests">testWrite	"Write and validate that it basically got written correctly, in terms of number and keys of db rows"	| storeRows storeRow purchaseRows purchaseKeys rentalRows rentalKeys |	storeRows := session accessor		executeSQLString: 'SELECT * FROM VIDEO_STORE'.	storeRows := storeRows asSortedCollection: [:a :b | a first &lt;= b first].	self assert: storeRows size = 2.	storeRow := storeRows first.	self assert: storeRow size = 2.	self assert: storeRow first = 1.	self assert: storeRow last = 'Als Video'.	storeRow := storeRows last.	self assert: storeRow first = 2.	self assert: storeRow last = 'Bonzai Video'.	purchaseRows := session accessor		executeSQLString: 'SELECT * FROM VIDEO_PURCHASE'.	self assert: purchaseRows size = 10.	purchaseKeys := (purchaseRows collect: [:each | each atIndex: 1])		asSortedCollection.	self assert: purchaseKeys asArray = #(1 2 3 101 102 103 104 105 106 107).	rentalRows := session accessor		executeSQLString: 'SELECT * FROM VIDEO_RENTAL'.	self assert: rentalRows size = 4.	rentalKeys := (rentalRows collect: [:each | each atIndex: 1])		asSortedCollection.	self assert: rentalKeys asArray = #(1001 1002 1003 1004).</body></methods><methods><class-id>Glorp.GlorpRowMapUnificationTest</class-id> <category>tests</category><body package="GlorpTests">testDoubleRowUnificationDifferentRows	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f3		key: o3		withField: f2		key: o2.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 42.</body><body package="GlorpTests">testDoubleRowUnificationDifferentRows2	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 42.</body><body package="GlorpTests">testDoubleRowUnificationDifferentRows3	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap rowForTable: t3 withKey: o3) at: f3 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 42.</body><body package="GlorpTests">testDoubleRowUnificationDifferentRows4	| t4 f4 o4 |	t4 := DatabaseTable named: 'T4'.	f4 := t4 createFieldNamed: 'f4' type: (platform varChar: 10).	o4 := 'four'.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f3		key: o3		withField: f4		key: o4.	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 42.	self assert: ((rowMap rowForTable: t4 withKey: o4) at: f4) = 42.</body><body package="GlorpTests">testDoubleRowUnificationSameRow	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.</body><body package="GlorpTests">testDoubleRowUnificationSameRow2	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	rowMap		unifyField: f2		key: o2		withField: f1		key: o1.	(rowMap rowForTable: t1 withKey: o1) at: f1 put: 42.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 42.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 42.</body><body package="GlorpTests">testIteration	| rows r1 r2 r3 count |	r1 := rowMap findOrAddRowForTable: t1 withKey: o1.	r2 := rowMap findOrAddRowForTable: t1 withKey: o2.	r3 := rowMap findOrAddRowForTable: t2 withKey: o2.	rows := IdentitySet new.	count := 0.	rowMap rowsDo: [:each | 		count := count + 1.		rows add: each].	self assert: count = 3.	self assert: (rows includes: r1).	self assert: (rows includes: r3).	self assert: (rows includes: r2).</body><body package="GlorpTests">testStoreThenUnify	rowMap at: f1 key: o1 put: 12.	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 12.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 12.</body><body package="GlorpTests">testStoreWithRowMapKey	| a b key1 key2 key3 table r1 r2 r3 |	a := Object new.	b := Object new.	key1 := RowMapKey new key1: a; key2: b.	key2 := RowMapKey new key1: a; key2: b.	key3 := RowMapKey new key1: b; key2: a.	table := DatabaseTable new.	r1 := rowMap findOrAddRowForTable: table withKey: key1.	r2 := rowMap findOrAddRowForTable: table withKey: key2.	r3 := rowMap findOrAddRowForTable: table withKey: key3.	self assert: r1 == r2.	self assert: r2 == r3.	self assert: r1 owner == key1.</body></methods><methods><class-id>Glorp.GlorpRowMapUnificationTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	platform := GlorpDatabaseLoginResource defaultPlatform.	t1 := DatabaseTable named: 'T1'.	t2 := DatabaseTable named: 'T2'.	t3 := DatabaseTable named: 'T3'.	f1 := t1 createFieldNamed: 'f1' type: (platform varChar: 10).	f2 := t2 createFieldNamed: 'f2' type: (platform varChar: 10).	f3 := t3 createFieldNamed: 'f3'  type: (platform varChar: 10).	rowMap := RowMap new.	o1 := 'one'.	o2 := 'two'.	o3 := 'three'.</body></methods><methods><class-id>Glorp.GlorpRowMapUnificationTest</class-id> <category>tests-transformation</category><body package="GlorpTests">testUnifyExtraOnSourceSideWithTransformationBeforeStoreForward	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap		unifyField: f1		key: o1		withField: f3		key: o3.	(rowMap findOrAddRowForTable: t1 withKey: o1) at: f1 put: 12.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 12.</body><body package="GlorpTests">testUnifyExtraOnSourceSideWithTransformationBeforeStoreInverse	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap		unifyField: f1		key: o1		withField: f3		key: o3.	(rowMap findOrAddRowForTable: t2 withKey: o2) at: f2 put: 24.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 12.</body><body package="GlorpTests">testUnifyExtraOnTargetSideWithTransformationBeforeStoreForward	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap findOrAddRowForTable: t1 withKey: o1) at: f1 put: 12.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 24.</body><body package="GlorpTests">testUnifyExtraOnTargetSideWithTransformationBeforeStoreInverse	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap		unifyField: f2		key: o2		withField: f3		key: o3.	(rowMap findOrAddRowForTable: t2 withKey: o2) at: f2 put: 24.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.	self assert: ((rowMap rowForTable: t3 withKey: o3) at: f3) = 24.</body><body package="GlorpTests">testUnifyWithTransformationAfterStoreForward	(rowMap findOrAddRowForTable: t1 withKey: o1) at: f1 put: 12.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.</body><body package="GlorpTests">testUnifyWithTransformationAfterStoreInverse	"This is a little tricky. If we set the value first, then impose the constraint, then we're effectively doubling what was set. I think this is actually right, but also a very weird case on top of weird scenarios to begin with"	(rowMap findOrAddRowForTable: t2 withKey: o2) at: f2 put: 12.	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	"Note: vs. the 6 and 12 you might otherwise expect"	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.</body><body package="GlorpTests">testUnifyWithTransformationBeforeStoreForward	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	(rowMap findOrAddRowForTable: t1 withKey: o1) at: f1 put: 12.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 12.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 24.</body><body package="GlorpTests">testUnifyWithTransformationBeforeStoreInverse	rowMap		unifyField: f1		key: o1		withField: f2		key: o2		transformationForward: [:value | value * 2]		inverse: [:value | value / 2].	rowMap at: f2 key: o2 put: 12.	self assert: ((rowMap rowForTable: t1 withKey: o1) at: f1) = 6.	self assert: ((rowMap rowForTable: t2 withKey: o2) at: f2) = 12.</body></methods><methods><class-id>Glorp.GlorpRowMapUnificationTest</class-id> <category>tests-relatedrows</category><body package="GlorpTests">testRelatedRowInternal	| cf1 r1 r2 r3 |	cf1 := t1 createFieldNamed: 'cf1' type: (platform varChar: 10).	t1 addForeignKeyFrom: cf1 to: f1.	rowMap		unifyField: f1		key: o1		withField: cf1		key: o2.	rowMap		unifyField: f1		key: o1		withField: cf1		key: o3.	r1 := rowMap rowForTable: t1 withKey: o1.	r1 at: f1 put: o1.	r2 := rowMap rowForTable: t1 withKey: o2.	r2 at: f1 put: o2.	r3 := rowMap rowForTable: t1 withKey: o3.	r3 at: f1 put: o3.	self assert: (r1 relatedRowsIn: rowMap) isEmpty.	self assert: (r2 relatedRowsIn: rowMap) asArray = (Array with: r1).	self assert: (r3 relatedRowsIn: rowMap) asArray = (Array with: r1).</body></methods><methods><class-id>Glorp.GlorpMultipleGroupingTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	"We beginTransaction to be already in transaction on entering #transact:, so #transact will not commit if the transaction succeeds;  instead, #tearDown will roll it back, clean for the next test run."	super setUp.	session system: GlorpLockingDescriptorSystem new.	session beginTransaction.	session transact:		[session system example2 do:			[:each | session register: each]].</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpMultipleGroupingTest</class-id> <category>tests</category><body package="GlorpDBTests">testDoubleGrouping	"This is a simple, single table/class test of using #groupBy: twice, retrieving an aggregate field and a count.  (It is of course easy to write a multiple groupBy: that would return conflicting values for one of the returned fields.  When such a miswritten query is run, it raises an error demanding omission of that field or aggregation of its values.)"	| books query |	query := Query read: GlorpBook.	query retrieve: [:each | each copiesInStock sum].	query retrieve: [:each | each countStar].	query groupBy: [:each | each title].	query groupBy: [:each | each version].	query orderBy: [:each | each title].	"order result so easy to check in assert"	books := session execute: query.	self assert: books = #(#(4 2) #(7 2)).</body></methods><methods><class-id>Glorp.GlorpOptimisticLockingTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session system: GlorpLockingDescriptorSystem new.	session beginTransaction.	session transact: [session register: session system example1].</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpOptimisticLockingTest</class-id> <category>tests</category><body package="GlorpDBTests">changeABookFrom: books	^session		transact:			[session register: books.			books first copiesInStock: books first copiesInStock - 1].</body><body package="GlorpDBTests">testSuccessfulUpdate	| books versions newVersions |	books := session read: GlorpBook orderBy: #id.	versions := (session accessor executeSQLString: 'SELECT VERSION FROM BOOK ORDER BY ID') collect: [:each | each first].	session modify: books in: [		books do: [:each | each copiesInStock: (each copiesInStock * 2)]].	newVersions := (session accessor executeSQLString: 'SELECT VERSION FROM BOOK ORDER BY ID') collect: [:each | each first].	self assert: newVersions = (versions collect: [:each | each + 1]).</body><body package="GlorpDBTests">testSuccessfulUpdateOntoNullVersionField	| books copies someBook |	someBook := session readOneOf: GlorpBook.	session accessor executeSQLString: 'UPDATE BOOK SET VERSION = NULL WHERE ID = ', someBook id printString. 	session reset.	books := session read: GlorpBook orderBy: #id.		copies := books collect: [:each | each copiesInStock].	session transact: [		session register: books.		books do: [:each | each copiesInStock: (each copiesInStock - 1)]].	session reset.	books := session read: GlorpBook orderBy: #id.	self assert: (books collect: [:each | each copiesInStock]) = (copies collect: [:each | each - 1]).</body><body package="GlorpDBTests">testSuccessfulUpdateTwiceWithRefresh	| book |	book := session readOneOf: GlorpBook where: [:each | each title like: 'Mastering%'].	session modify: book in: [		book copiesInStock: 4].	session refresh: book.	self assert: book copiesInStock = 4.	"Make sure we've properly updated the optimistic lock field"	session modify: book in: [		book copiesInStock: 7].	session reset.	book := session readOneOf: GlorpBook where: [:each | each title like: 'Mastering%'].	self assert: book copiesInStock = 7.</body><body package="GlorpDBTests">testSuccessfulUpdateTwiceWithRefreshAndSaveAndContinue	| book |	session beginUnitOfWork.	book := session readOneOf: GlorpBook where: [:each | each title like: 'Mastering%'].	book copiesInStock: 4.	session saveAndContinue.	session refresh: book.	self assert: book copiesInStock = 4.	"Make sure we've properly updated the optimistic lock field"	book copiesInStock: 7.	session commitUnitOfWork.	session reset.	book := session readOneOf: GlorpBook where: [:each | each title like: 'Mastering%'].	self assert: book copiesInStock = 7.</body><body package="GlorpDBTests">testUnsuccessfulUpdateProceedingAndFailing	| books |	books := session read: GlorpBook.	session accessor		executeSQLStringNoResult: 'UPDATE BOOK SET COPIES_IN_STOCK = 7, VERSION = 3'.	self should:		[[self changeABookFrom: books]			on: GlorpWriteFailure			do: [:ex | ex resume: false]]		raise: GlorpTransactionFailure		description: 'Resuming failed write with false did not raise transaction failure'.	self should:		[[self changeABookFrom: books]			on: GlorpWriteFailure			do: [:ex | ex resume]]		raise: GlorpTransactionFailure		description: 'Default resume did not falsify transaction'.	session reset.	books := session read: GlorpBook.	self assert: (books collect: [:each | each copiesInStock]) = #(7 7).</body><body package="GlorpDBTests">testUnsuccessfulUpdateProceedingAnyway	| books |	books := session read: GlorpBook.	session accessor		executeSQLStringNoResult: 'UPDATE BOOK SET COPIES_IN_STOCK = 7, VERSION = 3'.	[self changeABookFrom: books]		on: GlorpWriteFailure		do: [:ex | ex resume: true].	session reset.	books := session read: GlorpBook.	self assert: (books collect: [:each | each copiesInStock]) = #(7 7).</body><body package="GlorpDBTests">testUnsuccessfulUpdateWithNoAction	"This is a little quirky. SUnit's action in should:raise: is to exit the exception with true. So the thing just short circuits, and we don't get a transaction failure because we killed the whole unit of work. This is, in general, what will happen if we handle and don't resume the write failures."	| books |	books := session read: GlorpBook.	session accessor		executeSQLStringNoResult: 'UPDATE BOOK SET COPIES_IN_STOCK = 7, VERSION = 3'.	self shouldnt: [		self should: [self changeABookFrom: books] raise: GlorpWriteFailure]		raise: GlorpTransactionFailure.	session reset.	books := session read: GlorpBook.	self assert: (books collect: [:each | each copiesInStock]) = #(7 7).</body></methods><methods><class-id>Glorp.GlorpDatabaseSequenceTest</class-id> <category>tests</category><body package="GlorpDBTests">assignSequences	| accessor |	accessor := session isNil ifFalse: [session accessor].	row1 preWriteAssignSequencesUsing: session.	row1 postWriteAssignSequencesUsing: accessor.	row2 preWriteAssignSequencesUsing: session.	row2 postWriteAssignSequencesUsing: accessor</body><body package="GlorpDBTests">increment	"If the platform&gt;&gt;supportsSettingSequenceIncrement, then this test should ask for the increment from the sequence object itself.  Otherwise, it is the default, 1."	^system platform supportsSettingSequenceIncrement		ifTrue: [sequence sequenceIncrement]		ifFalse: [1]</body><body package="GlorpDBTests">row1Value	^row1 atFieldNamed: 'ID'.</body><body package="GlorpDBTests">row2Value	^row2 atFieldNamed: 'ID'.</body><body package="GlorpDBTests">testGetNextValue	session platform usesIdentityColumns ifTrue: [^self].	self assignSequences.	self assert: self row2Value = (self row1Value + 1).</body><body package="GlorpDBTests">testGetNextValues	"If the platform supportsSettingSequenceIncrement then the increment will be computed in the image within each range and only got from the database at the start of each range (i.e. at 1, 4, 7 and 10, since this test's increment is 3 at time of writing - see tableForBANK_TRANS:) in method nextSequenceNumber:."	| rows thisID nextID |	session platform usesIdentityColumns ifTrue: [^self].	rows := Array new: 10.	1 to: 10 do:		[:i || row |		row := DatabaseRow newForTable: table.		row preWriteAssignSequencesUsing: session.		row postWriteAssignSequencesUsing: session accessor.		rows at: i put: row].	1 to: 9 do:		[:i |		thisID := (rows at: i) atFieldNamed: 'ID'.		nextID := (rows at: i + 1) atFieldNamed: 'ID'.		self assert: nextID = (thisID + 1)].</body><body package="GlorpDBTests">testReserveEmpty	session platform usesIdentityColumns ifTrue: [^self].	sequence reserveSequenceNumbers: 2 in: session for: table.	session := nil.	self assignSequences.	self assert: self row1Value + self increment = self row2Value.</body><body package="GlorpDBTests">testReserveUsingTable	session platform usesIdentityColumns ifTrue: [^self].	[session beginTransaction.	self writeTransactionRow: 65.	self writeTransactionRow: 66.	self writeTransactionRow: 67.	sequence reserveSequenceNumbers: 7 in: session for: table]		ensure: [session rollbackTransaction].	session := nil.	self assignSequences.	self assert: self row1Value + self increment = self row2Value.</body><body package="GlorpDBTests">testReservedNumberAllocation	session := nil.	sequence reservedNumbers add: 23; add: 24.	self assignSequences.	self assert: self row1Value = 23.	self assert: self row2Value = 24.</body><body package="GlorpDBTests">writeTransactionRow: anInteger	| tempRow |	tempRow := DatabaseRow newForTable: table.	session platform usesIdentityColumns ifFalse: [		tempRow atFieldNamed: 'ID' put: anInteger].	tempRow atFieldNamed: 'AMT_CURR' put: 'CDN'.	session writeRow: tempRow.</body></methods><methods><class-id>Glorp.GlorpDatabaseSequenceTest</class-id> <category>setup</category><body package="GlorpDBTests">setUp	super setUp.	table := session system tableNamed: 'BANK_TRANS'.	sequence := (table fieldNamed: 'ID') type sequence.	row1 := DatabaseRow newForTable: table.	row2 := DatabaseRow newForTable: table.</body></methods><methods><class-id>Glorp.GlorpMediaType</class-id> <category>accessing</category><body package="GlorpTestModels">mimeType	^mimeType</body><body package="GlorpTestModels">mimeType: anObject	mimeType := anObject</body><body package="GlorpTestModels">name 	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpMediaType class</class-id> <category>instance creation</category><body package="GlorpTestModels">text	^self new name: 'text'; mimeType: 'text/plain'</body></methods><methods><class-id>Glorp.GlorpTestUpdatingTimestampInRecord</class-id> <category>tests</category><body package="GlorpDBTests">testUpdating	| record firstTime secondTime |	session beginTransaction.	[	"First verify that when we insert, a timestamp is set"	record := GlorpRecordWithUpdateTime new id: 12; name: 'thing'.	session modify: record in: [ ].	session reset.	record := session readOneOf: GlorpRecordWithUpdateTime.	self assert: record id = 12.	firstTime := record updateTime asSeconds.	self assert: (firstTime - Timestamp now asSeconds) &lt; 2.	"Now wait long enough for the timestamp to definitely change, and verify that if modify the object it changes"	(Delay forSeconds: 2) wait.	session modify: record in: [record name: 'different'].	secondTime := record updateTime asSeconds.	self deny: secondTime = firstTime.	"Now verify that if we don't modify the object, we don't write the timestamp, or put it into the object"	(Delay forSeconds: 2) wait.	session modify: record in: [].	self assert: record updateTime asSeconds = secondTime.	session reset.	record := session readOneOf: GlorpRecordWithUpdateTime.	self assert: record updateTime asSeconds = secondTime.]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testUpdatingComment	"Test that we update the unmapped comment field. We just put the printString of time now into the field, so most of the same sort of logic applies as in testUpdating."	| record time time2 rows |	session beginTransaction.	[	"First verify that when we insert, a comment is set"	record := GlorpRecordWithUpdateTime new id: 12; name: 'thing'.	time := Time now printString.	session modify: record in: [ ].	time2 := Time now printString.	session reset.	rows := session accessor executeSQLString: 'SELECT UPDATE_COMMENT from RECORD_WITH_UPDATE'.	"Just in case the seconds flipped in that interval between us noting the time and the value being generated, check against before and after. I really can't see there being more than a one second gap in there"	self assert: (rows first first = time or: [rows first first = time2]).	"Now wait long enough for the time to definitely change, and verify that if modify the object it changes"	(Delay forSeconds: 2) wait.	record := session readOneOf: GlorpRecordWithUpdateTime.	time := Time now printString.	session modify: record in: [record name: 'different'].	time2 := Time now printString.	rows := session accessor executeSQLString: 'SELECT UPDATE_COMMENT from RECORD_WITH_UPDATE'.	"Just in case the seconds flipped in that interval between us noting the time and the value being generated, check against before and after. I really can't see there being more than a one second gap in there"	self assert: (rows first first = time or: [rows first first = time2]).	"Now verify that if we don't modify the object, we don't write the comment, or put it into the object"	(Delay forSeconds: 2) wait.	session modify: record in: [].	rows := session accessor executeSQLString: 'SELECT UPDATE_COMMENT from RECORD_WITH_UPDATE'.	"Now verify that we still have the previous time value"	self assert: (rows first first = time or: [rows first first = time2]).]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testUpdatingOtherThing	"Test that we update the mapped other thing field. We just put the printString of time now into the field, so most of the same sort of logic applies as in testUpdating."	| record time time2 newThing |	session beginTransaction.	[	"First verify that when we insert, a comment is set"	record := GlorpRecordWithUpdateTime new id: 12; name: 'thing'.	time := Time now printString.	session modify: record in: [ ].	time2 := Time now printString.	session reset.	newThing := session readOneOf: GlorpRecordWithUpdateTime.	"Just in case the seconds flipped in that interval between us noting the time and the value being generated, check against before and after. I really can't see there being more than a one second gap in there"	self assert: (newThing updateSomeOtherThing = time or: [newThing updateSomeOtherThing = time2]).	"Now wait long enough for the time to definitely change, and verify that if modify the object it changes"	(Delay forSeconds: 2) wait.	session reset.	record := session readOneOf: GlorpRecordWithUpdateTime.	time := Time now printString.	session modify: record in: [record name: 'different'].	time2 := Time now printString.	session reset.	newThing := session readOneOf: GlorpRecordWithUpdateTime.	self assert: (newThing updateSomeOtherThing = time or: [newThing updateSomeOtherThing = time2]).	record := session readOneOf: GlorpRecordWithUpdateTime.	"Now verify that if we don't modify the object, we don't write the comment, or put it into the object"	(Delay forSeconds: 2) wait.	session modify: record in: [].	session reset.	newThing := session readOneOf: GlorpRecordWithUpdateTime.	self assert: (newThing updateSomeOtherThing = time or: [newThing updateSomeOtherThing = time2]).]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.DefaultableThing</class-id> <category>accessing</category><body package="GlorpDBTests">boolean	^boolean</body><body package="GlorpDBTests">boolean: anObject	boolean := anObject</body><body package="GlorpDBTests">id	^id</body><body package="GlorpDBTests">id: anObject	id := anObject</body><body package="GlorpDBTests">integer	^integer</body><body package="GlorpDBTests">integer: anObject	integer := anObject</body></methods><methods><class-id>GlorpOrderedDeleteTest</class-id> <category>running</category><body package="GlorpDBTests">setUp	super setUp.	session system: (GlorpOrderedLinkDescriptorSystem forPlatform: session platform).	session beginTransaction.	session inUnitOfWorkDo:		[session register: (GlorpTravelFolder new name: 'Test')].</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests">testDeleteFromAndAddToOrderedCollection	| folderFromDB final |	folderFromDB := session readOneOf: GlorpTravelFolder.	session inUnitOfWorkDo:		[session register: folderFromDB.		1 to: 4 do: [:idx | folderFromDB files add: (GlorpTravelFile new name: 'File' , idx printString)]].	session inUnitOfWorkDo:		[session register: folderFromDB.		folderFromDB files remove: (folderFromDB files detect: [:each | each name = 'File3']).		folderFromDB files add: (GlorpTravelFile new name: 'A New File').		folderFromDB files add: (GlorpTravelFile new name: 'Another New File').		].	final := (session refresh: folderFromDB) files.	self assert: final size = 5.	self assert: (final collect: #name) asSortedCollection asArray = #('A New File' 'Another New File' 'File1' 'File2' 'File4').</body><body package="GlorpDBTests">testDeleteFromOrderedCollection	| folderFromDB final |	folderFromDB := session readOneOf: GlorpTravelFolder.	session inUnitOfWorkDo:		[session register: folderFromDB.		1 to: 4 do: [:idx | folderFromDB files add: (GlorpTravelFile new name: 'File' , idx printString)]].	session inUnitOfWorkDo:		[session register: folderFromDB.		folderFromDB files remove: (folderFromDB files detect: [:each | each name = 'File3']).		].	final := (session refresh: folderFromDB) files.	self assert: final size = 3.	self assert: (final collect: #name) asSortedCollection asArray = #( 'File1' 'File2' 'File4').</body><body package="GlorpDBTests">testDeleteFromUnorderedCollection	"Create 4 'files' in my main 'folder', save, then delete the third and save. Get the persistent state,	verify that the unordered files collection is file1, file2 and file4."	| folderFromDB final |	folderFromDB := (session read: GlorpTravelFolder				where: [:each | each name = 'Test']) first.	session inUnitOfWorkDo:		[session register: folderFromDB.		1 to: 4 do: [:idx | folderFromDB unordered add: (GlorpTravelFile new name: 'File' , idx printString)]].	(session refresh: folderFromDB) unordered.	folderFromDB := (session read: GlorpTravelFolder where: [:each | each name = 'Test']) first.	session inUnitOfWorkDo:		[session register: folderFromDB.		folderFromDB unordered remove: (folderFromDB unordered detect: [:each | each name = 'File3'])].	final := (session refresh: folderFromDB) unordered.	self assert: final size = 3.	self assert: (final collect: #name) asSortedCollection asArray = #('File1' 'File2' 'File4').</body><body package="GlorpDBTests">testRearrangeOrderedCollection	| folder newFolder |	folder := GlorpTravelFolder new name: 'Fred'.	4 to: 1 by: -1 do: [:idx | folder files add: (GlorpTravelFile new name: 'File' , idx printString)].	session inUnitOfWorkDo: [		session register: folder.		folder files: (folder files asSortedCollection asOrderedCollection)].	session reset.	newFolder := session readOneOf: GlorpTravelFolder where: [:each | each name = 'Fred'].	self assert: newFolder files asArray = newFolder files asSortedCollection asArray.	self assert: newFolder files size = 4.</body><body package="GlorpDBTests">testValidationOfSystemWithOrderFieldInPrimaryKey	"A mapping with a link table and which writes the order field must define primary key fields and must not include the order field as a primary key.  If we remove the primary key fields from the ordered link table, it will make all the fields primary, including the order field, so should raise a validation error."	session system giveOrderedLinkTableNoPrimaryKeyFields.	self		should: [session system validate]		raise: Error		description:  'Validation of this system should have failed'.</body></methods><methods><class-id>Glorp.ClassO</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassO	^attrAClassO</body><body package="GlorpTestModels">attrAClassO: anObject	attrAClassO := anObject</body><body package="GlorpTestModels">attrBClassO	^attrBClassO</body><body package="GlorpTestModels">attrBClassO: anObject	attrBClassO := anObject</body><body package="GlorpTestModels">attrCClassO	^attrCClassO</body><body package="GlorpTestModels">attrCClassO: anObject	attrCClassO := anObject</body><body package="GlorpTestModels">attrDClassO	^attrDClassO</body><body package="GlorpTestModels">attrDClassO: anObject	attrDClassO := anObject</body></methods><methods><class-id>Glorp.GlorpObjectMappedToFunctionTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	| accountRow3 |	super setUp.	session beginTransaction.	system writeCustomer1Rows.	accountRow3 := system exampleAccountRow3.	session writeRow: accountRow3.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests">testRelationships	| branch accounts |	branch := session readOneOf: GlorpBankBranch where: [:each | each branchNumber = 2].	accounts := branch accounts yourself.	self assert: accounts size = 1.	self assert: accounts first id = 9874.</body></methods><methods><class-id>Glorp.GlorpObjectMappedToFunctionTest</class-id> <category>tests</category><body package="GlorpDBTests">testBasicRead	| branches |	branches := session read: GlorpBankBranch.	self assert: branches size = 3.	self assert: (branches collect: [:each | each branchNumber]) asSortedCollection = #(2 3 712) asSortedCollection.</body><body package="GlorpDBTests">testCache	| branches branch2 branch3 |	branches := session read: GlorpBankBranch.	branch2 := session readOneOf: GlorpBankBranch where: [:each | each branchNumber = 2].	branch3 := session readOneOf: GlorpBankBranch where: [:each | each branchNumber = 3].	self deny: branch2 == branch3.	self assert: (branches includes: branch2).	self assert: (branches includes: branch3).</body><body package="GlorpDBTests">testNoWriteValidation	| |	(session system descriptorFor: GlorpBankBranch) mappings next readOnly: false.	self should: [session system validate] raise: Dialect error.</body><body package="GlorpDBTests">testReadQueryingAttributes	| branches |	branches := session read: GlorpBankBranch where: [:each |		each accounts anySatisfy: [:eachAccount |			eachAccount accountNumber accountNumber in: #( '3' '4')]].	self assert: branches size = 2.	self assert: branches asSet size = 2.</body></methods><methods><class-id>Glorp.GlorpMessage</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	folder := nil.	user := nil.	subject := ''.	contents := ''.</body></methods><methods><class-id>Glorp.GlorpMessage</class-id> <category>accessing</category><body package="GlorpTestModels">contents	^contents</body><body package="GlorpTestModels">contents: aString	contents := aString</body><body package="GlorpTestModels">folder	^folder</body><body package="GlorpTestModels">folder: aGlorpFolder	folder := aGlorpFolder</body><body package="GlorpTestModels">folderName	^self folder name.</body><body package="GlorpTestModels">subject	^subject</body><body package="GlorpTestModels">subject: aString	subject := aString</body><body package="GlorpTestModels">user	^user</body><body package="GlorpTestModels">user: aGlorpUser	user := aGlorpUser</body><body package="GlorpTestModels">userId	^self user id.</body></methods><methods><class-id>Glorp.GlorpMessage class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpReservation</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger</body><body package="GlorpTestModels">passenger	^passenger</body><body package="GlorpTestModels">passenger: aPassenger	passenger := aPassenger.	passengers add: aPassenger.</body><body package="GlorpTestModels">passengers	^passengers</body><body package="GlorpTestModels">passengers: aCollection	passengers := aCollection.</body></methods><methods><class-id>Glorp.GlorpReservation</class-id> <category>initialize/release</category><body package="GlorpTestModels">initialize	passengers := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpReservation class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		id: 2;		passenger: GlorpPassenger example1.</body><body package="GlorpTestModels">example2	^self new		id: 7;		passenger: GlorpPassenger example2.</body></methods><methods><class-id>Glorp.GlorpReservation class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpProxyEqualityTest</class-id> <category>initialize-release</category><body package="GlorpTestModels">setUp 	super setUp. 	session := GlorpSessionResource current newSession.	proxy := Proxy new.	proxy session: session.	stub := GlorpQueryStub readOneOf: GlorpAddress where: [:address | address id = 1].	stub result: 'abc'.	proxy query: stub.	proxy parameters: #().	proxy2 := Proxy new.	proxy2 session: session.	stub2 := GlorpQueryStub readOneOf: GlorpAddress where: [:address | address id = 1].	stub2 result: 'abc'.	proxy2 query: stub2.	proxy2 parameters: #().</body><body package="GlorpTestModels">setUp2	proxy query result: 'def'</body><body package="GlorpTestModels">testEquality	self assert: proxy = proxy2.</body><body package="GlorpTestModels">testEquality2	self assert: proxy2 = proxy.</body><body package="GlorpTestModels">testEqualityFailing	self setUp2.	self deny: proxy = proxy2.</body><body package="GlorpTestModels">testEqualityFailing2	self setUp2.	self deny: proxy2 = proxy.</body><body package="GlorpTestModels">testInequality	self setUp2.	self deny: proxy = proxy2.</body><body package="GlorpTestModels">testInequality2	self setUp2.	self deny: proxy2 = proxy.</body><body package="GlorpTestModels">testInequalityFailing	self deny: proxy ~= proxy2.</body><body package="GlorpTestModels">testInequalityFailing2	self deny: proxy2 ~= proxy.</body></methods><methods><class-id>Glorp.GlorpProxyEqualityTest class</class-id> <category>Accessing</category><body package="GlorpTestModels">resources	^Array with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpWarehouse</class-id> <category>accessing</category><body package="GlorpTestModels">address	^address</body><body package="GlorpTestModels">address: anObject	address := anObject</body><body package="GlorpTestModels">currentItem	^currentItem</body><body package="GlorpTestModels">currentItem: anInventoryItem	currentItem := anInventoryItem</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">items	^items</body><body package="GlorpTestModels">items: aCollection	items := aCollection</body></methods><methods><class-id>Glorp.GlorpWorkingStiff</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpWorkingStiff</class-id> <category>comparing</category><body package="GlorpTestModels">= aWorkingStiff	^self class = aWorkingStiff class and: [id = aWorkingStiff id and: [name = aWorkingStiff name]].</body></methods><methods><class-id>Glorp.GlorpSalariedEmployee</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger</body><body package="GlorpTestModels">salary	^salary</body><body package="GlorpTestModels">salary: aNumber	salary := aNumber</body></methods><methods><class-id>Glorp.GlorpWorker</class-id> <category>initialize/release</category><body package="GlorpTestModels">initialize	pendingJobs := OrderedCollection new.	finishedJobs := OrderedCollection new.	priorityJobs := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpWorker</class-id> <category>accessing</category><body package="GlorpTestModels">finishedJobs	^finishedJobs</body><body package="GlorpTestModels">finishedJobs: anObject	finishedJobs := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body><body package="GlorpTestModels">pendingJobs	^pendingJobs</body><body package="GlorpTestModels">pendingJobs: anObject	pendingJobs := anObject</body><body package="GlorpTestModels">priorityJobs	^priorityJobs</body><body package="GlorpTestModels">priorityJobs: anObject	priorityJobs := anObject</body></methods><methods><class-id>Glorp.GlorpWorker class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels">exampleCreditStatus1	| example |	example := GlorpVideoCreditStatus new.		example balanceOwing: 12.00.	example dateOwing: (Date today addDays: -1).	example comments: 'One'.	^example.</body><body package="GlorpTestModels">exampleCreditStatus2	| example |	example := GlorpVideoCreditStatus new.		example balanceOwing: 22.00.	example dateOwing: (Date today addDays: -1).	example comments: 'Two'.	^example.</body><body package="GlorpTestModels">exampleCreditStatus3	| example |	example := GlorpVideoCreditStatus new.		example balanceOwing: 33.00.	example dateOwing: (Date today addDays: -1).	example comments: 'Three'.	^example.</body><body package="GlorpTestModels">exampleCustomer1	"A customer with only online purchases"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Adrian'.	customer dateOfBirth: (Date today subtractDays: (10 * 365)).	customer addOnlinePurchase: self exampleOnlinePurchase1.	customer addOnlinePurchase: self exampleOnlinePurchase2.	^customer.</body><body package="GlorpTestModels">exampleCustomer2	"A customer with only inStore purchases"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Bob'.	customer dateOfBirth: (Date today subtractDays: (20 * 365)).	customer addInStorePurchase: self exampleInStorePurchase1.	^customer.</body><body package="GlorpTestModels">exampleCustomer3	"A customer with only rentals"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Carol'.	customer dateOfBirth: (Date today subtractDays: (30 * 365)).	customer addRental: self exampleInStoreRental1.	^customer.</body><body package="GlorpTestModels">exampleCustomer4	"A customer with only credit"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'David'.	customer dateOfBirth: (Date today subtractDays: (40 * 365)).	customer creditStatus: self exampleCreditStatus1.	^customer.</body><body package="GlorpTestModels">exampleCustomer5	"A customer with purchases and rentals"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Eleanor'.	customer dateOfBirth: (Date today subtractDays: 50 * 365).	customer addInStorePurchase: self exampleInStorePurchase2.	customer addInStorePurchase: self exampleInStorePurchase3.	customer addRental: self exampleInStoreRental2.	^customer.</body><body package="GlorpTestModels">exampleCustomer6	"A customer with purchases and credit"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Francois'.	customer dateOfBirth: (Date today subtractDays: 60 * 365).	customer addInStorePurchase: self exampleInStorePurchase4.	customer addInStorePurchase: self exampleInStorePurchase5.	customer creditStatus: self exampleCreditStatus2.	^customer.</body><body package="GlorpTestModels">exampleCustomer7	"A customer with everything"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'George'.	customer dateOfBirth: (Date today subtractDays: 70 * 365).	customer addInStorePurchase: self exampleInStorePurchase6.	customer addOnlinePurchase: self exampleOnlinePurchase3.	customer addRental: self exampleInStoreRental3.	customer addRental: self exampleInStoreRental4.	customer creditStatus: self exampleCreditStatus3.	^customer.</body><body package="GlorpTestModels">exampleCustomer8	"A customer with just a single purchase"	| customer |	customer := GlorpVideoCustomer new.	customer name: 'Hieronymous'.	customer dateOfBirth: (Date today subtractDays: 80 * 365).	customer addInStorePurchase: self exampleInStorePurchase7.	^customer.</body><body package="GlorpTestModels">exampleInStorePurchase1	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 101.	purchase title: 'An American in Paris'.	purchase price: 1.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels">exampleInStorePurchase2	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 102.	purchase title: 'Brazil'.	purchase price: 2.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels">exampleInStorePurchase3	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 103.	purchase title: 'Cambodia, Swimming To'.	purchase price: 3.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels">exampleInStorePurchase4	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 104.	purchase title: 'Dogma'.	purchase price: 4.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels">exampleInStorePurchase5	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 105.	purchase title: 'ET'.	purchase price: 5.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels">exampleInStorePurchase6	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 106.	purchase title: 'Fargo'.	purchase price: 6.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels">exampleInStorePurchase7	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 107.	purchase title: 'Glengarry GlenRoss'.	purchase price: 7.00.	purchase inStore: true.	^purchase.</body><body package="GlorpTestModels">exampleInStoreRental1	| rental |	rental := GlorpVideoRental new.	rental id: 1001.	rental title: 'Amelie'.	rental price: 21.00.	rental dueDate: Date today.	^rental.</body><body package="GlorpTestModels">exampleInStoreRental2	| rental |	rental := GlorpVideoRental new.	rental id: 1002.	rental title: 'Best in Show'.	rental price: 22.00.	rental dueDate: Date today.	^rental.</body><body package="GlorpTestModels">exampleInStoreRental3	| rental |	rental := GlorpVideoRental new.	rental id: 1003.	rental title: 'Charlie Brown Christmas'.	rental price: 23.00.	rental dueDate: Date today.	^rental.</body><body package="GlorpTestModels">exampleInStoreRental4	| rental |	rental := GlorpVideoRental new.	rental id: 1004.	rental title: 'Down By Law'.	rental price: 24.00.	rental dueDate: Date today.	^rental.</body><body package="GlorpTestModels">exampleOnlinePurchase1	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 1.	purchase title: 'All About Eve'.	purchase price: 1.11.	purchase inStore: false.	^purchase.</body><body package="GlorpTestModels">exampleOnlinePurchase2	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 2.	purchase title: 'Butch Cassidy and the Sundance Kid'.	purchase price: 2.22.	purchase inStore: false.	^purchase.</body><body package="GlorpTestModels">exampleOnlinePurchase3	| purchase |	purchase := GlorpVideoPurchase new.	purchase id: 3.	purchase title: 'Cabaret'.	purchase price: 3.33.	purchase inStore: false.	^purchase.</body><body package="GlorpTestModels">exampleStore1	"self new exampleStore1"	| example |	example := GlorpVideoStore new.	example name: 'Als Video'.	example id: 1.	example customers: (Array with: self exampleCustomer1 with: self exampleCustomer2 with: self exampleCustomer3 with: self exampleCustomer4), (Array with: self exampleCustomer5 with: self exampleCustomer6 with: self exampleCustomer7).	example computeCollections.	^example.</body><body package="GlorpTestModels">exampleStore2	"self new exampleStore2"	| example |	example := GlorpVideoStore new.	example name: 'Bonzai Video'.	example id: 2.	example customers: (Array with: self exampleCustomer8).	example computeCollections.	^example.</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForGlorpVideoCreditStatus: aDescriptor	| table |	table := self tableNamed: 'VIDEO_CREDIT_STATUS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #balanceOwing to: (table fieldNamed: 'BALANCE').	(aDescriptor newMapping: DirectMapping) from: #dateOwing to: (table fieldNamed: 'DATE_OWING').	(aDescriptor newMapping: DirectMapping) from: #comments to: (table fieldNamed: 'COMMENTS').	(aDescriptor newMapping: OneToOneMapping)			attributeName: #customer.</body><body package="GlorpTestModels">descriptorForGlorpVideoCustomer: aDescriptor	| table linkTable purchaseTable |	table := self tableNamed: 'VIDEO_CUSTOMER'.	linkTable := self tableNamed: 'VIDEO_PURCHASE_LINK'.	purchaseTable := self tableNamed: 'VIDEO_PURCHASE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'CUSTOMERNAME').	(aDescriptor newMapping: DirectMapping) from: #dateOfBirth to: (table fieldNamed: 'BIRTHDATE').	(aDescriptor newMapping: OneToOneMapping)			attributeName: #store.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #creditStatus.	(aDescriptor newMapping: ToManyMapping)		attributeName: #inStoreRentals.	(aDescriptor newMapping: ToManyMapping)		useLinkTable;		attributeName: #inStorePurchases;		linkTableJoin: (Join 			from: (table fieldNamed: 'STORE_ID')			to: (linkTable fieldNamed: 'STORE_ID'));		targetTableJoin: (Join			from: (table fieldNamed: 'CUSTOMERNAME')			to: (purchaseTable fieldNamed: 'CUSTOMERNAME')			from: (table fieldNamed: 'BIRTHDATE')			to: (purchaseTable fieldNamed: 'CUSTOMERBIRTHDATE')			from: 'T'			to: (purchaseTable fieldNamed: 'IN_STORE'));			constructRowMapKeyAs: [:customer :purchase | 					MultipleRowMapKey with: customer with: purchase with: customer videoStore yourself].	(aDescriptor newMapping: ToManyMapping)		useLinkTable;		attributeName: #onlinePurchases;		linkTableJoin: (Join 			from: (table fieldNamed: 'STORE_ID')			to: (linkTable fieldNamed: 'STORE_ID'));		targetTableJoin: (Join 				from: (table fieldNamed: 'CUSTOMERNAME')			to: (purchaseTable fieldNamed: 'CUSTOMERNAME')			from: (table fieldNamed: 'BIRTHDATE')			to: (purchaseTable fieldNamed: 'CUSTOMERBIRTHDATE')			from: 'F'			to: (purchaseTable fieldNamed: 'IN_STORE'));			constructRowMapKeyAs: [:customer :purchase | 					MultipleRowMapKey with: customer with: purchase with: customer videoStore yourself].	"A complicated way of saying that the Store plus one other attribute has to be there"	aDescriptor imaginaryTableIsDefinedByRelationFrom: #store to: #inStorePurchases.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #store to: #inStoreRentals.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #store to: #onlinePurchases.	aDescriptor imaginaryTableIsDefinedByRelationFrom: #store to: #creditStatus.	aDescriptor buildReplacementTableSelect.</body><body package="GlorpTestModels">descriptorForGlorpVideoPurchase: aDescriptor	| table |	table := self tableNamed: 'VIDEO_PURCHASE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #title to: (table fieldNamed: 'TITLE').	(aDescriptor newMapping: DirectMapping) from: #price to: (table fieldNamed: 'PRICE').	(aDescriptor newMapping: DirectMapping) from: #inStore to: (table fieldNamed: 'IN_STORE').	(aDescriptor newMapping: OneToOneMapping)			useLinkTable;			attributeName: #store;			constructRowMapKeyAs: [:purchase :store | 					MultipleRowMapKey with: purchase with: store with: purchase customer yourself].	(aDescriptor newMapping: OneToOneMapping)		attributeName: #customer.</body><body package="GlorpTestModels">descriptorForGlorpVideoRental: aDescriptor	| table |	table := self tableNamed: 'VIDEO_RENTAL'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #title to: (table fieldNamed: 'TITLE').	(aDescriptor newMapping: DirectMapping) from: #dueDate to: (table fieldNamed: 'DUE_DATE').	(aDescriptor newMapping: DirectMapping) from: #price to: (table fieldNamed: 'PRICE').	(aDescriptor newMapping: DirectMapping) fromPseudoVariable: #customerName to: (table fieldNamed: 'CUSTOMERNAME').	(aDescriptor newMapping: OneToOneMapping)		attributeName: #customer.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #store.</body><body package="GlorpTestModels">descriptorForGlorpVideoStore: aDescriptor	| table |	table := self tableNamed: 'VIDEO_STORE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: ToManyMapping)			attributeName: #customers;			join: (Join				from: (table fieldNamed: 'ID')				to: ((self tableNamed: 'VIDEO_CUSTOMER') fieldNamed: 'STORE_ID')).	"The relationship to purchases is different from the one in customer, which distinguishes online from inStore"	(aDescriptor newMapping: ToManyMapping)		useLinkTable;		attributeName: #purchases;		constructRowMapKeyAs: [:store :purchase | 					MultipleRowMapKey with: store with: purchase with: purchase customer yourself].	"No relationship to rentals at all"</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>accessing</category><body package="GlorpTestModels">allTableNames	^#('VIDEO_STORE' 'VIDEO_PURCHASE' 'VIDEO_RENTAL' 'VIDEO_PURCHASE_LINK' 'VIDEO_CUSTOMER' 'VIDEO_CREDIT_STATUS').</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpVideoStore;		add: GlorpVideoCreditStatus;		add: GlorpVideoCustomer;		add: GlorpVideoPurchase;		add: GlorpVideoRental;		yourself</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForVIDEO_CREDIT_STATUS: aTable	| customerTable custName custDate storeId |	customerTable := self tableNamed: 'VIDEO_CUSTOMER'.	custName := (aTable createFieldNamed: 'CUSTOMERNAME' type: (platform varchar: 50))		bePrimaryKey.	custDate := (aTable createFieldNamed: 'CUSTOMERBIRTHDATE' type: platform date) bePrimaryKey.	storeId := (aTable createFieldNamed: 'STORE_ID' type: platform int4) bePrimaryKey.	aTable addForeignKeyFrom: custName		to: (customerTable fieldNamed: 'CUSTOMERNAME')		from: custDate		to: (customerTable fieldNamed: 'BIRTHDATE')		from: storeId		to: (customerTable fieldNamed: 'STORE_ID') .	aTable addForeignKeyFrom: storeId to: ((self tableNamed: 'VIDEO_STORE') fieldNamed: 'ID').	aTable createFieldNamed: 'BALANCE' type: (platform double).	aTable createFieldNamed: 'DATE_OWING' type: platform date.	aTable createFieldNamed: 'COMMENTS' type: (platform varchar: 50).</body><body package="GlorpTestModels">tableForVIDEO_CUSTOMER: aTable	"Note: This table is imaginary"	| storeId |	aTable isImaginary: true.	(aTable createFieldNamed: 'CUSTOMERNAME' type: (platform varchar: 50))		bePrimaryKey.	(aTable createFieldNamed: 'BIRTHDATE' type: platform date) bePrimaryKey.	storeId := (aTable createFieldNamed: 'STORE_ID' type: (platform int4)) bePrimaryKey.	aTable addForeignKeyFrom: storeId		to: ((self tableNamed: 'VIDEO_STORE') fieldNamed: 'ID')</body><body package="GlorpTestModels">tableForVIDEO_PURCHASE: aTable	| custName custDate customerTable |	(aTable createFieldNamed: 'ID' type: (platform int4)) bePrimaryKey.	customerTable := self tableNamed: 'VIDEO_CUSTOMER'.	custName := aTable createFieldNamed: 'CUSTOMERNAME' type: (platform varchar: 50).	custDate := aTable createFieldNamed: 'CUSTOMERBIRTHDATE' type: platform date.	aTable addForeignKeyFrom: custName		to: (customerTable fieldNamed: 'CUSTOMERNAME')		from: custDate		to: (customerTable fieldNamed: 'BIRTHDATE').	aTable createFieldNamed: 'TITLE' type: (platform varchar: 50).		aTable createFieldNamed: 'PRICE' type: (platform double).	aTable createFieldNamed: 'IN_STORE' type: (platform char: 1).</body><body package="GlorpTestModels">tableForVIDEO_PURCHASE_LINK: aTable	| storeId purchaseId |	purchaseId := aTable createFieldNamed: 'PURCHASE_ID' type: platform int4.	storeId := aTable createFieldNamed: 'STORE_ID' type: (platform int4).	aTable addForeignKeyFrom: storeId		to: ((self tableNamed: 'VIDEO_STORE') fieldNamed: 'ID').	aTable addForeignKeyFrom: purchaseId		to: ((self tableNamed: 'VIDEO_PURCHASE') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForVIDEO_RENTAL: aTable	| custName custDate storeId customerTable |	(aTable createFieldNamed: 'ID' type: (platform int4)) bePrimaryKey.	customerTable := self tableNamed: 'VIDEO_CUSTOMER'.	custName := aTable createFieldNamed: 'CUSTOMERNAME' type: (platform varchar: 50).	custDate := aTable createFieldNamed: 'CUSTOMERBIRTHDATE' type: platform date.	storeId := aTable createFieldNamed: 'STORE_ID' type: (platform int4).	aTable addForeignKeyFrom: custName		to: (customerTable fieldNamed: 'CUSTOMERNAME')		from: custDate		to: (customerTable fieldNamed: 'BIRTHDATE')		from: storeId		to: (customerTable fieldNamed: 'STORE_ID').	aTable addForeignKeyFrom: storeId to: ((self tableNamed: 'VIDEO_STORE') fieldNamed: 'ID').	aTable createFieldNamed: 'TITLE' type: (platform varchar: 50).		aTable createFieldNamed: 'DUE_DATE' type: platform date.	aTable createFieldNamed: 'PRICE' type: (platform double).</body><body package="GlorpTestModels">tableForVIDEO_STORE: aTable	(aTable createFieldNamed: 'ID' type: (platform int4)) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varchar: 20).</body></methods><methods><class-id>Glorp.GlorpVideoDescriptorSystem</class-id> <category>class models</category><body package="GlorpTestModels">classModelForGlorpVideoCreditStatus: aClassModel	aClassModel newAttributeNamed: #customer type: GlorpVideoCustomer.	aClassModel newAttributeNamed: #store type: GlorpVideoStore.	aClassModel newAttributeNamed: #balanceOwing type: Number.	aClassModel newAttributeNamed: #dateOwing type: Date.	aClassModel newAttributeNamed: #comments type: String.</body><body package="GlorpTestModels">classModelForGlorpVideoCustomer: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #dateOfBirth type: Date.	aClassModel newAttributeNamed: #onlinePurchases collectionOf: GlorpVideoPurchase.	aClassModel newAttributeNamed: #inStorePurchases collectionOf: GlorpVideoPurchase.	aClassModel newAttributeNamed: #inStoreRentals collectionOf: GlorpVideoRental.		aClassModel newAttributeNamed: #store type: GlorpVideoStore.	aClassModel newAttributeNamed: #creditStatus type: GlorpVideoCreditStatus.</body><body package="GlorpTestModels">classModelForGlorpVideoPurchase: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #title type: String.	aClassModel newAttributeNamed: #price type: Number.	aClassModel newAttributeNamed: #inStore type: Boolean.	aClassModel newAttributeNamed: #customer type: GlorpVideoCustomer.		aClassModel newAttributeNamed: #store type: GlorpVideoStore.</body><body package="GlorpTestModels">classModelForGlorpVideoRental: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #title type: String.	aClassModel newAttributeNamed: #price type: Number.	aClassModel newAttributeNamed: #dueDate type: Date.	aClassModel newAttributeNamed: #customer type: GlorpVideoCustomer.	aClassModel newAttributeNamed: #store type: GlorpVideoStore.</body><body package="GlorpTestModels">classModelForGlorpVideoStore: aClassModel	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #purchases collectionOf: GlorpVideoPurchase.	aClassModel newAttributeNamed: #customers collectionOf: GlorpVideoCustomer.</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">inStore	^inStore</body><body package="GlorpTestModels">inStore: anObject	inStore := anObject</body><body package="GlorpTestModels">price	^price</body><body package="GlorpTestModels">price: anObject	price := anObject</body><body package="GlorpTestModels">title	^title</body><body package="GlorpTestModels">title: aString	title := aString</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>comparing</category><body package="GlorpTestModels">&lt;= aVideoPurchase	^self title &lt;= aVideoPurchase title.</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>As yet unclassified</category><body package="GlorpTestModels">customer	^customer</body><body package="GlorpTestModels">customer: aCustomer	customer := aCustomer.</body><body package="GlorpTestModels">store: aGlorpVideoStore	store := aGlorpVideoStore.</body><body package="GlorpTestModels">videoStore	^store.</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self title.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize</body></methods><methods><class-id>Glorp.GlorpVideoPurchase</class-id> <category>testing</category><body package="GlorpTestModels">assertEqual: aPurchase	self assert: customer name = aPurchase customer name.	self assert: customer dateOfBirth = aPurchase customer dateOfBirth.	self assert: store id = aPurchase videoStore id.	self assert: id = aPurchase id.	self assert: title = aPurchase title.	self assert: (price * 1000) rounded = (aPurchase price * 1000) rounded.	self assert: inStore = aPurchase inStore.</body></methods><methods><class-id>Glorp.GlorpVideoPurchase class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id> <category>accessing</category><body package="GlorpTestModels">allTableNames	^#('GR_USER' 'GR_FOLDER' 'GR_MESSAGE').</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpUser;		add: GlorpFolder;		add: GlorpMessage;		yourself</body></methods><methods><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForGR_FOLDER: aTable 	| userId |	userId := aTable createFieldNamed: 'USER_ID' type: platform integer.	userId bePrimaryKey.	aTable addForeignKeyFrom: userId		to: ((self tableNamed: 'GR_USER') fieldNamed: 'ID').	(aTable createFieldNamed: 'NAME' type: (platform varChar: 50)) bePrimaryKey.</body><body package="GlorpTestModels">tableForGR_MESSAGE: aTable 	| userId folderName |	userId := aTable createFieldNamed: 'USER_ID' type: platform integer.	userId bePrimaryKey.	folderName := aTable createFieldNamed: 'FOLDER_NAME' type: (platform varChar: 50).	folderName bePrimaryKey.	aTable addForeignKeyFrom: userId		to: ((self tableNamed: 'GR_USER') fieldNamed: 'ID').	aTable addForeignKeyFrom: userId		to: ((self tableNamed: 'GR_FOLDER') fieldNamed: 'USER_ID')		from: folderName		to: ((self tableNamed: 'GR_FOLDER') fieldNamed: 'NAME').	(aTable createFieldNamed: 'SUBJECT' type: (platform varChar: 50)) bePrimaryKey.	aTable createFieldNamed: 'CONTENTS' type: (platform varChar: 100).</body><body package="GlorpTestModels">tableForGR_USER: aTable 	| |	(aTable createFieldNamed: 'ID' type: platform integer)		bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).</body></methods><methods><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels">example1	| user1 user2 folder1 folder1a folder2 message1 message2 message3 |	user1 := GlorpUser new id: 1; name: 'User One'.	user2 := GlorpUser new id: 2; name: 'User Two'.	folder1 := GlorpFolder new name: 'One'; user: user1.	user1 folders add: folder1.	folder1a := GlorpFolder new name: 'One-A'; user: user1.	user1 folders add: folder1a.	folder2 := GlorpFolder new name: 'Two'; user: user2.	user2 folders add: folder2.		message1 := GlorpMessage new subject: 'goes in folder 1'; user: user1; folder: folder1.	folder1 messages add: message1.	message2 := GlorpMessage new subject: 'also goes in folder 1'; user: user1; folder: folder1.	folder1 messages add: message2.	message3 := GlorpMessage new subject: 'goes in folder 2'; user: user2; folder: folder2.	folder2 messages add: message3.	^Array with: user1 with: user2.</body></methods><methods><class-id>Glorp.GlorpCompositeKeyDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForGlorpFolder: aDescriptor	| table userMapping messageMapping |	table := self tableNamed: 'GR_FOLDER'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	userMapping := OneToOneMapping new		attributeName: #user;		referenceClass: GlorpUser."		join: (Join from: (table fieldNamed: 'USER_ID') to: (userTable fieldNamed: 'ID'))."	aDescriptor addMapping: userMapping.	messageMapping := OneToManyMapping new		attributeName: #messages;		referenceClass: GlorpMessage."		join: (Join 			from: (table fieldNamed: 'USER_ID')			to: (messageTable fieldNamed: 'USER_ID') 				from: (table fieldNamed: 'NAME')			to: (messageTable fieldNamed: 'FOLDER_NAME'))."	messageMapping beExclusive.	aDescriptor addMapping: messageMapping.</body><body package="GlorpTestModels">descriptorForGlorpMessage: aDescriptor	| table userMapping folderMapping |	table := self tableNamed: 'GR_MESSAGE'.	aDescriptor table: table.	self tableNamed: 'GR_USER'.	self tableNamed: 'GR_FOLDER'.	aDescriptor addMapping: (DirectMapping from: #subject to: (table fieldNamed: 'SUBJECT')).	aDescriptor addMapping: (DirectMapping from: #contents to: (table fieldNamed: 'CONTENTS')).	userMapping := OneToOneMapping new		attributeName: #user;		referenceClass: GlorpUser."		mappingCriteria: (Join from: (table fieldNamed: 'USER_ID') to: (userTable fieldNamed: 'ID'))."	aDescriptor addMapping: userMapping.	folderMapping := OneToOneMapping new		attributeName: #folder;		referenceClass: GlorpFolder.	"Let it figure this out for itself""		mappingCriteria: (Join 			from: (table fieldNamed: 'USER_ID')			to: (userTable fieldNamed: 'ID') 				from: (table fieldNamed: 'NAME')			to: (folderTable fieldNamed: 'FOLDER_NAME'))."	aDescriptor addMapping: folderMapping.</body><body package="GlorpTestModels">descriptorForGlorpUser: aDescriptor	| table folderMapping |	table := self tableNamed: 'GR_USER'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	folderMapping := OneToManyMapping new		attributeName: #folders;		referenceClass: GlorpFolder."		mappingCriteria: 						(Join								from: (table fieldNamed: 'ID')								to: (folderTable fieldNamed: 'USER_ID'))."	folderMapping beExclusive.	aDescriptor addMapping: folderMapping.</body></methods><methods><class-id>Glorp.GlorpWorkerDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels">exampleJobRow: anInteger finished: aBoolean	| table row |	table := self tableNamed: 'GLORP_JOB'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: anInteger.	row at: (table fieldNamed: 'DESCRIPTION') put: 'Job ', anInteger printString.	row at: (table fieldNamed: 'FINISHED') put: (aBoolean ifTrue: ['Y'] ifFalse: ['N']).	row at: (table fieldNamed: 'OWNER_ID') put: 1234.	^row.</body><body package="GlorpTestModels">exampleLinkRow1	| table row |	table := self tableNamed: 'GLORP_WORKER_JOB_LINK'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'WORKER_ID') put: 1234.	row at: (table fieldNamed: 'JOB_ID') put: 2.	row at: (table fieldNamed: 'PRIORITY') put: 'N'.	^row.</body><body package="GlorpTestModels">exampleLinkRow2	| table row |	table := self tableNamed: 'GLORP_WORKER_JOB_LINK'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'WORKER_ID') put: 1234.	row at: (table fieldNamed: 'JOB_ID') put: 3.	row at: (table fieldNamed: 'PRIORITY') put: 'Y'.	^row.</body><body package="GlorpTestModels">exampleWorkerRow	| table row |	table := self tableNamed: 'GLORP_WORKER'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: 1234.	row at: (table fieldNamed: 'NAME') put: 'John Worker'.	^row.</body></methods><methods><class-id>Glorp.GlorpWorkerDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels">allTableNames	^#('GLORP_WORKER' 'GLORP_JOB' 'GLORP_WORKER_JOB_LINK').</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpJob;		add: GlorpWorker;		yourself</body></methods><methods><class-id>Glorp.GlorpWorkerDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForGLORP_JOB: aTable	| ownerId |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'DESCRIPTION' type: (platform varChar: 40).	aTable createFieldNamed: 'FINISHED' type: (platform varChar: 1).	ownerId := aTable createFieldNamed: 'OWNER_ID' type: platform int4.	aTable addForeignKeyFrom: ownerId		to: ((self tableNamed: 'GLORP_WORKER') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForGLORP_WORKER: aTable	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).</body><body package="GlorpTestModels">tableForGLORP_WORKER_JOB_LINK: aTable	| workerId jobId |	workerId := aTable createFieldNamed: 'WORKER_ID' type: platform int4.	aTable addForeignKeyFrom: workerId		to: ((self tableNamed: 'GLORP_WORKER') fieldNamed: 'ID').	jobId := aTable createFieldNamed: 'JOB_ID' type: platform int4.	aTable addForeignKeyFrom: jobId		to: ((self tableNamed: 'GLORP_JOB') fieldNamed: 'ID').	aTable createFieldNamed: 'PRIORITY' type: (platform varChar: 1).</body></methods><methods><class-id>Glorp.GlorpWorkerDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForGlorpJob: aDescriptor 	"Note that the job table contains a FINISHED field, but the GlorpJob object doesn't. This field is determined only by membership in the finished or pending collections. In this particular case it's not very useful from a domain perspective, but it's interesting to be able to map. Similarly, whether a job is priority or not is not in the domain object, and is stored in the link table defining the relationship"	| table |	table := self tableNamed: 'GLORP_JOB'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id				to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #description				to: (table fieldNamed: 'DESCRIPTION')).</body><body package="GlorpTestModels">descriptorForGlorpWorker: aDescriptor 	| table linkTable |	table := self tableNamed: 'GLORP_WORKER'.	aDescriptor table: table.	aDescriptor 		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor 		addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: ((OneToManyMapping new)				attributeName: #pendingJobs;				referenceClass: GlorpJob;				join: (self workerCriteriaWithConstant: 'N' in: table)).	aDescriptor addMapping: ((OneToManyMapping new)				attributeName: #finishedJobs;				referenceClass: GlorpJob;				join: (self workerCriteriaWithConstant: 'Y' in: table)).	linkTable := self tableNamed: 'GLORP_WORKER_JOB_LINK'.	"Note that priorityJobs may include finished jobs as well, and instances may occur in both this collection and the other two"	aDescriptor addMapping: ((ManyToManyMapping new)				attributeName: #priorityJobs;				referenceClass: GlorpJob;				join: (Join 							from: (table fieldNamed: 'ID')							to: (linkTable fieldNamed: 'WORKER_ID')							from: 'Y'							to: (linkTable fieldNamed: 'PRIORITY'))).</body><body package="GlorpTestModels">workerCriteriaWithConstant: aString in: table 	^Join 		from: (table fieldNamed: 'ID')		to: ((self tableNamed: 'GLORP_JOB') fieldNamed: 'OWNER_ID')		from: aString		to: ((self tableNamed: 'GLORP_JOB') fieldNamed: 'FINISHED').</body></methods><methods><class-id>Glorp.GlorpExpressionJoiningTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	source := BaseExpression new.	target := source get: #relation.	base := BaseExpression new.</body><body package="GlorpTests">tearDown	source := nil.	target := nil.	base := nil.	system := nil.</body></methods><methods><class-id>Glorp.GlorpExpressionJoiningTest</class-id> <category>tests</category><body package="GlorpTests">join: exp 	^exp asExpressionJoiningSource: source toTarget: target</body><body package="GlorpTests">resultOfJoiningFieldFor: aTable toExpressionBuiltOn: anotherTable	| exp table |	base descriptor: (system descriptorFor: GlorpCustomer).	exp := FieldExpression forField: (aTable fieldNamed: 'ID')				basedOn: BaseExpression new.	table := base getTable: anotherTable.	^exp asExpressionJoiningSource: base toTarget: table.</body><body package="GlorpTests">testBase	| result |	result := self join: base. 	self assert: result == source.</body><body package="GlorpTests">testConstant	| exp |	exp := ConstantExpression for: 42.	self assert: (self join: exp) == exp</body><body package="GlorpTests">testField	| exp  result |	exp := FieldExpression forField: (DatabaseField named: 'test' type: system platform int4)				basedOn: base.	result := self join: exp.	self assert: result base == source.	self assert: result field == exp field</body><body package="GlorpTests">testFieldBuiltOnDifferentTable	| result custTable |	custTable := system tableNamed: 'GR_CUSTOMER'.	result := self 		resultOfJoiningFieldFor: custTable		toExpressionBuiltOn: custTable.	self assert: result base == (base getTable: custTable).	self assert: result field == ((system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').</body><body package="GlorpTests">testFieldBuiltOnSameTable	| exp result base2 table custTable |	custTable := system tableNamed: 'GR_CUSTOMER'.	base2 := BaseExpression new.	base2 descriptor: (system descriptorFor: GlorpCustomer).	table := base2 getTable: custTable.	exp := FieldExpression forField: (custTable fieldNamed: 'ID')				basedOn: base.	result := exp asExpressionJoiningSource: base2 toTarget: table.	self assert: result base == table.	self assert: result field == exp field.</body><body package="GlorpTests">testMapping	| result exp |	exp := base get: #foo.	result := self join: exp. 	self assert: result base == source.	self assert: result name = #foo.</body><body package="GlorpTests">testParameter	| result exp table field |	table := DatabaseTable named: 'T'.		field := DatabaseField named: 'F' type: system platform int4.	table addField: field.	exp := base getParameter: field.	result := self join: exp.	self assert: result base == source.	self assert: result class == FieldExpression.	self assert: result field == field.</body><body package="GlorpTests">testRelation	| result exp |	exp := [:a | a foo = 3] asGlorpExpressionOn: base.	result := self join: exp. 	self assert: result class == RelationExpression.	self assert: result rightChild == exp rightChild.	self assert: result leftChild base == source.</body><body package="GlorpTests">testRelation2	| result exp field | 	field := DatabaseField named: 'fred' type: system platform int4.	exp := [:a | a foo = field] asGlorpExpressionOn: base.	result := self join: exp. 	self assert: result class == RelationExpression.	self assert: result rightChild class == FieldExpression.	self assert: result rightChild field == field.	self assert: result leftChild base == source.</body><body package="GlorpTests">testSelfJoinWithPrimaryKeyExpression	"This tests a join of a class to itself, in this case customers who have other customers associated with them. Useful for hierarchies"	| pkExpression field result |	field := (system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID'.	pkExpression := Join 		from: field		to: field.	result := self join: pkExpression.	self assert: result leftChild basicField == field.	self assert: result rightChild basicField == field.	self assert: result rightChild base name = #relation.</body><body package="GlorpTests">testTable	| result exp table |	table := DatabaseTable named: 'T'.	exp := base getTable: table.	result := self join: exp. 	self assert: result base == target.	self assert: result table == table.</body></methods><methods><class-id>Glorp.GlorpTaskedWorker</class-id> <category>accessing</category><body package="GlorpTestModels">isSimilarToWorker: aWorker	"Compare values, ignoring #ids, which are assigned by the database."	| myKeys otherKeys myTask otherTask |	myKeys := self tasks keys asSortedCollection.	otherKeys := aWorker tasks keys asSortedCollection.	myKeys = otherKeys ifFalse: [^false].	myKeys do: [:aKey|		myTask := self tasks at: aKey.		otherTask := aWorker tasks at: aKey.		myTask description = otherTask description ifFalse: [^false]].	^true</body><body package="GlorpTestModels">tasks	^tasks</body><body package="GlorpTestModels">tasks: anObject	tasks := anObject</body></methods><methods><class-id>Glorp.GlorpTaskedWorker</class-id> <category>actions</category><body package="GlorpTestModels">addTask: aTask key: aString	tasks at: aString put: aTask</body><body package="GlorpTestModels">removeTaskAtKey: aString	tasks removeKey: aString ifAbsent: [self error: 'Task not found.']</body></methods><methods><class-id>Glorp.GlorpTaskedWorker</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: id printString;		nextPutAll: ', ';		nextPutAll: (name ifNil: [name printString]);		nextPut: $);		cr</body></methods><methods><class-id>Glorp.GlorpTaskedWorker</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	tasks := Dictionary new.</body></methods><methods><class-id>Glorp.GlorpTaskedWorker</class-id> <category>comparing</category><body package="GlorpTestModels">= aWorker	super = aWorker ifFalse: [^false].	(tasks keys asSortedCollection = aWorker tasks keys asSortedCollection) ifFalse: [^false].	(tasks asSortedCollection = aWorker tasks asSortedCollection) ifFalse: [^false].	^true</body></methods><methods><class-id>Glorp.GlorpTaskedWorker class</class-id> <category>examples</category><body package="GlorpTestModels">example1	"GlorpTaskedWorker example1"	| workers tasks keys names |	tasks := GlorpWorkerTask exampleTasks.	keys := GlorpWorkerTask exampleTaskKeys.	names := #('Jim' 'Tom' 'Lori' 'George' 'Jenny').	workers := OrderedCollection new.	1 to: 5 do: [:i|		workers add: ((GlorpTaskedWorker new)				id: i;				name: (names at: i);				addTask: (tasks at: i) key: (keys at: i);				yourself)].	^workers</body></methods><methods><class-id>Glorp.GlorpTaskedWorker class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpTableTest</class-id> <category>tests</category><body package="GlorpTests">testBasicSequencing	| row |	row := DatabaseRow newForTable: (system tableNamed: 'STUFF').	row preWriteAssignSequencesUsing: nil.	row postWriteAssignSequencesUsing: nil.	self assert: (row at: ((system tableNamed: 'STUFF') fieldNamed: 'ID')) = 1.</body><body package="GlorpTests">testCircularFieldRefs	| field table1 table2 |	table1 := DatabaseTable named: 'BAR'.	field := table1 createFieldNamed: 'FOO' type: dbPlatform int4.	table2 := DatabaseTable named: 'BLETCH'.	table1 addForeignKeyFrom: field to: (table2 createFieldNamed: 'FLIRP' type: dbPlatform int4).	self assert: (table2 fieldNamed: 'FLIRP') = table1 foreignKeyConstraints first targetFields first.</body><body package="GlorpTests">testConstraintCreation	| constraint dropWord |	constraint := ForeignKeyConstraint		sourceField: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE')		targetField: ((system tableNamed: 'PERSON') fieldNamed: 'ID').	self assert: constraint creationString =		( 'CONSTRAINT ', constraint name, ' FOREIGN KEY (BANK_CODE) REFERENCES PERSON (ID)').	dropWord := self keywordForConstraintsWhenDropping: constraint onPlatform: dbPlatform.		dbPlatform supportsConstraints ifTrue:		[self assert: constraint dropString =			( 'ALTER TABLE BANK_ACCT DROP ', dropWord, ' ', constraint name)].	constraint := ForeignKeyConstraint		sourceField: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE')		targetField: ((system tableNamed: 'PERSON') fieldNamed: 'ID')		suffixExpression: 'ON DELETE CASCADE'.	self assert: constraint creationString = ('CONSTRAINT ', constraint name, ' FOREIGN KEY (BANK_CODE) REFERENCES PERSON (ID) ON DELETE CASCADE').	dbPlatform supportsConstraints ifTrue:		[self assert: constraint dropString = ('ALTER TABLE BANK_ACCT DROP ', dropWord, ' ',  constraint name)].</body><body package="GlorpTests">testConstraintNonCreation	| constraint |	constraint := ForeignKeyConstraint 		sourceField: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE')		targetField: ((system tableNamed: 'PERSON') fieldNamed: 'ID').	constraint shouldCreateInDatabase: false.	self assert: constraint creationString = ''.	self assert: constraint dropString = ''.</body><body package="GlorpTests">testFieldTable	| field table |	field := DatabaseField named: 'FOO' type: dbPlatform int4.	table := DatabaseTable named: 'BAR'.	table addField: field.	self assert: (table fieldNamed: 'FOO') = field.</body><body package="GlorpTests">testForeignKeyFieldAPI	"SQLite does not support foreign keys but it will parse them;  this test passes on SQLite."	| table1 table2 fieldCustAddr fieldAddrId constraint |	table1 := DatabaseTable named: 'Customer'.	(table1 createFieldNamed: 'ID' type: dbPlatform int4) bePrimaryKey.	fieldCustAddr := table1 createFieldNamed: 'ADDRESS' type: dbPlatform int4.	table2 := DatabaseTable named: 'Address'.	fieldAddrId := (table2 createFieldNamed: 'ID' type: dbPlatform int4) bePrimaryKey.	table2 createFieldNamed: 'Street' type: dbPlatform varChar.	constraint := table1 addForeignKeyFrom: fieldCustAddr toTable: table2.	self assert: (table2 fieldNamed: 'ID') = table1 foreignKeyConstraints first targetFields first.	self assert: constraint name =  'Customer_A_TO_Address_ID_REF1'.	table1 := DatabaseTable named: 'Customer'.	(table1 createFieldNamed: 'ID' type: dbPlatform int4) bePrimaryKey.	fieldCustAddr := table1 createFieldNamed: 'ADDRESS' type: dbPlatform int4.	table2 := DatabaseTable named: 'Address'.	fieldAddrId := (table2 createFieldNamed: 'ID' type: dbPlatform int4) bePrimaryKey.	table2 createFieldNamed: 'Street' type: dbPlatform varChar.	table1 addForeignKeyFrom: fieldCustAddr to: fieldAddrId.	self assert: (table2 fieldNamed: 'ID') = table1 foreignKeyConstraints first targetFields first.</body><body package="GlorpTests">testPrimaryKeyFields	| pkFields table |	table := system tableNamed: 'BANK_TRANS'.	pkFields := table primaryKeyFields.	self assert: pkFields size = 1.	self assert: (pkFields at: 1) == (table fieldNamed: 'ID').</body><body package="GlorpTests">testPrimaryKeyFields2	| table field |	table := DatabaseTable new.	field := (DatabaseField named: 'FRED' type: (dbPlatform varChar: 10))		bePrimaryKey.	table addField: field.	self assert: table primaryKeyFields size = 1.	self assert: (table primaryKeyFields at: 1) == field.</body><body package="GlorpTests">testPrimaryKeyFieldsNoPK	| pkFields table |	table := system tableNamed: 'CUSTOMER_ACCT_LINK'.	pkFields := table primaryKeyFields.	self assert: pkFields size = 0.</body><body package="GlorpTests">testPrintingWithParent	| t t1 |	t := system tableNamed: 'GR_CUSTOMER'.	t1 := t copy.	t1 parent: t.	t1 name: 'foo'.	self assert: t1 sqlTableName = 'GR_CUSTOMER foo'.</body><body package="GlorpTests">testPrintingWithoutParent	| t t1 |	t := system tableNamed: 'GR_CUSTOMER'.	self assert: t sqlTableName = 'GR_CUSTOMER'.</body><body package="GlorpTests">testRowCreation	| row |	row := system examplePersonRow1.	self assert: (row at: (row table fieldNamed: 'ID')) = 3.</body><body package="GlorpTests">testTwoSequences	| row1 row2 table idField |	table := system tableNamed: 'STUFF'.	row1 := DatabaseRow newForTable: table.	row2 := DatabaseRow newForTable: table.	row1 preWriteAssignSequencesUsing: nil.	row1 postWriteAssignSequencesUsing: nil.	row2 preWriteAssignSequencesUsing: nil.	row2 postWriteAssignSequencesUsing: nil.	idField := table fieldNamed: 'ID'.	self assert: (row1 at: idField) = 1.	self assert: (row2 at: idField) = 2.</body></methods><methods><class-id>Glorp.GlorpTableTest</class-id> <category>support</category><body package="GlorpTests">keywordForConstraintsWhenDropping: aConstraint onPlatform: aDatabasePlatform	"This method returns the term to test against independently of #writeConstraintToDrop:onStream:.  The logic is that ANSI uses 'DROP CONSTRAINT but MySQL uses		'DROP PRIMARY KEY' for primary key constraints (and then says don't name the constraint name in the drop statement!)		'DROP FOREIGN KEY'  for foreign key constraints		'DROP KEY' for unique constraints (it also supports DROP INDEX for this)"	(aDatabasePlatform isKindOf: MySQLPlatform) ifFalse: [^'CONSTRAINT'].	aConstraint isForeignKeyConstraint ifTrue: [^'FOREIGN KEY'].	aConstraint isPrimaryKeyConstraint ifTrue: [^'PRIMARY KEY'].	^'KEY'</body><body package="GlorpTests">setUp	super setUp.	descriptors := system allDescriptors.	dbPlatform := system platform.	GlorpInMemorySequenceDatabaseType reset</body></methods><methods><class-id>Glorp.GlorpPrimaryKeyExpressionWithConstantTest</class-id> <category>tests</category><body package="GlorpTests">testAsExpressionCompound		| e personTable |	personTable := system tableNamed: 'PERSON'.	e := compoundExpression asGeneralGlorpExpression.	self assert: (e rightChild isKindOf: RelationExpression).	self assert: (e rightChild relation == #=).	self assert: (e rightChild leftChild isKindOf: FieldExpression).	self assert: e rightChild leftChild field == (personTable fieldNamed: 'ADDRESS_ID').	self assert: (e rightChild rightChild isKindOf: ConstantExpression).	self assert: e rightChild rightChild value = 'B'.</body><body package="GlorpTests">testAsExpressionSingle		| e field param |	e := expression asGeneralGlorpExpression.	self assert: (e isKindOf: RelationExpression).	self assert: e relation == #=.	field := e leftChild.	self assert: (field isKindOf: FieldExpression).	self assert: field field == ((system tableNamed: 'CUSTOMER_ACCT_LINK') fieldNamed: 'ACCT_ID').	param := e rightChild.	self assert: (param isKindOf: ConstantExpression).	self assert: param value = 7.</body><body package="GlorpTests">testCompoundSQLPrinting	| stream params|	stream := WriteStream on: (String new: 100).	params := Dictionary new.	params at: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID') put: 1.	compoundExpression printSQLOn: stream withParameters: params.	self assert: stream contents = 'PERSON.NAME = 1 AND PERSON.ADDRESS_ID = ''B'''.</body><body package="GlorpTests">testParameterCount	self assert: expression numberOfParameters = 1.	self assert: compoundExpression numberOfParameters = 2.</body><body package="GlorpTests">testSQLPrinting	| stream params |	stream := WriteStream on: (String new: 100).	params := Dictionary new.	expression printSQLOn: stream withParameters: params.	self assert: stream contents = 'CUSTOMER_ACCT_LINK.ACCT_ID = 7'</body></methods><methods><class-id>Glorp.GlorpPrimaryKeyExpressionWithConstantTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	expression := Join 		from: 7		to: ((system tableNamed: 'CUSTOMER_ACCT_LINK') fieldNamed: 'ACCT_ID').	compoundExpression := Join		from: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID')		to: ((system tableNamed: 'PERSON') fieldNamed: 'NAME').	compoundExpression		addSource: 'B'		target: ((system tableNamed: 'PERSON') fieldNamed: 'ADDRESS_ID').</body></methods><methods><class-id>Glorp.GlorpCommitOrderTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	platform := system platform.	t1 := DatabaseTable new name: 'T1'.	t1id := (t1 createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	t2 := DatabaseTable new name: 'T2'.	t2id := (t2 createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	t3 := DatabaseTable new name: 'T3'.	t3id := (t3 createFieldNamed: 'ID' type: platform int4) bePrimaryKey.</body></methods><methods><class-id>Glorp.GlorpCommitOrderTest</class-id> <category>tests</category><body package="GlorpTests">testCommitOrder	| sorter |	sorter := TableSorter for: (Array with: (system tableNamed: 'BANK_TRANS') with: (system tableNamed: 'GR_CUSTOMER')).	self assert: sorter sort first name = 'GR_CUSTOMER'.</body><body package="GlorpTests">testCommitOrder2	"Test for a cycle between t1 and t2 with t3 also pointing to both. Order of t1, t2 is indeterminate, but t3 should be last"	| table1 table1id table2 table2id t2fk t3fk t3fk2 sorter t1fk |	table1 := DatabaseTable new name: 'T1'.	table1id := (table1 createFieldNamed: 'ID' type: platform inMemorySequence) bePrimaryKey.	table2 := DatabaseTable new name: 'T2'.	table2id := (table2 createFieldNamed: 'ID' type: platform inMemorySequence) bePrimaryKey.	t1fk := table1 createFieldNamed: 'T2_ID' type: platform int4.	table1 addForeignKeyFrom: t1fk to: table2id.	t2fk := table2 createFieldNamed: 'T1_ID' type: platform int4.	table2 addForeignKeyFrom: t2fk to: table1id.	t3 := DatabaseTable new name: 'T3'.	t3fk := t3 createFieldNamed: 'T2_ID' type: platform int4.	t3 addForeignKeyFrom: t3fk to: table2id.	t3fk2 := t3 createFieldNamed: 'T1_ID' type: platform int4.	t3 addForeignKeyFrom: t3fk2 to: table1id.	sorter := TableSorter for: (Array with: t3 with: table2 with: table1).	self assert: sorter sort last name = 'T3'.</body><body package="GlorpTests">testCommitOrderNonSequencedFieldsDontCount	"Test for a cycle between t1 and t2 with t3 also pointing to both, but with nothing sequenced. Order should be completely indeterminate. We rely on the topological sort being predictable and depending on the insert order so that if we feed objects with no dependencies in in different orders we should get different results."	| t1fk t2fk t3fk t3fk2 sorter sorter2 |	t1fk := t1 createFieldNamed: 'T2_ID' type: platform int4.	t1 addForeignKeyFrom: t1fk to: (t2id).	t2fk := t2 createFieldNamed: 'T1_ID' type: platform int4.	t2 addForeignKeyFrom: t2fk to: (t1id).	t3 := DatabaseTable new name: 'T3'.	t3fk := t3 createFieldNamed: 'T2_ID' type: platform int4.	t3 addForeignKeyFrom: t3fk to: (t2id).	t3fk2 := t3 createFieldNamed: 'T1_ID' type: platform int4.	t3 addForeignKeyFrom: t3fk2 to: (t1id).	sorter := TableSorter for: (Array with: t3 with: t2 with: t1).	sorter2 := TableSorter for: (Array with: t1 with: t2 with: t3).	self assert: sorter sort first ~= sorter2 sort first.</body></methods><methods><class-id>Glorp.GlorpInventoryItem</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpInventoryItem</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: id printString.	aStream nextPut: $,.	aStream nextPutAll: name printString.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpExpressionTableAliasingTest</class-id> <category>tests</category><body package="GlorpTests">testBase	exp := BaseExpression new.	exp descriptor: (system descriptorFor: GlorpCustomer).	self helpTestBasicAliasing: (system tableNamed: 'GR_CUSTOMER').</body><body package="GlorpTests">testMapping	| base |	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	exp := base get: 'transactions'.	self helpTestBasicAliasing: (system tableNamed: 'BANK_TRANS').</body><body package="GlorpTests">testTable	| base transTable |	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	transTable := system tableNamed: 'BANK_TRANS'.	exp := base getTable: transTable.	self helpTestBasicAliasing: transTable</body><body package="GlorpTests">testTableSameAsBase	| base custTable |	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	custTable := system tableNamed: 'GR_CUSTOMER'.	exp := base getTable: custTable.	self deny: exp hasTableAliases.	exp assignTableAliasesStartingAt: 1 prefix: ''.	base assignTableAliasesStartingAt: 42 prefix: nil.	self deny: exp hasTableAliases.	self assert: (exp aliasedTableFor: custTable) name = 't42'.</body></methods><methods><class-id>Glorp.GlorpExpressionTableAliasingTest</class-id> <category>support</category><body package="GlorpTests">helpTestBasicAliasing: aTable	self deny: exp hasTableAliases.	exp assignTableAliasesStartingAt: 1 prefix: 's1t'.	self assert: exp hasTableAliases.	self assert: exp tableAliases size = 1.	self assert: (exp tableAliases at: aTable) name = 's1t1'.</body></methods><methods><class-id>Glorp.ClassB</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassB	^attrAClassB</body><body package="GlorpTestModels">attrAClassB: anObject	attrAClassB := anObject</body><body package="GlorpTestModels">attrBClassB	^attrBClassB</body><body package="GlorpTestModels">attrBClassB: anObject	attrBClassB := anObject</body><body package="GlorpTestModels">attrCClassB	^attrCClassB</body><body package="GlorpTestModels">attrCClassB: anObject	attrCClassB := anObject</body><body package="GlorpTestModels">attrDClassB	^attrDClassB</body><body package="GlorpTestModels">attrDClassB: anObject	attrDClassB := anObject</body></methods><methods><class-id>Glorp.ClassB</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassB := nil.	attrBClassB := nil.	attrCClassB := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.ClassB class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpDescriptorTest</class-id> <category>tests</category><body package="GlorpTests">testAllClassesAndNames	| identity1 identity2 identity3 |	system flushAllClasses.	identity1 := system allClasses.	identity2 := system allClasses.	system flushAllClasses.	identity3 := system allClasses.	self assert: identity1 == identity2.	self assert: identity1 ~~ identity3.	self should: [system allClassNames] raise: Dialect error.</body><body package="GlorpTests">testAllMappingsForField	| descriptor mappings |	descriptor := system descriptorFor: GlorpCustomer.	mappings := descriptor 				allMappingsForField: ((system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	self assert: mappings first attributeName = #id</body><body package="GlorpTests">testBuildBankTransactionAndDependentsFromRow	| transactionDescriptor object row moneyDescriptor money1 table translations session builder |	session := GlorpMockSession new.	session system: system.	transactionDescriptor := system descriptorFor: GlorpBankTransaction.	object := GlorpBankTransaction new.	row := #(99 nil 'CDN' 98 'service charge' 'USD' 97).	builder := ObjectBuilder new.	builder row: row.	transactionDescriptor populateObject: object inBuilder: builder.	self assert: object id = 99.	moneyDescriptor := system descriptorFor: GlorpMoney.	money1 := GlorpMoney new.	table := system tableNamed: 'MONEY_IMAGINARY_TABLE'.	translations := IdentityDictionary new.	translations at: (table fieldNamed: 'CURRENCY') put: 3.	translations at: (table fieldNamed: 'AMOUNT') put: 4.	builder := ElementBuilder new fieldTranslations: translations; row: row.	moneyDescriptor		populateObject: money1		inBuilder: builder.	self assert: money1 amount = 98.	self assert: money1 currency = #CDN.</body><body package="GlorpTests">testBuildPersonFromRow	| descriptor object address session builder |	session := GlorpMockSession new.	session system: system.	address := GlorpAddress new.	session cacheAt: 127 put: address.	descriptor := system descriptorFor: GlorpPerson.	system tableNamed: 'PERSON'.	object := GlorpPerson new.	builder := ObjectBuilder new.	builder row: #(456 'Ralph' 127).	descriptor populateObject: object inBuilder: builder.	self assert: object class = GlorpPerson.	self assert: object id = 456.	self assert: object name = 'Ralph'.	self assert: object address getValue == address.</body><body package="GlorpTests">testClassLookup	self assert: (Dialect smalltalkAt: 'Object') == Object.	Dialect isVWWithNameSpaces ifTrue: [		"Sneaky meta-tricks to avoid things that won't compile in non-VW dialects"		self assert: (Dialect smalltalkAt: 'GlorpTestNamespace.GlorpTestClassInNamespace') == (Compiler evaluate: 'GlorpTestNamespace.GlorpTestClassInNamespace').		self assert: (Dialect smalltalkAt: 'GlorpTestNamespace.GlorpTestClassInNamespace') notNil].</body><body package="GlorpTests">testDescriptorIdentity	| descriptor |	descriptor := system descriptorFor: GlorpCustomer.	self assert: descriptor == (system descriptorFor: GlorpCustomer).</body><body package="GlorpTests">testDescriptorWithNamespace	| descriptor testCaseClass |	Dialect isVWWithNameSpaces ifFalse: [^self].	system := GlorpDescriptorSystemWithNamespaces new.	testCaseClass := 'GlorpTestNamespace.GlorpTestClassInNamespace' asQualifiedReference value.	descriptor := system descriptorFor: testCaseClass.	self assert: descriptor describedClass == testCaseClass.</body><body package="GlorpTests">testMappedFields	| descriptor |	descriptor := system descriptorFor: GlorpBankTransaction.	self assert: (descriptor mappedFields) = (descriptor table fields).</body><body package="GlorpTests">testMappingForField	| descriptor mapping |	descriptor := system descriptorFor: GlorpCustomer.	mapping := descriptor 				directMappingForField: ((system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	self assert: mapping attributeName = #id</body><body package="GlorpTests">testPrimaryKeyExpressionFor	| descriptor trans exp |	descriptor := system descriptorFor: GlorpBankTransaction.	trans := GlorpBankTransaction new.	trans id: 42.	exp := descriptor		primaryKeyExpressionFor: trans		basedOn: BaseExpression new		relation: #=.	self assert: exp relation = #=.	self assert: exp rightChild value = 42.</body><body package="GlorpTests">testPrimaryKeyExpressionForFailing	| descriptor trans |	descriptor := system descriptorFor: GlorpBankTransaction.	trans := GlorpCustomer new.	self		should:			[descriptor				primaryKeyExpressionFor: trans				basedOn: BaseExpression new				relation: #=]		raise: self errorSignal.</body><body package="GlorpTests">testPrimaryKeyExpressionForWithCompositeKey	self unfinished.</body></methods><methods><class-id>Glorp.GlorpDescriptorTest</class-id> <category>support</category><body package="GlorpTests">errorSignal	^Dialect error.</body></methods><methods><class-id>Glorp.GlorpTravelAgency</class-id> <category>comparing</category><body package="GlorpTestModels">= aGlorpTravelAgency	^self name = aGlorpTravelAgency name.</body></methods><methods><class-id>Glorp.GlorpTravelAgency</class-id> <category>accessing</category><body package="GlorpTestModels">agents	^agents</body><body package="GlorpTestModels">agents: anObject	agents := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests</class-id> <category>accessing</category><body package="GlorpDBTypeTests">platform	^connection platform</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests</class-id> <category>setUp</category><body package="GlorpDBTypeTests">createTypeTestTable	| system |	connection doDDLOperation: [		connection			dropTableNamed: self tableName			ifAbsent: [:ex | ex return: nil].		table := DatabaseTable named: self tableName.		table			createFieldNamed: 'test'			type: type.		(table createFieldNamed: 'id' type: session system platform inMemorySequence) bePrimaryKey.		connection			createTable: table			ifError:				[:ex | 				Transcript show: 'CANNOT CREATE TABLE'.             		self signalFailure: ex messageText.				ex return: nil].	].	system := self systemFor: table.	session system: system.	^table.</body><body package="GlorpDBTypeTests">defaultDatabaseType	self subclassResponsibility.</body><body package="GlorpDBTypeTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	connection := session accessor.	type := self defaultDatabaseType.	table := self createTypeTestTable.</body><body package="GlorpDBTypeTests">systemFor: aTable	| system descriptor mapping model |	system := DynamicDescriptorSystem new.	model := system addClassModelFor: GlorpTypeTestsModelClass.	model newAttributeNamed: #id.	model newAttributeNamed: #test type: stType.	system privateTableAt: aTable name put: aTable.	descriptor := Descriptor new.	descriptor system: system.	descriptor classModel: model.	descriptor table: aTable.	descriptor		addMapping: (DirectMapping from: #id to: (aTable fieldNamed: 'id')).	stType isNil		ifTrue:			[mapping := DirectMapping from: #test to: (aTable fieldNamed: 'test')]		ifFalse:			[mapping := DirectMapping				from: #test				type: stType				to: (aTable fieldNamed: 'test')].	descriptor addMapping: mapping.	system privateDescriptorAt: GlorpTypeTestsModelClass put: descriptor.	^system.</body><body package="GlorpDBTypeTests">tableName	"Oracle's table, column and constraint name limit is 30.  Since our constraint names append _PK, _UNQ to tablename, make the prefix five chars shorten and limit the whole to 25 or so."	^connection platform isOraclePlatform		ifTrue: ['TYPT' , self selector , self class name first: 25]		ifFalse: ['TYPETESTS' , self selector , self class name]</body><body package="GlorpDBTypeTests">tearDown	super tearDown.	session doDDLOperation: [		connection			dropTableNamed: self tableName			ifAbsent: [:ex | ex return: nil]].	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests</class-id> <category>initializing</category><body package="GlorpDBTypeTests">initialize</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests</class-id> <category>helpers</category><body package="GlorpDBTypeTests">compareFloatInModel: read with: original	read isNil ifTrue: [^false].	read test = original ifTrue: [^true].	read test isNil ifTrue: [^false].	^(read test - original) abs &lt;= 0.00001.</body><body package="GlorpDBTypeTests">helpTestExplicitReadBackFor: dbOutValue	"Read back the row with the given value, using an explicit where clause."	| queryStream result |	queryStream := SQLStringSelectCommand sqlString: String new parameters: #() useBinding: false session: session.	queryStream nextPutAll: 'SELECT test,id FROM ', self tableName, ' WHERE test '.	queryStream nextPutAll: (dbOutValue isNil ifTrue: [' IS '] ifFalse: [' = ']).	type print: dbOutValue on: queryStream.	result := connection executeSQLString: queryStream contents.	result isEmpty ifTrue: [^nil].	^(result atIndex: 1) atIndex: 1.</body><body package="GlorpDBTypeTests">helpTestFloat: anObject	"Don't try and read back an equal float, it'll likely fail on precision issues"	self		helpTestValue: anObject		compareModelWith:			[:read :original | self compareFloatInModel: read with: original]		compareWith:			[:read :original | original isNil or: [(read - original) abs &lt;= 0.00001]].</body><body package="GlorpDBTypeTests">helpTestInvalidValue: anObject	self helpTestValue: anObject		compareModelWith: [:read :original | read isNil or: [ read test ~= original ]]		compareWith: [:read :original | read ~= original]</body><body package="GlorpDBTypeTests">helpTestValue: anObject 	"Don't try and read back an equal float, it'll likely fail on precision issues"	self 		helpTestValue: anObject		compareModelWith: 			[:read :original | 			read notNil and: 					[(original isKindOf: Float) or: 							[original class == Dialect doublePrecisionFloatClass 								or: [read test = original]]]]		compareWith: [:read :original | read = original]</body><body package="GlorpDBTypeTests">helpTestValue: anObject compareModelWith: modelBlock compareWith: aBlock 	self 		helpTestValueWithSQLWrite: anObject		compareModelWith: modelBlock		compareWith: aBlock.	self 		helpTestValueWithUnitOfWorkWrite: anObject		compareModelWith: modelBlock</body><body package="GlorpDBTypeTests">helpTestValue: anObject compareWith: aBlock 	self 		helpTestValue: anObject		compareModelWith: [:read :original | true]		compareWith: aBlock</body><body package="GlorpDBTypeTests">helpTestValueWithSQLWrite: anObject compareModelWith: modelBlock compareWith: aBlock	| dbInValue readObject row converter dbOutValue typeTestModel system dbInValue2 readObject2 command |	system := self systemFor: table.	session system: system.	row := DatabaseRow newForTable: table.	row owner: GlorpTypeTestsModelClass new.	converter := type converterForStType: (stType isNil ifTrue: [anObject class] ifFalse: [stType]).	dbOutValue := converter convert: anObject toDatabaseRepresentationAs: type.	row atFieldNamed: 'test' put: dbOutValue.	self inTransactionDo: [	session writeRow: row.	command := SQLStringCommand new setSQLString: 'SELECT test, id FROM ', self tableName.	command maximumLobSizeToRetrieveDirectly: ((dbOutValue class = ByteArray or: [dbOutValue isString]) ifTrue: [dbOutValue size] ifFalse: [42]).	dbInValue := (session accessor executeCommand: command) first atIndex: 1.	readObject := converter convert: dbInValue fromDatabaseRepresentationAs: type.	(session platform canUseInWhereClause: dbOutValue type: type) ifTrue: [		dbInValue2 := self helpTestExplicitReadBackFor: dbOutValue.		readObject2 := converter convert: dbInValue2 fromDatabaseRepresentationAs: type].	(session platform canUseInWhereClause: anObject type: type) ifTrue: [		typeTestModel := self readBackModelWithValue: anObject.		self assert: (modelBlock value: typeTestModel value: anObject)]	].	self assert: (aBlock value: readObject value: anObject).	readObject2 isNil ifFalse: [		self assert: (aBlock value: readObject2 value: anObject)].</body><body package="GlorpDBTypeTests">helpTestValueWithUnitOfWorkWrite: anObject compareModelWith: aBlock	| typeTestModel system model |	system := self systemFor: table.	session system: system.	self inTransactionDo: [	session beginUnitOfWork.	model := GlorpTypeTestsModelClass new test: anObject.	session register: model.	session commitUnitOfWork.	session reset.	(session platform canUseInWhereClause: anObject type: type) ifTrue: [		typeTestModel := self readBackModelWithValue: anObject.		self assert: (aBlock value: typeTestModel value: anObject)]].</body><body package="GlorpDBTypeTests">inTransactionDo: aBlock	"Like the one in session, but always rollback."	| alreadyInTransaction result |	[ 	alreadyInTransaction := session isInTransaction.	alreadyInTransaction ifFalse: [session beginTransaction].	result := aBlock numArgs = 1 ifTrue: [aBlock value: self] ifFalse: [aBlock value].	alreadyInTransaction ifFalse: [session rollbackTransaction]]		ifCurtailed:			[alreadyInTransaction ifFalse: [session rollbackTransaction]].	^result.</body><body package="GlorpDBTypeTests">readBackModelWithValue: anObject	^session		readOneOf: GlorpTypeTestsModelClass		where: [:each | each test = anObject].</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeIndividualDBTests class</class-id> <category>resources</category><body package="GlorpDBTypeTests">resources	^Array with: GlorpDatabaseLoginResource with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpNumeric52Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testNumeric52	self platform supportsVariableSizedNumerics ifFalse: [^self].	self helpTestFloat: nil.	self helpTestFloat: 12.	self helpTestFloat: 321.12.	self helpTestInvalidValue: 17.098.	self helpTestFloat: 3.14.	self helpTestFloat: (Dialect coerceToDoublePrecisionFloat: 12).	self helpTestFloat: (Dialect coerceToDoublePrecisionFloat: 321.12).	self helpTestInvalidValue: (Dialect coerceToDoublePrecisionFloat: 17.098).	self helpTestFloat: (Dialect coerceToDoublePrecisionFloat: 3.14).	self helpTestFloat: (Dialect readFixedPointFrom: '321.12').	self helpTestInvalidValue: (Dialect readFixedPointFrom: '321.123').	self helpTestFloat: (Dialect readFixedPointFrom: '3.14').	self helpTestFloat: (Dialect readFixedPointFrom: '3.1' ).</body></methods><methods><class-id>Glorp.GlorpNumeric52Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^(self platform numeric)		precision: 5;		scale: 2.</body></methods><methods><class-id>Glorp.GlorpTreeNode</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	aStream nextPutAll: 'Node('.	id printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpTreeNode</class-id> <category>accessing</category><body package="GlorpTestModels">children	^children</body><body package="GlorpTestModels">children: aCollection	children := aCollection.</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger.</body><body package="GlorpTestModels">parent	^parent</body><body package="GlorpTestModels">parent: aGlorpTreeNode	parent := aGlorpTreeNode.</body></methods><methods><class-id>Glorp.GlorpTreeNode</class-id> <category>adding</category><body package="GlorpTestModels">addChild: aGlorpTreeNode	aGlorpTreeNode parent: self.	self children add: aGlorpTreeNode.</body><body package="GlorpTestModels">childrenRecursively: aTreeNode	"The parameter is a tree node within the tree of the getter.  If my parent has also been fetched, put me in my parent;  otherwise do nothing (all the nodes will be in the cache but their links were not fetched).	This example needs work.  The RecursionMapping's attribute should be used more.  We should also consult the #children mapping since it could have ordering or other features to respect when adding."	(aTreeNode parent isGlorpProxy and: [aTreeNode parent isInstantiated not]) ifTrue: [^self].	"The next two lines mostly duplicate each other, but the ancestor node's parent will be a proxy (on nil) so we need both."	(aTreeNode children isGlorpProxy and: [aTreeNode children isInstantiated not]) ifTrue:		[aTreeNode children: OrderedCollection new].	(aTreeNode parent children isGlorpProxy and: [aTreeNode parent children isInstantiated not]) ifTrue:		[aTreeNode parent children: OrderedCollection new].	aTreeNode parent children add: self.</body></methods><methods><class-id>Glorp.GlorpTreeNode</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	children := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpTreeNode class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpPublisherEmployee</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">jobTitle	^jobTitle</body><body package="GlorpTestModels">jobTitle: aString	jobTitle := aString</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpPublisherEmployee</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	id := nil.	name := nil.	jobTitle := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.GlorpPublisherEmployee class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpItemWithQty</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger.</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: aString	name := aString.</body><body package="GlorpTestModels">qty	^qty</body><body package="GlorpTestModels">qty: anInteger	qty := anInteger.</body><body package="GlorpTestModels">totalSales	^totalSales</body><body package="GlorpTestModels">totalSales: aDouble	totalSales := aDouble.</body></methods><methods><class-id>Glorp.GlorpItemWithQty</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: id printString.	aStream nextPut: $,.	aStream nextPutAll: name printString.	aStream nextPut: $,.	aStream nextPutAll: qty printString.	aStream nextPut: $,.	aStream nextPutAll: totalSales printString.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpFilteringQueryTest</class-id> <category>support</category><body package="GlorpTests">setUp</body></methods><methods><class-id>Glorp.GlorpFilteringQueryTest</class-id> <category>tests</category><body package="GlorpTests">testSimple	| query result |	query := FilteringQuery on: #( 1 2 3 4 5 6 7 8) filter: [:each :parameters | each odd].	result := GlorpSession new execute: query.	self assert: result = #(1 3 5 7).</body></methods><methods><class-id>Glorp.GlorpTinyPublisher</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body><body package="GlorpTestModels">titles	^titles</body><body package="GlorpTestModels">titles: anObject	titles := anObject</body><body package="GlorpTestModels">titlesWithNumberInStock	^titlesWithNumberInStock</body><body package="GlorpTestModels">titlesWithNumberInStock: anObject	titlesWithNumberInStock := anObject</body></methods><methods><class-id>Glorp.IdentityHashPrintingObject</class-id> <category>printing</category><body package="GlorpTests">printOn: aStream	aStream nextPutAll: 'thing with hash '.	self identityHash printOn: aStream.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionTest</class-id> <category>support</category><body package="GlorpTests">customerStream	| rows |	rows := #( ( 1 'Alan' ) (2 'Bob')).	^ReadStream on: rows.</body><body package="GlorpTests">joinedStream	| rows |	rows := #( ( 1 'Alan' 101 101 '1st Avenue' 111) (2 'Bob' 102 102 '2nd Avenue' 222) ).	^ReadStream on: rows.</body><body package="GlorpTests">joinedStream2	| rows |	rows := #( (1 'Alan' 101 101 '1st Avenue' 111  ) (2 'Bob' 102 102 '2nd Avenue' 222  ) ).	^ReadStream on: rows.</body><body package="GlorpTests">joinedStreamToMany	| rows |	rows := #( (1 'Alan' 101  7 'root' 'foo.com' )  (1 'Alan' 101  8 'root' 'bar.com' )  ).	^ReadStream on: rows.</body><body package="GlorpTests">joinedStreamToMany3	| rows |	rows := #( 			(1 'Alan' 1 '001' '001'  '123' 1 1 #CDN 1.5 'stuff' #CDN 1)  			(1 'Alan' 1 '001' '001'  '123' 2 1  #USD 1.5 'stuff' #USD 1) 			(1 'Alan' 2 '002' '002'  '234' 3 1  #CHF 1.5 'stuff' #CHF 1)			(1 'Alan' 2 '002' '002'  '234' 4 1  #EUR 1.5 'stuff' #EUR 1) ).	^ReadStream on: rows.</body><body package="GlorpTests">mockStream	| rows |	rows := #( ( 1 'Alan' 101) (2 'Bob' 102) (3 'Carol' 103)).	^ReadStream on: rows.</body><body package="GlorpTests">mockStream2	| rows |	rows := #( ( 4 'David' 104) (5 'Evan' 105)).	^ReadStream on: rows.</body><body package="GlorpTests">setUp	| query |	super setUp.	session := GlorpSessionResource current newSession.	((session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #name) shouldProxy: false.	query := Query read: GlorpPerson.	query session: session.	query prepare.	stream := GlorpCursoredStream on: self mockStream for: (query sqlWith: nil) accessor: nil.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionTest</class-id> <category>tests</category><body package="GlorpTests">testBuilderIsolation	"Make sure that we can have multiple streams open simultaneously against the same query"	| stream2 person1 stream3 person4 person4a |	stream2 := GlorpCursoredStream on: self mockStream2 for: stream command.	stream3 := GlorpCursoredStream on: self mockStream2 for: stream command.	person1 := stream next.	person4 := stream2 next.	person4a := stream3 next.	self assert: person4 == person4a.	self assert: person4 id = 4.	self assert: person1 id = 1.	self assert: stream next id = 2.	self assert: person4a id = 4.</body><body package="GlorpTests">testCollect	self assert: (stream collect: [:each | each name]) = #('Alan' 'Bob' 'Carol').</body><body package="GlorpTests">testKnittingWithAlsoFetch	| query person1 person2 |	query := Query read: GlorpPerson.	query session: session.	query alsoFetch: [:each | each address].	query prepare.	stream := GlorpCursoredStream on: self joinedStream2 for: (query sqlWith: nil).	person1 := stream next.	self assert: session privateGetCache numberOfElements = 2.	self assert: person1 address street = '1st Avenue'.	person2 := stream next.	self assert: session privateGetCache numberOfElements = 4.	self assert: stream atEnd.	self assert: person2 id = 2.	self assert: person2 address street = '2nd Avenue'.	self assert: session privateGetCache numberOfElements = 4.</body><body package="GlorpTests">testKnittingWithAlsoFetchDoubleToMany	| query customer1 |	query := Query read: GlorpCustomer.	query session: session.	query alsoFetch: [:each | each accounts].	query alsoFetch: [:each | each transactions].	query prepare.	stream := GlorpCursoredStream on: self joinedStreamToMany3 for: (query sqlWith: #()).	customer1 := stream next.	self assert: session privateGetCache numberOfElements = 7.	self assert: stream atEnd.	self assert: customer1 id = 1.	self assert: customer1 accounts size = 2.	self assert: customer1 accounts first accountNumber accountNumber = '123'.	self assert: customer1 accounts last accountNumber accountNumber = '234'.</body><body package="GlorpTests">testKnittingWithAlsoFetchToManyInSingleGroup	| query person1 |	query := Query read: GlorpPerson.	query session: session.	query alsoFetch: [:each | each emailAddresses].	query prepare.	stream := GlorpCursoredStream on: self joinedStreamToMany for: (query sqlWith: #()).	person1 := stream next.	self assert: session privateGetCache numberOfElements = 3.	self assert: (person1 emailAddresses allSatisfy: [:each | each user = 'root']).	self assert: person1 emailAddresses first ~= person1 emailAddresses last.	self assert: stream atEnd.</body><body package="GlorpTests">testKnittingWithRetrieve	| query tuple person1 address1 person2 address2 |	query := Query read: GlorpPerson.	query session: session.	query retrieve: [:each | each].	query retrieve: [:each | each address].	query prepare.	stream := GlorpCursoredStream on: self joinedStream for: (query sqlWith: nil).	tuple := stream next.	self assert: session privateGetCache numberOfElements = 2.	person1 := tuple first.	address1 := tuple last.	self assert: address1 street = '1st Avenue'.	self assert: person1 address == address1.	tuple := stream next.	self assert: stream atEnd.	person2 := tuple first.	address2 := tuple last.	self assert: person2 id = 2.	self assert: address2 street = '2nd Avenue'.	self assert: person2 address == address2.</body><body package="GlorpTests">testNext	| person |	person := stream next.	self assert: person class == GlorpPerson.	self assert: person id = 1.	self assert: person name = 'Alan'.	self assert: session privateGetCache numberOfElements = 1.	person := stream next.	self assert: person id = 2.	self assert: person name = 'Bob'.	self assert: session privateGetCache numberOfElements = 2.	stream next.	self assert: stream atEnd.	self assert: stream next = nil.</body><body package="GlorpTests">testNextColon	| people |	people := stream next: 2.	self assert: people size = 2.	self assert: people first id = 1.	self assert: people first name = 'Alan'.	self assert: session privateGetCache numberOfElements = 2.	self assert: people last id = 2.</body><body package="GlorpTests">testPostFetchEvents	| query customer |	query := Query read: GlorpCustomer.	query session: session.	query prepare.	stream := GlorpCursoredStream on: self customerStream for: (query sqlWith: #()).	customer := stream next.	self assert: customer seenPostFetch.</body><body package="GlorpTests">testReadEmpty	stream := GlorpCursoredStream on: (ReadStream on: #()) for: (stream query sqlWith: #()).	self assert: stream atEnd.	self assert: stream next isNil.</body><body package="GlorpTests">testRegistration	| person |	session beginUnitOfWork.	person := stream next.	self assert: (session isRegistered: person).</body><body package="GlorpTests">testRelease	| person |	stream next.	stream release.	self assert: stream atEnd.	self assert: stream next isNil.</body><body package="GlorpTests">testUpToEnd	| people |	people := stream upToEnd.	self assert: people size = 3.	self assert: people first name = 'Alan'.	self assert: people last name = 'Carol'.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionTest class</class-id> <category>resources</category><body package="GlorpTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem</class-id> <category>printing</category><body package="GlorpTests">printOn: aStream	aStream nextPut: $(.	id printOn: aStream.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem</class-id> <category>relationships</category><body package="GlorpTests">relateTo: anItem	relatedItems add: anItem.</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem</class-id> <category>accessing</category><body package="GlorpTests">id	^id</body><body package="GlorpTests">id: anObject	id := anObject</body><body package="GlorpTests">parent	^parent</body><body package="GlorpTests">parent: anObject	parent := anObject</body><body package="GlorpTests">relatedItems	^relatedItems</body><body package="GlorpTests">relatedItems: aCollection	relatedItems := aCollection</body><body package="GlorpTests">status	^status</body><body package="GlorpTests">status: aSymbol	status := aSymbol</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem</class-id> <category>initialize-release</category><body package="GlorpTests">initialize	relatedItems := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortItem class</class-id> <category>instance creation</category><body package="GlorpTests">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.ClassE</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassE := nil.	attrBClassE := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.ClassE</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassE	^attrAClassE</body><body package="GlorpTestModels">attrAClassE: anObject	attrAClassE := anObject</body><body package="GlorpTestModels">attrBClassE	^attrBClassE</body><body package="GlorpTestModels">attrBClassE: anObject	attrBClassE := anObject</body></methods><methods><class-id>Glorp.ClassE class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.ClassG</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassG	^attrAClassG</body><body package="GlorpTestModels">attrAClassG: anObject	attrAClassG := anObject</body></methods><methods><class-id>Glorp.ClassG</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassG := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.GlorpTax</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject.</body><body package="GlorpTestModels">supertax	^supertax</body><body package="GlorpTestModels">taxes	taxes ifNil: [taxes := IdentitySet new].	^taxes.</body></methods><methods><class-id>Glorp.GlorpTax</class-id> <category>add/remove</category><body package="GlorpTestModels">addTax: aTax	self taxes add: aTax.	aTax supertax: self.</body></methods><methods><class-id>Glorp.GlorpTax</class-id> <category>private</category><body package="GlorpTestModels">id: anObject	id := anObject.</body><body package="GlorpTestModels">supertax: anObject	supertax := anObject.</body></methods><methods><class-id>Glorp.GlorpTax class</class-id> <category>glorp</category><body package="GlorpTestModels">glorpCommonSetupDescriptor: aDescriptor forSystem: aSystem	| table |	table := aSystem tableNamed: 'TAX'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping:			((OneToManyMapping new)				attributeName: #taxes;				referenceClass: GlorpTax;				join: (Join from: (table fieldNamed: 'ID') to: (table fieldNamed: 'TAX_ID'))).	aDescriptor addMapping:			((OneToOneMapping new)				attributeName: #supertax;				referenceClass: GlorpTax;				join: (Join from: (table fieldNamed: 'TAX_ID') to: (table fieldNamed: 'ID'))).</body><body package="GlorpTestModels">glorpSetupDescriptor: aDescriptor forSystem: aSystem	| table |	table := aSystem tableNamed: 'TAX'.	aDescriptor table: table.	"(aSystem typeResolverFor: GlorpTax)		register: aDescriptor		keyedBy: 'XXX'		field: (table fieldNamed: 'TYPE')."	(aSystem typeResolverFor: GlorpTax)		register: aDescriptor		abstract: true</body><body package="GlorpTestModels">glorpTypeResolver	^FilteredTypeResolver forRootClass: GlorpTax.</body></methods><methods><class-id>Glorp.GlorpSurcharge class</class-id> <category>glorp</category><body package="GlorpTestModels">glorpSetupDescriptor: aDescriptor forSystem: aSystem	| table |	table := aSystem tableNamed: 'TAX'.	self glorpCommonSetupDescriptor: aDescriptor forSystem: aSystem.	(aSystem typeResolverFor: GlorpTax)		register: aDescriptor		keyedBy: 'S'		field: (table fieldNamed: 'TYPE').</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests</class-id> <category>tests</category><body package="GlorpDBTypeTests">testSerial	"type := PGSerialType instance.	self assert: false.	self assert: (type typeString = 'SERIAL')"</body><body package="GlorpDBTypeTests">testTypeParametersNotAliased	| type2 type3 |	type := (self platform) varchar.	self assert: type width isNil.	self assert: (type2 := self platform varChar: 5) width = 5.	self assert: type width isNil.	type3 := self platform varChar: 10.	self assert: type3 width = 10.	self assert: type2 width = 5.	self assert: type width isNil.</body><body package="GlorpDBTypeTests">testVarBinary	"Needs doing"	self needsWork: 'write the test'.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests</class-id> <category>infrastructure tests</category><body package="GlorpDBTypeTests">testReadTime	self platform readTime: '18:06:22.12' for: self platform time.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests</class-id> <category>setup</category><body package="GlorpDBTypeTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	connection := session accessor.</body><body package="GlorpDBTypeTests">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests</class-id> <category>accessing</category><body package="GlorpDBTypeTests">platform	^connection platform</body></methods><methods><class-id>Glorp.GlorpDatabaseTypeDBTests class</class-id> <category>accessing</category><body package="GlorpDBTypeTests">resources	^Array with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpTypeComparisonTest</class-id> <category>testing</category><body package="GlorpDBTypeTests">testIntegerToInteger	self assert: (GlorpIntegerType new platform: platform) = (GlorpIntegerType new platform: platform).	self assert: (GlorpIntegerType new platform: platform) hash = (GlorpIntegerType new platform: platform) hash.</body><body package="GlorpDBTypeTests">testIntegerToIntegerishNumber	self assert: (GlorpIntegerType new platform: platform) = (GlorpNumericType new platform: platform).	self assert: (GlorpIntegerType new platform: platform) hash = (GlorpNumericType new platform: platform) hash.	self assert: (GlorpNumericType new platform: platform) = (GlorpIntegerType new platform: platform).	self assert: (GlorpNumericType new platform: platform) hash = (GlorpIntegerType new platform: platform) hash.</body><body package="GlorpDBTypeTests">testIntegerToNumber	self deny: (GlorpIntegerType new platform: platform) = (GlorpNumericType new platform: platform; precision: 2).	self deny: (GlorpIntegerType new platform: platform) hash = (GlorpNumericType new platform: platform; precision: 2) hash.	self deny: (GlorpNumericType new platform: platform; precision: 2) = (GlorpIntegerType new platform: platform).	self deny: (GlorpNumericType new platform: platform; precision: 2) hash = (GlorpIntegerType new platform: platform) hash.</body><body package="GlorpDBTypeTests">testIntegerishNumberToNumber	self deny: (GlorpNumericType new platform: platform) = (GlorpNumericType new platform: platform; precision: 2).	self deny: (GlorpNumericType new platform: platform) hash = (GlorpNumericType new platform: platform; precision: 2) hash.	self deny: (GlorpNumericType new platform: platform; precision: 2) = (GlorpNumericType new platform: platform).	self deny: (GlorpNumericType new platform: platform; precision: 2) hash = (GlorpNumericType new platform: platform) hash.</body><body package="GlorpDBTypeTests">testNumberToNumber	self assert: (GlorpNumericType new platform: platform; precision: 2) = (GlorpNumericType new platform: platform; precision: 2).	self assert: (GlorpNumericType new platform: platform; precision: 2) hash = (GlorpNumericType new platform: platform; precision: 2) hash.	self assert: (GlorpNumericType new platform: platform; precision: 2) = (GlorpNumericType new platform: platform; precision: 2).	self assert: (GlorpNumericType new platform: platform; precision: 2) hash = (GlorpNumericType new platform: platform; precision: 2) hash.</body></methods><methods><class-id>Glorp.GlorpTypeComparisonTest</class-id> <category>running</category><body package="GlorpDBTypeTests">setUp	super setUp.	platform := DatabasePlatform new</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels">exampleAuthor1	^GlorpEncyclopediaAuthor new 		id: 1;		name: 'Somebody'.</body><body package="GlorpTestModels">exampleAuthor2	^GlorpEncyclopediaAuthor new 		id: 2;		name: 'Somebody Else'.</body><body package="GlorpTestModels">exampleEncyclopedias	"self new exampleEncyclopedias"	| encyc1 entry1 entry2 entry3 encyc2 encyc3 |	encyc1 := GlorpEncyclopedia new id: 3; name: 'The Canadian Encyclopedia'.	entry1 := self exampleEntry1.	entry2 := self exampleEntry2.	entry3 := self exampleEntry3.	encyc1 articleAt: '12345' put: entry1.	encyc1 articleAt: 'abcde' put: entry2.	encyc1 articleAt: 'unique' put: entry3.	encyc2 := GlorpEncyclopedia new id: 4; name: 'The Plagiarists Compendium'.	encyc2 articleAt: '54321' put: entry1.	encyc2 articleAt: 'edcba' put: entry2.	encyc2 entriesByAuthor at: self exampleAuthor1 put: entry1.	encyc2 entriesByAuthor at: self exampleAuthor2 put: entry2.	encyc3 := GlorpEncyclopedia new id: 5; name: 'The Very Frugal Dictionary'.	^Array with: encyc1 with: encyc2 with: encyc3.</body><body package="GlorpTestModels">exampleEntry1	^GlorpEncyclopediaEntry new 		id: 'one';		title: 'All About Ants';		text: 'Ants are, like, these little tiny creatures. Gross.'.</body><body package="GlorpTestModels">exampleEntry2	^GlorpEncyclopediaEntry new 		id: 'two';		title: 'Computer Programming Languages';		text: 'There are many different computer programming languages. The best one is Smalltalk.'.</body><body package="GlorpTestModels">exampleEntry3	^GlorpEncyclopediaEntry new 		id: 'three';		title: 'Vehicular Fish Decay';		text: 'Do you know what happens if you leave a fish too long in an elevator? Well heres a clue. Fish is biodegradable. That means it rots.'.</body><body package="GlorpTestModels">examplePublisher1	"Put in the copies to avoid an issue with reverting immutable objects."	^GlorpPublisher new 		id: 1;		name: 'Cambridge';		titles: (Array with: 'Mastering ENVY/Developer' copy with: 'Principia Mathematica' copy with:  'Metadata-Based Persistence for Dummies' copy);		titlesWithNumberInStock: (Dictionary new			at:  'Mastering ENVY/Developer' put: 2;			at: 'Principia Mathematica' put: 2;			at: 'Metadata-Based Persistence for Dummies' put: 2;			yourself);		employees: (Dictionary new			at: 'CEO' put: (GlorpPublisherEmployee new id: 1; name: 'The Boss'; jobTitle: 'CEO');			at: 'Editor' put: (GlorpPublisherEmployee new id: 2; name: 'Somebody'; jobTitle: 'Editor');			yourself);		differentBunchOfEmployeesById: (Dictionary new			at: 3 put: (GlorpPublisherEmployee new id: 3; name: 'Contractor 1'; jobTitle: 'Contractor');			at: 4 put: (GlorpPublisherEmployee new id: 4; name: 'Contractor 2'; jobTitle: 'Contractor');			yourself);		yourself.</body><body package="GlorpTestModels">examplePublisher2	^GlorpPublisher new 		id: 2;		name: 'Harper Collins';		titles: (Array with: 'A book' copy);		titlesWithNumberInStock: (Dictionary new			at:  'A book' copy put: 200;			yourself).</body><body package="GlorpTestModels">examplePublisher3	^GlorpPublisher new 		id: 3;		name: 'A New Publishing company';		titles: #().</body><body package="GlorpTestModels">examplePublishers	^Array with: self examplePublisher1 with: self examplePublisher2 with: self examplePublisher3.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForENCYC: aTable 	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForENCYC_AUTHOR: aTable	(aTable createFieldNamed: 'ID' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForENCYC_AUTHOR_ENTRY_LINK: aTable	| entryId authorId |	entryId := aTable createFieldNamed: 'ENCYC_ENTRY_ID' type: (platform varChar: 50).	aTable addForeignKeyFrom: entryId to: ((self tableNamed: 'ENCYC_ENTRY') fieldNamed: 'ID').	authorId := aTable createFieldNamed: 'ENCYC_AUTHOR_ID' type: (platform integer).	aTable addForeignKeyFrom: authorId to: ((self tableNamed: 'ENCYC_AUTHOR') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForENCYC_BIO: aTable 	| encycId |	(aTable createFieldNamed: 'TITLE' type: (platform varChar: 50)) bePrimaryKey.	encycId := aTable createFieldNamed: 'ENCYC_ID' type: platform integer.	encycId bePrimaryKey.	aTable addForeignKeyFrom: encycId to: ((self tableNamed: 'ENCYC') fieldNamed: 'ID').	aTable createFieldNamed: 'ENTRY_TEXT' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForENCYC_ENTRY: aTable 	(aTable createFieldNamed: 'ID' type: (platform varChar: 50)) bePrimaryKey.	aTable createFieldNamed: 'TITLE' type: (platform varChar: 50).	aTable createFieldNamed: 'ENTRY_TEXT' type: (platform varChar: 200).	aTable createFieldNamed: 'MEDIA_TYPE_NAME' type: (platform varChar: 100).	aTable createFieldNamed: 'MEDIA_TYPE_MIME' type: (platform varChar: 100).</body><body package="GlorpTestModels">tableForENCYC_ENTRY_LINK: aTable 	| encycId entryId |	encycId := aTable createFieldNamed: 'ENCYC_ID' type: platform int4.	encycId bePrimaryKey.	aTable addForeignKeyFrom: encycId to: ((self tableNamed: 'ENCYC') fieldNamed: 'ID').	entryId := aTable createFieldNamed: 'ENCYC_ENTRY_ID' type: (platform varChar: 50).	aTable addForeignKeyFrom: entryId to: ((self tableNamed: 'ENCYC_ENTRY') fieldNamed: 'ID').	(aTable createFieldNamed: 'REFERENCE_NO' type: (platform varChar: 10)) bePrimaryKey.</body><body package="GlorpTestModels">tableForGR_PUBLISHER: aTable 	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForIMAGINARY_MEDIA_TYPE: aTable 	aTable isImaginary: true.  	aTable createFieldNamed: 'MEDIA_TYPE_NAME' type: (platform varChar: 100).	aTable createFieldNamed: 'MEDIA_TYPE_MIME' type: (platform varChar: 100).</body><body package="GlorpTestModels">tableForPUBLISHER_EMP: aTable 	| |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).		aTable createFieldNamed: 'JOBTITLE' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForPUBLISHER_TITLE2: aTable 	| |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'TITLE' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForPUBLISHER_TITLE: aTable 	| pubId |	pubId := aTable createFieldNamed: 'PUBLISHER_ID' type: platform int4.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_PUBLISHER') fieldNamed: 'ID').	aTable createFieldNamed: 'POSITION' type: (platform int4).		aTable createFieldNamed: 'TITLE' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForPUB_EMP_LINK: aTable 	| pubId titleId |	pubId := aTable createFieldNamed: 'PUBLISHER_ID' type: platform int4.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_PUBLISHER') fieldNamed: 'ID').	titleId := aTable createFieldNamed: 'EMP_ID' type: platform int4.	aTable addForeignKeyFrom: titleId  to: ((self tableNamed: 'PUBLISHER_EMP') fieldNamed: 'ID').	aTable createFieldNamed: 'FOO' type: (platform varchar: 5).</body><body package="GlorpTestModels">tableForPUB_TITLES_STOCK: aTable 	| pubId |	pubId := aTable createFieldNamed: 'PUBLISHER_ID' type: platform int4.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_PUBLISHER') fieldNamed: 'ID').	aTable createFieldNamed: 'TITLE' type: (platform varChar: 50).	aTable createFieldNamed: 'STOCK' type: platform int4.</body><body package="GlorpTestModels">tableForPUB_TITLE_LINK: aTable 	| pubId titleId |	pubId := aTable createFieldNamed: 'PUBLISHER_ID' type: platform int4.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_PUBLISHER') fieldNamed: 'ID').	titleId := aTable createFieldNamed: 'TITLE_ID' type: platform int4.	aTable addForeignKeyFrom: titleId  to: ((self tableNamed: 'PUBLISHER_TITLE2') fieldNamed: 'ID').	aTable createFieldNamed: 'STOCK' type: platform int4.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForGlorpEncyclopedia: aDescriptor	| table linkTable entriesByAuthor entryTable authorEntryLink |	table := self tableNamed: 'ENCYC'.	linkTable := self tableNamed: 'ENCYC_ENTRY_LINK'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DictionaryMapping)		attributeName: #entries;		referenceClass: GlorpEncyclopediaEntry;		keyField: (linkTable fieldNamed: 'REFERENCE_NO');		linkFields: (Array with: (linkTable fieldNamed: 'ENCYC_ENTRY_ID')).	(aDescriptor newMapping: DictionaryMapping)		attributeName: #biographicalEntries;		referenceClass: GlorpEncyclopediaBioEntry;		usesLinkTable: false;		beExclusive;		keyField: ((self tableNamed: 'ENCYC_BIO') fieldNamed: 'TITLE').	entryTable := self tableNamed: 'ENCYC_ENTRY'.	authorEntryLink := self tableNamed: 'ENCYC_AUTHOR_ENTRY_LINK'.	entriesByAuthor := aDescriptor newMapping: DictionaryMapping.	entriesByAuthor		attributeName: #entriesByAuthor;		referenceClass: GlorpEncyclopediaEntry;		usesLinkTable: true;													"Some or all of these"		join: (Join from: (table fieldNamed: 'ID') to: (linkTable fieldNamed: 'ENCYC_ID'));	"...  three lines may"		linkFields: (Array with: (linkTable fieldNamed: 'ENCYC_ENTRY_ID'));				"... not be needed."		"constructRowMapKeyAs: [:encyc :entry :author | MultipleRowMapKey with: encyc yourSelf with: author yourSelf];"		keyMapping: ((entriesByAuthor newMapping: OneToOneMapping)			attributeName: #key;			referenceClass: GlorpEncyclopediaAuthor;			usesLinkTable: true;		"true, i.e. look for a foreign key constraint from 'from' to 'to' in the join"			join: (Join from: (entryTable fieldNamed: 'ID') to: (authorEntryLink fieldNamed: 'ENCYC_ENTRY_ID'));	"map from value to key"			linkFields: (Array with: (authorEntryLink fieldNamed: 'ENCYC_AUTHOR_ID'))";"			"Note that when we're fired as a one-to-one, the row map key constructor block arguments will be different than for the main mapping"			"constructRowMapKeyAs: [:encyc :author | MultipleRowMapKey with: encyc yourSelf with: author yourSelf]").</body><body package="GlorpTestModels">descriptorForGlorpEncyclopediaAuthor: aDescriptor 	| entryTable |	entryTable := self tableNamed: 'ENCYC_AUTHOR'.	aDescriptor table: entryTable.	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #name.</body><body package="GlorpTestModels">descriptorForGlorpEncyclopediaBioEntry: aDescriptor 	| entryTable |	entryTable := self tableNamed: 'ENCYC_BIO'.	aDescriptor table: entryTable.	"It's important that we have a mapping for the owner here, because we're expecting these entries to be deleted, and we can't delete them without knowing the primary keys."	(aDescriptor newMapping: OneToOneMapping)		attributeName: #owner;		beReadOnly.	(aDescriptor newMapping: DirectMapping) from: #title		to: (entryTable fieldNamed: 'TITLE').	(aDescriptor newMapping: DirectMapping) from: #text		to: (entryTable fieldNamed: 'ENTRY_TEXT').</body><body package="GlorpTestModels">descriptorForGlorpEncyclopediaEntry: aDescriptor 	| entryTable |	entryTable := self tableNamed: 'ENCYC_ENTRY'.	aDescriptor table: entryTable.	(aDescriptor newMapping: DirectMapping) from: #id		to: (entryTable fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #title		to: (entryTable fieldNamed: 'TITLE').	(aDescriptor newMapping: DirectMapping) from: #text		to: (entryTable fieldNamed: 'ENTRY_TEXT').	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)		attributeName: #mediaType;		referenceClass: GlorpMediaType;		fieldTranslation: (Join new						addSource: (entryTable fieldNamed: 'MEDIA_TYPE_NAME')						target: ((self tableNamed: 'IMAGINARY_MEDIA_TYPE') 									fieldNamed: 'MEDIA_TYPE_NAME');						addSource: (entryTable fieldNamed: 'MEDIA_TYPE_MIME')						target: ((self tableNamed: 'IMAGINARY_MEDIA_TYPE') 									fieldNamed: 'MEDIA_TYPE_MIME');					yourself).	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpMediaType: aDescriptor 	| table |	table := self tableNamed: 'IMAGINARY_MEDIA_TYPE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'MEDIA_TYPE_NAME').	(aDescriptor newMapping: DirectMapping) from: #mimeType		to: (table fieldNamed: 'MEDIA_TYPE_MIME')</body><body package="GlorpTestModels">descriptorForGlorpPublisher: aDescriptor 	| table titleTable titleStockTable linkTable |	table := self tableNamed: 'GR_PUBLISHER'.	titleTable := self tableNamed: 'PUBLISHER_TITLE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectToManyMapping)		attributeName: #titles;		resultField: (titleTable fieldNamed: 'TITLE');		writeTheOrderField;		orderBy: [:each | (each getTable: titleTable) getField: 'POSITION'];		join: (Join from: (table fieldNamed: 'ID') to: (titleTable fieldNamed: 'PUBLISHER_ID')).	titleStockTable := self tableNamed: 'PUB_TITLES_STOCK'.	(aDescriptor newMapping: DictionaryMapping)		attributeName: #titlesWithNumberInStock;		usesLinkTable: false;		keyField: (titleStockTable fieldNamed: 'TITLE');		valueField: (titleStockTable fieldNamed: 'STOCK');		join: (Join from: (table fieldNamed: 'ID') to: (titleStockTable fieldNamed: 'PUBLISHER_ID')).	linkTable := self tableNamed: 'PUB_EMP_LINK'.	(aDescriptor newMapping: DictionaryMapping)		attributeName: #employees;		usesLinkTable: true;		keyField: ((self tableNamed: 'PUBLISHER_EMP' ) fieldNamed: 'JOBTITLE');		join: (Join 			from: (table fieldNamed: 'ID')			to: (linkTable fieldNamed: 'PUBLISHER_ID')			from: 'A'			to: (linkTable fieldNamed: 'FOO')).	(aDescriptor newMapping: DictionaryMapping)		attributeName: #differentBunchOfEmployeesById;		usesLinkTable: true;		join: (Join 			from: (table fieldNamed: 'ID')			to: (linkTable fieldNamed: 'PUBLISHER_ID')			from: 'B'			to: (linkTable fieldNamed: 'FOO'));		keyField: ((self tableNamed: 'PUB_EMP_LINK') fieldNamed: 'EMP_ID').		"	titleStockLinkTable := self tableNamed: 'PUB_TITLE_LINK'.	titleTable2 := self tableNamed: 'PUBLISHER_TITLE2'.	(aDescriptor newMapping: DictionaryMapping)		attributeName: #titlesWithNumberInStockLink;		usesLinkTable: true;		keyField: (titleTable2 fieldNamed: 'TITLE');		valueField: (titleStockLinkTable fieldNamed: 'STOCK');		linkTableJoin: (Join from: (table fieldNamed: 'ID') to: (titleStockLinkTable fieldNamed: 'PUBLISHER_ID'))."</body><body package="GlorpTestModels">descriptorForGlorpPublisherEmployee: aDescriptor 	| table |	table := self tableNamed: 'PUBLISHER_EMP'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectMapping) from: #jobTitle		to: (table fieldNamed: 'JOBTITLE').</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels">allTableNames	^#('ENCYC' 'ENCYC_ENTRY' 'ENCYC_ENTRY_LINK' 'ENCYC_AUTHOR' 'ENCYC_AUTHOR_ENTRY_LINK' 'IMAGINARY_MEDIA_TYPE' 'GR_PUBLISHER' 'PUBLISHER_TITLE' 'PUB_TITLES_STOCK' 'PUB_TITLE_LINK' 'PUBLISHER_TITLE2' 'PUB_EMP_LINK' 'PUBLISHER_EMP').</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpEncyclopedia;		add: GlorpMediaType;		add: GlorpEncyclopediaEntry;		add: GlorpPublisher;		add: GlorpPublisherEmployee;		add: GlorpEncyclopediaAuthor;		yourself</body></methods><methods><class-id>Glorp.GlorpEncyclopediaDescriptorSystem</class-id> <category>classes</category><body package="GlorpTestModels">classModelForGlorpEncyclopedia: aClassModel  	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name. 	aClassModel newAttributeNamed: #entries dictionaryFrom: String to: GlorpEncyclopediaEntry.	"A slightly contrived way of having a mapping to a type of entries that don't use a link table."	aClassModel newAttributeNamed: #biographicalEntries dictionaryFrom: String to: GlorpEncyclopediaBioEntry.	"An object-&gt;object dictionary."	aClassModel newAttributeNamed: #entriesByAuthor dictionaryFrom: GlorpEncyclopediaAuthor to: GlorpEncyclopediaEntry.</body><body package="GlorpTestModels">classModelForGlorpEncyclopediaAuthor: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.</body><body package="GlorpTestModels">classModelForGlorpEncyclopediaBioEntry: aClassModel 	aClassModel newAttributeNamed: #owner type: GlorpEncyclopedia.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #text.</body><body package="GlorpTestModels">classModelForGlorpEncyclopediaEntry: aClassModel 	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #text.	aClassModel newAttributeNamed: #mediaType type: GlorpMediaType</body><body package="GlorpTestModels">classModelForGlorpMediaType: aClassModel 	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #mimeType</body><body package="GlorpTestModels">classModelForGlorpPublisher: aClassModel  	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name. 	aClassModel newAttributeNamed: #titles collection: Array of: String.	aClassModel newAttributeNamed: #titlesWithNumberInStock dictionaryFrom: String to: Integer.	aClassModel newAttributeNamed: #employees dictionaryFrom: String to: GlorpPublisherEmployee.	aClassModel newAttributeNamed: #differentBunchOfEmployeesById dictionaryFrom: Integer to: GlorpPublisherEmployee."	aClassModel newAttributeNamed: #titlesWithNumberInStockLink collection: Dictionary of: Integer."</body><body package="GlorpTestModels">classModelForGlorpPublisherEmployee: aClassModel  	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name. 	aClassModel newAttributeNamed: #position.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaConditionalTestSystem</class-id> <category>examples</category><body package="GlorpTestModels">exampleEncyclopediaFeatures	^self exampleEncyclopedias collect:		[:each |		GlorpEncyclopediaFeature new			encyclopedia: each;			yourself]</body></methods><methods><class-id>Glorp.GlorpEncyclopediaConditionalTestSystem</class-id> <category>classes</category><body package="GlorpTestModels">classModelForGlorpEncyclopediaFeature: aClassModel	aClassModel newAttributeNamed: #encyclopedia.	aClassModel newAttributeNamed: #featured type: GlorpEncyclopediaEntry.	(aClassModel newAttributeNamed: #featuredEntryText type: String) useDirectAccess: false.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaConditionalTestSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForENCYC_WITH_FEATURE: aTable	"Add a featured entry whose text will be stored locally if short but in an entry of the linked encyclopedia if long."	(aTable createFieldNamed: 'ENCYC_ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'featuredEntryID' type: (platform varChar: 50).	"The entry table's id is a varchar"	aTable createFieldNamed: 'featuredEntryString' type: (platform varchar: 30).</body></methods><methods><class-id>Glorp.GlorpEncyclopediaConditionalTestSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForGlorpEncyclopediaFeature: aDescriptor	"We either have a 'featured' entry and put its id in field featuredEntryID, or we have the feature entry string directly in field featuredEntryString.  The first case is the representativeMapping and so decides the conditional name, referenceClass, etc."	| featuredEntryStringField featuredEntryIDField encycEntryTable conditional featuredEntryMapping table |	table := self tableNamed: 'ENCYC_WITH_FEATURE'.	aDescriptor table: table.		(aDescriptor directMapping from: #id to: (table fieldNamed: 'ENCYC_ID')) beForPseudoVariable.	aDescriptor oneToOneMapping		attributeName: #encyclopedia;		referenceClass: GlorpEncyclopedia;		join: (Join				from: (table fieldNamed: 'ENCYC_ID')				to: ((self tableNamed: 'ENCYC') fieldNamed: 'ID')).	"For testing"	featuredEntryIDField := aDescriptor table fieldNamed: 'featuredEntryID'.	(aDescriptor directMapping from: #featuredEntryID to: featuredEntryIDField) beForPseudoVariable.	featuredEntryStringField := aDescriptor table fieldNamed: 'featuredEntryString'.	(aDescriptor directMapping from: #featuredEntryString to: featuredEntryStringField) beForPseudoVariable.	encycEntryTable := self tableNamed: 'ENCYC_ENTRY'.	conditional := aDescriptor newMapping: ConditionalMapping.	featuredEntryMapping := (conditional newMapping: OneToOneMapping)		attributeName: #featured;		join: (Join				from: featuredEntryIDField				to: (encycEntryTable fieldNamed: 'ID')).	conditional		forField: featuredEntryStringField	"nil size = 0 so gets string case but returns nil anyway"		attribute: [:object | object featuredEntryText size &gt; featuredEntryStringField type width						ifFalse: [object featuredEntryText]						ifTrue: [nil]]		if: [:each | each isNil] useMapping: featuredEntryMapping.	conditional otherwise: (DirectMapping from: #featuredEntryText to: featuredEntryStringField).	aDescriptor resetMappedFields.	"from ConditionalMapping&gt;&gt;newMapping - maybe the otherwise: should call this?"	"conditional debugRead: true.	conditional debugWrite: true."</body></methods><methods><class-id>Glorp.GlorpNonperishableItem</class-id> <category>accessing</category><body package="GlorpTestModels">serialNumber	^serialNumber</body><body package="GlorpTestModels">serialNumber: anObject	serialNumber := anObject</body></methods><methods><class-id>Glorp.GlorpUnassembledItem</class-id> <category>accessing</category><body package="GlorpTestModels">assemblyCost	^assemblyCost</body><body package="GlorpTestModels">assemblyCost: anObject	assemblyCost := anObject</body></methods><methods><class-id>Glorp.GlorpEmployee class</class-id> <category>glorp setup</category><body package="GlorpTestModels">glorpTypeResolver	^FilteredTypeResolver forRootClass: GlorpEmployee</body></methods><methods><class-id>Glorp.GlorpManager</class-id> <category>accessing</category><body package="GlorpTestModels">branch	^branch</body><body package="GlorpTestModels">branch: anObject	branch := anObject</body></methods><methods><class-id>Glorp.GlorpManager</class-id> <category>comparing</category><body package="GlorpTestModels">= aManager	^super = aManager and: [branch = aManager branch].</body></methods><methods><class-id>Glorp.AbstractLOBTest</class-id> <category>private</category><body package="GlorpDBTypeTests">adjustForMaximumSize: aValue	^aValue size &gt; session platform maximumQueryValueSize 		ifTrue: [(aValue copyFrom: 1 to: session platform maximumQueryValueSize - 2), '%']		ifFalse: [aValue].</body><body package="GlorpDBTypeTests">convertToTypeFrom: anObject	"For SQL-Server, return the function which converts anObject's value to my type."		^anObject		ifNotNil:			[FunctionExpression for: #convertTo: withArguments: (Array with: anObject asGlorpExpression) basedOn: type asGlorpExpression system: session system]</body><body package="GlorpDBTypeTests">helpTestExplicitReadBackFor: dbOutValue	"Read back the row with the given value, using an explicit where clause."	| queryStream result compareClause|	queryStream := SQLStringSelectCommand sqlString: nil parameters: #() useBinding: session useBinding session: session.	queryStream nextPutAll: 'SELECT test,id FROM ', self tableName, ' WHERE test'.	compareClause := self platform isSQLServerPlatform ifTrue: [' = '] ifFalse: [' LIKE '].	queryStream nextPutAll: (dbOutValue isNil ifTrue: [' IS '] ifFalse: [compareClause]).	(dbOutValue notNil and: [type requiresCast]) ifTrue: [queryStream nextPutAll: ' CAST ('].	(self platform isSQLServerPlatform and: [dbOutValue notNil and: [type requiresConvertToVarbinary]])		ifTrue: [queryStream nextPutAll: ' CONVERT(varbinary(max),'].	(queryStream canBind: dbOutValue to: type) 		ifTrue: [			queryStream parameters: (Array with: dbOutValue).			queryStream nextPutAll: '?']		ifFalse: [type print: dbOutValue on: queryStream].	(dbOutValue notNil and: [type requiresCast]) ifTrue: [		queryStream nextPutAll: ' AS '.		queryStream nextPutAll: type queryType typeName.		queryStream nextPutAll: ')'].	(self platform isSQLServerPlatform and: [dbOutValue notNil and: [type requiresConvertToVarbinary]])		ifTrue: [queryStream nextPutAll: ')'].	result := connection executeCommand: queryStream.	result isEmpty ifTrue: [^nil].	^(result atIndex: 1) atIndex: 1.</body><body package="GlorpDBTypeTests">helpTestValue: anObject compareModelWith: modelBlock compareWith: aBlock 	| dbOutValue |	dbOutValue := self adjustForMaximumSize: anObject.	^super helpTestValue: dbOutValue compareModelWith: modelBlock compareWith: aBlock.</body><body package="GlorpDBTypeTests">readBackModelWithValue: anObject	"For SQL-Server, use CONVERT (which is easier than CAST for now), with = instead of LIKE."		^self platform isSQLServerPlatform		ifTrue:			[| converted |			converted := self convertToTypeFrom: anObject.			session				readOneOf: GlorpTypeTestsModelClass				where: [:each | each test = converted]]		ifFalse:			[session				readOneOf: GlorpTypeTestsModelClass				where: [:each | each test like: anObject]]	"^session		readOneOf: GlorpTypeTestsModelClass		where: [:each | each test like: (Cast value: anObject as: type queryType)]."</body></methods><methods><class-id>Glorp.GlorpClobTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">longString	"Make a significant sized stringlob. 64k+ a bit should do"	| stream |	stream := WriteStream on: (String new: 10000).	(((2 raisedTo: 16) + 100.0) / 255.0) ceiling timesRepeat: [		stream nextPutAll: self string255].	^stream contents.</body><body package="GlorpDBTypeTests">string255	^'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu'.</body><body package="GlorpDBTypeTests">testClob	self helpTestValue: nil.	self helpTestValue: 'abcdef'.</body><body package="GlorpDBTypeTests">testLargeClob	"The long test here not only fails, it messes up the driver so that other tests fail"	(session platform class == AccessPlatform and: [session useBinding not])		ifTrue: [^self].	self helpTestValue: self longString.</body></methods><methods><class-id>Glorp.GlorpClobTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform clob.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForBANK_ACCT: aTable	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'BANK_CODE' type: (platform varChar: 10).	aTable createFieldNamed: 'BRANCH_NO' type: (platform int4).	aTable createFieldNamed: 'ACCT_NO' type: (platform varChar: 10).</body><body package="GlorpTestModels">tableForBANK_TRANS: aTable 	| ownerId |	(aTable createFieldNamed: 'ID' type: (platform serial: 3))		bePrimaryKey.	ownerId := aTable createFieldNamed: 'OWNER_ID' type: platform int4.	aTable addForeignKeyFrom: ownerId		to: ((self tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	aTable createFieldNamed: 'AMT_CURR' type: (platform varChar: 5).	aTable createFieldNamed: 'AMT_AMT' type: platform int4.	aTable createFieldNamed: 'SRVC_DESC' type: (platform varChar: 30).	aTable createFieldNamed: 'SRVC_AMT_CURR' type: (platform varChar: 5).	aTable createFieldNamed: 'SRVC_AMT_AMT' type: platform int4.</body><body package="GlorpTestModels">tableForCITIES: aTable	(aTable createFieldNamed: 'id' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'name' type: (platform varChar: 30).</body><body package="GlorpTestModels">tableForCITIES_GRAPH: aTable	"This is the link table for the relationship connecting cities.  It lets us test extracting data from the link table in recursive queries."	| cityField nextCityField citiesTable|	cityField := (aTable createFieldNamed: 'city' type: platform int4) bePrimaryKey.	nextCityField := (aTable createFieldNamed: 'nextCity' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'distance' type: platform double.	citiesTable := self tableNamed: 'CITIES'.	aTable addForeignKeyFrom: cityField to: (citiesTable fieldNamed: 'id').	aTable addForeignKeyFrom: nextCityField to: (citiesTable fieldNamed: 'id').</body><body package="GlorpTestModels">tableForCOMPRESSED_MONEY_TABLE: aTable	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	aTable createFieldNamed: 'CURRENCY_NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'AMOUNT' type: platform int4.</body><body package="GlorpTestModels">tableForCUSTOMER_ACCT_LINK: aTable	| customerId accountId |	customerId := (aTable createFieldNamed: 'CUSTOMER_ID' type: platform int4).	aTable addForeignKeyFrom: customerId to: ((self tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	accountId := aTable createFieldNamed: 'ACCT_ID' type: platform int4.	aTable addForeignKeyFrom: accountId to: ((self tableNamed: 'BANK_ACCT') fieldNamed: 'ID').	aTable addIndexForFields: (Array with: customerId with: accountId).</body><body package="GlorpTestModels">tableForEMAIL_ADDRESS: aTable	| personId |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	(aTable createFieldNamed: 'USER_NAME' type: (platform varChar: 20)) beIndexed.	aTable createFieldNamed: 'HOST_NAME' type: (platform varChar: 20).	personId := aTable createFieldNamed: 'PERSON_ID' type: platform int4.	personId beIndexed.	(aTable addForeignKeyFrom: personId to: ((self tableNamed: 'PERSON') fieldNamed: 'ID')).</body><body package="GlorpTestModels">tableForEMAIL_DOMAIN: aTable	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'DOMAIN_NAME' type: (platform varChar: 20).</body><body package="GlorpTestModels">tableForFKADDRESS: aTable 	| contact |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	contact := aTable createFieldNamed: 'CONTACT_ID' type: platform int4.	aTable addForeignKeyFrom: contact		to: ((self tableNamed: 'FKCONTACT') fieldNamed: 'ID')</body><body package="GlorpTestModels">tableForFKCONTACT: aTable 	| address |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	address := aTable createFieldNamed: 'ADDRESS_ID' type: platform int4.	aTable addForeignKeyFrom: address		to: ((self tableNamed: 'FKADDRESS') fieldNamed: 'ID')</body><body package="GlorpTestModels">tableForGR_ADDRESS: aTable 	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'STREET' type: (platform varChar: 20).	aTable createFieldNamed: 'HOUSE_NUM' type: (platform varChar: 20)</body><body package="GlorpTestModels">tableForGR_CUSTOMER: aTable 	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20)</body><body package="GlorpTestModels">tableForITEM_RELATIVE_LOCKS: aTable	"I have two example relative fields.  One (#beRelative sent to field) is not NULLable and has a database default value.  The other (#beRelative sent to field's type) is NULLable (and in this example no dbDefaultValue is set)."	aTable name: 'ITEM_RELATIVE_LOCKS'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	(aTable createFieldNamed: 'QTY' type: platform int4) beRelative.	aTable createFieldNamed: 'TOTAL_SALES' type: (platform number precision:10; scale: 2) beRelative.	(aTable createFieldNamed: 'LOCK1' type: (platform versionFieldFor: platform int4)) beLockKey.	(aTable createFieldNamed: 'LOCK2' type: platform int4) "beLockKey".</body><body package="GlorpTestModels">tableForITEM_WITH_QTY: aTable	"I have two example relative fields.  One (#beRelative sent to field) is not NULLable and has a database default value.  The other (#beRelative sent to field's type) is NULLable (and in this example no dbDefaultValue is set)."	aTable name: 'ITEM_WITH_QTY'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	(aTable createFieldNamed: 'QTY' type: platform int4) beRelative.	aTable createFieldNamed: 'TOTAL_SALES' type: (platform number precision:10; scale: 2) beRelative.</body><body package="GlorpTestModels">tableForMONEY_IMAGINARY_TABLE: aTable	aTable isImaginary: true.	aTable createFieldNamed: 'CURRENCY' type: (platform varChar: 5).	aTable createFieldNamed: 'AMOUNT' type: platform int4</body><body package="GlorpTestModels">tableForPERSON: aTable	| addrId|	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	addrId := aTable createFieldNamed: 'ADDRESS_ID' type: platform int4.	aTable addForeignKeyFrom: addrId to: ((self tableNamed: 'GR_ADDRESS') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForSTUFF: aTable 	(aTable createFieldNamed: 'ID' type: platform inMemorySequence)		bePrimaryKey.	aTable createFieldNamed: 'THING' type: (platform varChar: 20)</body><body package="GlorpTestModels">tableForTRANSFORMED_TIME: aTable	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	aTable createFieldNamed: 'TIMEFIELD' type: platform int4.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels">exampleAccountRow1	| accountTable row |	accountTable := self tableNamed: 'BANK_ACCT'.	row := DatabaseRow newForTable: accountTable.	row at: (accountTable fieldNamed: 'ID') put: 9874.	row at: (accountTable fieldNamed: 'BANK_CODE') put: '1'.	row at: (accountTable fieldNamed: 'BRANCH_NO') put: 2.	row at: (accountTable fieldNamed: 'ACCT_NO') put: '3'.	^row.</body><body package="GlorpTestModels">exampleAccountRow2	| accountTable row |	accountTable := self tableNamed: 'BANK_ACCT'.	row := DatabaseRow newForTable: accountTable.	row at: (accountTable fieldNamed: 'ID') put: 6.	row at: (accountTable fieldNamed: 'BANK_CODE') put: '2'.	row at: (accountTable fieldNamed: 'BRANCH_NO') put: 3.	row at: (accountTable fieldNamed: 'ACCT_NO') put: '4'.	^row.</body><body package="GlorpTestModels">exampleAccountRow3	| accountTable row |	accountTable := self tableNamed: 'BANK_ACCT'.	row := DatabaseRow newForTable: accountTable.	row at: (accountTable fieldNamed: 'ID') put: 22.	row at: (accountTable fieldNamed: 'BANK_CODE') put: '2'.	row at: (accountTable fieldNamed: 'BRANCH_NO') put: 712.	row at: (accountTable fieldNamed: 'ACCT_NO') put: '5551212'.	^row.</body><body package="GlorpTestModels">exampleAddressRow	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 123.	row at: (addressTable fieldNamed: 'STREET') put: 'Paseo Montril'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '10185'.	^row</body><body package="GlorpTestModels">exampleAddressRowForOrdering1	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 1.	row at: (addressTable fieldNamed: 'STREET') put: 'Alpha'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '300'.	^row</body><body package="GlorpTestModels">exampleAddressRowForOrdering2	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 2.	row at: (addressTable fieldNamed: 'STREET') put: 'Beta'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '200'.	^row</body><body package="GlorpTestModels">exampleAddressRowForOrdering3	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 3.	row at: (addressTable fieldNamed: 'STREET') put: 'Gamma'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '100'.	^row</body><body package="GlorpTestModels">exampleAddressRowForOrdering4	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 6.	row at: (addressTable fieldNamed: 'STREET') put: 'Beta'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '120'.	^row</body><body package="GlorpTestModels">exampleAddressRowForOrdering5	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 4.	row at: (addressTable fieldNamed: 'STREET') put: 'Beta'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '130'.	^row</body><body package="GlorpTestModels">exampleAddressRowWithDifferentStreet	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 123.	row at: (addressTable fieldNamed: 'STREET') put: 'Garden of the Gods'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '10185'.	^row</body><body package="GlorpTestModels">exampleBankTransactionRow	| table row |	table := self tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'OWNER_ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'CDN'.	row atFieldNamed: 'AMT_AMT' put: 7.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'USD'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	^row</body><body package="GlorpTestModels">exampleBankTransactionRow2	| table row |	table := self tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'OWNER_ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'EUR'.	row atFieldNamed: 'AMT_AMT' put: 45.	row atFieldNamed: 'SRVC_DESC' put: 'deposit'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'EUR'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 1.	^row</body><body package="GlorpTestModels">exampleCALinkRow1	| linkTable row |	linkTable := self tableNamed: 'CUSTOMER_ACCT_LINK'.	row := DatabaseRow newForTable: linkTable.	row at: (linkTable fieldNamed: 'ACCT_ID') put: 9874.	row at: (linkTable fieldNamed: 'CUSTOMER_ID') put: 27.	^row.</body><body package="GlorpTestModels">exampleCALinkRow2	| linkTable row |	linkTable := self tableNamed: 'CUSTOMER_ACCT_LINK'.	row := DatabaseRow newForTable: linkTable.	row at: (linkTable fieldNamed: 'ACCT_ID') put: 6.	row at: (linkTable fieldNamed: 'CUSTOMER_ID') put: 27.	^row.</body><body package="GlorpTestModels">exampleCALinkRow3	| linkTable row |	linkTable := self tableNamed: 'CUSTOMER_ACCT_LINK'.	row := DatabaseRow newForTable: linkTable.	row at: (linkTable fieldNamed: 'ACCT_ID') put: 22.	row at: (linkTable fieldNamed: 'CUSTOMER_ID') put: 28.	^row.</body><body package="GlorpTestModels">exampleCALinkRow4	| linkTable row |	linkTable := self tableNamed: 'CUSTOMER_ACCT_LINK'.	row := DatabaseRow newForTable: linkTable.	row at: (linkTable fieldNamed: 'ACCT_ID') put: 6.	row at: (linkTable fieldNamed: 'CUSTOMER_ID') put: 28.	^row.</body><body package="GlorpTestModels">exampleCompressedMoneyRow	| table row |	table := self  tableNamed: 'COMPRESSED_MONEY_TABLE'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: 123.	row at: (table fieldNamed: 'AMOUNT') put: 12.	row at: (table fieldNamed: 'CURRENCY_NAME') put: 'CDN'.	^row</body><body package="GlorpTestModels">exampleCompressedMoneyRow2	| table row |	table := self  tableNamed: 'COMPRESSED_MONEY_TABLE'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: 124.	row at: (table fieldNamed: 'AMOUNT') put: 15.	row at: (table fieldNamed: 'CURRENCY_NAME') put: 'CDN'.	^row</body><body package="GlorpTestModels">exampleCustomerRow1	| customerTable row |	customerTable := self tableNamed: 'GR_CUSTOMER'.	row := DatabaseRow newForTable: customerTable.	row at: (customerTable fieldNamed: 'ID') put: 27.	row at: (customerTable fieldNamed: 'NAME') put: 'aCustomer'.	^row.</body><body package="GlorpTestModels">exampleCustomerRow2	| customerTable row |	customerTable := self tableNamed: 'GR_CUSTOMER'.	row := DatabaseRow newForTable: customerTable.	row at: (customerTable fieldNamed: 'ID') put: 28.	row at: (customerTable fieldNamed: 'NAME') put: 'anotherCustomer'.	^row.</body><body package="GlorpTestModels">exampleEmailAddressRow1	| personTable row |	personTable := self tableNamed: 'EMAIL_ADDRESS'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 42.	row at: (personTable fieldNamed: 'USER_NAME') put: 'alan'.	row at: (personTable fieldNamed: 'HOST_NAME') put: 'objectpeople.com'.	row at: (personTable fieldNamed: 'PERSON_ID') put: 3.	^row.</body><body package="GlorpTestModels">exampleEmailAddressRow2	| personTable row |	personTable := self tableNamed: 'EMAIL_ADDRESS'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 54321.	row at: (personTable fieldNamed: 'USER_NAME') put: 'johnson'.	row at: (personTable fieldNamed: 'HOST_NAME') put: 'cs.uiuc.edu'.	row at: (personTable fieldNamed: 'PERSON_ID') put: 3.	^row.</body><body package="GlorpTestModels">exampleFrequentFlyerRow	| ffTable row |	ffTable := self tableNamed: 'FREQUENT_FLYER'.	row := DatabaseRow newForTable: ffTable.	row at: (ffTable fieldNamed: 'ID') put: 1.	row at: (ffTable fieldNamed: 'POINTS') put: 10000.	row at: (ffTable fieldNamed: 'AIRLINE_ID') put: nil.	^row.</body><body package="GlorpTestModels">exampleFrequentFlyerRow2	| ffTable row |	ffTable := self tableNamed: 'FREQUENT_FLYER'.	row := DatabaseRow newForTable: ffTable.	row at: (ffTable fieldNamed: 'ID') put: 2.	row at: (ffTable fieldNamed: 'POINTS') put: 7.	row at: (ffTable fieldNamed: 'AIRLINE_ID') put: nil.	^row.</body><body package="GlorpTestModels">exampleItemRelativeLocksRow1	| itemTable row |	itemTable := self  tableNamed: 'ITEM_RELATIVE_LOCKS'.	row := DatabaseRow newForTable: itemTable.	row at: (itemTable fieldNamed: 'ID') put: 1.	row at: (itemTable fieldNamed: 'NAME') put: 'Thingamabob 1'.	row at: (itemTable fieldNamed: 'QTY') put: '100'.	row at: (itemTable fieldNamed: 'TOTAL_SALES') put: '0'.	row at: (itemTable fieldNamed: 'LOCK1') put: 0.	row at: (itemTable fieldNamed: 'LOCK2') put: 10.	^row</body><body package="GlorpTestModels">exampleItemRelativeLocksRow2	| itemTable row |	itemTable := self  tableNamed: 'ITEM_RELATIVE_LOCKS'.	row := DatabaseRow newForTable: itemTable.	row at: (itemTable fieldNamed: 'ID') put: 2.	row at: (itemTable fieldNamed: 'NAME') put: 'Gizmo 2'.	row at: (itemTable fieldNamed: 'QTY') put: '50'.	row at: (itemTable fieldNamed: 'TOTAL_SALES') put: '500'.	row at: (itemTable fieldNamed: 'LOCK1') put: 1.	row at: (itemTable fieldNamed: 'LOCK2') put: 20.	^row</body><body package="GlorpTestModels">exampleItemWithQtyRow1	| itemTable row |	itemTable := self  tableNamed: 'ITEM_WITH_QTY'.	row := DatabaseRow newForTable: itemTable.	row at: (itemTable fieldNamed: 'ID') put: 1.	row at: (itemTable fieldNamed: 'NAME') put: 'Thingamabob 1'.	row at: (itemTable fieldNamed: 'QTY') put: '100'.	row at: (itemTable fieldNamed: 'TOTAL_SALES') put: '0'.	^row</body><body package="GlorpTestModels">exampleItemWithQtyRow2	| itemTable row |	itemTable := self  tableNamed: 'ITEM_WITH_QTY'.	row := DatabaseRow newForTable: itemTable.	row at: (itemTable fieldNamed: 'ID') put: 2.	row at: (itemTable fieldNamed: 'NAME') put: 'Gizmo 2'.	row at: (itemTable fieldNamed: 'QTY') put: '50'.	row at: (itemTable fieldNamed: 'TOTAL_SALES') put: '500'.	^row</body><body package="GlorpTestModels">exampleModifiedAddressRow	| addressTable row |	addressTable := self  tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: addressTable.	row at: (addressTable fieldNamed: 'ID') put: 123.	row at: (addressTable fieldNamed: 'STREET') put: 'Something Else'.	row at: (addressTable fieldNamed: 'HOUSE_NUM') put: '10185'.	^row</body><body package="GlorpTestModels">examplePassengerRow	| passengerTable row |	passengerTable := self tableNamed: 'PASSENGER'.	row := DatabaseRow newForTable: passengerTable.	row at: (passengerTable fieldNamed: 'ID') put: 1.	row at: (passengerTable fieldNamed: 'NAME') put: 'Some Passenger'.	^row.</body><body package="GlorpTestModels">examplePassengerRow2	| passengerTable row |	passengerTable := self tableNamed: 'PASSENGER'.	row := DatabaseRow newForTable: passengerTable.	row at: (passengerTable fieldNamed: 'ID') put: 2.	row at: (passengerTable fieldNamed: 'NAME') put: 'Another Passenger'.	^row.</body><body package="GlorpTestModels">examplePassengerRowInfrequent	"A passenger who is not a frequent flyer."	| passengerTable row |	passengerTable := self tableNamed: 'PASSENGER'.	row := DatabaseRow newForTable: passengerTable.	row at: (passengerTable fieldNamed: 'ID') put: 3.	row at: (passengerTable fieldNamed: 'NAME') put: 'Rare Passenger'.	^row</body><body package="GlorpTestModels">examplePersonRow1	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 3.	row at: (personTable fieldNamed: 'NAME') put: 'aPerson'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: 123.	^row.</body><body package="GlorpTestModels">examplePersonRow2	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 4.	row at: (personTable fieldNamed: 'NAME') put: 'aPerson'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: nil.	^row.</body><body package="GlorpTestModels">examplePersonRowForOrdering1	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 86.	row at: (personTable fieldNamed: 'NAME') put: 'person1'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: 2.	^row.</body><body package="GlorpTestModels">examplePersonRowForOrdering2	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 87.	row at: (personTable fieldNamed: 'NAME') put: 'person2'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: 3.	^row.</body><body package="GlorpTestModels">examplePersonRowForOrdering3	| personTable row |	personTable := self tableNamed: 'PERSON'.	row := DatabaseRow newForTable: personTable.	row at: (personTable fieldNamed: 'ID') put: 88.	row at: (personTable fieldNamed: 'NAME') put: 'person3'.	row at: (personTable fieldNamed: 'ADDRESS_ID') put: 1.	^row.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>tables/airline</category><body package="GlorpTestModels">tableForAIRLINE: aTable	(aTable createFieldNamed: 'ID' type: platform inMemorySequence) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20)</body><body package="GlorpTestModels">tableForAIRLINE_MEAL: aTable	aTable createFieldNamed: 'ID' type: platform int4.	aTable createFieldNamed: 'DESCR' type: (platform varChar: 20).	aTable createFieldNamed: 'FLIGHT_ID' type: platform int4</body><body package="GlorpTestModels">tableForFLIGHT: aTable	aTable name: 'FLIGHT'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'FLIGHT_NUM' type: platform int4</body><body package="GlorpTestModels">tableForFLIGHT_PASS: aTable	| flight pass airline |	aTable name: 'FLIGHT_PASS'.	flight := aTable createFieldNamed: 'FLIGHT_ID' type: platform int4.	aTable addForeignKeyFrom: flight		to: ((self tableNamed: 'FLIGHT') fieldNamed: 'ID').	pass := aTable createFieldNamed: 'PASS_ID' type: platform int4.	aTable addForeignKeyFrom: pass		to: ((self tableNamed: 'PASSENGER') fieldNamed: 'ID').	airline := aTable createFieldNamed: 'AIRLINE_ID' type: platform int4.	aTable addForeignKeyFrom: airline		to: ((self tableNamed: 'AIRLINE') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForFREQUENT_FLYER: aTable 	| airlineId |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'POINTS' type: platform int4.	airlineId := aTable createFieldNamed: 'AIRLINE_ID' type: platform int4.	aTable addForeignKeyFrom: airlineId to: ((self tableNamed: 'AIRLINE') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForGR_TRAVEL_AGENT: aTable 	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	aTable createFieldNamed: 'AGENT_NAME' type: (platform varchar: 50).	aTable createFieldNamed: 'AGENCY_NAME' type: (platform varchar: 50).</body><body package="GlorpTestModels">tableForITINERARY: aTable 	| res |	(aTable createFieldNamed: 'ID' type: platform serial)		bePrimaryKey.	res := aTable createFieldNamed: 'RES_ID' type: (platform int4).	aTable addForeignKeyFrom: res		to: ((self tableNamed: 'RESERVATION') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForPASSENGER: aTable	| |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20)</body><body package="GlorpTestModels">tableForRESERVATION: aTable 	| pass |	(aTable createFieldNamed: 'ID' type: platform int4)		bePrimaryKey.	pass := aTable createFieldNamed: 'PASS_ID' type: (platform int4).	aTable addForeignKeyFrom: pass		to: ((self tableNamed: 'PASSENGER') fieldNamed: 'ID').</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/bank</category><body package="GlorpTestModels">classModelForGlorpBankAccount: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #accountNumber type: GlorpBankAccountNumber.	aClassModel newAttributeNamed: #accountHolders collectionOf: GlorpCustomer.</body><body package="GlorpTestModels">classModelForGlorpBankAccountNumber: aClassModel	aClassModel newAttributeNamed: #bankCode.	aClassModel newAttributeNamed: #branchNumber.	aClassModel newAttributeNamed: #accountNumber.</body><body package="GlorpTestModels">classModelForGlorpBankBranch: aClassModel	aClassModel newAttributeNamed: #branchNumber.	aClassModel newAttributeNamed: #accounts collectionOf: GlorpBankAccount.</body><body package="GlorpTestModels">classModelForGlorpBankTransaction: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #owner type: GlorpCustomer.	aClassModel newAttributeNamed: #amount type: GlorpMoney.	aClassModel newAttributeNamed: #serviceCharge type: GlorpServiceCharge.</body><body package="GlorpTestModels">classModelForGlorpCustomer: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #transactions collectionOf: GlorpBankTransaction.	aClassModel newAttributeNamed: #accounts collectionOf: GlorpBankAccount.	aClassModel newAttributeNamed: #accountsSortedById collectionOf: GlorpBankAccount.	aClassModel newAttributeNamed: #accountsSortedByIdDescending collectionOf: GlorpBankAccount.</body><body package="GlorpTestModels">classModelForGlorpEmailAddress: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #user.	aClassModel newAttributeNamed: #host.</body><body package="GlorpTestModels">classModelForGlorpEmailDomain: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #topLevelDomain.	aClassModel newAttributeNamed: #addresses type: GlorpEmailAddress.</body><body package="GlorpTestModels">classModelForGlorpMoney: aClassModel	aClassModel newAttributeNamed: #currency.	aClassModel newAttributeNamed: #amount.</body><body package="GlorpTestModels">classModelForGlorpPerson: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #address type: GlorpAddress.	aClassModel newAttributeNamed: #emailAddresses collectionOf: GlorpEmailAddress.</body><body package="GlorpTestModels">classModelForGlorpServiceCharge: aClassModel	aClassModel newAttributeNamed: #description.	aClassModel newAttributeNamed: #amount type: GlorpMoney.</body><body package="GlorpTestModels">descriptorForGlorpBankAccount: aDescriptor 	| table |	table := self tableNamed: 'BANK_ACCT'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id				to: (table fieldNamed: 'ID').	(aDescriptor newMapping: ToManyMapping)				attributeName: #accountHolders;				useLinkTable.	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)				attributeName: #accountNumber.</body><body package="GlorpTestModels">descriptorForGlorpBankAccountNumber: aDescriptor	| table |	table := self tableNamed: 'BANK_ACCT'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #bankCode to: (table fieldNamed: 'BANK_CODE').	(aDescriptor newMapping: DirectMapping) from: #branchNumber to: (table fieldNamed: 'BRANCH_NO').	(aDescriptor newMapping: DirectMapping) from: #accountNumber to: (table fieldNamed: 'ACCT_NO').</body><body package="GlorpTestModels">descriptorForGlorpBankBranch: aDescriptor	| table distinctBranchNumber mapping |	table := self tableNamed: 'BANK_ACCT'.	aDescriptor table: table.	distinctBranchNumber := [:each | ((each getTable: table) getField: (table fieldNamed: 'BRANCH_NO')) distinct] asGlorpExpression.	mapping := aDescriptor newMapping: DirectMapping.	mapping from: #branchNumber to: distinctBranchNumber.	mapping readOnly: true.	aDescriptor keyFields: (Array with: distinctBranchNumber).	(aDescriptor newMapping: ToManyMapping)		attributeName: #accounts;		readOnly: true;		join: (Join				from: distinctBranchNumber				to: (table fieldNamed: 'BRANCH_NO')).</body><body package="GlorpTestModels">descriptorForGlorpBankTransaction: aDescriptor	| table | 	table := self tableNamed: 'BANK_TRANS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id				to: (table fieldNamed: 'ID').	(aDescriptor newMapping: OneToOneMapping)				attributeName: #owner.	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)				attributeName: #amount;				fieldTranslation: ((Join new)							addSource: (table fieldNamed: 'AMT_AMT')								target: ((self tableNamed: 'MONEY_IMAGINARY_TABLE') fieldNamed: 'AMOUNT');							addSource: (table fieldNamed: 'AMT_CURR')								target: ((self tableNamed: 'MONEY_IMAGINARY_TABLE') fieldNamed: 'CURRENCY');							yourself).	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)				attributeName: #serviceCharge.</body><body package="GlorpTestModels">descriptorForGlorpCustomer: aDescriptor	| table |	table := self tableNamed: 'GR_CUSTOMER'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'NAME'); shouldProxy: true.	(aDescriptor newMapping: ToManyMapping)			attributeName: #transactions.	(aDescriptor newMapping: ToManyMapping)			attributeName: #accounts;			useLinkTable.	"Two additional relationships, there to test ordering within a mapping, where the order is determined by a field in the link table"	(aDescriptor newMapping: ToManyMapping)			attributeName: #accountsSortedById;			readOnly: true;			useLinkTable;			orderBy: [:each | (each getTable: 'CUSTOMER_ACCT_LINK') getField: 'ACCT_ID'].	(aDescriptor newMapping: ManyToManyMapping)			attributeName: #accountsSortedByIdDescending;			readOnly: true;			useLinkTable;			orderBy: [:each | ((each getTable: 'CUSTOMER_ACCT_LINK') getField: 'ACCT_ID') descending].</body><body package="GlorpTestModels">descriptorForGlorpEmailAddress: aDescriptor	| table |	table := self tableNamed: 'EMAIL_ADDRESS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #user to: (table fieldNamed: 'USER_NAME').	(aDescriptor newMapping: DirectMapping) from: #host to: (table fieldNamed: 'HOST_NAME').</body><body package="GlorpTestModels">descriptorForGlorpEmailDomain: aDescriptor	| table addresses addressJoinBlock addressJoin |	table := self tableNamed: 'EMAIL_DOMAIN'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #topLevelDomain to: (table fieldNamed: 'DOMAIN_NAME').	addresses := aDescriptor toManyMapping		attributeName: #addresses.	addressJoin := Join new.	addressJoinBlock :=		[:each || field | field := each getField: 'HOST_NAME'.		field copyFrom: (field length - 2) to: field length].	addressJoin		addSource: (table fieldNamed: 'DOMAIN_NAME')		target: (addressJoinBlock asGlorpExpressionOn: (BaseExpression new descriptor: (self descriptorFor: GlorpEmailAddress))).	addresses join: addressJoin.</body><body package="GlorpTestModels">descriptorForGlorpMoney: aDescriptor	| table |	table := self tableNamed: 'MONEY_IMAGINARY_TABLE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #currency type: Symbol to: (table fieldNamed: 'CURRENCY').	(aDescriptor newMapping: DirectMapping) from: #amount to: (table fieldNamed: 'AMOUNT').	^aDescriptor.</body><body package="GlorpTestModels">descriptorForGlorpPerson: aDescriptor	| table |	table := self tableNamed: 'PERSON'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectMapping) fromPseudoVariable: #addressId to: (table fieldNamed: 'ADDRESS_ID').	(aDescriptor newMapping: OneToOneMapping)			attributeName: #address.	(aDescriptor newMapping: ToManyMapping)			attributeName: #emailAddresses;			orderBy: #id.</body><body package="GlorpTestModels">descriptorForGlorpServiceCharge: aDescriptor 		| table |	table := self tableNamed: 'BANK_TRANS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #description				to: (table fieldNamed: 'SRVC_DESC').	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)				attributeName: #amount;				fieldTranslation: ((Join new)							addSource: (table fieldNamed: 'SRVC_AMT_AMT')								target: ((self tableNamed: 'MONEY_IMAGINARY_TABLE') fieldNamed: 'AMOUNT');							addSource: (table fieldNamed: 'SRVC_AMT_CURR')								target: ((self tableNamed: 'MONEY_IMAGINARY_TABLE') fieldNamed: 'CURRENCY');							yourself).</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/airline</category><body package="GlorpTestModels">descriptorForGlorpAirline: aDescriptor 	aDescriptor table: (self tableNamed: 'AIRLINE').	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #name.</body><body package="GlorpTestModels">descriptorForGlorpItinerary: aDescriptor 	aDescriptor table: (self tableNamed: 'ITINERARY').	aDescriptor directMappingFor: #id.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #reservation.</body><body package="GlorpTestModels">descriptorForGlorpPassenger: aDescriptor 	| passTable ffTable ffMiles airlineMapping |	passTable := self tableNamed: 'PASSENGER'.	ffTable := self tableNamed: 'FREQUENT_FLYER'.	aDescriptor table: passTable.	aDescriptor addTable: ffTable.	aDescriptor addMultipleTableJoin: (			Join 			from: (passTable fieldNamed: 'ID')			to: (ffTable fieldNamed: 'ID')) beOuterJoin.	(aDescriptor newMapping: DirectMapping) from: #id to: (passTable fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (passTable fieldNamed: 'NAME').	ffMiles := aDescriptor newMapping: ConditionalMapping.	ffMiles 		forField: (ffTable fieldNamed: 'POINTS')		attribute: [:object | object frequentFlyerPoints]		if: [:x | x notNil]		useMapping: ((ffMiles newMapping: DirectMapping) from: #frequentFlyerMiles to: (ffTable fieldNamed: 'POINTS')).	ffMiles otherwise: (ffMiles newMapping: ConstantMapping).		airlineMapping := aDescriptor newMapping: ConditionalMapping.	airlineMapping		forField: (ffTable fieldNamed: 'AIRLINE_ID')		attribute: [:object | object airline]		if: [:x | x notNil]		useMapping: ((airlineMapping newMapping: OneToOneMapping) attributeName: #airline).	airlineMapping otherwise: (airlineMapping newMapping: ConstantMapping).</body><body package="GlorpTestModels">descriptorForGlorpReservation: aDescriptor 	| table |	table := self tableNamed: 'RESERVATION'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	"The res-&gt;passenger relationship is actually 1-1, but map it as both 1-1 and 1-many so that we can more easily verify that only one object comes back, i.e. that joins are being done correctly"	(aDescriptor newMapping: OneToManyMapping)			attributeName: #passengers.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #passenger.</body><body package="GlorpTestModels">descriptorForGlorpTravelAgency: aDescriptor	| table |	table := self tableNamed: 'GR_TRAVEL_AGENT'.	aDescriptor table: table.	aDescriptor directMapping from: #name to: (table fieldNamed: 'AGENCY_NAME').	aDescriptor toManyMapping			attributeName: #agents;			join: (Join from: (table fieldNamed: 'AGENCY_NAME') to: (table fieldNamed: 'AGENCY_NAME')).</body><body package="GlorpTestModels">descriptorForGlorpTravelAgent: aDescriptor	| table |	table := self tableNamed: 'GR_TRAVEL_AGENT'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	aDescriptor directMapping from: #name to: (table fieldNamed: 'AGENT_NAME').	(aDescriptor newMapping: EmbeddedValueOneToOneMapping)			attributeName: #agency.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>owner</category><body package="GlorpTestModels">descriptorForGlorpOwner: aDescriptor	| table slaveTable |	table := self tableNamed: 'GLORP_OWNER'.	slaveTable := self tableNamed: 'GLORP_SLAVE'.	aDescriptor table: table.	aDescriptor		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID'));		addMapping:				((OneToManyMapping new)						attributeName: #slaves;						referenceClass: GlorpSlave;						collectionType: OrderedCollection;						orderBy:								[:each | (each getTable: 'GLORP_SLAVE') getField: 'POSITION_IN_OWNER'];						writeTheOrderField;						mappingCriteria:								(Join										from: (table fieldNamed: 'ID')										to: (slaveTable fieldNamed: 'OWNER_ID')));		addMapping:				((OneToOneMapping new)						attributeName: #slave;						referenceClass: GlorpSlave;						mappingCriteria:								(Join										from: (table fieldNamed: 'SLAVE_ID')										to: (slaveTable fieldNamed: 'ID'))).</body><body package="GlorpTestModels">descriptorForGlorpSlave: aDescriptor	| table |	table := self tableNamed: 'GLORP_SLAVE'.	aDescriptor table: table.	aDescriptor		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).</body><body package="GlorpTestModels">tableForGLORP_OWNER: aTable	| field |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	field := aTable createFieldNamed: 'SLAVE_ID' type: platform int4.	aTable		addForeignKeyFrom: field		to: ((self tableNamed: 'GLORP_SLAVE') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForGLORP_SLAVE: aTable	| field constraint |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'POSITION_IN_OWNER' type: platform int4.	field := aTable createFieldNamed: 'OWNER_ID' type: platform int4.	"Don't actually create this constraint because it causes a cycle that can confuse our sorting mechanism."	"constraint := aTable		addForeignKeyFrom: field		to: ((self tableNamed: 'GLORP_OWNER') fieldNamed: 'ID').	constraint shouldCreateInDatabase: false."</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/other</category><body package="GlorpTestModels">classModelForDefaultableThing: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #boolean type: Boolean.	aClassModel newAttributeNamed: #integer type: Integer.</body><body package="GlorpTestModels">classModelForGlorpRecordWithUpdateTime: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #updateTime type: Timestamp.	aClassModel newAttributeNamed: #updateSomeOtherThing type: String.</body><body package="GlorpTestModels">descriptorForDefaultableThing: aDescriptor	| table |	table := self tableNamed: 'DEFAULTABLE_THING'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #boolean		to: (table fieldNamed: 'MY_BOOL').	(aDescriptor newMapping: DirectMapping)		from: #integer		to: (table fieldNamed: 'MY_INT').</body><body package="GlorpTestModels">descriptorForGlorpCompressedMoney: aDescriptor 	| table currencyField amountField |	table := self tableNamed: 'COMPRESSED_MONEY_TABLE'.	aDescriptor 		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	currencyField := table fieldNamed: 'CURRENCY_NAME'.	amountField := table fieldNamed: 'AMOUNT'.	aDescriptor table: table.	aDescriptor addMapping: (AdHocMapping 				forAttribute: #array				fromDb: 					[:row :elementBuilder :context| 					Array with: (elementBuilder valueOfField: (context translateField: currencyField))						with: (elementBuilder valueOfField: (context translateField: amountField))]				toDb: 					[:rows :attribute :attributeRows | 					(rows at: table) at: currencyField put: (attribute at: 1).					(rows at: table) at: amountField put: (attribute at: 2)]				mappingFields: (Array with: currencyField with: amountField)).	"Note that position won't work if we have a join. We need to take the elementbuilder into account"	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpItemRelativeLocks: aDescriptor	| table |	table := self tableNamed: 'ITEM_RELATIVE_LOCKS'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	aDescriptor directMapping from: #name to: (table fieldNamed: 'NAME').	aDescriptor directMapping from: #qty to: (table fieldNamed: 'QTY').	aDescriptor directMapping from: #totalSales to: (table fieldNamed: 'TOTAL_SALES').	aDescriptor directMapping from: #lock1 to: (table fieldNamed: 'LOCK1').	aDescriptor directMapping from: #lock2 to: (table fieldNamed: 'LOCK2').</body><body package="GlorpTestModels">descriptorForGlorpItemWithQty: aDescriptor	| table |	table := self tableNamed: 'ITEM_WITH_QTY'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	aDescriptor directMapping from: #name to: (table fieldNamed: 'NAME').	aDescriptor directMapping from: #qty to: (table fieldNamed: 'QTY').	aDescriptor directMapping from: #totalSales to: (table fieldNamed: 'TOTAL_SALES').</body><body package="GlorpTestModels">descriptorForGlorpRecordWithUpdateTime: aDescriptor	| table |	table := self tableNamed: 'RECORD_WITH_UPDATE'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectMapping)		from: #updateTime		to: (table fieldNamed: 'UPDATE_TIME').	(aDescriptor newMapping: DirectMapping)		from: #updateSomeOtherThing		to: (table fieldNamed: 'UPDATE_OTHER_THING').</body><body package="GlorpTestModels">descriptorForGlorpTransformedTime: aDescriptor	"By the time the #fromDb: block is evaluated, the elementBuilder could have been assigned another row, so we use the 'row' parameter, not 'elementBuilder row', and call #valueForField:in:, not valueForField:, in that block."	| table timeField |	table := self tableNamed: 'TRANSFORMED_TIME'.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	timeField := table fieldNamed: 'TIMEFIELD'.	aDescriptor table: table.	aDescriptor addMapping: (AdHocMapping		forAttribute: #time		fromDb:			[:row :elementBuilder :context |			Time fromSeconds: (elementBuilder valueOfField: (context translateField: timeField) in: row)]		toDb:			[:rows :attribute :attributeRows |			(rows at: table) at: timeField put: attribute asSeconds]		mappingFields: (Array with: timeField)).	"Note that position won't work if we have a join. We need to take the elementbuilder into account."	^aDescriptor</body><body package="GlorpTestModels">tableForDEFAULTABLE_THING: aTable 	| boolean converter |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	boolean := aTable createFieldNamed: 'MY_BOOL' type: (platform boolean).	"We want a default value for this field, but we can't just use a boolean, because in some database we can represent that directly, but in others it will need to be converted to an integer. And likewise we can't just use an integer, so we need to do an explicit conversion."	converter := boolean converterForStType: Boolean.	boolean defaultValue: (converter convert: false toDatabaseRepresentationAs: boolean type).	(aTable createFieldNamed: 'MY_INT' type: (platform int4)) defaultValue: 4.</body><body package="GlorpTestModels">tableForRECORD_WITH_UPDATE: aTable 	| |	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	(aTable createFieldNamed: 'NAME' type: (platform varchar: 20)).	aTable createFieldNamed: 'UPDATE_TIME' type: (platform versionFieldFor: platform timestamp) generateOverExistingValues.	"OK, it's not much of a comment, we just print the current time. Note that this field is completely unmapped"	aTable createFieldNamed: 'UPDATE_COMMENT' type: (platform generatorFor: (platform varchar: 20) withBlock: [Time now printString]) generateOverExistingValues.	"But this one *is* mapped"	aTable createFieldNamed: 'UPDATE_OTHER_THING' type: (platform generatorFor: (platform varchar: 20) withBlock: [Time now printString]) generateOverExistingValues.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>class models/airline</category><body package="GlorpTestModels">classModelForGlorpAirline: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.</body><body package="GlorpTestModels">classModelForGlorpItinerary: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #reservation type: GlorpReservation.</body><body package="GlorpTestModels">classModelForGlorpPassenger: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #frequentFlyerMiles.	aClassModel newAttributeNamed: #airline type: GlorpAirline.</body><body package="GlorpTestModels">classModelForGlorpReservation: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #passengers collectionOf: GlorpPassenger.	aClassModel newAttributeNamed: #passenger type: GlorpPassenger.</body><body package="GlorpTestModels">classModelForGlorpTravelAgency: aClassModel	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #agents collectionOf: GlorpTravelAgent.</body><body package="GlorpTestModels">classModelForGlorpTravelAgent: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #agency type: GlorpTravelAgency.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels">allTableNames	^#('GR_ADDRESS' 'PERSON' 'GR_CUSTOMER' 'BANK_TRANS' 'BANK_ACCT' 'CUSTOMER_ACCT_LINK' 'EMAIL_ADDRESS' 'STUFF' 'PASSENGER' 'AIRLINE' 'FREQUENT_FLYER' 'COMPRESSED_MONEY_TABLE' 'RESERVATION' 'ITINERARY' 'TRANSFORMED_TIME' 'FKCONTACT' 'FKADDRESS' 'GLORP_OWNER' 'GLORP_SLAVE' 'TREE_NODE' 'TREE_NODE_LINK' 'RECORD_WITH_UPDATE' 'GR_TRAVEL_AGENT' 'GLORP_SALARIED_EMPLOYEE' 'CITIES' 'CITIES_GRAPH' 'ITEM_WITH_QTY' 'ITEM_RELATIVE_LOCKS').</body><body package="GlorpTestModels">constructAllClasses	"This includes a list of classes as an example, but we don't actually use most of them, because the superclass method will figure it out if the descriptor methods are written in this class."	^(super constructAllClasses) 		add: GlorpAddress;		yourself."	^(super constructAllClasses)		add: GlorpPerson;		add: GlorpAddress;		add: GlorpCustomer;		add: GlorpBankTransaction;		add: GlorpBankAccount;		add: GlorpMoney;		add: GlorpCompressedMoney;		add: GlorpServiceCharge;		add: GlorpBankAccountNumber;		add: GlorpEmailAddress;		add: GlorpPassenger;		add: GlorpAirline;		add: GlorpReservation;		add: GlorpItinerary;		add: GlorpTransformedTime;		add: GlorpBankBranch;		add: GlorpOwner;		add: GlorpSlave;		add: GlorpTreeNode;		add: GlorpRecordWithUpdateTime;		add: GlorpTravelAgent;		add: GlorpTravelAgency;		yourself."</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>standalone domain class</category><body package="GlorpTestModels">classModelForGlorpSalariedEmployee: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #salary.</body><body package="GlorpTestModels">descriptorForGlorpSalariedEmployee: aDescriptor	| table |	table := self tableNamed: 'GLORP_SALARIED_EMPLOYEE'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	aDescriptor directMapping from: #name to: (table fieldNamed: 'NAME').	aDescriptor directMapping from: #salary to: (table fieldNamed: 'SALARY').</body><body package="GlorpTestModels">tableForGLORP_SALARIED_EMPLOYEE: aTable	(aTable createFieldNamed: 'ID' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'SALARY' type: (platform number precision: 9; scale: 4; yourself).</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/tree nodes</category><body package="GlorpTestModels">classModelForGlorpRootNode: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #root type: GlorpTreeNode.</body><body package="GlorpTestModels">classModelForGlorpTreeNode: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #children collectionOf: GlorpTreeNode.	aClassModel newAttributeNamed: #parent type: GlorpTreeNode.</body><body package="GlorpTestModels">descriptorForGlorpRootNode: aDescriptor	| table |	table := self tableNamed: 'ROOT_NODE'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'HOLDER_ID').	aDescriptor oneToOneMapping		attributeName: #root;		referenceClass: GlorpTreeNode;		join: (Join				from: (table fieldNamed: 'ROOT')				to: ((self tableNamed: 'TREE_NODE') fieldNamed: 'ID')).	(aDescriptor directMapping from: #rootID to: (table fieldNamed: 'ROOT')) beForPseudoVariable.</body><body package="GlorpTestModels">descriptorForGlorpTreeNode: aDescriptor	| table |	table := self tableNamed: 'TREE_NODE'.	aDescriptor table: table.	aDescriptor directMappingFor: #id.	aDescriptor toManyMapping		attributeName: #children;		useLinkTable;		join: (Join				from: (table fieldNamed: 'ID')				to: ((self tableNamed: 'TREE_NODE_LINK') fieldNamed: 'PARENT')).	aDescriptor oneToOneMapping		attributeName: #parent;		useLinkTable;		join: (Join				from: (table fieldNamed: 'ID')				to: ((self tableNamed: 'TREE_NODE_LINK') fieldNamed: 'CHILD')).</body><body package="GlorpTestModels">tableForROOT_NODE: aTable	| root |	"Avoid same field name (ID) as TREE_NODE"	(aTable createFieldNamed: 'HOLDER_ID' type: platform int4) bePrimaryKey.	root := aTable createFieldNamed: 'ROOT' type: platform int4.	aTable		addForeignKeyFrom: root		to: ((self tableNamed: 'TREE_NODE') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForTREE_NODE: aTable	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.</body><body package="GlorpTestModels">tableForTREE_NODE_LINK: aTable	| parent child mainTable |	parent := (aTable createFieldNamed: 'PARENT' type: platform int4) bePrimaryKey.	child := (aTable createFieldNamed: 'CHILD' type: platform int4) bePrimaryKey.	mainTable := self tableNamed: 'TREE_NODE'.	aTable		addForeignKeyFrom: parent		to: (mainTable fieldNamed: 'ID').	aTable addForeignKeyFrom: child		to: (mainTable fieldNamed: 'ID').</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>descriptors/city graph</category><body package="GlorpTestModels">classModelForGlorpCitiesGraph: aClassModel	aClassModel newAttributeNamed: #city type: GlorpCity.	aClassModel newAttributeNamed: #nextCity type: GlorpCity.	aClassModel newAttributeNamed: #distance type: Double.</body><body package="GlorpTestModels">classModelForGlorpCity: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #name type: String.	aClassModel newAttributeNamed: #nextCities dictionaryFrom: GlorpCity to: Double.	aClassModel newAttributeNamed: #nextLinkedCities collectionOf: GlorpCity.</body><body package="GlorpTestModels">descriptorForGlorpCitiesGraph: aDescriptor	| graphTable citiesTable |	graphTable := self tableNamed: 'CITIES_GRAPH'.	aDescriptor table: graphTable.	citiesTable := self tableNamed: 'CITIES'.		(aDescriptor newMapping: DirectMapping)		from: #distance		to: (graphTable fieldNamed: 'distance').	aDescriptor oneToOneMapping		attributeName: #city;		join: (Join				from: (graphTable fieldNamed: 'city')				to: (citiesTable fieldNamed: 'id')).					aDescriptor oneToOneMapping		attributeName: #nextCity;		referenceClass: GlorpCity;		join: (Join				from: (graphTable fieldNamed: 'nextCity')				to: (citiesTable fieldNamed: 'id')).	(aDescriptor newMapping: DirectMapping)		from: #cityId		to: (graphTable fieldNamed: 'city');		beForPseudoVariable.		(aDescriptor newMapping: DirectMapping)		from: #nextcityId		to: (graphTable fieldNamed: 'nextcity');		beForPseudoVariable.		"This mapping is used for the link-table-based recursion example. (Not the dictionary-based example)."	aDescriptor toManyMapping		attributeName: #nextCityGraphs;		referenceClass: GlorpCitiesGraph;		useLinkTable;		beForPseudoVariable;		join: (Join				from: (graphTable fieldNamed: 'nextCity')				to: (citiesTable fieldNamed: 'id'));		reverseJoin: (Join					from: (citiesTable fieldNamed: 'id')					to: (graphTable fieldNamed: 'city'));		beForPseudoVariable.</body><body package="GlorpTestModels">descriptorForGlorpCity: aDescriptor	| citiesTable graphTable|	citiesTable := self tableNamed: 'CITIES'.	aDescriptor table: citiesTable.	graphTable := self tableNamed: 'CITIES_GRAPH'.	aDescriptor directMappingFor:  #id.	aDescriptor directMappingFor:  #name.	(aDescriptor newMapping: DirectMapping)		from: #city		to: (citiesTable fieldNamed: 'id');		beForPseudoVariable.			(aDescriptor newMapping: DictionaryMapping)		attributeName: #nextCities;		usesLinkTable: false;		keyField: (graphTable fieldNamed: 'nextCity');		valueField: (graphTable fieldNamed: 'distance');		join: (Join from: (citiesTable fieldNamed: 'id') to: (graphTable fieldNamed: 'city'));		reverseJoin: (Join from: (graphTable fieldNamed: 'nextCity') to: (citiesTable fieldNamed: 'id')).	"This mapping is used for the link-table-based recursion example. (Not the dictionary-based example)."	aDescriptor toManyMapping		attributeName: #nextLinkedCities;		beForPseudoVariable;		useLinkTable;		join: (Join				from: (citiesTable fieldNamed: 'id')				to: (graphTable fieldNamed: 'city'));		reverseJoin: (Join 					from: (graphTable fieldNamed: 'city')					to: (citiesTable fieldNamed: 'id')).</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>class models/other</category><body package="GlorpTestModels">classModelForGlorpItemRelativeLocks: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #qty.	aClassModel newAttributeNamed: #totalSales.	aClassModel newAttributeNamed: #lock1.	aClassModel newAttributeNamed: #lock2.</body><body package="GlorpTestModels">classModelForGlorpItemWithQty: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #qty.	aClassModel newAttributeNamed: #totalSales.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>support</category><body package="GlorpDBTests">writeCustomer1Rows	| linkRow2 id2 id1 accountRow1 customerRow accountRow2 linkRow1 |	customerRow := self exampleCustomerRow1.	accountRow1 := self exampleAccountRow1.	accountRow2 := self exampleAccountRow2.	linkRow1 := self exampleCALinkRow1.	linkRow2 := self exampleCALinkRow2.	session writeRow: customerRow.	session writeRow: accountRow1.	session writeRow: accountRow2.	session writeRow: linkRow1.	session writeRow: linkRow2.	id1 := accountRow1 at: (accountRow1 table fieldNamed: 'ID').	id2 := accountRow2 at: (accountRow2 table fieldNamed: 'ID').	^Array with: id1 with: id2.</body><body package="GlorpDBTests">writeCustomerWithDualAccountOwners	| linkRow2 id2 id1 accountRow1 accountRow2 linkRow1 customer1Row customer2Row linkRow4 |	customer1Row := self exampleCustomerRow1.	customer2Row := self exampleCustomerRow2.	accountRow1 := self exampleAccountRow1.	accountRow2 := self exampleAccountRow2.	linkRow1 := self exampleCALinkRow1.	linkRow2 := self exampleCALinkRow2.	linkRow4 := self exampleCALinkRow4.	session writeRow: customer1Row.	session writeRow: customer2Row.	session writeRow: accountRow1.	session writeRow: accountRow2.	session writeRow: linkRow1.	session writeRow: linkRow2.	session writeRow: linkRow4.	id1 := accountRow1 at: (accountRow1 table fieldNamed: 'ID').	id2 := accountRow2 at: (accountRow2 table fieldNamed: 'ID').	^Array with: id1 with: id2.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem</class-id> <category>test support</category><body package="GlorpTests">testIDLessThan5: aValue	"A test method, used for conditional mapping tests"	^aValue &lt; 5.</body><body package="GlorpTests">testIDMoreThan5: aValue	"A test method, used for conditional mapping tests"	^aValue &gt; 5.</body></methods><methods><class-id>Glorp.GlorpDemoDescriptorSystem class</class-id> <category>accessing</category><body package="GlorpTestModels">default	Default isNil ifTrue: [Default := self new].	^Default</body></methods><methods><class-id>Glorp.GlorpLinkTableAnywhereDescriptorSystem</class-id> <category>descriptors/bank</category><body package="GlorpTestModels">classModelForGlorpCustomer: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #transactions collectionOf: GlorpBankTransaction.	"Note: accounts is a 1-1 in this model"	aClassModel newAttributeNamed: #accounts type: GlorpBankAccount.	aClassModel newAttributeNamed: #accountsSortedById collectionOf: GlorpBankAccount.	aClassModel newAttributeNamed: #accountsSortedByIdDescending collectionOf: GlorpBankAccount.</body><body package="GlorpTestModels">descriptorForGlorpCustomer: aDescriptor	| table |	table := self tableNamed: 'GR_CUSTOMER'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: OneToManyMapping)			attributeName: #transactions;			referenceClass: GlorpBankTransaction.	(aDescriptor newMapping: OneToOneMapping)			attributeName: #accounts;			referenceClass: GlorpBankAccount;			usesLinkTable: true.</body></methods><methods><class-id>Glorp.GlorpTextTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform text</body></methods><methods><class-id>Glorp.GlorpTextTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">longString	"Make a significant sized stringlob. 64k+ a bit should do"	| stream |	stream := WriteStream on: (String new: 10000).	(((2 raisedTo: 16) + 100.0) / 255.0) ceiling timesRepeat: [		stream nextPutAll: self string255].	^stream contents.</body><body package="GlorpDBTypeTests">string255	^'abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstu'.</body><body package="GlorpDBTypeTests">testLargeText	"For Access, the long test here not only fails, it messes up the driver so that other tests fail"	(session platform class == AccessPlatform and: [session useBinding not])		ifTrue: [^self].	self helpTestValue: self longString.</body><body package="GlorpDBTypeTests">testSymbol	"Test that we can store a Symbol as text. This is particularly interesting because then we have to go through a non-empty type converter, and those need to take into account that text type, although a string type, probably doesn't have a maximum width."	stType := Symbol.	self helpTestValue: #'ASymbolStoredAsText'.</body><body package="GlorpDBTypeTests">testText"	self helpTestValue: nil."	self helpTestValue: 'Now is the time for all good squeakers to come to the aid of the mouse'.</body></methods><methods><class-id>Glorp.GlorpTimestampTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform timestamp</body></methods><methods><class-id>Glorp.GlorpTimestampTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">compareTime: read to: original	"GNU Smalltalk seems to be quite alone in following the ANSI standard..."	| zeroDuration max min |	Dialect isGNU ifTrue:		[zeroDuration := (Smalltalk at: #Duration) zero.		^(read offset: zeroDuration) = (original offset: zeroDuration)].	"MS SQL Server fails randomly because it has a resolution of 3 ms only."	session platform class = SQLServerPlatform ifTrue:		[max := original addMilliseconds: 3.		min := original addMilliseconds: -3.		^read between: min and: max].	"Otherwise"	^session platform supportsMillisecondsInTimes 		ifTrue: [read = original]		ifFalse: [read = original or: [read = (original addMilliseconds: (-1 * original milliseconds)) or: [read asSeconds = original asSeconds]]]</body><body package="GlorpDBTypeTests">testTimeStamp	"This has to be UTC because postgres has time zones and will try and compensate"	| time |	time := Dialect timestampNow.	self helpTestValue: nil.	self		helpTestValue: time		compareWith:			[:read :original | 			"MS SQL Server fails randomly because it has a resolution of 3 ms only."			"GNU Smalltalk seems to be quite lone in following the ANSI standard..."			self compareTime: read to: original].</body><body package="GlorpDBTypeTests">testTimeStampBetweenAnd	| record time newRecord |	session system: (GlorpDemoDescriptorSystem forPlatform: session platform).	self		inTransactionDo:			[record := (GlorpRecordWithUpdateTime new)				id: 12;				name: 'thing'.			session modify: record in: [].			session reset.			record := session readOneOf: GlorpRecordWithUpdateTime.			time := record updateTime.			session reset.			newRecord := session				readOneOf: GlorpRecordWithUpdateTime				where:					[:each | 					each updateTime						between: (time subtractSeconds: 1)						and: (time addSeconds: 1)].			self assert: newRecord id = record id.].</body><body package="GlorpDBTypeTests">testTimeStampCast	"SQLite does not have time-related types:  they are all mapped to strings.  I have not debugged why this test fails yet but assume it is completely unrealistic to expect a string to be cast to a timestamp."	| timestamp model |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding testTimestampCast for VisualAge'. ^self].	timestamp := Dialect timestampNow.	"Since VW moved to nanosend-granularity Timestamps, the		timestamp millisecond: 0	call we used to make here no longer suffices to round for all platforms.  In particular, OraclePlatform&gt;&gt;timestamp returns the 'DATE' type;  casting to Oracle DATE loses all data below seconds.  We therefore truncate the timestamp to seconds in what is (or can be made in Glorp*Port) a dialect-neutral way."	timestamp := timestamp class fromSeconds: timestamp asSeconds.	session transact: [session register: (GlorpTypeTestsModelClass new test: timestamp)].	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test cast: session platform timestamp) = timestamp].	self deny: model isNil		description: 'This test will fail on SQLite which has no DB Timestamp type;  see test comment'.	self assert: (self compareTime: model test to: timestamp).	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test cast: session platform date) = timestamp].	self deny: model isNil.	self assert: (self compareTime: model test to: timestamp).	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | each test asTimestamp = timestamp].	self deny: model isNil.	self assert: (self compareTime: model test to: timestamp).</body><body package="GlorpDBTypeTests">testTimeStampCompare	| record time newRecord |	session system: (GlorpDemoDescriptorSystem forPlatform: session platform).	self		inTransactionDo:			[record := (GlorpRecordWithUpdateTime new)				id: 12;				name: 'thing'.			session modify: record in: [].			session reset.			record := session readOneOf: GlorpRecordWithUpdateTime.			time := record updateTime.			session reset.			newRecord := session				readOneOf: GlorpRecordWithUpdateTime				where:					[:each | 						(each updateTime &gt; (time subtractSeconds: 1))						&amp; (each updateTime &lt; (time addSeconds: 1))].			self assert: newRecord id = record id].</body></methods><methods><class-id>Glorp.GlorpTimestampWithTimeZoneTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	"For now, non-supporting platforms just repeat the superclass' tests.  Later, raise explicit test skip for non-supporting platforms."	self platform isPostgreSQLPlatform ifTrue: [^self platform timestamptz].	^super defaultDatabaseType</body></methods><methods><class-id>Glorp.GlorpTimestampWithTimeZoneTest</class-id> <category>setUp</category><body package="GlorpDBTypeTests">setUp	| exdiConnection tz |	super setUp.	self platform isPostgreSQLPlatform ifTrue:		[exdiConnection := connection connection.		priorTimeZone := exdiConnection timezone.		tz := exdiConnection suggestedDefaultTimeZone.		exdiConnection timezone: tz].</body><body package="GlorpDBTypeTests">tearDown	| exdiConnection |	self platform isPostgreSQLPlatform ifTrue:		[exdiConnection := connection connection.		exdiConnection timezone: priorTimeZone].	super tearDown.</body></methods><methods><class-id>Glorp.GlorpObjectComparisonJoinsTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session system useJoinsForAnySatisfy: true.	session beginTransaction.	itinerary1 := GlorpItinerary example1.	itinerary2 := GlorpItinerary example2.	itinerary2 reservation passenger: nil.	itinerary2 reservation passengers: #().	session transact: [		session register: itinerary1.		session register: itinerary2].</body><body package="GlorpDBTests">tearDown		session rollbackTransaction.	itinerary1 := nil.	itinerary2 := nil.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpObjectComparisonJoinsTest</class-id> <category>tests</category><body package="GlorpDBTests">testBasicEqualNil	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passenger isNIL].	self assert: reservations size = 1.	self assert: reservations first id = 7.</body><body package="GlorpDBTests">testBasicNotNil	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passenger notNIL].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests">testEqualNil	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger isNIL]].	self assert: reservations size = 1.	self assert: reservations first id = 7.</body><body package="GlorpDBTests">testEqualToIdsInExpression	"Just to verify that this works when not directly comparing objects"	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger id = each passenger id]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests">testEqualToObjectInExpression	"A somewhat contrived example of comparing two relationships that should end up with the same object, because they're actually mapped the same way. But will fail if the passenger is nil"	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger = each passenger]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests">testEqualToObjectInMemory	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger = itinerary1 reservation passenger]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests">testNotEqualToObjectInExpression	"A somewhat contrived example of comparing two relationships that should end up with the same object, because they're actually mapped the same way. But will fail if the passenger is nil, because nil ~= nil"	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger ~= each passenger]].	self assert: reservations isEmpty.</body><body package="GlorpDBTests">testNotEqualToObjectInMemory	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger ~= (GlorpPassenger new id: 7)]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body><body package="GlorpDBTests">testNotNil	| reservations |	reservations := session read: GlorpReservation where: [:each |		each passengers anySatisfy: [:eachPassenger | eachPassenger notNIL]].	self assert: reservations size = 1.	self assert: reservations first id = 2.	self assert: reservations first passenger id = 3.</body></methods><methods><class-id>Glorp.GlorpObjectComparisonSubselectTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session system useJoinsForAnySatisfy: false.</body></methods><methods><class-id>Glorp.ClassC</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassC	^attrAClassC</body><body package="GlorpTestModels">attrAClassC: anObject	attrAClassC := anObject</body><body package="GlorpTestModels">attrBClassC	^attrBClassC</body><body package="GlorpTestModels">attrBClassC: anObject	attrBClassC := anObject</body></methods><methods><class-id>Glorp.ClassC</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassC := nil.	attrBClassC := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.ClassC class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpBankAccount</class-id> <category>accessing</category><body package="GlorpTestModels">accountHolders	^accountHolders.</body><body package="GlorpTestModels">accountNumber	^accountNumber</body><body package="GlorpTestModels">accountNumber: anAccountNumber 	accountNumber := anAccountNumber</body><body package="GlorpTestModels">basicAddHolder: aCustomer	accountHolders add: aCustomer.</body><body package="GlorpTestModels">basicRemoveHolder: aCustomer	accountHolders remove: aCustomer.</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpBankAccount</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream 		nextPutAll: '(id=';		print: id;		nextPut: $).</body></methods><methods><class-id>Glorp.GlorpBankAccount</class-id> <category>initialize</category><body package="GlorpTestModels">initialize	accountHolders := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpBankAccount</class-id> <category>comparing</category><body package="GlorpTestModels">&lt;= anAccount	^self accountNumber accountNumber &lt;= anAccount accountNumber accountNumber.</body></methods><methods><class-id>Glorp.GlorpBankAccount class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new 		id: 123;		accountNumber: GlorpBankAccountNumber example12345.</body></methods><methods><class-id>Glorp.GlorpBankAccount class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.ClassA</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassA	^attrAClassA</body><body package="GlorpTestModels">attrAClassA: anObject	attrAClassA := anObject</body><body package="GlorpTestModels">attrBClassA	^attrBClassA</body><body package="GlorpTestModels">attrBClassA: anObject	attrBClassA := anObject</body><body package="GlorpTestModels">attrCClassA	^attrCClassA</body><body package="GlorpTestModels">attrCClassA: anObject	attrCClassA := anObject</body><body package="GlorpTestModels">attrDClassA	^attrDClassA</body><body package="GlorpTestModels">attrDClassA: anObject	attrDClassA := anObject</body><body package="GlorpTestModels">attrEClassA	^attrEClassA</body><body package="GlorpTestModels">attrEClassA: aBoolean	attrEClassA := aBoolean.</body><body package="GlorpTestModels">attrFClassA	^attrFClassA</body><body package="GlorpTestModels">attrFClassA: anObject	attrFClassA := anObject</body><body package="GlorpTestModels">attrGClassA	^attrGClassA</body><body package="GlorpTestModels">attrGClassA: anObject	attrGClassA := anObject</body><body package="GlorpTestModels">attrHClassA	^attrHClassA</body><body package="GlorpTestModels">attrHClassA: aBoolean	attrHClassA := aBoolean.</body></methods><methods><class-id>Glorp.ClassA</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	attrFClassA := OrderedCollection new.</body><body package="GlorpTestModels">newClassB	| newClassB |	newClassB := ClassB new.	attrFClassA add: newClassB.	^newClassB</body><body package="GlorpTestModels">newClassI	| newClassI |	newClassI := ClassI new.	attrGClassA add: newClassI.	^newClassI</body></methods><methods><class-id>Glorp.ClassA</class-id> <category>testing</category><body package="GlorpTestModels">hasClassBWithPK: aClassBPKVal	^self attrFClassA anySatisfy: [:classB | classB attrAClassB = aClassBPKVal]</body><body package="GlorpTestModels">hasClassIWithClassC: aClassCObj	^self attrGClassA anySatisfy: [:classI | classI attrBClassI = aClassCObj]</body></methods><methods><class-id>Glorp.ClassA class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.ASOrderLineItem</class-id> <category>accessing</category><body package="GlorpTestModels">item	^item</body><body package="GlorpTestModels">item: anObject	item := anObject</body><body package="GlorpTestModels">order	^order</body><body package="GlorpTestModels">order: anObject	order := anObject</body><body package="GlorpTestModels">posNo	^posNo</body><body package="GlorpTestModels">posNo: anObject	posNo := anObject</body><body package="GlorpTestModels">price	^price</body><body package="GlorpTestModels">price: anObject	price := anObject</body><body package="GlorpTestModels">quantity	^quantity</body><body package="GlorpTestModels">quantity: anObject	quantity := anObject</body></methods><methods><class-id>Glorp.ClassJ</class-id> <category>accessing</category><body package="GlorpTestModels">addK: aKObj	attrCClassJ ifNil: [attrCClassJ := OrderedCollection new].	attrCClassJ add: aKObj.</body><body package="GlorpTestModels">attrAClassJ	^attrAClassJ</body><body package="GlorpTestModels">attrAClassJ: anObject	attrAClassJ := anObject</body><body package="GlorpTestModels">attrBClassJ	^attrBClassJ</body><body package="GlorpTestModels">attrBClassJ: anObject	attrBClassJ := anObject</body><body package="GlorpTestModels">attrCClassJ	^attrCClassJ</body><body package="GlorpTestModels">attrCClassJ: anObject	attrCClassJ := anObject</body></methods><methods><class-id>Glorp.ClassJ</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassJ := nil.	attrBClassJ := nil.	attrCClassJ := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.ClassJ class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpCompressedMoney</class-id> <category>accessing</category><body package="GlorpTestModels">amount	^array at: 2</body><body package="GlorpTestModels">amount: anObject	array at: 2 put: anObject</body><body package="GlorpTestModels">currency	^array at: 1</body><body package="GlorpTestModels">currency: anObject	array at: 1 put: anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpCompressedMoney</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		print: self amount;		space;		nextPutAll: self currency;		nextPut: $).</body></methods><methods><class-id>Glorp.GlorpCompressedMoney</class-id> <category>initialize</category><body package="GlorpTestModels">initialize	array := Array new: 2.</body></methods><methods><class-id>Glorp.GlorpCompressedMoney class</class-id> <category>instance creation</category><body package="GlorpTestModels">currency: aSymbol amount: aNumber	^super new initialize		currency: aSymbol;		amount: aNumber.</body><body package="GlorpTestModels">defaultCurrency	^#CDN.</body><body package="GlorpTestModels">forAmount: aNumber	^self currency: self defaultCurrency amount: aNumber.</body><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDatabaseSessionTest</class-id> <category>tests</category><body package="GlorpDBTests">testWriteRow	| rowToWrite fields rowReadFromDatabase |	rowToWrite := session system examplePersonRow2.		[session beginTransaction.	session writeRow: rowToWrite.	rowReadFromDatabase := (session accessor				executeSQLString: 'SELECT * FROM ' , rowToWrite table name) first.	fields := rowToWrite table fields.	(1 to: fields size) with: fields		do: [:index :field | self assert: (rowReadFromDatabase atIndex: index) = (rowToWrite at: field)]] 			ensure: [session rollbackTransaction]</body></methods><methods><class-id>Glorp.GlorpDatabaseSessionTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpDatabaseSessionTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.ASItem</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	bonuses := OrderedCollection new.</body></methods><methods><class-id>Glorp.ASItem</class-id> <category>accessing</category><body package="GlorpTestModels">bonuses	^bonuses</body><body package="GlorpTestModels">bonuses: anObject	bonuses := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.ASItem class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>support</category><body package="GlorpDBTests">checkExpiryTime	""	| rowToWrite address modifiedRow expiryTime newExpiryTime |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	expiryTime := ((session cacheFor: address) basicAt: 123 ifAbsent: [#(nil)]) at: 1.	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	(Delay forSeconds: 1) wait.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	newExpiryTime := ((session cacheFor: address) basicAt: 123 ifAbsent: [#(nil)]) at: 1.	self assert: newExpiryTime &gt; expiryTime.	self assert: address street = 'Paseo Montril'] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">checkExpiryTime: aBlock	""	| rowToWrite address modifiedRow expiryTime newExpiryTime |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	expiryTime := ((session cacheFor: address) basicAt: 123 ifAbsent: [#(nil)]) at: 1.	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	(Delay forSeconds: 1) wait.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	newExpiryTime := ((session cacheFor: address) basicAt: 123 ifAbsent: [#(nil)]) at: 1.	aBlock value: expiryTime value: newExpiryTime value: address] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">checkRefreshDoing: aBlock	"Check that we refresh correctly doing the action specified by aBlock"	| rowToWrite address modifiedRow |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	aBlock value: address.	self assert: address street = 'Something Else'.] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">helperForTestReadEmbeddedOneToOne	| transRow query result |		[session beginTransaction.	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	query := Query readOneOf: GlorpBankTransaction				where: [:each | each id = each id].	result := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: result serviceCharge notNil.	self assert: result serviceCharge description = 'additional overcharge'.	self assert: result amount currency = #CDN.	self assert: result amount amount = 7.	self assert: result serviceCharge amount currency = #USD.	self assert: result serviceCharge amount amount = 2.	^result.</body><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	system := session system.</body><body package="GlorpDBTests">tearDown	super tearDown.	session reset.	session := nil.	system := nil.</body><body package="GlorpDBTests">write2CustomerRowsWith3Transactions	| table row aGlorpDemoDescriptorSystem |	session system writeCustomerWithDualAccountOwners.	aGlorpDemoDescriptorSystem := session system.	table := aGlorpDemoDescriptorSystem tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'CDN'.	row atFieldNamed: 'AMT_AMT' put: 9.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'CHF'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 27.	session writeRow: row.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'USD'.	row atFieldNamed: 'AMT_AMT' put: 10.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'CHF'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 27.	session writeRow: row.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'EUR'.	row atFieldNamed: 'AMT_AMT' put: 11.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'EUR'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 28.	session writeRow: row.</body><body package="GlorpDBTests">writeCustomer1Rows	^system writeCustomer1Rows.</body><body package="GlorpDBTests">writeCustomer1RowsWith2Transactions	| table row aGlorpDemoDescriptorSystem |	self writeCustomer1RowsWithTransactions.	aGlorpDemoDescriptorSystem := session system.	table := aGlorpDemoDescriptorSystem tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'USD'.	row atFieldNamed: 'AMT_AMT' put: 9.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'CHF'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 27.	session writeRow: row.</body><body package="GlorpDBTests">writeCustomer1RowsWithTransactions	| table row aGlorpDemoDescriptorSystem |	self writeCustomer1Rows.	aGlorpDemoDescriptorSystem := session system.	table := aGlorpDemoDescriptorSystem tableNamed: 'BANK_TRANS'.	row := DatabaseRow newForTable: table.	row atFieldNamed: 'ID' put: nil.	row atFieldNamed: 'AMT_CURR' put: 'CDN'.	row atFieldNamed: 'AMT_AMT' put: 7.	row atFieldNamed: 'SRVC_DESC' put: 'additional overcharge'.	row atFieldNamed: 'SRVC_AMT_CURR' put: 'USD'.	row atFieldNamed: 'SRVC_AMT_AMT' put: 2.	row atFieldNamed: 'OWNER_ID' put: 27.	session writeRow: row.</body><body package="GlorpDBTests">writeReservationData	"This test inserts data that includes multiple rows with an identity column, namely the itinerary instances.  This can help testing isIdentiotyColumn-related effects.  If, with loggingEnabled, you see the test generating a single round trip to the database for both itineraries via a seqence of statements such as	INSERT INTO public.ITINERARY (ID,RES_ID)  VALUES (221,2); INSERT INTO public.ITINERARY (ID,RES_ID)  VALUES (222,7)or a single statement with a sequence of values or a bound array, then either the serial type of the platform under test does not use identity columns or the server-side assignment of ids is being retrieved by Glorp.  If separate statements are sent, with intervening statements that retrieve the id of each, then the serial type (or Glorp's use of it) is imposing a performance cost by preventing group writing."	session beginUnitOfWork.	session register: GlorpItinerary example1.	session register: GlorpItinerary example2.	session commitUnitOfWork.	session writeRow: session system examplePassengerRow.	session initializeCache.</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests-refreshing</category><body package="GlorpDBTests">testExpiryTimeNotReset	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeout: 3.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkExpiryTime:		[:expiryTime :newExpiryTime :address |		self assert: newExpiryTime = expiryTime.		self assert: address street = 'Paseo Montril'].</body><body package="GlorpDBTests">testExpiryTimeReset	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeout: 4.	cachePolicy expiryAction: #remove.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkExpiryTime:		[:expiryTime :newExpiryTime :address |		self assert: newExpiryTime &gt; expiryTime.		self assert: address street = 'Paseo Montril'].</body><body package="GlorpDBTests">testExpiryTimeReset2	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeout: 4.	cachePolicy expiryAction: #notifyAndRemove.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkExpiryTime:		[:expiryTime :newExpiryTime :address |		self assert: newExpiryTime &gt; expiryTime.		self assert: address street = 'Paseo Montril'].</body><body package="GlorpDBTests">testNonRefreshAddress	"Test that if we don't set the refresh flag on the query we don't re-read the data"	| query rowToWrite address modifiedRow |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	query := Query readOneOf: GlorpAddress where: [:each | each id = 123].	query executeIn: session.	self assert: address street = 'Paseo Montril'.] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testRefreshAddress	"Check that we refresh correctly when the refresh flag is set"	| query rowToWrite address modifiedRow |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	address := session readOneOf: GlorpAddress				where: [:each | each id = 123].	modifiedRow := session system exampleModifiedAddressRow.	modifiedRow owner: address. "Otherwise it thinks it's an insert"	session writeRow: modifiedRow.	query := Query readOneOf: GlorpAddress where: [:each | each id = 123].	query shouldRefresh: true.	query executeIn: session.	self assert: address street = 'Something Else'.] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testSessionRefresh	"Check that we refresh correctly when the refresh flag is set"	self checkRefreshDoing: [:anAddress | session refresh: anAddress].</body><body package="GlorpDBTests">testSessionRefreshOnExpiry	"Check that we refresh correctly when an object has expired"	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeout: 0.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkRefreshDoing: [:anAddress |		session readOneOf: GlorpAddress where: [:each | each id = 123]].</body><body package="GlorpDBTests">testSessionRefreshOnExpiryWithCacheLookupOnly	"Check that we refresh correctly when an object has expired, doing only a cache lookup, not an explicit read"	| cachePolicy |	cachePolicy := TimedExpiryCachePolicy new.	cachePolicy timeout: 0.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkRefreshDoing: [:anAddress |		session privateGetCache lookupClass: GlorpAddress key: 123 ifAbsent: [nil]].</body><body package="GlorpDBTests">testSessionRefreshOnProxyExpiry	"Check that we refresh correctly when an object has expired"	| cachePolicy |	cachePolicy := TimedStrongCachePolicy new.	cachePolicy timeout: 0.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkRefreshDoing: [:anAddress |		session readOneOf: GlorpAddress where: [:each | each id = 123]].</body><body package="GlorpDBTests">testSessionRefreshOnProxyExpiryWithCacheLookupOnly	"Check that we refresh correctly when an object has expired, doing only a cache lookup, not an explicit read"	| cachePolicy |	cachePolicy := TimedStrongCachePolicy new.	cachePolicy timeout: 0.	cachePolicy expiryAction: #refresh.	(session descriptorFor: GlorpAddress) cachePolicy: cachePolicy.	self checkRefreshDoing: [:anAddress |		session privateGetCache lookupClass: GlorpAddress key: 123 ifAbsent: [nil]].</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests</category><body package="GlorpDBTests">testCompoundAND	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query read: GlorpAddress				where: [:address | address id &lt; 124 AND: (address id  &gt; 122) AND: (address id ~= nil)].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests">testConversionOnConstantQueryParams	| query result transRow | 		[	session beginTransaction.	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	query := Query read: GlorpBankTransaction where: [:trans | trans amount currency = #CDN].	result := session execute: query.	self assert: result size = 1.	self assert: result first amount amount = 7] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testConversionOnConstantQueryParams2	| query result transRow |		[	session beginTransaction.	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	query := Query read: GlorpBankTransaction where: [:trans | trans amount amount = 7].	result := session execute: query.	self assert: result size = 1.	self assert: result first amount amount = 7] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testDeleteWithEmbedded	| transaction uow |		[session beginTransaction.	session beginUnitOfWork.	self writeCustomer1RowsWithTransactions.	transaction := (session read: GlorpBankTransaction) first.	session delete: transaction.	uow := session privateGetCurrentUnitOfWork.	self assert: (uow willDelete: transaction).	self assert: (uow willDelete: transaction amount).	self assert: (uow willDelete: transaction serviceCharge).	self assert: (uow willDelete: transaction serviceCharge amount).	session commitUnitOfWork] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testDeletedObjectsNotReadInManyQuery	| query anAccount accounts someAccountId |	[session beginTransaction.	someAccountId := self writeCustomer1Rows first.	session beginUnitOfWork.	query := Query readOneOf: GlorpBankAccount				where: [:each | each id = someAccountId].	anAccount := session execute: query.	self assert: anAccount class == GlorpBankAccount.	self assert: anAccount id = someAccountId.	session delete: anAccount.	accounts := session read: GlorpBankAccount.	self assert: accounts size = 1.	self deny: (accounts includes: anAccount).	self deny: (accounts anySatisfy: [:each | each id = someAccountId]).] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testDeletedObjectsNotReadInOneQuery	| query anAccount someAccountId account |	[session beginTransaction.	someAccountId := self writeCustomer1Rows first.	session beginUnitOfWork.	query := Query readOneOf: GlorpBankAccount				where: [:each | each id = someAccountId].	anAccount := session execute: query.	self assert: anAccount class == GlorpBankAccount.	self assert: anAccount id = someAccountId.	session delete: anAccount.	account := session readOneOf: GlorpBankAccount where: [:each | each id = someAccountId].	self assert: account isNil] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testNonIntrusiveAlsoFetch	| alsoFetchQuery query results | 	"If a platform has no outer joins (!) we cannot execute this test."	(session system platform supportsANSIJoins	or: [session system platform useMicrosoftOuterJoins	or: [session system platform useOracleOuterJoins ]])		ifFalse: [^self].	[session beginTransaction.	session beginUnitOfWork.	session register: GlorpPerson example1.	session register: (GlorpPerson example1							id: 2;							address: nil;							yourself).	session commitUnitOfWork.	alsoFetchQuery := Query						read: GlorpPerson						where: nil.	alsoFetchQuery alsoFetch: [:ea | ea address beOuterJoin].	query := Query					read: GlorpPerson					where: nil.	results := alsoFetchQuery executeIn: session.	self assert: results size = 2.	results := query executeIn: session.	self assert: results size = 2] 			ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testQueryHasLimit	self deny: (SimpleQuery read: GlorpAddress) hasLimit.	self assert: (SimpleQuery read: GlorpAddress limit: 10) hasLimit.	self assert: (SimpleQuery read: GlorpAddress limit: -10) hasLimit.	self assert: (SimpleQuery read: GlorpAddress) limitMakesSense.	self assert: (SimpleQuery read: GlorpAddress limit: 10) limitMakesSense.	self deny: (SimpleQuery read: GlorpAddress limit: 0) limitMakesSense.	self deny: (SimpleQuery read: GlorpAddress limit: -10) limitMakesSense.</body><body package="GlorpDBTests">testQueryHasOffset	self deny: (SimpleQuery read: GlorpAddress) hasOffset.	self assert: ((SimpleQuery read: GlorpAddress) offset: 10; yourself) hasOffset.	self deny: ((SimpleQuery read: GlorpAddress) offset: 0; yourself) hasOffset.	self deny: ((SimpleQuery read: GlorpAddress) offset: -10; yourself) hasOffset.</body><body package="GlorpDBTests">testReadAccountsWithCompoundAnySatisfyExists	| query result |		[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			account accountHolders anySatisfyExists: [:each | (each id = 27) &amp; (each name = 'aCustomer')]].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithCompoundAnySatisfyJoin	| query result |		[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			account accountHolders anySatisfyJoin: [:each | (each id = 27) &amp; (each name = 'aCustomer')]].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithMultipleAnySatisfyExists	| query result |	 	[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyExists: [:each | each id = 24]) 				| (account accountHolders anySatisfyExists: [:each | each id = 27])].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithMultipleAnySatisfyJoin	| query result |	 	[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyJoin: [:each | each id = 24]) 				| (account accountHolders anySatisfyJoin: [:each | each id = 27])].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithMultipleAnySatisfyMixed1	| query result |	 	[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyJoin: [:each | each id = 24]) 				| (account accountHolders anySatisfyExists: [:each | each id = 27])].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithMultipleAnySatisfyMixed2	| query result |	 	[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyExists: [:each | each id = 24]) 				| (account accountHolders anySatisfyJoin: [:each | each id = 27])].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithNestedAnySatisfyExists	| query result |	[| block |	session beginTransaction.	self writeCustomer1RowsWithTransactions.	block := 			[:account | 			account accountHolders anySatisfyExists: [:each | each transactions anySatisfyExists: [:eachTrans |			eachTrans id ~= nil]]].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithNestedAnySatisfyJoin	| query result |	[| block |	session beginTransaction.	self writeCustomer1RowsWithTransactions.	block := 			[:account | 			account accountHolders anySatisfyJoin: [:each | each transactions anySatisfyJoin: [:eachTrans |			eachTrans id ~= nil]]].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithNestedAnySatisfyMixed1	| query result |	[| block |	session beginTransaction.	self writeCustomer1RowsWithTransactions.	block := 			[:account | 			account accountHolders anySatisfyExists: [:each | each transactions anySatisfyJoin: [:eachTrans |			eachTrans id ~= nil]]].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithNestedAnySatisfyMixed2	| query result |	[| block |	session beginTransaction.	self writeCustomer1RowsWithTransactions.	block := 			[:account | 			account accountHolders anySatisfyJoin: [:each | each transactions anySatisfyExists: [:eachTrans |			eachTrans id ~= nil]]].	query := Query read: GlorpBankAccount where: block.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAccountsWithVirtualCollectionAndAlsoFetch	| query result |	 	[| block |	((session system descriptorFor: GlorpBankAccount) mappingForAttributeNamed: #accountHolders) collectionType: GlorpVirtualCollection.	session beginTransaction.	self writeCustomer1Rows.	block := 			[:account | 			(account accountHolders anySatisfyExists: [:each | each id = 24]) 				| (account accountHolders anySatisfyJoin: [:each | each id = 27])].	query := Query read: GlorpBankAccount where: block.	query alsoFetch: #accountHolders.	result := session execute: query.	self assert: result size = 2.	self assert: result first accountHolders class == OrderedCollection] 			ensure: [				((session system descriptorFor: GlorpBankAccount) mappingForAttributeNamed: #accountHolders) collectionType: OrderedCollection.				session rollbackTransaction]</body><body package="GlorpDBTests">testReadAdHoc 	| queryTime table row time idField times |		[	session beginTransaction.		table := session system tableNamed: 'TRANSFORMED_TIME'.	row := DatabaseRow newForTable: table.	idField := (table fieldNamed: 'ID').	row at: idField put: 3.	time := Time now.	row at: (table fieldNamed: 'TIMEFIELD') put: time asSeconds.	session writeRow: row.	queryTime := GlorpTransformedTime  new id: 3; time: time.	times := session read: GlorpTransformedTime where: [:each | each time = time].	self assert: times size = 1.	self assert: times first time asSeconds = time asSeconds.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAdHocProxied	| table row time idField times time2 |	((session system descriptorFor: GlorpTransformedTime) mappingForAttributeNamed: #time) shouldProxy: true.	[	session beginTransaction.		table := session system tableNamed: 'TRANSFORMED_TIME'.	row := DatabaseRow newForTable: table.	idField := (table fieldNamed: 'ID').	row at: idField put: 3.	time := Time now.	row at: (table fieldNamed: 'TIMEFIELD') put: time asSeconds.	session writeRow: row.	row := DatabaseRow newForTable: table.	row at: idField put: 4.	time2 := Dialect addSeconds: 10 to: Time now.	row at: (table fieldNamed: 'TIMEFIELD') put: time2 asSeconds.	session writeRow: row.	times := session read: GlorpTransformedTime orderBy: [:each | each time].	self assert: times size = 2.	self assert: times first time class == AdHocProxy.	self assert: times first time asSeconds = time asSeconds.	self assert: times last time asSeconds = time2 asSeconds.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadAddress	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query read: GlorpAddress				where: [:address | address id = 123].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests">testReadAddressProxy	| object query results rowToWrite proxy | 	[session beginTransaction.		rowToWrite := session system exampleAddressRow.		session writeRow: rowToWrite.		query := (Query			read: GlorpAddress			where: ([:address | address id = 123]) ) returnProxies: true.		results := query executeIn: session.		self assert: (results size = 1).		proxy := results first.		object := proxy getValue]	ensure: [session rollbackTransaction].	self assert: (proxy isGlorpProxy).	self assert: (object class = GlorpAddress).	self assert: (object id = 123).	self assert: (object street = 'Paseo Montril').	self assert: (object number = '10185').</body><body package="GlorpDBTests">testReadAddressProxyAlreadyInMemory	"Check that if the object is already in memory we don't create a proxy for it, just return the instance Unless explicitly asked, in which case we return a proxy."	| object object2 query results rowToWrite |	[session beginTransaction.		rowToWrite := session system exampleAddressRow.		session writeRow: rowToWrite.		object := session readOneOf: GlorpAddress where: [:address | address id = 123].		self deny: (object class inheritsFrom: Proxy).		object2 := session readOneOf: GlorpAddress where: [:address | address id = 123].		self deny: (object class inheritsFrom: Proxy).		self assert: object2 == object.		object := nil.		object2 := nil.		Dialect garbageCollect.		(Delay forSeconds: 2) wait.		query := (Query			read: GlorpAddress			where: ([:address | address id = 123]) ) returnProxies: true.		results := query executeIn: session.		session accessor denyReads.		self assert: (results size = 1).		object := results first]	ensure: [session rollbackTransaction].	self assert: (object class = Proxy).	self deny: object isInstantiated.	self assert: (object id = 123).	self assert: (object street = 'Paseo Montril').	self assert: (object number = '10185').	session accessor permitEverything.</body><body package="GlorpDBTests">testReadAddressSubstring	| object query results rowToWrite results2 results3 |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query read: GlorpAddress where:		[:address | (address street copyFrom: 1 to: 5) = 'Paseo'].	results := query executeIn: session.	query := Query read: GlorpAddress where:		[:address | (address street copyFrom: 7 to: 13) = 'Montril'].	results2 := query executeIn: session.	query := Query read: GlorpAddress where:		[:address | (address street copyFrom: 3 to: 7) = 'seo M'].	results3 := query executeIn: session]			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'.	self assert: results2 size = 1.	self assert: results2 first = results first.	self assert: results3 size = 1.	self assert: results3 first = results first.</body><body package="GlorpDBTests">testReadAllAddress	| object results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	results := session read: GlorpAddress] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests">testReadCompressedMoney	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleCompressedMoneyRow.	session writeRow: rowToWrite.	query := Query read: GlorpCompressedMoney				where: [:money | money id ~= 0].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpCompressedMoney.	self assert: object amount = 12.	self assert: object currency = 'CDN'.</body><body package="GlorpDBTests">testReadCompressedMoney2	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleCompressedMoneyRow.	session writeRow: rowToWrite.	query := Query read: GlorpCompressedMoney				where: [:money | money = (GlorpCompressedMoney new id: 123; currency: 'CDN'; amount: 12)].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpCompressedMoney.	self assert: object amount = 12.	self assert: object currency = 'CDN'.</body><body package="GlorpDBTests">testReadCustomerAndAddTransaction	| query  customer accountIds newCustomer rawRows |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	session beginUnitOfWork.	query := Query readOneOf: GlorpCustomer				where: [:person | person id = 27].	customer := session execute: query.	customer addTransaction: GlorpBankTransaction example1.	session commitUnitOfWork.	newCustomer := session execute: query.	self assert: customer == newCustomer.	self assert: customer transactions first owner yourSelf == customer.	rawRows := session accessor executeSQLString: 'SELECT ID, NAME FROM GR_CUSTOMER'.	self assert: rawRows size = 1.	self assert: (rawRows first atIndex: 1) = 27.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadCustomerWithAccounts	| query id1 id2 result accounts backRef1 backRef2 accountIds |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query readOneOf: GlorpCustomer				where: [:person | person id = 27].	result := session execute: query.	self assert: result seenPostFetch = true.	accounts := result accounts getValue.	self assert: accounts size = 2.	self assert: (accounts first id = id1 or: [accounts last id = id1]).	self assert: (accounts first id = id2 or: [accounts last id = id2]).	self assert: accounts first id ~= accounts last id.	backRef1 := accounts first accountHolders getValue.	self assert: backRef1 size = 1.	self assert: backRef1 first = result.	backRef2 := accounts first accountHolders getValue.	self assert: backRef2 size = 1.	self assert: backRef2 first = result] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadCustomerWithAnySatisfyExists	| query result accounts |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpCustomer				where: 					[:person | 					person accounts anySatisfyExists: [:each | each accountNumber branchNumber &gt; 0]].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: accounts size = 2.	query := Query read: GlorpCustomer				where: 					[:person | 					person accounts anySatisfy: [:each | each accountNumber branchNumber = 2]].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: accounts size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadCustomerWithAnySatisfyJoin	| query result accounts |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpCustomer				where: 					[:person | 					person accounts anySatisfyJoin: [:each | each accountNumber branchNumber &gt; 0]].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: accounts size = 2.	query := Query read: GlorpCustomer				where: 					[:person | 					person accounts anySatisfy: [:each | each accountNumber branchNumber = 2]].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: accounts size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadCustomerWithIncludes	| query result accounts account |		[session beginTransaction.	self writeCustomer1Rows.	account := session readOneOf: GlorpBankAccount where: [:each | each accountNumber branchNumber = 2].	query := Query read: GlorpCustomer				where: 					[:person | 					person accounts includes: account].	result := session execute: query.	self assert: result size = 1.	accounts := result first accounts getValue.	self assert: (accounts includes: account).	self assert: accounts size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadCustomerWithMultipleAnySatisfyExists	| query result |		[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:person | 			(person accounts anySatisfyExists: [:each | each accountNumber branchNumber = 2]) 				&amp; (person accounts 						anySatisfyExists: [:each | each accountNumber branchNumber = 3])].	query := Query read: GlorpCustomer where: block.	result := session execute: query.	self assert: result size = 1] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadCustomerWithMultipleAnySatisfyJoin	| query result |		[| block |	session beginTransaction.	self writeCustomer1Rows.	block := 			[:person | 			(person accounts anySatisfyJoin: [:each | each accountNumber branchNumber = 2]) 				&amp; (person accounts 						anySatisfyJoin: [:each | each accountNumber branchNumber = 3])].	query := Query read: GlorpCustomer where: block.	result := session execute: query.	self assert: result size = 1] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadEmbeddedObjectDirectly	| serviceCharges transRow |		[	session beginTransaction.	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	transRow := session system exampleBankTransactionRow2.	session writeRow: transRow.	serviceCharges := session read: GlorpServiceCharge.	self assert: serviceCharges size = 2.	self deny: serviceCharges first == serviceCharges last.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadEmbeddedOneToOne	self helperForTestReadEmbeddedOneToOne.</body><body package="GlorpDBTests">testReadMultiFieldAdHoc	| object query results rowToWrite row2 |		[session beginTransaction.	rowToWrite := session system exampleCompressedMoneyRow.	row2 := session system exampleCompressedMoneyRow2.	session writeRow: rowToWrite.	session writeRow: row2.	query := Query read: GlorpCompressedMoney				where: [:money | money array = #('CDN' 12)].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpCompressedMoney.	self assert: object amount = 12.	self assert: object currency = 'CDN'.</body><body package="GlorpDBTests">testReadMultipleObjectsManyToMany1	| query result account |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpBankAccount.	query alsoFetch: [:each | each accountHolders].	result := query executeIn: session.	self assert: result size = 2.	account := result first.	self deny: account accountHolders isGlorpProxy.	self assert: account accountHolders size = 1.	self assert: (account accountHolders first == (result last accountHolders first))] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadMultipleObjectsManyToMany2	| query result customer |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpCustomer.	query retrieve: [:each | each ].	query alsoFetch: [:each | each accounts].	result := query executeIn: session.	self assert: result size = 1.	customer := result first.	self deny: customer accounts class isGlorpProxy.	self assert: customer accounts size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadMultipleObjectsManyToMany3	| query result customer array |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpCustomer.	query retrieve: [:each | each ].	query retrieve: [:each | each accounts].	result := query executeIn: session.	self assert: result size = 1.	array := result first.	customer := array first.	self deny: customer accounts isGlorpProxy.	self assert: customer accounts size = 2.	self assert: customer accounts == array last] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadMultipleObjectsManyToMany4	"If we read just a to-many relation, then it doesn't get knitted and we just get a collection of the target"	| query result |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpCustomer where: [:each | each id ~= 7].	query retrieve: [:each | each accounts].	result := query executeIn: session.	self assert: result size = 2.	self assert: session privateGetCache numberOfElements = 2.	self assert: (result allSatisfy: [:each | each class == GlorpBankAccount]).	self assert: result first ~= result last] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadMultipleObjectsToManyAlsoFetchTwoLevels	| query result account transactions |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	session beginUnitOfWork.	query := Query read: GlorpBankAccount.	query alsoFetch: [:each | each accountHolders].	query alsoFetch: [:each | each accountHolders transactions].	result := query executeIn: session.	self assert: result size = 2.	account := result detect: [:each | each id = 9874].	self deny: result first == result last.	self deny: account accountHolders isGlorpProxy.	self assert: account accountHolders size = 1.	transactions := account accountHolders first transactions.	self deny: transactions isGlorpProxy.	self assert: transactions size = 2.	self assert: account accountHolders first == (result at: 2) accountHolders first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadPassenger	| passengerRow1 passengerRow2 query result |		[session beginTransaction.	passengerRow1 := session system examplePassengerRow.	session writeRow: passengerRow1.	passengerRow2 := session system exampleFrequentFlyerRow.	session writeRow: passengerRow2.	query := Query readOneOf: GlorpPassenger				where: [:passenger | passenger id = 1].	result := query executeIn: session.	self assert: result id = 1.	self assert: result name = 'Some Passenger'.	self assert: result frequentFlyerPoints = 10000] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadRelationshipField	| query results |		[session beginTransaction.	query := Query read: GlorpItinerary where: [:each | ((each getTable: 'ITINERARY') getField: 'RES_ID') = nil].	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 0.</body><body package="GlorpDBTests">testReadReservationWithJoinToPassenger	| reservations |		[session beginTransaction.	self writeReservationData.	session beginUnitOfWork.	reservations := session read: GlorpReservation				where: [:each | each passenger id = 3].	self assert: reservations size = 1.	self assert: reservations first passengers size = 1.] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadReservationWithPassenger		| reservation passenger reservations |	[session beginTransaction.	self writeReservationData.	session beginUnitOfWork.	"This doesn't validate so well. We want to make sure that the passenger table read uses a join and gets back only the one row, but it's hard to test that. Putting in an error check in the query for readOne... that returns multiple would work, but is kind of intrusive"	reservations := session read: GlorpReservation where: [:each | each id = 2].	self assert: reservations size = 1.	reservation := reservations first.	passenger := reservation passenger.	passenger id.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadTransactionsWithIndependentSubselect	| query result query2 matchingResult |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	query := Query read: GlorpBankTransaction where: [:each |		each exists: (Query read: GlorpCustomer where: [:eachCustomer |			(eachCustomer id = each owner id) &amp; (eachCustomer name = 'anotherCustomer')])].	query orderBy: [:each | each owner name].	"Another way of saying the same thing"	query2 := Query read: GlorpBankTransaction where: [:each | each owner name = 'anotherCustomer'].	result := session execute: query.	matchingResult := session execute: query2.	self assert: result size = matchingResult size.	result with: matchingResult do: [:one :other |		self assert: one = other]] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadTransactionsWithIndependentSubselectAndNot	| query result query2 matchingResult |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	query := Query read: GlorpBankTransaction where: [:each |		each notExists: (Query read: GlorpCustomer where: [:eachCustomer |			(eachCustomer id = each owner id) &amp; (eachCustomer name = 'anotherCustomer')])].	query orderBy: [:each | each owner name].	"Another way of saying the same thing"	query2 := Query read: GlorpBankTransaction where: [:each | each owner name ~= 'anotherCustomer'].	query2 orderBy: [:each | each owner name].	result := session execute: query.	matchingResult := session execute: query2.	self assert: result size = matchingResult size.	result with: matchingResult do: [:one :other |		self assert: one = other]] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadTransactionsWithMaxSubselect	| query result |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	query := Query read: GlorpBankTransaction where: [:each |		each amount amount = ((Query read: GlorpBankTransaction			where: [:eachTrans | eachTrans owner = each owner]) 				retrieve: [:eachTrans | eachTrans amount amount max])].	query orderBy: [:each | each owner name].	result := session execute: query.	self assert: result size = 2.	self assert: result first amount amount = 10.	self assert: result last amount amount = 11.	self assert: result first owner id ~= result last owner id] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadTransactionsWithMaxSubselectAndRetrieveMax	| query result |		[session beginTransaction.	self write2CustomerRowsWith3Transactions.	query := Query read: GlorpBankTransaction where: [:each |		each amount amount = ((Query read: GlorpBankTransaction			where: [:eachTrans | eachTrans owner = each owner]) 				retrieveMax: [:eachTrans | eachTrans amount amount])].	query orderBy: [:each | each owner name].	result := session execute: query.	self assert: result size = 2.	self assert: result first amount amount = 10.	self assert: result last amount amount = 11.	self assert: result first owner id ~= result last owner id] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadWithCacheHits	| query addressRow result1 result2 |		[session beginTransaction.	addressRow := session system exampleAddressRow.	session writeRow: addressRow.	query := Query readOneOf: GlorpAddress				where: [:address | address id = 123].	result1 := query executeIn: session.	result2 := query executeIn: session.	self assert: result1 == result2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadWithFalseWhereClause	| query id1 id2 result accountIds |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query read: GlorpBankAccount				where: false.	result := session execute: query.	self assert: result size = 0] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadWithLimit	| results |	session platform supportsLimit ifFalse: [^self].	results := Set new.	[session beginTransaction.	session		inUnitOfWorkDo:			[(1 to: 5) do: [:i | session register: ((GlorpAddress new)													id: i;													yourself)]].	results		add: (session execute: (SimpleQuery read: GlorpAddress limit: 3)) size;		add: (session execute: (SimpleQuery read: GlorpAddress where: true limit: 3)) size;		add: (session execute: (SimpleQuery read: GlorpAddress limit: 3)) size;		add: (session execute: (SimpleQuery read: GlorpAddress where: true limit: 3)) size;		add: (session read: GlorpAddress limit: 3) size;		add: (session read: GlorpAddress where: true limit: 3) size.	self assert: (results allSatisfy: [:ea | ea = 3])] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testReadWithLimitAndOffset	session platform supportsOffset ifFalse: [^self].	[session beginTransaction.	session		inUnitOfWorkDo:			[(1 to: 5) do: [:i | session register: ((GlorpAddress new)													id: i;													yourself)]].	self assert: (session execute: ((SimpleQuery read: GlorpAddress limit: 2)									offset: 2;									yourself)) size = 2.	self assert: (session execute: ((SimpleQuery read: GlorpAddress limit: 0)									offset: 2;									yourself)) size = 0.	self assert: (session execute: ((SimpleQuery read: GlorpAddress)									offset: 6;									yourself)) size = 0] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testReadWithNilWhereClause	| query id1 id2 result accountIds |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query read: GlorpBankAccount				where: nil.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadWithObjectEqualityToEmbeddedObject	| query result |	 	[session beginTransaction.	self writeCustomer1RowsWith2Transactions.	query := Query	read: GlorpBankTransaction	where: [:trans | trans amount = (GlorpMoney currency: #CDN amount: 7)].	result := session execute: query.	self assert: result size = 1.	self assert: result first amount amount = 7.	self assert: result first amount currency = #CDN] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadWithObjectEqualityToEmbeddedObjectNested	| query result |	 	[session beginTransaction.	self writeCustomer1RowsWith2Transactions.	query := Query		 read: GlorpBankTransaction	where: [:trans | trans serviceCharge amount = (GlorpMoney currency: #CHF amount: 2)].	result := session execute: query.	self assert: result size = 1.	self assert: result first serviceCharge amount amount = 2.	self assert: result first serviceCharge amount currency = #CHF] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testReadWithOffset	session platform supportsOffset ifFalse: [^self].	[session beginTransaction.	session		inUnitOfWorkDo:			[(1 to: 5) do: [:i | session register: ((GlorpAddress new)													id: i;													yourself)]].	self assert: (session execute: ((SimpleQuery read: GlorpAddress)									offset: 2;									yourself)) size = 3] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testReadWithTrueWhereClause	| query id1 id2 result accountIds |		[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query read: GlorpBankAccount				where: true.	result := session execute: query.	self assert: result size = 2] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testRegisteringWithEmbeddedMapping	| bankTrans |	session beginUnitOfWork.	bankTrans := self helperForTestReadEmbeddedOneToOne.	self assert: (session isRegistered: bankTrans).	self assert: (session isRegistered: bankTrans serviceCharge).	self assert: (session isRegistered: bankTrans serviceCharge amount).</body><body package="GlorpDBTests">testSequencePolicyForInsert	| testObject |	GlorpInMemorySequenceDatabaseType reset.	[session beginTransaction.	session beginUnitOfWork.	testObject := GlorpAirline new.	session register: testObject.	session commitUnitOfWork.	self assert: testObject id = 1]		ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testShortCircuitEmptyReturnWhenLimitMeansNoResults	self deny: (SimpleQuery read: GlorpAddress limit: 3) shortCircuitEmptyReturn.	self assert: (SimpleQuery read: GlorpAddress limit: 0) shortCircuitEmptyReturn.	self assert: (SimpleQuery read: GlorpAddress limit: -3) shortCircuitEmptyReturn</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>accessing</category><body package="GlorpDBTests">session	^session.</body><body package="GlorpDBTests">session: anObject	session := anObject</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests-functions</category><body package="GlorpDBTests">testCount	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each id count].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 3.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testCountOnRelatedAttribute	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each accountHolders id count].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 2.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testCountStar	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each countStar].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 3.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testCountStarInRetrieveWithConstants	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query read: GlorpBankAccount.	query session: session.	query retrieve: [:each | each countStar].	query retrieve: [:each | 'X'].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = #(3 'X').	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testCountStarOnRelatedObject	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each accountHolders countStar].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 2.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testCountStarOnRelatedObjectAttribute	| query result account extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each accountHolders id countStar].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 2.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testCountStarOnRelatedObjectWithGroupBy	| query result extraAccount |		[session beginTransaction.	self writeCustomer1Rows.	extraAccount := session system exampleAccountRow3.	session writeRow: extraAccount.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each accountHolders countStar].	query groupBy: [:each | each id].	result := query executeIn: session.	self assert: result = #(1 1 )] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testMax	| query result account |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each accountNumber accountNumber max].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = '4'.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testMin	| query result account |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each accountNumber accountNumber min].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = '3'.	account := result first] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testRegexMatches	"This will fail on SQLite unless an application-defined SQL function named 'regexp' is added at run-time.  It will likewise fail on DB2 and SQLServer unless both a database function and a glorp reference to its name (which need not be regexp) have been added;  these database do not offer regex support, just the ability to add functions."	| customers |	[session beginTransaction.	session beginUnitOfWork.	self writeCustomer1Rows.	session reset.	customers := session read: GlorpCustomer where: [:each | each name regexMatches: 'aCustomer'].	self assert: customers size = 1.	customers := session read: GlorpCustomer where: [:each | each name regexMatches: 'a*omer'].	self assert: customers size = 1.	customers := session read: GlorpCustomer where: [:each | each name regexMatches: 'a?ustomer'].	self assert: customers size = 1.	customers := session read: GlorpCustomer where: [:each | each name regexMatches: 'aCusto(m|e|r)*'].	self assert: customers size = 1.	customers := session read: GlorpCustomer where: [:each | each name regexMatches: 'Not a customer'].	self assert: customers isEmpty.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testRetrieveComputed	"This test also exercises aliasing functions, specifically an infix function and a prefix function."	| query results |	[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each id].	query retrieve: [:each | each id * 2 alias: 'idDoubled'].	query retrieve: [:each | 2].	query retrieve: [:each | each id negated alias: 'idNegated'].	query retrieve: [:each | each id * each id].	results := query executeIn: session.	results do:		[:eachRow  |		self assert: eachRow first * eachRow first = eachRow last.		self assert: (eachRow at: 2) = (2 * eachRow first).		self assert: (eachRow at: 3) = 2.		self assert: eachRow first + (eachRow at: 4) = 0]]			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testSimilarTo	"Postgres and Firebird (and Sybase) support the ANSI SQL 'SIMILAR TO' form of regex (in which the % and _ of SQL's LIKE predicate replace the corresponding * and ? of regex) but most databases do not."	| customers |		[session beginTransaction.	session beginUnitOfWork.	self writeCustomer1Rows.	session reset.	customers := session read: GlorpCustomer where: [:each | each name similarTo: 'aCustomer'].	self assert: customers size = 1.	customers := session read: GlorpCustomer where: [:each | each name similarTo: 'a%omer'].	self assert: customers size = 1.	customers := session read: GlorpCustomer where: [:each | each name similarTo: 'a_ustomer'].	self assert: customers size = 1.	customers := session read: GlorpCustomer where: [:each | each name similarTo: 'aCusto(m|e|r)*'].	self assert: customers size = 1.	customers := session read: GlorpCustomer where: [:each | each name similarTo: 'Not a customer'].	self assert: customers isEmpty.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testSum	| query result |		[session beginTransaction.	self writeCustomer1Rows.	query := Query read: GlorpBankAccount.	query retrieve: [:each | each accountNumber branchNumber sum].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = 5] 			ensure: [session rollbackTransaction]</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests-sql</category><body package="GlorpDBTests">testCustomSQLInAccountsMapping	"Test using custom sql for the mapping's query. This will only work if using binding."	| query id1 id2 result accounts backRef1 backRef2 accountIds |	session useBinding ifFalse: [^self].	((session system descriptorFor: GlorpCustomer) 		mappingForAttributeNamed: #accounts)			query sql: 'SELECT t1.ID, t1.BANK_CODE, t1.BRANCH_NO, t1.ACCT_NO FROM BANK_ACCT t1, CUSTOMER_ACCT_LINK t2 WHERE ((t2.ACCT_ID = t1.ID) AND (t2.CUSTOMER_ID = ?))'.	[session beginTransaction.	accountIds := self writeCustomer1Rows.	id1 := accountIds at: 1.	id2 := accountIds at: 2.	query := Query readOneOf: GlorpCustomer				where: [:person | person id = 27].	result := session execute: query.	accounts := result accounts getValue.	self assert: accounts size = 2.	self assert: (accounts first id = id1 or: [accounts last id = id1]).	self assert: (accounts first id = id2 or: [accounts last id = id2]).	self assert: accounts first id ~= accounts last id.	backRef1 := accounts first accountHolders getValue.	self assert: backRef1 size = 1.	self assert: backRef1 first = result.	backRef2 := accounts first accountHolders getValue.	self assert: backRef2 size = 1.	self assert: backRef2 first = result] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testCustomSQLInAddressMapping	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query read: GlorpAddress.	query sql: 'select ID, STREET, HOUSE_NUM from GR_ADDRESS where ID = 123'.	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests">testReadAddressWithCustomSQL	| object query results rowToWrite |		[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query read: GlorpAddress.	query sql: 'select ID, STREET, HOUSE_NUM from GR_ADDRESS where ID = 123'.	results := query executeIn: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body><body package="GlorpDBTests">testReadAddressWithCustomSQLBinding	"Test that we can bind to custom SQL. If not binding, don't run this test."	| object query results rowToWrite |		session useBinding ifFalse: [^self].	[session beginTransaction.	rowToWrite := session system exampleAddressRow.	session writeRow: rowToWrite.	query := Query read: GlorpAddress.	query sql: 'select ID, STREET, HOUSE_NUM from GR_ADDRESS where ID = ?'.	results := query executeWithParameters: #(123) in: session] 			ensure: [session rollbackTransaction].	self assert: results size = 1.	object := results first.	self assert: object class = GlorpAddress.	self assert: object id = 123.	self assert: object street = 'Paseo Montril'.	self assert: object number = '10185'</body></methods><methods><class-id>Glorp.GlorpReadingTest</class-id> <category>tests-in</category><body package="GlorpDBTests">testInFromJoin	| query result |	[session beginTransaction.	self writeReservationData.	query := Query read: GlorpItinerary where: [:each | each reservation passengers 		anySatisfyJoin: [:eachPassenger | eachPassenger airline id in: #(73 74)]].	result := session execute: query.	self assert: (result allSatisfy: [:each | each reservation passengers anySatisfy: [:eachPassenger | #(73 74) includes: eachPassenger airline id]]).	self assert: result size = 2] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testInFromSubselect	| query result |	[session beginTransaction.	self writeReservationData.	query := Query read: GlorpItinerary where: [:each | each reservation passengers 		anySatisfyExists: [:eachPassenger | eachPassenger airline id in: #(73 74)]].	result := session execute: query.	self assert: (result allSatisfy: [:each | each reservation passengers anySatisfy: [:eachPassenger | #(73 74) includes: eachPassenger airline id]]).	self assert: result size = 2] ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpReadingTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpDeleteTest</class-id> <category>tests</category><body package="GlorpDBTests">checkCustomerDeletedInDatabase	| result |	result := session accessor 				executeSQLString: 'SELECT * FROM GR_CUSTOMER WHERE ID=1'.	self assert: result isEmpty</body><body package="GlorpDBTests">checkCustomerNotInCache	self assert: (session cacheLookupForClass: GlorpCustomer key: 1) isNil</body><body package="GlorpDBTests">checkCustomerStillInCache	self assert: (session cacheLookupForClass: GlorpCustomer key: 1) notNil</body><body package="GlorpDBTests">checkFoldersDeletedInDatabase	| result generalResult |	result := session accessor 				executeSQLString: 'SELECT * FROM GR_FOLDER WHERE USER_ID=1'.	self assert: result isEmpty.	generalResult := session accessor 				executeSQLString: 'SELECT * FROM GR_FOLDER'.	self assert: generalResult size = 1.</body><body package="GlorpDBTests">checkFoldersExistInDatabase	| result |	result := session accessor 				executeSQLString: 'SELECT * FROM GR_FOLDER WHERE USER_ID=1'.	self assert: result size = 2.</body><body package="GlorpDBTests">checkFoldersNotInCache	self assert: (session cacheLookupForClass: GlorpFolder key: #(1 'One')) isNil.	self assert: (session cacheLookupForClass: GlorpFolder key: #(1 'One-A')) isNil.</body><body package="GlorpDBTests">checkMessagesDeletedInDatabase	| result generalResult |	result := session accessor 				executeSQLString: 'SELECT * FROM GR_MESSAGE WHERE USER_ID = 1'.	self assert: result isEmpty.	generalResult := session accessor 				executeSQLString: 'SELECT * FROM GR_MESSAGE'.	self assert: generalResult size = 1.</body><body package="GlorpDBTests">checkPersonDeletedInDatabase	| result |	result := session accessor 				executeSQLString: 'SELECT * FROM PERSON WHERE ID=1'.	self assert: result isEmpty</body><body package="GlorpDBTests">doDeleteAndDoubleAddOfFoldersFor: user	| new2 removed new |	^session		modify: user		in:			[user folders do: [:each | each printString].			removed := user folders detect: [:each | each name = 'One'].			user folders remove: removed.			new := GlorpFolder new name: 'One'.			new user: user.			user folders add: new.			new2 := GlorpFolder new name: 'One'.			new2 user: user.			user folders add: new2].</body><body package="GlorpDBTests">setUpCustomer	session beginTransaction.	session accessor 		executeSQLStringNoResult: 'INSERT INTO GR_CUSTOMER VALUES (1,''Fred Flintstone'')'.	^session readOneOf: GlorpCustomer where: [:each | each id = 1].</body><body package="GlorpDBTests">setUpPersonWithAddress	session beginTransaction.	session accessor 		executeSQLStringNoResult: 'INSERT INTO GR_ADDRESS VALUES (2,''Paseo Montril'', ''999'')'.	session accessor 		executeSQLStringNoResult: 'INSERT INTO PERSON VALUES (1,''Fred Flintstone'', 2)'.	^session readOneOf: GlorpPerson where: [:each | each id = 1].</body><body package="GlorpDBTests">testCascadingDeleteAcrossNil	| person addressRows personRows |	session inTransactionDo: [session accessor dropConstraint: (session system tableNamed: 'PERSON') foreignKeyConstraints first].	[	((session system descriptorFor: GlorpPerson) mappingForAttributeNamed: #address) beExclusive.	self setUpPersonWithAddress .	session accessor executeSQLString: 'delete from GR_ADDRESS where ID = 2'.	session reset.	person := session readOneOf: GlorpPerson.	"First, make sure this doesn't walkback"	[session beginUnitOfWork.	session delete: person] ensure: [session commitUnitOfWork].	"Now make sure the address is left"	addressRows := session accessor executeSQLString: 'SELECT * FROM GR_ADDRESS'.	self assert: addressRows isEmpty.	personRows :=  session accessor executeSQLString: 'SELECT * FROM PERSON'.	self assert: personRows isEmpty.		] 		ensure: [			session rollbackTransaction.			session inTransactionDo: [session accessor createTableFKConstraints: (session system tableNamed: 'PERSON') ifError: [self halt]]]</body><body package="GlorpDBTests">testCascadingDeleteInstantiating	| user |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session beginUnitOfWork.	user folders do: [:each | each printString].	session delete: user.	session commitUnitOfWork.	self checkFoldersNotInCache.	self checkFoldersDeletedInDatabase.	self checkMessagesDeletedInDatabase] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testCascadingDeleteWithoutInstantiating	| user |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session beginUnitOfWork.	session delete: user.	session commitUnitOfWork.	self checkFoldersNotInCache.	self checkFoldersDeletedInDatabase] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testDeleteAndReinsertTwiceWhenRemovingFromAnExclusiveCollection	"Make sure that if we add a new thing twice, we get the expected failure of a primary key conflict."	| user |	[self setUpFolders.	self checkFoldersExistInDatabase.	user := session		readOneOf: GlorpUser		where: [:each | each name = 'User One'].	self		should: [self doDeleteAndDoubleAddOfFoldersFor: user]		raise: GlorpDatabaseWriteError] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testDeleteAndReinsertWhenRemovingFromAnExclusiveCollection	"Test that if we delete something and then re-insert with the same primary key, that it gets converted to an update. This is not really advisable as something to do, since you're really violating the primary key = object identity correspondence, but it can reasonably happen if you're using domain primary keys, link tables reified as objects, or other circumstances"	| user removed result generalResult new |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session modify: user in: [		user folders do: [:each | each printString].		removed := user folders detect: [:each | each name = 'One'].		user folders remove: removed.		new := GlorpFolder new name: 'One'.		new user: user.		user folders add: new].	self assert: (session cacheLookupForClass: GlorpFolder key: #(1 'One')) == new.	result := session accessor executeSQLString: 'SELECT * FROM GR_FOLDER WHERE USER_ID=1'.	self assert: result size = 2.	generalResult := session accessor executeSQLString: 'SELECT * FROM GR_FOLDER'.	self assert: generalResult size = 3.	result := session accessor executeSQLString: 'SELECT * FROM GR_MESSAGE WHERE USER_ID = 1'.	self assert: result isEmpty.	generalResult := session accessor executeSQLString: 'SELECT * FROM GR_MESSAGE'.	self assert: generalResult size = 1.] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testDeleteFromAnExclusiveCollectionContainingNil	| user removed |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session modify: user in: [		user folders do: [:each | each printString].		removed := user folders detect: [:each | each name = 'One'].		user folders remove: removed.		user folders add: nil]	"The only assertion is that we shouldn't be crashing here."	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testDeleteKeyValCopy	"Delete an object that shares key values only with the deletion target."	| person keyValPerson keyValAddress |	keyValPerson := GlorpPerson new.	keyValAddress := GlorpAddress new.		[person := self setUpPersonWithAddress.	keyValPerson id: person id.	keyValAddress id: person address id.	session beginUnitOfWork.	session delete: keyValPerson.	session delete: keyValAddress.	session commitUnitOfWork.	self checkPersonDeletedInDatabase.] 		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testDeleteMultipleTable	| passengerRow1 passengerRow2 passenger rows frequentFlyerRow1 frequentFlyerRow2 |		[	session beginTransaction.	passengerRow1 := session system examplePassengerRow.	session writeRow: passengerRow1.	frequentFlyerRow1 := session system exampleFrequentFlyerRow.	session writeRow: frequentFlyerRow1.	passengerRow2 := session system examplePassengerRow2.	session writeRow: passengerRow2.	frequentFlyerRow2 := session system exampleFrequentFlyerRow2.	session writeRow: frequentFlyerRow2.	passenger := session readOneOf: GlorpPassenger.	session delete: passenger.	rows := session accessor executeSQLString: 'SELECT * FROM FREQUENT_FLYER'.	self assert: rows size = 1.	rows := session accessor executeSQLString: 'SELECT * FROM PASSENGER'.	self assert: rows size = 1.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testDeleteMultipleTableWithOneMissing	| passengerRow1 passengerRow2 passenger rows frequentFlyerRow2 |		[	session beginTransaction.	passengerRow1 := session system examplePassengerRow.	session writeRow: passengerRow1.	passengerRow2 := session system examplePassengerRow2.	session writeRow: passengerRow2.	frequentFlyerRow2 := session system exampleFrequentFlyerRow2.	session writeRow: frequentFlyerRow2.	passenger := session readOneOf: GlorpPassenger where: [:each | each id = 1].	session delete: passenger.	rows := session accessor executeSQLString: 'SELECT * FROM FREQUENT_FLYER'.	self assert: rows size = 1.	rows := session accessor executeSQLString: 'SELECT * FROM PASSENGER'.	self assert: rows size = 1.	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testDeleteWhenRemovingFromAnExclusiveCollection	| user removed result generalResult |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session modify: user in: [		user folders do: [:each | each printString].		removed := user folders detect: [:each | each name = 'One'].		user folders remove: removed].	self assert: (session cacheLookupForClass: GlorpFolder key: #(1 'One')) isNil.	result := session accessor executeSQLString: 'SELECT * FROM GR_FOLDER WHERE USER_ID=1'.	self assert: result size = 1.	generalResult := session accessor executeSQLString: 'SELECT * FROM GR_FOLDER'.	self assert: generalResult size = 2.	result := session accessor executeSQLString: 'SELECT * FROM GR_MESSAGE WHERE USER_ID = 1'.	self assert: result isEmpty.	generalResult := session accessor executeSQLString: 'SELECT * FROM GR_MESSAGE'.	self assert: generalResult size = 1.] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testNormalDeleteOnFolders	| user |		[self setUpFolders.	self checkFoldersExistInDatabase.	user := session readOneOf: GlorpUser where: [:each | each name = 'User One'].	session beginUnitOfWork.	session delete: user.	user folders do: [:each | 		session delete: each.		each messages do: [:eachMessage |			session delete: eachMessage]].	session commitUnitOfWork.	self checkFoldersNotInCache.	self checkFoldersDeletedInDatabase.	self checkMessagesDeletedInDatabase] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testUnitOfWorkDelete	| customer result |		[customer := self setUpCustomer.	session beginUnitOfWork.	session delete: customer.	result := session accessor 				executeSQLString: 'SELECT * FROM GR_CUSTOMER WHERE ID=1'.	self assert: result size = 1.	self 		assert: (session readOneOf: GlorpCustomer where: [:each | each id = 1]) isNil.	self checkCustomerStillInCache.	session commitUnitOfWork.	self checkCustomerNotInCache.	self checkCustomerDeletedInDatabase] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testUnitOfWorkDeleteOrder	| person |		[person := self setUpPersonWithAddress.	session beginUnitOfWork.	session delete: person.	session delete: person address.	session commitUnitOfWork.	self checkPersonDeletedInDatabase.] 			ensure: [session rollbackTransaction]</body></methods><methods><class-id>Glorp.GlorpDeleteTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests">setUpFolders	session system: (GlorpCompositeKeyDescriptorSystem forPlatform: session platform).	session beginTransaction.	session transact: [session register: session system example1].	session reset.</body><body package="GlorpDBTests">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpDeleteTest</class-id> <category>delete-insert-update tests</category><body package="GlorpDBTests">assertDeleteCopy: aBlock ofInsertUpdatesFields: anInteger	"If the test is run bound then #shouldUpdateOnlyChangedFields will by default return false and all 3 fields will be updated regardless of which have been changed.  We therefore check the row's opinion of fieldsNeedingUpdate, not the UpdateCommand's opinion."	| person oldAddress address otherSession triedToWrite |	triedToWrite := false.	person := GlorpPerson example2.	person address: nil.	[address := self setUpPersonWithAddress address getValue.	oldAddress := aBlock value: address.	address street: 'Change Street'.	otherSession := GlorpDemoDescriptorSystem sessionForLogin: GlorpDatabaseLoginResource current login.	otherSession  accessor: GlorpDatabaseLoginResource current accessor.	otherSession accessor denyWrites.	"raise GlorpIllegalCommand so we can check write state"	otherSession beginUnitOfWork.	otherSession delete: oldAddress.	person address: address.	otherSession register: person.	[otherSession commitUnitOfWork] on: GlorpIllegalCommand do:		[:ex || rowMap row | triedToWrite := true.		rowMap := otherSession privateGetCurrentUnitOfWork privateGetRowMap			subMapForTable: (otherSession system tableNamed: 'GR_ADDRESS').		row := rowMap at: address.		self deny: row forDeletion.		self assert: row fieldsNeedingUpdate size = anInteger.		row := rowMap at: oldAddress.		self assert: row forDeletion]] ensure:			[session rollbackTransaction.			otherSession rollbackTransaction.			otherSession resetPermissions].	self assert: triedToWrite		description: 'The important asserts of this test were not reached'.</body><body package="GlorpDBTests">testDeleteKeyValCopyInsertIsUpdate	"By definition, the key value(s) must be the same for the delete and insert to be merged into an update.  In this test, the deleted object has no values for the two non-key fields (even if it did and they matched those of the inserted one, the current implementation of #collapseMatchingInsertsAndDeletesFor: would still update all non-key fields, not trusting the user to supply a fully-formed object to delete since deletion only requires the primary key values)."	self		assertDeleteCopy: [:addr | GlorpAddress new id: addr id; yourself]		ofInsertUpdatesFields: 2.</body><body package="GlorpDBTests">testDeleteOldCopyInsertNewIsUpdate	"This shows how a user can mimic Glorp's memento management while deferring creating a session.  You capture a shallowCopy of the object of interest, then change the original as you wish.  By deleting the old copy and registering the changed original in the same session, you achieve the same effect as if you had registered the original in the session before you changed it:  the session treats it as an update.  The user is responsible for ensuring it is in fact an update, not an insert, i.e. an object of that key is already in the database.  Only the changed field would be regarded as needing update by the row if the deleted row were its oldVersion, but #collapseMatchingInsertsAndDeletesFor: does not set this for fear a user could carelessly provide a deleted object that matched a changed field in the inserted object, so would not be updated.  Thus all non-key fields are always updated, even when not differing between delete and insert."	self		assertDeleteCopy: [:addr | addr shallowCopy]		ofInsertUpdatesFields: 2.</body><body package="GlorpDBTests">testDeleteShallowCopyInsertIsUpdate	"This is like testDeleteOldCopyInsertNewIsUpdate but demonstrates a workaround for the case when the user knows the object is already in the database but did not capture a shallowCopy before changing it.  It exploits the Glorp shortcut that, when delete and insert are combined to update, Glorp does not check which fields have changed but updates all fields, even though in this example the object and copy are unchanged."	| person address otherSession |	person := GlorpPerson example2.	person address: nil.	[address := self setUpPersonWithAddress address getValue.	address street: 'Change Street'.	otherSession := GlorpDemoDescriptorSystem sessionForLogin: GlorpDatabaseLoginResource current login.	otherSession  accessor: GlorpDatabaseLoginResource current accessor.	otherSession beginUnitOfWork.	otherSession delete: address shallowCopy.	person address: address.	otherSession register: person.	otherSession commitUnitOfWork]			ensure: [session rollbackTransaction.  otherSession rollbackTransaction]</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginTest</class-id> <category>tests</category><body package="GlorpDBTests">testLogin	self assert: self accessor isLoggedIn not.	self accessor login.	self assert: self accessor isLoggedIn.	self accessor logout.	self assert: self accessor isLoggedIn not</body><body package="GlorpDBTests">testSecureLoginDiscardsPassword	| oldValue |	self assert: self accessor isLoggedIn not.	oldValue := self accessor currentLogin secure.	[self accessor currentLogin secure: true.	self accessor login.	self assert: accessor currentLogin password isNil.	self accessor logout]		ensure: [self accessor currentLogin secure: oldValue].</body><body package="GlorpDBTests">testUnsecureLoginDoesNotDiscardPassword	| oldValue |	self assert: self accessor isLoggedIn not.	oldValue := self accessor currentLogin secure.	[self accessor currentLogin secure: false.	self accessor login.	self assert: accessor currentLogin password notNil.	self accessor logout]		ensure: [self accessor currentLogin secure: oldValue].</body><body package="GlorpDBTests">testUnsuccessfulLogin	| anotherAccessor invalidLogin |	"Some databases can't fail to log in."	login database supportsAuthentication ifFalse: [^self].	invalidLogin := GlorpDatabaseLoginResource defaultLogin copy.	invalidLogin		password: 'you will never ever guess this password';		username: 'not a valid user name'.	anotherAccessor := DatabaseAccessor forLogin: invalidLogin.	self assert: anotherAccessor isLoggedIn not.	anotherAccessor loginIfError: [:ex | ].	Dialect isVisualAge		"The isLoggedIn is unreliable under VA, can return false positive"		ifFalse: [self assert: anotherAccessor isLoggedIn not]		ifTrue: [Transcript cr; show: self class name, '&gt;&gt;testUnsuccessfulLogin skips a trivial isLoggedIn check, saying it was unreliable under VA55, could return false positive, later versions not yet verified'].	anotherAccessor logout.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginTest</class-id> <category>accessing</category><body package="GlorpDBTests">accessor	^accessor.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	login := GlorpDatabaseLoginResource defaultLogin copy.	accessor := DatabaseAccessor forLogin: login.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpDatabaseLoginResource.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsTest</class-id> <category>setup</category><body package="GlorpDBTests">setUp		| |	super setUp.	session := GlorpSessionResource current newSession.	system := session system.	session beginTransaction.	self writeAccountRows.	singleQuery := Query read: GlorpBankAccount				where: [:passenger | passenger id = 6].	allQuery := Query read: GlorpBankAccount.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.</body><body package="GlorpDBTests">writeAccountRows	| accountRow1 accountRow2 |	accountRow1 := session system exampleAccountRow1. 	accountRow2 := session system exampleAccountRow2.	session writeRow: accountRow1.	session writeRow: accountRow2.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsTest</class-id> <category>tests</category><body package="GlorpDBTests">check: aClass	| collectionClass |	collectionClass := aClass isBehavior ifTrue: [aClass] ifFalse: [aClass class].	singleQuery collectionType: aClass.	allQuery collectionType: aClass.	singleResult := session execute: singleQuery.	allResult := session execute: allQuery.	self assert: singleResult class == collectionClass.	self assert: allResult class == collectionClass.	self assert: singleResult size = 1.	self assert: allResult size = 2.</body><body package="GlorpDBTests">testArray	self check: Array.</body><body package="GlorpDBTests">testBlank	singleResult := session execute: singleQuery.	allResult := session execute: allQuery.	self assert: singleResult class == Array.	self assert: allResult class == Array.	self assert: singleResult size = 1.	self assert: allResult size = 2.</body><body package="GlorpDBTests">testOrderedCollection	self check: OrderedCollection.</body><body package="GlorpDBTests">testSet	self check: Set.</body><body package="GlorpDBTests">testSortedCollection	self check: SortedCollection.	self assert: allResult first &lt;= allResult last.</body><body package="GlorpDBTests">testSortedCollectionReversed	self check: (SortedCollection sortBlock: [:a :b | b &lt;= a]).	self assert: allResult last &lt;= allResult first.</body></methods><methods><class-id>Glorp.GlorpPartialWritesTest</class-id> <category>tests</category><body package="GlorpDBTests">testNoDifferenceNoWriteself todo</body><body package="GlorpDBTests">testWritingNewObjectself todo</body><body package="GlorpDBTests">testWritingObjectWithAddedComponentself todo</body><body package="GlorpDBTests">testWritingObjectWithChangedAttributeself todo</body><body package="GlorpDBTests">testWritingObjectWithChangedComponentself todo</body><body package="GlorpDBTests">testWritingObjectWithChangedComponentAttributeself todo</body><body package="GlorpDBTests">testWritingObjectWithDeletedComponentself todo</body><body package="GlorpDBTests">testWritingObjectWithDeletedRelationshipself todo</body></methods><methods><class-id>Glorp.GlorpPartialWritesTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.</body></methods><methods><class-id>Glorp.GlorpVarchar4Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform varchar: 4.</body></methods><methods><class-id>Glorp.GlorpVarchar4Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testTrimmedChar4	| converter |	stType := String.	converter := type platform converterNamed: #stringToTrimmedString.	self assert: (converter convert:  'abc' toDatabaseRepresentationAs: type) = 'abc'.	self assert: (converter convert:  'abcd' toDatabaseRepresentationAs: type) = 'abcd'.	self assert: (converter convert:  'abcde' toDatabaseRepresentationAs: type) = 'abcd'.</body><body package="GlorpDBTypeTests">testVarChar4	stType := String.	self helpTestValue: nil.	self helpTestValue: '' compareWith: [:read :original |		self platform usesNullForEmptyStrings ifTrue: [read = nil] ifFalse: [read = original]].	self helpTestValue: 'a'.	self helpTestValue: 'ab'.	self helpTestValue: 'abc'.	self helpTestValue: 'abcd'.	stType := Symbol.	self helpTestValue: #abcd.	stType := nil.	"This overlong-means-invalid check fails on SQLite where column length limits are unenforced."	self should: [self helpTestInvalidValue: 'abcde'] raise: GlorpDatabaseWriteError.</body></methods><methods><class-id>Glorp.GlorpReadQueryTest</class-id> <category>tests-ordering</category><body package="GlorpDBTests">helpTestSingleOrderingBy: aBlock setup: setupBlock	| query result realBlock |	query := Query read: GlorpAddress.	query orderBy: aBlock.	realBlock := query expressionBlockFor: aBlock.	result := session execute: query.	self verifyOrderFor: result byAttribute: realBlock.</body><body package="GlorpDBTests">testDescendingSingleOrdering	| query result sortedResult |		query := Query read: GlorpAddress where: [:each | each street ~= 'Beta'].	query orderBy: [:each | each street descending].	result := session execute: query.	sortedResult := result 				asSortedCollection: [:a :b | a street &gt; b street].	self assert: sortedResult asArray = result asArray.</body><body package="GlorpDBTests">testDoubleOrderingAddress	| query |	query := Query read: GlorpAddress.	query orderBy: [:each | each street].	query orderBy: [:each | each number].	self validateDoubleOrderFor: query.</body><body package="GlorpDBTests">testMixedDoubleOrderingAddress	| query |	query := Query read: GlorpAddress.	query orderBy: [:each | each street descending].	query orderBy: [:each | each number].	self validateDoubleOrderMixedFor: query.</body><body package="GlorpDBTests">testOrderingByRelatedObjectAttribute	| query result |	query := Query read: GlorpPerson.	query orderBy: [:each | each address street].	result := session execute: query.	self verifyOrderFor: result byAttribute: [:each | each address street].</body><body package="GlorpDBTests">testOrderingWithNonEmptyWhereClause	| query result |	query := Query read: GlorpPerson where: [:each | each id ~= 12].	query orderBy: #(#address #street).	result := session execute: query.	self verifyOrderFor: result byAttribute: [:each | each address street].</body><body package="GlorpDBTests">testSingleOrderingAddress1	self 		helpTestSingleOrderingBy: [:each | each street]		setup: [self writeAddressOrderingRows].</body><body package="GlorpDBTests">testSingleOrderingAddress2	self 		helpTestSingleOrderingBy: [:each | each number]		setup: [self writeAddressOrderingRows].</body><body package="GlorpDBTests">testSingleOrderingBySymbol	self 		helpTestSingleOrderingBy: #street		setup: [self writeAddressOrderingRows].</body><body package="GlorpDBTests">testSymbolsOrderingByRelatedObjectAttribute	| query result |	query := Query read: GlorpPerson.	query orderBy: #(#address #street).	result := session execute: query.	self verifyOrderFor: result byAttribute: [:each | each address street].</body></methods><methods><class-id>Glorp.GlorpReadQueryTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	session system: (GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database).	session beginTransaction.	self writeAddressDoubleOrderingRows.	self writePersonOrderingRows.</body><body package="GlorpDBTests">tearDown	super tearDown.	session rollbackTransaction.	session reset.	session := nil.</body><body package="GlorpDBTests">validateDoubleOrderFor: query 	| result sortedResult |	result := session execute: query.	sortedResult := result asSortedCollection: 					[:a :b | 					a street = b street 						ifTrue: [a number &lt;= b number]						ifFalse: [a street &lt; b street]].	^self assert: sortedResult asArray = result asArray</body><body package="GlorpDBTests">validateDoubleOrderMixedFor: query 	| result sortedResult |	result := session execute: query.	sortedResult := result asSortedCollection: 					[:a :b | 					a street = b street 						ifTrue: [a number &lt;= b number]						ifFalse: [a street &gt; b street]].	^self assert: sortedResult asArray = result asArray</body><body package="GlorpDBTests">verifyOrderFor: result byAttribute: aBlock	1 to: result size - 1		do: 			[:i | 			| a b |			a := result at: i.			b := result at: i + 1.			self assert: (aBlock value: a) &lt;= (aBlock value: b)]</body><body package="GlorpDBTests">writeAddressDoubleOrderingRows	self writeAddressOrderingRows.	session writeRow: session system exampleAddressRowForOrdering4.	session writeRow: session system exampleAddressRowForOrdering5.</body><body package="GlorpDBTests">writeAddressOrderingRows	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.</body><body package="GlorpDBTests">writePersonOrderingRows	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.	session writeRow: session system examplePersonRowForOrdering3.</body></methods><methods><class-id>Glorp.GlorpReadQueryTest</class-id> <category>tests</category><body package="GlorpDBTests">testCriteriaSetup	| query |	query := Query readOneOf: GlorpAddress where: [:each | each id = 12].	query session: session.	query setUpExpressions.	self assert: query whereClause class == RelationExpression.	self assert: query whereClause ultimateBaseExpression descriptor 				== (session descriptorFor: GlorpAddress)</body><body package="GlorpDBTests">testIn	| query result |		query := Query read: GlorpAddress where: [:each | each street in: #('Beta' 'Alpha')].	result := session execute: query.	self assert: (result allSatisfy: [:each | #('Beta' 'Alpha') includes: each street]).	self assert: result size = 4.</body><body package="GlorpDBTests">testInEmpty	"This test generates an error in DB2 because DB2 claims that IN (NULL) is invalid,	since not even NULL can be IN (NULL) (since NULL isn't equal to itself)."	| query result |	session platform isDB2Platform ifTrue: [^self].	query := Query read: GlorpAddress where: [:each | each street in: #()].	result := session execute: query.	self assert: result isEmpty</body><body package="GlorpDBTests">testInInteger	| query result |		query := Query read: GlorpAddress where: [:each | each id in: #(1 2)].	result := session execute: query.	self assert: (result allSatisfy: [:each | #(1 2) includes: each id]).	self assert: result size = 2.</body><body package="GlorpDBTests">testInSymbol	| query result transRow transRow2 |	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.		transRow2 := session system exampleBankTransactionRow2.	session writeRow: transRow2.		query := Query read: GlorpBankTransaction where: [:each | each amount currency in: #(#USD #CDN)].	result := session execute: query.	self assert: (result allSatisfy: [:each | each amount currency = #CDN]).	self assert: result size = 1.	query := Query read: GlorpBankTransaction where: [:each | each amount currency in: #(#USD #DM)].	result := session execute: query.	self assert: result isEmpty.</body><body package="GlorpDBTests">testLike	| query result |		query := Query read: GlorpAddress where: [:each | each street like: 'Be%'].	result := session execute: query.	self assert: (result allSatisfy: [:each | each street = 'Beta']).	self assert: result size = 3.</body><body package="GlorpDBTests">testPseudoColumnQuery	"Does the alias function write its base in the select statement (only) as aliased."	| query result a logStream |	a := 5.	query := Query read: GlorpCitiesGraph where: [:each | each distance in: #()].	query alsoFetch: [:each| (each distance - a) alias: 'DefaultAlias'].	session accessor		logging: true;		logger: TextCollector new.	result := [session execute: query] ensure:		[logStream := session accessor logger value asString readStream.		session accessor endLogging].	self assert: result isEmpty.	self assert: ((logStream upToAll: 'FROM') indexOfSubCollection: ' AS DefaultAlias' startingAt: 1) &gt; 0		description: 'We did not alias the expression in the select field''s list'.	self assert: (logStream upToEnd indexOfSubCollection: ' AS DefaultAlias' startingAt: 1) = 0		description: 'We wrote an alias in the wrong place'.	"now provide the alias string"	a := 3.	query := Query read: GlorpCitiesGraph where: [:each | each distance in: #()].	query alsoFetch: [:each| (each distance - a) alias: 'MyAlias'].	session accessor		logging: true;		logger: TextCollector new.	result := [session execute: query] ensure:		[logStream := session accessor logger value asString readStream.		session accessor endLogging].	self assert: result isEmpty.	self assert: ((logStream upToAll: 'FROM') indexOfSubCollection: ' AS MyAlias' startingAt: 1) &gt; 0		description: 'We did not alias the expression to our chosen name in the select field''s list'.	self assert: (logStream upToEnd indexOfSubCollection: ' AS MyAlias' startingAt: 1) = 0		description: 'We wrote our chosen  alias name in the wrong place'.</body><body package="GlorpDBTests">testReadMultipleObjects	| query result tracing addressReadSeparately personReadSeparately allResults |	query := Query read: GlorpPerson.	tracing := Tracing new.	tracing retrieve: [:each | each ].	tracing retrieve: [:each | each address].	query tracing: tracing.	query orderBy: #id.	allResults := query executeIn: session.	self assert: allResults size = 3.	result := allResults first.	self assert: (result at: 1) id = 86.	self assert: ((result at: 1) class == GlorpPerson).	self assert: (result at: 1) address == (result at: 2).	self assert: ((result at: 2) class == GlorpAddress).	self assert: ((result at: 2) id = 2).	addressReadSeparately := session readOneOf: GlorpAddress where: [:each | each id = 2].	self assert: result last == addressReadSeparately.	personReadSeparately := session readOneOf: GlorpPerson where: [:each | each id = 86].	self assert: personReadSeparately == result first.	self assert: personReadSeparately address yourSelf == result last.</body><body package="GlorpDBTests">testReadWithConditionalInWhereClause	"The frequentFlyerMiles is not an outer join.  It has an additional expression that is an outer join.  Thus this test would have passed in Glorp in 8.2 and earlier, since the outer join is an additional expression of the wheer clause, not the whereClause as such."	| passengerRow1 passengerRow2 frequentFlyerRow1 frequentFlyerRow2 passengerRow3 query |	passengerRow1 := session system examplePassengerRow.	session writeRow: passengerRow1.	frequentFlyerRow1 := session system exampleFrequentFlyerRow.	session writeRow: frequentFlyerRow1.	passengerRow2 := session system examplePassengerRow2.	session writeRow: passengerRow2.	frequentFlyerRow2 := session system exampleFrequentFlyerRow2.	session writeRow: frequentFlyerRow2.	passengerRow3 := session system examplePassengerRowInfrequent.	session writeRow: passengerRow3.	self assert: (session read: GlorpPassenger where: [:each | each frequentFlyerMiles notNil]) size = 2.	query := Query read: GlorpPassenger where: [:each | each frequentFlyerMiles isNil].	self assert: (session execute: query) size = 1.</body><body package="GlorpDBTests">testReadWithFunctionInWhereClause	"The assertion on what we read doesn't matter too much, as we're primarily testing that the expression doesn't walkback."	| people |	people := session read: GlorpPerson where: [:each | each id + each id &gt; 2].	people do: [:each | self assert: (each id + each id) &gt; 10].	people := session read: GlorpPerson where: [:each | (each name , each address street) = 'person1Beta'].	self assert: people size = 1.	self assert: people first name = 'person1'.</body></methods><methods><class-id>Glorp.GlorpReadQueryTest</class-id> <category>tests-data reading</category><body package="GlorpDBTests">testReadDataItemsFromEmbeddedObject	| query result transRow id |	transRow := session system exampleBankTransactionRow.	session writeRow: transRow.	id := transRow atFieldNamed: 'ID'.	query := Query read: GlorpBankTransaction.	query retrieve: [:each | each id].	query retrieve: [:each | each serviceCharge description].	result := query executeIn: session.	self assert: result size = 1.	self assert: result first = (Array with: id with: 'additional overcharge').</body><body package="GlorpDBTests">testReadDistinctIds	| query result |	query := Query read: GlorpPerson.	query retrieve: [:each | each id distinct].	result := query executeIn: session.	self assert: (result asSortedCollection asArray = #(86 87 88)).</body><body package="GlorpDBTests">testReadDistinctIdsWithWhereClause	| query result |	query := Query read: GlorpPerson.	query retrieve: [:each | each id distinct].	query whereClause: [:each | each id ~= 423421].	result := query executeIn: session.	self assert: (result asSortedCollection asArray = #(86 87 88)).</body><body package="GlorpDBTests">testReadDistinctRelatedAttribute	| query result allStreets |	query := Query read: GlorpPerson.	query retrieve: [:each | each address street distinct].	result := query executeIn: session.	self assert: (result asSortedCollection asArray = #('Alpha' 'Beta' 'Gamma')).	allStreets := (session read: GlorpAddress) collect: [:each | each street].	self assert: allStreets size = 5.</body><body package="GlorpDBTests">testReadObjectsAndData	| query result tracing addressReadSeparately personReadSeparately |	query := Query read: GlorpPerson.	tracing := Tracing new.	tracing retrieve: [:each | each id].	tracing retrieve: [:each | each address].	query tracing: tracing.	query orderBy: #id.	result := query executeIn: session.	self assert: result size = 3.	self assert: (result first at: 1) = 86.	self assert: ((result first at: 2) class == GlorpAddress).	self assert: ((result first at: 2) id = 2).	addressReadSeparately := session readOneOf: GlorpAddress where: [:each | each id = 2].	self assert: result first last == addressReadSeparately.	personReadSeparately := session readOneOf: GlorpPerson where: [:each | each id = 86].	self assert: personReadSeparately address yourSelf == result first last.</body><body package="GlorpDBTests">testReadOneWithObjects	| query result |	query := Query readOneOf: GlorpPerson where: [:each | each id = 86].	query retrieve: [:each | each].	query retrieve: [:each | each address].	query orderBy: [:each | each id].	result := query executeIn: session.	self assert: result first id = 86.	self assert: (result first address yourSelf == result last).</body><body package="GlorpDBTests">testReadOnlyPrimaryKeys	| query result |	query := Query read: GlorpPerson.	query retrieve: [:each | each id].	result := query executeIn: session.	self assert: (result asSortedCollection asArray = #(86 87 88)).</body><body package="GlorpDBTests">testReadTwoDataItems	| query result tracing|	query := Query read: GlorpPerson.	tracing := Tracing new.	tracing retrieve: [:each | each id].	tracing retrieve: [:each | each name].	query tracing: tracing.	result := query executeIn: session.	self assert: result size = 3.	self assert: (result includes: #(86 'person1')).	self assert: (result includes: #(87 'person2')).	self assert: (result includes: #(88 'person3')).</body><body package="GlorpDBTests">testReadTwoDataItemsFromDifferentObjects	| query result tracing|	query := Query read: GlorpPerson.	tracing := Tracing new.	tracing retrieve: [:each | each id].	tracing retrieve: [:each | each address street].	query tracing: tracing.	query orderBy: #id.	result := query executeIn: session.	self assert: result size = 3.	self assert: result first = #(86 'Beta').	self assert: (result at: 2) = #(87 'Gamma').	self assert: result last = #(88 'Alpha').</body><body package="GlorpDBTests">testReadTwoObjects	| query result |	query := Query read: GlorpPerson.	query retrieve: [:each | each].	query retrieve: [:each | each address].	query orderBy: [:each | each id].	result := query executeIn: session.	self assert: result size = 3.	self assert: (result first atIndex: 1) id = 86.	self assert: ((result first atIndex: 1) address yourSelf == result first last).</body></methods><methods><class-id>Glorp.GlorpReadQueryTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpBooleanTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">testBoolean	stType := Boolean.	self helpTestValue: nil compareWith: [:read :original |		self platform usesNullForFalse ifTrue: [read = false] ifFalse: [read = nil]].	self helpTestValue: true.	self helpTestValue: false.</body></methods><methods><class-id>Glorp.GlorpBooleanTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform boolean.</body></methods><methods><class-id>Glorp.GlorpFloat4Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform float4.</body></methods><methods><class-id>Glorp.GlorpFloat4Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testFloat4	self helpTestFloat: nil.	self helpTestValue: 3.14 compareWith: [:read :original |		read - original &lt;= 0.00001].</body></methods><methods><class-id>Glorp.ClassI</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassI := nil.	attrBClassI := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.ClassI</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassI	^attrAClassI</body><body package="GlorpTestModels">attrAClassI: anObject	attrAClassI := anObject</body><body package="GlorpTestModels">attrBClassI	^attrBClassI</body><body package="GlorpTestModels">attrBClassI: anObject	attrBClassI := anObject</body></methods><methods><class-id>Glorp.ClassI class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpFloat8Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform float8</body><body package="GlorpDBTypeTests">testFloat8	type := (self platform) double.	self helpTestFloat: nil.	self helpTestValue: (Dialect coerceToDoublePrecisionFloat: 3.14) compareWith: [:read :original |		read - original &lt;= 0.0000001].</body></methods><methods><class-id>Glorp.GlorpPassenger</class-id> <category>accessing</category><body package="GlorpTestModels">airline	^airline.</body><body package="GlorpTestModels">airline: anAirline	airline := anAirline.</body><body package="GlorpTestModels">frequentFlyerPoints	^frequentFlyerMiles.</body><body package="GlorpTestModels">frequentFlyerPoints: aSmallInteger 	frequentFlyerMiles := aSmallInteger.</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: aSmallInteger 	id := aSmallInteger.</body><body package="GlorpTestModels">name	^name.</body><body package="GlorpTestModels">name: aString 	name := aString.</body></methods><methods><class-id>Glorp.GlorpPassenger class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		id: 3;		name: 'Some Passenger';		frequentFlyerPoints: 10000;		airline: GlorpAirline example1.</body><body package="GlorpTestModels">example2	^self new		id: 39;		name: 'Some Other Passenger';		frequentFlyerPoints: 7;		airline: GlorpAirline example2.</body></methods><methods><class-id>Glorp.GlorpDateTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform date</body></methods><methods><class-id>Glorp.GlorpDateTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">testDate	| date |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding date test for VisualAge'. ^self].	date := Date today.	stType := Date.	self helpTestValue: date.	self helpTestValue: nil.</body><body package="GlorpDBTypeTests">testDateCast	"SQLite does not have time-related types:  they are all mapped to strings.  I have not debugged why this test fails yet but assume it is completely unrealistic to expect a string to be cast to a timestamp."	| date model |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding date test for VisualAge'. ^self].	date := Date today.	session transact: [session register: (GlorpTypeTestsModelClass new test: date)].	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test cast: session platform date) = date].	self deny: model isNil		description: 'This test will fail on SQLite which has no DB Date type;  see test comment'.	self assert: model test = date.	model := 	model := session platform isDB2Platform		ifTrue:			[session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test timestamp: (each test time0)) = date]]		ifFalse:			[session readOneOf: GlorpTypeTestsModelClass where: [:each | (each test cast: session platform timestamp) = date]].	self deny: model isNil.	self assert: model test = date.	model := session readOneOf: GlorpTypeTestsModelClass where: [:each | each test asDate = date].	self deny: model isNil.	self assert: model test = date.</body></methods><methods><class-id>Glorp.GlorpBankTransaction</class-id> <category>accessing</category><body package="GlorpTestModels">amount	^amount</body><body package="GlorpTestModels">amount: aGlorpMoney 	amount := aGlorpMoney</body><body package="GlorpTestModels">id	"Private - Answer the value of the receiver's ''id'' instance variable."	^id</body><body package="GlorpTestModels">id: anObject	"Private - Set the value of the receiver's ''id'' instance variable to the argument, anObject."	id := anObject</body><body package="GlorpTestModels">owner	"Private - Answer the value of the receiver's ''owner'' instance variable."	^owner</body><body package="GlorpTestModels">owner: aCustomer 	owner := aCustomer</body><body package="GlorpTestModels">serviceCharge	^serviceCharge</body><body package="GlorpTestModels">serviceCharge: aServiceCharge 	serviceCharge := aServiceCharge</body></methods><methods><class-id>Glorp.GlorpBankTransaction</class-id> <category>initialize</category><body package="GlorpTestModels">initialize	amount := GlorpMoney forAmount: 0.	serviceCharge := GlorpServiceCharge default.</body></methods><methods><class-id>Glorp.GlorpBankTransaction class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new</body><body package="GlorpTestModels">example2	^self new</body></methods><methods><class-id>Glorp.GlorpBankTransaction class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpVarchar2Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform varchar: 2.</body></methods><methods><class-id>Glorp.GlorpVarchar2Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testTrimmedChar2	| converter |	stType := String.	converter := type platform converterNamed: #stringToTrimmedString.	self assert: (converter convert:  'abc' toDatabaseRepresentationAs: type) = 'ab'.	self assert: (converter convert:  'abcd' toDatabaseRepresentationAs: type) = 'ab'.	self assert: (converter convert:  'abcde' toDatabaseRepresentationAs: type) = 'ab'.</body><body package="GlorpDBTypeTests">testVarChar2	stType := String.	self helpTestValue: nil.	self helpTestValue: '' compareWith: [:read :original |		self platform usesNullForEmptyStrings ifTrue: [read = nil] ifFalse: [read = original]].	self helpTestValue: 'a'.	self helpTestValue: 'ab'.	"These overlong-means-invalid checks fail on SQLite where column length limits are unenforced."	self should: [self helpTestInvalidValue: 'abc'] raise: GlorpDatabaseWriteError.	self should: [self helpTestInvalidValue: 'abcd'] raise: GlorpDatabaseWriteError.	self should: [self helpTestInvalidValue: 'abcde'] raise: GlorpDatabaseWriteError.</body></methods><methods><class-id>GlorpCitiesGraph</class-id> <category>accessing</category><body package="GlorpTestModels">city	^city</body><body package="GlorpTestModels">city: anObject	city := anObject</body><body package="GlorpTestModels">distance	^distance</body><body package="GlorpTestModels">distance: anObject	distance := anObject</body><body package="GlorpTestModels">nextCity	^nextCity</body><body package="GlorpTestModels">nextCity: anObject	nextCity := anObject</body></methods><methods><class-id>Glorp.GlorpRegionalManager</class-id> <category>accessing</category><body package="GlorpTestModels">region	^region</body><body package="GlorpTestModels">region: anObject	region := anObject</body></methods><methods><class-id>Glorp.GlorpRegionalManager</class-id> <category>comparing</category><body package="GlorpTestModels">= aRegionalManager	^super = aRegionalManager and: [region = aRegionalManager region].</body></methods><methods><class-id>Glorp.GlorpBankBranch</class-id> <category>accessing</category><body package="GlorpTestModels">accounts	^accounts</body><body package="GlorpTestModels">accounts: anObject	accounts := anObject</body><body package="GlorpTestModels">branchNumber	^branchNumber.</body><body package="GlorpTestModels">branchNumber: aString	branchNumber := aString</body></methods><methods><class-id>Glorp.GlorpBankBranch</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', self branchNumber printString, ')'.</body></methods><methods><class-id>Glorp.GlorpVariableTypeTestSystem</class-id> <category>classes</category><body package="GlorpTestModels">classModelForGlorpGallery: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #images collectionOf: GlorpImageFile.	"Not a real attribute, but used in our conditional mapping."	aClassModel newAttributeNamed: #imagesLink collectionOf: GlorpImageLink.</body><body package="GlorpTestModels">classModelForGlorpImageFile: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #bits type: ByteArray.	(aClassModel newAttributeNamed: #thumbnailBits type: ByteArray) useDirectAccess: false.</body><body package="GlorpTestModels">classModelForGlorpImageLink: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #title.	aClassModel newAttributeNamed: #thumbnailBits type: ByteArray.	aClassModel newAttributeNamed: #fullImage type: GlorpImageFile.</body><body package="GlorpTestModels">descriptorForGlorpGallery: aDescriptor		| table linkTable imagesConditional |	table := self tableNamed: 'GALLERY'.	linkTable := self tableNamed: 'GALLERY_LINK'.	aDescriptor table: table.	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #name.	imagesConditional := (aDescriptor newMapping: ConditionalToManyMapping)		attributeName: #images;		join: Join new.	imagesConditional		forField: (linkTable fieldNamed: 'LARGE')		attribute: [:object | object isLarge]		if: [:x | x = true]		useMapping:			((imagesConditional newMapping: ToManyMapping)				attributeName: #imagesLink;				useLinkTable;				join:						(Join								from: (table fieldNamed: 'ID')								to: (linkTable fieldNamed: 'GALLERY_ID')								from: 'T'								to: (linkTable fieldNamed: 'LARGE'))).	imagesConditional		otherwise:			((imagesConditional newMapping: ToManyMapping)				attributeName: #images;				useLinkTable;				join:						(Join								from: (table fieldNamed: 'ID')								to: (linkTable fieldNamed: 'GALLERY_ID')								from: 'F'								to: (linkTable fieldNamed: 'LARGE'))).</body><body package="GlorpTestModels">descriptorForGlorpImageFile: aDescriptor		aDescriptor table: 'GLORP_IMAGE_FILE'.	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #title.	aDescriptor directMappingFor: #bits.	aDescriptor directMapping from: #thumbnailBits to: 'THUMBNAIL_BITS'.</body><body package="GlorpTestModels">descriptorForGlorpImageLink: aDescriptor		aDescriptor table: 'GLORP_IMAGE_FILE'.	aDescriptor directMappingFor: #id.	aDescriptor directMappingFor: #title.	aDescriptor directMapping from: #thumbnailBits to: 'THUMBNAIL_BITS'.	"This is really joining to our own table to get the full version of ourselves"	aDescriptor oneToOneMapping 		attributeName: #fullImage;		join: (Join from: (aDescriptor table fieldNamed: 'ID') to: (aDescriptor table fieldNamed: 'ID')).</body><body package="GlorpTestModels">tableForGALLERY: aTable	aTable createFieldNamed: 'ID' type: platform serial.	aTable createFieldNamed: 'NAME' type: platform text.</body><body package="GlorpTestModels">tableForGALLERY_LINK: aTable	| galleryId imageId |	galleryId := aTable createFieldNamed: 'GALLERY_ID' type: platform integer.	aTable addForeignKeyFrom: galleryId to: ((self tableNamed: 'GALLERY') fieldNamed: 'ID').	imageId := aTable createFieldNamed: 'IMAGE_ID' type: platform integer.	aTable addForeignKeyFrom: imageId to: ((self tableNamed: 'GLORP_IMAGE_FILE') fieldNamed: 'ID').	"Avoid booleans here because they aren't portable"	aTable createFieldNamed: 'LARGE' type: (platform char: 1).</body><body package="GlorpTestModels">tableForGLORP_IMAGE_FILE: aTable	aTable createFieldNamed: 'ID' type: platform serial.	aTable createFieldNamed: 'TITLE' type: platform text.	aTable createFieldNamed: 'BITS' type: platform blob.	aTable createFieldNamed: 'THUMBNAIL_BITS' type: platform blob.</body></methods><methods><class-id>Glorp.GlorpPictureReview</class-id> <category>accessing</category><body package="GlorpTestModels">picture	^picture</body><body package="GlorpTestModels">picture: aGlorpTaggableObject	picture := aGlorpTaggableObject.</body><body package="GlorpTestModels">sequence	^sequence</body><body package="GlorpTestModels">sequence: anInteger	sequence := anInteger.</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels">bookExample1	^(GlorpBook new)		title: 'Mastering ENVY/Developer';		author: 'Knight/Pelrine/Cho';		description:				'Absolutely the best book written on ENVY/Developer by a set of authors all living on different continents';		copiesInStock: 2000;		version: 1.</body><body package="GlorpTestModels">bookExample2	^(GlorpBook new)		title: 'The Bad Beginning';		author: 'Lemony Snicket';		description: 'Very fine description of the EJB standards process';		copiesInStock: 3;		version: 5.</body><body package="GlorpTestModels">customerExample1	^(GlorpBookstoreCustomer new)		accountNumber: '123456789ABCDEF';		name: 'Aunt Colof'.</body><body package="GlorpTestModels">customerExample2	^(GlorpBookstoreCustomer new)		accountNumber: '7';		name: 'Veronica Filbert Davidson'.</body><body package="GlorpTestModels">example1	"Return an example start set of books, customers and orders."	| cust1 cust2 book1 book2 |	cust1 := self customerExample1.	cust2 := self customerExample2.	book1 := self bookExample1.	book2 := self bookExample2.	^Array		with: book1		with: book2		with: cust1		with: cust2.</body><body package="GlorpTestModels">example2	"Return an example start set of books, customers and orders."	| book1 book2 book3 book4 customer1 customer2 |	book1 := GlorpBook example1.	book2 := GlorpBook example2.	book3 := GlorpBook example3.	book4 := GlorpBook example4.	customer1 := self customerExample1.	customer2 := self customerExample2.	customer1 booksOnOrder: (Array with: book1 with: book3).	customer2 booksOnOrder: (Array with: book2 with: book4).	^OrderedCollection new		add: book1;		add: book2;		add: book3;		add: book4;		add: customer1;		add: customer2;		yourself		.</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels">allTableNames	^#('BOOK' 'BOOK_CUSTOMER' 'CUSTOMER_BOOK_LINK').</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses) 		add: GlorpBook;		add: GlorpBookstoreCustomer;		yourself.</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForBOOK: aTable	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'TITLE' type: (platform varChar: 100).	aTable createFieldNamed: 'DESCRIPTION' type: (platform varChar: 255).	aTable createFieldNamed: 'COPIES_IN_STOCK' type: (platform int4).	(aTable createFieldNamed: 'VERSION' type: (platform versionFieldFor: platform int4))		beLockKey;		"let's us test ordinary lock key behaviour"		beNullable: true.	"let's us testSuccessfulUpdateOntoNullVersionField"</body><body package="GlorpTestModels">tableForBOOK_CUSTOMER: aTable	(aTable createFieldNamed: 'ACCOUNT_NUMBER' type: (platform varChar: 15)) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 100).</body><body package="GlorpTestModels">tableForCUSTOMER_BOOK_LINK: aTable	| custKey bookKey |	custKey := aTable createFieldNamed: 'CUSTOMER_ACCT_NUM' type: (platform varChar: 15).	aTable addForeignKeyFrom: custKey		to: ((self tableNamed: 'BOOK_CUSTOMER') fieldNamed: 'ACCOUNT_NUMBER').	bookKey := aTable createFieldNamed: 'BOOK_ID' type: (platform int4).		aTable addForeignKeyFrom: bookKey		to: ((self tableNamed: 'BOOK') fieldNamed: 'ID').</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForGlorpBook: aDescriptor	| table |	table := self tableNamed: 'BOOK'.	aDescriptor table: table.	aDescriptor addMapping: (			DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (			DirectMapping from: #title to: (table fieldNamed: 'TITLE')).	aDescriptor addMapping: (			DirectMapping from: #copiesInStock to: (table fieldNamed: 'COPIES_IN_STOCK')).	aDescriptor addMapping: (			DirectMapping from: #version to: (table fieldNamed: 'VERSION')).</body><body package="GlorpTestModels">descriptorForGlorpBookstoreCustomer: aDescriptor	| table |	table := self tableNamed: 'BOOK_CUSTOMER'.	aDescriptor table: table.	aDescriptor addMapping: (			DirectMapping from: #accountNumber to: (table fieldNamed: 'ACCOUNT_NUMBER')).	aDescriptor addMapping: (			DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (			ManyToManyMapping new			attributeName: #booksOnOrder;			referenceClass: GlorpBook).</body></methods><methods><class-id>Glorp.GlorpLockingDescriptorSystem</class-id> <category>optimization parameters</category><body package="GlorpTestModels">shouldUpdateOnlyChangedFieldsFor: aCommand	"Allow testing of both cases by switching binding state."	^aCommand useBinding not</body></methods><methods><class-id>Glorp.GlorpBankAccountNumber</class-id> <category>accessing</category><body package="GlorpTestModels">accountNumber	^accountNumber</body><body package="GlorpTestModels">accountNumber: anObject	accountNumber := anObject</body><body package="GlorpTestModels">bankCode	^bankCode</body><body package="GlorpTestModels">bankCode: anObject	bankCode := anObject</body><body package="GlorpTestModels">branchNumber	^branchNumber</body><body package="GlorpTestModels">branchNumber: anObject	branchNumber := anObject</body></methods><methods><class-id>Glorp.GlorpBankAccountNumber class</class-id> <category>examples</category><body package="GlorpTestModels">example12345	^self new		accountNumber: 12345;		bankCode: 4;		branchNumber: 777.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaStockDescriptorSystem</class-id> <category>examples</category><body package="GlorpTestModels">examplePublisher1	"Put in the copies to avoid an issue with reverting immutable objects."	^GlorpTinyPublisher new 		id: 1;		name: 'Cambridge';		titles: (Array with: 'Mastering ENVY/Developer' copy with: 'Principia Mathematica' copy with:  'Metadata-Based Persistence for Dummies' copy);		titlesWithNumberInStock: (Dictionary new			at:  'Mastering ENVY/Developer' put: 2;			at: 'Principia Mathematica' put: 2;			at: 'Metadata-Based Persistence for Dummies' put: 2;			yourself).</body><body package="GlorpTestModels">examplePublisher2	^GlorpTinyPublisher new 		id: 2;		name: 'Harper Collins';		titles: (Array with: 'A book' copy);		titlesWithNumberInStock: (Dictionary new			at:  'A book' copy put: 200;			yourself).</body><body package="GlorpTestModels">examplePublishers	^Array with: self examplePublisher1 with: self examplePublisher2</body></methods><methods><class-id>Glorp.GlorpEncyclopediaStockDescriptorSystem</class-id> <category>other</category><body package="GlorpTestModels">allTableNames	^#('GR_TINY_PUBLISHER' 'PU2B_TITLES_STOCK')</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpTinyPublisher;		yourself</body></methods><methods><class-id>Glorp.GlorpEncyclopediaStockDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForGR_TINY_PUBLISHER: aTable 	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForPU2B_TITLES_STOCK: aTable 	"Use a different table name to avoid conflicts with GlorpEncyclopediaDescriptorSystem."	| pubId |	pubId := (aTable createFieldNamed: 'TINY_PUBLISHER_ID' type: platform int4) bePrimaryKey; yourself.	aTable addForeignKeyFrom: pubId  to: ((self tableNamed: 'GR_TINY_PUBLISHER') fieldNamed: 'ID').	(aTable createFieldNamed: 'TITLE' type: (platform varChar: 50)) bePrimaryKey.	aTable createFieldNamed: 'STOCK' type: platform int4.	aTable createFieldNamed: 'UNUSED' type: (platform varchar: 10).</body></methods><methods><class-id>Glorp.GlorpEncyclopediaStockDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">classModelForGlorpTinyPublisher: aClassModel  	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name. 	aClassModel newAttributeNamed: #titles collection: Array of: String.	aClassModel newAttributeNamed: #titlesWithNumberInStock dictionaryFrom: String to: Integer.</body><body package="GlorpTestModels">descriptorForGlorpTinyPublisher: aDescriptor 	| table titleStockTable |	table := self tableNamed: 'GR_TINY_PUBLISHER'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'NAME').	titleStockTable := self tableNamed: 'PU2B_TITLES_STOCK'.	(aDescriptor newMapping: DictionaryMapping)		attributeName: #titlesWithNumberInStock;		usesLinkTable: false;		keyField: (titleStockTable fieldNamed: 'TITLE');		valueField: (titleStockTable fieldNamed: 'STOCK');		join: (Join from: (table fieldNamed: 'ID') to: (titleStockTable fieldNamed: 'TINY_PUBLISHER_ID')).</body></methods><methods><class-id>Glorp.Station</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">successor	^successor</body><body package="GlorpTestModels">successor: anObject	successor := anObject</body></methods><methods><class-id>Glorp.GlorpMappingDBTest</class-id> <category>support</category><body package="GlorpDBTests">inTransactionDo: aBlock	[session beginTransaction.	aBlock value] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">tearDown	super tearDown.	session reset.	session resetPermissions.	session := nil.	system := nil.</body></methods><methods><class-id>Glorp.GlorpMappingDBTest</class-id> <category>Running</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	system := session system.</body></methods><methods><class-id>Glorp.GlorpMappingDBTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpMappingDBTest class</class-id> <category>testing</category><body package="GlorpDBTests">isAbstract	^self sunitName = #GlorpMappingDBTest</body></methods><methods><class-id>Glorp.GlorpVariableTypeTest</class-id> <category>testing</category><body package="GlorpDBTests">testRead	| gallery image |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example1).		session modify: gallery in: [].		session reset.		gallery := session readOneOf: GlorpGallery.		self assert: gallery images size = 1.		image := gallery images first.		self assert: image class = GlorpImageFile.		self assert: image bits = GlorpImageFile example1 bits.		].</body><body package="GlorpDBTests">testReadBoth	| gallery image link |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example2); add: (GlorpImageFile example1).		session modify: gallery in: [].		session reset.		gallery := session readOneOf: GlorpGallery.		self assert: gallery images size = 2.		self assert: (gallery images select: [:each | each class = GlorpImageFile]) size = 1.		image := gallery images detect: [:each | each class = GlorpImageFile].		link := gallery images detect: [:each | each class = GlorpImageLink].		self assert: (gallery images collect: [:each | each id]) asSet size = 2.		self assert: image bits = (GlorpImageFile example1 bits).		self assert: image thumbnailBits = (GlorpImageFile example1 bits).		self assert: image thumbnailBits = (GlorpImageFile example2 thumbnailBits).		].</body><body package="GlorpDBTests">testReadLarge	| gallery image |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example2).		session modify: gallery in: [].		session reset.		gallery := session readOneOf: GlorpGallery.		self assert: gallery images size = 1.		image := gallery images first.		self assert: image class = GlorpImageLink.		self assert: image thumbnailBits = (GlorpImageFile example2 thumbnailBits) .		].</body><body package="GlorpDBTests">testWrite	| gallery images links |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example1).		session modify: gallery in: [].		session reset.		images := session accessor executeSQLString: 'SELECT * FROM GLORP_IMAGE_FILE'.		self assert: images size = 1.		links := session accessor executeSQLString: 'SELECT GALLERY_ID, IMAGE_ID, LARGE FROM GALLERY_LINK'.		self assert: links size = 1.		self assert: links first last ='F'].</body><body package="GlorpDBTests">testWriteLarge	| gallery images links |	self inTransactionDo: [		gallery := GlorpGallery new name: 'Some Gallery'.		gallery images add: (GlorpImageFile example2).		session modify: gallery in: [].		session reset.		images := session accessor executeSQLString: 'SELECT * FROM GLORP_IMAGE_FILE'.		self assert: images size = 1.		links := session accessor executeSQLString: 'SELECT GALLERY_ID, IMAGE_ID, LARGE FROM GALLERY_LINK'.		self assert: links size = 1.		self assert: links first last = 'T'].</body></methods><methods><class-id>Glorp.GlorpVariableTypeTest</class-id> <category>Running</category><body package="GlorpDBTests">setUp	super setUp.	system := GlorpVariableTypeTestSystem forPlatform: session system platform.	session system: system.</body></methods><methods><class-id>Glorp.GlorpRowMapForMementosCollectionTest</class-id> <category>tests</category><body package="GlorpTestModels">createRowMap	rowMap := RowMapForMementos withCorrespondenceMap: transaction undoMap.	rowMap collectionMementos: transaction collectionMementos.	newCollection := rowMap collectionMementoFor: collection.</body><body package="GlorpTestModels">testArray	collection := Array with: 1 with: 2 with: 3 with: 4.	copy := collection copy.	transaction register: collection.	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection = copy.	self deny: newCollection = collection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels">testDictionary	collection := Dictionary new.	1 to: 50 do: [:i | collection at: i put: i printString].	copy := collection copy.	transaction register: collection.	#( 1 2 7 43 15 9 10 17 18 19 33 23) do: [:i | collection removeKey: i].	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection size = copy size.	self assert: newCollection keys asSortedCollection = copy keys asSortedCollection.	self assert: newCollection values asSortedCollection = copy values asSortedCollection.	self deny: newCollection values asSortedCollection = collection values asSortedCollection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels">testIdentityDictionary	collection := IdentityDictionary new.	1 to: 50 do: [:i | collection at: i put: i printString].	copy := collection copy.	transaction register: collection.	#( 1 2 7 43 15 9 10 17 18 19 33 23) do: [:i | collection removeKey: i].	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection size = copy size.	self assert: newCollection keys asSortedCollection = copy keys asSortedCollection.	self assert: newCollection values asSortedCollection = copy values asSortedCollection.	self deny: newCollection values asSortedCollection = collection values asSortedCollection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels">testOrderedCollection	collection := (1 to: 50) asOrderedCollection.	copy := collection copy.	transaction register: collection.	12 timesRepeat: [collection removeLast].	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection = copy.	self deny: newCollection = collection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels">testOrderedSet	collection := (Dialect smalltalkAt: #OrderedSet ifAbsent: [^self]) new.	1 to: 50 do: [:i | collection add: i].	copy := collection copy.	transaction register: collection.	#( 1 2 7 43 15 9 10 17 18 19 33 23) do: [:i | collection remove: i].	collection add: 999.	self createRowMap.	self assert: newCollection asSortedCollection = copy asSortedCollection.	self deny: newCollection asSortedCollection = collection asSortedCollection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels">testRBSmallDictionary	collection := (Dialect smalltalkAt: #RBSmallDictionary ifAbsent: [^self]) new.	1 to: 50 do: [:i | collection at: i put: i printString].	copy := collection copy.	transaction register: collection.	#( 1 2 7 43 15 9 10 17 18 19 33 23) do: [:i | collection removeKey: i].	collection at: 3 put: 'hello'.	self createRowMap.	self assert: newCollection size = copy size.	self assert: newCollection keys asSortedCollection = copy keys asSortedCollection.	self assert: newCollection values asSortedCollection = copy values asSortedCollection.	self deny: newCollection values asSortedCollection = collection values asSortedCollection		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body><body package="GlorpTestModels">testSet	collection := (1 to: 50) asSet.	copy := collection copy.	transaction register: collection.	1 to: 12 do: [:i | collection remove: i].	collection add: 'hello'.	self createRowMap.	self assert: newCollection asSortedCollection = copy asSortedCollection.	self deny: newCollection size = collection size		description: 'Copying is too shallow both here and in registerTransientInternalsOfCollection:'.</body></methods><methods><class-id>Glorp.GlorpRowMapForMementosCollectionTest</class-id> <category>support</category><body package="GlorpTestModels">setUp	transaction := ObjectTransaction new.	rowMap := nil.</body></methods><methods><class-id>Glorp.GlorpDatabaseTableTest</class-id> <category>tests</category><body package="GlorpDBTests">testFKUniqueNames	| platform contactTable linkTable companyId personId |	platform := GlorpDatabaseLoginResource defaultPlatform.	contactTable := DatabaseTable new						name: 'CONTACT';						yourself.	contactTable createFieldNamed: 'ID' type: platform serial.	linkTable := DatabaseTable new						name: 'COMPANY_PERSON_LINK';						yourself.	companyId := linkTable createFieldNamed: 'COMPANY_ID' type: platform int4.	personId := linkTable createFieldNamed: 'PERSON_ID' type: platform int4.	linkTable		addForeignKeyFrom: companyId to: (contactTable fieldNamed: 'ID');		addForeignKeyFrom: personId to: (contactTable fieldNamed: 'ID').	self assert: (linkTable foreignKeyConstraints collect: [:ea | ea name asSymbol]) asSet size = linkTable foreignKeyConstraints size.</body><body package="GlorpDBTests">testIndexes	| platform contactTable idField name1Field name2Field |	platform := GlorpDatabaseLoginResource defaultPlatform.	contactTable := DatabaseTable new						name: 'CONTACT';						yourself.	idField := (contactTable createFieldNamed: 'ID' type: platform serial) beIndexed.	self assert: contactTable indexes size = 1.	self assert: (contactTable hasIndexForField: idField).	name1Field := contactTable createFieldNamed: 'NAME1' type: platform varchar.	name2Field := contactTable createFieldNamed: 'NAME2' type: platform varchar.	self deny: (contactTable hasIndexForField: name1Field).	contactTable addIndexForFields: (Array with: name1Field with: name2Field).	self assert: contactTable indexes size = 2.	self assert: (contactTable hasIndexForField: idField).	self assert: (contactTable hasIndexForField: name1Field).	self assert: (contactTable hasIndexForField: name2Field).</body></methods><methods><class-id>Glorp.GlorpOwnerSlaveTest</class-id> <category>tests</category><body package="GlorpDBTests">test1	| owner slaves table field |	self		inTransactionDo:			[owner := GlorpOwner new.			owner id: 1.			slaves := OrderedCollection new.			1 to: 5 do: [:id | slaves add: (GlorpSlave new id: id)].			owner slaves: slaves.			owner slave: slaves last.			session beginUnitOfWork.			session register: owner.			session commitUnitOfWork.			session reset.			owner := session readOneOf: GlorpOwner where: [:each | each id = 1].			self assert: owner slaves isEmpty not.			table := session system tableNamed: 'GLORP_SLAVE'.			field := table fieldNamed: 'OWNER_ID'.			slaves := session				read: GlorpSlave				where: [:each | ((each getTable: table) getField: field) ~= nil].			self assert: slaves size = 5].</body><body package="GlorpDBTests">testSortOrder	"Validate that it doesn't matter what order we put in the input, the tables come out in the correct sort order."	| justTheseTables sorted sorted2 |	justTheseTables := Array with: (system tableNamed: 'GLORP_OWNER') with: (system tableNamed: 'GLORP_SLAVE').	sorted := (TableSorter for: justTheseTables) sort.	sorted2 := (TableSorter for: justTheseTables reverse) sort.	self assert: sorted = sorted2.	self assert: sorted first name = 'GLORP_SLAVE'.</body></methods><methods><class-id>Glorp.GlorpDatabaseIndexTest</class-id> <category>tests</category><body package="GlorpDBTests">testNameGeneration	| platform table field index |	platform := GlorpDatabaseLoginResource defaultPlatform.	table := DatabaseTable new						name: 'A_VERY_VERY_VERY_LONG_TABLE_NAME';						yourself.	field := table createFieldNamed: 'A_VERY_LONG_FIELD_NAME' type: platform serial.	index := table addIndexForField: field.	self assert: index name size &lt;= platform maximumLengthOfTableName.</body><body package="GlorpDBTests">testNameGenerationLong	| platform table field index |	"SQL Server has very long IDs"	platform := SQLServerPlatform new.	table := DatabaseTable new						name: 'A_VERY_VERY_VERY_LONG_TABLE_NAME';						yourself.	field := table createFieldNamed: 'A_VERY_LONG_FIELD_NAME' type: platform serial.	index := table addIndexForField: field.	self assert: index name size &lt;= platform maximumLengthOfTableName.	self assert: index name = (table name, '_', field name, '_IDX').</body></methods><methods><class-id>Glorp.ASOrder</class-id> <category>accessing</category><body package="GlorpTestModels">customer	^customer</body><body package="GlorpTestModels">customer: anObject	customer := anObject</body><body package="GlorpTestModels">lineItems	^lineItems</body><body package="GlorpTestModels">lineItems: anObject	lineItems := anObject</body><body package="GlorpTestModels">orderNo	^orderNo</body><body package="GlorpTestModels">orderNo: anObject	orderNo := anObject</body></methods><methods><class-id>Glorp.ASOrder</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	orderNo := nil.	lineItems := OrderedCollection new.</body></methods><methods><class-id>Glorp.ASOrder class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>tests-read</category><body package="GlorpDBTests">additionalTests	"It would be good to have tests here for a foreign key 'pointing' the other direction. Also composite keys (once those work)"</body><body package="GlorpDBTests">testReRegisteringAfterUpdate	"Test that even if we re-register the object after it's been modified, we still write the changes."	self		inTransactionDo:			[self writePersonWithAddress.			session reset.			session beginUnitOfWork.			person := (session read: GlorpPerson) first.			person name: 'new name'.			session register: person.			session commitUnitOfWork.			session reset.			self readPerson.			self assert: person name = 'new name'].</body><body package="GlorpDBTests">testReadAction	| collection |	self		inTransactionDo:			[collection := OrderedCollection new.			self writePersonWithAddress.			((session system descriptorFor: GlorpPerson)				mappingForAttributeNamed: #address)				proxyAction: [:owner :object | collection add: owner -&gt; object].			person := session readOneOf: GlorpPerson.			person address yourSelf.			self assert: collection size = 1.			self assert: collection first = (person -&gt; person address yourSelf)].</body><body package="GlorpDBTests">testReadPersonAndAddAddress	self inTransactionDo: [		self 			inUnitOfWorkDo: [person address: (GlorpAddress new id: 5555; street: 'hello'; number: 'world')]			initializeWith: [self writeHomelessPerson].		self readPerson.		self checkPerson].</body><body package="GlorpDBTests">testReadPersonAndAddBogusCollectionInsteadOfAddress	self inTransactionDo: [		self should: [self 				inUnitOfWorkDo: [person address: #()]				initializeWith: [self writeHomelessPerson]]			raise: GlorpInvalidTypeError].</body><body package="GlorpDBTests">testReadPersonAndAddBogusObjectInsteadOfAddress	self inTransactionDo: [		self should: [self 				inUnitOfWorkDo: [person address: GlorpPerson new]				initializeWith: [self writeHomelessPerson]]			raise: GlorpInvalidTypeError].</body><body package="GlorpDBTests">testReadPersonAndAddBogusObjectInsteadOfEmailAddresses	self inTransactionDo: [		self should: [self 				inUnitOfWorkDo: [person emailAddresses: 42]				initializeWith: [self writeHomelessPerson]]			raise: GlorpInvalidTypeError].</body><body package="GlorpDBTests">testReadPersonAndAddBogusObjectInsteadOfEmailAddresses2	self inTransactionDo: [		self should: [self 				inUnitOfWorkDo: [person emailAddresses: GlorpEmailAddress new]				initializeWith: [self writeHomelessPerson]]			raise: GlorpInvalidTypeError].</body><body package="GlorpDBTests">testReadPersonAndRemoveAddress	self inTransactionDo: [		self inUnitOfWorkDo: [			session delete: person address.			person address: nil.].		self readPerson.		self checkPerson.		self checkNoAddress.		self checkNoAddressesInDB].</body><body package="GlorpDBTests">testReadPersonAndReplaceAddress	self inTransactionDo:		[self inUnitOfWorkDo: 			[person address: ((GlorpAddress new) id: 12; street: 'foo'; number: '1234')].		self readPerson.		self checkPerson.		self assert: person address isGlorpProxy.		self assert: person address getValue id = 12.		self assert: person address getValue street = 'foo'.].</body><body package="GlorpDBTests">testReadPersonAndReplaceAdressWithDifferentProxy	| proxy |	self inTransactionDo: 			[			session writeRow: session system exampleAddressRowForOrdering1.			self inUnitOfWorkDo: 					[ | field |					proxy := Proxy new.					proxy query: person address query copy.					field := (session system tableNamed: 'PERSON') fieldNamed: 'ADDRESS_ID'.					proxy parameters: (IdentityDictionary new at: field put: 1; yourself).					proxy session: person address session.					person address: proxy].			self readPerson.			self checkPerson.			self assert: person address isGlorpProxy.			self assert: person address getValue notNil.			self assert: person address getValue id = 1]</body><body package="GlorpDBTests">testReadPersonAndReplaceAdressWithProxy	| proxy |	self inTransactionDo: 			[self inUnitOfWorkDo: 					[proxy := Proxy new.					proxy query: person address query copy.					proxy parameters: person address parameters copy.					proxy session: person address session.					person address: proxy].			self readPerson.			self checkPerson.			self assert: person address isGlorpProxy.			self assert: person address getValue notNil.			self assert: person address getValue id = 123]</body><body package="GlorpDBTests">testReadPersonAndUpdateName	"Test to make sure that if we update a person while deferring instantiating their address, we don't have problems with that relationship."	self inTransactionDo:		[self inUnitOfWorkDo: [person name: 'new name'].		self deny: person address isInstantiated.		session reset.		self readPerson.		self assert: person name = 'new name'.		self assert: person address isGlorpProxy.		self deny: (session isNewObjectOrInstantiatedProxy: person address)			description: '#isNew: would DNU here but #isNewObjectOrInstantiatedProxy: should not'.		self assert: (session isUninstantiatedProxy: person address).		self assert: person address getValue id = 123.		self assert: person address getValue street = 'Paseo Montril'].		self deny: (session isUninstantiatedProxy: person address).		self deny: (session isNewObjectOrInstantiatedProxy: person address)			description: '#isNew: would DNU here but #isNewObjectOrInstantiatedProxy: should not'.		self deny: (session isNew: person address yourSelf).	"address getValue would also work but be less polymorphic"</body><body package="GlorpDBTests">testReadPersonWithAddress	self inTransactionDo: [		self writePersonWithAddress.		self readPerson.		self checkPerson.		self checkAddress].</body><body package="GlorpDBTests">testReadPersonWithoutAddress	self inTransactionDo: [		self writeHomelessPerson.		self writeAddress.		self readPerson.		self checkPerson.		self checkNoAddress].</body><body package="GlorpDBTests">testReadWithCacheHitFromExpression	self		inTransactionDo:			[self				inUnitOfWorkDo:					[self assert: person address yourSelf id = 123.					session accessor permitNothing.					session readOneOf: GlorpAddress where: [:each | each id = 123]]].</body><body package="GlorpDBTests">testReadWithCacheHitFromJoin	self inTransactionDo: [		self 			inUnitOfWorkDo: [				session readOneOf: GlorpAddress.				session accessor permitNothing.				self assert: (person address yourSelf id = 123)]].</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>support</category><body package="GlorpDBTests">checkAddress	self assert: person address isGlorpProxy.	self assert: person address getValue id = 123.	^self assert: person address getValue class == GlorpAddress.</body><body package="GlorpDBTests">checkNoAddress	self deny: person address isGlorpProxy.	self assert: person address == nil.</body><body package="GlorpDBTests">checkNoAddressesInDB	| addresses addressKeys |	addresses := session accessor executeSQLString: 'SELECT * FROM GR_ADDRESS'.	self assert: addresses isEmpty.	addressKeys := session accessor executeSQLString: 'SELECT ADDRESS_ID FROM PERSON'.	self assert: (addressKeys size = 1).	self assert: (addressKeys first atIndex: 1) = nil.</body><body package="GlorpDBTests">checkPerson	self assert: person class = GlorpPerson.	self assert: person id = personId.	self assert: person name = 'aPerson'.</body><body package="GlorpDBTests">inUnitOfWorkDo: aBlock	"Set up a bunch of the normal data, read the objects, then run the block in a unit of work"	self inUnitOfWorkDo: aBlock initializeWith: [self writePersonWithAddress].</body><body package="GlorpDBTests">inUnitOfWorkDo: aBlock initializeWith: initBlock	"Set up a bunch of the normal data, read the objects, then run the block in a unit of work"	initBlock value.	session beginUnitOfWork.	self readPerson.	aBlock value.	session commitUnitOfWork.	session reset.</body><body package="GlorpDBTests">readPerson	| results query |	query := Query		read: GlorpPerson		where: [:pers | pers id = personId].	results := query executeIn: session.	self assert: results size = 1.	person := results first.</body><body package="GlorpDBTests">writeAddress	| addressRow |	addressRow := session system exampleAddressRow.	session writeRow: addressRow.</body><body package="GlorpDBTests">writeHomefulPerson	| personRow |	personRow := session system examplePersonRow1.	session writeRow: personRow.	personId := personRow atFieldNamed: 'ID'.</body><body package="GlorpDBTests">writeHomelessPerson	| personRow |	personRow := session system examplePersonRow2.	session writeRow: personRow.	personId := personRow atFieldNamed: 'ID'.</body><body package="GlorpDBTests">writePersonWithAddress	self writeAddress.	self writeHomefulPerson.</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>tests-write</category><body package="GlorpDBTests">testWritePersonWithAddress	|newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson example1.		personId := newPerson id.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person id = newPerson id.		self assert: person name = newPerson name.		self assert: person address id = newPerson address id.		self assert: person address street = newPerson address street].</body><body package="GlorpDBTests">testWritePersonWithoutAddress	|newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson example1.		newPerson address: nil.		personId := newPerson id.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person id = newPerson id.		self assert: person name = newPerson name.		self assert: person address yourSelf == nil.		self checkNoAddressesInDB].</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>tests-link table</category><body package="GlorpDBTests">testLinkTableRead	| customers |	system := GlorpLinkTableAnywhereDescriptorSystem forPlatform: system platform.	session system: system.	self inTransactionDo: [		self writeCustomersWithOneAccountEach.		session reset.		customers := session read: GlorpCustomer.		self assert: ((customers collect: [:each | each accounts id]) asSortedCollection asArray = #(22 9874))].</body><body package="GlorpDBTests">testLinkTableWrite	system := GlorpLinkTableAnywhereDescriptorSystem		forPlatform: system platform.	session system: system.	self		inTransactionDo:			[| rows row |			self				inUnitOfWorkDo:					[| cust1 acct1 |					cust1 := GlorpCustomer new.					cust1 id: 2.					cust1 name: 'Violet Baudelaire'.					acct1 := GlorpBankAccount new.					acct1 id: 3.					cust1 accounts: acct1.					session register: cust1].			session reset.			rows := session accessor				executeSQLString:					'select * from GR_CUSTOMER t1, BANK_ACCT t2, CUSTOMER_ACCT_LINK t3 WHERE t3.ACCT_ID = t2.ID AND t3.CUSTOMER_ID = t1.ID'.			self assert: rows size = 1.			row := rows first.			self assert: (row asArray = (OrderedCollection new add: 2; add: 'Violet Baudelaire'; add: 3; add: nil; add: nil; add: nil; add: 2; add: 3; yourself) asArray)].</body><body package="GlorpDBTests">writeCustomersWithOneAccountEach	| customerRow accountRow1 accountRow2 linkRow1 linkRow2 customerRow2 |	customerRow := session system exampleCustomerRow1.	customerRow2 := session system exampleCustomerRow2.	accountRow1 := session system exampleAccountRow1. 	accountRow2 := session system exampleAccountRow3.	linkRow1 := session system exampleCALinkRow1.	linkRow2 := session system exampleCALinkRow3.	session writeRow: customerRow.	session writeRow: customerRow2.	session writeRow: accountRow1.	session writeRow: accountRow2.	session writeRow: linkRow1.	session writeRow: linkRow2.</body></methods><methods><class-id>Glorp.GlorpOneToOneDBTest</class-id> <category>tests-join</category><body package="GlorpDBTests">testReadPersonWithJoinToAddress	| people |	self inTransactionDo: [		self writePersonWithAddress.		people := session read: GlorpPerson where: [:eachPerson | eachPerson address street = 'Paseo Montril'].		self assert: people size = 1.		person := people first.		self assert: person address street = 'Paseo Montril'.		self assert: person address id = 123].</body></methods><methods><class-id>Glorp.BatchTestPlatform</class-id> <category>commands</category><body package="GlorpTestModels">insertCommandForRows: aCollectionOfDatabaseRows binding: aBoolean session: aSession	"I do not array bind;  whether binding or not, I can only group if I support group-writing of values."	^self supportsGroupWritingValues		ifTrue: [InsertSelectRowsCommand				forRows: aCollectionOfDatabaseRows				useBinding: aBoolean				session: aSession				ifNoIdentityColumn: InsertMultiValuesCommand]		ifFalse: [InsertSelectRowCommand				forRows: aCollectionOfDatabaseRows				useBinding: aBoolean				session: aSession				ifNoIdentityColumn: InsertCommand]</body><body package="GlorpTestModels">updateCommandForRows: someDatabaseRows binding: aBoolean session: aSession	^(someDatabaseRows first fields anySatisfy: [:each | each type isRelativeType])		ifFalse: [BatchTestUpdateCommand forRows: someDatabaseRows useBinding: aBoolean session: aSession]		ifTrue: [self relativeUpdateCommand forRows: someDatabaseRows useBinding: aBoolean session: aSession]</body></methods><methods><class-id>Glorp.BatchTestPlatform</class-id> <category>binding</category><body package="GlorpTestModels">bindingsForGroupWritingFor: aCommand	"Binding in batch is my reason-d'etre."	^aCommand batchStatementBindings</body></methods><methods><class-id>Glorp.BatchTestPlatform</class-id> <category>testing</category><body package="GlorpTestModels">usesArrayBindingToGroupWrite	"My purpose is to test batch binding, so we deliberately do not use arrays."	^false</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-read</category><body package="GlorpDBTests">checkNumberOfAccounts: anInteger	| accountRows |	accountRows := session accessor		executeSQLString: 'SELECT * FROM BANK_ACCT'.	self assert: accountRows size = anInteger.</body><body package="GlorpDBTests">checkNumberOfLinkRows: anInteger	| linkRows |	linkRows := session accessor		executeSQLString: 'SELECT * FROM CUSTOMER_ACCT_LINK'.	self assert: linkRows size = anInteger.</body><body package="GlorpDBTests">testReadCustomerAndAddAccount	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [customer addAccount: (GlorpBankAccount new id: 77473)]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId3 := 77473.			self checkAccounts.			self checkNumberOfLinkRows: 4].</body><body package="GlorpDBTests">testReadCustomerAndDeleteAccount	self		inTransactionDo:[			[self 				inUnitOfWorkDo: [ | account| 					account := customer accounts detect: [:each | each id = 9874].					session delete: account]				initializeWith: [self writeCustomerWithAccounts]]				on: Dialect error				do: [:ex | Transcript show: 'integrity violation'; cr.^self].			self readCustomer.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2.			self checkNumberOfAccounts: 2].</body><body package="GlorpDBTests">testReadCustomerAndDeleteAccountProperly	"Do both the delete and the patching up of relationships"	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [ | account| 					account := customer accounts detect: [:each | each id = 9874].					session delete: account.					customer removeAccount: account]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2.			self checkNumberOfAccounts: 2].</body><body package="GlorpDBTests">testReadCustomerAndRemoveAccount	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| account |					account := customer accounts detect: [:each | each id = 9874].					customer accounts remove: account]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2].</body><body package="GlorpDBTests">testReadCustomerAndReplaceAccounts	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| account |					account := GlorpBankAccount new id: 99999.					customer accounts do: [:each | each accountHolders remove: customer].					customer accounts: (Array with: account)]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId1 := 99999.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2.			self checkNumberOfAccounts: 4].</body><body package="GlorpDBTests">testReadCustomerAndReplaceAccountsWithRemoval	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| account |					account := customer accounts detect: [:each | each id = 6].					customer accounts: (Array with: account)]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2].</body><body package="GlorpDBTests">testReadCustomerAndReplaceAccountsWithoutInstantiatingHolders	"This works, but only fortuitously. If the accounts haven't been read into memory, we don't have to remove their object-level references to the account holder, because changing one side of the relationship in memory is enough to cause the link rows to be deleted"	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| account |					account := GlorpBankAccount new id: 99999.					customer accounts: (Array with: account)]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId1 := 99999.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 2.			self checkNumberOfAccounts: 4].</body><body package="GlorpDBTests">testReadCustomerAndReplaceInstantiatedAccountsWithEmpty	self		inTransactionDo:			[self				inUnitOfWorkDo:					[customer accounts yourSelf. 					customer accounts: #()]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId1 := nil.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 1.			self checkNumberOfAccounts: 3].</body><body package="GlorpDBTests">testReadCustomerAndReplaceUninstantiatedAccountsWithEmpty	self		inTransactionDo:			[self				inUnitOfWorkDo:					[customer accounts: #()]				initializeWith: [self writeCustomerWithAccounts].			self readCustomer.			accountId1 := nil.			accountId2 := nil.			self checkAccounts.			self checkNumberOfLinkRows: 1.			self checkNumberOfAccounts: 3].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-write</category><body package="GlorpDBTests">testWriteCustomerWithAccounts	| newCustomer |	self		inTransactionDo:			[self writeCustomerWithAccounts.			session beginUnitOfWork.			newCustomer := GlorpCustomer example1.			newCustomer id: 12.			customerId := 12.			newCustomer accounts: (OrderedCollection with: (GlorpBankAccount new id: 223)).			session register: newCustomer.			session commitUnitOfWork.			session reset.			self readCustomer.			accountId1 := 223.			accountId2 := nil.			self checkAccounts.			self checkNumberOfAccounts: 4.			self checkNumberOfLinkRows: 4].</body><body package="GlorpDBTests">testWriteCustomerWithNoAccounts	| newCustomer |	self		inTransactionDo:			[session beginUnitOfWork.			newCustomer := GlorpCustomer example1.			newCustomer id: 12.			customerId := 12.			session register: newCustomer.			session commitUnitOfWork.			session reset.			self readCustomer.			accountId1 := nil.			accountId2 := nil.			self checkAccounts.			self checkNumberOfAccounts: 0.			self checkNumberOfLinkRows: 0].</body><body package="GlorpDBTests">testWriteCustomerWithTwoAccounts	| newCustomer |	self		inTransactionDo:			[self writeCustomerWithAccounts.			session beginUnitOfWork.			newCustomer := GlorpCustomer example1.			newCustomer id: 12.			customerId := 12.			newCustomer accounts: (OrderedCollection with: (GlorpBankAccount new id: 223)).			newCustomer accounts add: (GlorpBankAccount new id: 224).			session register: newCustomer.			session commitUnitOfWork.			session reset.			self readCustomer.			accountId1 := 223.			accountId2 := 224.			self checkAccounts.			self checkNumberOfAccounts: 5.			self checkNumberOfLinkRows: 5].</body><body package="GlorpDBTests">testWriteCustomersAndAccounts	| newCustomer1 newCustomer2 newCustomer3 joint withBaby1 withBaby2 hisChecking herChecking |	self		inTransactionDo:			[			session beginUnitOfWork.			newCustomer1 := GlorpCustomer exampleD1.			newCustomer2 := GlorpCustomer exampleD2.			newCustomer3 := GlorpCustomer exampleD3.			hisChecking := GlorpBankAccount new id: 301.			herChecking := GlorpBankAccount new id: 302.			joint := GlorpBankAccount new id: 303.			withBaby1 := GlorpBankAccount new id: 304.			withBaby2 := GlorpBankAccount new id: 305.			newCustomer1 id: 201; accounts: (OrderedCollection with: hisChecking with: joint with: withBaby1).			newCustomer2 id: 202; accounts: (OrderedCollection with: herChecking with: joint with: withBaby2).			newCustomer3 id: 203; accounts: (OrderedCollection with: withBaby1 with: withBaby2).			session register: newCustomer1;				register: newCustomer2;				register: newCustomer3.			session commitUnitOfWork.			session reset.			newCustomer1 := self readCustomer: 201.			self assert: newCustomer1 accounts size = 3.			newCustomer2 := self readCustomer: 202.			self assert: newCustomer2 accounts size = 3.			newCustomer3 := self readCustomer: 203.			self assert: newCustomer3 accounts size = 2.			self checkNumberOfAccounts: 5.			self checkNumberOfLinkRows: 8].</body><body package="GlorpDBTests">testWriteCustomersAndAccountsAndDelete	| newCustomer1 newCustomer2 newCustomer3 joint withBaby1 withBaby2 hisChecking herChecking |	self		inTransactionDo:			[			session beginUnitOfWork.			newCustomer1 := GlorpCustomer exampleD1.			newCustomer2 := GlorpCustomer exampleD2.			newCustomer3 := GlorpCustomer exampleD3.			hisChecking := GlorpBankAccount new id: 301.			herChecking := GlorpBankAccount new id: 302.			joint := GlorpBankAccount new id: 303.			withBaby1 := GlorpBankAccount new id: 304.			withBaby2 := GlorpBankAccount new id: 305.			newCustomer1 id: 201; accounts: (OrderedCollection with: hisChecking with: joint with: withBaby1).			newCustomer2 id: 202; accounts: (OrderedCollection with: herChecking with: joint with: withBaby2).			newCustomer3 id: 203; accounts: (OrderedCollection with: withBaby1 with: withBaby2).			session register: newCustomer1;				register: newCustomer2;				register: newCustomer3.			session commitUnitOfWork.			session reset.			newCustomer1 := self readCustomer: 201.			self assert: newCustomer1 accounts size = 3.			newCustomer2 := self readCustomer: 202.			self assert: newCustomer2 accounts size = 3.			newCustomer3 := self readCustomer: 203.			self assert: newCustomer3 accounts size = 2.			self checkNumberOfAccounts: 5.			self checkNumberOfLinkRows: 8.			session reset.				session transact: [ | cust acct |						cust := self readCustomer: 201.				acct := cust accounts detect: [:ea| ea id = 301] ifNone: [nil].				acct notNil ifTrue: [session delete: acct].				session delete: cust].			self checkNumberOfAccounts: 4.			self checkNumberOfLinkRows: 5].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>support</category><body package="GlorpDBTests">checkAccounts	| sorted numberOfAccounts |	numberOfAccounts := (accountId1 isNil ifTrue: [0] ifFalse: [1]) + (accountId2 isNil ifTrue: [0] ifFalse: [1]) + (accountId3 isNil ifTrue: [0] ifFalse: [1]).	self assert: customer accounts size = numberOfAccounts.	sorted := customer accounts asSortedCollection: [:a :b | a id &lt;= b id].	accountId1 isNil ifFalse: [self assert: sorted first id = accountId1].	accountId2 isNil ifFalse: [self assert: (sorted at: 2) id = accountId2].	accountId3 isNil ifFalse: [self assert: sorted last id = accountId3].	self assert: (customer accounts collect: [:each | each id]) asSet size = customer accounts size.</body><body package="GlorpDBTests">inUnitOfWorkDo: aBlock initializeWith: initBlock	"Set up a bunch of the normal data, read the objects, then run the block in a unit of work"	initBlock value.	session beginUnitOfWork.	self readCustomer.	aBlock value.	session commitUnitOfWork.	session reset.</body><body package="GlorpDBTests">readCustomer	| results query |	query := Query		read: GlorpCustomer		where: [:cust | cust id = customerId].	results := query executeIn: session.	self assert: results size = 1.	customer := results first.</body><body package="GlorpDBTests">readCustomer: aCustomerId	| results query |	query := Query		read: GlorpCustomer		where: [:cust | cust id = aCustomerId].	results := query executeIn: session.	self assert: results size = 1.	^results first.</body><body package="GlorpDBTests">session: aDatabaseSession	session := aDatabaseSession.</body><body package="GlorpDBTests">writeCustomerWithAccounts	| customerRow accountRow1 accountRow2 linkRow1 linkRow2 customerRow2 accountRow3 linkRow3 |	customerRow := session system exampleCustomerRow1.	customerId := customerRow atFieldNamed: 'ID'.	customerRow2 := session system exampleCustomerRow2.	accountRow1 := session system exampleAccountRow1. 	accountId2 := accountRow1 atFieldNamed: 'ID'.	accountRow2 := session system exampleAccountRow2.	accountId1 := accountRow2 atFieldNamed: 'ID'.	accountRow3 := session system exampleAccountRow3.	linkRow1 := session system exampleCALinkRow1.	linkRow2 := session system exampleCALinkRow2.	linkRow3 := session system exampleCALinkRow3.	session writeRow: customerRow.	session writeRow: customerRow2.	session writeRow: accountRow1.	session writeRow: accountRow2.	session writeRow: accountRow3.	session writeRow: linkRow1.	session writeRow: linkRow2.	session writeRow: linkRow3.</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-nodes</category><body package="GlorpDBTests">testReadAndDeleteNodes	"Make sure we don't delete out of order and that links disappear."	| nodes links |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		session transact: [			nodes := session read: GlorpTreeNode.			nodes do: [:each | session delete: each]].		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links size = 0].</body><body package="GlorpDBTests">testReadNode	| allNodes |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		allNodes := session read: GlorpTreeNode orderBy: #id.		self assert: (allNodes collect: [:each | each id]) asArray = #( 1 2 3).		self assert: allNodes first children size = 2.		self assert: (allNodes first children collect: [:each | each id]) asSortedCollection asArray = #( 2 3)].</body><body package="GlorpDBTests">testReadNodeAndDeleteChild	| node1 node3 links nodes |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		node1 := session readOneOf: GlorpTreeNode where: [:each | each id = 1].		node3 := (node1 children asSortedCollection: [:a :b | a id &lt;= b id]) last.		session transact: [			session register: node1.			session delete: node3.			node1 children remove: node3].		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links size = 1.		self assert: links first first = 1. 		self assert: links first last = 2.		nodes := session accessor executeSQLString: 'SELECT * FROM TREE_NODE'.		self deny: (nodes anySatisfy: [:each | each first = node3 id]).		self assert: nodes size = 2		].</body><body package="GlorpDBTests">testReadNodeAndDeleteChildWithSaveAndContinue	"This exercises two things. First, there's a bug in save and continue with deleted objects resurrecting. Second, make sure that if we delete both parent and child, the link goes away"	| node1 node3 links nodes node2 |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		node1 := session readOneOf: GlorpTreeNode where: [:each | each id = 1].		node2 := (node1 children asSortedCollection: [:a :b | a id &lt;= b id]) first.		node3 := (node1 children asSortedCollection: [:a :b | a id &lt;= b id]) last.		session beginUnitOfWork.			[session register: node1.			session delete: node3.			node1 children remove: node3] ensure: [session saveAndContinue].		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links size = 1.		self assert: links first first = 1. 		self assert: links first last = 2.		nodes := session accessor executeSQLString: 'SELECT * FROM TREE_NODE'.		self deny: (nodes anySatisfy: [:each | each first = node3 id]).		self assert: nodes size = 2.			[session register: node1.			session delete: node2.			session delete: node1] ensure: [session saveAndContinue].		nodes := session accessor executeSQLString: 'SELECT * FROM TREE_NODE'.		self assert: nodes isEmpty.		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links isEmpty.		].</body><body package="GlorpDBTests">testReadNodeAndDeleteParent	| node1 links |	self inTransactionDo: [		self writeNodeWithChildren.		session reset.		session transact: [		node1 := session readOneOf: GlorpTreeNode where: [:each | each id = 1].		session delete: node1.		node1 children: #()].		links := session accessor executeSQLString: 'SELECT * FROM TREE_NODE_LINK'.		self assert: links size = 0].</body><body package="GlorpDBTests">treeNodeClass	treeNodeClass isNil ifTrue: [treeNodeClass := GlorpTreeNode].	^treeNodeClass.</body><body package="GlorpDBTests">treeNodeClass: aClass	treeNodeClass := aClass.</body><body package="GlorpDBTests">writeNodeWithChildren	| node1 node2 node2a |	node1 := self treeNodeClass new id: 1.	node2 := self treeNodeClass new id: 2.	node2a := self treeNodeClass new id: 3.	node1 children add: node2.	node1 children add: node2a.	session inUnitOfWorkDo: [session register: node1].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-subselect</category><body package="GlorpDBTests">testReadCustomerOrderingByCountSubselect	"DB2 (as of 9.8) does not support an ORDER BY clause with correlated column references.	The ORDER BY sub-select here refers back to the selected column, so we skip this for DB2. Access doesn't appear to allow anything in the ORDER BY clause except column names."	| customers |	(session platform supportsCorrelatedSubqueriesInOrderBy) ifFalse: [^self].	self		inTransactionDo:			[| sorted |			self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				orderBy: [:each | each accounts sqlCount].			sorted := (customers asSortedCollection: [:a :b | a accounts size &lt;= b accounts size]) asArray.			self assert: customers = sorted.			customers := session				read: GlorpCustomer				orderBy: [:each | each accounts sqlCount descending].			self assert: customers reverse = sorted].</body><body package="GlorpDBTests">testReadCustomerWithAverageSubselect	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:each | 					(each average: [:eachCust | eachCust accounts id]) = ((9874 + 6) / 2)].		self assert: customers size = 1.		self assert: customers first id = 27.		customers := session				read: GlorpCustomer				where:					[:each | 					(each accounts id sqlAverage) = 22].		self assert: customers size = 1.		self assert: customers first id = 28.].</body><body package="GlorpDBTests">testReadCustomerWithCountSubselect	| customersWithOneAccount customersWithTwoAccounts customersWithLessThanFiveAccounts |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customersWithOneAccount := session				read: GlorpCustomer				where:					[:each | 					(each getConstant: 1) = (each count: [:eachCust | eachCust accounts])].			customersWithTwoAccounts := session				read: GlorpCustomer				where:					[:each | 					(each count: [:eachCust | eachCust accounts]) = 2].			"fully general syntax. doesn't require any helper methods, just the existence of the function"			customersWithLessThanFiveAccounts := session				read: GlorpCustomer				where: [:each | (each aggregate: each accounts as: #countStar) &lt; 5].		self assert: customersWithOneAccount size = 1.		self assert: customersWithOneAccount first id = 28.		self assert: customersWithTwoAccounts size = 1.		self assert: customersWithTwoAccounts first id = 27.		self assert: customersWithLessThanFiveAccounts size = 2].</body><body package="GlorpDBTests">testReadCustomerWithCountSubselectAlternateSyntax	| customersWithOneAccount customersWithTwoAccounts |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customersWithOneAccount := session				read: GlorpCustomer				where:					[:each | 					(each getConstant: 1) = (each accounts sqlCount)].			customersWithTwoAccounts := session				read: GlorpCustomer				where:					[:each | 					each accounts sqlCount = 2].		self assert: customersWithOneAccount size = 1.		self assert: customersWithOneAccount first id = 28.		self assert: customersWithTwoAccounts size = 1.		self assert: customersWithTwoAccounts first id = 27].</body><body package="GlorpDBTests">testReadCustomerWithEqualityComparisonToAccountsUsingInClause	"Test doing a primary key rewrite of the where clause in a subselect, to the result of another subselect"	| customers accounts |	self		inTransactionDo:			[self writeCustomerWithAccounts.			accounts := session read: GlorpBankAccount where: [:each | each id = 22].			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount in: accounts]].			self assert: customers size = 1.			customers do: [:each | each accounts do: [:eachAcct | self assert: eachAcct id = 22]]].</body><body package="GlorpDBTests">testReadCustomerWithEqualitySubSelectToAccountsUsingInClause	"Test doing a primary key rewrite of the where clause in a subselect, to the result of another subselect"	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount in: (Query read: GlorpBankAccount where: [:accts2 | accts2 id &lt;&gt; 12])]].			self assert: customers size = 2.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | 							eachAccount in: (Query read: GlorpBankAccount where: [:accts2 | accts2 id = 22])]].			self assert: customers size = 1.			customers do: [:each | each accounts do: [:eachAcct | self assert: eachAcct id = 22]]].</body><body package="GlorpDBTests">testReadCustomerWithFilteredSubSelectToAccounts1	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					(eachCustomer accounts select: [:eachAccount | eachAccount accountNumber bankCode = '2']) sqlCount &gt; 0].			self assert: customers size = 2].</body><body package="GlorpDBTests">testReadCustomerWithFilteredSubSelectToAccounts2	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					(eachCustomer accounts select: [:eachAccount | eachAccount accountNumber bankCode = '2']) sqlCount &gt; 1].			self assert: customers size = 0].</body><body package="GlorpDBTests">testReadCustomerWithFilteredSubSelectToAccounts3	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					(eachCustomer accounts select: [:eachAccount | eachAccount id &gt; 5 ]) sqlCount &lt;= 1].			self assert: customers size = 1].</body><body package="GlorpDBTests">testReadCustomerWithFilteredSubSelectToAccountsAndAggregate	"Test with a filtered read to accounts, where we've used an aggregate function to find the customer with the maximum primary key for the given id"	| query |	((session system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts) useFilteredRead.	self		inTransactionDo:			[self writeCustomerWithAccounts.			query := Query readOneOf: GlorpCustomer where: [:each |				| q |				q := Query read: GlorpCustomer where: [:eachPundle |					eachPundle name = 'aCustomer'].				q retrieve: [:x | x id max].				each id = q].			customer := session execute: query.			self assert: customer name = 'aCustomer'.			self assert: (customer accounts collect: [:each | each id]) asSortedCollection asArray = #(6 9874)].</body><body package="GlorpDBTests">testReadCustomerWithIsEmptyAndFilteredSubselectsToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | (eachCustomer accounts select: [:each | each id &gt; 30]) isEmpty].			self assert: customers size = 1.			self assert: customers first id = 28].</body><body package="GlorpDBTests">testReadCustomerWithIsEmptySubselectToAccounts1	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | eachCustomer accounts isEmpty].			self assert: customers size = 0].</body><body package="GlorpDBTests">testReadCustomerWithMaxSubselect	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:each | 					(each max: [:eachCust | eachCust accounts id]) = 9874].		self assert: customers size = 1.		self assert: customers first id = 27.		customers := session				read: GlorpCustomer				where:					[:each | 					(each accounts id sqlMax) = 22].		self assert: customers size = 1.		self assert: customers first id = 28.].</body><body package="GlorpDBTests">testReadCustomerWithMinSubselect	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:each | 					(each min: [:eachCust | eachCust accounts id]) = 6].		self assert: customers size = 1.		self assert: customers first id = 27.		customers := session				read: GlorpCustomer				where:					[:each | 					(each accounts id sqlMin) = 22].		self assert: customers size = 1.		self assert: customers first id = 28.].</body><body package="GlorpDBTests">testReadCustomerWithNotEmptyAndFilteredSubselectsToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | (eachCustomer accounts select: [:each | each id &gt; 30]) notEmpty].			self assert: customers size = 1.			self assert: customers first id = 27].</body><body package="GlorpDBTests">testReadCustomerWithSimpleSubSelectToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount id &lt;&gt; 12]].			self assert: customers size = 2].</body><body package="GlorpDBTests">testReadCustomerWithSubSelectToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount accountNumber bankCode = '2']].			self assert: customers size = 2].</body><body package="GlorpDBTests">testReadCustomerWithSubSelectToAccounts2	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | eachAccount accountNumber branchNumber = 3]].			self assert: customers size = 1].</body><body package="GlorpDBTests">testReadCustomerWithSubSelectToAccountsUsingInClause	"Test doing an IN clause with the result of another subselect"	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | 							| q |							q := Query read: GlorpBankAccount where: [:accts2 | accts2 id &lt;&gt; 12].							q retrieve: #id.							eachAccount id in: q]].			self assert: customers size = 2.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyExists: [:eachAccount | 							| q |							q := Query read: GlorpBankAccount where: [:accts2 | accts2 id = 22].							q retrieve: #id.							eachAccount id in: q]].			self assert: customers size = 1.			customers do: [:each | each accounts do: [:eachAcct | self assert: eachAcct id = 22]].].</body><body package="GlorpDBTests">testReadCustomerWithSumSubselect	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:each | 					(each sum: [:eachCust | eachCust accounts accountNumber branchNumber]) &lt; 6].		self assert: customers size = 1.		self assert: customers first id = 27.		customers := session				read: GlorpCustomer				where:					[:each | 					(each accounts accountNumber branchNumber sqlSum) &gt; 6].		self assert: customers size = 1.		self assert: customers first id = 28.].</body></methods><methods><class-id>Glorp.GlorpManyToManyDBTest</class-id> <category>tests-join</category><body package="GlorpDBTests">testReadCustomerOrderByLinkTableField	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session read: GlorpCustomer.			customers do: [:each | | sortedAccounts |				sortedAccounts := each accounts asSortedCollection: [:a :b | a id &lt;= b id].				self assert: each accountsSortedById asArray = sortedAccounts asArray]].</body><body package="GlorpDBTests">testReadCustomerOrderByLinkTableFieldDescending	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session read: GlorpCustomer.			customers do: [:each | | sortedAccounts |				sortedAccounts := each accounts asSortedCollection: [:a :b | a id &lt;= b id].				self assert: each accountsSortedByIdDescending asArray = sortedAccounts asArray reverse]].</body><body package="GlorpDBTests">testReadCustomerWithJoinToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyJoin: [:eachAccount | eachAccount accountNumber bankCode = '2']].			self assert: customers size = 2].</body><body package="GlorpDBTests">testReadCustomerWithJoinToAccounts2	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyJoin: [:eachAccount | eachAccount accountNumber branchNumber = 3]].			self assert: customers size = 1].</body><body package="GlorpDBTests">testReadCustomerWithSimpleJoinToAccounts	| customers |	self		inTransactionDo:			[self writeCustomerWithAccounts.			customers := session				read: GlorpCustomer				where:					[:eachCustomer | 					eachCustomer accounts						anySatisfyJoin: [:eachAccount | eachAccount id &lt;&gt; 12]].			self assert: customers size = 2].</body></methods><methods><class-id>Glorp.GlorpJob</class-id> <category>accessing</category><body package="GlorpTestModels">description	^description</body><body package="GlorpTestModels">description: anObject	description := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpQueryTableAliasingTest</class-id> <category>tests</category><body package="GlorpTests">testAliasWithEmbeddedMapping	self unfinished.</body><body package="GlorpTests">testBuildingObject	| customer |	elementBuilder instance: GlorpCustomer new.	elementBuilder requiresPopulating: true.	elementBuilder buildObjectFrom: #(12 'Name').	customer := elementBuilder instance.	self assert: customer class == GlorpCustomer.	self assert: customer id = 12.	self assert: customer name = 'Name'.</body><body package="GlorpTests">testElementBuilderFields	elementBuilder fieldsForSelectStatement 		do: [:each | self assert: each table name = 't1']</body><body package="GlorpTests">testExpressionTableAlias	| fields |	fields := expression translateFields: expression descriptor mappedFields.	fields do: [:each | self assert: each table name = 't1']</body><body package="GlorpTests">testQueryPrintingFields	| stream |	query 		initResultClass: GlorpCustomer		whereClause: expression		singleObject: true.	query limit: nil.	query setupTracing.	query computeFields.	stream := String new writeStream.	query printSelectFieldsOn: stream.	self assert: stream contents = 't1.ID, t1.NAME'</body><body package="GlorpTests">testQueryPrintingSimpleWhereClause	| string |	string := self helpTestPrintingWhereClause: ((expression get: #name) get: #= withArguments: #('Fred')).	self assert: '(t1.NAME = ''Fred'')' equalsIgnoringOuterBrackets: string.</body><body package="GlorpTests">testQueryPrintingTables	| stream string |	query 		initResultClass: GlorpCustomer		whereClause: expression		singleObject: true.	query setupTracing.	query computeFields.	stream := String new writeStream.	query printTablesOn: stream.	string := stream contents.	self assert: string = '&lt;n&gt; FROM GR_CUSTOMER t1' expandMacros.</body></methods><methods><class-id>Glorp.GlorpQueryTableAliasingTest</class-id> <category>utility</category><body package="GlorpTests">helpTestPrintingWhereClause: anExpression	| command |	query 		initResultClass: GlorpCustomer		whereClause: expression		singleObject: true.	query setupTracing.	query computeFields.	command := GlorpNullCommand useBinding: false session: session.	anExpression			printSQLOn: command		withParameters: Dictionary new.	^command sqlString.</body></methods><methods><class-id>Glorp.GlorpQueryTableAliasingTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	query := SimpleQuery new.	expression := BaseExpression new.	expression descriptor: (system descriptorFor: GlorpCustomer).	(expression descriptor mappingForAttributeNamed: #name) shouldProxy: false.	elementBuilder := ObjectBuilder for: expression in: query.	expression assignTableAliasesStartingAt: 1 prefix: 't'.	session := GlorpSession new.	session system: system.	query session: system session.</body></methods><methods><class-id>Glorp.GlorpMoney</class-id> <category>accessing</category><body package="GlorpTestModels">amount	^amount</body><body package="GlorpTestModels">amount: anInteger	amount := anInteger</body><body package="GlorpTestModels">currency	^currency</body><body package="GlorpTestModels">currency: aSymbol	currency := aSymbol</body></methods><methods><class-id>Glorp.GlorpMoney class</class-id> <category>instance creation</category><body package="GlorpTestModels">currency: aSymbol amount: aNumber	^self new		currency: aSymbol;		amount: aNumber.</body><body package="GlorpTestModels">defaultCurrency	^#CDN.</body><body package="GlorpTestModels">forAmount: anAmount	^self currency: self defaultCurrency amount: anAmount.</body></methods><methods><class-id>Glorp.GlorpSessionResource</class-id> <category>accessing</category><body package="GlorpDBTests">newSession	self setUp.	^self session</body><body package="GlorpDBTests">session	^session.</body></methods><methods><class-id>Glorp.GlorpSessionResource</class-id> <category>setup</category><body package="GlorpDBTests">glorpTestsSystem	"We want to prep the GlorpDemoTablePopulatorResource but subclasses using different systems may not;  put it here where it will be overridden."	GlorpDemoTablePopulatorResource current.	^GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database</body><body package="GlorpDBTests">setAccessor		session accessor: GlorpDatabaseLoginResource current accessor.</body><body package="GlorpDBTests">setUp	super setUp.	session := self glorpTestsSystem		sessionForLogin: GlorpDatabaseLoginResource current login.	self setAccessor.</body><body package="GlorpDBTests">tearDown	session logout.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpSessionResource class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource</body></methods><methods><class-id>Glorp.GlorpMockSession</class-id> <category>accessing</category><body package="GlorpDBTests">accessor	^GlorpMockAccessor new		connection: GlorpMockConnection new;		yourself</body><body package="GlorpDBTests">rows	^rows.</body></methods><methods><class-id>Glorp.GlorpMockSession</class-id> <category>initialize</category><body package="GlorpDBTests">initialize	super initialize.	rows := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpMockSession</class-id> <category>testing</category><body package="GlorpDBTests">useBinding	^true.</body></methods><methods><class-id>Glorp.GlorpMockSession</class-id> <category>read/write</category><body package="GlorpDBTests">writeHomogeneousRows: aCollection	aCollection do: [:each | self writeRow: each].	^true.</body><body package="GlorpDBTests">writeRow: aRow	aRow shouldBeWritten ifFalse: [^true].	aRow preWriteAssignSequencesUsing: self.	rows add: aRow.	aRow postWriteAssignSequencesUsing: self accessor.	^true.</body></methods><methods><class-id>Glorp.GlorpMockSession class</class-id> <category>instance creation</category><body package="GlorpDBTests">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpMockConnection</class-id> <category>accessing</category><body package="GlorpDBTests">lastAutoIncrementValue	^3</body></methods><methods><class-id>Glorp.GlorpQueryStub</class-id> <category>executing</category><body package="GlorpDBTests">executeWithParameters: parameterArray in: aSession 	aSession register: result.	^result.</body></methods><methods><class-id>Glorp.GlorpQueryStub</class-id> <category>initialize</category><body package="GlorpDBTests">initialize	super initialize.	readsOneObject := true.</body></methods><methods><class-id>Glorp.GlorpQueryStub</class-id> <category>accessing</category><body package="GlorpDBTests">result	^result</body><body package="GlorpDBTests">result: anObject	result := anObject</body></methods><methods><class-id>Glorp.GlorpQueryStub class</class-id> <category>instance creation</category><body package="GlorpDBTests">newQuery	^self new.</body></methods><methods><class-id>Glorp.GlorpTravelFile</class-id> <category>accessing</category><body package="GlorpDBTests">&lt;= aTravelFile	^self name &lt;= aTravelFile name.</body><body package="GlorpDBTests">id	^id</body><body package="GlorpDBTests">id: anObject	id := anObject</body><body package="GlorpDBTests">name	^name</body><body package="GlorpDBTests">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpExpressionBasicPropertiesTest</class-id> <category>tests</category><body package="GlorpTests">testHasDescriptorForBase	| exp |	self assert: base hasDescriptor.	exp := [:a | a ] asGlorpExpressionOn: base.	self assert: exp hasDescriptor.</body><body package="GlorpTests">testHasDescriptorForDirect	| exp |	exp := [:a | a id ] asGlorpExpressionOn: base.	self deny: exp hasDescriptor.</body><body package="GlorpTests">testHasDescriptorForOneToMany	| exp |	exp := [:a | a emailAddresses ] asGlorpExpressionOn: base.	self assert: exp hasDescriptor.</body><body package="GlorpTests">testHasDescriptorForOneToOne	| exp |	exp := [:a | a address ] asGlorpExpressionOn: base.	self assert: exp hasDescriptor.</body><body package="GlorpTests">testHasDescriptorForPrimaryKeyExpression	| exp |	exp := Join new.	self deny: exp hasDescriptor.</body><body package="GlorpTests">testHasDescriptorForRelation	| exp |	exp := [:a | a = 3] asGlorpExpressionOn: base.	self deny: exp hasDescriptor.</body><body package="GlorpTests">testHasDescriptorForTwoLevelDirect	| exp |	exp := [:a | a address street] asGlorpExpressionOn: base.	self deny: exp hasDescriptor.	self assert: exp base hasDescriptor.</body><body package="GlorpTests">testHasDescriptorForUninitializedBase	self deny: BaseExpression new hasDescriptor.</body></methods><methods><class-id>Glorp.GlorpExpressionBasicPropertiesTest</class-id> <category>support</category><body package="GlorpTests">setUp	base := BaseExpression new descriptor: (		(GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database)			descriptorFor: GlorpPerson)</body></methods><methods><class-id>Glorp.GlorpBasicMappingTest</class-id> <category>tests</category><body package="GlorpTests">testGet		self assert: (mapping getValueFrom: person) = 1</body><body package="GlorpTests">testSet		mapping setValueIn: person to: 2.	self assert: person id = 2.	self assert: (mapping getValueFrom: person) = 2.</body></methods><methods><class-id>Glorp.GlorpBasicMappingTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	mapping := DirectMapping new.	mapping attributeName: #id.	mapping attribute classModel describedClass: GlorpPerson.	person := GlorpPerson example1.</body></methods><methods><class-id>Glorp.GlorpCommandTest</class-id> <category>tests</category><body package="GlorpTests">testFieldsToUpdate	| command system row old bookTable session |	session := GlorpLockingDescriptorSystem sessionForLogin: (Login new database: OraclePlatform new).	system := session system.	bookTable := system tableNamed: 'BOOK'.	row := DatabaseRow newForTable: bookTable.	old := DatabaseRow newForTable: bookTable.	old at: (bookTable fieldNamed: 'ID') put: 6.	old at: (bookTable fieldNamed: 'TITLE') put: 'ABook'.	old at: (bookTable fieldNamed: 'DESCRIPTION') put: 'Stuff'.	old at: (bookTable fieldNamed: 'COPIES_IN_STOCK') put: 3.	old at: (bookTable fieldNamed: 'VERSION') put: 2.	row at: (bookTable fieldNamed: 'ID') put: 6.	row at: (bookTable fieldNamed: 'TITLE') put: 'ABook'.	row at: (bookTable fieldNamed: 'DESCRIPTION') put: 'Stuff'.	row at: (bookTable fieldNamed: 'COPIES_IN_STOCK') put: 4.	row at: (bookTable fieldNamed: 'VERSION') put: 2.	row withAllFieldsIn: old.	command := UpdateCommand forRows: (Array with: row) useBinding: false session: session.	self assert: command shouldUpdateOnlyChangedFields.	self assert: command singleRowBoundFields size = 2.	self assert: command singleRowBindings isEmpty. 	command useBinding: true.	self deny: command shouldUpdateOnlyChangedFields.	self assert: command singleRowBoundFields size = 5.	"The lock field is bound at the end"	self assert: command singleRowBindings size = 6.</body><body package="GlorpTests">testSplittingInserts1	"Test both creation protocols on a single row."	| rows command wasEvaluated assertBlock |	 wasEvaluated := false.	rows := Array with: DatabaseRow new.	"The normal protocol for a single row."	command := InsertCommand forRow: rows first useBinding: false session: nil.	assertBlock :=		[wasEvaluated := true.		self assert: command row == rows first].	command allRowsGrouped: 1000 evaluate: assertBlock.	self assert: wasEvaluated.  wasEvaluated := false.	assertBlock value.	"we end in our start state"	command allRowsGrouped: 1 evaluate: assertBlock.	self assert: wasEvaluated.  wasEvaluated := false.	assertBlock value.	"again, we end in our start state"	"The forRows: protocol should not be called on a single row - see what happens if it were."	command := InsertCommand forRows: rows useBinding: false session: nil.	command allRowsGrouped: 1000 evaluate: assertBlock.	self assert: wasEvaluated.  wasEvaluated := false.	assertBlock value.	"we end in our start state"	command allRowsGrouped: 1 evaluate: assertBlock.	self assert: wasEvaluated.  wasEvaluated := false.	assertBlock value.	"again, we end in our start state"</body><body package="GlorpTests">testSplittingInserts1000	| rows command evaluatedTimes assertBlock |	rows := (Array new: 1000) atAllPut: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	evaluatedTimes := 0.	assertBlock :=		[self assert: command allRows size = 1000.		self assert: command allRows first == command row.		self assert: command allRows first == rows first.		self assert: command allRows last == rows last].	command allRowsGrouped: 1000 evaluate:		[evaluatedTimes := evaluatedTimes + 1.		assertBlock value].	self assert: evaluatedTimes = 1.	assertBlock value.	"check we ended in our start state"</body><body package="GlorpTests">testSplittingInserts1001	| rows command subCommands |	rows := (Array new: 1001) atAllPut: DatabaseRow new.	rows at: rows size put: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := OrderedCollection new.	command allRowsGrouped: 1000 evaluate:		[subCommands add: command shallowCopy].	self assert: subCommands size = 2.	self assert: subCommands first allRows size = 1000.	self assert: subCommands first allRows first == rows first.	self assert: subCommands first allRows last == (rows at: 1000).	self assert:  subCommands last allRows size = 1.	self assert: subCommands last allRows first == rows last.	"check we ended in our start state"	self assert: command allRows size = 1001.	self assert: command allRows first == command row.	self assert: command allRows first == rows first.	self assert: command allRows last == rows last.</body><body package="GlorpTests">testSplittingInserts1003	| rows command subCommands |	rows := (Array new: 1003) atAllPut: DatabaseRow new.	rows at: rows size put: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := OrderedCollection new.	command allRowsGrouped: 1000 evaluate:		[subCommands add: command shallowCopy].	self assert: (subCommands allSatisfy: [:each | each allRows first == each row]).	self assert: subCommands size = 2.	self assert: subCommands first allRows size = 1000.	self assert: subCommands first allRows first == rows first.	self assert: subCommands first allRows last == (rows at: 1000).	self assert:  subCommands last allRows size = 3.	self assert: subCommands last allRows first == command row.	self assert: subCommands last allRows first == (rows at: 1001).	self assert: subCommands last allRows last == rows last.	"check we ended in our start state"	self assert: command allRows size = 1003.	self assert: command allRows first == command row.	self assert: command allRows first == rows first.	self assert: command allRows last == rows last.</body><body package="GlorpTests">testSplittingInserts2	| rows command evaluatedTimes assertBlock |	rows := Array with: DatabaseRow new with: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	evaluatedTimes := 0.	assertBlock :=		[self assert: command allRows size = 2.		self assert: command allRows first == command row.		self assert: command allRows first == rows first.		self assert: command allRows last == rows last].	command allRowsGrouped: 1000 evaluate:		[evaluatedTimes := evaluatedTimes + 1.		assertBlock value].	self assert: evaluatedTimes = 1.	assertBlock value.	"check we ended in our start state"	evaluatedTimes := 0.	command allRowsGrouped: 1 evaluate:		[evaluatedTimes := evaluatedTimes + 1.		self assert: command allRows size = 1.		self assert: command allRows first == command row.		self assert: command allRows first == (rows at: evaluatedTimes)].	self assert: evaluatedTimes = 2.	assertBlock value.</body><body package="GlorpTests">testSplittingInserts2000plus	"Check an exact multiple, then the same with a little extra."	| rows command subCommands |	rows := (Array new: 2000) atAllPut: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := OrderedCollection new.	command allRowsGrouped: 1000 evaluate:		[subCommands add: command shallowCopy].	self assert: (subCommands allSatisfy: [:each | each allRows first == each row]).	self assert: subCommands size = 2.	self assert: subCommands first allRows size = 1000.	self assert: subCommands first allRows first == rows first.	self assert: subCommands first allRows last == (rows at: 1000).	self assert:  subCommands last allRows size = 1000.	self assert: subCommands last allRows first == (rows at: 1001).	self assert: subCommands last allRows last == rows last.	"check we ended in our start state"	self assert: command allRows size = 2000.	self assert: command allRows first == command row.	self assert: command allRows first == rows first.	self assert: command allRows last == rows last.	rows := (Array new: 2002) atAllPut: DatabaseRow new.	command := InsertCommand forRows: rows useBinding: false session: nil.	subCommands := OrderedCollection new.	command allRowsGrouped: 1000 evaluate:		[subCommands add: command shallowCopy].	self assert: (subCommands allSatisfy: [:each | each allRows first == each row]).	self assert: subCommands size = 3.	self assert: subCommands first allRows size = 1000.	self assert: subCommands first allRows first == rows first.	self assert: subCommands first allRows last == (rows at: 1000).	self assert: (subCommands at: 2) allRows size = 1000.	self assert: (subCommands at: 2) allRows first == (rows at: 1001).	self assert: (subCommands at: 2) allRows last == rows last.	self assert: subCommands last allRows size = 2.	self assert: subCommands last allRows first == (rows at: 2001).	self assert: subCommands last allRows last == rows last.	"check we ended in our start state"	self assert: command allRows size = 2002.	self assert: command allRows first == command row.	self assert: command allRows first == rows first.	self assert: command allRows last == rows last.</body></methods><methods><class-id>Glorp.GlorpErrorTest</class-id> <category>tests</category><body package="GlorpTests">testMessageTextVW	| innerException text outerException error |	Dialect isVisualWorks ifFalse: [^self].	text := 'Something is horribly wrong'.	error := (Dialect smalltalkAt: #ExternalDatabaseError) new dbmsErrorString: text.	outerException := GlorpDatabaseReadError new databaseError: (Array with: error).	[outerException signal] on: GlorpError do: [:ex |			self assert: ex messageText = text].		innerException := (Dialect smalltalkAt: #ExternalDatabaseException) new.	innerException parameter: (Array with: error).	[DatabaseAccessor new handleError: innerException for: InsertCommand new ] on: GlorpError do: [:ex |			self assert: ex messageText = text.		ex return: nil].</body></methods><methods><class-id>Glorp.GlorpMessageCollectorTest</class-id> <category>tests</category><body package="GlorpTests">messageCollectorDNUObjectStudio	| caught |	caught := false.	[collector basicDoesNotUnderstand: #foo args: #()] on: MessageNotUnderstood		do: [:signal | caught := true. signal sunitExitWith: nil].	self assert: caught</body><body package="GlorpTests">testExpressionCreation	| exp |	exp := collector foo asGlorpExpression.	self assert: exp name == #foo.	self assert: exp base class == BaseExpression</body><body package="GlorpTests">testMessageCollectorDNU	| message caught |	Dialect isObjectStudio ifTrue: [		^self messageCollectorDNUObjectStudio].	message := Message selector: #foo arguments: #().	caught := false.	[collector basicDoesNotUnderstand: message] on: MessageNotUnderstood		do: [:signal | caught := true. signal sunitExitWith: nil].	self assert: caught</body><body package="GlorpTests">testMessageIntercept	| foo |	foo := collector foo.	self assert: foo privateGlorpSelector == #foo.	self assert: foo privateGlorpReceiver == collector.</body></methods><methods><class-id>Glorp.GlorpMessageCollectorTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	collector := MessageArchiver new</body></methods><methods><class-id>Glorp.GlorpTracingTest</class-id> <category>tests</category><body package="GlorpTests">testAddDuplicateTracings	| all |	tracing addExpression: (tracing base get: #foo).	tracing addExpression: (tracing base get: #foo).	all := tracing allTracings.	self assert: all size = 2.	self assert: all first == tracing base.</body><body package="GlorpTests">testAddRecursiveTracings	| all |	tracing addExpression: (tracing base get: #foo).	tracing addExpression: ((tracing base get: #foo) get: #bar).	all := tracing allTracings.	self assert: all size = 3.	self assert: all first == tracing base.	self assert: all last base == (all at: 2).</body><body package="GlorpTests">testAddTracing	| all |	tracing addExpression: (tracing base get: #foo).	all := tracing allTracings.	self assert: all size = 2.	self assert: all first == tracing base.	self assert: all last == (tracing base get: #foo).</body><body package="GlorpTests">testAddTwoTracings	tracing addExpression: (tracing base get: #foo).	tracing addExpression: (tracing base get: #bar).	self assert: tracing allTracings size = 3.	self assert: tracing allTracings first == tracing base.</body></methods><methods><class-id>Glorp.GlorpTracingTest</class-id> <category>support</category><body package="GlorpTests">setUp	tracing := Tracing new.	tracing setup.</body></methods><methods><class-id>Glorp.GlorpVirtualCollectionBasicTest</class-id> <category>support</category><body package="GlorpDBTests">realObjects	"Get the real objects from a virtual collection without resorting to any of its mechanisms except do:, so we can validate against more complex things."	^self realObjectsFrom: vc.</body><body package="GlorpDBTests">realObjectsFrom: aVirtualCollection	"Get the real objects from a virtual collection without resorting to any of its mechanisms except do:, so we can validate against more complex things."	| all |	all := OrderedCollection new.	aVirtualCollection do: [:each | all add: each].	^all.</body><body package="GlorpDBTests">setUp	super setUp.	session beginTransaction.	self writePersonRows.	vc := session virtualCollectionOf: GlorpPerson.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests">writePersonRows	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.	session writeRow: session system examplePersonRowForOrdering3.</body></methods><methods><class-id>Glorp.GlorpVirtualCollectionBasicTest</class-id> <category>tests</category><body package="GlorpDBTests">testCollect	| ids |	ids := vc collect: [:each | each id].		self assert: ids size = 3.	ids do: [:each | self assert: each isInteger].</body><body package="GlorpDBTests">testCreation		self assert: vc notNil.	self should: [vc isKindOf: GlorpVirtualCollection].</body><body package="GlorpDBTests">testDo	| all |	all := OrderedCollection new.	vc do: [:each |		self assert: (each isKindOf: GlorpPerson).		all add: each.		].	self assert: all size = 3.	self assert: all asSet size = 3.	self assert: (all collect: [:each | each id]) asSortedCollection asArray = #(86 87 88).</body><body package="GlorpDBTests">testInject	| sumofIds |	sumofIds := vc inject: 0 into: [:sum :each | sum + each id].	self assert: sumofIds = (86 + 87 + 88).</body><body package="GlorpDBTests">testIsEmpty	| vc2 |	self deny: vc isEmpty.	vc2 := vc select: [:each | each id = 98].	self assert: vc2 isEmpty.</body><body package="GlorpDBTests">testReject	| vc2 |	vc2 := vc reject: [:each | each id &gt; 87 ].	self deny: vc isInstantiated.	self deny: vc2 isInstantiated.	self assert: vc2 size = 2.	self deny: vc isInstantiated.	self assert: vc size = 3.	self assert: (self realObjectsFrom: vc2) size = 2.</body><body package="GlorpDBTests">testSelect	| vc2 |	vc2 := vc select: [:each | each id &lt;= 87 ].	self deny: vc isInstantiated.	self deny: vc2 isInstantiated.	self assert: vc2 size = 2.	self deny: vc isInstantiated.	self assert: vc size = 3.	self assert: (self realObjectsFrom: vc2) size = 2.</body></methods><methods><class-id>Glorp.GlorpMappingFromClassModelTests</class-id> <category>Tests</category><body package="GlorpTests">someCode	| model descriptor mapping table |	table := DatabaseTable named: 'TYPETESTS'.	table createFieldNamed: 'test' type: system platform boolean.	model := system addClassModelFor: GlorpTypeTestsModelClass.	model newAttributeNamed: #test type: Boolean.	system privateTableAt: table name put: table.	descriptor := Descriptor new.	descriptor system: system.	descriptor classModel: model.	descriptor table: table.	descriptor 		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'id')).	Boolean isNil 		ifTrue: [mapping := DirectMapping from: #test to: (table fieldNamed: 'test')]		ifFalse: 			[mapping := DirectMapping 						from: #test						type: Boolean						to: (table fieldNamed: 'test')].	descriptor addMapping: mapping.	system privateDescriptorAt: GlorpTypeTestsModelClass put: descriptor.	^system</body><body package="GlorpTests">testAllAttributes	| bankTransTable customerTable ownerId btOwnerId customerModel customerDescriptor attributes |	bankTransTable := system addEmptyTableNamed: 'BANK_TRANS'.	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	btOwnerId := bankTransTable createFieldNamed: 'OWNER_ID'				type: platform int4.	bankTransTable addForeignKeyFrom: btOwnerId to: ownerId.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #id type: Integer.	customerModel newAttributeNamed: #transactions		collectionOf: GlorpBankTransaction.	system addClassModelFor: GlorpBankTransaction.	system addEmptyDescriptorFor: GlorpBankTransaction.	(system descriptorFor: GlorpBankTransaction) table: (system tableNamed: 'BANK_TRANS').	customerDescriptor := system addEmptyDescriptorFor: GlorpCustomer.	customerDescriptor table: customerTable.	system createMappingsFromClassModelIn: customerDescriptor.	self assert: (customerDescriptor mappingForAttributeNamed: #id) notNil.	self 		assert: (customerDescriptor mappingForAttributeNamed: #transactions) notNil.	system validate.	attributes := OrderedCollection new.	customerDescriptor classModel attributesDo: [:each | attributes add: each].	self assert: attributes size = 2.</body><body package="GlorpTests">testAllAttributesSkipDefined	| bankTransTable customerTable ownerId btOwnerId customerModel customerDescriptor ownerId2 |	bankTransTable := system addEmptyTableNamed: 'BANK_TRANS'.	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	ownerId2 := customerTable createFieldNamed: 'ID2' type: platform int4.	btOwnerId := bankTransTable createFieldNamed: 'OWNER_ID'				type: platform int4.	bankTransTable addForeignKeyFrom: btOwnerId to: ownerId.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #id type: Integer.	customerModel newAttributeNamed: #transactions		collectionOf: GlorpBankTransaction.	system addClassModelFor: GlorpBankTransaction.	system addEmptyDescriptorFor: GlorpBankTransaction.	customerDescriptor := system addEmptyDescriptorFor: GlorpCustomer.	customerDescriptor table: customerTable.	(customerDescriptor newMapping: DirectMapping) from: #id to: ownerId2.	system createMappingsFromClassModelIn: customerDescriptor.	self assert: customerDescriptor mappings size = 2.	self 		assert: (customerDescriptor mappingForAttributeNamed: #id) field = ownerId2</body><body package="GlorpTests">testDirectMapping	| customerTable ownerId descriptor mapping customerModel |	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #id type: Integer.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	descriptor table: customerTable.	system createMappingIn: descriptor fromClassModelForAttributeNamed: #id.	mapping := descriptor mappingForAttributeNamed: #id.	self assert: mapping class = DirectMapping.	self assert: mapping field = ownerId</body><body package="GlorpTests">testDirectMappingNameFieldNameComputation	| customerTable ownerId descriptor mapping customerModel |	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'OWNER_ID' type: platform int4.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #id type: Integer.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	descriptor table: customerTable.	system attributeNameToFieldNameBlock: [:symbol | 'OWNER_ID'].	system createMappingIn: descriptor fromClassModelForAttributeNamed: #id.	mapping := descriptor mappingForAttributeNamed: #id.	self assert: mapping class = DirectMapping.	self assert: mapping field = ownerId</body><body package="GlorpTests">testOneToOneRelation	| bankTransTable customerTable ownerId btOwnerId bankTransModel descriptor mapping |	bankTransTable := system addEmptyTableNamed: 'BANK_TRANS'.	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	btOwnerId := bankTransTable createFieldNamed: 'OWNER_ID'				type: platform int4.	bankTransTable addForeignKeyFrom: btOwnerId to: ownerId.	system		addClassModelFor: GlorpCustomer;		addEmptyDescriptorFor: GlorpCustomer.	bankTransModel := system addClassModelFor: GlorpBankTransaction.	bankTransModel newAttributeNamed: #owner type: GlorpCustomer.	descriptor := system addEmptyDescriptorFor: GlorpBankTransaction.	descriptor table: bankTransTable.	system createMappingIn: descriptor fromClassModelForAttributeNamed: #owner.	mapping := descriptor mappingForAttributeNamed: #owner.	self assert: mapping class = OneToOneMapping</body><body package="GlorpTests">testToManyRelation	| bankTransTable customerTable ownerId btOwnerId mapping customerModel customerDescriptor |	bankTransTable := system addEmptyTableNamed: 'BANK_TRANS'.	customerTable := system addEmptyTableNamed: 'GR_CUSTOMER'.	ownerId := customerTable createFieldNamed: 'ID' type: platform int4.	btOwnerId := bankTransTable createFieldNamed: 'OWNER_ID'				type: platform int4.	bankTransTable addForeignKeyFrom: btOwnerId to: ownerId.	customerModel := system addClassModelFor: GlorpCustomer.	customerModel newAttributeNamed: #transactions		collectionOf: GlorpBankTransaction.	system addClassModelFor: GlorpBankTransaction.	system addEmptyDescriptorFor: GlorpBankTransaction.	customerDescriptor := system addEmptyDescriptorFor: GlorpCustomer.	customerDescriptor table: customerTable.	system createMappingIn: customerDescriptor		fromClassModelForAttributeNamed: #transactions.	mapping := customerDescriptor mappingForAttributeNamed: #transactions.	self assert: mapping class = ToManyMapping.	self assert: mapping referenceClass = GlorpBankTransaction</body></methods><methods><class-id>Glorp.GlorpMappingFromClassModelTests</class-id> <category>running</category><body package="GlorpTests">setUp	platform := PostgresSocketPlatform new.	system := DynamicDescriptorSystem forPlatform: platform</body></methods><methods><class-id>Glorp.TestCommandPermission</class-id> <category>tests</category><body package="GlorpDBTests">testAlsoDeny	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyCommand: InsertCommand.	session accessor alsoDenyCommand: DeleteCommand.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					session delete: person]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testDenyReads	| person address |	[session beginTransaction.	self writeTestRows.	person := session readOneOf: GlorpPerson where: nil.	address := person address yourSelf.	session accessor denyReads.	self should: [session readOneOf: GlorpPerson where: nil] raise: GlorpIllegalCommand.	session inUnitOfWorkDo: [		session register: person.		session delete: address.		person address: (GlorpAddress new id: 7).		person name: 'Quigley Quagmire']]	ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testForbiddenDelete	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyCommand: DeleteCommand.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					session delete: person address.					person address: nil]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testForbiddenDeleteAllowsUpdateAndInsert	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyCommand: DeleteCommand.	person := session readOneOf: GlorpPerson where: nil.	session inUnitOfWorkDo: [		session register: person.		person address: (GlorpAddress new id: 7).		person name: 'Quigley Quagmire']]	ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testInsertOnlyAllowsInsert	| person |	[session beginTransaction.	self writeTestRows.	session accessor insertOnly.	person := session readOneOf: GlorpPerson where: nil.	session		inUnitOfWorkDo:			[session register: person.			session register: (GlorpPerson new id: 4)]]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testInsertOnlyForbidsDelete	| person |	[session beginTransaction.	self writeTestRows.	session accessor insertOnly.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					session delete: person]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testInsertOnlyForbidsUpdate	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyWrites.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					person name: 'Quigley Quagmire']]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testPermitEverything	session accessor permitEverything.	[session beginTransaction.	self writeTestRows.	session inUnitOfWorkDo: [ | person |		person := session readOneOf: GlorpPerson where: nil.		session delete: person address.		person address: (GlorpAddress new id: 7).		person name: 'Quigley Quagmire']]	ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testPermitNothing	session accessor permitNothing.	self should: [session read: GlorpPerson] raise: GlorpIllegalCommand.	self		should:			[session accessor executeCommand: InsertCommand new]		raise: GlorpIllegalCommand.	self		should:			[session accessor executeCommand: UpdateCommand new]		raise: GlorpIllegalCommand.	self		should:			[session accessor executeCommand: DeleteCommand new]		raise: GlorpIllegalCommand.	self		should:			[session accessor				executeCommand: SQLStringSelectCommand new]		raise: GlorpIllegalCommand.</body><body package="GlorpDBTests">testReadOnlyForbidsDelete	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyWrites.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					session delete: person]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testReadOnlyForbidsInsert	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyWrites.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					person address: (GlorpAddress new id: 7)]]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testReadOnlyForbidsUpdate	| person |	[session beginTransaction.	self writeTestRows.	session accessor denyWrites.	person := session readOneOf: GlorpPerson where: nil.	self		should:			[session				inUnitOfWorkDo:					[session register: person.					person name: 'Quigley Quagmire']]		raise: GlorpIllegalCommand] ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.TestCommandPermission</class-id> <category>support</category><body package="GlorpDBTests">writeTestRows	| addressRow personRow |	addressRow := session system exampleAddressRow.	session writeRow: addressRow.	personRow := session system examplePersonRow1.	session writeRow: personRow.</body></methods><methods><class-id>Glorp.GlorpStringTest</class-id> <category>tests</category><body package="GlorpTests">testGlorpIsCollection	self deny: 'abc' glorpIsCollection.	self deny: Object new glorpIsCollection.	self deny: $a glorpIsCollection.	self assert: #() glorpIsCollection.</body><body package="GlorpTests">testLikePercent	self deny: ('abc' like: 'def').	self assert: ('' like: '%').	self assert: ('abc' like: '%').	self assert: ('abc' like: '%bc').	self deny: ('abc' like: 'a%ac').	self assert: ('aaababc' like: '%bc').	self assert: ('abcd' like: 'ab%cd').	self assert: ('abcdef' like: 'ab%ef').	self assert: ('abcdef' like: 'ab%ef%').	self assert: ('abcdefg' like: 'ab%ef%').</body><body package="GlorpTests">testLikePercentButNotStar	self deny: ('abcd' like: 'abc*').	self deny: ('abcdefgh' like: 'ab%e*gh').	self assert: ('abcdefgh' like: 'ab%efgh').	self assert: ('abc*efg' like: 'abc*efg').	self assert: ('abc*efg' like: 'ab%g').	self assert: ('abc*efg' like: 'abc_efg').</body><body package="GlorpTests">testLikeUnderscore	self deny: ('' like: '_').	self assert: ('a' like: '_').	self assert: ('abc' like: '_bc').	self deny: ('aaababc' like: '_bc').	self deny: ('abcd' like: 'ab_cd').	self assert: ('abcd' like: 'a_cd').	self assert: ('abcdef' like: 'ab__ef').	self assert: ('abcdef' like: 'ab__ef%').	self assert: ('abcdefg' like: 'ab%ef_').	self deny: ('abcdefgh' like: 'ab%ef_').</body><body package="GlorpTests">testLikeUnderscoreButNotHash	self deny: ('a' like: '#').	self assert: ('a##b' like: 'a##b').	self assert: ('a#bcd' like: 'a#_cd').</body></methods><methods><class-id>Glorp.GlorpQueryUnionTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session beginTransaction.	self writeAddressOrderingRows.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests">writeAddressOrderingRows	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.</body><body package="GlorpDBTests">writePeople	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.</body></methods><methods><class-id>Glorp.GlorpQueryUnionTest</class-id> <category>tests-functional</category><body package="GlorpDBTests">testBasicExcept	| query1 query2 union result |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	query2 := Query read: GlorpAddress where: [:each | each id = 2].		union := query1 except: query2.	result := session execute: union.	self assert: result size = 1.</body><body package="GlorpDBTests">testBasicExcept2	| query1 query2 union result |	query1 := Query read: GlorpAddress where: [:each | each id in: #(1 2)].		query2 := Query read: GlorpAddress where: [:each | each id = 1].	union := query1 except: query2.	result := session execute: union.	self assert: result size = 1.	self assert: result first id = 2.</body><body package="GlorpDBTests">testBasicExcept3	| query1 query2 union result |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	query2 := Query read: GlorpAddress where: [:each | each street = 'Alpha'].		union := query1 except: query2.	result := session execute: union.	self assert: result size = 0.</body><body package="GlorpDBTests">testBasicIntersect	| query1 query2 union result |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	query2 := Query read: GlorpAddress where: [:each | each id = 2].		union := query1 intersect: query2.	result := session execute: union.	self assert: result size = 0.</body><body package="GlorpDBTests">testBasicIntersect2	| query1 query2 union result |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	query2 := Query read: GlorpAddress where: [:each | each id in: #(1 2)].		union := query1 intersect: query2.	result := session execute: union.	self assert: result size = 1.</body><body package="GlorpDBTests">testBasicIntersect3	| query1 query2 union result |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	query2 := Query read: GlorpAddress where: [:each | each street = 'Alpha'].		union := query1 intersect: query2.	result := session execute: union.	self assert: result size = 1.</body><body package="GlorpDBTests">testBasicUnion	| query1 query2 union result |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	query2 := Query read: GlorpAddress where: [:each | each id = 2].		union := query1 unionAll: query2.	result := session execute: union.	self assert: result size = 2.	self assert: result first id = 1.	self assert: result last id = 2.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests">testCompoundWithSingleQuery	"Test that the coding of CompoundQuery is robust to the trivial case of there only being a single query.  We deliberately do not set the operation, thus verifying that a single query nowhere consults it.  This test demonstrates that both 'requiresDistinct' and 'readsOneObject' are initialized on the assumption there will be multiple queries."	| union result |	self writePeople.	union := CompoundQuery new addQuery:		(Query readOneOf: GlorpAddress where: [:each | each id = 2]).	union requiresDistinct: false.	"only one query, so we cannot need to read distinct"	union readsOneObject:		"only one query, so we could need to just one object"		union queries first readsOneObject.	result := session execute: union.	self assert: result class == GlorpAddress.	self assert: result street = 'Beta'.	self assert: result number = '200'</body><body package="GlorpDBTests">testOrderByInAlsoFetchUnion	"On Oracle, SQLServer and MySQL, a compound query with same-name fields (from different tables, of course) will raise a duplicate/ambiguous error.  Glorp aliases the fields to avoid this."	| query1 query2 union result |	self writePeople.	query1 := Query read: GlorpPerson where: [:each | each id = 86].	query2 := Query read: GlorpPerson where: [:each | each id = 87].	query1 alsoFetch: [:each | each address].	query2 alsoFetch: [:each | each address].	union := query1 unionAll: query2.	union orderBy: [:each | each name].	union orderBy: [:each | each address number].	result := session execute: union.	self assert: result first id = 86.	self assert: result last id = 87.</body><body package="GlorpDBTests">testOrderByInUnion	| query1 query2 union result |	self writePeople.	query1 := Query read: GlorpAddress where: [:each | each id &gt; 1].	query1 retrieve: #id.	query2 := Query read: GlorpPerson.	query2 retrieve: [:each | each id].	union := query1 unionAll: query2.	union orderBy: [:each | each id descending].	result := session execute: union.	self assert: result = #(87 86 3 2).</body><body package="GlorpDBTests">testOrderBySameNameFieldsInAlsoFetchUnion	| query1 query2 union result |	self writePeople.	query1 := Query read: GlorpPerson where: [:each | each id = 86].	query2 := Query read: GlorpPerson where: [:each | each id = 87].	query1 alsoFetch: [:each | each address].	query2 alsoFetch: [:each | each address].	union := query1 unionAll: query2.	union orderBy: [:each | each id].	union orderBy: [:each | each address id alias: 'AddressTableID'].	result := session execute: union.	self assert: result first id = 86.	self assert: result last id = 87.</body><body package="GlorpDBTests">testRetrieveFixedValue	| query1 query2 union result |	self writePeople.	query1 := Query read: GlorpPerson where: [:each | each id = 86].	query1 retrieve: #id.	query1 retrieve: [:each | each getConstant: 0 alias: #hasPaid].	query2 := Query read: GlorpPerson where: [:each | each id = 87].	query2 retrieve: #id.	query2 retrieve: [:each | each getConstant: 1 alias: #hasPaid].	union := query1 unionAll: query2.	union orderBy: [:each | each id descending].	result := session execute: union.	self assert: result = #(#(87 1) #(86 0)).</body><body package="GlorpDBTests">testThreeWayUnion	| query1 query2 union result query3 |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	query2 := Query read: GlorpAddress where: [:each | each id = 2].		query3 := Query read: GlorpAddress where: [:each | each id = 3].		union := (query1 unionAll: query2) unionAll: query3.	union orderBy: [:each | each id].	result := session execute: union.	self assert: result size = 3.	self assert: result first id = 1.	self assert: result last id = 3.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests">testThreeWayUnionNested	"If we send #unionAll: to a CompoundQuery that is already a union, we create an unnested CompoundQuery for efficiency.  If we send it in reverse order, we do not check, so create a union within a union.  The same SQL code is generated but the bracketting differs:	(...) UNION ALL ((...) UNION ALL (...))in the nested query, compared to	(...) UNION ALL (...) UNION ALL (...)in the flattened query."	| query1 query2 union result query3 |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	query2 := Query read: GlorpAddress where: [:each | each id = 2].		query3 := Query read: GlorpAddress where: [:each | each id = 3].		union := query3 unionAll: (query1 unionAll: query2).	union orderBy: [:each | each id].	result := session execute: union.	self assert: result size = 3.	self assert: result first id = 1.	self assert: result last id = 3.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests">testUnionWithEmpty	| query1 query2 union result |	query1 := Query read: GlorpAddress where: false.	query2 := Query read: GlorpAddress where: [:each | each id = 2].		union := query1 unionAll: query2.	result := session execute: union.	self assert: result size = 1.	self assert: result first id = 2.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests">testUnionWithParameters	| query1 query2 union result field1 dict |	field1 := (system tableNamed: 'GR_ADDRESS') fieldNamed: 'ID'.	query1 := Query read: GlorpAddress where: [:each | each id = (each parameter: field1)].	query2 := Query read: GlorpAddress where: [:each | each id = ((each parameter: field1) + 1)].		union := query1 unionAll: query2.	union orderBy: [:each | each id].	dict := Dictionary new at: field1 put: 2; yourself.	result := union executeWithParameters: dict in: session.	self assert: result size = 2.	self assert: result first id = 2.	self assert: result last id = 3.	self assert: (result allSatisfy: [:each | each class == GlorpAddress]).</body><body package="GlorpDBTests">testUnionWithRetrieveDisaparateResults	| query1 query2 union result |	self writePeople.	query1 := Query read: GlorpAddress.	query1 retrieve: #id.	query2 := Query read: GlorpPerson.	query2 retrieve: #id.	union := query1 unionAll: query2.	result := session execute: union.	self assert: result asSortedCollection asArray = #(1 2 3 86 87).</body><body package="GlorpDBTests">testUnionWithRetrieveThoroughlyDisaparateResults	"Fields from mismatched tables"	| query1 query2 union result |	self writePeople.	query1 := Query read: GlorpAddress.	query1 retrieve: [:each | each street].	query2 := Query read: GlorpPerson.	query2 retrieve: [:each | each name].	union := query1 unionAll: query2.	result := session execute: union.	self assert: result asSortedCollection asArray = #('Alpha' 'Beta' 'Gamma' 'person1' 'person2').</body><body package="GlorpDBTests">testUnionWithRetrieveThoroughlyDisaparateResults2	"The tables will get aliased differently, make sure that works"	| query1 query2 union result |	self writePeople.	query1 := Query read: GlorpAddress where: [:each | each id = 2].	query1 retrieve: [:each | each street].	query2 := Query read: GlorpPerson where: [:each | each id = 87].	query2 retrieve: [:each | each address street].	union := query1 unionAll: query2.	result := session execute: union.	self assert: result asSortedCollection asArray = #('Beta' 'Gamma').</body></methods><methods><class-id>Glorp.GlorpQueryUnionTest</class-id> <category>tests-unit</category><body package="GlorpDBTests">testCompoundCommandCreate	| query1 union command |	query1 := Query read: GlorpAddress.	union := query1 unionAll: query1.	union session: session.	command := union sqlWith: #().	self assert: command class == CompoundSelectCommand.</body><body package="GlorpDBTests">testCreateCompoundQuery	| query1 union |	query1 := Query read: GlorpAddress.	union := query1 unionAll: query1.	self assert: union class == CompoundQuery.</body><body package="GlorpDBTests">testUnionSQL	"Use expandMacros to avoid platform-specific line-end conventions blocking string matching."	| query1 union command |	query1 := Query read: GlorpAddress where: [:each | each id = 1].	union := query1 unionAll: query1.	union session: session.	command := union sqlWith: #().	self assert: ('SELECT * FROM (*SELECT *&lt;n&gt; FROM GR_ADDRESS t1&lt;n&gt; WHERE *t1.ID = * UNION ALL *SELECT *&lt;n&gt; FROM GR_ADDRESS t1&lt;n&gt; WHERE *t1.ID = *' expandMacros match: command sqlString).</body></methods><methods><class-id>Glorp.GlorpConditionalMappingTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	descriptor := system descriptorFor: GlorpPassenger.	mapping := descriptor newMapping: ConditionalMapping.	mapping conditionalField: (descriptor primaryTable fieldNamed: 'ID').	mapping if: #testIDLessThan5: then: (mapping1 := DirectMapping from: #blah to: (descriptor primaryTable fieldNamed: 'ID')).	mapping if: #testIDMoreThan5: then: (mapping2 := DirectMapping from: #bletch to: (descriptor primaryTable fieldNamed: 'NAME')).	mapping otherwise: (mapping3 := DirectMapping from: #bazoomer to: (descriptor primaryTable fieldNamed: 'ID')).	mapping conditionalMethod: #id.</body><body package="GlorpTests">setUpNew	"Set up using the newer protocol"	newMapping := descriptor newMapping: ConditionalMapping.	newMapping		forField: (descriptor primaryTable fieldNamed: 'ID')		attribute: #id		if: [:value | value = 1]		useMapping: (mapping1 := DirectMapping from: #blah to: (descriptor primaryTable fieldNamed: 'ID')).	newMapping if: #testIDMoreThan5: then: (mapping2 := DirectMapping from: #bletch to: (descriptor primaryTable fieldNamed: 'NAME')).	newMapping otherwise: (mapping3 := DirectMapping from: #bazoomer to: (descriptor primaryTable fieldNamed: 'ID')).</body></methods><methods><class-id>Glorp.GlorpConditionalMappingTest</class-id> <category>tests</category><body package="GlorpTests">testApplicableMappingForReadNewProtocol	| builder |	self setUpNew.	builder := ElementBuilder for: ([:x | x] asGlorpExpressionForDescriptor: descriptor) in: SimpleQuery new.	builder row: #(1 foo nil nil).	self assert: (newMapping applicableMappingForRow: #(1 foo nil nil) in: builder) == mapping1.	builder row: #(6 foo nil nil).	self assert: (newMapping applicableMappingForRow: #(6 foo nil nil) in: builder) == mapping2.	builder row: #(5 foo nil nil).	self assert: (newMapping applicableMappingForRow: #(5 foo nil nil) in: builder) == mapping3.</body><body package="GlorpTests">testApplicableMappingForReadOldProtocol	| builder |	builder := ElementBuilder for: ([:x | x] asGlorpExpressionForDescriptor: descriptor) in: SimpleQuery new.	builder row: #(1 foo nil nil).	self assert: (mapping applicableMappingForRow: #(1 foo nil nil) in: builder) == mapping1.	builder row: #(6 foo nil nil).	self assert: (mapping applicableMappingForRow: #(6 foo nil nil) in: builder) == mapping2.	builder row: #(5 foo nil nil).	self assert: (mapping applicableMappingForRow: #(5 foo nil nil) in: builder) == mapping3.</body><body package="GlorpTests">testApplicableMappingForWriteNewProtocol	| passenger |	self setUpNew.	passenger := GlorpPassenger new.	passenger id: 1.	self assert: (newMapping applicableMappingForObject: passenger) == mapping1.	passenger id: 6.	self assert: (newMapping applicableMappingForObject: passenger) == mapping2.	passenger id: 5.	self assert: (newMapping applicableMappingForObject: passenger) == mapping3.</body><body package="GlorpTests">testApplicableMappingForWriteOldProtocol	| passenger |	passenger := GlorpPassenger new.	passenger id: 1.	self assert: (mapping applicableMappingForObject: passenger) == mapping1.	passenger id: 6.	self assert: (mapping applicableMappingForObject: passenger) == mapping2.	passenger id: 5.	self assert: (mapping applicableMappingForObject: passenger) == mapping3.</body><body package="GlorpTests">testDescriptor	self assert: mapping1 descriptor == descriptor.	self assert: mapping2 descriptor == descriptor.	self assert: mapping3 descriptor == descriptor.</body><body package="GlorpTests">testMappedFieldsOldProtocol	self assert: mapping mappedFields asSortedCollection = descriptor primaryTable fields asSortedCollection.	mapping := descriptor newMapping: ConditionalMapping.	self assert: mapping mappedFields isEmpty.	mapping conditionalField: (descriptor primaryTable fieldNamed: 'ID').	self assert: mapping mappedFields size = 1.		mapping if: #testIDLessThan5: then: (mapping1 := DirectMapping from: #blah to: (descriptor primaryTable fieldNamed: 'NAME')).	self assert: mapping mappedFields asSortedCollection = descriptor primaryTable fields asSortedCollection.</body></methods><methods><class-id>Glorp.ASCustomer</class-id> <category>accessing</category><body package="GlorpTestModels">customer	^customer</body><body package="GlorpTestModels">customer: anObject	customer := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body><body package="GlorpTestModels">orders	^orders</body><body package="GlorpTestModels">orders: anObject	orders := anObject</body></methods><methods><class-id>Glorp.ASCustomer</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	id := nil.	customer := nil.	name := nil.	orders := OrderedCollection new.</body></methods><methods><class-id>Glorp.ASCustomer class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingErrorTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	session system: (GlorpEncyclopediaStockDescriptorSystem forPlatform: session platform).	session beginTransaction.</body><body package="GlorpTests">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingErrorTest</class-id> <category>running</category><body package="GlorpTests">testModifyLinkTableForcingKeyRaisesError	"Change link table rows, not either of the two class tables.  This test involves a MultiRowKeyMap as owner of the link table row, and will not throw an exception in RowMap&gt;&gt;collapseMatchingInsertsAndDeletesFor:."	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpTinyPublisher where: [:each | each id = 1].		[session inUnitOfWorkDo: 			[session modify: publisher				in: [publisher titlesWithNumberInStock at: 'Mastering ENVY/Developer' put: 123]]]	on: Dialect error	do: [:ex | ^self assert: (ex messageText ~= 'link table entry requiring update is only partially populated') description: 'Raised #collapseMatchingInsertsAndDeletesFor: error'].	self assert: true description: 'No error raised'</body></methods><methods><class-id>Glorp.Successor</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">station	^station</body><body package="GlorpTestModels">station: anObject	station := anObject</body><body package="GlorpTestModels">successorCustomer	^successorCustomer</body><body package="GlorpTestModels">successorCustomer: anObject	successorCustomer := anObject</body><body package="GlorpTestModels">successorFeeder	^successorFeeder</body><body package="GlorpTestModels">successorFeeder: anObject	successorFeeder := anObject</body></methods><methods><class-id>Glorp.InheritanceQueryTest</class-id> <category>utility</category><body package="GlorpTests">queryForCustomerStation	| query |	query := Query read: CustomerStation where:		[:customerStation |		customerStation successor anySatisfy:			[:successor | successor id in: self queryForSuccessor]].	query retrieve: [:customerStation | customerStation id].	^query</body><body package="GlorpTests">queryForFeederStation	| query |	query := Query read: FeederStation where: [:feederStation | feederStation id in: #(1 2 3 4)].	query retrieve: [:feederStation | feederStation id].	^query</body><body package="GlorpTests">queryForSuccessor	| query |	query := Query read: Successor where:		[:successor | successor successorFeeder id in: self queryForFeederStation].	query retrieve: [:successor | successor id].	^query</body><body package="GlorpTests">writeTestHarness	|  feedStation1 feedStation2 feedStation3 custStation6 custStation7 custStation8 custStation9 custStation10 custStation11 |	session register: (feedStation1 := FeederStation new id: 1; yourself).	session register: (feedStation2 := FeederStation new id: 2; yourself).	session register: (feedStation3 := FeederStation new id: 3; yourself).	session register: ("feedStation4 := "FeederStation new id: 4; yourself).	session register: ("feedStation5 := "FeederStation new id: 5; yourself).		session register: (custStation6 := CustomerStation new id: 6; yourself).	session register: (custStation7 := CustomerStation new id: 7; yourself).	session register: (custStation8 := CustomerStation new id: 8; yourself).	session register: (custStation9 := CustomerStation new id: 9; yourself).	session register: (custStation10 := CustomerStation new id: 10; yourself).	session register: (custStation11 := CustomerStation new id: 11; yourself).	feedStation1 successor:		(Array			with: (Successor new id: 101; station: feedStation1; successorCustomer: custStation6; yourself)			with: (Successor new id: 102; station: feedStation1; successorCustomer: custStation7; yourself)			with: (Successor new id: 103; station: feedStation1; successorCustomer: custStation8; yourself)).	feedStation2 successor:		(Array			with: (Successor new id: 104; station: feedStation2; successorCustomer: custStation9; yourself)			with: (Successor new id: 105; station: feedStation2; successorCustomer: custStation10; yourself)).	"This last line is the one found in #testSubSelectRebuild.  If we did not set both successorFeeder and successorCustomer, it would not be found (see the test's comment)."	custStation10 successor:		(Array			with: (Successor new id: 106; station: custStation10; successorFeeder: feedStation3; successorCustomer: custStation11; yourself)).</body></methods><methods><class-id>Glorp.InheritanceQueryTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	system := InheritanceQueryDescriptorSystem forPlatform: session platform.	session system: system.	session beginTransaction.	session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.</body><body package="GlorpTests">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.InheritanceQueryTest</class-id> <category>running</category><body package="GlorpTests">testInnerQueries	self assert: (session execute: self queryForCustomerStation) size = 1.</body><body package="GlorpTests">testLocalInnerQueries	"The same as testInnerQueries, but with all the queries defined within the block (should run the same)."	| query |	query := Query read: CustomerStation where:		[:customerStation |		customerStation successor anySatisfy: 			[:successor || query2 |			query2 := Query read: Successor where: 				[:successor1 || feederQuery |				feederQuery := Query read: FeederStation where:					[:feederStation | feederStation id in: #(1 2 3 4)].				feederQuery retrieve: [:feederStation | feederStation id].				successor1 successorFeeder id in: feederQuery].			query2 retrieve: [:successor1 | successor1 id].			successor id in: query2]].	query retrieve: [:customerStation | customerStation id].	self assert: (session execute: query) = #(10).</body><body package="GlorpTests">testSubSelectRebuild	"The OR in the anySatisfy block works for a successor with both successorCustomer and successorFeeder values.  It does not work when one is nil because the nil check ends up being asked of the object, not the successor object's field ponting to it.  (Maybe fix with outer join?)"	| query stations unproxiedSuccessor |	query := Query read: Station where:		[:station |		station successor anySatisfy:			[:successor |			successor successorFeeder id = 3 OR:				[successor successorCustomer id = 1]]].	stations := session execute: query.	self assert: stations size = 1.	unproxiedSuccessor := stations first successor first.	self assert: unproxiedSuccessor successorFeeder id = 3.</body><body package="GlorpTests">testTestHarness	"The test writes 5 customer stations and 5 feeder stations, thus adding 10 rows to the horizontally-mapped superclass's table (Station)."	self assert: (session read: Station) size = 11.	self assert: (session read: CustomerStation) size = 6.	self assert: (session read: FeederStation) size = 5.	self assert: (session read: Successor) size = 6.</body></methods><methods><class-id>Glorp.GlorpTransformedTime</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">time	^time</body><body package="GlorpTestModels">time: anObject	time := anObject</body></methods><methods><class-id>Glorp.GlorpTransformedTime</class-id> <category>initialize</category><body package="GlorpTestModels">initialize	time := Time now.</body></methods><methods><class-id>Glorp.GlorpTransformedTime class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDirectMappingTest</class-id> <category>support</category><body package="GlorpTests">setUp	| descriptor |	super setUp.	mapping := DirectMapping from: #id to: ((system tableNamed: 'GR_CUSTOMER') fieldNamed: 'ID').	descriptor := Descriptor new.	descriptor classModel: (GlorpClassModel for: GlorpCustomer).	descriptor addMapping: mapping.</body></methods><methods><class-id>Glorp.GlorpDirectMappingTest</class-id> <category>tests</category><body package="GlorpTests">testExpressionFor	| cust exp |	cust := GlorpCustomer new.	cust id: 12.	exp := mapping		expressionFor: cust		basedOn: BaseExpression new		relation: #=.	self assert: exp rightChild class == ConstantExpression.	self assert: exp rightChild value = 12.	self assert: exp relation = #=.	self assert: exp leftChild class == MappingExpression.</body><body package="GlorpTests">testProxying	| customers |	session beginTransaction.	[((system descriptorFor: GlorpPerson) mappingForAttributeNamed: #name) shouldProxy: true.	session modify: GlorpPerson example1 in: [].	session reset.	customers := session read: GlorpPerson.	self assert: customers first name isGlorpProxy.	self deny: customers first name isInstantiated.	self assert: customers first name = 'Zaphod Beeblebrox']		ensure: [session rollbackTransaction].	self deny: ((system descriptorFor: GlorpPerson) mappedFields includes: ((system tableNamed: 'PERSON') fieldNamed: 'NAME')).</body></methods><methods><class-id>Glorp.BatchTestUpdateCommand</class-id> <category>bound values</category><body package="GlorpTestModels">batchBindingTypes: arrayBindingTypes	"Were batch binding to be used in the UpdateCommand hierarchy, not just in this test, this metghod should be pushed up and called on bindingTypes as needed."	| size all |	size := arrayBindingTypes size.	all := Array new: allRows size * size.	0 to: allRows size - 1 do:		[:i || index | index := i * size.		all replaceElementsFrom: index + 1 to: index + size withArray: arrayBindingTypes startingAt: 1].	^all</body><body package="GlorpTestModels">bindingTypes	^(self shouldUseGroupWriting not or: [self platform usesArrayBindingToGroupWrite])		ifTrue: [super bindingTypes]		ifFalse: [self batchBindingTypes: super bindingTypes]</body></methods><methods><class-id>Glorp.ClassK</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassK	^attrAClassK</body><body package="GlorpTestModels">attrAClassK: anObject	attrAClassK := anObject</body><body package="GlorpTestModels">attrBClassK	^attrBClassK</body><body package="GlorpTestModels">attrBClassK: anObject	attrBClassK := anObject</body><body package="GlorpTestModels">attrCClassK	^attrCClassK</body><body package="GlorpTestModels">attrCClassK: anObject	attrCClassK := anObject</body></methods><methods><class-id>Glorp.ClassK</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassK := nil.	attrBClassK := nil.	attrCClassK := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.ClassK class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpExampleSystem</class-id> <category>initialize</category><body package="GlorpTestModels">initialize	objects := Dictionary new.</body></methods><methods><class-id>Glorp.GlorpExampleSystem</class-id> <category>misc</category><body package="GlorpTestModels">lookupObject: aNumber ofClass: aClass ifAbsentPut: absentBlock	^(objects at: aClass ifAbsentPut: [Dictionary new]) at: aNumber ifAbsentPut: absentBlock.</body></methods><methods><class-id>Glorp.GlorpExampleSystem</class-id> <category>api</category><body package="GlorpTestModels">objectNumber: aNumber ofClass: aClass	| symbol instance|	instance := self lookupObject: aNumber ofClass: aClass ifAbsentPut: [aClass new].	symbol := ('example', aClass name, 'Number', aNumber printString, ':') asSymbol.	self perform: symbol with: instance.	^instance.</body></methods><methods><class-id>Glorp.GlorpExampleSystem class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpBankExampleSystem</class-id> <category>examples</category><body package="GlorpTestModels">exampleGlorpAddressNumber1: anAddress	anAddress id: 12.	anAddress street: 'Paseo Montril'.	anAddress number: '10185'.</body><body package="GlorpTestModels">exampleGlorpBankAccountNumber1: anAccount	anAccount id: 1.	anAccount accountNumber: (self objectNumber: 1 ofClass: GlorpBankAccountNumber).</body><body package="GlorpTestModels">exampleGlorpBankAccountNumber2: anAccount	anAccount id: 2.	anAccount accountNumber: (self objectNumber: 2 ofClass: GlorpBankAccountNumber).</body><body package="GlorpTestModels">exampleGlorpBankAccountNumberNumber1: aBankAccountNumber	aBankAccountNumber bankCode: '004'.	aBankAccountNumber branchNumber: 0342.	aBankAccountNumber accountNumber: '12345'.</body><body package="GlorpTestModels">exampleGlorpBankAccountNumberNumber2: aBankAccountNumber	aBankAccountNumber bankCode: '004'.	aBankAccountNumber branchNumber: 0342.	aBankAccountNumber accountNumber: '01010'.</body><body package="GlorpTestModels">exampleGlorpBankTransactionNumber1: aTrans	"Nothing to initialize"</body><body package="GlorpTestModels">exampleGlorpBankTransactionNumber2: aTrans	"Nothing to initialize"</body><body package="GlorpTestModels">exampleGlorpCustomerNumber1: aCustomer	aCustomer id: 1.	aCustomer name: 'Fred Flintstone'.	aCustomer addTransaction: (self objectNumber: 1 ofClass: GlorpBankTransaction).	aCustomer addTransaction: (self objectNumber: 2 ofClass: GlorpBankTransaction).	aCustomer addAccount: (self objectNumber: 1 ofClass: GlorpBankAccount).	aCustomer addAccount: (self objectNumber: 2 ofClass: GlorpBankAccount).</body><body package="GlorpTestModels">exampleGlorpEmailAddressNumber1: anEmailAddress 	anEmailAddress id: 2.	anEmailAddress user: 'foo'.	anEmailAddress host: 'bar.com'</body><body package="GlorpTestModels">exampleGlorpPersonNumber1: aPerson 	aPerson id: 1.	aPerson name: 'Barney Rubble'.	aPerson address: (self objectNumber: 1 ofClass: GlorpAddress).		aPerson emailAddress: (self objectNumber: 1 ofClass: GlorpEmailAddress).</body></methods><methods><class-id>Glorp.GlorpTag</class-id> <category>as yet unclassified</category><body package="GlorpTestModels">generateKeyFromLabel	key := label asLowercase</body><body package="GlorpTestModels">key	^ key</body><body package="GlorpTestModels">key: aKey	key := aKey</body><body package="GlorpTestModels">label	^ label</body><body package="GlorpTestModels">label: aLabel	label := aLabel</body></methods><methods><class-id>Glorp.GlorpItemRelativeLocks</class-id> <category>accessing</category><body package="GlorpTestModels">lock1	^lock1</body><body package="GlorpTestModels">lock1: anInteger	"My database field is of VersionType, so my update values are generated, but this method can set a start value in a test."	lock1 := anInteger.</body><body package="GlorpTestModels">lock2	^lock2</body><body package="GlorpTestModels">lock2: anInteger	"My database field is _not_ of VersionType.  This is debatable:  generation is normal for lock fields.  Change or clarify.  Also I am not used in tests.  Use or lose me."	lock2 := anInteger.</body></methods><methods><class-id>Glorp.GlorpCollectionTypesDescriptorSystem</class-id> <category>tables</category><body package="GlorpCollectionTypeModels">linkTable	^self tableNamed: 'GR_THING_LINK'.</body><body package="GlorpCollectionTypeModels">ownerTable	^self tableNamed: 'GR_THINGWITHCOLLECTIONS'.</body><body package="GlorpCollectionTypeModels">tableForGR_THINGONE: aTable	| setOwnerId arrayOwnerId |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	setOwnerId := aTable createFieldNamed: 'SET_OWNER' type: platform int4.	aTable addForeignKeyFrom: setOwnerId		to: (self ownerTable fieldNamed: 'ID').	arrayOwnerId := aTable createFieldNamed: 'ARRAY_OWNER' type: platform int4.	aTable addForeignKeyFrom: arrayOwnerId		to: (self ownerTable fieldNamed: 'ID').	aTable createFieldNamed: 'ARRAY_POSITION' type: platform int4.</body><body package="GlorpCollectionTypeModels">tableForGR_THINGWITHCOLLECTIONS: aTable	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).</body><body package="GlorpCollectionTypeModels">tableForGR_THING_LINK: aTable	| ownerId thingId |	ownerId := (aTable createFieldNamed: 'OWNER_ID' type: platform int4) bePrimaryKey.	aTable addForeignKeyFrom: ownerId to: (self ownerTable fieldNamed: 'ID').	thingId := (aTable createFieldNamed: 'THING_ID' type: platform int4) bePrimaryKey.	aTable		addForeignKeyFrom: thingId		to: (self thingOneTable fieldNamed: 'ID').	aTable createFieldNamed: 'TYPE' type: (platform char: 1).	aTable createFieldNamed: 'POSITION' type: platform int4.</body><body package="GlorpCollectionTypeModels">thingOneTable	^self tableNamed: 'GR_THINGONE'.</body></methods><methods><class-id>Glorp.GlorpCollectionTypesDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpCollectionTypeModels">descriptorForGlorpThingOne: aDescriptor 	aDescriptor table: self thingOneTable.	aDescriptor addMapping: (DirectMapping from: #id to: (self thingOneTable fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (self thingOneTable fieldNamed: 'NAME')).</body><body package="GlorpCollectionTypeModels">descriptorForGlorpThingWithLotsOfDifferentCollections: aDescriptor	| ocMapping |	aDescriptor table: self ownerTable.	aDescriptor		addMapping:			(DirectMapping from: #id to: (self ownerTable fieldNamed: 'ID')).	aDescriptor		addMapping:			(DirectMapping from: #name to: (self ownerTable fieldNamed: 'NAME')).	aDescriptor		addMapping:			((OneToManyMapping new)				attributeName: #array;				referenceClass: GlorpThingOne;				collectionType: Array;				orderBy: [:each | (each getTable: self thingOneTable) getField: 'ARRAY_POSITION'];				writeTheOrderField;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self thingOneTable fieldNamed: 'ARRAY_OWNER'))).	aDescriptor		addMapping:			((OneToManyMapping new)				attributeName: #set;				referenceClass: GlorpThingOne;				collectionType: Set;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self thingOneTable fieldNamed: 'SET_OWNER'))).	ocMapping := ((ManyToManyMapping new)				attributeName: #orderedCollection;				referenceClass: GlorpThingOne;				collectionType: OrderedCollection;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self linkTable fieldNamed: 'OWNER_ID')								from: 'O'								to: (self linkTable fieldNamed: 'TYPE'))).	ocMapping orderBy: [:each | (each getTable: self linkTable) getField: 'POSITION'].	ocMapping writeTheOrderField.	aDescriptor addMapping: ocMapping.	aDescriptor		addMapping:			((ManyToManyMapping new)				attributeName: #bag;				referenceClass: GlorpThingOne;				collectionType: Bag;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self linkTable fieldNamed: 'OWNER_ID')								from: 'B'								to: (self linkTable fieldNamed: 'TYPE'))).	aDescriptor		addMapping:			((ManyToManyMapping new)				attributeName: #sortedCollection;				referenceClass: GlorpThingOne;				collectionType: SortedCollection;				join:						(Join								from: (self ownerTable fieldNamed: 'ID')								to: (self linkTable fieldNamed: 'OWNER_ID')								from: 'S'								to: (self linkTable fieldNamed: 'TYPE'))).</body></methods><methods><class-id>Glorp.GlorpCollectionTypesDescriptorSystem</class-id> <category>accessing</category><body package="GlorpCollectionTypeModels">allTableNames	^#('GR_THINGWITHCOLLECTIONS' 'GR_THINGONE' 'GR_THING_LINK').</body><body package="GlorpCollectionTypeModels">constructAllClasses	^super constructAllClasses add: GlorpThingWithLotsOfDifferentCollections; add: GlorpThingOne; yourself.</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>tests</category><body package="GlorpDBTests">testAutomaticRegistrationOnRead	| p c |	p := self exampleCustomerProxy.	c := p getValue.	session beginUnitOfWork.	session register: p.	self assert: (session isRegistered: p).	self assert: (session isRegistered: c).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction isRegistered: p).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction isRegistered: c).</body><body package="GlorpDBTests">testCheckIfInstantiationRequiredForDirectMapping	| c1 mapping proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	c1 name: proxy.	session beginUnitOfWork.	session register: c1.	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #name.	self deny: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests">testCheckIfInstantiationRequiredForRelationshipInstantiatedProxy	| c1 mapping proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	proxy query: (GlorpQueryStub new session: session; result: 'foo').	proxy session: session.	proxy yourSelf.	c1 accounts: proxy.	session beginUnitOfWork.	session register: c1.	c1 accounts: #().	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts.	self deny: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests">testCheckIfInstantiationRequiredForRelationshipNoChange	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| c1 mapping proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	c1 accounts: proxy.	session beginUnitOfWork.	session privateRegisterAsOld: c1.	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts.	self deny: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests">testCheckIfInstantiationRequiredForRelationshipNoProxy	| c1 mapping |	c1 := GlorpCustomer new.	c1 accounts: #().	session beginUnitOfWork.	session register: c1.	c1 accounts: nil.	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts.	self deny: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests">testCheckIfInstantiationRequiredForRelationshipWithChange	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| c1 mapping proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	proxy session: session.	proxy query: (GlorpQueryStub new result: 'foo').	c1 accounts: proxy.	session beginUnitOfWork.	session privateRegisterAsOld: c1.	c1 accounts: #().	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #accounts.	self assert: (session privateGetCurrentUnitOfWork instantiateIfRequiredFor: c1 mapping: mapping).</body><body package="GlorpDBTests">testCheckIfInstantiationRequiredForToManyRelationshipFromNew	"Note that we force the object to be registered as new, just to make absolutely sure it's being treated as a new object."	| c1 proxy |	c1 := GlorpCustomer new.	proxy := Proxy new.	proxy session: session.	c1 accounts: proxy.	session beginUnitOfWork.	session privateRegisterAsNew: c1.	self assert: (proxy isInstantiated).</body><body package="GlorpDBTests">testCommitOrderAtSessionLevel	| tables | 	tables := session tablesInCommitOrder.	tables first name = 'CUSTOMER'.	self unfinished.</body><body package="GlorpDBTests">testOriginalValueFor	| c1 mapping |	c1 := GlorpCustomer new.	c1 name: 'fred'.	session beginUnitOfWork.	session register: c1.	c1 name: 'barney'.	mapping := (session descriptorFor: GlorpCustomer) mappingForAttributeNamed: #name.	self assert: (session privateGetCurrentUnitOfWork originalValueFor: c1 mapping: mapping) = 'fred'.</body><body package="GlorpDBTests">testRollbackImmutableNonImmediateLiteral	"Values written as literals in code such as 'Smalltalk' or 3.1415926535898d or 2.718s are immutable but not immediate.  Such values, if registered, are immensely unlikely to change intentionally - that's why they are made immutable.  By contrast, non-literal objects may be immutable and may change in #whileMutableDo: - see GlorpWVWriteBarrierTracker.  If we register an isLiteralImmutable value (and have no modificationTracker set in the session), we need to be able to abort that session's unit of work without seeing a spurious modification error.  Equally, we must not prevent GlorpWVWriteBarrierTracker from working correctly when in use (tests for that are in GlorpMigrationTests;  see e.g. #testAutoRegistrationUsingImmutabilityFlag)."	| salariedEmployees query namedSalaries |	salariedEmployees := Array		with: (GlorpSalariedEmployee new id: 1; name: 'double'; salary: 98765.4321d; yourself)		with: (GlorpSalariedEmployee new id: 2; name: 'float'; salary: 25.5; yourself)		with: (GlorpSalariedEmployee new id: 3; name: 'fixed'; salary: 12345.6789s; yourself).	"In Oracle array binding, a statement in OracleSession&gt;&gt;findRightBindingType: that raises an error if Doubles are combined with FixedPoints (or Integers) in the same column of the same array.  Thus we must use two units of work to write them separately.  (If you do not use binding (e.g. if you execute 'DatabasePlatform useBindingIfSupported: false' then the test passes on Oracle with all three registered in a single unit of work.)"	[session inUnitOfWorkDo: [:sess | sess registerAll: (salariedEmployees first: 2)].	session inUnitOfWorkDo: [:sess | sess register: salariedEmployees last].	session beginUnitOfWork.	query := SimpleQuery read: GlorpSalariedEmployee.	query orderBy: #salary; retrieve: #name; retrieve: #salary.	namedSalaries := session execute: query.	session rollbackUnitOfWork.	self assert: (namedSalaries collect: #first) = #('float' 'fixed' 'double').	self assert: (namedSalaries collect: #last) = #(25.5 12345.6789s 98765.4321d)]		ensure: [session inUnitOfWorkDo: [:sess | sess deleteAll: salariedEmployees]].</body><body package="GlorpDBTests">testRollbackOneToManyAfterAdd	| customer t1 t2 transList amount |	customer := GlorpCustomer example1.	t1 := customer transactions first.	t2 := customer transactions last.	transList := customer transactions.	amount := t1 amount.	session beginUnitOfWork.	session register: customer.	20 timesRepeat: [customer addTransaction: (GlorpBankTransaction new)].	customer transactions first amount: 65543.	session rollbackUnitOfWork.	self assert: customer transactions == transList.	self assert: customer transactions size = 2.	self assert: customer transactions first == t1.	self assert: customer transactions last == t2.	self assert: t1 amount == amount.</body><body package="GlorpDBTests">testRollbackOneToManyAfterReplace	| customer t1 t2 transList |	customer := GlorpCustomer example1.	t1 := customer transactions first.	t2 := customer transactions last.	transList := customer transactions.	session beginUnitOfWork.	session register: customer.	customer transactions: OrderedCollection new.	session rollbackUnitOfWork.	self assert: customer transactions == transList.	self assert: customer transactions size = 2.	self assert: customer transactions first == t1.	self assert: customer transactions last == t2.</body><body package="GlorpDBTests">testRollbackOneToManyProxy	| customer t1 t2 transList |	customer := GlorpCustomer example1.	t1 := customer transactions first.	t2 := customer transactions last.	transList := customer transactions.	session beginUnitOfWork.	session register: customer.	customer transactions: OrderedCollection new.	session rollbackUnitOfWork.	self assert: customer transactions == transList.	self assert: customer transactions size = 2.	self assert: customer transactions first == t1.	self assert: customer transactions last == t2.</body><body package="GlorpDBTests">testRollbackOneToManyWithList	"Check that dependents aren't being registered for the collection"	| customer marker |	"Lists only exist in VW"	Dialect isVisualWorks ifFalse: [^self].	marker := Object new.	customer := GlorpCustomer example1.	customer transactions: (customer transactions asList).	customer transactions addDependent: marker.	session beginUnitOfWork.	session register: customer.	20 timesRepeat: [customer addTransaction: (GlorpBankTransaction new)].	session rollbackUnitOfWork.	self assert: customer transactions class == (Dialect smalltalkAt: #List).	self assert: customer transactions size = 2.	self should: [customer transactions privateAt: 3] raise: Object subscriptOutOfBoundsSignal.	self assert: (customer transactions dependents includes: marker).	self deny: (session isRegistered: marker).</body><body package="GlorpDBTests">testRollbackOneToOne	| transaction customer |	transaction := GlorpBankTransaction new.	customer := GlorpCustomer new.	transaction owner: customer.	session beginUnitOfWork.	session register: transaction.	transaction owner: GlorpCustomer new.	session rollbackUnitOfWork.	self assert: transaction owner == customer.</body><body package="GlorpDBTests">testRollbackOneToOneWithProxy	| transaction customerProxy |	transaction := self exampleTransactionWithCustomerProxy.	customerProxy := transaction owner.	session beginUnitOfWork.	session register: transaction.	transaction owner: GlorpCustomer new.	session rollbackUnitOfWork.	self assert: transaction owner == customerProxy</body><body package="GlorpDBTests">testWriteObjectWithNilCollection	| c1 query customer |	c1 := GlorpCustomer new.	c1 transactions: nil.	c1 id: 9999.	[session beginTransaction.	session beginUnitOfWork.	session register: c1.	session commitUnitOfWork.	query := Query readOneOf: GlorpCustomer where: [:each | each id = 9999].	query shouldRefresh: true.	customer := session execute: query.	self assert: customer transactions notNil.	self assert: customer transactions isEmpty.	]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>support</category><body package="GlorpDBTests">exampleCustomerProxy	| p |	p := Proxy new.	p session: session.	p query: (GlorpQueryStub readOneOf: GlorpCustomer where: [:a | a id = 3]).	p query result: (GlorpCustomer new id: 3).	^p</body><body package="GlorpDBTests">exampleCustomerWithTransactionsProxy	| customer |	customer := GlorpCustomer new.	customer transactions: self exampleTransactionsProxy.	^customer</body><body package="GlorpDBTests">exampleTransactionWithCustomerProxy	| transaction |	transaction := GlorpBankTransaction example1.	transaction owner: self exampleCustomerProxy.	^transaction</body><body package="GlorpDBTests">exampleTransactionsProxy	| p |	p := Proxy new.	p session: session.	p query: (GlorpQueryStub readOneOf: GlorpBankTransaction where: [:a | a id ~= 0]).	p query result: (Array with: GlorpBankTransaction example1 with: GlorpBankTransaction example1).	^p</body><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests">tearDown	super tearDown.	session reset.	session resetPermissions.	session := nil.</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>tests-registration</category><body package="GlorpDBTests">testPostRegister	| c1 t1 t2 |	c1 := GlorpCustomer example2.	[session beginTransaction.	session beginUnitOfWork.	t1 := GlorpBankTransaction new.	t2 := GlorpBankTransaction new.	c1 addTransaction: t1.	c1 addTransaction: t2.	session register: c1.	self assert: (session isRegistered: c1).	self assert: (session isRegistered: t1).	self assert: (session isRegistered: t2).	session commitUnitOfWork]		ensure: [session rollbackTransaction].	"Need some assertions on what was written"	self unfinished.</body><body package="GlorpDBTests">testPreRegister		| c1 t1 t2 trans |	c1 := GlorpCustomer example2.	[session beginTransaction.	session beginUnitOfWork.	session register: c1.	t1 := GlorpBankTransaction new.	t2 := GlorpBankTransaction new.	c1 addTransaction: t1.	c1 addTransaction: t2.	trans := session privateGetCurrentUnitOfWork privateGetTransaction.	session commitUnitOfWork.	self assert: (trans isRegistered: c1).	self assert: (trans isRegistered: t1).	self assert: (trans isRegistered: t2).]		ensure: [session rollbackTransaction].	"Need some assertions on what got written"	self unfinished.</body><body package="GlorpDBTests">testRegisterAll	| c1 c2 collection |	c1 := GlorpCustomer new.	c2 := GlorpCustomer new.	session beginUnitOfWork.	collection := Array with: c1 with: c2.	session registerAll: collection.	self assert: (session isRegistered: c1).	self assert: (session isRegistered: c2).	self deny: (session isRegistered: collection).</body><body package="GlorpDBTests">testRegisterCollection	| c1 c2 collection |	c1 := GlorpCustomer new.	c2 := GlorpCustomer new.	session beginUnitOfWork.	collection := Array with: c1 with: c2.	session register: collection.	self assert: (session isRegistered: c1).	self assert: (session isRegistered: collection).</body><body package="GlorpDBTests">testRegisterEmbeddedInTargetDontRefetch	" This tests for a problem with embedded objects suddenly becoming nil. This can happen when an object is part of a to-many relation. If the relation is followed during the registering phase the query will wrongly replace the embedded object even though requiresPopulating is false. When the object itself is already registered the replaced embedded object won't be registered."	| transactionId customer |		[session beginTransaction.	session inUnitOfWorkDo: 			[customer := GlorpCustomer example1.			customer id: 42.			session register: customer].	transactionId := customer transactions first id.	customer := nil.	session initializeCache.	session inUnitOfWorkDo: 			[| transaction amount |			transaction := session readOneOf: GlorpBankTransaction						where: [:each | each id = transactionId].			amount := transaction amount.			transaction owner transactions getValue.			self assert: amount == transaction amount]] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testRegisterExistingCollection	| c1 |	c1 := GlorpCustomer new.	session beginUnitOfWork.	session register: c1.	session register: c1 transactions.	self assert: (session isRegistered: c1).	self assert: (session isRegistered: c1 transactions).	self deny: (session isNew: c1 transactions).</body><body package="GlorpDBTests">testRegisterInstantiatedProxy	| p c |	p := self exampleCustomerProxy.	c := p getValue.	session beginUnitOfWork.	session register: p.	self assert: (session isRegistered: p).	self assert: (session isRegistered: c).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction isRegistered: p).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction isRegistered: c).</body><body package="GlorpDBTests">testRegisterObjectWithCollectionProxyThenInstantiate	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| customer transactions |	customer := self exampleCustomerWithTransactionsProxy.	session beginUnitOfWork.	session privateRegisterAsOld: customer.	self deny: customer transactions isInstantiated.	transactions := customer transactions getValue.	self assert: customer transactions isInstantiated.	session register: transactions.	self assert: (session isRegistered: transactions first).	self assert: (session isRegistered: customer).	self assert: (session isRegistered: transactions).	self assert: (session isRegistered: customer transactions).</body><body package="GlorpDBTests">testRegisterObjectWithInstantiatedProxy	| transaction customer |	transaction := self exampleTransactionWithCustomerProxy.	customer := transaction owner getValue.	session beginUnitOfWork.	session register: transaction.	self assert: (session isRegistered: transaction).	self assert: (session isRegistered: customer).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: transaction).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: customer).	self assert: transaction owner isInstantiated.</body><body package="GlorpDBTests">testRegisterObjectWithNilCollection	| c1 |	c1 := GlorpCustomer new.	c1 transactions: nil.	session beginUnitOfWork.	session register: c1.	self assert: (session isRegistered: c1).</body><body package="GlorpDBTests">testRegisterObjectWithProxy	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| transaction |	transaction := self exampleTransactionWithCustomerProxy.	session beginUnitOfWork.	session privateRegisterAsOld: transaction.	self assert: (session isRegistered: transaction).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: transaction).	self deny: transaction owner isInstantiated.</body><body package="GlorpDBTests">testRegisterObjectWithProxyThenInstantiate	"Note that we explicitly register the objects as being old (even though they aren't) so that we don't force instantation of the related objects, which is what we're trying to test."	| transaction customer |	transaction := self exampleTransactionWithCustomerProxy.	session beginUnitOfWork.	session privateRegisterAsOld: transaction.	self deny: transaction owner isInstantiated.	customer := transaction owner getValue.	session register: transaction.	self assert: (session isRegistered: transaction).	self assert: (session isRegistered: customer).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: transaction).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: customer).	self assert: transaction owner isInstantiated</body><body package="GlorpDBTests">testRegisterObjectWithProxyThenInstantiateAndReregister	| transaction customer |	transaction := self exampleTransactionWithCustomerProxy.	session beginUnitOfWork.	session register: transaction.	customer := transaction owner getValue.	session register: transaction.	self assert: (session isRegistered: transaction).	self assert: (session isRegistered: customer).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: transaction).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: customer).	self assert: transaction owner isInstantiated</body><body package="GlorpDBTests">testRegisterProxy	| p |	p := self exampleCustomerProxy.	session beginUnitOfWork.	session register: p.	self deny: (session isRegistered: p).	self deny: (session isRegistered: p query result).	p getValue.	self assert: (session isRegistered: p).	self assert: (session isRegistered: p query result).</body><body package="GlorpDBTests">testRegisterProxyThenInstantiateAndReregister	| p c |	p := self exampleCustomerProxy.	session beginUnitOfWork.	session register: p.	c := p getValue.	session register: p.	self assert: (session isRegistered: p).	self assert: (session isRegistered: c).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: p).	self assert: (session privateGetCurrentUnitOfWork privateGetTransaction 				isRegistered: c)</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>tests-transaction wrappers</category><body package="GlorpDBTests">testInTransactionDoSuccessful	"This has to test that a transaction completed successfully, so unlike most other tests, we have to clean up the evidence afterwards"	| result endResult |	[session inTransactionDo: [		session writeRow: session system exampleAddressRow].	result := session read: GlorpAddress.	self assert: result size = 1.	self assert: result first id = 123]		ensure: [session inTransactionDo: [session accessor executeSQLStringNoResult: 'DELETE FROM GR_ADDRESS']].	endResult := session read: GlorpAddress.	self assert: endResult size = 0.</body><body package="GlorpDBTests">testInTransactionDoUnsuccessful	| result initial|	initial := session read: GlorpAddress.	self assert: initial isEmpty.	[session inTransactionDo: [		session writeRow: session system exampleAddressRow.		self error: 'no you don''t']] on: Dialect error do: [:ex | ex return: nil].	result := session read: GlorpAddress.	self assert: result size = 0.</body><body package="GlorpDBTests">testTransactSuccessful	"This has to test that a transaction completed successfully, so unlike most other tests, we have to clean up the evidence afterwards"	| result |	[session transact: [		session register: (GlorpReservation new id: 345)].	result := session read: GlorpReservation.	self assert: result size = 1.	self assert: result first id = 345]		ensure: [session transact: [session accessor executeSQLStringNoResult: 'DELETE FROM RESERVATION']].</body><body package="GlorpDBTests">testTransactUnsuccessful	| result |	[session transact: [		session register: (GlorpReservation new id: 345).		self error: 'didn''t work']] on: Dialect error do: [:ex | ex return: nil].	result := session read: GlorpReservation.	self assert: result size = 0.</body><body package="GlorpDBTests">testinUnitOfWorkSuccessful	| result |	[session beginTransaction.	session inUnitOfWorkDo: [		session register: (GlorpReservation new id: 345)].	result := session read: GlorpReservation.	self assert: result size = 1.	self assert: result first id = 345]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testinUnitOfWorkUnsuccessful	| result |	[session beginTransaction.	[session inUnitOfWorkDo: [		session register: (GlorpReservation new id: 345).		self error: 'aaaagh']] on: Dialect error do: [:ex | ex return: nil].	result := session read: GlorpReservation.	self assert: result size = 0]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest</class-id> <category>tests-forcing update</category><body package="GlorpDBTests">testRegisteringAndForcingUpdate	"Test that we can force the first customer to be rewritten, even if it hasn't been modified by using the #forceSaveOf: call."	| customer triedToWrite row table map otherCustomer |	session beginTransaction.	customer := GlorpCustomer example1 id: 7.	otherCustomer := GlorpCustomer example2 id: 8.	session modify: (Array with: customer with: otherCustomer) in: [].	session accessor denyWrites.	session modify: customer in: [].	session beginUnitOfWork.	session register: otherCustomer.	session save: customer.	[session commitUnitOfWork] on: GlorpIllegalCommand do: [:ex |		triedToWrite := true.		table := session system tableNamed: 'GR_CUSTOMER'.		map := session privateGetCurrentUnitOfWork privateGetRowMap subMapForTable: table.		row := map at: map keys asArray first.		self assert: (row at: row fields first) = 7.		self assert: (row at: row fields last) = 'Fred Flintstone'.		self assert: map size = 1.	].	self assert: triedToWrite.	session rollbackTransaction.</body><body package="GlorpDBTests">testRegisteringAndForcingUpdateToDatabase	"Test going round trip to the database with forceSaveOf:. This doesn't assert much, but is mostly to make sure we aren't doing an insert instead of an update."	| customer otherCustomer |	session beginTransaction.	customer := GlorpCustomer example1 id: 7.	otherCustomer := GlorpCustomer example2 id: 8.	session modify: (Array with: customer with: otherCustomer) in: [].	session inUnitOfWorkDo: [		session register: otherCustomer.		session save: customer].	session rollbackTransaction.</body></methods><methods><class-id>Glorp.GlorpUnitOfWorkTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpConstantValueInRelationshipTest</class-id> <category>support</category><body package="GlorpDBTests">idsFor: aCollection	^(aCollection collect: [:each | each id]) asSortedCollection asArray.</body><body package="GlorpDBTests">sampleWorker	| worker job3 |	worker := GlorpWorker new.	worker id: 1234.	worker name: 'Some Worker'.	worker pendingJobs add: (GlorpJob new id: 1; description: 'job 1').	worker pendingJobs add: (GlorpJob new id: 2; description: 'job 2').	worker finishedJobs add: (job3 := GlorpJob new id: 3; description: 'job 3').	worker finishedJobs add: (GlorpJob new id: 4; description: 'job 4').	worker priorityJobs add: job3.	^worker.</body><body package="GlorpDBTests">setUp	system := GlorpWorkerDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database.	session := GlorpSessionResource current newSession.	session system: system.</body><body package="GlorpDBTests">writeTestData	session writeRow: system exampleWorkerRow.	session writeRow: (system exampleJobRow: 1 finished: false).	session writeRow: (system exampleJobRow: 2 finished: false).	session writeRow: (system exampleJobRow: 3 finished: true).	session writeRow: (system exampleJobRow: 4 finished: true).	session writeRow: system exampleLinkRow1.	session writeRow: system exampleLinkRow2.</body></methods><methods><class-id>Glorp.GlorpConstantValueInRelationshipTest</class-id> <category>tests</category><body package="GlorpDBTests">testRead	| worker |	[session beginTransaction.	self writeTestData.	worker := session execute: (Query readOneOf: GlorpWorker where: [:each | each id = 1234]).	self assert: (self idsFor: worker pendingJobs) = #(1 2).	self assert: (self idsFor: worker finishedJobs) = #(3 4).	self assert: (self idsFor: worker priorityJobs) = #(3).	] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testReadWithJoin	| worker |	[session beginTransaction.	self writeTestData.	worker := session		execute:			(Query readOneOf: GlorpWorker where: [:each | each pendingJobs id = 1]).	self assert: worker id = 1234] ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testWrite	| worker sampleWorker |	[session beginTransaction.	session beginUnitOfWork.	sampleWorker := self sampleWorker.	session register: sampleWorker.	session commitUnitOfWork.	session reset.	worker := session execute: (Query readOneOf: GlorpWorker where: [:each | each id = 1234]).	self assert: (self idsFor: worker pendingJobs) = #(1 2).	self assert: (self idsFor: worker finishedJobs) = #(3 4).	self assert: (self idsFor: worker priorityJobs) = #(3).	] ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpConstantValueInRelationshipTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpChar2Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform char width: 2</body></methods><methods><class-id>Glorp.GlorpChar2Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testChar2	stType := String.	self helpTestValue: nil.	self helpTestValue: '' compareWith: [:read :original |		self platform usesNullForEmptyStrings ifTrue: [read = nil] ifFalse: [read = original]].	self helpTestValue: 'a'.	self helpTestValue: 'ab'.	"These overlong-means-invalid checks fail on SQLite where column length limits are unenforced."	self should: [self helpTestInvalidValue: 'abc'] raise: GlorpDatabaseWriteError.	self should: [self helpTestInvalidValue: 'abcd'] raise: GlorpDatabaseWriteError.	self should: [self helpTestInvalidValue: 'abcde'] raise: GlorpDatabaseWriteError.		self assert: (type typeString asUppercase = (self platform char: 2) typeString asUppercase)</body><body package="GlorpDBTypeTests">testTrimmedChar2	| converter |	stType := String.	converter := type platform converterNamed: #stringToTrimmedString.	self assert: (converter convert:  'abc' toDatabaseRepresentationAs: type) = 'ab'.	self assert: (converter convert:  'abcd' toDatabaseRepresentationAs: type) = 'ab'.	self assert: (converter convert:  'abcde' toDatabaseRepresentationAs: type) = 'ab'.</body></methods><methods><class-id>Glorp.GlorpVarchar1Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform varchar: 1.</body></methods><methods><class-id>Glorp.GlorpVarchar1Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testBooleanToTFString	stType := Boolean.	self helpTestValue: nil.	self helpTestValue: true.	self helpTestValue: false.</body></methods><methods><class-id>Glorp.GlorpImageLink</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">image	^fullImage</body><body package="GlorpTestModels">image: anObject	fullImage := anObject</body><body package="GlorpTestModels">thumbnailBits	^thumbnailBits</body><body package="GlorpTestModels">thumbnailBits: anObject	thumbnailBits := anObject</body><body package="GlorpTestModels">title	^title</body><body package="GlorpTestModels">title: anObject	title := anObject</body></methods><methods><class-id>Glorp.GlorpTimeTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform time</body></methods><methods><class-id>Glorp.GlorpTimeTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">testTime	self helpTestValue: nil.	self		helpTestValue: Time now		compareWith:			[:read :original | 			(read hours = original hours and: [read minutes = original minutes])				and: [read seconds truncated = original seconds truncated]].</body></methods><methods><class-id>Glorp.GlorpInt2Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testBooleanToInteger	stType := Boolean.	self helpTestValue: nil.	self helpTestValue: true.	self helpTestValue: false.</body><body package="GlorpDBTypeTests">testInt2	self helpTestValue: nil.	self helpTestValue: 32123.</body></methods><methods><class-id>Glorp.GlorpInt2Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform int2.</body></methods><methods><class-id>Glorp.GlorpEmailAddress</class-id> <category>accessing</category><body package="GlorpTestModels">host	^host</body><body package="GlorpTestModels">host: anObject	host := anObject</body><body package="GlorpTestModels">id	^ id</body><body package="GlorpTestModels">id: anInteger	 id := anInteger.</body><body package="GlorpTestModels">user	^user</body><body package="GlorpTestModels">user: anObject	user := anObject</body></methods><methods><class-id>Glorp.GlorpEmailAddress</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: id printString.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpNumeric5Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform numeric scale: 5.</body></methods><methods><class-id>Glorp.GlorpNumeric5Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testNumeric5	| fixed |	self platform supportsVariableSizedNumerics ifFalse: [^self].	self helpTestFloat: nil.	self helpTestFloat: 12.	self helpTestFloat: 10991.	self helpTestFloat: (Dialect readFixedPointFrom: '3.0').	fixed := Dialect readFixedPointFrom: '321.12'.	self platform supportsDecimalsOnAllNumerics		ifTrue: [			self helpTestFloat: fixed.			self helpTestFloat: 3.14]		ifFalse: [			self helpTestInvalidValue: fixed.			self helpTestInvalidValue: 3.14].</body></methods><methods><class-id>Glorp.GlorpEncyclopedia</class-id> <category>accessing</category><body package="GlorpTestModels">articleAt: aString put: anEntry	entries at: aString put: anEntry.</body><body package="GlorpTestModels">biographicalEntries	^biographicalEntries</body><body package="GlorpTestModels">biographicalEntries: aDictionary	biographicalEntries := aDictionary</body><body package="GlorpTestModels">entries	^entries.</body><body package="GlorpTestModels">entries: aDictionary	entries := aDictionary</body><body package="GlorpTestModels">entriesByAuthor	^entriesByAuthor</body><body package="GlorpTestModels">entriesByAuthor: aDictionary	entriesByAuthor := aDictionary</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: aString	name := aString</body><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	name isNil ifFalse: [aStream nextPutAll: name].	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpEncyclopedia</class-id> <category>initialize</category><body package="GlorpTestModels">initialize	entries := Dictionary new.	biographicalEntries := Dictionary new.	entriesByAuthor := Dictionary new.</body></methods><methods><class-id>Glorp.GlorpEncyclopedia class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpEncyclopedia class</class-id> <category>examples</category><body package="GlorpTestModels">example1	| result |	result := self new.	result entries at: 'one' put: GlorpEncyclopediaEntry example1.	result entries at: 'two' put: GlorpEncyclopediaEntry example2.	^result.</body></methods><methods><class-id>Glorp.GlorpObjectWithNoAccessors</class-id> <category>accessing</category><body package="GlorpTestModels">extremelyPrivateValue: aString	alue := aString</body></methods><methods><class-id>Glorp.GlorpBasicTax class</class-id> <category>glorp</category><body package="GlorpTestModels">glorpSetupDescriptor: aDescriptor forSystem: aSystem	| table |	table := aSystem tableNamed: 'TAX'.	self glorpCommonSetupDescriptor: aDescriptor forSystem: aSystem.	(aSystem typeResolverFor: GlorpTax)		register: aDescriptor		keyedBy: 'T'		field: (table fieldNamed: 'TYPE').</body></methods><methods><class-id>Glorp.GlorpDictionaryDescriptorSystem</class-id> <category>classes</category><body package="GlorpTestModels">classModelForGlorpTaskedWorker: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #tasks collection: Dictionary of: GlorpWorkerTask</body><body package="GlorpTestModels">classModelForGlorpWorkerTask: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #description.</body></methods><methods><class-id>Glorp.GlorpDictionaryDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForGlorpTaskedWorker: aDescriptor	| workerTable linkTable |	workerTable := self tableNamed: 'GLORP_TASKED_WORKER'.	linkTable := self tableNamed: 'GLORP_TWO_WAY_LINK'.	aDescriptor table: workerTable.	aDescriptor 		addMapping: (DirectMapping from: #id to: (workerTable fieldNamed: 'ID')).	aDescriptor 		addMapping: (DirectMapping from: #name to: (workerTable fieldNamed: 'NAME')).	(aDescriptor newMapping: DictionaryMapping)				attributeName: #tasks;				referenceClass: GlorpWorkerTask;				keyField: (linkTable fieldNamed: 'KEY_COLUMN');				relevantLinkTableFields: (Array with: (linkTable fieldNamed: 'RIGHT_ID'))</body><body package="GlorpTestModels">descriptorForGlorpWorkerTask: aDescriptor	| taskTable |	taskTable := self tableNamed: 'GLORP_WORKER_TASK'.	aDescriptor table: taskTable.	(aDescriptor newMapping: DirectMapping) from: #id to: (taskTable fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #description to: (taskTable fieldNamed: 'DESCRIPTION').</body></methods><methods><class-id>Glorp.GlorpDictionaryDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForGLORP_TASKED_WORKER: aTable	| id |	id := aTable createFieldNamed: 'ID' type: platform int4.	id bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varchar: 30).</body><body package="GlorpTestModels">tableForGLORP_TWO_WAY_LINK: aTable	| leftId rightId |	leftId := aTable createFieldNamed: 'LEFT_ID' type: platform int4.	leftId bePrimaryKey.	rightId := aTable createFieldNamed: 'RIGHT_ID' type: platform int4.	rightId bePrimaryKey.	aTable addForeignKeyFrom: leftId to: ((self tableNamed: 'GLORP_TASKED_WORKER') fieldNamed: 'ID').	aTable addForeignKeyFrom: rightId to: ((self tableNamed: 'GLORP_WORKER_TASK') fieldNamed: 'ID').	aTable createFieldNamed: 'KEY_COLUMN' type: (platform varChar: 10).	aTable createFieldNamed: 'UNUSED_COLUMN' type: (platform varChar: 10).</body><body package="GlorpTestModels">tableForGLORP_WORKER_TASK: aTable	| id |	id := aTable createFieldNamed: 'ID' type: platform int4.	id bePrimaryKey.	aTable createFieldNamed: 'DESCRIPTION' type: (platform varchar: 30).</body></methods><methods><class-id>Glorp.GlorpDictionaryDescriptorSystem</class-id> <category>initialization</category><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpTaskedWorker;		add: GlorpWorkerTask;		yourself</body></methods><methods><class-id>Glorp.GlorpDictionaryDescriptorSystem</class-id> <category>accessing</category><body package="GlorpTestModels">allTableNames	^#('GLORP_TASKED_WORKER' 'GLORP_TWO_WAY_LINK' 'GLORP_WORKER_TASK')</body></methods><methods><class-id>Glorp.ClassExample</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">trace	^trace</body><body package="GlorpTestModels">trace: anObject	trace := anObject</body><body package="GlorpTestModels">value	^value</body><body package="GlorpTestModels">value: anObject	value := anObject</body></methods><methods><class-id>Glorp.ClassExample</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	id := nil.	trace := nil.	value := 'test'.</body></methods><methods><class-id>Glorp.ClassExample class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="GlorpTestModels">withValue: aValue	^(self new)		value: aValue;		yourself</body></methods><methods><class-id>Glorp.GlorpTaggableObject</class-id> <category>as yet unclassified</category><body package="GlorpTestModels">initialize	tags := OrderedCollection new.</body><body package="GlorpTestModels">tags	^ tags</body><body package="GlorpTestModels">tags: someTags	tags := someTags</body></methods><methods><class-id>Glorp.GlorpTaggableObject class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpPortrait</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger.</body><body package="GlorpTestModels">subjectFullName	^subjectFullName</body><body package="GlorpTestModels">subjectFullName: aString	subjectFullName := aString.</body></methods><methods><class-id>Glorp.GlorpDescriptorSystemWithNamespaces</class-id> <category>accessing</category><body package="GlorpTestModels">allTableNames	^#()</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpTestClassInNamespace;		yourself</body><body package="GlorpTestModels">descriptorForGlorpTestClassInNamespace: aDescriptor 	^aDescriptor</body></methods><methods><class-id>Glorp.GlorpPerishableItem</class-id> <category>accessing</category><body package="GlorpTestModels">age	^age</body><body package="GlorpTestModels">age: anObject	age := anObject</body></methods><methods><class-id>Glorp.GlorpPoultry</class-id> <category>accessing</category><body package="GlorpTestModels">featherColor	^featherColor</body><body package="GlorpTestModels">featherColor: anObject	featherColor := anObject</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>As yet unclassified</category><body package="GlorpTestModels">addInStorePurchase: aPurchase	inStorePurchases add: aPurchase.	aPurchase customer: self.</body><body package="GlorpTestModels">addOnlinePurchase: aPurchase	onlinePurchases add: aPurchase.	aPurchase customer: self.</body><body package="GlorpTestModels">addRental: aRental	inStoreRentals add: aRental.	aRental customer: self.</body><body package="GlorpTestModels">dateOfBirth	^dateOfBirth.</body><body package="GlorpTestModels">dateOfBirth: aDate	dateOfBirth := aDate.</body><body package="GlorpTestModels">name	^name.</body><body package="GlorpTestModels">name: aString	name := aString.</body><body package="GlorpTestModels">purchases	^inStorePurchases, onlinePurchases.</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>accessing</category><body package="GlorpTestModels">creditStatus	^creditStatus</body><body package="GlorpTestModels">creditStatus: aCreditStatus	creditStatus := aCreditStatus.	creditStatus isNil ifFalse: [creditStatus customer: self].</body><body package="GlorpTestModels">inStorePurchases	^inStorePurchases</body><body package="GlorpTestModels">inStorePurchases: anObject	inStorePurchases := anObject</body><body package="GlorpTestModels">inStoreRentals	^inStoreRentals.</body><body package="GlorpTestModels">onlinePurchases	^onlinePurchases</body><body package="GlorpTestModels">onlinePurchases: anObject	onlinePurchases := anObject</body><body package="GlorpTestModels">store: anObject	store := anObject</body><body package="GlorpTestModels">videoStore	^store</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	onlinePurchases := OrderedCollection new.	inStorePurchases :=OrderedCollection new.	inStoreRentals := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>testing</category><body package="GlorpTestModels">assertEqual: aCustomer	onlinePurchases assertEqual: aCustomer onlinePurchases.	inStorePurchases assertEqual: aCustomer inStorePurchases.	inStoreRentals assertEqual: aCustomer inStoreRentals.	creditStatus assertEqual: aCustomer creditStatus.	self assert: store id = aCustomer videoStore id.	self assert: name = aCustomer name.	self assert: dateOfBirth = aCustomer dateOfBirth.</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: (name isNil ifTrue: [''] ifFalse: [name]).	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpVideoCustomer</class-id> <category>comparing</category><body package="GlorpTestModels">&lt;= aVideoCustomer	^self name &lt; aVideoCustomer name	or: [self name = aVideoCustomer name		and: [self dateOfBirth &lt;= aVideoCustomer dateOfBirth]]</body></methods><methods><class-id>Glorp.GlorpVideoCustomer class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpLineWorker</class-id> <category>accessing</category><body package="GlorpTestModels">productionLine	^productionLine</body><body package="GlorpTestModels">productionLine: anObject	productionLine := anObject</body></methods><methods><class-id>Glorp.GlorpLineWorker</class-id> <category>comparing</category><body package="GlorpTestModels">= aLineWorker	^super = aLineWorker and: [productionLine = aLineWorker productionLine].</body></methods><methods><class-id>Glorp.GlorpContractor</class-id> <category>accessing</category><body package="GlorpTestModels">hourlyRate	^hourlyRate</body><body package="GlorpTestModels">hourlyRate: aGlorpMoney	hourlyRate := aGlorpMoney.</body></methods><methods><class-id>Glorp.GlorpCollectionTypesWithClassModelsDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpCollectionTypeModels">descriptorForGlorpThingWithLotsOfDifferentCollections: aDescriptor	| ocMapping |	aDescriptor table: self ownerTable.	(aDescriptor newMapping: DirectMapping)		from: #id to: (self ownerTable fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #name to: (self ownerTable fieldNamed: 'NAME').	(aDescriptor newMapping: OneToManyMapping)		attributeName: #array;		orderBy: [:each | (each getTable: self thingOneTable) getField: 'ARRAY_POSITION'];		writeTheOrderField;			join:				(Join					from: (self ownerTable fieldNamed: 'ID')					to: (self thingOneTable fieldNamed: 'ARRAY_OWNER')).	(aDescriptor newMapping: OneToManyMapping)		attributeName: #set;		join:			(Join				from: (self ownerTable fieldNamed: 'ID')				to: (self thingOneTable fieldNamed: 'SET_OWNER')).	ocMapping := (aDescriptor newMapping: ManyToManyMapping)		attributeName: #orderedCollection;		join:			(Join				from: (self ownerTable fieldNamed: 'ID')				to: (self linkTable fieldNamed: 'OWNER_ID')				from: 'O'				to: (self linkTable fieldNamed: 'TYPE')).	ocMapping orderBy: [:each | (each getTable: self linkTable) getField: 'POSITION'].	ocMapping writeTheOrderField.	(aDescriptor newMapping: ManyToManyMapping)		attributeName: #bag;		join:			(Join				from: (self ownerTable fieldNamed: 'ID')				to: (self linkTable fieldNamed: 'OWNER_ID')				from: 'B'				to: (self linkTable fieldNamed: 'TYPE')).	(aDescriptor newMapping: ManyToManyMapping)		attributeName: #sortedCollection;		join:			(Join				from: (self ownerTable fieldNamed: 'ID')				to: (self linkTable fieldNamed: 'OWNER_ID')				from: 'S'				to: (self linkTable fieldNamed: 'TYPE')).</body></methods><methods><class-id>Glorp.GlorpCollectionTypesWithClassModelsDescriptorSystem</class-id> <category>class models</category><body package="GlorpCollectionTypeModels">classModelForGlorpThingWithLotsOfDifferentCollections: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #array collection: Array of: GlorpThingOne.	aClassModel newAttributeNamed: #set collection: Set of: GlorpThingOne.	aClassModel newAttributeNamed: #orderedCollection collection: OrderedCollection of: GlorpThingOne.	aClassModel newAttributeNamed: #bag collection: Bag of: GlorpThingOne.	aClassModel newAttributeNamed: #sortedCollection collection: SortedCollection of: GlorpThingOne.</body></methods><methods><class-id>Glorp.GlorpGallery</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">images	^images</body><body package="GlorpTestModels">images: anObject	images := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpGallery</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	images := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpGallery class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpRowDifferencingTest</class-id> <category>tests</category><body package="GlorpDBTests">computeDifference	currentObjectRowMap := self generateRowMapFor: currentObject.	correspondenceMap := self correspond: currentObject to: mementoObject.	mementoObjectRowMap := self generateMementoRowMapFor: mementoObject withCorrespondenceMap: correspondenceMap.	differenceMap := currentObjectRowMap differenceFrom: mementoObjectRowMap.</body><body package="GlorpDBTests">testDifferenceFromAnotherObject	currentObject := GlorpPerson example1.	mementoObject := GlorpPerson example2.	self computeDifference.	self assert: differenceMap numberOfEntries = 2.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'GR_ADDRESS')) = 1</body><body package="GlorpDBTests">testDifferenceFromSameObjectWithAddedComponent"	Commenting these out because I think the setup is just wrong.currentObject := Person example1.	mementoObject := Person example1WithNoAddress.	self computeDifference.	self assert: differenceMap numberOfEntries = 2.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'GR_ADDRESS')) = 1"</body><body package="GlorpDBTests">testDifferenceFromSameObjectWithChangedAttribute	currentObject := GlorpPerson example1.	mementoObject := GlorpPerson example1WithDifferentName.	self computeDifference.	self assert: differenceMap numberOfEntries = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1</body><body package="GlorpDBTests">testDifferenceFromSameObjectWithChangedComponent	"Commenting these out because I think the setup is just wrong"	"currentObject := Person example1.	mementoObject := Person example1WithDifferentAddress.	currentObjectRowMap := self generateRowMapFor: currentObject."	"Before changes occur, all original objects are registered with the unit of work.  		To mimic that, the original person's address needs to be added to current (after changes) ""	self addRowsFor: mementoObject address to: currentObjectRowMap.	correspondenceMap := self correspond: currentObject to: mementoObject.	correspondenceMap at: mementoObject address put: mementoObject address.	correspondenceMap removeKey: currentObject address.	mementoObjectRowMap := self generateMementoRowMapFor: mementoObject withCorrespondenceMap: correspondenceMap.	differenceMap := currentObjectRowMap differenceFrom: mementoObjectRowMap.	self assert: differenceMap numberOfEntries = 2.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'GR_ADDRESS')) = 1"</body><body package="GlorpDBTests">testDifferenceFromSameObjectWithChangedComponentAttribute	currentObject := GlorpPerson example1.	mementoObject := GlorpPerson example1WithChangedAddress.	self computeDifference.	self assert: differenceMap numberOfEntries = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'GR_ADDRESS')) = 1</body><body package="GlorpDBTests">testDifferenceFromSameObjectWithDeletedComponent	"Commenting these out because I think the setup is just wrong""	currentObject := Person example1WithNoAddress.	mementoObject := Person example1.	self computeDifference.	self assert: differenceMap numberOfEntries = 1.	self 		assert: (differenceMap 				numberOfEntriesForTable: (system tableNamed: 'PERSON')) = 1"</body><body package="GlorpDBTests">testEquality	| addressRow1 addressRow2 |	addressRow1 := session system exampleAddressRow.	addressRow2 := session system exampleAddressRowWithDifferentStreet.	self assert: (addressRow1 equals: addressRow1).	self assert: (addressRow1 equals: addressRow2) not.</body><body package="GlorpDBTests">testNoDifference2	| |	currentObject := GlorpPerson example1.	mementoObject := GlorpPerson example1.	self computeDifference.	self assert: differenceMap numberOfEntries = 0.</body></methods><methods><class-id>Glorp.GlorpRowDifferencingTest</class-id> <category>support</category><body package="GlorpDBTests">addRowsFor: object to: rowMap 	| descriptor |	descriptor := system descriptorFor: object class.	descriptor createRowsFor: object in: rowMap.</body><body package="GlorpDBTests">correspond: person1 to: person2 	| correspondanceMap |	correspondanceMap := IdentityDictionary new.	correspondanceMap at: person1 put: person2.	person1 address notNil ifTrue: 		[correspondanceMap at: person1 address put: person2 address.		"Now fix it up so this actually looks like a real memento"		person2 address: person1 address].	^correspondanceMap</body><body package="GlorpDBTests">generateMementoRowMapFor: person withCorrespondenceMap: aDictionary	| rowMap |	rowMap := RowMapForMementos withCorrespondenceMap: aDictionary.	self addRowsFor: person to: rowMap.	(person address notNil and: [(aDictionary at: person address ifAbsent: [nil]) notNil]) ifTrue: [self addRowsFor: (aDictionary at: person address) to: rowMap].	^rowMap</body><body package="GlorpDBTests">generateRowMapFor: person 	| rowMap |	rowMap := RowMap new.	self addRowsFor: person to: rowMap.	person address notNil ifTrue: [self addRowsFor: person address to: rowMap].	^rowMap</body><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	system := session system.	session beginUnitOfWork.</body></methods><methods><class-id>Glorp.GlorpServiceCharge</class-id> <category>accessing</category><body package="GlorpTestModels">amount	^amount</body><body package="GlorpTestModels">amount: anObject	amount := anObject</body><body package="GlorpTestModels">description	^description</body><body package="GlorpTestModels">description: anObject	description := anObject</body></methods><methods><class-id>Glorp.GlorpServiceCharge</class-id> <category>initialize</category><body package="GlorpTestModels">initialize</body></methods><methods><class-id>Glorp.GlorpServiceCharge class</class-id> <category>instance creation</category><body package="GlorpTestModels">default	^self new		amount: (GlorpMoney forAmount: 3);		description: 'additional overcharge'.</body><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpOwner</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id.</body><body package="GlorpTestModels">id: anObject	id := anObject.</body><body package="GlorpTestModels">slave	^slave.</body><body package="GlorpTestModels">slave: anObject	slave := anObject.</body><body package="GlorpTestModels">slaves	^slaves.</body><body package="GlorpTestModels">slaves: anObject	slaves := anObject.</body></methods><methods><class-id>Glorp.GlorpUser</class-id> <category>accessing</category><body package="GlorpTestModels">folders	^folders</body><body package="GlorpTestModels">folders: aCollection	folders := aCollection</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger</body><body package="GlorpTestModels">name	^name.</body><body package="GlorpTestModels">name: aString	name := aString.</body></methods><methods><class-id>Glorp.GlorpUser</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	id := nil.	folders := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpUser class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpWorkerTask</class-id> <category>accessing</category><body package="GlorpTestModels">description	^description</body><body package="GlorpTestModels">description: anObject	description := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body></methods><methods><class-id>Glorp.GlorpWorkerTask</class-id> <category>comparing</category><body package="GlorpTestModels">= aTask	self id = aTask id ifFalse: [^false].	self description = aTask description ifFalse: [^false].	^true</body><body package="GlorpTestModels">&gt; aTask	^self id &gt; aTask id</body></methods><methods><class-id>Glorp.GlorpWorkerTask</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream		nextPut: $(;		nextPutAll: id printString;		nextPutAll: ', ';		nextPutAll: (description ifNil: [description printString]);		nextPut: $);		cr</body></methods><methods><class-id>Glorp.GlorpWorkerTask class</class-id> <category>examples</category><body package="GlorpTestModels">exampleTaskKeys	| keys |	keys := OrderedCollection new.	keys add: 'Clean'.	keys add: 'Yard'.	keys add: 'Shop'.	keys add: 'Errands'.	keys add: 'Relax'.	^keys</body><body package="GlorpTestModels">exampleTasks	| tasks |	tasks := OrderedCollection new.	tasks add: (GlorpWorkerTask new id: 1; description: 'Clean house'; yourself).	tasks add: (GlorpWorkerTask new id: 2; description: 'Trim hedges  and mow lawn'; yourself).	tasks add: (GlorpWorkerTask new id: 3; description: 'Grocery shopping'; yourself).	tasks add: (GlorpWorkerTask new id: 4; description: 'Run errands'; yourself).	tasks add: (GlorpWorkerTask new id: 5; description: 'Take a break'; yourself).	^tasks</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry</class-id> <category>accessing</category><body package="GlorpTestModels">&lt;= aGlorpEncyclopediaEntry	^self title &lt;= aGlorpEncyclopediaEntry title.</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: aSmallInteger 	id := aSmallInteger.</body><body package="GlorpTestModels">mediaType	^mediaType</body><body package="GlorpTestModels">mediaType: anObject	mediaType := anObject</body><body package="GlorpTestModels">text	^text</body><body package="GlorpTestModels">text: aString 	text := aString.</body><body package="GlorpTestModels">title	^title</body><body package="GlorpTestModels">title: aString 	title := aString</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	title isNil ifFalse: [aStream nextPutAll: title].	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	mediaType := GlorpMediaType text</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		id: 1;		name: 'One';		text: 'The first number (not counting zero)'.</body><body package="GlorpTestModels">example2	^self new		id: 2;		name: 'Two';		text: 'The second number (comes after 1)'.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaEntry class</class-id> <category>initialize-release</category><body package="GlorpTestModels">new	^super new initialize</body></methods><methods><class-id>Glorp.GlorpThingWithLotsOfDifferentCollections</class-id> <category>accessing</category><body package="GlorpCollectionTypeModels">array	^array</body><body package="GlorpCollectionTypeModels">array: anObject	array := anObject</body><body package="GlorpCollectionTypeModels">bag	^bag</body><body package="GlorpCollectionTypeModels">bag: anObject	bag := anObject</body><body package="GlorpCollectionTypeModels">id	^id</body><body package="GlorpCollectionTypeModels">id: anObject	id := anObject</body><body package="GlorpCollectionTypeModels">name	^name</body><body package="GlorpCollectionTypeModels">name: anObject	name := anObject</body><body package="GlorpCollectionTypeModels">orderedCollection	^orderedCollection</body><body package="GlorpCollectionTypeModels">orderedCollection: anObject	orderedCollection := anObject</body><body package="GlorpCollectionTypeModels">set	^set</body><body package="GlorpCollectionTypeModels">set: anObject	set := anObject</body><body package="GlorpCollectionTypeModels">sortedCollection	^sortedCollection</body><body package="GlorpCollectionTypeModels">sortedCollection: anObject	sortedCollection := anObject</body></methods><methods><class-id>Glorp.GlorpThingWithLotsOfDifferentCollections</class-id> <category>initialize-release</category><body package="GlorpCollectionTypeModels"> initialize	array := #().	orderedCollection := OrderedCollection new.	set := Set new.	bag := Bag new.	sortedCollection := #() asSortedCollection.</body></methods><methods><class-id>Glorp.GlorpThingWithLotsOfDifferentCollections class</class-id> <category>instance creation</category><body package="GlorpCollectionTypeModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpThingWithLotsOfDifferentCollections class</class-id> <category>examples</category><body package="GlorpCollectionTypeModels">example1	| example array |	example := self new.	example name: 'fred'.	array := Array with: (GlorpThingOne named: 'array1') with: (GlorpThingOne named: 'array2') with: (GlorpThingOne named: 'array3').	example array: array.	example set add: (GlorpThingOne named: 'set1').	example set add: (GlorpThingOne named: 'set2').		example orderedCollection add: (GlorpThingOne named: 'orderedCollection1').	example orderedCollection add: (GlorpThingOne named: 'orderedCollection2').	example bag add: (GlorpThingOne named: 'bag1').	example bag add: (GlorpThingOne named: 'bag2').	example sortedCollection add: (GlorpThingOne named: 'sorted1').	example sortedCollection add: (GlorpThingOne named: 'sorted2').	example sortedCollection add: (GlorpThingOne named: 'sorted3').	example sortedCollection add: (GlorpThingOne named: 'sorted4').	^example.</body><body package="GlorpCollectionTypeModels">exampleForOrdering	| example |	example := self new.	example name: 'order'.	example orderedCollection add: (GlorpThingOne named: 'oc6').	example orderedCollection add: (GlorpThingOne named: 'oc5').	example orderedCollection add: (GlorpThingOne named: 'oc4').	example orderedCollection add: (GlorpThingOne named: 'oc3').	example orderedCollection add: (GlorpThingOne named: 'oc7').	example orderedCollection add: (GlorpThingOne named: 'oc8').	example array: (#('a1' 'a2' 'a3' 'a9' 'a8' 'a7') collect: [:each | GlorpThingOne named: each]).	^example</body></methods><methods><class-id>Glorp.GlorpThingOne</class-id> <category>accessing</category><body package="GlorpCollectionTypeModels">id	^id</body><body package="GlorpCollectionTypeModels">id: anInteger	id := anInteger</body><body package="GlorpCollectionTypeModels">name	^name</body><body package="GlorpCollectionTypeModels">name: aString	name := aString</body></methods><methods><class-id>Glorp.GlorpThingOne</class-id> <category>comparing</category><body package="GlorpCollectionTypeModels">&lt;= aThingOne	^self name &lt;= aThingOne name.</body></methods><methods><class-id>Glorp.GlorpThingOne class</class-id> <category>instance creation</category><body package="GlorpCollectionTypeModels">named: aString	^self new name: aString.</body></methods><methods><class-id>Glorp.GlorpTimedProxyReaperTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, ' for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding ', self class name, ' for ObjectStudio'. ^self].	reaper := TimedProxyReaper new.	reaper delay: 0.5.</body><body package="GlorpDBTests">tearDown	reaper release.	reaper := nil.</body></methods><methods><class-id>Glorp.GlorpTimedProxyReaperTest</class-id> <category>tests</category><body package="GlorpDBTests">README	"Unfortunately, these tests are timing sensitive. They may intermittently fail, when in fact they are working as advertised.	Rerun failed tests individually. If a test consistently fails, then it likely indicates a bug."</body><body package="GlorpDBTests">testAddObjects	| proxies |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testAddObjects for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testAddObjects for ObjectStudio'. ^self].	proxies := OrderedCollection new.	1 to: 10 do: [:index | 		proxies add: (TimedProxy readOneOf: Object where: nil in: nil).		proxies last glorpSecondsToLive: 1000.		reaper add: proxies last].	(Delay forSeconds: 1) wait.	proxies do: [:proxy | self should: [reaper includes: proxy]].</body><body package="GlorpDBTests">testExpireObjects	| proxies |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testExpireObjects for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding t', self class name, '&gt;&gt;estExpireObjects for ObjectStudio'. ^self].	proxies := OrderedCollection new.	1 to: 10 do: [:index | 		proxies add: (TimedProxy readOneOf: Object where: nil in: nil).		proxies last glorpSecondsToLive: 1.		reaper add: proxies last].	(Delay forSeconds: 5) wait.	proxies do: [:proxy | self shouldnt: [reaper includes: proxy]].</body><body package="GlorpDBTests">testTouchAndExpireObjectsWhileOtherObjectsAreBeingReaped	| expiringProxy proxy |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testTouchAndExpireObjectsWhileOtherObjectsAreBeingReaped for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testTouchAndExpireObjectsWhileOtherObjectsAreBeingReaped for ObjectStudio'. ^self].	reaper delay: 0.25.	expiringProxy := TimedProxy readOneOf: Object where: nil in: nil.	expiringProxy glorpSecondsToLive: 1.	proxy := TimedProxy readOneOf: Object where: nil in: nil.	proxy glorpSecondsToLive: 2.	reaper add: proxy; add: expiringProxy.	self assert: (reaper includes: proxy).	self assert: (reaper includes: expiringProxy).	(Delay forSeconds: 1) wait.	proxy glorpTouch.	(Delay forSeconds: 1.5) wait.	self assert: (reaper includes: proxy).	self deny: (reaper includes: expiringProxy).	(Delay forSeconds: 2) wait.	self deny: (reaper includes: proxy).</body><body package="GlorpDBTests">testTouchObjects	| proxy |	Dialect isVisualAge ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testTouchObjects for VisualAge'. ^self].	Dialect isObjectStudio ifTrue: [Transcript cr; show: 'Avoiding ', self class name, '&gt;&gt;testTouchObjects for ObjectStudio'. ^self].	reaper delay: 0.25.	proxy := TimedProxy readOneOf: Object where: nil in: nil.	proxy glorpSecondsToLive: 2.	reaper add: proxy.	(Delay forSeconds: 1) wait.	proxy glorpTouch.	(Delay forSeconds: 1.1) wait.	self should: [reaper includes: proxy].	(Delay forSeconds: 2) wait.	self shouldnt: [reaper includes: proxy]</body></methods><methods><class-id>Glorp.GlorpAttributeModelTest</class-id> <category>tests</category><body package="GlorpTests">testDictionaryTypes	| attributeModel obj classModel dict model |	dict := Dictionary new at: #one put: 'two'; yourself.	obj := 1@dict.	classModel := GlorpClassModel for: Point.	attributeModel := classModel newAttributeNamed: #y dictionaryFrom: Symbol to: String.	model := classModel attributeNamed: #y.	self assert: model == attributeModel.	self assert: model keyType == Symbol.	self assert: model type == String.	self assert: dict == (attributeModel getValueFrom: obj).	attributeModel setValueIn: obj to: nil.	self assert: nil == (attributeModel getValueFrom: obj).</body><body package="GlorpTests">testGetSetAssociation	| attributeModel obj classModel |	obj := nil-&gt;2.	classModel := GlorpClassModel for: Association.	attributeModel := classModel newAttributeNamed: #value.	attributeModel useDirectAccess: true.	self assert: 2 == (attributeModel getValueFrom: obj).	attributeModel setValueIn: obj to: 3.	self assert: 3 == (attributeModel getValueFrom: obj).	attributeModel useDirectAccess: false.	self assert: 3 == (attributeModel getValueFrom: obj).	attributeModel setValueIn: obj to: 2.	self assert: 2 == (attributeModel getValueFrom: obj).</body><body package="GlorpTests">testGetSetObject	| attributeModel obj classModel |	obj := (GlorpObjectWithNoAccessors new)								extremelyPrivateValue: 'Glorp';								yourself.	classModel := GlorpClassModel for: GlorpObjectWithNoAccessors.	attributeModel := classModel newAttributeNamed: #alue.	attributeModel useDirectAccess: true.	self assert: 'Glorp' = (attributeModel getValueFrom: obj).	attributeModel setValueIn: obj to: 'GLORP'.	self assert: 'GLORP' = (attributeModel getValueFrom: obj).	attributeModel useDirectAccess: false.	self should: [attributeModel getValueFrom: obj] raise: Dialect error.	self should: [attributeModel setValueIn: obj to: 'Glorp'] raise: Dialect error.</body><body package="GlorpTests">testPreserveAttributes	| attributeModel classModel descriptor mapping table field system |	system := DynamicDescriptorSystem new.	classModel := system addClassModelFor: Association.	attributeModel := classModel newAttributeNamed: #key.	descriptor := Descriptor new.	descriptor classModel: classModel.	table := DatabaseTable named: 'FRED'.	field := table createFieldNamed: 'BARNEY' type: OraclePlatform new int4.	mapping := DirectMapping from: #key type: Object to: field.	self assert: mapping attribute useDirectAccess.	self assert: attributeModel useDirectAccess.	mapping attribute useDirectAccess: false.	self assert: mapping attribute type == Object.	descriptor addMapping: mapping.	self assert: mapping attribute == attributeModel.	self assert: attributeModel type == Object.	self deny: attributeModel useDirectAccess.</body></methods><methods><class-id>Glorp.GlorpRowMapForMementosTest</class-id> <category>tests</category><body package="GlorpTests">testAdjustMultipleRowMapKey	| rowMapKey adjustedKey  |	rowMapKey := MultipleRowMapKey with: a1 with: b1 with: c1.	adjustedKey := rowMapKey adjustIn: rowMap correspondenceMap.	self assert: (adjustedKey keys includes: a2).	self assert: (adjustedKey keys includes: b2).	self assert: (adjustedKey keys includes: c2).</body><body package="GlorpTests">testAdjustRowMapKey	| rowMapKey adjustedKey  |	rowMapKey := RowMapKey new.	rowMapKey key1: a1; key2: b1.	adjustedKey := rowMapKey adjustIn: rowMap correspondenceMap.	self assert: (adjustedKey key1 == a2).	self assert: (adjustedKey key2 == b2).</body><body package="GlorpTests">testReverseAdjustMultipleRowMapKey	| rowMapKey adjustedKey  |	rowMapKey := MultipleRowMapKey with: a2 with: b2 with: c2.	adjustedKey := rowMapKey reverseAdjustIn: rowMap.	self assert: (adjustedKey keys includes: a1).	self assert: (adjustedKey keys includes: b1).	self assert: (adjustedKey keys includes: c1).</body><body package="GlorpTests">testReverseAdjustRowMapKey	| rowMapKey adjustedKey  |	rowMapKey := RowMapKey new.	rowMapKey key1: a2; key2: b2.	adjustedKey := rowMapKey reverseAdjustIn: rowMap.	self assert: (adjustedKey key1 == a1).	self assert: (adjustedKey key2 == b1).</body><body package="GlorpTests">testRowForTableMultiple	| rowMapKey row |	rowMapKey := MultipleRowMapKey with: a1 with: b1 with: c1.	row := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row1 := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row2 := rowMap rowForTable: table1 withKey: rowMapKey.	self assert: row == row1.	self assert: row == row2.</body><body package="GlorpTests">testRowForTableSingle	| rowMapKey row |	rowMapKey := RowMapKey new.	rowMapKey key1: a1; key2: b1.	row := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row1 := rowMap findOrAddRowForTable: table1 withKey: rowMapKey.	row2 := rowMap rowForTable: table1 withKey: rowMapKey.	self assert: row == row1.	self assert: row == row2.</body></methods><methods><class-id>Glorp.GlorpRowMapForMementosTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	a1 := IdentityHashPrintingObject new.	b1 := IdentityHashPrintingObject new.	c1 := IdentityHashPrintingObject new.	transaction := ObjectTransaction new.	transaction register: a1.	transaction register: b1.	transaction register: c1.	a2 := transaction undoMap at: a1.	b2 := transaction undoMap at: b1.	c2 := transaction undoMap at: c1.	rowMap := RowMapForMementos withCorrespondenceMap: transaction undoMap.	table1 := DatabaseTable new.	row1 := 'row1'.	row2 := 'row2'.</body></methods><methods><class-id>Glorp.GlorpObjectTransactionTest</class-id> <category>support</category><body package="GlorpTests">setUp	transaction := ObjectTransaction new</body></methods><methods><class-id>Glorp.GlorpObjectTransactionTest</class-id> <category>tests</category><body package="GlorpTests">testArray	| object |	object := #(1 2 3 4 5) copy.	transaction begin.	transaction register: object.	object		at: 1 put: #one;		at: 2 put: object.	transaction abort.	self		assert: (object at: 1) == 1;		assert: (object at: 2) == 2</body><body package="GlorpTests">testBecome	| object |	object := 'hello' copy.	transaction begin.	transaction register: object.	object become: Set new.	transaction abort.	self 		assert: object class == '' class;		assert: object = 'hello'.</body><body package="GlorpTests">testCommit	| array |	array := #(1 2 3 4 5) copy.	transaction begin.	transaction register: array.	array		at: 1 put: #one;		at: 2 put: array.	transaction commit.	self		assert: (array at: 1) == #one;		assert: (array at: 2) == array</body><body package="GlorpTests">testHashedCollection	| object originalMembers |	object := Set new.	originalMembers := #(#one #two #three 'four' 5 'vi' (1 2 3 4 5 6 7)) collect: [:each | each copy].	object addAll: originalMembers.	transaction begin.	transaction register: object.	object remove: #one; remove: (originalMembers at: 4).	object add: 1.	originalMembers last at: 7 put: 'seven'.	transaction abort.	self		assert: object size = originalMembers size;		assert: (object includes: originalMembers first);		assert: (object includes: (originalMembers at: 4));		assert: object size = (object rehash; size).	originalMembers do: [:each | self assert: (object includes: each)]</body><body package="GlorpTests">testRegisteredObjectsDoRecursively	| link |	link := 1 -&gt; (2 -&gt; (3 -&gt; (4 -&gt;5))).	transaction register: link.	self assert: transaction undoMap size = 1.	transaction registeredObjectsDo: [:each |		transaction register: each value].	self assert: transaction undoMap size = 4.</body><body package="GlorpTests">testString	| object |	object := 'Hello, World!' copy.	transaction begin.	transaction register: object.	object		at: 1 put: $h;		at: 2 put: $E.	transaction abort.	self		assert: object first  == $H;		assert: (object at: 2) == $e</body></methods><methods><class-id>Glorp.GlorpDialectTest</class-id> <category>tests</category><body package="GlorpTests">testBlockArgumentCount	self assert: (Dialect argumentCountFor: [3]) = 0.	self assert: (Dialect argumentCountFor: [:a | 3]) = 1.	self assert: (Dialect argumentCountFor: [:a :b | a &lt;= b]) = 2.</body><body package="GlorpTests">testClassImportLookup	self		assert: (Dialect					lookupClassNamed: 'AccessCast'					inContextOf: GlorpDescriptorSystemWithNamespaces					ifAbsent: [nil]) == AccessCast		description: 'We cannot find a class visible in the environment of this class, not imported'.	self		assert: (Dialect					lookupClassNamed: 'GlorpTestClassInNamespace'					inContextOf: GlorpDescriptorSystemWithNamespaces					ifAbsent: [nil]) == GlorpTestClassInNamespace		description: 'We cannot find a class imported by the class but not visible in its environment'.</body><body package="GlorpTests">testTimeSetMillisecond	| time oldMs oldSec oldMin newMs |	Dialect supportsMillisecondsInTimes ifFalse: [^self].	time := Time now.	oldMs := time milliseconds.	oldSec := time seconds truncated.	oldMin := time minutes.	newMs := oldMs &gt; 989 ifTrue: [3] ifFalse: [oldMs + 10].	time millisecond: newMs.	self assert: time milliseconds = newMs.	self assert: time seconds truncated = oldSec.	self assert: time minutes = oldMin.</body><body package="GlorpTests">testTokensBasedOn	self assert: (Dialect tokensBasedOn: '.' in: 'abc.def.ghi') asArray = #('abc' 'def' 'ghi').</body></methods><methods><class-id>Glorp.GlorpCoreExtensionsTest</class-id> <category>tests</category><body package="GlorpTests">testGlorpIsCollection	self deny: Object new glorpIsCollection.	self assert: Collection new glorpIsCollection</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionDBTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	session := GlorpSessionResource current newSession.	session beginTransaction.	self writePersonRows.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests">writePersonRows	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.	session writeRow: session system examplePersonRowForOrdering3.</body></methods><methods><class-id>Glorp.GlorpCursoredCollectionDBTest</class-id> <category>tests</category><body package="GlorpDBTests">testParallelStreams	"Passes on Oracle, DB2, SQLite and (now) on PostgresSocket.  (Skipped silently on SQLServer and PostgresLibpq which do not support multiple open cursors.)"	| query1 person query2 stream1 stream2 address person2 address2 |	session platform supportsMultipleOpenCursors ifFalse: [^self].	query1 := Query read: GlorpPerson.	query1 orderBy: [:each | each id].	query1 collectionType: GlorpCursoredStream.	query2 := Query read: GlorpAddress.	query2 orderBy: [:each | each id].	query2 collectionType: GlorpCursoredStream.	stream1 := session execute: query1.	self assert: session privateGetCache numberOfElements = 0.	stream2 := session execute: query2.	person := stream1 next.	self assert: session privateGetCache numberOfElements = 1.	self assert: person id = 86.	address := stream2 next.	self assert: address id = 1.	self assert: address street = 'Alpha'.	self assert: session privateGetCache numberOfElements = 2.	person2 := stream1 next.	address2 := stream2 next.	self assert: person2 class == GlorpPerson.	self assert: address2 class == GlorpAddress.	self assert: address2 street = 'Beta'."SQLite allows multiple processes to have the database file open at once, and multiple processes can read the database at once.  Thus we let that platform return true to #supportsMultipleOpenCursors.  When a process wants to write, it must lock the entire database file for the duration of its update (normally a few milliseconds, during which other processes wait on the writer to finish, then continue).  However this database locking is therefore dependent on the OS file-system and can show issues.  This test, after passing all its assertions, has been seen to fail in tearDown's rollback of the transaction due to 'database is locked'.  The presumption is that both cursors rollback and so appear like competing writes even though neither is really.   Releasing the cursors ends contention and lets the rollback succeed."	session platform class == SQLite3Platform ifTrue:		[stream1 release. stream1 := nil.		stream2 release. stream2 := nil].</body><body package="GlorpDBTests">testReadAsStream	| query stream person restOfPeople |	query := Query read: GlorpPerson.	query orderBy: [:each | each id].	query collectionType: GlorpCursoredStream.	stream := session execute: query.	self assert: session privateGetCache numberOfElements = 0.	person := stream next.	self assert: session privateGetCache numberOfElements = 1.	self assert: person id = 86.	restOfPeople := stream upToEnd.	self assert: restOfPeople size = 2.	self assert: session privateGetCache numberOfElements = 3.</body><body package="GlorpDBTests">testReadEmptyStream	| query stream person |	query := Query read: GlorpPerson where: [:each | each id = 999].	query collectionType: GlorpCursoredStream.	stream := session execute: query.	self assert: session privateGetCache numberOfElements = 0.	person := stream next.	self assert: session privateGetCache numberOfElements = 0.	self assert: person isNil.	self assert: stream atEnd.</body><body package="GlorpDBTests">testReadLiteralEmptyStream	| query stream person |	query := Query read: GlorpPerson where: false.	query collectionType: GlorpCursoredStream.	stream := session execute: query.	self assert: session privateGetCache numberOfElements = 0.	person := stream next.	self assert: session privateGetCache numberOfElements = 0.	self assert: person isNil.	self assert: stream atEnd.</body></methods><methods><class-id>Glorp.GlorpSelectCommandTest</class-id> <category>tests</category><body package="GlorpDBTests">testExecute	| command dict result string |	dict := #('abc' 'Smalltalk').	string := session useBinding		ifTrue: ['SELECT ID FROM STUFF WHERE THING=? OR THING = ?']		ifFalse:			['SELECT ID FROM STUFF WHERE THING=''abc'' OR THING = ''Smalltalk'''].	command := SQLStringSelectCommand		sqlString: string		parameters: dict		useBinding: session useBinding		session: session.	result := session accessor executeCommand: command.	self assert: result size = 2.	self assert: result first first = 12.	self assert: result last first = 113141.</body></methods><methods><class-id>Glorp.ClassL</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassL	^attrAClassL</body><body package="GlorpTestModels">attrAClassL: anObject	attrAClassL := anObject</body><body package="GlorpTestModels">attrBClassL	^attrBClassL</body><body package="GlorpTestModels">attrBClassL: anObject	attrBClassL := anObject</body><body package="GlorpTestModels">attrCClassL	^attrCClassL</body><body package="GlorpTestModels">attrCClassL: anObject	attrCClassL := anObject</body><body package="GlorpTestModels">attrDClassL	^attrDClassL</body><body package="GlorpTestModels">attrDClassL: anObject	attrDClassL := anObject</body></methods><methods><class-id>Glorp.GlorpGettingPrimaryKeyFromMappingTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	system := GlorpDocumentDescriptorSystem forPlatform: system platform.	session system: system.	session beginTransaction.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpGettingPrimaryKeyFromMappingTest</class-id> <category>tests</category><body package="GlorpDBTests">createData	"Create seed data"	| doc attb att |	doc := GlorpDocument new initialize.	attb := GlorpAttachmentBytes new content: 'Hello, Alan'.	att := (GlorpAttachment new)				index: 1;				mimeType: 'text/plain';				attachmentBytes: attb.	session modify: doc in: [doc attachments add: att].</body><body package="GlorpDBTests">testUnchangedInUnitOfWork 	| doc |	self createData.	session reset.	doc := session readOneOf: GlorpDocument.	"Something changed? Should not."	session modify: doc in: [].	doc := nil.	session reset.	doc := session readOneOf: GlorpDocument.	self assert: doc attachments size = 1.	doc attachments do: 			[:each | 			self assert: each attachmentBytes content yourSelf notNil].	"The bug would cause this to write out the attachment over again, generating a primary key constraint error. Just in case that doesn't catch it, do a count"	session accessor permitNothingDuring: [		session modify: doc in: []].	self assert: (session count: GlorpDocument) = 1.	self assert: (session count: GlorpAttachment) = 1.	self assert: (session count: GlorpAttachmentBytes) = 1.	self assert: doc id notNil.	((session accessor executeSQLString: 'SELECT * FROM attachment') first do: [:each | self assert: each notNil]).	((session accessor executeSQLString: 'SELECT * FROM attachmentbytes') first do: [:each | self assert: each notNil])</body></methods><methods><class-id>Glorp.GlorpItinerary</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">reservation	^reservation</body><body package="GlorpTestModels">reservation: anObject	reservation := anObject</body></methods><methods><class-id>Glorp.GlorpItinerary class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		reservation: GlorpReservation example1.</body><body package="GlorpTestModels">example2	^self new		reservation: GlorpReservation example2.</body></methods><methods><class-id>Glorp.GlorpCompositeKeyTest</class-id> <category>tests- basic reading</category><body package="GlorpDBTests">testAlsoFetchToManyRead	| users query |	query := Query read: GlorpUser where: [:each | each folders sqlCount = 2].	query alsoFetch: #folders.	users := session execute: query.	self deny: users isEmpty.	self deny: (users anySatisfy: [:each | each folders isGlorpProxy])		description: 'retrieve of alsoFetched folders got proxies'.	self assert: (users allSatisfy: [:each | each folders size = 2])		description: 'retrieve of alsoFetched folders did not get them all'.</body><body package="GlorpDBTests">testAlsoFetchToManyReadOne	"If a query reads only one object, but also fetches a to-many relationship joined to it, then it needs to retrieve more than one row and so cannot simply set LIMIT 1 on the overall query.  This test would fail in 8.0 and earlier, but passes in 8.1 and later since Glorp rewrites a query like	query := Query readOneOf: MyClass where: .... .	query alsoFetch: #myToManyRelationship.into an outer query whose limit is reset to nil, joined to a limit-1 inner query that does not alsoFetch (see #testAlsoFetchToManyReadOneCompositeKey for limitations on this approach)	query := Query readOneOf: MyClass where:		[:each | each = (Query readOneOf: MyClass where: ....)].	query alsoFetch: #myToManyRelationship.	query limit: nil.If the outer limit is not 1, but readsOneObject is true, Glorp assumes the user has already rewritten the query and so does not rewrite it again."	| userWithMultipleFolders query |	query := Query readOneOf: GlorpUser where: [:each | each folders sqlCount = 2].	query alsoFetch: #folders.	userWithMultipleFolders := session execute: query.	self deny: userWithMultipleFolders folders isGlorpProxy		description: 'folders were not alsoFetch:ed'.	self assert: userWithMultipleFolders folders size = 2		description: 'Reading user alsoFetch:ed only one folder'.</body><body package="GlorpDBTests">testAlsoFetchToManyReadOneUserLimit	"If the user sets the limit to a number other than 1 when alsoFetching a toMany, no rewriting the query occurs:  instead that number of rows will be returned."	| userWithMultipleFolders query |	query := Query readOneOf: GlorpUser where: [:each | each folders sqlCount = 2].	query alsoFetch: #folders.	query limit: 2.	userWithMultipleFolders := session execute: query.	self deny: userWithMultipleFolders folders isGlorpProxy		description: 'folders were not alsoFetch:ed'.	self assert: userWithMultipleFolders folders size &gt; 1		description: 'Reading user alsoFetch:ed only one folder'.</body><body package="GlorpDBTests">testAlsoFetchToManyReadOneUserRewrite	"This test shows how a user who wants to read only one object, but who also wants to fetch a to-many relationship joined to it, can do by hand the rewriting that Glorp's internals apply in 8.1 and after.  If the original query were	query := Query readOneOf: GlorpUser where: [:each | each folders sqlCount = 2].	query alsoFetch: #folders.then (before 8.1) it would not get more than one of to-many-joined folder rows, since it would get a single user by setting LIMIT 1 and this limit would apply to the whole query.  Recasting this to an outer query whose limit is reset to nil, joined to a limit-1 inner query that does not alsoFetch, is how the user can do in 8.0 and earlier what Glorp will do for them in 8.1 and after.  Glorp 8.1 uses the fact that the outer limit is not 1, although its readOneObject is true, to deduce when the user has already rewritten the query (so Glorp need not rewrite it again).	This test checks that such user-handled queries return the results a user will expect.  In 8.1 and after, the user need not bother, but older Glorp-using code may have had such workarounds.	To broaden the scope of the test suite, this test uses #in: instead of #=.  When the limit is 1, the two are semantically equivalent, but different platforms have different issues that can let one pass where the other fails."	| userWithMultipleFolders query |	query := Query readOneOf: GlorpUser where:		[:e | e in: (Query readOneOf: GlorpUser where:  [:each | each folders sqlCount = 2])].	query alsoFetch: #folders.	query limit: nil.	"limit was set to 1 in readOneOf: call"	session system platform isMySQLPlatform ifTrue: 		[self should: [userWithMultipleFolders := session execute: query]			raise: GlorpDatabaseReadError			description: 'Did not see error;  has MySQL fixed its LIMIT &amp; IN problem?'.		^self].	userWithMultipleFolders := session execute: query.	self deny: userWithMultipleFolders folders isGlorpProxy		description: 'Folders were not alsoFetch:ed'.	self assert: userWithMultipleFolders folders size = 2		description: 'Reading one user alsoFetch:ed only one folder'.</body><body package="GlorpDBTests">testBasicReadFolder	| folders |	folders := (session read: GlorpFolder) asSortedCollection: [:a :b | a name &lt;= b name].	self assert: folders size = 3.	self assert: folders first name = 'One'.	self assert: folders last name = 'Two'.</body><body package="GlorpDBTests">testBasicReadMessage	| messages |	messages := (session read: GlorpMessage) asSortedCollection: [:a :b | a subject &lt;= b subject].	self assert: messages size = 3.	self assert: messages first subject = 'also goes in folder 1'.	self assert: (messages at: 2) subject = 'goes in folder 1'.	self assert: messages last subject = 'goes in folder 2'.</body><body package="GlorpDBTests">testBasicReadUser	| users |	users := (session read: GlorpUser) asSortedCollection: [:a :b | a id &lt;= b id].	self assert: users size = 2.	self assert: users first name = 'User One'.	self assert: users last name = 'User Two'.</body><body package="GlorpDBTests">testFaulting	| users user1 sortedFolders user2 |	users := session read: GlorpUser.	user1 := users detect: [:each | each id = 1].	self assert: user1 folders size = 2.	sortedFolders := user1 folders asSortedCollection: [:a :b | a name &lt; b name].	self assert: sortedFolders first name = 'One'.	user2 := users detect: [:each | each id = 2].	self assert: user2 folders first messages first subject = 'goes in folder 2'.</body><body package="GlorpDBTests">testFolderIdentity	| folders |	folders := session read: GlorpFolder.	folders do: [:each | | individualFolders individualFolder otherIndividualFolder|		individualFolders := session read: GlorpFolder where: [:eachFolder | eachFolder = each].		self assert: individualFolders size = 1.		individualFolder := individualFolders first.		otherIndividualFolder := session readOneOf: GlorpFolder where: [:eachFolder | eachFolder = each].		self assert: individualFolder == each.		self assert: otherIndividualFolder == individualFolder].</body><body package="GlorpDBTests">testMessageCacheHit	| messages |	messages := session read: GlorpMessage.	messages do: [:each | | individualMessages individualMessage otherIndividualMessage|		individualMessages := session read: GlorpMessage where: [:eachMessage | eachMessage = each].		self assert: individualMessages size = 1.		individualMessage := individualMessages first.		session accessor denyReads.		otherIndividualMessage := session readOneOf: GlorpMessage where: [:eachMessage | eachMessage = each].		session accessor resetPermissions.		self assert: individualMessage == each.		self assert: otherIndividualMessage == individualMessage].</body><body package="GlorpDBTests">testMessageIdentity	| messages |	messages := session read: GlorpMessage.	messages do: [:each | | individualMessages individualMessage otherIndividualMessage|		individualMessages := session read: GlorpMessage where: [:eachMessage | eachMessage = each].		self assert: individualMessages size = 1.		individualMessage := individualMessages first.		otherIndividualMessage := session readOneOf: GlorpMessage where: [:eachMessage | eachMessage = each].		self assert: individualMessage == each.		self assert: otherIndividualMessage == individualMessage].</body><body package="GlorpDBTests">testReadWithCacheHitFromExpression	| message |	session reset.	message := session readOneOf: GlorpMessage where: [:each | each subject = 'goes in folder 1'].	self assert: message folder name = 'One'.	session accessor permitNothing.	session readOneOf: GlorpFolder where: [:each | each user id = 1 &amp; (each name = 'One')].</body><body package="GlorpDBTests">testReadWithCacheHitFromJoin	| message |	session reset.	message := session readOneOf: GlorpMessage where: [:each | each subject = 'goes in folder 1'].	session readOneOf: GlorpFolder where: [:each | each user id = 1 &amp; (each name = 'One')].	session accessor permitNothing.	self assert: message folder name = 'One'.</body><body package="GlorpDBTests">testReadWithCacheHitFromParameterizedExpression	| message query |	session reset.	message := session readOneOf: GlorpMessage where: [:each | each subject = 'goes in folder 1'].	self assert: message folder name = 'One'.	session accessor permitNothing.	query := Query readOneOf: GlorpFolder where: [:each | each user id = (each parameter: 1)  &amp; (each name = (each parameter: 2))].	query executeWithParameters: #(1 'One') in: session.</body><body package="GlorpDBTests">testReadWithJoins	| users |	users := session read: GlorpUser where: [:each | each folders anySatisfyJoin: [:eachFolder |		eachFolder messages anySatisfyJoin: [:eachMessage | eachMessage subject = 'goes in folder 1']]].	self assert: users size = 1.	self assert: users first id = 1.</body><body package="GlorpDBTests">testReadWithSubselect	| users |	users := session read: GlorpUser where: [:each | each folders anySatisfyExists: [:eachFolder |		eachFolder messages anySatisfyExists: [:eachMessage | eachMessage subject = 'goes in folder 1']]].	self assert: users size = 1.	self assert: users first id = 1.</body><body package="GlorpDBTests">testReadWithSubselectAndINClause	| users |	users := session read: GlorpUser where:		[:each |		each folders anySatisfyExists:			[:eachFolder || q |			q := Query read: GlorpFolder.			eachFolder in: q]].	self deny: (users anySatisfy: [:each | each folders isEmpty])		description: 'We asked only for users with some folders but got a user with none'.</body><body package="GlorpDBTests">testUserIdentity	| users |	users := session read: GlorpUser.	users		do:			[:each | 			| individualUser otherIndividualUser individualUsers |			individualUsers := session				read: GlorpUser				where: [:eachIndividual | eachIndividual id = each id].			self assert: individualUsers size = 1.			individualUser := individualUsers first.			otherIndividualUser := session				readOneOf: GlorpUser				where: [:eachIndividual | eachIndividual id = each id].			self assert: individualUser == each.			self assert: otherIndividualUser == individualUser].</body><body package="GlorpDBTests">testUserIdentityViaMessage	| users |	users := session read: GlorpUser.	users		do:			[:each | 			each folders				do:					[:eachFolder | 					eachFolder messages						do: [:eachMessage | 							self assert: eachMessage folder yourSelf == eachFolder.							self assert: eachMessage user yourSelf == each]]].</body><body package="GlorpDBTests">testUserIdentityViaMessageInUnitOfWork	session beginUnitOfWork.	[self testUserIdentityViaMessage] ensure: [session rollbackUnitOfWork].</body></methods><methods><class-id>Glorp.GlorpCompositeKeyTest</class-id> <category>setup</category><body package="GlorpDBTests">setUp	super setUp.	system := (GlorpCompositeKeyDescriptorSystem forPlatform: session platform).	session system: system.	session beginTransaction.	session transact: [session register: system example1].	session reset.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	session resetPermissions.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpCompositeKeyTest</class-id> <category>tests - composite keys</category><body package="GlorpDBTests">testAlsoFetchToManyReadOneCompositeKey	"The 'Glorp rewrites query to e = query' approach is exercised for simple primaryKey in testAlsoFetchToManyReadOne.  Here we test when the base has two primary key fields.  If session platform supportsLimit is false, we don't rewrite: the platform is inefficient when retrieving a single object in a query whose where clause matches many, but it is functionally correct in fetching toMany-related objects.  If the platform does support limit, we rewrite to avoid the risk of limiting #alsoFetch: across toMany-relations.  Where the base object has a composite key, the platform's value for supportsCompositeKeyArgsForOperand: determines whether we aggregate the LHS to a row-comparison like	(t1.ID, t1.NAME) = SELECT t1.ID, t1.NAME ... LIMIT 1or split the RHS thus	(t1.ID = SELECT t1.ID ... LIMIT 1)AND	(t1.NAME = SELECT t1.NAME ... LIMIT 1)"	| userWithMultipleFolders query |	query := Query readOneOf: GlorpFolder where: [:each | each user id = 1 AND: [each name = 'One']].	query alsoFetch: #messages.	userWithMultipleFolders := session execute: query.	self deny: userWithMultipleFolders messages isGlorpProxy		description: 'Folders were not alsoFetch:ed'.	self assert: userWithMultipleFolders messages size = 2		description: 'Reading one user alsoFetch:ed only one folder'.</body><body package="GlorpDBTests">testAlsoFetchToManyReadOneCompositeKeyUserRewrite	"The 'e = Query ... limit 1' approach of #testAlsoFetchToManyReadOneCompositeKey is in principle equivalent to 'e in: Query ... limit 1'.  In practice, different database platforms have different edge case issues with rowCompare/=/in:/compositeKey/limit/.  Here we express the query in the form that Glorp will rewrite it to in #testAlsoFetchToManyReadOneCompositeKey but using #in:, not #=.  For simple primaryKey, this is tested in #testAlsoFetchToManyReadOneUserRewrite.  Here, we test it for composite key.	MySQL does not tolerate ... IN limited subquery ...  When 'session system platform isMySQLPlatform' returns true, this test will raise a Glorp error (or, if that is resumed/omitted, a database error).  A later version of MySQL may correct this."	| userWithMultipleFolders query |	query := Query readOneOf: GlorpFolder where:		[:e | e in: ((Query read: GlorpFolder where:  [:each | each user id = 1 AND: [each name = 'One']]) limit: 1)].	query alsoFetch: #messages.	query limit: nil.	"limit was set to 1 in readOneOf: call"	session system platform isMySQLPlatform ifTrue:		[self should: [userWithMultipleFolders := session execute: query]			raise: GlorpDatabaseReadError			description: 'Did not see error;  has MySQL fixed its LIMIT &amp; IN problem?'.		^self].	userWithMultipleFolders := session execute: query.	self deny: userWithMultipleFolders messages isGlorpProxy		description: 'Folders were not alsoFetch:ed'.	self assert: userWithMultipleFolders messages size = 2		description: 'Reading one user alsoFetch:ed only one folder'.</body><body package="GlorpDBTests">testUserConstructedComposite	"Check a user-constructed composite key where the nominal composite has in fact only one mapping."	| query users userNames assertQuery allNamedUsers mappingsToRetrieve |	mappingsToRetrieve := #(name id).	query := Query read: GlorpUser where:		[:each || q |		q := Query read: GlorpUser where: [:e | e folders sqlCount &gt; 0].		q retrieveAll: mappingsToRetrieve.		(each getMappings: mappingsToRetrieve) in: q].	users := session execute: query.	self assert: users notEmpty.	"the code above completes the exercise of getMappings: - what follows checks the results"	userNames := users collect: [:each | each name].	assertQuery := Query read: GlorpUser where:		[:each | each name in: userNames].	allNamedUsers := (session execute: assertQuery) groupedBy: [:each | each name].	allNamedUsers do:		[:each | self assert: (each anySatisfy: [:folder | folder folders size &gt; 0])].</body><body package="GlorpDBTests">testUserConstructedCompositeBlock	"Check a user-constructed composite key where the nominal composite has in fact only one mapping."	| query users userNames assertQuery allNamedUsers mappingsToRetrieve |	mappingsToRetrieve := Array with: [:each | each name] with: [:each | each id].	query := Query read: GlorpUser where:		[:each || q |		q := Query read: GlorpUser where: [:e | e folders sqlCount &gt; 0].		q retrieveAll: mappingsToRetrieve.		(each getMappings: mappingsToRetrieve) in: q].	users := session execute: query.	self assert: users notEmpty.	"the code above completes the exercise of getMappings: - what follows checks the results"	userNames := users collect: [:each | each name].	assertQuery := Query read: GlorpUser where:		[:each | each name in: userNames].	allNamedUsers := (session execute: assertQuery) groupedBy: [:each | each name].	allNamedUsers do:		[:each | self assert: (each anySatisfy: [:folder | folder folders size &gt; 0])].</body><body package="GlorpDBTests">testUserConstructedCompositeBlockSingleton	"Exercise a user-constructed composite key where the nominal composite has in fact only one mapping.  As there is only one, we can check what is returned by comparing it with the results of a conventional query."	| testQuery folders assertQuery assertFolders |	testQuery := Query read: GlorpFolder where:		[:each || q |		q := Query read: GlorpFolder where: [:e | e messages sqlCount &gt; 0].		q retrieve: [:e | e name].		(each getMappings: (Array with: [:ea | ea name])) in: q].	testQuery orderBy: [:each | each name].		"order just to make assert comparison easier"	folders := session execute: testQuery.	self assert: folders notEmpty.	assertQuery := Query read: GlorpFolder where:		[:each || q |		q := Query read: GlorpFolder where: [:e | e messages sqlCount &gt; 0].		q retrieve: #name.		each name in: q].	assertQuery orderBy: [:each | each name].	"order just to make assert comparison easier"	assertFolders := session execute: assertQuery.	self assert: folders = assertFolders.</body><body package="GlorpDBTests">testUserConstructedCompositeSingleton	"Exercise a user-constructed composite key where the nominal composite has in fact only one mapping.  As there is only one, we can check what is returned by comparing it with the results of a conventional query."	| testQuery folders assertQuery assertFolders |	testQuery := Query read: GlorpFolder where:		[:each || q |		q := Query read: GlorpFolder where: [:e | e messages sqlCount &gt; 0].		q retrieve: #name.		(each getMappings: #(name)) in: q].	testQuery orderBy: [:each | each name].		"order just to make assert comparison easier"	folders := session execute: testQuery.	self assert: folders notEmpty.	assertQuery := Query read: GlorpFolder where:		[:each || q |		q := Query read: GlorpFolder where: [:e | e messages sqlCount &gt; 0].		q retrieve: #name.		each name in: q].	assertQuery orderBy: [:each | each name].	"order just to make assert comparison easier"	assertFolders := session execute: assertQuery.	self assert: folders = assertFolders.</body></methods><methods><class-id>Glorp.ASBonus</class-id> <category>accessing</category><body package="GlorpTestModels">credits	^credits</body><body package="GlorpTestModels">credits: anObject	credits := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.ASBonus</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	name := nil.	credits := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.ASBonus class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpFilteringQueryDBTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session beginTransaction.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	session resetPermissions.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpFilteringQueryDBTest</class-id> <category>tests</category><body package="GlorpDBTests">testReadDictionary	| entryMapping encyclopedias query readBackEncyclopedias canadian plagiarists |	session system: (GlorpEncyclopediaDescriptorSystem forPlatform: session platform).	system := session system.	encyclopedias := system exampleEncyclopedias.	entryMapping := (system descriptorFor: GlorpEncyclopedia) mappingForAttributeNamed: #entries.	entryMapping useFilteredRead.	session transact: [encyclopedias].	session reset.	query := Query read: GlorpEncyclopedia.	query orderBy: [:each | each name].	readBackEncyclopedias := session execute: query.	canadian := readBackEncyclopedias first.	self assert: canadian entries size = 3.	session accessor permitNothing.	self assert: (canadian entries at: 'abcde') id = 'two'.	self assert: (canadian entries at: '12345') id = 'one'.	self assert: (canadian entries at: 'unique') id = 'three'.	plagiarists := readBackEncyclopedias at: 2.	self assert: plagiarists entries size = 2.	self assert: (plagiarists entries at: '54321') = (canadian entries at: '12345').	self assert: (plagiarists entries at: 'edcba') = (canadian entries at: 'abcde').	self assert: readBackEncyclopedias last entries isEmpty.</body><body package="GlorpDBTests">testReadOneToMany	"This doesn't actually short-circuit interestingly, because of the shared holder"	| accounts txMapping tx1 tx2 otherHolder |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping useFilteredRead.	accounts := session execute: ((Query read: GlorpBankAccount where: [:each | each id ~= 2]) orderBy: [:each | each id]).	"Account 9874, 1 holder, 2 transactions"	tx1 := accounts last accountHolders first transactions.	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	otherHolder := accounts first accountHolders detect: [:each | each id = 28].	tx2 := otherHolder transactions.	self assert: (tx1 collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).	self assert: (tx2 collect: [:each | each amount currency]) asSortedCollection asArray = #(EUR).</body><body package="GlorpDBTests">testReadOneToMany2	| accounts txMapping otherHolder holder |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping useFilteredRead.	accounts := session execute: ((Query read: GlorpBankAccount where: [:each | each id ~= 2]) orderBy: [:each | each id]).	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	holder := accounts first accountHolders detect: [:each | each id = 28].	otherHolder := accounts first accountHolders detect: [:each | each id = 27].	self assert:  (holder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#EUR).	session accessor permitNothing.	self assert: (otherHolder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).</body><body package="GlorpDBTests">testReadOneToManyEmptyCriteria	| accounts txMapping otherHolder holder |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping useFilteredRead.	accounts := session execute: (Query read: GlorpBankAccount).	accounts := accounts asSortedCollection: [:a :b | a id &lt;= b id].	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	holder := accounts first accountHolders detect: [:each | each id = 28].	otherHolder := accounts first accountHolders detect: [:each | each id = 27].	self assert:  (holder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#EUR).	session accessor permitNothing.	self assert: (otherHolder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).</body><body package="GlorpDBTests">testReadOneToManyNoProxy	"This doesn't actually short-circuit interestingly, because of the shared holder"	| accounts txMapping tx1 tx2 otherHolder |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping shouldProxy: false.	txMapping useFilteredRead.	accounts := session execute: ((Query read: GlorpBankAccount where: [:each | each id ~= 2]) orderBy: [:each | each id]).	"Account 9874, 1 holder, 2 transactions"	tx1 := accounts last accountHolders first transactions.	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	otherHolder := accounts first accountHolders detect: [:each | each id = 28].	tx2 := otherHolder transactions.	self assert: (tx1 collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).	self assert: (tx2 collect: [:each | each amount currency]) asSortedCollection asArray = #(EUR).</body><body package="GlorpDBTests">testReadOneToOne	| people addressMapping |	session writeRow: session system exampleAddressRowForOrdering1.	session writeRow: session system exampleAddressRowForOrdering2.	session writeRow: session system exampleAddressRowForOrdering3.	session writeRow: session system examplePersonRowForOrdering1.	session writeRow: session system examplePersonRowForOrdering2.	session writeRow: session system examplePersonRowForOrdering3.	addressMapping := (system descriptorFor: GlorpPerson) mappingForAttributeNamed: #address.	addressMapping useFilteredRead.	people := session execute: (Query read: GlorpPerson where: [:each | each id ~= 2]).	people first address yourSelf.	session accessor permitNothing.	people := people asSortedCollection: [:a :b | a id &lt;= b id].	self assert: people first address id = 2.	self assert: (people at: 2) address id = 3.	self assert: (people at: 3) address id = 1.	self assert: people size = 3.</body><body package="GlorpDBTests">testTwoLevelRead	"A one-many and a many-many"	| accounts txMapping otherHolder holder accountMapping |	(GlorpReadingTest new session: session) write2CustomerRowsWith3Transactions.	txMapping := (system descriptorFor: GlorpCustomer) mappingForAttributeNamed: #transactions.	txMapping useFilteredRead.	accountMapping := (system descriptorFor: GlorpBankAccount) mappingForAttributeNamed: #accountHolders.	accountMapping useFilteredRead.	accounts := session execute: ((Query read: GlorpBankAccount where: [:each | each id ~= 2]) orderBy: [:each | each id]).	"Account 6, 2 holders, 1 with 1 transaction, 1 shared with 9874" 	self assert: accounts first accountHolders size = 2.	holder := accounts first accountHolders detect: [:each | each id = 28].	holder transactions yourSelf.	session accessor permitNothing.	self assert: (accounts last accountHolders collect: [:each | each id]) asArray = #(27).	otherHolder := accounts first accountHolders detect: [:each | each id = 27].	self assert:  (holder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#EUR).	session accessor permitNothing.	self assert: (otherHolder transactions collect: [:each | each amount currency]) asSortedCollection asArray = #(#CDN #USD).</body></methods><methods><class-id>Glorp.GlorpAttachmentBytes</class-id> <category>accessing</category><body package="GlorpTestModels">content	^content</body><body package="GlorpTestModels">content: anObject	content := anObject</body></methods><methods><class-id>Glorp.GlorpAttachmentBytes class</class-id> <category>glorp</category><body package="GlorpTestModels">glorpSetupClassModel: model forSystem: system 	model newAttributeNamed: #content</body><body package="GlorpTestModels">glorpSetupDescriptor: aDesc forSystem: system 	| t |	t := system tableNamed: 'attachmentbytes'.	aDesc table: t.	(aDesc newMapping: DirectMapping) from: #content		to: (t fieldNamed: 'content')</body></methods><methods><class-id>Glorp.GlorpFolder</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	user := nil.	messages := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpFolder</class-id> <category>accessing</category><body package="GlorpTestModels">messages	^messages</body><body package="GlorpTestModels">messages: aCollection	messages := aCollection</body><body package="GlorpTestModels">name	^name.</body><body package="GlorpTestModels">name: aString	name := aString.</body><body package="GlorpTestModels">user	^user</body><body package="GlorpTestModels">user: aGlorpUser	user := aGlorpUser</body><body package="GlorpTestModels">userId	^self user id.</body></methods><methods><class-id>Glorp.GlorpFolder class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>private</category><body package="GlorpTestModels">computeCollections	customers do: [:each | each store: self].	purchases := customers inject: #() into: [:sum :each | sum, each purchases].	purchases do: [:each | each store: self].</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>accessing</category><body package="GlorpTestModels">customers	^customers</body><body package="GlorpTestModels">customers: anObject	customers := anObject</body><body package="GlorpTestModels">purchases	^purchases</body><body package="GlorpTestModels">purchases: aCollection	purchases := aCollection</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>As yet unclassified</category><body package="GlorpTestModels">id	^id.</body><body package="GlorpTestModels">id: anInteger	id := anInteger.</body><body package="GlorpTestModels">name	^name.</body><body package="GlorpTestModels">name: aString	name := aString.</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>testing</category><body package="GlorpTestModels">assertEqual: aStore	self assert: id = aStore id.	self assert: name = aStore name.	customers assertEqual: aStore customers.	purchases assertEqual: aStore purchases.</body></methods><methods><class-id>Glorp.GlorpVideoStore</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	customers := OrderedCollection new.	purchases := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpVideoStore class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpEncyclopediaAuthor</class-id> <category>accessing</category><body package="GlorpTestModels">&lt;= aGlorpEncyclopediaAuthor	^self name &lt;= aGlorpEncyclopediaAuthor name.</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: aString	name := aString</body></methods><methods><class-id>Glorp.GlorpEncyclopediaAuthor</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: (self name isNil ifTrue: ['nil'] ifFalse: [self name]).	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForEMPLOYEE: aTable	| officeId |	aTable name: 'EMPLOYEE'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	officeId := aTable createFieldNamed: 'OFFICE_ID' type: platform int4.	aTable addForeignKeyFrom: officeId		to: ((self tableNamed: 'OFFICE') fieldNamed: 'ID').	aTable createFieldNamed: 'EMPLOYEE_TYPE' type: (platform varChar: 20).	aTable createFieldNamed: 'BRANCH' type: (platform varChar: 20).	aTable createFieldNamed: 'REGION' type: (platform varChar: 20).	aTable createFieldNamed: 'PRODUCTION_LINE' type: (platform varChar: 20).	"The following fields are only used by GlorpContractor."	aTable createFieldNamed: 'HOUR_AMT' type: platform int4.	aTable createFieldNamed: 'HOUR_CURR' type: (platform varChar: 5).</body><body package="GlorpTestModels">tableForNONPERISHABLE_ITEM: aTable	aTable name: 'NONPERISHABLE_ITEM'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'SERIAL_NUMBER' type: platform int4.</body><body package="GlorpTestModels">tableForOFFICE: aTable	| empOfMonth |	aTable name: 'OFFICE'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	empOfMonth := aTable createFieldNamed: 'EMPLOYEE_OF_MONTH' type: platform int4.	"Cheat by removing this, because it makes a cycle that we can't really handle yet"	"aTable addForeignKeyFrom: empOfMonth		to: ((self tableNamed: 'EMPLOYEE') fieldNamed: 'ID')."</body><body package="GlorpTestModels">tableForPERISHABLE_ITEM: aTable	aTable name: 'PERISHABLE_ITEM'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'AGE' type: platform int4.</body><body package="GlorpTestModels">tableForPOULTRY: aTable	aTable name: 'POULTRY'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'AGE' type: platform int4.	aTable createFieldNamed: 'FEATHER_COLOR' type: (platform varChar: 20).</body><body package="GlorpTestModels">tableForTAX: aTable	| superTaxId |	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: platform text.	aTable createFieldNamed: 'TYPE' type: (platform varchar: 16).	superTaxId := aTable createFieldNamed: 'TAX_ID' type: platform int4.	aTable addForeignKeyFrom: superTaxId to: ((self tableNamed: 'TAX') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForUNASSEMBLED_ITEM: aTable	aTable name: 'UNASSEMBLED_ITEM'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'SERIAL_NUMBER' type: platform int4.	aTable createFieldNamed: 'ASSEM_COST' type: platform int4.</body><body package="GlorpTestModels">tableForWAREHOUSE: aTable	(aTable createFieldNamed: 'ID' type: platform serial) bePrimaryKey.	aTable createFieldNamed: 'ADDRESS' type: (platform varChar: 50).	aTable createFieldNamed: 'CURRENT_ITEM_ID' type: platform int4.</body><body package="GlorpTestModels">tableForWAREHOUSE_ITEM_LINK: aTable	| warehouseId |	warehouseId := aTable createFieldNamed: 'WAREHOUSE_ID' type: platform int4.	aTable addForeignKeyFrom: warehouseId to: ((self tableNamed: 'WAREHOUSE') fieldNamed: 'ID').	aTable createFieldNamed: 'ITEM_ID' type: platform int4.</body><body package="GlorpTestModels">tableForWORKING_STIFF: aTable	aTable name: 'WORKING_STIFF'.	(aTable createFieldNamed: 'ID' type: platform int4) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>descriptors/employees</category><body package="GlorpTestModels">descriptorForGlorpContractor: aDescriptor	"This subclass has an embedded mapping, to test tracing and building of such cases."	| table |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	aDescriptor directMapping from: #name to: (table fieldNamed: 'NAME').	(self typeResolverFor: GlorpEmployee)		register: aDescriptor		keyedBy: 'C'		field: (table fieldNamed: 'EMPLOYEE_TYPE').	self addHourlyRateEmbeddedMappingTo: aDescriptor.</body><body package="GlorpTestModels">descriptorForGlorpEmployee: aDescriptor	"Add the GlorpContractor&gt;&gt;hourlyRate embedded mapping to this superclass conditionally (the condition being the concrete object is a Contractor).  This is a by-hand example of how to handle embedded objects in such classes.  The idea is that Glorp will construct this on the fly, so reading Employees does not omit the hourly rate of Contractors."	| table hourlyRateConditional typeResolutionField embeddedMapping |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	aDescriptor directMapping from: #name to: (table fieldNamed: 'NAME').	typeResolutionField := table fieldNamed: 'EMPLOYEE_TYPE'.	(self typeResolverFor: GlorpEmployee) register: aDescriptor keyedBy: 'E' field: typeResolutionField.	"The code below lets GlorpEmployee handle GlorpContractor's embedded mapping."	hourlyRateConditional := aDescriptor newMapping: ConditionalMapping.	embeddedMapping := self addHourlyRateEmbeddedMappingTo: hourlyRateConditional.	hourlyRateConditional 		forField: typeResolutionField		attribute: [:object | (self descriptorFor: object class) typeMapping keyedBy]		if: [:x | x = 'C']		useMapping: embeddedMapping;		otherwise: (hourlyRateConditional newMapping: ConstantMapping).	"We must set the index from GlorpContractor (GlorpEmployee has no such instVar, so attribute validation fails)."	embeddedMapping attribute privateAndbasicSetInstVarIndex:		((self descriptorFor: GlorpContractor) mappingForAttributeNamed: #hourlyRate) attribute instVarIndex.	"Alternatively, we could set useDirectAccess: false and give GlorpEmployee do-nothing #hourlyRate accessors."</body><body package="GlorpTestModels">descriptorForGlorpInventoryItem: aDescriptor	(self typeResolverFor: GlorpInventoryItem) register: aDescriptor abstract: true.</body><body package="GlorpTestModels">descriptorForGlorpLineWorker: aDescriptor	| table |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	(self typeResolverFor: GlorpEmployee) register: aDescriptor keyedBy: 'W' field: (table fieldNamed: 'EMPLOYEE_TYPE').	aDescriptor addMapping: (DirectMapping from: #productionLine to: (table fieldNamed: 'PRODUCTION_LINE')).	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpManager: aDescriptor	| table |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #branch to: (table fieldNamed: 'BRANCH')).	(self typeResolverFor: GlorpEmployee) register: aDescriptor keyedBy: 'M' field: (table fieldNamed: 'EMPLOYEE_TYPE').	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpNonperishableItem: aDescriptor	| table |	table := self tableNamed: 'NONPERISHABLE_ITEM'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #serialNumber to: (table fieldNamed: 'SERIAL_NUMBER')).	(self typeResolverFor: GlorpInventoryItem) register: aDescriptor.	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpOffice: aDescriptor	| table |	table := self tableNamed: 'OFFICE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (OneToManyMapping new			attributeName: #employees;			referenceClass: GlorpEmployee;			join: (Join 				from: (table fieldNamed: 'ID')				to: ((self tableNamed: 'EMPLOYEE') fieldNamed: 'OFFICE_ID'))).	aDescriptor addMapping: (OneToOneMapping new		attributeName: #employeeOfMonth;		referenceClass: GlorpEmployee;		join: (Join				from: (table fieldNamed: 'EMPLOYEE_OF_MONTH')				to: ((self tableNamed: 'EMPLOYEE') fieldNamed: 'ID'))).	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpPerishableItem: aDescriptor	| table |	table := self tableNamed: 'PERISHABLE_ITEM'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #age to: (table fieldNamed: 'AGE')).	(self typeResolverFor: GlorpInventoryItem) register: aDescriptor.	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpPoultry: aDescriptor	"Poultry does not participate in the InventoryItem heirarchy (ie it will not be retrieved when asking for an InventoryItem)"	| table |	table := self tableNamed: 'POULTRY'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #age to: (table fieldNamed: 'AGE')).	aDescriptor addMapping: (DirectMapping from: #featherColor to: (table fieldNamed: 'FEATHER_COLOR')).	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpRegionalManager: aDescriptor	| table |	table := self tableNamed: 'EMPLOYEE'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #branch to: (table fieldNamed: 'BRANCH')).	aDescriptor addMapping: (DirectMapping from: #region to: (table fieldNamed: 'REGION')).	(self typeResolverFor: GlorpEmployee) register: aDescriptor keyedBy: 'R' field: (table fieldNamed: 'EMPLOYEE_TYPE').	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpUnassembledItem: aDescriptor	| table |	table := self tableNamed: 'UNASSEMBLED_ITEM'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	aDescriptor addMapping: (DirectMapping from: #serialNumber to: (table fieldNamed: 'SERIAL_NUMBER')).	aDescriptor addMapping: (DirectMapping from: #assemblyCost to: (table fieldNamed: 'ASSEM_COST')).	(self typeResolverFor: GlorpInventoryItem) register: aDescriptor.	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpWarehouse: aDescriptor	| table linkTable |	table := self tableNamed: 'WAREHOUSE'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'ID').	aDescriptor directMapping from: #address to: (table fieldNamed: 'ADDRESS').	aDescriptor oneToOneMapping		attributeName: #currentItem;		join: (self				polymorphicJoinFromField: (table fieldNamed: 'CURRENT_ITEM_ID')				toAll: (Array with: GlorpNonperishableItem with: GlorpPerishableItem with: GlorpUnassembledItem)).	linkTable := self tableNamed: 'WAREHOUSE_ITEM_LINK'.	(aDescriptor newMapping: ManyToManyMapping)		attributeName: #items;		join: (Join from: (table fieldNamed: 'ID')					to: (linkTable fieldNamed: 'WAREHOUSE_ID'));		reverseJoin: (self					polymorphicJoinFromField: (linkTable fieldNamed: 'ITEM_ID')					toAll: (Array with: GlorpNonperishableItem with: GlorpPerishableItem with: GlorpUnassembledItem)).	^aDescriptor</body><body package="GlorpTestModels">descriptorForGlorpWorkingStiff: aDescriptor	"Working stiff does not participate in the Employee type mapping scheme (it uses its own table)"	| table |	table := self tableNamed: 'WORKING_STIFF'.	aDescriptor table: table.	aDescriptor addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID')).	aDescriptor addMapping: (DirectMapping from: #name to: (table fieldNamed: 'NAME')).	^aDescriptor</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>type resolvers</category><body package="GlorpTestModels">typeResolverForGlorpInventoryItem	^HorizontalTypeResolver forRootClass: GlorpInventoryItem.</body><body package="GlorpTestModels">typeResolverForGlorpTaggableObject   ^HorizontalTypeResolver forRootClass: GlorpTaggableObject</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>initialize-release</category><body package="GlorpTestModels">allTableNames	^#('EMPLOYEE' 'OFFICE' 'PERISHABLE_ITEM' 'NONPERISHABLE_ITEM' 'UNASSEMBLED_ITEM' 'WORKING_STIFF' 'POULTRY' 'TAX' 'WAREHOUSE' 'WAREHOUSE_ITEM_LINK'  'GLORP_IMAGE' 'GLORP_TAG' 'GLORP_TAGS' 'GLORP_PORTRAIT' 'GLORP_PICTURE_REVIEW').</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpOffice;		add: GlorpEmployee;		add: GlorpManager;		add: GlorpRegionalManager;		add: GlorpLineWorker;		add: GlorpInventoryItem;		add: GlorpPerishableItem;		add: GlorpNonperishableItem;		add: GlorpUnassembledItem;		add: GlorpWorkingStiff;		add: GlorpPoultry;		add: GlorpTax;		add: GlorpBasicTax;		add: GlorpSurcharge;		add: GlorpWarehouse;		add: GlorpTag;		add: GlorpTaggableObject;		add: GlorpImage;		add: GlorpContractor;	"we need not add GlorpMoney;  see #stealGlorpMoneyFromOtherSystem"		add: GlorpPortrait;		add: GlorpPictureReview;		yourself</body><body package="GlorpTestModels">constructAllTables	"This method usually returns tables, though there seems no need for it to do so."	super constructAllTables.	self stealGlorpMoneyFromOtherSystem.	^tables</body><body package="GlorpTestModels">stealGlorpMoneyFromOtherSystem	"We want GlorpMoney for our embedded mapping test, so we steal its initialized table, class and descriptor (in that order) from its owning descriptor system, switching them to point to our system as needed."	| glorpMoneySystem |	glorpMoneySystem := GlorpDemoDescriptorSystem new.	glorpMoneySystem platform: self platform.	tables		at: 'MONEY_IMAGINARY_TABLE'		ifAbsentPut: [glorpMoneySystem tableNamed: 'MONEY_IMAGINARY_TABLE'].	classModels		at: GlorpMoney		ifAbsentPut: [(glorpMoneySystem classModelFor: GlorpMoney) system: self].	descriptors		at: GlorpMoney		ifAbsentPut: [(glorpMoneySystem descriptorFor: GlorpMoney) system: self].</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>misc</category><body package="GlorpTestModels">addHourlyRateEmbeddedMappingTo: aDescriptor	| table imaginaryEmbeddedTable |	table   := self tableNamed: 'EMPLOYEE'.	imaginaryEmbeddedTable := self tableNamed: 'MONEY_IMAGINARY_TABLE'.	^(aDescriptor newMapping: EmbeddedValueOneToOneMapping)		attributeName: #hourlyRate;		referenceClass: GlorpMoney;		fieldTranslation: (Join new						addSource: (table fieldNamed: 'HOUR_AMT')						target: (imaginaryEmbeddedTable fieldNamed: 'AMOUNT');						addSource: (table fieldNamed: 'HOUR_CURR')						target: (imaginaryEmbeddedTable fieldNamed: 'CURRENCY'));		yourself.</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>descriptors/images</category><body package="GlorpTestModels">classModelForGlorpImage: aClassModel 	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #location.	aClassModel newAttributeNamed: #tags collectionOf: GlorpTag.</body><body package="GlorpTestModels">classModelForGlorpTag: aClassModel 	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #key.	aClassModel newAttributeNamed: #label</body><body package="GlorpTestModels">classModelForGlorpTaggableObject: aClassModel</body><body package="GlorpTestModels">descriptorForGlorpImage: aDescriptor 	| table |	table := self tableNamed: 'GLORP_IMAGE'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'id').	aDescriptor directMapping from: #location to: (table fieldNamed: 'location').	aDescriptor manyToManyMapping		attributeName: #tags;		referenceClass: GlorpTag;		join: (Join				from: (table fieldNamed: 'id')				to: ((self tableNamed: 'IMAGETAGS') fieldNamed: 'obj_id')).	(self typeResolverFor: GlorpTaggableObject)		register: aDescriptor.</body><body package="GlorpTestModels">descriptorForGlorpPictureReview: aDescriptor	aDescriptor table: (self tableNamed: 'GLORP_PICTURE_REVIEW').	aDescriptor oneToOneMapping		attributeName: #picture;		referenceClass: GlorpTaggableObject;		join: (self				polymorphicJoinFromField: (aDescriptor table fieldNamed: 'pictureID')				toAll: GlorpTaggableObject subclasses).	(aDescriptor directMapping from: #pictureID to: (aDescriptor table fieldNamed: 'pictureID')) beForPseudoVariable.	aDescriptor directMapping from: #sequence to: (aDescriptor table fieldNamed: 'sequence').</body><body package="GlorpTestModels">descriptorForGlorpPortrait: aDescriptor 	| table |	table := self tableNamed: 'GLORP_PORTRAIT'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'id').	aDescriptor directMapping from: #subjectFullName to: (table fieldNamed: 'subjectFullName').	aDescriptor manyToManyMapping		attributeName: #tags;		referenceClass: GlorpTag;		join: (Join				from: (table fieldNamed: 'id')				to: ((self tableNamed: 'IMAGETAGS') fieldNamed: 'obj_id')).	(self typeResolverFor: GlorpTaggableObject)		register: aDescriptor.</body><body package="GlorpTestModels">descriptorForGlorpTag: aDescriptor 	| table |	table := self tableNamed: 'GLORP_TAG'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'id').	(aDescriptor newMapping: DirectMapping)		from: #key		to: (table fieldNamed: 'key').	(aDescriptor newMapping: DirectMapping)		from: #label		to: (table fieldNamed: 'label').</body><body package="GlorpTestModels">descriptorForGlorpTaggableObject: aDescriptor	"We use one of our subtables to get a stand-in for the VariableJoin's target field.  As the VariableJoin's sourceField is the same for all targets, it does not matter which one we pick.  A sane query will replace the targetField with the sourceField in #condensePrimaryKeyComparison."	| firstSubclassField |	firstSubclassField := (self tableNamed: 'GLORP_IMAGE')  fieldNamed: 'id'.	aDescriptor table: DatabaseTable new.	aDescriptor table fields add: firstSubclassField.	aDescriptor table addAsPrimaryKeyField: firstSubclassField.	(aDescriptor directMapping from: #id to: firstSubclassField) beForPseudoVariable.	"The next line is the only real part of this descriptor."	(self typeResolverFor: GlorpTaggableObject)		register: aDescriptor		abstract: true.</body><body package="GlorpTestModels">tableForGLORP_IMAGE: aTable 	(aTable createFieldNamed: 'id' type: platform sequence) bePrimaryKey.	aTable		createFieldNamed: 'location'		type: (platform varChar: 250).</body><body package="GlorpTestModels">tableForGLORP_PICTURE_REVIEW: aTable	| pictureField fkConstraint |	pictureField := (aTable createFieldNamed: 'pictureID' type: platform integer) bePrimaryKey.	(aTable createFieldNamed: 'sequence' type: platform integer) bePrimaryKey.	fkConstraint := aTable		addForeignKeyFrom: pictureField		to: ((self tableNamed: 'GLORP_IMAGE') fieldNamed: 'ID').	fkConstraint shouldCreateInDatabase: false.	fkConstraint := aTable		addForeignKeyFrom: pictureField		to: ((self tableNamed: 'GLORP_PORTRAIT') fieldNamed: 'ID').	fkConstraint shouldCreateInDatabase: false.</body><body package="GlorpTestModels">tableForGLORP_PORTRAIT: aTable	"We could use the same sequence for portrait as for image in most cases (to avoid clashing sequence numbers see BasicTypeResolver&gt;&gt;validate), but not in SQLServer, SQLite and MySQL each of which usesIdentityColumns. In that case, the returned ids are governed by each table not by the sequence, of which the database is unaware, so there is duplication of ids."	(aTable createFieldNamed: 'id' type: platform integer) bePrimaryKey.	aTable		createFieldNamed: 'subjectFullName'		type: (platform varChar: 250).</body><body package="GlorpTestModels">tableForGLORP_TAG: aTable 	(aTable createFieldNamed: 'id' type: platform sequence) bePrimaryKey.	aTable		createFieldNamed: 'key'		type: (platform varChar: 200).	aTable		createFieldNamed: 'label'		type: (platform varChar: 200).</body><body package="GlorpTestModels">tableForGLORP_TAGS: aTable 	| tagKey tagObjKey |	tagKey := aTable createFieldNamed: 'tag_id' type: platform int4.	aTable		addForeignKeyFrom: tagKey		to: ((self tableNamed: 'GLORP_TAG')				fieldNamed: 'id').	tagObjKey := aTable createFieldNamed: 'obj_id' type: platform int4.	aTable		addForeignKeyFrom: tagObjKey		to: ((self tableNamed: 'GLORP_IMAGE')				fieldNamed: 'id')</body><body package="GlorpTestModels">tableForIMAGETAGS: aTable 	| tagKey tagObjKey |	tagKey := aTable createFieldNamed: 'tag_id' type: platform int4.	aTable		addForeignKeyFrom: tagKey		to: ((self tableNamed: 'GLORP_TAG')				fieldNamed: 'id').	tagObjKey := aTable createFieldNamed: 'obj_id' type: platform int4.	aTable		addForeignKeyFrom: tagObjKey		to: ((self tableNamed: 'GLORP_IMAGE')				fieldNamed: 'id')</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>classes</category><body package="GlorpTestModels">classModelForGlorpWarehouse: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #address.	aClassModel newAttributeNamed: #currentItem type: GlorpInventoryItem.	aClassModel newAttributeNamed: #items collectionOf: GlorpInventoryItem.</body></methods><methods><class-id>Glorp.GlorpInheritanceDescriptorSystem</class-id> <category>utility</category><body package="GlorpTestModels">polymorphicJoinFromField: aField toAll: concreteSubClasses	"Return a polymorphic join to the subclasses from the given field.  This assumes the target classes all have an ID field in their tables."	| polymorphicJoin |	polymorphicJoin := VariableJoin new.	concreteSubClasses do: 		[:eachClass |		polymorphicJoin			addJoinFor: eachClass			as: (Join					from: aField					to: ((self descriptorFor: eachClass) primaryTable fieldNamed: 'ID'))].	^polymorphicJoin</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>glorp/events</category><body package="GlorpTestModels">glorpNoticeOfExpiryIn: aSession	seenExpiry := true.</body><body package="GlorpTestModels">glorpPostFetch: aSession	seenPostFetch := true</body><body package="GlorpTestModels">glorpPostWrite: aSession	seenPostWrite := true</body><body package="GlorpTestModels">glorpPreWrite: aSession	seenPreWrite := true</body><body package="GlorpTestModels">seenExpiry	^seenExpiry</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>accessing</category><body package="GlorpTestModels">accounts	^accounts.</body><body package="GlorpTestModels">accounts: aCollection	accounts := aCollection.</body><body package="GlorpTestModels">addAccount: aBankAccount	accounts add: aBankAccount.	aBankAccount basicAddHolder: self.</body><body package="GlorpTestModels">addTransaction: aTransaction	transactions add: aTransaction.	aTransaction owner: self.</body><body package="GlorpTestModels">id	"Private - Answer the value of the receiver's ''id'' instance variable."	^id</body><body package="GlorpTestModels">id: anObject	"Private - Set the value of the receiver's ''id'' instance variable to the argument, anObject."	id := anObject</body><body package="GlorpTestModels">name	"Private - Answer the value of the receiver's ''name'' instance variable."	^name</body><body package="GlorpTestModels">name: anObject	"Private - Set the value of the receiver's ''name'' instance variable to the argument, anObject."	name := anObject</body><body package="GlorpTestModels">removeAccount: aBankAccount	accounts remove: aBankAccount.	aBankAccount basicRemoveHolder: self.</body><body package="GlorpTestModels">seenPostFetch	^seenPostFetch</body><body package="GlorpTestModels">seenPostWrite	^seenPostWrite</body><body package="GlorpTestModels">seenPreWrite	^seenPreWrite</body><body package="GlorpTestModels">transactions	"Private - Answer the value of the receiver's ''transactions'' instance variable."	^transactions</body><body package="GlorpTestModels">transactions: anObject	"Private - Set the value of the receiver's ''transactions'' instance variable to the argument, anObject."	transactions := anObject</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>As yet unclassified</category><body package="GlorpTestModels">accountsSortedById	^accountsSortedById.</body><body package="GlorpTestModels">accountsSortedByIdDescending	^accountsSortedByIdDescending.</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream 	super printOn: aStream.	aStream		nextPut: $(;		print: id;		nextPut: $,;		nextPutAll: (name ifNil: ['']);		nextPutAll: ')'</body></methods><methods><class-id>Glorp.GlorpCustomer</class-id> <category>initialize/release</category><body package="GlorpTestModels">initialize	transactions := OrderedCollection new.	accounts := OrderedCollection new.	seenExpiry := false.	seenPostFetch := false.	seenPreWrite:= false.	seenPostWrite := false.</body></methods><methods><class-id>Glorp.GlorpCustomer class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		name: 'Fred Flintstone';		addTransaction: GlorpBankTransaction example1;		addTransaction: GlorpBankTransaction example2.</body><body package="GlorpTestModels">example2	^self new          id: 123;		name: 'Fred Flintstone';		addTransaction: GlorpBankTransaction example1;		addTransaction: GlorpBankTransaction example2.</body><body package="GlorpTestModels">exampleD1	^self new		name: 'Fred Flintstone'</body><body package="GlorpTestModels">exampleD2	^self new		name: 'Wilma Flintstone'</body><body package="GlorpTestModels">exampleD3	^self new		name: 'Pebbles Flintstone'</body></methods><methods><class-id>Glorp.GlorpCustomer class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDocumentDescriptorSystem</class-id> <category>glorp</category><body package="GlorpTestModels">allTableNames	^#('document' 'attachment' 'attachmentbytes')</body><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpDocument;		add: GlorpAttachment;		add: GlorpAttachmentBytes;		yourself</body><body package="GlorpTestModels">tableForATTACHMENT: aTable 	| d |	d := (aTable createFieldNamed: 'document_id' type: platform int4) 				bePrimaryKey.	(aTable createFieldNamed: 'indexInDocument' type: platform int) bePrimaryKey.	aTable createFieldNamed: 'mimetype' type: (platform varchar: 32).	"FK Constraints"	aTable addForeignKeyFrom: d		to: ((self tableNamed: 'document') fieldNamed: 'id')</body><body package="GlorpTestModels">tableForATTACHMENTBYTES: aTable 	| d i |	d := (aTable createFieldNamed: 'attachment_document_id'				type: platform int4) bePrimaryKey.	i := (aTable createFieldNamed: 'attachment_index' type: platform int) 				bePrimaryKey.	aTable createFieldNamed: 'content' type: platform text.	"FK"	aTable 		addForeignKeyFrom: d		to: ((self tableNamed: 'attachment') fieldNamed: 'document_id')		from: i		to: ((self tableNamed: 'attachment') fieldNamed: 'indexInDocument')</body><body package="GlorpTestModels">tableForDOCUMENT: aTable 	(aTable createFieldNamed: 'id' type: platform sequence) bePrimaryKey.	aTable createFieldNamed: 'whatever' type: (platform integer).</body></methods><methods><class-id>Glorp.GlorpDocumentDescriptorSystem class</class-id> <category>none</category><body package="GlorpTestModels">doTest	"   AADescriptor doTest    "	| glorpSession doc |	glorpSession := self connectToDatabase.	"Try #1 -- this works as advertized"	doc := self readDocumentAndAttachmentsFrom: glorpSession.	"Something changed? Should not."	glorpSession modify: doc in: [].	doc := nil.	glorpSession accessor logout.	glorpSession := self connectToDatabase.	"Try #2 -- this makes Glorp believe the attachment was changed"	doc := self readDocumentAndAttachmentsFrom: glorpSession.	doc attachments do: 			[:ea | 			"Force attachmentBytes to be instanciated"			Transcript nextPutAll: '----&gt; ', ea attachmentBytes content; cr].	"Something changed? Should not, but does."	"Glorp now tries to update the attachment AND save the attachmentBytes again. Boom"	glorpSession modify: doc in: [].	glorpSession accessor logout</body><body package="GlorpTestModels">readDocumentAndAttachmentsFrom: glorpSession 	| doc |	doc := glorpSession readOneOf: GlorpDocument.	Transcript		cr;		nextPutAll: '---&gt; Read document ' , doc id printString;		cr.	doc attachments do: 			[:att | 			Transcript				cr;				nextPutAll: '------&gt; Attachment ' , att index printString , ' ' 							, att mimeType;				cr].	^doc</body></methods><methods><class-id>Glorp.GlorpVideoCreditStatus</class-id> <category>As yet unclassified</category><body package="GlorpTestModels">balanceOwing	^balanceOwing.</body><body package="GlorpTestModels">balanceOwing: aNumber	balanceOwing := aNumber.</body><body package="GlorpTestModels">comments	^comments.</body><body package="GlorpTestModels">comments: aString	comments := aString.</body><body package="GlorpTestModels">customer	^customer.</body><body package="GlorpTestModels">customer: aCustomer	customer := aCustomer.</body><body package="GlorpTestModels">dateOwing	^dateOwing.</body><body package="GlorpTestModels">dateOwing: aDate	dateOwing := aDate.</body></methods><methods><class-id>Glorp.GlorpVideoCreditStatus</class-id> <category>testing</category><body package="GlorpTestModels">assertEqual: aCreditStatus	self assert: customer name = aCreditStatus customer name.	self assert: customer dateOfBirth = aCreditStatus customer dateOfBirth.	self assert: balanceOwing = aCreditStatus balanceOwing.	self assert: dateOwing = aCreditStatus dateOwing.	self assert: comments = aCreditStatus comments.</body></methods><methods><class-id>Glorp.GlorpImage</class-id> <category>accessing</category><body package="GlorpTestModels">location	^ location</body><body package="GlorpTestModels">location: aLocation	location := aLocation</body></methods><methods><class-id>Glorp.GlorpImage class</class-id> <category>as yet unclassified</category><body package="GlorpTestModels">fromStream: aStream	^ self new image: aStream</body></methods><methods><class-id>Glorp.InheritanceQueryDescriptorSystem</class-id> <category>classes</category><body package="GlorpTestModels">classModelForCustomerStation: aClassModel	aClassModel newAttributeNamed: #id type: SmallInteger.	aClassModel newAttributeNamed: #successor collection: Array of: Successor.</body><body package="GlorpTestModels">classModelForFeederStation: aClassModel	aClassModel newAttributeNamed: #id type: SmallInteger.	aClassModel newAttributeNamed: #successor collection: Array of: Successor.</body><body package="GlorpTestModels">classModelForStation: aClassModel	aClassModel newAttributeNamed: #id type: SmallInteger.	aClassModel newAttributeNamed: #successor collection: Array of: Successor</body><body package="GlorpTestModels">classModelForSuccessor: aClassModel	aClassModel newAttributeNamed: #id type: SmallInteger.	aClassModel newAttributeNamed: #successorCustomer type: CustomerStation.	aClassModel newAttributeNamed: #successorFeeder type: FeederStation.	aClassModel newAttributeNamed: #station type: Station</body></methods><methods><class-id>Glorp.InheritanceQueryDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForCustomerStation: aDescriptor	| stationTable customerTable |	(self typeResolverFor: Station) register: aDescriptor.	stationTable := self tableNamed: 'NOTIFIER_STATION'.	aDescriptor table: stationTable.	customerTable := self tableNamed: 'NOTIFIER_CUSTOMERSTATION'.	aDescriptor table: customerTable.	aDescriptor addMultipleTableJoin:		(Join			from: (stationTable fieldNamed: 'ID')			to: (customerTable fieldNamed: 'STATION')).	aDescriptor toManyMapping		attributeName: #successor;		join: (Join from: (stationTable fieldNamed: 'ID')					to: ((self tableNamed: 'NOTIFIER_SUCCESSOR') fieldNamed: 'STATION'));		proxyAction: [:owner :value | value postFetchGlorp].	aDescriptor directMapping		from: #id to: (stationTable fieldNamed: 'ID');		converter: (PluggableDatabaseConverter new					name: '@yourself|yourself';					dbToStConverter: [:aValue | aValue yourself];					stToDbConverter: [:aValue | aValue yourself];					yourself).</body><body package="GlorpTestModels">descriptorForFeederStation: aDescriptor	| stationTable feederTable |	(self typeResolverFor: Station) register: aDescriptor.	stationTable := self tableNamed: 'NOTIFIER_STATION'.	aDescriptor table: stationTable.	feederTable := self tableNamed: 'NOTIFIER_FEEDERSTATION'.	aDescriptor table: feederTable.	aDescriptor addMultipleTableJoin:		(Join			from: (stationTable fieldNamed: 'ID')			to: (feederTable fieldNamed: 'STATION')).	aDescriptor toManyMapping		attributeName: #successor;		join: (Join				from: (stationTable fieldNamed: 'ID')				to: ((self tableNamed: 'NOTIFIER_SUCCESSOR') fieldNamed: 'STATION'));		proxyAction: [:owner :value | value postFetchGlorp].	aDescriptor directMapping		from: #id to: (stationTable fieldNamed: 'ID');		converter: (PluggableDatabaseConverter new					name: '@yourself|yourself';					dbToStConverter: [:aValue | aValue yourself];					stToDbConverter: [:aValue | aValue yourself];					yourself).</body><body package="GlorpTestModels">descriptorForStation: aDescriptor	aDescriptor table: (self tableNamed: 'NOTIFIER_STATION').	(self typeResolverFor: Station) register: aDescriptor abstract: true.</body><body package="GlorpTestModels">descriptorForSuccessor: aDescriptor"The original example from which this test set up came had converter and proxyAction behaviour.  Trivial behaviours - #yourself in the converter and #postFetchGlorp in the proxyActions - have been left in below."	| table |	table := self tableNamed: 'NOTIFIER_SUCCESSOR'.	aDescriptor table: table.	aDescriptor directMapping		from: #id to: (table fieldNamed: 'ID');		converter: (PluggableDatabaseConverter new					name: '@yourself|yourself';					dbToStConverter: [:aValue | aValue yourself];					stToDbConverter: [:aValue | aValue yourself];					yourself).	aDescriptor oneToOneMapping		attributeName: #station;	"this relation points at the predecessor"		join: (Join				from: ((self tableNamed: 'NOTIFIER_SUCCESSOR') fieldNamed: 'STATION')				to: ((self tableNamed: 'NOTIFIER_STATION') fieldNamed: 'ID'));		proxyAction: [:owner :value | value postFetchGlorp].	aDescriptor oneToOneMapping		attributeName: #successorCustomer;	"I can point to a successor customer station ... "		join: (Join				from: ((self tableNamed: 'NOTIFIER_SUCCESSOR') fieldNamed: 'NEXTCUSTOMER')				to: ((self tableNamed: 'NOTIFIER_CUSTOMERSTATION') fieldNamed: 'STATION'));		proxyAction: [:owner :value | value postFetchGlorp].	aDescriptor oneToOneMapping		attributeName: #successorFeeder;	" ... and/or a successor feeder station"		join: (Join				from: ((self tableNamed: 'NOTIFIER_SUCCESSOR') fieldNamed: 'NEXTFEEDER')				to: ((self tableNamed: 'NOTIFIER_FEEDERSTATION') fieldNamed: 'STATION'));		proxyAction: [:owner :value | value postFetchGlorp].</body></methods><methods><class-id>Glorp.InheritanceQueryDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForNOTIFIER_CUSTOMERSTATION: aTable	(aTable createFieldNamed: 'STATION' type: platform integer) bePrimaryKey.	aTable		addForeignKeyFrom: ((self tableNamed: 'NOTIFIER_CUSTOMERSTATION') fieldNamed: 'STATION')		to: ((self tableNamed: 'NOTIFIER_STATION') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForNOTIFIER_FEEDERSTATION: aTable	(aTable createFieldNamed: 'STATION' type: platform integer) bePrimaryKey.	aTable		addForeignKeyFrom: ((self tableNamed: 'NOTIFIER_FEEDERSTATION') fieldNamed: 'STATION')		to: ((self tableNamed: 'NOTIFIER_STATION') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForNOTIFIER_STATION: aTable	(aTable		createFieldNamed: 'ID'		type: platform integer) bePrimaryKey.</body><body package="GlorpTestModels">tableForNOTIFIER_SUCCESSOR: aTable	(aTable createFieldNamed: 'ID' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'NEXTCUSTOMER' type: platform integer.	aTable createFieldNamed: 'STATION' type: platform integer.	aTable createFieldNamed: 'NEXTFEEDER' type: platform integer.	aTable		addForeignKeyFrom: ((self tableNamed: 'NOTIFIER_SUCCESSOR') fieldNamed: 'NEXTCUSTOMER')		to: ((self tableNamed: 'NOTIFIER_CUSTOMERSTATION') fieldNamed: 'STATION').	aTable		addForeignKeyFrom: ((self tableNamed: 'NOTIFIER_SUCCESSOR') fieldNamed: 'NEXTFEEDER')		to: ((self tableNamed: 'NOTIFIER_FEEDERSTATION') fieldNamed: 'STATION').	aTable		addForeignKeyFrom: ((self tableNamed: 'NOTIFIER_SUCCESSOR') fieldNamed: 'STATION')		to: ((self tableNamed: 'NOTIFIER_STATION') fieldNamed: 'ID').</body></methods><methods><class-id>Glorp.InheritanceQueryDescriptorSystem</class-id> <category>type resolvers</category><body package="GlorpTestModels">typeResolverForStation	"The abstract class Station and its concrete subclasses CustomerStation and FeederStation are each represented in itheir own table.  The tables for the concrete subclasses include a link to the table of the abstract superclass."	^HorizontalTypeResolver forRootClass: Station</body></methods><methods><class-id>Glorp.GlorpExpressionTest</class-id> <category>tests</category><body package="GlorpTests">testAndOperation	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | (a firstName = fred) &amp; (a firstName ~= fred)] asGlorpExpressionOn: base.	self assert: expression class == RelationExpression.	self assert: expression relation = #AND.</body><body package="GlorpTests">testAndOperation2	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | (a firstName = fred) AND: (a firstName ~= fred)] asGlorpExpressionOn: base.	self assert: expression class == RelationExpression.	self assert: expression relation = #AND.</body><body package="GlorpTests">testAnySatisfyExists	| expression base |	system useJoinsForAnySatisfy: false.	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	expression := [:a | a items anySatisfy: [:each | each id = 7]] asGlorpExpressionOn: base.	self assert: expression class == SubSelectExpression.</body><body package="GlorpTests">testAnySatisfyJoin	| expression base |	system useJoinsForAnySatisfy: true.	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpCustomer).	expression := [:a | a items anySatisfy: [:each | each id = 7]] asGlorpExpressionOn: base.	self assert: expression class == CollectionExpression.	self assert: expression leftChild == expression rightChild leftChild base.</body><body package="GlorpTests">testAnySatisfyPrintExists	| expression |	system useJoinsForAnySatisfy: false.	expression := [:cust | cust transactions anySatisfy: [:each | each id = 7]] 				asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	self assert: (' EXISTS (SELECT s1t1.ID&lt;n&gt; FROM BANK_TRANS s1t1&lt;n&gt; WHERE *s1t1.ID = :1* AND *s1t2.ID = s1t1.OWNER_ID)*' expandMacros match: expression sqlString).</body><body package="GlorpTests">testAnySatisfyPrintJoin	| expression |	system useJoinsForAnySatisfy: true.	expression := [:cust | cust transactions anySatisfy: [:each | each id = 7]] 				asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	self assert: '(BANK_TRANS.ID = 7)' equalsIgnoringOuterBrackets: expression sqlString.</body><body package="GlorpTests">testBetweenAnd	| expression base command |	base := FieldExpression		forField: (DatabaseField named: 'test' type: system platform int4)		basedOn: BaseExpression new.	expression := [:a | a between: 3 and: 4] asGlorpExpressionOn: base.	self assert: expression class == InfixFunction.	self assert: expression name = 'BETWEEN AND'.	self assert: (expression arguments collect: [:each | each value]) = (Array with: 3 with: 4).	command := GlorpNullCommand useBinding: false session: system session.	expression			printSQLOn: command		withParameters: Dictionary new.	self assert: command sqlString = 'test BETWEEN 3 AND 4'.</body><body package="GlorpTests">testEqualityOperation	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | a firstName = fred] asGlorpExpressionOn: base.	self assert: expression leftChild == (base get: #firstName).	self assert: expression rightChild class == ConstantExpression.	self assert: expression rightChild value == fred.	self assert: expression relation == #=</body><body package="GlorpTests">testFindingMapping	| base baseDescriptor |	baseDescriptor := system descriptorFor: GlorpBankTransaction.	base := BaseExpression new descriptor: baseDescriptor.	self assert: (base get: #serviceCharge) mapping == (baseDescriptor mappingForAttributeNamed: #serviceCharge).	self assert: (base get: #serviceCharge) sourceDescriptor == (system descriptorFor: GlorpBankTransaction).	self assert: (base get: #serviceCharge) descriptor == (system descriptorFor: GlorpServiceCharge)</body><body package="GlorpTests">testGetField	| expression |	expression := [:cust | cust getField: 'ID'] asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	self assert: expression sqlString = 'GR_CUSTOMER.ID'.	self assert: expression class = FieldExpression.	self assert: expression field table = (system tableNamed: 'GR_CUSTOMER').</body><body package="GlorpTests">testGetFieldAmbiguous	| |	self 		should: [[:pass | pass getField: 'ID']			asGlorpExpressionForDescriptor: (system descriptorFor: GlorpPassenger)]		raise: Dialect error.</body><body package="GlorpTests">testGetFieldFromSecondaryTable	| expression |	expression := [:pass | pass getField: 'POINTS']		asGlorpExpressionForDescriptor: (system descriptorFor: GlorpPassenger).	self assert: expression sqlString = 'FREQUENT_FLYER.POINTS'.	self assert: expression class = FieldExpression.	self assert: expression field table = (system tableNamed: 'FREQUENT_FLYER').</body><body package="GlorpTests">testJoinOperation	| userExpression base expression addressTable personTable query field1 field2 join |	addressTable := system tableNamed: 'GR_ADDRESS'.	personTable := system tableNamed: 'PERSON'.	base := BaseExpression new.	base descriptor: (system descriptorFor: GlorpPerson).	userExpression := [:aPerson | aPerson address number = 12] 				asGlorpExpressionOn: base.	query := SimpleQuery readOneOf: GlorpPerson where: userExpression.	query session: (GlorpSession new system: system).	self assert: (userExpression additionalExpressionsIn: query) size = 1.	query prepare.	expression := query whereClause.	self assert: query joins size = 1.	join := query joins first.	self		assert: expression == userExpression;		assert: expression relation == #=.	field1 := join leftChild field.	self assert: field1 table parent == personTable.	self assert: field1 name = 'ADDRESS_ID'.	field2 := join rightChild field.	self assert: field2 table parent == addressTable.	self assert: field2 name = 'ID'.</body><body package="GlorpTests">testMappingBase	| base |	base := BaseExpression new.	self assert: (base get: #someAttribute) base == base</body><body package="GlorpTests">testMappingExpressionIdentity 	self assertIdentityOf: [:a | a someAttribute] and: [:a | a someAttribute].</body><body package="GlorpTests">testMappingExpressionIdentity2	self assertIdentityOf: [:a | a perform: #someAttribute] and: [:a | a someAttribute].</body><body package="GlorpTests">testMappingExpressionIdentity3	self assertIdentityOf: [:a | a get: #someAttribute] and: [:a | a someAttribute].</body><body package="GlorpTests">testMappingExpressionIdentity4	self denyIdentityOf: [:a | a get: #someAttribute] and: [:a | a someOtherAttribute].</body><body package="GlorpTests">testOrOperation	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | (a firstName = fred) | (a firstName ~= fred)] asGlorpExpressionOn: base.	self assert: expression class == RelationExpression.	self assert: expression relation = #OR.</body><body package="GlorpTests">testOrOperation2	| expression fred base |	fred := 'Fred'.	base := BaseExpression new.	expression := [:a | (a firstName = fred) OR: (a firstName ~= fred)] asGlorpExpressionOn: base.	self assert: expression class == RelationExpression.	self assert: expression relation = #OR.</body><body package="GlorpTests">testTwoLevelMappingExpressionIdentity	self assertIdentityOf: [:a | a someAttribute someAttribute] and: [:a | a someAttribute someAttribute].	self denyIdentityOf: [:a | a someAttribute someAttribute] and: [:a | a someAttribute].</body></methods><methods><class-id>Glorp.GlorpExpressionTest</class-id> <category>support</category><body package="GlorpTests">assertIdentityOf: aBlock and: anotherBlock	 	| base |	base := BaseExpression new.	self assert: (aBlock asGlorpExpressionOn: base) == (anotherBlock asGlorpExpressionOn: base)</body><body package="GlorpTests">denyIdentityOf: aBlock and: anotherBlock 	| base |	base := BaseExpression new.	self deny: (aBlock asGlorpExpressionOn: base) == (anotherBlock asGlorpExpressionOn: base)</body></methods><methods><class-id>Glorp.GlorpExpressionTest</class-id> <category>As yet unclassified</category><body package="GlorpTests">testIsNullPrint	| expression stream |	expression := [:cust | cust id = nil]		asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	stream := DatabaseCommand new session: system session.	expression printSQLOn: stream withParameters: Dictionary new.	self assert: '(GR_CUSTOMER.ID IS NULL)' equalsIgnoringOuterBrackets: expression sqlString.</body><body package="GlorpTests">testNotNullPrint	| expression stream |	expression := [:cust | cust id ~= nil]		asGlorpExpressionForDescriptor: (system descriptorFor: GlorpCustomer).	stream := DatabaseCommand new session: system session.	expression printSQLOn: stream withParameters: Dictionary new.	self assert: '(GR_CUSTOMER.ID IS NOT NULL)' equalsIgnoringOuterBrackets: stream contents.</body></methods><methods><class-id>Glorp.GlorpOrderedLinkDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForGlorpTravelFile: aDescriptor	| table |	table := self tableNamed: 'FILES'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name to: (table fieldNamed: 'name')</body><body package="GlorpTestModels">descriptorForGlorpTravelFolder: aDescriptor	| table linkTable unorderedTable |	table := self tableNamed: 'FOLDERS'.	linkTable := self tableNamed: 'FOLDER_FILES_LINK'.	unorderedTable := self tableNamed: 'UNORDERED_LINK'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping) from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping) from: #name		to: (table fieldNamed: 'name').	(aDescriptor toManyMapping)		attributeName: #files;		useLinkTable;		orderBy: [:e | (e getTable: 'FOLDER_FILES_LINK') getField: 'cindex'];		writeTheOrderField;		join: (Join from: (table fieldNamed: 'ID')					to: (linkTable fieldNamed: 'FOLDER_ID')).	(aDescriptor toManyMapping)		attributeName: #unordered;		useLinkTable;		join: (Join from: (table fieldNamed: 'ID')					to: (unorderedTable fieldNamed: 'FOLDER_ID')).</body></methods><methods><class-id>Glorp.GlorpOrderedLinkDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">tableForFILES: aTable	(aTable createFieldNamed: 'ID' type: platform sequence) bePrimaryKey.	aTable createFieldNamed: 'name' type: (platform varChar: 50)</body><body package="GlorpTestModels">tableForFOLDERS: aTable	(aTable createFieldNamed: 'ID' type: platform sequence) bePrimaryKey.	aTable createFieldNamed: 'name' type: (platform varChar: 50)</body><body package="GlorpTestModels">tableForFOLDER_FILES_LINK: aTable	"The chief purpose of this system is to explore what happens when we do not set primary keys, thus causing the cindex order field to pecome one of the 'all fields' primary key that is then computed."	| folderId fileId |	folderId := aTable createFieldNamed: 'FOLDER_ID' type: platform int4.	aTable addForeignKeyFrom: folderId to: ((self tableNamed: 'FOLDERS') fieldNamed: 'ID').	fileId := aTable createFieldNamed: 'FILE_ID' type: platform int4.	aTable addForeignKeyFrom: fileId to: ((self tableNamed: 'FILES') fieldNamed: 'ID').	aTable createFieldNamed: 'cindex' type: platform int.	folderId bePrimaryKey.	fileId bePrimaryKey.</body><body package="GlorpTestModels">tableForUNORDERED_LINK: aTable	| folderId fileId |	folderId := aTable createFieldNamed: 'FOLDER_ID' type: platform int4.	aTable addForeignKeyFrom: folderId		to: ((self tableNamed: 'FOLDERS') fieldNamed: 'ID').	fileId := aTable createFieldNamed: 'FILE_ID' type: platform int4.	aTable addForeignKeyFrom: fileId		to: ((self tableNamed: 'FILES') fieldNamed: 'ID')</body></methods><methods><class-id>Glorp.GlorpOrderedLinkDescriptorSystem</class-id> <category>initialize-release</category><body package="GlorpTestModels">constructAllClasses	^(super constructAllClasses)		add: GlorpTravelFolder;		add: GlorpTravelFile;		yourself</body><body package="GlorpTestModels">giveOrderedLinkTableNoPrimaryKeyFields	"The chief purpose of this system is to explore what happens when we do not set primary keys, thus causing the cindex order field to pecome one of the 'all fields' primary key that is then computed."	| table |	table := self tableNamed: 'FOLDER_FILES_LINK'.	(table fieldNamed: 'FOLDER_ID')		instVarNamed: 'isPrimaryKey' put: false.	(table fieldNamed: 'FILE_ID')		instVarNamed: 'isPrimaryKey' put: false.	table instVarNamed: 'primaryKeyFields' put: nil.</body></methods><methods><class-id>Glorp.GlorpOrderedLinkDescriptorSystem</class-id> <category>classes</category><body package="GlorpTestModels">classModelForGlorpTravelFile: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name</body><body package="GlorpTestModels">classModelForGlorpTravelFolder: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #files collectionOf: GlorpTravelFile.	aClassModel newAttributeNamed: #unordered collectionOf: GlorpTravelFile.</body></methods><methods><class-id>Glorp.GlorpOrderedLinkDescriptorSystem</class-id> <category>accessing</category><body package="GlorpTestModels">allTableNames	"Return a list of all the table names that this system uses."	^#('FOLDERS' 'FOLDER_FILES_LINK' 'UNORDERED_LINK' 'FILES')</body></methods><methods><class-id>Glorp.GlorpSessionTest</class-id> <category>support</category><body package="GlorpTests">addCustomerToCache	| customer |	customer := GlorpCustomer example1.	customer id: 3.	session cacheAt: 3 put: customer.	^customer</body><body package="GlorpTests">setUp	super setUp.	session := GlorpSession new.	session system: system</body></methods><methods><class-id>Glorp.GlorpSessionTest</class-id> <category>tests</category><body package="GlorpTests">helpTestUpdateWithExpiredExistingEntry: aCachePolicy	| customer customer2 row table unitOfWork |	(session system descriptorFor: GlorpCustomer) 		cachePolicy: aCachePolicy.	customer := self addCustomerToCache.	customer2 := GlorpCustomer new.	customer2 id: customer id.	customer2 name: 'Barney Rubble'.	row := DatabaseRow newForTable: (table := system tableNamed: 'GR_CUSTOMER').	row at: (table fieldNamed: 'ID') put: customer id.	unitOfWork := UnitOfWork new.	unitOfWork session: session.	"Since there's already an object there, this shouldn't do anything"	unitOfWork updateSessionCacheFor: customer2 withRow: row.	self assert: (session expiredInstanceOf: GlorpCustomer key: 3) == customer.</body><body package="GlorpTests">helpTestUpdateWithoutExpiredExistingEntry: aCachePolicy	| customer2 row table unitOfWork |	(session system descriptorFor: GlorpCustomer) 		cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	customer2 := GlorpCustomer new.	customer2 id: 3.	customer2 name: 'Barney Rubble'.	row := DatabaseRow newForTable: (table := system tableNamed: 'GR_CUSTOMER').	row at: (table fieldNamed: 'ID') put: 3.	unitOfWork := UnitOfWork new.	unitOfWork session: session.	unitOfWork updateSessionCacheFor: customer2 withRow: row.	self assert: (session expiredInstanceOf: GlorpCustomer key: 3) == customer2.</body><body package="GlorpTests">testAddingDescriptors	self assert: session system == system.	self assert: system session == session.	(session descriptorFor: GlorpAddress) session == session.</body><body package="GlorpTests">testDuplicateDetection	| customer customer2 |	session beginUnitOfWork.	customer := self addCustomerToCache.	customer2 := customer copy.	self should: [session register: customer2] raise: Dialect error.	session rollbackUnitOfWork.</body><body package="GlorpTests">testExecuteQuery	| q result |	q := GlorpQueryStub new result: 3.	result := session execute: q.	self assert: result = 3</body><body package="GlorpTests">testHasExpired1	| customer |	customer := self addCustomerToCache.	self deny: (session hasExpired: customer)</body><body package="GlorpTests">testHasExpired2	| customer |	(session system descriptorFor: GlorpCustomer) 		cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	customer := self addCustomerToCache.	self assert: (session hasExpired: customer)</body><body package="GlorpTests">testHasExpired3	| customer |	(session system descriptorFor: GlorpCustomer) 		cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	customer := self addCustomerToCache.	self assert: (session hasExpired: customer)</body><body package="GlorpTests">testHasObjectOfClassExpired1	self addCustomerToCache.	self deny: (session hasObjectExpiredOfClass: GlorpCustomer withKey: 3).</body><body package="GlorpTests">testHasObjectOfClassExpired2	(session system descriptorFor: GlorpCustomer) 		cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	self addCustomerToCache.	self assert: (session hasObjectExpiredOfClass: GlorpCustomer withKey: 3).</body><body package="GlorpTests">testSQLDeleteStringFor	| row table string |	table := session system tableNamed: 'GR_ADDRESS'.	row := DatabaseRow newForTable: table.	row at: (table fieldNamed: 'ID') put: 12.	row at: (table fieldNamed: 'STREET') put: 'some street'.	string := (DeleteCommand forRow: row useBinding: true session: session) sqlString.	self assert: string = 'DELETE FROM GR_ADDRESS WHERE ID = ?'.	string := (DeleteCommand forRow: row useBinding: false session: session) sqlString.	self assert: string = 'DELETE FROM GR_ADDRESS WHERE ID = 12'.</body><body package="GlorpTests">testUpdateWithExpiredExistingEntry	self helpTestUpdateWithExpiredExistingEntry: (TimedExpiryCachePolicy new timeout: 0; expiryAction: #refresh).</body><body package="GlorpTests">testUpdateWithExpiredExistingEntry2	self helpTestUpdateWithExpiredExistingEntry: (TimedStrongCachePolicy new timeout: 0; expiryAction: #refresh).</body><body package="GlorpTests">testUpdateWithoutExpiredExistingEntry	self helpTestUpdateWithoutExpiredExistingEntry: (TimedExpiryCachePolicy new timeout: 0).</body><body package="GlorpTests">testUpdateWithoutExpiredExistingEntry2	self helpTestUpdateWithoutExpiredExistingEntry: (TimedStrongCachePolicy new timeout: 0).</body></methods><methods><class-id>Glorp.GlorpJoinTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	expression := Join 		from: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID')		to: ((system tableNamed: 'CUSTOMER_ACCT_LINK') fieldNamed: 'ACCT_ID').	compoundExpression := Join		from: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID')		to: ((system tableNamed: 'PERSON') fieldNamed: 'NAME').	compoundExpression		addSource: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE')		target: ((system tableNamed: 'PERSON') fieldNamed: 'ADDRESS_ID').</body></methods><methods><class-id>Glorp.GlorpJoinTest</class-id> <category>tests</category><body package="GlorpTests">testAsExpressionCompound		| e personTable accountTable |	personTable := system tableNamed: 'PERSON'.	accountTable := system tableNamed: 'BANK_ACCT'.	e := compoundExpression asGeneralGlorpExpression.	self assert: (e isKindOf: RelationExpression).	self assert: e relation == #AND.	self assert: (e leftChild isKindOf: RelationExpression).	self assert: (e leftChild relation == #=).	self assert: (e leftChild leftChild isKindOf: FieldExpression).	self assert: e leftChild leftChild field == (personTable fieldNamed: 'NAME').	self assert: (e leftChild rightChild isKindOf: ParameterExpression).	self assert: e leftChild rightChild field == (accountTable fieldNamed: 'ID').	self assert: (e rightChild isKindOf: RelationExpression).	self assert: (e rightChild relation == #=).	self assert: (e rightChild leftChild isKindOf: FieldExpression).	self assert: e rightChild leftChild field == (personTable fieldNamed: 'ADDRESS_ID').	self assert: (e rightChild rightChild isKindOf: ParameterExpression).	self assert: e rightChild rightChild field = (accountTable fieldNamed: 'BANK_CODE').</body><body package="GlorpTests">testAsExpressionSingle		| e field param |	e := expression asGeneralGlorpExpression.	self assert: (e isKindOf: RelationExpression).	self assert: e relation == #=.	field := e leftChild.	self assert: (field isKindOf: FieldExpression).	self assert: field field == ((system tableNamed: 'CUSTOMER_ACCT_LINK') fieldNamed: 'ACCT_ID').	param := e rightChild.	self assert: (param isKindOf: ParameterExpression).	self assert: param field == ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID').</body><body package="GlorpTests">testCompoundSQLPrinting	| stream params|	stream := WriteStream on: (String new: 100).	params := Dictionary new.	params at: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID') put: 1.	params at: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'BANK_CODE') put: 3.	compoundExpression printSQLOn: stream withParameters: params.	self assert: stream contents = 'PERSON.NAME = 1 AND PERSON.ADDRESS_ID = 3'.</body><body package="GlorpTests">testCreation	self assert: expression allSourceFields size = 1.	self assert: expression allSourceFields first == ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID').</body><body package="GlorpTests">testParameterCount	self assert: expression numberOfParameters = 1.	self assert: compoundExpression numberOfParameters = 2.</body><body package="GlorpTests">testSQLPrinting	| stream params |	stream := WriteStream on: (String new: 100).	params := Dictionary new.	params at: ((system tableNamed: 'BANK_ACCT') fieldNamed: 'ID') put: 'abc'.	expression printSQLOn: stream withParameters: params.	self assert: stream contents = 'CUSTOMER_ACCT_LINK.ACCT_ID = ''abc'''</body></methods><methods><class-id>Glorp.GlorpMappingTest</class-id> <category>tests</category><body package="GlorpTests">helperForMergedOneToOneReversingWriteOrder: aBoolean 	| account accountTable row |	account := GlorpBankExampleSystem new objectNumber: 1 ofClass: GlorpBankAccount.	accountTable := system tableNamed: 'BANK_ACCT'.	aBoolean 		ifTrue: 			[self write: account.			self write: account accountNumber]		ifFalse: 			[self write: account accountNumber.			self write: account].	self assert: (rowMap includesRowForTable: accountTable withKey: account).	self assert: (rowMap includesRowForTable: accountTable				withKey: account accountNumber).	row := self rowFor: account.	self assert: (row at: (accountTable fieldNamed: 'ID')) = account id.	(Array with: row with: (self rowFor: account accountNumber)) do: 			[:each | 			self assert: (each at: (accountTable fieldNamed: 'BANK_CODE')) 						= account accountNumber bankCode.			self assert: (each at: (accountTable fieldNamed: 'BRANCH_NO')) 						= account accountNumber branchNumber.			self assert: (each at: (accountTable fieldNamed: 'ACCT_NO')) 						= account accountNumber accountNumber].	self assert: (rowMap numberOfEntriesForTable: accountTable) = 2</body><body package="GlorpTests">helperForNestedMergedOneToOneReversingWriteOrder: aBoolean 	| trans transTable moneyTable row fieldNames fieldValues |	trans := GlorpBankExampleSystem new objectNumber: 1				ofClass: GlorpBankTransaction.	transTable := system tableNamed: 'BANK_TRANS'.	moneyTable := system tableNamed: 'MONEY_IMAGINARY_TABLE'.	aBoolean 		ifTrue: 			[self write: trans.			self write: trans amount.			self write: trans serviceCharge.			self write: trans serviceCharge amount]		ifFalse: 			[self write: trans serviceCharge amount.			self write: trans serviceCharge.			self write: trans amount.			self write: trans].	self 		assert: (rowMap rowForTable: transTable withKey: trans) shouldBeWritten.	self 		assert: (rowMap rowForTable: transTable withKey: trans serviceCharge) 				shouldBeWritten not.	self 		assert: (rowMap rowForTable: moneyTable withKey: trans amount) 				shouldBeWritten not.	self 		assert: (rowMap rowForTable: moneyTable withKey: trans serviceCharge amount) 				shouldBeWritten not.	row := self rowFor: trans.	self assert: (row at: (transTable fieldNamed: 'ID')) = trans id.	fieldNames := #('AMT_CURR' 'AMT_AMT' 'SRVC_DESC' 'SRVC_AMT_CURR' 'SRVC_AMT_AMT').	fieldValues := (Array 				with: trans amount currency asString				with: trans amount amount				with: trans serviceCharge description) 					, (Array with: trans serviceCharge amount currency asString							with: trans serviceCharge amount amount).	fieldNames with: fieldValues		do: [:fieldName :value | self assert: (row at: (transTable fieldNamed: fieldName)) = value].	self assert: (rowMap numberOfEntriesForTable: transTable) = 2.	self assert: (rowMap numberOfEntriesForTable: moneyTable) = 2</body><body package="GlorpTests">testManyToMany	| customer customerTable accountTable linkTable linkRow |	customer := GlorpBankExampleSystem new objectNumber: 1 ofClass: GlorpCustomer.	rowMap := RowMap new.	customerTable := system tableNamed: 'GR_CUSTOMER'.	accountTable := system tableNamed: 'BANK_ACCT'.	linkTable := system tableNamed: 'CUSTOMER_ACCT_LINK'.	self write: customer.	customer accounts do: [:each | 		self write: each].	self assert: (rowMap includesRowForTable: customerTable withKey: customer).	customer accounts do: [:each |		self assert: (rowMap includesRowForTable: accountTable withKey: each).		self assert: (rowMap includesRowForTable: linkTable withKey: (RowMapKey new key1: customer; key2: each))].	customer accounts do: [:each | | rowMapKey |		self assert: ((self rowFor: each) at: (accountTable fieldNamed: 'ID')) = each id.		rowMapKey := RowMapKey new key1: customer; key2: each.		linkRow := rowMap rowForTable: linkTable withKey: rowMapKey.		self assert: (linkRow at: (linkTable fieldNamed: 'ACCT_ID')) = each id.		self assert: (linkRow at: (linkTable fieldNamed: 'CUSTOMER_ID')) = customer id.		].	self assert: ((self rowFor: customer) at: (customerTable fieldNamed: 'ID')) = customer id.	self assert: ((rowMap numberOfEntriesForTable: linkTable) = 2).	self assert: ((rowMap numberOfEntriesForTable: customerTable) = 1).</body><body package="GlorpTests">testMergedOneToOne	self helperForMergedOneToOneReversingWriteOrder: false</body><body package="GlorpTests">testMergedOneToOneReversingWrites	self helperForMergedOneToOneReversingWriteOrder: true</body><body package="GlorpTests">testMissingDescriptor	self assert: (system descriptorFor: nil) isNil.	self assert: (system descriptorFor: UndefinedObject) isNil.	self assert: (system descriptorFor: 3) isNil</body><body package="GlorpTests">testMultipleTableCreation		| descriptor table passenger table2 row1 row2 |	descriptor := system descriptorFor: GlorpPassenger.	passenger := GlorpPassenger example1.	rowMap := RowMap new.	table := system existingTableNamed: 'PASSENGER'.	table2 := system existingTableNamed: 'FREQUENT_FLYER'.	descriptor createRowsFor: passenger in: rowMap.	self assert: (rowMap includesRowForTable: table withKey: passenger).	self assert: (rowMap includesRowForTable: table2 withKey: passenger).	row1 := rowMap rowForTable: table withKey: passenger.	self assert: (row1 at: (table fieldNamed: 'ID'))			= passenger id.	self assert: (row1 at: (table fieldNamed: 'NAME'))			= passenger name.	row2 := rowMap rowForTable: table2 withKey: passenger.	self assert: (row2 at: (table2 fieldNamed: 'ID'))			= passenger id.	self assert: (row2 at: (table2 fieldNamed: 'POINTS')) = passenger frequentFlyerPoints.	self assert: rowMap numberOfEntries = 3</body><body package="GlorpTests">testMultipleTableCreationWithOneMissing		| descriptor table passenger table2 row1 |	descriptor := system descriptorFor: GlorpPassenger.	passenger := GlorpPassenger example1.	passenger frequentFlyerPoints: nil.	passenger airline: nil.	rowMap := RowMap new.	table := system existingTableNamed: 'PASSENGER'.	table2 := system existingTableNamed: 'FREQUENT_FLYER'.	descriptor createRowsFor: passenger in: rowMap.	self assert: (rowMap includesRowForTable: table withKey: passenger).	self deny: (rowMap includesRowForTable: table2 withKey: passenger).	row1 := rowMap rowForTable: table withKey: passenger.	self assert: (row1 at: (table fieldNamed: 'ID'))			= passenger id.	self assert: (row1 at: (table fieldNamed: 'NAME'))			= passenger name.	self assert: rowMap numberOfEntries = 1.</body><body package="GlorpTests">testNestedMergedOneToOne	self helperForNestedMergedOneToOneReversingWriteOrder: false</body><body package="GlorpTests">testNestedMergedOneToOneReversingWriteOrder	self helperForNestedMergedOneToOneReversingWriteOrder: true.</body><body package="GlorpTests">testNilOneToOne		| person  personTable addressTable |	person := GlorpPerson example1.	person address: nil.	self write: person.	self write: person address.	personTable := system existingTableNamed: 'PERSON'.	addressTable := system existingTableNamed: 'GR_ADDRESS'.	self assert: (rowMap includesRowForTable: personTable withKey: person).	self deny: (rowMap includesRowForTable: addressTable withKey: person address).	self assert: rowMap numberOfEntries = 1.</body><body package="GlorpTests">testOneToMany	| customer customerTable transactionTable |	customer := GlorpCustomer example1.	rowMap := RowMap new.	customerTable := system tableNamed: 'GR_CUSTOMER'.	transactionTable := system tableNamed: 'BANK_TRANS'.	self write: customer.	customer transactions do: [:each |		self write: each].	self assert: (rowMap includesRowForTable: customerTable withKey: customer).	customer transactions do: [:each |		self assert: (rowMap includesRowForTable: transactionTable withKey: each)].	customer transactions do: [:each |		self assert: ((self rowFor: each) at: (transactionTable fieldNamed: 'OWNER_ID')) = customer id].	self assert: ((self rowFor: customer) at: (customerTable fieldNamed: 'ID')) = customer id.</body><body package="GlorpTests">testOneToOne		| person  personTable addressTable |	person := GlorpPerson example1.	self write: person.	self write: person address.	personTable := system existingTableNamed: 'PERSON'.	addressTable := system existingTableNamed: 'GR_ADDRESS'.	self assert: (rowMap includesRowForTable: personTable withKey: person).	self assert: (rowMap includesRowForTable: addressTable withKey: person address).	self assert: ((self rowFor: person address) at: (addressTable fieldNamed: 'ID')) = person address id.	self assert: ((self rowFor: person) at: (personTable fieldNamed: 'ADDRESS_ID')) = person address id.	self assert: rowMap numberOfEntries = 2.</body><body package="GlorpTests">testOneToOneWithProxy	| person  personTable addressTable proxy stub |	person := GlorpPerson example1.	proxy := Proxy new.	proxy session: GlorpSession new.	stub := GlorpQueryStub readOneOf: GlorpAddress where: [:address | address id = 1].	stub result: person address.	proxy query: stub.	person address: proxy.	self deny: person address isInstantiated.	self write: person.	personTable := system existingTableNamed: 'PERSON'.	addressTable := system existingTableNamed: 'GR_ADDRESS'.	self assert: (rowMap includesRowForTable: personTable withKey: person).	self deny: (rowMap includesRowForTable: addressTable withKey: person address).	self deny: ((self rowFor: person) hasValueFor: (personTable fieldNamed: 'ADDRESS_ID')).	self assert: rowMap numberOfEntries = 1.</body><body package="GlorpTests">testRowCreation	| descriptor person row table  |	descriptor := system descriptorFor: GlorpPerson.	person := GlorpPerson example1.	rowMap := RowMap new.	table := system existingTableNamed: 'PERSON'.	descriptor createRowsFor: person in: rowMap.	self assert: (rowMap includesRowForTable: table withKey: person).	row := rowMap rowForTable: table withKey: person.	self assert: (row at: (table fieldNamed: 'ID')) = person id.	self assert: (row at: (table fieldNamed: 'NAME')) = person name.	self assert: rowMap numberOfEntries = 2.</body></methods><methods><class-id>Glorp.GlorpMappingTest</class-id> <category>support</category><body package="GlorpTests">rowFor: anObject	| descriptor |	descriptor := system descriptorFor: anObject.	descriptor isNil ifTrue: [^nil].	^rowMap rowForTable: descriptor table withKey: anObject.</body><body package="GlorpTests">setUp	super setUp.	rowMap := RowMap new.</body><body package="GlorpTests">write: anObject	| descriptor |	descriptor := system descriptorFor: anObject. 	descriptor isNil ifTrue: [^self].	descriptor createRowsFor: anObject in: rowMap.</body></methods><methods><class-id>Glorp.GlorpCacheTest</class-id> <category>tests</category><body package="GlorpTests">testDuplicates 	| c1 c2 |	c1 := GlorpCustomer example1.	c2 := GlorpCustomer example1.	cache at: 3 insert: c1.	cache at: 3 insert: c2.	self assert: (cache lookupClass: GlorpCustomer key: 3) = c1.</body><body package="GlorpTests">testDuplicatesDifferentClasses	| cust trans |	cust := GlorpCustomer example1.	trans := GlorpBankTransaction example1.	cache at: 3 insert: cust.	cache at: 3 insert: trans.	self assert: (cache lookupClass: GlorpCustomer key: 3) = cust.	self assert: (cache lookupClass: GlorpBankTransaction key: 3) = trans.</body><body package="GlorpTests">testInsert	| customer |	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3) == customer</body><body package="GlorpTests">testManualExpireAll	| customer customer2 readBackCustomer |	system cachePolicy: TimedExpiryCachePolicy new.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	cache expireAll.	readBackCustomer := session readOneOf: GlorpCustomer where: [:each | each id = 3].	self assert: readBackCustomer isNil.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	customer2 := GlorpCustomer new.	cache at: 3 insert: customer2.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer2.</body><body package="GlorpTests">testManualExpiry	| customer customer2 readBackCustomer |	system cachePolicy: TimedExpiryCachePolicy new.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	cache expireClass: GlorpCustomer key: 3 ifAbsent: [self error: 'wrong'].	readBackCustomer := session readOneOf: GlorpCustomer where: [:each | each id = 3].	self assert: readBackCustomer isNil.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	customer2 := GlorpCustomer new.	cache at: 3 insert: customer2.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer2.</body><body package="GlorpTests">testRemove	| customer |	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3) == customer.	cache removeClass: GlorpCustomer key: 3 ifAbsent: [ self signalFailure: 'Item was not in cache.' ].	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: []) == nil.</body></methods><methods><class-id>Glorp.GlorpCacheTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	system cachePolicy: CachePolicy new.	session := GlorpSessionResource current newSession.	session system: system.	cache := session privateGetCache.</body><body package="GlorpTests">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpCacheTest class</class-id> <category>Accessing</category><body package="GlorpTests">resources	^Array with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpAttachment</class-id> <category>accessing</category><body package="GlorpTestModels">attachmentBytes	^attachmentBytes</body><body package="GlorpTestModels">attachmentBytes: anObject	attachmentBytes := anObject</body><body package="GlorpTestModels">index	^index</body><body package="GlorpTestModels">index: anObject	index := anObject</body><body package="GlorpTestModels">mimeType	^mimeType</body><body package="GlorpTestModels">mimeType: anObject	mimeType := anObject</body></methods><methods><class-id>Glorp.GlorpAttachment class</class-id> <category>glorp</category><body package="GlorpTestModels">glorpSetupClassModel: model forSystem: system 	model		newAttributeNamed: #index;		newAttributeNamed: #mimeType;		newAttributeNamed: #attachmentBytes type: GlorpAttachmentBytes</body><body package="GlorpTestModels">glorpSetupDescriptor: aDesc forSystem: system 	| t |	t := system tableNamed: 'attachment'.	aDesc table: t.	(aDesc newMapping: DirectMapping) from: #index		to: (t fieldNamed: 'indexInDocument').	(aDesc newMapping: DirectMapping) from: #mimeType		to: (t fieldNamed: 'mimetype').	(aDesc newMapping: OneToOneMapping) attributeName: #attachmentBytes</body></methods><methods><class-id>Glorp.GlorpAdHocMappingTest</class-id> <category>tests</category><body package="GlorpTests">moneyNegatingMappingTo: amountField in: aDescriptor 	mapping := aDescriptor newMapping: AdHocMapping.	mapping		forAttribute: #amount		fromDb: [:row :elementBuilder :context | (elementBuilder valueOfField: (context translateField: amountField)) negated]		toDb: [:rows :attribute :attributeRows | (rows at: table) at: amountField put: attribute negated]		mappingFields: (Array with: amountField).	^mapping.</body><body package="GlorpTests">testNegateMappingRead	| amountField inputRow builder |	descriptor := system descriptorFor: GlorpMoney.	table := system tableNamed: 'MONEY_IMAGINARY_TABLE'.	amountField := table fieldNamed: 'AMOUNT'.	mapping := self moneyNegatingMappingTo: amountField in: descriptor.	descriptor addMapping: mapping.	money := GlorpMoney basicNew.	inputRow := #('US' 1).	builder := ElementBuilder new.	builder row: inputRow.	mapping mapObject: money inElementBuilder: builder.	self assert: money amount = -1.</body><body package="GlorpTests">testNegateMappingWrite	| amountField outputRow |	descriptor := system descriptorFor: GlorpMoney.	table := system tableNamed: 'MONEY_IMAGINARY_TABLE'.	amountField := table fieldNamed: 'AMOUNT'.	mapping := self moneyNegatingMappingTo: amountField in: descriptor.	descriptor table: table.	descriptor addMapping: mapping.	money := GlorpMoney forAmount: 3.	rowMap := RowMap new.	mapping mapFromObject: money intoRowsIn: rowMap.	outputRow := rowMap rowForTable: table withKey: money.	self assert: (outputRow at: (table fieldNamed: 'AMOUNT')) = -3</body><body package="GlorpTests">testSplitMappingRead	| inputRow builder |	money := GlorpCompressedMoney basicNew.	mapping := (system descriptorFor: GlorpCompressedMoney)		mappingForAttributeNamed: #array.	inputRow := #(432 'US' 1).	builder := ElementBuilder new.	builder row: inputRow.	mapping mapObject: money inElementBuilder: builder.	self assert: money amount = 1.	self assert: money currency = 'US'.</body><body package="GlorpTests">testSplitMappingWrite	| outputRow |	money := GlorpCompressedMoney currency: 'DM' amount: 99.	mapping := (system descriptorFor: GlorpCompressedMoney) 				mappingForAttributeNamed: #array.	rowMap := RowMap new.	mapping mapFromObject: money intoRowsIn: rowMap.	table := mapping descriptor primaryTable.	outputRow := rowMap rowForTable: table withKey: money.	self assert: (outputRow at: (table fieldNamed: 'AMOUNT')) = 99.	self assert: (outputRow at: (table fieldNamed: 'CURRENCY_NAME')) = 'DM'</body></methods><methods><class-id>Glorp.ClassQ</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassQ	^attrAClassQ</body><body package="GlorpTestModels">attrAClassQ: anObject	attrAClassQ := anObject</body><body package="GlorpTestModels">attrBClassQ	^attrBClassQ</body><body package="GlorpTestModels">attrBClassQ: anObject	attrBClassQ := anObject</body></methods><methods><class-id>Glorp.GlorpQueryCopyingTest</class-id> <category>tests</category><body package="GlorpTests">testExpressionTableAliases	query prepare.	newQuery := query copy.	self assert: (self tableAliasesPresentFor: query).	self deny: (self tableAliasesPresentFor: newQuery).</body><body package="GlorpTests">testPreparedness	self deny: query isPrepared.	query prepare.	newQuery := query copy.	self assert: query isPrepared.	self deny: newQuery isPrepared.</body></methods><methods><class-id>Glorp.GlorpQueryCopyingTest</class-id> <category>As yet unclassified</category><body package="GlorpTests">tableAliasesPresentFor: aQuery	aQuery whereClause detect: [:each | each hasTableAliases] ifNone: [^false].	^true.</body></methods><methods><class-id>Glorp.GlorpQueryCopyingTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	query := Query read: GlorpCustomer.	query whereClause: [:each | each accounts anySatisfy: [:foo | foo id = 12]].	session := GlorpSessionResource current newSession.	query session: session.</body></methods><methods><class-id>Glorp.GlorpQueryCopyingTest class</class-id> <category>resources</category><body package="GlorpTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpPerson</class-id> <category>accessing</category><body package="GlorpTestModels">address	"Private - Answer the value of the receiver's ''address'' instance variable."	^address</body><body package="GlorpTestModels">address: anObject	"Private - Set the value of the receiver's ''address'' instance variable to the argument, anObject."	address := anObject</body><body package="GlorpTestModels">emailAddresses	^emailAddresses</body><body package="GlorpTestModels">emailAddresses: aCollection	emailAddresses := aCollection</body><body package="GlorpTestModels">hasEmail	^hasEmail</body><body package="GlorpTestModels">hasEmail: aBoolean	hasEmail := aBoolean</body><body package="GlorpTestModels">id	"Private - Answer the value of the receiver's ''id'' instance variable."	^id</body><body package="GlorpTestModels">id: anObject	"Private - Set the value of the receiver's ''id'' instance variable to the argument, anObject."	id := anObject</body><body package="GlorpTestModels">name	"Private - Answer the value of the receiver's ''name'' instance variable."	^name</body><body package="GlorpTestModels">name: anObject	"Private - Set the value of the receiver's ''name'' instance variable to the argument, anObject."	name := anObject</body></methods><methods><class-id>Glorp.GlorpPerson</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '('.	aStream nextPutAll: id printString, ',', (name ifNil: ['']).	aStream nextPutAll: ')'.</body></methods><methods><class-id>Glorp.GlorpPerson class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: GlorpAddress example1.</body><body package="GlorpTestModels">example1WithChangedAddress	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: GlorpAddress example1WithChangedAddress.</body><body package="GlorpTestModels">example1WithDifferentAddress	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: GlorpAddress example2.</body><body package="GlorpTestModels">example1WithDifferentName	^self new		id: 1; 		name: 'John Doe';		address: GlorpAddress example1.</body><body package="GlorpTestModels">example1WithNoAddress	^self new		id: 1;		name: 'Zaphod Beeblebrox';		address: nil.</body><body package="GlorpTestModels">example2	^self new		id: 2;		name: 'John Doe';		address: GlorpAddress example2.</body></methods><methods><class-id>Glorp.GlorpEncyclopediaBioEntry</class-id> <category>accessing</category><body package="GlorpTestModels">text	^text</body><body package="GlorpTestModels">text: anObject	text := anObject</body><body package="GlorpTestModels">title	^title</body><body package="GlorpTestModels">title: anObject	title := anObject</body></methods><methods><class-id>Glorp.GlorpEncyclopediaBioEntry</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize</body></methods><methods><class-id>Glorp.GlorpEncyclopediaBioEntry class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpDescriptorSystemWithNamespacePoolDictionaryDeclarer class</class-id> <category>VA compatibility</category><body package="GlorpTestModels">_PRAGMA_GlorpTestNamespace	"%%PRAGMA DECLARE	(name: GlorpTestNamespace isPool: true isConstant: true)	(pool: GlorpTestNamespace declarations: (		))"</body><body package="GlorpTestModels">initialize	"If this is VA, force the pool dictionary/namespace pragma for the test namespace to be handled. That means that subsequent packages on file-in will be able to see it. A lot of jumping through hoops for something that doesn't even get exercised in VA"	Dialect isVisualAge ifFalse: [^self].	(Smalltalk at: #EtAbstractMethodsBrowser) new		rebuildNamespaceIfRequired: (Smalltalk at: #GlorpTestModels)		askUser: false.</body></methods><methods><class-id>Glorp.GlorpDescriptorValidationTest</class-id> <category>testing</category><body package="GlorpTests">testJoinDirection	| descriptor table1 table2 mapping system descriptor2 |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	descriptor2 := system addEmptyDescriptorFor: GlorpVideoStore.	table1 := DatabaseTable named: 'Table1'.	table1 createFieldNamed: 'one' type: nil.	table2 := DatabaseTable named: 'Table2'.	table2 createFieldNamed: 'two' type: nil.	descriptor addTable: table1.	descriptor2  addTable: table2.	mapping := descriptor newMapping: OneToOneMapping.	mapping attributeName: #accounts.	mapping referenceClass: GlorpVideoStore.	mapping join: (Join from: (table1 fieldNamed: 'one') to: (table2 fieldNamed: 'two')).	mapping validate.	mapping := descriptor newMapping: OneToOneMapping.	mapping attributeName: #bar.	mapping referenceClass: GlorpVideoStore.	mapping join: (Join from: (table2 fieldNamed: 'two') to: (table1 fieldNamed: 'one')).	self should: [mapping validate] raise: Dialect error.</body><body package="GlorpTests">testValidateDirectInstvarAccessExisting	| descriptor table mapping system field |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	table := DatabaseTable named: 'Table1'.	field := table createFieldNamed: 'one' type: OraclePlatform new integer.	descriptor addTable: table.	mapping := descriptor newMapping: DirectMapping.	mapping from: #id to: field.	mapping validate</body><body package="GlorpTests">testValidateDirectInstvarAccessNonExisting	| descriptor table mapping system field |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	table := DatabaseTable named: 'Table1'.	field := table createFieldNamed: 'one' type: OraclePlatform new integer.	descriptor addTable: table.	mapping := descriptor newMapping: DirectMapping.	mapping from: #bar to: field.	self should: [mapping validate] raise: Dialect error</body><body package="GlorpTests">testValidateSelectorAccessExisting	| descriptor table mapping system field |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	table := DatabaseTable named: 'Table1'.	field := table createFieldNamed: 'one' type: OraclePlatform new integer.	descriptor addTable: table.	mapping := descriptor newMapping: DirectMapping.	mapping from: #id to: field.	mapping attribute useDirectAccess: false.	mapping validate</body><body package="GlorpTests">testValidateSelectorAccessNonExisting	| descriptor table mapping system field |	system := DynamicDescriptorSystem new.	descriptor := system addEmptyDescriptorFor: GlorpCustomer.	table := DatabaseTable named: 'Table1'.	field := table createFieldNamed: 'one' type: OraclePlatform new integer.	descriptor addTable: table.	mapping := descriptor newMapping: DirectMapping.	mapping from: #foo to: field.	mapping attribute useDirectAccess: false.	self should: [mapping validate] raise: Dialect error</body><body package="GlorpTests">testValidatingExistingDescriptors	| session |	session := GlorpSessionResource current newSession.	GlorpTestDescriptorSystem allSubclasses do:		[:each |		session system: (each forPlatform: OraclePlatform new).		session system validate].</body></methods><methods><class-id>Glorp.GlorpBookstoreCustomer</class-id> <category>accessing</category><body package="GlorpTestModels">accountNumber	^accountNumber</body><body package="GlorpTestModels">accountNumber: anObject	accountNumber := anObject</body><body package="GlorpTestModels">booksOnOrder	^booksOnOrder</body><body package="GlorpTestModels">booksOnOrder: someBooks	booksOnOrder := someBooks.</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpBookstoreCustomer</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	booksOnOrder := OrderedCollection new.</body></methods><methods><class-id>Glorp.GlorpBookstoreCustomer class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize.</body></methods><methods><class-id>Glorp.GlorpFakeElementBuilder</class-id> <category>element builder protocol</category><body package="GlorpTests">valueOf: aField	^value.</body><body package="GlorpTests">valueOfField: aField in: anArray	^value.</body></methods><methods><class-id>Glorp.GlorpFakeElementBuilder</class-id> <category>accessing</category><body package="GlorpTests">value: anObject	value := anObject.</body></methods><methods><class-id>Glorp.GlorpNoProxyCollectionReadTest</class-id> <category>tests</category><body package="GlorpTests">testReadCollectionWithoutProxies	| persons session |	session := GlorpSessionResource current newSession.	session platform supportsMultipleOpenCursors ifFalse: [^self].	(session system descriptorFor: GlorpPerson) mappings do:		[:each | (each respondsTo: #shouldProxy:) ifTrue: [each shouldProxy: false]].	session beginTransaction.	[session beginUnitOfWork.	session register: GlorpPerson example1.	session register: GlorpPerson example2.	session commitUnitOfWork.	session reset.	persons := session read: GlorpPerson.	self assert: persons size = 2] ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortTest</class-id> <category>support</category><body package="GlorpTests">assertSortOrder: aCollection	| ids |	ids := (sorted collect: [:each | each id]) asArray.	self assert: ids = aCollection asArray.</body><body package="GlorpTests">sort	| sorter |	sorter := GlorpRowSorter new getChildrenVia: #relatedItems.	sorted := sorter sort: unsorted.</body><body package="GlorpTests">sort: aCollection	unsorted := aCollection.	self sort.</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortTest</class-id> <category>tests</category><body package="GlorpTests">testBasicSort1	self sort: self data1.	self assertSortOrder: #(3 2 1).</body><body package="GlorpTests">testBasicSort2	"Try it with a different initial order. The sort is a convoluted way of writing the questionably-portable reverse"	self sort: (self data1 asSortedCollection: [:a :b | a id &gt;= b id]).	self assertSortOrder: #(3 2 1).</body><body package="GlorpTests">testBasicSortCompleteGraph	| one two three |	one := GlorpBreadthFirstTopologicalSortItem new id: 1.	two := GlorpBreadthFirstTopologicalSortItem new id: 2.	three := GlorpBreadthFirstTopologicalSortItem new id: 3.	one relateTo: two.	one relateTo: three.	three relateTo: two.	three relateTo: one.	two relateTo: three.	two relateTo: one.	self sort: (Array with: one with: two with: three).	self assert: sorted size = 3.</body><body package="GlorpTests">testMedium1	self sort: self dataForMedium.	self assertSortOrder: #('c1' 'a2' 'b1' 'a1' 'c3' 'a4' 'b3' 'a3' 'b2' 'b4' 'c2' 'c4').</body><body package="GlorpTests">testNoCyclesMedium	self sort: self dataForNoCyclesMedium.	self assertSortOrder: #('c1' 'c2' 'c3' 'c4' 'b1' 'b2' 'b3' 'b4' 'a1' 'a2' 'a3' 'a4').</body><body package="GlorpTests">testNoCyclesMediumPermuted	self sort: self dataForNoCyclesMediumPermuted.	self assertSortOrder: #('c1' 'b1' 'c2' 'b2' 'c3' 'b3' 'c4' 'b4' 'a1' 'a2' 'a3' 'a4').</body></methods><methods><class-id>Glorp.GlorpBreadthFirstTopologicalSortTest</class-id> <category>data</category><body package="GlorpTests">data1	| one two three |	one := GlorpBreadthFirstTopologicalSortItem new id: 1.	two := GlorpBreadthFirstTopologicalSortItem new id: 2.	three := GlorpBreadthFirstTopologicalSortItem new id: 3.	one relateTo: two.	two relateTo: three.	^Array with: one with: two with: three.</body><body package="GlorpTests">dataForGroupNamed: aString	| one two three four |	one := GlorpBreadthFirstTopologicalSortItem new id: aString, '1'.	two := GlorpBreadthFirstTopologicalSortItem new id: aString, '2'.	three := GlorpBreadthFirstTopologicalSortItem new id: aString, '3'.	four := GlorpBreadthFirstTopologicalSortItem new id: aString, '4'.	^Array with: one with: two with: three with: four.</body><body package="GlorpTests">dataForMedium	"Data to ensure that things tend to stay together.  This is a simple grouping a1-&gt;b, b-&gt;c, b-&gt;a2, repeated, with some extra floating b's and c's."	groupA := self dataForGroupNamed: 'a'.	groupB := self dataForGroupNamed: 'b'.	groupC := self dataForGroupNamed: 'c'.	groupA first relateTo: groupB first.	(groupA at: 3) relateTo: (groupB at: 3).	groupB first relateTo: groupC first.	(groupB at: 3) relateTo: (groupC at: 3).	groupB first relateTo: (groupA at: 2).	(groupB at: 3) relateTo: (groupA at: 4).	^groupA, groupB, groupC.</body><body package="GlorpTests">dataForNoCyclesMedium	"Data to ensure that things tend to stay together.  This is a simple grouping a-&gt;b, b-&gt;c repeated"	groupA := self dataForGroupNamed: 'a'.	groupB := self dataForGroupNamed: 'b'.	groupC := self dataForGroupNamed: 'c'.	1 to: 4 do: [:i |		(groupA at: i) relateTo: (groupB at: i).		(groupB at: i) relateTo: (groupC at: i)].	^groupC, groupB, groupA.</body><body package="GlorpTests">dataForNoCyclesMediumPermuted	"Data to ensure that things tend to stay together.  This is a simple grouping a-&gt;b, b-&gt;c repeated"	groupA := self dataForGroupNamed: 'a'.	groupB := self dataForGroupNamed: 'b'.	groupC := self dataForGroupNamed: 'c'.	1 to: 4 do: [:i |		(groupA at: i) relateTo: (groupB at: i).		(groupB at: i) relateTo: (groupC at: i)].	^groupB, groupA, groupC.</body></methods><methods><class-id>Glorp.GlorpNullCommand</class-id> <category>accessing</category><body package="GlorpTests">sqlString	^stream contents.</body></methods><methods><class-id>Glorp.GlorpNullCommand</class-id> <category>testing</category><body package="GlorpTests">succeeded	^true.</body></methods><methods><class-id>Glorp.GlorpNullCommand class</class-id> <category>As yet unclassified</category><body package="GlorpTests">useBinding: aBoolean session: aSession	^(self new)		useBinding: aBoolean;		session: aSession;		yourself.</body></methods><methods><class-id>Glorp.GlorpFilteredInheritanceTest</class-id> <category>tests</category><body package="GlorpTests">compareEmployees: employees	employees do: [:each |		| corresponding |		corresponding := allEmployees detect: [:eachOriginal | each id = eachOriginal id].		self assert: corresponding = each].</body><body package="GlorpTests">makeSupertaxIn: aCollection	| previous newTax |	previous := aCollection last.	newTax := (GlorpBasicTax new)		name: (String with: (Character value: previous name first asInteger + 1));		yourself.	previous addTax: newTax.	aCollection add: newTax.</body><body package="GlorpTests">testCacheLookup	"Ask for an Employee which should be from the cache and which should return a Manager."	| manager employee |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	manager := session readOneOf: GlorpManager				where: [:each | each id = 3 ].	self assert: (session cacheLookupForClass: GlorpEmployee key: 3) == manager.	employee := session readOneOf: GlorpEmployee				where: [:each | each id = 3 ].	self assert: employee == manager.	manager := session readOneOf: GlorpRegionalManager				where: [:each | each id = 12 ].	employee := session readOneOf: GlorpEmployee				where: [:each | each id = 12 ].	self assert: employee == manager.	employee := session readOneOf: GlorpManager				where: [:each | each id = 11 ].	manager := session readOneOf: GlorpEmployee				where: [:each | each id = 11 ].	self assert: employee == manager.	"Test that the cache refuses to return an object which is not of the proper class or subclass."	employee := session readOneOf: GlorpEmployee				where: [:each | each id = 4 ].	self assert: (session privateGetCache lookupClass: GlorpRegionalManager key: 4 ifAbsent: []) isNil.	manager := session readOneOf: GlorpRegionalManager				where: [:each | each id = 4 ].	self assert: manager isNil.	"Proxys seem to try a cache lookup before they execute their query...can we write a test which fails due to this?"] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests">testDirectQuery	"Ask for all Employees, see if we get subclasses too"	| employees offices |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	employees := true 				ifTrue: [session read: GlorpEmployee where: [:each | each name = 'Bob']]				ifFalse: [session halt read: GlorpEmployee].	self assert: employees size = 8.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpEmployee]) size = 1.	self assert: (employees select: [:emp | emp isMemberOf: GlorpManager]) size = 2.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpLineWorker]) size = 4.	self 		assert: (employees select: [:emp | emp isMemberOf: GlorpRegionalManager]) size 				= 1.	self compareEmployees: employees.	session initializeCache.	offices := session readOneOf: GlorpOffice				where: [:each | each employeeOfMonth name = 'Bob'].	"There is no regional manager with id = 4 but we can ensure that the type info is getting into the query's key by asking for one and seeing that it doesn't exist"	session initializeCache.	self 		assert: (session readOneOf: GlorpRegionalManager where: [:each | each id = 4]) 				== nil] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests">testDirectQuery2	"Ask for all Employees, see if we get subclasses too."	| employees contractors |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	employees := session read: GlorpEmployee.	self assert: employees size = 13.	self assert: (employees select: [:emp | emp isMemberOf: GlorpEmployee]) size = 2.	self assert: (employees select: [:emp | emp isMemberOf: GlorpManager]) size = 3.	self assert: (employees select: [:emp | emp isMemberOf: GlorpLineWorker]) size = 5.	self assert: (employees select: [:emp | emp isMemberOf: GlorpRegionalManager]) size = 2.	self assert: (contractors := employees select: [:emp | emp isMemberOf: GlorpContractor]) size = 1.	self assert: contractors first hourlyRate class == GlorpMoney.	self assert: contractors first hourlyRate amount = 100.	]		ensure: [session rollbackTransaction]</body><body package="GlorpTests">testDirectQueryWithAbstractClass	| fromdb |	session beginTransaction.	[session inUnitOfWorkDo: [	session register: (GlorpBasicTax new name: 'Tax'; yourself).								session register: (GlorpSurcharge new name: 'Surcharge'; yourself)].	session reset.	fromdb := session read: GlorpTax.	self assert: fromdb size = 2.	self assert: (fromdb select: [:emp | emp isMemberOf: GlorpTax]) isEmpty.	self assert: (fromdb select: [:emp | emp isMemberOf: GlorpBasicTax]) size = 1.	self assert: (fromdb select: [:emp | emp isMemberOf: GlorpSurcharge]) size = 1] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests">testEmbeddedMapping	"Check that when we only read contractors, the embedded mapping works OK."	| employees |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	employees := session read: GlorpContractor.	self assert: employees size = 1.	self assert: employees first hourlyRate amount = 100.	]		ensure: [session rollbackTransaction]</body><body package="GlorpTests">testNotInSelect	"Ask for an Employee which should be from the cache and which should return a Manager."	| testEmployees |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	testEmployees := session read: GlorpManager				where: [:each | each id notIn: #(1 2 3)].	self assert: testEmployees notEmpty	"Proxys seem to try a cache lookup before they execute their query...can we write a test which fails due to this?"] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests">testOrderBy	| employees query |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	query := Query read: GlorpEmployee				where: [:each | each id &lt;= 4].	query orderBy: #name.	query orderBy: #id.	employees := session execute: query.	self assert: (employees asSortedCollection: [:a :b | a name = b name ifTrue: [		a id &lt;= b id] ifFalse: [a name &lt; b name]]) asArray = employees]			ensure: [session rollbackTransaction]</body><body package="GlorpTests">testRelationshipQuery	"Ask for all Employees in a given office and test that the return types are correct."	| employees office |	session beginTransaction.		[session beginUnitOfWork.	self writeTestHarness.	session commitUnitOfWork.	session initializeCache.	office := session readOneOf: GlorpOffice				where: [:each | each id = 1 ].	employees := office employees.	self assert: employees size = 6.	self assert: (employees select: [:emp | emp isMemberOf: GlorpEmployee]) size = 2.	self assert: (employees select: [:emp | emp isMemberOf: GlorpManager]) size = 1.	self assert: (employees select: [:emp | emp isMemberOf: GlorpLineWorker]) size = 2.	self assert: (employees select: [:emp | emp isMemberOf: GlorpRegionalManager]) size = 1] 			ensure: [session rollbackTransaction]</body><body package="GlorpTests">testTaxInsertOrdering	| taxes first |	taxes := OrderedCollection new.	first := (GlorpBasicTax new)		name: 'A';		yourself.	taxes add: first.	10 timesRepeat: [self makeSupertaxIn: taxes].	[session beginTransaction.	session inUnitOfWorkDo: [session registerAll: taxes]]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpFilteredInheritanceTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	session system: (GlorpInheritanceDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database).</body><body package="GlorpTests">tearDown	super tearDown.	session reset.	session := nil.</body><body package="GlorpTests">writeTestHarness	| office1 office2  eom1 eom2 jim bob jenny |	session register: (office1 := GlorpOffice new id: 1; yourself).	session register: (office2 := GlorpOffice new id: 2; yourself).	office1 addEmployee: (eom1 := GlorpEmployee new id: 1; name: 'Bob'; yourself).	office1 addEmployee: (GlorpEmployee new id: 2; name: 'Jim'; yourself).	office1 addEmployee: (GlorpManager new id: 3; name: 'Bob'; branch: 'West'; yourself).	office2 addEmployee: (eom2 := GlorpManager new id: 4; name: 'Steve'; branch: 'East'; yourself).	office2 addEmployee: (GlorpManager new id: 5; name: 'Bob'; branch: 'South'; yourself).	office1 addEmployee: (GlorpLineWorker new id: 6; name: 'Wally'; productionLine: 'Gold'; yourself).	office1 addEmployee: (GlorpLineWorker new id: 7; name: 'Bob'; productionLine: 'Silver'; yourself).	office2 addEmployee: (GlorpLineWorker new id: 8; name: 'Bob'; productionLine: 'Tin'; yourself).	office2 addEmployee: (GlorpLineWorker new id: 9; name: 'Bob'; productionLine: 'Copper'; yourself).	office2 addEmployee: (GlorpLineWorker new id: 10; name: 'Bob'; productionLine: 'Steel'; yourself).	office1 addEmployee: (GlorpRegionalManager new id: 11; name: 'Bob'; branch: 'South'; region: 'MidWest'; yourself).	office2 addEmployee: (GlorpRegionalManager new id: 12; name: 'Mike'; branch: 'North'; region: 'NorthEast'; yourself).	office1 employeeOfMonth: eom1.	office2 employeeOfMonth: eom2.	session register: (jim := GlorpWorkingStiff new id: 13; name: 'Jim'; yourself).	session register: (bob := GlorpWorkingStiff new id: 14; name: 'Bob'; yourself). 	session register: (jenny := GlorpContractor new id: 15; name: 'Jenny'; yourself).	jenny hourlyRate: (GlorpMoney forAmount: 100).	"embedded mapping."	allEmployees := (Array with: jim with: bob with: jenny), office1 employees, office2 employees.</body></methods><methods><class-id>Glorp.GlorpFilteredInheritanceTest class</class-id> <category>resources</category><body package="GlorpTests">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpTransformedFieldValueWrapperTest</class-id> <category>tests</category><body package="GlorpTests">testPrivateSetOuter	self deny: inner hasValue.	self deny: outer hasValue.	outer privateSetContents: 8.	self assert: outer contents = 8.	self assert: inner contents = 4.	self assert: inner hasValue.	self assert: outer hasValue.</body><body package="GlorpTests">testSetInner	self deny: inner hasValue.	self deny: outer hasValue.	inner contents: 3.	self assert: outer contents = 6.	self assert: inner contents = 3.	self assert: inner hasValue.	self assert: outer hasValue.</body><body package="GlorpTests">testSetOuter	self deny: inner hasValue.	self deny: outer hasValue.	outer contents: 8.	self assert: outer contents = 8.	self assert: inner contents = 4.	self assert: inner hasValue.	self assert: outer hasValue.</body><body package="GlorpTests">testSetOuterFails	self deny: inner hasValue.	self deny: outer hasValue.	outer contents: 8.	self should: [outer contents: 9] raise: Dialect error.	self assert: outer contents = 8.	self assert: inner contents = 4.	self assert: inner hasValue.	self assert: outer hasValue.</body></methods><methods><class-id>Glorp.GlorpTransformedFieldValueWrapperTest</class-id> <category>accessing</category><body package="GlorpTests">inner	^inner</body><body package="GlorpTests">inner: aFieldValueWrapper	inner := aFieldValueWrapper</body><body package="GlorpTests">outer	^outer</body><body package="GlorpTests">outer: aTransformingFieldValueWrapper	outer := aTransformingFieldValueWrapper</body></methods><methods><class-id>Glorp.GlorpTransformedFieldValueWrapperTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	inner := FieldValueWrapper new.	outer := TransformingFieldValueWrapper new innerWrapper: inner; forwardTransformation: [:a | a * 2]; inverseTransformation: [:a | a / 2].</body></methods><methods><class-id>Glorp.GlorpExpressionRebuildingTest</class-id> <category>tests</category><body package="GlorpTests">testLoneBase	original := BaseExpression new.	rebuilt := original rebuildOn: newBase.	self assert: rebuilt == newBase.</body><body package="GlorpTests">testMapping	original := [:each | each foo] asGlorpExpression.	rebuilt := original rebuildOn: newBase.	self assert: rebuilt base == newBase.</body><body package="GlorpTests">testRelation	original := [:each | each foo bar = each foo bletch] asGlorpExpression.	rebuilt := original rebuildOn: newBase.	self assert: rebuilt ultimateBaseExpression == newBase.	self assert: rebuilt leftChild ultimateBaseExpression == newBase.	self assert: rebuilt rightChild ultimateBaseExpression == newBase.	self assert: rebuilt leftChild base base == newBase.</body></methods><methods><class-id>Glorp.GlorpExpressionRebuildingTest</class-id> <category>tests-outer scope references</category><body package="GlorpTests">testRebuildDoubleInnerScopeNormallyWithExists	original := [:each | 	each foo		anySatisfyExists:			[:eachFoo | eachFoo things anySatisfyExists: [:eachThing | eachThing stuff = each fooThing]]]		asGlorpExpression.	rebuilt := original rebuildOn: newBase.	rebuilt do: [:each | self assert: each ultimateBaseExpression == newBase].</body><body package="GlorpTests">testRebuildDoubleInnerScopeNormallyWithJoins	original := [:each | 	each foo		anySatisfyJoin:			[:eachFoo | eachFoo things anySatisfyJoin: [:eachThing | eachThing stuff = each fooThing]]]		asGlorpExpression.	rebuilt := original rebuildOn: newBase.	rebuilt do: [:each | self assert: each ultimateBaseExpression == newBase].</body><body package="GlorpTests">testRebuildInnerScopeForSubquery	| foo |	original := [:each | each foo anySatisfyJoin: [:eachFoo | eachFoo thing = each fooThing]] asGlorpExpression.	"Just so that it prints distinctively"	original ultimateBaseExpression descriptor: (Descriptor new classModel: (GlorpClassModel for: Object)).	foo := original leftChild.	newBase := SubSelectBaseExpression on: foo.	rebuilt := original rightChild rebuildOn: newBase startingFrom: foo.	self assert: rebuilt leftChild base == newBase.	self assert: rebuilt leftChild ultimateBaseExpression == original ultimateBaseExpression.	self assert: rebuilt rightChild base == original ultimateBaseExpression.</body><body package="GlorpTests">testRebuildInnerScopeNormally	original := [:each | each foo anySatisfy: [:eachFoo | eachFoo thing = each fooThing]]		asGlorpExpression.	rebuilt := original rebuildOn: newBase.	rebuilt do: [:each | self assert: each ultimateBaseExpression == newBase].</body><body package="GlorpTests">testRebuildMappingWithStart	original := [:each | each foo bar] asGlorpExpression.	rebuilt := original rebuildOn: newBase startingFrom: original base.	self assert: rebuilt base == newBase.</body></methods><methods><class-id>Glorp.GlorpExpressionRebuildingTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	newBase := BaseExpression new.</body></methods><methods><class-id>Glorp.GlorpRelativeFieldWithLocksTest</class-id> <category>test-updating with valid locks</category><body package="GlorpTests">testRelativeLockFieldDecrementUsage	| session1 session2 query items |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each | each qty: 10]].		"Set the target qty to 10."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 10.	self assert: items last qty = 10.</body><body package="GlorpTests">testRelativeLockFieldManyRowUpdate	"This test inserts, then updates, an array of data to ensure that relative field works with multiple row update."	| session1 session2 session3 data1 data2 data3 |	session1 := GlorpSessionResource current newSession.	data1 := OrderedCollection new		add: (GlorpItemRelativeLocks new id: 3; name: 'a'; qty: 10; lock1: 3);		add: (GlorpItemRelativeLocks new  id: 4; name: 'b'; qty: 11; lock1: 4);		add: (GlorpItemRelativeLocks new  id: 5; name: 'c'; qty: 12; lock1: 5);		add: (GlorpItemRelativeLocks new  id: 6; name: 'd'; qty: 13; lock1: 6);		yourself.	session1 inUnitOfWorkDo: [session1 registerAll: data1].	session2 := GlorpSessionResource current newSession.	session2 inUnitOfWorkDo:		[data2 := session2 read: GlorpItemRelativeLocks.		self assert: data2 size = 6.		data2 do: [:each| each qty: 35]].	session3 := GlorpSessionResource current newSession.	data3 := session3 read: GlorpItemRelativeLocks.	self assert: data3 size = 6 .	data3 do: [:each| self assert: each qty = 35].</body><body package="GlorpTests">testRelativeLockFieldNormalUsage	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each qty: 125]].		"Set the target qty to 125."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.</body><body package="GlorpTests">testRelativeLockFieldNullWrite	"We created the qty field to be not-NULLable, but the totalSales field can hold NULL.  Of course, once we NULL a relative field, we cannot insert any value (at least, not via that mapping)."	| session1 session2 query items session3 canRaiseGlorpWriteFailure |	"Some platforms will raise a GlorpWriteFailure if an update fails, and rowCount will be zero.	When we update a NULL relative field, MySQL returns 0 for rowCount, and Glorp throws the exception."	canRaiseGlorpWriteFailure := session accessor platform supportsRowCountFor: UpdateCommand new.	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo:		"read, check values, set to nil"		[query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		self assert: items first totalSales = 0.		self assert: items last totalSales = 500s.		items do: [:each | each totalSales: nil].		items do: [:each | self assert: each totalSales isNil]].	session2 := GlorpSessionResource current newSession.	[session2 inUnitOfWorkDo:		"read, check values are nil, set to 20"		[query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session2 execute: query.		self assert: items first totalSales isNil.		self assert: items last totalSales isNil.		items do: [:each | each totalSales: 20].		"Before we write, we hold the values we set."		items do: [:each | self assert: each totalSales = 20]]]			on: GlorpWriteFailure do: [:ex| canRaiseGlorpWriteFailure ifTrue: [ex return: nil]].	"After we write, we are syched with the database, so are nil again (if we are a returning command, not otherwise)."	(self supportsReturningValuesForSession: session1)		ifTrue: [items do: [:each | self assert: each totalSales isNil]].	"read, check values are still nil"	session3 := GlorpSessionResource current newSession.	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session3 execute: query.	self assert: items first totalSales isNil.	self assert: items last totalSales isNil.</body><body package="GlorpTests">testRelativeLockFieldOneRowNULLOneNotNULL	"Have a null and a non-null row.  This passes on Postgres unbound and bound but the bound only works because Postgres bound does not group."	| session1 session2 query items session3 canRaiseGlorpWriteFailure hadWriteFailure |	"Some platforms will raise a GlorpWriteFailure if an update fails, and rowCount will be zero.	When we update a NULL relative field, MySQL returns 0 for rowCount, and Glorp throws the exception."	canRaiseGlorpWriteFailure := session accessor platform supportsRowCountFor: UpdateCommand new.	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo:		"read, check values, set to nil"		[query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		self assert: items first totalSales = 0.		self assert: items last totalSales = 500s.		items first totalSales: nil.		items last totalSales: 250].	session2 := GlorpSessionResource current newSession.	hadWriteFailure := false.	[session2 inUnitOfWorkDo:		"read, check values are nil, set to 20"		[query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session2 execute: query.		self assert: items first totalSales isNil.		self assert: items last totalSales = 250.		items do: [:each | each totalSales: 20].		"Before we write, we hold the values we set."		items do: [:each | self assert: each totalSales = 20]]]			on: GlorpWriteFailure			do: [:ex| canRaiseGlorpWriteFailure ifTrue: [hadWriteFailure := true].					ex return: nil].	"After we write, we are syched with the database, so are nil again (if we are a returning command, not otherwise)."	(self supportsReturningValuesForSession: session1) ifTrue:		[self assert: items first totalSales isNil.		self assert: items last totalSales = 20].	"read, check values are still nil"	session3 := GlorpSessionResource current newSession.	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session3 execute: query.	self assert: items first totalSales isNil.	self assert: (hadWriteFailure or: [items last totalSales = 20s]).</body><body package="GlorpTests">testWithOnlyRelativeLockFieldNormalUsage	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each qty: 125]].		"Set the target qty to 125."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.</body></methods><methods><class-id>Glorp.GlorpRelativeFieldWithLocksTest</class-id> <category>running</category><body package="GlorpTests">sessionShouldUpdateOnlyChangedFields	"Return true if our session will only update changed fields. If this is true, and our only changes are to relative fields,	then the lock keys (if any) will be excluded from both the update list and from the where clause. In this case, the	only fields updated will be the relative fields.	Otherwise, if we return false, then even a relative-only update will update the lock fields as well, causing any tests	that depend on the special handling of relative fields to fail. (Therefore, a guard clause has been added to those tests.)"	^session system shouldUpdateOnlyChangedFieldsFor: Glorp.UpdateCommand new</body><body package="GlorpTests">setUp	| itemWithLockRow1 itemWithLockRow2 |	super setUp.	session := GlorpSessionResource current newSession.	session beginTransaction.	itemWithLockRow1 := session system exampleItemRelativeLocksRow1.	itemWithLockRow2 := session system exampleItemRelativeLocksRow2.	session writeRow: itemWithLockRow1.	session writeRow: itemWithLockRow2.	session commitTransaction</body><body package="GlorpTests">shouldUpdateOnlyChangedFieldsForSession: aSession	"Return true if our session will only update changed fields. If this is true, and our only changes are to relative fields,	then the lock keys (if any) will be excluded from both the update list and from the where clause. In this case, the	only fields updated will be the relative fields.	Otherwise, if we return false, then even a relative-only update will update the lock fields as well, causing any tests	that depend on the special handling of relative fields to fail. (Therefore, a guard clause has been added to those tests.)"	^aSession system shouldUpdateOnlyChangedFieldsFor: Glorp.UpdateCommand new</body><body package="GlorpTests">supportsReturningValuesForSession: aSession	"Oracle supports returning values, but only if the command is bound."		^(aSession platform relativeUpdateCommand includesBehavior: ReturningUpdateCommand)		and: [aSession platform isOraclePlatform not or: [DatabasePlatform useBindingIfSupported]].</body><body package="GlorpTests">tearDown	session delete: GlorpItemRelativeLocks where: [:book | book id &gt;= 0].	session reset.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpRelativeFieldWithLocksTest</class-id> <category>test-updating with invalid locks</category><body package="GlorpTests">testRelativeFieldNormalUsageBadLocks	"Reuse session1, which evidently knows about the items it read before, so when we register: them later in another transaction, they are updated, not inserted.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."	| query items session1 session2 caughtError |	"Read the items with session1."	session1 := GlorpSessionResource current newSession.	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	items := session1 read: GlorpItemRelativeLocks.	"Invalidate the locks, going around Glorp, so that its sessions are unaware of the change."	session1 accessor			executeSQLStringNoResult: 'UPDATE ITEM_RELATIVE_LOCKS SET LOCK1 = LOCK1 + 100, LOCK2 = LOCK2 + 100'.	"Re-register (resynch them) the items, and try to update them with now invalid lock keys."	caughtError := false.	[session1			transact:				[session1 register: items.				items do: [:each| each qty: 125]]]			on: GlorpDatabaseWriteError, GlorpWriteFailure			do: [:ex | caughtError := true.					ex return: nil].	self assert: caughtError not.		"Since we ONLY changed relative fields, the locks should have been ignored."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.</body><body package="GlorpTests">testRelativeLockFieldManyRowUpdateBadLocks	"This test inserts, then updates, an array of data to ensure that relative field works with multiple row update.	Reuse session1, which evidently knows about the items it read before, so when we register: them later in another transaction, they are updated, not inserted.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."	| session1 session3 data1 data3 caughtError |	session1 := GlorpSessionResource current newSession.	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	data1 := OrderedCollection new		add: (GlorpItemRelativeLocks new id: 3; name: 'a'; qty: 10; lock1: 3);		add: (GlorpItemRelativeLocks new  id: 4; name: 'b'; qty: 11; lock1: 4);		add: (GlorpItemRelativeLocks new  id: 5; name: 'c'; qty: 12; lock1: 5);		add: (GlorpItemRelativeLocks new  id: 6; name: 'd'; qty: 13; lock1: 6);		yourself.	session1 inUnitOfWorkDo: [session1 registerAll: data1].	session1 accessor			executeSQLStringNoResult: 'UPDATE ITEM_RELATIVE_LOCKS SET LOCK1 = LOCK1 + 100, LOCK2 = LOCK2 + 100'.	caughtError := false.	[session1			transact:				[session1 registerAll: data1.				data1 do: [:each| each qty: 35]]]			on: GlorpDatabaseWriteError, GlorpWriteFailure			do: [:ex | caughtError := true.					ex return: nil].	self assert: caughtError not.		"Since we ONLY changed relative fields, the locks should have been ignored."	session3 := GlorpSessionResource current newSession.	data3 := session3 read: GlorpItemRelativeLocks.	self assert: data3 size = 6 .	data3 do: [:each| self assert: ((each qty = 35) or: [#(50 100) includes: each qty])].</body><body package="GlorpTests">testRelativeLockFieldSingleRowUpdateBadLocks	"This test inserts, then updates, a single item to ensure that relative field works with single row updates.	Reuse session1, which evidently knows about the items it read before, so when we register: them later in another transaction, they are updated, not inserted.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."	| session1 session3 item data3 caughtError |	session1 := GlorpSessionResource current newSession.	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	item := GlorpItemRelativeLocks new id: 3; name: 'a'; qty: 10; lock1: 3.	session1 inUnitOfWorkDo: [session1 register: item].	session1 accessor			executeSQLStringNoResult: 'UPDATE ITEM_RELATIVE_LOCKS SET LOCK1 = LOCK1 + 100, LOCK2 = LOCK2 + 100'.	caughtError := false.	[session1			transact:				[session1 register: item.				item qty: 35]]			on: GlorpDatabaseWriteError, GlorpWriteFailure			do: [:ex | caughtError := true.					ex return: nil].	self assert: caughtError not.		"Since we ONLY changed relative fields, the locks should have been ignored."	session3 := GlorpSessionResource current newSession.	data3 := session3 read: GlorpItemRelativeLocks.	self assert: data3 size = 3 .	data3 do: [:each| self assert: ((each qty = 35) or: [#(50 100) includes: each qty])].</body></methods><methods><class-id>Glorp.GlorpRelativeFieldWithLocksTest</class-id> <category>test-updating all fields with locks</category><body package="GlorpTests">testUpdatingNormalAndRelativeFields	"Ensure that we can update  relative fields and regular fields, and that the lock fields do get incremented."	| query items session1 session2 locks |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each qty: 125.					"Set the target qty to 125."						each name: (each name,'new')]].	"Also, change the name (a non-relative field)."	"Load just the lock fields, to ensure that they were incremented."	locks := session1 accessor executeSQLString: 'SELECT LOCK1 FROM ITEM_RELATIVE_LOCKS ORDER BY LOCK1'.	self assert: (  locks first first &gt; 1).	self assert: (locks last first &gt; 2).	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.	self assert: (items first name findString: 'new' startingAt: 1) &gt; 0.	self assert: (items last name findString: 'new' startingAt: 1) &gt; 0.</body><body package="GlorpTests">testUpdatingOnlyNormalFields	"Ensure that we can update regular fields, and that the lock fields do get incremented."	| query items session1 session2 locks |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each name: 'xyz']].		"Set the target qty to 125."	"Load just the lock fields, to ensure that they were incremented."	locks := session1 accessor executeSQLString: 'SELECT LOCK1 FROM ITEM_RELATIVE_LOCKS ORDER BY LOCK1'.	self assert: (locks first first &gt; 1).	self assert: (locks last first &gt; 2).	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 100.	self assert: items last qty = 50.</body><body package="GlorpTests">testUpdatingOnlyNormalFields2	"Ensure that we can update regular fields, and that the lock fields do get incremented."	| items lockValues newLockValues |	items := session read: GlorpItemRelativeLocks orderBy: #id.	lockValues := (session accessor executeSQLString: 'SELECT LOCK1 FROM ITEM_RELATIVE_LOCKS ORDER BY ID') collect: [:each | each first].	session modify: items in: [		items do: [:each | each name: 'xyz']].	newLockValues := (session accessor executeSQLString: 'SELECT LOCK1 FROM ITEM_RELATIVE_LOCKS ORDER BY ID') collect: [:each | each first].	self assert: newLockValues = (lockValues collect: [:each | each + 1]).</body></methods><methods><class-id>Glorp.GlorpRelativeFieldWithLocksTest</class-id> <category>test-multiple fields and valid locks</category><body package="GlorpTests">testMultipleRelativeFieldsNormalUsage	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each qty: 125; totalSales: 100.0]].	"We wrote values in setUp and updated them; check values."	session2 := GlorpSessionResource current newSession.	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.	self assert: items first totalSales = 100.	self assert: items last totalSales = 100.</body><body package="GlorpTests">testSecondRelativeFieldOnlyUsage	"Update the 2nd relative field, leaving the first unchanged (so it's contents won't be part of our update query)."	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each totalSales: 200.0]].		"Set the target totalSales to 125."	session2 := GlorpSessionResource current newSession.	"SetUp has already written these values to the db, so update their quantities."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first totalSales = 200.0.	self assert: items last totalSales = 200.0.</body><body package="GlorpTests">testSecondRelativeFieldOnlyUsageSingleRow	"Update the 2nd relative field, leaving the first unchanged (so it's contents won't be part of our update query).	This test only updates one row, so it won't use array-binding (if that is available for the current platform)."	| query session1 session2 itemWritten itemRead|	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query readOneOf: GlorpItemRelativeLocks.		itemWritten := session1 execute: query.		itemWritten totalSales: 200.0].		"Set the target totalSales to 125."	session2 := GlorpSessionResource current newSession.	"SetUp has already written these values to the db, so update their quantities."	query := Query readOneOf: GlorpItemRelativeLocks where: [:each| each id = itemWritten id].	itemRead := session2 execute: query.	self assert: itemRead totalSales = 200.0.</body></methods><methods><class-id>Glorp.GlorpRelativeFieldWithLocksTest</class-id> <category>tests requiring relative-only-lock-free</category><body package="GlorpTests">testImageDBConsistencyAfterParallelUpdates	"This test investigates possible discrepancy between the image after updating a relative field if it has also been updated in another session."	"This test will ERROR on RETURNING platforms if the relative-only-ignores-locks code fails, so the second (qty: 300) update has invalid locks.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."	| session1 session2 session3 query1 query2 query3 items1 items2 items3 |	session1 := GlorpSessionResource current newSession.	(self supportsReturningValuesForSession: session1) ifFalse: [^true].	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 		["Read the current values in the first session. Values are #(100 50)"		query1 := Query read: GlorpItemRelativeLocks.		query1 orderBy: [:item | item id].		items1 := session1 execute: query1.			session2 := GlorpSessionResource current newSession.		session2 inUnitOfWorkDo: 			["Read the items, and then update their quantities, undetected by session1."			query2 := Query read: GlorpItemRelativeLocks.			query2 orderBy: [:item | item id].			items2 := session2 execute: query2.			items2 do: [:each | each qty: 125]].	"Set the target qty to 125. (update +25, update +75)."		"Use the already-cached items from session1, whose values are still #(100 50)"		items1 do: [:each | each qty: 300]].	"Update the quantity. (update +200, update +250)."	"Both updates have now been applied to the database;  items2 do not know of later updates ..."	self assert: items2 first qty = 125 description: 'Session2 first should still have value 125' resumable: true.	self assert: items2 last qty = 125 description: 'Session2 last should still have value 125' resumable: true.	"... . but items1 do know the actual final value at the end of writing their increments to the DB."	self assert: items1 first qty = 325 description: 'Session1 first lacks post-write value 325' resumable: true.	self assert: items1 last qty = 375 description: 'Session1 last lacks post-write value 375' resumable: true.	"... and so their values are no longer the ones they wrote."	self deny: items1 first qty = 300 description: 'Session1 first still has pre-write value 300' resumable: true.	self deny: items1 last qty = 300 description: 'Session1 last still has its pre-write value 300' resumable: true.	"Determine the actual quantities."	session3 := GlorpSessionResource current newSession.	query3 := Query read: GlorpItemRelativeLocks.	query3 orderBy: [:item | item id].	items3 := session3 execute: query3.	self assert: items3 first qty = 325 description: 'Re-read first lacks final value 325' resumable: true.	self assert: items3 last qty = 375 description: 'Re-read last lacks final value 375'.	"no point resuming last assert"</body><body package="GlorpTests">testMultiRelativeFieldsImageDBConsistencyAfterParallelUpdates	"This test investigates possible discrepancy between the image after updating a relative field if it has also been updated in another session. Oracle cannot return values if unbound."	"This test will ERROR on RETURNING platforms if the relative-only-ignores-locks code fails, so the second (qty: 300) update has invalid locks.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."		| session1 session2 session3 query1 query2 query3 items1 items2 items3 |	session1 := GlorpSessionResource current newSession.	(self supportsReturningValuesForSession: session1) ifFalse: [^true].	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 		["Read the current values in the first session. Values are #(100 500s) and #(50 0s)"		query1 := Query read: GlorpItemRelativeLocks.		query1 orderBy: [:item | item id].		items1 := session1 execute: query1.			session2 := GlorpSessionResource current newSession.		session2 inUnitOfWorkDo: 			["Read the items, and then update their quantities, undetected by session1."			query2 := Query read: GlorpItemRelativeLocks.			query2 orderBy: [:item | item id].			items2 := session2 execute: query2.			items2 do: [:each| each qty: 125; totalSales: 100.0]].		"Set the target qty to 125, sales to 100.00."		"Use the already-cached items from session1, whose values are still #(100 50)"		items1 do: [:each | each qty: 300; totalSales: 25.0]].	"Update the quantity. (update +200, update +250), (+25.0, -475.0)."	"Both updates have now been applied to the database;  items2 do not know of later updates ..."	self assert: items2 first qty = 125 description: 'Session2 first should still have value 125' resumable: true.	self assert: items2 first totalSales = 100s description: 'Session2 first sales should still have value 100.00' resumable: true.	self assert: items2 last qty = 125 description: 'Session2 last should still have value 125' resumable: true.	self assert: items2 last totalSales = 100s description: 'Session2 last  sales should still have value 100.00' resumable: true.	"... . but items1 do know the actual final value at the end of writing their increments to the DB."	self assert: items1 first qty = 325 description: 'Session1 first lacks post-write value 325' resumable: true.	self assert: items1 last qty = 375 description: 'Session1 last lacks post-write value 375' resumable: true.	"... and so their values are no longer the ones they wrote."	self deny: items1 first qty = 300 description: 'Session1 first still has pre-write value 300' resumable: true.	self deny: items1 last qty = 300 description: 'Session1 last still has its pre-write value 300' resumable: true.	"Determine the actual quantities."	session3 := GlorpSessionResource current newSession.	query3 := Query read: GlorpItemRelativeLocks.	query3 orderBy: [:item | item id].	items3 := session3 execute: query3.	self assert: items3 first qty = 325 description: 'Re-read first lacks final value 325' resumable: true.	self assert: items3 first totalSales = 125s description: 'Re-read first lacks final value 325' resumable: true.	self assert: items3 last qty = 375 description: 'Re-read last lacks final value 375'.	"no point resuming last assert"	self assert: items3 last totalSales = -375s description: 'Re-read last lacks final value 375'.	"no point resuming last assert"</body><body package="GlorpTests">testRelativeLockFieldParallelDecrements	"This test validates the behavior of relative field updates, which don't need to know the current values of their target fields. They do know the relative change in value between when their session read them and wrote them, which is what gets added to the target in the database. This test uses 2 separate sessions, oblivious about each other, and involves several steps.	Step 1: The first session loads values from the Db. It sees qty #(100 50) for the two rows.	Step 2: The second session does the same, and updates these values to #(10 10).	Step 3: The first session now updates the qty from #(100 50), unaware these are stale numbers, to (300 300).	Step 4: The transaction commits, and the database qty is now #(325 375),			since (300-100=200)+10=210  and (300-50=250)+10=260.	Step 5: A fresh session reads from the database and confirms these values."	"This test will ERROR on RETURNING platforms if the relative-only-ignores-locks code fails, so the second (qty: 300) update has invalid locks.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."		| session1 session2 session3 query1 query2 query3 items1 items2 items3 |	session1 := GlorpSessionResource current newSession.	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 			["Read the current values in the first session. Values are #(100 50)"			query1 := Query read: GlorpItemRelativeLocks.			query1 orderBy: [:item | item id].			items1 := session1 execute: query1.						session2 := GlorpSessionResource current newSession.			session2 inUnitOfWorkDo: 					["Read the items, and then update their quantities, undetected by session1.					This inner UOW generates and commits its own transaction at the end of its block. 					The outer UOW starts and commits its own transaction at the end of its block."					query2 := Query read: GlorpItemRelativeLocks.					query2 orderBy: [:item | item id].					items2 := session2 execute: query2.					items2 do: [:each | each qty: 10]].	"Set the target qty to 10. (update -90, update -40)."			"Use the already-cached items from session1, whose values are still #(100 50)"			items1 do: [:each | each qty: 300]].	"Update the quantity. (update +200, update +250)."	"Determine the actual quantities."	session3 := GlorpSessionResource current newSession.	query3 := Query read: GlorpItemRelativeLocks.	query3 orderBy: [:item | item id].	items3 := session3 execute: query3.	self assert: items3 first qty = 210.	self assert: items3 last qty = 260.</body><body package="GlorpTests">testRelativeLockFieldParallelIncrements	"Read values, apply two updates in separate sessions, then read again from the database and verify values are the summary of the two differences."	"This test will ERROR on RETURNING platforms if the relative-only-ignores-locks code fails, so the second (qty: 300) update has invalid locks.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."		| session1 session2 session3 query1 query2 query3 items1 items2 items3 |	session1 := GlorpSessionResource current newSession.	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 			["Read the current values in the first session. Values are #(100 50)"			query1 := Query read: GlorpItemRelativeLocks.			query1 orderBy: [:item | item id].			items1 := session1 execute: query1.						session2 := GlorpSessionResource current newSession.			session2 inUnitOfWorkDo: 					["Read the items, and then update their quantities, undetected by session1."					query2 := Query read: GlorpItemRelativeLocks.					query2 orderBy: [:item | item id].					items2 := session2 execute: query2.					items2 do: [:each | each qty: 125]].	"Set the target qty to 125. (update +25, update +75)."			"Use the already-cached items from session1, whose values are still #(100 50)"			items1 do: [:each | each qty: 300]].	"Update the quantity. (update +200, update +250)."	"Determine the actual quantities."	session3 := GlorpSessionResource current newSession.	query3 := Query read: GlorpItemRelativeLocks.	query3 orderBy: [:item | item id].	items3 := session3 execute: query3.	self assert: items3 first qty = 325.	self assert: items3 last qty = 375</body><body package="GlorpTests">testUpdatingOnlyRelativeFields	"Ensure that we can update only relative fields, and that the lock fields are NOT incremented."	"This test will ERROR on platforms if the relative-only-ignores-locks code fails, thereby incrementing the locks.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."			| query items session1 session2 locks |	session1 := GlorpSessionResource current newSession.	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each qty: 125]].		"Set the target qty to 125."	"Load just the lock fields, to ensure that they weren't incremented."	locks := session1 accessor executeSQLString: 'SELECT LOCK1 FROM ITEM_RELATIVE_LOCKS ORDER BY LOCK1'.	self assert: (locks first first = 1).	self assert: (locks last first = 2).	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 125.</body><body package="GlorpTests">testUpdatingRelativeFieldsOnlyInFirstRow	"Ensure that we can update only relative fields, and that the lock fields are NOT incremented."	"This test will ERROR on platforms if the relative-only-ignores-locks code fails, thereby incrementing the locks.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."			| query items session1 session2 locks |	session1 := GlorpSessionResource current newSession.	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items first qty: 125.				"Set only the target qty to 125, meaning no need for lock keys."		items last name: 'yogi bear'].		"Set only the name field, meaning we'll need lock keys."	"Load just the lock fields, to ensure that they weren't incremented."	locks := session1 accessor executeSQLString: 'SELECT LOCK1 FROM ITEM_RELATIVE_LOCKS ORDER BY LOCK1'.	self assert: (locks first first = 1).	"Started at 1, stayed at 1."	self assert: (locks last first = 3).	"Went from 2 to 3."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 125.	self assert: items last qty = 50.</body><body package="GlorpTests">testUpdatingRelativeFieldsOnlyInSecondRow	"Ensure that we can update only relative fields, and that the lock fields are NOT incremented."	"This test will ERROR on platforms if the relative-only-ignores-locks code fails, thereby incrementing the locks.	If the platform or image settings always updates ALL fields, the relative-only-ignores-locks code is bypassed. Knowing this, return true."			| query items session1 session2 locks |	session1 := GlorpSessionResource current newSession.	(self shouldUpdateOnlyChangedFieldsForSession: session1) ifFalse: [^true].	session1 inUnitOfWorkDo: 		["Read the items, and update their quantities."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items first name: 'yogi bear'.		"Set only the name field, meaning we'll need lock keys."		items last qty: 125].				"Set only the target qty to 125, meaning no need for lock keys."	"Load just the lock fields, to ensure that they weren't incremented."	locks := session1 accessor executeSQLString: 'SELECT LOCK1 FROM ITEM_RELATIVE_LOCKS ORDER BY LOCK1'.	self assert: (locks first first = 2).	"Went from 1 to 2."	self assert: (locks last first = 2).	"Started at 2, stayed at 2."	session2 := GlorpSessionResource current newSession.	"We wrote values to the db in setUp; check the post-relative-update values."	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first qty = 100.	self assert: items last qty = 125.</body></methods><methods><class-id>Glorp.GlorpRelativeFieldWithLocksTest</class-id> <category>test-returning with valid locks</category><body package="GlorpTests">testRelativeFieldNonUsage	| query items session1 session2 |	session1 := GlorpSessionResource current newSession.	session1 inUnitOfWorkDo:		["Read the items and update a normal field but ignore the relative field."		query := Query read: GlorpItemRelativeLocks.		query orderBy: [:item| item id].		items := session1 execute: query.		items do: [:each| each name: 'Smith']].	"We wrote values to the db in setUp; check their quantities are unchanged."	session2 := GlorpSessionResource current newSession.	query := Query read: GlorpItemRelativeLocks.	query orderBy: [:item| item id].	items := session2 execute: query.	self assert: items first name = 'Smith'.	self assert: items first qty = 100.	self assert: items last name = 'Smith'.	self assert: items last qty = 50.</body></methods><methods><class-id>Glorp.GlorpExpressionIterationTest</class-id> <category>tests</category><body package="GlorpTests">helpTestSingleNodeDo: exp 	self assert: (exp collect: [:each | each]) = (OrderedCollection with: exp)</body><body package="GlorpTests">testDoBase	self helpTestSingleNodeDo:BaseExpression new</body><body package="GlorpTests">testDoCollection	| exp l r |	exp := CollectionExpression new.	l := BaseExpression new.	r := BaseExpression new.	exp leftChild: l; rightChild: r.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: r with: exp)).</body><body package="GlorpTests">testDoConstant	self helpTestSingleNodeDo: ConstantExpression new</body><body package="GlorpTests">testDoField	| exp |	exp := FieldExpression new.	exp field: nil base: BaseExpression new.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: exp base with: exp)).</body><body package="GlorpTests">testDoMapping	| exp |	exp := MappingExpression new.	exp named: 'foo' basedOn: BaseExpression new.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: exp base with: exp)).</body><body package="GlorpTests">testDoParameter	| exp |	exp := ParameterExpression new.	exp field: nil base: BaseExpression new.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: exp base with: exp)).</body><body package="GlorpTests">testDoRelation	| exp l r |	exp := RelationExpression new.	l := BaseExpression new.	r := BaseExpression new.	exp leftChild: l; rightChild: r.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: l with: r with: exp)).</body><body package="GlorpTests">testDoTable	| exp |	exp := TableExpression new.	exp table: nil base: BaseExpression new.	self assert: ((exp collect: [:each | each]) = (OrderedCollection with: exp base with: exp)).</body><body package="GlorpTests">testDoWithCommonBase	| exp l r base |	exp := RelationExpression new.	base := BaseExpression new.	l := MappingExpression new.	l named: nil basedOn: base.	r := MappingExpression new.	r named: nil basedOn: base.	exp leftChild: l; rightChild: r.		self assert: ((exp collect: [:each | each]) = (OrderedCollection with: base with: l with: r with: exp)).</body></methods><methods><class-id>Glorp.GlorpDeleteInUnitOfWorkTest</class-id> <category>As yet unclassified</category><body package="GlorpTests">system	^unitOfWork session system.</body><body package="GlorpTests">tableNamed: aString 	^self system tableNamed: aString.</body></methods><methods><class-id>Glorp.GlorpDeleteInUnitOfWorkTest</class-id> <category>support</category><body package="GlorpTests">setUp	| session |	session := GlorpMockSession new.	session beginUnitOfWork.	unitOfWork := session privateGetCurrentUnitOfWork.	session system: (GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database)</body><body package="GlorpTests">tearDown	unitOfWork := nil.</body></methods><methods><class-id>Glorp.GlorpDeleteInUnitOfWorkTest</class-id> <category>tests</category><body package="GlorpTests">testCommit	unitOfWork delete: GlorpAddress example1.	unitOfWork commit.	self assert: (unitOfWork numberOfRows) = 1.</body><body package="GlorpTests">testDeleteRegistration	| obj |	obj := Object new.	unitOfWork delete: obj.	self assert: (unitOfWork willDelete: obj).	self deny: (unitOfWork willDelete: 3).</body><body package="GlorpTests">testDeletesComeAfterUpdates	unitOfWork delete: GlorpAddress example1.	unitOfWork register: GlorpCustomer example1.	unitOfWork commit.	self assert: unitOfWork session rows last table == (self tableNamed: 'GR_ADDRESS').</body><body package="GlorpTests">testDeletesInReverseOrder	"Not that good a test, because it could be luck with only two tables. Should test this at a lower level"	| cust trans |	cust := GlorpCustomer example2.	trans := cust transactions first.	"We need to give it a primary key or else the delete logic fails"	trans id: 42.	unitOfWork delete: cust.	unitOfWork delete: trans.	unitOfWork commit.	self assert: unitOfWork session rows last owner == cust.	self assert: (unitOfWork session rows reverse at: 2) owner == trans.</body><body package="GlorpTests">testGeneratingDeleteRows	unitOfWork delete: GlorpAddress example1.	unitOfWork createRows.	self assert: unitOfWork privateGetRowMap numberOfEntries = 1.	unitOfWork rowsForTable: (self tableNamed: 'GR_ADDRESS')		do: [:each | self assert: each forDeletion]</body></methods><methods><class-id>Glorp.GlorpTimedExpiryCacheTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	self setUpExpiryWithRealDelay.</body><body package="GlorpTests">setUpExpiryWithRealDelay	(cache session descriptorFor: GlorpCustomer) cachePolicy: (TimedExpiryCachePolicy new timeout: 1).	(cache session descriptorFor: GlorpBankTransaction) cachePolicy: (TimedExpiryCachePolicy new timeout: 1).</body><body package="GlorpTests">setUpExpiryWithZeroDelay	(cache session descriptorFor: GlorpCustomer) cachePolicy: (TimedExpiryCachePolicy new timeout: 0).	(cache session descriptorFor: GlorpBankTransaction) cachePolicy: (TimedExpiryCachePolicy new timeout: 0).</body><body package="GlorpTests">setUpForExpiryActionOf: aSymbol	(cache session descriptorFor: GlorpCustomer) cachePolicy expiryAction: aSymbol.	(cache session descriptorFor: GlorpBankTransaction) cachePolicy expiryAction: aSymbol.</body><body package="GlorpTests">setUpForNotify	self setUpForExpiryActionOf: #notify.</body><body package="GlorpTests">setUpForNotifyAndRemove	self setUpForExpiryActionOf: #notifyAndRemove.</body><body package="GlorpTests">setUpForRefresh	self setUpForExpiryActionOf: #refresh.</body></methods><methods><class-id>Glorp.GlorpTimedExpiryCacheTest</class-id> <category>tests</category><body package="GlorpTests">testExpiryReturningNilWithRealDelay	"test that objects expire with a non-zero delay time."	| customer customer2 |	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	(Delay forSeconds: 2) wait.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	customer2 := GlorpCustomer new.	cache at: 3 insert: customer2.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer2.</body><body package="GlorpTests">testNotExpiredAfterRefresh	| customer |	self setUpForRefresh.	session accessor beginTransaction.	[session accessor executeSQLStringNoResult: 'INSERT INTO GR_CUSTOMER VALUES (3,''Fred Flintstone'')'.	customer := session execute: (Query readOneOf: GlorpCustomer where: [:each | each id = 3]).	(Delay forSeconds: 2) wait.	self assert: (cache hasExpired: customer).	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer.	self deny: (cache hasExpired: customer)]		ensure: [session accessor rollbackTransaction].</body><body package="GlorpTests">testNotify	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotify.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	self assert: customer seenExpiry.</body><body package="GlorpTests">testNotifyAndRemove	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotifyAndRemove.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	self assert: customer seenExpiry = true.</body><body package="GlorpTests">testRegisteredObjectsDoNotExpire	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotifyAndRemove.	customer := GlorpCustomer example1.	customer id: 3.	cache at: 3 insert: customer.	session beginUnitOfWork.	session register: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer.	self deny: customer seenExpiry.</body></methods><methods><class-id>Glorp.GlorpSQLPrintingTest</class-id> <category>tests</category><body package="GlorpTests">testDatePrinting	| date stream |	date := Dialect newDateWithYears: 1997 months: 11 days: 14.	stream := WriteStream on: String new.	date glorpPrintSQLOn: stream.	self assert: stream contents = '''1997-11-14'''.	date := Dialect newDateWithYears: 2002 months: 5 days: 2.	stream := WriteStream on: String new.	date glorpPrintSQLOn: stream.	self assert: stream contents = '''2002-05-02'''.</body><body package="GlorpTests">testGroupWritingInsertCommandSQL	"Oracle never writes groups of statements:  in Oracle, a multi-row insert statement uses a single SQL expression followed by either an array of bound values or (if not binding) a sequence of individual unbound values.  The other platforms support combinations of {bound|unbound}Statements and/or of a single statement followed by {bound|unbound}Values and/or followed by an array of bound values (unless they do not support any kind of grouping in which case only a solo statement can be tested - see #testUngroupedInsertCommandSQL).	In some cases, what the server will accept depends on its version.  The default values must use the functionally-safe approach (e..g no group writing, or grouped statements not values).  This test fakes up an accessor with connection to send #postLoginInitializeFromAccessor: so it can test Glorp's exploitation of the abilities of newer servers."	| platform unboundStatements unboundValues boundStatements boundValues boundArray mockAccessor |	unboundStatements := 'INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (1,NULL,NULL); INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (2,NULL,NULL)'.	boundStatements := 'INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (?,?,?); INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (?,?,?)'.	unboundValues := 'INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (1,NULL,NULL), (2,NULL,NULL)'.	boundValues := 'INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (?,?,?), (?,?,?)'.	boundArray := 'INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (?,?,?)'.	mockAccessor := GlorpMockAccessor new connection: PostgresSocketConnection new.	mockAccessor connection activeParameters		at: 'standard_conforming_strings' put: 'on';		at: 'server_version' put: '8.2'.	platform := PostgresSocketPlatform new useBinding: false.	self assertGroupWritingOnPlatform: platform printsSQL: unboundStatements.	platform := PostgresSocketPlatform new useBinding: false; postLoginInitializeFromAccessor: mockAccessor.	self assertGroupWritingOnPlatform: platform printsSQL: unboundValues.	platform := PostgresSocketPlatform new useBinding: true; postLoginInitializeFromAccessor: mockAccessor.	self assertGroupWritingOnPlatform: platform printsSQL: boundValues.	platform := PostgresLibpqPlatform new useBinding: false.	self assertGroupWritingOnPlatform: platform printsSQL: unboundStatements.	platform := PostgresLibpqPlatform new useBinding: true.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	"If our mock accessor returned #(('on')) instead of #((3)) to executeSQLString:, we could skip setting the instVar above."	platform postLoginInitializeFromAccessor: mockAccessor.	self assertGroupWritingOnPlatform: platform printsSQL: boundValues.	"Check the test raises a failure if we try to test group writing when it should not be allowed."	mockAccessor connection activeParameters at: 'server_version' put: '8.1'.	platform := PostgresSocketPlatform new useBinding: true; postLoginInitializeFromAccessor: mockAccessor.	self deny: (self twoRowInsertCommandForPlatform: platform) shouldUseGroupWriting		description: 'PostgresSocketPlatform on old server trying to group-write when bound'		resumable: true.	"We reuse the mockAccessor, exploiting the fact that the libpq connection and the socket connection both understand #serverVersion."	platform := PostgresLibpqPlatform new useBinding: true.	platform postLoginInitializeFromAccessor: mockAccessor.	self deny: (self twoRowInsertCommandForPlatform: platform) shouldUseGroupWriting		description: 'PostgresLibpqPlatform on old server trying to group-write when bound'		resumable: true.	platform := SQLServerPlatform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertGroupWritingOnPlatform: platform printsSQL: unboundValues.	platform := SQLServerPlatform new useBinding: true.	self assertGroupWritingOnPlatform: platform printsSQL: boundArray.	platform := SQLServerPlatform new useBinding: false.	self assertGroupWritingOnPlatform: platform printsSQL: unboundStatements.	"We do not use bound batching (i.e. instead of array binding) on any platform (we did on SQLServer in the past), so we have a test platform to exercise it."	platform := BatchTestPlatform new useBinding: true.	self assertGroupWritingOnPlatform: platform printsSQL: boundStatements.	platform := OraclePlatform new useBinding: true.	self assertGroupWritingOnPlatform: platform printsSQL: boundArray.	platform := OraclePlatform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self		assertGroupWritingOnPlatform: platform		printsSQL: 'INSERT ALL INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (1,NULL,NULL) INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (2,NULL,NULL) SELECT * FROM DUAL'.	platform := DB2Platform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertGroupWritingOnPlatform: platform printsSQL: unboundValues.	platform := DB2Platform new useBinding: true.	self assertGroupWritingOnPlatform: platform printsSQL: boundArray.	platform := MySQLPlatform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertGroupWritingOnPlatform: platform printsSQL: unboundValues.	platform := MySQLPlatform new useBinding: true.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertGroupWritingOnPlatform: platform printsSQL: boundValues.	platform := SQLite3Platform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertGroupWritingOnPlatform: platform printsSQL: unboundValues.	platform := SQLite3Platform new useBinding: true.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertGroupWritingOnPlatform: platform printsSQL: boundValues.</body><body package="GlorpTests">testGroupWritingUpdateCommandSQL	"Oracle and DB2 support array binding but not statement batching, so they can only group-write bound updates..  PostgreSocket supports statement batching but only for unbound statements, so can never writes groups of updates bound.  SQLServer supports array binding and statement batching, so can group-write both bound and unbound updates.  Array-bound updates share the same SQL statement so, the rows of a multi-row update command must be subdivided into subgroups of rows with values for the same subset of fields and only these subgroups can be group-written.  Batched update statements do not have this limitation."	| platform unboundStatements boundArrayAll mockAccessor boundStatements |	unboundStatements := #('UPDATE GR_ADDRESS SET STREET = ''Privet Drive'',HOUSE_NUM = ''4'' WHERE ID = 1; UPDATE GR_ADDRESS SET STREET = ''Baker Street'' WHERE ID = 2; UPDATE GR_ADDRESS SET STREET = ''Coven Street'' WHERE ID = 3; UPDATE GR_ADDRESS SET HOUSE_NUM = ''221b'' WHERE ID = 4; UPDATE GR_ADDRESS SET HOUSE_NUM = ''7'' WHERE ID = 5; UPDATE GR_ADDRESS SET HOUSE_NUM = ''12'' WHERE ID = 6').	boundStatements := #('UPDATE GR_ADDRESS SET STREET = ?,HOUSE_NUM = ? WHERE ID = ?' 'UPDATE GR_ADDRESS SET STREET = ? WHERE ID = ?; UPDATE GR_ADDRESS SET STREET = ? WHERE ID = ?' 'UPDATE GR_ADDRESS SET HOUSE_NUM = ? WHERE ID = ?; UPDATE GR_ADDRESS SET HOUSE_NUM = ? WHERE ID = ?; UPDATE GR_ADDRESS SET HOUSE_NUM = ? WHERE ID = ?').	boundArrayAll :=		#('UPDATE GR_ADDRESS SET STREET = ?,HOUSE_NUM = ? WHERE ID = ?'		'UPDATE GR_ADDRESS SET STREET = ? WHERE ID = ?'		'UPDATE GR_ADDRESS SET HOUSE_NUM = ? WHERE ID = ?').	mockAccessor := GlorpMockAccessor new connection: PostgresSocketConnection new.	mockAccessor connection activeParameters		at: 'standard_conforming_strings' put: 'on';		at: 'server_version' put: '9.4.4'.	platform := PostgresSocketPlatform new useBinding: false.	self assertGroupUpdatingOnPlatform: platform printsSQLs: unboundStatements.	platform := PostgresSocketPlatform new useBinding: false; postLoginInitializeFromAccessor: mockAccessor.	self assertGroupUpdatingOnPlatform: platform printsSQLs: unboundStatements.	platform := PostgresLibpqPlatform new useBinding: false.	self assertGroupUpdatingOnPlatform: platform printsSQLs: unboundStatements.	"We reuse the mockAccessor, exploiting the fact that the libpq connection and the socket connection both understand #serverVersion."	platform := PostgresLibpqPlatform new useBinding: false; postLoginInitializeFromAccessor: mockAccessor.	self assertGroupUpdatingOnPlatform: platform printsSQLs: unboundStatements.	"Check the test raises a failure if we try to test group writing when it should not be allowed."	platform := PostgresSocketPlatform new useBinding: true; postLoginInitializeFromAccessor: mockAccessor.	self deny: (self sixRowUpdateCommandForPlatform: platform) shouldUseGroupWriting		description: 'PostgresSocketPlatform trying to group-write updates when bound'		resumable: true.	"We reuse the mockAccessor, exploiting the fact that it's now set and both libpq and socket connection understand #serverVersion."	platform := PostgresLibpqPlatform new useBinding: true.	platform postLoginInitializeFromAccessor: mockAccessor.	self deny: (self sixRowUpdateCommandForPlatform: platform) shouldUseGroupWriting		description: 'PostgresLibpqPlatform trying to group-write updates when bound'		resumable: true.	platform := SQLServerPlatform new useBinding: false.	self assertGroupUpdatingOnPlatform: platform printsSQLs: unboundStatements.	platform := SQLServerPlatform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	"just to check this has no effect"	self assertGroupUpdatingOnPlatform: platform printsSQLs: unboundStatements.	platform := SQLServerPlatform new useBinding: true.	self assertGroupUpdatingOnPlatform: platform printsSQLs: boundArrayAll.	platform := BatchTestPlatform new useBinding: true.	self assertGroupUpdatingOnPlatform: platform printsSQLs: boundStatements.	platform := OraclePlatform new useBinding: true.	self assertGroupUpdatingOnPlatform: platform printsSQLs: boundArrayAll.	platform := DB2Platform new useBinding: true.	self assertGroupUpdatingOnPlatform: platform printsSQLs: boundArrayAll.</body><body package="GlorpTests">testGroupWritingWithIdentityColumn	"When a row is inserted into a table with a serial-type column, some servers post-assign the id value, i.e. the id is a _result_ of inserting a row and so cannot easily be known beforehand.  Glorp needs to know such ids to maintain the map between an object and row(s) written for it.  This can complicate group-writing insert statements:  if the table has a serial type and the platform uses identity columns, either a post-insert query to discover the ids must be wrapped into a grouped insert, or individual inserts, immediately succeeded by post-insert query for the id, are needed.  See #postWriteAssignSequencesUsing: versus #preWriteAssignSequencesUsing: and their call chain."	| platform unboundValues boundArray boundValues |	unboundValues := 'DECLARE @TableOfIdentities TABLE (IdentValue INT); INSERT INTO ITINERARY (RES_ID)  OUTPUT Inserted.ID INTO @TableOfIdentities(IdentValue)  VALUES (4), (5); SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue'.	boundValues := 'DECLARE @TableOfIdentities TABLE (IdentValue INT); INSERT INTO ITINERARY (RES_ID)  OUTPUT Inserted.ID INTO @TableOfIdentities(IdentValue)  VALUES (?), (?); SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue'.	boundArray := 'DECLARE @TableOfIdentities TABLE (IdentValue INT); INSERT INTO ITINERARY (RES_ID)  OUTPUT Inserted.ID INTO @TableOfIdentities(IdentValue)  VALUES (?); SELECT IdentValue FROM @TableOfIdentities ORDER BY IdentValue'.	platform := SQLServerPlatform new useBinding: true.	self assertGroupWritingIdentityOnPlatform: platform printsSQL: boundArray.	platform := SQLServerPlatform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertGroupWritingIdentityOnPlatform: platform printsSQL: unboundValues.	platform := SQLServerPlatform new useBinding: false.	self deny: (self twoRowIdentityInsertCommandForPlatform: platform) shouldUseGroupWriting		description: ('Old versions of &lt;1s&gt; &lt;2?Bound:Unbound&gt; should not attempt to group-write rows with identity column'				expandMacrosWith: platform class name				with: platform useBinding).	platform := BatchTestPlatform new useBinding: true.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertGroupWritingIdentityOnPlatform: platform printsSQL: boundValues.</body><body package="GlorpTests">testNonGroupWritingInsertCommandSQL	"The platform instances below do not currently support group writing.  If any become able to group-write, move them from this test to testGroupWriting."	| platform |	platform := OraclePlatform new useBinding: false.	"by default, assumes old version so not writing value sequences"	self assertNonGroupWritingOnPlatform: platform.	platform := DB2Platform new useBinding: false.	self assertNonGroupWritingOnPlatform: platform.	platform := MySQLPlatform new useBinding: false.	self assertNonGroupWritingOnPlatform: platform.	platform := MySQLPlatform new useBinding: true.	self assertNonGroupWritingOnPlatform: platform.	platform := SQLite3Platform new useBinding: false.	self assertNonGroupWritingOnPlatform: platform.	platform := SQLite3Platform new useBinding: true.	self assertNonGroupWritingOnPlatform: platform.	platform := FirebirdPlatform new useBinding: false.	self assertNonGroupWritingOnPlatform: platform.	platform := FirebirdPlatform new useBinding: true.	self assertNonGroupWritingOnPlatform: platform.	platform := AccessPlatform new useBinding: false.	self assertNonGroupWritingOnPlatform: platform.	platform := AccessPlatform new useBinding: true.	self assertNonGroupWritingOnPlatform: platform.</body><body package="GlorpTests">testNonGroupWritingUpdateCommandSQL	"The platform instances below do not currently support group writing of update commands.  If any become able to group-write updates, move them from this test to testGroupWriting."	| platform |	platform := OraclePlatform new useBinding: false.	self assertNonGroupUpdatingOnPlatform: platform.	platform := OraclePlatform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := DB2Platform new useBinding: false.	self assertNonGroupUpdatingOnPlatform: platform.	platform := DB2Platform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := PostgresSocketPlatform new useBinding: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := MySQLPlatform new useBinding: false.	self assertNonGroupUpdatingOnPlatform: platform.	platform := MySQLPlatform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := MySQLPlatform new useBinding: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := MySQLPlatform new useBinding: true.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := SQLite3Platform new useBinding: false.	self assertNonGroupUpdatingOnPlatform: platform.	platform := SQLite3Platform new useBinding: false.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := SQLite3Platform new useBinding: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := SQLite3Platform new useBinding: true.	platform instVarNamed: 'supportsGroupWritingValues' put: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := FirebirdPlatform new useBinding: false.	self assertNonGroupUpdatingOnPlatform: platform.	platform := FirebirdPlatform new useBinding: true.	self assertNonGroupUpdatingOnPlatform: platform.	platform := AccessPlatform new useBinding: false.	self assertNonGroupUpdatingOnPlatform: platform.	platform := AccessPlatform new useBinding: true.	self assertNonGroupUpdatingOnPlatform: platform.</body><body package="GlorpTests">testNonGroupWritingWithIdentityColumn	"The platform instances below do not currently support group writing.  If any become able to group-write, move them from this test to testGroupWriting."	| platform command requiredStrings actualStrings |	platform := SQLServerPlatform new useBinding: false.	command := self twoRowIdentityInsertCommandForPlatform: platform.	self deny: command shouldUseGroupWriting		description: ('Old SQLServerPlatform unbound should not group-write multi-row &lt;1s&gt;'					expandMacrosWith: command class name).	requiredStrings := OrderedCollection		with: 'INSERT INTO ITINERARY (RES_ID)  VALUES (4); SELECT SCOPE_IDENTITY()'		with: 'INSERT INTO ITINERARY (RES_ID)  VALUES (5); SELECT SCOPE_IDENTITY()'.	actualStrings := OrderedCollection new.	"Mimic the first lines of execute{Unbound|Bound}In: to test non-group writing"	(command hasMultipleRows and: [command shouldUseGroupWriting not]) ifTrue:		[command allRowsSinglyEvaluate: [actualStrings add: command sqlString]].	actualStrings with: requiredStrings do:		[:actualString :requiredString |		self			assert: actualString = requiredString			description: ('Inserting ungrouped row to &lt;1s&gt; &lt;2?Bound:Unbound&gt; wrote &lt;3s&gt; instead of expected &lt;4s&gt;'						expandMacrosWith: platform class name						with: platform useBinding						with: actualString						with: requiredString)			resumable: true].</body></methods><methods><class-id>Glorp.GlorpSQLPrintingTest</class-id> <category>utilities-update</category><body package="GlorpTests">assertGroupUpdatingOnPlatform: platform printsSQLs: sqlStrings	"The parameter platform instance is configured to allow group writing.  Verify that a five-row UpdateCommand created from it will group-write by evaluating the relevant code in RowBasedCommand&gt;&gt;execute{Bound|Unbound}In:, which is	self hasMultipleRows and: [self shouldUseGroupWriting not] ...(as we know our test command has multiple rows, we only check #shouldUseGroupWriting).  Then check the command's SQL.  The update command may subgroup its rows according to the SQL command, so we get the SQL string for each subgroup."	| command actualStrings |	command := self sixRowUpdateCommandForPlatform: platform.	self assert: command shouldUseGroupWriting		description: ('&lt;1s&gt; &lt;2?Bound:Unbound&gt; cannot group-write multi-row &lt;3s&gt;'					expandMacrosWith: platform class name					with: platform useBinding					with: command class name).	actualStrings := OrderedCollection new.	command allRowsGrouped: 1000 evaluate:		[actualStrings add: command sqlString].	sqlStrings with: actualStrings do:		[:sqlString :actualString |		self assert: actualString = sqlString			description: ('&lt;1s&gt; &lt;2?Bound:Unbound&gt; wrote &lt;3s&gt; instead of expected &lt;4s&gt;'						expandMacrosWith: platform class name						with: platform useBinding						with: actualString						with: sqlString)		resumable: true].</body><body package="GlorpTests">assertNonGroupUpdatingOnPlatform: aDatabasePlatform	"The parameter platform instance is not configured to allow group writing.  Verify that a multi-row UpdateCommand created from it will not group-write by evaluating the relevant code in UpdateCommand&gt;&gt;execute{Bound|Unbound}In:, which is	self hasMultipleRows and: [self shouldUseGroupWriting not] ...(as we know our test command has multiple rows, we only check #shouldUseGroupWriting).  Then check each row's SQL under the		self allRowsSinglyEvaluate: [ ... self sqlString ...]follow-on code of those methods."	| command requiredStrings actualStrings |	command := self sixRowUpdateCommandForPlatform: aDatabasePlatform.	self deny: command shouldUseGroupWriting		description: ('&lt;1s&gt; &lt;2?Bound:Unbound&gt; should not group-write multi-row &lt;3s&gt;'					expandMacrosWith: aDatabasePlatform class name					with: aDatabasePlatform useBinding					with: command class name).	requiredStrings := command useBinding		ifFalse: [#('UPDATE GR_ADDRESS SET STREET = ''Privet Drive'',HOUSE_NUM = ''4'' WHERE ID = 1'				'UPDATE GR_ADDRESS SET STREET = ''Baker Street'' WHERE ID = 2'				'UPDATE GR_ADDRESS SET STREET = ''Coven Street'' WHERE ID = 3'				'UPDATE GR_ADDRESS SET HOUSE_NUM = ''221b'' WHERE ID = 4'				'UPDATE GR_ADDRESS SET HOUSE_NUM = ''7'' WHERE ID = 5'				'UPDATE GR_ADDRESS SET HOUSE_NUM = ''12'' WHERE ID = 6')]		ifTrue: [#('UPDATE GR_ADDRESS SET STREET = ?,HOUSE_NUM = ? WHERE ID = ?'				'UPDATE GR_ADDRESS SET STREET = ? WHERE ID = ?'				'UPDATE GR_ADDRESS SET STREET = ? WHERE ID = ?'				'UPDATE GR_ADDRESS SET HOUSE_NUM = ? WHERE ID = ?'				'UPDATE GR_ADDRESS SET HOUSE_NUM = ? WHERE ID = ?'				'UPDATE GR_ADDRESS SET HOUSE_NUM = ? WHERE ID = ?')].	actualStrings := OrderedCollection new.	"Mimic the first lines of execute{Unbound|Bound}In: to test non-group writing"	(command hasMultipleRows and: [command shouldUseGroupWriting not])		ifTrue: [command allRowsSinglyEvaluate: [actualStrings add: command sqlString]].	actualStrings with: requiredStrings do:		[:actualString :requiredString |		self assert: actualString = requiredString			description: ('Updating ungrouped row to &lt;1s&gt; &lt;2?Bound:Unbound&gt; wrote &lt;3s&gt; instead of expected &lt;4s&gt;'					expandMacrosWith: aDatabasePlatform class name					with: aDatabasePlatform useBinding					with: actualString					with: requiredString)		resumable: true].</body><body package="GlorpTests">sixRowUpdateCommandForPlatform: aDatabasePlatform	"A trivial multi-row update command for testing group writing.  One row has values for all three fields, two have values for ID and STREET, three have values for ID and HOUSE_NUM.  (These row numbers - 1, 2 and 3 - are used as indexes to get specific results in callers.)"	| rows session system table |	session := GlorpDemoDescriptorSystem sessionForLogin: (Login new database: aDatabasePlatform).	system := session system.	table := system tableNamed: 'GR_ADDRESS'.	rows := OrderedCollection new: 6.	"ID, STREET and HOUSE_NUM have values"	rows add: (DatabaseRow newForTable: table).	rows last		atFieldNamed: 'ID' put: 1;		atFieldNamed: 'STREET' put: 'Privet Drive';		atFieldNamed: 'HOUSE_NUM' put: '4'.	"ID and STREET have values"	rows add: (DatabaseRow newForTable: table).	rows last		atFieldNamed: 'ID' put: 2;		atFieldNamed: 'STREET' put: 'Baker Street'.	rows add: (DatabaseRow newForTable: table).	rows last		atFieldNamed: 'ID' put: 3;		atFieldNamed: 'STREET' put: 'Coven Street'.	"ID and HOUSE_NUM have values"	rows add: (DatabaseRow newForTable: table).	rows last		atFieldNamed: 'ID' put: 4;		atFieldNamed: 'HOUSE_NUM' put: '221b'.	rows add: (DatabaseRow newForTable: table).	rows last		atFieldNamed: 'ID' put: 5;		atFieldNamed: 'HOUSE_NUM' put: '7'.	rows add: (DatabaseRow newForTable: table).	rows last		atFieldNamed: 'ID' put: 6;		atFieldNamed: 'HOUSE_NUM' put: '12'.	^session platform		updateCommandForRows: rows asArray		binding: session useBinding		session: session</body></methods><methods><class-id>Glorp.GlorpSQLPrintingTest</class-id> <category>utilities-insert</category><body package="GlorpTests">assertGroupWritingIdentityOnPlatform: platform printsSQL: aString	| command actualString |	command := self twoRowIdentityInsertCommandForPlatform: platform.	self assert: command shouldUseGroupWriting		description: ('&lt;1s&gt; &lt;2?Bound:Unbound&gt; cannot group-write multi-row &lt;3s&gt;'				expandMacrosWith: platform class name				with: platform useBinding				with: command class name).	actualString := command sqlString.	self		assert: actualString = aString		description: ('&lt;1s&gt; &lt;2?Bound:Unbound&gt; wrote &lt;3s&gt; instead of expected &lt;4s&gt;'				expandMacrosWith: platform class name				with: platform useBinding				with: actualString				with: aString)		resumable: true.</body><body package="GlorpTests">assertGroupWritingOnPlatform: platform printsSQL: aString	"The parameter platform instance is configured to allow group writing.  Verify that a two-row InsertCommand created from it will group-write by evaluating the relevant code in RowBasedCommand&gt;&gt;execute{Bound|Unbound}In:, which is	self hasMultipleRows and: [self shouldUseGroupWriting not] ...(as we know our test command has two rows, we only check #shouldUseGroupWriting).  Then check the command's SQL."	| command actualString |	command := self twoRowInsertCommandForPlatform: platform.	self assert: command shouldUseGroupWriting		description: ('&lt;1s&gt; &lt;2?Bound:Unbound&gt; cannot group-write multi-row &lt;3s&gt;'					expandMacrosWith: platform class name					with: platform useBinding					with: command class name).	actualString := command sqlString.	self assert: actualString = aString		description: ('&lt;1s&gt; &lt;2?Bound:Unbound&gt; wrote &lt;3s&gt; instead of expected &lt;4s&gt;'					expandMacrosWith: platform class name					with: platform useBinding					with: actualString					with: aString)		resumable: true.</body><body package="GlorpTests">assertNonGroupWritingOnPlatform: aDatabasePlatform	"The parameter platform instance is not configured to allow group writing.  Verify that a two-row InsertCommand created from it will not group-write by evaluating the relevant code in InsertCommand&gt;&gt;execute{Bound|Unbound}In:, which is	self hasMultipleRows and: [self shouldUseGroupWriting not] ...(as we know our test command has two rows, we only check #shouldUseGroupWriting).  Then check each row's SQL under the		self allRowsSinglyEvaluate: [ ... self sqlString ...]follow-on code of those methods."	| command requiredStrings actualStrings |	command := self twoRowInsertCommandForPlatform: aDatabasePlatform.	self deny: command shouldUseGroupWriting		description: ('&lt;1s&gt; &lt;2?Bound:Unbound&gt; should not group-write multi-row &lt;3s&gt;'					expandMacrosWith: aDatabasePlatform class name					with: aDatabasePlatform useBinding					with: command class name).	requiredStrings := command useBinding		ifFalse: [OrderedCollection				with: 'INSERT INTO GR_ADDRESS (ID)  VALUES (1)'				with: 'INSERT INTO GR_ADDRESS (ID)  VALUES (2)']		ifTrue: [OrderedCollection				with: 'INSERT INTO GR_ADDRESS (ID)  VALUES (?)'				with: 'INSERT INTO GR_ADDRESS (ID)  VALUES (?)'].	actualStrings := OrderedCollection new.	"Mimic the first lines of execute{Unbound|Bound}In: to test non-group writing"	(command hasMultipleRows and: [command shouldUseGroupWriting not])		ifTrue: [command allRowsSinglyEvaluate: [actualStrings add: command sqlString]].	actualStrings with: requiredStrings do:		[:actualString :requiredString |		self assert: actualString = requiredString			description: ('Inserting ungrouped row to &lt;1s&gt; &lt;2?Bound:Unbound&gt; wrote &lt;3s&gt; instead of expected &lt;4s&gt;'					expandMacrosWith: aDatabasePlatform class name					with: aDatabasePlatform useBinding					with: actualString					with: requiredString)		resumable: true].</body><body package="GlorpTests">twoRowIdentityInsertCommandForPlatform: aDatabasePlatform	"A trivial multi-row insert command for testing group writing.  Make the command use binding if the platform instance is configured to use binding."	| row1 row2 session system |	session := GlorpDemoDescriptorSystem sessionForLogin: (Login new database: aDatabasePlatform).	system := session system.	row1 := DatabaseRow newForTable: (system tableNamed: 'ITINERARY').	row1 atFieldNamed: 'RES_ID' put: 4.	row2 := DatabaseRow newForTable: (system tableNamed: 'ITINERARY').	row2 atFieldNamed: 'RES_ID' put: 5.	^session platform		insertCommandForRows: (Array with: row1 with: row2)		binding: session useBinding		session: session</body><body package="GlorpTests">twoRowInsertCommandForPlatform: aDatabasePlatform	"A trivial multi-row insert command for testing group writing."	| row1 row2 session system |	session := GlorpDemoDescriptorSystem sessionForLogin: (Login new database: aDatabasePlatform).	system := session system.	row1 := DatabaseRow newForTable: (system tableNamed: 'GR_ADDRESS').	row1 atFieldNamed: 'ID' put: 1.	row2 := DatabaseRow newForTable: (system tableNamed: 'GR_ADDRESS').	row2 atFieldNamed: 'ID' put: 2.	^session platform		insertCommandForRows: (Array with: row1 with: row2)		binding: session useBinding		session: session</body></methods><methods><class-id>Glorp.GlorpTimedStrongCacheTest</class-id> <category>tests</category><body package="GlorpTests">setUp	super setUp.	self setUpExpiryWithRealDelay.</body><body package="GlorpTests">setUpExpiryWithRealDelay	(cache session descriptorFor: GlorpCustomer) cachePolicy: (TimedStrongCachePolicy new timeout: 1).	(cache session descriptorFor: GlorpBankTransaction) cachePolicy: (TimedStrongCachePolicy new timeout: 1).</body><body package="GlorpTests">setUpExpiryWithZeroDelay	(cache session descriptorFor: GlorpCustomer) cachePolicy: (TimedStrongCachePolicy new timeout: 0).	(cache session descriptorFor: GlorpBankTransaction) cachePolicy: (TimedStrongCachePolicy new timeout: 0).</body><body package="GlorpTests">setUpForExpiryActionOf: aSymbol	(cache session descriptorFor: GlorpCustomer) cachePolicy expiryAction: aSymbol.	(cache session descriptorFor: GlorpBankTransaction) cachePolicy expiryAction: aSymbol.</body><body package="GlorpTests">setUpForNotifyAndRemove	self setUpForExpiryActionOf: #notifyAndRemove.</body><body package="GlorpTests">setUpForRefresh	self setUpForExpiryActionOf: #refresh.</body><body package="GlorpTests">testExpiryReturningNilWithRealDelay	"test that objects expire with a non-zero delay time."	| customer customer2 |	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	(Delay forSeconds: 2) wait.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	customer2 := GlorpCustomer new.	cache at: 3 insert: customer2.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer2.</body><body package="GlorpTests">testNotExpiredAfterRefresh	| customer |	self setUpForRefresh.	session accessor beginTransaction.	[session accessor executeSQLStringNoResult: 'INSERT INTO GR_CUSTOMER VALUES (3,''Fred Flintstone'')'.	customer := session execute: (Query readOneOf: GlorpCustomer where: [:each | each id = 3]).	(Delay forSeconds: 2) wait.	self assert: (cache hasExpired: customer).	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer.	self deny: (cache hasExpired: customer)]		ensure: [session accessor rollbackTransaction].</body><body package="GlorpTests">testNotify	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotify.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self deny: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	self assert: customer seenExpiry.</body><body package="GlorpTests">testNotifyAndRemove	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotifyAndRemove.	customer := GlorpCustomer example1.	cache at: 3 insert: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == nil.	self assert: customer seenExpiry = true.</body><body package="GlorpTests">testRegisteredObjectsDoNotExpire	| customer |	self setUpExpiryWithZeroDelay.	self setUpForNotifyAndRemove.	customer := GlorpCustomer example1.	customer id: 3.	cache at: 3 insert: customer.	session beginUnitOfWork.	session register: customer.	self assert: (cache lookupClass: GlorpCustomer key: 3 ifAbsent: [nil]) == customer.	self deny: customer seenExpiry.</body></methods><methods><class-id>Glorp.GlorpTimedStrongCacheTest</class-id> <category>support</category><body package="GlorpTests">setUpForNotify	self setUpForExpiryActionOf: #notify.</body></methods><methods><class-id>Glorp.GlorpDatabaseAccessorTest</class-id> <category>tests</category><body package="GlorpTests">testLoggingSwitch	| currentSetting accessor |	currentSetting := DatabaseAccessor loggingEnabled.	accessor := DatabaseAccessor new.	[DatabaseAccessor loggingEnabled: true.	self assert: accessor logging.	DatabaseAccessor loggingEnabled: false.	self deny: accessor logging.	accessor logging: true.	self assert: accessor logging.	accessor logging: false.	self deny: accessor logging.	DatabaseAccessor loggingEnabled: true.	self deny: accessor logging] ensure: [DatabaseAccessor loggingEnabled: currentSetting].</body></methods><methods><class-id>Glorp.GlorpMatchDeleteInsertTest</class-id> <category>running</category><body package="GlorpTests">depopulate	| workers tasks |	session reset.	session beginUnitOfWork.	workers := session read: GlorpTaskedWorker.	session deleteAll: workers.	tasks := session read: GlorpWorkerTask.	session deleteAll: tasks.	session commitUnitOfWork.</body><body package="GlorpTests">populate	| workers |	session beginUnitOfWork.	workers := GlorpTaskedWorker example1.	session register: workers.	session commitUnitOfWork.</body><body package="GlorpTests">repopulate	self depopulate.	self populate.</body><body package="GlorpTests">setUp	super setUp.	session system: (GlorpDictionaryDescriptorSystem forPlatform: session platform).	self repopulate.</body><body package="GlorpTests">tearDown	session rollbackUnitOfWork.	self depopulate.	super tearDown</body><body package="GlorpTests">testLinkBasic	"Just a smoke test to ensure that the general setup is okay."	| workers exampleWorkers |	workers := session read: GlorpTaskedWorker orderBy: #name.	exampleWorkers := (GlorpTaskedWorker example1) asSortedCollection: [:a :b| a name &lt; b name].	self assert: (workers size = exampleWorkers size).	self assert: ((workers at: 3) isSimilarToWorker: (exampleWorkers at: 3)).</body><body package="GlorpTests">testLinkDelete	"Change link table rows, not either of the two class tables.  This will not throw an exception in RowMap&gt;&gt;collapseMatchingInsertsAndDeletesFor:"	| worker taskKey |	session beginTransaction.	session inUnitOfWorkDo: [		worker := session readOneOf: GlorpTaskedWorker where: [:each| each name = 'Jim'].		session read: GlorpWorkerTask orderBy: #description.		taskKey := worker tasks keys asArray first.		worker tasks removeKey: taskKey ifAbsent:			[self assert: false description: 'Task not found']].	session rollbackTransaction.</body><body package="GlorpTests">testLinkReplace	"Change link table rows, not either of the two class tables.  This will not throw an exception in RowMap&gt;&gt;collapseMatchingInsertsAndDeletesFor:"	| tasks worker taskToRemove |	session inUnitOfWorkDo:		[worker := session readOneOf: GlorpTaskedWorker where: [:each| each name = 'Jim'].		tasks := session read: GlorpWorkerTask orderBy: #description.		taskToRemove := worker tasks keys asOrderedCollection first.		worker addTask: (tasks at: 2) key: 'Shop'.		worker addTask: (tasks at: 4) key: 'Relax'.		worker removeTaskAtKey: taskToRemove].	worker := session readOneOf: GlorpTaskedWorker where: [:each| each name = 'Jim'].	tasks := worker tasks.	self assert: (tasks size = 2).	self assert: (tasks keys includes: 'Shop').	self assert: (tasks keys includes: 'Relax').</body><body package="GlorpTests">testObjDeleteInsertLinkInLaterUoV	"We delete and create a Task in the same Unit of Work forcing use of the same primary key, but only link it to the same Worker in a later Unit of Work."	| worker oldTask newTask oldTaskKey |	session inUnitOfWorkDo:		[worker := session readOneOf: GlorpTaskedWorker where: [:each | each name = 'Jenny'].		oldTask := worker tasks values first.		oldTaskKey := worker tasks keys asOrderedCollection first.		worker removeTaskAtKey: oldTaskKey.		session delete: oldTask.		newTask := GlorpWorkerTask new description: 'Wax floors'; id: oldTask id; yourself.		session register: newTask].	session inUnitOfWorkDo:		[worker := session readOneOf: GlorpTaskedWorker where: [:each | each name = 'Jenny'].		newTask := session readOneOf: GlorpWorkerTask where: [:each | each description = 'Wax floors'].		worker addTask: newTask key: 'Wax'].	worker := session readOneOf: GlorpTaskedWorker where: [:each | each name = 'Jenny'].	self assert: (worker tasks anySatisfy: [:task | task description = 'Wax floors'])</body><body package="GlorpTests">testObjDeleteInsertLinkInSameUoW	"We delete and create a Task in the same Unit of Work forcing use of the same primary key, and link it to the same Worker in that same Unit of Work."	| worker oldTask newTask oldTaskKey |	session inUnitOfWorkDo:		[worker := session readOneOf: GlorpTaskedWorker where: [:each | each name = 'Jenny'].		oldTask := worker tasks values first.		oldTaskKey := worker tasks keys asOrderedCollection first.		worker removeTaskAtKey: oldTaskKey.		session delete: oldTask.		newTask := GlorpWorkerTask new description: 'Wax floors'; id: oldTask id; yourself.		session register: newTask.		worker addTask: newTask key: 'Wax'].	worker := session readOneOf: GlorpTaskedWorker where: [:each | each name = 'Jenny'].	self assert: (worker tasks anySatisfy: [:task | task description = 'Wax floors'])</body></methods><methods><class-id>Glorp.GlorpWeakCacheTest</class-id> <category>support</category><body package="GlorpTests">checkCacheExhaustivelyFor: aBlock	"Check to make sure the cache satisfies the criteria. Since this relies on unpredictable finalization, do a full 10 garbage collect then wait iterations. Don't return early, because we're checking to see that finalization *doesn't* happen"	self assert: (self doesCacheExhaustivelySatisfy: aBlock).</body><body package="GlorpTests">checkCacheFor: aBlock	"Check to make sure the cache satisfies the criteria. Since this relies on unpredictable finalization, do up to 10 garbage collect then wait iterations. If it's true before that, return early, but if it's not true at the end, fail"	self assert: (self doesCacheSatisfy: aBlock).</body><body package="GlorpTests">doesCacheExhaustivelySatisfy: aBlock	| result |	result := false.	10		timesRepeat:			[Dialect garbageCollect.			(Delay forMilliseconds: 100) wait.			result := aBlock value].	^result.</body><body package="GlorpTests">doesCacheSatisfy: aBlock	10		timesRepeat:			[Dialect garbageCollect.			(Delay forMilliseconds: 100) wait.			aBlock value ifTrue: [^true]].	^false.</body><body package="GlorpTests">mournKeyOf: anEphemeron	mourned := true.</body><body package="GlorpTests">setUp	super setUp.	system cachePolicy: WeakVWCachePolicy new.	mourned := false.</body></methods><methods><class-id>Glorp.GlorpWeakCacheTest</class-id> <category>initializing</category><body package="GlorpTests">initialize</body></methods><methods><class-id>Glorp.GlorpWeakCacheTest</class-id> <category>tests</category><body package="GlorpTests">testEphemeralValue	| value ephemeron |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	value := Object new.	ephemeron := (Dialect smalltalkAt: #EphemeralValue) key: 'abc' value: value.	ephemeron manager: self.	Dialect garbageCollect.	value := nil.	self should: [10 timesRepeat: [		mourned ifFalse: [Dialect garbageCollect.		(Delay forMilliseconds: 100) wait]].		mourned].</body><body package="GlorpTests">testEphemeralValueDictionary	| value dict done |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	value := Object new.	dict := WeakVWCachePolicy new dictionaryClass new.	dict at: 'abc' put: value.	Dialect garbageCollect.	value := nil.	done := false.	self should:		[10	timesRepeat:			[done ifFalse: [				Dialect garbageCollect.				(Delay forMilliseconds: 100) wait.				done := dict size = 0]].			 done].</body><body package="GlorpTests">testEphemeron	| value ephemeron |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	value := Object new.	ephemeron := (Dialect smalltalkAt: #Ephemeron) key: value value: 'abc'.	ephemeron manager: self.	Dialect garbageCollect.	value := nil.	self should: [10 timesRepeat: [		mourned ifFalse: [Dialect garbageCollect.		(Delay forMilliseconds: 100) wait]].		mourned].</body><body package="GlorpTests">testEphemeronDictionary	| value dict done |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	value := Object new.	dict := (Dialect smalltalkAt: #EphemeronDictionary) new.	dict at: value put: 'abc'.	Dialect garbageCollect.	value := nil.	done := false.	self should:		[10	timesRepeat:			[done ifFalse: [				Dialect garbageCollect.				(Delay forMilliseconds: 100) wait.				done := dict size = 0]].			 done].</body><body package="GlorpTests">testLargeWeakDictionary	| elements size customers newElements |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	system cachePolicy numberOfElements: 1.	size := 2 raisedTo: 14.	customers := OrderedCollection new: size.	1 to: size do: [:i | | cust |		cust := GlorpCustomer new.		customers add: cust.		cache at: i insert: cust].	elements := cache numberOfElements.	self assert: elements = (2 raisedTo: 14).	customers := nil.	Dialect garbageCollect.	(Delay forSeconds: 2) wait.	Dialect garbageCollect.	(Delay forSeconds: 1) wait.	newElements := cache numberOfElements.	self assert: newElements = 1.</body><body package="GlorpTests">testUnreferencedExcessObjectsAreRemoved	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	system cachePolicy numberOfElements: 1.	cache at: 3 insert: GlorpCustomer new.	cache at: 4 insert: GlorpCustomer new.	self checkCacheFor: [(cache containsObjectForClass: GlorpCustomer key: 3) not].	self assert: (cache containsObjectForClass: GlorpCustomer key: 4).</body><body package="GlorpTests">testUnreferencedObjectsAreRemoved	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	system cachePolicy numberOfElements: 0.	cache at: 3 insert: GlorpCustomer new.	self		checkCacheFor: [(cache containsObjectForClass: GlorpCustomer key: 3) not].</body><body package="GlorpTests">testUnreferencedObjectsAreRemovedInTheRightOrder	| customer |	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	system cachePolicy numberOfElements: 1.	cache at: 3 insert: GlorpCustomer new.	cache at: 4 insert: GlorpCustomer new.	customer := cache lookupClass: GlorpCustomer key: 3.	self deny: customer isNil.	cache at: 3 insert: customer.	self checkCacheFor: [(cache containsObjectForClass: GlorpCustomer key: 4) not].	self assert: (cache containsObjectForClass: GlorpCustomer key: 3).</body><body package="GlorpTests">testUnreferencedObjectsNotRemovedDueToExtraReferences	Dialect isVWWithNameSpaces ifFalse: [ ^self ].	cache at: 3 insert: GlorpCustomer new.	self checkCacheExhaustivelyFor: [(cache containsObjectForClass: GlorpCustomer key: 3)].</body></methods><methods><class-id>Glorp.GlorpWeakCacheTest class</class-id> <category>instance creation</category><body package="GlorpTests">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpPublisher</class-id> <category>accessing</category><body package="GlorpTestModels">differentBunchOfEmployeesById	^differentBunchOfEmployeesById</body><body package="GlorpTestModels">differentBunchOfEmployeesById: aDictionary	differentBunchOfEmployeesById := aDictionary</body><body package="GlorpTestModels">employees	^employees.</body><body package="GlorpTestModels">employees: aDictionary	employees := aDictionary.</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body><body package="GlorpTestModels">titles	^titles</body><body package="GlorpTestModels">titles: aCollectionOfStrings	titles := aCollectionOfStrings</body><body package="GlorpTestModels">titlesWithNumberInStock	^titlesWithNumberInStock</body><body package="GlorpTestModels">titlesWithNumberInStock: aDictionary	titlesWithNumberInStock := aDictionary.	self titlesWithNumberInStockLink: (Dictionary new addAll: (aDictionary associations collect: [:each | each copy]); yourself).</body><body package="GlorpTestModels">titlesWithNumberInStockLink	^titlesWithNumberInStockLink</body><body package="GlorpTestModels">titlesWithNumberInStockLink: aDictionary	titlesWithNumberInStockLink := aDictionary</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests</category><body package="GlorpTests">testCasesToWrite	"How des a dictionary mapping relate to 1:many vs many:many.	dictionary of strings to strings	dictionary of strings to objects	dictionary of objects to objects	keys always have to be related to values somehow, because I can't extract the association otherwise. Both might also be associated to source.    You should be able to use the topological sort to determine the create/delete order of tables as well"</body><body package="GlorpTests">testCollectionKeyQuery	| encyclopedias matches |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset."	matches := session read: GlorpEncyclopedia where: [:each | each entries anySatisfy: [:eachEntry |		((eachEntry getTable: 'ENCYC_ENTRY_LINK') getField: 'REFERENCE_NO') = 'unique']]."	matches := session read: GlorpEncyclopedia where:		[:each | each entries anySatisfy: [:eachEntry | eachEntry key = 'unique']].	self assert: matches size = 1.	self assert: matches first name = 'The Canadian Encyclopedia'.	matches do: [:each | self assert: (each entries anySatisfy: [:eachEntry | eachEntry id = 'three'])].	matches do: [:each | self assert: each entries size = 3].</body><body package="GlorpTests">testCollectionValueQuery	| encyclopedias matches |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	matches := session read: GlorpEncyclopedia where: [:each | each entries anySatisfy: [:eachEntry |		eachEntry value title = 'Vehicular Fish Decay']].	self assert: matches size = 1.	self assert: matches first name = 'The Canadian Encyclopedia'.	matches do: [:each | self assert: (each entries anySatisfy: [:eachEntry | eachEntry id = 'three'])].	matches do: [:each | self assert: each entries size = 3].</body><body package="GlorpTests">testCollectionValueQueryWithImpliedValue	| encyclopedias matches |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	matches := session read: GlorpEncyclopedia where: [:each | each entries anySatisfy: [:eachEntry |		eachEntry title = 'Vehicular Fish Decay']].	self assert: matches size = 1.	self assert: matches first name = 'The Canadian Encyclopedia'.	matches do: [:each | self assert: (each entries anySatisfy: [:eachEntry | eachEntry id = 'three'])].	matches do: [:each | self assert: each entries size = 3].</body><body package="GlorpTests">testCollectionValueQueryWithImpliedValueAndObjectEquality	| encyclopedias matches entry |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	entry := session readOneOf: GlorpEncyclopediaEntry where: [:each | each title = 'Vehicular Fish Decay'].	matches := session read: GlorpEncyclopedia where: [:each | each entries anySatisfy: [:eachEntry |		eachEntry = entry]].	self assert: matches size = 1.	self assert: matches first name = 'The Canadian Encyclopedia'.	matches do: [:each | self assert: (each entries anySatisfy: [:eachEntry | eachEntry id = 'three'])].	matches do: [:each | self assert: each entries size = 3].</body><body package="GlorpTests">testQueryWithDictionaryType	| encyclopedias query dict linkTable entryTable refField linkTableField idField |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	linkTable := session system tableNamed: 'ENCYC_ENTRY_LINK'.	entryTable := session system tableNamed: 'ENCYC_ENTRY'.	refField := linkTable fieldNamed: 'REFERENCE_NO'.	linkTableField := linkTable fieldNamed: 'ENCYC_ENTRY_ID'.	idField := entryTable fieldNamed: 'ID'.	query := Query read: GlorpEncyclopediaEntry.	query whereClause: [:each | ((each getTable: linkTable) getField: linkTableField) = ((each getTable: entryTable) getField: idField)].	query retrieveDictionaryWithKey: [:each | (each getTable: linkTable) getField: refField] value: [:each | each].	dict := session execute: query.	self assert: dict class == Dictionary.	self assert: dict size = 5.	self assert: (dict at: 'abcde') id = 'two'.	self assert: (dict at: 'abcde') == (dict at: 'edcba').</body><body package="GlorpTests">testReadWithAlsoFetch	| encyclopedias query readBackEncyclopedias |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	query := Query read: GlorpEncyclopedia.	query orderBy: [:each | each name].	query alsoFetch: [:each | each entries beOuterJoin].	readBackEncyclopedias := session execute: query.	session accessor denyReads.	self verifyEncyclopedias: readBackEncyclopedias.</body><body package="GlorpTests">testReadWithRetrieve	| encyclopedias query readBackEncyclopedias |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	query := Query read: GlorpEncyclopedia.	query orderBy: [:each | each name].	query retrieve: [:each | each].	query retrieve: [:each | each entries beOuterJoin].	readBackEncyclopedias := session execute: query.	session accessor denyReads.	self assert: readBackEncyclopedias size = 6.	self verifyEncyclopedias:		((readBackEncyclopedias collect: [:each | each first])			asSet asSortedCollection: [:a :b | a name &lt;= b name]).	readBackEncyclopedias do:		[:eachArray |		eachArray last key isNil			ifTrue: [self assert: eachArray first entries isEmpty]			ifFalse: [self assert: (eachArray first entries at: eachArray last key) = eachArray last value]].</body><body package="GlorpTests">testUpdate	| encyclopedias canadian allEntryRows allLinkRows |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	session accessor denyCommand: DeleteCommand.	session inUnitOfWorkDo:		[| newEntry |		canadian := session readOneOf: GlorpEncyclopedia where: [:each | each name like: 'The Ca%'].		newEntry := GlorpEncyclopediaEntry new			id: 'seven';			title: 'The Latest Entry';			text: 'This is all about the very newest stuff'.		canadian entries at: 'unique' put: newEntry].	self assert: (canadian entries at: 'abcde') id = 'two'.	self assert: (canadian entries at: '12345') id = 'one'.	self assert: (canadian entries at: 'unique') id = 'seven'.	self assert: (canadian entries at: 'unique') title = 'The Latest Entry'.	allEntryRows := session accessor executeSQLString: 'select * from ENCYC_ENTRY'.	"We didn't actually delete the 'three' entry"	self assert: allEntryRows size = 4.	allLinkRows := session accessor executeSQLString: 'select * from ENCYC_ENTRY_LINK'.	"But we should have only our 3 link table rows, plus 2 for the other encyclopedia"	self assert: allLinkRows size = 5.</body><body package="GlorpTests">testUpdateNonLinkTable	"Test updating a dictionary where we don't have a link table, but the target table refers back to the containing object."	| encyclopedias canadian bio newBio |	encyclopedias := session system exampleEncyclopedias.	bio := GlorpEncyclopediaBioEntry new title: 'Alan Kay'; text: 'A stub'.	encyclopedias first biographicalEntries at: bio title put: bio.	session transact: [session register: encyclopedias].	session reset.	session inUnitOfWorkDo: [		canadian := session readOneOf: GlorpEncyclopedia where: [:each | each name like: 'The Ca%'].		newBio := GlorpEncyclopediaBioEntry new			title: 'Alan Kay';			text: 'a bit more information'.		canadian biographicalEntries at: 'Alan Kay' put: newBio].	session reset.	canadian := session readOneOf: GlorpEncyclopedia where: [:each | each name like: 'The Ca%'].	self assert: canadian biographicalEntries size = 1.	self assert: (canadian biographicalEntries at: 'Alan Kay') text = 'a bit more information'.	self assert: (session count: GlorpEncyclopediaBioEntry) = 1.</body><body package="GlorpTests">testWriteAndReadBack	| encyclopedias query readBackEncyclopedias |	encyclopedias := session system exampleEncyclopedias.	session transact: [session register: encyclopedias].	session reset.	query := Query read: GlorpEncyclopedia.	query orderBy: [:each | each name].	readBackEncyclopedias := session execute: query.	self verifyEncyclopedias: readBackEncyclopedias.</body><body package="GlorpTests">verifyEncyclopedias: readBackEncyclopedias	| plagiarists canadian |	self assert: readBackEncyclopedias size = 3.	canadian := readBackEncyclopedias first.	self assert: canadian name = 'The Canadian Encyclopedia'.	self assert: canadian entries size = 3.	self assert: (canadian entries at: 'abcde') id = 'two'.	self assert: (canadian entries at: '12345') id = 'one'.	self assert: (canadian entries at: 'unique') id = 'three'.	plagiarists := readBackEncyclopedias at: 2.	self assert: plagiarists entries size = 2.	self		assert:			(plagiarists entries at: '54321') = (canadian entries at: '12345').	self		assert:			(plagiarists entries at: 'edcba') = (canadian entries at: 'abcde').	self assert: readBackEncyclopedias last entries isEmpty.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>support</category><body package="GlorpTests">setUp	super setUp.	session system: (GlorpEncyclopediaDescriptorSystem forPlatform: session platform).	session beginTransaction.</body><body package="GlorpTests">tearDown	session rollbackTransaction.	super tearDown.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests-simple reference classes</category><body package="GlorpTests">testDeleteSimpleTypeOneToMany	| publishers publisher |	self assert: (session read: GlorpPublisher) isEmpty.	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titles: (publisher titles copyWithout: 'Mastering ENVY/Developer')].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: publisher titles size = 2.	self assert: publisher titles asSortedCollection = (session system examplePublisher1 titles copyWithout: 'Mastering ENVY/Developer') asSortedCollection.</body><body package="GlorpTests">testSimpleTypeOneToMany	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each id = 1].	publishers do: [:each | 		each titles do: [:eachTitle | self assert: eachTitle isString]].	self assert: publishers first titles size = 3.	self assert: publishers first titles asSortedCollection = session system examplePublisher1 titles asSortedCollection.</body><body package="GlorpTests">testSimpleTypeOneToManyComplexQuerying	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titles sqlCount = 3].	self assert: publishers size = 1.	self assert: publishers first titles size = 3.	self assert: (publishers first titles includes: 'Mastering ENVY/Developer').</body><body package="GlorpTests">testSimpleTypeOneToManyQuerying	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titles anySatisfy: [:x | x like: 'Master%' ]].	self assert: publishers size = 1.	self assert: (publishers first titles anySatisfy: [:each | each like: 'Master%']).</body><body package="GlorpTests">testSimpleTypeOneToManyQueryingIncludes	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titles includes: 'Mastering ENVY/Developer' ].	self assert: publishers size = 1.	self assert: (publishers first titles includes: 'Mastering ENVY/Developer').</body><body package="GlorpTests">testSimpleTypeOneToManyQueryingWithFilteredReads	| publishers publisherOne publisher2 |	((session system descriptorFor: GlorpPublisher) mappingForAttributeNamed: #titles) useFilteredRead.	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each id &lt; 3].	self assert: publishers size = 2.	publisherOne := publishers detect: [:each | each id = 1].	self assert: publisherOne titles size = 3.	self assert: (publisherOne titles includes: 'Mastering ENVY/Developer').	session accessor denyReads.	publisher2 := publishers detect: [:each | each id = 2].	self assert: publisher2 titles first = 'A book'.</body><body package="GlorpTests">testUpdateSimpleTypeOneToMany	| publishers publisher |	self assert: (session read: GlorpPublisher) isEmpty.	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titles: (Array with: 'New Improved Book'), publisher titles].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: publisher titles size = 4.	self assert: publisher titles asSortedCollection = (session system examplePublisher1 titles , (Array with: 'New Improved Book')) asSortedCollection.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests-simple reference dictionary</category><body package="GlorpTests">testSimpleTypeDictionary	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each id = 1].	publishers do: [:each | 		each titlesWithNumberInStock keysAndValuesDo: [:eachTitle :eachNumber | 				self assert: eachTitle isString.			self assert: eachNumber = 2]].	self assert: publishers first titlesWithNumberInStock size = 3.	self assert: publishers first titlesWithNumberInStock keys asSortedCollection = session system examplePublisher1 titles asSortedCollection."	publishers do: [:each | 		each titlesWithNumberInStockLink keysAndValuesDo: [:eachTitle :eachNumber | 				self assert: eachTitle isString.			self assert: eachNumber = 2]].	self assert: publishers first titlesWithNumberInStockLink size = 3.	self assert: publishers first titlesWithNumberInStockLink keys asSortedCollection = session system examplePublisher1 titles asSortedCollection."</body><body package="GlorpTests">testSimpleTypeDictionaryComplexQuerying	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock sqlCount = 3].	self assert: publishers size = 1.	self assert: publishers first titlesWithNumberInStock size = 3.	self assert: (publishers first titlesWithNumberInStock keys includes: 'Mastering ENVY/Developer')."	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStockLink sqlCount &gt; 0].	publishers := publishers asSortedCollection: [:a :b | a name &lt;= b name].	self assert: publishers size = 2.	self assert: publishers first titlesWithNumberInStock size = 3.	self assert: (publishers first titlesWithNumberInStock keys includes: 'Mastering ENVY/Developer')."</body><body package="GlorpTests">testSimpleTypeDictionaryQuerying	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock anySatisfy: [:x | x key like: 'Master%']].	self assert: publishers size = 1.	self assert: publishers first titlesWithNumberInStock size = 3.	self assert: (publishers first titlesWithNumberInStock keys includes: 'Mastering ENVY/Developer')."	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock anySatisfy: [:x | x value  = 2]].	self assert: publishers size = 1.	self assert: publishers first id = 1."</body><body package="GlorpTests">testSimpleTypeDictionaryQueryingWithAlsoFetch	| publishers publisherOne publisher2 q |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	q := Query read: GlorpPublisher where: [:each | each id &lt; 3].	q orderBy: [:each | each id].	q alsoFetch: [:each | each titlesWithNumberInStock].	publishers := session execute: q.	session accessor denyReads.		self assert: publishers asSet size = 2.	publisherOne := publishers detect: [:each | each id = 1].	self assert: publisherOne titlesWithNumberInStock size = 3.	self assert: (publisherOne titlesWithNumberInStock includesKey: 'Mastering ENVY/Developer').	self assert: (publisherOne titlesWithNumberInStock values asArray = #(2 2 2)).	publisher2 := publishers detect: [:each | each id = 2].	self assert: publisher2 titlesWithNumberInStock keys asArray first = 'A book'.	self assert: (publisher2 titlesWithNumberInStock at: 'A book') = 200.</body><body package="GlorpTests">testSimpleTypeDictionaryQueryingWithFilteredReads	| publishers publisherOne publisher2 |	((session system descriptorFor: GlorpPublisher) mappingForAttributeNamed: #titlesWithNumberInStock) useFilteredRead.	"((session system descriptorFor: GlorpPublisher) mappingForAttributeNamed: #titlesWithNumberInStockLink) useFilteredRead."	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each id &lt; 3].	self assert: publishers size = 2.	publisherOne := publishers detect: [:each | each id = 1].	self assert: publisherOne titlesWithNumberInStock size = 3.	self assert: (publisherOne titlesWithNumberInStock includesKey: 'Mastering ENVY/Developer').	self assert: (publisherOne titlesWithNumberInStock values asArray = #(2 2 2))."	self assert: publisherOne titlesWithNumberInStockLink size = 3.	self assert: (publisherOne titlesWithNumberInStockLink includesKey: 'Mastering ENVY/Developer').	self assert: (publisherOne titlesWithNumberInStockLink values asArray = #(2 2 2))."	session accessor denyReads.	publisher2 := publishers detect: [:each | each id = 2].	self assert: publisher2 titlesWithNumberInStock keys asArray first = 'A book'."	self assert: publisher2 titlesWithNumberInStockLink keys asArray first = 'A book'."	self assert: (publisher2 titlesWithNumberInStock at: 'A book') = 200."	self assert: (publisher2 titlesWithNumberInStockLink at: 'A book') = 200."</body><body package="GlorpTests">testSimpleTypeDictionaryQueryingWithRetrieve	| publishers publisherOne publisher2 q actualPublishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	q := Query read: GlorpPublisher where: [:each | each id &lt; 3].	q retrieve: [:each | each].	q retrieve: [:each | each titlesWithNumberInStock].	publishers := session execute: q.		actualPublishers := publishers collect: [:each | each first].	self assert: actualPublishers asSet size = 2.	publisherOne := actualPublishers detect: [:each | each id = 1].	self assert: publisherOne titlesWithNumberInStock size = 3.	self assert: (publisherOne titlesWithNumberInStock includesKey: 'Mastering ENVY/Developer').	self assert: (publisherOne titlesWithNumberInStock values asArray = #(2 2 2)).	publisher2 := actualPublishers detect: [:each | each id = 2].	self assert: publisher2 titlesWithNumberInStock keys asArray first = 'A book'.	self assert: (publisher2 titlesWithNumberInStock at: 'A book') = 200.</body><body package="GlorpTests">testSimpleTypeDictionaryRead	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock anySatisfy: [:eachTitleAssociation |		eachTitleAssociation value = 2]].	self assert: publishers size = 1.</body><body package="GlorpTests">testSimpleTypeDictionaryReadWithImpliedValue	| publishers |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publishers := session read: GlorpPublisher where: [:each | each titlesWithNumberInStock anySatisfy: [:eachTitleAssociation |		eachTitleAssociation = 2]].	self assert: publishers size = 1.</body><body package="GlorpTests">testUpdateSimpleTypeDictionaryAdding	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStock at: 'New Book' put: 1].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStock at: 'New Book') = 1.	self assert: publisher titlesWithNumberInStock size = 4.</body><body package="GlorpTests">testUpdateSimpleTypeDictionaryDeleting	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStock removeKey: 'Mastering ENVY/Developer'].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStock at: 'Mastering ENVY/Developer' ifAbsent: [999]) = 999.	self assert: publisher titlesWithNumberInStock size = 2.</body><body package="GlorpTests">testUpdateSimpleTypeDictionaryLinkModifying"	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStockLink at: 'Mastering ENVY/Developer' put: 123].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStockLink at: 'Mastering ENVY/Developer') = 123."	"It can't find how to delete properly, because it doesn't know the primary key of the old record, and we don't have it recorded anywhere in the image"	"self assert: (session accessor executeSQLString: 'SELECT * FROM PUBLISHER_TITLE2') size = 4.	self assert: (session accessor executeSQLString: 'SELECT * FROM PUB_TITLE_LINK') size = 4."</body><body package="GlorpTests">testUpdateSimpleTypeDictionaryLinkedAdding"	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStockLink at: 'New Book' put: 1].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStockLink at: 'New Book') = 1.	self assert: publisher titlesWithNumberInStockLink size = 4."</body><body package="GlorpTests">testUpdateSimpleTypeDictionaryLinkedDeleting"	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStockLink removeKey: 'Mastering ENVY/Developer'].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStockLink at: 'Mastering ENVY/Developer' ifAbsent: [999]) = 999.	self assert: publisher titlesWithNumberInStockLink size = 2."</body><body package="GlorpTests">testUpdateSimpleTypeDictionaryModifying	| publishers publisher |	publishers := session system examplePublishers.	session modify: publishers in: [].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	session modify: publisher in: [		publisher titlesWithNumberInStock at: 'Mastering ENVY/Developer' put: 123].	session reset.	publisher := session readOneOf: GlorpPublisher where: [:each | each id = 1].	self assert: (publisher titlesWithNumberInStock at: 'Mastering ENVY/Developer') = 123.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests-key in different tables</category><body package="GlorpTests">testWriteAndReadBackKeyInLinkTable	| query readBackPublishers publishers withEmps |	publishers := session system examplePublishers.	session transact: [session register: publishers].	session reset.	query := Query read: GlorpPublisher.	query orderBy: [:each | each name].	readBackPublishers := session execute: query.	self assert: readBackPublishers size = 3.	withEmps := readBackPublishers at: 2.	self assert: withEmps name = 'Cambridge'.	self assert: withEmps differentBunchOfEmployeesById size = 2.	self assert: withEmps differentBunchOfEmployeesById keys asSortedCollection asArray = #(3 4).	self assert: (withEmps differentBunchOfEmployeesById at: 3) name = 'Contractor 1'.	self assert: (withEmps differentBunchOfEmployeesById at: 4) name = 'Contractor 2'.</body><body package="GlorpTests">testWriteAndReadBackKeyInTargetTable	| query readBackPublishers publishers withEmps |	publishers := session system examplePublishers.	session transact: [session register: publishers].	session reset.	query := Query read: GlorpPublisher.	query orderBy: [:each | each name].	readBackPublishers := session execute: query.	self assert: readBackPublishers size = 3.	withEmps := readBackPublishers at: 2.	self assert: withEmps name = 'Cambridge'.	self assert: withEmps employees size = 2.	self assert: withEmps employees keys asSortedCollection asArray = #('CEO' 'Editor').	self assert: (withEmps employees at: 'CEO') name = 'The Boss'.	self assert: (withEmps employees at: 'Editor') name = 'Somebody'.</body></methods><methods><class-id>Glorp.GlorpDictionaryMappingTest</class-id> <category>tests-arbitrary object to object</category><body package="GlorpTests">testObjectObjectOneToMany	|  encyclopedias withAuthors first last |	encyclopedias := session system exampleEncyclopedias.	session modify: encyclopedias in: [].	session reset.	withAuthors := session readOneOf: GlorpEncyclopedia where: [:each | each id = 4].	self assert: withAuthors entriesByAuthor size = 2.	first := withAuthors entriesByAuthor keys asSortedCollection first.	last := withAuthors entriesByAuthor keys asSortedCollection last.	self assert: first name = 'Somebody'.	self assert: (withAuthors entriesByAuthor at: first) title = 'All About Ants'.	self assert: last name = 'Somebody Else'.	self assert: (withAuthors entriesByAuthor at: last) title = 'Computer Programming Languages'.</body></methods><methods><class-id>Glorp.GlorpRootNode</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger.</body><body package="GlorpTestModels">root	^root</body><body package="GlorpTestModels">root: aGlorpTreeNode	root := aGlorpTreeNode.</body></methods><methods><class-id>Glorp.GlorpBlobTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform blob.</body></methods><methods><class-id>Glorp.GlorpBlobTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">adjustForMaximumSize: anObject	^anObject.</body><body package="GlorpDBTypeTests">blob255	^ByteArray withAll: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255)</body><body package="GlorpDBTypeTests">largeBlob	"Make a significant sized blob. 64k+ a bit should do"	| blobStream |	blobStream := WriteStream on: (ByteArray new: 10000).	(((2 raisedTo: 16) + 100.0) / 255.0) ceiling timesRepeat: [		blobStream nextPutAll: self blob255].	^blobStream contents.</body><body package="GlorpDBTypeTests">mediumlargeBlob	"Make a Blob just under 32K in size"	"self new mediumlargeBlob"	| blobStream |	blobStream := WriteStream on: (ByteArray new: 10000).	(((2 raisedTo: 15) - 600.0) / 255.0) ceiling timesRepeat: [		blobStream nextPutAll: self blob255].	^blobStream contents.</body><body package="GlorpDBTypeTests">testBlob	self helpTestValue: nil.	self helpTestValue: (ByteArray withAll: #(1 2 3 4 255)).	stType := String.	self helpTestValue: 'abcdef'.</body><body package="GlorpDBTypeTests">testBlobWithSubstring	"Test our ability to query with substring against a blob. This is severely limited in Postgresql, and may be limited in others.	The compare blocks once looked clean, like this:		[:each | (each test copyFrom: 1 to: 3) = 'hgf'].	but the DB2 compare blocks would need to look like this:		[:each | (each test copyFrom: 1 to: 3) like: 'hgf'].	Rather than duplicate the blocks, the operator was switched to:		[:each | (each test copyFrom: 1 to: 3) perform: compare with: 'hgf'].	which results in the desired SQL, although in code it looks unpleasant."	| result system compare |	session platform supportsStringQueryOnBlobs ifFalse: [^self knownFailure].	compare := session platform isDB2Platform		ifTrue: [ #like: ]		ifFalse: [ #= ].	stType := String.	self inTransactionDo: [		system := self systemFor: table.		session system: system.		session inUnitOfWorkDo: [			| model |			model := GlorpTypeTestsModelClass new test: 'hgfedcbazyx'.			session register: model].		session reset.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 1 to: 3) perform: compare with: 'hgf'].		self assert: result size = 1.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 1 to: 3) perform: compare with: 'abc'].		self assert: result size = 0.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 4 to: 6) perform: compare with: 'edc'].		self assert: result size = 1.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 7 to: 9) perform: compare with: 'baz'].		self assert: result size = 1.		result := session read: GlorpTypeTestsModelClass where: [:each | (each test copyFrom: 1 to: 6) perform: compare with: 'hgfedc'].		self assert: result size = 1].</body><body package="GlorpDBTypeTests">testDefaultBlobPrinting	"Test out default (SQL-92 syntax) byte array printing"	| stream |	stream := WriteStream on: String new.	type := type copy.	type platform: DatabasePlatform new.	type print: (ByteArray with: 0) on: stream.	self assert: stream contents = 'X''00'''.	stream reset.	type print: (ByteArray with: 16rFF) on: stream.	self assert: stream contents = 'X''FF'''.	stream reset.	type print: (ByteArray with: 16r47) on: stream.	self assert: stream contents = 'X''47'''.	stream reset.	type print: (ByteArray withAll: #(1 2 16rFE)) asByteArray on: stream.	self assert: stream contents = 'X''0102FE'''.</body><body package="GlorpDBTypeTests">testLargeBlob	| blob |	blob := self mediumlargeBlob.	(session platform useBinding not and: [blob size &gt; session platform maximumQueryValueSize])		ifTrue: [Transcript cr; show: '******* Skipping large unbound blob test']		ifFalse: [self helpTestValue: blob].	blob := self largeBlob.	(session platform useBinding not and: [blob size &gt; session platform maximumQueryValueSize])		ifFalse: [self helpTestValue: blob].</body></methods><methods><class-id>Glorp.GlorpTimeWithTimeZoneTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	"For now, non-supporting platforms just repeat the superclass' tests.  Later, raise explicit test skip for non-supporting platforms."	self platform isPostgreSQLPlatform ifTrue: [^self platform timetz].	^super defaultDatabaseType</body></methods><methods><class-id>Glorp.GlorpTimeWithTimeZoneTest</class-id> <category>setUp</category><body package="GlorpDBTypeTests">setUp	| exdiConnection tz |	super setUp.	self platform isPostgreSQLPlatform		ifTrue: 			[exdiConnection := connection connection.			priorTimeZone := exdiConnection timezone.			tz := exdiConnection suggestedDefaultTimeZone.			exdiConnection timezone: tz]</body><body package="GlorpDBTypeTests">tearDown	| exdiConnection |	self platform isPostgreSQLPlatform		ifTrue: 			[exdiConnection := connection connection.			exdiConnection timezone: priorTimeZone].	super tearDown</body></methods><methods><class-id>GlorpCity</class-id> <category>accessing</category><body package="GlorpTestModels">id	"	***This is decompiled code.*** 	No source was available"	^id</body><body package="GlorpTestModels">id: t1 	"	***This is decompiled code.*** 	No source was available"	id := t1.	^self</body><body package="GlorpTestModels">name	"	***This is decompiled code.*** 	No source was available"	^name</body><body package="GlorpTestModels">name: t1 	"	***This is decompiled code.*** 	No source was available"	name := t1.	^self</body><body package="GlorpTestModels">nextCities	^nextCities</body><body package="GlorpTestModels">nextCities: anObject	nextCities := anObject</body><body package="GlorpTestModels">priorCities	^priorCities</body><body package="GlorpTestModels">priorCities: anObject	priorCities := anObject</body></methods><methods><class-id>GlorpCity</class-id> <category>adding-removing</category><body package="GlorpTestModels">addNextCity: aGlorpCity distance: anInteger	"Create and return a cities graph link object"	^GlorpCitiesGraph new city: self; nextCity: aGlorpCity; distance: anInteger; yourself</body></methods><methods><class-id>GlorpCity</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	nextCities := OrderedCollection new.	priorCities := OrderedCollection new.</body></methods><methods><class-id>GlorpCity class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	^super new initialize</body></methods><methods><class-id>Glorp.ClassM</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassM	^attrAClassM</body><body package="GlorpTestModels">attrAClassM: anObject	attrAClassM := anObject</body></methods><methods><class-id>Glorp.GlorpImageFile</class-id> <category>accessing</category><body package="GlorpTestModels">bits	^bits</body><body package="GlorpTestModels">bits: anObject	bits := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">thumbnailBits: aByteArray	thumbnailBits := aByteArray</body><body package="GlorpTestModels">title	^title</body><body package="GlorpTestModels">title: anObject	title := anObject</body></methods><methods><class-id>Glorp.GlorpImageFile</class-id> <category>testing</category><body package="GlorpTestModels">isLarge	^bits size &gt; 10.</body><body package="GlorpTestModels">thumbnailBits	thumbnailBits isNil ifTrue: [thumbnailBits := bits copyFrom: 1 to: 5].	^thumbnailBits.</body></methods><methods><class-id>Glorp.GlorpImageFile class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		title: 'example1';		bits: #[1 2 3 4 5].</body><body package="GlorpTestModels">example2	^self new		title: 'example2';		bits: #[1 2 3 4 5 6 7 8 9 10 11 12 13 14 15].</body></methods><methods><class-id>Glorp.GlorpProxyTest</class-id> <category>tests</category><body package="GlorpDBTests">testAdHocProxy	"Some dialects (e.g. VA) inline yourself so we must send yourSelf."	| p |	p := AdHocProxy readBlock: ['instantiated!'].	self assert: p printString = '{uninstantiated AdHocProxy}'.	self assert: p isInstantiated not.	p yourSelf.	self assert: p isInstantiated.	self assert: p printString = '{''instantiated!''}'.	p uninstantiate.	self deny: p isInstantiated.</body><body package="GlorpDBTests">testCreation	| otherProxy |	self deny: proxy isInstantiated.	otherProxy := Proxy new.	self deny: otherProxy isInstantiated.</body><body package="GlorpDBTests">testInstantiationFromStub	self assert: (proxy getValue notNil).	self assert: proxy = 42.	self assert: proxy isInstantiated.</body><body package="GlorpDBTests">testPrintingInstantiated	proxy getValue.	self assert: proxy printString = ('{', proxy getValue printString, '}').</body><body package="GlorpDBTests">testPrintingUninstantiated	self assert: proxy printString = '{uninstantiated GlorpAddress}'.</body><body package="GlorpDBTests">testPrintingUninstantiatedCollection	proxy query readsOneObject: false.	self assert: proxy printString = '{uninstantiated collection of GlorpAddress}'.</body></methods><methods><class-id>Glorp.GlorpProxyTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	| stub |	super setUp.	session := GlorpSessionResource current newSession.	proxy := Proxy new.	proxy session: session.	stub := GlorpQueryStub readOneOf: GlorpAddress where: [:address | address id = 1].	stub result: 42.	proxy query: stub.	proxy parameters: #().</body></methods><methods><class-id>Glorp.GlorpProxyTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpBook</class-id> <category>accessing</category><body package="GlorpTestModels">author	^author</body><body package="GlorpTestModels">author: aString	author := aString</body><body package="GlorpTestModels">copiesInStock	^copiesInStock</body><body package="GlorpTestModels">copiesInStock: anInteger	copiesInStock := anInteger</body><body package="GlorpTestModels">description	^description</body><body package="GlorpTestModels">description: aString	description := aString</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger</body><body package="GlorpTestModels">title	^title</body><body package="GlorpTestModels">title: aString	title := aString.</body><body package="GlorpTestModels">version	^version</body><body package="GlorpTestModels">version: anInteger	version := anInteger</body></methods><methods><class-id>Glorp.GlorpBook class</class-id> <category>examples</category><body package="GlorpTestModels">example1	"These examples have some shared values to assist in testing groupBy."	^(GlorpBook new)		title: 'The First Book';		author: 'John Doe';		description: 'A good start';		copiesInStock: 3;		version: 1.</body><body package="GlorpTestModels">example2	"These examples have some shared values to assist in testing groupBy."	^(GlorpBook new)		title: 'The Second Book';		author: 'John Doe';		description: 'A superb book';		copiesInStock: 2;		version: 2.</body><body package="GlorpTestModels">example3	"These examples have some shared values to assist in testing groupBy."	^(GlorpBook new)		title: 'The First Book';		author: 'Richard Roe';		description: 'A good start';		copiesInStock: 1;		version: 1.</body><body package="GlorpTestModels">example4	"These examples have some shared values to assist in testing groupBy."	^(GlorpBook new)		title: 'The Second Book';		author: 'Richard Roe';		description: 'A superb book';		copiesInStock: 5;		version: 2.</body></methods><methods><class-id>Glorp.GlorpSimpleQueryTest</class-id> <category>tests</category><body package="GlorpDBTests">setUpQueryBasic: query 	| |	query session: session.	query setUpExpressions.	query setupTracing.</body><body package="GlorpDBTests">setUpQueryFields: query 	self setUpQueryBasic: query.	query computeFields.</body><body package="GlorpDBTests">setUpQueryFully: query 	self setUpQueryBasic: query.	query prepare</body><body package="GlorpDBTests">skipToString	^session platform supportsANSIJoins ifTrue: ['join '] ifFalse: ['where '].</body><body package="GlorpDBTests">testCaseInsensitiveQuery	| result |	session platform supportsCaseInsensitiveLike ifFalse: [^self].	[session beginUnitOfWork.	session beginTransaction.	session register: GlorpAddress example1.	session commitUnitOfWork.	result := session				readOneOf: GlorpAddress				where: [:address | address street ilike: 'WeSt%'].	self assert: result street = 'West 47th Ave'] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testComputingFieldsForDirectMappings	| query table |	query := SimpleQuery readOneOf: GlorpAddress where: [:each | each id = 1].	self setUpQueryFields: query.		table := session system tableNamed: 'GR_ADDRESS'.	self assert: (query fields = table fields).</body><body package="GlorpDBTests">testComputingFieldsForDirectMappingsWithFullPrepare	| query table |	query := Query readOneOf: GlorpAddress where: [:each | each id = 1].	query session: session.	query prepare.		table := session system tableNamed: 'GR_ADDRESS'.	self assert: ((query fields collect: [:each | each table parent fieldNamed: each name])= table fields).</body><body package="GlorpDBTests">testComputingFieldsForReferenceMappings	| query table |	query := SimpleQuery readOneOf: GlorpPerson where: [:each | each id = 1].	self setUpQueryFields: query.		table := session system tableNamed: 'PERSON'.	self assert: (query fields = table fields).</body><body package="GlorpDBTests">testComputingFieldsForReferenceMappingsWithFullPrepare	| query table |	query := SimpleQuery readOneOf: GlorpPerson where: [:each | each id = 1].	query session: session.	query prepare.		table := session system tableNamed: 'PERSON'.	self assert: ((query fields collect: [:each | each table parent fieldNamed: each name])= table fields).</body><body package="GlorpDBTests">testDescriptorAssignmentToCriteria	| query |	query := SimpleQuery readOneOf: GlorpAddress where: [:each | each id = 1].	query session: session.	query setUpExpressions.	self assert: query whereClause ultimateBaseExpression descriptor == (session descriptorFor: GlorpAddress).</body><body package="GlorpDBTests">testFieldAliasingForEmbeddedMappings	| query table |	query := SimpleQuery readOneOf: GlorpBankTransaction where: [:each | each id = 1].	self setUpQueryFields: query.	table := session system tableNamed: 'BANK_TRANS'.	self assert: (query fields = table fields).	self assert: (query builders first translateFieldPosition: (table fieldNamed: 'ID')) = 1.	self assert: (query builders first translateFieldPosition: (table fieldNamed: 'OWNER_ID')) = 2.</body><body package="GlorpDBTests">testJoinExpressionWithMultipleTables	| query sql sqlStream result command |	query := SimpleQuery readOneOf: GlorpPassenger where: [:each | each id = 1].	query session: session.	query prepare.	command := query sqlWith: Dictionary new.	command useBinding: false.	sql := command sqlString.	sqlStream := ReadStream on: sql asLowercase.	sqlStream skipToAll: self skipToString.	Dialect isVisualWorks ifTrue: [sqlStream skip: self skipToString size].	"&lt;Grumble grumble&gt; stupid incompatibilities"	result := sqlStream upToEnd.	session platform supportsANSIJoins ifTrue: [		self assert: ('*frequent_flyer t2 on *t1.id = t2.id*&lt;n&gt; where *t1.id = 1*' expandMacros match: result)]		ifFalse: [self assert:  ('*(t1.id = 1) and ((t1.id = t2.id*' match: result)].</body></methods><methods><class-id>Glorp.GlorpSimpleQueryTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpSimpleQueryTest</class-id> <category>tests-ordering</category><body package="GlorpDBTests">testDoubleOrderSQL	| query sql |	query := SimpleQuery read: GlorpAddress.	query orderBy: [:each | each id].	query orderBy: [:each | each number].	self setUpQueryFully: query.	sql := (query sqlWith: Dictionary new) sqlString.	self assert: ('* from *gr_address t1 order by t1.id, t1.house_num' match: sql asLowercase).</body><body package="GlorpDBTests">testOrderSQL	| query sql |	query := SimpleQuery read: GlorpAddress.	query orderBy: [:each | each id].	self setUpQueryFully: query.	sql := (query sqlWith: Dictionary new) sqlString.	self assert: ('* from *gr_address t1 order by t1.id' match: sql asLowercase).</body></methods><methods><class-id>Glorp.GlorpSimpleQueryTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpDatabaseBasicTest</class-id> <category>support</category><body package="GlorpDBTests">databaseLoginResource	^GlorpDatabaseLoginResource current.</body><body package="GlorpDBTests">setUp	super setUp.	system := GlorpDemoDescriptorSystem forPlatform: GlorpDatabaseLoginResource defaultLogin database.</body></methods><methods><class-id>Glorp.GlorpDatabaseBasicTest</class-id> <category>tests</category><body package="GlorpDBTests">testBeginTransactionWithCommit	self assert: self accessor isInTransaction not.	self accessor beginTransaction.	self assert: self accessor isInTransaction.	self accessor commitTransaction.	self assert: self accessor isInTransaction not</body><body package="GlorpDBTests">testBeginTransactionWithRollback	self assert: self accessor isInTransaction not.	self accessor beginTransaction.	self assert: self accessor isInTransaction.	self accessor rollbackTransaction.	self assert: self accessor isInTransaction not</body><body package="GlorpDBTests">testCreateTable	| selectResult presentFlag |	presentFlag := true.	[[self accessor beginTransaction.	self accessor		executeSQLStringNoResult: 'CREATE TABLE GLORP_TEST_CREATE (ID varchar(4))'] 		ensure: [self accessor commitTransaction].	selectResult := self accessor		executeSQLString: 'SELECT * FROM GLORP_TEST_CREATE'.	self assert: selectResult isEmpty]		ensure:			[[self accessor				beginTransaction;				dropTableNamed: 'GLORP_TEST_CREATE'					ifAbsent: [:ex |presentFlag := false. ex sunitExitWith: nil]]				ensure: [self accessor commitTransaction]].	self assert: presentFlag		description: 'Tried to drop the created table but it was already absent'.</body><body package="GlorpDBTests">testDropMissingTable	| absentFlag |	absentFlag := false.	[self accessor beginTransaction.	self accessor 		dropTableNamed: 'GLORP_TEST_DROP' 		ifAbsent: [:ex  | absentFlag := true. ex sunitExitWith: nil]]	ensure: [self accessor rollbackTransaction].	self assert: absentFlag</body><body package="GlorpDBTests">testIsExistingSQLServerSchema	"This test only targets SQL Server, and verifies that we can query for 'schemata'.	The functionality isn't needed by Store yet, so we must do without accessor helper methods."	| sql result |	Dialect isVisualWorks ifFalse: [^self].	self accessor platform isSQLServerPlatform		ifTrue: 			[sql := self accessor platform sqlStatementToTestExistenceOfSchema: 'master'.				result := self accessor executeSQLString: sql.				self assert: result first first = 1.				sql := self accessor platform sqlStatementToTestExistenceOfSchema: 'bogus_name'.				result := self accessor executeSQLString: sql.				self assert: result first first = 0]</body><body package="GlorpDBTests">testNameBinding	| selectResult |	"This is more of a low-level db functionality test than a glorp test, but it's convenient to be able ot write it here"	Dialect isVisualWorks ifFalse: [^self].	[self accessor beginTransaction.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (10,''abc'')'.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (20,''def'')'.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (30,''ghi'')'.	selectResult := self accessor 		executeSQLString: 'SELECT * FROM STUFF WHERE ID = :key OR ID = :value'			binding: 10-&gt;30.	self assert: selectResult size = 2]		ensure: [self accessor rollbackTransaction].</body><body package="GlorpDBTests">testNoErrorOnTableInSchemaCheck	"This test only targets all but SQL Server, and verifies that we can query for table and schema	without getting an error (which happens with SQL Server)."	Dialect isVisualWorks ifFalse: [^self].	(self accessor platform isSQLServerPlatform not and: [self accessor platform supportsSchemas])		ifTrue: 			[self assert: (self accessor isExistingTable: 'bogusTable' inSchema: 'bogusSchema') not]</body><body package="GlorpDBTests">testPositionalBinding	| selectResult | 	"This is more of a low-level db functionality test than a glorp test, but it's convenient to be able ot write it here"	Dialect isVisualWorks ifFalse: [^self].	[self accessor beginTransaction.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (10,''abc'')'.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (20,''def'')'.	self accessor executeSQLStringNoResult: 'INSERT INTO STUFF VALUES (30,''ghi'')'.	selectResult := self accessor 		executeSQLString: 'SELECT * FROM STUFF WHERE ID = :2 OR ID = :17'			binding: #(nil 10 nil nil nil nil nil nil nil nil nil nil nil nil nil nil 20).	self assert: selectResult size = 2]		ensure: [self accessor rollbackTransaction].</body><body package="GlorpDBTests">testReadEmpty	| results |	results := self accessor				executeSQLString: 'SELECT * FROM PERSON'.	self assert: results size = 0</body><body package="GlorpDBTests">testReadMultipleResultSetsUnbound	"This test passes on Postgres socket (unbound) and SQLServer.  It fails on Postgres libpq and SQLite as they do not support multiple result sets.  The test uses no parameters, so the query command generated by &gt;&gt;basicExecuteSQLString: will not use binding."	| results ascendingResults descendingResults |	"Use #basicExecuteSQLString: to test multi-result-set cursor because #executeSQLString: sends #upToEnd to its result - it does not return the cursor."	results := self accessor basicExecuteSQLString: 'SELECT * FROM STUFF ORDER BY ID; SELECT * FROM STUFF ORDER BY ID DESC'.	ascendingResults := results upToEndOfResultSet.	self assert: ascendingResults size = 5.	self assert: ascendingResults first size = 2.	self assert: ascendingResults first last =  'abc'.	descendingResults := results upToEndOfResultSet.	self assert: descendingResults size = 5.	self assert: descendingResults last size = 2.	self assert: descendingResults last last =  'abc'.	self assert: results cursor isNil		description: 'Glorp cursor not nilled after last result set read'.	self assert: results accessor isNil		description: 'Glorp cursor not released after last result set read'.</body><body package="GlorpDBTests">testReadStatement	| results |	results := self accessor				executeSQLString: 'SELECT * FROM STUFF ORDER BY ID'.	self assert: results size = 5.	self assert: results first size = 2.	self assert: results first last =  'abc'</body><body package="GlorpDBTests">testRollbackRemovesData	"Just to make sure I'm not losing my mind"	| numAddresses newNumAddresses|	numAddresses := (self accessor executeSQLString: 'SELECT * FROM GR_ADDRESS') size.	self accessor beginTransaction.	self accessor executeSQLStringNoResult: 'INSERT INTO GR_ADDRESS (ID,STREET,HOUSE_NUM)  VALUES (111,''Main Street'',''77777'')'.	newNumAddresses := (self accessor executeSQLString: 'SELECT * FROM GR_ADDRESS') size.	self assert: newNumAddresses = (numAddresses + 1).	self accessor rollbackTransaction.	self assert: numAddresses = (self accessor executeSQLString: 'SELECT * FROM GR_ADDRESS') size.</body></methods><methods><class-id>Glorp.GlorpDatabaseBasicTest</class-id> <category>accessing</category><body package="GlorpDBTests">accessor	^self databaseLoginResource accessor</body></methods><methods><class-id>Glorp.GlorpDatabaseBasicTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsThroughMappingsTest</class-id> <category>setup</category><body package="GlorpDBTests">descriptorClass	^GlorpCollectionTypesDescriptorSystem.</body><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	system := self descriptorClass forPlatform: session platform.	session system: system.	session beginTransaction.</body><body package="GlorpDBTests">tearDown	super tearDown.	session rollbackTransaction.</body><body package="GlorpDBTests">writeMore	| other |	session transact: [		session register: GlorpThingWithLotsOfDifferentCollections example1.		other := GlorpThingWithLotsOfDifferentCollections example1.		other name: 'barney'.		session register: other].</body><body package="GlorpDBTests">writeRows	session transact: [		session register: GlorpThingWithLotsOfDifferentCollections example1].</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsThroughMappingsTest</class-id> <category>tests</category><body package="GlorpDBTests">testReadBack	"Some dialects (e.g. VA) inline yourself so we must send yourSelf."	| thing list |	self writeRows.	session reset.	list := session read: GlorpThingWithLotsOfDifferentCollections.	self assert: list size = 1.	thing := list first.	self assert: thing array size = 3.	self		assert:			(self validateFor: thing array against: #('array1' 'array2' 'array3')).	self assert: thing array yourSelf class = Array.	self assert: thing set size = 2.	self assert: thing set yourSelf class = Set.	self assert: (self validateFor: thing set against: #('set1' 'set2')).	self assert: thing orderedCollection size = 2.	self assert: thing orderedCollection yourSelf class = OrderedCollection.	self		assert:			(self				validateFor: thing orderedCollection				against: #('orderedCollection1' 'orderedCollection2')).	self assert: thing orderedCollection first name = 'orderedCollection1'.	self assert: thing bag size = 2.	self assert: thing bag yourSelf class = Bag.	self assert: (self validateFor: thing bag against: #('bag1' 'bag2')).	self assert: thing sortedCollection size = 4.	self assert: thing sortedCollection yourSelf class = SortedCollection.	self assert:			(thing sortedCollection collect: [:each | each name]) asArray				= #('sorted1' 'sorted2' 'sorted3' 'sorted4').</body><body package="GlorpDBTests">testReadBackOneOfSeveral	"Some dialects (e.g. VA) inline yourself so we must send yourSelf."	| thing list |	self writeMore.	session reset.	list := session read: GlorpThingWithLotsOfDifferentCollections where: [:each | each name = 'fred'].	self assert: list size = 1.	thing := list first.	self assert: thing array size = 3.	self		assert:			(self validateFor: thing array against: #('array1' 'array2' 'array3')).	self assert: thing array yourSelf class = Array.	self assert: thing set size = 2.	self assert: thing set yourSelf class = Set.	self assert: (self validateFor: thing set against: #('set1' 'set2')).	self assert: thing orderedCollection size = 2.	self assert: thing orderedCollection yourSelf class = OrderedCollection.	self		assert:			(self				validateFor: thing orderedCollection				against: #('orderedCollection1' 'orderedCollection2')).	self assert: thing bag size = 2.	self assert: thing bag yourSelf class = Bag.	self assert: (self validateFor: thing bag against: #('bag1' 'bag2')).	self assert: thing sortedCollection size = 4.	self assert: thing sortedCollection yourSelf class = SortedCollection.	self assert:			(thing sortedCollection collect: [:each | each name]) asArray				= #('sorted1' 'sorted2' 'sorted3' 'sorted4').</body><body package="GlorpDBTests">testReadCollectionWithOrder	| thing list |	session transact: [session register: GlorpThingWithLotsOfDifferentCollections exampleForOrdering].	session reset.	list := session read: GlorpThingWithLotsOfDifferentCollections.	self assert: list size = 1.	thing := list first.	self assert: thing orderedCollection size = 6.	self		assert:			(thing orderedCollection collect: [:each | each name]) asArray = #('oc6' 'oc5' 'oc4' 'oc3' 'oc7' 'oc8')</body><body package="GlorpDBTests">testReadManyToManyWithOrder	| thing list |	session transact: [session register: GlorpThingWithLotsOfDifferentCollections exampleForOrdering].	session reset.	list := session read: GlorpThingWithLotsOfDifferentCollections.	self assert: list size = 1.	thing := list first.	self assert: thing orderedCollection size = 6.	self		assert:			(thing orderedCollection collect: [:each | each name]) asArray = #('oc6' 'oc5' 'oc4' 'oc3' 'oc7' 'oc8')</body><body package="GlorpDBTests">testReadOneToManyWithOrder	| thing list |	session transact: [session register: GlorpThingWithLotsOfDifferentCollections exampleForOrdering].	session reset.	list := session read: GlorpThingWithLotsOfDifferentCollections.	self assert: list size = 1.	thing := list first.	self assert: thing array size = 6.	self		assert:			(thing array collect: [:each | each name]) asArray = #('a1' 'a2' 'a3' 'a9' 'a8' 'a7')</body><body package="GlorpDBTests">validateFor: aCollection against: expectedArrayContents	^(aCollection collect: [:each | each name]) asSortedCollection asArray		= expectedArrayContents.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsThroughMappingsTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpDatabaseLoginResource with: GlorpDemoTablePopulatorResource with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpReadingPersonWithEmailAddressesTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.	session beginTransaction.	addressRow := session system exampleAddressRow.	session writeRow: addressRow.	personRow := session system examplePersonRow1.	session writeRow: personRow.	emailAddress1Row := session system exampleEmailAddressRow1.	emailAddress2Row := session system exampleEmailAddressRow2.	id1 := emailAddress1Row at: (emailAddress1Row table fieldNamed: 'ID').	id2 := emailAddress2Row at: (emailAddress2Row table fieldNamed: 'ID').	session writeRow: emailAddress1Row.	session writeRow: emailAddress2Row.</body><body package="GlorpDBTests">tearDown	oldReuseState isNil ifFalse:		[session reusePreparedStatements: oldReuseState].	session rollbackTransaction.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpReadingPersonWithEmailAddressesTest</class-id> <category>tests</category><body package="GlorpDBTests">testObjectsNotAddedTwiceWhenReadingMultipleObjectsOneToMany	"Read in the objects first, so they're in cache. Make sure they don't get the collection built up twice."	| people |	people := session read: GlorpPerson.	self testReadMultipleObjectsOneToMany.	^people.</body><body package="GlorpDBTests">testPreparedStatementsAreFaster	"Not really a good test, since there are lots of other factors. And since we don't support this on all dialects/databases, they might easily be the same. Maybe should remove this test, but on the other hand it's the most useful feedback that the prepared statements are actually good for something.  (The tearDown ensures our forcing of reusePreparedStatements is reverted.)"	| timePrepared timeUnPrepared |	oldReuseState := session reusePreparedStatements.	session reusePreparedStatements: true.	session reset.	timeUnPrepared := Time millisecondsToRun: [		session read: GlorpPerson where: [:eachPerson | eachPerson id = 3].		session read: GlorpPerson where: [:eachPerson | eachPerson id ~= 3].		session read: GlorpPerson where: [:eachPerson | eachPerson id &gt;= 3]].	session reset.	timePrepared := Time millisecondsToRun: [		3 timesRepeat: [ | query |			query := Query read: GlorpPerson where: [:eachPerson | eachPerson id = (eachPerson parameter: 1)].			query executeWithParameters: #(3) in: session]].	(session accessor numberOfPreparedStatements &lt; 1) ifTrue: [^self "Unsupported, don't bother testing"].	Transcript cr; show: 'Time reusing prepared statements = ', timePrepared printString.	Transcript cr; show: 'Time not reusing prepared statements = ', timeUnPrepared printString.	"Give a little bit of room, so if they take roughly the same amount of time it'll still pass"	self assert: (timePrepared * 0.8 )&lt; timeUnPrepared.</body><body package="GlorpDBTests">testPreparedStatementsAreReused	"The tearDown ensures our forcing of reusePreparedStatements is reverted." 	session useBinding ifFalse: [^self].	"test only makes sense if binding is on"	oldReuseState := session reusePreparedStatements.	session reusePreparedStatements: true.	session reset.	session read: GlorpPerson where: [:eachPerson | eachPerson id = 3].	session read: GlorpPerson where: [:eachPerson | eachPerson id ~= 3].	session read: GlorpPerson where: [:eachPerson | eachPerson id &gt;= 3].	self assert: session accessor numberOfPreparedStatements = 3.	session reset.	1 to: 3 do: [:i | | query |			query := Query read: GlorpPerson where: [:eachPerson | eachPerson id = (eachPerson parameter: 1)].			query executeWithParameters: (Array with: i) in: session].	self assert: session accessor numberOfPreparedStatements = 1.</body><body package="GlorpDBTests">testReadMultipleObjectsOneToMany	| query result person addresses |	query := Query read: GlorpPerson where: [:eachPerson | eachPerson id = 3].	query alsoFetch: [:each | each emailAddresses].	result := query executeIn: session.	self assert: result size = 1.	person := result first.	addresses := person emailAddresses.	self deny: addresses isGlorpProxy.	self assert: addresses size = 2.	self 		assert: (addresses first id = id1 or: [addresses last id = id1]).	self 		assert: (addresses first id = id2 or: [addresses last id = id2]).	self assert: addresses first id ~= addresses last id.</body><body package="GlorpDBTests">testReadPersonWithEmailAddresses	| query result emailAddresses |	query := Query		readOneOf:GlorpPerson		where: [:person | person id = 3].	result := query executeIn: session.	emailAddresses := result emailAddresses getValue.	self assert: emailAddresses size = 2.	self		assert:			(emailAddresses first id = id1 or: [emailAddresses last id = id1]).	self		assert:			(emailAddresses first id = id2 or: [emailAddresses last id = id2]).	self assert: emailAddresses first id ~= emailAddresses last id.</body></methods><methods><class-id>Glorp.GlorpReadingPersonWithEmailAddressesTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpWritingTest</class-id> <category>tests</category><body package="GlorpDBTests">testLargeWrite	"This is really just a performance test. No assertions. It should take on the order of 10 seconds. If it starts taking 10 minutes, it indicates a potential problem...."	| customer |	session beginTransaction.	[customer := GlorpCustomer new.	customer name: 'foo'.     customer id: 123.	1 to: 5000 do:		[:i || transaction |		transaction := GlorpBankTransaction new.		transaction amount amount: i.		customer addTransaction: transaction].	session beginUnitOfWork.	session register: customer.	session commitUnitOfWork]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testMultipleWritesAndReads	"Trying to narrow down on a problem with SQLiteEXDI"	| names customers |	session beginTransaction.	[session beginUnitOfWork.	names := OrderedCollection new.	1 to: 10		do: 			[:i | 			| nm |			nm := 'John Doe ' , i printString.			names add: nm.			session register: ((GlorpCustomer new)									id: i;									name: nm;									yourself)].	session commitUnitOfWork.	customers := session read: GlorpCustomer.	self assert: (names asSortedCollection isSameSequenceAs: (customers collect: [:ea | ea name]) asSortedCollection).	] 			ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testRegistrationFromWrittenObject	| customer trans transactions |	session beginTransaction.	[customer := GlorpCustomer new.	customer name: 'foo'.     customer id: 123.	session beginUnitOfWork.	session register: customer.	session commitUnitOfWork.	trans := GlorpBankTransaction new.	session beginUnitOfWork.	session readOneOf: GlorpCustomer where: [:each | each id = customer id].	customer addTransaction: trans.	session commitUnitOfWork.	transactions := session accessor executeSQLString: 'SELECT ID FROM BANK_TRANS WHERE OWNER_ID = ', customer id printString.	self assert: transactions size = 1.	self assert: (trans id = (transactions first atIndex: 1))]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testWriteManyNoIdentityColumn	"Test writing numbers that are on the edge of various platforms limits.  SQLite allows up to 500 rows and up to 1000 bound values, so 500 rows with 2 bound values each should check the exact limit of our grouping test for SQLite.  SQLServer imposed a 250 row limit."	session beginTransaction.	[| largeRowSize |	session beginUnitOfWork.	largeRowSize := 500.	1 to: largeRowSize do:		[:i || customer |		customer := GlorpCustomer new.		customer name: 'Mr_' , i printString.		customer id: 1230 + i.		session register: customer].	session commitUnitOfWork.	self assert: (session read: GlorpCustomer) size = largeRowSize]		ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testWriteManyWithIdentityColumn	"If the database supports identity columns, GlorpBankTransaction will have one (GlorpCustomer will not) and so this will exercise insertion in that case."	| customer largeRowSize |	session beginTransaction.	[customer := GlorpCustomer new.	customer name: 'foo'.     customer id: 123.	largeRowSize := 500.	1 to: largeRowSize do:		[:i || transaction |		transaction := GlorpBankTransaction new.		transaction amount amount: i.		customer addTransaction: transaction].	session beginUnitOfWork.	session register: customer.	session commitUnitOfWork.	self assert: (session readOneOf: GlorpCustomer) transactions size = largeRowSize]		ensure: [session rollbackTransaction].</body></methods><methods><class-id>Glorp.GlorpWritingTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.</body><body package="GlorpDBTests">tearDown	super tearDown.	session reset.	session := nil.</body></methods><methods><class-id>Glorp.GlorpWritingTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource</body></methods><methods><class-id>Glorp.GlorpNumeric5ZeroTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform numeric precision: 5; scale: 0.</body><body package="GlorpDBTypeTests">testNumeric5Zero	self platform supportsVariableSizedNumerics ifFalse: [^self].	self helpTestFloat: nil.	self helpTestFloat: 12.		self helpTestFloat: 10991.			self helpTestFloat: (Dialect coerceToDoublePrecisionFloat: 3.0).	self helpTestInvalidValue: (Dialect coerceToDoublePrecisionFloat: 321.12).	self helpTestFloat: (Dialect readFixedPointFrom: '3.0').	self helpTestInvalidValue: (Dialect readFixedPointFrom: '321.12').	self helpTestInvalidValue: 3.14.</body></methods><methods><class-id>Glorp.GlorpInsertUpdateTest</class-id> <category>support</category><body package="GlorpDBTests">rowFor: anObject	| rowMap rows |	rowMap := RowMap new.	session createRowsFor: anObject in: rowMap.	rows := rowMap rowsForKey: anObject.	self assert: rows size = 1.	^rows first.</body><body package="GlorpDBTests">setUp	super setUp.	session := GlorpSessionResource current newSession.</body></methods><methods><class-id>Glorp.GlorpInsertUpdateTest</class-id> <category>tests</category><body package="GlorpDBTests">testFunctionalInsertUpdateForInsert	| testObject |	[session beginTransaction.	session beginUnitOfWork.	testObject := GlorpCustomer example1.	testObject id: 876.	session register: testObject.	session commitUnitOfWork.	self assert: (testObject seenPreWrite = true).	self assert: (testObject seenPostWrite = true).	session beginUnitOfWork.	session register: testObject.	testObject name: 'Change of name'.	session commitUnitOfWork]		ensure: [session rollbackTransaction]</body><body package="GlorpDBTests">testRowOwnership	| aCustomer rowMap |	aCustomer := GlorpCustomer new.	rowMap := RowMap new.	(session descriptorFor: GlorpCustomer) createRowsFor: aCustomer in: rowMap.	rowMap rowsDo: [:each | 		self assert: each owner = aCustomer].</body><body package="GlorpDBTests">testShouldInsertForInsert	| testObject row |	testObject := GlorpCustomer example1.	testObject id: 876.	row :=self rowFor: testObject.	self assert: (session shouldInsert: row).</body><body package="GlorpDBTests">testShouldInsertForUpdate	| testObject row |	session beginUnitOfWork.	testObject := GlorpCustomer example1.	testObject id: 876.	session cacheAt: 876 put: testObject.	row :=self rowFor: testObject.	self deny: (session shouldInsert: row).</body></methods><methods><class-id>Glorp.GlorpInsertUpdateTest class</class-id> <category>resources</category><body package="GlorpDBTests">resources	^Array with: GlorpSessionResource.</body></methods><methods><class-id>Glorp.GlorpInt8Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testInt8	type := (self platform) int8.	self helpTestValue: nil.	self helpTestValue: 3212321555.</body></methods><methods><class-id>Glorp.GlorpInt8Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform int8</body></methods><methods><class-id>Glorp.GlorpVarchar10Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform varchar: 10.</body></methods><methods><class-id>Glorp.GlorpVarchar10Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testVarCharWithEscapedCharacters	stType := String.	self helpTestValue: nil.	#($\ $~ $` $! $@ $# $$ $% $^ $&amp; $* $( $) $_ $- $+ $= $| $} ${ $] $[ $" $' $: $; $? $/ $&gt; $. $&lt; $,)		do: [:ea | self helpTestValue: 'abc' , (String with: ea) , 'def']</body></methods><methods><class-id>Glorp.GlorpChar4Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform char width: 4.</body></methods><methods><class-id>Glorp.GlorpChar4Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testChar4	stType := String.	self helpTestValue: nil.	self helpTestValue: '' compareWith: [:read :original |		self platform usesNullForEmptyStrings ifTrue: [read = nil] ifFalse: [read = original]].	self helpTestValue: 'a'.	self helpTestValue: 'ab'.	self helpTestValue: 'abc'.	self helpTestValue: 'abcd'.	self should: [self helpTestInvalidValue: 'abcde'] raise: GlorpDatabaseWriteError.	stType := Symbol.	"This overlong-means-invalid check fails on SQLite where column length limits are unenforced."	self helpTestValue: #abcd.		self assert: (type typeString asUppercase= (self platform char: 4) typeString asUppercase)</body><body package="GlorpDBTypeTests">testTrimmedChar4	| converter |	stType := String.	converter := type platform converterNamed: #stringToTrimmedString.	self assert: (converter convert:  'abc' toDatabaseRepresentationAs: type)					= ('abc', (Array with: type platform paddingCharacter)).	self assert: (converter convert:  'abcd' toDatabaseRepresentationAs: type) = 'abcd'.	self assert: (converter convert:  'abcde' toDatabaseRepresentationAs: type) = 'abcd'.</body></methods><methods><class-id>Glorp.ClassH</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassH	^attrAClassH</body><body package="GlorpTestModels">attrAClassH: anObject	attrAClassH := anObject</body><body package="GlorpTestModels">attrBClassH	^attrBClassH</body><body package="GlorpTestModels">attrBClassH: anObject	attrBClassH := anObject</body><body package="GlorpTestModels">attrCClassH	^attrCClassH</body><body package="GlorpTestModels">attrCClassH: anObject	attrCClassH := anObject</body><body package="GlorpTestModels">attrDClassH	^attrDClassH</body><body package="GlorpTestModels">attrDClassH: anObject	attrDClassH := anObject</body></methods><methods><class-id>Glorp.ClassH</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassH := nil.	attrBClassH := nil.	attrCClassH := nil.	attrDClassH := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.ClassH class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpInt4Test</class-id> <category>tests</category><body package="GlorpDBTypeTests">testInt4	self helpTestValue: nil.	self helpTestValue: 3212321.</body></methods><methods><class-id>Glorp.GlorpInt4Test</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform int4</body></methods><methods><class-id>Glorp.GlorpInt4Test class</class-id> <category>instance creation</category><body package="GlorpDBTypeTests">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.GlorpRecordWithUpdateTime</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id.</body><body package="GlorpTestModels">id: anInteger	id := anInteger.</body><body package="GlorpTestModels">name	^name.</body><body package="GlorpTestModels">name: aString	name := aString.</body><body package="GlorpTestModels">updateSomeOtherThing	^updateSomeOtherThing</body><body package="GlorpTestModels">updateSomeOtherThing: aString	updateSomeOtherThing := aString</body><body package="GlorpTestModels">updateTime	^updateTime.</body></methods><methods><class-id>Glorp.GlorpNumericTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">testNumeric	| floatSelector |	self helpTestFloat: 12.		self helpTestFloat: nil.	self helpTestFloat: (Dialect readFixedPointFrom: '12345678').	self platform supportsDecimalsOnAllNumerics ifTrue: [		self helpTestValue: 3.14  compareWith: [:read :original |			read - original &lt;= 0.00001]]		ifFalse: [self helpTestInvalidValue: 3.14].	floatSelector := self platform supportsDecimalsOnAllNumerics ifTrue: [#helpTestFloat:] ifFalse: [#helpTestInvalidValue:].	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat:  321.12).	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat: 321.123).	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat: (Dialect readFixedPointFrom: '321.123456789')).	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat: 3.14).	self perform: floatSelector with: (Dialect coerceToDoublePrecisionFloat: 3.1).	self perform: floatSelector with: (Dialect readFixedPointFrom:  '321.12').	self perform: floatSelector with: (Dialect readFixedPointFrom: '321.123').	self perform: floatSelector with: (Dialect readFixedPointFrom: '3.14').	self perform: floatSelector with: (Dialect readFixedPointFrom: '3.1').</body></methods><methods><class-id>Glorp.GlorpNumericTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	"DB2 default precision is only 5, which needs to be increased for this test."	^self platform isDB2Platform		ifTrue: [self platform numeric precision: 10]		ifFalse: [self platform numeric]</body></methods><methods><class-id>Glorp.GlorpEmailDomain</class-id> <category>accessing</category><body package="GlorpTestModels">addresses	^addresses</body><body package="GlorpTestModels">addresses: anObject	addresses := anObject</body><body package="GlorpTestModels">topLevelDomain	^topLevelDomain</body><body package="GlorpTestModels">topLevelDomain: anObject	topLevelDomain := anObject</body></methods><methods><class-id>Glorp.GlorpIntegerTest</class-id> <category>tests</category><body package="GlorpDBTypeTests">testInteger	type := (self platform) integer.	self helpTestValue: nil.	self helpTestValue: 3212321.</body></methods><methods><class-id>Glorp.GlorpIntegerTest</class-id> <category>types</category><body package="GlorpDBTypeTests">defaultDatabaseType	^self platform integer.</body></methods><methods><class-id>Glorp.GlorpSlave</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id.</body><body package="GlorpTestModels">id: anObject	id := anObject.</body></methods><methods><class-id>Glorp.GlorpOffice</class-id> <category>accessing</category><body package="GlorpTestModels">addEmployee: anEmployee	self employees add: anEmployee.</body><body package="GlorpTestModels">employeeOfMonth	^employeeOfMonth</body><body package="GlorpTestModels">employeeOfMonth: anObject	employeeOfMonth := anObject</body><body package="GlorpTestModels">employees	employees isNil ifTrue: [ employees := OrderedCollection new ].	^employees</body><body package="GlorpTestModels">employees: anObject	employees := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">street	^street</body><body package="GlorpTestModels">street: aString	street := aString</body></methods><methods><class-id>Glorp.ASItemBonus</class-id> <category>accessing</category><body package="GlorpTestModels">bonus	^bonus</body><body package="GlorpTestModels">bonus: anObject	bonus := anObject</body><body package="GlorpTestModels">item	^item</body><body package="GlorpTestModels">item: anObject	item := anObject</body></methods><methods><class-id>Glorp.AlphaDescriptorSystem</class-id> <category>tables</category><body package="GlorpTestModels">classModelForClassExample: aClassModel	aClassModel newAttributeNamed: #id type: Integer.	aClassModel newAttributeNamed: #trace type: ClassExample.	aClassModel newAttributeNamed: #value type: String.</body><body package="GlorpTestModels">descriptorForClassExample: aDescriptor	| table |	table := self tableNamed: 'CLASS_EXAMPLE'.	aDescriptor table: table.	aDescriptor directMapping from: #id to: (table fieldNamed: 'id').	aDescriptor oneToOneMapping		attributeName: #trace;		join: (Join from: (table fieldNamed: 'trace')				to: (table fieldNamed: 'id')).	aDescriptor directMapping from: #value to: (table fieldNamed: 'value').</body><body package="GlorpTestModels">tableForCLASS_EXAMPLE: aTable	(aTable createFieldNamed: 'id' type: platform serial) bePrimaryKey.	((aTable createFieldNamed: 'trace' type: platform int4) imDefaultValue: 0)		beNullable: false.	aTable createFieldNamed: 'value' type: (platform varChar: 255).</body><body package="GlorpTestModels">tableForTBLA: aTable	(aTable createFieldNamed: 'ATTRACLASSA' type: (platform varChar: 20)) bePrimaryKey.	aTable createFieldNamed: 'ATTRBCLASSA' type: (platform varChar: 70).	aTable createFieldNamed: 'ATTRCCLASSA' type: platform integer.	aTable createFieldNamed: 'ATTRDCLASSA' type: (platform number precision: 9; scale: 4; yourself).	aTable createFieldNamed: 'ATTRECLASSA' type: platform integer.	aTable createFieldNamed: 'ATTRHCLASSA' type: platform boolean.</body><body package="GlorpTestModels">tableForTBLB: aTable	| field |	(aTable createFieldNamed: 'ATTRACLASSB' type: (platform varChar: 20)) bePrimaryKey.	aTable createFieldNamed: 'ATTRCCLASSB' type: (platform varChar: 70).	field := aTable createFieldNamed: 'ATTRBCLASSB' type: (platform varChar: 20).	aTable addForeignKeyFrom: field to: ((self tableNamed: 'TBLA') fieldNamed: 'ATTRACLASSA').	field bePrimaryKey.	field := aTable createFieldNamed: 'ATTRDCLASSB' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'TBLC') fieldNamed: 'ATTRACLASSC').	field bePrimaryKey.</body><body package="GlorpTestModels">tableForTBLC: aTable	(aTable createFieldNamed: 'ATTRACLASSC' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'ATTRBCLASSC' type: (platform varChar: 20).</body><body package="GlorpTestModels">tableForTBLE: aTable	"The issues of test 07 and 07a relate to whether the filter field 'OBJECT_TYPE' is or is not a primaryKey."	(aTable createFieldNamed: 'ATTRACLASSE' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'ATTRBCLASSE' type: (platform varChar: 20).	aTable createFieldNamed: 'OBJECT_TYPE' type: (platform varChar: 2).	aTable createFieldNamed: 'ATTRACLASSF' type: (platform varChar: 20).	aTable createFieldNamed: 'ATTRACLASSG' type: (platform varChar: 20).</body><body package="GlorpTestModels">tableForTBLH1: aTable	(aTable createFieldNamed: 'ATTRACLASSH' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'ATTRCCLASSH' type: (platform varChar: 20).	aTable createFieldNamed: 'ATTRDCLASSH' type: (platform varChar: 50).</body><body package="GlorpTestModels">tableForTBLH: aTable	(aTable createFieldNamed: 'ATTRACLASSH' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'ATTRBCLASSH' type: (platform varChar: 70).</body><body package="GlorpTestModels">tableForTBLI: aTable	| field |	field := aTable createFieldNamed: 'ATTRACLASSI' type: (platform varChar: 20).	aTable addForeignKeyFrom: field to: ((self tableNamed: 'TBLA') fieldNamed: 'ATTRACLASSA').	field bePrimaryKey.	field := aTable createFieldNamed: 'ATTRBCLASSI' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'TBLC') fieldNamed: 'ATTRACLASSC').	field bePrimaryKey.</body><body package="GlorpTestModels">tableForTBLJ: aTable	(aTable createFieldNamed: 'ATTRACLASSJ' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'ATTRBCLASSJ' type: (platform varChar: 70).</body><body package="GlorpTestModels">tableForTBLK: aTable	| field |	(aTable createFieldNamed: 'ATTRACLASSK' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'ATTRBCLASSK' type: platform integer.	field := aTable createFieldNamed: 'ATTRCCLASSK' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'TBLJ') fieldNamed: 'ATTRACLASSJ').</body><body package="GlorpTestModels">tableForTBLL: aTable	| field |	(aTable createFieldNamed: 'ATTRACLASSL' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'ATTRBCLASSL' type: (platform varChar: 20).	aTable createFieldNamed: 'ATTRCCLASSL' type: platform integer.	field := aTable createFieldNamed: 'ATTRDCLASSL' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'TBLM') fieldNamed: 'ATTRACLASSM').</body><body package="GlorpTestModels">tableForTBLM: aTable	(aTable createFieldNamed: 'ATTRACLASSM' type: platform integer) bePrimaryKey.</body><body package="GlorpTestModels">tableForTBLO: aTable	(aTable createFieldNamed: 'ATTRACLASSO' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'ATTRBCLASSO' type: (platform varChar: 20).	aTable createFieldNamed: 'ATTRCCLASSO' type: platform integer.	aTable createFieldNamed: 'ATTRDCLASSO' type: platform integer.</body><body package="GlorpTestModels">tableForTBLQ: aTable	| field |	(aTable createFieldNamed: 'ATTRACLASSQ' type: platform integer) bePrimaryKey.	field := aTable createFieldNamed: 'ATTRBCLASSQ' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'TBLE') fieldNamed: 'ATTRACLASSE').</body></methods><methods><class-id>Glorp.AlphaDescriptorSystem</class-id> <category>classes</category><body package="GlorpTestModels">classModelForClassA: aClassModel	self attrsOfClassA do: [:eachAttrName | aClassModel newAttributeNamed: eachAttrName].	aClassModel newAttributeNamed: #attrEClassA.	aClassModel newAttributeNamed: #attrFClassA collectionOf: ClassB.	aClassModel newAttributeNamed: #attrGClassA collectionOf: ClassI.	aClassModel newAttributeNamed: #attrHClassA type: Boolean.</body><body package="GlorpTestModels">classModelForClassB: aClassModel	aClassModel newAttributeNamed: #attrAClassB.	aClassModel newAttributeNamed: #attrBClassB type: ClassA.	aClassModel newAttributeNamed: #attrCClassB.	aClassModel newAttributeNamed: #attrDClassB type: ClassC.</body><body package="GlorpTestModels">classModelForClassC: aClassModel	aClassModel newAttributeNamed: #attrAClassC.	aClassModel newAttributeNamed: #attrBClassC.</body><body package="GlorpTestModels">classModelForClassF: aClassModel	aClassModel newAttributeNamed: #attrAClassE.	aClassModel newAttributeNamed: #attrBClassE.	aClassModel newAttributeNamed: #attrAClassF.</body><body package="GlorpTestModels">classModelForClassG: aClassModel	aClassModel newAttributeNamed: #attrAClassE.	aClassModel newAttributeNamed: #attrBClassE.	aClassModel newAttributeNamed: #attrAClassG.</body><body package="GlorpTestModels">classModelForClassH: aClassModel	self attrsOfClassH do: [:eachAttrName | aClassModel newAttributeNamed: eachAttrName].</body><body package="GlorpTestModels">classModelForClassI: aClassModel	aClassModel newAttributeNamed: #attrAClassI type: ClassA.	aClassModel newAttributeNamed: #attrBClassI type: ClassC.</body><body package="GlorpTestModels">classModelForClassJ: aClassModel	aClassModel newAttributeNamed: #attrAClassJ.	aClassModel newAttributeNamed: #attrBClassJ.	aClassModel newAttributeNamed: #attrCClassJ collectionOf: ClassK.</body><body package="GlorpTestModels">classModelForClassK: aClassModel	aClassModel newAttributeNamed: #attrAClassK.	aClassModel newAttributeNamed: #attrBClassK.	aClassModel newAttributeNamed: #attrCClassK type: ClassJ.</body><body package="GlorpTestModels">classModelForClassL: aClassModel	self attrsOfClassL do: [:eachAttrName | aClassModel newAttributeNamed: eachAttrName].	aClassModel newAttributeNamed: #attrDClassL type: ClassM.</body><body package="GlorpTestModels">classModelForClassM: aClassModel	aClassModel newAttributeNamed: #attrAClassM.</body><body package="GlorpTestModels">classModelForClassO: aClassModel	self attrsOfClassO do: [:eachAttrName | aClassModel newAttributeNamed: eachAttrName].</body><body package="GlorpTestModels">classModelForClassQ: aClassModel	aClassModel newAttributeNamed: #attrAClassQ.	aClassModel newAttributeNamed: #attrBClassQ type: ClassF.</body></methods><methods><class-id>Glorp.AlphaDescriptorSystem</class-id> <category>descriptors</category><body package="GlorpTestModels">descriptorForClassA: aDescriptor	| table |	table := self tableNamed: 'TBLA'.	aDescriptor table: table.	self attrsOfClassA do:		[:eachAttrName |		aDescriptor directMapping			from: eachAttrName			to: eachAttrName asString asUppercase].	(aDescriptor directMapping from: #attrEClassA to: 'ATTRECLASSA')		converter: self newBooleanConverter;		shouldProxy: true.	aDescriptor toManyMapping attributeName: #attrFClassA.	aDescriptor toManyMapping attributeName: #attrGClassA.	aDescriptor directMapping from: #attrHClassA to: 'ATTRHCLASSA'.</body><body package="GlorpTestModels">descriptorForClassB: aDescriptor	| table newMapping join |	table := self tableNamed: 'TBLB'.	aDescriptor table: table.	aDescriptor directMapping		from: #attrAClassB		to: (table fieldNamed: #attrAClassB asString asUppercase).	aDescriptor directMapping		from: #attrCClassB		to: (table fieldNamed: #attrCClassB asString asUppercase).	newMapping := aDescriptor oneToOneMapping.	newMapping attributeName: #attrBClassB.	join := Join new.	join		from: (table fieldNamed: #attrBClassB asString asUppercase)		to: ((self tableNamed: 'TBLA') fieldNamed: 'ATTRACLASSA').	newMapping join: join.	newMapping := aDescriptor oneToOneMapping.	newMapping attributeName: #attrDClassB.	join := Join new.	join		from: (table fieldNamed: #attrDClassB asString asUppercase)		to: ((self tableNamed: 'TBLC') fieldNamed: 'ATTRACLASSC').	newMapping join: join.</body><body package="GlorpTestModels">descriptorForClassC: aDescriptor	| table |	table := self tableNamed: 'TBLC'.	aDescriptor table: table.	aDescriptor directMapping		from: #attrAClassC		to: (table fieldNamed: #attrAClassC asString asUppercase).	aDescriptor directMapping		from: #attrBClassC		to: (table fieldNamed: #attrBClassC asString asUppercase).</body><body package="GlorpTestModels">descriptorForClassE: aDescriptor	| table |	table := self tableNamed: 'TBLE'.	aDescriptor table: table.	aDescriptor directMapping		from: #attrAClassE		to: (table fieldNamed: #attrAClassE asString asUppercase).	aDescriptor directMapping		from: #attrBClassE		to: (table fieldNamed: #attrBClassE asString asUppercase).	(self typeResolverFor: ClassE) register: aDescriptor abstract: true.</body><body package="GlorpTestModels">descriptorForClassF: aDescriptor	| table |	table := self tableNamed: 'TBLE'.	aDescriptor table: table.	aDescriptor directMapping		from: #attrAClassE		to: (table fieldNamed: #attrAClassE asString asUppercase).	aDescriptor directMapping		from: #attrBClassE		to: (table fieldNamed: #attrBClassE asString asUppercase).	aDescriptor directMapping		from: #attrAClassF		to: (table fieldNamed: #attrAClassF asString asUppercase).	(self typeResolverFor: ClassE)		register: aDescriptor		keyedBy: 'F'		field: (table fieldNamed: 'OBJECT_TYPE').</body><body package="GlorpTestModels">descriptorForClassG: aDescriptor	| table |	table := self tableNamed: 'TBLE'.	aDescriptor table: table.	aDescriptor directMapping		from: #attrAClassE		to: (table fieldNamed: #attrAClassE asString asUppercase).	aDescriptor directMapping		from: #attrBClassE		to: (table fieldNamed: #attrBClassE asString asUppercase).	aDescriptor directMapping		from: #attrAClassG		to: (table fieldNamed: #attrAClassG asString asUppercase).	(self typeResolverFor: ClassE)		register: aDescriptor		keyedBy: 'G'		field: (table fieldNamed: 'OBJECT_TYPE').</body><body package="GlorpTestModels">descriptorForClassH: aDescriptor	| tableH tableH1 |	tableH := self tableNamed: 'TBLH'.	aDescriptor table: tableH.	tableH1 := self tableNamed: 'TBLH1'.	aDescriptor table: tableH1.	aDescriptor addMultipleTableJoin: (Join from: (tableH fieldNamed: 'ATTRACLASSH') to: (tableH1 fieldNamed: 'ATTRACLASSH')).	#(#attrAClassH #attrBClassH) do:		[:eachAttrName |		aDescriptor directMapping			from: eachAttrName			to: (tableH fieldNamed: eachAttrName asString asUppercase)].	#(#attrCClassH #attrDClassH) do:		[:eachAttrName || eachField mapping | eachField := tableH1 fieldNamed: eachAttrName.		mapping := aDescriptor adHocMapping			forAttribute: eachAttrName			fromDb:				[:row :elementBuilder :context |				elementBuilder valueOfField: (context translateField: eachField) in: row]			toDb:				[:rows :attribute :attributeRows |				(rows at: eachField table) at: eachField put: attribute]		mappingFields: (Array with: eachField).		mapping shouldProxy: true].					"			mapping := aDescriptor adHocMapping			from: eachAttrName			to: (((#(#attrAClassH #attrBClassH) includes: eachAttrName) ifTrue: [tableH] ifFalse: [tableH1]) fieldNamed: eachAttrName asString asUppercase).		mapping field table == tableH ifFalse:			mapping query retrieve: (#(#attrCClassH #attrDClassH) asOrderedCollection remove: eachAttrName; first)]]."</body><body package="GlorpTestModels">descriptorForClassI: aDescriptor	| table |	table := self tableNamed: 'TBLI'.	aDescriptor table: table.	aDescriptor oneToOneMapping		attributeName: #attrAClassI;		join: (Join new				from: (table fieldNamed: #attrAClassI asString asUppercase)				to: ((self tableNamed: 'TBLA') fieldNamed: 'ATTRACLASSA')).	aDescriptor oneToOneMapping		attributeName: #attrBClassI;		join: (Join new				from: (table fieldNamed: #attrBClassI asString asUppercase)				to: ((self tableNamed: 'TBLC') fieldNamed: 'ATTRACLASSC')).</body><body package="GlorpTestModels">descriptorForClassJ: aDescriptor	| table |	table := self tableNamed: 'TBLJ'.	aDescriptor table: table.	aDescriptor directMapping		from: #attrAClassJ		to: (table fieldNamed: #attrAClassJ asString asUppercase).	aDescriptor directMapping		from: #attrBClassJ		to: (table fieldNamed: #attrBClassJ asString asUppercase).	aDescriptor toManyMapping		attributeName: #attrCClassJ;		orderBy: [:classKObj | classKObj attrBClassK descending].</body><body package="GlorpTestModels">descriptorForClassK: aDescriptor	| table newMapping join |	table := self tableNamed: 'TBLK'.	aDescriptor table: table.	aDescriptor directMapping		from: #attrAClassK		to: (table fieldNamed: #attrAClassK asString asUppercase).	aDescriptor directMapping		from: #attrBClassK		to: (table fieldNamed: #attrBClassK asString asUppercase).	newMapping := aDescriptor oneToOneMapping.	newMapping attributeName: #attrCClassK.	join := Join new.	join		from: (table fieldNamed: #attrCClassK asString asUppercase)		to: ((self tableNamed: 'TBLJ') fieldNamed: 'ATTRACLASSJ').	newMapping join: join.</body><body package="GlorpTestModels">descriptorForClassL: aDescriptor	| table newMapping join |	table := self tableNamed: 'TBLL'.	aDescriptor table: table.	self attrsOfClassL do:		[:eachAttrName |		newMapping := aDescriptor directMapping			from: eachAttrName			to: (table fieldNamed: eachAttrName asString asUppercase)].	newMapping := aDescriptor oneToOneMapping.	newMapping attributeName: #attrDClassL.	join := Join new.	join		from: (table fieldNamed: #attrDClassL asString asUppercase)		to: ((self tableNamed: 'TBLM') fieldNamed: 'ATTRACLASSM').	newMapping join: join.</body><body package="GlorpTestModels">descriptorForClassM: aDescriptor	| table |	table := self tableNamed: 'TBLM'.	aDescriptor table: table.	aDescriptor directMapping		from: #attrAClassM		to: (table fieldNamed: #attrAClassM asString asUppercase).</body><body package="GlorpTestModels">descriptorForClassO: aDescriptor	| table newMapping |	table := self tableNamed: 'TBLO'.	aDescriptor table: table.	self attrsOfClassO do:		[:eachAttrName |		newMapping := aDescriptor directMapping			from: eachAttrName			to: (table fieldNamed: eachAttrName asString asUppercase)].</body><body package="GlorpTestModels">descriptorForClassQ: aDescriptor	| table newMapping join |	table := self tableNamed: 'TBLQ'.	aDescriptor table: table.	newMapping := aDescriptor directMapping		from: #attrAClassQ		to: (table fieldNamed: #attrAClassQ asString asUppercase).	newMapping := aDescriptor oneToOneMapping.	newMapping attributeName: #attrBClassQ.	join := Join new.	join		from: (table fieldNamed: #attrBClassQ asString asUppercase)		to: ((self tableNamed: 'TBLE') fieldNamed: 'ATTRACLASSE').	newMapping join: join.</body><body package="GlorpTestModels">typeResolverForClassE	^FilteredTypeResolver forRootClass: ClassE</body></methods><methods><class-id>Glorp.AlphaDescriptorSystem</class-id> <category>accessing</category><body package="GlorpTestModels">allTableNames	^#('TBLA' 'TBLB' 'TBLC' 'TBLE' 'TBLH' 'TBLH1' 'TBLI' 'TBLJ' 'TBLK'  'TBLL' 'TBLM' 'TBLO' 'TBLQ')</body><body package="GlorpTestModels">attrsOfClassA	^#(#attrAClassA #attrBClassA #attrCClassA #attrDClassA)</body><body package="GlorpTestModels">attrsOfClassH	^#(#attrAClassH #attrBClassH #attrCClassH #attrDClassH).</body><body package="GlorpTestModels">attrsOfClassL	^#(#attrAClassL #attrBClassL #attrCClassL).</body><body package="GlorpTestModels">attrsOfClassO	^#(#attrAClassO #attrBClassO #attrCClassO #attrDClassO).</body><body package="GlorpTestModels">newBooleanConverter	^PluggableDatabaseConverter new		dbToStConverter: [:dbVal | dbVal == 1];		stToDbConverter: [:stVal | stVal == true ifTrue: [1] ifFalse: [0]];		yourself</body></methods><methods><class-id>Glorp.AlphaDescriptorSystem</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Earlier code for this descriptor system overrode getter #useDirectAccessForMapping to return false.  In this version, we set the instVar here instead, so that if anyone resets it then their exercise of the tests will be as they expect."	super initialize.	useDirectAccessForMapping := false.</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>As yet unclassified</category><body package="GlorpTestModels">customer	^customer.</body><body package="GlorpTestModels">customer: aCustomer	customer := aCustomer.</body><body package="GlorpTestModels">store: aGlorpVideoStore	store := aGlorpVideoStore.</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>accessing</category><body package="GlorpTestModels">dueDate	^dueDate</body><body package="GlorpTestModels">dueDate: anObject	dueDate := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">price	^price</body><body package="GlorpTestModels">price: anObject	price := anObject</body><body package="GlorpTestModels">title	^title</body><body package="GlorpTestModels">title: anObject	title := anObject</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: self title.	aStream nextPut: $).</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>testing</category><body package="GlorpTestModels">assertEqual: aRental	self assert: customer name = aRental customer name.	self assert: customer dateOfBirth = aRental customer dateOfBirth.	self assert: id = aRental id.	self assert: title = aRental title.	self assert: price = aRental price.	self assert: dueDate = aRental dueDate.</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	" *** Edit the following to properly initialize instance variables ***"	id := nil.	title := nil.	dueDate := nil.	price := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.GlorpVideoRental</class-id> <category>comparing</category><body package="GlorpTestModels">&lt;= aVideoRental	^self title &lt;= aVideoRental title.</body></methods><methods><class-id>Glorp.GlorpVideoRental class</class-id> <category>instance creation</category><body package="GlorpTestModels">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Glorp.AnySatisfyDescrSystem</class-id> <category>accessing</category><body package="GlorpTestModels">allTableNames	^#('ASCUSTOMER' 'ASORDER' 'ASORDERLINEITEM' 'ASITEM' 'ASITEMBONUS' 'ASBONUS').</body><body package="GlorpTestModels">classModelForASBonus: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #credits</body><body package="GlorpTestModels">classModelForASCustomer: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #orders collectionOf: ASOrder.</body><body package="GlorpTestModels">classModelForASItem: aClassModel	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #name.	aClassModel newAttributeNamed: #bonuses collectionOf: ASItemBonus.</body><body package="GlorpTestModels">classModelForASItemBonus: aClassModel	aClassModel newAttributeNamed: #item type: ASItem.	aClassModel newAttributeNamed: #bonus type: ASBonus.</body><body package="GlorpTestModels">classModelForASOrder: aClassModel	aClassModel newAttributeNamed: #orderNo.	aClassModel newAttributeNamed: #customer type: ASCustomer.	aClassModel newAttributeNamed: #lineItems collectionOf: ASOrderLineItem.</body><body package="GlorpTestModels">classModelForASOrderLineItem: aClassModel	aClassModel newAttributeNamed: #posNo.	aClassModel newAttributeNamed: #item type: ASItem.	aClassModel newAttributeNamed: #order type: ASOrder.	aClassModel newAttributeNamed: #quantity.	aClassModel newAttributeNamed: #price.</body><body package="GlorpTestModels">descriptorForASBonus: aDescriptor	| table |	table := self tableNamed: 'ASBONUS'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: DirectMapping)		from: #credits		to: (table fieldNamed: 'CREDITS').</body><body package="GlorpTestModels">descriptorForASCustomer: aDescriptor	| table |	table := self tableNamed: 'ASCUSTOMER'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: OneToManyMapping)		attributeName: #orders.</body><body package="GlorpTestModels">descriptorForASItem: aDescriptor	| table |	table := self tableNamed: 'ASITEM'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #id		to: (table fieldNamed: 'ID').	(aDescriptor newMapping: DirectMapping)		from: #name		to: (table fieldNamed: 'NAME').	(aDescriptor newMapping: OneToManyMapping)		attributeName: #bonuses.</body><body package="GlorpTestModels">descriptorForASItemBonus: aDescriptor	| table newMapping join |	table := self tableNamed: 'ASITEMBONUS'.	aDescriptor table: table.	newMapping := aDescriptor newMapping: OneToOneMapping.	newMapping attributeName: #item.	join := Join new.	join		from: (table fieldNamed: 'ITEMID')		to: ((self tableNamed: 'ASITEM') fieldNamed: 'ID').	newMapping join: join.	newMapping := aDescriptor newMapping: OneToOneMapping.	newMapping attributeName: #bonus.	join := Join new.	join		from: (table fieldNamed: 'BONUSID')		to: ((self tableNamed: 'ASBONUS') fieldNamed: 'ID').	newMapping join: join.</body><body package="GlorpTestModels">descriptorForASOrder: aDescriptor	| table newMapping join |	table := self tableNamed: 'ASORDER'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #orderNo		to: (table fieldNamed: 'ORDERNO').	(aDescriptor newMapping: OneToManyMapping)		attributeName: #lineItems.	newMapping := aDescriptor newMapping: OneToOneMapping.	newMapping attributeName: #customer.	join := Join new.	join		from: (table fieldNamed: 'CUSTOMERID')		to: ((self tableNamed: 'ASCUSTOMER') fieldNamed: 'ID').	newMapping join: join.</body><body package="GlorpTestModels">descriptorForASOrderLineItem: aDescriptor	| table newMapping join |	table := self tableNamed: 'ASORDERLINEITEM'.	aDescriptor table: table.	(aDescriptor newMapping: DirectMapping)		from: #posNo		to: (table fieldNamed: 'POSNO').	(aDescriptor newMapping: DirectMapping)		from: #quantity		to: (table fieldNamed: 'QUANTITY').	(aDescriptor newMapping: DirectMapping)		from: #price		to: (table fieldNamed: 'PRICE').	newMapping := aDescriptor newMapping: OneToOneMapping.	newMapping attributeName: #order.	join := Join new.	join		from: (table fieldNamed: 'ORDERORDERNO')		to: ((self tableNamed: 'ASORDER') fieldNamed: 'ORDERNO').	newMapping join: join.	newMapping := aDescriptor newMapping: OneToOneMapping.	newMapping attributeName: #item.	join := Join new.	join		from: (table fieldNamed: 'ITEMID')		to: ((self tableNamed: 'ASITEM') fieldNamed: 'ID').	newMapping join: join.</body><body package="GlorpTestModels">tableForASBONUS: aTable	(aTable createFieldNamed: 'ID' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).	aTable createFieldNamed: 'CREDITS' type: (platform integer).</body><body package="GlorpTestModels">tableForASCUSTOMER: aTable	(aTable createFieldNamed: 'ID' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).</body><body package="GlorpTestModels">tableForASITEM: aTable	(aTable createFieldNamed: 'ID' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'NAME' type: (platform varChar: 20).</body><body package="GlorpTestModels">tableForASITEMBONUS: aTable	| field |	field := aTable createFieldNamed: 'ITEMID' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'ASITEM') fieldNamed: 'ID').	field bePrimaryKey.	field := aTable createFieldNamed: 'BONUSID' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'ASBONUS') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForASORDER: aTable	| field |	(aTable createFieldNamed: 'ORDERNO' type: platform integer) bePrimaryKey.	field := aTable createFieldNamed: 'CUSTOMERID' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'ASCUSTOMER') fieldNamed: 'ID').</body><body package="GlorpTestModels">tableForASORDERLINEITEM: aTable	| field |	(aTable createFieldNamed: 'POSNO' type: platform integer) bePrimaryKey.	aTable createFieldNamed: 'QUANTITY' type: (platform number precision: 9; scale: 4; yourself).	aTable createFieldNamed: 'PRICE' type: (platform number precision: 9; scale: 4; yourself).	field := aTable createFieldNamed: 'ORDERORDERNO' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'ASORDER') fieldNamed: 'ORDERNO').	field bePrimaryKey.	field := aTable createFieldNamed: 'ITEMID' type: platform integer.	aTable addForeignKeyFrom: field to: ((self tableNamed: 'ASITEM') fieldNamed: 'ID').</body></methods><methods><class-id>Glorp.ClassF</class-id> <category>accessing</category><body package="GlorpTestModels">attrAClassF	^attrAClassF</body><body package="GlorpTestModels">attrAClassF: anObject	attrAClassF := anObject</body></methods><methods><class-id>Glorp.ClassF</class-id> <category>initialize-release</category><body package="GlorpTestModels">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	attrAClassF := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Glorp.GlorpConditionalMappingDBTest</class-id> <category>data</category><body package="GlorpDBTests">writeExampleEncycFeaturesOneMapOneInlineOneNil	| encycFeatures stBestEntry |	encycFeatures := session system exampleEncyclopediaFeatures.	session transact: [session register: encycFeatures].	self assert: (session read: GlorpEncyclopediaFeature) size = encycFeatures size.	session reset.	self assert: (session				read: GlorpEncyclopediaFeature				where: [:each | each featuredEntryID notNil]) isEmpty.	self assert: (session				read: GlorpEncyclopediaFeature				where: [:each | each featuredEntryString notNil]) isEmpty.	session reset.	"Write data using the conditional mapping"	session transact:		[encycFeatures := session read: GlorpEncyclopediaFeature orderBy: [:each | each encyclopedia id].		stBestEntry := session readOneOf: GlorpEncyclopediaEntry where: [:each | each id = 'two'].		encycFeatures first featured: stBestEntry.		encycFeatures last featuredEntryText: 'Silence is Golden'.		encycFeatures].	session reset.</body></methods><methods><class-id>Glorp.GlorpConditionalMappingDBTest</class-id> <category>running</category><body package="GlorpDBTests">setUp	super setUp.	system := GlorpEncyclopediaConditionalTestSystem forPlatform: session system platform.	session system: system.	session beginTransaction.	"prevent any transaction in test committing transaction along with the unit of work."</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests">testNilCompare	"Can we use the conditional in a where clause, comparing to nil."	self writeExampleEncycFeaturesOneMapOneInlineOneNil.	"Read data using each of the conditional mappings two cases' pseudovariables."	self assert: (session				read: GlorpEncyclopediaFeature				where: [:each | each featuredEntryID notNil]) size = 1.	self assert: (session				read: GlorpEncyclopediaFeature				where: [:each | each featuredEntryString notNil]) size = 1.	"Read data using the conditional;  check it is being expanded correctly in the where clause."	self assert: (session read: GlorpEncyclopediaFeature) size = 3.	self assert: (session				read: GlorpEncyclopediaFeature				where: [:each | each featured notNil]) size = 2		description: 'ConditionalMapping notNil have expanded to ORed conjunction of its mappings in #rewriteEquality'.	self assert: (session				read: GlorpEncyclopediaFeature				where: [:each | each featured isNil]) size = 1		description: 'ConditionalMapping isNil should have expanded to ANDed conjunction of its mappings in #rewriteEquality'.</body><body package="GlorpDBTests">testWriteAndRead	"Write both cases and neither for a conditional, then read all."	| readFeatures |	self writeExampleEncycFeaturesOneMapOneInlineOneNil.	readFeatures := session read: GlorpEncyclopediaFeature orderBy: [:each | each encyclopedia id].	self assert: (readFeatures collect: [:each | each featuredEntryText]) =		#('There are many different computer programming languages. The best one is Smalltalk.'	"one-one mapping"		nil					"no text in either mapping"		'Silence is Golden').		"short text held in the inline mapping"</body></methods><methods><class-id>Glorp.GlorpRecursionTest</class-id> <category>tests-cities</category><body package="GlorpDBTests">testReadCitiesGraphAvoidCycles	"This test retrieves the full path, the depth, and whether the path contains a cycle, from the recursion table.  It uses a WHERE clause to fetch only the paths leading to the target city.  It uses an ORDER BY clause to show the shortest paths first.  It uses the #prepend: function to switch the order of elements in the query block, since the block parser (MessageArchiver) requires a DatabaseField-related object to begin its parsing process;  without the #prepend:, the parser would see a string and switch to the Smalltalk parser."	| allNodes recursiveQuery startingCity endingCity recursionQuery startingDepth maxDepth varchar3 varcharM |	session platform canRecurse ifFalse: [^true].	"Retrieving boolean 'isCycle' to a SELECT field requires additional handling on some platforms.	(See removed method #testReadCitiesGraphWithProtectionRetrieve for retrieve-part handling.)"	session platform isPostgreSQLPlatform ifFalse: [^self].	"self skipUnless: session platform isPostgreSQLPlatform		description:  'GLORP cannot (yet) retrieve boolean to SELECT field on ', session platform class kind."	maxDepth := 15.	varchar3 := session platform varchar: 3.	varcharM := session platform varchar: maxDepth * 5.	"Holds maximum expected path, like (1)(2)(3)(4), assuming 3-digit city numbers."	self inTransactionDo: 		[self writeCitiesWithCycles.		session reset.		startingCity := session readOneOf: GlorpCity where: [:each | each name = 'Boston'].		endingCity := session readOneOf: GlorpCity where: [:each | each name = 'Los Angeles'].		startingDepth := 0 asGlorpExpression alias: #depth.		recursionQuery := Query read: GlorpCity where:			[:each | each depth &lt; maxDepth &amp; [(each recurse id = endingCity id) not] &amp; [each isCycle = false]].		recursiveQuery := (Query read: GlorpCity where: [:each | each id = startingCity id])			retrieveAll: (OrderedCollection new						add: [:each | each id];						add: [:each | each nextCities key];						add: [:each | each nextCities value];						add: [:each | startingDepth];						add: [:each | (each getConstant: '(' , startingCity id printString , ')' alias: #path) cast: varcharM];						add: [:each | each getConstant: false alias: #isCycle];						asArray)			thenFollow: #nextCities			recursiveQuery: recursionQuery			retrievingAll: (OrderedCollection new		"each=&gt;recursion table,  recurse=&gt;GlorpCity table."						add: [:each | each recurse id];						add: [:each | each recurse nextCities key];						add: [:each | each nextCitiesvalue + each recurse nextCities value];						add: [:each | each depth + 1 cast: Integer];						add: [:each | each path , '(' , (each recurse id cast: varchar3) , ')' cast: varcharM];						add: [:each | each path like: (((each recurse id cast: varchar3) prepend: '%(') , ')%' cast: varcharM)];						asArray)			intersect: ((Query read: GlorpCity) 	"each is this query, recursed=&gt;recursion table."						retrieveAll: (OrderedCollection new							add: [:each | each recursed id];							add: [:each | each recursed nextCitieskey];							add: [:each | each recursed nextCitiesvalue];							add: [:each | each recursed depth];							add: [:each | each recursed path];							add: [:each | each recursed isCycle];							asArray);						orderBy: [:each | each recursed nextCitiesvalue];						whereClause: [:each | each recursed nextCitieskey = endingCity id]).		allNodes := session execute: recursiveQuery.		self assert: allNodes notEmpty.		allNodes do: [:node | self assert: (node at: 2) = endingCity id]].</body><body package="GlorpDBTests">testReadCitiesGraphKeysAndValuesSimple	"Follow the graph, summing the distance traveled, incrementing depth,  appending to path and identifying cycles.  Records cycles, and stops at destination city, or depth&gt;11, or when in a cycle."	| allNodes recursiveQuery startingCity recursionQuery endingCity |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeCitiesNoCycles.		session reset.		startingCity := session readOneOf: GlorpCity where: [:each| each name = 'Boston'].		endingCity := session readOneOf: GlorpCity where: [:each| each name = 'Los Angeles'].		recursionQuery := Query read: GlorpCity where:			[:each |(each recurse id = endingCity id) not].		recursiveQuery := 			(Query read: GlorpCity where: [:each | each id = startingCity id])				retrieveAll:					(OrderedCollection new						add: [:each| each id];						add: [:each| each nextCities key];						add: [:each| each nextCities value];						asArray)				thenFollow: #nextCities				recursiveQuery: recursionQuery				retrievingAll: 		"each=&gt;recursion table,  recurse=&gt;GlorpCity table."					(OrderedCollection new						add: [:each | each recurse id];						add: [:each | each recurse nextCities key];						add: [:each | each nextCitiesvalue + each recurse nextCities value];						asArray)				intersect: ((Query read: GlorpCity) retrieveAll:	"recursed=&gt;recursion table."					(OrderedCollection new						add: [:each| each recursed id];						add: [:each| each recursed nextCitieskey];						add: [:each| each recursed nextCitiesvalue];						asArray)).		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 55].</body><body package="GlorpDBTests">testReadCitiesGraphKeysOnlySimple	"Follow the graph, summing the distance traveled, incrementing depth, appending to path and identifying cycles.  Records cycles, and stops at destination city, or depth&gt;11, or when in a cycle."	| allNodes recursiveQuery startingCity recursionQuery endingCity |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeCitiesNoCycles.		session reset.		startingCity := session readOneOf: GlorpCity where: [:each| each name = 'Boston'].		endingCity := session readOneOf: GlorpCity where: [:each| each name = 'Los Angeles'].		recursionQuery := Query read: GlorpCity where:			[:each |(each recurse id = endingCity id) not].			"[:each |(each recurse nextCities key = 11) not]."		recursiveQuery := 			(Query read: GlorpCity where: [:each | each id = startingCity id])				retrieveAll:					(OrderedCollection new						add: [:each| each id];						add: [:each| each nextCities key];						asArray)				thenFollow: #nextCities				recursiveQuery: recursionQuery				retrievingAll: 			"each=&gt;recursion table,  recurse=&gt;GlorpCity table."					(OrderedCollection new						add: [:each | each recurse id];						add: [:each | each recurse nextCities key];						asArray)				intersect: ((Query read: GlorpCity) retrieveAll:	"recursed=&gt;recursion table."					(OrderedCollection new						add: [:each| each recursed id];						add: [:each| each recursed nextCitieskey];						asArray)).		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 55].</body><body package="GlorpDBTests">testReadWriteCitiesNoCycles	| cities |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeCitiesNoCycles.		session reset.		cities := session read: GlorpCity.		self assert: cities size &gt; 10.		cities do:			[:city || links |			links := city nextCities yourSelf.			self deny: links isNil.			self assert: (links notEmpty or: [#(6 25 26 27 29) includes: city id])]].</body><body package="GlorpDBTests">testReadWriteCitiesWithCycles	| cities |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeCitiesWithCycles.		session reset.		cities := session read: GlorpCity.		self assert: cities size &gt; 10.		cities do:			[:city || links |			links := city nextCities yourSelf.			self deny: links isNil.			self deny: links isEmpty]].</body></methods><methods><class-id>Glorp.GlorpRecursionTest</class-id> <category>tests-nodes</category><body package="GlorpDBTests">testReadAncestors	"In a single round trip to the database, get all 3 ancestors of node 9 by recursively reading them.  In this test we retrieve the id as well as the parent id, for no reason except to test we can have additional fields in the recursion table."	| allNodes recursiveQuery |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery :=			(Query readOneOf: GlorpTreeNode where: [:each | each id = 9])				retrieveAll: (Array with: [:each | each parent id])				thenFollow: [:each | each parent]				recursivelyRetrievingAll: (Array with: [:each | each recurse parent id])				intersect: (Query read: GlorpTreeNode).		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 3.		self assert: (allNodes collect: [:each | each id]) asSet = (Set with: 4 with: 2 with: 1)].</body><body package="GlorpDBTests">testReadAncestorsOrdered	"In a single round trip to the database, get all 3 ancestors of node 9 by recursively reading them.  In this test we retrieve the id as well as the parent id, for no reason except to test we can have additional fields in the recursion table."	| allNodes recursiveQuery |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery :=			(Query readOneOf: GlorpTreeNode where: [:each | each id = 9])				retrieve: [:each | each parent id]				thenFollow: #parent				recursivelyRetrieving: [:each | each recurse parent id]				intersect: ((Query read: GlorpTreeNode) orderBy: [:each | each recursed parentid descending]; yourself).		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 3.		self assert: (allNodes collect: [:each | each id]) asArray = #(4 2 1)].</body><body package="GlorpDBTests">testReadAncestorsOrderedReverse	"The main purpose of this test is just to demonstrate the use of #start:retrieveAll:recursivelyRetrievingAll: in a cascade creating a recursive query."	| allNodes recursiveQuery mainQuery |	session platform canRecurse ifFalse: [^self].	self inTransactionDo: 		[self writeNodeWithDescendants.		session reset.		mainQuery := Query read: GlorpTreeNode.		mainQuery orderBy: [:each | each recursed parentid].		recursiveQuery := mainQuery asRecursiveQuery			mappingToCloseOver: #parent;			start: (Query readOneOf: GlorpTreeNode where: [:each | each id = 9])			retrieveAll: (Array with: [:each | each parent id])			recursivelyRetrievingAll: (Array with: [:each | each recurse parent id]);			yourself.		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 3.		self assert: (allNodes collect: [:each | each id]) asArray = #(1 2 4)].</body><body package="GlorpDBTests">testReadChildUnionAncestorsOrdered	"In a single round trip to the database, get all 3 ancestors of node 9 by recursively reading them, then union them to the child.  This test exposes issues in the initialization of recursive queries that need to be addressed so then can interact with others."	| allNodes recursiveQuery selfWithAllQuery |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery :=			(Query readOneOf: GlorpTreeNode where: [:each | each id = 9])				retrieve: [:each | each parent id]				thenFollow: #parent				recursivelyRetrieving: [:each | each recurse parent id]				intersect: (Query read: GlorpTreeNode).		selfWithAllQuery := recursiveQuery unionAll:			(Query read: GlorpTreeNode where: [:each | each id = 9]).		selfWithAllQuery orderBy: [:each | each id descending].		allNodes := session execute: selfWithAllQuery.		self assert: allNodes size = 4.		self assert: (allNodes collect: [:each | each id]) asArray = #(9 4 2 1)].</body><body package="GlorpDBTests">testReadDescendants	"In a single round trip to the database, get all 8 descendants of node 1 by recursively reading them.  Do not make any explicit use of the 'recursed' mapping in whereClause, ordering or grouping, thus testing that the intersecting Query will be joined to the recursion anyway."	| allNodes recursiveQuery |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery :=			(Query read: GlorpTreeNode where: [:each | each id = 1])				retrieveAll:					(Array with: [:each | each children id])				thenFollow: [:each | each children]				recursivelyRetrievingAll:					(Array with: [:each | each recurse children id])				intersect: (Query read: GlorpTreeNode).		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 8.		self assert: (allNodes collect: [:each | each id]) sort asArray = #(2 3 4 5 6 7 8 9)].</body><body package="GlorpDBTests">testReadDescendantsDepthOrdered	"Return depth as well as order by it, to show we can return constnats whose values are not the same in all rows.  In a single round trip to the database, get all 8 descendants of node 1 by recursively reading them.  Use the 'recursed' mapping to order the final query."	| allNodes recursiveQuery startingDepth |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		startingDepth := 1 asGlorpExpression alias: #depth.		recursiveQuery :=			(Query read: GlorpTreeNode where: [:each | each id = 1])				retrieveAll: (Array							with: [:each | each children id]							with: [:each | startingDepth])				thenFollow: #children				recursivelyRetrievingAll: (Array									with: [:each | each recurse children id]									with: [:each | each depth + 1 cast: Integer])	"SQLServer seems to need the cast - OR IS IT DB2?"				intersect: ((Query read: GlorpTreeNode)							orderBy: [:each | each recursed depth];							orderBy: [:each | each id];							retrieveAll: (Array with: [:each | each id] with: [:each | each recursed depth])							yourself).		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 8.		self assert: allNodes = #(#(2 1) #(3 1) #(4 2) #(5 2) #(6 2) #(7 2) #(8 2) #(9 3))].</body><body package="GlorpDBTests">testReadDescendantsIdOrdered	"In a single round trip to the database, get all 8 descendants of node 1 by recursively reading them.  Use the 'recursed' mapping to order the final query."	| allNodes recursiveQuery |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery :=			(Query read: GlorpTreeNode where: [:each | each id = 1])				retrieve: [:each | each children id]				thenFollow: #children				recursivelyRetrieving: [:each | each recurse children id]				intersect: ((Query read: GlorpTreeNode) orderBy: [:each | each recursed childrenid]; yourself).		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 8.		self assert: (allNodes collect: [:each | each id]) asArray = #(2 3 4 5 6 7 8 9)].</body><body package="GlorpDBTests">testReadParentUnionDescendantsWithRootId	"In a single round trip to the database, get all 8 descendants of node 1 by recursively reading them.  Have node 1's id in each row too.  Do not make any explicit use of the 'recursed' mapping in whereClause, ordering or grouping, thus testing that the intersecting Query will be joined to the recursion anyway."	| allNodes recursiveQuery selfWithAllQuery |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery :=			(Query read: GlorpTreeNode where: [:each | each id = 1])				retrieveAll:					(Array						with: [:each | each id]						with: [:each | each children id])				thenFollow: #children				recursivelyRetrievingAll:					(Array						with: [:each | each id]						with: [:each | each recurse children id])				intersect: (Query read: GlorpTreeNode where: [:each | each recursed id = 1]).		selfWithAllQuery := recursiveQuery unionAll:			(Query read: GlorpTreeNode where: [:each | each id = 1]).		allNodes := session execute: selfWithAllQuery.		self assert: allNodes size = 9.		self assert: (allNodes collect: [:each | each id]) sort asArray = #(1 2 3 4 5 6 7 8 9)].</body><body package="GlorpDBTests">testReadParentUnionDescendentsOrdered	"In a single round trip to the database, get all 8 descendants of node 1 by recursively reading them.  Use the 'recursed' mapping to order the final query."	| allNodes recursiveQuery selfWithAllQuery |	session platform canRecurse ifFalse: [^true].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery :=			(Query read: GlorpTreeNode where: [:each | each id = 1])				retrieveAll: (Array with: [:each | each children id])				thenFollow: #children				recursivelyRetrievingAll:					(Array with: [:each | each recurse children id])				intersect: (Query read: GlorpTreeNode).		selfWithAllQuery := recursiveQuery unionAll:			(Query read: GlorpTreeNode where: [:each | each id = 1]).		selfWithAllQuery orderBy: [:each | each id].		allNodes := session execute: selfWithAllQuery.		self assert: allNodes size = 9.		self assert: (allNodes collect: [:each | each id]) asArray = #(1 2 3 4 5 6 7 8 9)].</body><body package="GlorpDBTests">testReadRootAlsoFetchTreeRecursively	"Use this test to slim the API for also-fetching recursively.  Much of what we specify below could be calculated from fewer parameters, or moved to utility methods. "	| allNodes rootNode recursiveQuery intersectQuery |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeRootForNode: self writeNodeWithDescendants.		session reset.		self assert: (session cacheForClass: GlorpTreeNode) numberOfElements = 0.		intersectQuery := Query read: GlorpRootNode where: [:each | each id = 1].		recursiveQuery := intersectQuery			alsoFetch: [:each | each root];			orderBy: [:each | each root id];			orderBy: [:each | each root childrenRecursively id];			alsoFetchRecursively: [:each | each root childrenRecursively]				retrieveAll: (Array				with: [:each | each root id]				with: [:each | each root children id])			thenFollow: [:each | each children]			recursivelyRetrievingAll: (Array				with: [:each | each rootid]				with: [:each | each recurse children id]).		rootNode := (session execute: recursiveQuery) first.		self deny: rootNode root class == Proxy.		allNodes := OrderedCollection new.		(session cacheForClass: GlorpTreeNode) do:			[:each | allNodes add: each].		self assert: allNodes size = 9.		self assert: (allNodes collect: [:each | each id]) asArray sort = #(1 2 3 4 5 6 7 8 9)].</body><body package="GlorpDBTests">testReadRootAlsoFetchTreeRecursivelyDepthwise	"Use this test to slim the API for also-fetching recursively.  Much of what we specify below could be calculated from fewer parameters, or moved to utility methods. "	| allNodes rootNode recursiveQuery intersectQuery startingDepth |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeRootForNode: self writeNodeWithDescendants.		session reset.		self assert: (session cacheForClass: GlorpTreeNode) numberOfElements = 0.		startingDepth := 0 asGlorpExpression alias: #depth.		intersectQuery := Query read: GlorpRootNode where: [:each | each id = 1].		recursiveQuery := intersectQuery			alsoFetch: [:each | each root childrenRecursively parent];			alsoFetch: [:each | each root];			orderBy: [:each | each root id];			orderBy: [:each | each root childrenRecursively recursed depth];			alsoFetchRecursively: [:each | each root childrenRecursively]			retrieveAll: (Array				with: [:each | each root id]				with: [:each | each root children id]				with: [:each | startingDepth])			thenFollow: #children			recursivelyRetrievingAll: (Array				with: [:each | each rootid]				with: [:each | each recurse children id]				with: [:each | each depth + 1 cast: Integer]).		rootNode := (session execute: recursiveQuery) first.		self deny: rootNode root class == Proxy.		allNodes := OrderedCollection new.		(session cacheForClass: GlorpTreeNode) do:			[:each | allNodes add: each].		self assert: allNodes size = 9.		self assert: (allNodes collect: [:each | each id]) asArray sort = #(1 2 3 4 5 6 7 8 9)].		allNodes do: [:each | each id = 1 ifFalse: [self deny: each parent class == Proxy]].		allNodes do: [:each | self deny: each children class == Proxy].</body><body package="GlorpDBTests">testReadRootAlsoFetchTreeUsingRecursiveQuery	"Read the root node and alsoFetch its tree recursively.  Verify all 9 nodes are in the session cache.  If the relation did not use a linkTable, the whole tree would be explicitly constructed from the root;  as it is, we must fetch the parent explicitly to do this or exploit or ordering better: TBD."	| allNodes rootNode selfWithAllQuery |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeRootForNode: self writeNodeWithDescendants.		session reset.		self assert: (session cacheForClass: GlorpTreeNode) numberOfElements = 0.		selfWithAllQuery := self recursiveQueryFromRoot.		rootNode := (session execute: selfWithAllQuery) first.		self deny: rootNode root class == Proxy.		allNodes := OrderedCollection new.		(session cacheForClass: GlorpTreeNode) do:			[:each | allNodes add: each].		self assert: allNodes size = 9.		self assert: (allNodes collect: [:each | each id]) asArray sort = #(1 2 3 4 5 6 7 8 9)].		allNodes do: [:each | self assert: each parent class == Proxy].		allNodes do: [:each | self assert: each children class == Proxy].</body></methods><methods><class-id>Glorp.GlorpRecursionTest</class-id> <category>support-cities</category><body package="GlorpDBTests">cities	"GlorpRecursionTest new cities"	| cities |	cities := Dictionary new.	#( 'Boston' 'New York' 'Washington' 'Cinncinati' 'Chicago' 'St. Louis' 'Kansas City' 'Oklahoma City' 'Denver' 'Houston' 'Dallas' 'Phoenix' 'New Orleans'	'Atlanta' 'Seattle' 'Portland' 'Miami'  'Baltimore' 'Nashville' 'Salt Lake City' 'Portland' 'Elko' 'Reno' 'San Francisco' 'Los Angeles' 'Dallas' 'Seattle' 'Atlanta' 'Miami')	inject: 1 into: [:nextId :name| 		cities at: name put:  ((GlorpCity new) name: name; id: nextId).		nextId+1].	^cities</body><body package="GlorpDBTests">citiesGraphWithCycles	"GlorpRecursionTest new citiesGraphWithCycles	Add a backwards link for every forward link."	| graphNodes|	graphNodes := self citiesGraphWithNoCycles.	graphNodes copy do: [:node| graphNodes add: ((node nextCity) addNextCity: (node city) distance: (node distance)) ].	^graphNodes</body><body package="GlorpDBTests">citiesGraphWithNoCycles	"GlorpRecursionTest new citiesGraphWithNoCycles"		| cities graphNodes|	cities := self cities.	graphNodes := OrderedCollection new.	graphNodes add: ((cities at: 'Boston') addNextCity: (cities at: 'New York') distance: 240).	graphNodes add: ((cities at: 'Boston') addNextCity: (cities at: 'Chicago') distance: 1000).	graphNodes add: ((cities at: 'New York') addNextCity: (cities at: 'Chicago') distance: 800).	graphNodes add: ((cities at: 'New York') addNextCity: (cities at: 'Washington') distance: 200).	graphNodes add: ((cities at: 'Washington') addNextCity: (cities at: 'Atlanta') distance: 650).	graphNodes add: ((cities at: 'Atlanta') addNextCity: (cities at: 'Miami') distance: 650).	graphNodes add: ((cities at: 'Atlanta') addNextCity: (cities at: 'Dallas') distance: 750).	graphNodes add: ((cities at: 'Chicago') addNextCity: (cities at: 'St. Louis') distance: 350).	graphNodes add: ((cities at: 'St. Louis') addNextCity: (cities at: 'Kansas City') distance: 250).	graphNodes add: ((cities at: 'Kansas City') addNextCity: (cities at: 'Oklahoma City') distance: 320).	graphNodes add: ((cities at: 'Kansas City') addNextCity: (cities at: 'Denver') distance: 600).	graphNodes add: ((cities at: 'Oklahoma City') addNextCity: (cities at: 'Denver') distance: 600).	graphNodes add: ((cities at: 'Oklahoma City') addNextCity: (cities at: 'Dallas') distance: 200).	graphNodes add: ((cities at: 'Denver') addNextCity: (cities at: 'Salt Lake City') distance: 1000).	graphNodes add: ((cities at: 'Salt Lake City') addNextCity: (cities at: 'Elko') distance: 250).	graphNodes add: ((cities at: 'Salt Lake City') addNextCity: (cities at: 'Portland') distance: 800).	graphNodes add: ((cities at: 'Elko') addNextCity: (cities at: 'Reno') distance: 250).	graphNodes add: ((cities at: 'Reno') addNextCity: (cities at: 'San Francisco') distance: 220).	graphNodes add: ((cities at: 'San Francisco') addNextCity: (cities at: 'Los Angeles') distance: 390).	graphNodes add: ((cities at: 'San Francisco') addNextCity: (cities at: 'Portland') distance: 650).	graphNodes add: ((cities at: 'Portland') addNextCity: (cities at: 'Seattle') distance: 180).	^graphNodes</body><body package="GlorpDBTests">writeCitiesNoCycles	| graphNodes  |	graphNodes := self citiesGraphWithNoCycles.	session inUnitOfWorkDo: 			[graphNodes do: [:node | session register: node]]</body><body package="GlorpDBTests">writeCitiesWithCycles	| graphNodes  |	graphNodes := self citiesGraphWithCycles.	session inUnitOfWorkDo: 			[graphNodes do: [:node | session register: node]]</body></methods><methods><class-id>Glorp.GlorpRecursionTest</class-id> <category>support-nodes</category><body package="GlorpDBTests">recursiveQueryFromRoot	"Hardcodedly-construct the recursive query."	| recursiveQuery initialQuery intersectQuery |	initialQuery := Query read: GlorpRootNode where: [:each | each id = 1].	intersectQuery := Query read: GlorpRootNode where: [:each | each id = 1].	"this where probably needless"	intersectQuery alsoFetch: [:each | each root].	intersectQuery alsoFetch: [:each | each root childrenRecursively].	recursiveQuery := initialQuery		retrieveAll:			(Array				with: [:each | each root id]				with: [:each | each root children id])		thenFollow: #children		recursivelyRetrievingAll: (Array				with: [:each | each rootid]				with: [:each | each recurse children id])		intersect: intersectQuery.	recursiveQuery fetchBaseExpression: [:each | each root].	intersectQuery orderBy: [:each | each root childrenRecursively id].	^recursiveQuery</body><body package="GlorpDBTests">writeNodeWithChildren	| node1 node2 node2a |	node1 := GlorpTreeNode new id: 1.	node2 := GlorpTreeNode new id: 2.	node2a := GlorpTreeNode new id: 3.	node1 addChild: node2.	node1 addChild: node2a.	session inUnitOfWorkDo: [session register: node1].</body><body package="GlorpDBTests">writeNodeWithDescendants	| node1 node2a node2b node3aa node3ab node3ac node3ba node3bb node4aaa |	node4aaa:= GlorpTreeNode new id: 9.	node3bb := GlorpTreeNode new id: 8.	node3ba := GlorpTreeNode new id: 7.	node3ac := GlorpTreeNode new id: 6.	node3ab := GlorpTreeNode new id: 5.	(node3aa := GlorpTreeNode new id: 4)		addChild: node4aaa.	(node2b := GlorpTreeNode new id: 3)		addChild: node3ba; addChild: node3bb.	(node2a := GlorpTreeNode new id: 2)		addChild: node3aa; addChild: node3ab; addChild: node3ac.	(node1 := GlorpTreeNode new id: 1)		addChild: node2a; addChild: node2b.	session inUnitOfWorkDo: [session register: node1].	^node1</body><body package="GlorpDBTests">writeRootForNode: aGlorpTreeNode	| rootNode |	rootNode := GlorpRootNode new		id: aGlorpTreeNode id;	"just a random way of getting an id"		root: aGlorpTreeNode;		yourself.	session inUnitOfWorkDo: [session register: rootNode].	^rootNode</body></methods><methods><class-id>Glorp.GlorpRecursionTest</class-id> <category>tests-nodes-unrecursive</category><body package="GlorpDBTests">testReadRoot	"Get the root and verify it has a proxy to the root TreeNode whose iterated children comprise the whole tree."	| allNodes outerQuery rootNode index |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeRootForNode: self writeNodeWithDescendants.		session reset.		"recursiveQuery :=			(Query read: GlorpTreeNode where: [:each | each id = 1])				retrieveAll: (Array with: [:each | each children id])				thenFollow: #children				recursivelyRetrievingAll:					(Array with: [:each | each recurse children id])				intersect: (Query read: GlorpTreeNode).		selfWithAllQuery := recursiveQuery unionAll:			(Query readOneOf: GlorpTreeNode where: [:each | each id = 1]).		selfWithAllQuery orderBy: [:each | each id]."		outerQuery := Query readOneOf: GlorpRootNode where: [:each | each id = 1].		rootNode := session execute: outerQuery.		self assert: rootNode root class == Proxy.		self deny: rootNode root isInstantiated.		allNodes := OrderedCollection with: rootNode root yourSelf.		index := 1.		[index  &gt; allNodes size] whileFalse:			[allNodes addAll: (allNodes at: index) children.			index := index + 1].		self assert: allNodes size = 9.		self assert: (allNodes collect: [:each | each id]) asArray sort = #(1 2 3 4 5 6 7 8 9)].</body><body package="GlorpDBTests">testReadRootAlsoFetchTree	"Read the root node, alsoFetch its root.  Verify it has no proxy to the root TreeNode but that that node's children have not been read."	| outerQuery rootNode |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeRootForNode: self writeNodeWithDescendants.		session reset.		outerQuery := Query readOneOf: GlorpRootNode where: [:each | each id = 1].		outerQuery := outerQuery alsoFetch: #root.		rootNode := session execute: outerQuery.		self deny: rootNode root class == Proxy.		self assert: rootNode root children class == Proxy.		self deny: rootNode root children isInstantiated].</body></methods><methods><class-id>Glorp.GlorpRecursionTest</class-id> <category>test-aliasing</category><body package="GlorpDBTests">testReadChildUnionDecrementIdBlockDefined	"Within the recursion, define a temporary mapping from a node to a node whose id is one less.  Use it to recurse back to node1 from node9.  This exercise (although pointless in itself) tests both relationally-defined join sources and, more importantly, temporary relationships defined within a recursion."	| allNodes recursiveQuery selfUnionRecurseQuery |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery := (Query read: GlorpTreeNode where: [:each | each id = 9])			retrieve: [:each | each decrementIdNode id]			defineThenFollow: [:anotherDescriptor |				anotherDescriptor oneToOneMapping					attributeName: #decrementIdNode;					beForPseudoVariable;					referenceClass: GlorpTreeNode;					join: (Join							from: ([:each | (((each getTable: 'TREE_NODE') getField: 'ID') - 1) alias: 'DefaultAlias']													asGlorpExpressionForDescriptor: anotherDescriptor)							to: (anotherDescriptor table fieldNamed: 'ID'))]			recursivelyRetrieving: [:each | each recurse decrementIdNode id]			intersect: (Query read: GlorpTreeNode).		selfUnionRecurseQuery := recursiveQuery unionAll:			(Query read: GlorpTreeNode where: [:each | each id = 9]).		selfUnionRecurseQuery orderBy: [:each | each id descending].		allNodes := session execute: selfUnionRecurseQuery.		self assert: allNodes size = 9.		self assert: (allNodes collect: [:each | each id]) asArray = #(9 8 7 6 5 4 3 2 1)].</body><body package="GlorpDBTests">testReadCitiesViaAliasedPrefix	"This test retrieves the full path, the depth, and whether the path contains a cycle, from the recursion table.  It uses a WHERE clause to fetch only the paths leading to the target city.  It uses an ORDER BY clause to show the shortest paths first.  It uses the #prepend: function to switch the order of elements in the query block, since the block parser (MessageArchiver) requires a DatabaseField-related object to begin its parsing process;  without the #prepend:, the parser would see a string and switch to the Smalltalk parser."	| allNodes recursiveQuery startingCity recursionQuery startingDepth maxDepth |	session platform canRecurse ifFalse: [^true].	maxDepth := 5.	self inTransactionDo: 		[self writeCitiesWithCycles.		session reset.		startingCity := session readOneOf: GlorpCity where: [:each | each name = 'Boston'].		startingDepth := 0 asGlorpExpression alias: #depth.		recursionQuery := Query read: GlorpCity where: [:each | each depth &lt; maxDepth].		recursiveQuery := (Query read: GlorpCity where: [:each | each id = startingCity id])			retrieveAll: (Array						with: [:each | each wordLengthCityId id]						with: [:each | startingDepth])			defineThenFollow: [:anotherDescriptor |				anotherDescriptor oneToOneMapping					attributeName: #wordLengthCityId;					beForPseudoVariable;					referenceClass: GlorpCity;					join: (Join							from: ([:each | (((each getTable: 'CITIES') getField: 'name') length) alias: 'nameLength']												asGlorpExpressionForDescriptor: anotherDescriptor)							to: (anotherDescriptor table fieldNamed: 'id'))]			recursiveQuery: recursionQuery			retrievingAll: (Array						with: [:each | each recurse wordLengthCityId id]						with: [:each | each depth + 1 cast: Integer])			intersect: ((Query read: GlorpCity)						orderBy: [:each | each recursed depth];						whereClause: [:each | each recursed wordLengthCityIdid &lt; 26]).		allNodes := session execute: recursiveQuery.		(2 to: allNodes size)			inject: allNodes first			into: [:prev :index || next | next := allNodes at: index.				self assert: prev name size = next id.				next].		self assert: allNodes size = 6].</body><body package="GlorpDBTests">testReadDecrementIdBlockDefined	"Within the recursion, define a temporary mapping from a node to a node whose id is one less.  Use it to recurse back to node1 from node9.  This exercise (although pointless in itself) tests both relationally-defined join sources and, more importantly, temporary relationships defined within a recursion."	| allNodes recursiveQuery |	session platform canRecurse ifFalse: [^self].	self inTransactionDo:		[self writeNodeWithDescendants.		session reset.		recursiveQuery := (Query readOneOf: GlorpTreeNode where: [:each | each id = 9])			retrieve: [:each | each decrementIdNode id]			defineThenFollow: [:anotherDescriptor | 				anotherDescriptor oneToOneMapping					attributeName: #decrementIdNode;					beForPseudoVariable;					referenceClass: GlorpTreeNode;					join: (Join							from: ([:each | (((each getTable: 'TREE_NODE') getField: 'ID') - 1) alias: 'DefaultAlias']												asGlorpExpressionForDescriptor: anotherDescriptor)							to: (anotherDescriptor table fieldNamed: 'ID'))]			recursivelyRetrieving: [:each | each recurse decrementIdNode id]			intersect: (Query read: GlorpTreeNode).		recursiveQuery orderBy: [:each | each id descending].		allNodes := session execute: recursiveQuery.		self assert: allNodes size = 8.		self assert: (allNodes collect: [:each | each id]) asArray = #(8 7 6 5 4 3 2 1)].</body></methods><methods><class-id>Glorp.GlorpEmbeddedMappingDBTest</class-id> <category>support</category><body package="GlorpDBTests">setUp	super setUp.	session beginTransaction.	self writeAgents.	session reset.</body><body package="GlorpDBTests">tearDown	session rollbackTransaction.	super tearDown.</body><body package="GlorpDBTests">writeAgents	| agent1 agent2 agent3 |	agent1 := GlorpTravelAgent new id: 1; name: 'Agent One'.	agent1 agency: (GlorpTravelAgency new name: 'Agency One').	agent2 := GlorpTravelAgent new id: 2; name: 'Agent Two'.	agent2 agency: agent1 agency.	agent3 := GlorpTravelAgent new id: 3; name: 'Agent Three'.	agent3 agency: (GlorpTravelAgency new name: 'Agency Two').	session modify: (Array with: agent1 with: agent2 with: agent3) in: [].</body></methods><methods><class-id>Glorp.GlorpEmbeddedMappingDBTest</class-id> <category>tests</category><body package="GlorpDBTests">testModifyAgents	| agents |	agents := session read: GlorpTravelAgent orderBy: #id.	session modify: agents in: [		agents first name: 'Something Else'.		(agents at: 2) name: 'something else again'].	session reset.	agents := session read: GlorpTravelAgent orderBy: #id.	self assert: agents size = 3.	self assert: agents first agency yourSelf = (agents at: 2) agency yourSelf.	self deny: agents first agency yourSelf == (agents at: 2) agency yourSelf.	self deny: agents first agency yourSelf = agents last agency yourSelf.	self assert: agents first name = 'Something Else'.	self assert: (agents at: 2) name = 'something else again'.</body><body package="GlorpDBTests">testModifyAgentsReadOnlyAgency	"Test that if the agency mappings are all read-only, that we don't cause an error by trying to generate entries in the row map for its primary keys."	(session system descriptorFor: GlorpTravelAgency) mappings do: [:each | each beReadOnly].	[self testModifyAgents] ensure: [		(session system descriptorFor: GlorpTravelAgency) mappings do: [:each | each readOnly: false]].</body><body package="GlorpDBTests">testReadAgents	| agents |	agents := session read: GlorpTravelAgent orderBy: #id.	self assert: agents size = 3.	self assert: agents first agency yourSelf = (agents at: 2) agency yourSelf.	self deny: agents first agency yourSelf == (agents at: 2) agency yourSelf.	self deny: agents first agency yourSelf = agents last agency yourSelf.</body></methods><methods><class-id>Glorp.GlorpAirline</class-id> <category>accessing</category><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anInteger	id := anInteger</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: aString	name := aString</body></methods><methods><class-id>Glorp.GlorpAirline class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		id: 73;		name: 'Air Canada'.</body><body package="GlorpTestModels">example2	^self new		id: 74;		name: 'Lufthansa'.</body></methods><methods><class-id>Glorp.GlorpReadingDifferentCollectionsThroughMappingsWithClassModelsTest</class-id> <category>setup</category><body package="GlorpDBTests">descriptorClass	^GlorpCollectionTypesWithClassModelsDescriptorSystem.</body></methods><methods><class-id>Glorp.GlorpTravelAgent</class-id> <category>accessing</category><body package="GlorpTestModels">agency	^agency</body><body package="GlorpTestModels">agency: anObject	agency := anObject</body><body package="GlorpTestModels">id	^id</body><body package="GlorpTestModels">id: anObject	id := anObject</body><body package="GlorpTestModels">name	^name</body><body package="GlorpTestModels">name: anObject	name := anObject</body></methods><methods><class-id>Glorp.GlorpDirectMappingDBTest</class-id> <category>support</category><body package="GlorpDBTests">testUpdateWithDefaultValue	"Check that default values don't revert if we update the object in some other way.  (This test does not in fact error in Glorp 7.7 - 69 and earlier, so needs revision.)"	self inTransactionDo:		[| thing |		session transact: [thing := DefaultableThing new id: 1].		session reset.		thing := session readOneOf: DefaultableThing.		self assert: thing integer = 4.		session modify: thing in: [thing integer: 7].		session reset.		thing := session readOneOf: DefaultableThing.		session modify: thing in: [thing boolean: true].		self assert: thing integer = 7].</body><body package="GlorpDBTests">testWriteWithDefaultValue	| rawDBResult field converter dbValue raw |	self inTransactionDo: [		| thing |		session transact: [thing := DefaultableThing new id: 1].		session reset.		thing := session readOneOf: DefaultableThing.		self assert: thing boolean = false.		field := (system tableNamed: 'DEFAULTABLE_THING') fieldNamed: 'MY_BOOL'.		converter := field converterForStType: Boolean.		dbValue := converter convert: false toDatabaseRepresentationAs: field type.		rawDBResult := session accessor executeSQLString: 'select MY_BOOL from DEFAULTABLE_THING'.		"The conversion back might get done by us, or might get done by the EXDI layer, Accomodate either possibility as long as it comes out to something equivalent to what we thought it ought to be."		raw := rawDBResult first first.		self assert: (raw = dbValue or: [raw = false]).		self assert: thing integer = 4].</body><body package="GlorpDBTests">writeAddress	| addressRow |	addressRow := session system exampleAddressRow.	session writeRow: addressRow.</body><body package="GlorpDBTests">writeHomefulPerson	| personRow |	personRow := session system examplePersonRow1.	session writeRow: personRow.	personId := personRow atFieldNamed: 'ID'.</body><body package="GlorpDBTests">writeHomelessPerson	| personRow |	personRow := session system examplePersonRow2.	session writeRow: personRow.	personId := personRow atFieldNamed: 'ID'.</body><body package="GlorpDBTests">writePersonWithEmailAddresses	| personRow emailAddress1Row emailAddress2Row |	personRow := session system examplePersonRow1.	personId := personRow atFieldNamed: 'ID'.	session writeRow: personRow.	emailAddress1Row := session system exampleEmailAddressRow1.	emailAddress2Row := session system exampleEmailAddressRow2.	emailAddress1Row at: (emailAddress1Row table fieldNamed: 'ID').	emailAddress2Row at: (emailAddress2Row table fieldNamed: 'ID').	session writeRow: emailAddress1Row.	session writeRow: emailAddress2Row.</body></methods><methods><class-id>Glorp.GlorpDirectMappingDBTest</class-id> <category>tests</category><body package="GlorpDBTests">readPerson	| results query |	query := Query		read: GlorpPerson		where: [:pers | pers id = personId].	results := query executeIn: session.	self assert: results size = 1.	person := results first.</body><body package="GlorpDBTests">testMappingToSubselect	| personDescriptor people |	[session beginTransaction.	self writeAddress.	self writeHomelessPerson.	self writePersonWithEmailAddresses.	personDescriptor := system descriptorFor: GlorpPerson.	(personDescriptor newMapping: DirectMapping)		beReadOnly;		type: Boolean;		from: #hasEmail 		to: [:each | each emailAddresses notEmpty].	people := session read: GlorpPerson orderBy: #id.	self assert: people first hasEmail.	self deny: people last hasEmail.	self assert: people first emailAddresses notEmpty.	self assert: people last emailAddresses isEmpty.	 ]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testReadWithDirectFieldReference	| peopleWithAddresses peopleWithoutAddresses addressIdField |	[session beginTransaction.	self writeAddress.	self writeHomelessPerson.	self writeHomefulPerson.	addressIdField := (session system tableNamed: 'PERSON') fieldNamed: 'ADDRESS_ID'.	peopleWithAddresses := session read: GlorpPerson where: [:each | (each getField: addressIdField) notNIL].	peopleWithoutAddresses := session read: GlorpPerson where: [:each | (each getField: addressIdField) isNIL].	self assert: peopleWithAddresses size = 1.	self assert: peopleWithoutAddresses size = 1.	self assert: peopleWithAddresses first id = 3.	self assert: peopleWithoutAddresses first id = 4.	 ]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testReadWithPseudoVariableMapping	| peopleWithAddresses peopleWithoutAddresses |	[session beginTransaction.	self writeAddress.	self writeHomelessPerson.	self writeHomefulPerson.	peopleWithAddresses := session read: GlorpPerson where: [:each | each addressId notNIL].	peopleWithoutAddresses := session read: GlorpPerson where: [:each | each addressId isNIL].	self assert: peopleWithAddresses size = 1.	self assert: peopleWithoutAddresses size = 1.	self assert: peopleWithAddresses first id = 3.	self assert: peopleWithoutAddresses first id = 4.]		ensure: [session rollbackTransaction].</body><body package="GlorpDBTests">testUpdate	|newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson example1.		personId := newPerson id.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		session inUnitOfWorkDo: [			session register: person.			person name: 'something else'].		session reset.		self readPerson.		self assert: person id = newPerson id.		self assert: person name = 'something else'].</body></methods><methods><class-id>Glorp.GlorpAddress</class-id> <category>printing</category><body package="GlorpTestModels">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(', id printString, ',', street printString, ',' , number printString, ')'.</body></methods><methods><class-id>Glorp.GlorpAddress</class-id> <category>accessing</category><body package="GlorpTestModels">id	"Private - Answer the value of the receiver's ''id'' instance variable."	^id</body><body package="GlorpTestModels">id: anObject	"Private - Set the value of the receiver's ''id'' instance variable to the argument, anObject."	id := anObject</body><body package="GlorpTestModels">number	"Private - Answer the value of the receiver's ''number'' instance variable."	^number</body><body package="GlorpTestModels">number: anObject	"Private - Set the value of the receiver's ''number'' instance variable to the argument, anObject."	number := anObject</body><body package="GlorpTestModels">street	"Private - Answer the value of the receiver's ''street'' instance variable."	^street</body><body package="GlorpTestModels">street: anObject	"Private - Set the value of the receiver's ''street'' instance variable to the argument, anObject."	street := anObject</body></methods><methods><class-id>Glorp.GlorpAddress</class-id> <category>notification</category><body package="GlorpTestModels">glorpNoticeOfExpiryIn: aSession</body></methods><methods><class-id>Glorp.GlorpAddress class</class-id> <category>examples</category><body package="GlorpTestModels">example1	^self new		id: 1;		street: 'West 47th Ave';		number: '2042'.</body><body package="GlorpTestModels">example1WithChangedAddress	^self new		id: 1;		street: 'Garden of the Gods';		number: '99999'.</body><body package="GlorpTestModels">example2	^self new		id: 2;		street: 'Nowhere';		number: '1000'.</body></methods><methods><class-id>Glorp.GlorpAddress class</class-id> <category>glorp setup</category><body package="GlorpTestModels">glorpSetupClassModel: aClassModel forSystem: aDescriptorSystem 	aClassModel newAttributeNamed: #id.	aClassModel newAttributeNamed: #street.	aClassModel newAttributeNamed: #number.</body><body package="GlorpTestModels">glorpSetupDescriptor: aDescriptor forSystem: aDescriptorSystem 	| table |	table := aDescriptorSystem tableNamed: 'GR_ADDRESS'.	aDescriptor table: table.	aDescriptor		addMapping: (DirectMapping from: #id to: (table fieldNamed: 'ID'));		addMapping: (DirectMapping from: #street to: (table fieldNamed: 'STREET'));		addMapping: (DirectMapping from: #number to: (table fieldNamed: 'HOUSE_NUM'))</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>support</category><body package="GlorpDBTests">checkEmailAddresses: emailAddresses	| sorted numberOfAddresses |	numberOfAddresses := (emailId1 isNil ifTrue: [0] ifFalse: [1]) + (emailId2 isNil ifTrue: [0] ifFalse: [1]) + (emailId3 isNil ifTrue: [0] ifFalse: [1]).	self assert: emailAddresses size = numberOfAddresses.	sorted := emailAddresses asSortedCollection: [:a :b | a id &lt;= b id].	emailId1 isNil ifFalse: [self assert: sorted first id = emailId1].	emailId2 isNil ifFalse: [self assert: (sorted at: 2) id = emailId2].	emailId3 isNil ifFalse: [self assert: sorted last id = emailId3].	self assert: (emailAddresses collect: [:each | each id]) asSet size = emailAddresses size.</body><body package="GlorpDBTests">checkNumberOfEmailAddressesInDB: numberOfAddresses	| databaseAddresses |	databaseAddresses := session accessor executeSQLString: 'SELECT * FROM EMAIL_ADDRESS'.	self assert: databaseAddresses size = numberOfAddresses.</body><body package="GlorpDBTests">inUnitOfWorkDo: aBlock initializeWith: initBlock	"Set up a bunch of the normal data, read the objects, then run the block in a unit of work"	initBlock value.	session beginUnitOfWork.	self readPerson.	aBlock value.	session commitUnitOfWork.	session reset.</body><body package="GlorpDBTests">readPerson	| results query |	query := Query		read: GlorpPerson		where: [:pers | pers id = personId].	results := query executeIn: session.	self assert: results size = 1.	person := results first.</body><body package="GlorpDBTests">tearDown	((session system descriptorFor: GlorpPerson) mappingForAttributeNamed: #emailAddresses) isExclusive: false.	super tearDown.</body><body package="GlorpDBTests">writePersonWithEmailAddresses	| addressRow personRow emailAddress1Row emailAddress2Row |	addressRow := session system exampleAddressRow.	session writeRow: addressRow.	personRow := session system examplePersonRow1.	personId := personRow atFieldNamed: 'ID'.	session writeRow: personRow.	emailAddress1Row := session system exampleEmailAddressRow1.	emailAddress2Row := session system exampleEmailAddressRow2.	emailId1 := emailAddress1Row at: (emailAddress1Row table fieldNamed: 'ID').	emailId2 := emailAddress2Row at: (emailAddress2Row table fieldNamed: 'ID').	session writeRow: emailAddress1Row.	session writeRow: emailAddress2Row.</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests-read</category><body package="GlorpDBTests">testReadActionWithCollection	| collection |	self		inTransactionDo:			[collection := OrderedCollection new.			self writePersonWithEmailAddresses.			((session system descriptorFor: GlorpPerson)				mappingForAttributeNamed: #emailAddresses)				proxyAction:					[:owner :object | object do: [:each | collection add: owner -&gt; each]].			person := session readOneOf: GlorpPerson.			person emailAddresses yourSelf.			self assert: collection size = 2.			self assert: collection first = (person -&gt; person emailAddresses first).			self assert: collection last = (person -&gt; person emailAddresses last)].</body><body package="GlorpDBTests">testReadJustTheEmailAddressNotThePersonAndWriteBackWithChanges	| addresses addressRows |	"We won't have the person object to set a value for the PERSON_ID field. Ensure that we don't write a null for that field, or otherwise modify things."	self inTransactionDo: [			self writePersonWithEmailAddresses.		session beginUnitOfWork.		addresses := session read: GlorpEmailAddress.		addresses do: [:each | each host: 'bar.org'].		self assert: ((session privateGetCache cacheForClass: GlorpPerson) at: 3 ifAbsent: [nil]) isNil.		session commitUnitOfWork.		addressRows := session accessor executeSQLString: 'SELECT PERSON_ID, HOST_NAME from EMAIL_ADDRESS'.		self assert: addressRows size = 2.		addressRows do: [:each | 			self assert: (each atIndex: 1) = 3.			self assert: (each atIndex: 2) = 'bar.org'].].</body><body package="GlorpDBTests">testReadJustTheEmailAddressNotThePersonAndWriteBackWithNoChanges	| addresses addressRows |	"We won't have the person object to set a value for the PERSON_ID field. Ensure that we don't write a null for that field, or otherwise modify things."	self inTransactionDo: [			self writePersonWithEmailAddresses.		session beginUnitOfWork.		addresses := session read: GlorpEmailAddress.		self assert: ((session privateGetCache cacheForClass: GlorpPerson) at: 3 ifAbsent: [nil]) isNil.		session commitUnitOfWork.		addressRows := session accessor executeSQLString: 'SELECT PERSON_ID from EMAIL_ADDRESS'.		self assert: addressRows size = 2.		addressRows do: [:each | self assert: (each atIndex: 1) = 3].].</body><body package="GlorpDBTests">testReadPersonAndAddEmailAddress	| |	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [person emailAddresses add: (GlorpEmailAddress new id: 99876; user: 'postmaster'; host: 'foo.com')]				initializeWith: [self writePersonWithEmailAddresses].			emailId3 := 99876.			self readPerson.			self checkEmailAddresses: person emailAddresses].</body><body package="GlorpDBTests">testReadPersonAndAddEmailAddressProxy	| address |	self		inTransactionDo:			[self				inUnitOfWorkDo:					[| query |					query := Query						readOneOf: GlorpEmailAddress						where: [:each | each id = 99876].					query proxyType: Proxy.					address := session execute: query.					address yourself.					person emailAddresses add: address.					self assert: person emailAddresses last class == Proxy]				initializeWith:					[self writePersonWithEmailAddresses.					session						transact:							[(GlorpEmailAddress new)								id: 99876;								user: 'postmaster';								host: 'foo.com'].						session reset].			emailId3 := 99876.			self readPerson.			self checkEmailAddresses: person emailAddresses].</body><body package="GlorpDBTests">testReadPersonAndAddEmailAddressTwice	| personRow addressRow |	self		inTransactionDo:			[self				inUnitOfWorkDo:					[person emailAddresses						add:							((GlorpEmailAddress new)								id: 99876;								user: 'postmaster';								host: 'foo.com')]				initializeWith:					[addressRow := session system exampleAddressRow.					session writeRow: addressRow.					personRow := session system examplePersonRow1.					personId := personRow atFieldNamed: 'ID'.					session writeRow: personRow].			self				inUnitOfWorkDo:					[person emailAddresses						add:							((GlorpEmailAddress new)								id: 99991;								user: 'someone';								host: 'foo.com')]				initializeWith: [].			emailId1 := 99876.			emailId2 := 99991.			self readPerson.			self checkEmailAddresses: person emailAddresses].</body><body package="GlorpDBTests">testReadPersonAndDeleteEmailAddress	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [					session delete: person emailAddresses last. 					person emailAddresses removeLast. ]				initializeWith: [self writePersonWithEmailAddresses].			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 1].</body><body package="GlorpDBTests">testReadPersonAndRemoveEmailAddress	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [person emailAddresses removeLast]				initializeWith: [self writePersonWithEmailAddresses].			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests">testReadPersonAndReplaceEmailAddressesWithDifferent	| |	self		inTransactionDo:			[self 				inUnitOfWorkDo: [					person emailAddresses: (Array with: (GlorpEmailAddress new id: 99876; user: 'postmaster'; host: 'foo.com')) ]				initializeWith: [self writePersonWithEmailAddresses].			emailId1 := 99876.			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 3].</body><body package="GlorpDBTests">testReadPersonAndReplaceEmailAddressesWithRemoval	| |	self		inTransactionDo:			[self 				inUnitOfWorkDo: [					person emailAddresses: (Array with: person emailAddresses first) ]				initializeWith: [self writePersonWithEmailAddresses].			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests">testReadPersonAndReplaceInstantiatedEmailAddressesWithEmpty	| |	self		inTransactionDo:			[self 				inUnitOfWorkDo: [					person emailAddresses yourSelf. 					person emailAddresses: #(). ]				initializeWith: [self writePersonWithEmailAddresses].			emailId1 := nil.			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests">testReadPersonAndReplaceUninstantiatedEmailAddressesWithEmpty	| |	self		inTransactionDo:			[			self 				inUnitOfWorkDo: [person emailAddresses: #().]				initializeWith: [self writePersonWithEmailAddresses].			emailId1 := nil.			emailId2 := nil.			self readPerson.			self checkEmailAddresses: person emailAddresses.			self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests">testReadPersonWithEmailAddresses	| query result emailAddresses |	self		inTransactionDo:			[self writePersonWithEmailAddresses.			query := Query				readOneOf: GlorpPerson				where: [:eachPerson | eachPerson id = personId].			result := query executeIn: session.			emailAddresses := result emailAddresses getValue.			self checkEmailAddresses: emailAddresses].</body><body package="GlorpDBTests">testReadPersonWithIsEmptySubselectToEmailAddresses	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				read: GlorpPerson				where:					[:eachPerson | eachPerson emailAddresses isEmpty].			self assert: people size = 1].</body><body package="GlorpDBTests">testReadPersonWithNotEmptySubselectToEmailAddresses	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				read: GlorpPerson				where:					[:eachPerson | eachPerson emailAddresses notEmpty].			self assert: people size = 2].</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests-write</category><body package="GlorpDBTests">testUpdatePersonWithNilEmailAddressesAndExclusiveRelationship	| newPerson |	((session system descriptorFor: GlorpPerson) mappingForAttributeNamed: #emailAddresses) beExclusive.	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		session modify: person in: [person emailAddresses: nil].		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body><body package="GlorpDBTests">testWritePersonWithEmailAddresses	| newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson example1.		newPerson id: 231.		personId := 231.			newPerson emailAddresses: OrderedCollection new.		newPerson emailAddresses add: (GlorpEmailAddress new id: 2; user: 'one'; host: 'blorch.ca').		newPerson emailAddresses add: (GlorpEmailAddress new id: 3; user: 'two'; host: 'blorch.ca').		emailId1 := 2.		emailId2 := 3.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self checkEmailAddresses: person emailAddresses.		self checkNumberOfEmailAddressesInDB: 2].</body><body package="GlorpDBTests">testWritePersonWithNilEmailAddresses	| newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		newPerson emailAddresses: nil.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body><body package="GlorpDBTests">testWritePersonWithNilEmailAddressesAndExclusiveRelationship	| newPerson |	((session system descriptorFor: GlorpPerson) mappingForAttributeNamed: #emailAddresses) beExclusive.	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		newPerson emailAddresses: nil.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body><body package="GlorpDBTests">testWritePersonWithNoEmailAddresses	| newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body><body package="GlorpDBTests">testWritePersonWithNoEmailAddresses2	| newPerson |	self inTransactionDo: [		session beginUnitOfWork.		newPerson := GlorpPerson new.		newPerson id: 231.		personId := 231.		newPerson emailAddresses: OrderedCollection new.		session register: newPerson.		session commitUnitOfWork.		session reset.		self readPerson.		self assert: person emailAddresses isEmpty.		self checkNumberOfEmailAddressesInDB: 0].</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests-join</category><body package="GlorpDBTests">setUpSomeExtraPeople	self		inUnitOfWorkDo:			[| otherPerson |			session register: (GlorpPerson new id: 9924365).			otherPerson := GlorpPerson new id: 12121.			otherPerson				emailAddresses:					(OrderedCollection						with:							((GlorpEmailAddress new)								id: 7;								host: 'asdfasdf')).			session register: otherPerson]		initializeWith: [self writePersonWithEmailAddresses].</body><body package="GlorpDBTests">testReadPersonWithJoinToEmailAddresses	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				read: GlorpPerson				where:					[:eachPerson | 					eachPerson emailAddresses						anySatisfyJoin: [:eachEmail | eachEmail host = 'objectpeople.com']].			self assert: people size = 1].</body><body package="GlorpDBTests">testReadPersonWithNegativeJoinToEmailAddresses	"Read with a negative condition. Note that this excludes the person with no e-mail addresses, as we're not doing an outer join"	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				read: GlorpPerson				where:					[:eachPerson | 					eachPerson emailAddresses						anySatisfyJoin: [:eachEmail | eachEmail host ~= 'objectpeople.com']].			self assert: people size = 2].</body><body package="GlorpDBTests">testReadPersonWithNegativeSubselectToEmailAddresses	"Read with a negative condition. Note that this excludes the person with no e-mail addresses, as we're not doing an outer join"	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				read: GlorpPerson				where:					[:eachPerson | 					eachPerson emailAddresses						anySatisfyExists: [:eachEmail | eachEmail host ~= 'objectpeople.com']].			self assert: people size = 2].</body><body package="GlorpDBTests">testReadPersonWithSubselectToEmailAddresses	| people |	self		inTransactionDo:			[self setUpSomeExtraPeople.			people := session				read: GlorpPerson				where:					[:eachPerson | 					eachPerson emailAddresses						anySatisfyExists: [:eachEmail | eachEmail host = 'objectpeople.com']].			self assert: people size = 1].</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests-alsoFetch</category><body package="GlorpDBTests">testReadPersonWithExistsWithAlsoFetch	| people query |	self inTransactionDo: 			[self setUpSomeExtraPeople.			query := ReadQuery read: GlorpPerson						where: 							[:eachPerson | 							eachPerson emailAddresses 								anySatisfyExists: [:eachEmail | eachEmail host = 'objectpeople.com']].			query alsoFetch: [:e | e address].			people := query executeIn: session.			self assert: people size = 1]</body><body package="GlorpDBTests">testReadPersonWithJoinWithAlsoFetch	| people query |	self inTransactionDo: 			[self setUpSomeExtraPeople.			query := ReadQuery read: GlorpPerson						where: 							[:eachPerson | 							eachPerson emailAddresses anySatisfyJoin: 									[:eachEmail | 									eachEmail host = 'objectpeople.com' | (eachEmail host = 'cs.uiuc.edu')]].			query alsoFetch: [:e | e address].			people := query executeIn: session.			self assert: people size = 1]</body></methods><methods><class-id>Glorp.GlorpOneToManyDBTest</class-id> <category>tests-read-substrings</category><body package="GlorpDBTests">testReadRelationshipWithSubstringMatch	| domain newDomain |	self inTransactionDo:		[domain := GlorpEmailDomain new topLevelDomain: 'com'.		session modify: domain in: [].		self writePersonWithEmailAddresses.		session reset.		newDomain := session readOneOf: GlorpEmailDomain.		self assert: newDomain addresses size = 1.		self assert: newDomain addresses first host = 'objectpeople.com'].</body></methods><methods><class-id>Glorp.GlorpEncyclopediaFeature</class-id> <category>accessing - conditional</category><body package="GlorpTestModels">featured	^featured</body><body package="GlorpTestModels">featured: aGlorpEncyclopediaEntry	featured := aGlorpEncyclopediaEntry.</body><body package="GlorpTestModels">featuredEntryText	"I pretend to Glorp that I am the direct getter of instvar featuredEntryText.  Actually I get it from my feature instance."	^featured isNil		ifFalse: [featured text]		ifTrue: [nil]</body><body package="GlorpTestModels">featuredEntryText: aString	"I pretend to Glorp that I am the direct setter of instvar featuredEntryText.  Actually I store it in my feature instance."	featured isNil		ifTrue: [featured := GlorpEncyclopediaEntry new text: aString]		ifFalse: [featured text: aString].</body></methods><methods><class-id>Glorp.GlorpEncyclopediaFeature</class-id> <category>accessing</category><body package="GlorpTestModels">encyclopedia	^encyclopedia</body><body package="GlorpTestModels">encyclopedia: aGlorpEncyclopedia	encyclopedia := aGlorpEncyclopedia.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginResource</class-id> <category>accessing</category><body package="GlorpDBTests">accessor	^accessor</body><body package="GlorpDBTests">accessor: anObject	accessor := anObject</body><body package="GlorpDBTests">login	^login</body><body package="GlorpDBTests">login: anObject	"We don't attempt to be secure on logins being used for tests. Make sure we don't surprise someone by modifying the original instance."	login := anObject copy.	login secure: false.</body><body package="GlorpDBTests">platform	^login database</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginResource</class-id> <category>initialize/release</category><body package="GlorpDBTests">setUp	Transcript show: self class name asString, ' setUp'; cr.	super setUp.	self login: self class defaultLogin.	accessor := DatabaseAccessor forLogin: login.	accessor login.</body><body package="GlorpDBTests">tearDown	Transcript show: self class name asString, ' tearDown'; cr.	accessor notNil ifTrue: [[accessor logout] on: Dialect error do: [:ex | ]].</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginResource class</class-id> <category>accessing</category><body package="GlorpDBTests">constructEventsTriggered	^(super constructEventsTriggered)		add: #changedDefaultLogin;		yourself</body><body package="GlorpDBTests">defaultLogin	"Return the default Login. Whether it binds is determined by UseBindingIfSupported if that is set, otherwise by the login platform's preference."	DefaultLogin isNil ifTrue: [^DefaultLogin := self defaultPostgreSQLLoginForVPN].	DefaultLogin database useBinding: DefaultLogin database class useBindingIfSupported.	^DefaultLogin</body><body package="GlorpDBTests">defaultLogin: aLogin	DefaultLogin = aLogin ifFalse: [GlorpDemoTablePopulatorResource invalidateSetup].	DefaultLogin := aLogin.	self triggerEvent: #changedDefaultLogin.</body><body package="GlorpDBTests">defaultPlatform	^self defaultLogin database.</body></methods><methods><class-id>Glorp.GlorpDatabaseLoginResource class</class-id> <category>data</category><body package="GlorpDBTests">defaultAccessLogin	"To set the default database login for Access, execute the following statement."	"self defaultAccessLogin."	^DefaultLogin := (Login new)		database: AccessPlatform new;		username: 'whatever';		password: '';		connectString: 'access'</body><body package="GlorpDBTests">defaultDB2Login	"To set the default database login to Oracle, execute the following statement."	"self defaultDB2Login."	^DefaultLogin := (Login new)		database: DB2Platform new;		username: 'sames';		password: 'sames';		connectString: 'store'</body><body package="GlorpDBTests">defaultFirebirdLogin	"To set the default database login to Firebird, execute the following statement."	"self defaultFirebirdLogin."	^DefaultLogin := (Login new)		database: FirebirdPlatform new;		username: 'MyName';		password: 'MyPassword';		connectString: 'firebirdGlorpTestDB'</body><body package="GlorpDBTests">defaultMysqlLogin	"To set the default database login to MySQL, execute the following statement."	"self defaultMysqlLogin."	^DefaultLogin := (Login new)		database: MySQLPlatform new;		username: '';		password: '';		connectString: 'test'.</body><body package="GlorpDBTests">defaultOracleLiteLogin	"To set the default database login to Oracle, execute the following statement."	"self defaultOracleLiteLogin."	^DefaultLogin := (Login new)		database: OraclePlatform new;		username: 'System';		password: 'password';		connectString: 'odbc:polite'</body><body package="GlorpDBTests">defaultOracleLogin	"To set the default database login to Oracle, execute the following statement."	"self defaultOracleLogin."	^DefaultLogin := (Login new)		database: OraclePlatform new;		username: 'System';		password: 'manager';		connectString: ''</body><body package="GlorpDBTests">defaultOracleLogin2	"To set the default database login to Oracle, execute the following statement."	"self defaultOracleLogin2."	^DefaultLogin := (Login new)		database: OraclePlatform new;		username: 'system';		password: 'password';		connectString: ''</body><body package="GlorpDBTests">defaultOracleODBCLogin	"To set the default database login to Oracle, execute the following statement."	"self defaultOracleODBCLogin."	^DefaultLogin := (Login new)		database: OracleODBCPlatform new;		username: 'System';		password: 'manager';		connectString: 'oracle'</body><body package="GlorpDBTests">defaultPersonalOracleLogin	"To set the default database login to Oracle, execute the following statement."	"self defaultPersonalOracleLogin."	^DefaultLogin := (Login new)		database: OraclePlatform new;		username: 'system';		password: 'manager';		connectString: ''</body><body package="GlorpDBTests">defaultPostgreSQL3LibpqLocalLogin	"Execute the following statement to set the default database login to PostgreSQL protocol 3.0 via the C API (not socket, so, as for Oracle and other databases, the local client library must be on the path).  The setting of a schema is not needed for GlorpTest tests but is needed for ActiveRecordTest tests."	"self defaultPostgreSQL3LibpqLocalLogin."	^DefaultLogin := (Login new)		database: PostgresLibpqPlatform new;		schema: 'public';		username: 'MyName';		password: 'MyPassword';		connectString: 'localhost:5432_GlorpTestDB'.</body><body package="GlorpDBTests">defaultPostgreSQL3SocketLocalLogin	"To set the default database login to PostgreSQL protocol 3.0, execute the following statement.  The setting of a schema is not needed for GlorpTest tests but is needed for ActiveRecordTest tests."	"self defaultPostgreSQL3SocketLocalLogin."	^DefaultLogin := (Login new)		database: PostgresSocketPlatform new;		schema: 'public';		username: 'MyName';		password: 'MyPassword';		connectString: 'localhost:5432_GlorpTestDB'.</body><body package="GlorpDBTests">defaultPostgreSQLInternetLogin	"To set the default database login to  PostgreSQL protocol 2.0 via socket, execute the following statement."	"self defaultPostgreSQLInternetLogin."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'guest';		password: 'guest';		connectString: 'store.cincomsmalltalk.com:5432_glorptest'.</body><body package="GlorpDBTests">defaultPostgreSQLLocalLogin	"To set the default database login to PostgreSQL protocol 2.0 via socket, execute the following statement.  The setting of a schema is not needed for GlorpTest tests but is needed for ActiveRecordTest tests."	"self defaultPostgreSQLLocalLogin."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		schema: 'public';		username: 'MyName';		password: 'MyPassword';		connectString: 'localhost:5432_GlorpTestDB'.</body><body package="GlorpDBTests">defaultPostgreSQLLogin	"To set the default database login to  PostgreSQL protocol 2.0 via socket, execute the following statement."	"self defaultPostgreSQLLogin."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'glorp-test';		password: 'simple';		connectString: '192.168.0.18_glorp-test'.</body><body package="GlorpDBTests">defaultPostgreSQLLoginForGlorpStore	"To set the default database login to  PostgreSQL protocol 2.0 via socket, execute the following statement."	"self defaultPostgreSQLLoginForGlorpStore."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'store-glorp-test';		password: 'simple';		connectString: '192.168.0.18_store-glorp-test'.</body><body package="GlorpDBTests">defaultPostgreSQLLoginForVPN	"To set the default database login to  PostgreSQL protocol 2.0 via socket, execute the following statement."	"self defaultPostgreSQLLoginForVPN."	^DefaultLogin := (Login new)		database: PostgreSQLPlatform new;		username: 'dbadmin';		password: 'dbadmin';		connectString: 'curly.parcplace.com:5432_template1'.</body><body package="GlorpDBTests">defaultSQLServerLogin	"To set the default database login for Dolphin, execute the following statement."	"self defaultSQLServerLogin."	^DefaultLogin := (Login new)		database: SQLServerPlatform new;		username: 'glorptest';		password: 'password';		connectString: 'glorptest'</body><body package="GlorpDBTests">defaultSQLiteLocalLogin	"To set the default database login to SQLite, change the connectString to an appropriate path and execute the following statement."	"self defaultSQLiteLocalLogin."	^DefaultLogin := (Login new)		database: SQLite3Platform new;		username: '';		password: '';		connectString: 'C:\somePath\someData\glorpTestSQLite.db'.</body></methods><methods><class-id>Glorp.DescriptorSystem class</class-id> <category>utility</category><body package="GlorpDBTests">createTables	"Create the tables for this descriptor system. This will fail if the tables already exist. Use recreateTables for that."	^self createTablesFor: GlorpDatabaseLoginResource current login.</body><body package="GlorpDBTests">dropTables	"Drop and re-create the tables for this descriptor system."	^self dropTablesFor: GlorpDatabaseLoginResource current login.</body><body package="GlorpDBTests">recreateTables	"Drop and re-create the tables for this descriptor system."	^self recreateTablesFor: GlorpDatabaseLoginResource current login.</body></methods><methods><class-id>Core.Collection</class-id> <category>glorp</category><body package="GlorpTestModels">assertEqual: aCollection	"A convenience method for testing"	self asSortedCollection with: aCollection asSortedCollection do: [:a :b |		a assertEqual: b].</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>glorp</category><body package="GlorpTestModels">assertEqual: anObject	GlorpTestModelClass new assert: anObject = nil.</body></methods><initialize><class-id>Glorp.GlorpDescriptorSystemWithNamespacePoolDictionaryDeclarer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>DatabaseCommand</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>useBinding stream sqlString session </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>TestAsserter</name><environment>XProgramming.SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>DescriptorSystem</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>session platform descriptors tables sequences typeResolvers cachePolicy allClasses useDirectAccessForMapping classModels useJoinsForAnySatisfy </inst-vars><class-inst-vars>validateDescriptorSystem </class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpMappings</package></attributes></class><class><name>SQLServerPlatform</name><environment>Glorp</environment><super>Glorp.DatabasePlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars>supportsGroupWritingValues supportsUnboundRowCount canRecurse </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>TestResource</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name description </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class><class><name>UpdateCommand</name><environment>Glorp</environment><super>Glorp.RowBasedCommand</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpCore</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>GlorpSession</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>system currentUnitOfWork cache accessor applicationData reaper errorAction modificationTracker </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpCore</package></attributes></class><class><name>DatabaseAccessor</name><environment>Glorp</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection currentLogin logging logger logOnly reusePreparedStatements deniedCommands mutex dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GlorpDatabase</category><attributes><package>GlorpDatabase</package></attributes></class><class><name>AbstractReadQuery</name><environment>Glorp</environment><super>Glorp.Query</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resultClass whereClause base limit offset proxyType shouldRefresh tracing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Glorp</category><attributes><package>GlorpQueries</package></attributes></class></st-source>