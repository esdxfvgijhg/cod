<?xml version="1.0"?><st-source><!-- Name: ICCIncrementalTypesComment: IC&C Incremental TypesCopyright ©1997-2008 by IC&C GmbH, Software Foundations.All rights reserved.DbIdentifier: bear73DbTrace: 292374DbUsername: iccdevDbVersion: 7.6_01DevelopmentPrerequisites: #(#(#package 'ICC-Namespace' '7.6_01'))PackageName: ICCIncrementalTypesParcel: #('ICCIncrementalTypes')ParcelName: ICCIncrementalTypesPrerequisiteParcels: #(#('ICC-Namespace' '7.6_01'))PrintStringCache: (7.6_01,iccdev)Version: 7.6_01VersionDate: 02/28/2008Date: 5:08:51 PM May 26, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (may17.4) of May 26, 2017 on May 26, 2017 at 5:08:51 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>IncrementalTypes</name><environment>ICC</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></name-space><class><name>IT1TypeEnvironment</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeVariableBindings masterClass meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeEnvironment</class-id><body>ITTypeEnvironment represents a closure on type variable declarations in such a way that every free type variable in a type scheme that defines a type variable has a definition in the type environment.Instance Variables:	typeVariableBindings	&lt;IT1TypeVariableScope&gt;  type declarations closed by the environment	masterClass			&lt;Class&gt;	information necessary for interpreting 'current' references	meta					&lt;Boolean&gt;	indicating whether the type environment context is instance or class level</body></comment><class><name>IT1TypeScheme</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>masterClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id><body>This is an abstract class for type object semantics. It records the class in which an expression was created. Type schemes may be open or closed, depending on type variables they may be built upon.Instance Variables:	masterClass	&lt;Class&gt; Class in which a specific type expression was statically defined.Subclasses must implement the following messages:	Instance protocol:		accessing			baseClass		printing			printNotationOn:		compatibility			in:satisfiedBy:in:matchContext:</body></comment><class><name>IT1ClassType</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1TypeScheme</super><private>false</private><indexed-type>none</indexed-type><inst-vars>baseClass typeVariableScope meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1ClassType</class-id><body>This class is the basic means to define type structures.Instance variables:	baseClass			&lt;Class&gt;	typeVariableScope	&lt;IT1TypeVariableScope&gt;	meta				&lt;Boolean&gt;</body></comment><class><name>IT1LiteralType</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1ClassType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literal </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1LiteralType</class-id><body>Instances of this class record values which might be used for further type evaluation purposes.Instance Variables:	literal	&lt;Object&gt;</body></comment><class><name>IT1NameScope</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>outerScope </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1NameScope</class-id><body>ITNameScope is an abstract class for all variable scopes.Instance Variables:	outerScope	&lt;IT1NameScope | nil&gt;</body></comment><class><name>IT1TypeVariableScope</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1NameScope</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeVars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeVariableScope</class-id><body>This class describes a scope associated with type variables.Instance Variables:	typeVars	&lt;Dictionary key: String value: IT1TypeScheme&gt;</body></comment><class><name>IT1TypeVariable</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1TypeScheme</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeVarName meta </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeVariable</class-id><body>This class serves several purposes:	1. Generic types are used for type abstraction. Type variables instantiated with 'free' are unconstrained abstractions. Type variables instantiated with any other value are constrained abstractions.	2. Type inheritance solves part of the problem of the type/subtype vs. code inheritance discussion. It allows to explicitly define refinements of a type in a subclass. This is achieved using type variables with appropriate conformance rules.	3. Type polymorphism of e.g. methods is introduced via type variables and conformance.Instance variables:	typeVarName	&lt;String&gt;	meta			&lt;Boolean&gt;	indicates whether the type variable represents current class</body></comment><class><name>IT1FullType</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classType clientRelationDeclarations typeDescriptor baseClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1FullType</class-id><body>This class represents types based on classes.Full types allow partial decriptions of the type's object space, taking into account only those specifications which are semantically meaningful. A type's state space is strictly valid if its superclasses are strictly valid, and if no types referred to are incomplete in a certain sense. Otherwise, a type is only partially defined. There are situations where it is sufficient to have partial type definitions.Full type is fully elaborated on demand. Note that a type is not elaborated iff its classType is nil. Delaying full elaboration contributes to the incremental flavor of IncrementalTypes.Instance Variables:	baseClass					&lt;Class&gt;	class on which this full type is based	classType					&lt;IT1ClassType&gt;  type scheme specification for base class	clientRelationDeclarations	&lt;IT1ClientRelationScope&gt; defining all client relations	typeDescriptor				&lt;IT1TypeDescriptor | nil&gt;	attributes defined for the full typeClass Variables:	CompatibilityErrorSignal	&lt;Signal&gt;</body></comment><class><name>IT1TypeSpecificationsStub</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeSpecificationsStub</class-id><body>The purpose of this class is to avoid malfunctions of system modifications after reinstalling ADvance.Its sole service does nothing and answer false to indicate the nop."</body></comment><class><name>IT1TypeSpecifications</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1TypeSpecificationsStub</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeSpecifications</class-id><body>This class is a Singleton; its sole instance is accessible via 'default'.When classes are removed from the system, IncrementalTypes should be notified appropriately by -&gt;removeSpecificationOf: aClass &lt;-Instance Variables:	fullTypes				&lt;IdentityDictionary key: Class value: IT1FullType&gt;Class Variables:	Default			 		&lt;IT1TypeSpecifications&gt;	ImplementationMapping	&lt;IdentityDictionary key: Symbol value: String&gt;</body></comment><class><name>IT1ClientRelation</name><environment>ICC.IncrementalTypes</environment><super>UI.UISpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>roleContext roleName role implementation explanation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1ClientRelation</class-id><body>ITClientRelationInstance Variables:	roleContext		&lt;LiteralBindingReference | Class&gt; Coming from literal encoding, the roleContext temporary is aBindingReference.	roleName		&lt;String&gt;	role				&lt;IT1TypeScheme&gt;	implementation	&lt;Symbol | nil&gt; See class IT1TypeSpecifications for implementation types.	explanation		&lt;String&gt;</body></comment><class><name>IT1TypeDescriptor</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullType strictValidityReport localValidityReport </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeDescriptor</class-id><body>ITTypeDescriptor keeps track of information associated with full types, viz. status of declaration, or mappings defined for the type.StrictValidity always refers not to local validity but to conditions violating strict validity beyond local concerns.Instance Variables:	fullType				&lt;IT1FullType&gt; 			associated full type	strictValidityReport	&lt;IT1TypeReport | nil&gt;	localValidityReport	&lt;IT1TypeReport | nil&gt;</body></comment><class><name>IT1UnionType</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1TypeScheme</super><private>false</private><indexed-type>none</indexed-type><inst-vars>union </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1UnionType</class-id><body>This class is a type which should be used with care. Type aggregated in a union type should only be used in a context where the messages they must service are implemented by all members of the union type. nil is handled as an exception to the rule: nil as part of a union type is suppressed in type checking, a warning is issued, and it is assumed that programming provisions are taken to cope with partially defined situations.Instance Variables:	union	&lt;OrderedCollection of: IT1TypeScheme&gt;</body></comment><class><name>IT1ClientRelationScope</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1NameScope</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clientRelations localScope </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1ClientRelationScope</class-id><body>ITClientRelationDeclarationsInstance Variables:	localScope		&lt;Class&gt;	clientRelations	&lt;OrderedCollection of: IT1ClientRelation&gt;</body></comment><class><name>IT1TypeReport</name><environment>ICC.IncrementalTypes</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeReport</class-id><body>Instances of this class collect errors or warnings produced during type declaration analysis or type checking in general. Reports are produced as a side effect of type checking.Instance Variables:	errors		&lt;OrderedCollection of: String&gt; 	a description of errors encountered</body></comment><class><name>IT1TypeElaboration</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fullType elaborationHistory typeVarDeclarations clientRelationDeclarations typeEnvironment strictValidityReport localValidityReport </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id><body>This class controls elaboration of declarations for a dedicated master class. A successful elaboration leads to creation of full type variable declarations and their linking to an appropriate outer scope. Semantic objects are assigned according to context.Instance Variables:	fullType						&lt;IT1FullType&gt;	elaborationHistory			&lt;OrderedCollection of: Class&gt;	typeVarDeclarations			&lt;IT1TypeVariableScope&gt; scoping type variables currently elaborated	clientRelationDeclarations	&lt;IT1ClientRelationScope&gt;  scoping client relations currently elaborated	typeEnvironment			&lt;IT1TypeEnvironment&gt;	strictValidityReport			&lt;IT1TypeReport&gt;	localValidityReport			&lt;IT1TypeReport&gt;</body></comment><class><name>IT1FreeType</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1TypeScheme</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1FreeType</class-id><body>Instances of this class represent any type which encompasses all the worlds object identities and does understand nothing.</body></comment><class><name>IT1Context</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeRep </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1Context</class-id><body>ITContext is an abstract superclass for all classes establishing a context in type elaboration and type checking.Instance Variables:	typeRep	&lt;IT1TypeReport&gt;</body></comment><class><name>IT1Inferencing</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1Context</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inferenceConstraints </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1Inferencing</class-id><body>This class is used for type inference as part of compatibility checks. It collects constraints on type constructors imposed through a compatibility check.Instance Variables:	inferenceConstraints		&lt;OrderedCollection of: (Association key: String value: IT1TypeScheme)&gt;</body></comment><class><name>IT1TypeClosure</name><environment>ICC.IncrementalTypes</environment><super>ICC.IncrementalTypes.IT1TypeScheme</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeScheme typeEnvironment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1TypeClosure</class-id><body>This class defines the bindings of free type variables in a type scheme through a type environment.Instance Variables:	typeScheme		&lt;IT1TypeScheme&gt;	typeEnvironment	&lt;IT1TypeEnvironment&gt;</body></comment><class><name>IT1VariableDeclarations</name><environment>ICC.IncrementalTypes</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class instVars classVars classInstVars typeVars inheritedInstVars inheritedClassInstVars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C Incremental Types</category><attributes><package>ICCIncrementalTypes</package></attributes></class><comment><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id><body>This class provides an interface for checking class comments for declarations of variables. Declaration strings are evaluated and transformed into parse trees of proper type expressions following the syntax given by the Smalltalk Parser class.There are instance, class instance and class variables in standard VisualWorks. IncrementalTypes add type variable definitions. Furthermore, it is possible to redefine variables obeying compatibility rules.Instance Variables:	class					&lt;Class&gt;	instVars				&lt;Array of: (Association key: String value: ProgramNode)&gt;	classVars				&lt;Array of: (Association key: String value: ProgramNode)&gt;	classInstVars			&lt;Array of: (Association key: String value: ProgramNode)&gt;	typeVars				&lt;Array of: (Association key: String value: ProgramNode)&gt;	inheritedInstVars		&lt;Array of: (Association key: String value: ProgramNode)&gt;	inheritedClassInstVars	&lt;Array of: (Association key: String value: ProgramNode)&gt;</body></comment><shared-variable><name>ImplementationMapping</name><environment>ICC.IncrementalTypes.IT1TypeSpecifications</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>ICCIncrementalTypes</package></attributes></shared-variable><shared-variable><name>Default</name><environment>ICC.IncrementalTypes.IT1TypeSpecifications</environment><private>false</private><constant>false</constant><category>defaults</category><attributes><package>ICCIncrementalTypes</package></attributes></shared-variable><shared-variable><name>CompatibilityErrorSignal</name><environment>ICC.IncrementalTypes.IT1FullType</environment><private>false</private><constant>false</constant><category>signals</category><attributes><package>ICCIncrementalTypes</package></attributes></shared-variable><methods><class-id>ICC.IncrementalTypes.IT1TypeEnvironment</class-id> <category>type variable properties</category><body package="ICCIncrementalTypes">atTypeVarName: aTypeVarName	"^&lt;TypeScheme | nil &gt;"	^self typeVariableBindings atTypeVarName: aTypeVarName inEnvironment: self</body><body package="ICCIncrementalTypes">isDefined: aTypeVarName	"^&lt;Boolean&gt;"	^self typeVariableBindings isDefined: aTypeVarName</body><body package="ICCIncrementalTypes">typeVarBaseClassOf: aTypeVarName	"^&lt;Class&gt;"	^self typeVariableBindings baseClassOfTypeVar: aTypeVarName inEnvironment: self</body><body package="ICCIncrementalTypes">typeVarTypeOf: aTypeVarName	"^&lt;ITTypeScheme | nil &gt;"	^self typeVariableBindings typeVarTypeOf: aTypeVarName inEnvironment: self</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeEnvironment</class-id> <category>accessing</category><body package="ICCIncrementalTypes">masterClass	^masterClass</body><body package="ICCIncrementalTypes">masterClass: aClass	masterClass := aClass</body><body package="ICCIncrementalTypes">meta	^meta</body><body package="ICCIncrementalTypes">meta: aBoolean	meta := aBoolean</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeEnvironment</class-id> <category>private</category><body package="ICCIncrementalTypes">typeVariableBindings	^typeVariableBindings</body><body package="ICCIncrementalTypes">typeVariableBindings: aTypeVarScope	typeVariableBindings := aTypeVarScope</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeEnvironment class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">closureOn: aTypeVarScope masterClass: aMasterClass	^self		closureOn: aTypeVarScope		masterClass: aMasterClass		meta: false</body><body package="ICCIncrementalTypes">closureOn: aTypeVarScope masterClass: aMasterClass meta: aBoolean	| obj |	obj := self new.	obj typeVariableBindings: aTypeVarScope.	obj masterClass: aMasterClass.	obj meta: aBoolean.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id> <category>printing</category><body package="ICCIncrementalTypes">itTypeNotation	| aStream |	aStream := WriteStream on: (String new: 16).	self printNotationOn: aStream.	^aStream contents</body><body package="ICCIncrementalTypes">printNotationOn: aStream	"Default is to use namespaces within notation."	^self printNotationOn: aStream showNamespaces: true</body><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean	^self subclassResponsibility</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id> <category>accessing</category><body package="ICCIncrementalTypes">baseClass	"^&lt;Class&gt;	Every type scheme is assumed to have a base class, defining a common behavior of the scheme. This	assumption needs interpretation in specific cases."	^self subclassResponsibility</body><body package="ICCIncrementalTypes">baseClassIn: aTypeEnvironment	"^&lt;Class&gt;	Default behavior"	^self baseClass</body><body package="ICCIncrementalTypes">masterClass	^masterClass</body><body package="ICCIncrementalTypes">masterClass: aClass	masterClass := aClass</body><body package="ICCIncrementalTypes">typeScheme	^self</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id> <category>compatibility</category><body package="ICCIncrementalTypes">in: myEnv satisfiedBy: aTypeScheme in: aTypeSchemeEnv matchContext: matchContext	"Check for compatibility is a property of all type schemes."	^self subclassResponsibility</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id> <category>testing</category><body package="ICCIncrementalTypes">hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext	"^&lt;Boolean&gt;"	"Check through recursive descent over a type scheme structure and its type variable	bindings if a recursive type variable reference occurs."	^false</body><body package="ICCIncrementalTypes">isFree	^false</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">itTypes	^self class itTypes</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id> <category>closure</category><body package="ICCIncrementalTypes">closureIn: aTypeEnvironment	"The default for type expressions is to assume that they are closed."	^self</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id> <category>initialize-release</category><body package="ICCIncrementalTypes">initialize</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme</class-id> <category>error messages</category><body package="ICCIncrementalTypes">recursiveTypeVariableDeclarationError: aTypeVarName inElaborationContext: elabContext	elabContext typeRep addError: 'Recursion error in class ''' , elabContext masterClassName , '''. Illegal recursive type binding of type variable ''' , aTypeVarName , ''' .'.	^nil</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeScheme class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">masterClass: aClass	| obj |	obj := self new initialize.	obj masterClass: aClass.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType</class-id> <category>compatibility</category><body package="ICCIncrementalTypes">in: myEnv genericsSatisfy: aClassTypeEnv matchContext: matchContext	"^&lt;ITMatchContext | nil&gt;	Check my own type variable definitions against generic definitions in aClassType. If I am	not a constructed type, don't check. This prevents triggering of type scheme evaluations	where not appropriate."	| myTypeVarVal valToBeMatched |	self primTypeVariableScope isNil ifTrue: [^matchContext].	self typeVariableScope typeVars		keysAndValuesDo:			[:typeVarName :typeVarVal |			myTypeVarVal := self typeVariableScope atTypeVarName: typeVarName inEnvironment: myEnv.			valToBeMatched := aClassTypeEnv atTypeVarName: typeVarName.			valToBeMatched notNil ifTrue: [(valToBeMatched					in: aClassTypeEnv					satisfiedBy: myTypeVarVal					in: myEnv					matchContext: matchContext) isNil ifTrue: [^nil]]].	^matchContext</body><body package="ICCIncrementalTypes">in: myEnv satisfiedBy: aTypeScheme in: aTypeSchemeEnv matchContext: aMatchContext	"^&lt;ITTypeMatchContext | nil&gt;"	(aTypeScheme isKindOf: self class)		ifTrue: [^self				in: myEnv				satisfiedByClassType: aTypeScheme				in: aTypeSchemeEnv				matchContext: aMatchContext].	(aTypeScheme isKindOf: IT1TypeClosure)		ifTrue: [^self				in: myEnv				satisfiedBy: aTypeScheme typeScheme				in: aTypeScheme typeEnvironment				matchContext: aMatchContext].	(aTypeScheme isKindOf: IT1TypeVariable)		ifTrue: [^self				in: myEnv				satisfiedByTypeVariable: aTypeScheme				in: aTypeSchemeEnv				matchContext: aMatchContext].	(aTypeScheme isKindOf: IT1UnionType)		ifTrue: [^aTypeScheme				in: aTypeSchemeEnv				satisfies: self				in: myEnv				matchContext: aMatchContext].	(aTypeScheme isKindOf: IT1FreeType)		ifTrue: [^aMatchContext].	^self noCompatibilityAtAllError: aMatchContext typeRep</body><body package="ICCIncrementalTypes">in: myEnv satisfiedByClassType: aClassType in: aClassTypeEnv matchContext: matchContext	"^&lt;ITMatchContext | nil&gt;"	"Note that neither myEnv nor aTypeSchemeEnv are used as base class types are	closed by construction."	((aClassType baseClass includesBehavior: self baseClass)		and: [aClassType meta = self meta])		ifTrue: [^aClassType				in: aClassTypeEnv				genericsSatisfy: self typeEnvironment				matchContext: matchContext]		ifFalse: [^self classTypeMismatch: aClassType baseClassName typeRep: matchContext typeRep]</body><body package="ICCIncrementalTypes">in: myEnv satisfiedByTypeVariable: aTypeVariable in: aTypeVariableEnv matchContext: matchContext	"^&lt;ITMatchContext | nil&gt;"	"Type variables are dereferenced, their value tested again."	| typeVarVal |	typeVarVal := aTypeVariableEnv atTypeVarName: aTypeVariable typeVarName.	^typeVarVal isNil		ifTrue: [self missingTypeVarDeclarationError: aTypeVariable typeVarName						 typeRep: matchContext typeRep]		ifFalse: [self				in: myEnv				satisfiedBy: typeVarVal				in: aTypeVariableEnv				matchContext: matchContext]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType</class-id> <category>accessing</category><body package="ICCIncrementalTypes">associatedFullType	"^&lt;ITFullType &gt;	Assuming that this method is not invoked in a situation bringing about recursive definitions."	^self itTypes fullTypeOfClass: self baseClass</body><body package="ICCIncrementalTypes">baseClass	^baseClass</body><body package="ICCIncrementalTypes">baseClass: aClass	baseClass := aClass</body><body package="ICCIncrementalTypes">baseClassName	^self baseClass fullName asString</body><body package="ICCIncrementalTypes">baseClassShortName	^self baseClass name asString</body><body package="ICCIncrementalTypes">closedTypeVarTypeOf: typeVarName	"^&lt;ITTypeScheme&gt;	This method yields a closed type scheme."	^self typeVariableScope typeVarTypeOf: typeVarName inEnvironment: self typeEnvironment</body><body package="ICCIncrementalTypes">meta	^meta</body><body package="ICCIncrementalTypes">meta: aBoolean	meta := aBoolean</body><body package="ICCIncrementalTypes">primTypeVariableScope	^typeVariableScope</body><body package="ICCIncrementalTypes">typeVarTypeOf: typeVarName	"^&lt;ITTypeScheme&gt;	---Attention---	This method yields a type scheme which might be open. It should therefore used with care."	^self typeVariableScope typeVarTypeOf: typeVarName</body><body package="ICCIncrementalTypes">typeVarTypeOf: typeVarName inEnvironment: aTypeEnvironment	"^&lt;ITTypeScheme&gt;"	^self closedTypeVarTypeOf: typeVarName</body><body package="ICCIncrementalTypes">typeVariableScope	"^&lt;IT1TypeVariableScope&gt;	The scope is given by the superclass of the base class (or the base class itself if superclass is nil as for Object and LensAbsentee)."	| newOuterScope refClass |	typeVariableScope isNil		ifTrue:			[refClass := (self baseClass superclass isNil						ifTrue: [self baseClass]						ifFalse: [self baseClass superclass]).			newOuterScope := self itTypes typeVarDeclarationsOf: refClass.			typeVariableScope := IT1TypeVariableScope outerScope: newOuterScope].	^typeVariableScope</body><body package="ICCIncrementalTypes">typeVariableScope: aTypeVariableScope	typeVariableScope := aTypeVariableScope</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType</class-id> <category>error messages</category><body package="ICCIncrementalTypes">classTypeMismatch: className typeRep: typeRep	typeRep addError: ('Class &lt;1p&gt; does not match &lt;2p&gt;.' expandMacrosWith: className with: self baseClassName).	^nil</body><body package="ICCIncrementalTypes">missingTypeVarDeclarationError: typeVarName typeRep: typeRep	typeRep addError: 'Type variable ''', typeVarName , ''' has no declaration.'.	^nil</body><body package="ICCIncrementalTypes">noCompatibilityAtAllError: typeRep	typeRep addError: 'Class ''', self baseClassName , ''' is not matched.'.	^nil</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType</class-id> <category>testing</category><body package="ICCIncrementalTypes">hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext	"^&lt;Boolean&gt;"	^self typeVariableScope hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType</class-id> <category>printing</category><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean 	aStream nextPutAll: (aBoolean 				ifTrue: [self baseClassName]				ifFalse: [self baseClassShortName]).	self typeVariableScope printNotationOn: aStream showNamespaces: aBoolean</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType</class-id> <category>closure</category><body package="ICCIncrementalTypes">closureIn: aTypeEnvironment	^self typeVariableScope isEmpty		ifTrue: [self]		ifFalse: [IT1TypeClosure typeScheme: self typeEnvironment: aTypeEnvironment]</body><body package="ICCIncrementalTypes">typeEnvironment	^IT1TypeEnvironment closureOn: self typeVariableScope masterClass: self masterClass</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType</class-id> <category>private</category><body package="ICCIncrementalTypes">typeVarDeclarationsInElaborationContext: elabContext	"^&lt;IT1TypeVariableScope | nil&gt;"	| associatedFullType newOuterScope |	typeVariableScope isNil ifTrue: [(elabContext checkElaborationRecursionFor: self baseClass)			ifTrue: [^nil]			ifFalse:				[associatedFullType := self associatedFullType.				associatedFullType elaborateInContext: elabContext.				newOuterScope := associatedFullType typeVarDeclarations.				typeVariableScope := IT1TypeVariableScope outerScope: newOuterScope]].	^typeVariableScope</body><body package="ICCIncrementalTypes">updateTypeVariableScopeWith: aTypeVariableScope	self typeVariableScope isEmpty		ifTrue: [self typeVariableScope: aTypeVariableScope]		ifFalse: [self typeVariableScope extendBy: aTypeVariableScope]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType</class-id> <category>type substitution</category><body package="ICCIncrementalTypes">substituteTypeVars: typeVarNames with: args inElaborationContext: elabContext	"^&lt;ITClassType | nil&gt;"	"Check base class for existence of type variables, check their values for args	compatibility, and check whether type variable recursion occurs when substituting.	Substitution is interpreted as true parallel substitution."	| varVal match currentTypeVarBindings currentTypeEnvironment newTypeVarBindings |	currentTypeVarBindings := self typeVarDeclarationsInElaborationContext: elabContext.	elabContext updateStrictValidityReport: self associatedFullType strictValidityReport.	currentTypeVarBindings isNil ifTrue: [^nil].	currentTypeEnvironment := IT1TypeEnvironment closureOn: currentTypeVarBindings							masterClass: self masterClass.	newTypeVarBindings := IT1TypeVariableScope outerScope: currentTypeVarBindings.	typeVarNames with: args		do:			[:varName :arg |			varVal := currentTypeEnvironment atTypeVarName: varName.			varVal isNil ifTrue: [^self missingTypeVarDeclarationError: varName									typeRep: elabContext typeRep].			match := varVal						in: currentTypeEnvironment						satisfiedBy: arg						in: elabContext typeEnvironment						matchContext: (IT1Inferencing typeRep: elabContext typeRep).			match notNil				ifTrue: [newTypeVarBindings addTypeVar: varName -&gt; arg]				ifFalse: [^nil]].	self updateTypeVariableScopeWith: newTypeVarBindings</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClassType class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">masterClass: aMasterClass baseClass: aBaseClass	^self		masterClass: aMasterClass		baseClass: aBaseClass		meta: false</body><body package="ICCIncrementalTypes">masterClass: aMasterClass baseClass: aBaseClass meta: aBoolean	| obj |	obj := self masterClass: aMasterClass.	obj baseClass: aBaseClass.	obj meta: aBoolean.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1LiteralType</class-id> <category>accessing</category><body package="ICCIncrementalTypes">literal	^literal</body><body package="ICCIncrementalTypes">literal: anObject	literal := anObject</body></methods><methods><class-id>ICC.IncrementalTypes.IT1LiteralType</class-id> <category>printing</category><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean	self literal printOn: aStream</body></methods><methods><class-id>ICC.IncrementalTypes.IT1LiteralType class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">masterClass: aMasterClass baseClass: aBaseClass literal: anObject	| obj |	obj := self masterClass: aMasterClass baseClass: aBaseClass.	obj literal: anObject.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1NameScope</class-id> <category>accessing</category><body package="ICCIncrementalTypes">outerScope	^outerScope</body><body package="ICCIncrementalTypes">outerScope: aVariableDeclarations	outerScope := aVariableDeclarations</body></methods><methods><class-id>ICC.IncrementalTypes.IT1NameScope class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">outerScope: aNameScope	| obj |	obj := self new.	obj outerScope: aNameScope.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariableScope</class-id> <category>testing</category><body package="ICCIncrementalTypes">hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext	"^&lt;Boolean&gt;"	| ok |	ok := false.	self typeVars do: [:typeScheme | ok := ok or:		 [typeScheme hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext]].	^ok</body><body package="ICCIncrementalTypes">isEmpty	"^&lt;Boolean&gt;	Check if there exist a type variable in this scope."	self typeVars isEmpty ifFalse: [^false]		ifTrue: [self outerScope isNil				ifTrue: [^true]				ifFalse: [^self outerScope isEmpty]]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariableScope</class-id> <category>printing</category><body package="ICCIncrementalTypes">printNotationOn: aStream	"Default is to use namespaces within notation."	^self printNotationOn: aStream showNamespaces: true</body><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean	"Printing does not take care of binding semantics."	self typeVars		associationsDo:			[:assoc |			aStream space; nextPutAll: assoc key; nextPut: $:; space.			(assoc value closureIn: self)				printNotationOn: aStream showNamespaces: aBoolean]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariableScope</class-id> <category>type variable properties</category><body package="ICCIncrementalTypes">baseClassOfTypeVar: aTypeVarName inEnvironment: aTypeEnvironment	"^&lt;Class&gt;	Triggers a dereferencing if necessary. Note that accessing type variables yields closed type schemes."	^(self typeVarTypeOf: aTypeVarName inEnvironment: aTypeEnvironment) baseClass</body><body package="ICCIncrementalTypes">isDefined: aTypeVarName	"^&lt;Boolean&gt;"	^(self typeVars includesKey: aTypeVarName)		ifTrue: [true]		ifFalse: [self outerScope isNil				ifTrue: [false]				ifFalse: [self outerScope isDefined: aTypeVarName]]</body><body package="ICCIncrementalTypes">typeVarTypeOf: aTypeVarName	"Short form for type variables with closed type schemes as values."	^self typeVars at: aTypeVarName ifAbsent: [self outerScope isNil			ifTrue: [nil]			ifFalse: [self outerScope typeVarTypeOf: aTypeVarName]]</body><body package="ICCIncrementalTypes">typeVarTypeOf: aTypeVarName inEnvironment: aTypeEnvironment	"^&lt;ITTypeScheme | nil &gt;"	"Evaluate aTypeVarName in aTypeEnvironment, disallowing currentClass in class	context and instance in instance context. Type variables are not! dereferenced."	^self atTypeVarName: aTypeVarName inEnvironment: aTypeEnvironment</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariableScope</class-id> <category>adding</category><body package="ICCIncrementalTypes">addTypeVar: anAssociation	self typeVars add: anAssociation</body><body package="ICCIncrementalTypes">extendBy: aTypeVariableScope	aTypeVariableScope typeVars associationsDo: [:tVar | self addTypeVar: tVar]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariableScope</class-id> <category>accessing</category><body package="ICCIncrementalTypes">atTypeVarName: aTypeVarName inEnvironment: aTypeEnvironment	"^&lt;ITTypeScheme&gt;"	| val |	aTypeVarName = 'current' ifTrue: [^IT1ClassType			masterClass: aTypeEnvironment masterClass			baseClass: aTypeEnvironment masterClass			meta: aTypeEnvironment meta].	aTypeVarName = 'class' ifTrue: [aTypeEnvironment meta			ifTrue: [^nil]			ifFalse: [^IT1ClassType					masterClass: aTypeEnvironment masterClass					baseClass: aTypeEnvironment masterClass					meta: true]].	aTypeVarName = 'instance' ifTrue: [aTypeEnvironment meta			ifTrue: [^IT1ClassType					masterClass: aTypeEnvironment masterClass					baseClass: aTypeEnvironment masterClass					meta: false]			ifFalse: [^nil]].	aTypeVarName = 'free' ifTrue: [^IT1FreeType masterClass: aTypeEnvironment masterClass].	(val := self typeVars at: aTypeVarName ifAbsent: [nil]) isNil ifTrue: [^self outerScope isNil			ifTrue: [nil]			ifFalse: [self outerScope atTypeVarName: aTypeVarName inEnvironment: aTypeEnvironment]].	^val closureIn: aTypeEnvironment</body><body package="ICCIncrementalTypes">typeVars	typeVars isNil ifTrue: [typeVars := Dictionary new].	^typeVars</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariable</class-id> <category>accessing</category><body package="ICCIncrementalTypes">baseClass	"Default baseClass"	^UndefinedObject</body><body package="ICCIncrementalTypes">baseClassIn: aTypeEnvironment	"^&lt;Class&gt;"	^aTypeEnvironment typeVarBaseClassOf: self typeVarName</body><body package="ICCIncrementalTypes">meta	^meta</body><body package="ICCIncrementalTypes">meta: aBoolean	meta := aBoolean</body><body package="ICCIncrementalTypes">typeVarName	^typeVarName</body><body package="ICCIncrementalTypes">typeVarName: aString	typeVarName := aString</body><body package="ICCIncrementalTypes">typeVarTypeOf: aTypeVarName inEnvironment: aTypeEnvironment	"^&lt;ITTypeScheme&gt;	Basically, dereference myself and ask for aTypeVarName's value."	| myValue |	myValue := aTypeEnvironment typeVarTypeOf: self typeVarName.	^myValue typeVarTypeOf: aTypeVarName</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariable</class-id> <category>error messages</category><body package="ICCIncrementalTypes">noValidTypeVariableValueError: typeRep	typeRep addError: 'Type variable has invalid declaration.'.	^nil</body><body package="ICCIncrementalTypes">recursiveTypeVariableDeclarationError: aTypeVarName inElaborationContext: elabContext	elabContext typeRep addError: 'Recursion error in ''' , elabContext masterClassName ,		 '''. Illegal recursive type binding of type variable ''' , aTypeVarName , '''.'.	^nil</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariable</class-id> <category>closure</category><body package="ICCIncrementalTypes">closureIn: aTypeEnvironment	^IT1TypeClosure typeScheme: self typeEnvironment: aTypeEnvironment</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariable</class-id> <category>testing</category><body package="ICCIncrementalTypes">hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext	"^&lt;Boolean&gt;	Note that due to the general assumption on absence of recursive type variable	declarations, recursion over type variable bindings will be finite."	(self typeVarName = aTypeVarName)		ifTrue: [self recursiveTypeVariableDeclarationError: aTypeVarName inElaborationContext: elabContext. ^true]		ifFalse: [^(elabContext typeEnvironment atTypeVarName: self typeVarName) typeScheme					hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext]</body><body package="ICCIncrementalTypes">isFree	^self typeVarName = 'free'</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariable</class-id> <category>printing</category><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean	aStream nextPutAll: self typeVarName</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariable</class-id> <category>compatibility</category><body package="ICCIncrementalTypes">in: myEnv satisfiedBy: aTypeScheme in: aTypeSchemeEnv matchContext: matchContext	"^&lt;ITMatchContext | nil&gt;	Note that in case that in case I am not free, current, instance or class, note a restricting	binding in matchContext."	| myVal match |	aTypeScheme isFree ifTrue: [^matchContext].	myVal := myEnv atTypeVarName: self typeVarName.	^myVal isNil		ifTrue: [self noValidTypeVariableValueError: matchContext typeRep]		ifFalse:			[match := myVal						in: myEnv						satisfiedBy: aTypeScheme						in: aTypeSchemeEnv						matchContext: matchContext.			match notNil				ifTrue:					[(#('current' 'free' 'instance' 'class') includes: self typeVarName)						ifFalse: [matchContext addTypeVarBinding: self typeVarName -&gt; (IT1TypeClosure typeScheme: aTypeScheme typeEnvironment: aTypeSchemeEnv)].					matchContext]				ifFalse: [nil]]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeVariable class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">masterClass: aMasterClass typeVarName: aTypeVarName	| obj |	obj := self masterClass: aMasterClass.	obj typeVarName: aTypeVarName.	obj meta: false.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>private</category><body package="ICCIncrementalTypes">capitalizedFor: aString	^(aString at: 1) isUppercase		ifTrue: [aString]		ifFalse:			[| result |			result := aString copy.			result at: 1 put: (result at: 1) asUppercase.			result]</body><body package="ICCIncrementalTypes">classDefinitionAlertFor: roleName implementation: implementation 	Dialog warn: ('Can''t create &lt;1s&gt; &lt;2p&gt;.&lt;n&gt;Check class-, superclass- and subclass definitions!' 			expandMacrosWith: (self itTypes class implementationStringFor: implementation)			with: roleName)		for: nil</body><body package="ICCIncrementalTypes">mergeStrictValidityReports: aTypeReport	| mySuperType |	mySuperType := self superType.	(mySuperType isNil and: [aTypeReport isNil])		ifTrue: [^IT1TypeReport new].	mySuperType isNil ifTrue: [^aTypeReport].	^self strictValidityReportFrom: mySuperType strictValidityReport and: aTypeReport</body><body package="ICCIncrementalTypes">typeFrom: aTypeString	"^&lt;ITTypeScheme&gt; Build a type representation from aTypeString within the current context."	^IT1TypeElaboration elaborateParsedTypeExpression: (IT1VariableDeclarations new  parseType: aTypeString)		inClassContext: self baseClass</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>accessing</category><body package="ICCIncrementalTypes">baseClass	^baseClass</body><body package="ICCIncrementalTypes">baseClass: aClass	baseClass := aClass</body><body package="ICCIncrementalTypes">classType	classType isNil ifTrue: [self elaborate].	^classType</body><body package="ICCIncrementalTypes">classType: aClassType	classType := aClassType</body><body package="ICCIncrementalTypes">clientRelationDeclarations	"^&lt;ITClientRelationScope | nil&gt;	Elaboration is triggered on demand."	clientRelationDeclarations isNil ifTrue: [self elaborate].	^clientRelationDeclarations</body><body package="ICCIncrementalTypes">clientRelationDeclarations: aClientRelationDeclarations	clientRelationDeclarations := aClientRelationDeclarations</body><body package="ICCIncrementalTypes">clientRelationsOuterScope	"^&lt;ITClientRelationScope | nil&gt;"	^self isRoot		ifTrue: [nil]		ifFalse: [self baseClass superclass clientRelationDeclarations]</body><body package="ICCIncrementalTypes">typeDescriptor	typeDescriptor isNil ifTrue: [typeDescriptor := IT1TypeDescriptor forFullType: self].	^typeDescriptor</body><body package="ICCIncrementalTypes">typeDescriptor: aTypeDescriptor	typeDescriptor := aTypeDescriptor</body><body package="ICCIncrementalTypes">typeEnvironment	^self classType typeEnvironment</body><body package="ICCIncrementalTypes">typeRep	^self typeDescriptor typeRep</body><body package="ICCIncrementalTypes">typeVarDeclarations	"^&lt;ITTypeVariableScope | nil&gt;"	^self classType notNil		ifTrue: [self classType typeVariableScope]		ifFalse: [nil]</body><body package="ICCIncrementalTypes">typeVarDeclarationsInElaborationContext: elabContext	"^&lt;ITTypeVariableScope | nil&gt;"	self elaborateInContext: elabContext.	^self typeVarDeclarations</body><body package="ICCIncrementalTypes">typeVarOuterScope	"^&lt;ITTypeVariableScope | nil&gt;"	^self isRoot		ifTrue: [nil]		ifFalse: [self baseClass superclass typeVarDeclarations]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>testing</category><body package="ICCIncrementalTypes">isElaborated	^classType notNil</body><body package="ICCIncrementalTypes">isLocallyValid	^self typeDescriptor isLocallyValid</body><body package="ICCIncrementalTypes">isRoot	^self baseClass superclass isNil</body><body package="ICCIncrementalTypes">isStrictlyValid	^self typeDescriptor isStrictlyValid</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">itTypes	^self class itTypes</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>declarations</category><body package="ICCIncrementalTypes">checkCompatibilityOfClientRelation: aClientRelation	"^&lt;Boolean&gt;	Check if aClientRelation is not in conflict with an inherited declaration."	| typeToBeCheckedAgainst check |	typeToBeCheckedAgainst := self superType clientRelationTypeOf: aClientRelation roleName implementation: aClientRelation implementation.	typeToBeCheckedAgainst isNil		ifTrue: [^true]		ifFalse:			[check := typeToBeCheckedAgainst						in: self typeEnvironment						satisfiedBy: aClientRelation role						in: self typeEnvironment						matchContext: (IT1Inferencing typeRep: IT1TypeReport new).			^check notNil]</body><body package="ICCIncrementalTypes">declareClientRelation: aRoleName role: aTypeString implementation: anImplementation explanation: anExplanation	"^&lt;current&gt;	aRoleName 			&lt;String&gt;	aTypeString 		&lt;String&gt; describing the role of the client relation; any unbound	references in the type string are resolved within my class context.	anImplementation	&lt;Symbol&gt;	anExplanation 		&lt;String | nil&gt;"	(self itTypes class varImplementationTypes includes: anImplementation)		ifTrue: [self				declareVarClientRelation: aRoleName				role: aTypeString				implementation: anImplementation				explanation: anExplanation]		ifFalse: [self				declareNonVarClientRelation: aRoleName				role: aTypeString				implementation: anImplementation				explanation: anExplanation].	self baseClass invalidateTypeDeclarations</body><body package="ICCIncrementalTypes">declareNonVarClientRelation: aRoleName role: aTypeString implementation: implementation explanation: anExplanation	"Declare a new client relation which is not implemented through an instance variable, check its	consistency, and update the associated specification accordingly."	| newClientRelation |	newClientRelation := IT1ClientRelation				roleContext: self baseClass				roleName: aRoleName				role: (self typeFrom: aTypeString)				implementation: implementation				explanation: anExplanation.	self class errorSignal		handle:			[:ex |			self classDefinitionAlertFor: aRoleName implementation: implementation.			ex return]		do:			[(self checkCompatibilityOfClientRelation: newClientRelation)				ifFalse: [self class compatibilityErrorSignal raise].			clientRelationDeclarations addClientRelation: newClientRelation.			self updateClientRelationsSpec]</body><body package="ICCIncrementalTypes">declareVarClientRelation: relationName role: typeString implementation: implementation explanation: comment	"^&lt;current&gt;	relationName 	&lt;String&gt;	typeString 		&lt;String&gt; describing the role of the client relation; any unbound	references in the type string are resolved within my class context.	implementation	&lt;Symbol&gt;	comment 		&lt;String | nil&gt;"	| theRelationName |	theRelationName := implementation == #classVar				ifTrue: [self capitalizedFor: relationName]				ifFalse: [relationName].	ClassBuilder errorSignal		handle:			[:ex |			self classDefinitionAlertFor: theRelationName implementation: implementation.			ex return]		do:			[self adBasics systemOrganization				addVariableNamed: theRelationName				to: self baseClass				implementation: implementation.			(IT1VariableDeclarations on: self baseClass)				declareVariable: theRelationName				role: typeString				implementation: implementation				explanation: comment]</body><body package="ICCIncrementalTypes">removeClientRelation: aRoleName implementation: anImplementation	(self itTypes class varImplementationTypes includes: anImplementation)		ifTrue: [self removeVarClientRelation: aRoleName implementation: anImplementation]		ifFalse: [self removeNonVarClientRelation: aRoleName implementation: anImplementation].	self baseClass invalidateTypeDeclarations</body><body package="ICCIncrementalTypes">removeNonVarClientRelation: aRoleName implementation: anImplementation	self clientRelationDeclarations removeClientRelation: aRoleName implementation: anImplementation.	self updateClientRelationsSpec</body><body package="ICCIncrementalTypes">removeVarClientRelation: aRoleName implementation: implementation	ClassBuilder errorSignal		handle:			[:ex |			self classDefinitionAlertFor: aRoleName implementation: implementation.			ex return]		do:			[self adBasics systemOrganization				removeVariableNamed: aRoleName				from: self baseClass				implementation: implementation.			(IT1VariableDeclarations on: self baseClass)				removeVariable: aRoleName implementation: implementation]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>private-validity</category><body package="ICCIncrementalTypes">localValidityErrorsHeader	^('Declaration errors in class &lt;1p&gt;:&lt;n&gt;' expandMacrosWith: self baseClass printString)		, self separatorLine</body><body package="ICCIncrementalTypes">nonlocalValidityErrorsHeader	^('Declaration errors related to class &lt;1p&gt;:&lt;n&gt;' expandMacrosWith: self baseClass printString)		, self separatorLine</body><body package="ICCIncrementalTypes">separatorLine	^'--------------------------------------------------------------------------------'</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>variable values</category><body package="ICCIncrementalTypes">clientRelationTypeOf: aRoleName implementation: anImplementation	"^&lt;ITTypeScheme | nil&gt;	Triggers elaboration of declarations if necessary."	| clientRelationDecls |	clientRelationDecls := self clientRelationDeclarations.	^clientRelationDecls isNil		ifTrue: [nil]		ifFalse: [clientRelationDecls				atRoleName: aRoleName				implementation: anImplementation				inEnvironment: self classType typeEnvironment]</body><body package="ICCIncrementalTypes">locallyDefinedClientRelationTypeOf: aRoleName implementation: anImplementation	"^&lt;ITTypeScheme | nil&gt;	Triggers elaboration of declarations if necessary."	| clientRelationDecls |	clientRelationDecls := self clientRelationDeclarations.	^clientRelationDecls isNil		ifTrue: [nil]		ifFalse: [clientRelationDecls				atLocallyDefinedRoleName: aRoleName				ofImplementation: anImplementation				inEnvironment: self classType typeEnvironment]</body><body package="ICCIncrementalTypes">locallyDefinedClientRelationsOfImplementation: anImplementation	"^&lt;Set of: String&gt;	Return all class instance variable names which have been defined within the local scope of the base	class."	| clientRelationDecls |	clientRelationDecls := self clientRelationDeclarations.	^clientRelationDecls isNil		ifTrue: [Set new]		ifFalse: [clientRelationDecls locallyDefinedClientRelationsOfImplementation: anImplementation]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>validity</category><body package="ICCIncrementalTypes">fullValidityReport	"^&lt;IT1TypeReport&gt;"	| resultReport localValidityReport nonlocalValidityReport |	resultReport := IT1TypeReport new.	localValidityReport := self localValidityReport.	nonlocalValidityReport := self nonlocalValidityReport.	localValidityReport isEmpty ifFalse: [resultReport addError: self localValidityErrorsHeader; addAllErrors: localValidityReport errors].	nonlocalValidityReport isEmpty		ifFalse:			[resultReport isEmpty ifFalse: [resultReport addError: '\' withCRs].			resultReport addError: self nonlocalValidityErrorsHeader; addAllErrors: nonlocalValidityReport errors].	resultReport addError: '\\' withCRs.	^resultReport</body><body package="ICCIncrementalTypes">localValidityReport	^self typeDescriptor localValidityReport</body><body package="ICCIncrementalTypes">localValidityReport: aTypeReport	self typeDescriptor localValidityReport: aTypeReport</body><body package="ICCIncrementalTypes">nonlocalValidityReport	"^&lt;IT1TypeReport&gt; Answer the strictValidityReport with local errors removed."	^IT1TypeReport new		 addAllErrors: self strictValidityReport errors;		 removeAllErrors: self localValidityReport errors;		 yourself</body><body package="ICCIncrementalTypes">strictValidityReport	^self typeDescriptor strictValidityReport</body><body package="ICCIncrementalTypes">strictValidityReport: aTypeReport	self typeDescriptor strictValidityReport: aTypeReport</body><body package="ICCIncrementalTypes">strictValidityReportFrom: aStrictValidityReport and: aLocalValidityReport	"^&lt;IT1TypeReport&gt;"	aStrictValidityReport addAllErrors: aLocalValidityReport errors.	^(IT1TypeReport new) addAllErrors: aStrictValidityReport errors; yourself</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>elaboration</category><body package="ICCIncrementalTypes">completeElaboration: aTypeReport	"From superclass strict validity and local validity information, construct a new strict validity report. At this point it	is assumed that a superType has been fully elaborated."	| aStrictValidityReport |	aStrictValidityReport := self mergeStrictValidityReports: aTypeReport.	self strictValidityReport: (self strictValidityReportFrom: aStrictValidityReport and: self localValidityReport)</body><body package="ICCIncrementalTypes">elaborate	"^&lt;ITFullType&gt; Trigger the elaboration of declarations.	This is the entry point for a sequence of elaborations."	self isElaborated ifTrue: [^self].	^self elaborateInContext: nil</body><body package="ICCIncrementalTypes">elaborateInContext: anElaborationContext	"^&lt;ITFullType&gt;	Trigger the elaboration of declarations in a specific context. This elaboration is always successful."	^self isElaborated		ifTrue: [self]		ifFalse: [IT1TypeElaboration new elaborateFullType: self inContext: anElaborationContext]</body><body package="ICCIncrementalTypes">invalidateClientRelationsDeclaration	"^&lt;Boolean&gt;	Note that interface specifications are not affected."	| result |	(result := self isElaborated)		ifTrue:			[self classType: nil.			self clientRelationDeclarations: nil.			self typeDescriptor: nil].	^result</body><body package="ICCIncrementalTypes">superType	"^&lt;ITFullType |nil&gt;"	^self isRoot		ifTrue: [nil]		ifFalse: [self itTypes fullTypeOfClass: self baseClass superclass]</body><body package="ICCIncrementalTypes">superTypeClosureInContext: aTypeElaboration	"^&lt;ITFullType&gt;"	| fullSuperType |	self isRoot		ifTrue: [^self]		ifFalse:			[fullSuperType := self superType.			fullSuperType elaborateInContext: aTypeElaboration]</body><body package="ICCIncrementalTypes">typeVarElaborationValue: aTypeVarScope clientRelationElaborationValue: aClientRelationScope	"Sending this message means that the full type has been successfully elaborated. Thus,	create its associated type scheme."	self classType: (IT1ClassType masterClass: self baseClass baseClass: self baseClass).	self classType typeVariableScope: aTypeVarScope.	self clientRelationDeclarations: aClientRelationScope</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType</class-id> <category>specifications</category><body package="ICCIncrementalTypes">migrateToITClientRelationSpec	"^&lt;Boolean&gt;	Generate a method answering the client relation spec. Answers true if method creation was successfull."	| newMethodName oldMethodName oldMethodSource newMethodSource |	newMethodName := #itClientRelationsSpec.	oldMethodName := #clientRelationsSpec.	(Dialog confirm: 'Incompatible Relation Spec for Class ', self baseClass fullName, ' detected. Perform migration to current format?\If you choose ''no'', the client relations may not be visible.' withCRs)		ifTrue: [			oldMethodSource := (self baseClass class findSelector: oldMethodName) last getSource.			newMethodSource := oldMethodSource copy.			(Array 				with: (Array with: oldMethodName asString with: newMethodName asString) 				with: #('{ICC.ADvance.IT1ClientRelationScope}' '{ICC.IncrementalTypes.IT1ClientRelationScope}')				with: #('{ICC.ADvance.IT1ClientRelation}' '{ICC.IncrementalTypes.IT1ClientRelation}'))			do: [:eachPair | newMethodSource := newMethodSource copyReplaceAll: eachPair first with: eachPair last].			self baseClass class				compile: newMethodSource				classified: 'client relation specs'.			self baseClass class removeSelector: oldMethodName].	^self baseClass class includesSelector: newMethodName</body><body package="ICCIncrementalTypes">nonVarClientRelations	"^&lt;OrderedCollection of: ITClientRelation&gt; 	Retrieve itClientRelationsSpec from associated base class and 	build clientRelations from it. If such a spec does not exist but an 	older clientRelationsSpec does, user is asked whether migration 	shall be done."	^((self baseClass class includesSelector: #itClientRelationsSpec)		or: [(self baseClass class includesSelector: #clientRelationsSpec)				and: [self migrateToITClientRelationSpec]])		ifTrue: [self baseClass itClientRelationsSpec clientRelations]		ifFalse: [OrderedCollection new]</body><body package="ICCIncrementalTypes">updateClientRelationsSpec	"For all non-variable client relation specs, create a new specification."	clientRelationDeclarations save</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType class</class-id> <category>class initialization</category><body package="ICCIncrementalTypes">initialize	"self initialize"	CompatibilityErrorSignal := (Object errorSignal newSignalMayProceed: true)				notifierString: 'Type compatibility error';				nameClass: self message: #errorSignal;				yourself</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType class</class-id> <category>Signal constants</category><body package="ICCIncrementalTypes">compatibilityErrorSignal	^CompatibilityErrorSignal</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FullType class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">baseClass: aClass	"^&lt;ITFullType&gt; Create a new full type and elaborate it in a liberal way."	^self new baseClass: aClass; yourself</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecificationsStub</class-id> <category>elaboration</category><body package="ICCIncrementalTypes">invalidateTypeOf: aClass	"This is a stub that avoids malfunctions of system modifications after reinstalling ADvance.	Do nothing and answer false to indicate the nop."	^false</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications</class-id> <category>accessing types</category><body package="ICCIncrementalTypes">clientRelationDeclarationsOf: aClass	"&lt;ITClientRelationScope | nil&gt;"	^(self fullTypeOfClass: aClass) clientRelationDeclarations</body><body package="ICCIncrementalTypes">fullTypeOfClass: aClass	^self fullTypes at: aClass ifAbsent: [self createFullTypeEntry: aClass]</body><body package="ICCIncrementalTypes">typeVarDeclarationsOf: aClass	"&lt;ITTypeVariableScope|nil&gt;"	| typeSpec |	typeSpec := self fullTypeOfClass: aClass.	^typeSpec typeVarDeclarations</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications</class-id> <category>updating</category><body package="ICCIncrementalTypes">update: anAspect with: anObject 	"Depending on the ADvance preferences (and whether ADvance is 	loaded) comment or special class method becomes updated."	| shallUseComment theClassInfoSelector |	shallUseComment := (self respondsTo: #advance) not or: [self advance preferences general classInfoSource == #comment].	theClassInfoSelector := (self respondsTo: #advance)				ifTrue: [self advance preferences general classInfoSelector]				ifFalse: [nil].	(#(#addClass: #changeClass: #removeClass:) includes: anAspect)		ifTrue: [^anObject first invalidateTypeDeclarations].	(#commentClass: == anAspect and: [shallUseComment])		ifTrue: [^anObject first invalidateTypeDeclarations].	((#(#addSelector:class: #changeSelector:class: #removeSelector:class:) includes: anAspect)		and: [shallUseComment not and: [anObject first == theClassInfoSelector]])		ifTrue: [anObject last invalidateTypeDeclarations]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications</class-id> <category>initialize-release</category><body package="ICCIncrementalTypes">initialize	fullTypes := IdentityDictionary new</body><body package="ICCIncrementalTypes">reinitializeAll	"This discards all type information including interface specs."	(Dialog confirm: 'Do you really want to discard all type specifications including interface specs?\(You may use '' ITTypeSpecifications class&gt;&gt;#reinitializeDeclarations'' instead.)' withCRs)		ifTrue: [self initialize]</body><body package="ICCIncrementalTypes">reinitializeDeclarations	(Dialog confirm: 'Do you really want to discard\all type variable declarations?' withCRs)		ifTrue: [Class rootsOfTheWorld do: [:each | each invalidateTypeDeclarations]]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications</class-id> <category>utility</category><body package="ICCIncrementalTypes">checkTypesFor: aCollectionOfClasses	"Elaborate the type declarations for aCollectionOfClasses.	Open an error report if any error occured."	| errorReport aStream |	errorReport := IT1TypeReport new.	aStream := WriteStream on: (String new: 1000).	aCollectionOfClasses		do:			[:each |			| fullType |			each invalidateTypeDeclarations.			fullType := each fullType elaborate; yourself.			(fullType isStrictlyValid and: [fullType isLocallyValid])				ifFalse:					[| aReport |					aReport := fullType fullValidityReport.					errorReport addAllErrors: aReport errors.					aStream nextPutAll: aReport errorText]].	errorReport isEmpty		ifTrue: [^Dialog warn: 'State types successfully declared.']		ifFalse: [ComposedTextView				open: aStream contents asValue				label: 'Type Checking Report'				icon: nil				extent: 540 @ 400]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications</class-id> <category>private</category><body package="ICCIncrementalTypes">createFullTypeEntry: aClass	"^&lt;IT1FullType&gt;"	^self fullTypes at: aClass put: (IT1FullType baseClass: aClass)</body><body package="ICCIncrementalTypes">fullTypes	^fullTypes</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications</class-id> <category>elaboration</category><body package="ICCIncrementalTypes">invalidateTypeOf: aClass	"^&lt;Boolean&gt; Answer true if an elaboration has been successfully removed."	| aFullType |	aFullType := self fullTypes at: aClass ifAbsent: [^false].	^aFullType invalidateClientRelationsDeclaration</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications class</class-id> <category>utility</category><body package="ICCIncrementalTypes">implementationFor: anImplementationString	^self implementationTypes detect: [:each | anImplementationString = (self implementationStringFor: each)]</body><body package="ICCIncrementalTypes">implementationStringFor: anImplementation	^self implementationMapping at: anImplementation</body><body package="ICCIncrementalTypes">implementationsForBaseImplementation: anImplementation	anImplementation == #instVar ifTrue: [^#(#instVar #inheritedInstVar)].	anImplementation == #classInstVar ifTrue: [^#(#classInstVar #inheritedClassInstVar)].	^self error: 'Invalid implementation: ' , anImplementation printString</body><body package="ICCIncrementalTypes">typeStringFor: aClassName roleType: aRoleType	"^&lt;String&gt;"	| prefix |	prefix := aRoleType = 'Single Association'				ifTrue: ['']				ifFalse: [aRoleType = 'Dictionary'						ifTrue: ['Dictionary key: Object value: ']						ifFalse: [aRoleType = 'ValueHolder'								ifTrue: ['ValueHolder on: ']								ifFalse: [aRoleType , ' of: ']]].	^prefix , aClassName asString</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications class</class-id> <category>accessing</category><body package="ICCIncrementalTypes">default	Default isNil ifTrue: [self default: self new].	^Default</body><body package="ICCIncrementalTypes">default: typeSpecification	Default notNil ifTrue: [ChangeSet current removeDependent: Default].	Default := typeSpecification.	Default notNil ifTrue: [ChangeSet current addDependent: Default]</body><body package="ICCIncrementalTypes">implementationMapping	^ImplementationMapping</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications class</class-id> <category>constants</category><body package="ICCIncrementalTypes">associationTypeStrings	^#('Single Association' 'ValueHolder' 'Collection' 'OrderedCollection' 'SortedCollection' 'Set' 'Array' 'Dictionary')</body><body package="ICCIncrementalTypes">implementationTypeStrings	^self implementationTypes collect: [:each | self implementationMapping at: each]</body><body package="ICCIncrementalTypes">implementationTypes	^self varImplementationTypes , self nonVarImplementationTypes</body><body package="ICCIncrementalTypes">inheritedVarImplementationTypes	^#(#inheritedInstVar #inheritedClassInstVar)</body><body package="ICCIncrementalTypes">nonVarImplementationTypes	^#(#instQuery #classQuery)</body><body package="ICCIncrementalTypes">simpleVarImplementationTypes	^#(#instVar #classInstVar #classVar)</body><body package="ICCIncrementalTypes">varImplementationTypes	^self simpleVarImplementationTypes , self inheritedVarImplementationTypes</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">new	^super new initialize</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeSpecifications class</class-id> <category>class initialization</category><body package="ICCIncrementalTypes">initialize	"self initialize"	self default: self new.	self initializeImplementationMapping</body><body package="ICCIncrementalTypes">initializeImplementationMapping	"This method looks funny, because OSI forgot the method #withKeysAndValues: in the VW3.0	non-Envy."	| initialMappings |	initialMappings := #(#instVar 'Instance Variable' #classVar 'Class Variable' #classInstVar 'Class Instance Variable' #inheritedInstVar 'Inherited Instance Variable' #inheritedClassInstVar 'Inherited Class Instance Variable' #instQuery 'Instance Query' #classQuery 'Class Query').	ImplementationMapping := IdentityDictionary new: initialMappings size.	1		to: initialMappings size		by: 2		do: [:i | ImplementationMapping at: (initialMappings at: i)				put: (initialMappings at: i + 1)]</body><body package="ICCIncrementalTypes">obsolete	"This class is being removed from the system. Uninitialize the receiver."	self uninitialize.	super obsolete</body><body package="ICCIncrementalTypes">reinitializeAll	"self reinitializeAll"	self default reinitializeAll</body><body package="ICCIncrementalTypes">reinitializeDeclarations	"self reinitializeDeclarations"	self default reinitializeDeclarations</body><body package="ICCIncrementalTypes">uninitialize	self default notNil ifTrue: [self default initialize].	self default: nil</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelation</class-id> <category>testing</category><body package="ICCIncrementalTypes">hasInheritedImplementation	^self itTypes class inheritedVarImplementationTypes includes: self implementation</body><body package="ICCIncrementalTypes">hasNonVarImplementation	^self itTypes class nonVarImplementationTypes includes: implementation</body><body package="ICCIncrementalTypes">isMultiple	^self role isNil		ifTrue: [false]		ifFalse: [self role baseClass viewAsITCollectionType]</body><body package="ICCIncrementalTypes">isWrapped	^self role isNil		ifTrue: [false]		ifFalse: [self role baseClass viewAsITWrappedType]</body><body package="ICCIncrementalTypes">meta	"Determine whether anImplementation addresses class or instance."	^#(#classVar #classInstVar #classQuery) includes: self implementation</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelation</class-id> <category>private</category><body package="ICCIncrementalTypes">compatibilityError: typeRep	typeRep addError: 'Incompatibility for role ' , self roleName , '.'.	^nil</body><body package="ICCIncrementalTypes">fromLiteralArrayEncoding: anArray	super fromLiteralArrayEncoding: anArray.	roleContext := roleContext valueOrDo: [nil].	role := (IT1FullType baseClass: roleContext)				typeFrom: role</body><body package="ICCIncrementalTypes">implementationPrefix	| anImplementation |	anImplementation := self implementation.	anImplementation == #inheritedInstVar ifTrue: [^'\'].	anImplementation == #classInstVar ifTrue: [^'$'].	anImplementation == #inheritedClassInstVar ifTrue: [^'\$'].	anImplementation == #classQuery ifTrue: [^'$'].	^''</body><body package="ICCIncrementalTypes">literalArrayEncoding	^(Array new: 11)		at: 1 put: self class fullyQualifiedReference; 		at: 2 put: #roleContext:; at: 3 put: self roleContext fullyQualifiedReference;		at: 4 put: #roleName:; at: 5 put: self roleName;		at: 6 put: #role:; at: 7 put: self roleNotation;		at: 8 put: #implementation:; at: 9 put: self implementation;		at: 10 put: #explanation:; at: 11 put: self explanation;		yourself</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelation</class-id> <category>accessing</category><body package="ICCIncrementalTypes">explanation	"^&lt;String | nil&gt; 	Answers the value of the instance variable. If not already set and 	if possible, this becomes initialized from the current variable 	comment given in the class comment (resp. the advance info 	method)."	explanation isNil ifTrue: [explanation := (self roleName isNil or: [self implementation isNil])					ifTrue: [nil]					ifFalse: [self roleContext explanationOf: self roleName implementation: self implementation]].	^explanation</body><body package="ICCIncrementalTypes">explanation: anExplanation 	"anExplanation &lt;String&gt; 	Sets the instance variable's value. nil is ignored to force lazy 	initialization from class comment, see method #explanation."	anExplanation notNil 		ifTrue: [explanation := anExplanation]</body><body package="ICCIncrementalTypes">extendedRoleName	^self implementationPrefix , self roleName</body><body package="ICCIncrementalTypes">implementation	^implementation</body><body package="ICCIncrementalTypes">implementation: aValue	implementation := aValue</body><body package="ICCIncrementalTypes">implementationString	^self itTypes class implementationStringFor: self implementation</body><body package="ICCIncrementalTypes">multiplicity	^self isMultiple		ifTrue: ['*']		ifFalse: ['0..1']</body><body package="ICCIncrementalTypes">role	^role</body><body package="ICCIncrementalTypes">role: aValue	role := aValue</body><body package="ICCIncrementalTypes">roleClass	| base aConstructor relationType |	self role isNil ifTrue: [^nil].	base := self role baseClass.	^(self isMultiple or: [self isWrapped])		ifTrue:			["Look for the type of the relation constructor; take care: it may be 'free'."			aConstructor := base defaultTypeConstructor.			((relationType := self role closedTypeVarTypeOf: aConstructor) isNil or: [relationType isFree])				ifTrue: [nil]				ifFalse: [relationType baseClass]]		ifFalse: [base]</body><body package="ICCIncrementalTypes">roleContext	^roleContext</body><body package="ICCIncrementalTypes">roleContext: aClass	roleContext := aClass</body><body package="ICCIncrementalTypes">roleName	^roleName</body><body package="ICCIncrementalTypes">roleName: aValue	roleName := aValue</body><body package="ICCIncrementalTypes">roleNotation	| aStream |	aStream := WriteStream on: (String new: 16).	self role printNotationOn: aStream.	^aStream contents</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelation</class-id> <category>updating type</category><body package="ICCIncrementalTypes">updateTypeTo: typeString	"Update the receivers type. Try to avoid going through the class definition	and just manipulate the comment."	(self itTypes class varImplementationTypes includes: self implementation)		ifTrue: [(IT1VariableDeclarations on: self roleContext)				declareVariable: self roleName				role: typeString				implementation: self implementation				explanation: self explanation]		ifFalse: [self roleContext				declareClientRelation: self roleName				role: typeString				implementation: self implementation				explanation: self explanation].	self roleContext invalidateTypeDeclarations</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelation</class-id> <category>properties</category><body package="ICCIncrementalTypes">checkCompatibilityInContext: fullType typeRep: typeRep	"^&lt;Boolean&gt;"	| result |	(result := fullType checkCompatibilityOfClientRelation: self)		ifFalse:			[self compatibilityError: typeRep.			self role: nil].	^result</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelation</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">itTypes	^self class itTypes</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelation class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">roleContext: aClass roleName: aRoleName role: aTypeScheme implementation: anImplementation	^self		roleContext: aClass		roleName: aRoleName		role: aTypeScheme		implementation: anImplementation		explanation: nil</body><body package="ICCIncrementalTypes">roleContext: aClass roleName: aRoleName role: aTypeScheme implementation: anImplementation explanation: anExplanation	^self new		 roleContext: aClass;		 roleName: aRoleName;		 role: aTypeScheme;		 implementation: anImplementation;		 explanation: anExplanation;		 yourself</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelation class</class-id> <category>client relation specs</category><body package="ICCIncrementalTypes">itClientRelationsSpec	"^&lt;IT1ClientRelationsScope&gt; Answer a client relations scope."	^( #(#{ICC.IncrementalTypes.IT1ClientRelationScope}		#localScope: #{ICC.IncrementalTypes.IT1ClientRelation}		#clientRelations: #(			#(#{ICC.IncrementalTypes.IT1ClientRelation}				#roleContext: #{ICC.IncrementalTypes.IT1ClientRelation}				#roleName: 't1'				#role: 'ICC.ADvance.IT1TypeVariableScope'				#implementation: #instQuery				#explanation: nil ) ) ) ) decodeAsLiteralArray</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeDescriptor</class-id> <category>validity</category><body package="ICCIncrementalTypes">localValidityReport	localValidityReport isNil ifTrue: [localValidityReport := IT1TypeReport new].	^localValidityReport</body><body package="ICCIncrementalTypes">localValidityReport: aTypeReport	localValidityReport := aTypeReport</body><body package="ICCIncrementalTypes">strictValidityReport	strictValidityReport isNil ifTrue: [strictValidityReport := IT1TypeReport new].	^strictValidityReport</body><body package="ICCIncrementalTypes">strictValidityReport: aTypeReport	strictValidityReport := aTypeReport</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeDescriptor</class-id> <category>initialize-release</category><body package="ICCIncrementalTypes">forFullType: aFullType	fullType := aFullType.</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeDescriptor</class-id> <category>accessing</category><body package="ICCIncrementalTypes">fullType	^fullType</body><body package="ICCIncrementalTypes">typeRep	self localValidityReport isNil ifTrue: [self localValidityReport: IT1TypeReport new].	^self localValidityReport</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeDescriptor</class-id> <category>testing</category><body package="ICCIncrementalTypes">isLocallyValid	^self localValidityReport isEmpty</body><body package="ICCIncrementalTypes">isStrictlyValid	^self strictValidityReport isEmpty</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeDescriptor class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">forFullType: aFullType	| obj |	obj := self new.	obj forFullType: aFullType.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType</class-id> <category>printing</category><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean	self union do: [:each | each printNotationOn: aStream showNamespaces: aBoolean]		separatedBy: [aStream nextPutAll: ' | ']</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType</class-id> <category>compatibility</category><body package="ICCIncrementalTypes">in: myEnv satisfiedBy: aTypeScheme in: aTypeSchemeEnv matchContext: matchContext	"^&lt;ITMatchContext | nil&gt;"	| ok |	aTypeScheme isFree ifTrue: [^matchContext].	ok := true.	self union do: [:aType | (aType			in: myEnv			satisfiedBy: aTypeScheme			in: aTypeSchemeEnv			matchContext: matchContext) isNil ifTrue: [ok := false]].	^ok		ifTrue: [matchContext]		ifFalse: [self unionTypeDoesNotMatchError: matchContext typeRep]</body><body package="ICCIncrementalTypes">in: myEnv satisfies: aTypeScheme in: aTypeSchemeEnv matchContext: matchContext	"^&lt;ITMatchContext | nil&gt;"	| ok |	ok := true.	self union do: [:oneOfMyTypes | ok := ok &amp; (aTypeScheme						in: aTypeSchemeEnv						satisfiedBy: oneOfMyTypes						in: myEnv						matchContext: matchContext) notNil].	^ok		ifTrue: [matchContext]		ifFalse: [self unionTypeNotMatchedError: matchContext typeRep]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType</class-id> <category>private</category><body package="ICCIncrementalTypes">commonSuperclassOf: aClass1 and: aClass2	"^&lt;Class&gt;	Find the nearest common superclass. Discard UndefinedObject. It is	assumed that in many cases aClass2 is	UndefinedObject."	aClass2 == UndefinedObject ifTrue: [^aClass1].	aClass1 == UndefinedObject ifTrue: [^aClass2].	(aClass1 includesBehavior: aClass2)		ifTrue: [^aClass2].	(aClass2 includesBehavior: aClass1)		ifTrue: [^aClass1].	aClass1 superclass isNil ifTrue: [^Object].	^self commonSuperclassOf: aClass1 superclass and: aClass2</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType</class-id> <category>accessing</category><body package="ICCIncrementalTypes">baseClass	"^&lt;Class&gt;	The base class of a union type is defined as the common superclass of	all base classes of union elements. This	is a default which may be improved. Special treatment is given to nil: It	is discarded unless it is the only type	the union type merges to."	^self union inject: self union first baseClass into: [:tempUnion :next | self commonSuperclassOf: tempUnion and: next baseClass]</body><body package="ICCIncrementalTypes">closedTypeVarTypeOf: typeVarName	"^&lt;ITTypeScheme | nil&gt;	This method yields a closed type scheme associated with the type variable binding of typeVarName	in the context 	of the union type's base class. This property is only valid if there is exactly one	union type component with the same base class as the union type's base class."	| unionBaseClass baseTypes |	unionBaseClass := self baseClass.	baseTypes := self union select: [:each | each baseClass == unionBaseClass].	^baseTypes size = 1		ifTrue: [baseTypes first closedTypeVarTypeOf: typeVarName]		ifFalse: [nil]</body><body package="ICCIncrementalTypes">union	^union</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType</class-id> <category>adding</category><body package="ICCIncrementalTypes">addTypeScheme: aTypeScheme	self union add: aTypeScheme</body><body package="ICCIncrementalTypes">addUnionType: aUnionType	self union addAll: aUnionType union</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType</class-id> <category>error messages</category><body package="ICCIncrementalTypes">unionTypeDoesNotMatchError: typeRep	typeRep addError: 'Union type does not match.'.	^nil</body><body package="ICCIncrementalTypes">unionTypeNotMatchedError: typeRep	typeRep addError: 'Union type is not matched.'.	^nil</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType</class-id> <category>testing</category><body package="ICCIncrementalTypes">hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext	^self union contains: [:typeScheme | typeScheme hasTypeVarRecursion: aTypeVarName inElaborationContext: elabContext]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType</class-id> <category>initialize-release</category><body package="ICCIncrementalTypes">initialize	super initialize.	union := OrderedCollection new</body></methods><methods><class-id>ICC.IncrementalTypes.IT1UnionType class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">with: aTypeScheme	^(self masterClass: aTypeScheme masterClass)		addTypeScheme: aTypeScheme; yourself</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope</class-id> <category>vars</category><body package="ICCIncrementalTypes">classInstVars	^self varsWithImplementation: #classInstVar</body><body package="ICCIncrementalTypes">classInstVars: namesAndSemantics	self addAsClientRelations: namesAndSemantics implementation: #classInstVar</body><body package="ICCIncrementalTypes">classVars	^self varsWithImplementation: #classVar</body><body package="ICCIncrementalTypes">classVars: namesAndSemantics	self addAsClientRelations: namesAndSemantics implementation: #classVar</body><body package="ICCIncrementalTypes">inheritedClassInstVars: namesAndSemantics	self addAsClientRelations: namesAndSemantics implementation: #inheritedClassInstVar</body><body package="ICCIncrementalTypes">inheritedInstVars: namesAndSemantics	self addAsClientRelations: namesAndSemantics implementation: #inheritedInstVar</body><body package="ICCIncrementalTypes">instVars	^self varsWithImplementation: #instVar</body><body package="ICCIncrementalTypes">instVars: namesAndSemantics	self addAsClientRelations: namesAndSemantics implementation: #instVar</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope</class-id> <category>private</category><body package="ICCIncrementalTypes">fromLiteralArrayEncoding: anArray	2		to: anArray size		by: 2		do: [:i | self perform: (anArray at: i)				with: (anArray at: i + 1)].	localScope := localScope valueOrDo: [nil].	clientRelations := clientRelations collect: [:each | each decodeAsLiteralArray]</body><body package="ICCIncrementalTypes">literalArrayEncoding	"^&lt;Array&gt;"	^(Array new: 5)		at: 1 put: self class fullyQualifiedReference;		at: 2 put: #localScope:; at: 3 put: self localScope fullyQualifiedReference;		at: 4 put: #clientRelations:; at: 5 put: (self nonVarClientRelations asArray collect: [:each | each literalArrayEncoding]);		yourself</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope</class-id> <category>specifications</category><body package="ICCIncrementalTypes">save	"Generate a method answering my reincarnation."	| methodName s |	methodName := #itClientRelationsSpec.	s := (String new: 1024) writeStream.	s		 nextPutAll: methodName;		 crtab;		 nextPutAll: '"^&lt;IT1ClientRelationsScope&gt; Answer a client relations scope."';		 cr;		 crtab;		 nextPutAll: '^( '.	UISpecification		prettyPrintSpecArray: self literalArrayEncoding		on: s		tabLevel: 1.	s nextPutAll: ' ) decodeAsLiteralArray'.	self adBasics systemOrganization		compile: s contents		classified: nil		for: self localScope class</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope</class-id> <category>adding-removing</category><body package="ICCIncrementalTypes">addAsClientRelations: namesAndSemantics implementation: anImplementation	namesAndSemantics do: [:each | self addClientRelation: (IT1ClientRelation				roleContext: self localScope				roleName: each key				role: each value				implementation: anImplementation)]</body><body package="ICCIncrementalTypes">addClientRelation: aClientRelation	"The first line leads to side effect considerations on aClientRelation!"	aClientRelation roleContext: self localScope.	self clientRelations add: aClientRelation</body><body package="ICCIncrementalTypes">addClientRelations: aClientRelationsCollection	aClientRelationsCollection do: [:each | self addClientRelation: each]</body><body package="ICCIncrementalTypes">removeClientRelation: aRoleName implementation: anImplementation	self clientRelations removeAllSuchThat: [:each | each roleName = aRoleName and: [each implementation = anImplementation]]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope</class-id> <category>accessing</category><body package="ICCIncrementalTypes">clientRelations	^clientRelations</body><body package="ICCIncrementalTypes">clientRelations: aCollectionOfClientRelations	clientRelations := aCollectionOfClientRelations</body><body package="ICCIncrementalTypes">itTypes	^self class itTypes</body><body package="ICCIncrementalTypes">localScope	^localScope</body><body package="ICCIncrementalTypes">localScope: aClass	localScope := aClass</body><body package="ICCIncrementalTypes">locallyDefinedClientRelationsOfImplementation: anImplementation	"^&lt;Set of: String&gt;"	^(self rolesWithImplementation: anImplementation) keys</body><body package="ICCIncrementalTypes">nonVarClientRelations	^self clientRelations select: [:ea | ea hasNonVarImplementation]</body><body package="ICCIncrementalTypes">rolesWithImplementation: anImplementation	"^&lt;Dictionary key: String value: ITTypeScheme&gt;"	| dict |	dict := Dictionary new.	self clientRelations do: [:each | each implementation == anImplementation ifTrue: [dict at: each roleName put: each role]].	^dict</body><body package="ICCIncrementalTypes">varsWithBaseImplementation: anImplementation	"^&lt;Dictionary key: String value: ITTypeScheme&gt;"	| dict implementations |	dict := Dictionary new.	implementations := self itTypes class implementationsForBaseImplementation: anImplementation.	self clientRelations do: [:each | (implementations includes: each implementation)			ifTrue: [dict at: each roleName put: each role]].	^dict</body><body package="ICCIncrementalTypes">varsWithImplementation: anImplementation	"^&lt;Dictionary key: String value: ITTypeScheme&gt;"	| dict |	dict := Dictionary new.	self clientRelations do: [:each | each implementation == anImplementation ifTrue: [dict at: each roleName put: each role]].	^dict</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope</class-id> <category>state variable properties</category><body package="ICCIncrementalTypes">atLocallyDefinedRoleName: aRoleName ofImplementation: anImplementation inEnvironment: aTypeEnvironment	"^&lt;ITTypeScheme | nil &gt;"	| val |	val := (self rolesWithImplementation: anImplementation)				at: aRoleName ifAbsent: [^nil].	^val closureIn: aTypeEnvironment</body><body package="ICCIncrementalTypes">atRoleName: aRoleName baseImplementation: anImplementation inEnvironment: aTypeEnvironment	"^&lt;ITTypeScheme | nil &gt;"	| val |	(val := (self varsWithBaseImplementation: anImplementation)				at: aRoleName ifAbsent: [nil]) isNil ifTrue: [^self outerScope isNil			ifTrue: [nil]			ifFalse: [self outerScope					atRoleName: aRoleName					implementation: anImplementation					inEnvironment: aTypeEnvironment]].	^val closureIn: aTypeEnvironment</body><body package="ICCIncrementalTypes">atRoleName: aRoleName implementation: anImplementation inEnvironment: aTypeEnvironment	"^&lt;ITTypeScheme | nil &gt;"	| val |	(val := (self varsWithImplementation: anImplementation)				at: aRoleName ifAbsent: [nil]) isNil ifTrue: [^self outerScope isNil			ifTrue: [nil]			ifFalse: [self outerScope					atRoleName: aRoleName					implementation: anImplementation					inEnvironment: aTypeEnvironment]].	^val closureIn: aTypeEnvironment</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope</class-id> <category>initialize-release</category><body package="ICCIncrementalTypes">initialize	clientRelations := OrderedCollection new</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope class</class-id> <category>private</category><body package="ICCIncrementalTypes">decodeFromLiteralArray: anArray	^self new fromLiteralArrayEncoding: anArray</body></methods><methods><class-id>ICC.IncrementalTypes.IT1ClientRelationScope class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">outerScope: anOuterScope localScope: aClass	| obj |	obj := self outerScope: anOuterScope.	obj localScope: aClass.	obj initialize.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeReport</class-id> <category>accessing</category><body package="ICCIncrementalTypes">errorText	| aStream |	aStream := (String new: 100) writeStream.	self errors do: [:each | aStream nextPutAll: each; cr].	^aStream contents</body><body package="ICCIncrementalTypes">errors	errors isNil ifTrue: [errors := OrderedCollection new].	^errors</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeReport</class-id> <category>adding-removing</category><body package="ICCIncrementalTypes">addAllErrors: aCollectionOfStrings	aCollectionOfStrings do: [:each | self addError: each]</body><body package="ICCIncrementalTypes">addError: aString	| emptyLineString |	emptyLineString := '\' withCRs.	(aString = emptyLineString or: [(self errors includes: aString) not])		ifTrue: [errors add: aString]</body><body package="ICCIncrementalTypes">errorsAddFirst: aString	(self errors includes: aString)		ifFalse: [errors addFirst: aString]</body><body package="ICCIncrementalTypes">removeAllErrors: aCollectionOfStrings	aCollectionOfStrings do: [:each | errors remove: each ifAbsent: []]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeReport</class-id> <category>initialize-release</category><body package="ICCIncrementalTypes">reinitialize	errors := nil</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeReport</class-id> <category>testing</category><body package="ICCIncrementalTypes">isEmpty	^self errors isEmpty</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>error messages</category><body package="ICCIncrementalTypes">classDeclarationRecursionError	self typeRep addError: 'Recursion error: ''' , self masterClassName , ''' is referring (in-)directly to itself.'.	^nil</body><body package="ICCIncrementalTypes">inheritedStateVariableDeclarationError: anImplementation var: varName	self typeRep addError: ('&lt;1s&gt; &lt;2p&gt; in class &lt;3p&gt; is defined without superclass definition.'			expandMacrosWith: (self itTypes class implementationStringFor: anImplementation)			with: varName			with: self masterClassName).	^nil</body><body package="ICCIncrementalTypes">inheritedStateVariableDeclarationSemanticsError	self typeRep errorsAddFirst: 'Error occured during creation of inherited state variable semantics for class ''' , self masterClassName , '''.'.	^nil</body><body package="ICCIncrementalTypes">inheritedStateVariableDeclarationSyntaxError	self typeRep addError: 'Syntax error in inherited state variable declarations of class ''' , self masterClassName , '''.'.	^nil</body><body package="ICCIncrementalTypes">nonVarClientRelationsError	self typeRep addError: 'There is an incompatibility for query client relations with supertype definitions.'.	^nil</body><body package="ICCIncrementalTypes">notAValidTypeError: aName	self typeRep addError: '''' , aName , ''' is neither an existing type nor a valid type variable name.'</body><body package="ICCIncrementalTypes">stateVariableDeclarationError: anImplementation var: varName	self typeRep addError: (self itTypes class implementationStringFor: anImplementation)			, ' ''' , varName , ''' in class ''' , self masterClassName , ''' is not properly declared.'.	^nil</body><body package="ICCIncrementalTypes">stateVariableDeclarationSemanticsError	self typeRep errorsAddFirst: 'Error occured during state variable semantics creation for class ''' , self masterClassName , '''.'.	^nil</body><body package="ICCIncrementalTypes">stateVariableDeclarationSyntaxError	self typeRep addError: 'Syntax error in state variable declarations of class ''' , self masterClassName , '''.'.	^nil</body><body package="ICCIncrementalTypes">typeVariableDeclarationError: varName	self typeRep addError: 'Type variable ''', varName , ''' in class ''' , self masterClassName , ''' is not properly declared.'.	^nil</body><body package="ICCIncrementalTypes">typeVariableDeclarationSemanticsError	self typeRep errorsAddFirst: 'Error occured during type variable semantics creation for  class ''' , self masterClassName , '''.'.	^nil</body><body package="ICCIncrementalTypes">typeVariableDeclarationSyntaxError	self typeRep addError: 'Syntax error in type variable declarations of class ''' , self masterClassName , '''.'.	^nil</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>semantics creation</category><body package="ICCIncrementalTypes">createInheritedStateVarSemantics: analyzer	"analyzer &lt;OrderedCollection of: (Association key: String value: ProgramNode)&gt;"	| vars |	vars := self				redefineSemanticsFor: #inheritedInstVar				redefiningVars: analyzer inheritedInstVars				stateVars: self clientRelationDeclarations instVars.	self clientRelationDeclarations inheritedInstVars: vars.	vars := self				redefineSemanticsFor: #inheritedClassInstVar				redefiningVars: analyzer inheritedClassInstVars				stateVars: self clientRelationDeclarations classInstVars.	self clientRelationDeclarations inheritedClassInstVars: vars</body><body package="ICCIncrementalTypes">createNonVarClientRelationsSemantics	| myNonVarClientRelations |	myNonVarClientRelations := self fullType nonVarClientRelations.	myNonVarClientRelations do: [:each | each checkCompatibilityInContext: self fullType typeRep: self typeRep].	self clientRelationDeclarations addClientRelations: myNonVarClientRelations</body><body package="ICCIncrementalTypes">createSemanticsFor: implementation varDefs: stateVars	"^&lt;OrderedCollection of: (Association key: String value: (ITTypeScheme | nil))&gt;	For every variable which has been found declared, a semantics is created -- possibly nil."	^stateVars		collect:			[:assoc |			| sem varName typeExpr |			varName := assoc key.			typeExpr := assoc value.			sem := nil.			typeExpr notNil				ifTrue:					[sem := typeExpr typeSemanticsInElaborationContext: self.					sem isNil ifTrue: [self stateVariableDeclarationError: implementation var: varName]].			varName -&gt; sem]</body><body package="ICCIncrementalTypes">createStateVarSemantics: analyzer	"analyzer &lt;OrderedCollection of: (Association key: String value: ProgramNode)&gt;"	self clientRelationDeclarations		 instVars: (self createSemanticsFor: #instVar varDefs: analyzer instVars);		 classVars: (self createSemanticsFor: #classVar varDefs: analyzer classVars);		 classInstVars: (self createSemanticsFor: #classInstVar varDefs: analyzer classInstVars)</body><body package="ICCIncrementalTypes">createTypeVarSemantics: typeVars	"^&lt;current&gt;	typeVars &lt;OrderedCollection of: (Association key: String value: ProgramNode)&gt;	If necessary, a new scope for type variable declarations is created. Note that in case of type variable	recursion, semantics is undefined."	| varName sem outerScopeVal match typeExpr |	typeVars isEmpty ifTrue: [^self].	typeVars		do:			[:assoc |			varName := assoc key.			typeExpr := assoc value.			sem := typeExpr typeSemanticsInElaborationContext: self.			sem notNil				ifTrue: [(sem hasTypeVarRecursion: varName inElaborationContext: self)						ifTrue: [sem := nil]						ifFalse:							[outerScopeVal := self typeEnvironment atTypeVarName: varName.							outerScopeVal notNil								ifTrue:									[match := outerScopeVal												in: self typeEnvironment												satisfiedBy: sem												in: self typeEnvironment												matchContext: (IT1Inferencing typeRep: self typeRep).									match isNil ifTrue: [self typeVariableDeclarationError: varName]]]]				ifFalse: [self typeVariableDeclarationError: varName].			self typeVarDeclarations addTypeVar: varName -&gt; sem]</body><body package="ICCIncrementalTypes">redefineSemanticsFor: implementation redefiningVars: redefinedVars stateVars: stateVars	"^&lt;OrderedCollection of: (Association key: String value: (ITTypeScheme | nil))&gt;	"	^redefinedVars		collect:			[:assoc |			| sem varName typeExpr |			varName := assoc key.			typeExpr := assoc value.			sem := nil.			typeExpr notNil				ifTrue:					[sem := typeExpr typeSemanticsInElaborationContext: self.					sem isNil						ifTrue: [self stateVariableDeclarationError: implementation var: varName]						ifFalse: [(implementation == #inheritedInstVar								ifTrue: [self clientRelationDeclarations										atRoleName: varName										baseImplementation: #instVar										inEnvironment: self typeEnvironment]								ifFalse: [self clientRelationDeclarations										atRoleName: varName										baseImplementation: #classInstVar										inEnvironment: self typeEnvironment]) isNil								ifTrue:									[sem := nil.									self inheritedStateVariableDeclarationError: implementation var: varName]]].			varName -&gt; sem]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>class elaboration</category><body package="ICCIncrementalTypes">checkElaborationRecursionFor: aClass	"^&lt;Boolean&gt; Check if aClass is mentioned in my elab history."	| hasRecursion |	hasRecursion := self elaborationHistory contains: [:each | aClass includesBehavior: each baseClass].	hasRecursion ifTrue: [self classDeclarationRecursionError].	^hasRecursion</body><body package="ICCIncrementalTypes">checkForClassElaborationRecursionInContext: elabContext	"^&lt;Boolean&gt; Check if I am evaluating a class recursively."	| mc hasRecursion |	elabContext isNil ifTrue: [^false].	mc := self baseClass.	hasRecursion := elabContext elaborationHistory contains: [:each | mc includesBehavior: each baseClass].	hasRecursion ifTrue: [self classDeclarationRecursionError].	^hasRecursion</body><body package="ICCIncrementalTypes">elaborate	"^&lt;ITFullType&gt;	Elaborate my variable declarations and create appropriate semantics."	self elaborateTypeVariables.	self elaborateStateVariables.	self elaborateInheritedStateVariables.	self elaborateClientRelationsSpec.	self fullTypeCompletion.	^self fullType</body><body package="ICCIncrementalTypes">elaborateClientRelationsSpec	self createNonVarClientRelationsSemantics.	self typeRep isEmpty ifTrue: [^self].	self nonVarClientRelationsError.	self fullTypeLocalValidityUpdate</body><body package="ICCIncrementalTypes">elaborateInheritedStateVariables	"Define semantics for those inherited variable declarations found.	Semantics is defined independent of inconsistencies possibly found."	| analyzer cmt |	analyzer := IT1VariableDeclarations on: self masterClass.	cmt := self infoString.	analyzer checkInheritedVars: cmt typeRep: self typeRep.	self typeRep isEmpty		ifFalse:			[self inheritedStateVariableDeclarationSyntaxError.			self fullTypeLocalValidityUpdate].	self createInheritedStateVarSemantics: analyzer.	self typeRep isEmpty ifTrue: [^self].	self inheritedStateVariableDeclarationSemanticsError.	self fullTypeLocalValidityUpdate</body><body package="ICCIncrementalTypes">elaborateStateVariables	"Define semantics for those state variable declarations found.	Semantics is defined independent of inconsistencies possibly found."	| cmt analyzer |	cmt := self infoString.	analyzer := IT1VariableDeclarations on: self masterClass.	analyzer checkVars: cmt typeRep: self typeRep.	self typeRep isEmpty		ifFalse:			[self stateVariableDeclarationSyntaxError.			self fullTypeLocalValidityUpdate].	self createStateVarSemantics: analyzer.	self typeRep isEmpty ifTrue: [^self].	self stateVariableDeclarationSemanticsError.	self fullTypeLocalValidityUpdate</body><body package="ICCIncrementalTypes">elaborateTypeVariables	"Define semantics for those type variable declarations found. Semantics is defined	independent of inconsistencies possibly found."	| analyzer |	(self fullType baseClass class includesSelector: #genericTypeConstructors)		ifFalse: [^self].	analyzer := IT1VariableDeclarations on: self masterClass.	analyzer checkTypeVars: self fullType baseClass genericTypeConstructors typeRep: self typeRep.	self typeRep isEmpty		ifFalse:			[self typeVariableDeclarationSyntaxError.			self fullTypeLocalValidityUpdate].	self createTypeVarSemantics: analyzer typeVars.	self typeRep isEmpty ifTrue: [^self].	self typeVariableDeclarationSemanticsError.	self fullTypeLocalValidityUpdate</body><body package="ICCIncrementalTypes">elaborationHistoryFrom: aTypeElaboration	aTypeElaboration isNil		ifTrue: [elaborationHistory := OrderedCollection new]		ifFalse:			[elaborationHistory := aTypeElaboration elaborationHistory copy.			elaborationHistory add: self fullType]</body><body package="ICCIncrementalTypes">fullTypeCompletion	"Complete definition of full type, including completeness information."	self fullType typeVarElaborationValue: self typeVarDeclarations clientRelationElaborationValue: self clientRelationDeclarations.	self fullType completeElaboration: self strictValidityReport</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>testing</category><body package="ICCIncrementalTypes">isDefined: aTypeVarName	^self typeEnvironment isDefined: aTypeVarName</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>validity</category><body package="ICCIncrementalTypes">addStrictValidityErrors: errors	self strictValidityReport addAllErrors: errors</body><body package="ICCIncrementalTypes">strictValidityReport	strictValidityReport isNil ifTrue: [strictValidityReport := IT1TypeReport new].	^strictValidityReport</body><body package="ICCIncrementalTypes">updateStrictValidityReport: aTypeRep	aTypeRep isNil ifFalse: [self addStrictValidityErrors: aTypeRep errors]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>accessing</category><body package="ICCIncrementalTypes">baseClass	^self fullType baseClass</body><body package="ICCIncrementalTypes">clientRelationDeclarations	^clientRelationDeclarations</body><body package="ICCIncrementalTypes">clientRelationDeclarations: aClientRelationScope	clientRelationDeclarations := aClientRelationScope</body><body package="ICCIncrementalTypes">elaborationHistory	^elaborationHistory</body><body package="ICCIncrementalTypes">fullType	^fullType</body><body package="ICCIncrementalTypes">fullType: aFullType	fullType := aFullType</body><body package="ICCIncrementalTypes">infoString	"Return the string this program will extract type information from."	^self masterClass infoString</body><body package="ICCIncrementalTypes">localValidityReport	^localValidityReport</body><body package="ICCIncrementalTypes">masterClass	^self fullType baseClass</body><body package="ICCIncrementalTypes">masterClassName	^self masterClass name asString</body><body package="ICCIncrementalTypes">typeEnvironment	^typeEnvironment</body><body package="ICCIncrementalTypes">typeRep	^self localValidityReport</body><body package="ICCIncrementalTypes">typeVarDeclarations	^typeVarDeclarations</body><body package="ICCIncrementalTypes">typeVarDeclarations: aTypeVariableScope	typeVarDeclarations := aTypeVariableScope</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>private</category><body package="ICCIncrementalTypes">fullTypeLocalValidityUpdate	self fullType localValidityReport addAllErrors: self localValidityReport errors.	self localValidityReport reinitialize</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>initialize-release</category><body package="ICCIncrementalTypes">clientRelationsOuterScope	^self fullType clientRelationsOuterScope</body><body package="ICCIncrementalTypes">elaborateFullType: aFullType inContext: aTypeElaboration	"^&lt;ITFullType&gt;	Stop elaboration if there is a recursion error. Otherwise, trigger elaboration of a type's	supertypes.	Note that initialization of my own state and type variable declarations refers to supertype	declarations."	fullType := aFullType.	localValidityReport := IT1TypeReport new.	self elaborationHistoryFrom: aTypeElaboration.	(self checkForClassElaborationRecursionInContext: aTypeElaboration)		ifTrue:			[aTypeElaboration updateStrictValidityReport: self typeRep.			^aFullType].	aFullType superTypeClosureInContext: self.	self initializeDeclarationScope.	typeEnvironment := self makeTypeEnvironment.	^self elaborate</body><body package="ICCIncrementalTypes">initializeDeclarationScope	self clientRelationDeclarations: (IT1ClientRelationScope outerScope: self clientRelationsOuterScope localScope: self fullType baseClass).	self typeVarDeclarations: (IT1TypeVariableScope outerScope: self typeVarOuterScope)</body><body package="ICCIncrementalTypes">makeTypeEnvironment	^IT1TypeEnvironment closureOn: self typeVarDeclarations masterClass: self masterClass</body><body package="ICCIncrementalTypes">typeVarOuterScope	^self fullType typeVarOuterScope</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">itTypes	^self class itTypes</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration</class-id> <category>type expression elaboration</category><body package="ICCIncrementalTypes">elaborateParsedTypeExpression: aParseNode inClassContext: aClass	"^&lt;ITTypeScheme|nil&gt;"	fullType := self itTypes fullTypeOfClass: aClass.	localValidityReport := IT1TypeReport new.	self elaborationHistoryFrom: nil.	self typeVarDeclarations: (IT1TypeVariableScope outerScope: self typeVarOuterScope).	typeEnvironment := IT1TypeEnvironment closureOn: self typeVarDeclarations masterClass: self masterClass.	^aParseNode typeSemanticsInElaborationContext: self</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeElaboration class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">elaborateParsedTypeExpression: aParseNode inClassContext: aClass	^self new elaborateParsedTypeExpression: aParseNode inClassContext: aClass</body><body package="ICCIncrementalTypes">forFullType: aFullType	^self new fullType: aFullType</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FreeType</class-id> <category>printing</category><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean	aStream nextPutAll: 'free'</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FreeType</class-id> <category>compatibility</category><body package="ICCIncrementalTypes">in: myEnv satisfiedBy: aTypeScheme in: aTypeSchemeEnv matchContext: matchContext	"^&lt;ITMatchContext | nil&gt;"	"A free type is compatible with everything."	^matchContext</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FreeType</class-id> <category>accessing</category><body package="ICCIncrementalTypes">baseClass	"^&lt;Class&gt;"	^Object</body></methods><methods><class-id>ICC.IncrementalTypes.IT1FreeType</class-id> <category>testing</category><body package="ICCIncrementalTypes">isFree	^true</body></methods><methods><class-id>ICC.IncrementalTypes.IT1Context</class-id> <category>accessing</category><body package="ICCIncrementalTypes">typeRep	^typeRep</body><body package="ICCIncrementalTypes">typeRep: aTypeReport	typeRep := aTypeReport</body></methods><methods><class-id>ICC.IncrementalTypes.IT1Context class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">typeRep: aTypeReport	^self new typeRep: aTypeReport</body></methods><methods><class-id>ICC.IncrementalTypes.IT1Inferencing</class-id> <category>accessing</category><body package="ICCIncrementalTypes">typeMatchConstraints	inferenceConstraints isNil ifTrue: [inferenceConstraints := Dictionary new].	^inferenceConstraints</body></methods><methods><class-id>ICC.IncrementalTypes.IT1Inferencing</class-id> <category>adding</category><body package="ICCIncrementalTypes">addTypeVarBinding: anAssociation	self typeMatchConstraints add: anAssociation</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeClosure</class-id> <category>compatibility</category><body package="ICCIncrementalTypes">in: myEnv satisfiedBy: aTypeScheme in: aTypeSchemeEnv matchContext: matchContext	"^&lt;ITMatchContext | nil&gt;"	^self typeScheme		in: self typeEnvironment		satisfiedBy: aTypeScheme		in: aTypeSchemeEnv		matchContext: matchContext</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeClosure</class-id> <category>accessing</category><body package="ICCIncrementalTypes">baseClass	"^&lt;Class&gt;"	^self typeScheme baseClassIn: self typeEnvironment</body><body package="ICCIncrementalTypes">closedTypeVarTypeOf: aTypeVarName	^self typeScheme typeVarTypeOf: aTypeVarName inEnvironment: self typeEnvironment</body><body package="ICCIncrementalTypes">typeEnvironment	^typeEnvironment</body><body package="ICCIncrementalTypes">typeEnvironment: aTypeEnvironment	typeEnvironment := aTypeEnvironment</body><body package="ICCIncrementalTypes">typeScheme	^typeScheme</body><body package="ICCIncrementalTypes">typeScheme: aTypeScheme	typeScheme := aTypeScheme</body><body package="ICCIncrementalTypes">typeVarTypeOf: aTypeVarName	^self typeScheme typeVarTypeOf: aTypeVarName inEnvironment: self typeEnvironment</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeClosure</class-id> <category>printing</category><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean	"Printing does not take care of binding semantics."	self typeScheme printNotationOn: aStream showNamespaces: aBoolean</body></methods><methods><class-id>ICC.IncrementalTypes.IT1TypeClosure class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">typeScheme: aTypeScheme typeEnvironment: aTypeEnvironment	| obj |	obj := self new.	obj typeScheme: aTypeScheme.	obj typeEnvironment: aTypeEnvironment.	^obj</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>private-parsing</category><body package="ICCIncrementalTypes">findDeclarations: aString in: scan	"Find and parse those declarations into an array which are listed under aString."	^(self findHeading: aString in: scan)		ifTrue: [self parseVars: scan]		ifFalse: [Array new]</body><body package="ICCIncrementalTypes">findHeading: headString in: scan	"Try to find headString: or headStrings: ."	| cr |	cr := Character cr.	[scan atEnd]		whileFalse:			[| line |			line := (scan upTo: cr) readStream.			((line nextAvailable: headString size)				sameAs: headString)				ifTrue:					[line peekFor: $s.					(line peekFor: $:)						ifTrue: [line skipSeparators].					^line atEnd]].	^false</body><body package="ICCIncrementalTypes">getClassInstVars: cmt	| declarations |	declarations := self findDeclarations: self classInstanceVariableDeclarationHeader in: cmt readStream.	classInstVars := self definedClassInstVarNames collect: [:each | declarations detect: [:eachAssoc | each = eachAssoc key]					ifNone: [each -&gt; nil]]</body><body package="ICCIncrementalTypes">getClassVars: cmt	| declarations |	declarations := self findDeclarations: self classVariableDeclarationHeader in: cmt readStream.	classVars := self definedClassVarNames collect: [:each | declarations detect: [:eachAssoc | each asString = eachAssoc key]					ifNone: [each -&gt; nil]]</body><body package="ICCIncrementalTypes">getInheritedClassInstVars: cmt	inheritedClassInstVars := self findDeclarations: self inheritedClassInstanceVariableDeclarationHeader in: cmt readStream</body><body package="ICCIncrementalTypes">getInheritedInstVars: cmt	inheritedInstVars := self findDeclarations: self inheritedInstanceVariableDeclarationHeader in: cmt readStream</body><body package="ICCIncrementalTypes">getInstVars: cmt	| declarations |	declarations := self findDeclarations: self instanceVariableDeclarationHeader in: cmt readStream.	instVars := self definedInstVarNames collect: [:each | declarations detect: [:eachAssoc | each = eachAssoc key]					ifNone: [each -&gt; nil]]</body><body package="ICCIncrementalTypes">getTypeVars: cmt	typeVars := self findDeclarations: 'Type Variable' in: cmt readStream</body><body package="ICCIncrementalTypes">parseType: typeString	" Parse the typeString if possible.	Answer an array (for now).	If the string can't be parsed,	answer nil. "	| type |	type := Object errorSignal		handle: [:ex | ex returnWith: nil]		do: [Kernel.Compiler preferredParserClass new parseType: typeString readStream builder: ProgramNodeBuilder new].	^type</body><body package="ICCIncrementalTypes">parseVars: scan	"^&lt;Array of: (Association key: String value: ProgramNode)&gt;	scan &lt;ReadStream&gt;	Parse variable declarations from current scan position up to either the end of the stream, or a blank line followed by a line that	does not begin with a space or tab. Answer an array of (varName -&gt; type)."	| vars |	vars := (Array new: 6) writeStream.	[scan atEnd]		whileFalse: [scan peek = Character cr				ifTrue:					[scan next.					(scan atEnd or: [scan peek isSeparator not])						ifTrue: [^vars contents]]				ifFalse:					[| line vname type parens vtype |					scan skipSeparators.					scan atEnd ifTrue: [^vars contents].					line := (scan upTo: Character cr) readStream.					vname := (String new: 20) writeStream.					parens := line atEnd not and: [line peek = $(].					[line atEnd not and: [parens							ifTrue:								[line peek = $) ifTrue: [parens := false].								true]							ifFalse: [line peek isSeparator not]]]						whileTrue: [vname nextPut: line next].					line skipSeparators.					(line next = $&lt;						and:							[type := line through: $&gt;.							["Special hack for embedded -&gt;"							type size &gt;= 2 and: [type last = $&gt; and: [(type at: type size - 1)										= $-]]]								whileTrue: [type := type , (line through: $&gt;)].							type size &gt; 1 and: [type last = $&gt;]])						ifTrue:							[vtype := self parseType: (type copyFrom: 1 to: type size - 1).							vars nextPut: vname contents -&gt; vtype]]].	^vars contents</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>private-declaration update</category><body package="ICCIncrementalTypes">explanationOf: aVariableName declarationHeader: aDeclarationHeader	"^&lt;String | nil&gt;"	| answer i scan |	scan := self infoString readStream.	answer := self				variableDeclarationOf: aVariableName				in: scan				declarationHeader: aDeclarationHeader.	answer isNil ifTrue: [^nil].	i := (answer at: 2) isNil				ifTrue: [1]				ifFalse: [2].	scan position: (answer at: i).	scan skipSeparators. 	"Preeceding spaces are cut of, otherwise they would become multiplied in subsequent save actions."	^((answer at: 3) &gt; scan position) 		ifTrue: [scan next: (answer at: 3) - (scan position + 1)]		ifFalse: ['']</body><body package="ICCIncrementalTypes">findVariableDeclarationOf: aVarName in: scan	"^&lt;(Array of: (Integer|nil) size: 3)|nil&gt;	scan &lt;ReadStream&gt;	Parse variable declarations from current scan position up to either the end of the stream, or a blank line followed	by a line that does not begin with a space or tab.	The answer contains the first and last position of the type declaration &lt;...&gt;, and the last position of a following	explanation. If there is no declaration, answer nil."	| positions linePositionInScan |	positions := Array new: 3.	[scan atEnd]		whileFalse: [scan peek = Character cr				ifTrue:					[scan next.					(scan atEnd or: [scan peek isSeparator not])						ifTrue: [^nil]]				ifFalse:					[| line vname type parens |					scan skipSeparators.					scan atEnd ifTrue: [^nil].					linePositionInScan := scan position.					line := (scan upTo: Character cr) readStream.					vname := String new writeStream.					parens := line atEnd not and: [line peek = $(].					[line atEnd not and: [parens							ifTrue:								[line peek = $) ifTrue: [parens := false].								true]							ifFalse: [line peek isSeparator not]]]						whileTrue: [vname nextPut: line next].					vname contents = aVarName						ifTrue:							[line skipSeparators.							positions at: 1 put: line position + linePositionInScan.							positions at: 3 put: scan position.							(line next = $&lt;								and:									[type := line through: $&gt;.									["Special hack for embedded -&gt;"									type size &gt;= 2 and: [type last = $&gt; and: [(type at: type size - 1)												= $-]]]										whileTrue: [type := type , (line through: $&gt;)].									type size &gt; 1 and: [type last = $&gt;]])								ifTrue: [positions at: 2 put: line position + linePositionInScan].							^positions]]].	^nil</body><body package="ICCIncrementalTypes">linestartOfVariable: aVarName in: scan	"^&lt;Integer | nil&gt;	scan &lt;ReadStream&gt;	Parse variable declarations from current scan position up to either the end of the stream, or a blank line followed	by a line that does not begin with a space or tab.	The answer contains the position of the line containing the declaration of aVarName.	If there is no declaration, answer nil."	| position |	[scan atEnd]		whileFalse: [scan peek = Character cr				ifTrue:					[scan next.					(scan atEnd or: [scan peek isSeparator not])						ifTrue: [^nil]]				ifFalse:					[| line vname type parens |					position := scan position + 1.					scan skipSeparators.					scan atEnd ifTrue: [^nil].					line := (scan upTo: Character cr) readStream.					vname := String new writeStream.					parens := line atEnd not and: [line peek = $(].					[line atEnd not and: [parens							ifTrue:								[line peek = $) ifTrue: [parens := false].								true]							ifFalse: [line peek isSeparator not]]]						whileTrue: [vname nextPut: line next].					vname contents = aVarName						ifTrue:							[line skipSeparators.							line next = $&lt;								and:									[type := line through: $&gt;.									["Special hack for embedded -&gt;"									type size &gt;= 2 and: [type last = $&gt; and: [(type at: type size - 1)												= $-]]]										whileTrue: [type := type , (line through: $&gt;)].									type size &gt; 1 and: [type last = $&gt;]].							^position]]].	^nil</body><body package="ICCIncrementalTypes">linestartOfVariable: anInstVarName in: scan declarationHeader: aDeclarationHeader	"^&lt;(Array of: (Integer|nil) size: 3)|nil&gt;	Parse variable declarations from current scan position up to either the end of the stream, or a blank line followed	by a line that	does not begin with a space or tab. Answer an array with the first and last position of the type declaration &lt;...&gt;	of anInstVarName. If there is no declaration, answer nil."	| res |	res := self findHeading: aDeclarationHeader in: scan.	^res		ifTrue: [self linestartOfVariable: anInstVarName in: scan]		ifFalse: [nil]</body><body package="ICCIncrementalTypes">nextCRIn: aString startingAt: aPosition	"^&lt;Integer|nil&gt;"	^aString		nextIndexOf: Character cr		from: aPosition		to: aString size</body><body package="ICCIncrementalTypes">positionAfterHeading: aString in: scan	"^&lt;Integer|nil&gt;"	^(self findHeading: aString in: scan)		ifTrue: [scan position]		ifFalse: [nil]</body><body package="ICCIncrementalTypes">variableDeclarationOf: anInstVarName in: scan declarationHeader: aDeclarationHeader	"^&lt;(Array of: (Integer|nil) size: 3)|nil&gt;	Parse variable declarations from current scan position up to either the end of the stream, or a blank line followed	by a line that	does not begin with a space or tab. Answer an array with the first and last position of the type declaration &lt;...&gt;	of anInstVarName. If there is no declaration, answer nil."	| res |	res := self findHeading: aDeclarationHeader in: scan.	^res		ifTrue: [self findVariableDeclarationOf: anInstVarName in: scan]		ifFalse: [nil]</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>private-checking</category><body package="ICCIncrementalTypes">checkClassInstVars: cmt typeRep: typeRep	self getClassInstVars: cmt.	^self		checkVars: self definedClassInstVarNames		heading: 'Class Instance'		against: self declaredClassInstVars		typeRep: typeRep</body><body package="ICCIncrementalTypes">checkClassVars: cmt typeRep: typeRep	self getClassVars: cmt.	^self		checkVars: self definedClassVarNames		heading: 'Class'		against: self declaredClassVars		typeRep: typeRep</body><body package="ICCIncrementalTypes">checkInstVars: cmt typeRep: typeRep	self getInstVars: cmt.	^self		checkVars: self definedInstVarNames		heading: 'Instance'		against: self declaredInstVars		typeRep: typeRep</body><body package="ICCIncrementalTypes">checkVars: vars heading: aString against: found typeRep: typeRep	| lcname  foundVars missing |	lcname := aString asLowercase.	vars isEmpty ifTrue: [^(found isNil or: [found isEmpty])			ifTrue: [#()]			ifFalse: [typeRep addError: class name , ' has no ' , lcname , ' variables, but it has a comment describing them.']].	found isNil ifTrue: [vars size = 1			ifTrue: [^typeRep addError: class name , ' has ' , vars size printString , ' ' , lcname , ' variable, but no comment describing it.']			ifFalse: [^typeRep addError: class name , ' has ' , vars size printString , ' ' , lcname , ' variables, but no comment describing them.']].	foundVars := found collect: [:vt | vt key].	missing := vars select: [:v | (foundVars includes: v) not].	missing isEmpty ifFalse: [missing size = 1			ifTrue: [typeRep addError: 'There is no description of the ' , lcname , ' variable ' , (missing at: 1) printString , '.']			ifFalse: [typeRep addError: 'There is no description of the ' , lcname , ' variables ' , missing printString , '.']].	missing := foundVars select: [:v | (vars includes: v) not].	missing isEmpty ifFalse: [missing size = 1			ifTrue: [typeRep addError: 'There is a description of a non-existent ' , lcname , ' variable ' , (missing at: 1) printString , '.']			ifFalse: [typeRep addError: 'There are descriptions of non-existent ' , lcname , ' variables ' , missing printString , '.']].	self		checkSyntaxOfVars: vars		in: found		typeRep: typeRep</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>accessing</category><body package="ICCIncrementalTypes">class: aClass	class := aClass</body><body package="ICCIncrementalTypes">classInstVars	^classInstVars</body><body package="ICCIncrementalTypes">classVars	^classVars</body><body package="ICCIncrementalTypes">infoString	"Return the string this program will extract type information from."	^class infoString</body><body package="ICCIncrementalTypes">infoString: aString	"Change the string this program will extract type information from."	class infoString: aString</body><body package="ICCIncrementalTypes">inheritedClassInstVars	^inheritedClassInstVars</body><body package="ICCIncrementalTypes">inheritedInstVars	^inheritedInstVars</body><body package="ICCIncrementalTypes">instVars	^instVars</body><body package="ICCIncrementalTypes">typeVars	^typeVars</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>private-support</category><body package="ICCIncrementalTypes">classInstanceVariableDeclarationHeader	^'Class Instance Variable'</body><body package="ICCIncrementalTypes">classVariableDeclarationHeader	^'Class Variable'</body><body package="ICCIncrementalTypes">inheritedClassInstanceVariableDeclarationHeader	^'Inherited Class Instance Variable'</body><body package="ICCIncrementalTypes">inheritedInstanceVariableDeclarationHeader	^'Inherited Instance Variable'</body><body package="ICCIncrementalTypes">instanceVariableDeclarationHeader	^'Instance Variable'</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">itTypes	^self class itTypes</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>checking</category><body package="ICCIncrementalTypes">checkInheritedVars: cmt typeRep: typeRep	| varNames   |	self getInheritedInstVars: cmt.	varNames := self inheritedInstVars collect: [:ivar | ivar key].	self		checkSyntaxOfVars: varNames		in: self inheritedInstVars		typeRep: typeRep.	self getInheritedClassInstVars: cmt.	varNames := self inheritedClassInstVars collect: [:ivar | ivar key].	self		checkSyntaxOfVars: varNames		in: self inheritedClassInstVars		typeRep: typeRep</body><body package="ICCIncrementalTypes">checkTypeVars: cmt typeRep: typeRep	| tVarNames |	self getTypeVars: cmt.	tVarNames := typeVars collect: [:tvar | tvar key].	^self		checkSyntaxOfVars: tVarNames		in: typeVars		typeRep: typeRep</body><body package="ICCIncrementalTypes">checkVars: cmt typeRep: typeRep	"^&lt;current&gt;"	"Note that class instance variable definitions are not crossChecked with existing	definitions."	self checkInstVars: cmt typeRep: typeRep.	self checkClassVars: cmt typeRep: typeRep.	self checkClassInstVars: cmt typeRep: typeRep</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>private</category><body package="ICCIncrementalTypes">checkSyntaxOfVars: vars in: found typeRep: typeRep	found do: [:vt | (vars includes: vt key)			ifTrue: [vt value isNil ifTrue: [typeRep addError: ('The description of &lt;1s&gt; has a syntax error.' expandMacrosWith: vt key)]]]</body><body package="ICCIncrementalTypes">declaredClassInstVars	^self classInstVars select: [:each | each value notNil]</body><body package="ICCIncrementalTypes">declaredClassVars	^self classVars select: [:each | each value notNil]</body><body package="ICCIncrementalTypes">declaredInstVars	^self instVars select: [:each | each value notNil]</body><body package="ICCIncrementalTypes">definedClassInstVarNames	^class class instVarNames</body><body package="ICCIncrementalTypes">definedClassVarNames	^class classVarNames asSortedCollection asArray collect: [:each | each asString]</body><body package="ICCIncrementalTypes">definedInstVarNames	^class instVarNames</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations</class-id> <category>declaration update</category><body package="ICCIncrementalTypes">declareVariable: aVariableName role: aTypeString implementation: anImplementation explanation: anExplanation	"Update the declaration of aVariableName with aTypeString and anExplanation.	If there is no variable declaration, take appropriate measures."	| infoString explanation aDeclarationHeader position entry infoStream extendedTypeString |	infoString := self infoString.	explanation := anExplanation isNil				ifTrue: [String new]				ifFalse: [anExplanation copy replaceAll: Character cr with: Character space].	aDeclarationHeader := self itTypes class implementationStringFor: anImplementation.	extendedTypeString := '&lt;' , aTypeString , '&gt;'.	position := self				variableDeclarationOf: aVariableName				in: infoString readStream				declarationHeader: aDeclarationHeader.	position isNil		ifTrue:			[entry := self positionAfterHeading: aDeclarationHeader in: infoString readStream.			entry isNil				ifTrue:					[infoStream := WriteStream with: self infoString.					infoStream						 cr;						 cr;						 nextPutAll: aDeclarationHeader , 's:';						 crtab]				ifFalse:					[infoStream := WriteStream								with: self infoString								from: 1								to: entry.					infoStream tab].			infoStream				 nextPutAll: aVariableName;				 space;				 tab;				 nextPutAll: extendedTypeString;				 space;				 nextPutAll: explanation.			entry notNil ifTrue: [infoStream nextPutAll: (infoString copyFrom: entry to: infoString size)]]		ifFalse:			[infoStream := WriteStream						with: self infoString						from: 1						to: (position at: 1).	"infoStream setToEnd."			infoStream				 nextPutAll: extendedTypeString;				 space;				 nextPutAll: explanation.			infoStream cr; nextPutAll: (infoString readStream position: (position at: 3); upToEnd)].	self adBasics systemOrganization setComment: infoStream contents for: class</body><body package="ICCIncrementalTypes">removeVariable: aVariableName implementation: anImplementation	"Remove the declaration of aVariableName, if present. If there is no variable declaration, do nothing."	| infoString aDeclarationHeader position infoStream skippedTo |	infoString := self infoString.	aDeclarationHeader := self itTypes class implementationStringFor: anImplementation.	position := self				linestartOfVariable: aVariableName				in: infoString readStream				declarationHeader: aDeclarationHeader.	position isNil ifTrue: [^self].	infoStream := WriteStream				with: self infoString				from: 1				to: position - 1.	skippedTo := self nextCRIn: infoString startingAt: position.	skippedTo isNil ifFalse: [infoStream nextPutAll: (infoString copyFrom: skippedTo + 1 to: infoString size)].	self infoString: infoStream contents</body></methods><methods><class-id>ICC.IncrementalTypes.IT1VariableDeclarations class</class-id> <category>instance creation</category><body package="ICCIncrementalTypes">on: aClass	^self new class: aClass</body></methods><methods><class-id>Core.Metaclass</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">invalidateTypeDeclarations	self soleInstance invalidateTypeDeclarations</body></methods><methods><class-id>Core.Collection class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">defaultTypeConstructor	^'of'</body><body package="ICCIncrementalTypes">genericTypeConstructors	^'Type Variables:	of 		&lt;free&gt;	size	&lt;free&gt;'</body><body package="ICCIncrementalTypes">viewAsITCollectionType	^true</body></methods><methods><class-id>Kernel.LiteralNode</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">isLiteralNode	^true</body><body package="ICCIncrementalTypes">typeSemanticsInElaborationContext: elabContext	"^&lt;IT1TypeScheme | nil&gt;"	^ICC.IncrementalTypes.IT1LiteralType		masterClass: elabContext masterClass		baseClass: self value class		literal: self value</body></methods><methods><class-id>Kernel.VariableNode</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">isVariableNode	^true</body><body package="ICCIncrementalTypes">typeSemanticsInElaborationContext: elabContext	"^&lt;IT1ClassType | nil&gt;"	"There are two kinds of type names: class names and type variable names.	If name is a type variable, it must be defined in aTypeEnvironment already.	This imposes certain restrictions on recursive definitions which are not of practical	importance, however. Special type variables are current, class, instance and free."	| theName typeName aType |	theName := self name.	typeName := theName asSymbol.	aType := (typeName asQualifiedReference home: elabContext baseClass environment)					valueOrDo: [nil].	(aType notNil and: [aType isBehavior])		ifTrue: [^ICC.IncrementalTypes.IT1ClassType masterClass: elabContext masterClass baseClass: aType].	((elabContext isDefined: theName)		or: [#(#current #free #instance #class) includes: typeName])		ifTrue: [^ICC.IncrementalTypes.IT1TypeVariable masterClass: elabContext masterClass typeVarName: theName].	elabContext notAValidTypeError: theName.	^nil</body></methods><methods><class-id>UI.SelectionInList class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">defaultTypeConstructor	^'on'</body><body package="ICCIncrementalTypes">genericTypeConstructors	^'Type Variables:	with &lt;free&gt;	on &lt;free&gt;	for &lt;free&gt;	of &lt;free&gt;'</body><body package="ICCIncrementalTypes">viewAsITWrappedType	^true</body></methods><methods><class-id>Core.Class</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">clientRelationDeclarations	^self itTypes clientRelationDeclarationsOf: self</body><body package="ICCIncrementalTypes">clientRelations	^self clientRelationDeclarations clientRelations</body><body package="ICCIncrementalTypes">clientRelationTypeOf: aRoleName implementation: aSymbol	"^&lt;ITTypeScheme | nil&gt;	Triggers elaboration of declarations if necessary."	^(self itTypes fullTypeOfClass: self)		clientRelationTypeOf: aRoleName implementation: aSymbol</body><body package="ICCIncrementalTypes">declareClientRelation: aRoleName role: aTypeString implementation: anImplementation explanation: anExplanation	"aRoleName 		&lt;String&gt;	aTypeString 		&lt;String&gt; describing the role of the client relation; any unbound						references in the type string are resolved within my class context.	anImplementation	&lt;Symbol&gt;	anExplanation 		&lt;String | nil&gt;"	self fullType		declareClientRelation: aRoleName		role: aTypeString		implementation: anImplementation		explanation: anExplanation</body><body package="ICCIncrementalTypes">explanationOf: aVariableName implementation: anImplementation	"^&lt;String | nil&gt;"	^(ICC.IncrementalTypes.IT1VariableDeclarations on: self)		explanationOf: aVariableName declarationHeader: (self itTypes class implementationStringFor: anImplementation)</body><body package="ICCIncrementalTypes">fullType	"&lt;ITFullType | nil&gt;"	^self itTypes fullTypeOfClass: self</body><body package="ICCIncrementalTypes">infoString	"Return the string the Incremental Types will extract type information from.	Depending on the ADvance settings use either the comment or the method given by the user in the	preferences."	| selector |	^(((self respondsTo: #advance) 		and: [self advance preferences general classInfoSource ~~ #comment 		and: [self class includesSelector: (selector := self advance preferences general classInfoSelector)]])		ifTrue: [self perform: selector]		ifFalse: [self comment asString]) copy</body><body package="ICCIncrementalTypes">infoString: aString	"Store the string the Incremental Types will extract type information from.	Depending on the ADvance settings use either the comment or the method given by the user in the	preferences."	| stream |	((self respondsTo: #advance) and: [self advance preferences general classInfoSource == #comment])		ifTrue: [self comment: aString]		ifFalse:			[stream := WriteStream on: (String new: aString size * 2).			stream				nextPutAll: self advance preferences general classInfoSelector;				crtab;				nextPut: $^;				print: aString.			self class compile: stream contents classified: #ADvance]</body></methods><methods><class-id>Core.Class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">itTypes	^ICC.IncrementalTypes.IT1TypeSpecifications default</body></methods><methods><class-id>Core.Class</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">locallyDefinedClientRelationsOfImplementation: anImplementation	"^&lt;Set of: String&gt;	Triggers elaboration of declarations if necessary."	^(self itTypes fullTypeOfClass: self)		locallyDefinedClientRelationsOfImplementation: anImplementation</body><body package="ICCIncrementalTypes">locallyDefinedClientRelationTypeOf: aRoleName implementation: anImplementation	"^&lt;ITTypeScheme | nil&gt;	Triggers elaboration of declarations if necessary."	^(self itTypes fullTypeOfClass: self)		locallyDefinedClientRelationTypeOf: aRoleName implementation: anImplementation</body><body package="ICCIncrementalTypes">removeClientRelation: aRoleName implementation: anImplementation	self fullType removeClientRelation: aRoleName implementation: anImplementation</body><body package="ICCIncrementalTypes">removeVariable: aVariableName implementation: anImplementation	(ICC.IncrementalTypes.IT1VariableDeclarations on: self)		removeVariable: aVariableName implementation: anImplementation</body><body package="ICCIncrementalTypes">typeVarDeclarations	^self itTypes typeVarDeclarationsOf: self</body></methods><methods><class-id>Core.Class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">viewAsITCollectionType	^false</body><body package="ICCIncrementalTypes">viewAsITWrappedType	^false</body></methods><methods><class-id>Kernel.MessageNode</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">argumentTypesFromArguments: elabContext	"^&lt;(OrderedCollection of: ITTypeScheme) | nil&gt;"	| ok args argType |	ok := true.	args := self arguments				collect:					[:arg |					argType := arg typeSemanticsInElaborationContext: elabContext.					argType isNil ifTrue: [ok := false].					argType].	^ok		ifTrue: [args]		ifFalse: [nil]</body><body package="ICCIncrementalTypes">associationTypeInElaborationContext: elabContext	"^&lt;ITTypeScheme | nil&gt;"	self arguments growToAtLeast: 2.	self		receiver: (VariableNode new name: 'Core.Association')		selector: #key:value:		arguments: (Array with: self receiver with: (self arguments at: 1)).	^self typeSemanticsInElaborationContext: elabContext</body><body package="ICCIncrementalTypes">metaClassTypeInElaborationContext: elabContext	"^&lt;ITTypeScheme | nil&gt;"	"For metaclasses, we do not enter the loop of class/metaclass reference."	| rec |	rec := self receiver typeSemanticsInElaborationContext: elabContext.	(rec isKindOf: ICC.IncrementalTypes.IT1ClassType)		ifTrue: [rec meta				ifFalse:					[rec meta: true.					^rec]				ifTrue: [^self noMetaclassClassError: elabContext typeRep]].	^nil</body><body package="ICCIncrementalTypes">noClassTypeError: typeRep	typeRep addError: 'Class type expected for generic instantiation.'.	^nil</body><body package="ICCIncrementalTypes">noMetaclassClassError: typeRep	typeRep addError: 'The class of a metaclass must not be specified.'.	^nil</body><body package="ICCIncrementalTypes">notACorrectSelectorError: str typeRep: typeRep	typeRep addError: str , ' is not a correct type variable.'.	^nil</body><body package="ICCIncrementalTypes">typeSemanticsInElaborationContext: elabContext	"^&lt;ITTypeScheme | nil&gt;"	self selector == #| ifTrue: [^self unionTypeInElaborationContext: elabContext].	self selector == #class ifTrue: [^self metaClassTypeInElaborationContext: elabContext].	self selector == #-&gt; ifTrue: [^self associationTypeInElaborationContext: elabContext].	^self typeSubstitutionInElaborationContext: elabContext</body><body package="ICCIncrementalTypes">typeSubstitutionInElaborationContext: elabContext	"^&lt;IT1ClassType | nil&gt;"	"For specific receivers, types to be substituted may be specifically defined. After successful substitution, typeVarReferences are joined."	| rec typeVarNames args |	rec := self receiver typeSemanticsInElaborationContext: elabContext.	(rec isKindOf: ICC.IncrementalTypes.IT1ClassType)		ifFalse: [^self noClassTypeError: elabContext typeRep].	typeVarNames := self typeVarNamesFromSelector: elabContext typeRep.	args := self argumentTypesFromArguments: elabContext.	typeVarNames isNil | args isNil ifTrue: [^nil].	^rec		substituteTypeVars: typeVarNames		with: args		inElaborationContext: elabContext</body><body package="ICCIncrementalTypes">typeVarNamesFromSelector: typeRep	"^&lt;(OrderedCollection of: String) | nil&gt;"	"Removes : from selector keywords. If there is a selector without a :, report an error."	^self selector keywords		collect:			[:keyword |			| str |			str := keyword asString.			str last ~= $: ifTrue: [^self notACorrectSelectorError: str typeRep: typeRep].			keyword asString copyFrom: 1 to: keyword size - 1]</body><body package="ICCIncrementalTypes">unionTypeInElaborationContext: elabContext	"^&lt;ITTypeScheme | nil&gt;"	| rec arg newType |	rec := self receiver typeSemanticsInElaborationContext: elabContext.	arg := (self arguments at: 1)				typeSemanticsInElaborationContext: elabContext.	rec isNil | arg isNil ifTrue: [^nil].	(rec isKindOf: ICC.IncrementalTypes.IT1UnionType)		ifTrue:			[(arg isKindOf: ICC.IncrementalTypes.IT1UnionType)				ifTrue: [rec addUnionType: arg]				ifFalse: [rec addTypeScheme: arg].			^rec]		ifFalse: [(arg isKindOf: ICC.IncrementalTypes.IT1UnionType)				ifTrue:					[arg addTypeScheme: rec.					^arg]				ifFalse:					[newType := ICC.IncrementalTypes.IT1UnionType masterClass: elabContext masterClass.					newType addTypeScheme: arg.					newType addTypeScheme: rec.					^newType]]</body></methods><methods><class-id>Kernel.ProgramNode</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">isLiteralNode	^false</body><body package="ICCIncrementalTypes">isReturnNode	^false</body><body package="ICCIncrementalTypes">isVariableNode	^false</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">defaultTypeConstructor	^'value'</body><body package="ICCIncrementalTypes">genericTypeConstructors	^'Type Variables:	key &lt;free&gt;	value &lt;free&gt;'</body></methods><methods><class-id>UI.ValueModel class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">defaultTypeConstructor	^'on'</body><body package="ICCIncrementalTypes">genericTypeConstructors	^'Type Variables:	with &lt;free&gt;	on &lt;free&gt;	for &lt;free&gt;	of &lt;free&gt;'</body><body package="ICCIncrementalTypes">viewAsITWrappedType	^true</body></methods><methods><class-id>Core.Behavior</class-id> <category>IT-API</category><body package="ICCIncrementalTypes">invalidateTypeDeclarations	"If there is a valid type declaration for me, it is invalidated and my subclasses are	asked to invalidate."	(ICC.IncrementalTypes.IT1TypeSpecifications default invalidateTypeOf: self)		ifTrue: [self subclasses do: [:each | each invalidateTypeDeclarations]]</body><body package="ICCIncrementalTypes">logDefinition	"Log my definition in Change file."	SourceFileManager default logChange: self definition</body></methods><methods><class-id>Core.Association class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">genericTypeConstructors	^'Type Variables:	key &lt;free&gt;	value &lt;free&gt;'</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">itTypeNotation	| aStream |	aStream := WriteStream on: (String new: 16).	self printNotationOn: aStream.	^aStream contents</body><body package="ICCIncrementalTypes">printNotationOn: aStream 	^self printNotationOn: aStream showNamespaces: true</body><body package="ICCIncrementalTypes">printNotationOn: aStream showNamespaces: aBoolean	aStream nextPutAll: 'undefined'</body></methods><methods><class-id>Kernel.BlockClosure class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">genericTypeConstructors	"^&lt;String&gt;"	^'Type Variables:	value &lt;free&gt;'</body></methods><methods><class-id>Kernel.ReturnNode</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">isReturnNode	^true</body></methods><methods><class-id>Core.Stream class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">genericTypeConstructors	^'Type Variables:	on &lt;free&gt;'</body></methods><methods><class-id>Core.CharacterArray class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">viewAsITCollectionType	^false</body></methods><methods><class-id>Core.Semaphore class</class-id> <category>IT-core</category><body package="ICCIncrementalTypes">viewAsITCollectionType	^false</body></methods><initialize><class-id>ICC.IncrementalTypes.IT1FullType</class-id></initialize><initialize><class-id>ICC.IncrementalTypes.IT1TypeSpecifications</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ProgramNode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition comment compilerHints blockIndex mapEntry returnMapEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ReturnNode</name><environment>Kernel</environment><super>Kernel.StatementNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>LiteralNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>UISpecification</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>VariableNode</name><environment>Kernel</environment><super>Kernel.LeafNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name read </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MessageNode</name><environment>Kernel</environment><super>Kernel.SimpleMessageNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expanded expansion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class></st-source>