<?xml version="1.0"?><st-source><!-- Name: ICCColorSelectorComment: IC&C ColorSelector as Part of ADvance  ©1998-2008 by IC&C GmbH, Software Foundations. All rights reserved.DbIdentifier: bear73DbTrace: 292372DbUsername: iccdevDbVersion: 7.6_01DevelopmentPrerequisites: #(#(#package 'ICC-Namespace' '7.6_01'))PackageName: ICCColorSelectorParcel: #('ICCColorSelector')ParcelName: ICCColorSelectorPrerequisiteParcels: #(#('ICC-Namespace' '7.6_01'))PrintStringCache: (7.6_01,iccdev)Version: 7.6_01VersionDate: 02/28/2008Post-Load Block: 	[:pkg |]Pre-Unload Block: 	[:pkg |]Date: 5:08:51 PM May 26, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (may17.4) of May 26, 2017 on May 26, 2017 at 5:08:51 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ICCColorBoxSpec</name><environment>ICC</environment><super>UI.RadioButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCColorBoxSpec</class-id><body>This class provides the specs for the colored buttons within a ICCColorSelector.</body></comment><class><name>ICCColorSelector</name><environment>ICC</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accept colors activeColorIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCColorSelector</class-id><body>The GUI to select colors from a table of few colors or to activate the ColorPicker with ColorWheel.Instance Variables:	accept	&lt;ValueHolder on: Boolean&gt;  	colors	&lt;Array of: (ValueHolder on: ColorValue)&gt; 	activeColorIndex	&lt;ValueHolder on: Integer&gt; </body></comment><class><name>ICCColorSelectionDialog</name><environment>ICC</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>colorSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCColorSelectionDialog</class-id><body>This is the modal dialog frame for ICCColorSelector.Instance Variables:	colorSelector	&lt;ICCColorSelector&gt; </body></comment><class><name>ICCColorAssigner</name><environment>ICC</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accept colorList colorSelector colorsChanged </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCColorAssigner</class-id><body>Instance Variables:	accept	&lt;ValueHolder on: Boolean&gt;  	colorList	&lt;SelectionInList&gt;  	colorSelector	&lt;ICC.ICCColorSelector&gt; 	colorsChanged	&lt;Boolean&gt;  </body></comment><class><name>ICCColorPicker</name><environment>ICC</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wheelSliderView wheelPosition red green blue saturation brightness hue colorModel oldColor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCColorPicker</class-id><body>A ColorPicker provides comfortable Color input: select color from a color wheel, input the RGB or the HSB values.Instance Variables:	wheelSliderView	&lt;ICCTransparentFractionalWidgetView&gt; 	wheelPosition	&lt;ValueHolder on: Point&gt; 	red	&lt;ValueHolder on: Number&gt;  	green	&lt;ValueHolder on: Number&gt;  	blue	&lt;ValueHolder on: Number&gt;  	saturation	&lt;Number&gt;  	brightness	&lt;ValueHolder on: Number&gt;  	hue	&lt;Number&gt;  	colorModel	&lt;ValueHolder on: ColorValue&gt;  	oldColor	&lt;ColorValue&gt;  Class Variables:	ColorWheel24Bit	&lt;OpaqueImage&gt;  	ColorWheel8Bit	&lt;OpaqueImage&gt;  </body></comment><class><name>ICCColorAssignmentDialog</name><environment>ICC</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>colorAssigner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCColorAssignmentDialog</class-id><body>Dialog to assign colors to a List.Instance Variables:	colorAssigner	&lt;ICC.ICCColorAssigner&gt;  comment</body></comment><class><name>ICCTransparentFractionalWidgetView</name><environment>ICC</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>axis markerBlock savedBkgdPatch markerImage savedPos controlActive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCTransparentFractionalWidgetView</class-id><body>Instance Variables:	axis	&lt;Point&gt;  	markerBlock	&lt;BlockClosure&gt;  This Block evaluates to a Rectangle.	savedBkgdPatch	&lt;Image&gt;  	markerImage	&lt;Image&gt;  	savedPos	&lt;Point&gt;  	controlActive	&lt;Boolean&gt;  </body></comment><class><name>ICCColorBoxView</name><environment>ICC</environment><super>UI.RadioButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>color </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCColorBoxView</class-id><body>Instances of this class are the views for the colored buttons within an ICCColorSelector.Instance Variables:	color	&lt;ValueHolder on: ColorValue&gt;  comment</body></comment><class><name>ICCPaint</name><environment>ICC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>symbolicColorDictionary indexedColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ICCColorSelector</package></attributes></class><comment><class-id>ICC.ICCPaint</class-id><body>Defines available default colors.Instance Variables:	symbolicColorDictionary	&lt;Dictionary key: Symbol value: ColorValue&gt;  	indexedColors	&lt;Array of: ColorValue&gt;  </body></comment><shared-variable><name>ColorWheel8Bit</name><environment>ICC.ICCColorPicker</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ICCColorSelector</package></attributes></shared-variable><shared-variable><name>ColorWheel24Bit</name><environment>ICC.ICCColorPicker</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ICCColorSelector</package></attributes></shared-variable><methods><class-id>ICC.ICCColorBoxSpec</class-id> <category>private</category><body package="ICCColorSelector">dispatchTo: policy with: builder	policy colorBox: self into: builder</body></methods><methods><class-id>ICC.ICCColorBoxSpec class</class-id> <category>installation</category><body package="ICCColorSelector">install	"Add the receiver to the painters palette."	"self install"	| uiPaletteClass |	uiPaletteClass := #{Tools.UIPalette} valueOrDo: [^self].	(uiPaletteClass activeSpecsList includes: self name)		ifFalse: [uiPaletteClass activeSpecsList add: self name]</body><body package="ICCColorSelector">uninstall	"Remove the receiver from the painters palette."	"self uninstall"	| uiPaletteClass |	uiPaletteClass := #{Tools.UIPalette} valueOrDo: [^self].	uiPaletteClass activeSpecsList remove: self name ifAbsent: []</body></methods><methods><class-id>ICC.ICCColorBoxSpec class</class-id> <category>private-interface building</category><body package="ICCColorSelector">componentName	"Identification of component"	^'Color Box'</body><body package="ICCColorSelector">specGenerationBlock	^[:ctrlr :point |		ICCColorBoxSpec			model: nil			label: nil			layout: ((ctrlr gridPoint: point)				extent:					(28@20))			properties: #(#canDefault )]</body></methods><methods><class-id>ICC.ICCColorBoxSpec class</class-id> <category>class initialization</category><body package="ICCColorSelector">obsolete	"This class is being removed from the system. Deinstall me."	self uninstall.	super obsolete</body></methods><methods><class-id>ICC.ICCColorSelector</class-id> <category>actions</category><body package="ICCColorSelector">changeColor	| newColor |	(newColor := ICCColorPicker openOn: self activeColorValue) notNil		ifTrue: [self activeColorValue: newColor]</body><body package="ICCColorSelector">doAccept	^accept value: true</body><body package="ICCColorSelector">doCancel	^accept value: false</body></methods><methods><class-id>ICC.ICCColorSelector</class-id> <category>initialize-release</category><body package="ICCColorSelector">initialize	activeColorIndex := 1 asValue.	accept := false asValue.	colors := Array new: 20.</body><body package="ICCColorSelector">paint: anICCPaint	1 to: 20 do: [:i | colors at: i put: (BufferedValueHolder subject: ((IndexedAdaptor subject: anICCPaint indexedColors)					forIndex: i)				triggerChannel: accept)]</body></methods><methods><class-id>ICC.ICCColorSelector</class-id> <category>private</category><body package="ICCColorSelector">buttonAt: index using: aBuilder	^(aBuilder componentAt: (self buttonNameAt: index)) widget</body><body package="ICCColorSelector">buttonNameAt: anIndex	^('activeColor' , (anIndex &lt; 10			ifTrue: ['0']			ifFalse: ['']) , anIndex displayString) asSymbol</body><body package="ICCColorSelector">buttonNumberFor: aSymbol	^(aSymbol copyFrom: 12 to: 13) asNumber</body></methods><methods><class-id>ICC.ICCColorSelector</class-id> <category>accessing</category><body package="ICCColorSelector">accept	^accept</body><body package="ICCColorSelector">activeColorHolder	^colors at: activeColorIndex value</body><body package="ICCColorSelector">activeColorIndex	^self activeColorIndexHolder value</body><body package="ICCColorSelector">activeColorIndex: aNumber	self activeColorIndexHolder value: aNumber</body><body package="ICCColorSelector">activeColorIndexHolder	^activeColorIndex</body><body package="ICCColorSelector">activeColorValue	^self activeColorHolder value</body><body package="ICCColorSelector">activeColorValue: aColorValue	self activeColorHolder value: aColorValue.	self activeColorIndexHolder changed: #value</body></methods><methods><class-id>ICC.ICCColorSelector</class-id> <category>interface opening</category><body package="ICCColorSelector">postBuildWith: aBuilder	"This message is sent by the builder when it has completed work on	either a complete window or a SubCanvas."	1 to: 20 do: [:index | (self buttonAt: index using: aBuilder)			backgroundColorAspect: (colors at: index)]</body></methods><methods><class-id>ICC.ICCColorSelector</class-id> <category>aspects</category><body package="ICCColorSelector">activeColor	"The selection of buttons is meant to update the activeColorIndex and vice versa."	^(PluggableAdaptor on: self activeColorIndexHolder)		getBlock: [:model | self buttonNameAt: model value]		putBlock: [:model :value | model value: (self buttonNumberFor: value)]		updateBlock: [:model :aspect :parameter | aspect == #value]</body></methods><methods><class-id>ICC.ICCColorSelector class</class-id> <category>load-unload</category><body package="ICCColorSelector">postLoadActionFor: aParcel	ICCColorBoxSpec install.	"Generate the colorWheelImages now, so they won't be during application execution."	ICCColorPicker initialize</body><body package="ICCColorSelector">preUnloadActionFor: aParcel	"This is called when package or parcel becomes unloaded."	ICCColorBoxSpec uninstall</body></methods><methods><class-id>ICC.ICCColorSelector class</class-id> <category>interface opening</category><body package="ICCColorSelector">open	^Dialog error: 'Use #openWith: to open.'</body><body package="ICCColorSelector">openWith: anICCPaint	self new paint: anICCPaint; open</body></methods><methods><class-id>ICC.ICCColorSelectionDialog</class-id> <category>actions</category><body package="ICCColorSelector">doAccept	self colorSelector doAccept.	^self colorSelector activeColorValue</body></methods><methods><class-id>ICC.ICCColorSelectionDialog</class-id> <category>accessing</category><body package="ICCColorSelector">colorSelector	^colorSelector</body></methods><methods><class-id>ICC.ICCColorSelectionDialog</class-id> <category>initialize-release</category><body package="ICCColorSelector">paint: anICCPaint	colorSelector := ICCColorSelector new paint: anICCPaint</body></methods><methods><class-id>ICC.ICCColorSelectionDialog class</class-id> <category>interface opening</category><body package="ICCColorSelector">open	^self openWith: ICCPaint new</body><body package="ICCColorSelector">openWith: anICCPaint	"Open a ICCColorSelectionDialog as dialog"	| dialog |	(dialog := self new paint: anICCPaint) open.	^dialog accept value		ifTrue: [dialog doAccept]		ifFalse: [nil]</body></methods><methods><class-id>ICC.ICCColorAssigner</class-id> <category>private</category><body package="ICCColorSelector">canApply: aBoolean	(self builder componentAt: #apply) widget isEnabled: aBoolean.	(self builder componentAt: #accept) widget isEnabled: aBoolean.</body><body package="ICCColorSelector">canExchange	| aBoolean |	aBoolean := colorList selectionIndex ~= 0.	(self builder componentAt: #toLeft)		isEnabled: aBoolean.	(self builder componentAt: #toRight)		isEnabled: aBoolean</body><body package="ICCColorSelector">colorsChanged: aBoolean	^self colorsChangedHolder value = aBoolean ifFalse: [self colorsChangedHolder value: aBoolean]</body></methods><methods><class-id>ICC.ICCColorAssigner</class-id> <category>interface opening</category><body package="ICCColorSelector">postBuildWith: aBuilder	((aBuilder componentAt: #symbolicColorNames) widget)		selectedVisualBlock:			[:view :index |			| item rw |			item := view sequence at: index.			rw := ReversingWrapper on: ((LabelAndIcon with: item subject forIndex displayString attributes: view textStyle)							icon: (ICCColorBoxView new backgroundColorAspect: item)).			rw reverse setValue: true.			BoundedWrapper on: rw];		visualBlock:			[:view :index |			| item |			item := view sequence at: index.			BoundedWrapper on: ((LabelAndIcon with: item subject forIndex displayString attributes: view textStyle)					icon: (ICCColorBoxView new backgroundColorAspect: item))].	builder := aBuilder.	self canExchange</body></methods><methods><class-id>ICC.ICCColorAssigner</class-id> <category>accessing</category><body package="ICCColorSelector">accept	^accept</body><body package="ICCColorSelector">colorSelector	^colorSelector</body><body package="ICCColorSelector">colorsChanged	^self colorsChangedHolder value</body><body package="ICCColorSelector">colorsChangedHolder	^colorsChanged</body></methods><methods><class-id>ICC.ICCColorAssigner</class-id> <category>actions</category><body package="ICCColorSelector">doAccept	accept value: true.	self colorsChanged: false.</body><body package="ICCColorSelector">doCancel	accept value: false.	self colorsChanged: false.	colorList listHolder changed: #value.</body><body package="ICCColorSelector">toLeft	colorList selection value: self colorSelector activeColorValue.	colorList list changed: #at: with: colorList selectionIndex.	self colorsChanged: true</body><body package="ICCColorSelector">toRight	self colorSelector activeColorValue: colorList selection value</body></methods><methods><class-id>ICC.ICCColorAssigner</class-id> <category>aspects</category><body package="ICCColorSelector">symbolicColorNames	"This method was generated by UIDefiner. Any edits made here	may be lost whenever methods are automatically defined. The	initialization provided below may have been preempted by an	initialize method."	^colorList</body></methods><methods><class-id>ICC.ICCColorAssigner</class-id> <category>initialize-release</category><body package="ICCColorSelector">initialize	colorsChanged := false asValue.	colorList := SelectionInList new</body><body package="ICCColorSelector">paint: anICCPaint	colorSelector := ICCColorSelector new paint: anICCPaint.	accept := colorSelector accept.	anICCPaint symbolicColorDictionary keys asSortedCollection		do: [:key | colorList list add: (BufferedValueHolder subject: ((IndexedAdaptor subject: anICCPaint symbolicColorDictionary)					forIndex: key)				triggerChannel: accept)].	colorList selectionIndexHolder onChangeSend: #canExchange to: self</body></methods><methods><class-id>ICC.ICCColorAssigner class</class-id> <category>interface opening</category><body package="ICCColorSelector">open	^Dialog error: 'Use #openWith: to open.'</body><body package="ICCColorSelector">openWith: anICCPaint	self new paint: anICCPaint; open</body></methods><methods><class-id>ICC.ICCColorPicker</class-id> <category>aspects</category><body package="ICCColorSelector">blue	^blue</body><body package="ICCColorSelector">brightness	^brightness</body><body package="ICCColorSelector">colorModel	^colorModel</body><body package="ICCColorSelector">green	^green</body><body package="ICCColorSelector">hue	^hue</body><body package="ICCColorSelector">red	^red</body><body package="ICCColorSelector">saturation	^saturation</body><body package="ICCColorSelector">wheelPosition	^wheelPosition</body><body package="ICCColorSelector">wheelSliderView	^wheelSliderView</body></methods><methods><class-id>ICC.ICCColorPicker</class-id> <category>actions</category><body package="ICCColorSelector">matchNearestPaint	| palette |	palette := Screen default colorPalette.	self color: (palette at: (palette indexOfPaintNearest: self color))</body></methods><methods><class-id>ICC.ICCColorPicker</class-id> <category>initialize-release</category><body package="ICCColorSelector">initialize	super initialize.	wheelPosition := (PluggableAdaptor on: (0.5 @ 0.5) asValue)				getBlock: [:m | "restrict values to be within a circle"					m value]				putBlock: [:m :v | (v - (0.5 @ 0.5)) r &lt;= 0.5						ifTrue: [m value: v]						ifFalse: [m value: (Point r: 0.5 theta: (v - (0.5 @ 0.5)) theta)									+ (0.5 @ 0.5)]]				updateBlock: [:m :a :p | true].	colorModel := ColorValue white asValue.	red := (PluggableAdaptor on: self colorModel)				getBlock: [:m | (m value red * 255) asInteger]				putBlock: [:m :v | m value: (ColorValue							red: v / 255							green: m value green							blue: m value blue)]				updateBlock: [:m :a :p | a == #value].	green := (PluggableAdaptor on: self colorModel)				getBlock: [:m | (m value green * 255) asInteger]				putBlock: [:m :v | m value: (ColorValue							red: m value red							green: v / 255							blue: m value blue)]				updateBlock: [:m :a :p | a == #value].	blue := (PluggableAdaptor on: self colorModel)				getBlock: [:m | (m value blue * 255) asInteger]				putBlock: [:m :v | m value: (ColorValue							red: m value red							green: m value green							blue: v / 255)]				updateBlock: [:m :a :p | a == #value].	hue := (PluggableAdaptor on: self colorModel)				getBlock: [:m | (m value hue * 255) asInteger]				putBlock: [:m :v | m value: (ColorValue							hue: v / 255							saturation: m value saturation							brightness: m value brightness)]				updateBlock: [:m :a :p | a == #value].	saturation := (PluggableAdaptor on: self colorModel)				getBlock: [:m | (m value saturation * 255) asInteger]				putBlock: [:m :v | m value: (ColorValue							hue: m value hue							saturation: v / 255							brightness: m value brightness)]				updateBlock: [:m :a :p | a == #value].	brightness := (PluggableAdaptor on: self colorModel)				getBlock: [:m | (m value brightness * 255) asInteger]				putBlock: [:m :v | m value: (ColorValue							hue: m value hue							saturation: m value saturation							brightness: v / 255)]				updateBlock: [:m :a :p | a == #value].	self colorModel onChangeSend: #colorChanged to: self.	self wheelPosition onChangeSend: #wheelPositionChanged to: self</body></methods><methods><class-id>ICC.ICCColorPicker</class-id> <category>interface opening</category><body package="ICCColorSelector">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self updatePatches.	self updateBrightnessScale</body><body package="ICCColorSelector">preBuildWith: aBuilder	"Wait until preBuild to set up the wheelSliderView, so color: can be called without causing the	wheelSliderView to be updated"	super preBuildWith: aBuilder.	wheelSliderView := ICCTransparentFractionalWidgetView model: wheelPosition.	wheelSliderView beTwoDimensional; markerImage: self class markerMask.	wheelSliderView controller cursor: Cursor bull</body></methods><methods><class-id>ICC.ICCColorPicker</class-id> <category>private</category><body package="ICCColorSelector">colorToPoint: aColorValue	"Convert aColorValue to the corresponding point on the color wheel,	ignoring the brightness"	| theStartColor |	theStartColor := (aColorValue notNil ifTrue: [aColorValue] ifFalse: [ColorValue lightGray]).	^(Point r: theStartColor saturation / 2.0 theta: theStartColor hue * 2.0 * Float pi)		+ (0.5@0.5)  "adjust to center of wheel"</body><body package="ICCColorSelector">pointToColor: aPoint	"Convert aPoint to the corresponding color, without affecting the current brightness.	An exception is if the current brightness is zero, in which case bump the	brightness up to 1"	|adjPt|	adjPt := aPoint - (0.5@0.5).  "adjust from center of circle"	^ColorValue hue:  adjPt theta / 2 / Float pi			saturation: adjPt r * 2.0			brightness: ((self color isNil or: [brightness value = 0 and: [(adjPt = Point zero) not]])							ifTrue: [1]							ifFalse: [brightness value / 255])</body><body package="ICCColorSelector">round: aFloat	"round to nearest second decimal place"	^(aFloat * 100) rounded / 100</body><body package="ICCColorSelector">updateBrightnessScale	| patch image depth |	patch := self builder componentAt: #brightnessScale.	patch isNil ifTrue: [^self].	hue := self color hue.	saturation := self color saturation.	depth := #(1 2 4 8 16 24 32) detect: [:d | patch bounds width &lt;= (2 ** d)].	Screen default colorPalette depth &gt;= 24		ifTrue:			[| pm gc b w |			pm := Pixmap extent: patch bounds extent.			gc := pm graphicsContext.			b := patch bounds height - 1.			w := patch bounds width.			0 to: w - 1 do: [:x | gc paint: (ColorValue						hue: hue						saturation: saturation						brightness: x / w); displayLineFrom: x @ 0 to: x @ b].			image := CachedImage on: pm asImage.			image instVarAt: 2 put: pm]		ifFalse:			[| colors palette |			colors := Array new: patch bounds width.			1 to: colors size do: [:i | colors at: i put: (ColorValue						hue: hue						saturation: saturation						brightness: i - 1 / patch bounds width)].			palette := MappedPalette withColors: colors.			image := Image						extent: patch bounds extent						depth: depth						palette: palette.			0 to: image width - 1 do: [:x | 0 to: image height - 1 do: [:y | image atPoint: x @ y put: x]].			image := CachedImage on: (image convertToPalette: Screen default colorPalette renderedBy: ErrorDiffusion new)].	patch label: image</body><body package="ICCColorSelector">updatePatches	| patch ditherPatch|	patch := self builder componentAt: #patch.	(patch notNil and: [patch lookPreferences backgroundColor ~= self color])		ifTrue: [patch lookPreferences: ((patch lookPreferences backgroundColor: self color)										selectionBackgroundColor: self color).				ditherPatch := self builder componentAt: #ditherPatch.				ditherPatch notNil					ifTrue:						[| pattern pix|						pattern := ((Image									extent: 16 @ 16									depth: 1									palette: (MappedPalette with: self color with: ColorValue black))										convertToPalette: Screen default colorPalette										renderedBy: OrderedDither new) asPattern.						pix := Pixmap extent: ditherPatch bounds extent.						pix graphicsContext							paint: pattern;							displayRectangle: pix bounds.						ditherPatch label: (CachedImage on: pix asImage)]]</body></methods><methods><class-id>ICC.ICCColorPicker</class-id> <category>accessing</category><body package="ICCColorSelector">color	^self colorModel value</body><body package="ICCColorSelector">color: aColorValue	self colorModel value: aColorValue</body></methods><methods><class-id>ICC.ICCColorPicker</class-id> <category>change messages</category><body package="ICCColorSelector">colorChanged	self builder isNil		ifFalse:			[self updatePatches.			self wheelPosition value: (self colorToPoint: self color).			(oldColor isNil or: [(self round: oldColor hue)					~= (self round: self color hue) or: [(self round: oldColor saturation)						~= (self round: self color saturation)]])				ifTrue: [self updateBrightnessScale]].	oldColor := self color</body><body package="ICCColorSelector">wheelPositionChanged	wheelPosition retractInterestsFor: self.	self color: (self pointToColor: self wheelPosition value).	wheelPosition onChangeSend: #wheelPositionChanged to: self</body></methods><methods><class-id>ICC.ICCColorPicker class</class-id> <category>resources</category><body package="ICCColorSelector">colorWheelImage	"Answer the image for the color wheel. Do calculation and rendering of the image if neccessary."	^Screen default colorDepth == 24		ifTrue: [self colorWheel24Bit]		ifFalse: [self colorWheel8Bit]</body><body package="ICCColorSelector">ditheredLabelImage	"UIMaskEditor new openOnClass: self andSelector: #ditheredLabelImage"	^Image extent: 37@8 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[10 72 0 0 8 0 0 0 8 72 0 0 8 0 0 0 106 235 25 76 104 0 0 0 154 76 165 146 152 0 0 0 138 72 189 30 136 0 0 0 138 72 161 16 136 0 0 0 154 72 165 18 152 0 0 0 106 104 153 12 104 0 0 0 ] pad: 32</body><body package="ICCColorSelector">emptyImage	^Image extent: 1@1 depth: 1 palette: MonoMappedPalette whiteBlack</body><body package="ICCColorSelector">markerMask	"UIMaskEditor new openOnClass: self andSelector: #markerMask"	^Image extent: 15@15 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[7 192 0 0 31 240 0 0 63 248 0 0 127 252 0 0 120 60 0 0 240 30 0 0 240 30 0 0 240 30 0 0 240 30 0 0 240 30 0 0 120 60 0 0 127 252 0 0 63 248 0 0 31 240 0 0 7 192 0 0 ] pad: 32</body><body package="ICCColorSelector">nearestLabelImage	"UIMaskEditor new openOnClass: self andSelector: #nearestLabelImage"	^Image extent: 33@8 depth: 1 palette: CoveragePalette monoMaskPalette bits: #[0 0 0 1 0 0 0 0 0 0 0 1 0 0 0 0 177 156 166 51 128 0 0 0 202 66 201 73 0 0 0 0 139 206 143 49 0 0 0 0 138 18 136 9 0 0 0 0 138 82 137 73 0 0 0 0 137 141 134 49 128 0 0 0 ] pad: 32</body></methods><methods><class-id>ICC.ICCColorPicker class</class-id> <category>private</category><body package="ICCColorSelector">colorWheel24Bit	"Answer the 24 bit image for the color wheel."	^ColorWheel24Bit</body><body package="ICCColorSelector">colorWheel8Bit	"Answer the 8 bit image for the color wheel."	^ColorWheel8Bit</body><body package="ICCColorSelector">generateColorWheel24Bit	"Generate the 24-bit color wheel image.	This is required in order to open the ICCColorPicker in 24-bit mode."	"self generateColorWheel24Bit"	| extent image maskImage center |	extent := 252 @ 252.	image := Image				extent: extent				depth: 24				palette: (FixedPalette						redShift: 0						redMask: 255						greenShift: 8						greenMask: 255						blueShift: 16						blueMask: 255).	maskImage := Image				extent: extent				depth: 1				palette: CoveragePalette monoMaskPalette.	center := extent // 2.	0 to: extent y - 1 do: [:y | 0 to: extent x - 1			do:				[:x |				| pt dpt r theta hue saturation color |				pt := x @ y.				dpt := pt - center.				r := dpt r.				theta := dpt theta.				r &lt;= center x					ifTrue:						[saturation := r / center x.						hue := theta / 2 / Float pi.						color := ColorValue									hue: hue									saturation: saturation									brightness: 1.0.						maskImage atPoint: pt put: 1]					ifFalse: [color := ColorValue black].				image atPoint: pt put: (image palette indexOfPaintNearest: color)]].	ColorWheel24Bit := OpaqueImage figure: (CachedImage on: image) shape: (CachedImage on: maskImage).	^ColorWheel24Bit</body><body package="ICCColorSelector">generateColorWheel8Bit	"Generate the 8-bit color wheel image. Uses the 24-bit version of the image	and initiates its generation if necessary.	This is required in order to open the ICCColorPicker in 8-bit mode, but it takes a while."	"self generateColorWheel8Bit"	| colorWheel24Bit renderImage |	colorWheel24Bit := self colorWheel24Bit.	renderImage := colorWheel24Bit figure asImage convertToPalette: Screen default colorPalette renderedBy: ICCPaint errorRenderer.	ColorWheel8Bit := OpaqueImage figure: (CachedImage on: renderImage) shape: colorWheel24Bit shape.	^ColorWheel8Bit</body><body package="ICCColorSelector">generateColorWheels	Cursor wait showWhile: 			[Transcript				cr;				show: 'Generating color wheel image...'.			self generateColorWheel24Bit.			self generateColorWheel8Bit.			Transcript				cr;				show: 'Done generating color wheel image.']</body></methods><methods><class-id>ICC.ICCColorPicker class</class-id> <category>interface opening</category><body package="ICCColorSelector">open	^self openOn: ColorValue white</body><body package="ICCColorSelector">openOn: aColorValue	"Open an ICCColorPicker with initial color aColorValue, then answer	nil if canceled or the new ColorValue picked"	| picker dlog |	picker := self new.	dlog := SimpleDialog new.	picker builder: dlog builder.	picker color: aColorValue.	dlog preBuildBlock: [:mdl :bldr | picker preBuildWith: bldr].	dlog postBuildBlock: [:mdl :bldr | picker postBuildWith: bldr].	dlog openFor: picker interface: #windowSpec.	^dlog accept value ifTrue: [picker color]</body></methods><methods><class-id>ICC.ICCColorPicker class</class-id> <category>initialize-release</category><body package="ICCColorSelector">initialize	"ICCColorPicker initialize"	self generateColorWheels.</body></methods><methods><class-id>ICC.ICCColorAssignmentDialog</class-id> <category>accessing</category><body package="ICCColorSelector">colorAssigner	^colorAssigner</body></methods><methods><class-id>ICC.ICCColorAssignmentDialog</class-id> <category>actions</category><body package="ICCColorSelector">doAccept	colorAssigner doAccept.	^self closeRequest</body><body package="ICCColorSelector">doApply	colorAssigner doAccept</body><body package="ICCColorSelector">doCancel	colorAssigner doCancel.	^self closeRequest</body></methods><methods><class-id>ICC.ICCColorAssignmentDialog</class-id> <category>private</category><body package="ICCColorSelector">canAccept: aBoolean	(self builder componentAt: #accept) widget isEnabled: aBoolean.	(self builder componentAt: #apply) widget isEnabled: aBoolean</body><body package="ICCColorSelector">colorsChanged	self canAccept: self colorAssigner colorsChanged</body></methods><methods><class-id>ICC.ICCColorAssignmentDialog</class-id> <category>initialize-release</category><body package="ICCColorSelector">paint: anICCPaint	colorAssigner := ICCColorAssigner new paint: anICCPaint.	colorAssigner colorsChangedHolder onChangeSend: #colorsChanged to: self.</body></methods><methods><class-id>ICC.ICCColorAssignmentDialog class</class-id> <category>interface opening</category><body package="ICCColorSelector">open	^Dialog error: 'Use #openWith: to open.'</body><body package="ICCColorSelector">openWith: anICCPaint	self new paint: anICCPaint; open</body></methods><methods><class-id>ICC.ICCTransparentFractionalWidgetView</class-id> <category>initialize-release</category><body package="ICCColorSelector">axis: aPoint	axis = aPoint		ifFalse:			[axis := aPoint.			self invalidate].	self initializeMarker</body><body package="ICCColorSelector">beHorizontal	self axis: 1 @ 0</body><body package="ICCColorSelector">beTwoDimensional	self axis: 1 @ 1</body><body package="ICCColorSelector">beVertical	self axis: 0 @ 1</body><body package="ICCColorSelector">initialize	super initialize.	self beVertical.	markerBlock := [Rectangle origin: 0 @ 0 extent: 4 @ 4 * axis transpose + (4 @ 4)].	self initializeMarker.	markerBlock := [markerImage bounds].	controlActive := false</body><body package="ICCColorSelector">initializeMarker	markerImage := (Mask extent: 4 @ 4 * axis transpose + (4 @ 4)) asImage</body><body package="ICCColorSelector">markerBlock: aBlock	"Set the block that computes the marker."	markerBlock := aBlock.	self invalidate</body></methods><methods><class-id>ICC.ICCTransparentFractionalWidgetView</class-id> <category>accessing</category><body package="ICCColorSelector">map: aPoint	" Answer a fraction between 0 and 1,	corresponding to the position of aPoint	in the visual space.  If both X and Y axes	are active, answer a Point rather than	a number. "	| markExtent diff pos |	markExtent := markerBlock value extent.	diff := self bounds extent - markExtent.	pos := (aPoint x asFloat @ aPoint y asFloat - (markExtent // 2) / diff max: 0.0@0.0) min: 1.0@1.0.	^axis x + axis y &gt; 1		ifTrue: [pos]		ifFalse: [pos dotProduct: axis]</body><body package="ICCColorSelector">markerImage: anImage	"Call this AFTER the initialize methods (beVertical, etc.)"	markerImage := anImage</body></methods><methods><class-id>ICC.ICCTransparentFractionalWidgetView</class-id> <category>displaying</category><body package="ICCColorSelector">displayOn: aGC	| marker diff rect oldRect |	"refrain from displaying if the mouse is down and my controller has control"	(controlActive and: [self controller sensor redButtonPressed])		ifTrue: [^self].	aGC paint: self foregroundColor.	marker := markerBlock value.	diff := self bounds extent - marker extent.	rect := marker translatedBy: (diff * axis * model value) rounded + (diff // 2 * (1 @ 1 - axis)).	(savedPos isNil or: [savedPos = model value])		ifFalse: [oldRect := marker translatedBy: (diff * axis * savedPos) rounded + (diff // 2 * (1 @ 1 - axis)).				savedBkgdPatch displayOn: aGC at: oldRect origin].	savedPos = model value		ifFalse: [savedBkgdPatch := (Screen default contentsOfArea: (rect translatedBy: (self localPointToGlobal: 0@0 + self topComponent globalOrigin))) first].	savedPos := model value.	markerImage displayOn: aGC at: rect origin</body></methods><methods><class-id>ICC.ICCTransparentFractionalWidgetView</class-id> <category>controller accessing</category><body package="ICCColorSelector">defaultController	^self defaultControllerClass new		controlBlock:			[:pt :state |			state == #down ifTrue: [model value: (self map: pt)].			(state == #wentUp or: [state == #up])				ifTrue: [model changed: state]]</body><body package="ICCColorSelector">defaultControllerClass	^WidgetController</body></methods><methods><class-id>ICC.ICCTransparentFractionalWidgetView</class-id> <category>updating</category><body package="ICCColorSelector">update: aspectSymbol	"Instead of repainting the whole view, invalidate the old marker and draw the new"	aspectSymbol == #wentUp ifTrue: [(savedPos isNil or: [savedPos = model value])			ifFalse: [self displayOn: self graphicsContext]].	aspectSymbol == #up ifTrue: [model value = savedPos ifFalse: [model value: savedPos]].	aspectSymbol == #value ifTrue: [model value = savedPos ifFalse: [self displayOn: self graphicsContext]]</body></methods><methods><class-id>ICC.ICCTransparentFractionalWidgetView</class-id> <category>control</category><body package="ICCColorSelector">startUp	controlActive := true.	[super startUp]		valueNowOrOnUnwindDo: [controlActive := false]</body></methods><methods><class-id>ICC.ICCColorBoxView</class-id> <category>bounds accessing</category><body package="ICCColorSelector">preferredBounds	"Answer the preferred bounding rectangle for the receiver"	^2 @ 2 extent: 18 @ 12</body></methods><methods><class-id>ICC.ICCColorBoxView</class-id> <category>visual properties</category><body package="ICCColorSelector">bottomRightColor	^self isSelected		ifTrue: [self hiliteColor]		ifFalse: [self shadowColor]</body><body package="ICCColorSelector">hiliteColor	"Answer the color to use to paint highlighted edges."	^ICCPaint brighter: self backgroundColor</body><body package="ICCColorSelector">shadowColor	"Answer the color to use to paint shadowed edges."	^ICCPaint darker: self backgroundColor</body><body package="ICCColorSelector">topLeftColor	^self isSelected		ifTrue: [self shadowColor]		ifFalse: [self hiliteColor]</body></methods><methods><class-id>ICC.ICCColorBoxView</class-id> <category>accessing</category><body package="ICCColorSelector">backgroundColor	color isNil ifTrue: [color := nil asValue].	^color value isNil		ifTrue: [super backgroundColor]		ifFalse: [color value]</body><body package="ICCColorSelector">backgroundColor: aColorValue	color isNil		ifTrue: [self backgroundColorAspect: aColorValue asValue]		ifFalse: [color value: aColorValue]</body><body package="ICCColorSelector">backgroundColorAspect: aColorValueHolder	color notNil ifTrue: [color retractInterestsFor: self].	color := aColorValueHolder.	color onChangeSend: #invalidate to: self.	self invalidate</body></methods><methods><class-id>ICC.ICCColorBoxView</class-id> <category>displaying</category><body package="ICCColorSelector">displayBackgroundIfNeededOn: aGraphicsContext in: aRectangle	self displayBackgroundOn: aGraphicsContext in: aRectangle</body><body package="ICCColorSelector">displayBevelingOn: aGraphicsContext in: aRectangle	| box line |	box := Rectangle origin: aRectangle origin extent: aRectangle extent - 1.	line := Array with: box bottomLeft with: box topLeft with: box topRight.	aGraphicsContext		paint: self topLeftColor;		displayPolyline: line.	line at: 2 put: box bottomRight.	aGraphicsContext		paint: self bottomRightColor;		displayPolyline: line.	box := box insetBy: 1.	line := Array with: box bottomLeft with: box topLeft with: box topRight.	aGraphicsContext		paint: self topLeftColor;		displayPolyline: line.	line at: 2 put: box bottomRight.	aGraphicsContext		paint: self bottomRightColor;		displayPolyline: line.</body><body package="ICCColorSelector">displayOn: aGC	"Display the button on aGraphicsContext not considering the decoration state."	| box offset aGraphicsContext |	aGraphicsContext := aGC copy.	box := self bounds.	aGraphicsContext paint: self borderColor.	self displayBevelingOn: aGraphicsContext in: box.	box := box insetBy: 2.	ICCPaint installPaintPolicyOn: aGraphicsContext.	self displayBackgroundIfNeededOn: aGraphicsContext in: box.	aGraphicsContext intersectClip: box.	label == nil		ifFalse:			[offset := self translation + box center - (label bounds extent // 2).			self setPaintOn: aGraphicsContext.			label displayOn: aGraphicsContext at: offset].	self hasFocus ifTrue: [self displayTraversalHiliteOn: aGraphicsContext]</body><body package="ICCColorSelector">displayTraversalHiliteOn: aGraphicsContext	"Display indication that the receiver has keyboard focus."	aGraphicsContext paint: self traversalHiliteColor.	aGraphicsContext displayInteriorRectangularBorder: (self bounds insetBy: 4@4)</body><body package="ICCColorSelector">invalidate	"Invalidate the receiver's bounding box.	Propagate the damage rectangle up the containment hierarchy.	This will result in a displayOn: aGraphicsContext being sent to the receiver."	self invalidateRectangle: self bounds</body></methods><methods><class-id>ICC.ICCColorBoxView</class-id> <category>private</category><body package="ICCColorSelector">normalBox	^self bounds</body><body package="ICCColorSelector">redisplayActiveArea	self simpleRedisplayIn: self normalBox colorBackgroundIfNeeded: false</body><body package="ICCColorSelector">setPaintOn: aGraphicsContext	"Set the foreground color for the display of the receiver's label."	aGraphicsContext paint: self foregroundColor</body><body package="ICCColorSelector">translation	^self isSelected		ifTrue: [1 @ 1]		ifFalse: [-1 @ -1]</body></methods><methods><class-id>ICC.ICCPaint</class-id> <category>copying</category><body package="ICCColorSelector">postCopy	| sDict |	super postCopy.	sDict := Dictionary new.	symbolicColorDictionary keysAndValuesDo: [:key :value | sDict at: key put: value ].	symbolicColorDictionary := sDict.	indexedColors := indexedColors copy</body></methods><methods><class-id>ICC.ICCPaint</class-id> <category>encode-decode</category><body package="ICCColorSelector">encodeDictionary: aDictionary	"Private - Create an encoding usable for Dictionary withKeysAndValues:"	| array index |	array := Array new: aDictionary size * 2.	index := 0.	aDictionary		keysAndValuesDo:			[:key :value |			array at: (index := index + 1) put: key literalArrayEncoding.			array at: (index := index + 1) put: value literalArrayEncoding].	^array</body><body package="ICCColorSelector">fromLiteralArrayEncoding: anArray	2 to: anArray size by: 2 do:		[:i | self perform: (anArray at: i) with: (anArray at: i+1)].	self symbolicColorDictionary: (Dictionary withKeysAndValues:		(self symbolicColorDictionary collect: [:each | each decodeAsLiteralArray])).	self indexedColors: (self indexedColors collect: [:each |		each decodeAsLiteralArray])</body><body package="ICCColorSelector">literalArrayEncoding	^(Array new: 5)		at: 1 put: self class name;		at: 2 put: #symbolicColorDictionary:;		at: 3 put: (self encodeDictionary: self symbolicColorDictionary);		at: 4 put: #indexedColors:;		at: 5 put: (self indexedColors collect: [:each | each literalArrayEncoding]);		yourself</body></methods><methods><class-id>ICC.ICCPaint</class-id> <category>initialize-release</category><body package="ICCColorSelector">addName: colorName forColor: colorValue	"Private - This is called by my own class from #addSymbolicColor:ifAbsent.	The reason for this indirection is that we want all instances of any subclass of ICCPaint	to know the same list of symbolic colors.	(#addSymbolicColor invokes this method for all instances of that class.)"	symbolicColorDictionary at: colorName put: colorValue</body><body package="ICCColorSelector">initialize	symbolicColorDictionary := self class defaultSymbolicColors.	indexedColors := self class defaultIndexedColors</body></methods><methods><class-id>ICC.ICCPaint</class-id> <category>accessing</category><body package="ICCColorSelector">indexedColors	^indexedColors</body><body package="ICCColorSelector">indexedColors: anArrayOfColors	anArrayOfColors size = 20		ifTrue: [indexedColors := anArrayOfColors]		ifFalse: [Dialog error: 'ICCPaint interface violation: ColorArrays have to contain exactly twenty items.']</body><body package="ICCColorSelector">symbolicColorDictionary	"&lt;Dictionary&gt; - Return a copy of the dictionary to enable the sender to change the contents but not	the set of the associations."	^symbolicColorDictionary copy</body><body package="ICCColorSelector">symbolicColorDictionary: aDictionary	symbolicColorDictionary := aDictionary</body></methods><methods><class-id>ICC.ICCPaint</class-id> <category>symbolic color accessing</category><body package="ICCColorSelector">doesNotUnderstand: aMessage	"Instances of ICCPaint should understand symbolic color names as messages.	If aMessage is not understood, check if it is a symbolic color name.	If so, return its color value; if not, raise the debugger.	Added support for new color values:		If a colorValue is not part of the dictionary of the single instance,		but is part of the defaults, it'll be added.	For each key of symbolicColorDictionary this simulates the following method:	&lt;key&gt;		^symbolicColorDictionary at: &lt;key&gt;"	^symbolicColorDictionary at: aMessage selector		ifAbsent:			[self class addSymbolicColor: aMessage selector				ifAbsent: [super doesNotUnderstand: aMessage]]</body></methods><methods><class-id>ICC.ICCPaint class</class-id> <category>instance creation</category><body package="ICCColorSelector">new	^super new initialize</body></methods><methods><class-id>ICC.ICCPaint class</class-id> <category>utilities</category><body package="ICCColorSelector">addSymbolicColor: colorName ifAbsent: aBlock	| colorValue |	colorValue := self defaultSymbolicColors at: colorName				ifAbsent: [^aBlock value].	self allInstances		do: [:paint | paint addName: colorName forColor:colorValue].	^colorValue</body><body package="ICCColorSelector">brighter: aColorValue	"^&lt;ColorValue&gt; Answer a brighter version of aColorValue.	If the Color Value is a SymbolicPaint, answer itself, since I don't know how to modify this ones at	the moment."	(aColorValue isKindOf: SymbolicPaint)		ifTrue: [^aColorValue].	aColorValue brightness = 0 ifTrue: [^ColorValue gray].	^ColorValue		hue: aColorValue hue		saturation: aColorValue saturation / 2		brightness: (aColorValue brightness / 0.7 min: 1)</body><body package="ICCColorSelector">darker: aColorValue	"^&lt;ColorValue&gt; Answer a darker version of aColorValue."	(aColorValue isKindOf: SymbolicPaint)		ifTrue: [^aColorValue].	^ColorValue		hue: aColorValue hue		saturation: aColorValue saturation		brightness: aColorValue brightness * 0.7</body><body package="ICCColorSelector">defaultRenderer	"Unlike ObjectShare, we want the colors to be dithered up to a depth of 8 bits."	^Screen default colorDepth &lt;= 8		ifTrue: [OrderedDither new]		ifFalse: [NearestPaint new]</body><body package="ICCColorSelector">errorRenderer	"Unlike ObjectShare, we want the colors to be dithered up to a depth of 8 bits."	^Screen default colorDepth &lt;= 8		ifTrue: [ErrorDiffusion new]		ifFalse: [NearestPaint new]</body><body package="ICCColorSelector">installPaintPolicyOn: aGraphicsContext	| renderer |	renderer := self defaultRenderer.	aGraphicsContext paintPolicy: ((PaintPolicy new) imageRenderer: renderer; paintRenderer: renderer)</body></methods><methods><class-id>ICC.ICCPaint class</class-id> <category>encode-decode</category><body package="ICCColorSelector">decodeFromLiteralArray: anArray	^self new fromLiteralArrayEncoding: anArray</body></methods><methods><class-id>ICC.ICCPaint class</class-id> <category>default colors</category><body package="ICCColorSelector">defaultIndexedColors	^(Array new: 20)		at: 1 put: (ColorValue white);		at: 2 put: (ColorValue brightness: 0.749969);		at: 3 put: (ColorValue gray);		at: 4 put: (ColorValue black);		at: 5 put: (ColorValue red: 1.0 green: 0.500061 blue: 0.750946);		at: 6 put: (ColorValue salmon);		at: 7 put: (ColorValue red: 1.0 green: 0.800024 blue: 0.500061);		at: 8 put: (ColorValue lightYellow);		at: 9 put: (ColorValue red: 0.800024 green: 1.0 blue: 0.500061);		at: 10 put: (ColorValue paleGreen);		at: 11 put: (ColorValue red: 0.500061 green: 1.0 blue: 0.751068);		at: 12 put: (ColorValue lightCyan);		at: 13 put: (ColorValue red: 0.500061 green: 0.800024 blue: 1.0);		at: 14 put: (ColorValue royalBlue);		at: 15 put: (ColorValue red: 0.800024 green: 0.500061 blue: 1.0);		at: 16 put: (ColorValue orchid);		at: 17 put: (ColorValue red: 0.500061 green: 0.250031 blue: 0.257111);		at: 18 put: (ColorValue red: 0.500061 green: 0.500061 blue: 0.250031);		at: 19 put: (ColorValue red: 0.250031 green: 0.500061 blue: 0.312782);		at: 20 put: (ColorValue red: 0.250031 green: 0.250031 blue: 0.500061);		yourself</body><body package="ICCColorSelector">defaultSymbolicColors	^Dictionary new</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>ICCColorSelector extension</category><body package="ICCColorSelector">colorBox: spec into: builder	| component model rv |	model := spec modelInBuilder: builder.	component := self colorBoxClass model: model.	self setTheLabelFor: spec component: component in: builder.	(rv := spec select) == nil		ifFalse: [component setReferenceValue: rv].	component controller: RadioButtonController new.	self setDispatcherOf: component fromSpec: spec builder: builder.	spec tabable		ifTrue: [component widgetState isTabStop: true.				builder sendKeyboardTo: component].	component widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [component widgetState isVisible: spec initiallyVisible].	builder component: component.	builder wrapWith: (self simpleWrapperFor: spec).	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body><body package="ICCColorSelector">colorBoxClass	^ICC.ICCColorBoxView</body></methods><methods><class-id>ICC.ICCColorBoxSpec class</class-id> <category>resources</category><body package="ICCColorSelector">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 3 bitsPerPixel: 4 palette: (MappedPalette withColors: ((Array new: 6) at: 1 put: ColorValue black; at: 2 put: (ColorValue scaledRed: 6553 scaledGreen: 6553 scaledBlue: 6553); at: 3 put: (ColorValue scaledRed: 3822 scaledGreen: 3822 scaledBlue: 3822); at: 4 put: ColorValue white; at: 5 put: ColorValue red; at: 6 put: (ColorValue scaledRed: 4112 scaledGreen: 0 scaledBlue: 0); yourself)) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@L3L3L3L3L3L3L3L2@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQEDQDQDQDQDQQDR@@@@@CDQQEQTUEQTUETQD @@@@@1DTUEQTUEQTUEDQH@@@@@LQEDUEQTUEQTUQDR@@@@@CDQQTUEQTUEQTTQD @@@@@1DTQTUEQTUEQUDQH@@@@@LQEEQTUEQTUEQQDR@@@@@CDQQEQTUEQTUETQD @@@@@1DTUEQTUEQTUEDQH@@@@@LQEDUEQTUEQTUQDR@@@@@CDQUUUUUUUUUUTQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@1DQDQDQDQDQDQDQH@@@@@LQDQDQDQDQDQDQDR@@@@@CDQDQDQDQDQDQDQD @@@@@"H"H"H"H"H"H"H"H@@@@@@@@@@@@@@@@@@@@@@@@@@b'))</body><body package="ICCColorSelector">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[255 255 255 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 135 255 248 192 133 85 92 192 134 170 172 192 133 85 92 192 134 170 172 192 133 85 92 192 134 170 172 192 133 85 92 192 134 170 172 192 133 85 92 192 135 255 252 192 131 255 252 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 128 0 0 192 255 255 255 192 255 255 255 192])</body></methods><methods><class-id>ICC.ICCColorSelector class</class-id> <category>interface specs</category><body package="ICCColorSelector">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Colors' 			#min: #(#{Core.Point} 118 132 ) 			#max: #(#{Core.Point} 118 132 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 694 564 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 1 0 -1 0.25 -6 0.2 ) 					#name: #activeColor01 					#model: #activeColor 					#select: #activeColor01 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.25 1 0 -1 0.5 -6 0.2 ) 					#name: #activeColor02 					#model: #activeColor 					#select: #activeColor02 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 1 0 -1 0.75 -6 0.2 ) 					#name: #activeColor03 					#model: #activeColor 					#select: #activeColor03 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.75 1 0 -1 1 -6 0.2 ) 					#name: #activeColor04 					#model: #activeColor 					#select: #activeColor04 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -4 0.2 -1 0.25 -11 0.4 ) 					#name: #activeColor05 					#model: #activeColor 					#select: #activeColor05 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.25 -4 0.2 -1 0.5 -11 0.4 ) 					#name: #activeColor06 					#model: #activeColor 					#select: #activeColor06 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 -4 0.2 -1 0.75 -11 0.4 ) 					#name: #activeColor07 					#model: #activeColor 					#select: #activeColor07 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.75 -4 0.2 -1 1 -11 0.4 ) 					#name: #activeColor08 					#model: #activeColor 					#select: #activeColor08 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -9 0.4 -1 0.25 -16 0.6 ) 					#name: #activeColor09 					#model: #activeColor 					#select: #activeColor09 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.25 -9 0.4 -1 0.5 -16 0.6 ) 					#name: #activeColor10 					#model: #activeColor 					#select: #activeColor10 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 -9 0.4 -1 0.75 -16 0.6 ) 					#name: #activeColor11 					#model: #activeColor 					#select: #activeColor11 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.75 -9 0.4 -1 1 -16 0.6 ) 					#name: #activeColor12 					#model: #activeColor 					#select: #activeColor12 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -14 0.6 -1 0.25 -21 0.8 ) 					#name: #activeColor13 					#model: #activeColor 					#select: #activeColor13 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.25 -14 0.6 -1 0.5 -21 0.8 ) 					#name: #activeColor14 					#model: #activeColor 					#select: #activeColor14 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 -14 0.6 -1 0.75 -21 0.8 ) 					#name: #activeColor15 					#model: #activeColor 					#select: #activeColor15 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.75 -14 0.6 -1 1 -21 0.8 ) 					#name: #activeColor16 					#model: #activeColor 					#select: #activeColor16 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -19 0.8 -1 0.25 -27 1 ) 					#name: #activeColor17 					#model: #activeColor 					#select: #activeColor17 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.25 -19 0.8 -1 0.5 -27 1 ) 					#name: #activeColor18 					#model: #activeColor 					#select: #activeColor18 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.5 -19 0.8 -1 0.75 -27 1 ) 					#name: #activeColor19 					#model: #activeColor 					#select: #activeColor19 ) 				#(#{ICC.ICCColorBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0.75 -19 0.8 -1 1 -27 1 ) 					#name: #activeColor20 					#model: #activeColor 					#select: #activeColor20 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -25 1 -1 1 -1 1 ) 					#name: #changeColor 					#model: #changeColor 					#label: 'More Colors...' 					#isDefault: false 					#defaultable: true ) ) ) )</body></methods><methods><class-id>ICC.ICCColorSelectionDialog class</class-id> <category>interface specs</category><body package="ICCColorSelector">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Select color' 			#min: #(#{Core.Point} 114 160 ) 			#max: #(#{Core.Point} 114 160 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 690 592 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -28 1 ) 					#name: #colorSelector 					#flags: 0 					#majorKey: #{ICC.ICCColorSelector} 					#minorKey: #windowSpec 					#clientKey: #colorSelector ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 1 0 -25 1 -2 0.5 -1 1 ) 					#name: #accept 					#model: #accept 					#label: 'OK' 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 -25 1 -1 1 -1 1 ) 					#name: #cancel 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>ICC.ICCColorAssigner class</class-id> <category>interface specs</category><body package="ICCColorSelector">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec		#window:		#(#WindowSpec			#label: 'Assign colors'			#bounds: #(#Rectangle 369 415 746 571 ) )		#component:		#(#SpecCollection			#collection: #(				#(#MenuButtonSpec					#layout: #(#Rectangle -278 241 -77 266 ) )				#(#SequenceViewSpec					#layout: #(#LayoutFrame 4 0 4 0 -14 0.666666 -4 1 )					#name: #symbolicColorNames					#model: #symbolicColorNames					#useModifierKeys: true					#selectionType: #highlight )				#(#ActionButtonSpec					#layout: #(#LayoutFrame -10 0.666666 -26 0.5 10 0.666666 -2 0.5 )					#name: #toLeft					#flags: 40					#model: #toLeft					#label: '&lt;&lt;'					#style: #pixelDefault					#defaultable: true )				#(#ActionButtonSpec					#layout: #(#LayoutFrame -10 0.666666 2 0.5 10 0.666666 26 0.5 )					#name: #toRight					#flags: 40					#model: #toRight					#label: '&gt;&gt;'					#style: #pixelDefault					#defaultable: true )				#(#SubCanvasSpec					#layout: #(#LayoutFrame 14 0.666666 4 0 -4 1 -4 1 )					#name: #colorSelector					#majorKey: #ICCColorSelector					#minorKey: #windowSpec					#clientKey: #colorSelector ) ) ) )</body></methods><methods><class-id>ICC.ICCColorPicker class</class-id> <category>interface specs</category><body package="ICCColorSelector">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Color Picker' 			#min: #(#{Core.Point} 561 274 ) 			#max: #(#{Core.Point} 561 274 ) 			#bounds: #(#{Graphics.Rectangle} 576 432 1137 706 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 5 5 261 261 ) 					#name: #colorWheelImage 					#label: #colorWheelImage 					#hasCharacterOrientedLabel: false ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 289 189 334 246 ) 					#name: #patchRegion 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) 						#setHiliteColor: #(#{Graphics.ColorValue} #gray ) 						#setShadowColor: #(#{Graphics.ColorValue} #black ) ) 					#lineWidth: 1 ) 				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.Rectangle} 5 5 261 261 ) 					#name: #wheelSlider 					#flags: 0 					#component: #wheelSliderView ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 333 189 378 246 ) 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) 						#setHiliteColor: #(#{Graphics.ColorValue} #gray ) 						#setShadowColor: #(#{Graphics.ColorValue} #black ) ) 					#lineWidth: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 332 188 377 245 ) 					#name: #ditherPatch 					#label: #emptyImage 					#hasCharacterOrientedLabel: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 294 175 ) 					#name: #nearestLabel 					#label: #nearestLabelImage 					#style: #small 					#hasCharacterOrientedLabel: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 334 175 ) 					#name: #ditheredLabel 					#label: #ditheredLabelImage 					#style: #small 					#hasCharacterOrientedLabel: false ) 				#(#{UI.RegionSpec} 					#layout: #(#{Graphics.Rectangle} 410 155 540 180 ) 					#lineWidth: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 409 154 539 179 ) 					#name: #brightnessScale 					#label: #emptyImage 					#hasCharacterOrientedLabel: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 290 190 333 245 ) 					#name: #patch 					#flags: 0 					#isOpaque: true 					#model: #matchNearestPaint 					#tabable: false ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 270 10 395 160 ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 400 10 550 200 ) ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 270 165 395 255 ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 275 25 ) 					#label: 'Red:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 315 20 385 45 ) 					#name: #redText 					#model: #red 					#alignment: #right 					#type: #number ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 315 50 385 60 ) 					#name: #redSlider 					#model: #red 					#orientation: #horizontal 					#start: 0 					#stop: 255 					#step: 1 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 315 65 385 90 ) 					#name: #greenText 					#model: #green 					#alignment: #right 					#type: #number ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 315 95 385 105 ) 					#name: #greenSlider 					#model: #green 					#orientation: #horizontal 					#start: 0 					#stop: 255 					#step: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 275 115 ) 					#label: 'Blue:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 315 110 385 135 ) 					#name: #blueText 					#model: #blue 					#alignment: #right 					#type: #number ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 315 140 385 150 ) 					#name: #blueSlider 					#model: #blue 					#orientation: #horizontal 					#start: 0 					#stop: 255 					#step: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 410 25 ) 					#label: 'Hue:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 470 0 20 0 540 0 45 0 ) 					#name: #hueText 					#model: #hue 					#alignment: #right 					#type: #number ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 470 50 540 60 ) 					#name: #hueSlider 					#model: #hue 					#orientation: #horizontal 					#start: 0 					#stop: 255 					#step: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 410 70 ) 					#label: 'Saturation:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 470 0 65 0 540 0 90 0 ) 					#name: #saturationText 					#model: #saturation 					#alignment: #right 					#type: #number ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 470 95 540 105 ) 					#name: #saturationSlider 					#model: #saturation 					#orientation: #horizontal 					#start: 0 					#stop: 255 					#step: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 410 115 ) 					#label: 'Brightness:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 470 0 110 0 540 0 135 0 ) 					#name: #brightnessText 					#model: #brightness 					#alignment: #right 					#type: #number ) 				#(#{UI.SliderSpec} 					#layout: #(#{Graphics.Rectangle} 410 140 540 150 ) 					#name: #brightnessSlider 					#model: #brightness 					#orientation: #horizontal 					#start: 0 					#stop: 255 					#step: 1 ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 400 230 473 255 ) 					#name: #accept 					#model: #accept 					#tabable: true 					#label: 'OK' 					#isDefault: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 475 230 552 255 ) 					#name: #cancel 					#model: #cancel 					#tabable: true 					#label: 'Cancel' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 275 70 ) 					#name: #Label1 					#label: 'Green:' ) ) ) )</body></methods><methods><class-id>ICC.ICCColorAssignmentDialog class</class-id> <category>interface specs</category><body package="ICCColorSelector">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec		#window:		#(#WindowSpec			#label: 'Assign colors'			#bounds: #(#Rectangle 452 434 829 590 ) )		#component:		#(#SpecCollection			#collection: #(				#(#MenuButtonSpec					#layout: #(#Rectangle -278 241 -77 266 ) )				#(#ActionButtonSpec					#layout: #(#LayoutFrame -226 1 -28 1 -156 1 -4 1 )					#name: #apply					#flags: 40					#model: #doApply					#label: '&amp;Apply'					#defaultable: true )				#(#ActionButtonSpec					#layout: #(#LayoutFrame -150 1 -28 1 -80 1 -4 1 )					#name: #accept					#flags: 40					#model: #doAccept					#label: 'OK'					#defaultable: true )				#(#ActionButtonSpec					#layout: #(#LayoutFrame -74 1 -28 1 -4 1 -4 1 )					#name: #cancel					#model: #doCancel					#label: 'Cancel'					#defaultable: true )				#(#SubCanvasSpec					#layout: #(#LayoutFrame 0 0 0 0 0 1 -30 1 )					#name: #ICCColorAssigner					#flags: 0					#majorKey: #ICCColorAssigner					#minorKey: #windowSpec					#clientKey: #colorAssigner ) ) ) )</body></methods><initialize><class-id>ICC.ICCColorPicker</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>View</name><environment>UI</environment><super>Graphics.DependentPart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controller </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>RadioButtonSpec</name><environment>UI</environment><super>UI.ButtonSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>select </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>RadioButtonView</name><environment>UI</environment><super>UI.ControlWithLabelView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>