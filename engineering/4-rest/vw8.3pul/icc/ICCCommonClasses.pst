<?xml version="1.0"?><st-source><!-- Name: ICCCommonClassesComment: Copyright ©1997-2008 by IC&C GmbH, Software Foundations.All rights reserved.DbIdentifier: bear73DbTrace: 292368DbUsername: iccdevDbVersion: 7.6_01DevelopmentPrerequisites: #(#(#package 'ICCResources' '7.6_01'))PackageName: ICCCommonClassesParcel: #('ICCCommonClasses')ParcelName: ICCCommonClassesPrerequisiteParcels: #(#('ICCResources' '7.6_01'))PrintStringCache: (7.6_01,iccdev)Version: 7.6_01VersionDate: 02/28/2008Date: 5:08:51 PM May 26, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (may17.4) of May 26, 2017 on May 26, 2017 at 5:08:51 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ICC1SimpleDialog</name><environment>ICC</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C ADvance Support</category><attributes><package>ICCCommonClasses</package></attributes></class><comment><class-id>ICC.ICC1SimpleDialog</class-id><body>This subclass of SimpleDialog provides some extra behavior for handling components.</body></comment><class><name>ICC1Dialog</name><environment>ICC</environment><super>ICC.ICC1SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title infoIconBlock buttonAlignment margin minButtonWidth openCentered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C ADvance Support</category><attributes><package>ICCCommonClasses</package></attributes></class><comment><class-id>ICC.ICC1Dialog</class-id><body>This subclass of ICCSimpleDialog provides some extra behavior for user requests and notifications.@See $&gt;'examples'.Instance Variables:	title				&lt;String&gt;				The dialogs window title.	infoIconBlock	&lt;BlockClosure | nil&gt;		Answers an optional icon - exclamation, stop, etc.	margin			&lt;Point&gt;					The side and bottom margin.	buttonAlignment	&lt;#left | #right | #center&gt;	How to align the buttons at the dialog bottom.	minButtonWidth	&lt;Integer&gt;				The minimal width of the buttons at the dialog bottom.	openCentered	&lt;Boolean&gt;				Wether the dialog should open centered to Screen</body></comment><class><name>ICC1ProgressDialog</name><environment>ICC</environment><super>ICC.ICC1Dialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>progress infoField1 infoField2 remainingTimeField animationProcess actionProcess startTime </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C ADvance Support</category><attributes><package>ICCCommonClasses</package></attributes></class><comment><class-id>ICC.ICC1ProgressDialog</class-id><body>This abstract class provides behaviour for creation of animated progess dialogs.Instance Variables:	infoField1				&lt;ValueHolder on: String&gt;	infoField2 				&lt;ValueHolder on: String&gt;	progress				&lt;ValueHolder on: Number&gt;	remainingTimeField 		&lt;ValueHolder on: String&gt;	animationProcess 		&lt;Process&gt;	actionProcess			&lt;Process&gt;	startTime	 			&lt;Time&gt;</body></comment><class><name>ICC1Wizard</name><environment>ICC</environment><super>ICC.ICC1SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>page </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C ADvance Support</category><attributes><package>ICCCommonClasses</package></attributes></class><comment><class-id>ICC.ICC1Wizard</class-id><body>This is an abstract superclass for Wizards. It provides a predefined window spec for the wizard layout, reusable button bars and tiny framework for moving forward and backward through the wizard's pages.Instance Variables:	page		&lt;Symbol&gt;				This indicates the wizard's current page.Subclasses must implement the following messages:	Instance protocol:		actions			next			back		pages			initialPage</body></comment><class><name>ICC1Utils</name><environment>ICC</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C ADvance Support</category><attributes><package>ICCCommonClasses</package></attributes></class><comment><class-id>ICC.ICC1Utils</class-id><body>This class is a repository for a lot of snippets of code that permit reflection about the system, such as asking for the system version.Some of these tools seem to have no natural home. Others might have a natural home that is part of the development environment -- in order to be reduce system modifications and extensions we've choosen this class as a home for it.</body></comment><class><name>ICC1AboutDialog</name><environment>ICC</environment><super>ICC.ICC1SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logo infoText windowLabel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C ADvance Support</category><attributes><package>ICCCommonClasses</package></attributes></class><comment><class-id>ICC.ICC1AboutDialog</class-id><body>This class implements a generic application info dialog. @See $&gt;'interface opening'for usage.Instance Variables:	logo			&lt;Image&gt;	infoText			&lt;ValueHolder on: Text&gt;	windowLabel	&lt;String&gt;</body></comment><class><name>ICC1ApplicationModel</name><environment>ICC</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>IC&amp;C ADvance Support</category><attributes><package>ICCCommonClasses</package></attributes></class><comment><class-id>ICC.ICC1ApplicationModel</class-id><body>This is an abstract subclass of ApplicationModel providing some extra behavior.</body></comment><methods><class-id>ICC.ICC1SimpleDialog</class-id> <category>actions</category><body package="ICCCommonClasses">doAccept	accept value: true.	self closeAccept</body></methods><methods><class-id>ICC.ICC1SimpleDialog</class-id> <category>private</category><body package="ICCCommonClasses">iccDialog	^ICC1Dialog</body><body package="ICCCommonClasses">initializeBuilderFor: aVisualOrNil	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow. It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection	between the dialog and the window that created it."	"Use the WidgetPolicy From Parent."	| tc vis |	vis := aVisualOrNil.	(vis isNil and: [GuessParentWindow])		ifTrue: [vis := UI.Dialog defaultParentWindow].	vis isNil ifTrue: [^self].	tc := vis topComponent.	tc isNil		ifTrue: [builder policy: vis widgetPolicy lookPolicyClass new]		ifFalse: [builder policy: tc widgetPolicy lookPolicyClass new]</body></methods><methods><class-id>ICC.ICC1SimpleDialog</class-id> <category>interface opening</category><body package="ICCCommonClasses">preBuildWith: aBuilder	super preBuildWith: aBuilder.	self iccChangeLookPolicyWith: aBuilder</body></methods><methods><class-id>ICC.ICC1SimpleDialog class</class-id> <category>resources</category><body package="ICCCommonClasses">applicationIcon	^self resources iconFor: self named: #applicationImage</body><body package="ICCCommonClasses">opaqueApplicationImage	^self resources opaqueImageFor: self named: #applicationImage</body></methods><methods><class-id>ICC.ICC1SimpleDialog class</class-id> <category>accessing</category><body package="ICCCommonClasses">resources	^ICC1Images</body></methods><methods><class-id>ICC.ICC1Dialog</class-id> <category>interface construction</category><body package="ICCCommonClasses">addButtonGap	self addGap: 6</body><body package="ICCCommonClasses">addDivider	| height layout field |	height := builder window displayBox height.	layout := Graphics.LayoutFrame new.	layout leftOffset: self margin x.	layout rightFraction: 1 offset: self margin x negated.	layout topOffset: height.	layout bottomOffset: height + 4.	field := UI.DividerSpec layout: layout.	builder add: field.	self addGap: 4.	^builder wrapper</body><body package="ICCCommonClasses">addIcon: anImage	| aLabelSpec |	(aLabelSpec := UI.LabelSpec new) setLabel: anImage; layout: ((Graphics.LayoutOrigin new) leftOffset: self margin x; topOffset: 10; yourself).	aLabelSpec hasImageOrientedLabel: true.	builder add: aLabelSpec.	^builder wrapper</body><body package="ICCCommonClasses">addLabel: aComposedText andTextLine: model offset: offset	| height separation layout label field grid fieldOffset |	height := builder window displayBox height.	separation := 8.	layout := UI.AlignmentOrigin new				 leftOffset: self margin x;				 topOffset: height;				 yourself.	label := UI.LabelSpec layout: layout.	label hasCharacterOrientedLabel: false; setLabel: aComposedText.	builder add: label.	fieldOffset := layout leftOffset + separation + (offset isNil					ifTrue: [aComposedText width]					ifFalse: [offset]).	layout := Graphics.LayoutFrame new.	layout		 leftOffset: fieldOffset;		 rightFraction: 1;		 rightOffset: self margin x negated;		 topOffset: height.	field := UI.InputFieldSpec				model: model				menu: nil				layout: layout.	builder add: field.	grid := builder wrapper preferredBounds height.	layout bottomOffset: height + grid.	self addGap: grid.	self minWidth: 250.	^builder wrapper</body><body package="ICCCommonClasses">addLabels: labels values: values default: defaultValue storeInto: result takeKeyboard: takeKeyboard equalize: eqBoolean centered: centered	^self		addLabels: labels		values: values		default: defaultValue		storeInto: result		takeKeyboard: takeKeyboard		equalize: eqBoolean		columns: Core.SmallInteger maxVal		centered: centered</body><body package="ICCCommonClasses">addLabels: labels values: values default: defaultValue storeInto: result takeKeyboard: takeKeyboard equalize: eqBoolean columns: nColumns	^self		addLabels: labels		values: values		default: defaultValue		storeInto: result		takeKeyboard: takeKeyboard		equalize: eqBoolean		columns: nColumns		centered: false</body><body package="ICCCommonClasses">addLabels: labels values: values default: defaultValue storeInto: result takeKeyboard: takeKeyboard equalize: eqBoolean columns: nColumns centered: centered	| num maxButtonWidth maxButtonHeight separation buttonWAs buttonWidth window box layout top actualColumns actualRows left |	num := labels size.	maxButtonWidth := 0.	maxButtonHeight := 0.	separation := 5.	buttonWAs := Core.OrderedCollection new.	window := builder window.	box := window displayBox.	actualColumns := nColumns min: labels size.	actualRows := num + actualColumns - 1 // actualColumns.	"We have to create and place the buttons before we can ask them their	preferred bounds and refine their spacing."	layout := Graphics.LayoutFrame new.	centered		ifTrue: [layout leftFraction: 0.5; rightFraction: 0.5]		ifFalse: [layout leftFraction: 1; rightFraction: 1].	builder newComposite.	1 to: num		do:			[:index |			| lbl val buttonSpec buttonW bExt |			lbl := labels at: index.			val := values at: index.			(buttonSpec := UI.ActionButtonSpec						model: (result isNil								ifTrue: [val]								ifFalse: [									[result value: val.									self close]])						label: lbl						layout: (0 @ 0 extent: 1 @ 1)) defaultable: (values includes: defaultValue); isDefault: val == defaultValue.			builder add: buttonSpec.			buttonW := builder wrapper.			(takeKeyboard and: [val == defaultValue])				ifTrue: [builder keyboardProcessor setActive: buttonW widget controller].			bExt := self minButtonWidth @ 0 max: buttonW preferredBounds extent.			maxButtonWidth := maxButtonWidth max: bExt x.			maxButtonHeight := maxButtonHeight max: bExt y.			buttonWAs add: buttonW -&gt; bExt].	buttonWidth := eqBoolean				ifTrue: [actualColumns * maxButtonWidth + (actualColumns - 1 * separation)]				ifFalse: [buttonWAs inject: separation negated into: [:x :assoc | x + assoc value x + separation]].	layout topOffset: box height; bottomOffset: box height + (actualRows * maxButtonHeight).	centered		ifTrue: [layout leftOffset: 0 - (buttonWidth + 1 // 2); rightOffset: buttonWidth + 1 // 2]		ifFalse: [layout leftOffset: buttonWidth negated - self margin x; rightOffset: self margin x negated].	builder endCompositeLayout: layout.	left := 0.	top := 0.	1 to: num		do:			[:index |			| bttnWA width |			bttnWA := buttonWAs at: index.			width := eqBoolean						ifTrue: [maxButtonWidth]						ifFalse: [bttnWA value x].			bttnWA key newLayout: (Graphics.Rectangle					left: left					right: left + width					top: top					bottom: top + maxButtonHeight).			index \\ actualColumns = 0				ifTrue:					[left := 0.					top := top + maxButtonHeight]				ifFalse: [left := left + width + separation]].	self addGap: maxButtonHeight * actualRows.	self minWidth: self buttonIndent + buttonWidth + (self margin x * 2).	^builder wrapper</body><body package="ICCCommonClasses">addList: model lines: maxLines validation: valid	| height layout field grid font scrollW max fullMax |	height := builder window displayBox height.	layout := Graphics.LayoutFrame new.	layout leftOffset: self margin x.	layout rightFraction: 1 offset: self margin x negated.	layout topOffset: height.	field := UI.SequenceViewSpec model: model menu: nil layout: layout.	builder add: field.	builder wrapper widget controller setDispatcher:		(UI.UIDispatcher new doubleClick: [valid value ifTrue: [accept value: true]]).	builder wrapper widget setValidTargetIndex: model selectionIndex.	scrollW := builder wrapper decorator scrollerComponent.	scrollW preferredBoundsBlock:				[:sw | | rect |				rect := sw component preferredBounds						translatedBy: sw translation.				rect height: maxLines*sw scrollGrid y.				rect].	font := builder wrapper widget textStyle defaultFont.	font := Graphics.Screen default defaultFontPolicy findFont: font.	max := model list inject: 0 into: [:i :str | i max: str size].		"Instead of exactly measuring every string, we		assume that $o will be a fairly representative		character.  Actually, $o will probably be wider		than the average, but this will usually be OK."	max := (font widthOf: $o) * max.		"Don't let the dialog get too wide."	fullMax := 350.	max &gt; fullMax		ifTrue:			[max := fullMax.			builder wrapper decorator useHorizontalScrollBar.			builder wrapper widget measureWidth: true].	grid := builder wrapper preferredBounds height.	layout bottomOffset: height+grid.	self addGap: grid.	self minWidth: max + 48.	^builder wrapper</body><body package="ICCCommonClasses">addMessage: messageString indented: indented	"Implementation of SimpleDialog changed emphasis of messageString to allBold.	We assume it is already emphasized correctly."	| txt layout box spec leftOffset |	box := builder window displayBox.	txt := Graphics.ComposedText withText: messageString style: (self builder policy class systemWidgetTextStyle).	layout := UI.AlignmentOrigin new topOffset: box height.	leftOffset := self margin x + (indented					ifTrue: [50]					ifFalse: [0]).	layout leftOffset: leftOffset; leftAlignmentFraction: 0.	spec := UI.LabelSpec layout: layout.	spec hasCharacterOrientedLabel: false.	spec setLabel: txt.	builder add: spec.	self addGap: txt bounds height.	self minWidth: leftOffset + txt bounds width + self margin x.	^builder wrapper</body><body package="ICCCommonClasses">addMultiList: model lines: maxLines validation: valid	| height layout field grid font scrollW max fullMax |	height := builder window displayBox height.	layout := Graphics.LayoutFrame new.	layout leftOffset: self margin x.	layout rightFraction: 1 offset: self margin x negated.	layout topOffset: height.	field := UI.SequenceViewSpec model: model menu: nil layout: layout.	field multipleSelections: true.	builder add: field.	builder wrapper widget controller setDispatcher:		(UI.UIDispatcher new doubleClick: [valid value ifTrue: [accept value: true]]).	scrollW := builder wrapper decorator scrollerComponent.	scrollW preferredBoundsBlock:				[:sw | | rect |				rect := sw component preferredBounds						translatedBy: sw translation.				rect height: maxLines*sw scrollGrid y.				rect].	font := builder wrapper widget textStyle defaultFont.	font := Graphics.Screen default defaultFontPolicy findFont: font.	max := model list inject: 0 into: [:i :str | i max: str size].		"Instead of exactly measuring every string, we		assume that $o will be a fairly representative		character.  Actually, $o will probably be wider		than the average, but this will usually be OK."	max := (font widthOf: $o) * max.		"Don't let the dialog get too wide."	fullMax := 350.	max &gt; fullMax		ifTrue:			[max := fullMax.			builder wrapper decorator useHorizontalScrollBar.			builder wrapper widget measureWidth: true].	grid := builder wrapper preferredBounds height.	layout bottomOffset: height+grid.	self addGap: grid.	self minWidth: max + 48.	^builder wrapper</body><body package="ICCCommonClasses">addTextLine: model	| height layout field grid |	height := builder window displayBox height.	layout := Graphics.LayoutFrame new.	layout leftOffset: self margin x.	layout rightFraction: 1 offset: self margin x negated.	layout topOffset: height.	field := UI.InputFieldSpec				model: model				menu: nil				layout: layout.	builder add: field.	grid := builder wrapper preferredBounds height.	layout bottomOffset: height + grid.	self addGap: grid.	self minWidth: 200.	^builder wrapper</body><body package="ICCCommonClasses">minWidth: n	| box |	box := builder window displayBox.	box width: (box width max: n + 6).	builder window displayBox: box</body><body package="ICCCommonClasses">postBuild	"Do everything short after building the window."	builder window label: self title.	self infoIconBlock isNil ifFalse: [self addIcon: infoIconBlock value].	postBuildBlock isNil		ifTrue: [self postBuildWith: builder]		ifFalse: [postBuildBlock value: self value: builder]</body><body package="ICCCommonClasses">setInitialGap	| box |	box := builder window displayBox.	box height: 12.	builder window displayBox: box</body></methods><methods><class-id>ICC.ICC1Dialog</class-id> <category>accessing</category><body package="ICCCommonClasses">buttonAlignment	^buttonAlignment</body><body package="ICCCommonClasses">buttonAlignment: aByteSymbol	buttonAlignment := aByteSymbol</body><body package="ICCCommonClasses">buttonIndent	^self buttonAlignment == #right &amp; self infoIconBlock notNil		ifTrue: [50]		ifFalse: [0]</body><body package="ICCCommonClasses">buttonsCentered	self buttonAlignment: #center</body><body package="ICCCommonClasses">buttonsRight	self buttonAlignment: #right</body><body package="ICCCommonClasses">infoIcon: anImage	self infoIconBlock: [anImage]</body><body package="ICCCommonClasses">infoIconBlock	^infoIconBlock</body><body package="ICCCommonClasses">infoIconBlock: aBlockClosure	infoIconBlock := aBlockClosure</body><body package="ICCCommonClasses">margin	^margin</body><body package="ICCCommonClasses">margin: aPoint	margin := aPoint</body><body package="ICCCommonClasses">minButtonWidth	^minButtonWidth</body><body package="ICCCommonClasses">minButtonWidth: anInteger	minButtonWidth := anInteger</body><body package="ICCCommonClasses">openCentered	^openCentered</body><body package="ICCCommonClasses">openCentered: aBoolean	openCentered := aBoolean</body><body package="ICCCommonClasses">thickMargin	self margin: 10 @ 8.	self minButtonWidth: 85</body><body package="ICCCommonClasses">thinMargin	self margin: 6 @ 7.	self minButtonWidth: 75</body><body package="ICCCommonClasses">title	^title</body><body package="ICCCommonClasses">title: aString	title := aString</body></methods><methods><class-id>ICC.ICC1Dialog</class-id> <category>icon accessing</category><body package="ICCCommonClasses">setAlertIcon	self infoIconBlock: [self class resources opaqueImageFor: self builder policy class named: #iccAlertIcon]</body><body package="ICCCommonClasses">setConfirmIcon	self infoIconBlock: [self class resources opaqueImageFor: self builder policy class named: #iccConfirmIcon]</body><body package="ICCCommonClasses">setMessageIcon	self infoIconBlock: [self class resources opaqueImageFor: self builder policy class named: #iccMessageIcon]</body><body package="ICCCommonClasses">setWarnIcon	self infoIconBlock: [self class resources opaqueImageFor: self builder policy class named: #iccWarnIcon]</body></methods><methods><class-id>ICC.ICC1Dialog</class-id> <category>utility</category><body package="ICCCommonClasses">choose: messageString fromList: list values: listValues buttons: buttons values: buttonValues lines: maxLines cancel: cancelBlock for: aVisualOrNil	^self		choose: messageString		fromList: list		values: listValues		initialSelection: nil		buttons: buttons		values: buttonValues		lines: maxLines		cancel: cancelBlock		for: aVisualOrNil</body><body package="ICCCommonClasses">choose: messageString fromList: list values: listValues initialSelection: initialSelection buttons: buttons values: buttonValues lines: maxLines cancel: cancelBlock for: aVisualOrNil	"Ask the user a question. Let the user pick from a row of buttons made up	to match the labels collection. Return the response from the corresponding	item from the values collection."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow. It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	| result spec sequence wrappers listW |	wrappers := Core.OrderedCollection new.	result := UI.ValueHolder new.	sequence := UI.SelectionInList new.	sequence list: list.	initialSelection isNil		ifTrue: [list size = 1 ifTrue: [sequence selectionIndex: 1]]		ifFalse: [sequence selection: initialSelection].	spec := self class interfaceSpecFor: #emptySpec.	self initializeBuilderFor: aVisualOrNil.	builder add: spec window.	builder add: spec component.	self initializeWindowFor: aVisualOrNil.	self setInitialGap.	self addMessage: messageString indented: false.	self addGap: 8.	listW := self				addList: sequence				lines: (maxLines min: list size + 2)				validation: [true].	self addButtonGap.	wrappers add: (self			addLabels: #('OK' 'Cancel') , buttons			values: #(#ok #cancel) , buttonValues			default: #ok			storeInto: result			takeKeyboard: true			equalize: false).	self addGap: self margin y.	self bottomAlignLowerEdge: listW.	self bottomAlign: wrappers.	self preOpen.	self postBuild.	self openDialog.	result value == #ok ifTrue: [sequence selectionIndex ~= 0			ifTrue: [accept value: true]			ifFalse: [^cancelBlock value]].	result value == #cancel ifTrue: [cancel value: true].	^accept value		ifTrue: [listValues at: sequence selectionIndex]		ifFalse: [cancel value				ifTrue: [cancelBlock value]				ifFalse: [result value]]</body><body package="ICCCommonClasses">choose: messageString labels: labels values: values default: defaultValue equalize: eqBoolean for: aVisualOrNil	"Ask the user a question. Let the user pick from a row of buttons made up	to match the labels collection. Return the response from the corresponding	item from the values collection."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow. It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	| result spec |	self escapeIsCancel: false.	result := UI.ValueHolder new.	spec := self class interfaceSpecFor: #emptySpec.	self initializeBuilderFor: aVisualOrNil.	builder add: spec window.	builder add: spec component.	self initializeWindowFor: aVisualOrNil.	self setInitialGap.	self addMessage: messageString indented: true.	self addGap: 26.	self		addLabels: labels		values: values		default: defaultValue		storeInto: result		takeKeyboard: true		equalize: eqBoolean		centered: self buttonAlignment == #center.	self addGap: self margin y.	self preOpen.	builder window maximumSize: builder window displayBox extent.	builder window minimumSize: builder window displayBox extent.	self postBuild.	self openDialog.	^result value</body><body package="ICCCommonClasses">chooseMultiple: messageString fromList: list values: listValues buttons: buttons values: buttonValues lines: maxLines cancel: cancelBlock for: aVisualOrNil	"Behave like choose:fromList:... but allow multiple selection."	| result spec okValue sequence wrappers listW |	wrappers := Core.OrderedCollection new.	result :=  UI.ValueHolder new.	sequence := UI.MultiSelectionInList new.	sequence list: list.	list size = 1 ifTrue: [sequence selectionIndexes: (Core.Set with: 1)].	spec := self class interfaceSpecFor: #emptySpec.	okValue := Core.Object new.	self initializeBuilderFor: aVisualOrNil.	builder add: spec window.	builder add: spec component.	self initializeWindowFor: aVisualOrNil.	self setInitialGap.	self addMessage: messageString indented: false.	self addGap: 8.	listW := self				addMultiList: sequence				lines: (maxLines min: list size + 2)				validation: [true].	self addButtonGap.	wrappers add: (self addOK: [sequence selectionIndex ~= 0]).	buttons isEmpty		ifFalse:			[self addGap: 4.			wrappers add: self addDivider.			self addGap: 4.			wrappers add: (self					addLabels: buttons					values: buttonValues					default: okValue					storeInto: result					takeKeyboard: true					equalize: true)].	self addGap: self margin y.	self bottomAlignLowerEdge: listW.	self bottomAlign: wrappers.	self preOpen.	self postBuild.	self openDialog.	^accept value		ifTrue: [sequence selectionIndexes collect: [:index | listValues at: index]]		ifFalse: [cancel value				ifTrue: [cancelBlock value]				ifFalse: [result value]]</body><body package="ICCCommonClasses">confirm: messageString	^self confirm: messageString for: nil</body><body package="ICCCommonClasses">confirm: messageString for: aVisualOrNil	^self		confirm: messageString		initialAnswer: true		for: aVisualOrNil</body><body package="ICCCommonClasses">confirm: messageString initialAnswer: aBoolean	^self		confirm: messageString		initialAnswer: aBoolean		for: nil</body><body package="ICCCommonClasses">confirm: messageString initialAnswer: aBoolean for: aVisualOrNil	^self		choose: messageString		labels: #('Yes' 'No')		values: #(true false)		default: aBoolean		for: aVisualOrNil</body><body package="ICCCommonClasses">request: messageString initialAnswer: aString onCancel: aBlockOrNil for: aVisualOrNil	"Create an instance of the receiver whose question is messageString.	Display it centered around the cursor. Supply aString as an initial	answer. Simply return whatever the user accepts. If aBlockOrNil is	not nil then cancel returns the result of evaluating the block.	Also, set the paragraph editor's paste buffer to the result."	"aVisualOrNil, if not nil, may be either a VisualPart or a	ScheduledWindow. It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	| spec string result |	string := UI.ValueHolder with: aString asString.	spec := self class interfaceSpecFor: #emptySpec.	self initializeBuilderFor: aVisualOrNil.	builder add: spec window.	builder add: spec component.	self initializeWindowFor: aVisualOrNil.	self minWidth: 250.	self setInitialGap.	self addMessage: messageString asText indented: false.	self addGap: 2.	self addTextLine: string.	self addGap: 24.	self addOK: [true].	self addGap: self margin y.	self preOpen.	builder window maximumSize: Graphics.Screen default bounds width @ builder window displayBox height.	builder window minimumSize: 150 @ builder window displayBox height.	self postBuild.	self openDialog.	result := accept value				ifTrue: [string value]				ifFalse: [aBlockOrNil isNil						ifTrue: [Core.String new]						ifFalse: [aBlockOrNil value]].	^result</body><body package="ICCCommonClasses">requestArray: labels initialAnswers: initialArray onCancel: aBlockOrNil for: aVisualOrNil	"Like requestLine:initialAnswer:onCancel:for: but offers multiple input fields."	| spec textArray modelArray result |	textArray := labels collect: [:aLabel | aLabel asText allBold].	modelArray := initialArray collect: [:anInitialAnswer | UI.ValueHolder with: anInitialAnswer asString].	spec := self class interfaceSpecFor: #emptySpec.	self initializeBuilderFor: aVisualOrNil.	builder add: spec window.	builder add: spec component.	self initializeWindowFor: aVisualOrNil.	self minWidth: 300.	self setInitialGap.	textArray with: modelArray		do:			[:eachText :eachModel |			self addMessage: eachText asText allBold indented: false.			self addGap: 2.			self addTextLine: eachModel.			self addGap: 6].	self addGap: 18.	self addOK: [true].	self addGap: self margin y.	self preOpen.	builder window maximumSize: Graphics.Screen default bounds width @ builder window displayBox height.	builder window minimumSize: 150 @ builder window displayBox height.	self postBuild.	self openDialog.	result := accept value				ifTrue: [modelArray collect: [:aModel | aModel value]]				ifFalse: [aBlockOrNil isNil						ifTrue: [Core.String new]						ifFalse: [aBlockOrNil value]].	^result</body><body package="ICCCommonClasses">requestLine: messageString initialAnswer: aString onCancel: aBlockOrNil for: aVisualOrNil	"Same as request:initialAnswer:onCancel:for: except for a horizontal alignment of label and	input field."	| result |	result := self class new				requestLineArray: (Core.Array with: messageString)				initialAnswers: (Core.Array with: aString)				onCancel: (aBlockOrNil isNil						ifTrue: [nil]						ifFalse: [[Core.Array with: aBlockOrNil value]])				for: aVisualOrNil.	^result isNil		ifTrue: [result]		ifFalse: [result at: 1]</body><body package="ICCCommonClasses">requestLineArray: labels initialAnswers: initialArray onCancel: aBlockOrNil for: aVisualOrNil	"Like requestLine:initialAnswer:onCancel:for: but offers multiple input fields."	| spec textArray modelArray result maxLabelSize |	textArray := labels collect: [:aLabel | Graphics.ComposedText withText: aLabel asText allBold style: builder policy class systemWidgetTextStyle].	modelArray := initialArray collect: [:anInitialAnswer | UI.ValueHolder with: anInitialAnswer asString].	maxLabelSize := textArray inject: 0 into: [:tmpMax :aText | tmpMax max: aText width].	spec := self class interfaceSpecFor: #emptySpec.	self initializeBuilderFor: aVisualOrNil.	builder add: spec window.	builder add: spec component.	self initializeWindowFor: aVisualOrNil.	self minWidth: 300.	self setInitialGap.	textArray with: modelArray		do:			[:eachText :eachModel |			self				addLabel: eachText				andTextLine: eachModel				offset: maxLabelSize.			self addGap: 10].	self addGap: 10.	self addDivider.	self addButtonGap.	self addOK: [true].	self addGap: self margin y.	self preOpen.	builder window maximumSize: Graphics.Screen default bounds width @ builder window displayBox height.	builder window minimumSize: 150 @ builder window displayBox height.	self postBuild.	self openDialog.	result := accept value				ifTrue: [modelArray collect: [:aModel | aModel value]]				ifFalse: [aBlockOrNil isNil						ifTrue: [Core.String new]						ifFalse: [aBlockOrNil value]].	^result</body><body package="ICCCommonClasses">threeStateConfirm: messageString initialAnswer: aBooleanOrNil for: aVisualOrNil	"Ask the user a question, with a true/false/nil answer. Return the response."	^self setWarnIcon		choose: messageString		labels: #('Yes' 'No' 'Cancel')		values: #(true false nil)		default: aBooleanOrNil		for: aVisualOrNil</body></methods><methods><class-id>ICC.ICC1Dialog</class-id> <category>utility-notification</category><body package="ICCCommonClasses">alert: messageString	self alert: messageString for: nil</body><body package="ICCCommonClasses">alert: messageString for: aVisualOrNil	"Present the message string to the user. Continue processing	when the user hits the 'ok' box or types cr."	^self setAlertIcon		choose: messageString		labels: #('OK')		values: #(nil)		default: nil		for: aVisualOrNil</body><body package="ICCCommonClasses">message: messageString	self message: messageString for: nil</body><body package="ICCCommonClasses">message: messageString for: aVisualOrNil	"Present the message string to the user. Continue processing	when the user hits the 'ok' box or types cr."	^self setMessageIcon		choose: messageString		labels: #('OK')		values: #(nil)		default: nil		for: aVisualOrNil</body><body package="ICCCommonClasses">warn: messageString	self warn: messageString for: nil</body><body package="ICCCommonClasses">warn: messageString for: aVisualOrNil	^self setWarnIcon		choose: messageString		labels: #('OK')		values: #(nil)		default: nil		for: aVisualOrNil</body></methods><methods><class-id>ICC.ICC1Dialog</class-id> <category>initialize-release</category><body package="ICCCommonClasses">initialize	super initialize.	self title: ''.	self buttonsRight.	self thinMargin.	self openCentered: false</body></methods><methods><class-id>ICC.ICC1Dialog</class-id> <category>interface opening</category><body package="ICCCommonClasses">openDialog	"Open the builder's window as type #imageModalDialog with my windows extent."	^self openWithExtent: builder window displayBox extent</body><body package="ICCCommonClasses">openFrom: aSpec	"Open a dialog based on aSpec"	self allButOpenFrom: aSpec.	self openWithExtent: builder window displayBox extent.	^accept value</body><body package="ICCCommonClasses">openWithExtent: ext	"Open the builder's window as type #imageModalDialog with the given extent."	| box |	box := 0 @ 0 extent: ext.	box := box align: box center with: (self openCentered					ifTrue: [Graphics.Screen default bounds center]					ifFalse: [UI.WindowSensor cursorPoint]).	^builder openPopUpIn: box type: #imageModalDialog</body></methods><methods><class-id>ICC.ICC1Dialog class</class-id> <category>notification dialogs</category><body package="ICCCommonClasses">alert: messageString	"Present the message string to the user. Continue processing	when the user hits the 'ok' box or types cr."	^self alert: messageString for: nil</body><body package="ICCCommonClasses">alert: messageString for: aVisualOrNil	"Present the message string to the user. Continue processing	when the user hits the 'ok' box or types cr."	(self notifier) title: 'Error'; alert: messageString for: aVisualOrNil</body><body package="ICCCommonClasses">message: messageString	"Present the message string to the user. Continue processing	when the user hits the 'ok' box or types cr."	^self message: messageString for: nil</body><body package="ICCCommonClasses">message: messageString for: aVisualOrNil	"Present the message string to the user. Continue processing	when the user hits the 'ok' box or types cr."	(self notifier) title: 'Information'; message: messageString for: aVisualOrNil</body><body package="ICCCommonClasses">warn: messageString	"Present the message string to the user. Continue processing	when the user hits the 'ok' box or types cr."	^self warn: messageString for: nil</body><body package="ICCCommonClasses">warn: messageString for: aVisualOrNil	"Present the message string to the user. Continue processing	when the user hits the 'ok' box or types cr."	(self notifier) title: 'Warning'; warn: messageString for: aVisualOrNil</body></methods><methods><class-id>ICC.ICC1Dialog class</class-id> <category>implementation classes</category><body package="ICCCommonClasses">aboutDialogClass	^ICC1AboutDialog</body></methods><methods><class-id>ICC.ICC1Dialog class</class-id> <category>fill in the blank dialogs</category><body package="ICCCommonClasses">request: messageString	"Create an instance of the receiver whose question is messageString.	Display it centered around the cursor. Simply return whatever the user	accepts."	^self request: messageString initialAnswer: UI.ParagraphEditor currentSelection</body><body package="ICCCommonClasses">request: messageString for: aVisualOrNil	"Create an instance of the receiver whose question is messageString.	Display it centered around the cursor. Simply return whatever the user	accepts."	^self		request: messageString		initialAnswer: UI.ParagraphEditor currentSelection		for: aVisualOrNil</body><body package="ICCCommonClasses">request: messageString initialAnswer: aString	"Create an instance of the receiver whose question is messageString.	Display it centered around the cursor. Supply aString as an initial	answer. Simply return whatever the user accepts."	^self		request: messageString		initialAnswer: aString		onCancel: nil</body><body package="ICCCommonClasses">request: messageString initialAnswer: aString for: aVisualOrNil	"Create an instance of the receiver whose question is messageString.	Display it centered around the cursor. Supply aString as an initial	answer. Simply return whatever the user accepts."	^self		request: messageString		initialAnswer: aString		onCancel: nil		for: aVisualOrNil</body><body package="ICCCommonClasses">request: messageString initialAnswer: aString onCancel: aBlockOrNil	^self		request: messageString		initialAnswer: aString		onCancel: aBlockOrNil		for: UI.Dialog defaultParentWindow</body><body package="ICCCommonClasses">request: messageString initialAnswer: aString onCancel: aBlockOrNil for: aVisualOrNil	^self new		request: messageString		initialAnswer: aString		onCancel: aBlockOrNil		for: aVisualOrNil</body></methods><methods><class-id>ICC.ICC1Dialog class</class-id> <category>file name dialogs</category><body package="ICCCommonClasses">requestFileName: message	"Prompt for a file name. Return an empty string if it fails."	^self requestFileName: message for: nil</body><body package="ICCCommonClasses">requestFileName: message default: default	"Prompt for a file name. Return an empty string if it fails."	^self		requestFileName: message		default: default		for: nil</body><body package="ICCCommonClasses">requestFileName: message default: default for: aVisualOrNil	"Prompt for a file name.  Return an empty string if it fails."	^self requestFileName: message default: default version: #any for: aVisualOrNil</body><body package="ICCCommonClasses">requestFileName: message default: default version: versionType	"Prompt for a file name. Return an empty string if it fails."	^self		requestFileName: message		default: default		version: versionType		for: nil</body><body package="ICCCommonClasses">requestFileName: message default: default version: versionType for: aVisualOrNil	"Prompt for a file name.  Return an empty string if it fails."	^self requestFileName: message default: default version: versionType ifFail: [''] for: aVisualOrNil</body><body package="ICCCommonClasses">requestFileName: message default: default version: versionType ifFail: failBlock	"Prompt for a file name.  Evaluate failBlock if none obtained.	If the user supplies a pattern (string containing $* or $#, then match against it.	If versionType is #any, accept any legal file name.	If versionType is #new, and the file exists, ask for confirmation to use it anyway.	If version Type is #old, and the file does not exist, ask for confirmation to use its name.	If versionType is #mustBeNew, and the file exists, evaluate failBlock.	If versionType is #mustBeOld, and the file does not exist, evaluate failBlock."	^self requestFileName: message default: default version: versionType ifFail: failBlock for: nil</body><body package="ICCCommonClasses">requestFileName: message default: default version: versionType ifFail: failBlock for: aVisualOrNil	"Prompt for a file name. Evaluate failBlock if none obtained.	If the user supplies a pattern (string containing $* or $#, then match against it.	If versionType is #any, accept any legal file name.	If versionType is #new, and the file exists, ask for confirmation to use it anyway.	If version Type is #old, and the file does not exist, ask for confirmation to use its name.	If versionType is #mustBeNew, and the file exists, evaluate failBlock.	If versionType is #mustBeOld, and the file does not exist, evaluate failBlock."	| fileName currentDir haveOne |	(#(#new #old #mustBeNew #mustBeOld #any) includes: versionType)		ifFalse: [self error: 'Illegal value for file version: ' , versionType printString].	fileName := default.	currentDir := OS.Filename defaultDirectoryName copyWith: OS.Filename separator.	[true]		whileTrue:			[fileName := self						request: message						initialAnswer: fileName						for: aVisualOrNil.			fileName isEmpty ifTrue: [^failBlock value].			haveOne := true.			((fileName includes: $*)				or: [fileName includes: $#])				ifTrue:					["Is a pattern, set up a menu"					| list list2 choice |					list := (OS.Filename filesMatching: fileName) asSortedCollection.					list2 := list collect: [:fname | (fname findString: currentDir startingAt: 1)									= 1									ifTrue: [fname copyFrom: currentDir size + 1 to: fname size]									ifFalse: [fname asString]].					list isEmpty						ifTrue: [choice := self										choose: 'There are no matching files.'										labels: #('Try again' 'Cancel')										values: #(#newPattern #abort)										default: #abort										for: aVisualOrNil]						ifFalse: [choice := self										choose: 'Choose a file.'										fromList: list2										values: list2										buttons: #('Try again')										values: #(#newPattern)										lines: 20										cancel: [#abort]										for: aVisualOrNil].					choice == #abort ifTrue: [^failBlock value].	"try again"					choice == #newPattern ifFalse: [fileName := choice]						ifTrue: [haveOne := false]].			haveOne ifTrue:				["got a single file name or match code said 'try again'"				| err |				fileName asFilename directory definitelyExists					ifFalse:						[haveOne := false.						(self confirm: fileName , '''s directory does not exist.\\Try again?' withCRs for: aVisualOrNil)							ifFalse: [^failBlock value]]					ifTrue:						[versionType = #any ifTrue: [^fileName].						(versionType = #new or: [versionType = #mustBeNew])							ifTrue:								[fileName asFilename exists ifFalse: [^fileName].								(versionType = #new and: [self confirm: fileName , ' already exists.\\Use anyway?' withCRs for: aVisualOrNil])									ifTrue: [^fileName].								err := ' File already exists.\\']							ifFalse:								["versionType must be either #old or #mustBeOld"								fileName asFilename exists ifTrue: [^fileName].								(versionType = #old and: [self confirm: fileName , ' does not exist.\Use anyway?' withCRs for: aVisualOrNil])									ifTrue: [^fileName].								fileName = fileName asFilename asString									ifTrue: [err := ' File not found: \  ']									ifFalse: [err := ' Illegal file name: \  ']].						(self							choose: err withCRs , 'Would you like to continue?'							labels: #('OK' 'Cancel')							values: #(true false)							default: false							for: aVisualOrNil)							ifFalse: [^failBlock value]]]]</body><body package="ICCCommonClasses">requestFileName: message for: aVisualOrNil	"Prompt for a file name. Return an empty string if it fails."	^self		requestFileName: message		default: 'file.ext'		for: aVisualOrNil</body><body package="ICCCommonClasses">requestNewFileName: message default: default	"Prompt for a file name of what should be a new file. Allow user to confirm	use of existing file. Return an empty string if it fails."	^self		requestNewFileName: message		default: default		for: nil</body><body package="ICCCommonClasses">requestNewFileName: message default: default for: aVisualOrNil	"Prompt for a file name of what should be a new file. Allow user to confirm	use of existing file. Return an empty string if it fails."	^self		requestFileName: message		default: default		version: #new		for: aVisualOrNil</body></methods><methods><class-id>ICC.ICC1Dialog class</class-id> <category>multiple choice dialogs</category><body package="ICCCommonClasses">choose: messageString fromList: list values: listValues buttons: buttons values: buttonValues lines: maxLines cancel: cancelBlock	"Give the user a choice of items ('list') presented in a list view, with	an 'OK' and 'Cancel' button. The OK button will not work unless a	list item is selected. Cancel returns the value of the cancelBlock. If	the list of items is very long, no more than maxLines will be shown	at any given time.	Below the 'OK' and 'Cancel', additional buttons specified by the	buttons and buttonValues parameters will appear. Pressing one	of these buttons causes the associated value to be returned."	^self new		choose: messageString		fromList: list		values: listValues		buttons: buttons		values: buttonValues		lines: maxLines		cancel: cancelBlock</body><body package="ICCCommonClasses">choose: messageString fromList: list values: listValues buttons: buttons values: buttonValues lines: maxLines cancel: cancelBlock for: aVisualOrNil	"Give the user a choice of items ('list') presented in a list view, with	an 'OK' and 'Cancel' button. The OK button will not work unless a	list item is selected. Cancel returns the value of the cancelBlock. If	the list of items is very long, no more than maxLines will be shown	at any given time.	Below the 'OK' and 'Cancel', additional buttons specified by the	buttons and buttonValues parameters will appear. Pressing one	of these buttons causes the associated value to be returned."	^self new		choose: messageString		fromList: list		values: listValues		buttons: buttons		values: buttonValues		lines: maxLines		cancel: cancelBlock		for: aVisualOrNil</body><body package="ICCCommonClasses">choose: messageString fromList: list values: listValues lines: maxLines cancel: cancelBlock	"Give the user a choice of items ('list') presented in a list view, with	an 'OK' and 'Cancel' button. The OK button will not work unless a	list item is selected. Cancel returns the value of the cancelBlock. If	the list of items is very long, no more than maxLines will be shown	at any given time."	^self		choose: messageString		fromList: list		values: listValues		buttons: #()		values: #()		lines: maxLines		cancel: cancelBlock</body><body package="ICCCommonClasses">choose: messageString fromList: list values: listValues lines: maxLines cancel: cancelBlock for: aVisualOrNil	"Give the user a choice of items ('list') presented in a list view, with	an 'OK' and 'Cancel' button. The OK button will not work unless a	list item is selected. Cancel returns the value of the cancelBlock. If	the list of items is very long, no more than maxLines will be shown	at any given time."	^self		choose: messageString		fromList: list		values: listValues		buttons: #()		values: #()		lines: maxLines		cancel: cancelBlock		for: aVisualOrNil</body><body package="ICCCommonClasses">choose: messageString labels: labels values: values default: defaultValue	"Ask the user a question. Let the user pick from a row of buttons made up	to match the labels collection. Return the response from the corresponding	item from the values collection."	^self new		choose: messageString		labels: labels		values: values		default: defaultValue</body><body package="ICCCommonClasses">choose: messageString labels: labels values: values default: defaultValue for: aVisualOrNil	"Ask the user a question. Let the user pick from a row of buttons made up	to match the labels collection. Return the response from the corresponding	item from the values collection."	^self new		choose: messageString		labels: labels		values: values		default: defaultValue		for: aVisualOrNil</body><body package="ICCCommonClasses">confirm: messageString	"Ask the user a question with a true/false answer. Return the response."	"self confirm: 'Close this dummy message?'"	^self confirm: messageString for: nil</body><body package="ICCCommonClasses">confirm: messageString for: aVisualOrNil	"Ask the user a question with a true/false answer. Return the response."	^self		confirm: messageString		initialAnswer: true		for: aVisualOrNil</body><body package="ICCCommonClasses">confirm: messageString initialAnswer: aBoolean	"Ask the user a question, with a true/false answer. Return the response."	^self		confirm: messageString		initialAnswer: aBoolean		for: nil</body><body package="ICCCommonClasses">confirm: messageString initialAnswer: aBoolean for: aVisualOrNil	"Ask the user a question, with a true/false answer. Return the response."	^((self notifier) title: 'Please Confirm'; setConfirmIcon; yourself)		confirm: messageString		initialAnswer: aBoolean		for: aVisualOrNil</body><body package="ICCCommonClasses">threeStateConfirm: messageString	"Ask the user a question with a true/false/nil answer. Return the response."	^self threeStateConfirm: messageString for: nil</body><body package="ICCCommonClasses">threeStateConfirm: messageString for: aVisualOrNil	"Ask the user a question, with a true/false/nil answer. Return the response."	^self		threeStateConfirm: messageString		initialAnswer: true		for: aVisualOrNil</body><body package="ICCCommonClasses">threeStateConfirm: messageString initialAnswer: aBooleanOrNil	"Ask the user a question, with a true/false/nil answer. Return the response."	^self		threeStateConfirm: messageString		initialAnswer: aBooleanOrNil		for: nil</body><body package="ICCCommonClasses">threeStateConfirm: messageString initialAnswer: aBooleanOrNil for: aVisualOrNil	"Ask the user a question, with a true/false/nil answer. Return the response."	^((self notifier) title: 'Please confirm'; yourself)		threeStateConfirm: messageString		initialAnswer: aBooleanOrNil		for: aVisualOrNil</body></methods><methods><class-id>ICC.ICC1Dialog class</class-id> <category>examples</category><body package="ICCCommonClasses">fileNameExamples	"self requestFileName: 'Name a file'"	"self requestFileName: 'Name a file' default: '*.st'"	"self requestFileName: 'Name a file' default: '*.st' version: #any"	"self requestFileName: 'file:' default: '*.st' version: #mustBeNew ifFail: ['']"	"self requestFileName: 'Name a file'"	"self requestNewFileName: 'Name a file' default: 'file.st'"	"self requestNewFileName: 'Name a file' default: 'file.st'"</body><body package="ICCCommonClasses">fillInExamples	"self request: 'What is your name?'"	"self request: 'What is your name?' for: Dialog defaultParentWindow"	"self request: 'What is your name?' initialAnswer: 'In einem fernen Land, unnahbar euren Schritten...'"	"self	request: 'What is your name?'	initialAnswer: 'Mr. T'	for: Dialog defaultParentWindow"	"self request: 'Your name?' initialAnswer: 'name' onCancel: ['Freddy']"</body><body package="ICCCommonClasses">multipleChoiceExamples1	"self	choose: 'Which one do you want?'	fromList: #('first' 'second' 'third' 'fourth') values: #(1 2 3 4)	buttons: #('Frobitz') values: #(nil)	lines: 8	cancel: [#noChoice]"	"self	choose: 'Which one do you want?'	fromList: #('first' 'second' 'third' 'fourth') values: #(1 2 3 4)	buttons: #('Frobitz') values: #(nil)	lines: 8	cancel: [#noChoice]	for: Dialog defaultParentWindow"	"self	choose: 'Which one do you want?'	fromList: #('first' 'second' 'third' 'fourth')	values: #(1 2 3 4)	lines: 8	cancel: [#noChoice]"	"self	choose: 'Which one do you want?'	fromList: #('first' 'second' 'third' 'fourth')	values: #(1 2 3 4)	lines: 8	cancel: [#noChoice]	for: Dialog defaultParentWindow"	"self	choose: 'Are you tired yet?'	labels: (Array with: 'absolutely' with: 'sort of' with: 'not really')	values: #(#yes #maybe #no)	default: #maybe"	"self	choose: 'Are you tired yet?'	labels: (Array with: 'Absolutely' with: 'Sort of' with: 'Not really')	values: #(#yes #maybe #no)	default: #maybe	for: Dialog defaultParentWindow"</body><body package="ICCCommonClasses">multipleChoiceExamples2	"self confirm: 'Delete all horrible memories?'"	"self confirm: 'Delete all horrible memories?'	for: Dialog defaultParentWindow"	"self confirm: 'Are you tired yet?' initialAnswer: false."	"self confirm: 'Are you tired yet?'	initialAnswer: false	for: ScheduledControllers activeController view."	"self threeStateConfirm: 'Do you want to save the changes?'"	"self threeStateConfirm: 'Do you want to save the changes?'	for: ScheduledControllers activeController view."	"self threeStateConfirm: 'Do you want to save the changes?' initialAnswer: false"	"self threeStateConfirm: 'Do you want to save the changes?' initialAnswer: false	for: ScheduledControllers activeController view."</body><body package="ICCCommonClasses">notificationExamples	"self alert: 'Beware, this is an alert'."	"self alert: 'Beware, this is an alert and not just a warning!'	for: Dialog defaultParentWindow."	"self message: 'Hi, this is an information.'."	"self message: 'Hi, this is an information.' for: Dialog defaultParentWindow."	"self warn: 'Beware, this is a warning.'."	"self warn: 'Beware, this is a warning' for: Dialog defaultParentWindow."</body><body package="ICCCommonClasses">requestSelectionExamples	"self	requestSelection: #('Kirsten' 'Katrin' 'Katharina' 'Katja' 'Kamelia' 'Carina')	dialogBlock: [(self new) thickMargin; title: 'Please Confirm'; setConfirmIcon]	selectAllLabel: 'I know all'	messageBlock: [:each | 'Do you know ' , each , '?']"	"self	requestSelection: #('Paris')	dialogBlock: [(self new) thickMargin; title: 'Please Confirm'; setConfirmIcon]	selectAllLabel: 'I''ve been everywhere'	messageBlock: [:each | 'Have you ever been in ' , each , '?']"</body></methods><methods><class-id>ICC.ICC1Dialog class</class-id> <category>request selection</category><body package="ICCCommonClasses">requestSelection: items dialogBlock: dialogBlock selectAllLabel: aLabel messageBlock: aBlock	| selection itemsSize |	selection := Core.OrderedCollection new.	itemsSize := items size.	1 to: itemsSize		do:			[:index |			| each answer singleItem |			each := items at: index.			singleItem := itemsSize = 1 | (index = itemsSize).			answer := (dialogBlock value) openCentered: itemsSize &gt; 1; yourself;						choose: (aBlock value: each)						labels: (singleItem								ifTrue: [#('Yes' 'No')]								ifFalse: [Core.Array										with: 'Yes'										with: aLabel										with: 'No'										with: 'Cancel'])						values: (singleItem								ifTrue: [#(#yes #no)]								ifFalse: [#(#yes #doAll #no #cancel)])						default: #yes.			answer == #yes ifTrue: [selection add: each].			answer == #doAll ifTrue: [^selection , (items copyFrom: index to: itemsSize)].			answer == #cancel ifTrue: [^selection]].	^selection</body></methods><methods><class-id>ICC.ICC1Dialog class</class-id> <category>instance creation</category><body package="ICCCommonClasses">notifier	^(self new) thickMargin; buttonsCentered; yourself</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>animation</category><body package="ICCCommonClasses">animationList	| aGraphicsContext |	aGraphicsContext := self builder window graphicsContext.	^self animationObjects		collect:			[:each |			| extent location backGC frontGC |			extent := each bounds extent.			backGC := (aGraphicsContext paintBasis retainedMediumWithExtent: extent) graphicsContext.			location := each container bounds origin.			backGC				copyArea: backGC clippingBounds				from: aGraphicsContext				sourceOffset: location				destinationOffset: 0 @ 0.			frontGC := (aGraphicsContext paintBasis retainedMediumWithExtent: extent) graphicsContext.			backGC medium displayOn: frontGC.			each displayOn: frontGC.			Core.Array				with: location				with: backGC				with: frontGC]</body><body package="ICCCommonClasses">animationObjects	| idPrefix animationObjectsSize |	idPrefix := 'animationObject'.	animationObjectsSize := self builder namedComponents keys inject: 0 into: [:max :each | (each asString copyFrom: 1 to: idPrefix size)					= idPrefix					ifTrue: [max max: (Core.Integer readFromString: (each asString copyFrom: idPrefix size + 1 to: each size))]					ifFalse: [max]].	^(1 to: animationObjectsSize)		collect: [:i | (self builder componentAt: (idPrefix , i printString) asSymbol) widget]</body><body package="ICCCommonClasses">animationPriority	^Smalltalk.Processor userSchedulingPriority + 1</body><body package="ICCCommonClasses">doAnimation	self		doAnimationsWithInitialDelay: 4000		stepDelay: 90		cycleDelay: 1300</body><body package="ICCCommonClasses">doAnimationsWithInitialDelay: initialDelay stepDelay: stepDelay cycleDelay: cycleDelay	| animationList aGraphicsContext |	aGraphicsContext := self builder window graphicsContext.	animationList := self animationList.	(Core.Delay forMilliseconds: initialDelay) wait.	[animationList		do:			[:each |			| location |			location := each at: 1.			(each at: 3) medium displayOn: aGraphicsContext at: location.			(Core.Delay forMilliseconds: stepDelay) wait.			(each at: 2) medium displayOn: aGraphicsContext at: location].	(Core.Delay forMilliseconds: cycleDelay) wait] repeat</body><body package="ICCCommonClasses">resumeAnimation	self animationProcess isNil ifFalse: [self animationProcess resume]</body><body package="ICCCommonClasses">startAnimation	self animationProcess isNil ifTrue: [self animationProcess: ([self doAnimation]				forkAt: self animationPriority)]</body><body package="ICCCommonClasses">stopAnimation	| aProcess |	self animationProcess isNil ifTrue: [^self].	aProcess := self animationProcess.	self animationProcess: nil.	aProcess terminate</body><body package="ICCCommonClasses">suspendAnimation	self animationProcess isNil ifFalse: [self animationProcess suspend]</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>aspects</category><body package="ICCCommonClasses">infoField1	^infoField1 isNil		ifTrue: [infoField1 :=  Core.String new asValue]		ifFalse: [infoField1]</body><body package="ICCCommonClasses">infoField2	^infoField2 isNil		ifTrue: [infoField2 :=  Core.String new asValue]		ifFalse: [infoField2]</body><body package="ICCCommonClasses">progress	^progress isNil		ifTrue: [progress := 0 asValue]		ifFalse: [progress]</body><body package="ICCCommonClasses">remainingTimeField	^remainingTimeField isNil		ifTrue: [remainingTimeField := Core.String new asValue]		ifFalse: [remainingTimeField]</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>events</category><body package="ICCCommonClasses">noticeOfWindowClose: aWindow	"The ApplicationWindow aWindow is in the process of closing.	You have been notified."	super noticeOfWindowClose: aWindow. 	self release</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>accessing</category><body package="ICCCommonClasses">actionProcess	^actionProcess</body><body package="ICCCommonClasses">actionProcess: aProcess	actionProcess := aProcess</body><body package="ICCCommonClasses">animationProcess	^animationProcess</body><body package="ICCCommonClasses">animationProcess: aProcess	animationProcess := aProcess</body><body package="ICCCommonClasses">startTime	^startTime</body><body package="ICCCommonClasses">startTime: aTime	startTime := aTime</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>processing</category><body package="ICCCommonClasses">actionPriority	^Smalltalk.Processor userSchedulingPriority</body><body package="ICCCommonClasses">basicDoAction	"Actions are implemented by subclasses."</body><body package="ICCCommonClasses">doAction	self startAnimation.	self startTime: Core.Time now.	self basicDoAction.	self stopAnimation.	[self stopAction.	Smalltalk.Transcript show: ' '.	"Don't remove this line!"	self doAccept] fork</body><body package="ICCCommonClasses">resumeAction	self actionProcess isNil ifFalse: [self actionProcess resume]</body><body package="ICCCommonClasses">startAction	self actionProcess isNil ifTrue: [self actionProcess: ([self doAction]				forkAt: self actionPriority)]</body><body package="ICCCommonClasses">stopAction	| aProcess |	self actionProcess isNil ifTrue: [^self].	aProcess := self actionProcess.	self actionProcess: nil.	aProcess terminate</body><body package="ICCCommonClasses">suspendAction	| aProcess |	aProcess := self actionProcess.	aProcess notNil &amp; aProcess suspendingList notNil ifTrue: [aProcess suspend]</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>initialize-release</category><body package="ICCCommonClasses">release	super release.	self stopAnimation.	self stopAction</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>utility</category><body package="ICCCommonClasses">remainingTimeStringFor: seconds	^seconds &gt; 59		ifTrue:			[| min sec |			min := seconds // 60.			sec := seconds \\ 60.			min printString , ':' , (sec &lt; 10					ifTrue: ['0']					ifFalse: ['']) , sec printString , ' minutes']		ifFalse: [seconds printString , ' seconds']</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>private</category><body package="ICCCommonClasses">changeRequest	self suspendAnimation.	self suspendAction.	(self iccDialog confirm: 'Do you wish to cancel operation?' for: self builder window)		ifTrue: [^true]		ifFalse:			[self resumeAnimation.			self resumeAction.			^false]</body><body package="ICCCommonClasses">doCancel	(self actionProcess isNil or: [self changeRequest])		ifTrue: [super doCancel]</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>progress</category><body package="ICCCommonClasses">elapsedTimeDisplayMinimum	^20</body><body package="ICCCommonClasses">remainingTimeDisplayMinimum	^3</body><body package="ICCCommonClasses">showProgress: aNumber	self progress value: aNumber.	self showRemainingTime: aNumber</body><body package="ICCCommonClasses">showRemainingTime: aNumber	| elapsedTime remainingTime |	elapsedTime := Core.Time now asSeconds - self startTime asSeconds.	elapsedTime &lt; self elapsedTimeDisplayMinimum ifTrue: [^self].	remainingTime := (elapsedTime * (1 - aNumber) / aNumber) rounded.	remainingTime &lt; self remainingTimeDisplayMinimum ifTrue: [^self].	self remainingTimeField value: 'Remaining time: ' , (self remainingTimeStringFor: remainingTime)</body></methods><methods><class-id>ICC.ICC1ProgressDialog</class-id> <category>interface opening</category><body package="ICCCommonClasses">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self startAction</body></methods><methods><class-id>ICC.ICC1Wizard</class-id> <category>private-pages</category><body package="ICCCommonClasses">backNextCancelButtons	(self builder componentAt: #buttonHolder) widget client: self spec: #backNextCancelSpec</body><body package="ICCCommonClasses">changePage	self perform: self page</body><body package="ICCCommonClasses">changePage: aPageSymbol	self page: aPageSymbol.	self perform: self page</body><body package="ICCCommonClasses">nextCancelButtons	(self builder componentAt: #buttonHolder) widget client: self spec: #nextCancelSpec</body><body package="ICCCommonClasses">setPageHolder	self setPageHolder: (self page , #Spec) asSymbol</body><body package="ICCCommonClasses">setPageHolder: aSpec	(self builder componentAt: #pageHolder) widget client: self spec: aSpec builder: self builder</body></methods><methods><class-id>ICC.ICC1Wizard</class-id> <category>actions</category><body package="ICCCommonClasses">back	self subclassResponsibility</body><body package="ICCCommonClasses">next	self subclassResponsibility</body></methods><methods><class-id>ICC.ICC1Wizard</class-id> <category>pages</category><body package="ICCCommonClasses">initialPage	^self subclassResponsibility</body></methods><methods><class-id>ICC.ICC1Wizard</class-id> <category>interface opening</category><body package="ICCCommonClasses">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self changePage</body></methods><methods><class-id>ICC.ICC1Wizard</class-id> <category>initialize-release</category><body package="ICCCommonClasses">initialize	super initialize.	self page: self initialPage</body></methods><methods><class-id>ICC.ICC1Wizard</class-id> <category>accessing</category><body package="ICCCommonClasses">page	^page</body><body package="ICCCommonClasses">page: aSymbol	page := aSymbol</body></methods><methods><class-id>ICC.ICC1Utils class</class-id> <category>validating names</category><body package="ICCCommonClasses">cleanStringFor: aString	"^&lt;String&gt; Answer the letters and digits in aString.	A new fully Qualified name my contain dots. Allow that."	^aString select: [:eachChar | eachChar isLetter or: [eachChar isDigit or: [eachChar = $.]]]</body><body package="ICCCommonClasses">validateClassName: varName confirm: confirmBlock warn: warnBlock	| cleanString newVarName msg firstChar |	newVarName := varName asString copy.	newVarName isEmpty		ifTrue:			[warnBlock value: 'An empty class name is invalid'.			^nil].	cleanString := self cleanStringFor: newVarName.	cleanString = newVarName		ifFalse:			[cleanString isEmpty				ifTrue:					[warnBlock value: 'No valid characters in class name'.					^nil].			newVarName := cleanString.			msg := 'Invalid characters in class name. Should I use ' , newVarName printString , '?'.			(confirmBlock value: msg value: newVarName)				ifFalse: [^nil]].	(firstChar := newVarName first) isLowercase		ifTrue:			[newVarName at: 1 put: (newVarName at: 1) asUppercase.			msg := 'Class names should be capitalized. Should I use ' , newVarName printString , '?'.			(confirmBlock value: msg value: newVarName)				ifFalse: [newVarName at: 1 put: firstChar]].	^newVarName asSymbol</body></methods><methods><class-id>ICC.ICC1Utils class</class-id> <category>private</category><body package="ICCCommonClasses">entryFor: aClass at: aKeyword	"^&lt;nil | String&gt;	Answer the entry at aKeyword in aClass' comment, nil if absent."	| aStream separators |	aStream := aClass comment readStream.	separators := Core.Array with: Core.Character tab with: Core.Character space.	[aStream atEnd]		whileFalse:			[aStream skipThrough: $@.			aStream atEnd				ifFalse:					[| nextKeyword |					nextKeyword := self stream: aStream upToOneOf: separators.					(aKeyword sameAs: nextKeyword)						ifTrue:							[aStream skipSeparators.							^aStream upTo: Core.Character cr]]].	^nil</body><body package="ICCCommonClasses">stream: aStream upToOneOf: aCollection	"Answer a subcollection of aStream from position to the occurrence (if any, exclusive)	of an element of aCollection.	 The stream is left positioned after the first matching element.	If no element is not found answer everything."	| newStream element |	newStream := (aStream contentsSpecies new: 64) writeStream.	[aStream atEnd]		whileFalse:			[element := aStream next.			(aCollection includes: element)				ifTrue: [^newStream contents].			newStream nextPut: element.].	^newStream contents</body></methods><methods><class-id>ICC.ICC1Utils class</class-id> <category>class infos</category><body package="ICCCommonClasses">applicationNameFor: aClass	"^&lt;nil | String&gt;	Answer the application name for aClass.	Check aClass' comment for an entry first.	If absent, check for a class method #applicationName.	If both are absent answer nil."	| applicationName |	^(applicationName := self entryFor: aClass at: 'name') isNil		ifTrue: [(aClass respondsTo: #applicationName)				ifTrue: [aClass applicationName]				ifFalse: [nil]]		ifFalse: [applicationName]</body><body package="ICCCommonClasses">copyrightFor: aClass	"^&lt;nil | String&gt;	Answer the copyright for aClass.	Check aClass' comment for an entry first.	If absent, check for a class method #copyright.	If both are absent answer nil."	| copyright |	^(copyright := self entryFor: aClass at: 'copyright') isNil		ifTrue: [(aClass respondsTo: #copyright)				ifTrue: [aClass copyright]				ifFalse: [nil]]		ifFalse: [copyright]</body><body package="ICCCommonClasses">versionFor: aClass	"^&lt;nil | (Array of: String)&gt;	Answer the version for aClass as tupel with release and date.	Check aClass' comment for an entry first.	If absent, check for a class method #versionId.	If both are absent answer nil."	| versionId |	^(versionId := self entryFor: aClass at: 'version') isNil		ifTrue: [(aClass respondsTo: #versionId)				ifTrue: [aClass versionId]				ifFalse: [nil]]		ifFalse:			[| aStream release date |			aStream := versionId readStream.			release := aStream upTo: $,.			aStream skipSeparators.			date := aStream upToEnd.			^Core.Array with: release with: date]</body></methods><methods><class-id>ICC.ICC1Utils class</class-id> <category>texts</category><body package="ICCCommonClasses">defaultTextStyle	| cStyle |	cStyle := Graphics.CharacterAttributes newWithDefaultAttributes.	cStyle at: #tiny put: [:query :value :fontPolicy | query pixelSize: (1 max: query pixelSize - 4)].	cStyle at: #small put: [:query :value :fontPolicy | query pixelSize: (1 max: query pixelSize - 2)].	cStyle setDefaultQuery: ((Graphics.FontDescription new) family: #('arial' 'helv' 'helvetica' '*'); manufacturer: #('adobe' '*'); pixelSize: Graphics.Screen default defaultFontPolicy preferredFontSize; yourself).	^(Graphics.VariableSizeTextAttributes new) setCharacterAttributes: cStyle; install; yourself</body><body package="ICCCommonClasses">textWithCRs: stringTextOrComposedText maxWidth: anInteger	"^&lt;Text&gt;	Answer stringTextOrComposedText as string word wrapped with width limited to	anInteger. This method will be moved to a class ICUtilities."	| aStream aComposedText text |	aComposedText := stringTextOrComposedText asComposedText.	aComposedText width &lt;= anInteger ifTrue: [^aComposedText text].	aComposedText compositionWidth: anInteger.	text := aComposedText asText.	aStream := Core.TextStream on: (Core.String new: 400).	1 to: aComposedText numberOfLines		do:			[:lineIndex |			| interval |			interval := aComposedText lineAt: lineIndex.			aStream nextPutAllText: (text copyFrom: interval first to: interval last ).			(text at: interval last)				= Core.Character cr ifFalse: ["Add a cr at end of line. Don't copy existing cr's."				aStream cr]].	aStream skip: -1.	^aStream contents</body></methods><methods><class-id>ICC.ICC1AboutDialog</class-id> <category>utility</category><body package="ICCCommonClasses">computeWindowHeightFor: aBuilder	"Answer the height of the window needed for the whole about text."	| aComponent layout |	aComponent := aBuilder componentAt: #applicationText.	layout := aComponent spec layout.	^layout topOffset + aComponent widget preferredBounds height + layout bottomOffset negated</body><body package="ICCCommonClasses">setWindowHeightFor: aBuilder to: height	"Set the windows height."	| box |	box := aBuilder window displayBox.	aBuilder window displayBox: (box origin extent: box width @ height)</body></methods><methods><class-id>ICC.ICC1AboutDialog</class-id> <category>accessing</category><body package="ICCCommonClasses">logo	"^&lt;Image&gt;	Answer the applications logo if supplied, a default from ICCResources else."	^logo isNil		ifTrue: [self class resources opaqueImageAt: #info]		ifFalse: [logo]</body><body package="ICCCommonClasses">logo: anImage	logo := anImage</body><body package="ICCCommonClasses">windowLabel	^windowLabel isNil		ifTrue: [self class windowLabel]		ifFalse: [windowLabel]</body><body package="ICCCommonClasses">windowLabel: aString	windowLabel := aString</body></methods><methods><class-id>ICC.ICC1AboutDialog</class-id> <category>private</category><body package="ICCCommonClasses">copyrightCharacter	^Core.Character value: 169</body><body package="ICCCommonClasses">wrapText	| aComponent layout textWidth box |	box := self builder window displayBox.	aComponent := self builder componentAt: #applicationText.	layout := aComponent spec layout.	textWidth := box width - layout leftOffset + layout rightOffset * (layout rightFraction - layout leftFraction) + (aComponent widget displayOrigin x * 2).	self infoText value: (self class utils textWithCRs: self infoText value maxWidth: textWidth)</body></methods><methods><class-id>ICC.ICC1AboutDialog</class-id> <category>interface opening</category><body package="ICCCommonClasses">postBuildWith: aBuilder	"Finish definition of text styles and determine final window size"	super postBuildWith: aBuilder.	(aBuilder componentAt: #applicationText) widget displayContents textStyle: ((self class utils defaultTextStyle) lineGrid: 14; baseline: 12; yourself).	(aBuilder componentAt: #copyrightText) widget displayContents textStyle: ((self class utils defaultTextStyle) lineGrid: 12; baseline: 10; yourself).	self wrapText.	self setWindowHeightFor: aBuilder to: (self computeWindowHeightFor: aBuilder).	aBuilder window label: self windowLabel</body><body package="ICCCommonClasses">preBuildWith: aBuilder	"Install binding for the logo."	super preBuildWith: aBuilder.	aBuilder visualAt: #logo put: self logo.</body></methods><methods><class-id>ICC.ICC1AboutDialog</class-id> <category>aspects</category><body package="ICCCommonClasses">infoFooter	^(self class copyrightText emphasizeAllWith: #(#tiny)) asValue</body><body package="ICCCommonClasses">infoText	^infoText isNil		ifTrue: [infoText := nil asValue]		ifFalse: [infoText]</body></methods><methods><class-id>ICC.ICC1AboutDialog class</class-id> <category>private</category><body package="ICCCommonClasses">aboutTextFor: aClass	"Answer a standard about text for aClass and its components."	| str |	str := Core.TextStream on: (Core.String new: 200).	str emphasis: #(#bold #small).	self printInfosAbout: aClass on: str.	str emphasis: #(#small).	(self applicationComponentsFor: aClass)		do:			[:eachClassName |			| eachClass |			eachClass := eachClassName asQualifiedReference valueOrDo: [nil].			eachClass notNil ifTrue: [self printInfosAbout: eachClass on: str]].	str nextPutAllText: self  addressText.	^str contents</body><body package="ICCCommonClasses">applicationComponentsFor: aClass	^(aClass respondsTo: #applicationComponents)		ifTrue: [aClass applicationComponents]		ifFalse: [#()]</body><body package="ICCCommonClasses">copyrightCharacter	^Core.Character value: 169</body><body package="ICCCommonClasses">logoFor: aClass	^(aClass respondsTo: #applicationLogo)		ifTrue: [aClass applicationLogo]		ifFalse: [nil]</body><body package="ICCCommonClasses">printInfosAbout: aClass on: aStream	"Print an info text about aClass on aStream.	Since version and copyright are optional we check whether they exist or not."	| applicationName version copyright |	applicationName := self utils applicationNameFor: aClass.	aStream nextPutAll: applicationName.	(version := self utils versionFor: aClass) notNil ifTrue: [aStream			 space;			 nextPutAll: (version at: 1);			 space;			 space;			 nextPutAll: (version at: 2)].	(copyright := self utils copyrightFor: aClass) notNil ifTrue: [aStream			 cr;			 nextPutAll: 'Copyright ';			 nextPut: self copyrightCharacter;			 space;			 nextPutAll: copyright].	aStream cr; cr</body><body package="ICCCommonClasses">windowLabelFor: aClass	^self windowLabel , ' ' , (self utils applicationNameFor: aClass)</body></methods><methods><class-id>ICC.ICC1AboutDialog class</class-id> <category>interface opening</category><body package="ICCCommonClasses">labeled: label logo: logo text: text for: aVisualOrNil	| aDialog |	(aDialog := self new) windowLabel: label; logo: logo.	aDialog infoText value: text.	aDialog openInterface: #windowSpec for: aVisualOrNil</body><body package="ICCCommonClasses">showInfo: aClass	"Open a new instance of the receiver and show information on aClass."	self showInfo: aClass for: nil</body><body package="ICCCommonClasses">showInfo: aClass for: aVisualOrNil	"Open a new instance of the receiver and show information on aClass.	aClass may respond to	#applicationName	^&lt;String&gt; 				A short description.	#applicationComponents	^&lt;Array of: Symbol&gt;		Names of components of an application.	#applicationLogo	^&lt;Image&gt;				The image used in the info dialog.	#copyright	^&lt;String&gt;				e. g. '1996 IC&amp;C GmbH'	#versionId	^&lt;Array of: String&gt;		e. g. #('1.0' '06/23/96')	Application name, copyright and versionId are read from class comment if existing."	self		labeled: (self windowLabelFor: aClass)		logo: (self logoFor: aClass)		text: (self aboutTextFor: aClass)		for: aVisualOrNil</body></methods><methods><class-id>ICC.ICC1AboutDialog class</class-id> <category>constants</category><body package="ICCCommonClasses">addressText	^('IC&amp;C GmbH  Software Building Blocks\' withCRs asText emphasizeAllWith: #(#bold #small))		, ('Papenhoehe 14D-25335 ElmshornPhone:	+ 49 (0) 4121-23 92-0Fax:  	+ 49 (0) 4121-23 92-59EMail:	info@icc-gmbh.deWeb:	www.io.com/~icc/'asText emphasizeAllWith: #small)</body><body package="ICCCommonClasses">copyrightText	^'WARNING: This software is protected by German copyright laws, international treaty provisions and all applicable national laws.' withCRs asText</body><body package="ICCCommonClasses">utils	^ICC1Utils</body><body package="ICCCommonClasses">windowLabel	^'About'</body></methods><methods><class-id>ICC.ICC1ApplicationModel</class-id> <category>actions</category><body package="ICCCommonClasses">about	self iccDialog aboutDialogClass showInfo: self class infoProvider for: self builder window</body><body package="ICCCommonClasses">unimplemented	self iccDialog message: 'Sorry, this action has not yet been implemented.' for: self builder window</body></methods><methods><class-id>ICC.ICC1ApplicationModel</class-id> <category>interface opening</category><body package="ICCCommonClasses">allButOpenInterface: aSymbol	"Build the ApplicationModel's user interface, using the specification	named.  Do everything but open the interface. Return the builder."	|  spec |	builder := UI.UIBuilder new.	builder source: self.	spec := self class interfaceSpecFor: aSymbol.	self preBuildWith: builder.	self preAddSpecWith: spec.			"Hook for reading and modifying the spec."	builder add: spec.	self postBuildWith: builder.	builder window model: self.	builder doFinalHookup.	^builder</body><body package="ICCCommonClasses">openInterface: aSymbol	"Open the ApplicationModel's user interface, using the specification	named."	|  spec |	builder := UI.UIBuilder new.	builder source: self.	spec := self class interfaceSpecFor: aSymbol.	self preBuildWith: builder.	self preAddSpecWith: spec.			"Hook for reading and modifying the spec."	builder add: spec.	self postBuildWith: builder.	builder window model: self.	builder openWithExtent: spec window bounds extent.	self postOpenWith: builder.	^builder</body><body package="ICCCommonClasses">preAddSpecWith: aSpec	"Do anything you might want to do prior to the builder adding aSpec."</body><body package="ICCCommonClasses">preBuildWith: aBuilder	super preBuildWith: aBuilder.	self iccChangeLookPolicyWith: aBuilder</body></methods><methods><class-id>ICC.ICC1ApplicationModel</class-id> <category>private</category><body package="ICCCommonClasses">iccDialog	^ICC1Dialog</body></methods><methods><class-id>ICC.ICC1ApplicationModel class</class-id> <category>resources</category><body package="ICCCommonClasses">applicationIcon	^self resources iconFor: self named: #applicationImage</body><body package="ICCCommonClasses">opaqueApplicationImage	^self resources opaqueImageFor: self named: #applicationImage</body></methods><methods><class-id>ICC.ICC1ApplicationModel class</class-id> <category>accessing</category><body package="ICCCommonClasses">infoProvider	^self</body><body package="ICCCommonClasses">resources	^ICC1Images</body></methods><methods><class-id>Core.Object</class-id> <category>error handling</category><body package="ICCCommonClasses">shiftHalt	InputState default shiftDown ifTrue: [self halt]</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>ICC-CommonClasses</category><body package="ICCCommonClasses">iccBeOn: aBoolean group: aCollectionOfIDs	self builder isNil ifTrue: [^self].	aCollectionOfIDs		do:			[:id |			| component |			component := builder componentAt: id.			component notNil ifTrue: [aBoolean					ifTrue: [component beOn]					ifFalse: [component beOff]]]</body><body package="ICCCommonClasses">iccChangeLookPolicyWith: aBuilder	"Change look policies. Substitute Win3LookPolicy by ICCWin3DLookPolicy and	CUALookPolicy by ICCCUALookPolicy. Do nothing if substitutes aren't available.	This code is typically sent during the #preBuildWith: process."	| lookPolicyName |	lookPolicyName := aBuilder policy class name.	lookPolicyName == #Win3LookPolicy		ifTrue:			[| preferredLook |			preferredLook := ('win32*4.0*' match: OSHandle currentPlatformID)						ifTrue: [#ICC1Win95LookPolicy]						ifFalse: [#ICC1Win3DLookPolicy].			aBuilder policy: (Smalltalk at: preferredLook ifAbsent: [^self]) new].	lookPolicyName == #CUALookPolicy ifTrue: [aBuilder policy: (Smalltalk at: #ICC1CUALookPolicy ifAbsent: [^self]) new]</body><body package="ICCCommonClasses">iccEnable: aBoolean group: aCollectionOfIDs	self builder isNil ifTrue: [^self].	aCollectionOfIDs		do:			[:id |			| component |			component := builder componentAt: id.			component notNil ifTrue: [aBoolean					ifTrue: [component enable]					ifFalse: [component disable]]]</body><body package="ICCCommonClasses">iccEnable: aBoolean itemAndButtonGroup: aCollectionOfIDs	self iccEnable: aBoolean group: (aCollectionOfIDs collect: [:i | (i , #Item) asSymbol])			, (aCollectionOfIDs collect: [:i | (i , #Button) asSymbol])</body><body package="ICCCommonClasses">iccVisible: aBoolean group: aCollectionOfIDs	self builder isNil ifTrue: [^self].	aCollectionOfIDs		do:			[:id |			| component |			component := builder componentAt: id.			component notNil ifTrue: [component isVisible: aBoolean]]</body></methods><methods><class-id>ICC.ICC1ProgressDialog class</class-id> <category>interface specs</category><body package="ICCCommonClasses">animationSpec	"UIPainter new openOnClass: self andSelector: #animationSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: ''			#min: #(#{Core.Point} 400 152 )			#max: #(#{Core.Point} 400 152 )			#bounds: #(#{Graphics.Rectangle} 627 550 1027 702 ) )		#component:		#(#{UI.SpecCollection}			#collection: #() ) )</body><body package="ICCCommonClasses">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: 'Progress...'			#min: #(#{Core.Point} 400 152 )			#max: #(#{Core.Point} 400 152 )			#bounds: #(#{Graphics.Rectangle} 638 538 1038 690 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} -85 1 -42 1 -10 1 -19 1 )					#model: #doCancel					#tabable: false					#label: 'Cancel' )				#(#{UI.TextEditorSpec}					#layout: #(#{Graphics.LayoutFrame} 4 0 -93 1 -8 1 -69 1 )					#flags: 4					#model: #infoField1					#isReadOnly: true )				#(#{UI.TextEditorSpec}					#layout: #(#{Graphics.LayoutFrame} 4 0 -71 1 -91 1 -47 1 )					#flags: 4					#model: #infoField2					#isReadOnly: true )				#(#{UI.TextEditorSpec}					#layout: #(#{Graphics.LayoutFrame} 4 0 -23 1 -101 1 0 1 )					#flags: 4					#model: #remainingTimeField					#isReadOnly: true )				#(#{ICC.ICC1ProgressBarSpec}					#layout: #(#{Graphics.LayoutFrame} 10 0 -39 1 -91 1 -23 1 )					#model: #progress					#start: 0					#stop: 1 )				#(#{UI.SubCanvasSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0 0 0 0 1 -95 1 )					#flags: 0					#minorKey: #animationSpec ) ) ) )</body></methods><methods><class-id>ICC.ICC1Wizard class</class-id> <category>interface specs</category><body package="ICCCommonClasses">backNextCancelSpec	"UIPainter new openOnClass: self andSelector: #backNextCancelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: ' '			#min: #(#{Core.Point} 350 48 )			#max: #(#{Core.Point} 350 48 )			#bounds: #(#{Graphics.Rectangle} 638 532 988 580 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.SubCanvasSpec}					#layout: #(#{Graphics.LayoutFrame} 138 0 0 0 0 1 -76 1 )					#name: #pageHolder					#flags: 0 )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} -245 1 -34 1 -170 1 -10 1 )					#name: #back					#model: #back					#label: '&lt; Back' )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} -170 1 -34 1 -95 1 -10 1 )					#name: #next					#model: #next					#label: 'Next &gt;'					#isDefault: true )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} -85 1 -34 1 -10 1 -10 1 )					#name: #cancel					#model: #doCancel					#label: 'Cancel' ) ) ) )</body><body package="ICCCommonClasses">nextCancelSpec	"UIPainter new openOnClass: self andSelector: #nextCancelSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: ' '			#min: #(#{Core.Point} 376 61 )			#max: #(#{Core.Point} 376 61 )			#bounds: #(#{Graphics.Rectangle} 682 537 1058 598 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.SubCanvasSpec}					#layout: #(#{Graphics.LayoutFrame} 138 0 0 0 0 1 -76 1 )					#name: #pageHolder					#flags: 0 )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} -245 1 -34 1 -170 1 -10 1 )					#flags: 40					#model: #back					#label: '&lt; Back' )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} -170 1 -34 1 -95 1 -10 1 )					#model: #next					#label: 'Next &gt;'					#isDefault: true )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} -85 1 -34 1 -10 1 -10 1 )					#model: #doCancel					#label: 'Cancel' ) ) ) )</body><body package="ICCCommonClasses">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: ' '			#min: #(#{Core.Point} 420 325 )			#max: #(#{Core.Point} 420 325 )			#bounds: #(#{Graphics.Rectangle} 700 541 1120 866 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.GroupBoxSpec}					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 130 0 -87 1 ) )				#(#{UI.DividerSpec}					#layout: #(#{Graphics.LayoutFrame} 10 0 -46 1 -10 1 -42 1 ) )				#(#{UI.SubCanvasSpec}					#layout: #(#{Graphics.LayoutFrame} 138 0 0 0 0 1 -77 1 )					#name: #pageHolder					#flags: 0 )				#(#{UI.SubCanvasSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0 -42 1 0 1 0 1 )					#name: #buttonHolder					#flags: 0 )				#(#{UI.SubCanvasSpec}					#layout: #(#{Graphics.LayoutFrame} 11 0 11 0 129 0 -88 1 )					#flags: 0					#minorKey: #paintingSpec ) ) ) )</body></methods><methods><class-id>ICC.ICC1AboutDialog class</class-id> <category>interface specs</category><body package="ICCCommonClasses">windowSpec	"UI.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: 'About'			#bounds: #(#{Graphics.Rectangle} 643 507 970 844 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.TextEditorSpec}					#layout: #(#{Graphics.LayoutFrame} 4 0 -74 1 -78 1 -6 1 )					#name: #copyrightText					#flags: 4					#model: #infoFooter					#style: #pixelDefault					#isReadOnly: true )				#(#{UI.TextEditorSpec}					#layout: #(#{Graphics.LayoutFrame} 70 0 8 0 -8 1 -88 1 )					#name: #applicationText					#flags: 4					#model: #infoText					#isReadOnly: true )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} -68 1 -70 1 -8 1 -47 1 )					#model: #accept					#label: 'OK'					#isDefault: true )				#(#{UI.DividerSpec}					#layout: #(#{Graphics.LayoutFrame} 8 0 -80 1 -8 1 -78 1 ) )				#(#{UI.LabelSpec}					#layout: #(#{UI.AlignmentOrigin} 35 0 10 0 0.5 0 )					#label: #logo					#hasCharacterOrientedLabel: false ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>