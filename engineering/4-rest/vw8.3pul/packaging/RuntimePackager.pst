<?xml version="1.0"?><st-source><!-- Name: RuntimePackagerNotice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.Comment: Runtime Packager is an image deployment utility that removes development tools and other unwanted classes from an image, leaving an image file that occupies significantly less disk space because it contains only objects required by your application.Description:The RuntimePackager (a.k.a. RTP) is composed of several parts: a mechanism for stripping a developmentment image, a tool to manipulate all the various settings of the stripping and packaging process, and a group of support classes that get packaged in a deployed image. The stripping mechanism is implemented in class RuntimeManager and its subclass RuntimeManagerStripper. The various RuntimeBuilder* classes are part of the RTP tool, and they are mostly stripped from the deployed image.Since the stripping process generally removes the tools, including the Debugger, the Runtime Packager also provides a framework for error handling and error notification. This is implemented in RuntimeErrorNotifier and its subclasses. Aside from those, the most important support class is RuntimeApplicationStartupSystem, which handles starting subsystems in the image before launching the deployed application.The public API for the Runtime Packager is mostly in the class-side protocol of class RuntimeManager.Usage:To open the Runtime Packager, use the "Tools" menu in the Launcher window or use the following do-it:	RuntimePackager.RuntimeBuilderUI openExternal Documentation:Further information on the Runtime Packager can be found in the "Application Developer's Guide" (located in the /doc subdirectory of the VisualWorks installation).DbIdentifier: bear73DbTrace: 475242DbUsername: nrossDbVersion: 8.2 - 1DevelopmentPrerequisites: #(#(#any 'Tools-IDE-ListIcons' ''))PackageName: RuntimePackagerParcel: #('RuntimePackager')ParcelName: RuntimePackagerPrerequisiteParcels: #(#('Tools-IDE-ListIcons' ''))PrintStringCache: (8.2 - 1,nross)Version: 8.2 - 1Post-Load Block: 	[:pkg |#{RuntimePackager.RuntimeManager} ifDefinedDo: [ :mgr | mgr postLoadActionFor: pkg ].]Pre-Unload Block: 	[:pkg |#{RuntimePackager.RuntimeManager} ifDefinedDo: [ :mgr | mgr preUnloadActionFor: pkg ].]Date: 12:20:33 PM October 23, 2015 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.2 (oct15.4) of October 23, 2015 on October 23, 2015 at 12:20:33 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>RuntimePackager</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Advbool-RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></name-space><class><name>RuntimeDeletedBehavior</name><environment>RuntimePackager</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id><body>RuntimeDeletedBehavior provides a "meta" class for instances of the objects substituted for behaviors which are deleted. Messages sent to these objects are generally not understood and cause a signal to be raised.RuntimeDeletedBehavior is a support class for the Runtime Packager, and gets packaged with the deployed application.Instance Variables:	originalName &lt;Symbol | String&gt;Class Variables:	DeletedBehaviorReferencedSignal &lt;Signal | nil&gt;	DummyMethodDictionary &lt;MethodDictionary | nil&gt;</body></comment><class><name>RuntimeManager</name><environment>RuntimePackager</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeManager</class-id><body>RuntimeManager provides a central set of data and methods used in creating the final stripped image and in managing image startup.  The template methods implemented here are copied to other classes as needed to selectively replace existing methods.  RuntimeManager and its subclass RuntimeManagerStripper are responsible for creating the final stripped image.  After the stripping process is completed, many of the methods are removed from RuntimeManager by the stripping process. Class RuntimeManager gets deployed, since it is used during startup of the user's application.Class Variables:	DeletedClasses &lt; ( IdentitySet of: Behavior ) | nil &gt;	DeletedGlobals &lt; ( IdentitySet of: Symbol ) | nil&gt;	DeletedMethods &lt; ( IdentityDictionary key: Behavior value: Set ) | nil &gt;	ErrorLogPath &lt;String | nil&gt;	ErrorNotifierClass &lt;Behavior | nil&gt;	ImageIdentification &lt;String | nil&gt;	ImagePath &lt;String | nil&gt;	InstVarIndexes &lt;IdentityDictionary&gt;	RunState &lt;Symbol&gt;	StartupMethod &lt;Symbol | nil&gt;	StrippingOptions &lt;Set&gt;	VWRelease &lt;Number | nil &gt;	ImageDumperClass &lt;Behavior | nil&gt;	LoadableClasses &lt; ( IdentitySet of: Behavior ) | nil&gt;	MemoryParams &lt;RuntimeBuilderMemoryParams | nil&gt;	NewMemoryPolicy &lt;MemoryPolicy | nil&gt;	PostStripBlock &lt;BlockClosure | nil&gt;	QuitBlock &lt;BlockClosure | nil&gt;	StartupClassName &lt;Symbol | nil&gt;</body></comment><class><name>RuntimeBuilderEditableObject</name><environment>RuntimePackager</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>editor viewer hasBeenEdited </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderEditableObject</class-id><body>RuntimeBuilderEditableObject provides a framework for objects that can be edited through a user interface.RuntimeBuilderEditableObject is a support class for the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.RuntimeBuilderEditor provides the corresponding part of the framework for the user interface used to change the object. In addition to an editor, an object can have a viewer, which is a user interface that displays but does not change the object. Only a single editor is permitted at one time. When the editor window closes, editor is set to nil. The same rules apply to viewer as well.Subclasses must implement the following messages:	accessing		editorClassInstance Variables:	editor &lt;RuntimeBuilderEditor&gt;	viewer &lt;RuntimeBuilderEditor&gt;	hasBeenEditted &lt;Boolean&gt;</body></comment><class><name>RuntimeBuilderMemoryParams</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderEditableObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>edenSize survivorSize largeSize stackSize codeSize oldSize fixedSize memoryPolicyClass memoryUpperBound </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderMemoryParams</class-id><body>RuntimeBuilderMemoryParams holds the current settings for memory parameters.RuntimeBuilderMemoryParams is a support class for the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.This class obtains the current space size values from ObjectMemory and the memory policy settings from ObjectMemory's current memory policy.  Please consult ObjectMemory and MemoryPolicy for further information on what these memory parameters are used for.Instance Variables	codeSize &lt;Number&gt;		The size (in bytes) of the Compiled CodeCache	edenSize  &lt;Number&gt;	The size (in bytes) of Eden	largeSize  &lt;Number&gt;	The size (in bytes) of the Large Space	oldSize  &lt;Number&gt;		The size (in bytes) of the Old Space	stackSize  &lt;Number&gt;	The size (in bytes) of the Stack Space	survivorSize  &lt;Number&gt;	The size (in bytes) of the Survivor Space	fixedSize	&lt;Number&gt;	The size (in bytes) of Fixed Space	memoryPolicyClass &lt;String&gt;		The full name of the memory policy class	memoryLimit  &lt;Number&gt;	The ceiling of memory growth</body></comment><class><name>RuntimeBuilderOptions</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderEditableObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorNotifierClass errorLogPath imageDumperClass startupClass startupMethod imagePath strippingOptions uiLooks operatingSystems parcelOptions prestripClass prestripMethod traceLevel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderOptions</class-id><body>RuntimeBuilderOptions is an editable object holding user-selected options that control building of the final stripped image.RuntimeBuilderOptions is a support class for the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.Instance Variables:	errorNotifierClass &lt;Class&gt;	errorLogPath &lt;String&gt;	imageDumperClass &lt;Class | nil &gt;	imagePath &lt;String&gt;	operatingSystems &lt;Set&gt;	prestripClass &lt;Class | nil&gt;	prestripMethod &lt;Symbol | nil&gt;	startupClass &lt;Class | nil&gt;	startupMethod &lt;Symbol | nil&gt;	strippingOptions &lt;Set&gt;	uiLooks &lt;Set&gt;	parcelOptions &lt;Dictionary&gt;	prestripClass &lt;Class | nil &gt;	prestripMethod &lt;Symbol | nil &gt;	traceLevel &lt;Integer&gt;</body></comment><class><name>RuntimeInstanceSurrogate</name><environment>RuntimePackager</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeInstanceSurrogate</class-id><body>RuntimeInstanceSurrogate provides a superclass for surrogates of classes. A minimal set of methods is provided with all messages that are not understood routed to the RuntimeSurrogateManager for processing.</body></comment><class><name>RuntimeHeadlessExample</name><environment>RuntimePackager</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeHeadlessExample</class-id><body>RuntimeHeadlessExample provides a simple application for testing headless image support.RuntimeHeadlessExample is a support class for the Runtime Packager, and gets stripped from the deployed application.</body></comment><class><name>RuntimeBuilderMessageTracer</name><environment>RuntimePackager</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>notifier options items invertedSelectors invertedClasses exitClasses accessors globalBindings sentSelectors deletedClasses deletedGlobals referencedClasses referencedGlobals referencedMethods newSelectors newClasses blocksReferenced externalInterfaceClasses pragmaReferences tracedMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderMessageTracer</class-id><body>RuntimeBuilderMessageTracer provides a way to trace message sends throughout the image to discover which classes, global, shared and methods may be removed when creating the runtime image.DescriptionRuntimeBuilderMessageTracer is a support class for the Runtime Packager tool, and has no public API. This class gets stripped from the deployed image.UsageDuring the stripping process, an instance of this class is created, supplied with a collection of items to keep and options (an instance of RuntimeBuilderOptions). Tracing is done by sending #traceSystem. After #traceSystem is done, the instance variable items is fully popluated with the results. For example:	tracer := RuntimeBuilderMessageTracer new.	options := RuntimeBuilderOptions new setDefaults.	keptItems := RuntimeBuilderItems new		options: options;		setDefaults.	tracer options: options,	tracer keptItems: keptItems.	tracer traceSystemStarting from kept methods and kepts classes, class, global, and selector refrerences are accumulated. When no new references are discovered, the process is complete. See #traceMessages for the details.Instance Variables:	notifier &lt;RuntimeProgressNotifier&gt;	invertedSelectors &lt;IdentityDictionary &gt;	accessors &lt;IdentitySet of: Symbol&gt;	sentSelectors &lt;IdentitySet of: Symbol&gt;	deletedClasses &lt;IdentitySet of: Behavior&gt;	deletedGlobals &lt;IdentitySet of: BindingReference&gt;	referencedClasses &lt;IdentitySet of: Behavior&gt;	referencedGlobals &lt;IdentitySet of: BindingReference &gt;	newSelectors &lt;IdentitySet of: Symbol&gt;	newClasses &lt;IdentitySet of: Behavior&gt;	options &lt;RuntimeBuilderOptions&gt;	items &lt;RuntimeBuilderItems&gt;	exitClasses &lt;IdentitySet of: Behavior&gt;	referencedMethods &lt;IdentityDictionary&gt;	pragmaReferences &lt;List of: CompiledMethod&gt;	A cache of all CompiledMethods that reference the Pragma class directly, to save doing a senders operation for each pragma method</body></comment><class><name>RuntimeBuilderAppModel</name><environment>RuntimePackager</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isChanged </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderAppModel</class-id><body>RuntimeBuilderAppModel implements an abstract class used as the basis of user interface ApplicationModel subclasses.  RuntimeBuilderAppModel is part of the Runtime Packager tool, and has no public API. It provides the functionality to track whether the user has made changes since the Runtime Packager tool was opened. As such, this class and all of its subclasses get stripped from the deployed image.Instance Variables:	isChanged &lt;Boolean&gt;</body></comment><class><name>RuntimeBuilderEditor</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderAppModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>subject warnings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderEditor</class-id><body>RuntimeBuilderEditor provides a framework for objects that can be edited through a user interface.RuntimeBuilderEditableObject is a support class used by the Runtime Packager tool, and has no public API. It provides the corresponding part of the framework for the object being changed. When the editor window closes, the subject object is notified to remove references to the application window containing the editor. As such, this class and all of its subclasses get stripped from the deployed image.Warnings are filtered to show each occurence only once. If the warning is identified by a user interface component, a new warning can be issued if the component is changed.Subclasses must implement the following messages:	internals		copyValuesFromSubjectInstance Variables:	subject &lt;RuntimeBuilderEditableObject&gt;	warnings &lt;Set&gt;</body></comment><class><name>RuntimeBuilderClassChooser</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameSpaceList categoryListTitle selectableClasses definedClasses selectableClassList selectedSubapplications bindingsInCurrentlySelected </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderClassChooser</class-id><body>RuntimeBuilderClassChooser provides a common framework for classes that choose classes based upon packages. A user interface showing a selection list of packages must be provided by the subclass.RuntimeBuilderClassChooser is part of the Runtime Packager tool, and has no public API. As such, this class and all of its subclasses get stripped from the deployed image.Note that this class was formerly used to select via categories, but is being repurposed to select via packages. Some of the old "category" nomenclature may still be used in comments, methods, and variable names.Subclasses must implement the following messages:	Instance protocol:		accessing			systemPackagesTree		actions			systemCategoriesSelectionChanged	Class protocol:		resources			systemSelectionMenuInstance Variables:	categoryListTitle	&lt;ValueModel&gt;			definedClasses	&lt;IdentitySet of: Class&gt;			globalBindings	&lt;(Set of: (GeneralBindingReference))&gt;		Binding references for shared variables in classes and in namespaces	nameSpaceList	&lt;SelectionInList&gt;			selectableClasses	&lt;IdentitySet of: Class&gt;			selectableClassList	&lt;List of: Association&gt;			selectedSubapplications	&lt;IdentitySet of: Class&gt;			systemCategoriesList	&lt;TreeSelectionModule&gt;		</body></comment><class><name>RuntimeErrorNotifier</name><environment>RuntimePackager</environment><super>Core.ErrorNotifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isProceedable exceptionType </inst-vars><class-inst-vars>debugNotifierMode </class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeErrorNotifier</class-id><body>RuntimeErrorNotifier is an abstract class from which error notifier subclasses can be created.RuntimeErrorNotifier is a support class for the Runtime Packager, and gets packaged with the deployed application.In a runtime image, the Notifier current instance is typically be set to one of these subclasses. Subclasses typically override methods in the 'user interface' protocol. The most common type of behavior is that, rather than opening an interactive debugger, they write some sort of error log.This class tries to ensure that it has a writable file when dumping the system state to a file (see #createEmergencyDump).Instance Variables:	isProceedable &lt;Boolean&gt; Is the exception proceedable.	exceptionType &lt;Symbol&gt; Different runtime behaviour may be desirable for different broad categories of exceptions. The method #classifyException will group exceptions into one of #(halt notify userInterrupt lowSpace other), and some methods will do different things for different categories of exceptions.Class Instance Variables:	debugNotifierMode &lt;nil | Boolean&gt; A flag for debug testing of this notifier. If this is true, then our intercept of notification is ignored, and it will reset the notifier to development mode and halt.</body></comment><class><name>RuntimeQuietEmergencyNotifier</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeErrorNotifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeQuietEmergencyNotifier</class-id><body>RuntimeQuietEmergencyNotifier provides an emergency notifier that does not interact with the user.RuntimeQuietEmergencyNotifier is a support class for the Runtime Packager, and gets packaged with the deployed application.When RuntimeQuietEmergencyNotifier has been chosen as an error notifier, the sole means of diagnosing an error is the dump created. This class is generally used when packaging a headless image for deployment.</body></comment><class><name>RuntimeMethodSurrogate</name><environment>RuntimePackager</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>hookedMethod hookedSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeMethodSurrogate</class-id><body>RuntimeMethodSurrogate is used as a replacement for a method which has been wrappered so that a reference to the original method can be detected.Instance Variables:	hookedMethod &lt;CompiledMethod&gt;	hookedSelector &lt;Symbol&gt;</body></comment><class><name>RuntimeBuilderItems</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderEditableObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>deletedClasses keptClasses deletedMethods keptMethods deletedGlobals keptGlobals unreferencedClasses unreferencedGlobals unreferencedMethods options globalBindings cachedDefaults </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderItems</class-id><body>RuntimeBuilderItems holds collections of classes, methods, and globals to be kept or deleted.  RuntimeBuilderItems provides for setting default values and interfacing with the external file holding settings.RuntimeBuilderItems is a support class for the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.Instance Variables:	deletedClasses &lt;IdentitySet of: Class&gt;	keptClasses &lt;IdentitySet of: Class&gt;	keptMethods &lt;IdentityDictionary key: Behavior value: Set&gt;	deletedMethods &lt;IdentityDictionary key: Behavior value: Set&gt;	deletedGlobals &lt;IdentitySet of: BindingReference&gt;	keptGlobals &lt;IdentitySet of: BindingReference&gt;	unreferencedMethods &lt;IdentityDictionary key: Behavior value: Set&gt;	unreferencedClasses &lt;IdentitySet of: Class&gt;	unreferencedGlobals &lt;IdentitySet of: BindingReference&gt;	options &lt;RuntimeBuilderOptions&gt;The encoding of deletedMethods, keptMethods, and unreferencedMethods is as a dictionary in which the key is the class or metaclass and the value is a set of selectors within the behavior.</body></comment><class><name>VersionForPackaging</name><environment>RuntimePackager</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.VersionForPackaging</class-id><body>VersionForPackaging is a minimal implementation of a version object to meet the needs of RuntimePackager. An instance knows how to read and write itself to a string form and compare itself to another instance. The class can create an instance reflecting the version of the current image, or create an instance from a Float. This class is intended for use only by RuntimePackager, since the notion of ordering versions does not always work in  a general sense because versions represent a branching tree. Instances of this class can order themselves in the most likely order of use (i.e. a user would most likley use RTP with 7.9, 7.9.1 and 7.10 in that order, even though both 7.9.1 and 7.10 are derive from 7.9).Instance Variables	elements	Array with 3 elements		Contains the integer elements of a version like, e.g. '7.9.1' as #( 7 9 1) or '7.10' as #(7 10 0)</body></comment><class><name>RuntimeApplicationStartupSystem</name><environment>Smalltalk</environment><super>Core.UserApplication</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimeApplicationStartupSystem</class-id><body>This starts up the application specified by Runtime Packager.Packaged applications are started using the Subsystem mechanism, (class RuntimeApplicationStartupSystem is a subclass of Subsystem). Runtime Packager includes this class in the deployed image, and uses the #main method to invoke the startup class/method. The same mechanism is used in both headless images and those with an active GUI.Note that the startup sequence of subsystems depends upon their prerequisite ordering. For details, see the comment for class Subsystem and the "Application Developer's Guide" (located in the /doc subdirectory of the VisualWorks installation).</body></comment><class><name>RuntimeBuilderReferenceBrowser</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderAppModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referenceFoundText referencesList keptItemsFilter targetsList referencesCache currentTarget keptItems deletedClasses deletedGlobals deletedMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser</class-id><body>Browse for references using an extended notion of a reference to class or method. This is parallel to the type of references detected in the scan for referenced items.RuntimeBuilderReferenceBrowser is part of the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.Instance Variables:	referenceFoundText &lt;ValueHolder on: Text&gt;	referencesList &lt;SelectionInList of: Association &gt;	keptItemsFilter &lt;ValueHolder on: Boolean&gt;	targetsList &lt;List&gt;	referencesCache &lt;IdentityDictionary&gt;	currentTarget &lt;Symbol | String &gt;	keptItems &lt;RuntimeBuilderItems&gt;	deletedClasses &lt;IdentitySet of: Class&gt;	deletedGlobals &lt;Set of: VariableBinding&gt;	deletedMethods &lt;IdentityDictionary key: Behavior value: Set&gt;</body></comment><class><name>RuntimeStartupController</name><environment>RuntimePackager</environment><super>UI.ApplicationStandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeStartupController</class-id><body>RuntimeStartupContoller is the controller of the main Runtime Packager window (see RuntimeBuilderUI).RuntimeStartupController detects the close of the window during the process of stripping the image and passes control to RuntimeManager to complete the stripping operation. This is done to allow as much of RuntimeBuilderUI and associated objects to be eliminated from the runtime image as possible.</body></comment><class><name>RuntimeBuilderItemsChooser</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderClassChooser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workingCopy keptClassesList keptMethodsList contingentClassesList contingentMethodsList deletedClassesList deletedMethodsList systemPackagesTree </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id><body>RuntimeBuilderItemsChooser provides the editor for setting values in the object holding collections of kept and deleted classes, methods, and globals.RuntimeBuilderItemsChooser is part of the Runtime Packager tool, and has no public API. As such, this class and all of its subclasses get stripped from the deployed image.Instance Variables:	deletedClasses &lt;IdentitySet of: Behavior&gt;	keptClasses &lt;IdentitySet of: Behavior&gt;	keptMethods &lt;IdentityDictionary key: Behavior value: Set&gt;	deletedMethods  &lt;IdentityDictionary key: Behavior value: Set&gt;	keptClassesList &lt;ValueHolder on: MultiSelectionInList&gt;	keptMethodsList &lt;ValueHolder on: MultiSelectionInList&gt;	contingentClassesList &lt;ValueHolder on: MultiSelectionInList&gt;	contingentMethodsList &lt;ValueHolder on: MultiSelectionInList&gt;	deletedClassesList &lt;ValueHolder on: MultiSelectionInList&gt;	deletedMethodsList &lt;ValueHolder on: MultiSelectionInList&gt;	deletedGlobals &lt;IdentitySet&gt;	keptGlobals &lt;IdentitySet&gt;deletedClasses and keptClasses contain class names rather than the classes themselves.</body></comment><class><name>RuntimeBuilderItemsViewer</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderItemsChooser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showParcelsAs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderItemsViewer</class-id><body>RuntimeBuilderItemsViewer provides a read-only editor (viewer) for kept and deleted classes, methods, and globals.  This viewer reflects the status after classes, methods and globals are deleted.  The contingent category does not apply.RuntimeBuilderItemsViewer is part of the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.Instance Variables:	showParcelsAs &lt;ValueHolder on: Symbol&gt;</body></comment><class><name>RuntimeBuilderMemoryParamEditor</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>edenSize survivorSize largeSize stackSize codeSize oldSize fixedSize memoryPolicyClass memoryPolicyClasses memoryLimit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderMemoryParamEditor</class-id><body>RuntimeBuilderMemoryParamEditor provides editor services for the current settings for memory parameters.RuntimeBuilderMemoryParamEditor is part of the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.Instance Variables:	codeSize &lt;ValueHolder on: Number&gt;	edenSize  &lt;ValueHolder on: Number&gt;	growthLimit  &lt;ValueHolder on: Number&gt;	incrementSize  &lt;ValueHolder on: Number&gt;	largeSize  &lt;ValueHolder on: Number&gt;	memoryLimit  &lt;ValueHolder on: Number&gt;	oldSize  &lt;ValueHolder on: Number&gt;	retryDecrement  &lt;ValueHolder on: Number&gt;	stackSize  &lt;ValueHolder on: Number&gt;	survivorSize  &lt;ValueHolder on: Number&gt;</body></comment><class><name>HierarchyErrorMessage</name><environment>RuntimePackager</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>errorString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.HierarchyErrorMessage</class-id><body>HierarchyErrorMessage is a specialized error notification dialog to assist a developer handle image strip errors in RuntimePackager Instance Variables:	errorString	&lt;ValueModel&gt;	error message to appear in notification dialog</body></comment><class><name>RuntimeExample</name><environment>RuntimePackager</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>survUsed oldUsed largeAlloc edenUsed permUsed oldAlloc largeUsed edenAlloc permAlloc survAlloc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeExample</class-id><body>RuntimeExample is a simple example application for exercising the packager tool.RuntimeExample shows memory statistics taken from ObjectMemory.RuntimeExample is a support class for the Runtime Packager, and gets stripped from the deployed application.Instance Variables:	survUsed &lt;ValueHolder on: Integer&gt;	oldUsed &lt;ValueHolder on: Integer&gt;	largeAlloc &lt;ValueHolder on: Integer&gt;	edenUsed &lt;ValueHolder on: Integer&gt;	permUsed &lt;ValueHolder on: Integer&gt;	oldAlloc &lt;ValueHolder on: Integer&gt;	largeUsed &lt;ValueHolder on: Integer&gt;	edenAlloc &lt;ValueHolder on: Integer&gt;	permAlloc &lt;ValueHolder on: Integer&gt;	survAlloc &lt;ValueHolder on: Integer&gt;</body></comment><class><name>RuntimeClassSurrogate</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeInstanceSurrogate</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeClassSurrogate</class-id><body>RuntimeClassSurrogate provides a superclass for surrogates of metaclasses. A minimal set of methods is provided with all messages that are not understood routed to the RuntimeSurrogateManager for processing.RuntimeClassSurrogate is a support class for the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.</body></comment><class><name>RuntimeFullDumper</name><environment>RuntimePackager</environment><super>Core.ErrorDumper</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeFullDumper</class-id><body>RuntimeFullDumper creates a more complete dump suitable for a packaged runtime image.RuntimeFullDumper is a support class for the Runtime Packager, and gets packaged with the deployed application.In addition to the information written by ErrorDumper, this class provides a means to include a more detailed stack dump, the command line information, database connections, an image identifier that can be set with the Runtime Packager, stacks for all quiescent processes, the contents of the Transcript, and open windows.</body></comment><class><name>RuntimeCompiledMethod</name><environment>RuntimePackager</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeCompiledMethod</class-id><body>This class provides an implementation of CompiledMethod that does away with instance variables not used by the virtual machine.  When the RuntimeCompiledMethod option is selected during packaging, the Runtime Packager checks for classes with unused instance variables and, if possible, alters the format of the class in the runtime image to reduce the number of variables. Replacement methods are supplied for methods that would have accessed these variables. This class will be used in the deployed image, where necessary.</body></comment><class><name>RuntimeEmergencyNotifier</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeErrorNotifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>emergencyAbortText </class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeEmergencyNotifier</class-id><body>RuntimeEmergencyNotifier provides the notifier used for unhandled exceptions in the stripped image. Text provided to the user can be changed by supplying new values for the class variables (and the sole class instance variable, emergencyAbortText).RuntimeEmergencyNotifier is a support class for the Runtime Packager, and gets packaged with the deployed application.Class Instance Variables:	emergencyAbortText 	&lt;String&gt; The message to display when there is an error while the image is quitting.Class Variables:	DialogClass &lt;Dialog|Class&gt; This is the class that will understand #choose:labels:values:default:.  By default the system's dialog class, Dialog is used.	DumpFailedMsg &lt;String&gt; This is the message to display when there was an error while writing the dump of the system state.	ErrorOccurredMsg &lt;String&gt; This is the message to display when an unhandled exception has occurred.	UserInterruptMsg &lt;String&gt; The is the message to display when an UserInterrupt (or one of its subclasses) has occurred.  </body></comment><class><name>RuntimeDebugNotifier</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeEmergencyNotifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeDebugNotifier</class-id><body>RuntimeDebugNotifier is an extension of the standard runtime emergency notifier that allows processing to continue after an application error. Any unhandled exceptions are dismissed if the user so authorizes.RuntimeDebugNotifier is a support class for the Runtime Packager, and gets packaged with the deployed application.Class Variables:	DebugErrorMsg &lt;String | nil&gt; The message to display when an unhanded exception has occurred.  Different from its superclass, because this user might proceed through the exception.	DebugInterruptMsg &lt;String | nil&gt; The message to display when UserInterrupt (or subclass) has occurred during the proceeding of the UnhandledException.	ButtonTitles &lt;Dictionary | nil&gt;  A dictionary that provides the labels for the dialog buttons, see the class side #buttonTitles method for an example of its structure.</body></comment><class><name>RuntimeSurrogateManager</name><environment>RuntimePackager</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>recursionLock exemptClasses hookedSuperclasses hookedMethodDictionaries unhookClassBlock unhookMethodBlock surrogateMethods </inst-vars><class-inst-vars>activeManager unhookingErrorSignal </class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeSurrogateManager</class-id><body>RuntimeSurrogateManager maintains information needed to support class and instance surrogates.Surrogates are created by dynamically rearranging the class hierarchy and removing access to method dictionaries.  RuntimeClassSurrogate and RuntimeInstanceSurrogate provide for routing message sends from surrogates to RuntimeSurrogateManager which in turn restores the hierarchy and method dictionary before resending the message previously not understood. A recursion lock is used to ensure integrity when multiple processes could potentially be sending messages to surroagates.Exempt classes are classes used in surrogate message processing. These classes themselves can not be surrogates due to the obvious recursion problem when they are referenced.There is a distinguished instance of RuntimeSurrogateManager which can be accessed through RuntimeSurrogateManager class&gt;&gt;activeManager.  Normally a new instance is needed only if the surrogate manager itself has been corrupted (which probably will orphan some surrogates) or if the collection of exempt classes is changed.Instance Variables:	recursionLock &lt;RecursionLock&gt;	exemptClasses &lt;IdentitySet&gt;	hookedSuperclasses &lt;IdentityDictionary&gt;	hookedMethodDictionaries &lt;IdentityDictionary&gt;	unhookClassBlock &lt;BlockClosure | nil&gt;	hookedMethods &lt;IdentityDictionary&gt;	unhookMethodBlock &lt;BlockClosure | nil&gt;	surrogateMethods &lt;OrderedCollection of: CompiledMethod &gt;Class Variables:	ActiveManager &lt;RuntimeSurrogateManager | nil&gt;	UnhookingErrorSignal &lt;Signal | nil&gt;</body></comment><class><name>RuntimeManagerStripper</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeManagerStripper</class-id><body>RuntimeManagerStripper is a subclass of RuntimeManager that provides an easy way to delete methods used for stripping that are not used in the runtime image.RuntimeManagerStripper is part of the Runtime Packager tool. As such, this class gets stripped from the deployed application.RuntimeManagerStripper implements the process of actually stripping deleted items from the image.Class Variables:	AllDeletedBehaviors 	&lt;nil | IdentitySet of: Behavior &gt; All the classes that are to be deleted by the stripper	ClassPrerequisites 	&lt;nil | IdentiyDictionary of: Behavior -&gt; OrderedCollection of: Behavior &gt; A map of each class to be deleted to its prequisites (subclasses and prerequisitesForLoading)	DeletedClassesInOrder 	&lt;nil | OrderedCollection of: Behavior&gt;	A topological sort based ClassPrerequisites (see the class side method sortClassForDeletion:in:notifying:)	LiteralKeyBlocks &lt; (Dictionary key: Behavior value: BlockClosure) | nil &gt;</body></comment><class><name>RuntimeDeletedInstance</name><environment>RuntimePackager</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeDeletedInstance</class-id><body>RuntimeDeletedInstance provides a class defining the objects substituted for deleted classes. Instances of these objects use RuntimeDeletedInstance to provide methods, primarily in implementing doesNotUnderstand and selected compilation methods.RuntimeDeletedInstance is a support class for the Runtime Packager, and gets packaged with the deployed application.</body></comment><class><name>RuntimeProgressNotifier</name><environment>RuntimePackager</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>progressCount text textWidget tickCount tickRate ended windowExtent progressString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeProgressNotifier</class-id><body>RuntimeProgressNotifier provides a separate window in which progress messages can be written to show the user that work is being done and is proceeding as expected.RuntimeProgressNotifier is part of the Runtime Packager tool. As such, this class gets stripped from the deployed application.Instance Variables:	tickCount &lt;Integer&gt;	tickRate &lt;Integer&gt;	text &lt;ValueHolder on: Text&gt;	progressCount &lt;Integer&gt;	textWidget &lt;TextEditorView&gt;	ended &lt;Boolean&gt;	windowExtent &lt;Point&gt;	progressString &lt;ValueHolder on: String&gt;</body></comment><class><name>RuntimeBuilderUI</name><environment>RuntimePackager</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stepTitle stepDescription currentStepNumber options keptItems tester paramFilename memoryParams reviewDone itemsDone scanDone testDone memoryDone optionsDone cleanupDone saveParcelsDone interactWithUser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderUI</class-id><body>RuntimeBuilderUI provides the main application window from which all other functions are launched.RuntimeBuilderUI is part of the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.Instance Variables:	stepTitle &lt;ValueHolder on: String&gt;	stepDescription &lt;ValueHolder on: String&gt;	currentStepNumber &lt;SmallInteger&gt;	options &lt;RuntimeBuilderOptions&gt;	keptItems &lt;RuntimeBuilderItems&gt;	tester &lt;RuntimeBuilderTester&gt;	paramFilename &lt;Filename&gt;	memoryParams &lt;RuntimeBuilderMemoryParams&gt;	reviewDone &lt;ValueHolder on: Boolean&gt;	itemsDone &lt;ValueHolder on: Boolean&gt;	scanDone &lt;ValueHolder on: Boolean&gt;	testDone &lt;ValueHolder on: Boolean&gt;	memoryDone &lt;ValueHolder on: Boolean&gt;	optionsDone &lt;ValueHolder on: Boolean&gt;	cleanupDone &lt;ValueHolder on: Boolean&gt;	saveParcelsDone &lt;ValueHolder on: Boolean&gt;Class Variables:	ActiveApplication &lt;RuntimeBuilderUI | nil&gt;	LicenseAccepted &lt;Boolean | nil&gt;</body></comment><class><name>RuntimeBuilderHelp</name><environment>RuntimePackager</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>helpString title </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderHelp</class-id><body>RuntimeBuilderHelp provides a way to display help text.RuntimeBuilderHelp is a support class for the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.A special interface is provided for displaying license text that allow the user to accept or reject the license agreement.Instance Variables:	helpString &lt;Text&gt;	title &lt;Text&gt;</body></comment><class><name>RuntimeBuilderOptionsEditor</name><environment>RuntimePackager</environment><super>RuntimePackager.RuntimeBuilderEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>edittingBuilder tabs errorNotifierClass errorLogPath shutdownOnLastWin startupClass startupMethod removeCompiler imagePath doThreeSaves installEmergencyEvaluator removeOrganization packageExternalInterfaces osMac osUnix osWindows headlessImage useRuntimeCompiledMethod parcelOptions parcelIsLoadable stripParcel parcelList currentParcel parcelPath mergeLiterals mergeByteCodes useAutoLoader imageDumperClass lastWindowCloseAction prestripClass prestripMethod saveParcel parcelSaveOption mergeMethods clearParcelPath parcelUnloadBeforeStrip traceLevel stripGlobals skipScan suppressSplashScreen </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderOptionsEditor</class-id><body>RuntimeBuilderOptionsEditor provides for user a way to set options that control creation of the final stripped image.RuntimeBuilderOptionsEditor is part of the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.Instance Variables:	doThreeSaves &lt;ValueHolder on: Boolean&gt;	edittingBuilder &lt;UIBuilder&gt;	errorNotifierClass &lt;ValueHolder on: String&gt;	errorLogPath &lt;ValueHolder on: String&gt;	imagePath &lt;ValueHolder on: String&gt;	installEmergencyEvaluator &lt;ValueHolder on: Boolean&gt;	packageExternalInterfaces &lt;ValueHolder on: Boolean&gt;	prestripClass &lt;ValueHolder on: String&gt;	prestripMethod &lt;ValueHolder on: String&gt;	removeCompiler &lt;ValueHolder on: Boolean&gt;	removeOrganization &lt;ValueHolder on: Boolean&gt;	shutdownOnLastWin &lt;ValueHolder on: Boolean&gt;	startupClass &lt;ValueHolder on: String&gt;	startupMethod &lt;ValueHolder on: String&gt;	currentParcel &lt;String | nil&gt;	headlessImage &lt;ValueHolder on: Boolean&gt;	imageDumperClass &lt;ValueHolder on: String&gt;	lastWindowCloseAction &lt;ValueHolder on: Symbol&gt;	mergeByteCodes &lt;ValueHolder on: Boolean&gt;	mergeCommonMethods &lt;ValueHolder on: Boolean&gt;	mergeLiterals &lt;ValueHolder on: Boolean&gt;	osMac &lt;ValueHolder on: Boolean&gt;	osUnix &lt;ValueHolder on: Boolean&gt;	osWindows &lt;ValueHolder on: Boolean&gt;	parcelIsLoadable &lt;ValueHolder on: Boolean&gt;	parcelList &lt;ValueHolder on: List&gt;	parcelOptions &lt;Dictionary&gt;	parcelPath &lt;ValueHolder on: String&gt;	parcelPostLoadClass &lt;ValueHolder on: String&gt;	parcelPostLoadMethod &lt;ValueHolder on: String&gt;	prestripClass &lt;ValueHolder on: String&gt;	prestripMethod &lt;ValueHolder on: String&gt;	stripParcel &lt;ValueHolder on: Boolean&gt;	uiLookMac &lt;ValueHolder on: Boolean&gt;	uiLookMotif &lt;ValueHolder on: Boolean&gt;	uiLookWindows &lt;ValueHolder on: Boolean&gt;	useAutoLoader &lt;ValueHolder on: Boolean&gt;	useRuntimeCompiledMethod &lt;ValueHolder on: Boolean&gt;	tabs &lt;SelectionInList&gt;	saveParcel &lt;ValueHolder on: Boolean&gt;	skipScan &lt;ValueHolder on: Boolean&gt;	parcelSaveOption &lt;ValueHolder on: Symbol&gt;	mergeMethods &lt;ValueHolder on: Boolean&gt;	clearParcelPath &lt;ValueHolder on: Boolean&gt;	suppressSplashScreen	&lt;ValueHolder on: Boolean&gt;	If true, set the flag that supresses the herald and sound on start-up.</body></comment><class><name>RuntimeBuilderTester</name><environment>RuntimePackager</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mainApplication testStatus dynamicMethods dynamicClasses options keptItems testInProgress dynamicItemsText textInProgress progressIndicator acceptedDynamicMethods acceptedDynamicClasses exemptClasses tickCounter tickRate progressCounter </inst-vars><class-inst-vars>activeTester </class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>RuntimePackager</package></attributes></class><comment><class-id>RuntimePackager.RuntimeBuilderTester</class-id><body>RuntimeBuilderTester provides the user interface and implementation of the application testing environment.RuntimeBuilderTester is part of the Runtime Packager tool, and has no public API. As such, this class gets stripped from the deployed image.RuntimeBuilderTester provides a way to install surrogates for classes and methods that will be deleted in the final stripped image, and a mechanism for detecting references to these surrogates. Referenced items are fed back as kept items when the window is closed.  ExemptClasses are classes that are used by the tester itself and thus do not participate in the reference detection process.Instance Variables:	mainApplication &lt;RuntimeBuilderUI&gt;	testStatus &lt;ValueHolder on: Text&gt;	dynamicMethods &lt;IdentitySet&gt;	dynamicClasses &lt;IdentitySet&gt;	options &lt;RuntimeBuilderOptions&gt;	keptItems &lt;RuntimeBuilderItems&gt;	testInProgress &lt;Boolean&gt;	dynamicItemsText &lt;ValueHolder on: String&gt;	textInProgress &lt;Boolean&gt;	progressIndicator &lt;ValueHolder on: String&gt;	acceptedDynamicMethods &lt;IdentitySet&gt;	acceptedDynamicClasses &lt;IdentitySet&gt;	exemptClasses &lt;IdentitySet&gt;	savedClassDeletions &lt;OrderedCollection&gt;	savedLoadableMethods &lt;Dictionary key: Behavior value: Set&gt;	savedParcels &lt;Collection&gt;	tickCounter &lt;Integer&gt;	tickRate &lt;Integer&gt;	progressCounter &lt;Integer&gt;Class Variables:	ActiveTester &lt;RuntimeBuilderTester | nil &gt;</body></comment><shared-variable><name>ActiveApplication</name><environment>RuntimePackager.RuntimeBuilderUI</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>LicenseAccepted</name><environment>RuntimePackager.RuntimeBuilderUI</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DeletedBehaviorReferencedSignal</name><environment>RuntimePackager.RuntimeDeletedBehavior</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DummyMethodDictionary</name><environment>RuntimePackager.RuntimeDeletedBehavior</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DebugErrorMsg</name><environment>RuntimePackager.RuntimeDebugNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ButtonTitles</name><environment>RuntimePackager.RuntimeDebugNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DebugInterruptMsg</name><environment>RuntimePackager.RuntimeDebugNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>AllDeletedBehaviors</name><environment>RuntimePackager.RuntimeManagerStripper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ClassPrerequisites</name><environment>RuntimePackager.RuntimeManagerStripper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>LiteralKeyBlocks</name><environment>RuntimePackager.RuntimeManagerStripper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DeletedClassesInOrder</name><environment>RuntimePackager.RuntimeManagerStripper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DumpFailedMsg</name><environment>RuntimePackager.RuntimeEmergencyNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>UserInterruptMsg</name><environment>RuntimePackager.RuntimeEmergencyNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ErrorOccurredMsg</name><environment>RuntimePackager.RuntimeEmergencyNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DialogClass</name><environment>RuntimePackager.RuntimeEmergencyNotifier</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>MemoryParams</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>TraceLevel</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>SanityCheckDeferredBindings</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DeletedClasses</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ImageIdentification</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>LoadableParcels</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>LauncherClassNames</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>RunState</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ImageDumperClass</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>LoadableNameSpaces</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>QuitBlock</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>VWRelease</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>StrippingOptions</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ErrorNotifierClass</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ErrorLogPath</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>LoadableClasses</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ParcelsToUnload</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>PostStripBlock</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>StartupMethod</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DeletedMethods</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>InstVarIndexes</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>NewMemoryPolicy</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>StartupClassName</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>DeletedGlobals</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><shared-variable><name>ImagePath</name><environment>RuntimePackager.RuntimeManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>RuntimePackager</package></attributes></shared-variable><methods><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id> <category>error handling</category><body package="RuntimePackager">doesNotUnderstand: aMessage	"Raise a signal indicating that a messsage was sent to a deleted behavior."	^RuntimeDeletedBehavior deletedBehaviorReferencedSignal		raiseWith: ( MessageSend			receiver: self			selector: aMessage selector			arguments: aMessage arguments )		errorString: 'A deleted Behavior was referenced: ', self originalName.</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id> <category>file in</category><body package="RuntimePackager">evaluate: x logged: y	"Can not do evaluate, so just answer self to pick up further messages"	^self</body><body package="RuntimePackager">scanFrom: x	"Can not really do this function when compiler is not present.  Answer nil"	^ nil</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id> <category>startup-shutdown</category><body package="RuntimePackager">exiting	"Ignore message to an application on image exit"	^self</body><body package="RuntimePackager">restart	"Ignore message to application when image is being restarted"	^self</body><body package="RuntimePackager">saving	"Ignore message to application when image is being saved"	^self</body><body package="RuntimePackager">shutDown	"Ignore message to application when image is being shut down"	^self</body><body package="RuntimePackager">startUp	"Ignore message to application when image is being started"	^self</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id> <category>parsing</category><body package="RuntimePackager">flushCachedParser	"Simulate the method called during finalization of CDeclarationParser"	^self</body><body package="RuntimePackager">preferredParserClass	"If Compiler is deleted, try to redirect to Parser"	^Parser</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id> <category>initialization</category><body package="RuntimePackager">initialize	"Perform a dummy class initialize (may be used on image start)"	^self</body><body package="RuntimePackager">initializeDeletedClass	"Initialize a new instance"	superclass := RuntimeDeletedInstance.	methodDict := self class dummyMethodDictionary.</body><body package="RuntimePackager">initializeDeletedMetaclass	"Initialize an instance for a metaclass"	self initializeDeletedClass.	superclass := Metaclass.</body><body package="RuntimePackager">install	"Perform a dummy class initialize (may be used on image start)"	^self</body><body package="RuntimePackager">installOn: aPlatform	"Perform a dummy class initialize (may be used on image start)"	^self</body><body package="RuntimePackager">localize	"Ignore attempts to localize the class for a locale. This is sent to ENVY/Developer	Applications, for example."	^self</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id> <category>accessing</category><body package="RuntimePackager">instanceBehavior	"Answer the source of instance behavior for this deleted behavior."	^self</body><body package="RuntimePackager">name	"Answer a name string indicative of the object"	^ '(deleted) ', originalName,		( superclass == Metaclass			ifFalse: [ '' ]			ifTrue: [ ' class' ] )</body><body package="RuntimePackager">originalName	"Answer the original class name"	^originalName</body><body package="RuntimePackager">setOriginalName: aString	"Set the original class name so that references can be debugged"	originalName := aString copy.</body><body package="RuntimePackager">shortName	"Answer a name string indicative of the object"	^ self name</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id> <category>testing</category><body package="RuntimePackager">isManaged	"Allow former ENVY/Developer subApplications to be ignored"	^false</body><body package="RuntimePackager">isPublic	"Always consider deleted behaviors as private. This is a partial fix to the problem	of updating all cross references when classes are deleted from ENVY/Developer	applications. This prevents the application from answering deleted classes to	messages such as allLocalClasses. The more general problem rarely happens."	^false</body><body package="RuntimePackager">needsSafeRebinding	"Answer true to force rebinding of any reference to a deleted item"	^true</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior</class-id> <category>printing</category><body package="RuntimePackager">printOn: aStream	"Add the behavior' name to the stream"	aStream nextPutAll: self name.</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior class</class-id> <category>Signal constants</category><body package="RuntimePackager">deletedBehaviorReferencedSignal	"Answer the appropriate signal"	DeletedBehaviorReferencedSignal isNil ifTrue: [		DeletedBehaviorReferencedSignal :=  Object errorSignal newSignal			notifierString: 'A deleted Behavior was referenced';			nameClass: self			message: #deletedBehaviorReferencedSignal. ].	^DeletedBehaviorReferencedSignal</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior class</class-id> <category>accessing</category><body package="RuntimePackager">dummyMethodDictionary	"Answer a sharable empty method dictionary"	DummyMethodDictionary isNil ifTrue: [		DummyMethodDictionary := MethodDictionary new ].	^DummyMethodDictionary</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedBehavior class</class-id> <category>instance creation</category><body package="RuntimePackager">forDeletedInstance: aClass	"answer a new behavior  to be used as a behavior for replacement	instances of the class provided."	^super new initializeDeletedClass		setOriginalName: aClass fullName;		setInstanceFormat: RuntimeDeletedInstance format.</body><body package="RuntimePackager">new	"This is an error if used"	^self shouldNotImplement</body><body package="RuntimePackager">onDeletedClass: aClass	"answer a new behavior patterned on the behavior provided"	^super new initializeDeletedClass		setOriginalName: aClass fullName;		setInstanceFormat: aClass format</body><body package="RuntimePackager">onDeletedMetaclass: aMetaclass	"answer a new behavior patterned on the behavior provided"	^super new initializeDeletedMetaclass		setOriginalName: aMetaclass soleInstance fullName;		setInstanceFormat: aMetaclass format</body></methods><methods><class-id>RuntimePackager.RuntimeManager</class-id> <category>method templates</category><body package="RuntimePackager">readConfigurationFile		"Bypass reading the ENVY/Developer configuration file.		This is probably no longer needed, but it is a clean kill of the		configuration file access."	^self</body><body package="RuntimePackager">unscheduleWindow: aWindow 	"This is a surrogate for WindowManager&gt;&gt;unscheduleWindow:	It is used to shutdown the system when the last window is closed	and to avoid opening the launcher during the final packaging step	1) gain access to RuntimeManager in a manner independent of home name space	2) Get known windows	3) if there are open windows, shut them down	4) if are we are in runtime image -- check for shutdown and if so, shutdown normal	5) are we are in a state where execution continues after the last window closes if so, close the dialog	6) otherwise, no special handling is needed"	| windows managerClass runState |	managerClass := #{RuntimePackager.RuntimeManager} value.	windows := ScheduledWindow scheduledWindows.	(windows size &gt; 1 or: [windows size == 1 and: [(windows includes: aWindow) not]]) ifTrue: 		[^self rtpUnscheduleWindow: aWindow].	runState := managerClass runState.	 runState == #runtime ifTrue: 		[managerClass shutdownOnLastWin == true ifTrue: 			[^managerClass quitImageNormal]].	aWindow isModalDialog ifTrue: [^self rtpUnscheduleWindow: aWindow].	(managerClass continueOnLastWin or: 		[#(#aboutToSave #applicationStarting #autoShutdownInhibited) includes: runState])		ifTrue: [^self].	^self rtpUnscheduleWindow: aWindow</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>utility</category><body package="RuntimePackager">allClassesDo: aBlock	"Evaluate aBlock with each class in the image.	This method is located here to allow release dependent	versions to be done later if needed."	SystemUtils allClassesDo: aBlock.</body><body package="RuntimePackager">allGlobalsFrom: aNameSpace	"Answer binding references for all the the globals (general bindings)	in aNameSpace or those contained it."	| globals envRef |	globals := OrderedCollection new.	envRef := aNameSpace fullyQualifiedReference asQualifiedReference.	aNameSpace bindingsDo: [ :binding |		binding isForGeneral ifTrue: [			globals add: ( envRef append: binding key ) ].		binding isForNameSpace ifTrue: [			globals addAll: ( self allGlobalsFrom: binding value ) ] ].	^globals</body><body package="RuntimePackager">allNameSpacesFrom: aNameSpace	"Answer an ordered collection of the name spaces contained in aNameSpace	and those name spaces in turn."	| nameSpaces |	nameSpaces := OrderedCollection with: aNameSpace.	aNameSpace bindingsDo: [ :binding |		( binding isForNameSpace and: [ binding value isObsolete not ] )			ifTrue: [				nameSpaces addAll: ( self allNameSpacesFrom: binding value ). ] ].	^nameSpaces</body><body package="RuntimePackager">cleanUpDeferredBindings	"Reset extraneous value references in DeferredBindings	and ResolvedDeferredBindings. The values are never used but	cause extraneous entries in Undeclared."	| idx dbClass rdbClass |	" cache things that must not change while this is executing"	idx := RuntimeManager resolvedValueIndex.	dbClass := DeferredBinding.	rdbClass := ResolvedDeferredBinding.	" fix all instances watching for the possibility that an instances's	class may change while this is running "	dbClass allInstancesDo: [ :binding |		( binding instVarAt: idx ) isNil ifFalse: [			[ binding class == dbClass ifTrue: [				binding instVarAt: idx put: nil ] ]			valueUnpreemptively. ] ].	rdbClass allInstancesDo: [ :binding |		( binding instVarAt: idx ) isNil ifFalse: [			[ binding class == rdbClass ifTrue: [				binding instVarAt: idx put: nil ] ]			valueUnpreemptively. ] ].</body><body package="RuntimePackager">expandedFilenameFrom: aString	"If this version of VW supports it, expand the string by substituting	environment variables and make a file name out of the result."	^ ( self expandedStringFrom: aString ) asFilename</body><body package="RuntimePackager">expandedStringFrom: aString	"If this version of VW supports it, expand the string by substituting	environment variables using the Filename methods"	^ Filename expandEnvironmentIn: aString</body><body package="RuntimePackager">hiddenReferenceTo: aString	"Answer a class or global named by aString or nil if none.	This particular way of doing things avoids the compiler.	aString is assumed to name something accessible from the	current environment. "	"RuntimeManager hiddenReferenceTo: 'RuntimeBuilderUI' "	"RuntimeManager hiddenReferenceTo: 'Fraction' "	| names |	names := ( aString tokensBasedOn: $. ) collect: [:x | x asSymbol ].	^ ( BindingReference new path: names;			class: nil home: self environment )			valueOrDo: [ nil ]</body><body package="RuntimePackager">in: anObject performWithoutReference: aString	"Perform the selector named by aString in anObject	without creating a detectable reference to the selector.	aString holds the selector name prefixed with a	single underscore."	^ self in: anObject performWithoutReference: aString		withArguments: ( Array new: 0 )</body><body package="RuntimePackager">in: anObject performWithoutReference: aString withArguments: anArray	"Perform the selector named by aString in anObject	without creating a detectable reference to the selector.	aString holds the selector name prefixed with a	single underscore."	| selector |	selector := ( aString first = $_		ifTrue: [ aString copyFrom: 2 to: aString size ]		ifFalse: [ aString ] ) asSymbol.	^ anObject perform: selector withArguments: anArray</body><body package="RuntimePackager">logicalFileSpecFrom: aString	"Answer a LogicalFileSpecification based on the string supplied.	If the conversion fails, answer nil."	^ [ aString asLogicalFileSpecification ]		on: Error		do: [ :ex | ex return: nil ]</body><body package="RuntimePackager">processEventsToDetectWindows	"On application startup allow enough events to be processed to fill ScheduledWindow scheduledWindows collection."	WindowManager allInstancesDo: 			[:wm | 			wm hasWindows 				ifTrue: 					[					[ScheduledWindow scheduledWindows isEmpty ifFalse: [^self].					wm processNextAvailableEvent] 							whileTrue]]</body><body package="RuntimePackager">purgeUndeclaredEntries	"Purge entries in Undeclared which are unreferenced and currently bound to nil.	Answer with a collection of the keys removed."	| allKeys |	allKeys := Undeclared keys.	Undeclared purgeUnusedBindings.	"Answer what was deleted"	^allKeys reject: [ :x | Undeclared includesKey: x ]</body><body package="RuntimePackager">valueWithoutShutdownOf: aBlock	"Evaluate a block during which the image will not shutdown when	no windows are open.  This is useful if a dialog or windows needs to be	closed before the next window is open.  Answer the value of the block."	| ans saveState |	saveState := RunState.	RunState := #autoShutdownInhibited.	ans := aBlock ensure: [RunState := saveState].	^ans</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>encapsulation breaking</category><body package="RuntimePackager">bytesIndex	"Answer the instVarAt: value for bytes in CompiledCode"	^self instVarIndexes at: #bytes</body><body package="RuntimePackager">initializeInstVarIndexes	"Initialize a dictionary of instance variable indexes for instance variables	that must be accessed outside of normal protocols"	InstVarIndexes := IdentityDictionary new.	InstVarIndexes		add: #quiescentProcessLists -&gt; (			ProcessorScheduler allInstVarNames indexOf: 'quiescentProcessLists' );		add: #methodDict -&gt; (			Behavior allInstVarNames indexOf: 'methodDict' );		add: #organization -&gt; (			ClassDescription allInstVarNames indexOf: 'organization' );		add: #bytes -&gt; (			CompiledMethod allInstVarNames indexOf: 'bytes' );		add: #resolvedValue -&gt; (			DeferredBinding allInstVarNames indexOf: 'resolvedValue' ).</body><body package="RuntimePackager">methodDictIndex	"Answer the instVarAt: value for methodDict in Behavior"	^self instVarIndexes at: #methodDict</body><body package="RuntimePackager">organizationIndex	"Answer the instVarAt: value for organization in ClassDescription"	^self instVarIndexes at: #organization</body><body package="RuntimePackager">quiescentProcessListsIndex	"Answer the instVarAt: value for quiescentProcessLists in ProcessorScheduler"	^self instVarIndexes at: #quiescentProcessLists</body><body package="RuntimePackager">resolvedValueIndex	"Answer the instVarAt: value for resolvedValue in DeferredBinding"	^self instVarIndexes at: #resolvedValue</body><body package="RuntimePackager">selectorsInClass: aClass	"Answer a collection of the selectors in a class using primitive access	techniques to avoid hidden code schemes.	MethodDictionary is different in VW 4.0. Just use the standard methods until	the need arises for something different."	^aClass selectors</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>accessing</category><body package="RuntimePackager">continueOnLastWin	"Answer true if the image is to continue when the last window closes.	Note that this is not the opposite of shutdown -- the other option is to	use whatever standard behavior the base image provides"	^( StrippingOptions includes: #continueOnLastWin )</body><body package="RuntimePackager">deletedClasses	^DeletedClasses</body><body package="RuntimePackager">deletedClasses: anIdentitySet	DeletedClasses := anIdentitySet</body><body package="RuntimePackager">deletedGlobals	^DeletedGlobals</body><body package="RuntimePackager">deletedGlobals: anIdentitySet	DeletedGlobals := anIdentitySet</body><body package="RuntimePackager">deletedMethods	^DeletedMethods</body><body package="RuntimePackager">deletedMethods: anIdentitySet	DeletedMethods := anIdentitySet</body><body package="RuntimePackager">emergencyHandlerBlock	"Answer the block used to handle unhandled exceptions"	RuntimeManager rtpObsoleteCode.	"Should not need this now, but see if Notifier swap can be avoided.	Maybe this is the right way to hook an exception handler again"	^ [ :ex :ctx | ErrorNotifierClass notify: ex context: ctx ]</body><body package="RuntimePackager">errorLogPath	^ErrorLogPath</body><body package="RuntimePackager">errorLogPath: aStringOrNil	"Set the error log path to either a portable file specification or nil.	The portable form is used so that this image can be run on different	platforms than the one the image was created on.	Conversion errors should be prevented by earlier validations, but if they	occur, ErrorLogPath is set to nil.	For VW 2.5, a string is used instead of the portable file form"	aStringOrNil size = 0		ifTrue: [ ErrorLogPath := nil. ]		ifFalse: [ ErrorLogPath := self logicalFileSpecFrom: aStringOrNil. ]</body><body package="RuntimePackager">errorNotifierClass	"Answer the class to use for emergency error notification."	^ErrorNotifierClass</body><body package="RuntimePackager">errorNotifierClass: aClassOrNil	ErrorNotifierClass := aClassOrNil</body><body package="RuntimePackager">imageDumperClass	"Answer the class to use for dumping the image in emergency error notification."	^ImageDumperClass</body><body package="RuntimePackager">imageDumperClass: aClassOrNil	"Set the class to use for dumping the image in emergency error notification."	ImageDumperClass := aClassOrNil</body><body package="RuntimePackager">imageIdentification	ImageIdentification isNil		ifTrue: [ ^ 'An anonymous image' ].	^ImageIdentification</body><body package="RuntimePackager">imageIdentification: aString	ImageIdentification := aString</body><body package="RuntimePackager">imagePath	^ImagePath</body><body package="RuntimePackager">imagePath: aString	ImagePath := aString.</body><body package="RuntimePackager">instVarIndexes	"Answer a dictionary of instance variable indexes for instance variables	that must be accessed outside of normal protocols"	^InstVarIndexes</body><body package="RuntimePackager">launcherClassNames	"Return a list of launcher class names, so we know which things to close as part of the final stripping process."	LauncherClassNames isNil ifTrue: [LauncherClassNames := Array with: #VisualLauncher with: #WPENFIN].	^LauncherClassNames.</body><body package="RuntimePackager">launcherClassNames: anArray	"Set the list of launcher class names, used to know which things to close as part of the final stripping process."	LauncherClassNames := anArray.</body><body package="RuntimePackager">loadableClasses	^LoadableClasses</body><body package="RuntimePackager">loadableClasses: aSet	LoadableClasses := aSet.</body><body package="RuntimePackager">loadableNameSpaces	^LoadableNameSpaces</body><body package="RuntimePackager">loadableNameSpaces: aCollection	LoadableNameSpaces := IdentitySet withAll: aCollection.</body><body package="RuntimePackager">loadableParcels	^LoadableParcels</body><body package="RuntimePackager">loadableParcels: aCollection	LoadableParcels := aCollection.</body><body package="RuntimePackager">managerVersion	"Answer a number indentifying this version of RuntimeManager"	^7.31</body><body package="RuntimePackager">memoryParams	^MemoryParams</body><body package="RuntimePackager">memoryParams: params	MemoryParams := params.</body><body package="RuntimePackager">parcelsToUnload	^ParcelsToUnload</body><body package="RuntimePackager">parcelsToUnload: aSet	ParcelsToUnload := aSet.</body><body package="RuntimePackager">postStripBlock	"Answer a block to be evaluated after the stripping process is complete	but before the final image save.  If nothing is to be done, answer nil"	^PostStripBlock</body><body package="RuntimePackager">postStripBlock: aBlockOrNil	"Set a block to be evaluated after the stripping process is complete	but before the final image save."	" validate this nowto prevent problems in the strip when debugging is hard"	aBlockOrNil notNil ifTrue: [		( aBlockOrNil class == BlockClosure and: [		aBlockOrNil numArgs = 0 ] ) ifFalse: [			^self error: 'PostStripBlock must be a zero-argument block or nil' ] ].	PostStripBlock := aBlockOrNil.</body><body package="RuntimePackager">quitBlock	"Answer a block (or nil) to be executed before quiting the image"	^QuitBlock</body><body package="RuntimePackager">quitBlock: aBlockOrNil	"Set the block (or nil) to be executed before quiting the image.	If a block is provided, it should accept either one or zero arguments --	see RuntimeManager quitImage for arguments"	QuitBlock := aBlockOrNil</body><body package="RuntimePackager">runState	"Answer the run state of the image"	RunState isNil ifTrue: [ RunState := #development ].	^RunState</body><body package="RuntimePackager">runState: aSymbol	"Set the run state of the image"	RunState := aSymbol.</body><body package="RuntimePackager">shutdownOnLastWin	"Answer true if the image is to shutdown when the last window closes"	^( StrippingOptions includes: #shutdownOnLastWin )</body><body package="RuntimePackager">startupClass	"Answer the startup class by looking up the name or nil if none"	^StartupClassName isNil		ifTrue: [ nil ]		ifFalse: [ StartupClassName asQualifiedReference value ]</body><body package="RuntimePackager">startupClass: aClassOrNil	"Set the name of the startup class.  Names are used in case the	startup class is loaded via parcels."	aClassOrNil isNil		ifTrue: [ StartupClassName := nil ]		ifFalse: [ StartupClassName := aClassOrNil fullName ].</body><body package="RuntimePackager">startupMethod	^StartupMethod</body><body package="RuntimePackager">startupMethod: aSymbol	StartupMethod := aSymbol</body><body package="RuntimePackager">strippingOptions	"Answer the set of stripping options"	^StrippingOptions</body><body package="RuntimePackager">strippingOptions: aSet	"Set the set of stripping options"	StrippingOptions := aSet.</body><body package="RuntimePackager">traceLevel	"Answer a number as the trace level for stripping.	Values are:	0 - no debug tracing during stripping.	2 - trace class removals and namespace removals	4 - also trace method removals.	When these values are referenced, they are hardcoded to avoid the potential	for problems during stripping."	" Usually this is left as nil -- do a lazy init response"	^TraceLevel isInteger		ifFalse: [ TraceLevel := 0 ]		ifTrue: [ TraceLevel ]</body><body package="RuntimePackager">traceLevel: anInteger	"Set a number as the trace level for stripping.	See traceLevel method for values."	TraceLevel := anInteger</body><body package="RuntimePackager">vwRelease	"Answer the VisualWorks release of this image"	^VWRelease</body><body package="RuntimePackager">vwVersion	"Returns the VisualWorks version number of this image as a VersionForPackaging. Used in comparison with the version recorded with the loaded params.rtp. Although the old comment said 'Intended to distinguish between major releases (e.g. 7.4), minor releases (e.g. 7.4.1), and internal build releases (e.g. Pre-Release 7.4 (nov05.4))', the floating point representation did not distinguish between released versions and internal build releases. Floating point representation replaced to allow RTP to handle releases like 7.10"	^VersionForPackaging fromSystem</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>stripping</category><body package="RuntimePackager">copyMethodNamed: fromSelector as: toSelector in: toClass	"Copy a method from RuntimeManager to another class adjusting the mclass along the way.	The method must be valid in the target class (toClass)."	self copyMethodNamed: fromSelector from: RuntimeManager		as: toSelector in: toClass</body><body package="RuntimePackager">copyMethodNamed: fromSelector from: fromClass as: toSelector in: toClass	"Copy a method from one class to another adjusting the mclass along the way.	The method must be valid in the target class (toClass)."	| fromMethod copiedMethod |	fromMethod := fromClass compiledMethodAt: fromSelector.	" two copies are used to allow mclass to be changed and propogated to blocks "	copiedMethod := ( fromMethod shallowCopy mclass: toClass ) copy.	copiedMethod sourcePointer: nil.	toClass addSelector: toSelector withMethod: copiedMethod.</body><body package="RuntimePackager">copyMethodNamed: fromSelector toClass: toClass	"Copy a method from RuntimeManager to another class adjusting the mclass along the way.	The method must be valid in the target class (toClass)."	self copyMethodNamed: fromSelector from: RuntimeManager			as: fromSelector in: toClass</body><body package="RuntimePackager">createAndSaveFinalImage	"Create the final image and save it.  This is done in RuntimeManager	to ensure that methods and classes needed are not deleted from	the image during this process.  This method should always be kept	even though it is not used at runtime. "	" create an image identification if none present "	ImageIdentification isNil ifTrue: [		ImageIdentification := 'Image created ', Date today printString, '  ',			Time now printString. ].	" create the final image.  Stop if this fails (when possible ) "	RuntimeManagerStripper createFinalImage ifFalse: [		self unhookNotifierClass.		RunState := #development.		self unhookFromWindowManager.		^self ].	" discard the stripper class since its methods are no longer needed"	RuntimeManagerStripper quietlyRemoveFromSystem.	"Turn off the change set notification mechanism."	'ChangeSet.BroadcastChanges' asQualifiedReference 		ifDefinedDo: [:flag | 'ChangeSet.BroadcastChanges' asQualifiedReference value: false].	" evaluate the postStripBlock, if any"	PostStripBlock notNil ifTrue: [		PostStripBlock value ].	" do the final save "	( StrippingOptions includes: #doThreeSaves )		ifTrue: [ self doThreeStepFinalImageSave ]		ifFalse: [ self doOneStepFinalImageSave ].</body><body package="RuntimePackager">doOneStepFinalImageSave	"Save the final image in one step as a perm save"	|  saveMemoryPolicy |	" tell user what is about to happen "	self notifyUserNoninteractively: (			'\  Runtime image is about to be saved.  ',			'\  This window will close and then  ',			'\  reappear after the save completes.  \' ) withCRs	       label: 'About to save' delay: 5.	" compact memory, install memory policy, and do a perm save "	ObjectMemory globalGarbageCollect.	saveMemoryPolicy := ObjectMemory currentMemoryPolicy.	ObjectMemory removeDependent: RuntimeManager.	( StrippingOptions includes: #headlessImage ) ifTrue: [		self prepareForSavingHeadlessImage. ].	ObjectMemory addDependent: RuntimeManager.	ObjectMemory installMemoryPolicy: NewMemoryPolicy.	DeploymentOptionsSystem current startInRuntime: true.	ObjectMemory abortOrFinishIncrementalGC.	( ObjectMemory snapshotAs: ImagePath thenQuit: false withLoadPolicy: self loadPolicyForFinalSave )		ifTrue: [ "still executing the saved image"			" Restore old memory policy just in case "			ObjectMemory installMemoryPolicy: saveMemoryPolicy.			" Put things back so the message window can open "			( StrippingOptions includes: #headlessImage ) ifTrue: [				self resetFromSavingHeadlessImage. ].			" Terminate the current image  "			self notifyUserNoninteractively: ( '\  Runtime image "' withCRs,				ImagePath,				'"  saved. \  The current image will now be terminated. \' withCRs )					label: 'About to quit'					delay: 5.			RuntimeManager quitImageNormal. ].</body><body package="RuntimePackager">doThreeStepFinalImageSave	"Save the final image in three steps as described in Objectworks	documentation.  This is needed for shared perm space though it is	unlikely that this will make a practical difference.	AutoLoader and HeadlessImage are engaged just before the last save"	| saveMemoryPolicy |	" tell user what is about to happen "	self notifyUserNoninteractively: (		' \  The first of three saves is about to occur.  \',		'  After this save, the runtime image must be  \',		'  launched two more times to complete  \',		'  the process. \' ) withCRs	 	label: 'About to do first save' delay: 5.	" compact memory, install memory policy, and do a perm save "	ObjectMemory globalGarbageCollect.	saveMemoryPolicy := ObjectMemory currentMemoryPolicy.	ObjectMemory installMemoryPolicy: NewMemoryPolicy.	ObjectMemory abortOrFinishIncrementalGC.	ObjectMemory removeDependent: RuntimeManager.	ImageConfigurationSystem current canActivate: false.	( ObjectMemory snapshotAs: ImagePath thenQuit: false withLoadPolicy: self loadPolicyForFinalSave )		ifTrue: [			" Restore the memory policy just in case"			ObjectMemory installMemoryPolicy: saveMemoryPolicy.			" Terminate the current image after the first save "			self notifyUserNoninteractively:				'\   The first save of image "' withCRs, ImagePath, (				'"  \   is now complete.  The runtime image must be launched  ',				'\   two more times to complete the process.  \'  ) withCRs				label: 'About to quit (1 of 3)' delay: 5.			RuntimeManager quitImageNormal. ].	"restarted after the first snapshot"	ObjectMemory globalGarbageCollect.	( ObjectMemory snapshotAs: ImagePath thenQuit: false )		ifTrue: [ "continuing image execution"			self notifyUserNoninteractively:				'\   The second save of image "' withCRs, ImagePath, (				'"  \   is now complete.  The runtime image must be launched',				'  \   one more time to complete the process.  \'  ) withCRs				label: 'About to quit (2 of 3)' delay: 5.			RuntimeManager quitImageNormal ].	"restarted after second snapshot "	( StrippingOptions includes: #headlessImage ) ifTrue: [		self prepareForSavingHeadlessImage. ].	ObjectMemory addDependent: RuntimeManager.	ImageConfigurationSystem current canActivate: true.	DeploymentOptionsSystem current startInRuntime: true.	( ObjectMemory snapshotAs: ImagePath thenQuit: false )		ifTrue: [ "continuing image execution"			( StrippingOptions includes: #headlessImage ) ifTrue: [				self resetFromSavingHeadlessImage. ].			self notifyUserNoninteractively:				'\   The third save of image "' withCRs, ImagePath, (				'"  \   is now complete.  The runtime image is now',				'  \   ready to use.  \' ) withCRs				label: 'About to quit (3 of 3)' delay: 5.			RuntimeManager quitImageNormal ].	" restarted after third snapshot "	^self</body><body package="RuntimePackager">loadPolicyForFinalSave	"Normally, the final save should be a perm save.  7.7 and earlier 64bit VMs cannot do a perm save,	so we need to do a regular save for them."	^ObjectMemory is64Bit		ifTrue: [0]		ifFalse: [1].</body><body package="RuntimePackager">notifyUserNoninteractively: aString label: label delay: delaySeconds	"Place a message in a window labeled with the label provided.	After a delay, close the window and proceed"	| msg rect win |	#{WindowingSystem} 		ifDefinedDo: [:ws | ws isActive ifFalse: [^self]]		elseDo: [^self].			" Open a window "	msg := aString asComposedText.	rect := Screen default bounds center - ( ( msg  width @ msg height ) / 2 ) rounded			extent: (msg width @ msg height ).	win := ScheduledWindow openNewIn: rect.	win label: label.	[msg displayOn: win graphicsContext at: 0@0] uiEventFor: win.	" Allow UI window closes to complete and give user a chance to read message "	(Delay forSeconds: delaySeconds) wait.	win close.	win windowManager terminate.	WindowManager restoreAll.</body><body package="RuntimePackager">prepareForSavingHeadlessImage	"Set up for saving a headless image by positioning HeadlessImage	in the ObjectMemory dependents and setting the appropriate flag."	| headlessClass |	" locate the class "	headlessClass := self hiddenReferenceTo: 'HeadlessImage'.	headlessClass isNil ifTrue: [ ^self ].	" set the magic flag "	headlessClass default shouldSaveHeadless: true.	" reset the startup file unless the compiler was kept "	( ( StrippingOptions includes: #removeCompiler ) not and: [		( self hiddenReferenceTo: 'SmalltalkCompiler' ) notNil ] ) ifFalse: [		headlessClass default startupFilename: nil. ].</body><body package="RuntimePackager">resetFromSavingHeadlessImage	"Restore environment after saving a headless image."</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>dynamic references</category><body package="RuntimePackager">dynamicallyReferencedClasses	"Answer classes that can be dynamically referenced in the runtime image.	This is both an example and a practical necessity.  The following classes can	be skipped in the scan of refrenced items in some cases."	| classNames |	" Some hardcoded classes to start"	classNames := #(		#Class		#Metaclass		#LicenseProtect		#SystemError		#RuntimeStartupController		#PortableFilename		#CompiledInitializer		) asOrderedCollection.	classNames add: #Notifier.	" Make sure the methods are not deleted"	CompiledMethod withAllSubclasses do: [ :cl |		( #( #RuntimeMethodSurrogate #RuntimeCompiledMethod )			includes: cl name ) ifFalse: [			classNames add: cl name ] ].	" Save all CTypes to be safe"	CType withAllSubclasses do: [ :cl |		classNames add: cl name ].	^classNames</body><body package="RuntimePackager">dynamicallyReferencedGlobals	"Answer globals that can be dynamically referenced in the runtime image.	This is an example and a possibly a necessity "	^ #(	#{Root.Root}	#{Smalltalk.Root}	#{Smalltalk.Smalltalk}	#{Kernel.Processor}	#{Core.Transcript } )</body><body package="RuntimePackager">dynamicallyReferencedSelectors	"Answer selectors that can be dynamically referenced in the runtime image.	This is both an example and a practical necessity.  The following selectors are used	to create the runtime image and thus must be preserved."	^ #(	" the following are probably referenced elsewhere but included for safety"	#update:with:from:			" pick up ObjectMemory dependents among others "	#createAndSaveFinalImage	" used by runtime manager for final image save "	#returnFromSnapshot		" restart after image save "	#launchBaseProcess		" references items used in starting WindowManagers"	" a special null selector used in one of the older eval versions of VW"	#''							" used in VW Eval version"	" selectors known to the VM.		see DefineOpCodePool class&gt;&gt;initializeSpecialSelectors for		the technique used to locate the sysOopRegistry"	#doesNotUnderstand:	#cannotReturn:	#mustBeBoolean	#cannotResume	#at:	#at:put:	#size	#nonlocalReturn:through:	#invoke:arguments:	#invokeFromThread:arguments:process:	#invoke	#unlinkedCall:arguments:	#badBytecodeAt:	#literalsDo:	)</body><body package="RuntimePackager">itemsReferencedByClassSelector: aSelector	"Answer a collection of the references in the class method named by	aSelector or else answer nil to take normal defaults"	aSelector == #removeFromSystem ifTrue: [ ^Array new ].	aSelector == #restoreNotifierDeploymentMethods ifTrue: [ ^Array new ].	aSelector == #replaceNotifierDeploymentMethods ifTrue: [ ^Array new ].	^nil</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>class initialization</category><body package="RuntimePackager">initialize	"Initialize the class"	RunState := #development.	InstVarIndexes := nil.	LoadableParcels := nil.	DeletedClasses := nil.	DeletedMethods := nil.	StartupClassName := nil.	StartupMethod := nil.	ImagePath:= nil.	VWRelease := nil.	StrippingOptions := IdentitySet new.</body><body package="RuntimePackager">initializeVWRelease	"Initialize the VisualWorks release value based upon what is found	in SystemDictionary&gt;&gt;version.	Look for the first number and take that as the release level.	This should work in most languages including Japanese. "	| verStr |	VWRelease := 9999.  "unknown"	verStr := Smalltalk version readStream.	[ verStr atEnd not and: [ ( verStr peek) isDigit not ]  ]		whileTrue: [ verStr next ].	verStr atEnd ifFalse: [		VWRelease := Number readFrom: verStr ].</body><body package="RuntimePackager">loaded	"Perform all class initializations needed when the package is loaded.	The references generated by this method are overridden and packagerLoaded	is effectively hidden from the references scan."	self packagerLoaded.</body><body package="RuntimePackager">packagerLoaded	"Perform all class initializations needed when the package is loaded"	RuntimeManager initialize;		initializeVWRelease;		initializeInstVarIndexes.	RuntimeBuilderUI initialize.	RuntimeErrorNotifier initialize.	RuntimeEmergencyNotifier initialize.	RuntimeSurrogateManager initialize.	Transcript cr; show: 'Runtime Packager loaded.  '; cr;		show: 'Do "RuntimePackager.RuntimeBuilderUI open" for initial window'; cr;		show: 'or use Tools menu on launcher window'; cr.</body><body package="RuntimePackager">packagerRemoving	"Close any open windows as part of removing the application"	RuntimeBuilderUI activeApplication notNil		ifTrue: [			RuntimeBuilderUI activeApplication closeRequest.			ScheduledControllers checkForEvents. ].	ObjectMemory removeDependent: self.	RuntimeSurrogateManager removing.</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>parcel actions</category><body package="RuntimePackager">postLoadActionFor: aParcel	"Open the application when it is loaded from a Parcel"	self loaded.</body><body package="RuntimePackager">preUnloadActionFor: aParcel	"Prepare to unload the application"	self packagerRemoving.</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>runtime</category><body package="RuntimePackager">quitImage: aParam	"Quit the image doing any special cleanups before exiting.	If the block in QuitBlock does not take arguments, then	no argument is provided to it.	aParam is passed to the quit block as an argument.	Upon normal quit, aParam = #normal.	Upon unhandled exception or user interrupt, aParam = #exception	Other values can be used if understood by the quitBlock.	QuitBlock may want to test RuntimeManager&gt;&gt;isRuntime	if special handling is needed of the final quits prior to	exiting the image after the save of the stripped image."	QuitBlock notNil ifTrue: [		QuitBlock numArgs = 0			ifTrue: [ QuitBlock value ]			ifFalse: [ QuitBlock value: aParam ] ].	ObjectMemory quit.</body><body package="RuntimePackager">quitImageException	"Quit the image due to an unhandled exception"	self quitImage: #exception.</body><body package="RuntimePackager">quitImageNormal	"Quit the image under normal circumstances"	self quitImage: #normal.</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>control</category><body package="RuntimePackager">hookNotifierClass: aClass	"Hook up the class as an emergency notifier, for both GUI and headless operation.	This is VW release dependent"	| headless |	Notifier current: aClass.	headless := (self hiddenReferenceTo: 'BasicHeadlessSystem').	headless isNil ifFalse: [headless current headlessNotifier: aClass].</body><body package="RuntimePackager">hookToWindowManager	"Install intercept for WindowManager&gt;&gt;unscheduleWindow:"	| mdict surrogate method |	mdict := WindowManager instVarAt: self methodDictIndex.	surrogate := (self compiledMethodAt: #unscheduleWindow:) copy.	surrogate mclass: WindowManager.	surrogate sourcePointer: nil.	(mdict includesKey: #rtpUnscheduleWindow:) ifFalse: 			[method := mdict at: #unscheduleWindow:.			mdict at: #rtpUnscheduleWindow: put: method].	mdict 		at: #unscheduleWindow:		put: surrogate copy.	WindowManager flushVMmethodCache</body><body package="RuntimePackager">installHooks	"Install any necessary hooks for runtime environment"	self hookToWindowManager.</body><body package="RuntimePackager">removeFromLauncherMenu	"Remove from the Tools menu for the current VisualLauncher(s).	This logic is used for VW 3.0 and above"	VisualLauncher simplyRemoveSelector: #toolsRuntimePackager.</body><body package="RuntimePackager">startupApplication	"Start the application and check to see if we should continue"	" look for special startup procedures "	( self canUnderstand: #startupApplication ) ifTrue: [		self new startupApplication. ].	RunState := #applicationStarting.	" set a variable that is otherwise not initialized as a sanity check.	if the deferred binding process is working, the binding should be resolved now."	SanityCheckDeferredBindings := true.	" actually start the application "	self startupClass notNil ifTrue: [		self startupClass perform: StartupMethod ].	RunState := #runtime.	" if no windows are open then shutdown the image "	self shutdownOnLastWin ifTrue: [		self processEventsToDetectWindows.		ScheduledWindow scheduledWindows isEmpty ifTrue: [			RuntimeManager quitImageNormal] ].</body><body package="RuntimePackager">unhookFromWindowManager	"Remove intercept for WindowManager&gt;&gt;unscheduleWindow:"	| mdict method |	mdict := WindowManager instVarAt: self methodDictIndex.	(mdict includesKey: #rtpUnscheduleWindow:) ifTrue: 		[method := mdict at: #rtpUnscheduleWindow:.		mdict at: #unscheduleWindow: put: method.			mdict removeKey: #rtpUnscheduleWindow:.			WindowManager flushVMmethodCache]</body><body package="RuntimePackager">unhookNotifierClass	"Restore the emergency error notifier."	Notifier beDevelopment</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>markers</category><body package="RuntimePackager">rtpIsBroken	"This message is sent to leave a cross reference to broken code.	Eventually there should not be references"	self notify: 'Executed a broken method in Runtime Packager'.	^true</body><body package="RuntimePackager">rtpNeedsWork	"References to this method note places of dubious code"	^true</body><body package="RuntimePackager">rtpObsoleteCode	"References to this method note places of obsolete code"	^true</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>window unscheduling</category><body package="RuntimePackager">ensureUnscheduleWindow: aWindow 	| windowManager |	windowManager := aWindow windowManager.	(windowManager respondsTo: #rtpUnscheduleWindow:) 		ifTrue: 			[| noWindowBlock |						[noWindowBlock := WindowManager.NoWindowBlock.			WindowManager.NoWindowBlock := [:null | ].			windowManager rtpUnscheduleWindow: aWindow] 					ensure: [WindowManager.NoWindowBlock := noWindowBlock]]</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>testing</category><body package="RuntimePackager">isHeadless	"Answer true if this is a headless image, without introducing	a dependency on having WindowingSystem loaded."	| windowingSystem |	windowingSystem := self hiddenReferenceTo: 'WindowingSystem'.	^windowingSystem notNil and: [windowingSystem isHeadless].</body><body package="RuntimePackager">isRuntime	"Answer true if the image is in runtime mode."	^RuntimeSystem isRuntime.</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>copyright</category><body package="RuntimePackager">copyright	^SystemUtils copyright copyUpTo: Character cr.</body></methods><methods><class-id>RuntimePackager.RuntimeManager class</class-id> <category>initialize-release</category><body package="RuntimePackager">obsolete	"We cannot use self == RuntimeManager because at this point the system can no longer resolve the binding RuntimeManager.  By contrast, the class is not yet called AnObsolete... so a name check is recognised."	self name = #RuntimeManager ifTrue:		[self removeFromLauncherMenu.		ObjectMemory removeDependent: self].	super obsolete.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditableObject</class-id> <category>actions</category><body package="RuntimePackager">cancel	"Terminate any edit in progress"	editor notNil ifTrue: [		editor cancel ].	viewer notNil ifTrue: [		viewer cancel ].</body><body package="RuntimePackager">edit	"Open a window for editting"	self editor open.</body><body package="RuntimePackager">refresh	"Have open views refresh themselves"	editor notNil ifTrue: [ editor refresh ].	viewer notNil ifTrue: [ viewer refresh ].</body><body package="RuntimePackager">refreshViewer	"Have open viewers refresh themselves"	viewer notNil ifTrue: [ viewer refresh ].</body><body package="RuntimePackager">setDefaultValues	"Set default values for the receiver's aspects.	Typically this is overridden in subclasses"</body><body package="RuntimePackager">setDefaults	"Set aspects to their default values"	self canBeReset ifFalse: [		( Dialog confirm: 'Reset to default values discarding any previous changes?' )			ifFalse: [ ^self ] ].	self setDefaultValues.	hasBeenEdited := false.	editor notNil ifTrue: [		editor copyValuesFromSubject;			resetChanges ].</body><body package="RuntimePackager">terminateEdit	"Cancel the current editor"	editor := nil.</body><body package="RuntimePackager">terminateView	"Cancel the current viewer"	viewer := nil.</body><body package="RuntimePackager">view	"Open a view on the receiver"	viewer isNil ifTrue: [		viewer :=  self viewerClass on: self ].	viewer open.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditableObject</class-id> <category>name spaces</category><body package="RuntimePackager">classNamed: aString	"Convert the full name provided in aString into a class.	Answer nil if not found"	^ self classNamed: aString ifAbsent: [ nil ]</body><body package="RuntimePackager">classNamed: aString ifAbsent: aBlock	"Convert the full name provided in aString into a class.	Answer the value of aBlock if not found"	^aString asString asQualifiedReference valueOrDo: aBlock</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditableObject</class-id> <category>accessing</category><body package="RuntimePackager">editor	"Answer the application model controlling the editor	window for changing options"	editor isNil ifTrue: [		editor := self editorClass on: self ].	^editor.</body><body package="RuntimePackager">editorClass	"Answer the class used to edit the receiver"	^self subclassResponsibility</body><body package="RuntimePackager">hasBeenEdited	"Answer true if an editor has been open on the receiver"	^hasBeenEdited</body><body package="RuntimePackager">hasBeenEdited: aBoolean	"Set true if an editor has been open on the receiver"	hasBeenEdited := aBoolean.</body><body package="RuntimePackager">viewer	"Answer the object being used to view the receiver. "	^viewer</body><body package="RuntimePackager">viewerClass	"Answer the class used to view the receiver.  This may	be overidden in subclasses if a class other than the editor is used"	^self editorClass</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditableObject</class-id> <category>testing</category><body package="RuntimePackager">canBeReset	"Answer true if values can be reset now"	^self hasBeenEdited not and: [ editor isNil ]</body><body package="RuntimePackager">isBeingChanged	"Answer true if there is an editor pending with changes"	^ editor notNil and: [ editor isChanged ]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditableObject</class-id> <category>updating</category><body package="RuntimePackager">update: aspect with: aParam from: anObject	"Note that a change was made to the values in the object"	anObject == editor ifTrue: [		hasBeenEdited := true. ].	^super update: aspect with: aParam from: anObject</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditableObject</class-id> <category>initialize-release</category><body package="RuntimePackager">initialize	"Initialize a new instance"	hasBeenEdited := false.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditableObject</class-id> <category>copying</category><body package="RuntimePackager">copyFrom: aRuntimeBuilderEditor	editor := nil.	hasBeenEdited := false.</body><body package="RuntimePackager">postCopy	"Reset copy to relect its initial state"	super postCopy.	editor := nil.	hasBeenEdited := false.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditableObject class</class-id> <category>instance creation</category><body package="RuntimePackager">new	"Answer an initialized instance of the receiver"	^super new initialize</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMemoryParams</class-id> <category>accessing</category><body package="RuntimePackager">codeSize	^codeSize</body><body package="RuntimePackager">codeSize: anInteger	codeSize := anInteger</body><body package="RuntimePackager">edenSize	^edenSize</body><body package="RuntimePackager">edenSize: anInteger	edenSize := anInteger</body><body package="RuntimePackager">editorClass	"Answer the class that can edit this object"	^RuntimeBuilderMemoryParamEditor</body><body package="RuntimePackager">fixedSize	^fixedSize</body><body package="RuntimePackager">fixedSize: anObject	fixedSize := anObject</body><body package="RuntimePackager">largeSize	^largeSize</body><body package="RuntimePackager">largeSize: anInteger	largeSize := anInteger</body><body package="RuntimePackager">memoryPolicyClass	^memoryPolicyClass</body><body package="RuntimePackager">memoryPolicyClass: anObject	memoryPolicyClass := anObject</body><body package="RuntimePackager">memoryUpperBound	^memoryUpperBound</body><body package="RuntimePackager">memoryUpperBound: anInteger	memoryUpperBound := anInteger</body><body package="RuntimePackager">oldSize	^oldSize</body><body package="RuntimePackager">oldSize: anInteger	oldSize := anInteger</body><body package="RuntimePackager">stackSize	^stackSize</body><body package="RuntimePackager">stackSize: anInteger	stackSize := anInteger</body><body package="RuntimePackager">survivorSize	^survivorSize</body><body package="RuntimePackager">survivorSize: anInteger	survivorSize := anInteger</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMemoryParams</class-id> <category>load-save</category><body package="RuntimePackager">decodeFrom: tokens fileVersion: version	"Decode the new value from the token array provided"	| edenSizeOM survivorSizeOM largeSizeOM stackSizeOM	codeSizeOM oldSizeOM actionBlocks fixedSizeOM omSizes |	omSizes := ObjectMemory defaultSizesAtStartup.	edenSizeOM := omSizes at: 1.	survivorSizeOM := omSizes at: 2.	largeSizeOM := omSizes at: 3.	stackSizeOM := omSizes at: 4.	codeSizeOM := omSizes at: 5.	oldSizeOM := omSizes at: 6.	fixedSizeOM := omSizes at: 7.	" set up blocks to accept input values "	actionBlocks := Dictionary new		add: #edenSize -&gt; [:val | edenSize := ( val * edenSizeOM ) rounded ];		add: #survivorSize -&gt; [:val | survivorSize := ( val * survivorSizeOM ) rounded ];		add: #largeSize -&gt; [:val | largeSize := ( val * largeSizeOM ) rounded ];		add: #stackSize -&gt; [:val | stackSize := ( val * stackSizeOM ) rounded ];		add: #codeSize -&gt; [:val | codeSize := ( val * codeSizeOM ) rounded ];		add: #oldSize  -&gt; [:val | oldSize := ( val * oldSizeOM ) rounded ];		add: #fixedSize  -&gt; [:val | fixedSize := ( val * fixedSizeOM ) rounded ];		add: #memoryPolicyClass -&gt; [:val | memoryPolicyClass := val];		add: #memoryUpperBound -&gt; [:val | memoryUpperBound := val];		"The following are here for compatibility with versions prior to 7.9"		add: #memoryLimit -&gt; [:val | memoryUpperBound := (val * (1 bitShift: 29)) rounded];		add: #growthLimit -&gt; [:val | nil ];		add: #incrementSize -&gt; [:val | nil ];		add: #retryDecrement  -&gt; [:val | nil ];		yourself.	" assign values using action blocks "	1 to: tokens size by: 2 do: [ :index |		(actionBlocks includesKey: ( tokens at: index ) )			ifFalse: [ Dialog warn: ( 'Invalid token "', (tokens at: index), '" found' ). ]			 ifTrue: [ (actionBlocks at: (tokens at: index)) value: (tokens at: index + 1). ] ].	" indicate values were changed "	self refresh.	hasBeenEdited := true.	self changed.</body><body package="RuntimePackager">encodeOn: aStream tab: tabCount	"Encode the receiver onto a stream in a form suitable for decoding as a literal array.	Values are encoded as fractions of the current system values"	| omSizes edenSizeOM survivorSizeOM largeSizeOM stackSizeOM	codeSizeOM oldSizeOM fixedSizeOM |	omSizes := ObjectMemory defaultSizesAtStartup.	edenSizeOM := omSizes at: 1.	survivorSizeOM := omSizes at: 2.	largeSizeOM := omSizes at: 3.	stackSizeOM := omSizes at: 4.	codeSizeOM := omSizes at: 5.	oldSizeOM := omSizes at: 6.	fixedSizeOM := omSizes at: 7.	aStream		crtab: tabCount; nextPutAll: 'edenSize ';			print: edenSize asDouble / edenSizeOM;			nextPutAll: ' "'; print: edenSize; nextPut:$";		crtab: tabCount; nextPutAll: 'survivorSize ';			print: survivorSize asDouble / survivorSizeOM;			nextPutAll: ' "'; print: survivorSize; nextPut:$";		crtab: tabCount; nextPutAll: 'largeSize ';			print: largeSize asDouble / largeSizeOM;			nextPutAll: ' "'; print: largeSize; nextPut:$";		crtab: tabCount; nextPutAll: 'stackSize ';			print: stackSize asDouble / stackSizeOM;			nextPutAll: ' "'; print: stackSize; nextPut:$";		crtab: tabCount; nextPutAll: 'codeSize ';			print: codeSize asDouble / codeSizeOM;			nextPutAll: ' "'; print: codeSize; nextPut:$";		crtab: tabCount; nextPutAll: 'oldSize ';			print: oldSize asDouble / oldSizeOM;			nextPutAll: ' "'; print: oldSize; nextPut:$";		crtab: tabCount; nextPutAll: 'fixedSize ';			print: fixedSize asDouble / fixedSizeOM;			nextPutAll: ' "'; print: fixedSize; nextPut:$";		crtab: tabCount; nextPutAll: 'memoryPolicyClass ';			print: memoryPolicyClass;		crtab: tabCount; nextPutAll: 'memoryUpperBound ';			print: memoryUpperBound</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMemoryParams</class-id> <category>actions</category><body package="RuntimePackager">setDefaultValues	"Set default memory value based on current values"	| omSizes |	"ObjectMemory derived sizes"	omSizes := OrderedCollection new: 7.	ObjectMemory defaultSizesAtStartup with: ObjectMemory sizesAtStartup do: [:size :multiplier |		omSizes add: (size * multiplier asDouble) truncated].	edenSize := omSizes at: 1.	survivorSize := omSizes at: 2.	largeSize := omSizes at: 3.	stackSize := omSizes at: 4.	codeSize := omSizes at: 5.	oldSize := omSizes at: 6.	fixedSize := omSizes at: 7.	"Memory Policy sizes"	memoryPolicyClass := ObjectMemory currentMemoryPolicy class fullName.	memoryUpperBound := ObjectMemory currentMemoryPolicy memoryUpperBound.	" notify interested parties "	self changed.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptions</class-id> <category>accessing</category><body package="RuntimePackager">clearParcelPath	^( strippingOptions includes: #clearParcelPath )</body><body package="RuntimePackager">clearParcelPath: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #clearParcelPath ]		ifFalse: [ strippingOptions remove: #clearParcelPath ifAbsent: [] ].</body><body package="RuntimePackager">continueOnLastWin	^( strippingOptions includes: #continueOnLastWin )</body><body package="RuntimePackager">continueOnLastWin: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #continueOnLastWin ]		ifFalse: [ strippingOptions remove: #continueOnLastWin ifAbsent: [] ].</body><body package="RuntimePackager">doThreeSaves	^(strippingOptions includes: #doThreeSaves)</body><body package="RuntimePackager">doThreeSaves: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #doThreeSaves ]		ifFalse: [ strippingOptions remove: #doThreeSaves ifAbsent: [] ].</body><body package="RuntimePackager">editorClass	"Answer the class to edit the receiver"	^RuntimeBuilderOptionsEditor</body><body package="RuntimePackager">errorLogPath	^errorLogPath</body><body package="RuntimePackager">errorLogPath: aString	errorLogPath := aString</body><body package="RuntimePackager">errorNotifierClass	^errorNotifierClass</body><body package="RuntimePackager">errorNotifierClass: aClass	errorNotifierClass := aClass</body><body package="RuntimePackager">headlessImage	^(strippingOptions includes: #headlessImage)</body><body package="RuntimePackager">headlessImage: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #headlessImage ]		ifFalse: [ strippingOptions remove: #headlessImage ifAbsent: [] ].</body><body package="RuntimePackager">imageDumperClass	^imageDumperClass</body><body package="RuntimePackager">imageDumperClass: aClass	imageDumperClass := aClass</body><body package="RuntimePackager">imagePath	^imagePath</body><body package="RuntimePackager">imagePath: aString	imagePath := aString</body><body package="RuntimePackager">mergeByteCodes	^( strippingOptions includes: #mergeByteCodes )</body><body package="RuntimePackager">mergeByteCodes: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #mergeByteCodes ]		ifFalse: [  strippingOptions remove: #mergeByteCodes ifAbsent: [] ].</body><body package="RuntimePackager">mergeLiterals	^( strippingOptions includes: #mergeLiterals )</body><body package="RuntimePackager">mergeLiterals: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #mergeLiterals ]		ifFalse: [  strippingOptions remove: #mergeLiterals ifAbsent: [] ].</body><body package="RuntimePackager">mergeMethods	"Answer true if equal methods are to be merged in the runtime image"	^( strippingOptions includes: #mergeMethods )</body><body package="RuntimePackager">mergeMethods: aBoolean	"Add the option for merging methods if aBoolean is true"	aBoolean		ifTrue: [ strippingOptions add: #mergeMethods ]		ifFalse: [  strippingOptions remove: #mergeMethods ifAbsent: [] ].</body><body package="RuntimePackager">operatingSystems	"Answer the set of operating systems being supported"	^operatingSystems</body><body package="RuntimePackager">operatingSystems: aSet	"Answer the set of operating systems being supported"	operatingSystems := aSet</body><body package="RuntimePackager">osUnix	^( operatingSystems includes: #unix )</body><body package="RuntimePackager">osUnix: aBoolean	aBoolean		ifTrue: [ operatingSystems add: #unix ]		ifFalse: [ operatingSystems remove: #unix ifAbsent: [] ].</body><body package="RuntimePackager">osWindows	^( operatingSystems includes: #win )</body><body package="RuntimePackager">osWindows: aBoolean	aBoolean		ifTrue: [ operatingSystems add: #win ]		ifFalse: [ operatingSystems remove: #win ifAbsent: [] ].</body><body package="RuntimePackager">packageExternalInterfaces	^( strippingOptions includes: #packageExternalInterfaces )</body><body package="RuntimePackager">packageExternalInterfaces: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #packageExternalInterfaces ]		ifFalse: [ strippingOptions remove: #packageExternalInterfaces ifAbsent: [] ].</body><body package="RuntimePackager">parcelOptions	"Answer dictionary of options by parcel name"	^parcelOptions</body><body package="RuntimePackager">parcelOptions: aDict	"Set a dictionary of options by parcel name"	parcelOptions := aDict.</body><body package="RuntimePackager">prestripClass	^prestripClass</body><body package="RuntimePackager">prestripClass: aClassOrNil	prestripClass := aClassOrNil</body><body package="RuntimePackager">prestripMethod	^prestripMethod</body><body package="RuntimePackager">prestripMethod: aSymbolOrNil	prestripMethod := aSymbolOrNil</body><body package="RuntimePackager">removeCompiler	^(strippingOptions includes: #removeCompiler)</body><body package="RuntimePackager">removeCompiler: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #removeCompiler ]		ifFalse: [ strippingOptions remove: #removeCompiler ifAbsent: [] ].</body><body package="RuntimePackager">removeOrganization	^( strippingOptions includes: #removeOrganization )</body><body package="RuntimePackager">removeOrganization: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #removeOrganization ]		ifFalse: [ strippingOptions remove: #removeOrganization ifAbsent: [] ].</body><body package="RuntimePackager">shutdownOnLastWin	^( strippingOptions includes: #shutdownOnLastWin )</body><body package="RuntimePackager">shutdownOnLastWin: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #shutdownOnLastWin ]		ifFalse: [ strippingOptions remove: #shutdownOnLastWin ifAbsent: [] ].</body><body package="RuntimePackager">skipScan	^( strippingOptions includes: #skipScan )</body><body package="RuntimePackager">skipScan: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #skipScan ]		ifFalse: [ strippingOptions remove: #skipScan ifAbsent: [] ].</body><body package="RuntimePackager">startupClass	^startupClass</body><body package="RuntimePackager">startupClass: aClassOrNil	startupClass := aClassOrNil</body><body package="RuntimePackager">startupMethod	^startupMethod</body><body package="RuntimePackager">startupMethod: aSymbolOrNil	startupMethod := aSymbolOrNil</body><body package="RuntimePackager">stripGlobals	^( strippingOptions includes: #stripGlobals )</body><body package="RuntimePackager">stripGlobals: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #stripGlobals ]		ifFalse: [ strippingOptions remove: #stripGlobals ifAbsent: [] ].</body><body package="RuntimePackager">strippingOptions	"Answer the set of options for stripping the image"	^strippingOptions</body><body package="RuntimePackager">strippingOptions: aSet	"Answer the set of options for stripping the image"	strippingOptions := aSet.</body><body package="RuntimePackager">suppressSplashScreen	^( strippingOptions includes: #suppressSplashScreen )</body><body package="RuntimePackager">suppressSplashScreen: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #suppressSplashScreen ]		ifFalse: [ strippingOptions remove: #suppressSplashScreen ifAbsent: [] ].</body><body package="RuntimePackager">traceLevel	"Answer the trace level used during stripping"	^traceLevel</body><body package="RuntimePackager">traceLevel: anInteger	"Set the trace level used during stripping"	traceLevel := anInteger.</body><body package="RuntimePackager">useAutoLoader	^(strippingOptions includes: #useAutoLoader)</body><body package="RuntimePackager">useAutoLoader: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #useAutoLoader ]		ifFalse: [ strippingOptions remove: #useAutoLoader ifAbsent: [] ].</body><body package="RuntimePackager">useRuntimeCompiledMethod	^( strippingOptions includes: #useRuntimeCompiledMethod )</body><body package="RuntimePackager">useRuntimeCompiledMethod: aBoolean	aBoolean		ifTrue: [ strippingOptions add: #useRuntimeCompiledMethod ]		ifFalse: [ strippingOptions remove: #useRuntimeCompiledMethod ifAbsent: [] ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptions</class-id> <category>parcels</category><body package="RuntimePackager">hasLoadableParcels	"Answer true if at least one parcel is loadable into the runtime image"	parcelOptions keysAndValuesDo: [ :p :opt |		( opt at: #loadable ifAbsent: [ false ] ) ifTrue:[ ^true ] ].	^false</body><body package="RuntimePackager">hasParcelsToBeSaved	"Answer true if at least one parcel is loadable into the runtime image"	parcelOptions keysAndValuesDo: [ :p :opt |		( opt at: #saveParcel ifAbsent: [ false ] ) ifTrue:[ ^true ].		( opt at: #stripParcel ifAbsent: [ false] ) ifTrue: [ ^true ] ].	^false</body><body package="RuntimePackager">loadableApplications	"Answer the runtime loadable ENVY/Developer applications not including	those representing runtime loadable parcels."	^#().</body><body package="RuntimePackager">loadableClasses	"Answer all classes that can be dynamically loaded into the image.	For now all classes defined in parcels are assumed to be loadable	plus those defined in loadable ENVY/Developer applications."	| classes |	classes := IdentitySet new.	self loadableParcels do: [:parcel | classes addAll: parcel definedClasses].	^classes.</body><body package="RuntimePackager">loadableMethods	"Answer all methods that can be dynamically loaded into the image.	These are the method extensions in parcels and the methods in classes	defined in parcels plus those from loadable applications.	Answer in the form of a dictionary whose key is the behavior and value	is a set of the applicable selectors. The round about access logic is an	attempt to live with the Parcel public protocols"	| methods selectors |	methods := IdentityDictionary new.	"First, get the extensions from loadable parcels"	self loadableParcels do: [ :parcel |		parcel extendedBehaviors do: [ :behav |			selectors := methods at: behav ifAbsent: [ Set new ].			( RuntimeManager selectorsInClass: behav ) do: [ :sel |				( parcel definesSelector: sel forClass: behav ) ifTrue: [					selectors add: sel ] ].			selectors isEmpty ifFalse: [				methods at: behav  put: selectors ] ].		" defined and extended classes are assumed to be exclusive "		parcel definedClasses do: [ :cl |			selectors := methods at: cl ifAbsent: [ Set new ].			selectors addAll: ( RuntimeManager selectorsInClass: cl ).			selectors isEmpty ifFalse: [				methods at: cl put: selectors. ].			selectors := methods at: cl class ifAbsent: [ Set new ].			selectors addAll: ( RuntimeManager selectorsInClass: cl class ).			selectors isEmpty ifFalse: [				methods at: cl class put: selectors. ] ] ].	^methods</body><body package="RuntimePackager">loadableNameSpaces	"Answer name spaces that can be dynamically loaded into the image.	All name spaces defined in parcels are assumed to be loadable	as are those defined in pragmas in classes defined in loadable applications."	|  loadableNameSpaces |	loadableNameSpaces := IdentitySet new.	self loadableParcels do: [ :parcel |		loadableNameSpaces addAll: parcel definedNameSpaces ].	^loadableNameSpaces</body><body package="RuntimePackager">loadableParcels	"Answer the loadable parcels not including ENVY/Developer applications"	| parcels |	parcels := IdentitySet new.	parcelOptions keysAndValuesDo: [ :pname :popts |		( popts at: #loadable ifAbsent: [ false ] )			ifTrue: [ parcels add: ( Parcel parcelNamed: pname ). ] ].	^parcels</body><body package="RuntimePackager">parcelIsLoadable: parcelName	"Answer true if the parcel is loadable per parcelOptions"	^( parcelOptions at: parcelName asString ifAbsent: [ ^false ] )		at: #loadable ifAbsent: [ false ]</body><body package="RuntimePackager">parcelNamesToUnload	"Answer the names of parcels and applications to be unloaded before	the final stripping step."	| pnames |	pnames := Set new.	parcelOptions keysAndValuesDo: [ :parcelName :popts |		( ( popts at: #loadable ifAbsent: [ false ] ) and: [			popts at: #unloadBeforeStrip ifAbsent:[ false ] ] )			ifTrue: [				pnames add: parcelName ] ].	^pnames</body><body package="RuntimePackager">parcelsToUnload	"Answer the parcels to be unloaded before the final stripping step."	^self loadableParcels select: [ :parcel |		self unloadParcelBeforeStrip: parcel name ]</body><body package="RuntimePackager">pathForParcel: parcelName	"Answer a string naming the path to which parcelName should be saved"	^ ( parcelOptions at: parcelName asString ) at: #path ifAbsent: [ parcelName, '.pcl' ]</body><body package="RuntimePackager">removeNonloadableParcels	"Remove parcels that will be loaded at runtime from the parcel options dictionary.	Parcels that are not currently defined are treated as not loadable and deleted."	parcelOptions copy		keysAndValuesDo:			[:parcelName :parcelDict | 			(parcelDict at: #loadable ifAbsent: [false]) not				ifTrue: [parcelOptions removeKey: parcelName]].</body><body package="RuntimePackager">stripParcel: parcelName	"Answer true if the parcel is to save only kept classes and methods"	^( parcelOptions at: parcelName asString ifAbsent: [ ^false ] )		at: #stripParcel ifAbsent: [ false ]</body><body package="RuntimePackager">unloadParcelBeforeStrip: parcelName	"Answer true if the parcel is unloaded before stripping per parcelOptions"	^( parcelOptions at: parcelName asString ifAbsent: [ ^false ] )		at: #unloadBeforeStrip ifAbsent: [ false ]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptions</class-id> <category>load-save</category><body package="RuntimePackager">decodeErrorNotifierClass: val		^self		errorNotifierClass:			(val == #nil				ifTrue: [nil]				ifFalse:					[self						classNamed: val						ifAbsent:							[Transcript								cr;								show:										('Error Notifier Class &lt;1p&gt; not found.  It was skipped'												expandMacrosWith: val).							nil]])</body><body package="RuntimePackager">decodeFrom: tokens fileVersion: version	"Decode the new value from the token array provided"		| actionBlocks |	" set up blocks to accept input values "	actionBlocks := (Dictionary new)		" include compatibility for earlier formats "			add:				#packageExternalInterfaces						-&gt; [:val | self packageExternalInterfaces: val == #true];		add: #doThreeSaves -&gt; [:val | self doThreeSaves: val == #true];		add:				#removeOrganization -&gt; [:val | self removeOrganization: val == #true];		add: #removeCompiler -&gt; [:val | self removeCompiler: val == #true];		add: #shutdownOnLastWin -&gt; [:val | self shutdownOnLastWin: val == #true];		" parameters with non-boolean values "			add: #errorLogPath -&gt; [:val | self errorLogPath: val];		add: #errorNotifierClass -&gt; [:val | self decodeErrorNotifierClass: val];		add: #imageDumperClass -&gt; [:val | self decodeImageDumperClass: val];		add: #imagePath -&gt; [:val | self imagePath: val];		add:				#startupClass -&gt;						[:val | 						self							startupClass:								(val == #nil									ifTrue: [nil]									ifFalse:										[self											classNamed: val											ifAbsent:												[Transcript													cr;													show:															('Startup Class &lt;1p&gt; not found.  It was skipped' expandMacrosWith: val).												nil]])];		add:				#startupMethod						-&gt;							[:val | self startupMethod: (val == #nil ifTrue: [nil] ifFalse: [val asSymbol])];		add:				#prestripClass -&gt;						[:val | 						self							prestripClass:								(val == #nil									ifTrue: [nil]									ifFalse:										[self											classNamed: val											ifAbsent:												[Transcript													cr;													show:															('Prestrip Class &lt;1p&gt; not found.  It was skipped' expandMacrosWith: val).												nil]])];		add:				#prestripMethod						-&gt;							[:val | self prestripMethod: (val == #nil ifTrue: [nil] ifFalse: [val asSymbol])];		" decode parcel options keyword "			add:				#parcelOptions -&gt;						[:val | 						| dict pname optVals popts opt |						dict := Dictionary new.						1							to: val size							by: 2							do:								[:idx | 								pname := val at: idx.								optVals := val at: idx + 1.								popts := Dictionary new.								1									to: optVals size									by: 2									do:										[:idx2 | 										opt := optVals at: idx2 + 1.										opt == #true ifTrue: [opt := true].										opt == #false ifTrue: [opt := false].										popts at: (optVals at: idx2) put: opt].								dict at: pname put: popts].						self parcelOptions: dict];		" accept new formats for strippingOptions, operating systems, and UI Looks "			add: #strippingOptions -&gt; [:val | self strippingOptions: val asSet];		add: #operatingSystems -&gt; [:val | self operatingSystems: val asSet];		add: #uiLooks -&gt; [:val | ]; "Obsolete"		yourself.		" assign values using action blocks "	1		to: tokens size		by: 2		do:			[:index | 			(actionBlocks includesKey: (tokens at: index))				ifFalse:					[Dialog warn: 'Invalid token "' , (tokens at: index) , '" found']				ifTrue:					[(actionBlocks at: (tokens at: index)) value: (tokens at: index + 1)]].	" indicate values were changed "	self refresh.	hasBeenEdited := true.	self changed</body><body package="RuntimePackager">decodeImageDumperClass: val	"Set the class that will write out the system state when an unhandled exception occurs.	 If val is nil, then the parameters file did not have on specified.  If val refers to the old 	 RuntimeImageDumper class, then use the RuntimeFullDumper class instead."		| decodedValue |	decodedValue := val.	decodedValue == #nil ifTrue: [^self imageDumperClass: nil].	decodedValue = 'RuntimePackager.RuntimeImageDumper'		ifTrue: [decodedValue := 'RuntimePackager.RuntimeFullDumper'].	^self imageDumperClass:		(self			classNamed: decodedValue			ifAbsent:				[Transcript					cr;					show:							(#ImageDumperClassNotFound &lt;&lt; #RuntimePackager									&gt;&gt; 'Image Dumper Class &lt;1p&gt; not found.  It was skipped'									expandMacrosWith: val).				nil])</body><body package="RuntimePackager">encodeOn: aStream tab: tabCount	"Encode the receiver onto a stream in a form suitable for decoding as a literal array"	aStream		crtab: tabCount; nextPutAll: 'errorLogPath  '; print: errorLogPath;		crtab: tabCount; nextPutAll: 'errorNotifierClass  ';			print: ( errorNotifierClass isNil				ifTrue: [ nil ]				ifFalse: [ errorNotifierClass fullName ] );		crtab: tabCount; nextPutAll: 'imageDumperClass  ';			print: ( imageDumperClass isNil				ifTrue: [ nil ]				ifFalse: [ imageDumperClass fullName ] );		crtab: tabCount; nextPutAll: 'imagePath  '; print: imagePath;		crtab: tabCount; nextPutAll: 'startupClass  '; print: (			startupClass isNil				ifTrue: [ nil ]				ifFalse: [ startupClass fullName ] );		crtab: tabCount; nextPutAll: 'startupMethod '; print: (			startupMethod isNil ifTrue: [ nil ] ifFalse: [ startupMethod asString ] );		crtab: tabCount; nextPutAll: 'prestripClass  '; print: (			prestripClass isNil				ifTrue: [ nil ]				ifFalse: [ prestripClass fullName  ] );		crtab: tabCount; nextPutAll: 'prestripMethod '; print: (			prestripMethod isNil ifTrue: [ nil ] ifFalse: [ prestripMethod asString ] ) .	aStream crtab: tabCount; nextPutAll: 'strippingOptions ('.	strippingOptions do: [ :x |		aStream crtab: tabCount+1; nextPutAll: x ].	aStream nextPutAll: ' )'.	aStream crtab: tabCount; nextPutAll: 'operatingSystems ('.	operatingSystems do: [ :x |		aStream crtab: tabCount+1; nextPutAll: x ].	aStream nextPutAll: ' )'.	aStream crtab: tabCount; nextPutAll: 'parcelOptions ('.	parcelOptions keysAndValuesDo: [ :pname :popts |		( popts at: #loadable ifAbsent: [ false ] ) ifTrue: [			aStream crtab: tabCount+1; print: pname;				nextPutAll: ' ( '.			popts keysAndValuesDo: [ :opt :val |				aStream crtab: tabCount+ 2; nextPutAll: opt; space; print: val ].			aStream nextPut: $) ] ].	aStream nextPutAll: ' )'.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptions</class-id> <category>actions</category><body package="RuntimePackager">setDefaultValues	"Set options to their default values"	| changedAspects saveOperatingSystems saveRemoveCompiler |	" save certain aspects for which changes are of interest "	changedAspects := Set new.	saveRemoveCompiler := self removeCompiler.	saveOperatingSystems := operatingSystems.	" set new values "	strippingOptions := Set new.	operatingSystems := Set new.	" set canned options "	self removeCompiler: false.	self shutdownOnLastWin: true.	self doThreeSaves: false.	self skipScan: false.	self clearParcelPath: true.	self suppressSplashScreen: true.	self useAutoLoader: true.	self headlessImage: false.	self packageExternalInterfaces: true.	self removeOrganization: true.	self mergeByteCodes: true.	self mergeLiterals: false.	self mergeMethods: false.	self useRuntimeCompiledMethod: false.	self startupClass: nil.	self startupMethod: nil.	self prestripClass: nil.	self prestripMethod: nil.	self errorNotifierClass: RuntimeEmergencyNotifier.	self imageDumperClass: RuntimeFullDumper.	self errorLogPath: 'error.log'.	self imagePath: 'runtime'.	self traceLevel: 0.	self stripGlobals: true.	operatingSystems addAll: #(#win #unix #mac).	" clear parcel options "	parcelOptions := Dictionary new.	" look at some options that may have been changed "	self hasBeenEdited ifTrue: [		saveRemoveCompiler = self removeCompiler ifFalse: [			changedAspects add: #removeCompiler ].		saveOperatingSystems asSortedCollection =			operatingSystems asSortedCollection ifFalse: [			changedAspects add: #operatingSystems ]].	" notify interested parties that things have changed. "	self changed: #values with: changedAspects.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptions</class-id> <category>initialization</category><body package="RuntimePackager">initialize	"Initialize the object"	super initialize.	strippingOptions := Set new.	operatingSystems := Set new.	parcelOptions := Dictionary new.</body></methods><methods><class-id>RuntimePackager.RuntimeInstanceSurrogate</class-id> <category>basic methods</category><body package="RuntimePackager">== anObject	"Perform the same function as Object&gt;&gt;==.  This is needed to keep surrogates in an	IdentitySet or IdentityDictionary."	&lt;primitive: 110&gt;	self primitiveFailed</body><body package="RuntimePackager">doesNotUnderstand: aMessage	"Relay the message to the surrogate manager to force the receiver's class to	be restored to its normal state before resending the message."	^RuntimeSurrogateManager activeManager		interceptedInstanceMessage: aMessage receiver: self</body><body package="RuntimePackager">identityHash	"Perform the same function as Object&gt;&gt;identityHash"	&lt;primitive: 75&gt;	self primitiveFailed</body><body package="RuntimePackager">isNil	"Provide the standard answer of false"	^false</body><body package="RuntimePackager">notNil	"Provide the standard answer of true"	^true</body><body package="RuntimePackager">primitiveFailed	"Indicate that a primitive failed"	^Object errorSignal raiseErrorString: 'Primitive failed in a behavior surrogate'</body><body package="RuntimePackager">rtpClass	"Answer the object which is the receiver's class.	This form of the message is used by the manager to	get access to the real class"	&lt;primitive: 111&gt;	^self primitiveFailed</body></methods><methods><class-id>RuntimePackager.RuntimeHeadlessExample class</class-id> <category>actions</category><body package="RuntimePackager">openDialog	"Open a dialog, which is an error in the headless environment"	Dialog warn: 'RuntimeHeadlessExample class&gt;&gt;openDialog executed'.</body><body package="RuntimePackager">writeExampleFile	"Write a file containing some indication that the function was performed"	| file |	file := 'rtpexmpl.txt' asFilename writeStream.	file nextPutAll: 'RuntimeHeadlessExample was executed ';		nextPutAll: Date today printString;		space;		nextPutAll: Time now printString;		cr.	file close.</body></methods><methods><class-id>RuntimePackager.RuntimeHeadlessExample class</class-id> <category>parcel actions</category><body package="RuntimePackager">postLoadActionFor: aParcel	"Open the application when it is loaded from a Parcel"	self writeExampleFile.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMessageTracer</class-id> <category>internal</category><body package="RuntimePackager">addReferencedSelector: aSymbol in: aBehavior	"Remember that a selector was referenced explicitly in a specific behavior"	( referencedMethods at: aBehavior ifAbsent: [		referencedMethods at: aBehavior put: Set new ] ) add: aSymbol.</body><body package="RuntimePackager">addUnreferencedGlobalsIn: aNameSpace to: unref referenced: globals	"Add all global binding references that were not referenced.	globals holds a set of referenced globals as variable bindings.	Take the globals in aNameSpace and the name spaces in it"	| nsRef |	nsRef := aNameSpace fullyQualifiedReference.	aNameSpace bindingsDo: [ :binding |		binding isForClass ifFalse: [			( globals includes: binding ) ifFalse: [				unref add: ( nsRef append: binding key ). ] ].		binding isForNameSpace ifTrue: [			self addUnreferencedGlobalsIn: binding value to: unref referenced: globals ] ].</body><body package="RuntimePackager">findPragmaMessages	"Set up a cache of all messages that reference the Pragma class directly, to save doing a senders operation for each pragma method"	| methodCollector |	methodCollector := MethodCollector new.	pragmaReferences := methodCollector select: (methodCollector referencesTo: #{Pragma} binding).	pragmaReferences := pragmaReferences collect: [:each | each method].</body><body package="RuntimePackager">invertClassesAndGlobals	"Find and save all name spaces including those used for pools and class variables."	notifier log: 'Inverting global and class bindings.'.	self invertNameSpacesFrom: Root.	"We need to make sure that our list of globals are using the correct unique instance of the binding."	deletedGlobals := deletedGlobals collect: [:each | 		(globalBindings 			detect: [:eachGlobalBinding | eachGlobalBinding = each] 			ifNone: [nil])].	deletedGlobals := deletedGlobals select: [:each | each notNil].	referencedGlobals := referencedGlobals collect: [:each | 		(globalBindings 			detect: [:eachGlobalBinding | eachGlobalBinding = each] 			ifNone: [nil])].	referencedGlobals := referencedGlobals select: [:each | each notNil].</body><body package="RuntimePackager">invertNameSpacesFrom: aNameSpace	"Recursively go through name spaces inverting globals and classes."	aNameSpace bindingsDo: [ :binding |		( binding isForClass not and: [ aNameSpace isForClass not ] ) ifTrue: [			globalBindings at: binding put:				( aNameSpace fullyQualifiedReference append: binding key ) ].		binding isForClass ifTrue: [			| classesAtName |			classesAtName := invertedClasses at: binding key ifAbsent: [ nil ].			classesAtName isNil				ifTrue: [ invertedClasses at: binding key put: (OrderedCollection with: binding value ) ]				ifFalse: [ classesAtName add: binding value ].			self invertNameSpacesFrom: binding value asNameSpace." Is this needed -- hangs up on some classes like X11InputManager  --			binding value importDefinitions do: [ :ref |				| refValue |				( refValue := ref valueOrDo: [nil ] ) notNil ifTrue: [					self invertNameSpacesFrom: refValue. ] ]."		 ].		binding isForNameSpace ifTrue: [			self invertNameSpacesFrom: binding value. ] ].</body><body package="RuntimePackager">invertSelectors	"Build the dictionary of selectors and where they are used"	| classesFound |	notifier log: 'Inverting selectors '.	notifier tickRate: Symbol tableSize // 700.	classesFound := IdentitySet new.	RuntimeManager allClassesDo: [ :cl |		( classesFound includes: cl ) not ifTrue: [			notifier tick.			classesFound add: cl.			( RuntimeManager selectorsInClass: cl ) do: [ :sel |				| x mth |				x := invertedSelectors at: sel ifAbsent: [ nil ].				mth := cl compiledMethodAt: sel.				x isNil					ifTrue: [						invertedSelectors at: sel put: (OrderedCollection with: mth). ]					ifFalse: [ x add: mth ] ].			( RuntimeManager selectorsInClass: cl class ) do: [ :sel |				| x mth |				x := invertedSelectors at: sel ifAbsent: [ nil ].				mth := cl class compiledMethodAt: sel.				x isNil					ifTrue: [						invertedSelectors at: sel put: (OrderedCollection with: mth). ]					ifFalse: [ x add: mth ] ].		self noteExitMethodsIn: cl ] ].	accessors := IdentitySet new: invertedSelectors size // 4.	invertedSelectors keysAndValuesDo: [ :k : v |		invertedSelectors at: k put: v asArray.		( k isSequenceable and: [			k size &gt; 0 and: [			k last == $: and: [			( k inject: 0 into: [ :n :c |				c == $: ifTrue: [					n + 1 ] ifFalse: [ n ] ] ) == 1  ] ] ] )				ifTrue: [					| str |					str := k copyFrom: 1 to: k size - 1.					Symbol hasInterned: str ifTrue: [ :sym |						accessors add: sym. ] ] ].</body><body package="RuntimePackager">noteExitMethodsIn: aClass	"Note whether aClass implements any of the magic methods used	to override normal behavior in the message tracing process.	The set of such classes is used to optimize performance since	most classes will not implement any such methods"	#(	#dynamicallyReferencedClasses		#dynamicallyReferencedSelectors		#dynamicallyReferencedGlobals		#itemsReferencedBySelector:		#itemsReferencedByClassSelector: ) do: [ :sel |		( aClass class includesSelector: sel ) ifTrue: [			exitClasses add: aClass ] ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMessageTracer</class-id> <category>initialization</category><body package="RuntimePackager">addActiveWindowPolicyClass	"Add the default instance of WindowManagerUsagePolicy to the list of classes to keep.  If the runtime application      names another it should be traced later"	newClasses add: (Processor activeProcess environmentAt: #WindowManagerUsagePolicy) class</body><body package="RuntimePackager">deletedClassesAdd: aCollection	"Add to the set of classes that will not be scanned."	aCollection do: [ :cl |		deletedClasses addAll: cl withAllSubclasses ].</body><body package="RuntimePackager">deletedGlobalsAdd: aCollection	"Add to the set of classes that will not be scanned."	deletedGlobals addAll: aCollection.</body><body package="RuntimePackager">initialClassesAdd: aCollection	"Add to the set of classes to assume as resident."	newClasses addAll: aCollection</body><body package="RuntimePackager">initialGlobalsAdd: aCollection	"Add to the set of globals (as binding references) to assume as referenced.	The class of each global's current value is assumed to referenced as well.	If the global refers to a class, then that class is added also."	| refValue |	referencedGlobals addAll: aCollection.	aCollection do: [ :bindingRef |		refValue := bindingRef valueOrDo: [ nil ].		refValue isBehavior			ifTrue: [				newClasses add: ( refValue isMeta					ifTrue: [ refValue soleInstance ]					ifFalse: [ refValue ] ) ]			ifFalse: [ newClasses add: refValue class ] ].</body><body package="RuntimePackager">initialize	"Initialize  a new instance"	sentSelectors := IdentitySet new.	deletedClasses := IdentitySet new.	referencedClasses := IdentitySet new.	referencedGlobals := IdentitySet new.	referencedMethods := IdentityDictionary new.	deletedGlobals := IdentitySet new.	newSelectors := IdentitySet new.	newClasses := IdentitySet new.	exitClasses := IdentitySet new.	globalBindings := IdentityDictionary new.	invertedClasses := IdentityDictionary new.	invertedSelectors := IdentityDictionary new.	blocksReferenced := IdentitySet new.	externalInterfaceClasses := IdentitySet withAll: ExternalInterface withAllSubclasses.	tracedMethods := IdentitySet new.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMessageTracer</class-id> <category>accessing</category><body package="RuntimePackager">addNewSelector: aSelector	"Add a single selector to the sentSelectors collection"	^newSelectors add: aSelector</body><body package="RuntimePackager">addNewSelectors: selectorCollection	"Add a single selector to the sentSelectors collection"	^newSelectors addAll: selectorCollection</body><body package="RuntimePackager">addSentSelector: aSelector	"Add a single selector to the sentSelectors collection"	^sentSelectors add: aSelector</body><body package="RuntimePackager">items	"Answer the items object holding kept and deleted classes, globals, and methods"	^ items</body><body package="RuntimePackager">items: aRuntimeBuilderItems	"Set the items object holding kept and deleted classes, globals, and methods"	items := aRuntimeBuilderItems.</body><body package="RuntimePackager">newClasses	^newClasses</body><body package="RuntimePackager">newSelectors	^newSelectors</body><body package="RuntimePackager">notifier	^notifier</body><body package="RuntimePackager">notifier: anObject	notifier := anObject</body><body package="RuntimePackager">options	"Answer options being used for tracing"	^ options</body><body package="RuntimePackager">options: aRuntimeBuilderOptions	"Set options (RuntimeBuilderOptions) being used for tracing"	options := aRuntimeBuilderOptions</body><body package="RuntimePackager">referencedClasses	"Answer the collection of classes referenced somewhere"	^referencedClasses</body><body package="RuntimePackager">referencedGlobals	"Answer the collection of global variables referenced somewhere"	^referencedGlobals</body><body package="RuntimePackager">sentSelectors	"Answer the collection of selectors found to be sent from somewhere"	^sentSelectors</body><body package="RuntimePackager">unreferencedClasses	"Answer a collection of classes that werer not referenced"	| classes |	referencedClasses size == 0 ifTrue: [		^IdentitySet new. ].	classes := IdentitySet new.	RuntimeManager allClassesDo: [ :cl |		( referencedClasses includes: cl ) ifFalse: [				classes add: cl ] ].	^classes</body><body package="RuntimePackager">unreferencedGlobals	"Answer a collection of globals that were not referenced anywhere"	| unref globals |	referencedGlobals size == 0 ifTrue: [ ^Set new. ].	unref := Set new.	globals := IdentitySet new: referencedGlobals size.	referencedGlobals do: [ :ref |		globals add: ref bindingOrNil ].	self addUnreferencedGlobalsIn: Root to: unref referenced: globals.	^unref</body><body package="RuntimePackager">unreferencedMethods	"Answer the methods that are not referenced.  These are methods in which	the selector was not sent, the class was not referenced, or the method	was explicitly deleted.  Kept methods in referenced classes are considered	referenced in any case though."	|  unrefMethods unrefSelectors selectors |	unrefMethods := IdentityDictionary new.	Smalltalk allBehaviorsDo: [ :behav |		unrefSelectors := Set new: 17.		selectors := RuntimeManager selectorsInClass: behav.		" see if the class was referenced "		( referencedClasses includes: (			behav isMeta ifTrue: [ behav soleInstance ] ifFalse: [ behav ] ) )			ifFalse: [				" all selectors are thereby unreferenced as well "				unrefSelectors addAll: selectors. ]			ifTrue: [				" add any methods explicitly deleted "				unrefSelectors addAll: (					items deletedMethods at: behav ifAbsent: [ #( ) ] ).				" add all selectors not sent anywhere "				unrefSelectors addAll: (					selectors reject: [ :sel | sentSelectors includes: sel ] ).				" remove selectors that were aprior referenced "				( referencedMethods at:behav ifAbsent: [ #( ) ] ) do: [ :sel |					unrefSelectors remove: sel ifAbsent: []. ] ].		" create the entry in the unreferenced methods dictionary "		unrefSelectors isEmpty ifFalse: [			unrefMethods at: behav put: unrefSelectors asSet ] ].	^unrefMethods</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMessageTracer</class-id> <category>actions</category><body package="RuntimePackager">raiseNotifier	"Raise the notifier window, if there is one"	notifier notNil ifTrue: [ notifier raise ].</body><body package="RuntimePackager">traceSystem	"Trace all message sends to determine unreferenced classes and selectors.	items and options must be set before starting this process."	notifier := RuntimeProgressNotifier open.	[Cursor wait showWhile: [		" initialize for message tracing "		notifier log: 'Preparing for message trace'.		self initialClassesAdd: items keptClasses.		self addActiveWindowPolicyClass.		notifier tick.		self deletedClassesAdd: items deletedClasses.		self deletedClassesAdd: items classesInDeletedNameSpaces.		notifier tick.		self initialGlobalsAdd: items keptGlobals.		notifier tick.		self deletedGlobalsAdd: items deletedGlobals.		notifier tick.		" do the transitive closure of messages found "		self traceMessages.		" collect the results"		notifier log: 'Extracting unreferenced classes'.		items unreferencedClasses: self unreferencedClasses.		notifier log: 'Extracting unreferenced methods'.		items unreferencedMethods: self unreferencedMethods.		notifier log: 'Extracting unreferenced globals'.		items unreferencedGlobals: self unreferencedGlobals.		"With the addition of namespace tracing, we can undelete referenced namespaces"		items deletedGlobals: deletedGlobals.		items refreshViewer]] ensure: [				notifier close.			notifier := nil].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMessageTracer</class-id> <category>message tracing</category><body package="RuntimePackager">isCollectionWeShouldIterate: anObject	^#(Array Set Dictionary IdentityDictionary OrderedCollection List) includes: anObject class name.</body><body package="RuntimePackager">methodIsResourceMethod: aCompiledMethod	"Return true if this is a resource method, and thus might have compound selectors"	^aCompiledMethod homeMethod attributeMessages notNil		and: [aCompiledMethod homeMethod attributeMessages anySatisfy: [:each | each selector == #resource:]].</body><body package="RuntimePackager">overriddenReferencesListForMethod: aMethod	"Trace a compiled method to detect sent selectors and referenced classes."	| lits mclass who |	" look for class exits that will specify the literals in the method "	lits := nil.	[ ( mclass := aMethod mclass ) isBehavior ifTrue: [		mclass isMeta			ifTrue: [				( mclass includesSelector:					#itemsReferencedByClassSelector: ) ifTrue: [					( who := aMethod who ) notNil ifTrue: [						lits := mclass soleInstance perform:								#itemsReferencedByClassSelector:								with: ( who at: 2 ) ] ] ]			ifFalse: [				( mclass class includesSelector:						#itemsReferencedBySelector: ) ifTrue: [					( who := aMethod who ) notNil ifTrue: [						lits := mclass perform:							 #itemsReferencedBySelector:							with: ( who at: 2 ) ] ] ].		( lits isNil or: [ lits isKindOf: Collection ] ) ifFalse: [			self notify: 'Answered references are not in the form of a collection'.			lits := nil. ] ] ]	on: Error	do: [  :ex |		( Dialog choose: ( ex errorString,				'\\Error while obtaining reference overrides for \' withCRs,				aMethod displayString,				'\\These overrides will be ignored'  withCRs )			labels: #( 'OK' 'Debug' )			values: #( #ok #debug)			default: #ok ) == #ok			ifTrue: [ lits := nil ]			ifFalse: [ ex pass ] ].	^lits.</body><body package="RuntimePackager">traceAllLiterals: literal	"trace references from the literal including those contained	within literal if it is an Array"	literal class == Array		ifTrue: [ self traceArray: literal excluding: IdentitySet new. ]		ifFalse: [ self traceLiteral: literal. ].</body><body package="RuntimePackager">traceArray: anArray excluding: exclusionSet	"Recursively trace the array provided skipping elements in the exlusionSet."	exclusionSet add: self.	anArray do: [ :element |		element class == Array			ifTrue: [				(exclusionSet includes: element ) ifFalse: [					self traceArray: element excluding: exclusionSet ] ]			ifFalse: [ self traceLiteral: element ] ].</body><body package="RuntimePackager">traceBlockClosure: aBlockClosure	"Trace references from a block closure.	Need to avoid recursion in initializers, so make sure no block is scanned twice."	( blocksReferenced includes: aBlockClosure ) ifFalse: [		blocksReferenced add: aBlockClosure.		self traceMethod: aBlockClosure method. ].</body><body package="RuntimePackager">traceClass: aClass	"Examine the selectors implemented in a class to see if any of them are sent.	If so, trace the implementing methods.  Trace superclass also."	" do not retrace classes already done or apriori deleted "	" see if there are kept methods that should be included "	aClass isObsolete ifTrue: [^self].	((referencedClasses includes: aClass)		or: [deletedClasses includes: aClass]) ifTrue: [^self].	referencedClasses add: aClass.		"Include references through class pool"	aClass classPool bindingsDo: [:binding | self traceClassPoolEntry: binding].	"Include references to imported classes and globals"	self traceGlobalBinding: aClass environment strictReference bindingOrNil required: true.	aClass importDefinitions do: [:ref | 		self traceGlobalBinding: ref bindingOrNil required: true.		self traceLiteral: ref].	"Note - In RTP 5i.3 removed dead code left over from logic to	scan for references to items in dictionaries etc. This is not	needed since the references are detected via their bindings."		" external interfaces can reference items via their external dictionary "	(externalInterfaceClasses includes: aClass)		ifTrue:			[self addSentSelector: #resolveCTypeNamed:.	"Used for parcel loading"			aClass externals keys				do:					[:ext | ext isSymbol ifTrue: [self traceSelector: ext from: aClass]]].		self traceSentMessagesIn: aClass.	" see if there are kept methods that should be included "	(items keptMethods includesKey: aClass)		ifTrue:			[(items keptMethods at: aClass)				do: [:sel | self traceSelector: sel from: aClass]].	(items keptMethods includesKey: aClass class)		ifTrue:			[(items keptMethods at: aClass class)				do: [:sel | self traceSelector: sel from: aClass class]].	" look for special exits which provide additional directives "	(exitClasses includes: aClass)		ifTrue: [self traceDynamicItemsFrom: aClass].	" recursively do the same for the superclass, if any"	aClass superclass isNil ifFalse: [self traceClass: aClass superclass].</body><body package="RuntimePackager">traceClassPoolEntry: aVariableBinding	"Trace a class shared variable, and if that is a namespace or other collection, the contents of it. This is particularly significant for class pools that include references to other classes"	| binding |	binding := globalBindings at: aVariableBinding ifAbsent: [^nil].	( deletedGlobals includes: binding ) ifFalse: [		(referencedGlobals includes: binding) ifFalse: [			referencedGlobals add: binding.			binding value isBehavior				ifTrue: [self traceLiteral: binding value]				ifFalse: [					self traceLiteral: binding value class.					self traceStoredObject: binding value visited: IdentitySet new]]].</body><body package="RuntimePackager">traceCompoundSymbol: lit	"Trace selectors appearing in a compound symbol	in addition to those in a normal symbol"	" trace normal symbol references "	| idx1 |	self traceSymbol: lit.	" if symbol is a compound form, parse out the selectors	compound forms have selectors separated by spaces and	possibly by |"	idx1 := 1.	1 to: lit size		do: 			[:idx2 |			| ch |			ch := lit at: idx2.			(ch == Character space or: [ch == $|])				ifTrue: 					[idx2 &gt; idx1						ifTrue: [self addNewSelector: (lit copyFrom: idx1 to: idx2 - 1) asSymbol].					idx1 := idx2 + 1]].	(idx1 ~= 1 and: [idx1 &lt;= lit size])		ifTrue: [self addNewSelector: (lit copyFrom: idx1 to: lit size) asSymbol]</body><body package="RuntimePackager">traceDynamicItemsFrom: aClass	"Trace dynamic items identified via special class methods	The following methods are invoked where found:	- dynamicallyReferencedClasses	- dynamicallyReferencedGlobals	- dynamicallyReferencedSelectors	Each answers a collection of the object being referenced. Classes can be answered	as class objects, symbols naming the class , or as binding references.	Globals are similar. Selectors are answered as symbols naming the selector.	To allow flexibility, references to classes and globals that are not currently	loaded are allowed but ignored. Names of classes and globals are first resolved	in the environment of aClass and if not found, are resolved in the	Smalltalk name space."	| classes globals selectors dynamicClasses dynamicGlobals dynamicSelectors |		[" get dynamic items with some protection "	classes := (aClass class includesSelector: #dynamicallyReferencedClasses)				ifTrue: [aClass dynamicallyReferencedClasses]				ifFalse: [Array new].	globals := (aClass class includesSelector: #dynamicallyReferencedGlobals)				ifTrue: [aClass dynamicallyReferencedGlobals]				ifFalse: [Array new].	selectors := (aClass class				includesSelector: #dynamicallyReferencedSelectors)					ifTrue: [aClass dynamicallyReferencedSelectors]					ifFalse: [Array new].	" Convert the answers to a standard form"	" If a singleton was provided, make it a collection "	(classes isKindOf: Collection) ifFalse: [classes := Array with: classes].	(globals isKindOf: Collection) ifFalse: [globals := Array with: globals].	(selectors isKindOf: Collection)		ifFalse: [selectors := Array with: selectors].	" Look up items referenced "	dynamicClasses := classes collect: 					[:item |					| ref cl |					item isSymbol						ifTrue: 							[ref := aClass environment fullyQualifiedReference append: item.							ref isDefined ifFalse: [ref := item asQualifiedReference]]						ifFalse: [ref := item asQualifiedReference].					cl := ref valueOrDo: [nil].					cl isBehavior						ifTrue: [cl isMeta ifTrue: [cl soleInstance] ifFalse: [cl]]						ifFalse: [nil]].	dynamicGlobals := globals collect: 					[:item |					| ref |					item isSymbol						ifTrue: 							[ref := aClass environment fullyQualifiedReference append: item.							ref isDefined ifFalse: [ref := item asQualifiedReference]]						ifFalse: [ref := item asQualifiedReference].					ref isDefined ifTrue: [ref makeUnambiguous] ifFalse: [nil]].	dynamicSelectors := selectors select: [:item | item isSymbol]]			on: Error			do: 				[:ex |				(Dialog					choose: ex errorString							, '\\Error while obtaining dynamic items from \' withCRs , aClass fullName							, '\Dynamic items from this class will be ignored' withCRs					labels: #('OK' 'Debug')					values: #(#ok #debug)					default: #ok) == #ok					ifTrue: [^self]					ifFalse: [ex pass]].	" add items to the things to be traced "	newClasses addAll: (dynamicClasses select: [:item | item notNil]).	referencedGlobals addAll: (dynamicGlobals select: [:item | item notNil]).	self addNewSelectors: dynamicSelectors</body><body package="RuntimePackager">traceGlobalBinding: vb required: aBoolean	"Trace a variable binding to a global literal including those in class pools.	If this binding is required, then remove it from the deleted list. Otherwise if it's	not being deleted, include the class of the literal's value as referenced. Required 	means that this binding contains some kept value. If it is merely referenced, then	we don't override the deletion. The value of ValueHolders (but not subclasses	thereof)	are also included as referenced."	| binding realValue |	" look up the variable binding to get a standard binding reference, it any"	binding := globalBindings at: vb ifAbsent: [ ^nil ].	realValue := vb value.	aBoolean ifTrue: [deletedGlobals remove: binding ifAbsent: []].	( deletedGlobals includes: binding ) ifFalse: [		referencedGlobals add: binding.		((realValue isBehavior or: [realValue isNameSpace]) and: [realValue environment notNil]) 			ifTrue: [self traceGlobalBinding: realValue environment strictReference binding required: true].		realValue isBehavior			ifFalse: [				self traceLiteral: realValue class.				realValue class == ValueHolder ifTrue: [					self traceAllLiterals: realValue value ] ]			ifTrue: [				self traceAllLiterals: realValue ] ].</body><body package="RuntimePackager">traceLiteral: lit	"Trace a literal to detect sent selectors and referenced classes.	There are a number of special cases that are sifted through:	- for a class, add to the list to classes to scan	- for a binding to a class, add it to the classes to scan	- for a symbol, determine what it could be the name of and trace that	- for a binding reference, trace its value	- for an association, trace its value"	" look for a direct class or meta class reference.  These only	occur as a reference to the class itself. "	lit isBehavior ifTrue:  [		newClasses add: ( lit isMeta ifTrue: [ lit soleInstance ] ifFalse: [ lit ] ).		^self ].	" look for a reference via a variable binding "	lit isVariableBinding ifTrue: [		| vb |		vb := lit binding.		vb isForClass ifTrue: [ self traceLiteral: vb value. ].		(vb isForGeneral or: [vb isForNameSpace]) ifTrue: [ self traceGlobalBinding: vb required: false. ].		vb hasInitializer ifTrue: [ self traceBlockClosure: vb initializer. ].		^ self ].	" look for references to selectors and classes by name "	( lit isSymbol and: [ lit size &gt; 0 ] ) ifTrue: [		self traceSymbol: lit.		^self ].	" resolve binding references that appear as literals and trace that"	( lit isBindingReference ) ifTrue: [		self traceGlobalBinding: lit bindingOrNil required: false.		self traceLiteral: lit bindingOrNil.		^self  ].	" trace the value of an association, which is probably something rare "	lit class == Association ifTrue: [		self traceLiteral: lit value.		^self ].</body><body package="RuntimePackager">traceMessages	"Find all sent selectors by starting from the initial selectors and classes	and expanding as methods are examined for sent messages."	self invertClassesAndGlobals.	self invertSelectors.	self findPragmaMessages.	notifier log: 'Tracing sent messages '.	notifier tickRate: 1.	self traceOptionsReferences.	notifier tickRate: invertedSelectors size // 50.	" approximate guess "	[newClasses isEmpty and: [newSelectors isEmpty]] whileFalse: 			[self traceNewClasses.			self traceNewSelectors]</body><body package="RuntimePackager">traceMethod: aMethod	"Trace a compiled method to detect sent selectors and referenced classes."	| lits attributes done |   	(tracedMethods includes: aMethod) ifTrue:[ ^self ].   	tracedMethods add: aMethod.	notifier tick.	lits := self overriddenReferencesListForMethod: aMethod.	lits notNil ifTrue: [		lits do: [ :lit | self traceLiteral: lit ].		^self ].	done := OrderedCollection new.	attributes := aMethod homeMethod attributeMessages.	attributes isNil ifFalse: [		attributes do: [:eachMessage |			self traceMethodAttributeWithKey: eachMessage selector value: eachMessage arguments in: aMethod.			done add: eachMessage selector.			"We don't know that the arguments aren't compound selectors, but if they are, the worst thing that happens is we trace something twice"			done addAll: eachMessage arguments]].	lits := aMethod allLiterals.	(self methodIsResourceMethod: aMethod) 		ifTrue: [			lits do: [ :lit |				(done includes: lit) ifFalse: [					lit isSymbol						ifTrue: [ self traceCompoundSymbol: lit ]						ifFalse: [ self traceLiteral: lit ] ] ] ]		ifFalse: [			lits do: [ :lit | (done includes: lit) ifFalse: [self traceLiteral: lit ] ] ].	aMethod messages do: [ :sel |		( done includes: sel ) ifFalse: [ self traceLiteral: sel ] ].	" For ExternalMethods, include the result type name as a literal "	aMethod class == ExternalMethod ifTrue: [		self traceLiteral: aMethod resultType name ]</body><body package="RuntimePackager">traceMethodAttributeWithKey: aSelector value: argumentArray in: aMethod	"Trace something that's in the header list"	| references |	argumentArray do: [:eachArgument | self traceLiteral: eachArgument].	(aMethod mclass recognizedMethodPragmas includes: aSelector)		ifTrue: 			["This symbol represents a pragma. We don't know for sure what the pragma is going to use, so find methods in this hierarchy that reference both the symbol and the class Pragma, as the most likely things to be using it"			self addNewSelector: aSelector.			references := pragmaReferences select: 							[:eachMethod |							| classOne classTwo inTheRightHierarchy |							classOne := eachMethod mclass instanceBehavior.							classTwo := aMethod mclass instanceBehavior.							inTheRightHierarchy := classOne = classTwo										or: [(classOne inheritsFrom: classTwo) or: [classTwo inheritsFrom: classOne]].							inTheRightHierarchy and: [eachMethod allLiterals includes: aSelector]].			self addNewSelectors: (references collect: [:each | each selector])]</body><body package="RuntimePackager">traceNewClasses	| tempClasses |	notifier tick.	tempClasses := newClasses.	newClasses := IdentitySet new: tempClasses size * 3 // 2.	tempClasses do: [:cl | self traceClass: cl]</body><body package="RuntimePackager">traceNewSelectors	| tempSelectors |	notifier tick.	tempSelectors := newSelectors.	newSelectors := IdentitySet new: tempSelectors size * 3 // 2.	^tempSelectors do: [:sel | self traceSelector: sel]</body><body package="RuntimePackager">traceOptionsReferences	"Trace classes and methods mentioned in the options."	" trace startup class and method "	options startupClass notNil ifTrue: [		items includeStartupCode.		newClasses add: options startupClass.		self traceSelector: options startupMethod from: options startupClass class. ].	" trace error handler and image dumper -- note that selector is hard coded"	options errorNotifierClass notNil ifTrue: [		newClasses add: options errorNotifierClass.		self traceSelector: #notify:context: from: options errorNotifierClass class. ].	options imageDumperClass notNil ifTrue: [		newClasses add: options imageDumperClass. ].	" trace HeadlessImage if the options were selected "	options headlessImage ifTrue: [		newClasses add: ( #{HeadlessImage} valueOrDo: [ nil ] ) ].	" look for parcel action methods, which are always invoked.		unload functions are also used for references since they		can be invoked if the parcel is unloaded."	options loadableParcels do: [ :parcel |		Parcel binaryActions do:[ :action |			| blk |			blk := parcel propertyAt: action ifAbsent: [ nil ].			blk notNil ifTrue: [ self traceBlockClosure: blk ] ] ].	"postLoad: is sent to classes loaded through parcels.  If the parcel	is not being trimmed, this results in extra class references and they	need to be added to the collection of referenced classes to make	the postLoad: or initialize references visible"	options loadableParcels do: [ :parcel |		( options stripParcel: parcel name asString ) ifFalse: [			self initialClassesAdd: parcel definedClasses. ] ].	"Because of postLoad processing, any potentially loadable ExternalMethods	need to be examined for references to items that may define types"	options loadableMethods keysAndValuesDo: [ :cl :selectors |		selectors do: [ :sel |			| mth |			mth := cl compiledMethodAt: sel ifAbsent: [ nil ].			mth class == ExternalMethod ifTrue: [				self traceMethod: mth ] ] ].	" if compact methods are used, will need to add a reference to the special class used"	options useRuntimeCompiledMethod ifTrue: [		self initialClassesAdd: ( Array with: RuntimeCompiledMethod ) ].</body><body package="RuntimePackager">traceSelector: aSelector	"Examine the methods which send the selector to see if any of them	are included in referenced classes."	( sentSelectors includes: aSelector ) ifFalse: [		| methods |		self addSentSelector: aSelector.		methods := invertedSelectors at: aSelector ifAbsent: [ ^self "not a selector" ].		methods do: [ :mth |      	 " do not trace methods twice"      	 (tracedMethods includes: mth) ifFalse:[			" see if the class is being kept so far "			( referencedClasses includes: (				mth mclass isMeta					ifTrue: [ mth mclass soleInstance ]					ifFalse: [ mth mclass ] ) ) ifTrue: [				" make sure this method is not deleted "				( ( items deletedMethods includesKey: mth mclass ) and: [				( items deletedMethods at: mth mclass ) includes: aSelector ] ) ifFalse: [						" ok - trace the individual method "						self traceMethod: mth ] ] ] ] ].</body><body package="RuntimePackager">traceSelector: aSymbol from: aBehavior	"Trace the specific method referenced by aSymbol as implemented	in aBehavior or its superclasses"	| who |	who := aBehavior findSelector: aSymbol.	who notNil ifTrue: [		self traceMethod: (who at: 2).		self addReferencedSelector: aSymbol in: ( who at: 1 ). ].</body><body package="RuntimePackager">traceSentMessagesIn: aClass	"Trace the messages sent in this class, both class and instance methods"	self traceSentMessagesInClass: aClass.	self traceSentMessagesInClass: aClass class.</body><body package="RuntimePackager">traceSentMessagesInClass: aClass	"Trace the messages sent in this class, or that contain one of the class pragmas, on the theory that they're likely to be used reflectively. Note that this will do only instance methods. To find class methods, pass it a metaclass."	| deletedSel pragmas |	deletedSel := items deletedMethods at: aClass ifAbsent: [#()].	pragmas := aClass recognizedMethodPragmas.	(RuntimeManager selectorsInClass: aClass) do: 			[:eachSelector |			| sent method containsPragma |			(deletedSel includes: eachSelector)				ifFalse: 					[sent := sentSelectors includes: eachSelector.					method := aClass compiledMethodAt: eachSelector.					containsPragma := method attributeMessages notNil and: 									[method attributeMessages										anySatisfy: [:each | pragmas includes: each selector]].					sent | containsPragma						ifTrue: 							[self addNewSelector: method selector.							self traceMethod: method]]].	^self</body><body package="RuntimePackager">traceStoredObject: anObject visited: aSet	"Trace this object, and if it's a collection, its contents. Normally this is used for the contents of globals or shared variables. We aren't going to affect their contents directly if they're not namespaces, but we want to know what they hold so we know enough to trace the classes involved. Keep a local set to avoid infinite recursion for non-namespace collections that contain themselves. As soon as we get to something that involves a binding, it should stop anyway, so we only need to do this locally."	(aSet includes: anObject) ifTrue: [^self].	aSet add: anObject.	anObject isBehavior ifTrue: [^self traceLiteral: anObject].	self traceLiteral: anObject class.	anObject isNameSpace		ifTrue:			[anObject bindingsDo: [:each | self traceClassPoolEntry: each].			^self].	"This is awkward. We'd like to iterate over collections, but if we iterate over 'fake' collections like FixedPallette it takes an enormous amount of time. So restrict the types of things we iterate over to a minimal set of common collections we expect to see"	(self isCollectionWeShouldIterate: anObject)		ifTrue: [anObject do: [:each | self traceStoredObject: each visited: aSet]]		ifFalse: [self traceLiteral: anObject].</body><body package="RuntimePackager">traceSymbol: lit	"Trace the references implied by the symbol (lit)	These could be message sends ( a selector )	or a class named by the symbol."	" a few null symbols may be used in the system "	| simpleName index refClass |	lit size &gt; 0 ifFalse: [^self].	" treat each symbol reference as a message send"	(newSelectors includes: lit) ifTrue: [^self].	"been done "	self addNewSelector: lit.	"Lookup in inverted selectors happens later"	" expand an getter selector to its setter equivalent "	(lit last ~= $: and: [accessors includes: lit])		ifTrue: 			[Symbol hasInterned: lit , ':' ifTrue: [:sym | self addNewSelector: sym]].	" check for classes with that name -- all are assumed to be referenced "	newClasses addAll: (invertedClasses at: lit ifAbsent: [#()]).	" if the symbol happens to name a class that can be resolved as	a qualified reference trace that too. Look in inverted classes to avoid futile searches	and avoid useless symbol interns in the process."	index := lit lastIndexOf: $..	simpleName := index = 0				ifTrue: [lit]				ifFalse: [(lit copyFrom: index + 1 to: lit size) asSymbol].	(invertedClasses includesKey: simpleName)		ifTrue: 			[refClass := lit asQualifiedReference valueOrDo: [nil].			refClass isBehavior ifTrue: [newClasses add: refClass instanceBehavior]]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMessageTracer class</class-id> <category>instance creation</category><body package="RuntimePackager">new	^super new initialize</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderAppModel</class-id> <category>internals</category><body package="RuntimePackager">changeRequest	"An attempt is being made to close the window.	If changes have been made, confirm with user before close"	super changeRequest ifFalse: [ ^false ].	self isChanged ifTrue: [		( Dialog confirm:		'Changes have been made.\Do you want to discard them?'  withCRs )			ifFalse: [ ^false ] ].	^true</body><body package="RuntimePackager">isChanged	"Answer if a change has been made or is pending"	| widget |	isChanged ifTrue: [^true].	" look for pending changes from text fields due to auto accept "	self builder namedComponents keysAndValuesDo: 			[:compName :comp |			(((widget := comp widget) isKindOf: View) and: 					[(widget controller isKindOf: TextEditorController)						and: [widget controller textHasChanged]])				ifTrue: [^true]].	^false</body><body package="RuntimePackager">isChanged: aBoolean	"Force the check for if a change has been made or is pending"	isChanged := aBoolean.</body><body package="RuntimePackager">resetChanges	"Reset the indicator that changes have been made"	isChanged := false.</body><body package="RuntimePackager">update: anAspect	"Note that an aspect has changed"	anAspect == #value ifTrue: [		isChanged := true ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderAppModel</class-id> <category>initialize-release</category><body package="RuntimePackager">initialize	"Initialize the instance"	super initialize.	isChanged := false.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderAppModel</class-id> <category>interface opening</category><body package="RuntimePackager">open	"Open if needed.  Otherwise just bring to the front"	( self builder isNil or: [  self builder window isOpen not ] )		ifTrue: [ super open]		ifFalse: [  self builder window raise expand ]</body><body package="RuntimePackager">postBuildWith: aBuilder	"Set up dependencies to track changes"	self postBuildWith: aBuilder trackingChanges: true</body><body package="RuntimePackager">postBuildWith: aBuilder trackingChanges: aBoolean	"Set up dependencies to track changes"	super postBuildWith: aBuilder.	aBoolean ifTrue: [		aBuilder bindings keysAndValuesDo: [ :aspect :binding |			( binding isKindOf: Model ) ifTrue: [				binding addDependent: self ] ] ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderAppModel</class-id> <category>help</category><body package="RuntimePackager">overviewHelp	"Open a general help window"	RuntimeBuilderUI helpFor: #helpForOverview.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor</class-id> <category>actions</category><body package="RuntimePackager">accept	"Accept the input if valid.  Answer true if the contents are valid	and the window can be closed."	| valid |	( valid := self validate ) ifTrue: [		self isChanged ifTrue: [			self copyValuesToSubject.			self subject changed.			isChanged := false. ].		self terminateEdit.		self closeRequest. ].	^ valid</body><body package="RuntimePackager">cancel	"Discard any values input and close the window"	self terminateEdit.	isChanged := false.	self closeRequest.</body><body package="RuntimePackager">refresh	"refresh the view with new values in the subject."	super initialize.	self copyValuesFromSubject.	warnings := IdentitySet new.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor</class-id> <category>internals</category><body package="RuntimePackager">changeRequest	"An attempt is being made to close the window.	If changes have been made, confirm with user before close"	super changeRequest ifFalse: [ ^false ].	self terminateEdit.	^true</body><body package="RuntimePackager">copyValuesFromSubject	"Copy values from the options into receivers	aspects (ValueHolders)"	self subclassResponsibility</body><body package="RuntimePackager">copyValuesToSubject	"Copy values from the options into receivers	aspects (ValueHolders)"	subject hasBeenEdited: true.</body><body package="RuntimePackager">terminateEdit	"Terminate the edit on the subject, if any"	subject isNil ifFalse: [ subject terminateEdit ].</body><body package="RuntimePackager">update: anAspect with: aParam from: anObject	"If an aspect is changed, remove it from already issued	warnings dictionary"	warnings remove: anObject ifAbsent: [ ].	super update: anAspect with: aParam from: anObject.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor</class-id> <category>name spaces</category><body package="RuntimePackager">classIsDefinedWithName: aString	"Answer true if the class fully named in aString is defined"	| class |	class := self classNamed: aString.	^ class notNil and: [		class isBehavior and: [		class isMeta not ] ]</body><body package="RuntimePackager">classNamed: aString	"Convert the full name provided in aString into a class.	Answer nil if not found"	^ self classNamed: aString ifAbsent: [ nil ]</body><body package="RuntimePackager">classNamed: aString ifAbsent: aBlock	"Convert the full name provided in aString into a class.	Answer the value of aBlock if not found"	^aString asString asQualifiedReference valueOrDo: aBlock</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor</class-id> <category>initialize-release</category><body package="RuntimePackager">initialize	"Initialize the instance"	super initialize.	self copyValuesFromSubject.	warnings := Set new.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor</class-id> <category>accessing</category><body package="RuntimePackager">subject	"answer the RuntimeBuilderOptions being editted."	^subject</body><body package="RuntimePackager">subject: anObject	"Set the RuntimeBuilderOptions being editted."	subject := anObject</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor</class-id> <category>validations</category><body package="RuntimePackager">validate	"Validate all fields. Answer true if all validations are passed.	Typically this is overridden in subclasses"	^true</body><body package="RuntimePackager">validatePositive: anAspect	"Check that an aspect has a postive numeric value" 	| aspectValue |	aspectValue := ( self perform: anAspect) value.	( aspectValue &lt;= 0) ifTrue: [		( self builder componentAt: anAspect ) takeKeyboardFocus.		Dialog warn: 'Value must be positive'.		^ false ].	^true</body><body package="RuntimePackager">validateRange: anAspect low: low high: high	"Check that an aspect is within the range provided" 	| aspectValue |	aspectValue := ( self perform: anAspect) value.	( aspectValue &lt; low or: [ aspectValue&gt; high ] ) ifTrue: [		( self builder componentAt: anAspect ) takeKeyboardFocus.		Dialog warn: 'Value is out of range'.		^ false ].	^true</body><body package="RuntimePackager">validateRequiredValue: anAspect	"Check that a required value has been provided" 	| aspectValue |	aspectValue := ( self perform: anAspect ) value.	( aspectValue = 0 or: [ aspectValue = '' ] ) ifTrue: [		( self builder componentAt: anAspect ) takeKeyboardFocus.		Dialog warn: 'A value is required value is missing'.		^ false ].	^true</body><body package="RuntimePackager">warn: aString about: anObject	"If a warning has not previously been issued about this object	(typically a value holder for an aspect) issue one to the user.	Answer true if the warning was issued"	( warnings includes: anObject ) ifFalse: [		warnings add: anObject.		^ ( Dialog choose: aString			labels: #( 'Correct the error' 'Ignore this warning' )			values: #( #correct #ignore )			default: #correct ) == #correct ].	^false.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor class</class-id> <category>internals</category><body package="RuntimePackager">decodeFromLiteralArray: anArray	"Answer the result of sending a message to self.	This is useful in building menus of menus"	^self perform: (anArray at: 2)</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor class</class-id> <category>actions</category><body package="RuntimePackager">choose: aString fromList: aList	"Prompt the user to choose from the list provided and answer	the item choosed.  If nothing is chosen, answer nil"	^(IncrementalSearchDialog			forSelectionWithSearch:				[:pattern |				pattern isEmpty					ifTrue: [aList]					ifFalse: [aList select: [:each | pattern , '*' match: each]]])		windowLabel: aString;		firstLabel: (#FilterC &lt;&lt; #browser &gt;&gt; 'Filter:');		secondLabel: #MethodsC &lt;&lt; #browser &gt;&gt; 'Methods:';		select.</body><body package="RuntimePackager">findClass: prompt where: aBlock	"Prompt for a class.  Answer the class name selected or nil if none.	Prompt is the string shown to the user in solicting the name."	| dialog |	dialog := IncrementalSearchDialog forSelectionWithSearch: [:pattern |		Root allClasses select: [:each | (aBlock value: each) and: [('*', pattern, '*') match: each name]]].	dialog windowLabel: prompt.	dialog firstLabel: (#FilterC &lt;&lt; #browser &gt;&gt; 'Filter:').	dialog secondLabel: (#ClassesC &lt;&lt; #browser &gt;&gt; 'Classes:').	^dialog select.</body><body package="RuntimePackager">findClassName: prompt	"Prompt for a class.  Answer the class name selected or nil if none.	Prompt is the string shown to the user in solicting the name."	|  classFound |	classFound :=  self findClass: prompt where: [ :cl | true ].	^classFound isNil ifTrue: [ nil ] ifFalse: [ classFound fullName ]</body><body package="RuntimePackager">findClassName: prompt where: aBlock	"Prompt for a class.  Answer the class name selected or nil if none.	Prompt is the string shown to the user in solicting the name."	| classFound |	classFound := self findClass: prompt where: aBlock.	^classFound isNil ifTrue: [ nil ] ifFalse: [ classFound fullName ]</body><body package="RuntimePackager">findSelectorUnderstoodBy: aClass where: aBlock	"Prompt for a selector understood by the class provided.	aBlock is evaluationed with each possible selector and only	those which evaluate to true are considered as possibilities.	Answer nil if none selected."	|  classes selectorList selectedMethod classSelectors |	classes := OrderedCollection new: 12.	classes add: aClass.	[ classes last superclass notNil ] whileTrue: [		classes addLast: classes last superclass ].	selectorList := OrderedCollection new: classes size * 15.	classes do: [ :cl |		classSelectors := cl class selectors select: aBlock.		classSelectors isEmpty ifFalse: [			selectorList addAll: classSelectors ] ].	selectorList isEmpty ifTrue: [		Dialog warn: 'No suitable methods were found'.		^ nil ].	selectorList := selectorList asSet asSortedCollection.	selectedMethod := nil.	[	selectedMethod := self choose: 'Select a method' fromList: selectorList.		selectedMethod isNil ifTrue: [ ^ nil ].		selectedMethod isSymbol ifTrue: [ ^selectedMethod ].		( Dialog confirm: 'An invalid selection was made.\Try again?' withCRs )	] whileTrue: [].	^nil</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor class</class-id> <category>instance creation</category><body package="RuntimePackager">on: subject	"Answer an instance with the subject set to the RuntimeBuilderOptions	supplied"	^self basicNew subject: subject; initialize.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor class</class-id> <category>interface opening</category><body package="RuntimePackager">open	"Editors are not usually opened by themselves"	Dialog warn: 'This window can not be opened without a subject to edit'</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderClassChooser</class-id> <category>internals</category><body package="RuntimePackager">allClassesAndBindingReferencesDo: aBlock	"Copied from BrowserEnvironment's bindingReferencesDo:, but actually creating the binding references in the real namespace that owns them, and not filtering"	"self basicNew allClassesAndBindingReferencesDo: [:each | each yourself]"	Root withAllNameSpacesDo: [:ns | 		| ref |		ref := ns fullyQualifiedReference.		ns bindingsDo: [:each | aBlock value: (each isForClass ifTrue: [each value] ifFalse: [ref append: each key])]].	Root allBehaviorsDo: [:cls | 		cls isMeta ifFalse:			[cls asNameSpace bindingsDo: [:each | 				| ref |				ref := cls fullyQualifiedReference.				aBlock value: (each isForClass ifTrue: [each value] ifFalse: [ref append: each key])]]].</body><body package="RuntimePackager">buildCategoryList	"Build the list of all system categories or applications"	self categoryListTitle value: ('Packages/Bundles (&lt;1p&gt; selected)' expandMacrosWith: self systemPackagesTree selections size) asText allBold.</body><body package="RuntimePackager">buildSelectableClassList	"Build a list of classes that can be selected based on current	category selections. The list contains entries of associations	where the key is the name of the class in text and the value	is the class. The name is italic if the class is not defined	in one of the applications/categories selected"	self buildSelectableClassListFor: self systemCategoriesList selections.</body><body package="RuntimePackager">buildSelectableClassListFor: pundles	"Build a list of classes that can be selected based on current	category selections. The list contains entries of associations	where the key is the name of the class in text and the value	is the class. The name is italic if the class is not defined	in one of the applications/categories selected."	" initialize sets that are built one category/application at a time"	selectableClasses := IdentitySet new.	definedClasses := IdentitySet new.	bindingsInCurrentlySelected := IdentitySet new.	selectedSubapplications := IdentitySet new.	pundles do: [ :eachPundle |		self addClassesInPundle: eachPundle ].	" now build the list of selectable classes and globals "	selectableClassList := List new.	selectableClassList addAll: ( bindingsInCurrentlySelected collect: [:ref |		( Text string: ' Data ' emphasis: #italic ), ref toolListDisplayString  -&gt; ref ] ).	selectableClasses do: [ :cl |		( definedClasses includes: cl )			ifTrue: [ selectableClassList add: ( cl fullyQualifiedReference toolListDisplayString asText -&gt; cl) ]			ifFalse: [ selectableClassList add: ( Text string: cl fullyQualifiedReference toolListDisplayString emphasis: #italic ) -&gt; cl] ].	" sort by name "	selectableClassList sort.</body><body package="RuntimePackager">categoriesForClass: aClassOrBindingReference	"Answer a collection of the appropriate category, application,	or subapplication depending on the current display mode."	| paths immediatePackages |	immediatePackages := (aClassOrBindingReference isBehavior)		ifTrue: [Store.Registry packagesContaining: aClassOrBindingReference]		ifFalse: [			(aClassOrBindingReference value isNameSpace and: [aClassOrBindingReference environment isBehavior not])				ifTrue: ["This is a 'global' namespace, rather than a class shared. This is odd, in that we have to ask for					Store.Registry containingPackageForNameSpace: Kernel.UI,  but					Store.Registry allContainingPackagesForDataKey: #Processor owner: Kernel"					(Array with: (Store.Registry containingPackageForNameSpace: aClassOrBindingReference value))]				ifFalse: [Store.Registry 					allContainingPackagesForDataKey: aClassOrBindingReference name 					owner: aClassOrBindingReference environment]].	paths := immediatePackages inject: Array new into: [:sum :each |		sum, (self containmentPathsFor: each)].	^paths.</body><body package="RuntimePackager">classesMatching: aBlock 	"Copied from the RB"	| names |	names := Set new.	self allClassesAndBindingReferencesDo: [:each | (aBlock value: each) ifTrue: [names add: each]].	^names</body><body package="RuntimePackager">containmentPathsFor: aPundle	| parents |	parents := (Store.Registry enclosingComponentsFor: aPundle) asArray.	parents isEmpty ifTrue: [^Array with: (Array with: aPundle)].	^parents inject: OrderedCollection new into: [:allPaths :eachParent |		allPaths addAll: ((self containmentPathsFor: eachParent) collect: [:eachPath |			eachPath, (Array with: aPundle)]).		allPaths].</body><body package="RuntimePackager">expressInterests	"Setup interests in changed window contents"	self systemCategoriesList selectionIndexHolder		onChangeSend: #systemCategoriesSelectionChanged to: self.</body><body package="RuntimePackager">findPackage: prompt	"Prompt for a category.  Answer the category name selected or nil if none.	Prompt is the string shown to the user in solicting the name."	| dialog thePundle |	dialog := IncrementalSearchDialog 		forSelectionFrom: (Store.Registry allPundles)		filterBlock: [:entry :pundle | entry, '*' match: pundle name].	dialog		windowLabel: #FindPackageOrBundle &lt;&lt; #browser &gt;&gt; 'Find Package or Bundle';		firstLabel: #FilterC &lt;&lt; #browser &gt;&gt; 'Filter:';		secondLabel: #PackagesAndBundlesC &lt;&lt; #browser &gt;&gt; 'Packages and Bundles:';		objectToStringBlock: [:pundle | pundle name];		iconSelector: #toolListIcon.	thePundle := dialog select.	^thePundle.</body><body package="RuntimePackager">movableClassesFrom: selections	"Answer the classes in selections that are not extensions.	selections is a collection of associations in which the actual	class is the value of the association. If the value is a symbol,	it represents a global, which can always be moved"	| classes |	classes := OrderedCollection new.	selections do: [ :assoc |		(definedClasses includes: assoc value  )			ifTrue: [ classes add: assoc value ] ].	^classes</body><body package="RuntimePackager">moveClassSelectionsFrom: fromMS to: toMS	"Move the items selected in fromMS (a MultiSelectionInList) to	toMS (also a MultSelectionInList).  Answer the selections moved.	Only move entries associated with defined classes or globals"	| selections |	selections := fromMS selections select: [ :sel |		sel value isBindingReference or: [ definedClasses includes: sel value ] ].	^self moveSelectionsFrom: fromMS to: toMS selections: selections</body><body package="RuntimePackager">moveSelectionsFrom: fromMS to: toMS	"Move the items selected in fromMS (a MultiSelectionInList) to	toMS (also a MultSelectionInList).  Answer the selections moved."	^self moveSelectionsFrom: fromMS to: toMS selections:fromMS selections</body><body package="RuntimePackager">moveSelectionsFrom: fromMS to: toMS selections: selections	"Move the items selected in fromMS (a MultiSelectionInList) to	toMS (also a MultSelectionInList).  Answer the selections moved."	| selSet  toList |	"optimize some common cases"	selections isEmpty ifTrue: [		^OrderedCollection new ].	" handle the general case "	selSet := selections asSet.	fromMS list: ( fromMS list reject: [ :x | selSet includes: x ] ).	toList := toMS list.	toMS list: List new.  "Temporarily break a relationship"	toList addAll: selections; sort.	toMS list: toList. "Restore the relationship"	self setSelections: selSet in: toMS.	^selections</body><body package="RuntimePackager">nameSpaceTreeFrom: aNameSpace	"Answer a tree containing the name space with its contained	name spaces as children. If aNameSpace is nil, start from Root.	The top level key is not shown in the hierarchial list, so this allows	Root to appear."	| tree bindings |	aNameSpace isNil ifTrue: [		tree := AssociationTreeWithParent key: 'nil' value: nil.		tree addChild: (self nameSpaceTreeFrom: Root ).		^tree ].	tree := AssociationTreeWithParent key: aNameSpace name value: aNameSpace.	bindings := OrderedCollection new.	aNameSpace bindingsDo: [ :binding |		( binding isForNameSpace and: [		binding value isObsolete not and: [		binding value ~~ Undeclared ] ] ) ifTrue: [ bindings add: binding ] ].	" sort the name spaces by name and add recursively "	( bindings asSortedCollection: [ :x :y | x key &lt; y key ] ) do: [ :binding |		tree addChild: ( self nameSpaceTreeFrom: binding value ) ].	^tree</body><body package="RuntimePackager">referencesMatchingPartialName: aString	"Copied from the RB"	| pattern matches nameSelector |	aString trimBlanks isEmpty ifTrue: [^Array new].	pattern := aString trimBlanks.	pattern := (pattern includes: $*) ifTrue: [pattern] ifFalse: ['*', pattern, '*'].	nameSelector := (pattern includes: $.) ifTrue: [#fullName] ifFalse: [#name].	matches := self classesMatching: [:each | pattern match: (each perform: nameSelector)].	^matches asSortedCollection: [:a :b | a toolListDisplayString &lt; b toolListDisplayString]</body><body package="RuntimePackager">retractInterests	"Retract interests in changed window contents"	self systemCategoriesList selectionIndexHolder		retractInterestsFor: self.</body><body package="RuntimePackager">setSelectionOnValues: aCollection in: msl	"Set the selections in msl (aMultiSelectionInList) to match	the values contained in aCollection."	| selSet indexes |	selSet := Set new: aCollection size * 3 // 2.	aCollection do: [ :x | selSet add: x value ].	indexes := Set new: aCollection size * 3 // 2.	1 to: msl list size do: [ :i |		( selSet includes: (msl list at: i ) value ) ifTrue: [			indexes add: i ] ].	msl selectionIndexes: indexes.</body><body package="RuntimePackager">setSelections: aCollection in: msl	"Set the selections in msl (aMultiSelectionInList) to aCollections.	This is conceptually the same as the selections: method, but faster	when there are many selections."	| selSet indexes |	aCollection size &lt; 3		ifTrue: [ msl selections: aCollection ]		ifFalse: [			selSet := aCollection asSet.			indexes := Set new: aCollection size * 3 // 2.			1 to: msl list size do: [ :i |				( selSet includes: (msl list at: i ) ) ifTrue: [					indexes add: i ] ].			msl selectionIndexes: indexes. ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderClassChooser</class-id> <category>aspects</category><body package="RuntimePackager">categoryListTitle	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^categoryListTitle isNil ifTrue: [categoryListTitle := Text new asValue] ifFalse: [categoryListTitle]</body><body package="RuntimePackager">nameSpaceList	"Answer the list of system category (organization) names"	^nameSpaceList isNil		ifTrue: [nameSpaceList := IndentedTreeSelectionInList newEmptyInstance]		ifFalse: [nameSpaceList]</body><body package="RuntimePackager">systemCategoriesList		self subclassResponsibility</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderClassChooser</class-id> <category>actions</category><body package="RuntimePackager">clearAllCategories	"Clear all system categories in the selection list"	self systemCategoriesList treeHolder selectionIndexes: OrderedCollection new.</body><body package="RuntimePackager">findCategoryWithGlobal	"Prompt for a class and select the category containing it.	Answer the class selected or nil if none"	|  dialog bindingRef |	dialog := IncrementalSearchDialog forSelectionWithSearch:		[:entry | self referencesMatchingPartialName: entry].	dialog		windowLabel: #FindPackageForClassVariableOrNameSpace &lt;&lt; #browser &gt;&gt; 'Find Package for Class, Variable, or Name Space';		firstLabel: #FindC &lt;&lt; #browser &gt;&gt; 'Find:';		secondLabel: #ClassesNamespacesAndVariablesC &lt;&lt; #browser &gt;&gt; 'Classes, Variables, Name Spaces:';		iconSelector: #toolListIcon;		displayStringSelector: #toolListDisplayString;		objectToStringBlock: [:class | class name asString].	bindingRef := dialog select.	bindingRef isNil ifTrue: [^nil].	bindingRef notNil ifTrue: [		self findCategoryWithGlobal: bindingRef. ].	^bindingRef</body><body package="RuntimePackager">findCategoryWithGlobal: aGlobal	"Prompt for a class and select the category containing it."	|  selectedPackagePaths |	selectedPackagePaths := self categoriesForClass: aGlobal.	selectedPackagePaths isEmpty ifTrue:[ ^nil ].	self systemCategoriesList treeHolder selectionIndexes: OrderedCollection new.	selectedPackagePaths do: [:eachCollection |		self systemCategoriesList addSelectPath: eachCollection].	"Multiselection tree views don't correctly make things visible in 7.3.1"	(self systemCategoriesList widgetAt: #treeList) makeVisible: self systemCategoriesList treeHolder selectionIndexes first.</body><body package="RuntimePackager">findPackage	"Prompt for a category and select it."	| package paths |	package := self findPackage: 'Find and select package/bundle'.	package isNil ifTrue: [ ^nil ].	paths := self containmentPathsFor: package.	self systemCategoriesList treeHolder selectionIndexes: OrderedCollection new.	paths do: [:each |		self systemCategoriesList addSelectPath: each].	"Multiselection tree views don't correctly make things visible in 7.3.1"	(self systemCategoriesList widgetAt: #treeList) makeVisible: self systemCategoriesList treeHolder selectionIndexes first.</body><body package="RuntimePackager">nameSpaceSelectionChanged	"Respond to a change in selections among name spaces."	(self systemCategoriesList selections isEmpty 		and: [self nameSpaceList selection notNil]) 			ifTrue: [self selectAllCategories]			ifFalse: [self systemCategoriesSelectionChanged]</body><body package="RuntimePackager">refresh	"Reset current selections if the underlying data has changed."	self systemCategoriesList treeHolder selectionIndexes: OrderedCollection new.	super refresh.</body><body package="RuntimePackager">selectAllCategories	"Select all system categories in the selection list"	self systemCategoriesList treeHolder selectAll.</body><body package="RuntimePackager">systemCategoriesSelectionChanged	"Respond to a change in selections among system categories."	self subclassResponsibility.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderClassChooser</class-id> <category>interface opening</category><body package="RuntimePackager">postBuildWith: aBuilder trackingChanges: aBoolean	"Initialize after the builder is done"	super postBuildWith: aBuilder trackingChanges: aBoolean.	self buildCategoryList.	self expressInterests.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderClassChooser</class-id> <category>accessing</category><body package="RuntimePackager">systemPackagesTree	self subclassResponsibility.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderClassChooser class</class-id> <category>resources</category><body package="RuntimePackager">systemSelectionMenu	^self subclassResponsibility.</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier</class-id> <category>internal</category><body package="RuntimePackager">checkForErrorRecursion	"Make sure there was not a recursive error, that is,	an error arising while handling a different error.	ErrorProcess holds only the most recent error process to allow errors to arise	within multiple processes. No semaphores are used for synchronization to avoid	the possibility that an infinite wait could result. Multiple simultaneous	entries into this logic are possible, but very unlikely and mostly harmless"	self class errorState isNil ifTrue: [^self].	"check to see if we are in debug mode before shutting down"	self debugNotifierMode ifTrue: [		RuntimeManager unhookNotifierClass.		self halt: 'Recursive error condition in notifier under test'].	^super checkForErrorRecursion.</body><body package="RuntimePackager">classifyException	"Classify an exception as to its type."	self exceptionType: #other.	"Default"	"is this a halt?"	self exception creator == Object haltSignal 		ifTrue: 			[self exceptionType: #halt.			^self].	"is this a notify?"	self exception creator == Object notifySignal 		ifTrue: 			[self exceptionType: #notify.			^self].	"check for types of user interrupt. Note that low space is a user interrupt."	self exception creator == UserInterrupt 		ifTrue: 			[self exceptionType: #userInterrupt.			^self].	self exception creator == LowSpaceInterrupt 		ifTrue: 			[self exceptionType: #lowSpace.			^self].</body><body package="RuntimePackager">inferMissingData	"Fill out missing values based on what was provided"	"if no exception was passed initially find one"	self exception isNil ifTrue: [		self exception: self findException ].	"if proceedability was not indicated, take it from the exception"	self isProceedable isNil ifTrue: [		self isProceedable: self exception isResumable ].	"in the case where no context was provided explicitly, it should	be the parameter for the exception."	self context isNil ifTrue: [		self context: self exception initialContext sender ].	"determine the type of exception"	self classifyException.</body><body package="RuntimePackager">quitImage	RuntimeManager quitImageException.</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier</class-id> <category>actions</category><body package="RuntimePackager">createDump	"Create a dump that is appropriate for the runtime image.  If the interrupt was from the user, then	 check with the user first, to see if they want to quit the image.  If they do, then write the dump and 	 quit the image.  If the request to create a runtime image dump was not caused by an user interrupt,	 then write the dump file and quit the image."		| userNotified dumpWorked |	self isHeadless ifTrue: [^self createEmergencyDump].	userNotified := false.	self cleanUpUserInterface.	self isInterruptFromUser		ifTrue:			[userNotified := true.			self confirmUserInterruptRequest				ifFalse:					[self class resetErrorState.					^self proceedAfterUserInterrupt]].	dumpWorked := self createEmergencyDump.	userNotified ifFalse: [self notifyUserOfUnhandledException: dumpWorked].		"Finally, terminate the image. "	self class errorState: #quitting.	RuntimeManager quitImageException</body><body package="RuntimePackager">createEmergencyDump	"If RuntimeImageDumper is defined, create a dump log unless #dumpLogTo: fails with an OsError. If the dump fails due to an OsError and the image is not headless alert the user of an error saving the dump file and ask for a new pathname until the dump is successful or the user cancels.    Answer true if the dump succeeded or false otherwise. Also answer true if no dump is requested, as in the case where RuntimeImageDumper isNil."	self imageDumperClass ifNil: [^true].	errorFilename := self initialDumpPathString.	errorFilename := self validDumpFilenameFrom: errorFilename asString.		^[		errorFilename := self ensureDumpFilenameIsWritable: errorFilename.		errorFilename isNil			ifTrue: [false]			ifFalse: [self dumpLogTo: errorFilename].	  ] on: OsError	    do: [:ex | self requestNewValidFilenameAfterError: ex].</body><body package="RuntimePackager">proceedAfterUserInterrupt	"Proceed carefully after a user interrupt.  When event driven windows are	interrupted, event queue synchronization errors can result.  This case is	recognized and the exception is dismissed.  Since there is nothing going	on at the time anyway, the effect is the same.  This is all just a work-around	for what is probably a bug in the event queue mechanism"	self canProceedAfterUserInterrupt ifFalse: [		self dismissException ].	" otherwise we can just proceed as normal "	^self exception proceed</body><body package="RuntimePackager">proceedExceptionOr: aBlock 	"See if this notifier is being tested and if so open a normal debugging notifier."	self debugNotifierMode 		ifTrue: 			[RuntimeManager unhookNotifierClass.			self halt: 'Halted in notifier under test'].	"Fill out missing information depending on which instantiation	technique was used. This is done after the recursive error test	to catch problems finding the missing ingredients."	self inferMissingData.	"Check for proceedable signal that can proceed."	self isProceedable 		ifTrue: 			[self canProceedableExceptionProceed 				ifTrue: 					[self class resetErrorState.					self exception proceed]].	^aBlock value</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier</class-id> <category>testing</category><body package="RuntimePackager">canProceedAfterHalt	"Answer whether halts are to be automatically proceeded. The default is true	but this can be overridden in subclasses"	^true</body><body package="RuntimePackager">canProceedAfterUserInterrupt	"Answer true if a user interrupt can proceed.  When event driven windows are	interrupted, event queue synchronization errors can result.  This case is	recognized and false is answered."	|  queueClass nextClassAndMethod semaphoreClass	waitClassAndMethod ctx foundNext foundWait counter |	"obviously, the exception must be proceedable"	self isProceedable ifFalse: [ ^false ].	" locate the things needed to search the context stack "	queueClass := #{EventQueue} valueOrDo: [ ^true ].	( nextClassAndMethod := queueClass findSelector: #next ) isNil		ifTrue: [ ^ true ].	semaphoreClass := #{Semaphore} valueOrDo: [ ^false ].	( waitClassAndMethod := semaphoreClass findSelector: #wait ) isNil		ifTrue: [ ^true ].	" now look through the stack for Semaphore&gt;&gt;wait and EventQueue&gt;&gt;next "	ctx := self context.	foundNext := false.	foundWait := false.	counter := 0.	[ foundNext not and: [ ctx notNil and: [ counter &lt; 10 ] ] ] whileTrue: [		( ctx receiver class == semaphoreClass and: [			ctx method == waitClassAndMethod last ] )			ifTrue: [ foundWait := true ].		( ctx receiver class == queueClass and: [			ctx 	method == nextClassAndMethod last ] )			ifTrue: [ foundNext := true ].		ctx := ctx sender.		counter := counter + 1 ].	" if the problem children methods are found,	then there is no way to proceed without causing an error"	foundNext &amp; foundWait ifTrue: [ ^false ].	" otherwise we can just proceed as normal "	^true</body><body package="RuntimePackager">canProceedOnLowSpaceWarning	"Answer true if the current low space warning is to be proceeded.	This can be overridden in subclasses"	^false</body><body package="RuntimePackager">canProceedableExceptionProceed	"Answer true if the current exception can proceed and false if not.	By default halts are allowed to proceed, but this can be overridden.	Low space warnings are generally not allowed to proceed.	This test can be overridden in subclasses."	" ignore a halt "	self exceptionType == #halt		ifTrue: [ ^ self canProceedAfterHalt ].	"Look for a low space warning"	self exceptionType == #lowSpace		ifTrue: [			^self canProceedOnLowSpaceWarning ].	" other cases do not proceed automatically"	^false</body><body package="RuntimePackager">isHeadless	"Answer true if this image is operating in headless mode"	^RuntimeManager isHeadless</body><body package="RuntimePackager">isInterruptFromUser	"Answer true if the exception really is from the user versus other	unrelated ways of raising the userInterruptSignal such as low memory."	" must be a user interrupt signal"	^( self exceptionType == #userInterrupt and: [		self exception isResumable ] )</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier</class-id> <category>private</category><body package="RuntimePackager">ensureDumpFilenameIsWritable: aFilenameOrNil	"Return aFilenameOrNil if it is writable. If aFilenameOrNil is nil, it represents the user's attempt to cancel, so return nil.  If the parent directory does not exist, try to create it first.  If that fails prompt for a new location."		^(aFilenameOrNil isNil		or:			[aFilenameOrNil directory ensureDirectory.			aFilenameOrNil canBeWritten])		ifTrue: [aFilenameOrNil]		ifFalse:			[self				requestValidFilenameIfHeadful:					#unwritableErrorLog &lt;&lt; #dialogs &gt;&gt;							'Unwritable file.  Please specify a writable file for the error log:'				default: aFilenameOrNil asString]</body><body package="RuntimePackager">initialDumpPathString	| path |	path := self errorLogPath isNil		ifTrue: [String new]		ifFalse: [self errorLogPath].	(path respondsTo: #asResolvedString)		ifTrue: [path := path asResolvedString].	^path</body><body package="RuntimePackager">requestNewValidFilenameAfterError: ex	"There's been an error in writing out the log (e.g. disk full, disk error, no permissions). If we have a GUI available, ask the user if they want to try another filename, or just give up and quit. If there's no GUI, then just quit"	self isHeadless ifTrue: [ex return: false].	^(RuntimeManager hiddenReferenceTo: 'Dialog') 			ifNil: [false]			ifNotNil: 				[:dialogClass |  | tryToContinue |				"An OS error has prevented dump completion.  Ask the user for an alternate dump file and retry"				tryToContinue := (dialogClass 					choose: (#unableToWriteLog &lt;&lt; #dialogs &gt;&gt; 'Unable to write log: &lt;1s&gt;' 							expandMacrosWith: ex messageText)					labels: (Array 							with: #chooseNewDestination &lt;&lt; #dialogs &gt;&gt; 'Choose new destination'							with: #runtimeAbort &lt;&lt; #labels &gt;&gt; 'Quit without writing error log')					values: #(true false)					default: true).				tryToContinue 					ifTrue: [						errorFilename := self 							requestValidFilenameIfHeadful: #invalidLogFileName &lt;&lt; #dialogs 									&gt;&gt; 'Invalid file name.  To what file should errors be written?'							default: errorFilename asString.						ex retry]					ifFalse: [false]].</body><body package="RuntimePackager">requestValidFilenameIfHeadful: messageString default: defaultString	"Ask the user to supply a filename.  Answer the resulting string, or answer nil if headless or if Dialog is undefined."	| dialogClass newFileString |	(self isHeadless or: [(dialogClass := RuntimeManager hiddenReferenceTo: 'Dialog') isNil])		ifTrue: [^nil].	newFileString :=		dialogClass				requestFileName: messageString				default: defaultString.	^self validDumpFilenameFrom: newFileString</body><body package="RuntimePackager">showBusyWhile: aBlock	| cursorClass |	^(self isHeadless or: [(cursorClass := RuntimeManager hiddenReferenceTo: 'Cursor') isNil])		ifTrue: [aBlock value]		ifFalse: [cursorClass write showWhile: aBlock].</body><body package="RuntimePackager">validDumpFilenameFrom: aStringOrNil	"Return the filename representation of aStringOrNil, or nil.  Prompt the user for a new file if aString does not represent a valid filename. If aString is empty or nil, this represents the user's attempt to cancel, or an abort of the prompt when running headless, so return nil."	^(aStringOrNil isNil or: [aStringOrNil isEmpty])		ifTrue: [nil]		ifFalse: 			[[aStringOrNil asFilename]				on: Error				do:	[:ex |					self						requestValidFilenameIfHeadful: #invalidLogFileName &lt;&lt; #dialogs &gt;&gt;							'Invalid file name.  To what file should errors be written?'						default: aStringOrNil]]</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier</class-id> <category>accessing</category><body package="RuntimePackager">debugNotifierMode	"Answer true if the notifier is being tested and the standard debugger is used	to follow its progress"	^self class debugNotifierMode == true</body><body package="RuntimePackager">errorLogPath	"Answer the name of the file used to contain the image dump.	Expanded the string using current environment variables (if supported)	This can be overridden in subclasses"	^RuntimeManager errorLogPath</body><body package="RuntimePackager">exceptionType	"Answer the type of the exception"	^exceptionType</body><body package="RuntimePackager">exceptionType: aSymbol	"Set the type of the exception"	exceptionType := aSymbol.</body><body package="RuntimePackager">isProceedable	"Answer whether this exception is proceedable"	^isProceedable</body><body package="RuntimePackager">isProceedable: aBoolean	"Set whether this exception is proceedable"	isProceedable := aBoolean.</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier</class-id> <category>user interface</category><body package="RuntimePackager">cleanUpUserInterface	"Clean up the user interface after an error.	This should be overridden in subclasses as needed"	^self</body><body package="RuntimePackager">confirmUserInterruptRequest	"Ask the user if the image should quit now	This should be overridden in subclasses as needed"	^true</body><body package="RuntimePackager">notifyUserOfUnhandledException: dumpWorked	"Actually notify the user of the unhandled exception.	dumpWorked is a boolean indicating if a dump was written.	This should be overridden in subclasses as needed"	^self</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier class</class-id> <category>instance creation</category><body package="RuntimePackager">notify: anException context: aContext	"Notify the user about an exception"	^self new exception: anException;		context: aContext;		notify</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier class</class-id> <category>accessing</category><body package="RuntimePackager">debugNotifierMode	"Answer whether we are running in debug mode"	^debugNotifierMode</body><body package="RuntimePackager">debugNotifierMode: aBoolean	"Set whether we are running in debug mode"	"self debugNotifierMode: true"	debugNotifierMode := aBoolean.</body><body package="RuntimePackager">imageDumperClass	"Answer the class for dumping the image.  If no class is set, use the	value provided in RuntimeManager which originated in the	options specifications."	imageDumperClass notNil ifTrue: [ ^imageDumperClass ].	^RuntimeManager imageDumperClass</body></methods><methods><class-id>RuntimePackager.RuntimeErrorNotifier class</class-id> <category>class initialization</category><body package="RuntimePackager">initialize	"Reset class state to an initial condition"	debugNotifierMode := false.	self resetErrorState.</body></methods><methods><class-id>RuntimePackager.RuntimeQuietEmergencyNotifier</class-id> <category>testing</category><body package="RuntimePackager">isHeadless	"Answer true to force all user interface elements to be skipped"	^true</body></methods><methods><class-id>RuntimePackager.RuntimeMethodSurrogate</class-id> <category>initialization</category><body package="RuntimePackager">cloneFromMethod: aMethod	"Copy instance variables and literals from the method supplied.	This only needs to handle CompiledMethods since only surrogates are used.	Blocks are not truely copied since they do not exist in the template methods	appearing in RuntimeSurrogateManager."	" copy the instance variables "	1 to: self class instSize - 1  do: [ :idx |		self instVarAt: idx put: ( aMethod instVarAt: idx ) ].	" now copy the literals "	1 to: aMethod basicSize do: [ :idx |		self basicAt: idx put: ( aMethod basicAt: idx ) ].</body></methods><methods><class-id>RuntimePackager.RuntimeMethodSurrogate</class-id> <category>accessing</category><body package="RuntimePackager">hookedMethod	"Answer the method  that this surrogate represents"	^hookedMethod</body><body package="RuntimePackager">hookedMethod: aMethod	"Set the method  that this surrogate represents"	hookedMethod := aMethod.</body><body package="RuntimePackager">hookedSelector	"Answer the selector  that this surrogate represents"	^hookedSelector</body><body package="RuntimePackager">hookedSelector: aSymbol	"Set the selector  that this surrogate represents"	hookedSelector := aSymbol.</body></methods><methods><class-id>RuntimePackager.RuntimeMethodSurrogate</class-id> <category>compatibility</category><body package="RuntimePackager">attributeMessages	^hookedMethod attributeMessages.</body></methods><methods><class-id>RuntimePackager.RuntimeMethodSurrogate class</class-id> <category>instance creation</category><body package="RuntimePackager">cloneFromMethod: aMethod	"Answer a new instance cloned from the method supplied"	| x |	x := self basicNew: aMethod basicSize.	x cloneFromMethod: aMethod.	^x</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>accessing</category><body package="RuntimePackager">allDeletedClasses	"Answer the collection of deleted classes including any implied subclasses"	^self allDeletedClassesWithLoadables: true</body><body package="RuntimePackager">allDeletedClassesWithLoadables: includeLoadables	"Answer the collection of deleted classes including any implied subclasses.	If includeLoadable is true, add in the classes defined in loadable parcels.	Classes defined in name spaces that are themselves defined in loadable	parcels will be deleted unless such classes are loaded in parcels."	| classes |	classes := IdentitySet new: (		deletedClasses size max: unreferencedClasses size).	unreferencedClasses isEmpty		ifTrue: [			deletedClasses do: [ :cl |				classes addAll: cl withAllSubclasses ] ]		ifFalse: [			unreferencedClasses do: [ :cl |				classes addAll: cl withAllSubclasses. ] ].	self classesInDeletedNameSpaces do: [ :cl |		classes addAll: cl withAllSubclasses ].	includeLoadables		ifTrue: [			options loadableClasses do: [ :cl |				classes addAll: cl withAllSubclasses ] ].	^classes</body><body package="RuntimePackager">allDeletedGlobals	"Answer the deleted globals "	^unreferencedGlobals isEmpty		ifTrue: [ deletedGlobals ]		ifFalse: [ unreferencedGlobals ]</body><body package="RuntimePackager">allDeletedMethods	"Answer the dictionary of all deleted methods including those defined	as extensions in loadable parcels "	^self allDeletedMethodsWithLoadables: true</body><body package="RuntimePackager">allDeletedMethodsWithLoadables: includeLoadables	"Answer the dictionary of all deleted methods including those defined	as extensions in loadable parcels if includeLoadables is true "	| dict deleted selSet |	" choose the right starting point depending of whether scan was done or not "	deleted := unreferencedMethods isEmpty		ifTrue: [ deletedMethods ]		ifFalse: [ unreferencedMethods ].	includeLoadables		ifFalse: [			dict := deleted. ]		ifTrue: [			" allocate a dictionary to hold the final result. "			dict := IdentityDictionary new: deleted size.			deleted keysAndValuesDo: [:cl :selectors |					dict at: cl put: selectors ].			" get methods loaded by way of parcels  "			options loadableMethods keysAndValuesDo: [ :behav :loadables |				selSet := ( dict at: behav ifAbsent: [ dict at: behav put: Set new ] ) copy.				selSet addAll: loadables.				dict at: behav put: selSet. ] ].	^dict</body><body package="RuntimePackager">classesInDeletedNameSpaces	"Answer classes defined in name spaces that are being deleted.	If a class is defined in a name space that is itself defined in a loadable	parcel, the class is considered deleted unless it is defined in a loadable	parcel."	| deletedNS classes loadableNS loadableClasses |	deletedNS := self deletedNameSpaces.	classes := IdentitySet new.	deletedNS do: [ :ns | classes addAll: ns allClasses ].	loadableNS := options loadableNameSpaces.	loadableClasses := options loadableClasses.	loadableNS do: [ :ns |		classes addAll: ( ns allClasses reject: [ :cl | loadableClasses includes: cl ] ). ].	^classes</body><body package="RuntimePackager">deletedClasses	^deletedClasses</body><body package="RuntimePackager">deletedClasses: aSetOfClasses	deletedClasses := aSetOfClasses</body><body package="RuntimePackager">deletedGlobals	^deletedGlobals</body><body package="RuntimePackager">deletedGlobals: aSetOfBindingReferences	deletedGlobals := aSetOfBindingReferences</body><body package="RuntimePackager">deletedMethods	"Answer the dictionary of deleted methods.  Key is class, value is	set of selectors."	^deletedMethods</body><body package="RuntimePackager">deletedMethods: aDictionary	"Set the dictionary of deleted methods.  Key is class, value is	set of selectors."	deletedMethods := aDictionary</body><body package="RuntimePackager">deletedNameSpaces	"Answer namespaces that will be deleted because they are contained	in loadable namespaces but not themselves loadable."	| loadableNS deletedNS |	loadableNS := options loadableNameSpaces.	deletedNS := IdentitySet new.	loadableNS do: [ :ns | deletedNS addAll: ns withAllNameSpaces ].	deletedNS removeAll: loadableNS.	^deletedNS</body><body package="RuntimePackager">editorClass	"Answer the class to use as an editor"	^RuntimeBuilderItemsChooser</body><body package="RuntimePackager">keptClasses	^keptClasses</body><body package="RuntimePackager">keptClasses: aSetOfClasses	keptClasses := aSetOfClasses</body><body package="RuntimePackager">keptGlobals	^keptGlobals</body><body package="RuntimePackager">keptGlobals: aSetOfBindingReferences	keptGlobals := aSetOfBindingReferences</body><body package="RuntimePackager">keptMethods	"Answer the dictionary of kept methods.  Key is class, value is	set of selectors."	^keptMethods</body><body package="RuntimePackager">keptMethods: aDictionary	"Set the dictionary of kept methods.  Key is class, value is	set of selectors."	keptMethods := aDictionary</body><body package="RuntimePackager">options	"Answer the options used for setting defaults"	^options</body><body package="RuntimePackager">options: opts	"Set the options (RuntimeBuilderOptions) used for setting defaults"	options notNil ifTrue: [ options removeDependent: self ].	options := opts.	options addDependent: self.</body><body package="RuntimePackager">unreferencedClasses	^unreferencedClasses</body><body package="RuntimePackager">unreferencedClasses: aCollection	unreferencedClasses := aCollection</body><body package="RuntimePackager">unreferencedGlobals	^unreferencedGlobals</body><body package="RuntimePackager">unreferencedGlobals: aCollection	unreferencedGlobals := aCollection</body><body package="RuntimePackager">unreferencedMethods	"Answer the dictionary of unreferenced methods.  Key is class, value is	set of selectors."	^unreferencedMethods</body><body package="RuntimePackager">unreferencedMethods: aDictionary	"Set the dictionary of unreferenced methods.  Key is class, value is	set of selectors."	unreferencedMethods := aDictionary</body><body package="RuntimePackager">unreferencedMethodsCount	"Answer the number of methods represented in unreferencedMethods"	^unreferencedMethods inject: 0 into: [ :n :sel |		n + sel size ]</body><body package="RuntimePackager">viewerClass	"Answer the class to use as an viewer"	^RuntimeBuilderItemsViewer</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>load-save</category><body package="RuntimePackager">decodeClassesFrom: tokenArray	"Answer the classes named in the token array"	^IdentitySet withAll: (		( tokenArray collect: [ :token |			( BindingReference pathString: token ) valueOrDo: [					Transcript cr; show: 'Class ', token printString,						 ' not found.  It was skipped'.					nil ] ] )				select: [ :x | x notNil and: [ x isBehavior and: [ x isMeta not ] ] ] )</body><body package="RuntimePackager">decodeFrom:  tokens fileVersion: version	"Decode the new value from the token array provided"	" set up action blocks for scanning tokens"	| actionBlocks |	actionBlocks := Dictionary new		add: #deletedClasses -&gt; [ :tokenArray |			deletedClasses := self decodeClassesFrom: tokenArray ];		add: #keptClasses -&gt;  [ :tokenArray |			keptClasses := self decodeClassesFrom: tokenArray ];		add: #unreferencedClasses -&gt; [ :tokenArray |			unreferencedClasses := self decodeClassesFrom: tokenArray ];		add: #deletedMethods -&gt; [ :tokenArray |			deletedMethods := self decodeMethodsFrom: tokenArray ];		add: #keptMethods -&gt; [ :tokenArray |			keptMethods := self decodeMethodsFrom: tokenArray ];		add: #unreferencedMethods -&gt; [ :tokenArray |			unreferencedMethods := self decodeMethodsFrom: tokenArray ];		add: #deletedGlobals -&gt; [ :tokenArray |			deletedGlobals := self decodeGlobalsFrom: tokenArray ];		add: #keptGlobals -&gt; [ :tokenArray |			keptGlobals := self decodeGlobalsFrom: tokenArray ];		add: #unreferencedGlobals -&gt; [ :tokenArray |			unreferencedGlobals := self decodeGlobalsFrom: tokenArray ];		yourself.	"discard the results of previous scans for unreferenced items"	self resetUnreferencedItems.	" extract the new values from the tokens "	self initialize.	1 to: tokens size by: 2 do: [ :tokenIndex |		( actionBlocks includesKey: (tokens at: tokenIndex) )			ifFalse: [ Dialog warn: 'Invalid token ', (tokens at: tokenIndex), ' found'. ]			ifTrue: [				(actionBlocks at: (tokens at: tokenIndex) )					value: (tokens at: tokenIndex + 1) ] ].	"Make sure that loaded values are a valid class hierarchy, and are appropriate for this version. "	self adjustForVersion: version.	self ensureValidHierarchy.	" for unreferenced classes that were loaded, make their methods unreferenced also"	unreferencedClasses do: [ :cl |		unreferencedMethods at: cl put: ( RuntimeManager selectorsInClass: cl ).		unreferencedMethods at: cl class put: (RuntimeManager selectorsInClass: cl class ). ].	" display new values if applicable "	self refresh.	hasBeenEdited := true.	self changed.</body><body package="RuntimePackager">decodeGlobalsFrom: tokenArray	"Answer the bindings for globals named in the token array"	| ref |	^Set withAll: (		( tokenArray collect: [ :token |			ref := ( BindingReference pathString: token ) makeUnambiguous.			( ref isDefined and: [ ref binding isForClass not ] ) ifFalse: [				Transcript cr; show: (					'Global &lt;1s&gt; not found. It was skipped'						expandMacrosWith: token printString ). ].			ref ]  ) )</body><body package="RuntimePackager">decodeMethodsFrom: tokenArray	"Answer the methods named in the token array.	See keptMethods and deletedMethods for the encoding used.	Selectors entered alone are from an earlier version of the setting file.	There are treated as references to all implementations of the selector."	| allSelectors result classNamed classFound selIndex |	allSelectors := IdentitySet new.	result := IdentityDictionary new.	tokenArray do: [ :token |		token isString			ifTrue: [ allSelectors add: token asSymbol ]			ifFalse: [				"token should be an array of size at least 1"				( token size &gt; 1 and: [				( classNamed := ( BindingReference pathString: token first ) valueOrDo: [					Transcript cr; show: 'Class ', token printString,						 ' not found.  It was skipped'.					nil ] ) notNil and: [				classNamed isBehavior and: [				classNamed isMeta not  ] ] ] )					ifTrue: [						classFound := classNamed.						selIndex := 2.						( token size &gt;= 2 and: [							( token at: 2 ) = #class ] ) ifTrue: [								classFound := classNamed class.								selIndex := 3. ].						result at: classFound put: (							( token copyFrom: selIndex to: token size )								collect: [ :x | x asSymbol ] ) asSet ]					ifFalse: [						token size &gt; 1							ifTrue: [								Transcript cr; show: 'Invalid class in method token: ',									token first printString, '. It was skipped' ]							ifFalse: [								Transcript cr; show: 'Empty method token skipped'. ] ] ] ].	" Convert old format param files in which a reference to the selector applies		to all classes implementing the selector. The assumption is that only the		primary name space is affected."	allSelectors isEmpty ifFalse: [		Smalltalk allBehaviorsDo: [ :cl |			allSelectors do: [ :sel |				( cl includesSelector: sel )  ifTrue: [					( result at: cl ifAbsent: [						result at: cl put: Set new ] ) add: sel. ] ] ] ].	^result</body><body package="RuntimePackager">encodeClasses: aSet on: aStream tab: tabCount	"Encode a set of classes on a stream.	The classes are sorted by category and obsolete items are	omitted."	| prevCategory |	prevCategory := ''.	( ( ( aSet reject: [ :cl | cl isObsolete ] ) collect: [ :cl |		| cat |		cat := cl category.		cat isNil ifTrue: [ cat := '' ].		Array with: cl			with: cat			with: cl name ] )		asSortedCollection: [ :x :y |			( x at: 2 ) = ( y at: 2)				ifTrue: [ ( x at: 3 ) &lt; ( y at: 3) ]				ifFalse: [ ( x at: 2 ) &lt; ( y at: 2 ) ] ] )		do: [ :triple |			| cl  cat |			cl := triple at: 1.			cat := triple at: 2.			cat ~= prevCategory ifTrue: [				aStream cr; crtab: tabCount; nextPut: $";					nextPutAll: cat; nextPut: $".				prevCategory := cat. ].			aStream crtab: tabCount; print: cl fullName ].</body><body package="RuntimePackager">encodeMethods: aDict on: aStream tab: tabCount	"Encode methods on the stream.  Methods are encoded in one of the following	ways in the stream:	( 'class-name' 'selector1' 'selector2' .... )   &lt;- methods in the class named	( 'class-name' class 'selector1' 'selector2' ... ) &lt;- class methods	See keptMethods and deletedMethods for the contents of aDict"	| classes selectors |	classes := aDict keys asSortedCollection: [ :x :y | x name &lt; y name ].	classes do: [ :cl |		selectors := ( aDict at: cl ) asSortedCollection.		aStream crtab: tabCount; nextPutAll: '( '.		cl isMeta			ifTrue: [				aStream print: cl soleInstance fullName ; nextPutAll: ' class'.  ]			ifFalse: [ aStream print: cl fullName  ].		selectors do: [ :sel |			selectors size &gt; 1				ifTrue: [ aStream crtab: tabCount + 1 ]				ifFalse: [ aStream space ].			aStream print: sel asString ].		aStream nextPutAll: ' )'. ].</body><body package="RuntimePackager">encodeOn: aStream tab: tabCount	"Encode the receiver onto a stream in a form suitable for decoding as a literal array.	saveUnreferenced is a boolean that controls whether the unreferenced classes,	methods, and globals are saved with the parameters."	| meth |	" write a separator "	aStream cr; crtab: tabCount; nextPutAll: '"====deleted classes methods and globals===="'.	" deleted classes "	aStream crtab: tabCount; nextPutAll: 'deletedClasses ('.	self encodeClasses: deletedClasses on:aStream tab: tabCount+1.	aStream nextPutAll: ' )'.	" deleted methods "	aStream crtab: tabCount; nextPutAll: 'deletedMethods ('.		self encodeMethods: deletedMethods on: aStream tab: tabCount + 1.	aStream nextPutAll: ' )'.	" deleted globals "	aStream crtab: tabCount; nextPutAll: 'deletedGlobals ('.	( deletedGlobals asSortedCollection ) do: [ :ref |		aStream crtab: tabCount+1; print: ref asString ].	aStream nextPutAll: ' )'.	" write a separator "	aStream cr; crtab: tabCount; nextPutAll: '"====kept classes methods and globals===="'.	" kept classes "	aStream crtab: tabCount; nextPutAll: 'keptClasses ('.	self encodeClasses: keptClasses on:aStream tab: tabCount+1.	aStream nextPutAll: ' )'.	" kept methods "	aStream crtab: tabCount; nextPutAll: 'keptMethods ('.		self encodeMethods: keptMethods on: aStream tab: tabCount + 1.	aStream nextPutAll: ' )'.	" kept globals "	aStream crtab: tabCount; nextPutAll: 'keptGlobals ('.	( keptGlobals asSortedCollection ) do: [ :ref |		aStream crtab: tabCount+1;  print: ref asString. ].	aStream nextPutAll: ' )'.	" write a separator "	aStream cr; crtab: tabCount; nextPutAll:		 '"====unreferenced classes methods and globals, if any===="'.	" unreferenced classes, if any"	unreferencedClasses isEmpty ifFalse: [		aStream crtab: tabCount; nextPutAll: 'unreferencedClasses ('.		self encodeClasses: unreferencedClasses on:aStream tab: tabCount+1.		aStream nextPutAll: ' )'. ].	" unreferenced methods, if any, but not for unreferenced classes"	unreferencedMethods isEmpty ifFalse: [		"remove methods is classes that are themselves unreferenced"		meth := IdentityDictionary new: unreferencedMethods size.		unreferencedMethods keysAndValuesDo: [ :cl :v |			( unreferencedClasses includes: (				cl isMeta ifTrue: [ cl soleInstance ] ifFalse: [ cl ] ) )				ifFalse: [ meth add: cl -&gt; v ] ].		aStream crtab: tabCount; nextPutAll: 'unreferencedMethods ('.			self encodeMethods: meth on: aStream tab: tabCount + 1.		aStream nextPutAll: ' )'.	" unreferenced globals, if any "	unreferencedGlobals isEmpty ifFalse: [		aStream crtab: tabCount; nextPutAll: 'unreferencedGlobals ('.			( unreferencedGlobals asSortedCollection ) do: [ :ref |				aStream crtab: tabCount+1; print: ref asString ].			aStream nextPutAll: ' )'. ] ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>defaults</category><body package="RuntimePackager">defaultBundleNamesDeleted	"Answer the names of bundles to be completely deleted when using VisualWorks."	^#('Tools-Refactoring Browser')</body><body package="RuntimePackager">defaultBundleNamesKept	"Answer the names of bundles to be completely kept by default when using VisualWorks."	^#()</body><body package="RuntimePackager">defaultCUAClassesDeleted	"Answer the names of UILook specific classes to be deleted"	^ #(		#CUAActionButtonView		#CUABorderDecorationPolicy		#CUACheckButtonView		#CUAComboBoxButtonView		#CUAFeelPolicy		#CUALookPolicy		#CUAMenuBar		#CUAMenuBarButtonView		#CUAMenuButtonView		#CUAMenuItemView		#CUAMenuView		#CUARadioButtonView		#CUAScrollBar		#CUAScrollBarSlider		#CUAScrollerButtonView		#CUASpinButtonView		#CUAWidgetPolicy	) collect: [ :nm | nm asQualifiedReference valueOrDo: [		"debug -- Transcript cr; show: nm.  "		nil ] ]</body><body package="RuntimePackager">defaultClassesDeleted	"Answer a set of classes deleted by default "	| deleted |	cachedDefaults notNil and: [		cachedDefaults at: #defaultClassesDeleted ifPresent: [:answer | ^answer]]. 	deleted := IdentitySet new.	" choose which of classes should be deleted from the base image "	deleted addAll: self defaultClassesDeletedVW.	deleted addAll: self defaultRBClassesDeleted.	deleted addAll: self defaultPDPClassesDeleted.	" see if compiler is being deleted "	options removeCompiler ifTrue: [		deleted addAll: self defaultCompilerClassesDeleted ].	" get platform system specific deletions "	deleted addAll: self defaultOSClassesDeleted.	" avoid keeping development portions of Runtime Packager"	deleted addAll: self defaultClassesDeletedRTP.	cachedDefaults isNil ifFalse: [cachedDefaults at: #defaultClassesDeleted put: deleted].	^deleted</body><body package="RuntimePackager">defaultClassesDeletedRTP	"Answer the classes deleted from Runtime Packager"	^ #(	#RuntimeBuilderAppModel	#RuntimeBuilderClassChooser	#RuntimeBuilderEditableObject	#RuntimeBuilderEditor	#RuntimeBuilderHelp	#RuntimeBuilderItems	#RuntimeBuilderItemsChooser	#RuntimeBuilderItemsViewer	#RuntimeBuilderMemoryParamEditor	#RuntimeBuilderMemoryParams	#RuntimeBuilderMessageTracer	#RuntimeBuilderOptions	#RuntimeBuilderOptionsEditor	#RuntimeBuilderReferenceBrowser	#RuntimeBuilderTester	#RuntimeBuilderUI	#RuntimeClassSurrogate	#RuntimeInstanceSurrogate	#RuntimeMethodSurrogate	#RuntimeSurrogateManager	) collect: [ :nm | ( self class environment bindingFor: nm ) value ]</body><body package="RuntimePackager">defaultClassesDeletedVW	"Answer the classes deleted when using VisulaWorks. Tools oriented classes	typically loaded through parcels (or the ENVY/Developer equivalent applications)	are included to simplify the stripping process for the user especially when building	a baseline image for use with parcels."	^ #(	"Interface-Dialogs"	#PickASomethingDialog	"Interface-Events-Trackers"	#BitEditorTracker	#ColorBitEditorTracker	#ColumnReorderTracker	"Tools-Changes"	#ChangeEditor	#ChangeList	" #NamedChangeSet -- do not delete"	"Tools-Programming"	#BrowsingAgent	#ClassCreationDialog 	#ContextDefinition	#ContextInspector	#DebugContextsBrowserHelper	#Debugger	#DefinitionCreationDialog	#Explainer	" #GeneralMethodDefinition -- not deleted as of RTP5i.3"	" #InitializerDefinition -- not deleted as of RTP5i.3"	#MethodCollector	" #MethodDefinition -- not deleted as of RTP5i.3"	#MethodFilter	#MethodFilterAnd	#MethodFilterClassHierarchy	#MethodFilterImplementor	#MethodFilterInstVar	#MethodFilterNameSpace	#MethodFilterNot	#MethodFilterNull	#MethodFilterOr	#MethodFilterParcel	#MethodFilterProtocol	#MethodFilterReference	#MethodFilterSelect	" #Notifier -- do not delete"	#NotifierView	#ProcessHandle	#SharedVariableCreationDialog	#SmalltalkWorkbench	"UIBasics-Components"	#HotSlice	"UIBuilder-Specifications"	#MultiSpec	#SpecModel	"UIBuilder-Support"	#LabelConstructor	#HelpConstructor	"UIPainter"	#UISpecificationTreeModel	"UIPainter-Modes"	#DragHandle	#DrawingModeTracker	#SelectModeTracker	"UIPainter-Support"	#BitEditor	#BitView	#ColorBitEditor	#ColorBitView	#ColumnReorderAgent	#DataSetCallbacksSpecModel	#DataSetSpecColumnDetailsModel	#DataSetSpecColumnModel	#DirectBitView	#DSVDependencyAgent	#GridWrapper	#MaskPainterController	#MaskPainterView	#PaintedDataSetController	#PaintedDataSetView	#PaintTracker	#UIDefiner	#UIPainterController	#UIPainterSystemController	#UIPainterView	#UIPainterWatcher	"UIPainter-Tools"	#ClassFinder	#ColorToolModel	#IntegratedSpecModel	#MenuEditor	#PositionToolModel	#UIFinderVW2	#UIHotRegionEditor	#UIMaskEditor	#UIPainter	#UIPainterTool	#UIPalette	) collect: [ :nm | nm asQualifiedReference valueOrDo: [		"debug-- Transcript cr; show: nm." 		nil ] ]</body><body package="RuntimePackager">defaultClassesKept	"Answer a set of classes kept."	| kept |	cachedDefaults notNil and: [		cachedDefaults at: #defaultClassesKept ifPresent: [:answer | ^answer]]. 	" choose which of classes should be deleted by default "	kept := self defaultClassesKeptVW asSet.	"Include ourselves as a special class"	kept add: RuntimeManager.	" add any special startup classes "	kept addAll: self defaultStartupClasses.	cachedDefaults isNil ifFalse: [cachedDefaults at: #defaultClassesKept put: kept].	^kept</body><body package="RuntimePackager">defaultClassesKeptVW	"Answer a set of classes kept when using Visual Works 5.0 and above."	^self defaultClassesKeptVW_ClassOnly,		self defaultClassesKeptVWWithSubclasses,		self defaultClassesKeptVWWithSubclassesAndAllMethods</body><body package="RuntimePackager">defaultClassesKeptVWWithSubclasses	| classes |	classes := OrderedCollection new.	#(#ByteEncodedString #Boolean #Integer #DeferredBinding #VariableBinding #NameSpaceImport #CDatum #CPointerType #SocketAccessor #SocketAddress #StreamEncoder #CharacterEncoder #SymbolTable) do:		[:clName |		clName asQualifiedReference			ifDefinedDo: [:class |  classes addAll: class withAllSubclasses asArray]].	^classes asArray</body><body package="RuntimePackager">defaultClassesKeptVWWithSubclassesAndAllMethods	| classes |	classes := OrderedCollection new.	#(#StringCollationPolicy #PrintPolicy #LocaleSensitiveDataReader #Subsystem #CStructureLayout) do:		[:clName |		clName asQualifiedReference			ifDefinedDo: [:class |  classes addAll: class withAllSubclasses asArray]].	^classes asArray</body><body package="RuntimePackager">defaultClassesKeptVW_ClassOnly	"Answer a set of classes kept when using VisualWorks 5.0 and above."	| classNames memoryPolicyClassName |	classNames := #(		"Kernel-Classes"		#Behavior		#Class		#ClassDescription		#Metaclass		"Kernel-Collections"		#UTF8StreamEncoder		"Kernel-Exception Handling"		#Exception		#GenericException		#Signal		"Kernel-Methods"		#AnnotatedMethod		#BlockClosure		#BlockContext		#CompiledBlock		#CompiledCode		#CompiledMethod		#Context		#InstructionClient		#InstructionStream		#MarkedMethod		#Message		#MessageSend		#MethodContext		"Kernel-Support"		#MethodDictionary		#SystemError		"Kernel-Objects"		#Model		#Object		#UndefinedObject		#UninterpretedBytes		"Kernel-Processes"		#Delay		#Process		#ProcessEnvironment		#ProcessorScheduler		#Promise		#RecursionLock		#Semaphore		#SharedQueue		"Magnitude-General"		#Character		#Date		#Magnitude		#Time		#TimeZone		"Magnitude-Numbers"		#ArithmeticValue		#Number		"System-Support"		#AllocationFailure		#DependentsCollection		#ObjectMemory		#PoolDictionary		#SystemUtils		#'Kernel.SystemSupport.WeakClassTablePage'		#WeakKeyAssociation		"System-Name Spaces"		#NameSpace		#NameSpaceOfClass		#WeakNameSpaceBindings		#ScopeList		" Collections Support - explicitly keep binding classes"		#BindingReference		"Extra C support classes"		#CCompositeType		#CProcedureType		#FinalizeCallbackProcessNotification		"Tools"		#Notifier		#NamedChangeSet	).	memoryPolicyClassName := ObjectMemory currentMemoryPolicy class name.	(classNames includes: memoryPolicyClassName)		ifFalse: [classNames := classNames copyWith: memoryPolicyClassName].	^classNames collect:		[:nm |			nm asQualifiedReference valueOrDo:				[					"debug -- Transcript cr; show: nm. "					nil				]		]</body><body package="RuntimePackager">defaultCompilerClassesDeleted	"Answer the classes deleted when the compiler is to be removed.	This list is specific to VisualWorks 2.0 and above and includes	DLLCC as well as the standard compiler support."	^ #(		"DLLCC-CParsing"		CDeclarationParser		CExpressionParser		CParser		CPreprocessor		CScanner		"DLLCC-Interface"		ExternalInterfaceBuilder		ExternalInterfaceFinder		ExternalInterfaceHolder		"DLLCC-Parsing"		ExtendedCompiler		ExtendedParser		"System-Compiler-Public Access"		CodeRegenerator		Compiler		Decompiler		SmalltalkCompiler	) collect: [ :nm | nm asQualifiedReference valueOrDo: [] ]</body><body package="RuntimePackager">defaultGlobalsDeleted	"Answer the names of globals which will be kept by default"	"Right now there are no globals deleted by default	This method is here for future patches"	^ Set new</body><body package="RuntimePackager">defaultGlobalsKept	"Answer the names of globals which will be kept by default.	See RuntimeManager class&gt;&gt;dynamicallyReferencedGlobals for a list.	At present no globals are explicitly kept"	| kept reference |	cachedDefaults notNil and: [		cachedDefaults at: #defaultGlobalsKept ifPresent: [:answer | ^answer]]. 	kept := Set new.	kept add: #{CharacterEncoderPool}.	reference := CharacterEncoderPool fullyQualifiedReference.	kept addAll: (CharacterEncoderPool localBindings collect: [:each | reference append: each key]).	cachedDefaults isNil ifFalse: [cachedDefaults at: #defaultGlobalsKept put: kept].	^kept.</body><body package="RuntimePackager">defaultMethodsDeleted	"Answer the methods which will be deleted by default"	"Right now there are no such methods.	This method is here for future patches"	^ IdentityDictionary new</body><body package="RuntimePackager">defaultMethodsKept	"Answer the methods which will be kept by default"	| kept |	cachedDefaults notNil and: [		cachedDefaults at: #defaultMethodsKept ifPresent: [:answer | ^answer]]. 	kept := self defaultMethodsKeptVW.	cachedDefaults isNil ifFalse: [cachedDefaults at: #defaultMethodsKept put: kept].	^kept.</body><body package="RuntimePackager">defaultMethodsKeptVW	"Answer the methods which will be kept by default"	| keptMethodDict sels |	keptMethodDict := IdentityDictionary new.	self defaultClassesKeptVWWithSubclassesAndAllMethods do:		[:class |		sels := class selectors.		sels isEmpty			ifFalse:				[(keptMethodDict						at: class						ifAbsentPut: [Set new])					addAll: sels].		sels := class class selectors.		sels isEmpty			ifFalse:				[(keptMethodDict						at: class class						ifAbsentPut: [Set new])					addAll: sels]].	^keptMethodDict</body><body package="RuntimePackager">defaultOSClassesDeleted	"Answer the classes to be deleted given the supported operating systems"		| classes |	classes := Set new: 31.	options osWindows ifFalse: [classes addAll: self defaultPCClassesDeleted].	options osUnix ifFalse: [classes addAll: self defaultUnixClassesDeleted].	^classes</body><body package="RuntimePackager">defaultOpenLookClassesDeleted	"Answer the names of UILook specific classes to be deleted"	^ #(		#OpenLookActionButtonView		#OpenLookBorderDecorationPolicy		#OpenLookCheckButtonView		#OpenLookHorizontalScrollbar		#OpenLookLabeledButtonView		#OpenLookMenuBarButtonView		#OpenLookMenuButtonController		#OpenLookMenuTracker		#OpenLookMenuView		#OpenLookPolicy		#OpenLookRadioButtonView		#OpenLookScrollBar		#OpenLookScrollBarController		#OpenLookVerticalScrollbar		#OpenLookWidgetPolicy	) collect: [ :nm | nm asQualifiedReference valueOrDo: [] ]</body><body package="RuntimePackager">defaultPCClassesDeleted	"Answer the names of os specific classes to be deleted"	^ #(		#FATFilename		#HPFSFilename		#NTFSFilename		#PCDiskFileAccessor		#PCFilename		#PCIOAccessor		" the following are strictly VW 1 classes but will be ignored in VW 2"		#DOSDiskFileAccessor		#DOSFilename		#DOSIOAccessor		" the following are VW3 only"		#Win32sSystemSupport		#Win95SystemSupport		#WinNTSystemSupport	) collect: [ :nm | nm asQualifiedReference valueOrDo: [] ]</body><body package="RuntimePackager">defaultPDPClassesDeleted	"Answer the names of PDP specific classes to be deleted"	^#{Smalltalk.CraftedSmalltalk} ifDefinedDo: [:namespace| namespace allClasses] elseDo: [#()]</body><body package="RuntimePackager">defaultPackageNamesDeleted	"Answer the names of packages to be completely deleted when using VisualWorks."	^#("These are in the Base VisualWorks bundle."		'Tools-Differences' 'Tools-Inspector' 'Tools-Misc' 'Tools-NameSpaces' 		"These are in Tools-IDE bundle."		'Tools-Trippy' 'Tools-Workspace' 'Tools-Parcel Manager' 'Tools-File Browser' 'Tools-Changes'		'Tools-Settings-VW' 'Tools-Settings' 'Tools-IDE-ListIcons')</body><body package="RuntimePackager">defaultPackageNamesKept	"Answer the names of packages to be completely kept by default when using VisualWorks."	^#()</body><body package="RuntimePackager">defaultPackagesDeleted	"Answer the packages or bundles to be completely deleted by default when using VisualWorks."	| fromBundles fromPackages |	fromBundles := (self defaultBundleNamesDeleted collect: [:each | Store.Registry bundleNamed: each]) inject: OrderedCollection new into: [:sum :each |		sum addAll: (each ifNil: [#()] ifNotNil: [each leafItems]). sum].	fromPackages := self defaultPackageNamesDeleted collect: [:each |  Store.Registry packageNamed: each].	^fromBundles, (fromPackages select: [:each | each notNil]).</body><body package="RuntimePackager">defaultPackagesKept	"Answer the packages or bundles to be completely kept by default when using VisualWorks."	| fromBundles fromPackages |	fromBundles := (self defaultBundleNamesKept collect: [:each | Store.Registry bundleNamed: each]) inject: OrderedCollection new into: [:sum :each |		sum addAll: (each ifNil: [#()] ifNotNil: [each leafItems]). sum].	fromPackages := self defaultPackageNamesKept collect: [:each |  Store.Registry packageNamed: each].	^fromBundles, (fromPackages select: [:each | each notNil]).</body><body package="RuntimePackager">defaultRBClassesDeleted	"Answer the names of RB-specific classes to be deleted"	^#{Refactory.Browser} ifDefinedDo: [:namespace| namespace allClasses] elseDo: [#()]</body><body package="RuntimePackager">defaultStartupClasses	"Answer the classes that are dependents of	ObjectMemory or otherwise referenced dynamically in system startup"	| kept |	kept := IdentitySet new: 17.	" get the current dependents of ObjectMemory "	ObjectMemory dependents do: [ :obj |		obj isBehavior			ifFalse: [				obj class isObsolete ifFalse: [					kept add: obj class ] ]			ifTrue: [ obj isMeta					ifTrue: [ obj isObsolete ifFalse: [							kept add: obj soleInstance ] ]					ifFalse: [						( ( obj isKindOf: Class ) and: [							obj isObsolete not ] ) ifTrue: [							kept add: obj ] ] ] ].	^kept</body><body package="RuntimePackager">defaultUnixClassesDeleted	"Answer the names of os specific classes to be deleted"	^ #(		#UnixDiskFileAccessor		#UnixFilename		#UnixIOAccessor		#UnixPipeAccessor		#UnixProcess		#UnixSystemSupport		#X11InputManager	) collect: [ :nm | nm asQualifiedReference valueOrDo: [] ]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>actions</category><body package="RuntimePackager">adjustForVersion: aVersion 	"If we are loading a specification from a different version, reset all of the default kept classes, because they may not be correct. This may cause a bit more to be kept than is strictly necessary, but will avoid the situation of new, important code being stripped because you loaded a packager spec from an older version. For example, older specifications loaded into 7.3 would strip the entire subsystem hierarchy."	| adjustVersion |	(aVersion isKindOf: Float) ifTrue: [adjustVersion := VersionForPackaging fromFloat: aVersion].	(aVersion isKindOf: Integer) ifTrue: [adjustVersion := VersionForPackaging fromFloat: (aVersion * 1.0)].	aVersion isString ifTrue: [adjustVersion := VersionForPackaging fromString: aVersion].	aVersion class = VersionForPackaging ifTrue: [adjustVersion := aVersion].	adjustVersion &lt; RuntimeManager vwVersion ifFalse: [^self].	self defaultMethodsKept keysAndValuesDo: 			[:eachClass :eachSelectorSet | 			(keptMethods at: eachClass ifAbsentPut: [Set new]) addAll: eachSelectorSet.			deletedMethods at: eachClass				ifPresent: [:set | deletedMethods at: eachClass put: set - eachSelectorSet].			unreferencedMethods at: eachClass				ifPresent: [:set | unreferencedMethods at: eachClass put: set - eachSelectorSet]].	keptClasses addAll: self defaultClassesKept.	self defaultClassesKept do: 			[:each | 			deletedClasses remove: each ifAbsent: [].			unreferencedClasses remove: each ifAbsent: []]</body><body package="RuntimePackager">ensureValidHierarchy	"Make sure that no classes are kept while their superclasses are deleted.	Resolve any differences in favor of kept classes."	| namespaces |	namespaces := OrderedCollection new.	keptClasses		do:			[:eachClass | 			eachClass withAllSuperclasses				do:					[:eachSubclass | 					self dontDeleteClass: eachSubclass.					unreferencedClasses remove: eachSubclass ifAbsent: [].					self addNameSpace: eachSubclass environment into: namespaces]].	namespaces do: [:each | self dontDeleteGlobal: each].</body><body package="RuntimePackager">resetDefaultsFromOptions	"Set default values for classes where the default status is affected by option "	| wasReset defaultClasses newDeleted newKept |	" reset the results of any previous references scan "	wasReset := self canBeReset not. 	self resetUnreferencedItems.	defaultClasses := IdentitySet new: 37.	defaultClasses		addAll: self defaultCompilerClassesDeleted;		addAll: self defaultOpenLookClassesDeleted;		addAll: self defaultPCClassesDeleted;		addAll: self defaultUnixClassesDeleted;		addAll: self defaultRBClassesDeleted;		addAll: self defaultPDPClassesDeleted.	" sift out defaults to see what should be changed "	newDeleted := self defaultClassesDeleted select: [ :x | defaultClasses includes: x ].	newKept := self defaultClassesKept select: [ :x | defaultClasses includes: x ].	" adjust kept and deleted collections.  Leave globals and methods alone	since they are not affected by the options selections. "	defaultClasses do: [ :cl |		deletedClasses remove: cl ifAbsent: [].		keptClasses remove: cl ifAbsent: [] ].	deletedClasses addAll: newDeleted.	keptClasses addAll: newKept.	self includeStartupCode.	" ensure that kept classes are not deleted in their superclasses"	self ensureValidHierarchy.	" notify interested parties that things have changed."	wasReset ifTrue: [ self changed. ].	self refresh.</body><body package="RuntimePackager">resetUnreferencedItems	"Reset fields associated with storing unreferenced	classes, methods, and globals"	unreferencedMethods := IdentityDictionary new.	unreferencedClasses := IdentitySet new.	unreferencedGlobals := IdentitySet new.</body><body package="RuntimePackager">setDefaultValues	"Set default values for classes and methods "	| wasReset |	wasReset := self canBeReset not.	self resetUnreferencedItems.	"Do packages first, so that specific items listed overrule them."	self defaultPackagesDeleted do: [:each | self deleteAllInPundle: each].	self defaultPackagesKept do: [:each | self keepAllInPundle: each].	self defaultClassesDeleted do: [:each | self deleteClass: each].	options removeCompiler		ifFalse: [self defaultCompilerClassesDeleted do:[:each| self dontDeleteClass: each] ].	self defaultClassesKept do: [:each | self keepClass: each].	self defaultGlobalsKept do: [:each | self keepGlobal: each].	self defaultGlobalsDeleted do: [:each | self deleteGlobal: each].	self defaultMethodsKept keysAndValuesDo: 			[:eachClass :selectors |			selectors				do: [:eachSelector | self keepSelector: eachSelector inClass: eachClass]].	self defaultMethodsDeleted keysAndValuesDo: 			[:eachClass :selectors |			selectors				do: [:eachSelector | self deleteSelector: eachSelector inClass: eachClass]].	self includeStartupCode.	" ensure that kept classes are not deleted in their superclasses"	self ensureValidHierarchy.	" notify interested parties that things have changed."	wasReset ifTrue: [self changed].	self refresh</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>internal</category><body package="RuntimePackager">addNameSpace: aNameSpace into: aCollection	"Add the given name space (or class) into the list of global bindings that we have known unique references for. To make sure we've got everything, also add its parents to the list, walking backwards until we get to either Smalltalk or Root."	| binding |	(aNameSpace == Root or: [aNameSpace == Smalltalk]) ifTrue: [^self].	aNameSpace isBehavior		ifFalse:			[binding := aNameSpace environment fullyQualifiedReference				append: aNameSpace name.			binding := binding asSimplestReference.			binding := self uniqueReferenceFor: binding.			(aCollection includes: binding) ifFalse: [aCollection add: binding]].	self addNameSpace: aNameSpace environment into: aCollection.</body><body package="RuntimePackager">addSharedVariablesFor: aStoreModelCollection into: aCollection	aStoreModelCollection do: [:each |		self addNameSpace: each value into: aCollection.		each datumDescriptors do: [:eachDescriptor |			aCollection add: (self uniqueReferenceFor: eachDescriptor)]].</body><body package="RuntimePackager">uniqueReferenceFor: aStoreDescriptorOrBinding	"We need a way of normalizing the bindings we hold for shared variables and namespaces so that we can just know we're dealing with unique instances, simplifying the tests for equality. We do that by holding a set of bindings and normalizing each reference to an instance in that set."	| uniqueReference reference subCollection |	aStoreDescriptorOrBinding isBindingReference		ifTrue: [reference := aStoreDescriptorOrBinding]		ifFalse:			[reference := aStoreDescriptorOrBinding nameSpace fullyQualifiedReference.			aStoreDescriptorOrBinding isForData				ifTrue:					[reference := reference append: aStoreDescriptorOrBinding dataKey]].	subCollection := globalBindings at: reference name ifAbsentPut: [OrderedCollection new].	uniqueReference := subCollection		detect: [:x | x = reference]		ifNone:			[subCollection add: reference.			reference].	^uniqueReference.</body><body package="RuntimePackager">validateDeletableClasses: classes	"Validate that the set of classes provided can be moved to the deleted category	without causing an error in which a subclass is kept while its superclass is deleted.	Answer an ordered collection of any classes in error."	^classes select: [:eachClass |		eachClass withAllSubclasses anySatisfy: [ :eachSubclass | self keptClasses includes: eachSubclass ]].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>keeping/deleting</category><body package="RuntimePackager">defaultAllInPundle: aPundle	| methods |	aPundle definedClasses do: [:each | 		self keepClass: each].			"If the class is extended, and we're keeping methods, then we need to keep the class too, but don't actually move them into kept, just make sure they're not explicitly deleted."	aPundle extendedClasses do: [:each | self dontDeleteClass: each].	aPundle data do: [:each | self keepGlobal: each].	aPundle nameSpacesDefinedInPackage , aPundle nameSpacesExtendedInPackage		do: [:each | self keepGlobal: each].	methods := aPundle methods.	methods do: [:each | 		self keepSelector: each selector inClass: each implementingClass].</body><body package="RuntimePackager">deleteAllInPundle: aPundle	| methods |	aPundle definedClasses do: [:each |		self deleteClass: each].	"Note that we don't have to do anything for extended classes here. If they were contingent on just us, then presumably they will go away when all their methods do. If others use them, they won't"	aPundle data do: [:each |		self deleteGlobal: each].	aPundle nameSpacesDefinedInPackage, aPundle nameSpacesExtendedInPackage do: [:each | self deleteGlobal: each].	methods := aPundle methods.	methods do: [:each | 		self deleteSelector: each selector inClass: each implementingClass].</body><body package="RuntimePackager">deleteClass: aClass	self dontKeepClass: aClass.	deletedClasses add: aClass.</body><body package="RuntimePackager">deleteGlobal: aBindingReference		| uniqueReference |		uniqueReference := self uniqueReferenceFor: aBindingReference.		self dontKeepGlobal: uniqueReference.		deletedGlobals add: uniqueReference.</body><body package="RuntimePackager">deleteSelector: aSymbol inClass: aBehavior	self dontKeepSelector: aSymbol inClass: aBehavior.	(self deletedMethods at: aBehavior ifAbsentPut: [Set new]) add: aSymbol.</body><body package="RuntimePackager">dontDeleteClass: aClass	deletedClasses remove: aClass ifAbsent: [].</body><body package="RuntimePackager">dontDeleteGlobal: aBindingReference		| uniqueReference |		uniqueReference := self uniqueReferenceFor: aBindingReference.		deletedGlobals remove: uniqueReference ifAbsent: [].</body><body package="RuntimePackager">dontDeleteSelector: aSymbol inClass: aBehavior	| selectors |	selectors := self deletedMethods at: aBehavior ifAbsent: [^self].	selectors remove: aSymbol ifAbsent: [].	selectors isEmpty ifTrue: [self deletedMethods removeKey: aBehavior].</body><body package="RuntimePackager">dontKeepClass: aClass	keptClasses remove: aClass ifAbsent: [].</body><body package="RuntimePackager">dontKeepGlobal: aBindingReference		| uniqueReference |		uniqueReference := self uniqueReferenceFor: aBindingReference.		self keptGlobals remove: uniqueReference ifAbsent: [].</body><body package="RuntimePackager">dontKeepSelector: aSymbol inClass: aBehavior	| selectors |	selectors := self keptMethods at: aBehavior ifAbsent: [^self].	selectors remove: aSymbol ifAbsent: [].	selectors isEmpty ifTrue: [self keptMethods removeKey: aBehavior].</body><body package="RuntimePackager">includeStartupCode	"Make sure that we're not going to explicitly delete anything that we're told is startup code. Most important for the fairly trivial test case of packaging up SimpleWorkspace."	| package |	self options startupMethod isNil ifTrue: [^self].	self keepClass: self options startupClass.	self		keepSelector: self options startupMethod		inClass: self options startupClass class.	"Make all the methods in the containing package of the startup method be contingent."	package := Store.Registry containingPackageForSelector: self options startupMethod class: self options startupClass class.	(package methodsForClassNamed: self options startupClass absoluteName meta: true), 	(package methodsForClassNamed: self options startupClass absoluteName meta: false) do: [:each |		self dontDeleteSelector: each selector inClass: each implementingClass].</body><body package="RuntimePackager">keepAllInPundle: aPundle	| methods |	aPundle definedClasses do: [:each | 		self keepClass: each].			"If the class is extended, and we're keeping methods, then we need to keep the class too, but don't actually move them into kept, just make sure they're not explicitly deleted."	aPundle extendedClasses do: [:each | self dontDeleteClass: each].	aPundle data do: [:each | self keepGlobal: each].	aPundle nameSpacesDefinedInPackage , aPundle nameSpacesExtendedInPackage		do: [:each | self keepGlobal: each].	methods := aPundle methods.	methods do: [:each | 		self keepSelector: each selector inClass: each implementingClass].</body><body package="RuntimePackager">keepClass: aClass	self dontDeleteClass: aClass.	keptClasses add: aClass.</body><body package="RuntimePackager">keepGlobal: aBindingReference		| uniqueReference |		uniqueReference := self uniqueReferenceFor: aBindingReference.		self dontDeleteGlobal: uniqueReference.		self keptGlobals add: uniqueReference.</body><body package="RuntimePackager">keepSelector: aSymbol inClass: aBehavior	self dontDeleteSelector: aSymbol inClass: aBehavior.	(self keptMethods at: aBehavior ifAbsentPut: [Set new]) add: aSymbol.</body><body package="RuntimePackager">makeAllInPundleContingent: aPundle	| methods |	aPundle definedClasses do: [:each |		self dontKeepClass: each.		self dontDeleteClass: each].	"If the classes are extended, and we're making methods contingent, then we may need to keep the classes too, but don't actually move them into kept, just make sure they're not explicitly deleted."	aPundle extendedClasses do: [:each |		self dontDeleteClass: each].	aPundle data do: [:each |		self dontKeepGlobal: each.		self dontDeleteGlobal: each].	aPundle nameSpacesDefinedInPackage, aPundle nameSpacesExtendedInPackage do: [:each |		self dontKeepGlobal: each.		self dontDeleteGlobal: each].	methods := aPundle methods.	methods do: [:each | 		self dontKeepSelector: each selector inClass: each implementingClass.		self dontDeleteSelector: each selector inClass: each implementingClass].</body><body package="RuntimePackager">resetToDefaults: packages	"Reset the packages or bundles to default values leaving other classes	and globals as they were."	| hierarchyErrors |	self		withDefaultsDo:			[packages do: [:each | self resetToDefaultsForPackage: each].	" ensure that the class hierarchy is valid -- resolve in favor of kept classes "			hierarchyErrors := self validateDeletableClasses: self deletedClasses.			hierarchyErrors do: [:each | self dontDeleteClass: each]].	self includeStartupCode.</body><body package="RuntimePackager">resetToDefaultsForClass: aClass		self dontDeleteClass: aClass.		self dontKeepClass: aClass.		self deletedMethods removeKey: aClass ifAbsent: [ ].		self deletedMethods removeKey: aClass class ifAbsent: [ ].		self keptMethods removeKey: aClass ifAbsent: [ ].		self keptMethods removeKey: aClass class ifAbsent: [ ].		(self defaultClassesDeleted includes: aClass ) ifTrue: [			self deleteClass: aClass].		(self defaultClassesKept includes: aClass ) ifTrue: [			self keepClass: aClass ].		(self defaultMethodsDeleted includesKey: aClass ) ifTrue: [			self deletedMethods at: aClass put: (				self defaultMethodsDeleted at: aClass ) copy. ].		(self defaultMethodsDeleted includesKey: aClass class ) ifTrue: [			self deletedMethods at: aClass class put: (				self defaultMethodsDeleted at: aClass class ) copy. ].		(self defaultMethodsKept includesKey: aClass ) ifTrue: [			self keptMethods at: aClass put: (				self defaultMethodsKept at: aClass ) copy. ].		(self defaultMethodsKept includesKey: aClass class ) ifTrue: [			self keptMethods at: aClass class put: (				self defaultMethodsKept at: aClass class ) copy. ].</body><body package="RuntimePackager">resetToDefaultsForPackage: aPackage	"Reset the packages or bundles to default values leaving other classes	and globals as they were."	"Get current defaults and save them.	Note that this does not really support defaults for methods.	This only resets to contingent methods defined in the application."	| shareds |	aPackage isBundle ifTrue: [		aPackage allContainedItems do: [:each |			self resetToDefaultsForPackage: each].		^self].	"Reset classes based on defaults -- defined classes only"	aPackage definedClasses do: [ :classToDefault |		self resetToDefaultsForClass: classToDefault].	"It's easier to find all the shareds at once, and some are global to the package, rather than associated with a class, so do them all here."	shareds := OrderedCollection new.	self addSharedVariablesFor: aPackage extendedClassModels into: shareds.	self addSharedVariablesFor: aPackage definedClassModels into: shareds.	self addSharedVariablesFor: aPackage definedNameSpaceModels into: shareds.	self addSharedVariablesFor: aPackage extendedNameSpaceModels into: shareds.	aPackage nameSpaceModels do:		[:each || ref | ref := self uniqueReferenceFor: each.		(shareds includes: ref) ifFalse: [shareds add: ref]].	shareds do: [ :glName |		self dontDeleteGlobal: glName.		self dontKeepGlobal: glName.		(self defaultGlobalsDeleted includes: glName ) ifTrue: [			self deleteGlobal: glName].		(self defaultGlobalsKept includes: glName ) ifTrue: [			self keepGlobal: glName ] ].</body><body package="RuntimePackager">withDefaultsDo: aBlock	"Do a calculation that makes use of our defaults (which can be moderately expensive to calculate). Cache them for the duration of the calculation, and then throw them away at the end."	cachedDefaults := Dictionary new.	aBlock ensure: [cachedDefaults := nil].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>testing</category><body package="RuntimePackager">canBeReset	"Answer true if values can be reset without causing side effects"	^super canBeReset and: [self hasComputedUnreferencedItems not]</body><body package="RuntimePackager">hasComputedUnreferencedItems	^self unreferencedMethods notEmpty		or: [self unreferencedClasses notEmpty 			or: [self unreferencedGlobals notEmpty]].</body><body package="RuntimePackager">isDeletedSelector: aSymbol in: aBehavior	"Answer true if aSymbol names a deleted method in the behavior"	^( self deletedMethods at: aBehavior ifAbsent: [ #( ) ] ) includes: aSymbol</body><body package="RuntimePackager">isKeptSelector: aSymbol in: aBehavior	"Answer true if aSymbol names a kept method in the behavior"	^( self keptMethods at: aBehavior ifAbsent: [ #( ) ] ) includes: aSymbol</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>initialize-release</category><body package="RuntimePackager">initialize	"Initialize an instance with dummy values"	super initialize.	deletedClasses := IdentitySet new.	keptClasses := IdentitySet new.	deletedMethods := IdentityDictionary new.	keptMethods := IdentityDictionary new.	deletedGlobals :=Set new.	keptGlobals := Set new.	globalBindings := Dictionary new.	self resetUnreferencedItems.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>updating</category><body package="RuntimePackager">optionsThatAffectKeptItems	^#(#removeCompiler #operatingSystems #uiLooks #startupClass #startupMethod).</body><body package="RuntimePackager">update: aspect with: aParam from: anObject	"Note the effects of a change"	| dialogPrompt |	" look for options changes in which the aspects are identified "	(aspect == #values		and:			[anObject == options				and:					[aParam						anySatisfy: [:each | self optionsThatAffectKeptItems includes: each]]])		ifTrue:			[self canBeReset				ifTrue:					[self setDefaultValues.					hasBeenEdited := false]				ifFalse:					[dialogPrompt := 'Changes to options can affect default kept and deleted classes.Do you want to reset the status of classes affected by optionsat this time?  If you do not reset these items to defaults now,you can do so in the next step or at a later time.'.					self isBeingChanged						ifTrue:							[dialogPrompt := dialogPrompt								,									'\Warning:  pending changes to classes kept and deletedwill be lost if you reset to defaults now.' withCRs].					(Dialog						choose: dialogPrompt						labels: #('Reset to defaults' 'Do not reset now')						values: #(#reset #noReset)						default: #reset) == #reset						ifTrue:							[self resetDefaultsFromOptions.							hasBeenEdited := false]]].	^super		update: aspect		with: aParam		from: anObject.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItems</class-id> <category>copying</category><body package="RuntimePackager">copyFrom: aRuntimeBuilderItems	super copyFrom: aRuntimeBuilderItems.	deletedClasses := aRuntimeBuilderItems deletedClasses.	keptClasses := aRuntimeBuilderItems keptClasses.	deletedMethods := aRuntimeBuilderItems deletedMethods.	keptMethods := aRuntimeBuilderItems keptMethods.	deletedGlobals := aRuntimeBuilderItems deletedGlobals.	keptGlobals := aRuntimeBuilderItems keptGlobals.	options := aRuntimeBuilderItems options.</body><body package="RuntimePackager">postCopy	super postCopy.	deletedClasses := deletedClasses copy.	keptClasses := keptClasses copy.	deletedMethods := deletedMethods copy.	deletedMethods keysAndValuesDo: [:eachKey :eachValue |		deletedMethods at: eachKey put: eachValue copy].	keptMethods := keptMethods copy.	keptMethods keysAndValuesDo: [:eachKey :eachValue |		keptMethods at: eachKey put: eachValue copy].	deletedGlobals := deletedGlobals copy.	keptGlobals := keptGlobals copy.	unreferencedClasses := unreferencedClasses copy.	unreferencedGlobals := unreferencedGlobals copy.	unreferencedMethods := unreferencedMethods copy.	options := options copy.</body></methods><methods><class-id>RuntimePackager.VersionForPackaging</class-id> <category>initialize-release</category><body package="RuntimePackager">initialize	elements := (Array new: 3) atAllPut: 0.</body></methods><methods><class-id>RuntimePackager.VersionForPackaging</class-id> <category>accessing</category><body package="RuntimePackager">elements	^elements</body><body package="RuntimePackager">elements: anObject	elements := anObject</body><body package="RuntimePackager">releaseMajor	^elements at: 2</body><body package="RuntimePackager">releaseMajor: anInteger	elements at: 2 put: anInteger</body><body package="RuntimePackager">releaseMinor	^elements at: 3</body><body package="RuntimePackager">releaseMinor: anInteger	elements at: 3 put: anInteger</body><body package="RuntimePackager">releaseSeries	^elements at: 1</body><body package="RuntimePackager">releaseSeries: anInteger	elements at: 1 put: anInteger</body></methods><methods><class-id>RuntimePackager.VersionForPackaging</class-id> <category>comparing</category><body package="RuntimePackager">&lt; aVersionForPackaging	elements with: aVersionForPackaging elements do: [:a :b|		a &lt; b			ifTrue: [^true]			ifFalse: [				a &gt; b					ifTrue: [^false]]].	^false</body><body package="RuntimePackager">&lt;= aVersionForPackaging	^(self = aVersionForPackaging or: [self &lt; aVersionForPackaging])</body><body package="RuntimePackager">= aVersionForPackaging	^self class = aVersionForPackaging class		and: [self elements = aVersionForPackaging elements]</body><body package="RuntimePackager">&gt; aVersionForPackaging	^(self &lt;= aVersionForPackaging) not</body><body package="RuntimePackager">&gt;= aVersionForPackaging	^self = aVersionForPackaging or: [self &gt; aVersionForPackaging]</body><body package="RuntimePackager">hash	self class hash  * 2 + 1		bitXor: self elements hash.</body></methods><methods><class-id>RuntimePackager.VersionForPackaging</class-id> <category>printing</category><body package="RuntimePackager">printOn: aStream	aStream 		print: self releaseSeries;		nextPut: $.;		print: self releaseMajor.	self releaseMinor &gt; 0		ifTrue: [			aStream nextPut: $.;				print: self releaseMinor]</body></methods><methods><class-id>RuntimePackager.VersionForPackaging class</class-id> <category>utility</category><body package="RuntimePackager">extractVersionStringFromSystem	| releaseString tokens versionString |	releaseString := SystemUtils.SystemVersionName.	tokens := releaseString tokensBasedOn: $ .	versionString := tokens				detect: [:each | each first isDigit and: [each includes: $.]]				ifNone: [nil].	^self versionElementsFromString: versionString</body><body package="RuntimePackager">versionElementsFromString: versionString	| versionTokens resultColl |	versionTokens := versionString tokensBasedOn: $..	resultColl := versionTokens collect: 					[:eachToken |					| numString |					numString := eachToken select: [:eachChar | eachChar isDigit].					numString notEmpty						ifTrue: [Integer readFrom: numString readStream]						ifFalse: [0]].	[resultColl size &lt; 3] whileTrue: [resultColl add: 0].	^resultColl</body></methods><methods><class-id>RuntimePackager.VersionForPackaging class</class-id> <category>instance creation</category><body package="RuntimePackager">fromFloat: aFloat	" Create an instance of me from a float representing a vwVersion using the old RTP encoding. "	| versionString |	versionString := aFloat printString.	versionString := versionString select: [:ea| ea isDigit].	[versionString size &lt; 3]		whileTrue: [versionString := versionString, '0'].	^self new		releaseSeries: (versionString at: 1) digitValue;		releaseMajor: (versionString at: 2)  digitValue;		releaseMinor: (versionString at: 3) digitValue</body><body package="RuntimePackager">fromReleaseString: releaseString	| tokens versionString |	tokens := releaseString tokensBasedOn: $ .	versionString := tokens				detect: [:each | each first isDigit and: [each includes: $.]]				ifNone: [nil].	^self fromString: versionString</body><body package="RuntimePackager">fromString: aVersionString	| versionDigits |	versionDigits := self versionElementsFromString: aVersionString.	^self new		elements: versionDigits asArray</body><body package="RuntimePackager">fromSystem	| releaseString |	releaseString := SystemUtils.SystemVersionName.	^self fromReleaseString: releaseString</body><body package="RuntimePackager">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>RuntimeApplicationStartupSystem</class-id> <category>startup</category><body package="RuntimePackager">main	RuntimePackager.RuntimeManager startupApplication.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser</class-id> <category>actions</category><body package="RuntimePackager">addTargetFromUser	"Prompt for a new target to add..	Keep the cache entry around just in case"	|  name |	name := Dialog request: 'Enter Class, selector, or global to add'		initialAnswer: ''		onCancel: [ ^ self ].	( self targetsList list includes: name ) ifFalse: [			self targetsList list add: name. ].	self targetsList selection: name.	self targetsSelectionChanged.</body><body package="RuntimePackager">browseReference	"Browse the current selected reference"	| reference  methodDef |	( self referencesList selection ) isNil ifTrue: [ ^self ].	reference := self referencesList selection value.	" open browser on class "	reference isBehavior ifTrue: [		RuntimeBuilderUI browseClass: (			reference isMeta ifTrue: [ reference soleInstance ] ifFalse: [ reference ] ).		^self ].	" open protocol browser on method "	( reference isKindOf: CompiledMethod ) ifTrue: [		methodDef := MethodDefinition class: reference mclass			selector: ( reference mclass selectorAtMethod: reference					ifAbsent: [ #unknown ] ).		MethodCollector new			openListBrowserOn: ( Array with: methodDef )			label: 'Method Browser'.		^ self ].	" open inspector on a globals  contents "	reference isVariableBinding ifTrue: [		reference value inspect.		^ self ].	" open inspector on a variables contents "	reference class == Association ifTrue: [		( reference key classPool includesKey: reference value )			ifTrue: [				( reference key classPool at: reference value ) inspect.				^ self ] ].	" otherwise just inspect something "	reference inspect.</body><body package="RuntimePackager">browseReferenceClass	"Browse the class of the current selected reference"	| reference  targetClass |	( self referencesList selection ) isNil ifTrue: [ ^self ].	reference := self referencesList selection value.	" open browser on class "	reference isBehavior ifTrue: [ targetClass := reference.].	" open browser on method's class "	( reference isKindOf: CompiledMethod ) ifTrue: [ targetClass := reference mclass.].	" open inspector on a global's contents "	reference isVariableBinding ifTrue: [ targetClass := reference value class.].	" open browser on the class containing the variable "	reference class == Association ifTrue: [ targetClass := reference key ].	targetClass notNil ifTrue: [		RuntimeBuilderUI browseClass: (			targetClass isMeta ifTrue: [ targetClass soleInstance ] ifFalse: [ targetClass ] ). ].</body><body package="RuntimePackager">changeRequest	"Always allow window close"	^true</body><body package="RuntimePackager">filterKeptItemsChanged	"Respond to a change in the filter value"	self setDeletedItems.	self targetsSelectionChanged.</body><body package="RuntimePackager">newClassReferences	"Add a new target from the current selection in the references list	and scan for references to it.  If the reference is to a method, add the	class rather than the selector.  If reference is to a class variable, add the	class it is defined in."	| reference   |	( self referencesList selection ) isNil ifTrue: [ ^self ].	reference := self referencesList selection value.	" browse mclass of the method"	( reference isKindOf: CompiledMethod ) ifTrue: [		self addToTargets: ( reference mclass isMeta				ifTrue: [ reference mclass soleInstance ]				ifFalse: [ reference mclass ] ).		^ self ].	" browse the class owning the class variable "	( reference isKindOf: Association ) ifTrue: [		self addToTargets: ( reference key isMeta				ifTrue: [ reference key soleInstance ]				ifFalse: [ reference key ] ).		^ self ].	"Otherwise - add the reference itself"	self addToTargets: reference.</body><body package="RuntimePackager">newReferences	"Add a new target from the current selection in the references list	and scan for references to it"	| reference   |	( self referencesList selection ) isNil ifTrue: [ ^self ].	reference := self referencesList selection value.	self addToTargets: reference.</body><body package="RuntimePackager">referencesSelectionChanged	"Respond to changes in the selection on the references list"	| reference source str colonIdx binding |	( self referencesList selection ) isNil ifTrue: [		self referenceFoundText value: Text new.		^ self ].	reference := self referencesList selection value.	" get source if the reference is to a method"	( reference isKindOf: CompiledMethod ) ifTrue: [		 | idx fdx |		" get source of the the method"		source := reference getSource.		source := ( source isNil ifTrue: [ '' ] ifFalse: [ source ] ) asText.		" get name and trim after first colon (to find multi-keyword selectors)"		str := self searchStringFor: currentTarget.		( colonIdx := str indexOf: $: ) &gt; 0 ifTrue: [			str := str copyFrom: 1 to: colonIdx - 1 ].		" highlight occurrences of the search string"		idx := 1.		[ idx &lt;= source size ] whileTrue: [			fdx := source findString: str startingAt: idx.			fdx = 0				ifTrue: [ idx := source size + 1 ]				ifFalse: [					source emphasizeFrom: fdx to: fdx + str size - 1 with: #bold.					idx := fdx + str size ] ].		self referenceFoundText value: source.		^ self ].	" print out a definition if this is a class "	reference isBehavior ifTrue: [		self referenceFoundText value: reference definition.		^ self ].	" print value if this is a class variable reference"	reference class == Association ifTrue: [		binding := reference key classPool bindingFor: reference value.		self referenceFoundText value: (			binding notNil				ifTrue: [ reference key definitionOfStatic: binding ]				ifFalse: [ 'Not found in class' ] ).		^ self ].	" print out the current value of a global "	reference isVariableBinding ifTrue: [		self referenceFoundText value: reference value printString.		^self ].	" othewise just put out the display string for the referenced object"	self referenceFoundText value: reference printString.</body><body package="RuntimePackager">removeTarget	"Remove the select entry from the list displayed.	Keep the cache entry around just in case"	| index list  |	index := self targetsList selectionIndex.	index = 0 ifTrue: [ ^ self ].	list := self targetsList list.	self targetsList list:		( list copyFrom: 1 to: index - 1 ),		( list copyFrom: index + 1 to: list size ).	self referencesSelectionChanged.</body><body package="RuntimePackager">sortTargets	"Sort the list of targets by name"	| selection list |	selection := self targetsList selection.	list := self targetsList list.	list sort.	self targetsList list: list.	self targetsList selection: selection.</body><body package="RuntimePackager">targetsSelectionChanged	"The targets selection has changed.  Find the new references"	| list references referenceElements who |	" get references to the currently selected target "	self targetsList selection isNil ifTrue: [		self referencesList list: (List new).		^ self ].	currentTarget := self targetsList selection.	references := self referencesTo: currentTarget.	references isNil ifTrue: [		self referencesList list: (List new).		 ^ self ].	" select references that are not being deleted "	referenceElements := OrderedCollection new.	references do: [ :x |		x isBehavior ifTrue: [			( deletedClasses includes: x ) ifFalse: [				referenceElements add: x ] ].		x isVariableBinding ifTrue: [			( deletedGlobals includes: x binding ) ifFalse: [				referenceElements add: x binding ] ].		x class == Association ifTrue: [			( deletedClasses includes: x key ) ifFalse: [				referenceElements add: x ] ].		( x isKindOf: CompiledMethod ) ifTrue: [			( ( ( who := x who ) notNil and: [				( deletedMethods at: who first ifAbsent: [ #( ) ] )					includes: who last ] ) or: [			deletedClasses includes: (				x mclass isMeta ifTrue: [ x mclass soleInstance ] ifFalse: [ x mclass ] )			] ) ifFalse: [				referenceElements add: x ] ] ].	list := List new: referenceElements size.	referenceElements do:[ :x |		list add: (self nameFor: x ) -&gt; x. ].	list sortWith: [ :x :y | x key &lt; y key ].	self referencesList list: list.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser</class-id> <category>internals</category><body package="RuntimePackager">addToTargets: reference	"Add a new item to the targets list"	| referenceName |	referenceName := self referenceStringFor: reference.	( self targetsList list includes: referenceName ) ifFalse: [		self retractInterests.		self targetsList list add: referenceName; changed.		self expressInterests. ].	self targetsList selection: referenceName.</body><body package="RuntimePackager">array: anArray references: targets ignoring: aCollection	"Answer true if any element of the array references any of the targets"	anArray do: [ :element |			" is the element one of the targets "			( targets includes: element ) ifTrue: [ ^true ].			" is the element a binding reference to a target "			element isBindingReference ifTrue: [				( ( targets includes: element simpleName ) and: [					targets includes: ( element valueOrDo: [ nil ] ) ] )				ifTrue: [ ^true ] ].			" recursively descend an array"			element class == Array ifTrue: [				( aCollection includes: element ) ifFalse: [					aCollection add: element.					^self array: element references: targets ignoring: aCollection ] ] ].	^ false</body><body package="RuntimePackager">clearCache	"empty the cache of references found"	referencesCache := Dictionary new.</body><body package="RuntimePackager">expressInterests	"Setup interests in changed window contents"	self targetsList selectionIndexHolder		onChangeSend: #targetsSelectionChanged to: self.	self referencesList selectionIndexHolder		onChangeSend: #referencesSelectionChanged to: self.	self keptItemsFilter onChangeSend: #filterKeptItemsChanged to: self.</body><body package="RuntimePackager">method: aMethod references: targets special: specialSelectorIndex	"Answer whether the method references any of the	target items"	aMethod withAllBlockMethods do: [ :block |	  	block literals do: [ :lit |			" is a target directly referenced.				references to the defining class do not count"			( ( targets includes: lit ) and: [ lit ~~ aMethod mclass ] )				ifTrue: [ ^ true ].			" use a short cut for associations (if any are still used) "			lit class == Association ifTrue: [				( ( targets includes: lit key ) or: [					targets includes: lit value ] ) ifTrue: [ ^true ] ].			" for variable bingings, look at the value of the binding"			lit isVariableBinding ifTrue: [				( targets includes: lit value ) ifTrue: [ ^true ] ].			" for binding references, see if how they resolve"			lit isBindingReference ifTrue: [				( ( targets includes: lit simpleName ) and: [					targets includes: ( lit valueOrDo: [ nil ] ) ] )					ifTrue: [ ^true ] ].			" decompose an array and look for internal references "			lit class == Array ifTrue: [				 ( self array: lit references: targets ignoring: IdentitySet new )				ifTrue: [ ^ true ] ] ] ].	" special selectors are known only by number in the method"	specialSelectorIndex = 0 ifFalse: [		( aMethod sendsSpecialSelector: specialSelectorIndex )				ifTrue: [ ^ true ] ].	" otherwise there is no reference "	^false</body><body package="RuntimePackager">nameFor: x	"Answer the name for displaying in the target or references list"	" format a method reference "	( x isKindOf: CompiledMethod ) ifTrue: [		^x mclass fullName, '&gt;&gt;', (			x mclass selectorAtMethod: x ifAbsent: [ 'unboundMethod' ] ) ].	" format a class reference "	x isBehavior ifTrue: [		^x fullName ].	" format a class variable reference "	x class == Association ifTrue: [		^x printString ].	" format a global name "	x isVariableBinding ifTrue: [		^ x key ].	"otherwise error"	self error: 'Should not occur'.</body><body package="RuntimePackager">referenceStringFor: x	"Answer the name for searching for references to the object provided"	^ x isBehavior		ifTrue: [			( x isMeta ifTrue: [ x soleInstance ] ifFalse: [ x ] )				fullName ]		ifFalse: [ self searchStringFor: x ]</body><body package="RuntimePackager">referencesTo: aString	"Answer the references to what is named by aString,	which can be a global, a class name, or a selector"	| notifier resp foundReferences |	foundReferences := referencesCache at: aString ifAbsent: [ nil ].	foundReferences notNil ifTrue: [ ^foundReferences ].	[ [ 	notifier := RuntimeProgressNotifier open.		notifier log: 'Scanning for references to ', aString.		foundReferences := self referencesTo: aString notifying: notifier.		referencesCache at: aString put: foundReferences. ]		ensure: [ notifier close ] ]		on: UserInterrupt		do: [ :ex |			resp := Dialog choose: 'Terminate scan for references?'					labels: #( 'Yes' 'No' 'Debug' )					values: #( true false nil )					default: true.			resp = true ifTrue: [	^nil ].			resp = false ifTrue: [				notifier raise.				ex proceed. ].			ex pass. ].	^foundReferences</body><body package="RuntimePackager">referencesTo: aStringOrSymbol notifying: aNotifier	"Answer the references to the symbol, which can be a global,	a class name, or a selector. "	| references  targets specialSelector  targetClass aClassOrGlobalBinding |	references := OrderedCollection new.	specialSelector := 0.	" See if aStringOrSymbol can be a class or global reference.		Watch out for ill formed names which result in an error		whether you want them to or not"	( aStringOrSymbol isSymbol or: [		aStringOrSymbol contains: [ :ch | ch = $: ] ] )		ifTrue: [ aClassOrGlobalBinding := nil ]		 ifFalse: [ aClassOrGlobalBinding :=			aStringOrSymbol asQualifiedReference bindingOrNil. ].	" figure out what targets could be named by aString "	targets := OrderedCollection new: 7.	targets add: aStringOrSymbol.	targetClass := nil.	aClassOrGlobalBinding notNil		ifTrue: [			aClassOrGlobalBinding isForClass				ifTrue: [					targetClass := aClassOrGlobalBinding value.					targets add: targetClass;						add: aClassOrGlobalBinding;						add: targetClass fullName asSymbol;						add: targetClass name asSymbol. ]				ifFalse: [					" look for references to global by name "					targets add: aClassOrGlobalBinding;						add: aClassOrGlobalBinding  key. ] ]		ifFalse: [			| numArgs sym |			" treat aString as a selector, also add any related accessors"			sym := aStringOrSymbol asSymbol.			targets add: aStringOrSymbol; add: sym.			numArgs := aStringOrSymbol occurrencesOf: $: .			numArgs = 0 ifTrue: [				| str |				str := aStringOrSymbol, ':'.				targets add: str ; add: str asSymbol . ].			numArgs = 1 ifTrue: [				| str |				str := aStringOrSymbol copyWithout: $:.				targets add: str; add: str asSymbol. ].			specialSelector := CompiledCode specialSelectorIndexFor:  sym ].	targets := targets asSet asOrderedCollection.	" check each class for a reference "	aNotifier log: 'Scanning classes for references'.	aNotifier tickRate: Smalltalk allClasses size // 50.	RuntimeManager allClassesDo: [ :cl |		aNotifier tick.		" check for references via class imports "		aClassOrGlobalBinding notNil ifTrue: [			( cl importDefinitions contains: [ :ref |				ref bindingOrNil  = aClassOrGlobalBinding ] )				ifTrue: [ references add: cl ] ].		targetClass notNil ifTrue: [			" check for reference via subclass "			( cl inheritsFrom: targetClass ) ifTrue: [				references add: cl ].			" check for references via class variables "			cl classPool keysAndValuesDo: [ :key :value |				(  targetClass == value or: [ value isKindOf: targetClass ] )					ifTrue: [ references add: cl -&gt; key ]					ifFalse: [						( value class == ValueHolder and: [							targetClass == value value or: [							value value isKindOf: targetClass ] ] ) ifTrue: [							references add: cl -&gt; key ] ] ] ].		" check for reference via methods "		( RuntimeManager selectorsInClass: cl ) do: [ :sel |			| meth |			meth := cl compiledMethodAt: sel.			( self method: meth references: targets special: specialSelector)  ifTrue: [				references add: meth ] ].		( RuntimeManager selectorsInClass: cl class ) do: [ :sel |			| meth |			meth := cl class compiledMethodAt: sel.			( self method: meth references: targets special: specialSelector )  ifTrue: [				references add: meth ] ] ].	"Look for references to classes via globals"	targetClass notNil ifTrue: [		aNotifier log: 'Scanning for references via globals'.		( RuntimeManager allNameSpacesFrom: Root ) do: [ :ns |			ns bindingsDo: [ :binding |				binding isForGeneral ifTrue: [					( binding value class == targetClass or: [					binding value class inheritsFrom: targetClass ] ) ifTrue: [						references add: binding ] ] ] ] ].	^ references</body><body package="RuntimePackager">retractInterests	"Retract interests in changed window contents"	self targetsList selectionIndexHolder		retractInterestsFor: self.	self referencesList selectionIndexHolder		retractInterestsFor: self.	self keptItemsFilter retractInterestsFor: self.</body><body package="RuntimePackager">searchStringFor: x	"Answer the name for searching for the object provided"	| lastPeriod |	" check for a class "	x isBehavior ifTrue: [ ^x name ].	" check for a class variable reference "	x class == Association		ifTrue: [ ^ x value ].	" check for a global reference "	x isVariableBinding ifTrue: [ ^x key ].	" check for selector name "	x isSymbol ifTrue: [ ^x asString ].	" check for method "	( x isKindOf: CompiledMethod ) ifTrue: [		^x mclass selectorAtMethod: x ifAbsent: [ ^ #unknown ] ].	" for a string, extract the last part of a string as a qualified reference"	( x isKindOf: String ) ifTrue: [		lastPeriod := x lastIndexOf: $. ifAbsent: [ 0 ].		^ lastPeriod &gt; 0			ifTrue: [ x copyFrom: lastPeriod + 1 to: x size ]			ifFalse: [ x ] ].	" otherwise, convert x to a string if possible (shoud not occur) "	^x asString</body><body package="RuntimePackager">setDeletedItems	"set the collections of deleted items based on the current kept items"	( self keptItemsFilter value and: [ keptItems notNil ] )		ifTrue: [			deletedClasses := keptItems allDeletedClassesWithLoadables: false.			deletedGlobals := IdentitySet withAll: (				keptItems allDeletedGlobals collect: [ :x | x bindingOrNil ] ).			deletedMethods := keptItems allDeletedMethodsWithLoadables: false. ]		ifFalse: [			deletedClasses := IdentitySet new.			deletedGlobals :=  IdentitySet new.			deletedMethods := IdentityDictionary new. ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser</class-id> <category>accessing</category><body package="RuntimePackager">currentTarget	^currentTarget</body><body package="RuntimePackager">currentTarget: aSymbolClassOrBinding	currentTarget := aSymbolClassOrBinding</body><body package="RuntimePackager">keptItems	"Answer the kept items object or nil, if none"	^keptItems</body><body package="RuntimePackager">keptItems: items	"Set the kept items object or nil, if none"	keptItems := items</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser</class-id> <category>initialization</category><body package="RuntimePackager">initialize	"Set the initial values"	self keptItemsFilter value: true.	self clearCache.	self setDeletedItems.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser</class-id> <category>aspects</category><body package="RuntimePackager">keptItemsFilter	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^keptItemsFilter isNil ifTrue: [keptItemsFilter := false asValue] ifFalse: [keptItemsFilter]</body><body package="RuntimePackager">referenceFoundText	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^referenceFoundText isNil ifTrue: [referenceFoundText := String new asValue] ifFalse: [referenceFoundText]</body><body package="RuntimePackager">referencesList	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^referencesList isNil ifTrue: [referencesList := SelectionInList new] ifFalse: [referencesList]</body><body package="RuntimePackager">targetsList	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^targetsList isNil ifTrue: [targetsList := SelectionInList new] ifFalse: [targetsList]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser</class-id> <category>interface opening</category><body package="RuntimePackager">postOpenWith: aBuilder	"Initialize for opening the window"	super postBuildWith: aBuilder.	self targetsList list: ( List with: currentTarget ).	self targetsList selectionIndex: 1.	self targetsSelectionChanged.	self expressInterests.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser class</class-id> <category>interface opening</category><body package="RuntimePackager">openOn: aSymbol	"Open on the target provided.  This can be a global name, a class name, or a selector"	"RuntimeBuilderReferenceBrowser openOn: #RuntimeManager"	"RuntimeBuilderReferenceBrowser openOn: #Win3LookPolicy"	"RuntimeBuilderReferenceBrowser openOn: #ScheduledControllers"	"RuntimeBuilderReferenceBrowser openOn: #ControlManager"	^self openOn: aSymbol withItems: nil.</body><body package="RuntimePackager">openOn: aSymbol withItems: items	"Open on the target provided.  This can be a global name, a class name, or a selector"	"RuntimeBuilderReferenceBrowser openOn: #RuntimeManager"	"RuntimeBuilderReferenceBrowser openOn: #Win3LookPolicy"	"RuntimeBuilderReferenceBrowser openOn: #ScheduledControllers"	"RuntimeBuilderReferenceBrowser openOn: #ControlManager"	| inst |	inst := self new.	inst currentTarget: aSymbol.	inst keptItems:items.	inst setDeletedItems.	inst open.	^inst</body></methods><methods><class-id>RuntimePackager.RuntimeStartupController</class-id> <category>basic control sequence</category><body package="RuntimePackager">saveFinalImage	RuntimeManager runState == #aboutToSave		ifTrue: 			["remove dead references"			RuntimeManager ensureUnscheduleWindow: view.			eventDispatcher := model := view := nil.			"now go do the real work"			[RuntimeManager createAndSaveFinalImage] fork]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id> <category>internals</category><body package="RuntimePackager">addClassesInPundle: aPundle	"Add the classes in the category or application to selectableClasses	definedClasses and globalNames as appropriate.	Make sure currently obsolete classes are not selectable."	| pundles shareds |	pundles := aPundle allContainedItems , (Array with: aPundle).	selectedSubapplications addAll: pundles.	pundles		do:			[:subapp | 			subapp isBundle				ifFalse:					[selectableClasses						addAll: (subapp extendedClassModels collect: [:each | each value]).					selectableClasses						addAll: (subapp definedClassModels collect: [:each | each value]).					definedClasses						addAll: (subapp definedClassModels collect: [:each | each value]).					shareds := OrderedCollection new.					workingCopy						addSharedVariablesFor: subapp extendedClassModels						into: shareds.					workingCopy						addSharedVariablesFor: subapp definedClassModels						into: shareds.					workingCopy						addSharedVariablesFor: subapp definedNameSpaceModels						into: shareds.					workingCopy						addSharedVariablesFor: subapp extendedNameSpaceModels						into: shareds.					subapp nameSpaceModels						do: [:each | shareds add: (workingCopy uniqueReferenceFor: each)].					bindingsInCurrentlySelected addAll: shareds]].</body><body package="RuntimePackager">addSelector: aSymbol in: aBehavior to: aDict	"Add the selector/behavior combination to the dictionary.  aDict is typically	keptMethods or deletedMethods."	( aDict at: aBehavior ifAbsent: [ aDict at: aBehavior put: Set new ] )		add: aSymbol.</body><body package="RuntimePackager">buildClassLists	"Set the contents of deleted, kept and contingent class lists based upon	currently selected categories. Preserve existing selections as much	as possible."	| keptSelections contingentSelections  deletedSelections |	"save existing selections"	deletedSelections := self deletedClassesList selections.	keptSelections := self keptClassesList selections.	contingentSelections := self contingentClassesList selections.	" build new lists "	self buildSelectableClassList.	self deletedClassesList list: (		selectableClassList select: [ :assoc |			( self deletedClasses includes: assoc value ) |			( self deletedGlobals includes: assoc value ) ] ).	self contingentClassesList list: (		selectableClassList reject: [ :assoc |			| cl |			cl := assoc value.			( self keptClasses includes: cl ) |			( self keptGlobals includes: cl ) |			( self deletedClasses includes: cl ) |			( self deletedGlobals includes: cl ) ] ).	self keptClassesList list: (		selectableClassList select: [ :assoc |			( self keptClasses includes: assoc value  ) |			( self keptGlobals includes: assoc value ) ] ).	"restore selections"	self setSelections: deletedSelections in: self deletedClassesList.	self setSelections: contingentSelections in: self contingentClassesList.	self setSelections: keptSelections in: self keptClassesList.</body><body package="RuntimePackager">buildMethodLists	"Set the contents of deleted, kept, and contingent method lists based upon	currently selected classes.  Preserve existing method selections	as much as possible"	|  	classes keptSelections contingentSelections  deletedSelections		keptSel contingentSel deletedSel selKey multipleClasses		who className metaName |	"save existing selections"	deletedSelections := self deletedMethodsList selections.	contingentSelections := self contingentMethodsList selections.	keptSelections := self keptMethodsList selections.	" build new lists "	" first determine which classes are involved "	classes := self selectedClasses.	multipleClasses := ( classes size &gt; 1 ).	" build up lists of deleted, contingent, and kept selectors"	keptSel := List new: 127.	contingentSel := List new: classes size * 19.	deletedSel := List new: 127.	classes do: [ :cl |		className := cl name.		metaName := cl class name.		( self visibleSelectorsIn: cl ) do: [ :sel |			who := Array with: cl with: sel.			selKey := self selectorDisplayString: sel in: cl						name: className multiple: multipleClasses.			( self isKeptSelector: sel in: cl )				ifTrue: [ keptSel add: selKey -&gt; who ]				ifFalse: [ ( self isDeletedSelector: sel in: cl )					ifTrue: [ deletedSel add: selKey -&gt; who ]					ifFalse: [ contingentSel add: selKey -&gt; who ] ] ].		( self visibleSelectorsIn: cl class ) do: [ :sel |			who := Array with: cl class with: sel.			selKey := self selectorDisplayString: sel in: cl class						name: metaName multiple: multipleClasses.			( self isKeptSelector: sel in: cl class )				ifTrue: [ keptSel add: selKey -&gt; who ]				ifFalse: [ ( self isDeletedSelector: sel in: cl class )					ifTrue: [ deletedSel add: selKey -&gt; who ]					ifFalse: [ contingentSel add: selKey -&gt; who ] ] ] ].	" sort the lists -- save some indirections in the compare "	keptSel sortWith: [ :x :y | x key &lt; y key ].	contingentSel sortWith: [ :x :y | x key &lt; y key ].	deletedSel sortWith: [ :x :y | x key &lt; y key ].	" save as new lists "	self keptMethodsList list: keptSel.	self contingentMethodsList list: contingentSel.	self deletedMethodsList list: deletedSel.	"restore selections"	self setSelectionOnValues: deletedSelections in: self deletedMethodsList.	self setSelectionOnValues: contingentSelections in: self contingentMethodsList.	self setSelectionOnValues: keptSelections in: self keptMethodsList.</body><body package="RuntimePackager">copyValuesFromSubject	workingCopy := subject copy.</body><body package="RuntimePackager">copyValuesToSubject	"Copy values to the subject. If a previous scan for unreferenced items was done	reset the results and inform the user."	super copyValuesToSubject.	self isChanged ifFalse: [ ^self ].	workingCopy ensureValidHierarchy.	subject copyFrom: workingCopy.		 subject hasComputedUnreferencedItems ifTrue: [		subject resetUnreferencedItems.		Dialog warn: (			'Results of the previous scan for\',			'unreferenced items have been discarded.\\',			'The scan for unreferenced items \',			'probably should be done again.' ) withCRs. ]</body><body package="RuntimePackager">deleteHierarchyOf: classesToDelete	"Request to move any subclasses in classesToDelete to the contingent list because their superclasses are marked for deletion"	| errorMsg |	errorMsg := String new writeStream.	errorMsg nextPutAll: 'The requested move would create an invalid hierarchy&lt;n&gt;in which a superclass is deleted while a subclass is kept.&lt;nn&gt;See the following classes:'   expandMacros.	1 to: (3   min: classesToDelete size ) do: [ :index |		errorMsg cr; nextPutAll: ( classesToDelete at: index ) name ].	classesToDelete size &gt; 3 ifTrue: [errorMsg cr; nextPutAll: '... and additional classes'. ].	errorMsg cr; cr; nextPutAll: 'Move subclasses to contingent and continue?'.	(Dialog confirm: errorMsg contents)		ifTrue: 			[workingCopy 				keptClasses: (classesToDelete inject: self keptClasses into: [:sofar :class | sofar - class allSubclasses]).			self deletedClasses addAll: classesToDelete.			self buildClassLists.			self deletedClassesList 				selections: (deletedClassesList list select: [:assoc | classesToDelete includes: assoc value]).			^true]		ifFalse: [^false]</body><body package="RuntimePackager">deleteSelector: aSelector inClass: aClass	workingCopy deleteSelector: aSelector inClass: aClass.</body><body package="RuntimePackager">displayHierarchyErrorMsg: hierarchyErrors	"Display an error message that the intended move would create an invalid hierarchy.	hierarchyErrors is a collection of classes in error."	| errorMsg |	errorMsg := WriteStream on: ( String new: 128).	errorMsg nextPutAll: 'The requested move would create an invalid hierarchy'; cr;		nextPutAll: 'in which a superclass is deleted while a subclass is kept.'; cr; cr;		nextPutAll: 'See the following classes:'.	1 to: (3 min: (hierarchyErrors size) ) do: [ :index |		errorMsg cr; nextPutAll: ( hierarchyErrors at: index ) name ].	hierarchyErrors size &gt; 3 ifTrue: [		errorMsg cr; nextPutAll: '... and additional classes'. ].	Dialog warn: errorMsg contents.</body><body package="RuntimePackager">displayParcelErrorMsg: errors	"Display an error message that the intended move would conflict with parcels.	errors contains the classes in error."	| errorMsg |	errorMsg := WriteStream on: ( String new: 128).	errorMsg nextPutAll: 'The requested move would create a conflict with current'; cr;		nextPutAll: 'parcel definitions.  Classes loaded from parcels are deleted'; cr;		nextPutAll: 'from the final runtime image.'; cr; cr;		nextPutAll: 'See the following classes:'.	1 to: (3 min: (errors size) ) do: [ :index |		errorMsg cr; nextPutAll: ( errors at: index ) name ].	errors size &gt; 3 ifTrue: [		errorMsg cr; nextPutAll: '... and additional classes'. ].	Dialog warn: errorMsg contents.</body><body package="RuntimePackager">dontDeleteSelector: aSelector inClass: aClass	workingCopy dontDeleteSelector: aSelector inClass: aClass.</body><body package="RuntimePackager">dontKeepSelector: aSelector inClass: aClass	workingCopy dontKeepSelector: aSelector inClass: aClass.</body><body package="RuntimePackager">expressInterests	"Setup interests in changed window contents"	super expressInterests.	self deletedClassesList selectionIndexHolder		onChangeSend: #classSelectionChanged to: self.	self keptClassesList selectionIndexHolder		onChangeSend: #classSelectionChanged to: self.	self contingentClassesList selectionIndexHolder		onChangeSend: #classSelectionChanged to: self.</body><body package="RuntimePackager">keepHierarchyOf: classesToKeep	"Request to move any superclasses marked for deletion of classes in classesToKeep to the contingent list"	| errorMsg |	errorMsg := String new writeStream.	errorMsg nextPutAll: 'The requested move would create an invalid hierarchy&lt;n&gt;in which a superclass is deleted while a subclass is kept.&lt;nn&gt;See the following classes:'   expandMacros.	1 to: (3   min: classesToKeep size ) do: [ :index |		errorMsg cr; nextPutAll: ( classesToKeep at: index ) name ].	classesToKeep size &gt; 3 ifTrue: [errorMsg cr; nextPutAll: '... and additional classes'. ].	errorMsg cr; cr; nextPutAll: 'Move superclasses to contingent and continue?'.	(Dialog confirm: errorMsg contents)		ifTrue: 			[workingCopy 				deletedClasses: (classesToKeep inject: self deletedClasses into: [:sofar :class | sofar - class allSuperclasses]).			self keptClasses addAll: classesToKeep.			self buildClassLists.			self keptClassesList 				selections: (keptClassesList list select: [:assoc | classesToKeep includes: assoc value]).			^true]		ifFalse: [^false]</body><body package="RuntimePackager">keepSelector: aSelector inClass: aClass	workingCopy keepSelector: aSelector inClass: aClass.</body><body package="RuntimePackager">removeSelector: aSymbol in: aBehavior from: aDict	"Remove the selector/behavior combination to the dictionary.  aDict is typically	keptMethods or deletedMethods."	| set |	set := aDict at: aBehavior.	set remove: aSymbol.	set isEmpty ifTrue: [		aDict removeKey: aBehavior ].</body><body package="RuntimePackager">removeSelector: aSymbol in: aBehavior from: aDict ifAbsent: aBlock	"Remove the selector/behavior combination to the dictionary.  aDict is typically	keptMethods or deletedMethods."	| set |	set := aDict at: aBehavior ifAbsent: [^aBlock value].	set remove: aSymbol ifAbsent: [].	set isEmpty ifTrue: [		aDict removeKey: aBehavior ].</body><body package="RuntimePackager">retractInterests	"Retract interests in changed window contents"	super retractInterests.	self deletedClassesList selectionIndexHolder		retractInterestsFor: self.	self keptClassesList selectionIndexHolder		retractInterestsFor: self.	self contingentClassesList selectionIndexHolder		retractInterestsFor: self.</body><body package="RuntimePackager">selectedClasses	"Answer all classes currently selected"	| selections selectedClasses |	" get all the selections together "	( selections :=OrderedCollection new: 37 )		addAll: self keptClassesList selections;		addAll: self contingentClassesList selections;		addAll: self deletedClassesList selections.	" reject the symbols (ie globals) and just get the classes"	selectedClasses := OrderedCollection new: selections size.	selections do: [ :assoc |		assoc value isBindingReference ifFalse: [			selectedClasses add: assoc value ] ].	^selectedClasses</body><body package="RuntimePackager">selectorDisplayString: sel in: cl name: clName multiple: multiple	"Answer a string for displaying the selector in a selection list.	sel := a symbol naming the selector	cl := a class or metaclass containing the selector	clName := name of class or metaclass	multiple := a Boolean indicating if the selector potentially appears in multiple classes"	| selString str |	selString := sel asString.	str := WriteStream on: ( selString class new: (			selString size + clName size + 5 ) ).	str nextPutAll: selString.	multiple		ifFalse: [			cl isMeta ifTrue: [ str nextPutAll: ' (class)'. ] ]		ifTrue: [			str 	nextPutAll: ' (';				nextPutAll: clName;				nextPut: $). ].	^str contents</body><body package="RuntimePackager">uniqueReferenceFor: aStoreDescriptorOrBinding	^workingCopy uniqueReferenceFor: aStoreDescriptorOrBinding.</body><body package="RuntimePackager">updateCategoryTitle	"Build the list of all system categories or applications." 	self categoryListTitle value: ( 'Packages/Bundles (&lt;1p&gt; selected)' expandMacrosWith: self systemPackagesTree selections size) asText allBold.</body><body package="RuntimePackager">visibleSelectorsIn: cl 	"Answer the selectors currently visible by virtue of being controlled	by one of the selected applications."	^(RuntimeManager selectorsInClass: cl) select: 			[:sel | 			selectedSubapplications 				includes: (Store.Registry containingPackageForSelector: sel class: cl)]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id> <category>menu actions</category><body package="RuntimePackager">browseClasses: aListView	"Browse the selected classes in the view provided"	| anObject assoc |	aListView selectionIndexes isEmpty ifTrue: [ ^self ].	aListView selectionIndexes size &gt; 1		ifTrue: [ assoc := self class choose: 'Choose a class'					fromList: aListView selections ]		ifFalse: [ assoc := aListView selections first ].	assoc isNil ifTrue: [ ^self ].	anObject := assoc value.	anObject isBehavior		ifTrue: [ RuntimeBuilderUI browseClass: anObject ]		ifFalse: [ ( anObject valueOrDo: [ ^self ] ) inspect ].</body><body package="RuntimePackager">browseContingentClasses	"Browse selected contingent classes"	self browseClasses: self contingentClassesList.</body><body package="RuntimePackager">browseContingentMethods	"Browse selected methods"	self browseMethods: self contingentMethodsList</body><body package="RuntimePackager">browseDeletedClasses	"Browse selected deleted classes"	self browseClasses: self deletedClassesList.</body><body package="RuntimePackager">browseDeletedMethods	"Browse selected methods"	self browseMethods: self deletedMethodsList</body><body package="RuntimePackager">browseKeptClasses	"Browse selected contingent classes"	self browseClasses: self keptClassesList.</body><body package="RuntimePackager">browseKeptMethods	"Browse selected methods"	self browseMethods: self keptMethodsList</body><body package="RuntimePackager">browseMethods: aListView	"Browse the selected methods in the view provided"	| methods  |	aListView selectionIndexes isEmpty ifTrue: [ ^ self ].	methods := aListView selections collect: [ :x |			MethodDefinition class: x value first selector: x value last ].	MethodCollector new openListBrowserOn: methods label: 'Methods Browser'.</body><body package="RuntimePackager">browseSelectedPundle	self systemCategoriesList treeHolder selections do: [:each |		Refactory.Browser.RefactoringBrowser open navigator selectPundle: each value].</body><body package="RuntimePackager">clearAllContingentClasses	"Clear all contingent classes"	self contingentClassesList clearAll.</body><body package="RuntimePackager">clearAllContingentMethods	"Clear all methods"	self contingentMethodsList clearAll.</body><body package="RuntimePackager">clearAllDeletedClasses	"Clear all deleted classes"	self deletedClassesList clearAll.</body><body package="RuntimePackager">clearAllDeletedMethods	"Clear all methods"	self deletedMethodsList clearAll.</body><body package="RuntimePackager">clearAllKeptClasses	"Clear all kept classes"	self keptClassesList clearAll.</body><body package="RuntimePackager">clearAllKeptMethods	"Clear all methods"	self keptMethodsList clearAll.</body><body package="RuntimePackager">extendedReferenceContingentClasses	"Browse references to selected classes"	self extendedReferencesTo: self contingentClassesList.</body><body package="RuntimePackager">extendedReferenceContingentMethods	"Browse references to selected methods"	self extendedReferencesToMethods: self contingentMethodsList.</body><body package="RuntimePackager">extendedReferenceDeletedClasses	"Browse references to selected classes"	self extendedReferencesTo: self deletedClassesList.</body><body package="RuntimePackager">extendedReferenceDeletedMethods	"Browse references to selected methods"	self extendedReferencesToMethods: self deletedMethodsList.</body><body package="RuntimePackager">extendedReferenceKeptClasses	"Browse references to selected classes"	self extendedReferencesTo: self keptClassesList.</body><body package="RuntimePackager">extendedReferenceKeptMethods	"Browse references to selected methods"	self extendedReferencesToMethods: self keptMethodsList.</body><body package="RuntimePackager">extendedReferencesTo: aListView	"Browse class references to the selected classes in the view provided"	| sel target |	aListView selectionIndexes size = 0 ifTrue: [ ^ self ].	sel := aListView selections first.	( aListView selectionIndexes size ) &gt; 1 ifTrue: [		sel := Dialog choose: 'Choose one'			fromList: ( aListView selections collect: [ :x | x key ] )			values: aListView selections			lines: 10			cancel: [ ^self ] ].	" See whether a class or global was selected "	target := sel value isBehavior		ifTrue: [ sel value fullName ]		ifFalse: [ sel value asString ].	RuntimeBuilderReferenceBrowser openOn: target withItems: subject.</body><body package="RuntimePackager">extendedReferencesToMethods: aListView	"Browse class references to the selected methods in the view provided"	| sel |	aListView selectionIndexes size = 0 ifTrue: [ ^ self ].	sel := aListView selections first.	( aListView selectionIndexes size ) &gt; 1 ifTrue: [		sel := self class choose: 'Choose one'			fromList: ( aListView selections ).		sel isNil ifTrue: [ ^ self ] ].	RuntimeBuilderReferenceBrowser openOn: sel value last withItems: subject.</body><body package="RuntimePackager">implementorsOfContingentMethods	"Browse implementors of the selected methods"	self implementorsOfMethods: self contingentMethodsList.</body><body package="RuntimePackager">implementorsOfDeletedMethods	"Browse implementors of the selected methods"	self implementorsOfMethods: self deletedMethodsList.</body><body package="RuntimePackager">implementorsOfKeptMethods	"Browse implementors of the selected methods"	self implementorsOfMethods: self keptMethodsList.</body><body package="RuntimePackager">implementorsOfMethods: aListView 	"Browse implementors of the selected methods in the 	view provided"	| sel mc |	aListView selectionIndexes isEmpty ifTrue: [^self].	sel := aListView selectionIndexes size &gt; 1				ifTrue: [self class choose: 'Choose selector to browse' fromList: aListView selections]				ifFalse: [aListView selections first].	sel isNil ifTrue: [^self].	mc := MethodCollector new.	mc browseSelect: (mc implementorsOf: sel value last)</body><body package="RuntimePackager">resetAllCategoriesToDefaults	"Reset all categories/applications to default values."	"Make sure the user meant it"	( Dialog confirm: 'Really reset all packages/bundles to default settings?' )		ifFalse: [ ^ self ].	" do the deed "	self resetToDefaults: Store.Registry allPundles.	" now rebuild all lists "	self systemCategoriesSelectionChanged.</body><body package="RuntimePackager">resetSelectedCategoriesToDefaults	"Reset the selected category/application to default values leaving other classes	and globals as they were."	"Make sure the user meant it"	( Dialog confirm: 'Really reset selected packages/bundles to default settings?' )		ifFalse: [ ^ self ].	" do the deed "	self resetToDefaults: (self systemCategoriesList treeHolder selections collect: [:each | each value]).	" now rebuild all lists "	self systemCategoriesSelectionChanged.</body><body package="RuntimePackager">resetToDefaults: packages	"Reset the packages or bundles to default values leaving other classes	and globals as they were."	"See which classes are affected and set definedClasses etc."	workingCopy resetToDefaults: packages.	" remember that we changed things "	isChanged := true.</body><body package="RuntimePackager">selectAllContingentClasses	"Select all contingent classes"	self contingentClassesList selectAll.</body><body package="RuntimePackager">selectAllContingentMethods	"Select all methods"	self contingentMethodsList selectAll.</body><body package="RuntimePackager">selectAllDeletedClasses	"Select all deleted classes"	self deletedClassesList selectAll.</body><body package="RuntimePackager">selectAllDeletedMethods	"Select all methods"	self deletedMethodsList selectAll.</body><body package="RuntimePackager">selectAllKeptClasses	"Select all kept classes"	self keptClassesList selectAll.</body><body package="RuntimePackager">selectAllKeptMethods	"Select all methods"	self keptMethodsList selectAll.</body><body package="RuntimePackager">selectByCategory: aList widgetName: aSymbol	"Select the methods in a given category"	| classes categories protocol selections index |	classes := self selectedClasses.	categories := classes inject: IdentitySet new into: [ :set :cl |		set addAll: cl organization categories;			addAll: cl class organization categories;			yourself ].	protocol := self class choose: 'Select a category' fromList: (		List new addAll: categories; sort; yourself ).	protocol isNil ifTrue: [ ^self ].	selections := aList list select: [ :sel |		( sel value first organization categoryOfElement: sel value last )			= protocol ].	selections isEmpty ifFalse: [		index := aList list indexOf: selections first.		( self builder componentAt: aSymbol ) widget			makeVisible: index;			targetIndex: index.		aList selections: selections. ].</body><body package="RuntimePackager">selectClassFrom: aListView widgetName: widgetName	"Choose one of the selected items in aList and select the class in all categories"	| selections selectedClass index selection |	selections := aListView selections.	selections size = 0 ifTrue: [ ^self ].	selections size = 1		ifTrue: [ selectedClass := selections first value ]		ifFalse: [			selection :=  self class choose:				'Which class should be selected in all packages?'				fromList: aListView selections.			selection isNil ifTrue: [ ^self ].			selectedClass := selection value. ].	selectedClass isBehavior ifFalse: [ ^self ].	self findCategoryWithGlobal: selectedClass.	index := aListView list findFirst: [ :assoc | assoc value = selectedClass] .	aListView selectionIndexes: ( Set with: index ).	( self builder componentAt: widgetName ) widget		makeVisible: index;		targetIndex: index.</body><body package="RuntimePackager">selectContingentClass	"Choose one of the selected items and select the class in all categories"	self selectClassFrom: self contingentClassesList widgetName: #contingentClassesList.</body><body package="RuntimePackager">selectContingentMethodsByCategory	"Select methods by category"	self selectByCategory: self contingentMethodsList		widgetName: #contingentMethodsList.</body><body package="RuntimePackager">selectDeletedClass	"Choose one of the selected items and select the class in all categories"	self selectClassFrom: self deletedClassesList widgetName: #deletedClassesList.</body><body package="RuntimePackager">selectDeletedMethodsByCategory	"Select methods by category"	self selectByCategory: self deletedMethodsList		widgetName: #deletedMethodsList.</body><body package="RuntimePackager">selectKeptClass	"Choose one of the selected items and select the class in all categories"	self selectClassFrom: self keptClassesList widgetName: #keptClassesList.</body><body package="RuntimePackager">selectKeptMethodsByCategory	"Select methods by category"	self selectByCategory: self keptMethodsList		widgetName: #keptMethodsList.</body><body package="RuntimePackager">stepHelp	"Open a help window"	RuntimeBuilderUI helpFor: #helpForItems.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id> <category>actions</category><body package="RuntimePackager">classSelectionChanged	"Respond to a change in selections in classes"	Cursor wait showWhile: [		self buildMethodLists. ].</body><body package="RuntimePackager">deleteAllInPundle: aPundle	workingCopy deleteAllInPundle: aPundle.</body><body package="RuntimePackager">deleteSelectedPundle	"Move everything in the selected pundle(s) to deleted."	self systemPackagesTree selections do: [:each |		each withAllContainedItems do: [:eachSubItem |			eachSubItem isBundle ifFalse: [self deleteAllInPundle: eachSubItem]]].	self systemCategoriesSelectionChanged.	isChanged := true.</body><body package="RuntimePackager">findCategoryWithClassOrGlobal: foundItem	"Prompt for a class or global and select the category or categories	containing it. Answer the item selected or nil if none.	Select the item found whichever category it is in."	| index |	self deletedClassesList clearAll.	self contingentClassesList clearAll.	self keptClassesList clearAll.	( index := self deletedClassesList list findFirst: [ :x |			x value = foundItem ] ) &gt; 0 ifTrue: [		( self builder componentAt: #deletedClassesList ) widget			makeVisible: index;			targetIndex: index.		self deletedClassesList selectionIndexes: ( Set with: index ).		^foundItem ].	( index := self contingentClassesList list findFirst: [ :x |			x value = foundItem ] ) &gt; 0 ifTrue: [		( self builder componentAt: #contingentClassesList ) widget			makeVisible: index;			targetIndex: index.		self contingentClassesList selectionIndexes: ( Set with: index ).		^foundItem ].	( index := self keptClassesList list findFirst: [ :x |			x value = foundItem ] ) &gt; 0 ifTrue: [		( self builder componentAt: #keptClassesList ) widget			makeVisible: index;			targetIndex: index.		self keptClassesList selectionIndexes: ( Set with: index ).		^foundItem ].	"should never occur"	^nil</body><body package="RuntimePackager">findCategoryWithGlobal	"Prompt for a class and select the category or categories	containing it. Answer the class selected or nil if none.	Select the class found whichever category it is in."	| foundGlobal |	( foundGlobal := super findCategoryWithGlobal ) isNil		ifTrue: [ ^ nil ].	^self findCategoryWithClassOrGlobal: foundGlobal.</body><body package="RuntimePackager">keepAllInPundle: aPundle	| hierarchyErrors |	hierarchyErrors := self validateClassesInPundle: aPundle definedClasses.	(hierarchyErrors isEmpty) ifFalse: [^self].	workingCopy keepAllInPundle: aPundle.</body><body package="RuntimePackager">keepSelectedPundle	"Move everything in the selected pundle(s) to kept"	self systemPackagesTree selections do: [:each |		each withAllContainedItems do: [:eachSubItem |			eachSubItem isBundle ifFalse: [self keepAllInPundle: eachSubItem]]].	self systemCategoriesSelectionChanged.	isChanged := true.</body><body package="RuntimePackager">makeAllInPundleContingent: aPundle	workingCopy makeAllInPundleContingent: aPundle.</body><body package="RuntimePackager">makeSelectedPundleContingent	"Move everything in the selected pundle(s) to deleted."	self systemPackagesTree selections do: [:each |		each withAllContainedItems do: [:eachSubItem |			eachSubItem isBundle ifFalse: [self makeAllInPundleContingent: eachSubItem]]].	self systemCategoriesSelectionChanged.	isChanged := true.</body><body package="RuntimePackager">moveClassesContingentToDeleted	"Move selected classes from contigent to deleted"	| sel classesToDelete selectedClassesChanged |	self contingentClassesList selectionIndexes isEmpty ifTrue: [ ^ self ].	classesToDelete := self validateDeletableClassSelections: (		self contingentClassesList selections ).	classesToDelete size == 0  ifFalse: [		self deleteHierarchyOf: classesToDelete.		^self ].	Cursor wait showWhile: [		self retractInterests.		selectedClassesChanged := self deletedClassesList selectionIndexes isEmpty not.		sel := self moveClassSelectionsFrom: self contingentClassesList				to: self deletedClassesList.		selectedClassesChanged ifTrue: [			self buildMethodLists. ].		sel do: [ :assoc | assoc value isBindingReference			ifFalse: [ workingCopy deleteClass: assoc value ]			ifTrue: [ workingCopy deleteGlobal: assoc value ] ].		isChanged := true.		self expressInterests. ].</body><body package="RuntimePackager">moveClassesContingentToKept	"Move selected classes from contigent to kept"	| sel classesToKeep  selections selectedClassesChanged |	self contingentClassesList selectionIndexes isEmpty ifTrue: [ ^ self ].	selections := self contingentClassesList selections.	classesToKeep := self validateKeptClassSelections: selections.	classesToKeep size == 0 ifFalse: [		self keepHierarchyOf: classesToKeep.		^self ]."	The following test is obsolete.	parcelErrors := self validateKeptClassesWRTParcels: selections.	parcelErrors size ==0 ifFalse: [		self displayParcelErrorMsg: parcelErrors.		^self ]."	Cursor wait showWhile: [		self retractInterests.		selectedClassesChanged := self keptClassesList selectionIndexes isEmpty not.		sel := self moveClassSelectionsFrom: self contingentClassesList				to: self keptClassesList.		selectedClassesChanged ifTrue: [			self buildMethodLists. ].		sel do: [ :assoc | assoc value isBindingReference			ifFalse: [ workingCopy keepClass: assoc value ]			ifTrue: [ workingCopy keepGlobal: assoc value ] ].		isChanged := true.		self expressInterests. ].</body><body package="RuntimePackager">moveClassesDeletedToContingent	"Move selected classes from deleted to contingent"	| sel selectedClassesChanged |	self deletedClassesList selectionIndexes isEmpty ifTrue: [ ^ self ].	Cursor wait showWhile: [		self retractInterests.		selectedClassesChanged := self contingentClassesList				selectionIndexes isEmpty not.		sel := self moveClassSelectionsFrom: self deletedClassesList					to: self contingentClassesList.		selectedClassesChanged ifTrue: [			self buildMethodLists. ].		sel do: [ :assoc |			assoc value isBindingReference				ifFalse: [ workingCopy dontDeleteClass: assoc value ]				ifTrue: [ workingCopy dontDeleteGlobal: assoc value ] ].		isChanged := true.		self expressInterests. ].</body><body package="RuntimePackager">moveClassesKeptToContigent	"Move selected classes from kept to contingent"	| sel selectedClassesChanged |	self keptClassesList selectionIndexes isEmpty ifTrue: [ ^ self ].	Cursor wait showWhile: [		self retractInterests.		selectedClassesChanged := self contingentClassesList				selectionIndexes isEmpty not.		sel := self moveClassSelectionsFrom: self keptClassesList				to: self contingentClassesList.		selectedClassesChanged ifTrue: [			self buildMethodLists. ].		sel do: [ :assoc |			assoc value isBindingReference				ifFalse: [ workingCopy dontKeepClass: assoc value ]				ifTrue: [ workingCopy dontKeepGlobal: assoc value ] ].		isChanged := true.		self expressInterests. ].</body><body package="RuntimePackager">moveMethodsContingentToDeleted	"Move selected methods from contigent to deleted"	| sel selections cl |	self contingentMethodsList selectionIndexes isEmpty ifTrue: [ ^ self ].	Cursor wait showWhile: [		self retractInterests.		selections := self moveSelectionsFrom:			self contingentMethodsList to: self deletedMethodsList.		selections do: [ :assoc |			cl := assoc value first.			sel := assoc value last.			self deleteSelector: sel inClass: cl].		isChanged := true.		self expressInterests. ].</body><body package="RuntimePackager">moveMethodsContingentToKept	"Move selected methods from contigent to kept"	| sel selections cl |	self contingentMethodsList selectionIndexes isEmpty ifTrue: [ ^ self ].	Cursor wait showWhile: [		self retractInterests.		selections := self moveSelectionsFrom:			self contingentMethodsList to: self keptMethodsList.		selections do: [ :assoc |			cl := assoc value first.			sel := assoc value last.			self keepSelector: sel inClass: cl ].		isChanged := true.		self expressInterests. ].</body><body package="RuntimePackager">moveMethodsDeletedToContingent	"Move selected methods from deleted to contingent"	| sel selections cl |	self deletedMethodsList selectionIndexes isEmpty ifTrue: [ ^ self ].	Cursor wait showWhile: [		self retractInterests.		selections := self moveSelectionsFrom:			self deletedMethodsList to: self contingentMethodsList.		selections do: [ :assoc |			cl := assoc value first.			sel := assoc value last.			self dontDeleteSelector: sel inClass: cl].		isChanged := true.		self expressInterests. ].</body><body package="RuntimePackager">moveMethodsKeptToContingent	"Move selected methods from kept to contingent"	| sel selections cl |	self keptMethodsList selectionIndexes isEmpty ifTrue: [ ^ self ].	Cursor wait showWhile: [		self retractInterests.		selections := self moveSelectionsFrom:			self keptMethodsList to: self contingentMethodsList.		selections do: [ :assoc |			cl := assoc value first.			sel := assoc value last.			self dontKeepSelector: sel inClass: cl. ].		isChanged := true.		self expressInterests. ].</body><body package="RuntimePackager">selectPrerequisites	"Add the prerequisites of the currently selected items to the selections, recursively."	| new all next prereqs |	new := OrderedCollection new.	self systemPackagesTree selections do: [:each |		new addAll: each withAllContainedItems].	all := Set new.	[new isEmpty] whileFalse: [		next := new removeFirst.		all add: next.		prereqs := next deploymentPrerequisites collect: [:each |			Store.Registry pundleNamed: each first].		new addAll: (prereqs select: [:each | each notNil])].	self systemPackagesTree selections: all.	self systemCategoriesSelectionChanged.	isChanged := true.</body><body package="RuntimePackager">systemCategoriesSelectionChanged	"respond to a change in selections among system categories"	Cursor wait showWhile: [		self retractInterests.		self buildClassLists.		self buildMethodLists.		self expressInterests.		self updateCategoryTitle ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id> <category>aspects</category><body package="RuntimePackager">contingentClassesList	"Answer the list of contingent classes"	^contingentClassesList isNil		ifTrue: [contingentClassesList := MultiSelectionInList new]		ifFalse: [contingentClassesList]</body><body package="RuntimePackager">contingentMethodsList	"Answer the list of contingent method names"	^contingentMethodsList isNil		ifTrue: [contingentMethodsList := MultiSelectionInList new]		ifFalse: [contingentMethodsList]</body><body package="RuntimePackager">deletedClassesList	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^deletedClassesList isNil ifTrue: [deletedClassesList := MultiSelectionInList new] ifFalse: [deletedClassesList]</body><body package="RuntimePackager">deletedMethodsList	"Answer the list of deleted method names"	^deletedMethodsList isNil		ifTrue: [deletedMethodsList := MultiSelectionInList new]		ifFalse: [deletedMethodsList]</body><body package="RuntimePackager">keptClassesList	"Answer the list of kept class names"	^keptClassesList isNil		ifTrue: [keptClassesList := MultiSelectionInList new]		ifFalse: [keptClassesList]</body><body package="RuntimePackager">keptMethodsList	"Answer the list of kpet method names"	^keptMethodsList isNil		ifTrue: [keptMethodsList := MultiSelectionInList new]		ifFalse: [keptMethodsList]</body><body package="RuntimePackager">systemCategoriesList	"Answer the list of system category (organization) names"	^self systemPackagesTree</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id> <category>interface opening</category><body package="RuntimePackager">postBuildWith: aBuilder trackingChanges: aBoolean	"Bypass setting up dependencies to track changes"	super postBuildWith: aBuilder trackingChanges: false.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id> <category>validations</category><body package="RuntimePackager">validateClassesInPundle: classes"Verify that superclasses of the classes in the pundle are not among those marked for deletion."	| hierarchyErrors |	hierarchyErrors := self validateKeptClasses: classes.	hierarchyErrors isEmpty ifFalse: [ self displayHierarchyErrorMsg: hierarchyErrors].	^hierarchyErrors.</body><body package="RuntimePackager">validateDeletableClassSelections: selections	"Validate that the class selections as deletable"	^workingCopy validateDeletableClasses: ( self movableClassesFrom: selections )</body><body package="RuntimePackager">validateDeletableClasses: classes	"Validate that the set of classes provided can be moved to the deleted category	without causing an error in which a subclass is kept while its superclass is deleted.	Answer an ordered collection of any classes in error.	classes can also contain globals.  These are not tested "	| errors |	errors := OrderedCollection new.	classes do: [:cl |		"watch for globals that could get included here"		cl isSymbol ifFalse: [			( cl withAllSubclasses contains: [ :scl | self keptClasses includes: scl ] )				ifTrue: [ errors add: cl ] ] ].	^errors</body><body package="RuntimePackager">validateKeptClassSelections: selections	"Validate that the class selections as kept"	^self validateKeptClasses: ( self movableClassesFrom: selections )</body><body package="RuntimePackager">validateKeptClasses: classes	"Validate that the set of classes provided can be moved to the kept category	without causing an error in which a subclass is kept while its superclass is deleted.	Answeran ordered collection of any class names in error	classNames can also contain globals.  These are not tested "	| errors |	errors := OrderedCollection new.	classes do: [:cl |		"watch for globals that could get included here"		cl isSymbol ifFalse: [			( cl withAllSuperclasses				contains: [ :scl | self deletedClasses includes: scl  ] )				ifTrue: [ errors add: cl ] ] ].	^errors</body><body package="RuntimePackager">validateKeptClassesWRTParcels: classSelections	"Validate that the set of classes provided can be moved to the kept category	without conflicting with parcels.  This is an approximation since the contents	of parcels can change at any time.	Answer an ordered collection of any classes in error	classes can also contain symbols which are globals.  These are not tested "	| errors loadables cl |	loadables := subject options loadableClasses.	loadables isEmpty ifTrue: [ ^OrderedCollection new ].	errors := OrderedCollection new.	classSelections do: [:assoc |		cl := assoc value.		"watch for globals that could get included here"		cl isSymbol ifFalse: [			( cl withAllSuperclasses				select: [ :scl | loadables includes: cl ] ) isEmpty					ifFalse: [ errors add: cl ] ] ].	^errors</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id> <category>accessing</category><body package="RuntimePackager">bindingsInCurrentlySelected	^bindingsInCurrentlySelected</body><body package="RuntimePackager">bindingsInCurrentlySelected: aSet	bindingsInCurrentlySelected := aSet</body><body package="RuntimePackager">deletedClasses	^workingCopy deletedClasses</body><body package="RuntimePackager">deletedClasses: aCollection	workingCopy deletedClasses: aCollection</body><body package="RuntimePackager">deletedGlobals	^workingCopy deletedGlobals</body><body package="RuntimePackager">deletedGlobals: anObject	workingCopy deletedGlobals: anObject</body><body package="RuntimePackager">deletedMethods	^workingCopy deletedMethods</body><body package="RuntimePackager">deletedMethods: anObject	workingCopy deletedMethods: anObject</body><body package="RuntimePackager">initializeSystemPackagesTreeWidget	systemPackagesTree := TreeSelectionModule forStoreBundlesAndPackages.	systemPackagesTree useMultiSelection: true.	systemPackagesTree menu: self class systemSelectionMenu performer: self.</body><body package="RuntimePackager">keptClasses	^workingCopy keptClasses</body><body package="RuntimePackager">keptClasses: aCollection	workingCopy keptClasses: aCollection</body><body package="RuntimePackager">keptGlobals	^workingCopy keptGlobals</body><body package="RuntimePackager">keptGlobals: anObject	workingCopy keptGlobals: anObject</body><body package="RuntimePackager">keptMethods	^workingCopy keptMethods</body><body package="RuntimePackager">keptMethods: anObject	workingCopy keptMethods: anObject</body><body package="RuntimePackager">systemPackagesTree	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^systemPackagesTree isNil		ifTrue: 			[self initializeSystemPackagesTreeWidget. systemPackagesTree]		ifFalse:			[systemPackagesTree]</body><body package="RuntimePackager">workingCopy	^workingCopy</body><body package="RuntimePackager">workingCopy: anObject	workingCopy := anObject</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser</class-id> <category>testing</category><body package="RuntimePackager">isDeletedSelector: aSymbol in: aBehavior	"Answer true if aSymbol names a deleted method in the behavior"	^workingCopy isDeletedSelector: aSymbol in: aBehavior.</body><body package="RuntimePackager">isKeptSelector: aSymbol in: aBehavior	"Answer true if aSymbol names a kept method in the behavior"	^workingCopy isKeptSelector: aSymbol in: aBehavior.</body><body package="RuntimePackager">isPundleSelected	^self systemPackagesTree hasSelection.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser class</class-id> <category>resources</category><body package="RuntimePackager">mainMenu	^self mainMenuVW.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer</class-id> <category>actions</category><body package="RuntimePackager">accept	"Because this is read only, accept is the same as cancel"	self cancel.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer</class-id> <category>internals</category><body package="RuntimePackager">buildClassLists	"Set the contents of deleted, kept and contingent class lists based upon	currently selected categories. Preserve existing selections as much	as possible."	| keptSelections   deletedSelections |	"save existing selections"	deletedSelections := self deletedClassesList selections.	keptSelections := self keptClassesList selections.	" build new lists "	self buildSelectableClassList.	self deletedClassesList list: (		selectableClassList select: [ :assoc |			( self deletedClasses includes: assoc value ) |			( self deletedGlobals includes: assoc value ) ] ).	self keptClassesList list: (		selectableClassList reject: [ :assoc |			( self deletedClasses includes: assoc value  ) |			( self deletedGlobals includes: assoc value ) ] ).	"restore selections"	self setSelections: deletedSelections in: self deletedClassesList.	self setSelections: keptSelections in: self keptClassesList.</body><body package="RuntimePackager">buildMethodLists	"Set the contents of deleted, kept, and contingent method lists based upon	currently selected classes.  Preserve existing method selections	as much as possible"	|  	classes keptSelections deletedSelections		keptSel deletedSel selKey multipleClasses who isDeletedClass		className metaName |	"save existing selections"	deletedSelections := self deletedMethodsList selections.	keptSelections := self keptMethodsList selections.	" build new lists "	" first determine which classes are involved "	classes := self selectedClasses.	multipleClasses := ( classes size &gt; 1 ).	" build up sets of deleted, contingent, and kept selectors"	keptSel := List new: 127.	deletedSel := List new: 127.	classes do: [ :cl |		className := cl name.		metaName := cl class name.		isDeletedClass := self deletedClasses includes: cl.		( self visibleSelectorsIn: cl ) do: [ :sel |			who := Array with: cl with: sel.			selKey := self selectorDisplayString: sel in: cl						name: className multiple: multipleClasses.			( isDeletedClass or: [  self isDeletedSelector: sel in: cl ] )				ifTrue: [ deletedSel add: selKey -&gt; who ]				ifFalse: [ keptSel add: selKey -&gt; who ] ].		( self visibleSelectorsIn: cl class ) do: [ :sel |			who := Array with: cl class with: sel.			selKey := self selectorDisplayString: sel in: cl class						name: metaName multiple: multipleClasses.			( isDeletedClass or: [  self isDeletedSelector: sel in: cl class ] )				ifTrue: [ deletedSel add: selKey -&gt; who ]				ifFalse: [ keptSel add: selKey -&gt; who ] ] ].	" sort the lists -- save some indirections in the compare "	keptSel sortWith: [ :x :y | x key &lt; y key ].	deletedSel sortWith: [ :x :y | x key &lt; y key ].	" save as new lists "	self keptMethodsList list: keptSel.	self deletedMethodsList list: deletedSel.	"restore selections"	self setSelectionOnValues: deletedSelections in: self deletedMethodsList.	self setSelectionOnValues: keptSelections in: self keptMethodsList.</body><body package="RuntimePackager">changeRequest	"Indicate that the window can be closed if the superclass permits"	super changeRequest ifFalse: [ ^false ].	subject terminateView.	^true</body><body package="RuntimePackager">copyValuesFromSubject	"This is a bit weird, because we're really modifying our working copy to display according to our options, but since we know we'll never save it, it doesn't matter."	super copyValuesFromSubject.	self deletedClasses: (subject allDeletedClassesWithLoadables: (			self showParcelsAs value = #deleted )).	self deletedMethods: (subject allDeletedMethodsWithLoadables: (		self showParcelsAs value = #deleted )).	subject options stripGlobals		ifTrue: [ self deletedGlobals: subject allDeletedGlobals.]		ifFalse: [ self deletedGlobals: IdentitySet new ].</body><body package="RuntimePackager">copyValuesToSubject	"Copy values to the subject. Since this is a read-only view, do nothing"	^self</body><body package="RuntimePackager">expressInterests	"Setup interests in changed window contents"	self systemCategoriesList selectionIndexHolder		onChangeSend: #systemCategoriesSelectionChanged to: self.	self keptClassesList selectionIndexHolder		onChangeSend: #classSelectionChanged to: self.	self deletedClassesList selectionIndexHolder		onChangeSend: #classSelectionChanged to: self.</body><body package="RuntimePackager">retractInterests	"Retract interests in changed window contents"	self systemCategoriesList selectionIndexHolder		retractInterestsFor: self.	self keptClassesList selectionIndexHolder		retractInterestsFor: self.	self deletedClassesList selectionIndexHolder		retractInterestsFor: self.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer</class-id> <category>initialization</category><body package="RuntimePackager">initialize	"Initialize the instance within the framework"	self showParcelsAs value: #kept.	super initialize.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer</class-id> <category>interface opening</category><body package="RuntimePackager">postBuildWith: aBuilder trackingChanges: aBoolean	" Hook in relationships "	super postBuildWith: aBuilder trackingChanges: aBoolean.	self showParcelsAs onChangeSend: #refresh to: self.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer</class-id> <category>aspects</category><body package="RuntimePackager">showParcelsAs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^showParcelsAs isNil		ifTrue:			[showParcelsAs := nil asValue]		ifFalse:			[showParcelsAs]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer</class-id> <category>menu actions</category><body package="RuntimePackager">stepHelp	"Open a help window"	RuntimeBuilderUI helpFor: #helpForReview.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer</class-id> <category>reporting</category><body package="RuntimePackager">generateReport	"Write out deleted  classes and methods to a file.  This is your basic report generation	logic with nothing fancy about its design at all."	| file out preSort postSort prevCat selDeleted selInDeletedClasses totalSelectors totalClasses keyBlock keyTitle deletedSel loadedParcelCount loadedNameSpaceCount |	(	[file := (Dialog 				request: 'File name to which report should be written'				initialAnswer: 'report.txt'				onCancel: [^self]) asFilename.	file canBeWritten] 			on: OSErrorHolder errorSignal			do: [:ex | ex return: false]) 			ifFalse: 				[Dialog warn: 'Report file cannot be written with name supplied'.				^self].	file exists 		ifTrue: 			[(Dialog confirm: file asString , ' already exists.\Use it anyway?' withCRs) 				ifFalse: [^self]].	keyBlock := [:cls | (Store.Registry containingPackageForClass: cls) name].	keyTitle := 'Package'.	" show work in progress "	Cursor write showWhile: 			[" open the output file "						[out := file writeStream.			" write a title for the report "			out				nextPutAll: 'RUNTIME PACKAGER KEPT AND DELETED CLASSES, METHODS, AND VARIABLES';				cr;				nextPutAll: Date today printString;				space;				nextPutAll: Time now printString;				cr.			out				cr;				nextPutAll: 'Classes and methods loaded from parcels are shown as ';				nextPutAll: self showParcelsAs value asUppercase;				cr.			" intialize counters "			totalSelectors := 0.			totalClasses := 0.			" now print each report in category / class name sequence "			out				cr;				nextPutAll: 'DELETED CLASSES BY ';				nextPutAll: keyTitle asUppercase.			preSort := OrderedCollection new: (self deletedClasses) size.			self deletedClasses do: [:cl | preSort add: cl -&gt; (keyBlock value: cl)].			postSort := preSort asSortedCollection: 							[:x :y | 							x value &lt; y value or: [x value = y value and: [x key name &lt; y key name]]].			prevCat := nil.			selInDeletedClasses := 0.			postSort do: 					[:clAndCat | 					| cl cat |					cl := clAndCat key.					cat := clAndCat value.					" category break "					cat = prevCat 						ifFalse: 							[out								cr;								cr;								nextPutAll: cat;								nextPutAll: ' deleted classes:'.							prevCat := cat].					out						cr;						space;						space;						nextPutAll: cl name.					selInDeletedClasses := selInDeletedClasses 								+ (RuntimeManager selectorsInClass: cl) size 									+ (RuntimeManager selectorsInClass: cl class) size].			" now print report of deleted selectors in category / class name sequence "			out				cr;				cr;				nextPutAll: 'DELETED METHODS BY ';				nextPutAll: keyTitle asUppercase;				nextPutAll: ' AND CLASS'.			preSort := OrderedCollection new.			RuntimeManager allClassesDo: 					[:cl | 					totalClasses := totalClasses + 1.					totalSelectors := totalSelectors 								+ (RuntimeManager selectorsInClass: cl) size 									+ (RuntimeManager selectorsInClass: cl class) size.					(self deletedClasses includes: cl) not 						ifTrue: [preSort add: cl -&gt; (keyBlock value: cl)]].			postSort := preSort asSortedCollection: 							[:x :y | 							x value &lt; y value or: [x value = y value and: [x key name &lt; y key name]]].			prevCat := nil.			selDeleted := 0.			postSort do: 					[:clAndCat | 					| cl cat charCount anyDeletedSel |					cl := clAndCat key.					cat := clAndCat value.					"class report including selectors."					anyDeletedSel := false.					(self deletedMethods at: cl ifAbsent: [#()]) asSortedCollection do: 							[:sel | 							anyDeletedSel 								ifFalse: 									[" test category break "									cat = prevCat 										ifFalse: 											[out												cr;												cr;												nextPutAll: cat.											prevCat := cat].									" print class name "									out										cr;										cr;										space;										space;										nextPutAll: cl name;										nextPutAll: ' deleted methods:'.									charCount := 1000.									anyDeletedSel := true].							selDeleted := selDeleted + 1.							charCount := charCount + sel size + 1.							charCount &gt; 60 								ifTrue: 									[out crtab.									charCount := sel size + 1].							out								nextPutAll: sel;								space].					" and now the meta class "					anyDeletedSel := false.					(self deletedMethods at: cl class ifAbsent: [#()]) asSortedCollection do: 							[:sel | 							anyDeletedSel 								ifFalse: 									[" test category break "									cat = prevCat 										ifFalse: 											[out												cr;												cr;												nextPutAll: cat.											prevCat := cat].									" print metaclass name"									out										cr;										cr;										space;										space;										nextPutAll: cl class name;										nextPutAll: ' deleted methods:'.									charCount := 1000.									anyDeletedSel := true].							selDeleted := selDeleted + 1.							charCount := charCount + sel size + 1.							charCount &gt; 60 								ifTrue: 									[out crtab.									charCount := sel size + 1].							out								nextPutAll: sel;								space]].			" now print report of deleted selectors in category / class name sequence "			out				cr;				cr;				nextPutAll: 'KEPT METHODS BY ';				nextPutAll: keyTitle asUppercase;				nextPutAll: ' AND CLASS'.			preSort := OrderedCollection new.			RuntimeManager allClassesDo: 					[:cl | 					(self deletedClasses includes: cl) not 						ifTrue: [preSort add: cl -&gt; (keyBlock value: cl)]].			postSort := preSort asSortedCollection: 							[:x :y | 							x value &lt; y value or: [x value = y value and: [x key name &lt; y key name]]].			prevCat := nil.			postSort do: 					[:clAndCat | 					| cl cat charCount anyKeptSel |					cl := clAndCat key.					cat := clAndCat value.					"class report including kept selectors."					anyKeptSel := false.					deletedSel := self deletedMethods at: cl ifAbsent: [#()].					(RuntimeManager selectorsInClass: cl) asSortedCollection do: 							[:sel | 							(deletedSel includes: sel) 								ifFalse: 									[anyKeptSel 										ifFalse: 											[" test category break "											cat = prevCat 												ifFalse: 													[out														cr;														cr;														nextPutAll: cat.													prevCat := cat].											" print class name "											out												cr;												cr;												space;												space;												nextPutAll: cl name;												nextPutAll: ' kept methods:'.											charCount := 1000.											anyKeptSel := true].									charCount := charCount + sel size + 1.									charCount &gt; 60 										ifTrue: 											[out crtab.											charCount := sel size + 1].									out										nextPutAll: sel;										space]].					" and now the meta class "					anyKeptSel := false.					deletedSel := self deletedMethods at: cl class ifAbsent: [#()].					(RuntimeManager selectorsInClass: cl class) asSortedCollection do: 							[:sel | 							(deletedSel includes: sel) 								ifFalse: 									[anyKeptSel 										ifFalse: 											[" test category break "											cat = prevCat 												ifFalse: 													[out														cr;														cr;														nextPutAll: keyTitle;														space;														nextPutAll: cat.													prevCat := cat].											" print metaclass name"											out												cr;												cr;												space;												space;												nextPutAll: cl class name;												nextPutAll: ' kept methods:'.											charCount := 1000.											anyKeptSel := true].									charCount := charCount + sel size + 1.									charCount &gt; 60 										ifTrue: 											[out crtab.											charCount := sel size + 1].									out										nextPutAll: sel;										space]]].			" report on deleted Globals "			out				cr;				cr;				nextPutAll: 'DELETED GLOBALS'.			self deletedGlobals do: 					[:global | 					out						crtab;						nextPutAll: global asString].			(self deletedGlobals) isEmpty 				ifTrue: 					[out						crtab;						nextPutAll: 'none'].			" report on which parcels are loadable "			loadedParcelCount := 0.			out				cr;				cr;				nextPutAll: 'RUNTIME LOADABLE PARCELS'.			subject options loadableParcels do: 					[:parcel | 					loadedParcelCount := loadedParcelCount + 1.					out						crtab;						nextPutAll: parcel name].			loadedParcelCount = 0 				ifTrue: 					[out						crtab;						nextPutAll: 'none'].			" report on which name spaces are loadable "			loadedNameSpaceCount := 0.			out				cr;				cr;				nextPutAll: 'RUNTIME LOADABLE NAME SPACES'.			subject options loadableNameSpaces do: 					[:ns | 					loadedNameSpaceCount := loadedNameSpaceCount + 1.					out						crtab;						nextPutAll: ns fullName].			loadedNameSpaceCount = 0 				ifTrue: 					[out						crtab;						nextPutAll: 'none'].			" summary information "			out				cr;				cr;				nextPutAll: 'SUMMARY STATISTICS';				cr;				crtab;				nextPutAll: 'Classes entirely deleted:  ' , (self deletedClasses) size printString;				crtab;				nextPutAll: 'Classes kept:  ' 							, (totalClasses - (self deletedClasses) size) printString;				crtab;				nextPutAll: 'Total classes:  ' , totalClasses printString;				crtab;				nextPutAll: 'Percent of classes deleted:  ' 							, ((self deletedClasses) size * 100 // totalClasses) printString , '%';				cr;				crtab;				nextPutAll: 'Methods in deleted classes:  ' 							, selInDeletedClasses printString;				crtab;				nextPutAll: 'Methods separately deleted:  ' , selDeleted printString;				crtab;				nextPutAll: 'Total methods deleted: ' 							, (selDeleted + selInDeletedClasses) printString;				crtab;				nextPutAll: 'Methods kept:  ' 							, (totalSelectors - selDeleted - selInDeletedClasses) printString;				crtab;				nextPutAll: 'Total methods kept and deleted:  ' 							, totalSelectors printString;				crtab;				nextPutAll: 'Percent of methods deleted:  ' 							, ((selDeleted + selInDeletedClasses) * 100 // totalSelectors) printString 								, '%';				cr;				crtab;				nextPutAll: 'Globals deleted:  ' , (self deletedGlobals) size printString;				crtab;				nextPutAll: 'Parcels loaded at runtime: ' , loadedParcelCount printString;				crtab;				nextPutAll: 'Name spaces loaded at runtime: ' 							, loadedNameSpaceCount printString			" close the output file "] 					ensure: [out close]].	" end cursor showWhile "	" show the file just generated "	FileBrowser openOnFileNamed: file asString</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMemoryParamEditor</class-id> <category>aspects</category><body package="RuntimePackager">codeSize	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^codeSize isNil ifTrue: [codeSize := 0 asValue] ifFalse: [codeSize]</body><body package="RuntimePackager">edenSize	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^edenSize isNil ifTrue: [edenSize := 0 asValue] ifFalse: [edenSize]</body><body package="RuntimePackager">fixedSize	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^fixedSize isNil		ifTrue:			[fixedSize := 0 asValue]		ifFalse:			[fixedSize]</body><body package="RuntimePackager">largeSize	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^largeSize isNil ifTrue: [largeSize := 0 asValue] ifFalse: [largeSize]</body><body package="RuntimePackager">memoryPolicyClass	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^memoryPolicyClass isNil		ifTrue:			[memoryPolicyClass := String new asValue]		ifFalse:			[memoryPolicyClass]</body><body package="RuntimePackager">memoryPolicyClasses	| newClasses |	memoryPolicyClasses notNil ifTrue: [^memoryPolicyClasses].	newClasses := AbstractMemoryPolicy withAllSubclasses reject: [:any | any isAbstract].	memoryPolicyClasses := (newClasses collect: [:each | each fullName]) asSortedCollection asValue.	^memoryPolicyClasses</body><body package="RuntimePackager">memoryUpperBound	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^memoryLimit isNil ifTrue: [memoryLimit := 0 asValue] ifFalse: [memoryLimit]</body><body package="RuntimePackager">oldSize	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^oldSize isNil ifTrue: [oldSize := 0 asValue] ifFalse: [oldSize]</body><body package="RuntimePackager">stackSize	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^stackSize isNil ifTrue: [stackSize := 0 asValue] ifFalse: [stackSize]</body><body package="RuntimePackager">survivorSize	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^survivorSize isNil ifTrue: [survivorSize := 0 asValue] ifFalse: [survivorSize]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMemoryParamEditor</class-id> <category>Internals</category><body package="RuntimePackager">copyValuesFromSubject	"Copy value from the subject into aspect holders"	self edenSize value: subject edenSize.	self survivorSize value: subject survivorSize.	self largeSize value: subject largeSize.	self stackSize value: subject stackSize.	self codeSize value: subject codeSize.	self oldSize value: subject oldSize.	self fixedSize value: subject fixedSize.	self memoryPolicyClass value: subject memoryPolicyClass.	self memoryUpperBound value: subject memoryUpperBound</body><body package="RuntimePackager">copyValuesToSubject	"Copy values back to the subject to record the change"	super copyValuesToSubject.	self isChanged ifFalse: [^self].	subject edenSize: self edenSize value.	subject survivorSize: self survivorSize value.	subject largeSize: self largeSize value.	subject stackSize: self stackSize value.	subject codeSize: self codeSize value.	subject oldSize: self oldSize value.	subject fixedSize: self fixedSize value.	subject memoryPolicyClass: self memoryPolicyClass value.	subject memoryUpperBound: self memoryUpperBound value</body><body package="RuntimePackager">stepHelp	"Open a help window"	RuntimeBuilderUI helpFor: #helpForMemory.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMemoryParamEditor</class-id> <category>validations</category><body package="RuntimePackager">validate	"Validate all values before copying them to subject"	| max |	max := ObjectMemory defaultSizesAtStartup collect: [ :x | x asFloat * 1000 ].	" make sure these are positive numbers and not too big"	( self validateRange: #edenSize		low: 10000 high: ( max at: 1) ) ifFalse: [ ^false ].	( self validateRange: #stackSize		low: 10000 high: (max at: 4) ) ifFalse: [ ^false ].	( self validateRange: #survivorSize		low: 10000 high: (max at: 2) ) ifFalse: [ ^false ].	( self validateRange: #codeSize		low: 10000 high: (max at: 5) ) ifFalse: [ ^false ].	( self validateRange: #largeSize		low: 10000 high: (max at: 3) ) ifFalse: [ ^false ].	( self validateRange: #oldSize		low: 10000 high: (max at: 6) ) ifFalse: [ ^false ].	" check memory policy values "	( self validatePositive: #memoryUpperBound ) ifFalse: [ ^false ].	^true</body></methods><methods><class-id>RuntimePackager.HierarchyErrorMessage</class-id> <category>actions</category><body package="RuntimePackager">continue	^self accept value</body><body package="RuntimePackager">copy	ParagraphEditor currentSelection: self errorString value asText.</body></methods><methods><class-id>RuntimePackager.HierarchyErrorMessage</class-id> <category>accessing</category><body package="RuntimePackager">description	^'Potential Runtime Image Problem:\The following classes have a superclass or namespace that will be stripped from the runtime image, or has a superclass that will be kept,\but with all methods stripped:\\'.</body><body package="RuntimePackager">errorString: aString	self errorString value: (self description, aString) withCRs</body><body package="RuntimePackager">missingMethodsDescription	^'\The following classes have superclasses that are marked to be kept,\but all of the superclass methods are marked to be deleted:\\'.</body><body package="RuntimePackager">missingSuperclassDescription	^'\The following classes have superclasses that are marked for deletion,\and will not appear in the runtime image:\\'.</body><body package="RuntimePackager">noNameSpaceDescription	^'\The following classes belong to a namespace marked for deletion,\in the runtime image:\\'.</body></methods><methods><class-id>RuntimePackager.HierarchyErrorMessage</class-id> <category>aspects</category><body package="RuntimePackager">errorString	"This method was generated by UIDefiner. The initialization provided 	below may have been preempted by an initialize method."	^errorString isNil ifTrue: [errorString := String new asValue] ifFalse: [errorString]</body></methods><methods><class-id>RuntimePackager.HierarchyErrorMessage class</class-id> <category>instance creation</category><body package="RuntimePackager">errorString: aString	^self new errorString: aString.</body></methods><methods><class-id>RuntimePackager.RuntimeExample</class-id> <category>aspects</category><body package="RuntimePackager">edenAlloc	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^edenAlloc isNil		ifTrue:			[edenAlloc := 0 asValue]		ifFalse:			[edenAlloc]</body><body package="RuntimePackager">edenUsed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^edenUsed isNil		ifTrue:			[edenUsed := 0 asValue]		ifFalse:			[edenUsed]</body><body package="RuntimePackager">largeAlloc	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^largeAlloc isNil		ifTrue:			[largeAlloc := 0 asValue]		ifFalse:			[largeAlloc]</body><body package="RuntimePackager">largeUsed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^largeUsed isNil		ifTrue:			[largeUsed := 0 asValue]		ifFalse:			[largeUsed]</body><body package="RuntimePackager">oldAlloc	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^oldAlloc isNil		ifTrue:			[oldAlloc := 0 asValue]		ifFalse:			[oldAlloc]</body><body package="RuntimePackager">oldUsed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^oldUsed isNil		ifTrue:			[oldUsed := 0 asValue]		ifFalse:			[oldUsed]</body><body package="RuntimePackager">permAlloc	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^permAlloc isNil		ifTrue:			[permAlloc := 0 asValue]		ifFalse:			[permAlloc]</body><body package="RuntimePackager">permUsed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^permUsed isNil		ifTrue:			[permUsed := 0 asValue]		ifFalse:			[permUsed]</body><body package="RuntimePackager">survAlloc	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^survAlloc isNil		ifTrue:			[survAlloc := 0 asValue]		ifFalse:			[survAlloc]</body><body package="RuntimePackager">survUsed	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^survUsed isNil		ifTrue:			[survUsed := 0 asValue]		ifFalse:			[survUsed]</body></methods><methods><class-id>RuntimePackager.RuntimeExample</class-id> <category>accessing</category><body package="RuntimePackager">edenAllocNow	^ObjectMemory current edenBytes</body><body package="RuntimePackager">edenUsedNow	^ObjectMemory current edenUsedBytes</body><body package="RuntimePackager">largeAllocNow	^ObjectMemory current largeBytes</body><body package="RuntimePackager">largeUsedNow	^ObjectMemory current largeUsedBytes</body><body package="RuntimePackager">oldAllocNow	^ObjectMemory current oldBytes</body><body package="RuntimePackager">oldUsedNow	| om |	om := ObjectMemory current.	^( om oldDataBytes		+ ( om  bytesPerOTE * om oldOTEs )		+ ( om bytesPerRTE * om oldRtUsedEntries)  )</body><body package="RuntimePackager">permAllocNow	^ObjectMemory current permBytes</body><body package="RuntimePackager">permUsedNow	| om |	om := ObjectMemory current.	^( om permDataBytes		+ ( om  bytesPerOTE * om permOTEs ) )</body><body package="RuntimePackager">survAllocNow	^ObjectMemory current survBytes</body><body package="RuntimePackager">survUsedNow	^ObjectMemory current survUsedBytes</body></methods><methods><class-id>RuntimePackager.RuntimeExample</class-id> <category>actions</category><body package="RuntimePackager">forceError	"An error was requested by the user to test error handling"	Transcript cr; show: 'Error requested by user'.	^self error: 'Error requested by user'</body><body package="RuntimePackager">setValues	"Set the values for the different aspects based on the current memory usage"	self edenAlloc value: self edenAllocNow.	self edenUsed value: self edenUsedNow.	self largeAlloc value: self largeAllocNow.	self largeUsed value: self largeUsedNow.	self oldAlloc value: self oldAllocNow.	self oldUsed value: self oldUsedNow.	self permAlloc value: self permAllocNow.	self permUsed value: self permUsedNow.	self survAlloc value: self survAllocNow.	self survUsed value: self survUsedNow.</body></methods><methods><class-id>RuntimePackager.RuntimeExample</class-id> <category>initialization</category><body package="RuntimePackager">initialize	"Initialize the instance"	self setValues.</body></methods><methods><class-id>RuntimePackager.RuntimeExample class</class-id> <category>parcel actions</category><body package="RuntimePackager">postLoadActionFor: aParcel	"Open the application when it is loaded from a Parcel"	self open.</body></methods><methods><class-id>RuntimePackager.RuntimeClassSurrogate</class-id> <category>basic methods</category><body package="RuntimePackager">class	"Treat as a doesNotUnderstand situation. Logic can be added here if there are	exceptions to this general rule."	" treat as a doesNotUnderstand situation "	^RuntimeSurrogateManager activeManager		interceptedClassMessage: ( Message selector: #class ) receiver: self</body><body package="RuntimePackager">doesNotUnderstand: aMessage	"Relay the message to the surrogate manager to force the receiver to	be restored to its normal state before resending the message."	^RuntimeSurrogateManager activeManager		interceptedClassMessage: aMessage receiver: self</body><body package="RuntimePackager">instVarAt: anInteger put: anObject	"Perfrom the same function as Object&gt;&gt;instVarAt:put:"	&lt;primitive: 74&gt;	^self primitiveFailed</body><body package="RuntimePackager">rtpInstVarAt: index	"Answer the instance variable.  See the normal instVarAt: implementation."	&lt;primitive: 73&gt;	^self primitiveFailed</body></methods><methods><class-id>RuntimePackager.RuntimeClassSurrogate</class-id> <category>behavior methods</category><body package="RuntimePackager">flushVMmethodCache	"Perform the same function as Behavior&gt;&gt;flushVMmethodCache"	&lt;primitive: 89&gt;	self primitiveFailed</body><body package="RuntimePackager">format	"Answer the behaviors format -- needed to validate method hooking"	^self rtpInstVarAt: 3</body><body package="RuntimePackager">name	"Answer the class name by direct access to the variable"	^self rtpInstVarAt: 7</body></methods><methods><class-id>RuntimePackager.RuntimeClassSurrogate</class-id> <category>scanner methods</category><body package="RuntimePackager">isLiteralSymbol: aSymbol	"Symbol&gt;&gt;storeOn: sends this message to Scanner class if it is present.	When Scanner is hooked, it is still in the SystemDictionary and would thus	get the message.  One case where this occurs is when an exception occurs,	as for example, in RuntimeSurrogateManager&gt;&gt;unhookClass:.  Supply an	appropriate response to avoid circular unhooking of Scanner."	^false</body></methods><methods><class-id>RuntimePackager.RuntimeFullDumper</class-id> <category>dumping</category><body package="RuntimePackager">dumpArgs: aContext 	"Dump the receiver and stack for the context"	| local |	aContext isBlockContext 		ifFalse: 			["Must be a method context"			dumpStream				crtab;				nextPutAll: 'Receiver: '.			self dumpValue: aContext homeReceiver.			1 to: aContext method numArgs				do: 					[:n | 					[local := aContext localAt: n] on: Object subscriptOutOfBoundsSignal						do: [:ex | local := 'Out of bounds -- not on context stack'].					dumpStream						crtab;						nextPutAll: 'Arg';						nextPutAll: n printString;						nextPutAll: ': '.					self dumpValue: local]]</body><body package="RuntimePackager">dumpCommandLine	"Write a representation of the current command line, if possible"	| opts |	dumpStream nextPutAll: 'Command Line:'.	opts := CEnvironment commandLine.	opts do: [ :opt | dumpStream space; nextPutAll: opt asString. ].</body><body package="RuntimePackager">dumpDatabases	"Dump critical database objects, that is, connections and sessions"	" make sure that database classes are resident before writing the dump "	| dbConnClass dbSessionClass |	dbConnClass := RuntimeManager hiddenReferenceTo:		'ExternalDatabaseConnection'.	dbSessionClass := RuntimeManager hiddenReferenceTo:		'ExternalDatabaseSession'.	dbConnClass isNil | dbSessionClass isNil ifTrue: [ ^self ].	self dumpSeparator.	" dump all database connections "	dumpStream cr; nextPutAll: 'External Database Connections (all instances):'.	dbConnClass allSubclasses do: [ :dbConnCl |		dbConnCl allInstances do: [ :conn |			dumpStream cr; crtab; print: conn;				crtab: 2; nextPutAll: 'hash: '; print: conn identityHash;				crtab: 2; nextPutAll: 'state: '; print: conn state;				crtab: 2; nextPutAll: 'username: '; print: conn username;				crtab: 2; nextPutAll: 'environment: '; print: conn environment. ] ].	" dump all database sessions "	dumpStream cr; cr; nextPutAll: 'External Database Sessions (all instances):'.	dbSessionClass allSubclasses do: [ :dbSessCl |		dbSessCl allInstances do: [ :sess |		dumpStream cr; crtab; print: sess;			crtab: 2; nextPutAll: 'state: '; print: sess state;			crtab: 2; nextPutAll: 'connection hash: '; print: sess connection identityHash;			crtab: 2; nextPutAll: 'query: '; print: sess query. ] ].	" end of this section"	dumpStream cr.</body><body package="RuntimePackager">dumpExceptionReport: anException context: aContext	"Append a dump onto the dump stream.  anException represents the	condition causing the dump to be written in the first place.  aContext is the	context in which the exception was raised. The invoker should handle exceptions	that may arise in this process "	self dumpHeader.	self dumpSummary: anException.	self dumpCommandLine.	self dumpSeparator.	dumpStream cr; nextPutAll: 'Active Process'.	self dumpDetailsOfProcess: Processor activeProcess.	self dumpStack: aContext.	self dumpException: anException.	self dumpStackArgs: aContext.	self dumpQuiescentProcesses.	self dumpSuspendedProcesses.	self dumpTranscript.	self dumpDatabases.	self dumpWindows.	self dumpExtra.	self dumpTrailer.</body><body package="RuntimePackager">dumpExtra	"Dump anything else that needs dumping.  This method is here	for subclasses that might want to add to the end of a dump."	^self</body><body package="RuntimePackager">dumpImageIdentification	dumpStream		cr;		nextPutAll: 'Image Identification: ';		print: RuntimeManager imageIdentification.	self dumpSystemInformation.</body><body package="RuntimePackager">dumpQuiescentProcesses	"Dump all processes other than the active one"	| quiescentProcesses |	self dumpSeparator.	dumpStream cr; nextPutAll: 'Quiescent Processes'.	quiescentProcesses := Processor instVarAt: (			RuntimeManager quiescentProcessListsIndex).	quiescentProcesses do: [ :pl |		pl do: [ :p |			p suspendedContext notNil ifTrue: [				self dumpDetailsOfProcess: p.				self dumpStack: p suspendedContext ] ] ].</body><body package="RuntimePackager">dumpStackArgs: aContext	"Dump  a description of the args used for the initial stack entries.	This is done separately just in case there is a fatal error in evaluating the	printString of one of the argument values.."	| maxNbr ctx stackSize |	self dumpSeparator.	dumpStream cr; nextPutAll: 'Initial Context Stack Arguments:'.	maxNbr := self maximumArgFramesDumped.	ctx := aContext.	stackSize := 0.	[ ctx notNil and: [ stackSize &lt; maxNbr ] ] whileTrue: [		stackSize := stackSize + 1.		"Only dump args for MethodContexts, which are those that are not block contexts"		ctx isBlockContext ifFalse: [			[ dumpStream cr;				nextPut: $[; print: stackSize; nextPut: $]; space;				print: ctx.			self dumpArgs: ctx. ]			on: Error			do: [ :ex | dumpStream cr; nextPutAll: '--Error: ', ex description ] ].		ctx := ctx sender ].	" end of this section "	dumpStream cr.</body><body package="RuntimePackager">dumpSuspendedProcesses	"Dump all processes that are neither active nor suspended"	| quiescentProcesses rejectProcesses |	self dumpSeparator.	dumpStream cr; nextPutAll: 'Suspended Processes'.	" Get the collection of processes not to be printed"	quiescentProcesses := Processor instVarAt: (			RuntimeManager quiescentProcessListsIndex).	rejectProcesses := IdentitySet withAll: quiescentProcesses.	rejectProcesses add: Processor activeProcess.	" Now look at all instances of Process and print those with a suspended context"	Process allInstances do: [ :process |		process suspendedContext notNil ifTrue: [			( rejectProcesses includes: process ) ifFalse: [				self dumpDetailsOfProcess: process.				self dumpStack: process suspendedContext ] ] ].</body><body package="RuntimePackager">dumpSystemInformation	"Write a system installation dump"		dumpStream cr.	self printBasicSystemInformationOn: dumpStream.	self printParcelsOn: dumpStream.	self printBundlesOn: dumpStream.	self printPackagesOn: dumpStream.</body><body package="RuntimePackager">dumpTranscript	"Dump the entire Transcript"	" do not do the dump is Transcript is not in the image "	Transcript class == TextCollector ifFalse: [		dumpStream cr; nextPutAll: 'Transcript is not a TextCollector'; cr.		 ^self ].	self dumpSeparator.	dumpStream cr; nextPutAll: 'Transcript:';		cr; nextPutAll: '&lt;&lt;&lt;BEGIN TRANSCRIPT&gt;&gt;&gt;';		cr; nextPutAll: Transcript value;		cr; nextPutAll: '&lt;&lt;&lt;END TRANSCRIPT&gt;&gt;&gt;';		cr.</body><body package="RuntimePackager">dumpWindowParts: aComp origin: aPoint	"Dump window parts by recursively descending the window structure.	aComp is the component being dumped and aPoint is theoretically its origin.	This very non-oo approach is used to avoid sprinkling methods into the classes	that would ordinarily do this recursion."	| contents pointString |	" descend the window structure "	( aComp isKindOf: (		RuntimeManager hiddenReferenceTo: 'BoundedWrapper' ) ) ifTrue: [		^self dumpWindowParts: aComp component			origin: aPoint + aComp bounds origin ].	( aComp isKindOf: (		RuntimeManager hiddenReferenceTo: 'Wrapper' ) ) ifTrue: [		^self dumpWindowParts: aComp component origin: aPoint ].	( aComp isKindOf: (		RuntimeManager hiddenReferenceTo: 'CompositePart' ) ) ifTrue: [		^aComp components do: [ :comp |			self dumpWindowParts: comp origin: aPoint ] ].	" see if we have reached something with a model "	( aComp isKindOf: (		RuntimeManager hiddenReferenceTo: 'DependentPart' ) )		ifFalse: [ ^self ].	pointString := ( aPoint printString, '          ' ) copyFrom: 1 to: 10.	" see how to dump what we have found "	( aComp isKindOf: (		RuntimeManager hiddenReferenceTo: 'ComposedTextView' ) ) ifTrue: [		dumpStream crtab: 2; nextPutAll: pointString; tab;			nextPutAll: 'displayContents: '.		contents := ( aComp displayContents textAt: 1 ) asString.		contents size &gt; 128			ifFalse: [ ^dumpStream print: contents ]			ifTrue: [				^dumpStream print: (contents copyFrom: 1 to: 64);					nextPutAll: ' ... ';					print: (contents copyFrom: contents size -  63							to: contents size ) ]  ].	( aComp isKindOf: (		RuntimeManager hiddenReferenceTo: 'SequenceView' ) ) ifTrue: [		aComp selectionIndex &gt; 0 ifTrue: [		dumpStream crtab: 2; nextPutAll: pointString; tab.		^dumpStream nextPutAll: 'selection: ';			print: (aComp displayStringAt: aComp selectionIndex ) ] ].	( aComp isKindOf: (		RuntimeManager hiddenReferenceTo: 'TableView' ) ) ifTrue: [		aComp selectionIndex = aComp zeroIndex ifFalse: [		dumpStream crtab: 2; nextPutAll: pointString; tab.		^dumpStream nextPutAll: 'selection: ';			print: (aComp displayStringAt: aComp selectionIndex ) ] ].</body><body package="RuntimePackager">dumpWindows	"Dump identifying information on all scheduled windows"	| controllers view retryCount |	self dumpSeparator.	dumpStream		cr;		nextPutAll: 'Scheduled Windows:'.	controllers := ScheduledControllers scheduledControllers.	controllers do: 			[:cont | 			view := cont view.			dumpStream				cr;				crtab;				print: view.			(view isKindOf: ScheduledWindow) 				ifTrue: 					[dumpStream						space;						nextPutAll: 'label: ';						print: view label;						crtab: 2;						nextPutAll: 'model class:  ';						nextPutAll: view model class name.					retryCount := 0.					[self dumpWindowParts: view component origin: 0 @ 0] 						on: Object errorSignal						do: 							[:ex | 							(retryCount := retryCount + 1) &gt; 1 ifTrue: [ex reject].							dumpStream								cr;								nextPutAll: '=== EXCEPTION DURING DUMP:  ';								print: ex errorString]					" detect recursive errors and percolate if so"]].	dumpStream cr</body></methods><methods><class-id>RuntimePackager.RuntimeFullDumper</class-id> <category>system information</category><body package="RuntimePackager">printBasicSystemInformationOn: aStream	| patches |	aStream nextPutAll: (#patches &lt;&lt; #dialogs &gt;&gt; 'Patches:') asString. 	patches := ChangeSet patches asSortedStrings.	patches isEmpty		ifTrue: [aStream crtab; nextPutAll: (#none &lt;&lt; #dialogs &gt;&gt; '(none)') asString]		ifFalse: [patches do: [:str | aStream crtab; nextPutAll: str]].	aStream cr</body><body package="RuntimePackager">printBundlesOn: aStream	aStream nextPutAll: (#Bundles &lt;&lt; #store &gt;&gt; 'Bundles:') asString.	self printNamesAndVersionsOf: Store.Registry allBundles on: aStream.	aStream cr</body><body package="RuntimePackager">printNamesAndVersionsOf: pundleCollection on: aStream	(pundleCollection asSortedCollection: [:a :b | a name &lt;= b name]) do:		[:pundle |		aStream 			crtab; 			nextPutAll: pundle name, ' ', pundle versionString]</body><body package="RuntimePackager">printPackagesOn: aStream	aStream nextPutAll: (#PackagesC &lt;&lt; #store &gt;&gt; 'Packages:') asString.	self printNamesAndVersionsOf: Store.Registry allPackages on: aStream.	aStream cr</body><body package="RuntimePackager">printParcelsOn: aStream	aStream nextPutAll: (#ParcelsC &lt;&lt; #dialogs &gt;&gt; 'Parcels:') asString.	Parcel parcelNames asSortedStrings do:		[:str | | p |		(p := Parcel parcelNamed: str) isLoaded ifTrue:			[aStream crtab; nextPutAll: str.			p versionString size &gt; 0 ifTrue:				[aStream nextPutAll: ((#parcelVersion &lt;&lt; #dialogs &gt;&gt; ' Version &lt;1p&gt;')					expandMacrosWith: p versionString)].			p timestamp notNil ifTrue:				[aStream					nextPutAll: ((#parcelTimestamp &lt;&lt; #dialogs &gt;&gt; ' of &lt;1s&gt; &lt;2s&gt;')						expandMacrosWith: p timestamp asDate shortPrintString 						with: p timestamp asTime shortPrintString)]]].	aStream cr</body></methods><methods><class-id>RuntimePackager.RuntimeCompiledMethod</class-id> <category>Envy</category><body package="RuntimePackager">filePointer	"There is no file pointer so answer nil"	^nil</body><body package="RuntimePackager">filePointer: x	"There is no file pointer so ignore this"	^self</body><body package="RuntimePackager">hasFilePointer	"There is no pointer, so the answer is no"	^false</body><body package="RuntimePackager">methodWithSource	"There is no source, so answer nil"	^nil</body><body package="RuntimePackager">selector	"Use who to get the answer since there is no such instance variable"	| who |	who := self who.	^ who == nil		ifTrue: [ self mclass defaultSelectorForMethod: self ]		ifFalse: [ who at: 2 ]</body><body package="RuntimePackager">selector: x	"There is no such instance variable, so ignore this"	^ self</body><body package="RuntimePackager">sourceString	"There is no source, so answer nil"	^nil</body><body package="RuntimePackager">testVisibilityIn: anApp	"There is no way to do this, so just ignore it"	^self</body></methods><methods><class-id>RuntimePackager.RuntimeCompiledMethod</class-id> <category>accessing</category><body package="RuntimePackager">getSource	"Answer the source code for the receiver.  Answer nil if this method	has no stored source, which is always the case here."	^nil</body><body package="RuntimePackager">instVarAt: anInteger	"Answer the instance variable, bypassing references to dropped instance variables"	| superSize selfSize |	superSize := self class superclass instSize.	selfSize := self class instSize.	^anInteger &lt;= selfSize		ifTrue: [ super instVarAt: anInteger ]		ifFalse: [			anInteger &lt;= superSize				ifTrue: [ nil ]				ifFalse: [ super instVarAt: anInteger + selfSize - superSize ] ]</body><body package="RuntimePackager">instVarAt: anInteger put: aValue	"Set the instance variable, bypassing references to dropped instance variables"	| superSize selfSize |	superSize := self class superclass instSize.	selfSize := self class instSize.	^anInteger &lt;= selfSize		ifTrue: [ super instVarAt: anInteger put: aValue ]		ifFalse: [			anInteger &lt;= superSize				ifTrue: [ aValue ]				ifFalse: [ super instVarAt: anInteger + selfSize - superSize put: aValue ] ]</body><body package="RuntimePackager">sourcePointer	"There is no source pointer, so answer nil"	^ nil</body><body package="RuntimePackager">sourcePointer: x	"There is no source pointer, so ignore this"	^ self</body><body package="RuntimePackager">storeGeneralStructureOn: aBinaryStorageWriter	"This function is not really used in the runtime environment.	Just make sure there are no references to missing variables"	self error: 'Function not supported for compressed methods'.</body></methods><methods><class-id>RuntimePackager.RuntimeCompiledMethod class</class-id> <category>instance creation</category><body package="RuntimePackager">fromMethod: aMethod	"Answer a new instance copied from the method supplied"	| newCM |	newCM := self new: aMethod basicSize.	" copy values dropping any not in this type of method "	1 to: aMethod size + aMethod class instSize do: [ :index |		newCM instVarAt: index put: (aMethod instVarAt: index ) ].	^newCM</body></methods><methods><class-id>RuntimePackager.RuntimeCompiledMethod class</class-id> <category>activation</category><body package="RuntimePackager">setRuntimeFormat	"Change the class format to reflect dropping CompiledMethod's	instance variables.  This is done during the process of stripping	an image for runtime.  The following code relies upon mclass being the	first instance variable in CompiledMethod."	self setInstanceFormat: (		 (self format bitAnd: self fixedFieldsMask bitInvert ) bitOr: (			CompiledCode instSize + 1 ) ).</body></methods><methods><class-id>RuntimePackager.RuntimeEmergencyNotifier</class-id> <category>user interface</category><body package="RuntimePackager">cleanUpUserInterface	"Clean up the user interface after an error."	"Try to shutdown any active controllers when an error occurs"	Window activeController 		ifNotNil: [:activeController | activeController shutdownBecauseOfError].	"Make all open windows non-modal"	WindowManager beEffectivelyModeless.	(InputState default respondsTo: #ungrabBecauseOfError) 		ifTrue: [InputState default ungrabBecauseOfError].	" Restore event queue "	EventQueue allInstancesDo: [:each | each restoreReadSynchSignals].</body><body package="RuntimePackager">confirmUserInterruptRequest	"Ask the user if the image should quit now"	^self confirm: self class userInterruptMsg</body><body package="RuntimePackager">notifyUserOfUnhandledException: dumpWorked	"Actually notify the user of the unhandled exception.	dumpWorked is a boolean indicating if a dump was written"	| msg errorString |	msg := WriteStream on: (String new: 512).	errorString := self exception errorString.	errorString size &gt; 60 ifTrue: [		errorString := errorString copyFrom: 1 to: 55.		errorString := errorString, ' ...' ].	msg     nextPutAll: errorString; cr; cr;		nextPutAll: self class errorOccurredMsg.	dumpWorked ifFalse: [		msg cr; nextPutAll: self class dumpFailedMsg ].	self warn: msg contents.</body><body package="RuntimePackager">notifyUserWhenImageQuitFails	"Notify the user when an attempt to quit the image fails"	| abortTime abortWin text |	" remember when this started "	abortTime := Time now asSeconds.	" put up a dumb window without a real UI (safer that way)"	text := (self class emergencyAbortText		expandMacrosWith: self initialDumpPathString) asComposedText.	abortWin := ScheduledWindow openNewIn: (		0@0 extent: text preferredBounds extent + (40@40) ).	text displayOn: abortWin graphicsContext at: 20@20.	" write the dump "	self createEmergencyDump.	" wait in a spin loop -- safest way possible"	[Time now asSeconds - abortTime &lt; 5 ] whileTrue:		[text displayOn: abortWin graphicsContext at: 20@20].	" now close the window "	abortWin close.</body></methods><methods><class-id>RuntimePackager.RuntimeEmergencyNotifier</class-id> <category>dialog interface</category><body package="RuntimePackager">choose: choice labels: labels values: values default: default	"Notify user via a Dialog"	^self class dialogClass choose: choice		labels: labels		values: values		default: default</body><body package="RuntimePackager">confirm: aString	"Notify the user by using a Dialog."	^self class dialogClass confirm: aString</body><body package="RuntimePackager">warn: aString	"Warn the user by using a Dialog."	^self class dialogClass warn: aString.</body></methods><methods><class-id>RuntimePackager.RuntimeEmergencyNotifier class</class-id> <category>accessing</category><body package="RuntimePackager">dialogClass	"Answer the class for notifying the user of an error"	^DialogClass</body><body package="RuntimePackager">dialogClass: aClass	"Set the class for notifying the user of an error"	DialogClass := aClass.</body><body package="RuntimePackager">dumpFailedMsg	^DumpFailedMsg</body><body package="RuntimePackager">dumpFailedMsg: aString	DumpFailedMsg := aString</body><body package="RuntimePackager">emergencyAbortText	^emergencyAbortText</body><body package="RuntimePackager">emergencyAbortText: aComposedText	emergencyAbortText := aComposedText asString</body><body package="RuntimePackager">errorOccurredMsg	^ErrorOccurredMsg</body><body package="RuntimePackager">errorOccurredMsg: aString	ErrorOccurredMsg := aString</body><body package="RuntimePackager">userInterruptMsg	^UserInterruptMsg</body><body package="RuntimePackager">userInterruptMsg: aString	UserInterruptMsg := aString</body></methods><methods><class-id>RuntimePackager.RuntimeEmergencyNotifier class</class-id> <category>class initialization</category><body package="RuntimePackager">initialize	"Reset class state to an initial condition"	DialogClass := Dialog.	UserInterruptMsg :='Processing was interrupted by user request.Do you want to terminate this application now?'.	ErrorOccurredMsg :='An error occurred in this application.The application will now terminate.'.	DumpFailedMsg :='A diagnostic dump of the error could notbe made, or the dump was incomplete.'.	emergencyAbortText :='A system error occurred during quit.A diagnostic dump is being written to&lt;t&gt;&lt;1p&gt;after which this application will terminate'.</body></methods><methods><class-id>RuntimePackager.RuntimeDebugNotifier</class-id> <category>user interface</category><body package="RuntimePackager">confirmUserInterruptRequest	"Ask the user if the image should quit now.	If the user indicates that the error should be ignored	create a dump and dismiss the exception."	| userResp labels values |	"see if there is a way to proceed after the interrupt "	self canProceedAfterUserInterrupt		ifTrue: [			labels := Array	with: ( self class buttonTitles at: #exit )					with: ( self class buttonTitles at: #proceed )					with: ( self class buttonTitles at: #dismiss ).			values := #( #exit #proceed #dismiss). ]		ifFalse: [			labels := Array	with: ( self class buttonTitles at: #exit )					with: ( self class buttonTitles at: #dismiss ).			values := #( #exit  #dismiss). ].	" take input from the user "	userResp := self  choose: self class userInterruptMsg					labels: labels values: values default: #exit.	userResp  == #dismiss		ifTrue: [			self createEmergencyDump.			self dismissException ].	^userResp == #exit</body><body package="RuntimePackager">notifyUserOfUnhandledException: dumpWorked	"Notify user and see if image should be terminated"	| msg errorString labels values resp |	msg := WriteStream on: (String new: 512).	errorString := self exception errorString.	errorString size &gt; 80 ifTrue: [		errorString := errorString copyFrom: 1 to: 75.		errorString := errorString, ' ...' ].	msg     nextPutAll: errorString; cr; cr;		nextPutAll: self class errorOccurredMsg.	dumpWorked ifFalse: [		msg cr; nextPutAll: self class dumpFailedMsg ].	" ask the user if the image should be terminated "	self isProceedable		ifTrue: [			labels := Array				with: ( self class buttonTitles at: #exit )				with: ( self class buttonTitles at: #proceed )				with: ( self class buttonTitles at: #continue ).			values := #( #exit #proceed #continue ). ]		ifFalse: [			labels := Array				with: ( self class buttonTitles at: #exit )				with: ( self class buttonTitles at: #continue ).			values := #( #exit #continue ). ].	resp := self choose: msg contents		labels: labels		values: values		default: #exit.	resp == #exit ifTrue: [ ^self ].	" see if  we should proceed with this exception "	resp == #proceed ifTrue: [		self class resetErrorState.		^self exception proceed ].	"otherwise, dismiss the current exception -- this does not return"	self dismissException.</body></methods><methods><class-id>RuntimePackager.RuntimeDebugNotifier class</class-id> <category>accessing</category><body package="RuntimePackager">buttonTitles	"Answer the dictionary used to hold button titles.	If no value has been saved for buttons, answer with a default"	ButtonTitles size = 0 ifTrue: [		ButtonTitles := Dictionary new			at: #exit put: 'Exit';			at: #proceed put: 'Proceed';			at: #dismiss put: 'Dismiss';			at: #continue put: 'Continue';			yourself. ].	^ButtonTitles</body><body package="RuntimePackager">buttonTitles: aDictionary	"Set the dictionary used to hold button titles."	ButtonTitles := aDictionary.</body><body package="RuntimePackager">debugErrorMsg	"Answer the message to be displayed to the user	when an unhandled exception is encounterred."	^DebugErrorMsg</body><body package="RuntimePackager">debugErrorMsg: aString	"Set the message to be displayed to the user	when an unhandled exception is encounterred."	DebugErrorMsg := aString.</body><body package="RuntimePackager">debugInterruptMsg	"Answer the message to be displayed to the user	when a user interrupt is encounterred."	^DebugInterruptMsg</body><body package="RuntimePackager">debugInterruptMsg: aString	"Set the message to be displayed to the user	when a user interrupt is encounterred."	DebugInterruptMsg := aString.</body><body package="RuntimePackager">errorOccurredMsg	"Provide a message to the user for errors in a debug mode."	^ self debugErrorMsg size == 0		ifTrue: [			'An error has occurred. Continue processing only if you are\' withCRs,			'certain that application data integrity will not be affected.' ]		ifFalse: [ self debugErrorMsg ]</body><body package="RuntimePackager">userInterruptMsg	"Answer the message displayed when a user interrupt occurs"	^self debugInterruptMsg size = 0		ifTrue: ['Processing was interrupted by user request.Press Exit to exit the application.Press Proceed (if shown) to proceed without interruption.Press Dismiss to stop the current operation.' ]		ifFalse: [ self debugInterruptMsg ]</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager</class-id> <category>method hooking</category><body package="RuntimePackager">addSelectorQuietly: aSelector withMethod: aMethod to: aBehavior	"Add the selector with the indicated method to a class or metaclass.	The standard Behavior methods are not used because we do not want	to trigger side-effects of changing instance methods. Similarly, this add is done	without regard to validation considerations"	| mdict |	mdict := aBehavior instVarAt: 2.	mdict at: aSelector put: aMethod.	aBehavior flushVMmethodCacheEntriesFor: aSelector.</body><body package="RuntimePackager">allHookedMethods	"Answer a collection of all hooked methods.  Look through all method	dictionaries (watching out for those tricky dicts) and find the surrogates"	| surrogates selectors meth |	surrogates :=OrderedCollection new: 127.	Smalltalk allBehaviorsDo: [ :behav |		selectors := RuntimeManager selectorsInClass: behav.		selectors do: [ :sel |			meth := behav compiledMethodAt: sel ifAbsent: [ nil ].			meth class == RuntimeMethodSurrogate				ifTrue: [ surrogates add: meth ] ] ].	^surrogates</body><body package="RuntimePackager">hookMethod: aMethod selector: aSymbol	"Hook the compiled method so that notfication of its execution can be made."	" watch out for special meta classes that are not one associated with the class "	aMethod mclass isMeta ifTrue: [		aMethod mclass soleInstance class == aMethod mclass			ifFalse: [ ^self  "cannot unhook in this case" ] ].	^self hookMethod: aMethod selector: aSymbol mclass: aMethod mclass</body><body package="RuntimePackager">hookMethod: aMethod selector: aSymbol mclass: mclass	"Hook the compiled method so that notfication of its execution can be made."	| surrogate numArgs repl mcl numLit |	" do not attempt to make a surrogate of an existing surrogate "	aMethod class == RuntimeMethodSurrogate		ifTrue: [ ^self ].	" only install the surrogate if the classes are compatible "	mclass format = aMethod mclass format		ifFalse: [ ^ self ].	"exempt classes are ignored as far as method hooking goes, except for Object"	( mclass ~~ Object and: [ self exemptClasses includes: mclass ] ) ifTrue: [ ^self ].	( mclass isMeta and: [		mclass ~~ Object class and: [		self exemptClasses includes: mclass soleInstance ] ] ) ifTrue: [ ^ self ].	"do not attempt to hook marked methods"	aMethod isMarked ifTrue: [ ^self ].	numArgs := aMethod numArgs.	"surrogates are only available for up to 32 arguments"	numArgs &gt; 32 ifTrue: [ ^self ].	recursionLock critical: [		" build a surrogate method to go into the method dictionary"		surrogate := ( surrogateMethods at: numArgs + 1 ) copy.		surrogate mclass: mclass.  "note that there are no blocks in the templates"		surrogate sourcePointer: nil.		aMethod mclass == mclass			ifTrue: [ surrogate hookedMethod: aMethod. ]			ifFalse: [				" relocate the template to a new class "				repl := aMethod copy mclass: mclass.				mcl := aMethod mclass.				repl withAllBlockMethodsDo: [ :code |					numLit := code numLiterals.					1 to: numLit do: [ :idx |						( code literalAt: idx ) == mcl ifTrue: [							code literalAt: idx put: mclass ] ] ].				surrogate hookedMethod: repl. ].		surrogate hookedSelector: aSymbol.		" install the surrogate in the method dictionary "		self addSelectorQuietly: aSymbol withMethod: surrogate to: mclass.	].      " end critical section "</body><body package="RuntimePackager">hookSelector: selector in: aBehavior	"Hook the method named by the selector.  aBehavior must itself	implement the method, that is, superclasses are not inspected"	self hookMethod: (		aBehavior compiledMethodAt: selector ifAbsent: [			^self error: 'Behavior supplied does not implement selector being hooked' ] )		selector: selector</body><body package="RuntimePackager">unhookAllMethods	"Unhook all methods known to be hooked at present.  Look through all	methods (watching out for the hidden dictionaries) and unhook any	surrogates found"	| selectors meth |	Smalltalk allBehaviorsDo: [ :behav |		selectors := RuntimeManager selectorsInClass: behav.		selectors do: [ :sel |			meth := behav compiledMethodAt: sel ifAbsent: [ nil ].			meth class == RuntimeMethodSurrogate				ifTrue: [ self unhookMethod: meth ] ] ].</body><body package="RuntimePackager">unhookMethod: surrogateMethod	"Unhook the surrogate method by replacing it with the original method"	|  mclass hookedMethod sel |	" make sure the class is unhooked first (class is not understood if hooked ) "	mclass := surrogateMethod mclass.	mclass class.	" can only unhook methods that are really surrogates "	surrogateMethod class == RuntimeMethodSurrogate		ifFalse: [ ^self ].	" unhook the method by storing the original method in the method dictionary "	recursionLock critical: [		sel := surrogateMethod hookedSelector.		hookedMethod := surrogateMethod hookedMethod.		self addSelectorQuietly: sel withMethod: hookedMethod to: surrogateMethod mclass. ].	" perform requested functions upon successful unhooking"	unhookMethodBlock notNil ifTrue: [		unhookMethodBlock			value: mclass			value: sel			value: hookedMethod ].</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager</class-id> <category>class hooking</category><body package="RuntimePackager">allHookedClasses	"Answer a collection of all hooked classes"	^hookedSuperclasses keys</body><body package="RuntimePackager">hookClass: aClass	"Transform aClass into a surrogate for itself"	| meta |	recursionLock critical: [	" ignore attempts to hook exempt classes"	( self exemptClasses includes: aClass ) ifTrue: [ ^self ].	" do not hook and already hooked class "	( hookedSuperclasses includesKey: aClass ) ifTrue: [ ^self ].	" just make sure we are still sane "	( aClass isBehavior and: [ aClass isMeta not ] ) ifFalse: [		^self error: 'class is not valid for hooking to surrogate' ].	" hook all subclasses recursively "	aClass subclasses do: [ :sub | self hookClass: sub ].	" remember the metaclass for later use "	meta := aClass class.	" save the superclass and method dictionary for the class and metaclass "	hookedSuperclasses at: aClass put: (aClass instVarAt: 1).	hookedMethodDictionaries at: aClass put: (aClass instVarAt: 2).	hookedSuperclasses at: meta put: (meta instVarAt: 1).	hookedMethodDictionaries at: meta  put: (meta instVarAt: 2).	" set the superclass and empty the method dictionary "	aClass instVarAt: 1 put: RuntimeInstanceSurrogate.	aClass instVarAt: 2 put: MethodDictionary new.	aClass flushVMmethodCache.	meta instVarAt: 1 put: RuntimeClassSurrogate.	meta instVarAt: 2 put: MethodDictionary new.	meta flushVMmethodCache.	].  "end critical section"</body><body package="RuntimePackager">unhookAllClasses	"Unhook all classes by sending each global object a message.	This will perform at list a minimal repair of any hooked classes that are not	in the hooked classes dictionaries"	Smalltalk allBehaviorsDo: [ :behav | behav class ].</body><body package="RuntimePackager">unhookClass: aClass	"Restore the behavior surrogate to its normal form"	self unhookClass: aClass selector: nil.</body><body package="RuntimePackager">unhookClass: aClass selector: aSymbolOrNil 	"Restore the behavior surrogate to its normal form"	" set up error handling environment and critical section controls "	| meta savedException |	savedException := nil.		[recursionLock critical: 			[" the main function to perform "			[meta := aClass rtpClass] on: Object messageNotUnderstoodSignal				do: [:ex | ^self].			" make sure super class is also unhooked, if needed "			self unhookClass: (hookedSuperclasses at: aClass						ifAbsent: 							["Attempt temporary repair so debugger can open."							aClass instVarAt: 1 put: Object.							meta instVarAt: 1 put: Object class.							^self class unhookingErrorSignal 								raiseErrorString: 'Fatal error unhooking class ' , aClass name])				selector: nil.			" restore superclasses and method dictionaries "			meta instVarAt: 1 put: (hookedSuperclasses at: meta ifAbsent: [^self]).	"stop if already unhooked by superclass"			meta instVarAt: 2 put: (hookedMethodDictionaries at: meta).			meta flushVMmethodCache.			hookedSuperclasses removeKey: meta.			hookedMethodDictionaries removeKey: meta.			aClass instVarAt: 1 put: (hookedSuperclasses at: aClass).			aClass instVarAt: 2 put: (hookedMethodDictionaries at: aClass).			aClass flushVMmethodCache.			hookedSuperclasses removeKey: aClass ifAbsent: [].			hookedMethodDictionaries removeKey: aClass ifAbsent: []			"changed"]] 			on: Object errorSignal			do: [:ex | savedException := ex].	"end critical section"	" reraised (non-proceedable) any exception "	savedException isNil 		ifFalse: 			[^(savedException creator newException)				originator: savedException originator;				errorString: savedException localErrorString;				parameter: savedException parameter;				raise].	" perform any desired notifications "	unhookClassBlock notNil 		ifTrue: [unhookClassBlock value: aClass value: aSymbolOrNil]</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager</class-id> <category>initialization</category><body package="RuntimePackager">beginTest	"Do intializations needed to begin a test using surrogates"	RuntimeInstanceSurrogate assignSuperclass: nil.</body><body package="RuntimePackager">endTest	"Do intializations needed to end a test using surrogates"	RuntimeInstanceSurrogate assignSuperclass: Object.</body><body package="RuntimePackager">initialize	"Initialize a new instance"	| surrogateSelectors templateSelector |	recursionLock := RecursionLock new.	hookedSuperclasses := IdentityDictionary new.	hookedMethodDictionaries := IdentityDictionary new.	unhookClassBlock := nil.	unhookMethodBlock := nil.	" cache surrogate methods "	surrogateSelectors := #( #surrogateMethod ) asOrderedCollection.	templateSelector := #surrogateMethod:.	1 to: 32 do: [ :n |		surrogateSelectors add: templateSelector.		templateSelector := ( templateSelector, 'with:' ) asSymbol ].	surrogateMethods := ( surrogateSelectors collect: [ :sel |		RuntimeMethodSurrogate cloneFromMethod: (			self class compiledMethodAt: sel ) ] ) asArray.</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager</class-id> <category>accessing</category><body package="RuntimePackager">exemptClasses	"Answer the set of classes which are exempt from being hooked and,	except for Object, whose methods are likewise exempt from being hooked."	exemptClasses notNil ifTrue: [ ^exemptClasses ].	exemptClasses := self kernelClasses.	exemptClasses		addAll: RuntimeMethodSurrogate withAllSuperclasses;		addAll: RuntimeClassSurrogate withAllSuperclasses;		addAll: RuntimeInstanceSurrogate withAllSuperclasses;		addAll: RuntimeSurrogateManager withAllSuperclasses.	^exemptClasses</body><body package="RuntimePackager">kernelClasses	"Answer the set of classes which are part of the kernel and are	required for hooking and unhooking classes and methods"	^ IdentitySet  new		addAll: Class withAllSuperclasses;		addAll: ControlManager withAllSuperclasses;		addAll: WindowManager withAllSuperclasses;		addAll: Exception withAllSuperclasses;		addAll: IdentitySet withAllSuperclasses;		addAll: InputSensor withAllSuperclasses;		addAll: LargePositiveInteger withAllSuperclasses;		addAll: MarkedMethod withAllSuperclasses;		addAll: Metaclass withAllSuperclasses;		addAll: MethodContext withAllSuperclasses;		addAll: MethodDictionary withAllSuperclasses;		addAll: ObjectMemory withAllSuperclasses;		addAll: Process withAllSuperclasses;		addAll: RecursionLock withAllSuperclasses;		addAll: Semaphore withAllSuperclasses;		addAll: ScannerTable withAllSuperclasses;		addAll: Signal withAllSuperclasses;		addAll: SmallInteger withAllSuperclasses;		addAll: VariableBinding withAllSubclasses;		addAll: VariableBinding withAllSuperclasses;		addAll: BindingReference withAllSubclasses;		addAll: BindingReference withAllSuperclasses;		addAll: DeferredBinding withAllSuperclasses;		addAll: DeferredBinding withAllSubclasses;		yourself</body><body package="RuntimePackager">unhookClassBlock	"Answer the block to execute when a class is unhooked"	^unhookClassBlock</body><body package="RuntimePackager">unhookClassBlock: aBlockOrNil	"Set the block to execute when a class is unhooked"	unhookClassBlock := aBlockOrNil.</body><body package="RuntimePackager">unhookMethodBlock	"Answer the block to execute when a method is unhooked"	^unhookMethodBlock</body><body package="RuntimePackager">unhookMethodBlock: aBlockOrNil	"Set the block to execute when a method is unhooked"	unhookMethodBlock := aBlockOrNil.</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager</class-id> <category>message handling</category><body package="RuntimePackager">interceptedClassMessage: aMessage receiver: aClass	"Unhook the surrogate and resend the intercepted message"	self unhookClass: aClass selector: aMessage selector.	^aClass perform: aMessage selector withArguments: aMessage arguments</body><body package="RuntimePackager">interceptedInstanceMessage: aMessage receiver: anObject	"Unhook the surrogate and resend the intercepted message"	self unhookClass: anObject rtpClass selector: nil.	^anObject perform: aMessage selector withArguments: aMessage arguments</body><body package="RuntimePackager">interceptedMethodInvocation	"Intercept invocation of a hooked method"	| ctx surrogate method args  numArgs |	" locate what was sent in the original context "	ctx := thisContext sender.	surrogate := ctx method.	method := surrogate hookedMethod.	" extract the original arguements "	numArgs := method numArgs.	args := Array new: numArgs.	1 to: numArgs do: [ :index |		args at: index put: (ctx localAt: index) ].	" unhook the method that got the message "	self unhookMethod: surrogate.	" resent the original message"	^ctx receiver performMethod: method arguments: args.</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager</class-id> <category>template methods</category><body package="RuntimePackager">surrogateMethod	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	with: t25	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	with: t25 with: t26	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	with: t25 with: t26 with: t27	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	with: t25 with: t26 with: t27 with: t28	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	with: t25 with: t26 with: t27 with: t28 with: t29	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	with: t25 with: t26 with: t27 with: t28 with: t29 with: t30	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	with: t25 with: t26 with: t27 with: t28 with: t29 with: t30	with: t31	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body><body package="RuntimePackager">surrogateMethod: t1 with: t2 with: t3 with: t4 with: t5 with: t6	with: t7 with: t8 with: t9 with: t10 with: t11 with: t12	with: t13 with: t14 with: t15 with: t16 with: t17 with: t18	with: t19 with: t20 with: t21 with: t22 with: t23 with: t24	with: t25 with: t26 with: t27 with: t28 with: t29 with: t30	with: t31 with: t32	^RuntimePackager.RuntimeSurrogateManager activeManager interceptedMethodInvocation</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager class</class-id> <category>accessing</category><body package="RuntimePackager">activeManager	"Answer the current global surrogate manager"	activeManager isNil ifTrue: [		activeManager := self new. ].	^activeManager</body><body package="RuntimePackager">activeManager: aManager	"Set the current global surrogate manager"	activeManager := aManager.</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager class</class-id> <category>class initialize-release</category><body package="RuntimePackager">initialize	"Initialize the class"	activeManager := nil.</body><body package="RuntimePackager">removeFromSystem	"Reset access to the active manager"	self removing.	super removeFromSystem.</body><body package="RuntimePackager">removing	"Reset access to activeManager to free up anchor for	surrogate methods"	self activeManager: nil.</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager class</class-id> <category>instance creation</category><body package="RuntimePackager">new	"Answer a new instance"	^super new initialize</body></methods><methods><class-id>RuntimePackager.RuntimeSurrogateManager class</class-id> <category>Signal constants</category><body package="RuntimePackager">unhookingErrorSignal	"Answer the signal used to report unhooking errors"	unhookingErrorSignal isNil ifTrue: [		unhookingErrorSignal := Object errorSignal newSignal			notifierString: 'Error unhooking a surrogate object';			nameClass: self			message: #unhookingErrorSignal. ].	^unhookingErrorSignal</body></methods><methods><class-id>RuntimePackager.RuntimeManagerStripper class</class-id> <category>stripping</category><body package="RuntimePackager">createFinalImage	"Create the final image before the save.  RuntimeManager dependents are	notified of events through changed messages."	| notifier  tickRatePerClass |	notifier := RuntimeProgressNotifier open.	notifier log: 'Creating final runtime image'.	RuntimeManager changed: #aboutToStripImage.	"Suppress the splash screen and herald if desired"	DeploymentOptionsSystem suppressSplashScreenAndHerald: (StrippingOptions includes: #suppressSplashScreen).	"Supress the ability to raise the EmergencyEvaluator"	self suppressEmergencyEvaluator: notifier.	"do preliminary operations that do not need to be seen as referenced."	self createFinalImageHiddenLogic: notifier.	" remove unreferenced items and force a relinkSystem when done "	SystemUtils modifySystem: [		self discardUnreferencedMethodsClassesAndGlobals: notifier.		self discardLoadableNameSpaces: notifier.		notifier log: 'Linking System'. ].	notifier log: 'Cleaning up DeferredBindings'.	self cleanUpDeferredBindings.	" finish stripping the image "	tickRatePerClass := Smalltalk allClasses size // 50.	( StrippingOptions includes: #mergeLiterals ) ifTrue: [		notifier tickRate: tickRatePerClass.		self mergeLiterals: notifier ].	( StrippingOptions includes: #mergeByteCodes ) ifTrue: [		notifier tickRate: tickRatePerClass.		self mergeByteCodeStrings: notifier. ].	( StrippingOptions includes: #mergeMethods ) ifTrue: [		notifier tickRate: tickRatePerClass.		self mergeMethods: notifier. ].	( StrippingOptions includes: #useRuntimeCompiledMethod ) ifTrue: [		notifier tickRate: tickRatePerClass.		self installCompactMethods: notifier. ].	" garbage collection more time "	notifier log: 'Global garbage collect again'.	ObjectMemory globalGarbageCollect.	" rebuild the dictionary of symbols "	notifier log: 'Rehashing symbol table'.	Symbol rehash.	" that's all follks "	notifier log: 'Done'.	notifier close.	RuntimeManager changed: #imageStrippingComplete.	^true</body><body package="RuntimePackager">createFinalImageHiddenLogic: notifier	"Perform the steps needed to create the final image that should not be seen	in the scan for referenced classes and methods.  Answer true if successful."	" expand the filename for the target image file"	ImagePath := self expandedStringFrom: ImagePath.	" keep this class and its superclasses (just in case) "	self withAllSuperclasses do: [ :cl |		DeletedClasses remove: cl ifAbsent: [] ].	" remove the definitions of loadable parcels "	self destroyLoadableParcels: notifier.	" package external interface classes - do first in case of failure "	( StrippingOptions includes: #packageExternalInterfaces ) ifTrue: [		( self packageExternalInterfaceSubclasses: notifier ) ifFalse: [ ^ false ] ].	"Install the emergency error handler"	notifier log: 'Installing emergency error handler'.	RuntimeManager changed: #aboutToInstallEmergencyErrorHandler.	ErrorNotifierClass notNil ifTrue: [		self hookNotifierClass: ErrorNotifierClass ].	self discardSourcesFromFinalImage: notifier.	self emptyChangeSetsInFinalImage: notifier.	self doMiscellaneousCleanupsInFinalImage: notifier.	self replaceDoItMenusInFinalImage: notifier.	( StrippingOptions includes: #removeOrganization ) ifTrue: [		self discardSystemAndClassOrganizations: notifier. ].	" garbage collect before removing methods etc."	notifier log: 'Global garbage collect (please wait)'.	ObjectMemory globalGarbageCollect.	"Set spaces for runtime image startup"	self setSpaceSizesInFinalImage: notifier.	^true</body><body package="RuntimePackager">destroyLoadableParcels: notifier	"Destroy the definitions of loadable parcels so that there are no conflicts	when the parcels are later reloaded. Unload parcels that are to be unloaded	and unload applications that will be represented as parcels."	| |	notifier log: 'Removing the definitions of loadable parcels'.	RuntimeManager changed: #destroyingLoadableParcels.	"Destroy parcels that are known to be loadable. Classes will be removed later."	LoadableParcels do: [ :parcel |		( ParcelsToUnload includes: parcel ) ifFalse: [			Parcel destroyParcelNamed: parcel name ] ].	"Unload remaining parcels that are to be unloaded"	( SystemUtils sortForLoading: ParcelsToUnload ) reverseDo: [ :parcel |		Parcel unloadParcelNamed: parcel name. "This way hooks with ED 5i" ].	"Remove any dangling references"	LoadableParcels := nil.	ParcelsToUnload := nil.</body><body package="RuntimePackager">discardLoadableNameSpaces: notifier	"Discard name spaces that are loaded via parcels "	| sortedNS |	RuntimeManager changed: #aboutToDeleteLoadableNameSpaces.	" Delete names spaces that are loaded via parcels "	LoadableNameSpaces isEmpty ifFalse: [		notifier log: '  Deleting loadable Name Spaces'.		" put the name spaces in an arbitrary but predictable order"		sortedNS := LoadableNameSpaces asSortedCollection: [ :x :y | x name &lt; y name ].		sortedNS do: [ :ns |			ns isObsolete ifFalse: [				self traceLevel &gt;= 2 ifTrue: [					notifier cr; show: 'Removing namespace ', ns name. ].				ns quietlyRemoveFromSystem. ] ] ].	" Make really sure extraneous references are gone "	LoadableNameSpaces := nil.</body><body package="RuntimePackager">discardSourcesFromFinalImage: notifier	"Discard sources to prevent access to sources and changes files in the runtime image.	 Be sure to tell the DevelopmentSystem that it can not be activated, otherwise it will	 try to re-install the changes file when the system is starting up."	| cl |	( cl := RuntimeManager hiddenReferenceTo: 'SourceFileManager' ) notNil ifTrue: [		notifier log: (#DisconnectingSourcesAndChanges &lt;&lt; #RuntimePackager &gt;&gt; 'Disconnecting sources and changes files from this image') asString.		RuntimeManager changed: #aboutToDiscardSources.		cl default removeAllSources.		DevelopmentSystem canActivate: false].</body><body package="RuntimePackager">discardSystemAndClassOrganizations: notifier	" discard system organizer, class organizers, and misc info"	| exceptionClasses |	notifier log: 'Deleting system and class organizations'.	RuntimeManager changed: #aboutToDiscardOrganizations.	( RuntimeManager allNameSpacesFrom: Root ) do: [ :ns |		ns organization: ns organization class new. ].	" save a collection of exceptions consisting of classes that	use organization information at runtime"	exceptionClasses := IdentitySet new.	exceptionClasses add: CIntegerType. "see CIntegerType class&gt;&gt;initializeSelectors"	" empty organizations. setting to nil trips up	ClassDescription&gt;&gt;whichCategoryIncludesSelector: in VW5i.0"	RuntimeManager allClassesDo: [ :cl |		( exceptionClasses includes: cl ) ifFalse: [			cl instVarAt: self organizationIndex put: cl organization class new.			cl class instVarAt: self organizationIndex put: cl class organization class new. ] ].</body><body package="RuntimePackager">discardUnreferencedMethodsClassesAndGlobals: notifier	" discard unreferenced classes, methods and globals "	| replacements specialCompilerClasses traceClassRemovals traceMethodRemovals traceCount |	notifier log: 'Deleting unreferenced items'.	RuntimeManager changed: #aboutToDeleteUnreferencedItems.	" discard unreferenced classes "	notifier tickRate: DeletedClasses size // 50.	" check the TraceLevel "	traceClassRemovals := false.	traceMethodRemovals := false.	self traceLevel &gt;= 2 ifTrue: [ traceClassRemovals := true. ].	self traceLevel &gt;= 4 ifTrue: [ traceMethodRemovals := true. ].	"Special compiler classes are not removed removed from their name space to	allow deleted behaviors to remain behind with just enough behavior."	specialCompilerClasses := IdentitySet new.	( StrippingOptions includes: #removeCompiler ) ifTrue: [		specialCompilerClasses add: ( self hiddenReferenceTo: 'SmalltalkCompiler' ).		specialCompilerClasses add: ( self hiddenReferenceTo: 'Compiler' ).		specialCompilerClasses add: ( self hiddenReferenceTo: 'Scanner' ).		specialCompilerClasses add: ( self hiddenReferenceTo: 'Parser' ). ].	"sort the deleted classes bottom up in the hierarchy"	notifier log: '  Deleting classes part 1'.	"Always, always keep method dictionaries"	MethodDictionary withAllSubclasses do: [ : cl |		DeletedClasses remove: cl ifAbsent: [] ].	replacements := self prepareClassesForDeletionIn: notifier.	" remove classes from the System Dictionary and make them obsolete "	notifier log: '  Deleting classes part 2'.	self purgeDependents: AllDeletedBehaviors.	replacements do: [ :repArray |		| cl |		cl := repArray at: 1.		" For special compiler classes, leave alone until phase 2 "		( specialCompilerClasses includes: cl ) ifFalse: [			" watch out for ghost classes "			( cl format notNil and: [			cl class format notNil and: [			cl environment includesKey: cl name ] ] )				ifTrue: [					traceClassRemovals ifTrue: [						notifier cr; show: 'Removing ',cl name. ].					cl quietlyRemoveFromSystem.  ] ].		notifier tick. ].	" replace each class with a naked behavior and replace old instances"	notifier log: '  Deleting classes part 3'.	replacements do: [ :x |		| cl meta replClass replMeta replInstBehavior |		cl := x at: 1.		meta := cl class.		replInstBehavior := x at: 2.		replClass := x at: 3.		replMeta := x at: 4.		" dispose of old instances "		cl allInstancesDo: [ :obj |			| newObj |			newObj := replInstBehavior new.			newObj primBecome: obj. ].		" switch places between old and new classes "		replClass become: cl.		cl flushVMmethodCache.		replMeta become: meta.		meta flushVMmethodCache.		notifier tick.  ].	replacements := nil.	" remove unreferenced methods "	notifier log: '  Deleting methods'.	notifier tickRate: DeletedMethods size // 50.	traceCount := 0.	DeletedMethods keysAndValuesDo: [ :behav :selectors |		" do not bother deleted classes (which still understand identity methods)"		( AllDeletedBehaviors includes: behav ) ifFalse: [			selectors do: [ :sel |				traceMethodRemovals ifTrue: [					( traceCount := traceCount + 1) &gt; 20 ifTrue: [						notifier text value: String new.						traceCount := 0. ].					notifier cr; show: behav name, '&gt;&gt;', sel. ].				" hard code keeping copyright methods "				sel == #copyright					ifFalse: [ [ behav quietlyRemoveSelector: sel  ] on: Error do: [:ex | ex return ] ] ].			" flush the method cache all at once "			behav flushVMmethodCache. ].		notifier tick. ].	" set unreferenced globals to nil "	( StrippingOptions includes: #stripGlobals ) ifTrue: [		notifier log: '  Removing unreferenced globals'.		notifier tickRate: DeletedGlobals size // 50.		traceCount := 0.		self sortDeletedGlobals.		DeletedGlobals do: [ :ref |			| refBinding |			refBinding := ref bindingOrNil.			refBinding notNil ifTrue: [				traceClassRemovals ifTrue: [					( traceCount := traceCount + 1) &gt; 20 ifTrue: [						notifier text value: String new.						traceCount := 0 ].					notifier cr; show: 'Resetting ', refBinding key. ].				refBinding whileMutableDo: [refBinding setValue: nil].				"Remove the binding, notifying the change set so that it gets removed from the containing package.				If the binding is for a shared variable on a class, its environment will be a class so coerce it to be				a namespace.  This is a no-op for proper Namespaces."				refBinding value isNameSpace 					ifTrue: [ref removeFromSystem: #(changes)]					ifFalse:						[ref environment							ifNotNil:								[:refEnvironment |								refEnvironment asNameSpace removeBinding: refBinding recordIn: #(changes) ifAbsent: []]]]]].	self purgeChangeSets.	self removeExtraneousReferences</body><body package="RuntimePackager">doMiscellaneousCleanupsInFinalImage: notifier	"Take care of minor cleanups"	| cl |	notifier log: 'Doing miscellaneous cleanups'.	RuntimeManager changed: #doingMiscellaneousCleanups.	"clear the transcript, but only if standard text collector is in use"	Transcript removeDependent: RuntimeManager. " just in case"	( Transcript isKindOf: TextCollector ) ifTrue: [		Transcript clear.		Transcript dependents do: [ :dep |			dep class == ScheduledWindow ifTrue: [ dep refresh ] ].		Transcript addDependent: RuntimeManager. ].	"discard installation instructions and system workspace"	cl := RuntimeManager hiddenReferenceTo: 'ComposedTextView'.	cl notNil ifTrue: [		( cl classPool at: #InstallationWorkspace ifAbsent: [ ValueHolder new ] )			value: Text new.		( cl classPool at: #SystemWorkspace ifAbsent: [ ValueHolder new ] )			value: Text new. ].	"forget previous paste buffer selections (more privacy than space savings)"	cl := RuntimeManager hiddenReferenceTo: 'ParagraphEditor'.	cl notNil ifTrue: [		( cl classPool includesKey: #PreviousSelection ) ifTrue: [			cl classPool at: #PreviousSelection put: (				( cl classPool at: #PreviousSelection ) class new ). ].		( cl classPool includesKey: #UndoSelection ) ifTrue: [			cl classPool at: #UndoSelection put: (				( cl classPool at: #UndoSelection ) class new ). ]. ].	" Clear the Parcel search path is indicated and valid for this release "	( ( StrippingOptions includes: #clearParcelPath ) and: [		( cl := RuntimeManager hiddenReferenceTo: 'Parcel' ) notNil ] )		ifTrue: [			cl searchPathModel value: List new. ].	"unhook from the Launcher Window"	self removeFromLauncherMenu.	"Disable the warp to launcher feature"	(RuntimeManager hiddenReferenceTo: 'InputState') 		ifNotNil: [:inputState | inputState warpToLauncherKey: -1].	"just to clean up extra reference - not really needed"	cl := nil.</body><body package="RuntimePackager">emptyChangeSetsInFinalImage: notifier	" empty the current change set(s). If Project is defined, remove changes "	| cl |	notifier log: 'Emptying change sets'.	RuntimeManager changed: #emptyingChangeSets.	cl := #{ChangeSet} valueOrDo: [ nil ].	cl notNil ifTrue: [ cl current initialize ].</body><body package="RuntimePackager">installCompactMethods: notifier	" Install the more compact runtime methods as replacements for existing	method dictionaries."	| rtcmClass |	notifier log: 'Installing compact methods'.	RuntimeManager changed: #aboutToInstallCompactMethods.	rtcmClass := self hiddenReferenceTo: 'RuntimeCompiledMethod'.	rtcmClass setRuntimeFormat.	RuntimeManager allClassesDo: [ :cl |		notifier tick.		( cl ~~ self and: [			cl ~~ Object and: [			cl ~~ Behavior ] ] ) ifTrue: [			self replaceMethodsIn: cl using: rtcmClass.			self replaceMethodsIn: cl class using: rtcmClass. ] ].</body><body package="RuntimePackager">mergeArrayLiteral: litArray  pool: literals	"Replace the contents of litArray with merged literals"	| lit repl |	1 to: litArray size do: [ :idx |		lit := litArray at: idx.		repl := self mergeLiteral: lit pool: literals.		lit == repl ifFalse: [ "avoid changing things that are not different"			litArray whileMutableDo: [litArray at: idx put: repl ] ] ].</body><body package="RuntimePackager">mergeByteCodeStrings: notifier	"Merge method bytes that are the same to refer to only one occurrence"	| methodBytes bytesIdx tableSize sortedBytes lastBytes bytes |	bytesIdx := self bytesIndex. "cache for later frequent use"	tableSize := 63.	notifier log: 'Merging method byte codes'.	notifier tickRate: notifier tickRate * 2. " i.e. only go half way"	RuntimeManager changed: #aboutToMergeByteCodes.	" put methods into slots based on a fast hash "	methodBytes := Array new: tableSize.	1 to: tableSize do: [ :index | methodBytes at: index put: OrderedCollection new ].	notifier tick.	RuntimeManager allClassesDo: [ :obj |			( Array with: obj with: obj class ) do: [ :behav |				( behav instVarAt: self methodDictIndex ) do: [ :meth |					meth withAllBlockMethodsDo: [ :bl |						bl isShort ifFalse: [							| mbytes |							mbytes := bl instVarAt: bytesIdx.							mbytes size &gt; 4 ifTrue: [ "this should always be true"								( methodBytes at: (									( mbytes at: 5) + mbytes size  \\  tableSize + 1 ) )										add: bl. ] ] ] ] ].			notifier tick. ].	" sort and merge each group of methods "	notifier tickRate: tableSize // 25.	1 to: tableSize do: [ :index |		sortedBytes := ( methodBytes at: index ) asSortedCollection: [ :xBlock :yBlock |			" sort based on length of bytes and contents of bytes "			| x y |			x := xBlock instVarAt: bytesIdx.			y := yBlock instVarAt: bytesIdx.			x size == y size				ifTrue: [ | i  n |					i := 1.					n :=x size.					[ i &lt;=n and: [ (x at: i) == (y at: i) ] ] whileTrue: [ i := i + 1].					i &lt;= n						ifTrue: [ ( x at: i) &lt; (y at: i ) ]						ifFalse: [ false ] ]				ifFalse: [ x size &lt; y size ] ].		sortedBytes size &gt; 1 ifTrue: [			lastBytes := sortedBytes first instVarAt: bytesIdx.			sortedBytes do: [ :bl |				bytes := bl instVarAt: bytesIdx.				bytes = lastBytes					ifTrue: [ bl instVarAt: bytesIdx put: lastBytes ]					ifFalse: [ lastBytes := bytes ] ] ].		notifier tick. ].</body><body package="RuntimePackager">mergeLiteral: lit  pool: literals	"Answer the unique value to use for merging the literal lit.	literals contains a dictionary with the unique instance of each literal value"	| litKey lits literalBlock |	" Arrays are scanned for merged immediate values but are not	merged into unique values themselves "	lit class == Array ifTrue: [		self mergeArrayLiteral: lit pool: literals.		^lit ].	" Get the dictionary of values for the literal "	lits := literals at: lit class ifAbsent: [ ^lit ].	" Empty strings are not merged -- if there were an application bug, too many		undiagnosable problems would arise because of the widespread use of this		literal in the base image. See for example ComposedText class&gt;&gt;new."	( lit isString and: [ lit size = 0 ] ) ifTrue: [ ^lit ].	litKey := lit. "default key is the literal itself"	"See if special handling applies to arithmetic values"	lit respondsToArithmetic ifTrue: [		literalBlock := LiteralKeyBlocks at: lit class ifAbsent: [ nil ].		literalBlock notNil ifTrue: [ litKey := literalBlock value: lit ] ].	" Answer the unique value from the literals dictionary "	^lits at: litKey ifAbsent: [		lits at: litKey put: lit ]</body><body package="RuntimePackager">mergeLiterals: notifier	"Merge literals that are the same to refer to only one occurrence.	Literals are merged only for selected classes and then only for equal values.	Empty strings are used in too many critical places and are not merged.	Array contents are merged but the Arrays themselves are not.	Arithmetic values get special blocks to handle cases where equality does not	mean that values can be merged."	| literals |	notifier log: 'Merging method and block literals'.	RuntimeManager changed: #aboutToMergeLiterals.	" Special classes to use for literals.	Fraction is a hopeful addition since the compiler does not treat 1/2 as a literal	Do not cause extraneous references in the unlikely event these classes are not	used elsewhere."	literals := Dictionary new: 17.	#( 	'ByteString' 'TwoByteString'		'LargePositiveInteger' 'LargeNegativeInteger'		'Float' 'Double'		'FixedPoint' 'Fraction' ) do: [ :cln |		( cln asQualifiedReference isDefined ) ifTrue: [			literals at: ( cln asQualifiedReference value ) put: Dictionary new. ] ].	" initialize the blocks used to compare literals "	self setupLiteralKeyBlocks.	" get unique occurrences of literals and replace them in methods and blocks "	RuntimeManager allClassesDo: [ :cl |			( cl instVarAt: self methodDictIndex ) do: [ :meth |				self mergeLiteralsInMethod: meth pool: literals ].			( cl class instVarAt: self methodDictIndex ) do: [ :meth |				self mergeLiteralsInMethod: meth pool: literals ].		notifier tick. ].	"Just to be safe, clear the literal key blocks"	LiteralKeyBlocks := nil.</body><body package="RuntimePackager">mergeLiteralsInMethod: method pool: literals	"Merge the literals in method using literals as the pool of common values"	| numLit lit repl |	" protect against any strange variants of methods "	( method class == CompiledMethod or: [	method class == AnnotatedMethod ] )  ifFalse: [ ^self ].	" replace literals with unique instances "	method withAllBlockMethods do: [ :bl |		numLit := bl numLiterals.		1 to: numLit do: [ :idx |			lit := bl literalAt: idx.			repl := self mergeLiteral: lit pool: literals.			lit == repl ifFalse: [ "do not change if not different"				bl literalAt: idx put: repl; flushCachedVMCode ] ] ].</body><body package="RuntimePackager">mergeMethods: notifier	"Merge methods that are the same so that only one real instance is present.	Moving methods to a common owner is no longer used because of	SystemUtils class&gt;&gt;linkSystem which uses mclass to reset the bindings.	Method names appearing in stack traces will therefore be unreliable."	| allMethods mdictIdx exceptionClasses rtcmClass count |	notifier log: 'Merging common methods'.	RuntimeManager changed: #aboutToMergeMethods.	count := 0.	"One tick for class and one for metaclass"	notifier tickRate: notifier tickRate * 2.	" set up a place to store methods so that dups can be detected "	allMethods := Dictionary new: 32000.	mdictIdx := self methodDictIndex.	" initialize the blocks used to compare literals "	self setupLiteralKeyBlocks.	" prepare a list of classes that are not touched "	exceptionClasses := IdentitySet with: self.	exceptionClasses		addAll: ExternalInterface withAllSuperclasses;		addAll: Class withAllSuperclasses;		addAll: Metaclass withAllSuperclasses;		addAll: GenericException withAllSubclasses;		addAll: GeneralNameSpace withAllSubclasses;		addAll: DeferredBinding withAllSubclasses;		addAll: ( exceptionClasses copy collect: [ :x | x class ] ).	" go through all behaviors and do the merge "	rtcmClass := self hiddenReferenceTo: 'RuntimeCompiledMethod'.	SystemUtils allBehaviorsDo: [ :behav |		| dups mdict |		notifier tick.		( exceptionClasses includes: behav ) ifFalse: [			mdict := behav instVarAt: mdictIdx.			dups := IdentityDictionary new.			mdict keysAndValuesDo: [ :sel :mth |				" Screen for only cases that can be safely merged "				( ( mth class == CompiledMethod or: [					mth class == rtcmClass ] ) and: [				"  value is sent internally by the VM in some cases -- avoid problems"				sel ~~ #value ] )				ifTrue: [					| replAssoc |				  	replAssoc := allMethods associationAt: mth ifAbsent: [						allMethods at: mth put: sel.						nil ].					replAssoc notNil ifTrue: [						dups at: sel put: replAssoc key ] ] ].			dups keysAndValuesDo: [ : sel :repl |				" put the replacement in where the current method was "				count := count + 1.				mdict at: sel put: repl.				behav flushVMmethodCacheEntriesFor: sel. ] ] ].	"DEBUG output	notifier show: ' ', count printString, ' methods merged'. "</body><body package="RuntimePackager">packageExternalInterfaceSubclasses:  notifier	"Do any necessary cleanups for C macros by invoking	ExternalDictionary class&gt;&gt;fillDefineCachesWithValues."	| macroClass fillSelector |	" put message on notifier "	notifier log: 'Packaging ExternalInterface subclasses'.	notifier tickRate: 1.	RuntimeManager changed: #packagingExternalInterfaceSubclasses.	" avoid references to certain selectors and classes "	macroClass := RuntimeManager hiddenReferenceTo: 'CMacroDefinition'.	macroClass isNil ifTrue: [ ^ true ].	fillSelector := ( '_fillDefineCaches' copyWithout: $_ ) asSymbol.	" package each external interface subclass "	ExternalInterface allSubclasses do: [ :cl |		( DeletedClasses includes: cl ) ifFalse: [			[ cl perform: fillSelector ]			on: Error			do: [ :ex |				Dialog warn: ex errorString,					'\\Error in packaging external interface for ' withCRs,					cl class name.				^false ] ].		notifier tick.].	^true</body><body package="RuntimePackager">prepareClassesForDeletionIn: notifier	"Sort the classes to make sure that we delete subclasses before superclasses, and dependents (as defined by prerequisitesForLoading) before the things they depend on. Create a collection of replacement classes and metaclasses to substitute, and also populate the AllDeletedBehaviors list."	| replacements visited |	DeletedClassesInOrder := OrderedCollection new: DeletedClasses size.	ClassPrerequisites := IdentityDictionary new: DeletedClasses size.	DeletedClasses := DeletedClasses asSet.	DeletedClasses copy do: [:each | DeletedClasses addAll: each allSubclasses].	"Subclasses must be removed before superclasses"	DeletedClasses do: [:each |		ClassPrerequisites at: each put: each subclasses asOrderedCollection].	"Prerequisites must be removed *after* things that require them" 	DeletedClasses do: [:each |		each prerequisitesForLoading do: [:eachPrereq |			ClassPrerequisites at: eachPrereq ifPresent: [:collection |  collection add: each]]].	visited := IdentitySet new: DeletedClasses size.	DeletedClasses do: [:each |		self sortClassForDeletion: each in: visited notifying: notifier].	AllDeletedBehaviors := IdentitySet new: DeletedClasses size.	DeletedClasses do: [ :cl |		AllDeletedBehaviors add: cl; add: cl class ].	replacements := OrderedCollection new: DeletedClasses size.	DeletedClassesInOrder do: [ :cl |			replacements add: ( Array				with: cl				with: ( RuntimeDeletedBehavior forDeletedInstance: cl)				with: ( RuntimeDeletedBehavior onDeletedClass: cl )				with: ( RuntimeDeletedBehavior onDeletedMetaclass: cl class ) ) ].	^replacements.</body><body package="RuntimePackager">purgeDependents: deletedClasses	"Clean up any well-known system dependencies that include things that are going to be deleted. The most basic of these, is any class-level dependencies, e.g. dependencies on ObjectMemory, ChangeSet, etc."	Object withAllSubclasses, (Array with: Transcript with: Store.Registry) do: [:each | 		| deletedDependents |		deletedDependents := each dependents select: [:dependent | 			(deletedClasses includes: dependent) or: [deletedClasses includes: dependent class]].		deletedDependents do: [:dependent | each removeDependent: dependent]].</body><body package="RuntimePackager">replaceDoItMenusInFinalImage: notifier	" check for need to delete doits from menu (but avoid dependency on compiler)"	| paraEdCl |	( DeletedClasses includes:  (		RuntimeManager hiddenReferenceTo: 'SmalltalkCompiler'  ) ) ifTrue: [		notifier log: 'Removing doits from ParagraphEditor menus'.		RuntimeManager changed: #removingDoIts.		" just make sure we are not dealing with a deviant image"		paraEdCl := RuntimeManager hiddenReferenceTo: 'ParagraphEditor'.		paraEdCl notNil ifTrue: [			( paraEdCl classPool includesKey: #TextEditorYellowButtonMenu )				ifTrue: [					paraEdCl classPool at: #CodeYellowButtonMenu put: (						paraEdCl classPool at: #TextEditorYellowButtonMenu ) ].			paraEdCl withAllSubclasses do: [ :cl |				cl allInstances do: [ :x | x initializeMenu] ] ] ].</body><body package="RuntimePackager">replaceMethodsIn: aBehavior using: rtcmClass	"Replace the methods in the behavior provided with ones of the	class provided. This is done to remove extra instance variables."	| mdict |	mdict := aBehavior instVarAt: self methodDictIndex.	"check for spoof method dictionaries that may have	unusual protocols and are thus better avoided"	mdict class == MethodDictionary ifFalse: [ ^ self ].	"replace each method with a more compact one"	mdict keysAndValuesDo: [:sel :meth |		( meth class == CompiledMethod and: [		meth mclass == aBehavior ] ) ifTrue: [			meth become: ( rtcmClass fromMethod: meth ).			aBehavior flushVMmethodCacheEntriesFor: sel. ] ]</body><body package="RuntimePackager">resolveMemoryPolicyClass	^MemoryParams memoryPolicyClass asQualifiedReference		valueOrDo: [LargeGrainMemoryPolicy]</body><body package="RuntimePackager">setSpaceSizesInFinalImage: notifier	" set space sizes at startup and build a new memory policy (installed later)"	| startupSizes newSizes |	notifier log: 'Setting startup space sizes'.	startupSizes := ObjectMemory defaultSizesAtStartup.	newSizes := Array new: 7.	newSizes at: 1 put: MemoryParams edenSize asFloat / ( startupSizes at: 1 ).	newSizes at: 2 put: MemoryParams survivorSize asFloat / (startupSizes at: 2).	newSizes at: 3 put: MemoryParams largeSize asFloat / (startupSizes at: 3).	newSizes at: 4 put: MemoryParams stackSize asFloat / (startupSizes at: 4).	newSizes at: 5 put: MemoryParams codeSize asFloat / (startupSizes at: 5).	newSizes at: 6 put: MemoryParams oldSize asFloat / (startupSizes at: 6).	newSizes at: 7 put: MemoryParams fixedSize asFloat / (startupSizes at: 7).	ObjectMemory sizesAtStartup: newSizes.	self resolveMemoryPolicyClass defaultMemoryUpperBound: MemoryParams memoryUpperBound.	NewMemoryPolicy := self resolveMemoryPolicyClass new.	MemoryParams := nil.</body><body package="RuntimePackager">setupLiteralKeyBlocks	"Setup a dictionary of blocks used to generate keys for comparing numeric	literals. These blocks handle special cases in which the criteria for merging is not the	normal definition of equality. Allow for classes having been stripped out	and avoid adding new references to classes."	| cl |	LiteralKeyBlocks := Dictionary new: 17.	(cl := Smalltalk at: 'Fraction' asSymbol ifAbsent: [ nil ] ) notNil  ifTrue: [		LiteralKeyBlocks at: cl put: [ :lit |			Array with: lit numerator with: lit denominator ] ].	(cl := Smalltalk at: 'FixedPoint' asSymbol ifAbsent: [ nil ] ) notNil  ifTrue: [		LiteralKeyBlocks at: cl put: [ :lit |			Array with: lit numerator with: lit scale with: lit denominator ] ].	(cl := Smalltalk at: 'Double' asSymbol ifAbsent: [ nil ] ) notNil  ifTrue: [		LiteralKeyBlocks at: cl put: [ :lit |			| key |			key := Array new: lit basicSize.			1 to: key size do: [ :i | key at: i put: ( lit basicAt: i ) ].			key ] ].	(cl := Smalltalk at: 'Float' asSymbol ifAbsent: [ nil ] ) notNil  ifTrue: [		LiteralKeyBlocks at: cl put: [ :lit |			| key |			key := Array new: lit basicSize.			1 to: key size do: [ :i | key at: i put: ( lit basicAt: i ) ].			key ] ].</body><body package="RuntimePackager">sortClassForDeletion: aClass in: aSet notifying: notifier	"Do a topological sort for this class, based on the prerequisites we have set up in ClassPrerequisites for subclass and prerequisitesForLoading relationships. Put the results into DeletedClassesInOrder."	| prereqs |	(aSet includes: aClass) ifTrue: [^self].	aSet add: aClass.	prereqs := ClassPrerequisites at: aClass.	prereqs do: [:each | self sortClassForDeletion: each in: aSet notifying: notifier].	notifier ifNotNil: [notifier tick].	DeletedClassesInOrder add: aClass.</body><body package="RuntimePackager">sortDeletedGlobals		"Sort the deleted globals so that things contained get deleted before the things that contain them. Note that this won't work for references in general, but ours are all fully qualified, so it gets the environment right"		DeletedGlobals := DeletedGlobals asSortedCollection: [:a :b |			| allEnvs current |			allEnvs := OrderedCollection new.			current := a environment.			[current isNil] whileFalse: [allEnvs add: current. current := current environment].			(allEnvs includes: b)].</body><body package="RuntimePackager">suppressEmergencyEvaluator: notifier	"Ignore keystrokes that raise the EmergencyEvaluator in the runtime image"	notifier log: 'Suppressing the emergency evaluator'.	InputState interruptKeyValue: nil</body></methods><methods><class-id>RuntimePackager.RuntimeManagerStripper class</class-id> <category>dynamic references</category><body package="RuntimePackager">itemsReferencedByClassSelector: aSelector	"Filter out false references"	aSelector == #createFinalImage ifTrue: [		^( self class compiledMethodAt: #createFinalImage ) allLiterals			reject: [ :lit | lit == #createFinalImageHiddenLogic: ] ].	^nil</body></methods><methods><class-id>RuntimePackager.RuntimeManagerStripper class</class-id> <category>private-stripping</category><body package="RuntimePackager">purgeChangeSets	"Purge all change sets, if any are present. This is done very late so we get changes 	 that were caused by our deletions. Try to avoid using possibly-stripped 	 messages, e.g. #allGeneralInstances."	(self hiddenReferenceTo: 'ChangeSet') ifNotNil: [:changeSet |		[changeSet allSubclasses, (Array with: changeSet) do: [:eachClass  | 			eachClass allInstancesDo: [:each |				[each initialize] on: Error do: [:ex | ex return]]]] 			on: Error do: [:ex | ex return]].</body><body package="RuntimePackager">removeExtraneousReferences	" Make really sure extraneous references are gone."	LoadableClasses := nil.	DeletedMethods := nil.	DeletedClasses := nil.	DeletedGlobals := nil.	AllDeletedBehaviors := nil.	DeletedClassesInOrder := nil.	ClassPrerequisites := nil.</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedInstance</class-id> <category>compiling</category><body package="RuntimePackager">compile: textOrStream in: aClass notifying: aRequestor ifFail: failBlock	"Always treat compile requests as failures"	^failBlock value</body><body package="RuntimePackager">evaluate: textOrStream	in: aContext	receiver: receiver	notifying: aRequestor	ifFail: failBlock	"Always treat compile requests as failures"	^failBlock value</body><body package="RuntimePackager">evaluate: textOrStream	in: aContext	to: receiver	notifying: aRequestor	ifFail: failBlock	"Always treat compile requests as failures"	^failBlock value</body><body package="RuntimePackager">format: textOrStream in: aClass notifying: aRequestor	"Do not really do the format"	^textOrStream</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedInstance</class-id> <category>error handling</category><body package="RuntimePackager">doesNotUnderstand: aMessage	"Raise a signal indicating that a messsage was sent to a deleted behavior."	^RuntimeDeletedBehavior deletedBehaviorReferencedSignal		raiseWith: ( MessageSend			receiver: self			selector: aMessage selector			arguments: aMessage arguments )		errorString: 'Referenced an instance of deleted Behavior:  ', self class originalName</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedInstance</class-id> <category>parsing</category><body package="RuntimePackager">initScanner	"Fill in for Scanner or Parser on this -- do nothing"	^self</body><body package="RuntimePackager">isLetter: aChar	"Fill in for Parser processing of this"	^ aChar = $_ or: [ aChar isLetter ]</body></methods><methods><class-id>RuntimePackager.RuntimeDeletedInstance</class-id> <category>printing</category><body package="RuntimePackager">printOn: aStream	"Print the receiver, an instance of a deleted behavior"	aStream		nextPutAll: 'a ';		nextPutAll: self class name.</body></methods><methods><class-id>RuntimePackager.RuntimeProgressNotifier</class-id> <category>internals</category><body package="RuntimePackager">advanceProgressIndicator	"Bump the progress indicator up to the next value"	| area rect |	progressCount := progressCount + 1.	progressCount &gt; 50		ifTrue: [ self resetProgressIndicator. ]		ifFalse: [			area := self builder componentAt: #progressString.			rect := Rectangle origin: 0.0 @ 0.0 extent: ( progressCount / 50.0 ) @ 1.0.			rect := rect scaledBy: ( area bounds insetBy: 3 ) extent.			rect := rect translatedBy: area bounds origin + ( 3 @3 ).			rect displayFilledOn: area graphicsContext. ].</body><body package="RuntimePackager">changeRequest	"Answer true if the window can be closed"	super changeRequest ifTrue: [ ^ true ].	ended := true.	^true</body><body package="RuntimePackager">checkForResize	"Look to see if the window size has changed"	windowExtent = self builder window extent ifFalse: [		self builder window checkForEvents.		self builder window component invalidate.		windowExtent := self builder window extent.		textWidget selectAt: 1.		textWidget selectAt: text value size. ].</body><body package="RuntimePackager">resetProgressIndicator	"Reset the progress indicator to an intial value"	| area |	progressCount := 0.	self builder isNil ifFalse: [		area := self builder componentAt: #progressString.		area graphicsContext clippingRectangle: ( area bounds insetBy: 3 ); clear. ].</body></methods><methods><class-id>RuntimePackager.RuntimeProgressNotifier</class-id> <category>actions</category><body package="RuntimePackager">close	"Close the window now"	self closeAndUnschedule.	RuntimeManager ensureUnscheduleWindow: self builder window.</body><body package="RuntimePackager">cr	"Send a CR to the text"	ended ifTrue: [ ^ self ].	self show: (String with: Character cr).</body><body package="RuntimePackager">log: aString	"Print the current time and the string in the window"	self show:  (String with: Character cr), Time now printString, ' ' , aString.	tickCount := 0.	self resetProgressIndicator.</body><body package="RuntimePackager">raise	"Raise the window if any"	self builder isNil ifTrue: [ ^nil ].	self builder window isOpen ifFalse: [ ^self ].	self builder window raise.</body><body package="RuntimePackager">show: aString	"Show the string in the progress window"	ended ifTrue: [ ^ self ].	text value: text value, aString.	textWidget selectAt: text value size.	self checkForResize.</body><body package="RuntimePackager">tab	"Send a tab to the text"	ended ifTrue: [ ^ self ].	self show: (String with: Character tab).</body><body package="RuntimePackager">tick	"Indicate progress by advancing the indicator"	ended ifTrue: [ ^self ].	tickCount := tickCount + 1.	tickCount &gt; tickRate ifTrue: [		self checkForResize.		self advanceProgressIndicator.		tickCount := 0. ].</body></methods><methods><class-id>RuntimePackager.RuntimeProgressNotifier</class-id> <category>initialization</category><body package="RuntimePackager">initialize	"Intitialize the instance"	tickCount := 0.	tickRate := 1.	text := Text new asValue.	ended := false.	self resetProgressIndicator.</body></methods><methods><class-id>RuntimePackager.RuntimeProgressNotifier</class-id> <category>interface opening</category><body package="RuntimePackager">postBuildWith: aBuilder	"Make the progressIndicator non-interactive"	super postBuildWith: aBuilder.	textWidget := ( aBuilder componentAt: #text ) widget.</body></methods><methods><class-id>RuntimePackager.RuntimeProgressNotifier</class-id> <category>aspects</category><body package="RuntimePackager">progressString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^progressString isNil		ifTrue:			[progressString := String new asValue]		ifFalse:			[progressString]</body><body package="RuntimePackager">text	"Answer the model of the currently showing text."	^text</body></methods><methods><class-id>RuntimePackager.RuntimeProgressNotifier</class-id> <category>accessing</category><body package="RuntimePackager">tickRate	"Answer the rate at which tick events are displayed"	^tickRate</body><body package="RuntimePackager">tickRate: anInteger	"Set the rate at which tick events are displayed"	tickRate := anInteger</body></methods><methods><class-id>RuntimePackager.RuntimeProgressNotifier class</class-id> <category>interface opening</category><body package="RuntimePackager">open	"Create a new instance and open it"	| x extent |	x := self new.	x allButOpenInterface: #windowSpec.	extent := x builder windowSpec bounds extent.	x builder openIn: (Rectangle			origin: (Screen default bounds center - ( extent // 2 ) )			extent:  extent ).	^x</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>internals</category><body package="RuntimePackager">changeRequest	"See if the window can be closed.  If so, cancel any opertions in progress"	" See if window is being closed for image save "	RuntimeManager runState == #aboutToSave ifTrue: [ ^true ].	" Proceed with normal checks for closing the window"	super changeRequest ifFalse: [ ^false ].	( tester notNil and: [ tester testInProgress ] ) ifTrue: [		Dialog warn: 'A test is in progress.\It must be ended before closing this window' withCRs.		^false ].	options cancel.	keptItems cancel.	tester notNil ifTrue: [ tester cancel ].	memoryParams cancel.	ScheduledControllers scheduledControllers do: [ :ctrl |		( ctrl model isKindOf: RuntimeBuilderAppModel ) ifTrue:[			ctrl closeNoTerminate ] ].	ActiveApplication := nil.	" clear the manager to, among other things, allow the application to be unloaded "	RuntimeSurrogateManager activeManager: nil.	^true</body><body package="RuntimePackager">closeDrainEventsAndUnschedule: controller	^controller closeDrainEventsAndUnschedule</body><body package="RuntimePackager">closeExtraWindows: deletedClasses	"Close all windows which directly reference classes that are being deleted,	present company excepted."	| controllers extras |	WindowManager allInstancesDo: [:each | each purgeDeadWindows].	controllers := ScheduledWindow scheduledControllers reject: [ :controller |			controller == self builder window controller or: [			controller model isKindOf: RuntimeBuilderAppModel ] ].	extras := controllers select: [ :controller |		controller class isObsolete or: [		( deletedClasses includes: controller class ) or: [		( deletedClasses includes: controller view class ) or: [		( deletedClasses includes: controller model class ) or: [		( deletedClasses includes: controller sensor class ) ] ] ] ] ].	extras isEmpty ifFalse: [		( interactWithUser not or: [			Dialog confirm:			'There are windows scheduled that reference deleted',			'\classes.  Do you want to close them now?' withCRs ] )			ifTrue: [				extras do: [ :controller | self closeDrainEventsAndUnschedule: controller] ] ].</body><body package="RuntimePackager">moveToStep: anInteger	"Move to the user step indicated"	| sels |	" move to the indicated step "	( anInteger &lt;= self class numberOfSteps and: [		anInteger &gt; 0 ] ) ifTrue: [		currentStepNumber := anInteger.		self stepTitle value: ( self class titleForStep: currentStepNumber ) asText allBold.		self stepDescription value: (			self class summaryOfStep: currentStepNumber ) ].	" adjust the button states "	( self builder componentAt: #previousStepButton ) perform: (		currentStepNumber == 1 ifTrue: [ #disable ] ifFalse: [ #enable ] ).	( self builder componentAt: #nextStepButton ) perform: (		currentStepNumber == self class numberOfSteps ifTrue: [ #disable ] ifFalse: [ #enable ] ).	" see if there are actions for this step "	sels := self class selectorsForStep: currentStepNumber.	( self builder componentAt: #doThisStepButton ) perform: (		( sels first isNil or: [			(sels at: 2) notNil and: [			( self perform: (sels at: 2) ) not ] ] )			ifTrue: [ #disable ] ifFalse: [ #enable ] ).	( self builder componentAt: #takeDefaultsButton ) perform: (		( sels last isNil or: [			(sels at: 2) notNil and: [			( self perform: (sels at: 2) ) not ] ] )			ifTrue: [ #disable ] ifFalse: [ #enable ] ).</body><body package="RuntimePackager">prepareToStripSystem	"Open a window confirming that the stripping is to proceed.	If the user approves the strip, set up RuntimeManager."	| launcherControllers deletedClasses hierarchyErrors |	( tester notNil and: [ tester testInProgress ] ) ifTrue: [		Dialog warn: ( 'A test is in progress.\',			'It must be ended before performing this step' ) withCRs.		^false ].	" get the real set of classes to be deleted "	deletedClasses := keptItems allDeletedClasses.	"Inspect the keptClasses and deletedClasses for hierarchy problems:	missing superclasses, namespaces, and superclass methods. If found 	inform the user, who may proceed or exit the packaging process."	hierarchyErrors := self checkForHierarchyProblems.	hierarchyErrors isEmpty 		ifFalse: [ | rtpHierarchyHelp | 		rtpHierarchyHelp := HierarchyErrorMessage errorString: hierarchyErrors.		rtpHierarchyHelp open.		rtpHierarchyHelp continue ifFalse: [^false]].	" close any extraneous windows"	self closeExtraWindows: deletedClasses.	"Disconnect from Store and remove debug hooks"	(RuntimeManager hiddenReferenceTo: 'Store.DbRegistry') ifNotNil: [:registry |registry disconnect].	(RuntimeManager hiddenReferenceTo: 'ProbedCompiledMethod') ifNotNil: [:probe |		probe revertAllProbedMethodsInSystem].	" look for open launchers (Visual Launchers only) not caught in the previous step"	launcherControllers := ScheduledControllers scheduledControllers		select: [ :cont | RuntimeManager launcherClassNames includes: cont model class name].	launcherControllers size &gt; 0 ifTrue: [		( interactWithUser not or: [		Dialog confirm: 'Do you want to close all open visual launchers now?'  ] )			ifTrue: [				launcherControllers do: [ :lc | lc closeDrainEventsAndUnschedule ] ] ].	" alert the user that this is the last chance to stop this process"	interactWithUser ifTrue: [		( Dialog confirm:'This is the final step in preparing the runtime image.Any extraneous windows should already be closedand application windows that are to remain open shouldbe in their desired position.  Runtime Packagerwindows will be closed automatically.Once the preparation process begins, it should not beinterrupted.  The resulting runtime image will be savedautomatically when the process completes.Do you want to proceed with this step?' )		ifFalse: [ ^false ] ].	RuntimeManager runState: #aboutToSave.	" get final set of deleted classes and methods "	RuntimeManager deletedClasses: deletedClasses.	RuntimeManager deletedMethods: keptItems allDeletedMethods.	RuntimeManager deletedGlobals: keptItems deletedGlobals copy.	RuntimeManager deletedGlobals addAll: keptItems unreferencedGlobals.	RuntimeManager loadableClasses: options loadableClasses.	" setup runtime manager for exit/startup sequence "	RuntimeManager		strippingOptions: options strippingOptions;		errorNotifierClass: options errorNotifierClass;		imageDumperClass: options imageDumperClass;		errorLogPath: options errorLogPath;		imagePath: options imagePath;		startupClass: options startupClass;		startupMethod: options startupMethod;		memoryParams: memoryParams;		loadableParcels: options loadableParcels;		loadableNameSpaces: options loadableNameSpaces;		parcelsToUnload: options parcelsToUnload;		traceLevel: options traceLevel.	" install hooks so that all windows can be closed "	RuntimeManager installHooks.	" now that everything is set up, send the user defined message, if any"	self sendPrestripMessage.	" Remove as much of the UI as possible"	options cancel.	keptItems cancel.	tester notNil ifTrue: [ tester cancel ].	memoryParams cancel.	ScheduledControllers scheduledControllers do: [ :ctrl |		( ctrl model isKindOf: RuntimeBuilderAppModel ) ifTrue:[			ctrl closeNoTerminate ] ].	ActiveApplication := nil.	self release.	options := keptItems := tester := memoryParams := nil.	self builder window controller closeAndUnschedule saveFinalImage.	" done without error"	^true</body><body package="RuntimePackager">sendPrestripMessage	"Send the prestrip message defined by the user.  This can be used to	hook up to the Runtime Manager for special handling during stripping"	options prestripClass isNil | options prestripMethod isNil ifFalse: [		options prestripClass perform: options prestripMethod ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>aspects</category><body package="RuntimePackager">cleanupDone	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^cleanupDone isNil		ifTrue:			[cleanupDone := false asValue]		ifFalse:			[cleanupDone]</body><body package="RuntimePackager">itemsDone	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^itemsDone isNil		ifTrue:			[itemsDone := false asValue]		ifFalse:			[itemsDone]</body><body package="RuntimePackager">memoryDone	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^memoryDone isNil		ifTrue:			[memoryDone := false asValue]		ifFalse:			[memoryDone]</body><body package="RuntimePackager">optionsDone	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^optionsDone isNil		ifTrue:			[optionsDone := false asValue]		ifFalse:			[optionsDone]</body><body package="RuntimePackager">reviewDone	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^reviewDone isNil		ifTrue:			[reviewDone := false asValue]		ifFalse:			[reviewDone]</body><body package="RuntimePackager">saveParcelsDone	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^saveParcelsDone isNil		ifTrue:			[saveParcelsDone := false asValue]		ifFalse:			[saveParcelsDone]</body><body package="RuntimePackager">scanDone	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^scanDone isNil		ifTrue:			[scanDone := false asValue]		ifFalse:			[scanDone]</body><body package="RuntimePackager">stepDescription	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^stepDescription isNil ifTrue: [stepDescription := String new asValue] ifFalse: [stepDescription]</body><body package="RuntimePackager">stepTitle	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^stepTitle isNil ifTrue: [stepTitle := String new asValue] ifFalse: [stepTitle]</body><body package="RuntimePackager">testDone	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^testDone isNil		ifTrue:			[testDone := false asValue]		ifFalse:			[testDone]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>parcels</category><body package="RuntimePackager">defineParcelPrereqs: parcelAppls	"Define prerequisite parcels based on Envy Application prereqs.	ENVY/Developer is assumed to be present in the image.	parcelAppls is an IdentityDictionary with the application as key and	parcel as value."	parcelAppls keysAndValuesDo: [ :pappl :parcel |		| prereqs |		prereqs := OrderedCollection new.		" The first prereq is hard coded to allow use of Application classes in the parcel,"		prereqs add: #('ENVYManagerApplicationSupport' '' ) copy.		" Add any loadable prerequisite applications as parcel prereqs"		pappl prerequisites do: [ :appl |			( parcelAppls includesKey: appl ) ifTrue: [				| preq |				preq := parcelAppls at: appl.				prereqs add: ( Array with:  preq name with: String new ) ] ].		parcel prerequisiteParcels: prereqs. ].</body><body package="RuntimePackager">hasParcelsToBeSaved	"Answer true if there are runtime loadable parcels"	^options hasParcelsToBeSaved</body><body package="RuntimePackager">parcelsToBeSaved	"Answer the parcels that are to be saved as part of this packaging operation"	^options loadableParcels.</body><body package="RuntimePackager">trimParcel: aParcel	"Answer a parcel copied from aParcel but with deleted classes and	methods removed"	|  deletedClasses deletedMethods workParcel |	" determine which classes and methods are deleted other than by being in parcels"	deletedClasses := keptItems unreferencedClasses isEmpty		ifTrue: [ keptItems deletedClasses ]		ifFalse: [ keptItems unreferencedClasses ].	deletedMethods := keptItems unreferencedMethods isEmpty		ifTrue: [ keptItems deletedMethods ]		ifFalse: [ keptItems unreferencedMethods ].	workParcel := aParcel copy.	"Now we have a working copy that can be changed.	Remove deleted classes and methods using mostly public protocols"	workParcel definedClasses do: [ :cl |		( deletedClasses includes: cl ) ifTrue: [			workParcel removeClasses: cl withAllSubclasses ] ].	workParcel definedAndExtendedClasses do: [ :cl |		" need to work around a bug by deleting these selectors one at a time"		( deletedMethods includesKey: cl ) ifTrue: [			( deletedMethods at: cl ) do: [ :sel |				workParcel removeSelector: sel forClass: cl. ] ].		( deletedMethods includesKey: cl class ) ifTrue: [			( deletedMethods at: cl class ) do: [ :sel |				workParcel removeSelector: sel forClass: cl class. ] ] ].	^workParcel</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>actions</category><body package="RuntimePackager">checkForHierarchyProblems"Problems may occur in the runtime image if a kept class has it's namespace, superclass, or all the methods of that superclass stripped during packaging. Users are informed and allowed to proceed or terminate the packaging process at their discretion."	| errorString missingNameSpaceString noMethodsErrorString missingSuperclassString |	errorString := String new.	"missing superclasses"	missingSuperclassString := self checkForMissingSuperclasses.	missingSuperclassString notEmpty 		ifTrue: [errorString := errorString, HierarchyErrorMessage new missingSuperclassDescription, missingSuperclassString].	"missing namespaces"	missingNameSpaceString := self checkForMissingNameSpaces.	missingNameSpaceString notEmpty		ifTrue: [errorString := errorString, HierarchyErrorMessage new noNameSpaceDescription, missingNameSpaceString].	"If a superclass contains no methods"	noMethodsErrorString := self checkForMissingSuperclassMethods.	noMethodsErrorString notEmpty 		ifTrue: [errorString := errorString, HierarchyErrorMessage new missingMethodsDescription, noMethodsErrorString].	^errorString</body><body package="RuntimePackager">checkForMissingNameSpaces"Check the set of classes marked to be kept to insure that their namespace is not marked for deletion."	| errorString deletedGlobals |	errorString := String new.	deletedGlobals := keptItems deletedGlobals.	deletedGlobals addAll: keptItems unreferencedGlobals.	keptItems keptClasses do: 			[:aClass |  				(deletedGlobals includes: aClass environment)						ifTrue:							[errorString := errorString , 'class: ' , aClass printString 												, ', namespace: ' , aClass environment printString 												, '\']].	^errorString</body><body package="RuntimePackager">checkForMissingSuperclassMethods	| errorString |	errorString := String new.	keptItems keptClasses do: 			[:aClass | 			| superclasses |			superclasses := aClass allSuperclasses.			superclasses do: 					[:superClass | 					keptItems deletedMethods at: superClass						ifPresent: 							[:selectors | 							selectors size = superClass selectors size 								ifTrue: 									[errorString := errorString , 'class: ' , aClass printString 												, ', superclass: ' , superClass printString 												, '\']]]].	^errorString</body><body package="RuntimePackager">checkForMissingSuperclasses"Check the set of classes marked to be kept for any superclasses that are marked for deletion."	| errorString |	errorString := String new.	keptItems keptClasses do: 			[:aClass | 			| superclasses |			superclasses := aClass allSuperclasses.			superclasses do: 					[:superClass | 					(keptItems allDeletedClasses includes: superClass)						ifTrue:							[errorString := errorString , 'class: ' , aClass printString 												, ', superclass: ' , superClass printString 												, '\']]].	^errorString</body><body package="RuntimePackager">doThisStepPushed	"Act on the do step button. Make sure we have interactivity turned on."	| sel |	interactWithUser := true.	sel := (self class selectorsForStep: currentStepNumber) first.	sel notNil ifTrue: [ self perform: sel ].</body><body package="RuntimePackager">loadParametersFile: filename 	"Load the parameters that are specified by filename.	 If there are any pending changes, they will be lost.   Also, it is assumed that file is readable."	| in fileVersion tokens actionBlocks |	Transcript		cr;		show: (#LoadingRuntimePackagerParams &lt;&lt; #RuntimePackager 					&gt;&gt; 'Loading Runtime Packager parameters from &lt;1s&gt;' 						expandMacrosWith: filename asString).	in := filename readStream.	fileVersion := VersionForPackaging fromString: '1.0'.	[tokens := Scanner new scanTokens: in contents] on: Object errorSignal		do: 			[:ex | 			Dialog warn: (#x1sErrorOccured &lt;&lt; #RuntimePackager &gt;&gt; '&lt;1s&gt;&lt;n&gt;An error occurred scanning the settings file contents' expandMacrosWith: ex errorString).			in close.			^self].	in close.	" set up for processing tokens "	actionBlocks := (Dictionary new)				add: #version -&gt; [:ver | (ver isString and: [ver allSatisfy: [:ea| ea isDigit or: [ea = $.]]]) ifTrue: [fileVersion := VersionForPackaging fromString: ver]];				add: #options 							-&gt; [:tokenArray | options decodeFrom: tokenArray fileVersion: fileVersion];				add: #keptItems -&gt; 								[:tokenArray | 								" for compatibility with version 2 files"								keptItems decodeFrom: tokenArray fileVersion: fileVersion];				add: #keptAndDeletedItems 							-&gt; [:tokenArray | keptItems decodeFrom: tokenArray fileVersion: fileVersion];				add: #memoryParams 							-&gt; [:tokenArray | memoryParams decodeFrom: tokenArray fileVersion: fileVersion];				yourself.	" get the contents using a two pass edit procedure"	1 to: 2		do: 			[:pass | 			1 to: tokens size				by: 2				do: 					[:tokenIndex | 					| actionBlock |					actionBlock := actionBlocks at: (tokens at: tokenIndex)								ifAbsent: 									[Dialog 										warn: (#InvalidToken1sFound &lt;&lt; #RuntimePackager &gt;&gt; 'Invalid token &lt;1s&gt; found&lt;n&gt;Settings were not loaded' expandMacrosWith: (tokens at: tokenIndex)).									^self].					pass == 2 						ifTrue: 							[actionBlock notNil 								ifTrue: 									[[actionBlock value: (tokens at: tokenIndex + 1)] 										on: Object informationSignal										do: [:ex | Dialog warn: (#ErrorDecodingSettingsFile &lt;&lt; #RuntimePackager &gt;&gt; 'Error decoding settings file&lt;n&gt;&lt;1s&gt;' expandMacrosWith: ex errorString)]]]]].	" if unreferenced classes, methods, or globals were loaded alert the user"	self anyUnreferencedDefinitions 		ifTrue: [Dialog warn: self class warningForEarlierScanMessage].	" remember the file loaded "	paramFilename := filename</body><body package="RuntimePackager">nextStepPushed	"Act on the next step button"	self moveToStep: currentStepNumber + 1.</body><body package="RuntimePackager">previousStepPushed	"Act on the previous step button"	self moveToStep: currentStepNumber - 1.</body><body package="RuntimePackager">takeDefaultsPushed	"Act on the take defaults button. Just in case, enable interactivity"	| sel |	interactWithUser := true.	sel := (self class selectorsForStep: currentStepNumber) last.	sel notNil ifTrue: [ self perform: sel ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>interface opening</category><body package="RuntimePackager">open	"Open if needed.  Otherwise just bring to the front"	( self builder isNil or: [  self builder window isOpen not ] )		ifTrue: [ super open]		ifFalse: [  self builder window raise expand ]</body><body package="RuntimePackager">postBuildWith: aBuilder	"Set up to use special controller needed for doing the final strip step"	" Hook in special controller that will kick off stripping at the end"	aBuilder window controller: RuntimeStartupController new.	" Make status boxes non-changable"	#( #cleanupDone #optionsDone #itemsDone #scanDone		#reviewDone saveParcelsDone #testDone #memoryDone ) do: [ :id |		( aBuilder componentAt: id ) widget controller: NoController new. ].</body><body package="RuntimePackager">postOpenWith: aBuilder	"Initialize the window."	ActiveApplication := self.	self moveToStep: 1.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>menu actions</category><body package="RuntimePackager">helpContents	"Pick a topic for help and open the window"	| helpSelection helpContents |	helpContents := List new.	1 to: self class stepTitles size do: [ :i |		helpContents add: ( self class titleForStep: i ) -&gt; i ].	helpSelection := Dialog choose: 'Which help topic would you like to view?'		fromList: helpContents		values: helpContents		lines: 15		cancel: [ ^self ].	( RuntimeBuilderHelp		onString: ( self class perform: ( self class helpAccessors at: helpSelection value ) )		title: helpSelection key ) open.</body><body package="RuntimePackager">loadParams	"Load parameters from a file"	| file |	self anyPendingChanges 		ifTrue: 			[(Dialog confirm: self class changesPendingMessage) ifFalse: [^self]].	" make sure file is readable "	(	[file := (Dialog 				requestFileName: #FilenameToLoadParams &lt;&lt; #RuntimePackager &gt;&gt; 'File name to load parameters from'				default: paramFilename asString				version: #mustBeOld				ifFail: [^self]) asFilename.	file isReadable] 			on: OSErrorHolder errorSignal			do: [:ex | ex return: false]) 			ifFalse: 				[Dialog warn: #TheFileSuppliedDoes &lt;&lt; #RuntimePackager &gt;&gt; 'The file supplied does not exist or could not be read'.				^self].	Cursor read showWhile: [self loadParametersFile: file]</body><body package="RuntimePackager">openLauncher	"Open the standard launcher"	| launcher |	"Hide the dependency because of Envy prereqs"	launcher := #{VisualLauncher } valueOrDo: [		Dialog warn: 'Image no longer contains VisualLauncher'.		^self ].	launcher open.</body><body package="RuntimePackager">packageRuntimeImage	"Package the runtime image in one step"	( Dialog confirm:'This function will package the runtime image in one step based on optionsalready set either through the user interface or by loading a saved parametersfile. The following actions are taken automatically:o  Scan for unreferenced items (if not skipped as an option)o  Save any pacels indicated as loadable at runtimeo  Strip and save the runtime imageExcept for error conditions and warnings, no further prompts are made.The current image is not saved prior to creating the runtime image and exiting.Are you ready to proceed with packaging the runtime image?' )		ifFalse: [ ^ self ].	interactWithUser := false.	[ options skipScan ifFalse: [		self traceMessages ifFalse: [			interactWithUser := true.			^self ] ].	self saveParcels ifFalse: [		interactWithUser := true.		^self ].	] on: Error do: [ :ex |		interactWithUser := true.		ex pass. ].	" This is basically the point of no return, but if we come	back here, the strip failed in some way."	self stripSystem.	interactWithUser := true.</body><body package="RuntimePackager">quitImage	"Quit the image after a dialog"	ObjectMemory quitDialog.</body><body package="RuntimePackager">saveImage	"Quit the image after a dialog"	ObjectMemory saveDialogThenQuit: false.</body><body package="RuntimePackager">saveParams	"Save parameters to a file"	| out file |	" See if any pending changes are outstanding"	options isBeingChanged | keptItems isBeingChanged 		| memoryParams isBeingChanged 			ifTrue: 				[(Dialog 					confirm: ('Changes are pending in already open windows.\' 							, 'Saving settings will not include those changes\' 								, 'unless you first press Ok in the respective windows.\\' 								, 'Do you want to continue anyway?') withCRs) 						ifFalse: [^self]].	(	[file := (Dialog 				requestFileName: 'File name for saving parameters'				default: paramFilename asString				version: #new				ifFail: [^self]) asFilename.	file canBeWritten] 			on: OSErrorHolder errorSignal			do: [:ex | ex return: false]) 			ifFalse: 				[Dialog warn: 'Parameter file cannot be written with name supplied'.				^self].	" show work in progress "	Cursor write showWhile: 			[" open the output file "			[out := file writeStream] on: OSErrorHolder errorSignal				do: 					[:ex | 					(Dialog 						choose: 'Output file cannot be written'						labels: #('OK' 'Debug')						values: #(#ok #debug)						default: #ok) == #ok 						ifTrue: [^self]						ifFalse: [ex reject]].			" Write each parameter class from current contents"						[out				nextPutAll: '"RuntimeBuilderUI settings ';				nextPutAll: Date today printString;				space;				nextPutAll: Time now printString;				nextPut: $";				cr;				cr;				nextPutAll: 'version ';				print: RuntimeManager vwVersion printString;				cr;				nextPutAll: 'options ( '.			options encodeOn: out tab: 1.			out				nextPutAll: ' )';				cr;				cr;				nextPutAll: 'keptAndDeletedItems ('.			keptItems encodeOn: out tab: 1.			out nextPutAll: ' )'.			out				cr;				cr;				nextPutAll: 'memoryParams ('.			memoryParams encodeOn: out tab: 1.			out nextPutAll: ' )'			" close the output file and remember its name "] 					ensure: [out close].			paramFilename := file	" end cursor showWhile "]</body><body package="RuntimePackager">stepHelp	"Open a help window on showing information about the current step"	self class helpForStep: currentStepNumber</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>functions</category><body package="RuntimePackager">chooseKeptItems	"Open the kept items window"	keptItems edit.</body><body package="RuntimePackager">cleanUpImage	"Invoke inspectors if needed to enable image to be cleaned up.	Check for extra undeclared items and non-model models"	| inspectorOpened insp |	inspectorOpened := false.	keptItems canBeReset ifTrue: [		keptItems setDefaults.		self itemsDone value:false. ].	options canBeReset ifTrue: [		options setDefaults.		self optionsDone value: false. ].	Undeclared isEmpty ifFalse: [		" see if there are still entries to be removed from Undeclared "		( Dialog confirm:				'Undeclared dictionary is not empty.  Do you want to ',				'\remove unreferenced nil entries before opening a browser?' withCRs )				ifTrue: [					" get rid of extraneous values that hang around "					Transcript cr; show: 'Cleaning up DeferredBindings'.					RuntimeManager cleanUpDeferredBindings.					" now that the junk is out of the way, purge undeclared "					Transcript cr; show: 'Purging unreferenced entries from Undeclared ...'.					Cursor wait showWhile: [						RuntimeManager purgeUndeclaredEntries asSortedCollection do: [ :k |							Transcript cr; show: 'Removed ', k displayString. ] ].						Transcript cr; show: '...done'.  ] ].	Undeclared isEmpty ifFalse: [		" open an inspector with an appropriate title "		inspectorOpened := true.		insp := DictionaryInspector inspect: Undeclared.		insp open.		insp builder window label: 'Undeclared Items'. ].	( DependentsFields keys contains: [ :obj |			( #(	#{ObjectMemory}				#{RuntimeManager}				#{ExternalDatabaseConnection}				#{Parcel}  )				contains: [ :bnd | ( bnd valueOrDo: [] ) == obj  ] ) not ] ) ifTrue: [		inspectorOpened := true.		" open an inspector with an appropriate title "		insp := DictionaryInspector inspect: DependentsFields.		insp open.		insp builder window label: 'DependentsFields'. ].	inspectorOpened ifFalse: [		Dialog warn: 'Undeclared and DependentsFields look clean' ].	self cleanupDone value: true.</body><body package="RuntimePackager">defaultKeptItems	"Set the defaults for kept items"	keptItems setDefaults; refresh.	"force changed message since items might	not have been editted yet.  This will cause	status tracking to notice the event"	keptItems changed.</body><body package="RuntimePackager">defaultMemoryParams	"Choose default memory parameters"	memoryParams setDefaults; refresh.</body><body package="RuntimePackager">defaultOptions	"Choose default options"	options setDefaults; refresh.</body><body package="RuntimePackager">saveParcels	"Save loadable parcels to files. Answer true if the step succeeds."	| parcelToSave path continue parcels resp saveAll obsoleteClasses |	" make sure there are no open editor windows "	( options isBeingChanged or: [ keptItems isBeingChanged ] ) ifTrue: [		( Dialog confirm: ( 'There are pending changes in open windows.\',				'Do you still want to proceed?' ) withCRs )			ifFalse: [ ^ false ] ].	" find the parcels to be saved "	parcels := self parcelsToBeSaved.	parcels isEmpty ifTrue: [		interactWithUser ifTrue: [			Dialog warn: 'There are no parcels to be saved.'. ].		^true ].	saveAll := interactWithUser not.	parcels do: [ :parcel |		( options stripParcel: parcel name )			ifTrue: [ parcelToSave := self trimParcel: parcel ]			ifFalse: [ parcelToSave := parcel copy ].		" set padded to true (hardly ever a bad idea and sometimes required)"		parcelToSave propertyAt: #padded put: true.		path := options pathForParcel: parcelToSave name.		Transcript cr; show: 'Saving parcel ', parcelToSave name, ' to ',			( RuntimeManager expandedStringFrom: path) , ' ...'.		continue := true.		"See if any obsolete classes were included in the parcel saved"		obsoleteClasses := parcelToSave definedAndExtendedClasses				select: [ :cl | cl isObsolete ].		obsoleteClasses isEmpty ifFalse: [			Transcript cr; show:				'Warning: The following obsolete classes are present in the parcel:'.			( obsoleteClasses asSortedCollection: [ :x :y | x name &lt; y name ] ) do: [ :cl |				Transcript crtab; show: cl name ].			( Dialog confirm:				'Obsolete classes are defined or extended in parcel ', parcelToSave name,				'\Do you want to save it anyway?' withCRs )				ifFalse: [					Transcript cr; show: 'skipped due to error'.					continue := false. ] ].		" watch out for errors writing the file "		continue ifTrue: [ OSErrorHolder errorSignal			handle: [ :ex |				( Dialog confirm:  ex errorString,					'\Error writing ' withCRs, path,					'\Do you want to continue with the next parcel?' withCRs )					ifFalse: [ ^false ]					ifTrue: [ ex return ] ]			do: [				| src file |				file := RuntimeManager expandedFilenameFrom:path.				src := file asString.				( src lastIndexOf: $. ) &gt; 0					ifTrue: [						src := ( src copyFrom: 1 to: ( src lastIndexOf: $.) - 1 ),								Parcel sourceExtension. ]					ifFalse: [ src := src, Parcel sourceExtension ].				src asFilename exists ifTrue: [					resp := Dialog choose: (							'Parcel source file exists:&lt;n&gt;&lt;1s&gt;&lt;n&gt;&lt;n&gt;Should it be deleted now?'								expandMacrosWith: src )							labels: #( 'Yes' 'No' 'Cancel' )							values: #( #yes #no #cancel )							default: #cancel.					resp == #yes ifTrue: [						src asFilename delete.						Transcript cr; show: src, ' deleted'. ].					resp == #cancel ifTrue: [						Transcript show: 'cancelled'.						^false ] ].				saveAll not &amp; file exists ifTrue: [					resp := Dialog choose: path, ' exists.  Use it anyway?'						labels: #( 'Yes' 'Yes to All' 'No' 'Cancel' )						values: #( #yes #yesAll #no #cancel )						default: #yes.					resp == #yesAll ifTrue: [ saveAll := true ].					resp == #no ifTrue: [						Transcript show: 'skipped'.						continue := false ].					resp == #cancel ifTrue: [						Transcript show: 'cancelled'.						^false ] ].				continue ifTrue: [					parcelToSave parcelOutOn: file								withSource: nil								hideOnLoad: true								republish: false								backup: true.					Transcript show: ' ... done'. ] ] ] ].	interactWithUser ifTrue: [		Dialog warn: 'Parcels have been saved.  See Transcript for results'. ].	self saveParcelsDone value: true.	^true</body><body package="RuntimePackager">setMemoryParams	"Open the memory parameters window"	memoryParams edit.</body><body package="RuntimePackager">setOptions	"Open the options window"	options edit.</body><body package="RuntimePackager">stripSystem	"Set up for stripping the image.  Make sure runState	is set correctly before entering the prepare phase and	reset it if the operation is not to proceed.  Control is	passed to RuntimeManager via RuntimeStartupController	after the window closes."	RuntimeManager runState: #development.	^ self prepareToStripSystem		ifFalse: [			RuntimeManager runState: #development.			false. ]		ifTrue: [ true ]</body><body package="RuntimePackager">testApplication	"Test the application"	tester isNil ifTrue: [		tester := RuntimeBuilderTester new.		tester mainApplication: self.		tester keptItems: keptItems.		tester options: options. ].	tester open.</body><body package="RuntimePackager">testCompleted	"The test has been completed, clear the current tester"	tester := nil.</body><body package="RuntimePackager">traceMessages	"Trace sent messages to determine which classes and selectors are not needed.	Answer true if the step suceeded."	| tracer startTime endTime resp |	( options isBeingChanged | keptItems isBeingChanged ) ifTrue: [		(Dialog confirm: (			'Changes are pending in already open windows.\',			'These changes do not take effect until OK is pressed in\',			'the respective windows.\\',			'Executing the scan for references now will ignore pending changes.\\',			'Do you want to continue anyway?' ) withCRs )			ifFalse: [ ^false ] ].	( options startupClass notNil or: [	keptItems hasBeenEdited or: [	options useAutoLoader  and: [ options hasLoadableParcels ] ] ] )		ifFalse: [			( Dialog confirm: (			'No startup class and method have specified, use AutoLoader for\',			'parcel loading was not specified or there are no loadable parcels,\',			'and no changes were made to the kept classes and methods.\\',			'This can result in the intended application being omitted from\',			'the scan of sent messages and subsequently being deleted\',			'from the runtime image.\\',			'Do you want to continue anyway?' ) withCRs ) ifFalse: [ ^ false ] ].	" note when we started "	startTime := Time now.	" do the trace "	tracer := RuntimeBuilderMessageTracer new.	[	tracer options: options; items: keptItems; traceSystem ]	on: UserInterrupt	do: [ :ex |			ex errorString = 'User Interrupt' ifFalse: [ ex reject ].			resp := Dialog choose: 'Terminate scan for referenced items?'				labels: #( 'Yes' 'No' 'Debug' )				values: #( true false nil )				default: true.			resp = true ifTrue: [				keptItems resetUnreferencedItems.				self scanDone value: false.				^false ].			resp = false ifTrue: [				tracer raiseNotifier.				ex resume ].			ex pass. ].	" note when we ended "	endTime := Time now.	" tel the user about the results "	interactWithUser ifTrue: [		stepDescription value: 		('Scan completed in ',		(endTime asSeconds - startTime asSeconds ) printString, ' seconds',		'\\Unreferenced Items:\',		'  ', keptItems unreferencedClasses size printString, ' classes\',		 '  ', keptItems unreferencedMethodsCount printString, ' methods\',		 '  ', keptItems unreferencedGlobals size printString, ' globals',		'\\Proceed to the next step to review details') withCRs. ].	self scanDone value: true.	self reviewDone value: false.	self saveParcelsDone value: false.	self testDone value: false.	^true</body><body package="RuntimePackager">viewReferencedItems	"Open the referenced items window"	keptItems view.	self reviewDone value: true.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>updating</category><body package="RuntimePackager">update: anAspect with: aParam from: anObject	"Monitor changes to keep track of status"	anObject == options ifTrue: [			self optionsDone value: true.			self scanDone value: false.			self saveParcelsDone value: false.			self testDone value: false. ].	anObject == keptItems ifTrue: [			self itemsDone value: true.			self scanDone value: false.			self reviewDone value: false.			self saveParcelsDone value: false.			self testDone value: false. ].	anObject == memoryParams ifTrue: [			self memoryDone value: true. ].	^super update: anAspect with: aParam from: anObject</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>initialize-release</category><body package="RuntimePackager">initialize	"Initialize the instance"	super initialize.	interactWithUser := true.	currentStepNumber := 0.	options := RuntimeBuilderOptions new setDefaults.	keptItems := RuntimeBuilderItems new		options: options;		setDefaults.	memoryParams := RuntimeBuilderMemoryParams new setDefaults.	paramFilename := 'params.rtp' asFilename.	options addDependent: self.	keptItems addDependent: self.	memoryParams addDependent: self.</body><body package="RuntimePackager">release	options removeDependent: self.	keptItems removeDependent: self.	memoryParams removeDependent: self.	super release</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>testing</category><body package="RuntimePackager">anyPendingChanges	^options isBeingChanged 		or: [keptItems isBeingChanged or: [memoryParams isBeingChanged]]</body><body package="RuntimePackager">anyUnreferencedDefinitions	^keptItems unreferencedClasses isEmpty not or: 			[keptItems unreferencedMethods isEmpty not 				or: [keptItems unreferencedGlobals isEmpty not]]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI</class-id> <category>accessing</category><body package="RuntimePackager">interactWithUser: aBoolean	interactWithUser := aBoolean</body><body package="RuntimePackager">keptItems	^keptItems</body><body package="RuntimePackager">options	^options</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI class</class-id> <category>accessing</category><body package="RuntimePackager">activeApplication	"Answer the currently active instance, if any"	^ActiveApplication</body><body package="RuntimePackager">activeApplication: aUI	"Set the currently active instance, if any"	ActiveApplication := aUI</body><body package="RuntimePackager">numberOfSteps	"Answer the total number of user steps presented"	^10</body><body package="RuntimePackager">selectorsForStep: anInteger	"Answer the selectosr to execute when performing	the user step specified by anInteger.  Answer at:1 is the	selector to use for executing the step, answer at: 2 is the	selector to use for setting defaults"	^self stepSelectors at: anInteger</body><body package="RuntimePackager">stepSelectors	"Answer the array of step selectors"	^ #(		(nil nil nil)		(cleanUpImage nil nil)		(setOptions nil defaultOptions )		(chooseKeptItems nil defaultKeptItems )		(traceMessages nil nil)		(viewReferencedItems nil nil)		(saveParcels hasParcelsToBeSaved nil)		(testApplication nil nil)		(setMemoryParams nil defaultMemoryParams)		(stripSystem nil nil)	)</body><body package="RuntimePackager">stepSummaries	"Answer the array of step summaries."	^ #("Step 1 - Overview"'This step provides an overview of the general process of packaging runtime images for release.  By consulting the help for this step, you can obtain an overview of the packaging process and the commonly used conventions of the user interface.'"Step 2 - Clean up image"'Objects can accumulate in a development image that are not needed for runtime execution but would occupy storage.  This step scans for global objects that commonly arise in the development process. If Parcels containing development tools such as UIPainter or Store are present, they should be unloaded before packaging the image for runtime. Runtime Packager does not perform this function for you, but the resulting image will be more compact if you do so before proceeding.'"Step 3 - Set basic options"'Options and data entry fields used in later steps are entered here.  Default values can be used but in most cases it will be necessary to at least specify a starting method for the application.  Changes to options can affect the outcome of later steps and may require that they be done again.'"Step 4 - Specify items to keep"'In this step you will specify globals, classes, and methods that will be kept or deleted in the final runtime image.  Items that are specified as contingent will be analyzed in the following step to determine if they are referenced and thus should be kept in the final runtime image.'"Step 5 - Scan for unreferenced items"'In this step the image is scanned to detect classes, methods, and globals that should be kept in the runtime image and which can be deleted.  Kept methods within kept classes are scanned for selectors representing message sends and references to classes and globals until no more references are found.'"Step 6 - Review kept items"'In this step you see the detailed results of the previous step.  If you are pursuing an aggressive strategy of removing all extraneous classes, you would want to check here to see that you have eliminated exactly what you intended.'"Step 7 - Save parcels"'In this step you save parcels that are loadable at runtime. Parcels specified as loadable in the Options step are saved under the path names provided in that step. These path names should be different from the names used for any development copies of these parcels or the development copies will be overwritten. If no parcels have been specified as loadable, the DO THIS STEP button is disabled.'"Step 8 - Test application"'This step allows you to test your application in a simulated runtime environment.  Some references can slip past the scanning process unnoticed and cause your application to die an untimely death in the runtime version.  This step provides an way to detect these references and keep the referenced items in the final image.'"Step 9 - Set Runtime Memory Parameters"'This step provides a way to set memory parameters for the runtime image.  See VisualWorks documentation for a more complete description of the parameters and how they are used in the Smalltalk image.  Current image start-up values are used as the default and in many cases these would be sufficient without further changes. This step is optional.'"Step 10 - Strip and save image"'This step is the final one.  Deleted classes and methods are removed and the final image is saved under the name provided earlier on the options window.  The stripping process is automatic once a few preliminary questions are posed.  Once it is underway, the stripping process should not be interupted. After the stripping process is completed, this image exits automatically.')</body><body package="RuntimePackager">stepTitles	"Answer the array of step titles"	^#(	'Overview'	'Clean up image'	'Set common options'	'Specify classes and methods to keep'	'Scan for unreferenced items'	'Review kept classes and methods'	'Save runtime loadable parcels'	'Test application'	'Set runtime memory parameters'	'Strip and save image'	)</body><body package="RuntimePackager">summaryOfStep: anInteger	"Answer a summary of the step."	^self stepSummaries at: anInteger</body><body package="RuntimePackager">titleForStep: anInteger	"Answer the title for a user step based on the number supplied"	^ self stepTitles at: anInteger</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI class</class-id> <category>help</category><body package="RuntimePackager">helpAccessors	"Answer the accessors for help in step number order"	^#(		#helpForOverview #helpForCleanup #helpForOptions #helpForItems		#helpForScan #helpForReview #helpForParcels #helpForTest		#helpForMemory #helpForStrip ).</body><body package="RuntimePackager">helpFor: accessor	"Open a help window on showing information about a step"	( RuntimeBuilderHelp		onString: ( self perform: accessor )		title: ( self titleForStep: ( self helpAccessors indexOf: accessor ) ) ) open</body><body package="RuntimePackager">helpForCleanup	"Display help for Image Cleanup step."^'PURPOSE OF THIS STEPObjects can accumulate in a development image that are not needed for runtime execution and would occupy storage needlessly.  This step scans for global objects that commonly arise in the development process.The scan for referenced and unreferenced items will detect unreferenced globals appearing in the Smalltalk System Dictionary.  Two other major possible sources for extraneous globals cannot be detected in the scan of referenced items:  Undeclared variables and non-Model objects that have dependents.  When this step is performed, inspectors are opened on the contents of the global variables Undeclared and DependentsFields.  If no suspicious contents are found, you will be notified and no inspectors are opened.USAGEIf entries exist in the Undeclared dictionary, you will be prompted to remove any items that are apparently unreferenced and which are also currently bound to nil.  These can entries can be left behind when classes are removed from the system, for example.  Removing these entries should  normally be harmless and will greatly simplify analyzing the Undeclared items.  However, there is no provision for restoring any entries deleted by this process and the image should first be saved if you are not sure that the entries are extraneous.The inspectors that are opened provide menu actions in the ordinary way.  Be especially careful when removing items from DependentsFields if you do not understand why they are there.  In most cases, undeclared variables represent some type of problem in the development process and each entry should be investigated to ensure that no problems are lurking in the application.  If no references to an entry can be found, the entry can be eliminated.This step can be skipped if you do not want to eliminate the types of global objects detected here.'</body><body package="RuntimePackager">helpForItems	"Display help for a step."^'PURPOSE OF THIS STEP:In this step you will specify variables, classes, and methods that will be kept or deleted in the final runtime image.  Items are divided into three major categories:o	Deleted - these are always deleted in the runtime image.o	Contingent - these are deleted if no references to them can be detected.o	Kept - these are kept in any case.Being deleted has different meanings for different types of objects.  For variables, being deleted means that its name is removed from the containing namespace, and any previous references to the variable by name become references to nil.  For classes, being deleted means that the class is replaced with a subclass of Object having no methods of its own and having the class name removed from its containing namespace. Deleting a method means removing it from the method dictionary in which it appears.When a class is kept, only the definition of the class is necessarily kept in its entirety.  Methods that are unreferenced can still be deleted from kept classes.  When a method is kept, it will remain in the runtime image only if its defining class is not otherwise deleted.Several rules are enforced in the specification of kept and deleted items.  You cannot delete a class if subclasses of it are kept.  Specifying that a class is to be deleted implicitly specifies that its subclasses are also to be deleted.USAGEThe packages tree allows selection of the package(s) and/or bundle(s) for which classes and variables are displayed. All lists, including the package/bundle tree view appearing in this window are of the multiselect variety.  In the lists, selected items are shown with check marks, while in the tree they are shown by highlighting the selected item(s).  When you select packages or bundles, all classes they define or extend are shown in the class selection boxes.  When you select classes, all methods implemented on either as instance methods or as class methods are shown in the method selection boxes.  Do not forget to unselect packages and classes when you no longer want related classes and methods to be visible.The status of classes, methods, and variables can be changed by pressing the buttons between the selection boxes.  The meaning of the buttons is mnemonic:	&gt;&gt;  means move all selected items from the left to the right.	&lt;&lt;  means move all selected items from the right to the left.After items are moved, they become the selected items in the box to which they are moved.  Hence, you can easily undo an erroneous button press by pressing the button for movement in the opposite direction.Pop-up menus are provided in each selection box.  These can be used to select all items currently appearing in the box, clear all selections, look at specific items, and scan for references.  Two types of reference scan are provided.  The standard reference scan is provided through the Browser classes and may miss some references that will be detected during the more complete scan for referenced items in the next step.  The extended reference scan is more inclusive.  It also allows you to filter out the items that are not being kept in the runtime image, which is especially useful after the scan for referenced items has been completed in the following step.Classes that are extended but not defined in a selected application or subapplication are shown in italics. Such classes can only be moved among the deleted, contingent, and kept groups only when their defining application or subapplication is selected.When a class or classes  are selected, only those methods defined in a selected application or subapplication are shown. The pop-up menu option Select Class is provided to allow easy selection of all applications and subapplications in which a class is defined or extended and thus allows the listing of all methods associated with the class.Classes that are dynamically loaded through the use of parcels should be indicated as contingent or kept in the runtime image. Since all classes loadable through parcels are deleted in the base runtime image, whether the class is kept or contingent is relevant only to the scanning for unreferenced items.A menu option is provided for resetting classes and methods to their default settings.  Only classes and methods in currently selected categories (or applications) will be affected.  This permits a more selective way to reset to default values than would achieved by pressing TAKE DEFAULTS in the main window.DEFAULTSBy default, some classes are kept.  These are kernel classes and they are almost certainly needed to make a runtime image. For a complete list, see the method defaultClassesKeptVW in class RuntimeBuilderItems.Class RuntimeManager within Runtime Packager is needed for image start-up and is by default also a kept class.  RuntimeManagerStripper is a special subclass of RuntimeManager used to complete the stripping operation and is required.  It will be elimated in the final runtime image.Global objects are  not kept by default, but the major system globals are referenced in numerous places are will be detected as referenced.Classes that are not generally used in the runtime image are deleted by default.  These classes come from the Tools name space and related Tools categories. For a complete list, see the method defaultClassesDeleteVW in class RuntimeBuilderItems.When an image starts, ObjectMemory sends update:with:from: messages to all its dependents.  By default, the classes of all dependents of ObjectMemory are kept.  If you know that a dependent is not needed in the runtime image, you can specify the class as deleted.'</body><body package="RuntimePackager">helpForMemory	"Display help for a step"^'PURPOSE OF THIS STEPThis step provides a way to set memory parameters for the runtime image.  See VisualWorks documentation for a more complete description of the parameters and how they are used in the Smalltalk image.Spaces sizes are:	Eden - initial space used for creating new objects	Survivor - space used for new objects that have graduated from eden	Large - space for objects larger than 1K	Stack - space holding the portion of the stack not converted to objects	Code Cache - cache of dynamically compiled method machine code	Old - tenured objects that have graduated from survivor spacePolicy values are:	Growth Increment - how much additional memory to allocate at a time	Retry Decrement - how much less to ask for if memory is not available	Growth Regime Limit - size at which reclaiming space is preferred to expansion	Memory Limit - maximum amount of memory allocatedUSAGEEnter the desired values and press OK.Space sizes have a minimum value of 10000 bytes and a maximum value of 1000 times the default sizes at startup.  Growth Increment must be at least twice Retry Decrement and no more than Memory Limit.NOTESSpaces sizes are derived from ObjectMemory&gt;&gt;defaultSizesAtStartup.MemoryPolicy values are taken from the following MemoryPolicy aspects:	preferredGrowthIncrement	growthRetryDecrement	growthRegimeUpperBound	memoryUpperBoundWhen memory values are stored in the parameters file, they are stored as ratios between the values specified here and the startup values of the image.  If the parameters file is loaded on a different platform than the one where it was created, the interpretation of these ratios may or may not be what was intended and the final results should be reviewed before they are used.'</body><body package="RuntimePackager">helpForOptions	"Display help for a step."^'PURPOSE OF THIS STEPOptions and data entry fields used in later steps are entered here.  For simplicity of organization, the options are grouped into pages of a notebook.  Pages are as follows:--------------------Basics PageThis page includes the essential elements that are always needed.  These are:o	Startup Class and Startup Method	When the runtime image starts, the selector specified in	Startup Method is sent as a message to the class specified	in Startup Class.  This message provides a convenient way	to open the initial window of  the application or do other	application initializations.  The initial message is included	in the scan of sent messages done later.  If you do not use	a Startup Class and Startup Method, you will need to	specify the starting point for scanning referenced classes	and methods in the next step. The fully qualified name of the	Startup Class should be provided.o	Image Path Name	When the image is finally stripped, it is saved to the file	named here.  For obvious reasons, this field is required and	the file named must be writable.  The same conventions	for appending suffixes to the file name are used here as are	normally used for image saves.--------------------Details PageThis page includes a variety of options that are commonly selected:o	Remove compiler classes	Remove classes used to provide the public access interface to	the compiler. In many cases the compiler is required, even in a	runtime image.o	Install emergency evaluator as a dialog	The emergency evaluator is invoked by pressing control-	shift-C.  If this box is checked, a dialog will appear confirming	that the user wants to exit the image.  If this box is not checked,	the control-shift-C key press is ignored.o	Build headless image	Create an image that does not access the display.	Class HeadlessImage supplied with VisualWorks 2.5 and	above must be present in the image to select this option.o	Clear parcel search path	Clear the list of directories to be searched when loading	parcels. If this is not selected, the settings value will	be preserved in the runtime image.o	Use three-step save procedure	A three-step procedure is recommended for optimal runtime	images.  See the "Memory Management" chapter in the	VisualWorks documentation for an explanation of the	procedure.  The procedure will be used if this box is	checked.  Because of the extra time required for three saves,	the default is to create a slightly less optimal image in	a single step.o	Skip default scan for unreferenced items	The menu option File -&gt; Packager Runtime Image normally	performs a scan for unreferenced items as part of the	packaging process. To instead skip doing the scan,	select this option.o	Supress splash screen and herald sound	While loading the image, the virtual machine normally displays	a splash screen and plays a herald sound. This can be suppressed	by setting a flag in the image before saving it. This flag will automatically	be set for a headless image, but is optional for a GUI runtime image.o	Action on last window close	This option selects what is to be done when the last window	in the runtime image is closed.  The choices are:	Shutdown image - shutdown the image using normal quit procedures	Continue - continue processing without any windows open	Standard Behavior - allow base image behavior to determine the action	If Shutdown image is selected and there are no windows open when	the application startup procedure completes, then the image will be	shutdown at that time.--------------------Platforms PageThis page allows you to select UILooks and Operating Systems to be supported in the runtime image.  By default only the current platform and look are supported and any others required must be selected.  These selections are used to set defaults for classes to be deleted from the system.--------------------Exceptions PageThis page is used to specify information needed to handle exceptions in the runtime image:o	Error Notifier Class	The default class, RuntimeEmergencyNotifier, notifies the user	and creates a diagnostic dump when an unhandled exception	is detected.  If you want to enhance the standard behavior,	you can subclass RuntimeEmergencyNotifier and specify	your class here.  Other error handler classes provided with	Runtime Packager are RuntimeDebugNotifier and	RuntimeQuietEmergencyNotifier. The fully qualified name of	the error notifier class must be provided.o	Image Dumper Class	The default class, RuntimeImageDumper, is used by	RuntimeEmergencyNotifier to create the diagnostic	dump when an unhandled exception occurs.  If you want	to replace this with your own class, your class must	understand the class method #dumpSystemImage:context:on:.	If your emergency error handler does not use the dumper class,	the dumper class may be omitted here. The fully qualified name	of the image dumper class must be provided if any is entered.o	Error Log Path Name	The diagnostic dump created on unhandled exceptions is	written to the file named here.  This file should be writable by	the runtime user for a dump to be created.  Exceptions occurring	during the final stages of the image stripping process are	also reported as dumps to this file.  If you do not want dumps	to be created, leave this field blank.--------------------Parcels PageThis page allows you to provide information about Parcels that will be loaded into the runtime image.  Each parcel defined in the current image is listed.  The following information can be provided for each parcel by selecting it from the list:o	Loaded into image at runtime	Select this option for each parcel or application that is loaded into the	image during runtime execution.  Before other Parcel options can be	entered this one must be selected.o	Unload before saving runtime image	Select this option to cause the parcel or application to be unloaded in the	normal way before stripping and saving the runtime image. If this option is	not selected, all classes and methods defined in the parcel or application	are deleted before saving the runtime image, but preUnload and removing	actions are not performed.o	Save options	The "Save Loadable Parcels" step to follow allows you to save parcels that	are loaded into the runtime image. This option controls how the selected	 parcel is to be handled in that step. The choices are:	-	Strip unreferenced items and save		Saves only those classes and methods that are determined to be		referenced. The contents of the parcel in the image are not changed,		but the version of the parcel saved omits unreferenced items.	-	Save full parcel		The full contents of the parcel, including unreferenced items are		saved based on the current definition of the parcel in the image.	-	Do not save parcel		The parcel is not saved. You should ensure that the parcel is saved		by using the Parcel Browser before the Test step is done and before		using the runtime image.o	Path name for saving parcel	After the scan for referenced items is completed, loadable	parcels are stored.  Each parcel is stored in the corresponding	file specified with this option.  The path is required for the parcels	that are to be saved. No source file is generated for runtime parcels	and the name specified here should not have a corresponding .pst	file resident in the same directory.Buttons available on this page are as follows:NEW PARCEL - creates a new empty parcel and adds it to the list.UNLOAD - unloads the currently selected parcel. This removes classes and extension methods defined in the parcel from the current image.--------------------Stripping PageThis page allows specification of options that control the final stripping step.  These options are:o	Remove system organization	Remove the system organization and categories from	the System Dictionary and from all classes.  This option	will reduce the size of the runtime image but may	conflict with any services that require categories	to be present or application logic that depends on	naming conventions for categories..o	Package external interfaces	Prior to creating the stripped image, replace CMacroDefinition	instances with their values.o	Merge method and block byte codes	The byte codes that control the operation of the Smalltalk Virtual Machine	are merged so that unique values are stored in a single instance of	ByteArray rather than being duplicated.o	Use compact compiled methods	CompiledMethod objects contain pointers to source code and other objects	not used in the runtime image.  This will option will cause a replacement	class to be used eliminating the extra storage needed for the pointers. Note	that historically this was most useful when using ENVY/Developer. For normal      methods, the savings are minimal.o	Merge literals	Multiple instances of compiler generated literals with the same value are	merged into single instances.  This option should be used very carefully	since it can cause some application bugs to be manifest in ways that	could be very difficult to debug.o	Merge methods	Multiple instances of methods that are equal except for the class in which	they appear are merged into a common instance.	Normally this operation is safe, but since the identity of merged methods	cannot be determined in all cases, there are possible exposures,	especially in some exception handling logic.o	Remove unreferenced globals	Unreferenced globals are set to nil and removed from their name spaces	during the final stripping step if this option is selected.o	Trace Level	During the final stripping step additional information can be logged in the	progress notifier window so that hangs or crashes can be isolated.	For the Medium setting, classes and globals being removed are shown.	For the High setting, individual methods are shown as they are stripped	from the image.o	Prestrip Class	Prestrip Class names a class to which a message will be	sent before the actual stripping processing commences.	This message can be used to invoke user logic for customizing	some aspects of the stripping process, for example, by becoming	a dependent of RuntimeManager and monitoring changed:	messages used to inform of progress through the different	steps in the stripping process. The fully qualified name of the	prestrip class must be supplied.o	Prestrip Method	Prestrip Method names the method to which the pre-strip	message is to be sent.  This method must be one the	prestrip class can respond to.  If no message is to be sent,	Prestrip Method and Prestrip Class should be blank.USAGEOptions are selected as check boxes.  Entry fields can be supplied in any order.  Options are not acted on until the OK button is pressed except for Parcel Post Load class and method specifications.  When the OK button is pressed, you may be informed of errors or inconsistencies in the entered fields.  If you press the CANCEL button,  changes you have made are discarded and the window is closed.Buttons labeled "?" can be used to select items through pop-up menus.DEFAULTSDefault values are as shown below:	Basics Page		Startup Class:  none (blank)		Startup Method:  none (blank)		Image Path Name:  runtime	Details Page		Remove compiler classes:  false		Install emergency evaluator dialog: false		Use AutoLoader: true		Build headless image: false		Use three-step save procedure: false		Action on last window close: Shutdown image.	Platforms Page		UI Looks: All		Operating Systems: All	Exceptions Page		Error Notifier Class:  RuntimeEmergencyNotifier		Image Dumper Class:  RuntimeImageDumper		Error Log Path Name:  error.log	Parcels Page		Loaded into image at runtime: false		Save options: strip and save the parcel		Path name for saving parcel: &lt;parcel name&gt;.pcl	Stripping Page		Remove system organization: true		Package external interfaces: true		Merge method and block byte codes: true		Use compact compiled method: false		Merge literals: false		Merge methods: false		Remove unreferenced globals: true		Trace Level: none		Prestrip Class: none		Prestrip Method: none'</body><body package="RuntimePackager">helpForOverview	"Display general overview help."^'PURPOSE OF THIS STEPThis step provides an overview of the general process of packaging runtime images for release.  It includes general usage information and an overview of the overall process.  There are no actions to perform in this step.USAGEIn packaging a runtime image, you will proceed through a series of steps to convert your development image into its stand-alone runtime form.  A description of the step will appear much as this one does, showing you the purpose of the step, usage information about how to use windows associated with the step, and other necessary information.At each step, you may make choices about what function is to be performed.  The following buttons control these actions:o	DO THIS STEP performs the function of the step,o	TAKE DEFAULTS elects to take system provided default actions,o	&lt;&lt; PREVIOUS returns you to the previous step in the sequence, ando	NEXT &gt;&gt; advances you to the next step in the sequence.Some steps are optional.  The description of the step will clearly state this fact when it applies.  In that case, you may progress directly to the next step without pressing either DO THIS STEP or TAKE DEFAULTS.In some cases, one or more buttons might not apply to a step, and buttons will be disabled when applicable.  For example, the DO THIS STEP button is disabled for this step because there is no associated action.The following menu items are provided in this window for performing common functions:File menu	Load parameters - read values for parameters (see below) from a file.	Save parameters - write values for parameters (see below) to a file.	Open launcher - open the system launcher.	Save image - save the image in its current state.	Quit image - use the normal quit dialog to allow you to exit the image.	Package Runtime Image - prepare the runtime image in one step	Exit - exit this application (but does not exit the image as a whole).	The parameters file is used to store the specifications the programmer	has made when using Runtime Packager.  It contains of the following	specifications:	o	Common Options	o	Kept and deleted classes, methods, and globals	o	Memory parametersActions menu	Menu items correspond with the actions taken	at each step.  You can use these items to perform	the step directly without going forward or backward	to reach the desired step.Help menu	Contents - shows a list of help topics to select from	Help for current step - shows help window for current step	About Runtime Packager - shows current version	About Patches - shows Runtime Packager patchesOVERVIEW OF STEPSThe following steps are presented in sequence through this user interface.  In general, these steps should be performed in this sequence.  If information supplied in a previous step is changed, you may need to perform later steps over again.  For the most common cases, you will be notified when a step must be done over.  The sequence of steps follows:1.  	Overview - information only;  no action is performed for this step.2.  	Clean up image - check the image for extraneous global objects.3.  	Set common options - specify parameters used in later steps.4.  	Specify runtime classes and methods to keep - customize the items	to be kept for runtime.5.  	Scan for unreferenced items - scan the image for unreferenced	classes, methods, and globals.6.  	Review kept classes, methods, and globals - review the results	of the previous scan.7.	Save runtime loadable parcels - save any parcels needed for	the runtime image.8.  	Test application - interactively detect missed references to	application classes and methods.9.	Set runtime memory parameters - set sizes for different spaces	on startup and set memory policy values.10.  Strip and save image - create a stripped image for stand-alone	application execution.You can save the image at any time to preserve the progress you have made, but saving while you are testing your application is not recommended.  You might find it useful to save the current parameters (see menus above) after steps 3, 4, 8, and 9.  This will permit you to return quickly to the current status even if you start from a clean image.MEANING OF OK AND CANCEL BUTTONSSeveral windows have OK and CANCEL buttons.  They operate the same in each case.  The OK button saves all current changes and closes the window.  If errors or inconsistencies are detected, you will be informed and have an opportunity to correct them before the window is closed.  The CANCEL button closes the window without saving changes.  Changes are not applied unless the OK button was pressed.REOPENING ALREADY OPEN WINDOWSIf you return to a previous step for which a window is already open, doing the action of that step will cause the previous window to be raised to the foreground.  If you had made changes to that window but not yet pressed OK, you will see the window with the changes in place.  If the previous window was minimized, it will automatically be expanded.  You are not required to close the windows that go with each step as you proceed through the sequence of steps, but leaving all windows open can be confusing and a source of errors in the final image.Only one instance of this main window is permitted at a time.  If you attempt to open a new instance, the currently active instance will be brought to the foreground.PRINT HELP PAGESHelp pages such as this one can be printed by pressing the PRINT button. Be sure to correctly specify the image settings for printing documents. If you find that PostScript is being printed rather than text, use the Setting option in the VisualWorks Launcher window to change the Printing settings for Document Printing from PostScript Printing to Document Printing.'</body><body package="RuntimePackager">helpForParcels	"Answer help text for the step."^'PURPOSE OF THIS STEPParcels identified as loadable in the runtime image are saved to files in this step.  The identification of which parcels are loadable and the file names under which they will be saved occurred in the Common Options step earlier.  Changing which parcels are loadable would affect the outcome of the previous scan step.Parcels are saved in their entirety except for those where the "Strip unreferenced items and save" option was selected.  For these parcels, only classes and methods found to be referenced in the previous scan step will be saved.  The contents of the parcel in the current image are not changed.Parcels are saved without source. Care should be taken that a version of the parcel file (*.pcl) is not overwritten when a corresponding parcel sources file (*.pst) is present. If the overwrite occurs, the source file will be usable and the source for the parcel may be lost.USAGEPress DO THIS STEP.  The names of parcels saved are written to the Transcript as the saves proceed.RESTRICTIONSParcels being saved must be defined in the image and all classes and methods must be in the image as they are to be saved.'</body><body package="RuntimePackager">helpForReview	"Display help for a step."^'PURPOSE OF THIS STEPIn this step you see the detailed results of the previous step.  The first time through, this might not be especially meaningful, but you probably want to make sure that your application was not somehow bypassed in the scan and thus declared deleted.  If you are pursuing an aggressive strategy of removing all extraneous classes, you would want to check here to see that you have eliminated exactly what you intended.In this step you can also create a report file showing classes, methods, and variables deleted as well as those kept.   Before creating the final stripped version of an application, you may want to create this report and save it for later support of the deployed application.USAGEThe usage here is roughly the same as the usage for specifying the kept and deleted items earlier.  You are presented with selection boxes that can be used to view packages/bundles, classes, and methods.  In this step, there is no contingent category.  Everything being deleted is shown as such.  Classes loaded through Parcels at runtime are not included in the runtime image and are shown as deleted or kept depending on the selection for the Show Parcels As option.You can select classes to see which of their methods are being deleted.  If you select a deleted class, its methods will be shown as deleted.  You can use pop-up menus to browse or scan references to the methods shown.  The extended references browser is especially useful in determining why a class or method is kept or deleted based on the results of the scan for referenced items.There are no decisions to make in this step.  If you find that something needs to be changed, you must return to an earlier step to make the change.  In all likelihood you will want to rerun the scan for referenced items after your change.RuntimeManagerStripper is shown as kept when, in fact, it will be eliminated in the final runtime image. This class is a special case due to the need to discard the stripper methods after the final image has been created, but not before.  Similarly, copyright methods are preserved in the final image but may appear as deleted here.  These are also treated as special cases to preserve copyright markings.Press the CLOSE button to close this window.  If you want to write a report file, press the REPORT button.  You will be prompted for the name of the file to which the report should be written.  After the report is written, a file browser is opened on the report file created.'</body><body package="RuntimePackager">helpForScan	"Display help for a step."^'PURPOSE OF THIS STEPIn this step the image is scanned to detect classes, methods, and variables that should be kept in the runtime image.  Conceptually, the scan is a straightforward process.  Kept methods within kept classes are scanned for selectors representing message sends and references to classes and globals.  As new methods, classes, and variables are detected, they are added to the list of kept items and, in turn, scanned for references to other items.  Eventually the processes reaches the point at which no new references can be detected and the scan ends.The initial kept classes and methods are those indicated as such in the previous step plus the application startup class and method as well as the error notifier class.Deleted classes are bypassed in the scan for referenced items, as are deleted globals and methods.The following special class methods are used to allow classes to specify additional items to be kept:o	dynamicallyReferencedClasses	Answer a collection of classes or qualified class names that are	to be kept in the runtime image.o	dynamicallyReferencedSelectors	Answer a collection of symbols naming methods that are	to be kept in the runtime image.o	dynamicallyReferencedGlobals	Answer a collection of symbols or vairable bindings naming globals that are	to be kept in the runtime image.o	itemsReferencedBySelector: aSymbol	Answer the collection of literals including symbols, variable bindings, and	classes referenced in the instance method named by aSymbol.  In the scan,	these literals replace entirely those found in the method itself.o	itemsReferencedByClassSelector: aSymbol	Answer the collection of literals including symbols, variable bindings, and	classes referenced in the class method named by aSymbol.  In the scan,	these literals replace entirely those found in the method itself.When these selectors are implemented as class methods, the answers provided by them are used during the scan to include classes, methods, and globals to be considered referenced and thus kept in the runtime image.  If an improper answer is returned by these selectors, a dialog is used to alert you to the error.USAGEAll you need to do is press the DO THIS STEP button.  A window will open to show you progress reports.Scanning a large image might take some time. For large images, a fast machine with adequate memory will make this and other steps proceed much more smoothly.When the scan is complete, you will be presented with a dialog box summarizing the results of the scan.  You can see more detailed information by proceeding to the next step.If you choose to bypass this step, only classes, methods,  and variables that you have explicitly indicated as deleted will be removed from the runtime image.'</body><body package="RuntimePackager">helpForStep: anInteger	"Open a help window on showing information about a step"	| accessor |	accessor := self helpAccessors at: anInteger.	( RuntimeBuilderHelp		onString: ( self perform: accessor )		title: ( self titleForStep: anInteger ) ) open</body><body package="RuntimePackager">helpForStrip	"Display help for a step."^'PURPOSE OF THIS STEPThis step is the final one.  Deleted classes and methods are removed and the final image is saved under the name provided earlier on the options window.  The final image is created with the following steps:1.	The image is checked for instances of Browser and its	subclasses.  Associated windows will be closed	automatically if you press YES in the dialog box.2.	Visual Launchers are closed if you so authorize by pressing	YES in the dialog box.  You probably do not want the	standard launcher in your runtime image, but you might	want to use instances of the launcher in your application.	If so, you should close the launchers manually and just say	NO here instead of closing all launchers automatically.3.	You will be given one last chance to change your mind.4.	Subclasses of ExternalInterface are packaged for the runtime	environment if the Package External Interfaces option was selected. 	C macros are fully expanded to prevent the need to do so at runtime	and to remove the dependency on CMacroDefinition.5.	Your emergency notifier is installed.  If you are using	RuntimeEmergencyNotifier, any errors after this	point will cause a dump file to be written.  If the	debuggers are stripped out this could be the only way	to debug a problem in this step.6.	Sources are discarded.  That is, the image will no longer	look for sources or create changes entries.7.	A new emergency evaluator is installed.  The evaluator is	invoked when you press Ctrl-Shift-Y. The replacement	evaluator is a dialog confirming that you want to quit now.8.	A series of mundane clean-ups are done. One of these is clearing	the transcript.  The transcript is written to the dump file on errors,	and you might want to place application error messages there	even if the transcript is not shown to the user. The definitions of	any parcels indicated as loadable at runtime are discarded at this	time to prevent conflicts when the parcel is loaded at runtime.9.	The default pop-up menu for text fields that could contain code is	replaced with the menu for straight text. A few	other menus that reference the compiler are not altered.	If you select DOIT from these menus, the request is ignored.10.	System and method categories are discarded if the remove system	organization and categories option was selected.11.	Methods, classes, and variables are deleted from the image.	Copyright notices in the method named copyright are always retained.12.	If selected, literals are merged based on value.13.	If selected, multiple instances of the same byte code string are consolidated	into a single instance referenced from multiple methods.14.	If selected, multiple instances of the same method are merged into a single	instance. Because only one instance of the method is present in the image,	functions that request the identity of the method will get only one of possibly	multiple classes and selectors that use the method.15.	If the compact compiled methods option was selected	the method dictionaries are rebuilt with instances of CompiledMethod	replaced by RuntimeCompiledMethod instances.16.	The symbol table is rehashed to reclaim space from unreferenced	symbols.17.	You are informed that the image is about to be saved.	This window and the one appearing later do not have controllers.	You will be given 5 seconds to read the contents and then	the window is closed automatically.18.	The garbage collector runs to remove all the deleted objects	from the image.  A perm save is then done.19.	Another window appears letting you know that the save	was done successfully.20.	The image quits automatically.If you are using the "three step procedure" for saving the image, the image is left in a state in which another save is done upon image start-up for the next two times the image is launched.  A garbage collection is done before the first of these saves.You are now the proud owner of a stripped runtime image.  Place it to good use and may your dump files remain empty.USAGEPress the DO THIS STEP button.  The rest of the process is automated once you get past the warning dialogs unless you have selected the "Save runtime image using three step procedure" option.  If you are using the three step procedure, a runtime image is first created and saved automatically.  You must then launch that runtime image two more times to create the final runtime image.  On each launch, a new runtime images is saved and you are notified of your progress.  After the final save, the runtime image is left in a state in which the application will be started on the next launch.'</body><body package="RuntimePackager">helpForTest	"Display help for a step"^'PURPOSE OF THIS STEPIt would be nice to say that the process of scanning references was foolproof and that you could rest assured that all the classes and methods, and only the classes and methods, needed to run your application will remain in the runtime image.  This, however, is not the case.  A number of types of references can slip past unnoticed causing the application to die an untimely death in the runtime version.Typically the problems revolve around dynamically created names.  For example, the following code would cause an undetected reference:pickOne: aString	self perform: (#pick, aString) asSymbol.In general, there is no way to know what values aString might assume, even if you could connect them together with the naming convention that prefixes them with #pick to form a selector name.  Classes and globals can be referenced in similar dynamic fashion.Similarly, extraneous references are very common.  For example, Icon class&gt;&gt;initialize references Icon class&gt;&gt;createLauncherIcon which references class LauncherView, which, in turn, references most programming tools, none of which are probably needed in the runtime image.  The only way to eliminate these extraneous references is to delete either classes or methods explicitly.This step provides a way for you to take a broad-brush approach towards which classes and methods are needed and find out where you were wrong by running test cases.  When you reference a deleted class or method during a test, it is recorded as referenced and can be fedback to the selection of kept items.  If your test cases are sufficient, you will discover all dynamic references.  At a minimum, you should be able to discover the pattern of which things are dynamically referenced and which are not.Note that image startup and shutdown processing is not included within the scope of a test.  Deleting classes or methods used in startup or shutdown is a common source of difficulty in creating a viable runtime image.  In most cases, dumps written to the error log are the best way to debug startup or shutdown problems.USAGEIf you have extra windows open, for example a browser, you should close or minimize them before beginning an application test.  References to classes and methods from all open windows  will be considered part of the application being tested.  Having extra windows open tends to result in extraneous references and may cause you to include unneeded classes and methods in the runtime image.Buttons along the top of the window control activities during the application test.o	SAVE	In spite of all precautions to the contrary, it is possible	that the image could be corrupted during the test.  It might	be wise to save the image before beginning the test itself.	Pressing this button gives you an easy way to do this.  Once	the test starts, you probably do not want to save the image.	Changes made to the image to detect references to deleted	classes and methods could result in an image that cannot	be restarted after it is saved or result in loss of source	information.o	BEGIN TEST	This button begins the test process.  All deleted classes and	methods are altered to allow the detection of any references to	them.  When that process has been completed, the startup	message, if any, is sent and the application starts its execution	in the normal way.o	END TEST	When you have completed application testing, pressing this	button will restore the image to its status prior to the beginning	of the test.  If debugger windows are opened during the test,	you might want to press this button before debugging the	problem.o	ACCEPT DYNAMIC REFERENCES	As deleted classes and methods are referenced, they are reported	in the scrollable text area below.  If you want to accept all such	classes and methods as items to be kept in the runtime image,	press this button.o	IGNORE DYNAMIC REFERENCES	In some cases you may see references to items that are clearly	not part of your application.  For example, you may see	references to the debugger if an error occurs.  To ignore the	dynamic references appearing in the text area below, press	this button.  All dynamic references displayed will be ignored.	This button is active both during and after the test.	If pressed during the test, displayed dynamic references	revert to the status they had at the beginning of the test.	If pressed after the test, displayed dynamic references are	simply ignored.References to classes and methods that would have been deleted in the runtime image are shown in the scrollable text area as they occur.  Only the first reference to each item is shown.  Once the references are accepted or are ignored, the text area is cleared.OK and CANCEL have the conventional meaning in this window.  After the test ends, you can press OK and have all accepted dynamic references included as kept items.  You might want to go back and rerun the scan step at this time to pick up other classes and methods that are now reachable but just did not happen to get used in your test.  If you press CANCEL, no changes are made to the kept items and the window is simply closed.Classes and methods that are potentially loadable through Parcels do not get special treatment in this step. The assumption is that loadable Parcels will be loaded into the image through command processing at start up or through some equivalent process. Do not allow Parcels to be loaded during the test or you not be able to recover the source for methods contained in such parcels, as would be case if runtime parcels into any development image.'</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI class</class-id> <category>interface opening</category><body package="RuntimePackager">open	"Open the currently active instance, if any"	"RuntimeBuilderUI open"	ActiveApplication notNil		ifTrue: [ ActiveApplication open ]		ifFalse: [ super open ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI class</class-id> <category>utility</category><body package="RuntimePackager">browseClass: aClass	"Browse the class provided. This method is primarily here to allow release	dependent changes to the interface for browsing a class"	 #{SmalltalkWorkbench} value browseClass: aClass.</body><body package="RuntimePackager">changesPendingMessage	^(#ChangesPendingMessage &lt;&lt; #RuntimePackager &gt;&gt; 'Changes are pending in already open windows.&lt;n&gt;Loading a new settings file will override these changes.&lt;n&gt;&lt;n&gt;Do you want to continue anyway?') expandMacros</body><body package="RuntimePackager">warningForEarlierScanMessage	^(#WarningForEarlierScan &lt;&lt; #RuntimePackager &gt;&gt; 'Warning: results of an earlier Scan for Unreferenced Items step were&lt;n&gt;saved in the parameters file just loaded. These classes, methods, and&lt;n&gt;globals will be deleted in the final stripped image.&lt;n&gt;&lt;n&gt;You may want to perform the Scan for Unreferenced Items step again to&lt;n&gt;ensure that the set of unreferenced items is consistent with this image.&lt;n&gt;') expandMacros</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI class</class-id> <category>class initialization</category><body package="RuntimePackager">initialize	"Initialize the class"	"RuntimeBuilderUI initialize"	ActiveApplication := nil.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderHelp</class-id> <category>actions</category><body package="RuntimePackager">hardcopy	"Print the help currently being displayed"	| doc blankLines |	blankLines := '\\' withCRs asText.	doc := ( #{Document} valueOrDo: [			Dialog warn: 'Class Document is not present in the image'.			^self ] ) new.	doc doFooter: true		footerString: 'Runtime Packager Help: ', self title value asString		doPageNumbers: true.	doc startParagraph.	doc addText: 'Runtime Packager Help' withCRs asText allBold.	doc addText: blankLines.	doc addText: self title value.	doc addText: blankLines.	doc addText: self helpString value.	doc close.	Cursor wait showWhile: [		doc toPrinter. ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderHelp</class-id> <category>aspects</category><body package="RuntimePackager">helpString	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^helpString isNil		ifTrue:			[helpString := Text new asValue]		ifFalse:			[helpString]</body><body package="RuntimePackager">setHelpString: aString	"Set the value of helpString after some simple edits"	"For now just set the string"	self helpString value: aString asText.</body><body package="RuntimePackager">setTitle: aString	"Set the value of title"	self title value: aString asText allBold</body><body package="RuntimePackager">title	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^title isNil		ifTrue:			[title := Text new asValue]		ifFalse:			[title]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderHelp class</class-id> <category>instance creation</category><body package="RuntimePackager">onString: aString	"Create an instance on a string"	^self new setHelpString: aString</body><body package="RuntimePackager">onString: aString title: titleString	"Create an instance on a string"	^self new		setHelpString: aString;		setTitle: titleString</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor</class-id> <category>internals</category><body package="RuntimePackager">buildParcelList	"Build the list of parcels on startup or whenever it is changed"	| saveSelection list loadables |	self retractParcelInterests.	saveSelection := self parcelList selection.	list := List new.	loadables := Set new.	parcelOptions keysAndValuesDo: [ :key :popt |		( popt at: #loadable ifAbsent: [ false ] ) ifTrue: [			loadables add: key ] ].	Parcel parcels do: [ :parcel |		| nm key |		nm := parcel name asString.		key := ( '&lt;', nm, '&gt;' ) asText.		( loadables includes: nm ) ifTrue: [			key := key allBold ].		list add: key  -&gt; nm. ].	self parcelList list: ( list sort; yourself ).	self parcelList selection: saveSelection.	self parcelList selection isNil ifTrue: [		currentParcel := nil.		edittingBuilder notNil ifTrue: [			self disableParcelEntryFields: edittingBuilder. ].		self clearParcelEntryFields. ].	self expressParcelInterests.</body><body package="RuntimePackager">changeRequest	"Release dependencies when the window closes"	| result |	( result := super changeRequest ) ifTrue: [		self release ].	^result</body><body package="RuntimePackager">clearParcelEntryFields	"Reset the data entry fields for a parcel"	self parcelIsLoadable value: false.	self parcelUnloadBeforeStrip value: false.	self parcelSaveOption value: #doNotSaveParcel.	self parcelPath value: String new.</body><body package="RuntimePackager">copyValuesFromSubject	"Copy options values from the options object to its editor"		self removeCompiler value: subject removeCompiler.	self doThreeSaves value: subject doThreeSaves.	self skipScan value: subject skipScan.	self suppressSplashScreen value: subject suppressSplashScreen.	self clearParcelPath value: subject clearParcelPath.	self packageExternalInterfaces value: subject packageExternalInterfaces.	self removeOrganization value: subject removeOrganization.	self startupClass		value:			(subject startupClass isNil				ifTrue: ['']				ifFalse: [subject startupClass fullName asString]).	self startupMethod		value:			(subject startupMethod isNil				ifTrue: ['']				ifFalse: [subject startupMethod asString]).	self errorNotifierClass		value:			(subject errorNotifierClass isNil				ifTrue: ['']				ifFalse: [subject errorNotifierClass fullName asString]).	self imageDumperClass		value:			(subject imageDumperClass isNil				ifTrue: ['']				ifFalse: [subject imageDumperClass fullName asString]).	self errorLogPath value: subject errorLogPath.	self imagePath value: subject imagePath.	self useAutoLoader value: subject useAutoLoader.	self headlessImage value: subject headlessImage.	self mergeByteCodes value: subject mergeByteCodes.	self mergeLiterals value: subject mergeLiterals.	self mergeMethods value: subject mergeMethods.	self osUnix value: subject osUnix.	self osWindows value: subject osWindows.	self useRuntimeCompiledMethod value: subject useRuntimeCompiledMethod.	self stripGlobals value: subject stripGlobals.	self traceLevel value: subject traceLevel.	" set prestrip class and method "	self prestripClass		value:			(subject prestripClass isNil				ifTrue: ['']				ifFalse: [subject prestripClass fullName asString]).	self prestripMethod		value:			(subject prestripMethod isNil				ifTrue: ['']				ifFalse: [subject prestripMethod asString]).	" set last window action "	subject continueOnLastWin		ifTrue: [self lastWindowCloseAction value: #continue]		ifFalse:			[subject shutdownOnLastWin				ifTrue: [self lastWindowCloseAction value: #shutdown]				ifFalse: [self lastWindowCloseAction value: #standard]].	" set up parcel information "	parcelOptions := Dictionary new.	subject parcelOptions		keysAndValuesDo:			[:key :value | 			parcelOptions				at: key				put: value copy].	self buildParcelList</body><body package="RuntimePackager">copyValuesToSubject	"Copy options values back to the options object holding them"		| changedAspects |	super copyValuesToSubject.	changedAspects := Set new.	" see what was changed.  Only certain aspects are checked"	#(#removeCompiler #headlessImage #useRuntimeCompiledMethod #errorNotifierClass #imageDumperClass #startupClass #startupMethod)		do:			[:aspect | 			(self perform: aspect) value = (subject perform: aspect)				ifFalse: [changedAspects add: aspect]].	#(#osWindows #osUnix)		do:			[:aspect | 			(self perform: aspect) value = (subject perform: aspect)				ifFalse: [changedAspects add: #operatingSystems]].	subject removeCompiler: self removeCompiler value.	subject doThreeSaves: self doThreeSaves value.	subject skipScan: self skipScan value.	subject suppressSplashScreen: self suppressSplashScreen value.	subject clearParcelPath: self clearParcelPath value.	subject packageExternalInterfaces: self packageExternalInterfaces value.	subject removeOrganization: self removeOrganization value.	subject shutdownOnLastWin: self lastWindowCloseAction value == #shutdown.	subject continueOnLastWin: self lastWindowCloseAction value == #continue.	subject		startupClass:			(self startupClass value = ''				ifTrue: [nil]				ifFalse: [self classNamed: self startupClass value]).	subject		startupMethod:			(self startupClass value = ''				ifTrue: [nil]				ifFalse: [self startupMethod value asSymbol]).	subject		errorNotifierClass:			(self errorNotifierClass value = ''				ifTrue: [nil]				ifFalse: [self classNamed: self errorNotifierClass value]).	subject		imageDumperClass:			(self imageDumperClass value = ''				ifTrue: [nil]				ifFalse: [self classNamed: self imageDumperClass value]).	subject		prestripClass:			(self prestripClass value = ''				ifTrue: [nil]				ifFalse: [self classNamed: self prestripClass value]).	subject		prestripMethod:			(self prestripClass value = ''				ifTrue: [nil]				ifFalse: [self prestripMethod value asSymbol]).	subject errorLogPath: self errorLogPath value.	subject imagePath: self imagePath value.	currentParcel notNil		ifTrue:			[" force any pending values to be processed "			self parcelList selectionIndex: 0].	subject useAutoLoader: self useAutoLoader value.	subject headlessImage: self headlessImage value.	subject mergeByteCodes: self mergeByteCodes value.	subject mergeLiterals: self mergeLiterals value.	subject mergeMethods: self mergeMethods value.	subject osUnix: self osUnix value.	subject osWindows: self osWindows value.	subject useRuntimeCompiledMethod: self useRuntimeCompiledMethod value.	subject stripGlobals: self stripGlobals value.	subject traceLevel: self traceLevel value.	subject parcelOptions: parcelOptions.	subject removeNonloadableParcels.	" tell interested parties about the change "	subject changed: #values with: changedAspects</body><body package="RuntimePackager">disableParcelEntryFields: aBuilder	"Disable the data entry fields for a parcel"	| comp |	self parcelAspects		do: [ :aspect |			comp := aBuilder componentAt: aspect.			comp notNil ifTrue: [				" do not disable loadable option selection"				aspect == #parcelIsLoadable ifFalse: [ comp disable ] ] ].	self parcelList selection isNil ifTrue: [		comp := aBuilder componentAt: #parcelIsLoadable.		comp notNil ifTrue: [ comp disable ] ].</body><body package="RuntimePackager">enableParcelEntryFields: aBuilder	"Enable the data entry fields for a parcel"	| comp |	self parcelAspects		do: [ :aspect |			comp := aBuilder componentAt: aspect.			comp notNil ifTrue: [				" only enable those allow by the loadable status"				( aspect == #parcelIsLoadable ) | ( self parcelIsLoadable value )					ifTrue: [ comp enable ]					ifFalse: [ comp disable ] ] ].</body><body package="RuntimePackager">expressParcelInterests	"Add dependency relationships used for parcel processing.	Note that Parcel sends multiple update messages for one	change in some cases. "	" need to know if parcels change in Parcel class"	self parcelList selectionIndexHolder		onChangeSend: #parcelListSelectionChanged to: self.	self parcelIsLoadable onChangeSend: #parcelIsLoadableChanged to: self.	Parcel addDependent: self.</body><body package="RuntimePackager">parcelAspects	"Answer the names of the parcel entry field aspects"	^#( 		#parcelIsLoadable			#parcelUnloadBeforeStrip			#saveParcel			#stripParcel			#doNotSaveParcel			#parcelPath ).</body><body package="RuntimePackager">parcelIsLoadableChanged	"React to a change in parcelIsLoadable aspect by enabling/disabling fields.	The default value of the save option changes depending on whether the parcel	is loadable or not. Actually, the save option for a non-loadable parcel	is irrelevant, but potentially confusing to a user who may not be aware of this."	| popt |	popt := parcelOptions at: currentParcel ifAbsent: [ Dictionary new ].	edittingBuilder notNil &amp; self parcelIsLoadable value		ifTrue: [			popt isEmpty ifTrue: [				self parcelUnloadBeforeStrip value: false.				self parcelSaveOption value: #stripParcel. ].			self enableParcelEntryFields: edittingBuilder. ]		ifFalse: [			popt isEmpty ifTrue: [				self parcelUnloadBeforeStrip value: false.				self parcelSaveOption value: #doNotSaveParcel. ].			self disableParcelEntryFields: edittingBuilder. ].</body><body package="RuntimePackager">parcelListSelectionChanged	"Respond to a change in the parcel list selection"	" ignore changing back to where we are already"	self parcelList selection value = currentParcel ifTrue: [ ^self ].	currentParcel notNil ifTrue: [		" check current values and record them in the parcel "		self validateCurrentParcel ifFalse: [			self resetParcelSelection.			^self ].		self saveCurrentParcelEntry. ].	" get values from the new current selection, if any "	currentParcel := self parcelList selection value.	currentParcel isNil		ifTrue: [			edittingBuilder notNil ifTrue: [				self disableParcelEntryFields: edittingBuilder. ].			self clearParcelEntryFields. ]		ifFalse: [			self setParcelAspectValues.			edittingBuilder notNil ifTrue: [				self enableParcelEntryFields: edittingBuilder ] ].</body><body package="RuntimePackager">resetParcelSelection	"Reset the current parcel selection to the current parcel if possible"	self parcelList selection: (		self parcelList list detect: [ :x | x value = currentParcel ] ifNone: [			currentParcel := nil.			nil ] ).</body><body package="RuntimePackager">retractParcelInterests	"Add dependency relationships used for parcel processing"	" need to know if parcels change in Parcel class"	self parcelList selectionIndexHolder retractInterestsFor: self.	self parcelIsLoadable retractInterestsFor: self.	Parcel removeDependent: self.</body><body package="RuntimePackager">saveCurrentParcelEntry	"Save the current parcel entry before moving on to a new selection"	| popt loadableChanged |	" save the entered values, but only for loadable parcels "	loadableChanged := self parcelIsLoadable value ~= (		( parcelOptions at: currentParcel ifAbsent: [ Dictionary new ] )			at: #loadable ifAbsent: [ false ] ).	self parcelIsLoadable value		ifTrue: [			popt := Dictionary new.			popt at: #loadable put: true.			popt at: #saveParcel put: ( self parcelSaveOption value = #saveParcel ).			popt at: #stripParcel put: ( self parcelSaveOption value = #stripParcel ).			popt at: #path put: self parcelPath value.			popt at: #unloadBeforeStrip put: self parcelUnloadBeforeStrip value.			parcelOptions at: currentParcel put: popt. ]		ifFalse: [			parcelOptions removeKey: currentParcel ifAbsent: [ ] ].	" force a rebuild of the parcel list to change emphasis"	loadableChanged ifTrue: [		self buildParcelList ].</body><body package="RuntimePackager">setParcelAspectValues	"Set the values of parcel aspects when a new selection occurs"	| popt |	" avoid side effects of setting things"	self retractParcelInterests.	" set the loadable value"	popt := parcelOptions at: currentParcel ifAbsent: [ Dictionary new ].	self parcelIsLoadable value: ( popt at: #loadable ifAbsent: [ false ] ).	self parcelUnloadBeforeStrip value: ( popt at: #unloadBeforeStrip ifAbsent: [ false ] ).	" set the save option value"	( popt at: #stripParcel ifAbsent: [ false ] )		ifTrue: [ self parcelSaveOption value: #stripParcel ]		ifFalse: [			( popt at: #saveParcel ifAbsent: [ self parcelIsLoadable value ] )				ifTrue: [ self parcelSaveOption value: #saveParcel ]				ifFalse: [ self parcelSaveOption value:  #doNotSaveParcel. ] ].	self parcelPath value: ( popt at: #path ifAbsent: [ currentParcel, '.pcl' ] ).	self expressParcelInterests.</body><body package="RuntimePackager">setTab: specName	"Set the tab selection to the one	with the specified subcanvas spec"	| tabIndex |	tabIndex := 0.	1 to: self tabs list size do: [ :i |		( self tabs list at: i )  value = specName			ifTrue: [ tabIndex := i ] ].	self tabs selectionIndex: tabIndex.</body><body package="RuntimePackager">tabSelectionChanged	"Respond to a change in the notebook tab	by setting the new subcanvas"	| spec |	self tabs selectionIndex = 0 ifTrue: [ ^self ].	spec := self tabs selection value.	edittingBuilder := (self builder componentAt: #notebook)			widget client: self			spec:spec.	self tabs selection value = #parcelsSpec		ifTrue: [ self parcelIsLoadableChanged. ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor</class-id> <category>aspects</category><body package="RuntimePackager">clearParcelPath	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^clearParcelPath isNil		ifTrue:			[clearParcelPath := false asValue]		ifFalse:			[clearParcelPath]</body><body package="RuntimePackager">doThreeSaves	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^doThreeSaves isNil ifTrue: [doThreeSaves := false asValue] ifFalse: [doThreeSaves]</body><body package="RuntimePackager">errorLogPath	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^errorLogPath isNil ifTrue: [errorLogPath := String new asValue] ifFalse: [errorLogPath]</body><body package="RuntimePackager">errorNotifierClass	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^errorNotifierClass isNil ifTrue: [errorNotifierClass := String new asValue] ifFalse: [errorNotifierClass]</body><body package="RuntimePackager">headlessImage	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^headlessImage isNil ifTrue: [headlessImage := false asValue] ifFalse: [headlessImage]</body><body package="RuntimePackager">imageDumperClass	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^imageDumperClass isNil		ifTrue:			[imageDumperClass := String new asValue]		ifFalse:			[imageDumperClass]</body><body package="RuntimePackager">imagePath	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^imagePath isNil ifTrue: [imagePath := String new asValue] ifFalse: [imagePath]</body><body package="RuntimePackager">lastWindowCloseAction	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^lastWindowCloseAction isNil		ifTrue:			[lastWindowCloseAction := nil asValue]		ifFalse:			[lastWindowCloseAction]</body><body package="RuntimePackager">mergeByteCodes	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^mergeByteCodes isNil		ifTrue:			[mergeByteCodes := false asValue]		ifFalse:			[mergeByteCodes]</body><body package="RuntimePackager">mergeLiterals	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^mergeLiterals isNil		ifTrue:			[mergeLiterals := false asValue]		ifFalse:			[mergeLiterals]</body><body package="RuntimePackager">mergeMethods	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^mergeMethods isNil		ifTrue:			[mergeMethods := false asValue]		ifFalse:			[mergeMethods]</body><body package="RuntimePackager">osMac	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^osMac isNil ifTrue: [osMac := true asValue] ifFalse: [osMac]</body><body package="RuntimePackager">osUnix	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^osUnix isNil ifTrue: [osUnix := true asValue] ifFalse: [osUnix]</body><body package="RuntimePackager">osWindows	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^osWindows isNil ifTrue: [osWindows := true asValue] ifFalse: [osWindows]</body><body package="RuntimePackager">packageExternalInterfaces	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^packageExternalInterfaces isNil ifTrue: [packageExternalInterfaces := false asValue] ifFalse: [packageExternalInterfaces]</body><body package="RuntimePackager">parcelIsLoadable	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelIsLoadable isNil		ifTrue:			[parcelIsLoadable := false asValue]		ifFalse:			[parcelIsLoadable]</body><body package="RuntimePackager">parcelList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelList isNil		ifTrue:			[parcelList := SelectionInList new]		ifFalse:			[parcelList]</body><body package="RuntimePackager">parcelPath	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelPath isNil		ifTrue:			[parcelPath := String new asValue]		ifFalse:			[parcelPath]</body><body package="RuntimePackager">parcelSaveOption	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelSaveOption isNil		ifTrue:			[parcelSaveOption := nil asValue]		ifFalse:			[parcelSaveOption]</body><body package="RuntimePackager">parcelUnloadBeforeStrip	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^parcelUnloadBeforeStrip isNil		ifTrue:			[parcelUnloadBeforeStrip := false asValue]		ifFalse:			[parcelUnloadBeforeStrip]</body><body package="RuntimePackager">prestripClass	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^prestripClass isNil		ifTrue:			[prestripClass := String new asValue]		ifFalse:			[prestripClass]</body><body package="RuntimePackager">prestripMethod	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^prestripMethod isNil		ifTrue:			[prestripMethod := String new asValue]		ifFalse:			[prestripMethod]</body><body package="RuntimePackager">removeCompiler	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^removeCompiler isNil ifTrue: [removeCompiler := false asValue] ifFalse: [removeCompiler]</body><body package="RuntimePackager">removeOrganization	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^removeOrganization isNil ifTrue: [removeOrganization := false asValue] ifFalse: [removeOrganization]</body><body package="RuntimePackager">saveParcel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^saveParcel isNil		ifTrue:			[saveParcel := false asValue]		ifFalse:			[saveParcel]</body><body package="RuntimePackager">shutdownOnLastWin	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^shutdownOnLastWin isNil ifTrue: [shutdownOnLastWin := false asValue] ifFalse: [shutdownOnLastWin]</body><body package="RuntimePackager">skipScan	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^skipScan isNil ifTrue: [skipScan := false asValue] ifFalse: [skipScan]</body><body package="RuntimePackager">startupClass	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^startupClass isNil ifTrue: [startupClass := String new asValue] ifFalse: [startupClass]</body><body package="RuntimePackager">startupMethod	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^startupMethod isNil ifTrue: [startupMethod := String new asValue] ifFalse: [startupMethod]</body><body package="RuntimePackager">stripGlobals	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^stripGlobals isNil		ifTrue:			[stripGlobals := false asValue]		ifFalse:			[stripGlobals]</body><body package="RuntimePackager">stripParcel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^stripParcel isNil		ifTrue:			[stripParcel := false asValue]		ifFalse:			[stripParcel]</body><body package="RuntimePackager">suppressSplashScreen	^suppressSplashScreen isNil		ifTrue: [suppressSplashScreen := false asValue]		ifFalse: [suppressSplashScreen].</body><body package="RuntimePackager">tabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^tabs isNil		ifTrue:			[tabs := SelectionInList new]		ifFalse:			[tabs]</body><body package="RuntimePackager">traceLevel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^traceLevel isNil		ifTrue:			[traceLevel := nil asValue]		ifFalse:			[traceLevel]</body><body package="RuntimePackager">useAutoLoader	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^useAutoLoader isNil		ifTrue:			[useAutoLoader := false asValue]		ifFalse:			[useAutoLoader]</body><body package="RuntimePackager">useRuntimeCompiledMethod	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^useRuntimeCompiledMethod isNil ifTrue: [useRuntimeCompiledMethod := false asValue] ifFalse: [useRuntimeCompiledMethod]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor</class-id> <category>actions</category><body package="RuntimePackager">findErrorNotifierClass	"Set the error notifier class to a menu choice"	| className |	className := RuntimeBuilderClassChooser findClassName: 'Find error notifier class:'		where: [ :cl | cl  respondsTo:  #openContext:label:proceedable:  ].	className notNil ifTrue: [		self errorNotifierClass value: className asString ].</body><body package="RuntimePackager">findImageDumperClass	"Set the image dumper class to a menu choice"	| className |	className := RuntimeBuilderClassChooser findClassName: 'Find image dumper class:'		where: [ :cl | cl respondsTo: #dumpSystemImage:context:on: ].	className notNil ifTrue: [		self imageDumperClass value: className asString ].</body><body package="RuntimePackager">findPrestripClass	"Set the prestrip class to a menu choice"	| className |	className := RuntimeBuilderClassChooser findClassName: 'Find pre-strip class:'.	className notNil ifTrue: [		self prestripClass value: className asString ].</body><body package="RuntimePackager">findPrestripMethod	"Set the prestrip method to a menu choice"	| cl selector |	cl := self classNamed: self prestripClass value ifAbsent: [ nil ].	( cl isNil or: [		cl isBehavior not  ] ) ifTrue: [		Dialog warn: 'Pre-strip class is not a valid class name'.		^ self. ].	selector := RuntimeBuilderClassChooser findSelectorUnderstoodBy: cl		where: [ :sel | sel numArgs = 0 ].	selector notNil ifTrue: [		self prestripMethod value: selector asString. ].</body><body package="RuntimePackager">findStartupClass	"Set the startup class to a menu choice."	| aClass |	aClass := IncrementalSearchDialog selectClass: (#FindStartupClass &lt;&lt; #RuntimePackager &gt;&gt;'Find startup class:').	aClass notNil ifTrue: [		self startupClass value: aClass fullName ].</body><body package="RuntimePackager">findStartupMethod	"Set the startup method to a menu choice"	| cl selector |	cl := self classNamed: self startupClass value  ifAbsent: [ nil ].	( cl isNil or: [		cl isBehavior not ] ) ifTrue: [		Dialog warn: 'Startup class is not a valid class name'.		^ self. ].	selector := RuntimeBuilderClassChooser findSelectorUnderstoodBy: cl		where: [ :sel | sel numArgs = 0 ].	selector notNil ifTrue: [		self startupMethod value: selector asString. ].</body><body package="RuntimePackager">refresh	"Resync with subject.  In this case, special handling of parcels is needed	to prevent collision with a currently selected parcel"	currentParcel := nil.	self parcelList selection: nil.	^super refresh</body><body package="RuntimePackager">stepHelp	"Open a help window"	RuntimeBuilderUI helpFor: #helpForOptions.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor</class-id> <category>interface opening</category><body package="RuntimePackager">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(aBuilder componentAt: #notebook)		ifNotNil:			[:wrapper | 			wrapper widget tabBar component				visualBlock:					[:view :index | 					| item component |					item := view sequence at: index.					component := LabelAndIcon						with: item label						attributes: view textStyle.					component icon: item labelImage.					component offset: 6 @ 0.					BoundedWrapper on: component]]</body><body package="RuntimePackager">postOpenWith: aBuilder	"Initially select the first tab"	self tabs selectionIndex: 1</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor</class-id> <category>initialize-release</category><body package="RuntimePackager">initialize	"Initialize the instance"	super initialize.	currentParcel := nil.	self tabs list: self class tabsMenu menuItems.	self tabs selectionIndexHolder		onChangeSend: #tabSelectionChanged to: self.</body><body package="RuntimePackager">release	"Release any long-term dependencies when closing down"	self retractParcelInterests.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor</class-id> <category>updating</category><body package="RuntimePackager">update: anAspect with: aParam from: anObject	"watch for changes in other objects"	anAspect == #parcels ifTrue: [		self buildParcelList ].	^super update: anAspect with: aParam from: anObject</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor</class-id> <category>validations</category><body package="RuntimePackager">validate	"Validate all fields. Answer true if all validations are passed"	self validateStartupClass ifFalse: [ ^false ].	self validateStartupMethod ifFalse: [ ^false ].	self validateHeadlessImage ifFalse: [ ^false ].	self validateLastWindowCloseAction ifFalse: [ ^false ].	self validateErrorNotifierClass ifFalse: [ ^false ].	self validateImageDumperClass ifFalse: [ ^false ].	self validateErrorLogPath ifFalse: [ ^false ].	self validateImagePath ifFalse: [ ^false ].	self validateOperatingSystems ifFalse: [ ^ false ].	self validateParcels ifFalse: [ ^ false ].	self validatePrestripClass ifFalse: [ ^false ].	self validatePrestripMethod ifFalse: [ ^false ].	^true</body><body package="RuntimePackager">validateCurrentParcel	" Check the currently selected parcel entry and true if it is OK"	" ignore pacels that are not loadable "	| lfs |	self parcelIsLoadable value ifFalse: [^true].	self validateCurrentParcelAsParcel ifFalse: [^false].	" check for writability of save file "	self parcelPath value = '' 		ifTrue: 			[self parcelIsLoadable value 				&amp; (self stripParcel value | self saveParcel value) 					ifTrue: 						[self setTab: #parcelsSpec.						(edittingBuilder componentAt: #parcelPath) takeKeyboardFocus.						Dialog warn: 'Path is required save the parcel'.						^false]					ifFalse: 						[self setTab: #parcelsSpec.						(edittingBuilder componentAt: #parcelPath) takeKeyboardFocus.						(self 							warn: 'Warning: parcel cannot be saved unless a path name is provided'							about: #parcelPathMissing) ifTrue: [^false]]].	(	[lfs := RuntimeManager logicalFileSpecFrom: self parcelPath value.	lfs notNil and: [lfs asFilename canBeWritten]] 			on: OSErrorHolder errorSignal			do: [:ex | ex return: false]) 			ifFalse: 				[self setTab: #parcelsSpec.				(edittingBuilder componentAt: #parcelPath) takeKeyboardFocus.				Dialog warn: 'Parcel save path name is not writable or is invalid'.				^false].	^true</body><body package="RuntimePackager">validateCurrentParcelAsParcel	" Check the currently selected parcel entry and true if it is OK.	This check is specialized to the case where the current parcel	is really a parcel and not an application."	| extraClasses parcel |	parcel := Parcel parcelNamed: currentParcel.	" Make sure the parcel is still present "	parcel isNil ifTrue: [		self setTab: #parcelsSpec.		( edittingBuilder componentAt:#parcelIsLoadable ) takeKeyboardFocus.		Dialog warn: 'Selection is no longer defined in this image.'.		self parcelIsLoadable value: false.		^false ].	"Check for names spaces defined in the parcel that contain other classes"	extraClasses := IdentitySet new.	parcel definedNameSpaces do: [ :ns |		extraClasses addAll: ns allClasses ].	parcel definedClasses do: [ :cl | extraClasses remove: cl ifAbsent: [ ] ].	extraClasses isEmpty ifFalse: [		self setTab: #parcelsSpec.		( edittingBuilder componentAt: #parcelIsLoadable ) takeKeyboardFocus.		( self warn: (				'Warning: Parcel defines name space(s) that contain\',				'classes not in the parcel itself. Such classes will be\',				'deleted along with the name space during preparation\',				'of the final runtime image.' ) withCRs			about: 'classesInDeletedNameSpaces for ', currentParcel )			ifTrue: [ ^false ] ].	^true</body><body package="RuntimePackager">validateErrorLogPath	"Check to see of the error log path is writable.	Issue a warning if not.   Answer true a the warning	was actually issued (supressed after the first time)	or if the name is not well formed"	| lfs |	self errorLogPath value = '' ifTrue: [^true].	(	[lfs := RuntimeManager logicalFileSpecFrom: self errorLogPath value.	lfs notNil and: [lfs asFilename canBeWritten]] 			on: OSErrorHolder errorSignal			do: [:ex | ex return: false]) 			ifFalse: 				[(self 					warn: 'Warning: Error log path is not currently writable or is invalid'					about: self errorLogPath) 						ifTrue: 							[self setTab: #exceptionsSpec.							(edittingBuilder componentAt: #errorLogPath) takeKeyboardFocus.							^false]].	^true</body><body package="RuntimePackager">validateErrorNotifierClass	"Check that a valid class has been specified"	| cl requiredSelector |	self errorNotifierClass value = ''	  ifFalse: [		( cl := ( self classNamed: self errorNotifierClass value				ifAbsent: [ nil ] ) ) isBehavior			ifFalse: [				self setTab: #exceptionsSpec.				( edittingBuilder componentAt: #errorNotifierClass ) takeKeyboardFocus.				Dialog warn: 'Error notifier class should be a valid class name'.				^false]			ifTrue: [				( cl respondsTo: (					requiredSelector := #openContext:label:proceedable:  ) ) ifFalse: [					self setTab: #exceptionsSpec.					( edittingBuilder componentAt: #errorNotifierClass ) takeKeyboardFocus.					Dialog warn: 'Error notifier class must respond to ', requiredSelector.					^false] ] ]	  ifTrue: [		( self warn: 'Warning:  you must supply your own handler for unhandled exceptions.',				'\This handler must be in place before the final strip and save step.' withCRs				about: self errorNotifierClass ) ifTrue: [			self setTab: #exceptionsSpec.			( edittingBuilder componentAt: #errorNotifierClass ) takeKeyboardFocus.			 ^ false ] ].	^true</body><body package="RuntimePackager">validateHeadlessImage	"Validate the Headless Image feature"	self headlessImage value ifFalse: [ ^true ].	#{HeadlessImage} isDefined		ifFalse: [			self setTab: #detailsSpec.			( edittingBuilder componentAt: #headlessImage ) takeKeyboardFocus.			Dialog warn: 'Class HeadlessImage must be present in the image'.			^false].	^true</body><body package="RuntimePackager">validateImageDumperClass	"Check that a valid class has been specified"	| cl |	self imageDumperClass value = ''	  ifFalse: [		( cl := ( self classNamed: self imageDumperClass value				ifAbsent: [ nil ] ) ) isBehavior			ifFalse: [				self setTab: #exceptionsSpec.				( edittingBuilder componentAt: #imageDumperClass ) takeKeyboardFocus.				Dialog warn: 'Image dumper class should be a valid class name'.				^false]			ifTrue: [				( cl respondsTo: #dumpSystemImage:context:on: ) ifFalse: [					self setTab: #exceptionsSpec.					( edittingBuilder componentAt: #imageDumperClass )						takeKeyboardFocus.					Dialog warn: ('Image dumper class must respond to the\',						'#dumpSystemImage:context:on: selector' ) withCRs.					^false] ] ].	^true</body><body package="RuntimePackager">validateImagePath	"Check to see of the image path is writable."	| lfs imageName |	self imagePath value = '' 		ifTrue: 			[self setTab: #basicsSpec.			(edittingBuilder componentAt: #imagePath) takeKeyboardFocus.			Dialog warn: 'Image path name is required'.			^false].	(	[imageName := self imagePath value, '.im'.	lfs := RuntimeManager logicalFileSpecFrom: imageName.	lfs notNil and: [lfs asFilename canBeWritten]] 			on: OSErrorHolder errorSignal			do: [:ex | ex return: false]) 			ifFalse: 				[self setTab: #basicsSpec.				(edittingBuilder componentAt: #imagePath) takeKeyboardFocus.				Dialog warn: 'Image path name is not writable or is invalid'.				^false].	^true</body><body package="RuntimePackager">validateLastWindowCloseAction	"Check that the last window close action is compatible with other parameters"	( self lastWindowCloseAction value = #shutdown and: [	self headlessImage value = true and: [	self startupClass value = '' ] ] ) ifTrue: [		( self warn:'Warning: there is no startup method specified.Specifying shutdown as the last window actionin a headless image will cause the image to shutdown immediately after image startup processingis completed.'			about: self lastWindowCloseAction ) ifTrue: [			self setTab: #detailsSpec.			(edittingBuilder componentAt: #shutdown ) takeKeyboardFocus.			^false ] ].	^true</body><body package="RuntimePackager">validateOperatingSystems	"Make sure the current operating system is selected"		| os table aspect |	os := ExternalInterface currentPlatform first.	table := #(#(#win32 #osWindows)  #(#unix #osUnix)).	aspect := (table select: [:x | x first == os]) first last.	(self perform: aspect) value		ifFalse:			[self setTab: #platformsSpec.			(edittingBuilder componentAt: aspect) takeKeyboardFocus.			Dialog warn:					'The operating system currently in use must be among those selected.'.			^false].	^true</body><body package="RuntimePackager">validateParcels	"Parcels are handled differently than other fields since their changes	are applied immediately to parcel objects rather than being saved up	for application when the OK button is pressed.  The validation occurs	when the list selection changes."	currentParcel notNil ifTrue: [		" check that the current selection is valid "		self validateCurrentParcel ifFalse: [			self resetParcelSelection.			^false ] ].	^ true</body><body package="RuntimePackager">validatePrestripClass	"Check that a valid class has been specified"	( self prestripClass value = '' or: [		( self classNamed: self prestripClass value ifAbsent: [ nil ] ) isBehavior ] )		ifFalse: [			self setTab: #strippingSpec.			( edittingBuilder componentAt: #prestripClass ) takeKeyboardFocus.			Dialog warn: 'Pre-strip Class should be either omitted or be a valid class name'.			^false]		ifTrue: [ ^true ]</body><body package="RuntimePackager">validatePrestripMethod	"Check that a valid method has been specified"	| cl sel |	" make sure both or neither prestrip class and  method are defined"	( self prestripMethod value = '' )		ifFalse: [ self prestripClass value = ''			ifTrue: [				self setTab: #strippingSpec.				( edittingBuilder componentAt: #prestripClass ) takeKeyboardFocus.				Dialog warn: 'Pre-strip class must be defined for pre-strip method to be used'.				^false ] ]		ifTrue: [ self prestripClass value = ''			ifTrue: [ ^true ]			ifFalse: [				self setTab: #strippingSpec.				( edittingBuilder componentAt: #prestripMethod ) takeKeyboardFocus.				Dialog warn: 'Pre-strip method must be defined for pre-strip class to be used'.				^false ] ].	" make sure method  takes no args "	sel := self prestripMethod value asSymbol.	( sel = #'' or: [ sel numArgs = 0 ] ) ifFalse: [		self setTab: #strippingSpec.		( edittingBuilder componentAt: #prestripMethod ) takeKeyboardFocus.		Dialog warn: 'Pre-strip method must not require arguments'.		^false ].	" make sure method really is a class method of prestrip class"	cl := self classNamed: self prestripClass value  ifAbsent: [ ^true ].	( cl isBehavior and: [	cl respondsTo:  sel ] )		ifFalse: [			self setTab: #strippingSpec.			( edittingBuilder componentAt: #prestripMethod ) takeKeyboardFocus.			Dialog warn: 'Pre-strip method is not understood by the pre-strip class'.			^false].	^true</body><body package="RuntimePackager">validateStartupClass	"Check that a valid class has been specified"	( self startupClass value = '' or: [		( self classNamed: self startupClass value ifAbsent: [ nil ] ) isBehavior ] )		ifFalse: [			self setTab: #basicsSpec.			( edittingBuilder componentAt: #startupClass ) takeKeyboardFocus.			Dialog warn: 'Startup Class should be either omitted or be a valid class name'.			^false]		ifTrue: [ ^true ]</body><body package="RuntimePackager">validateStartupMethod	"Check that a valid method has been specified"	| cl sel |	" make sure both or neither startup class and startup method are defined"	( self startupMethod value = '' )		ifFalse: [ self startupClass value = ''			ifTrue: [				self setTab: #basicsSpec.				( edittingBuilder componentAt: #startupClass ) takeKeyboardFocus.				Dialog warn: 'Startup class must be defined for startup method to be used'.				^false ] ]		ifTrue: [ self startupClass value = ''			ifTrue: [ ^true ]			ifFalse: [				self setTab: #basicsSpec.				( edittingBuilder componentAt: #startupMethod ) takeKeyboardFocus.				Dialog warn: 'Startup method must be defined for startup class to be used'.				^false ] ].	" make sure statup method  takes no args "	sel := self startupMethod value asSymbol.	( sel = #'' or: [ sel numArgs = 0 ] ) ifFalse: [		self setTab: #basicsSpec.		( edittingBuilder componentAt: #startupMethod ) takeKeyboardFocus.		Dialog warn: 'Startup method must not require arguments'.		^false ].	" make sure startup method really is a class method of startup class"	cl := self classNamed: self startupClass value asSymbol ifAbsent: [ ^true ].	( cl isBehavior and: [	cl respondsTo:  sel ] )		ifFalse: [			self setTab: #basicsSpec.			( edittingBuilder componentAt: #startupMethod ) takeKeyboardFocus.			(Object canUnderstand: sel) ifFalse:  [				Behavior withAllSubclasses					detect: [ :cls | cls canUnderstand: sel ]						ifNone: [							Dialog warn: ('Startup method is not implemented \',								'as a class method in any class') withCRs.							^false. ] ].			Dialog warn: 'Startup method is not understood by the startup class'.			^false].	^true</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester</class-id> <category>actions</category><body package="RuntimePackager">accept	"Alter keptItems unreferenced and deleted classes and methods to reflect	dynamic items"	| answer |	testInProgress ifTrue: [ ^self ].	" is there are dynamic references see what is to be done "	dynamicClasses size + dynamicMethods size == 0 ifFalse: [		 answer := Dialog choose: ( (				'Do you want to accept the most recent dynamic \',				'references before closing this window?' ) withCRs )				labels: #( 'Yes' 'No' 'Cancel' )				values: #( #yes #no #cancel )				default: #yes.		answer = #cancel ifTrue: [ ^self ].		answer = #yes			ifTrue: [ self acceptReferences ]			ifFalse: [ "rehooking was done in endTest"				dynamicClasses := IdentitySet new.				dynamicMethods := IdentityDictionary new. ] ].	" adjust kept and deleted items to keep dynamic referenced items "	self testStatus value:		'Removing dynamic references from deleted items' asText allBold.	self incorporateClassReferences.	self incorporateMethodReferences.	"Update any now invalid view of kept items"	acceptedDynamicClasses size + acceptedDynamicMethods size == 0 ifFalse: [		keptItems refresh ].	self closeWindow.	RuntimeBuilderUI activeApplication testDone value: true.</body><body package="RuntimePackager">acceptReferences	"Accept dynamic references as part of the application"	" if there are no dynamic items, ignore the button"	dynamicMethods size + dynamicClasses size == 0 ifTrue: [ ^ self ].	" copy dynamic classes and methods to accepted "	acceptedDynamicMethods addAll: dynamicMethods.	dynamicMethods := Set new.	acceptedDynamicClasses addAll: dynamicClasses.	dynamicClasses := Set new.	" reset appropriate displays"	dynamicItemsText value: Text new.	testStatus value: 'Dynamically referenced items were accepted' asText allBold.</body><body package="RuntimePackager">beginTest	"Initiate a test sequence"	| endButton startupClass |	" make sure we are not trying to restart a test already in progress"	testInProgress ifTrue: [ ^self ].	" clean up for intiating more than one test in this window. "	self builder window refresh.	ScheduledControllers checkForEvents.	" check to see if there may be parcels loaded into the image "	options hasLoadableParcels ifTrue: [		self warnAboutParcelLoading ifFalse: [ ^self ] ].	" really start setting up for the test "	startupClass := options startupClass.	self testStatus value: 'Installing wrappers for classes and methods' asText allBold.	#( saveImage beginTest  accept cancel ) do: [ :comp |		( self builder componentAt: comp ) disable ].	endButton := ( self builder componentAt: #endTest ).	endButton enable; takeKeyboardFocus; disable.	" all systems are go --  initiate the test environment "	testInProgress := true.	self class activeTester: self.	Cursor wait showWhile: [ self prepareForTest. ].	endButton enable.	#( acceptReferences ignoreReferences ) do: [ :comp |		( self builder componentAt: comp ) enable ].	self testStatus value: 'Ready to test application' asText allBold.	" no longer attempt to preload parcels -- function is obsolete"	startupClass notNil ifTrue: [		startupClass perform: options startupMethod. ].</body><body package="RuntimePackager">cancel	"Cancel any changes in progress"	testInProgress ifTrue: [ ^self ].	self closeWindow.</body><body package="RuntimePackager">endTest	"Restore the image to its initial state"	self restoreMinimalDevelopmentState.	self mainWindow refresh.	ScheduledControllers checkForEvents.	dynamicClasses size + dynamicMethods size == 0		ifTrue: [			#( acceptReferences ignoreReferences ) do: [ :comp |				(self wrapperAt: comp ) disable ] ].	( self wrapperAt: #endTest ) disable.	" return classes and methods to their original state "	Cursor wait showWhile: [ self unhookAll. ].	" finish restoring the image state and clean up displays "	RuntimeSurrogateManager activeManager endTest.	self class activeTester: nil.	testInProgress := false.	self testStatus value: (#Testcompleted &lt;&lt; #RuntimePackager &gt;&gt; 'Test completed') asText allBold.	#( saveImage beginTest accept cancel ) do: [ :comp |		(self wrapperAt: comp ) enable ].</body><body package="RuntimePackager">endTestQuietly	"Restore the image to its initial state without progress notifications"	| manager |	self restoreMinimalDevelopmentState.	manager := RuntimeSurrogateManager activeManager.	manager allHookedClasses do: [ :cl | manager unhookClass: cl ].	manager allHookedMethods do: [ :meth | manager unhookMethod: meth  ].	manager endTest.	self class activeTester: nil.	testInProgress := false.</body><body package="RuntimePackager">ignoreReferences	"Ignore dynamic references and do not include them as part of the application"	" if there are no dynamic items, ignore the button"	dynamicMethods size + dynamicClasses size == 0 ifTrue: [ ^ self ].	"reset dynamic classes and methods  "	testInProgress		ifTrue: [			testStatus value:				'Reapplying wrappers' asText allBold.			dynamicItemsText value: Text new.			Cursor wait showWhile: [ self rehookDynamicReferences. ] ]		ifFalse: [			dynamicMethods := Set new.			dynamicClasses := Set new. ].	" reset appropriate displays"	dynamicItemsText value: Text new.	testStatus value: 'Dynamically referenced items were ignored' asText allBold.</body><body package="RuntimePackager">overviewHelp	"Open a general help window"	RuntimeBuilderUI helpFor: #helpForOverview.</body><body package="RuntimePackager">saveImage	"Save the image before any real damage is done"	testInProgress ifTrue: [ ^self ].	ObjectMemory saveDialogThenQuit: false.</body><body package="RuntimePackager">stepHelp	"Open a general help window"	RuntimeBuilderUI helpFor: #helpForTest.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester</class-id> <category>internals</category><body package="RuntimePackager">changeRequest	"Need to prevent the window from closing while a test is in progress"	super changeRequest ifFalse: [ ^false ].	testInProgress ifTrue: [		( Dialog confirm:'The test in progress must be ended before this window is closed.Ending the test now may take several minutes and no progressindicators are provided during the process.Do you want to end the test now?' )			ifTrue: [ self endTestQuietly.  ^true ]			ifFalse: [ ^ false ] ].	( dynamicClasses size + dynamicMethods size +		acceptedDynamicClasses size + acceptedDynamicMethods size == 0 ) ifFalse: [		( Dialog confirm: ('Do you want to discard changes concerning \',			'dynamically referenced classes and methods?' ) withCRs )			ifFalse: [ ^false ] ].	mainApplication testCompleted.	^true</body><body package="RuntimePackager">closeWindow	"close the window now"	dynamicClasses := Set new.	dynamicMethods :=Set new.	acceptedDynamicClasses := Set new.	acceptedDynamicMethods := Set new.	self closeRequest.</body><body package="RuntimePackager">findClassByName: aSymbol	"Find the named class which could be present in the System	Dictionary or be currently Undeclared.  If not found answer nil.	Avoid using asQualifiedReference because of entanglement with	the compiler. This assumes that the name is a Smalltalk name"	| names binding |	names := aSymbol tokensBasedOn: $. .	binding :=#{Root.Smalltalk}.	names do: [ :token |		binding notNil ifTrue: [ binding := binding value bindingFor: token asSymbol ] ].	( binding notNil and: [ binding isForClass ] )		ifFalse: [ binding := Undeclared bindingFor: names last asSymbol ].	^ binding notNil		ifTrue: [ binding value ]		ifFalse: [ nil ]</body><body package="RuntimePackager">hideProgressIndicator	"Make the progress indicator border invisble and reset the indicator"	| area |	self resetProgressIndicator.	area := self builder componentAt: #progressIndicator.	area graphicsContext clippingRectangle: area bounds; clear.</body><body package="RuntimePackager">hookDeletedMethods: deletedMethods using: manager 	"Hook all methods that will be deleted from the runtime system."	| method methClass |	self testStatus value: (#InstallingWrappersForMethods &lt;&lt; #RuntimePackager &gt;&gt;'Installing wrappers for methods') asText allBold.		tickRate := deletedMethods size // 50.	self showProgressIndicator.	deletedMethods keysAndValuesDo: 			[:behav :selectors | 			self progressTick.			methClass := behav isMeta ifTrue: [behav soleInstance] ifFalse: [behav].			(self exemptClasses includes: methClass) 				ifFalse: 					[selectors do: 							[:sel | 							method := behav compiledMethodAt: sel ifAbsent: [nil].							method notNil ifTrue: [manager hookMethod: method selector: sel]]]]</body><body package="RuntimePackager">incorporateClassReferences	"Incorporate accepted class references within the sets of kept and	deleted classes"	| cl |	acceptedDynamicClasses do: [ :cln |		cl := self findClassByName: cln.		keptItems deletedClasses remove: cl ifAbsent: [].		keptItems keptClasses add: cl.		keptItems unreferencedClasses remove: cl ifAbsent: [].  ].</body><body package="RuntimePackager">incorporateMethodReferences	"Incorporate dynamic method references within the sets	of kept and deleted methods"	| cl sel |	acceptedDynamicMethods do: [ :array |		"array is class + isMeta + selector"		cl := self findClassByName: ( array at: 1 ).		sel := array at: 3.		cl notNil ifTrue: [			( array at: 2)  ifTrue: [ cl := cl class ].			sel := array at: 3.			keptItems keptMethods at: cl put: (				( keptItems keptMethods at: cl ifAbsent: [ Set new ] )					add: sel; yourself ).			( keptItems deletedMethods includesKey: cl ) ifTrue: [				( ( keptItems deletedMethods at: cl )					remove: sel ifAbsent: [];					yourself ) isEmpty ifTrue: [						keptItems deletedMethods removeKey: cl ] ].			( keptItems unreferencedMethods includesKey: cl ) ifTrue: [				( ( keptItems unreferencedMethods at: cl )					remove: sel ifAbsent: [ ];					yourself ) isEmpty ifTrue: [						keptItems unreferencedMethods removeKey: cl ] ] ] ].</body><body package="RuntimePackager">installUnhookClassBlock: runtimeManager	"Set up blocks that will act upon references to deleted items. "	|textView|	textView := self widgetAt: #dynamicItemsText.		runtimeManager unhookClassBlock: [ :cl :sel |		| cln |		cln := ( cl isMeta ifTrue: [ cl soleInstance ] ifFalse: [ cl ] ) fullName.		dynamicClasses add: cln.		textInProgress ifFalse: [			textInProgress := true.			dynamicItemsText value: dynamicItemsText value, (				'(Class) ',cl fullName,				' class',				( sel isNil ifTrue: [ '' ] ifFalse: [ '&gt;&gt;', sel ] ),				(String with:Character cr) ).			textView selectAt: dynamicItemsText value size.			textInProgress := false.  ] ].</body><body package="RuntimePackager">installUnhookMethodBlock: runtimeManager	"Set up blocks that will act upon references to deleted items. "	|textView|	textView := self widgetAt: #dynamicItemsText.	runtimeManager unhookMethodBlock: [ :cl :sel :meth |		| cln |		cln := ( cl isMeta ifTrue: [ cl soleInstance ] ifFalse: [ cl ] ) fullName.		dynamicMethods add: ( Array with: cln with: cl isMeta with: sel ).		textInProgress ifFalse: [			textInProgress := true.			dynamicItemsText value: dynamicItemsText value, (				'(Method) ', cl fullName, '&gt;&gt;', sel, (String with: Character cr) ).			textView selectAt: dynamicItemsText value size.			textInProgress := false. ] ].</body><body package="RuntimePackager">prepareForTest	"Hook all classes and methods that would normally be stripped from	runtime image.  Install blocks that will record references to these items."	| mgr deletedClasses deletedMethods classDeletions |	" initialize and reset from previous tests "	dynamicItemsText value: Text new.	mgr := RuntimeSurrogateManager activeManager.	mgr beginTest.	mgr		unhookMethodBlock: nil;		unhookClassBlock: nil.	mgr unhookAllMethods.	mgr unhookAllClasses.	textInProgress := false.	self installUnhookMethodBlock: mgr.	self installUnhookClassBlock: mgr.	"Cache some things that will be needed later but whose	accessor methods may be deleted."	deletedClasses := keptItems allDeletedClassesWithLoadables: false.	deletedMethods := keptItems allDeletedMethodsWithLoadables: false.	self hookDeletedMethods: deletedMethods using: mgr.	" hook deleted classes in hierarchial order. "	self exemptClasses do: [:cl | deletedClasses remove: cl ifAbsent: []].	deletedClasses copy do: 			[:cl | 			(deletedClasses includes: cl) 				ifTrue: 					[cl allSubclasses do: [:sub | deletedClasses remove: sub ifAbsent: []]]].	classDeletions := OrderedCollection new.	deletedClasses 		do: [:cl | classDeletions addAll: cl withAllSubclasses reverse].	" go back and hook the classes so that references can be detected "	self testStatus value: (#InstallingWrappers &lt;&lt; #RuntimePackager &gt;&gt; 'Installing wrappers for classes') asText allBold.	tickRate := classDeletions size // 50.	self showProgressIndicator.	classDeletions do: 			[:cl | 			self progressTick.			mgr hookClass: cl].	DeploymentOptionsSystem current isRuntime: true.	" more or less done at this point "	self installQuitSurrogate.	self hideProgressIndicator</body><body package="RuntimePackager">progressTick	"Move the progress indicator one notch"	| area rect |	tickCounter := tickCounter + 1.	tickCounter &gt; tickRate ifTrue: [		tickCounter := 0.		( progressCounter := progressCounter + 1 ) &gt; 50 ifTrue: [			self resetProgressIndicator.			progressCounter := 1. ].		area := self builder componentAt: #progressIndicator.		rect := Rectangle origin: 0.0 @ 0.0 extent: ( progressCounter / 50.0 ) @ 1.0.		rect := rect scaledBy: ( area bounds insetBy: 3 ) extent.		rect := rect translatedBy: area bounds origin + ( 3 @ 3).		rect displayFilledOn: area graphicsContext.  ].</body><body package="RuntimePackager">rehookDynamicReferences	"Unhook methods and classes that were dynamically referenced"	| mgr methods classes classesInOrder |	mgr := RuntimeSurrogateManager activeManager.	" avoid case in which things somehow change underneath you "	methods := dynamicMethods.	classes := dynamicClasses collect: [ :cln | self findClassByName: cln ].	dynamicMethods := Set new.	dynamicClasses := Set new.	" Order classes so that rehooking is done in hierarchial order "	classesInOrder := OrderedCollection new: methods size.	classes copy do: [ :cl |		cl withAllSuperclasses reverseDo: [ :scl |			( classes includes: scl ) ifTrue: [				classesInOrder add: scl.				classes remove: scl ] ] ].	" rehook methods "	tickRate := methods size // 50.	self showProgressIndicator.	methods do: [ :array | "array = class name + isMeta + selector "		| cl meth sel |		self progressTick.		sel := array at: 3.		cl := self findClassByName: ( array at: 1 ).		cl notNil ifTrue: [ " class could have been unloaded "			( array at: 2 ) ifTrue: [ cl := cl class ].			meth := cl compiledMethodAt: sel ifAbsent: [ nil ].			mgr hookMethod: meth selector: sel mclass: cl ] ].	" rehook classes "	tickRate := classesInOrder size // 50.	self showProgressIndicator.	classesInOrder reverseDo: [ :cl |		self progressTick.		mgr hookClass: cl ].	self hideProgressIndicator.</body><body package="RuntimePackager">resetProgressIndicator	"Reset the progress indicator to an intial value"	| area |	progressCounter := 0.	self builder isNil ifFalse: [		area := self builder componentAt: #progressIndicator.		area graphicsContext clippingRectangle: ( area bounds insetBy: 3 ); clear. ].</body><body package="RuntimePackager">restoreMinimalDevelopmentState	"Restore enough image state to provide progress feedback."	"Ignore dynamic refrences during this process. "	RuntimeSurrogateManager activeManager		unhookMethodBlock: nil; 		unhookClassBlock: nil.	DeploymentOptionsSystem current isRuntime: false.	self restoreQuitMethod.</body><body package="RuntimePackager">showLogEntry: aString	"Place the information into the dynamic items area of the display"	dynamicItemsText value: dynamicItemsText value, aString.	( self builder componentAt: #dynamicItemsText ) widget		selectAt: dynamicItemsText value size.</body><body package="RuntimePackager">showProgressIndicator	"Make the progress indicator border visible and reset the indicator"	| area |	area := self builder componentAt: #progressIndicator.	( area bounds insetBy: 1 ) displayStrokedOn: area graphicsContext.	self resetProgressIndicator.</body><body package="RuntimePackager">unhookAll	"Unhook all methods and classes originally hooked for this test execution"	| mgr hookedClasses hookedMethods |	mgr := RuntimeSurrogateManager activeManager.	mgr unhookMethodBlock: nil; unhookClassBlock: nil.	self testStatus value: 'Restoring classes' asText allBold.	hookedClasses := mgr allHookedClasses.	tickRate := hookedClasses size // 50.	self showProgressIndicator.	hookedClasses do: [ :cl |		" The following is debug only ---		self showLogEntry: 'Restoring ', cl name, (String with:Character cr). "		self progressTick.		mgr unhookClass: cl ].	self testStatus value: 'Restoring methods' asText allBold.	hookedMethods := mgr allHookedMethods.	tickRate := hookedMethods size // 50.	self showProgressIndicator.	hookedMethods do: [ :meth |		self progressTick.		mgr unhookMethod: meth  ].	" reset the progress indicator - we are done"	self hideProgressIndicator.</body><body package="RuntimePackager">warnAboutParcelLoading	"Give the user a warning about the impact of parcels"	^Dialog confirm:'Parcels have been indicated as loadable at runtime. For purposes of the test,it is assumed that these parcels would be loaded at runtime through command lineparameters and that the results of loading these parcels is the same as the currentcontents of the image. If these parcels or any others are loaded into the image becauseof application processing during the test, it is likely that the integrity of the image willbe adversely affected. The test process cannot protect the image from this possibility.Do you still want to continue with the test?'</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester</class-id> <category>aspects</category><body package="RuntimePackager">dynamicItemsText	"Answer the text describing dynamic references found so far"	^dynamicItemsText</body><body package="RuntimePackager">progressIndicator	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^progressIndicator isNil ifTrue: [progressIndicator := String new asValue] ifFalse: [progressIndicator]</body><body package="RuntimePackager">testStatus	"This method was generated by UIDefiner. The initialization provided	below may have been preempted by an initialize method."	^testStatus isNil ifTrue: [testStatus := Text new asValue] ifFalse: [testStatus]</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester</class-id> <category>accessing</category><body package="RuntimePackager">exemptClasses	"Answer tester classes that should never be hooked as part	of a test."	exemptClasses notNil ifTrue: [ ^exemptClasses ].	exemptClasses := IdentitySet new.	exemptClasses		addAll: RuntimeManager withAllSuperclasses;		addAll: RuntimeBuilderUI withAllSuperclasses;		addAll: RuntimeBuilderItems withAllSuperclasses;		addAll: RuntimeBuilderOptions withAllSuperclasses;		addAll: RuntimeBuilderTester withAllSuperclasses.	" test for case in which CMacroDefinition will ultimately be eliminated "	( ExternalInterface respondsTo: #optimizationLevel: ) ifTrue: [		exemptClasses add: ( #{CMacroDefinition} valueOrDo: [ nil ] ). ].	^exemptClasses</body><body package="RuntimePackager">keptItems	"Answer the items indicated to be kept by the user"	^keptItems</body><body package="RuntimePackager">keptItems: items	"Set the items indicated to be kept by the user"	keptItems := items</body><body package="RuntimePackager">mainApplication	"Answer the controlling application object"	^mainApplication</body><body package="RuntimePackager">mainApplication: anApplication	"Set the controlling application object"	mainApplication := anApplication</body><body package="RuntimePackager">options	"Answer the options specified for building the runtime image"	^options</body><body package="RuntimePackager">options: opts	"Set the options specified for building the runtime image"	options := opts</body><body package="RuntimePackager">testInProgress	"Answer true if a test is in progress"	^testInProgress</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester</class-id> <category>initialize-release</category><body package="RuntimePackager">initialize	"Initialize a new instance"	testInProgress := false.	dynamicItemsText := Text new asValue.	textInProgress := false.	dynamicClasses := Set new.	dynamicMethods := Set new.	acceptedDynamicClasses := Set new.	acceptedDynamicMethods := Set new.	tickCounter := 0.	tickRate := 1.	progressCounter := 0.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester</class-id> <category>image quitting</category><body package="RuntimePackager">installQuitSurrogate	"Install the surrogate as a replacement for the quit method."	| quitMethod quitSurrogate mdict |	quitMethod := ObjectMemory class compiledMethodAt: #quit ifAbsent: [ ^self ].	quitSurrogate := ( self class compiledMethodAt: #quitMethodSurrogate ) shallowCopy.	quitSurrogate sourcePointer: nil.	mdict := ObjectMemory class instVarAt: 2.	" avoid installing the surrogate twice, which is not good "	( mdict includesKey: #rtpQuit ) ifFalse: [		mdict at: #rtpQuit put: quitMethod. ].	mdict at: #quit put: quitSurrogate.	ObjectMemory class flushVMmethodCache.</body><body package="RuntimePackager">restoreQuitMethod	"Restore the original quit method to ObjectMemory class."	| quitMethod  mdict |	mdict := ObjectMemory class instVarAt: 2.	quitMethod := mdict at: #rtpQuit ifAbsent: [ ^self ].	mdict at: #quit put: quitMethod.	mdict removeKey: #rtpQuit.	ObjectMemory class flushVMmethodCache.</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester</class-id> <category>interface opening</category><body package="RuntimePackager">open	"Open if needed.  Otherwise just bring to the front"	( self builder isNil or: [  self builder window isOpen not ] )		ifTrue: [ super open]		ifFalse: [  self builder window raise expand ]</body><body package="RuntimePackager">postBuildWith: aBuilder	"Set buttons and selection lists to their initial condition"	# ( endTest acceptReferences ignoreReferences )		do: [ :comp |			( aBuilder componentAt: comp ) disable ].</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester</class-id> <category>template methods</category><body package="RuntimePackager">quitMethodSurrogate	"This method is installed in the method dictionary of ObjectMemory class	to detect attempts at quitting the image while a test is active. "	(Dialog confirm:'A quit was requested during a test.Do you really want to quit the image now?')		ifTrue: [self rtpQuit ].	^self</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester class</class-id> <category>accessing</category><body package="RuntimePackager">activeTester	"Answer the active tester instance, if any, or else nil"	^activeTester</body><body package="RuntimePackager">activeTester: aTester	"Set the active tester instance, if any, or else nil"	activeTester := aTester</body></methods><methods><class-id>UI.StandardSystemController</class-id> <category>events</category><body package="RuntimePackager">closeDrainEventsAndUnschedule	"Erase the receiver's view, remove it's deferrable events, and remove it from the collection of scheduled controllers."	view ifNotNil: [ | windowManager |				windowManager := view windowManager.				view close; unscheduleWindow.				windowManager ifNotNil: [:manager| manager drainOutstandingEventsFor: view].]</body></methods><methods><class-id>Core.ImageConfigurationSystem</class-id> <category>helpers</category><body package="RuntimePackager">getOptionsFrom: aStream	"Override this to allow the runtime packager functionality of putting arbitrary command-line options in the config file"	^(Array with: ObjectMemory imageName with: '-pcl'), 		(self tokensFromStream: aStream).</body><body package="RuntimePackager">processOptions: options	"Override this to allow the runtime packager functionality of putting arbitrary command-line options in the config file"	| optionsBySequence sequenceValues earlyOptionsBySequence  |	"Note that this duplicates most of runActivationActions"	earlyOptionsBySequence := (DeploymentOptionsSystem current commandLineOptionsWithPositionsInCommandLine: options)		groupedBy: [:each | each value sequence].	optionsBySequence := (self commandLineOptionsWithPositionsInCommandLine: options)		groupedBy: [:each | each value sequence].	(Array with: earlyOptionsBySequence with: optionsBySequence) do: [:each |		sequenceValues := each keys asSortedCollection.		sequenceValues do:	[:sequence | 			| interests |			interests := each at: sequence.				(interests asSortedCollection: [:a :b | a key &lt;= b key])					do: [:association | association value triggerOptionAt: association key]]].</body></methods><methods><class-id>DeploymentOptionsSystem</class-id> <category>command-line options</category><body package="RuntimePackager">hookNotifierClass: aClassName	| requiredSelector notifierClass |	requiredSelector := #openContext:label:proceedable:.	"can be release dependent"	notifierClass := RuntimePackager.RuntimeManager hiddenReferenceTo: aClassName.	"use to look up name"	"These used to be transcript show's, but we want this to run early enough that the transcript may not be available. And it doesn't really make sense in a runtime image anyway"	notifierClass isNil		ifTrue:			[self error: ('Notifier class &lt;1s&gt; not in image.' expandMacrosWith: aClassName).			^self].	(notifierClass respondsTo: requiredSelector)		ifFalse:			[self error: 'Notifier class &lt;1s&gt; does not respond to &lt;2s&gt;.'.			^self].	RuntimePackager.RuntimeManager hookNotifierClass: notifierClass.</body></methods><methods><class-id>Tools.ItemSelectionModule</class-id> <category>accessing-selection</category><body package="RuntimePackager">addSelect: anObject	"Select an object equal to the one passed as the argument, if found. If multi-selecting, add to the selection rather than replacing it"	| item |	item := self selectionAspect list detect: [:some | some value = anObject] ifNone: [^self].	useMultiSelection		ifTrue: [			self selectionAspect selections: (self selectionAspect selections, (Array with: item))]		ifFalse: [self selectionAspect selection: item]</body></methods><methods><class-id>Tools.TreeSelectionModule</class-id> <category>accessing-selection</category><body package="RuntimePackager">addSelectPath: aCollection	"The inherited #select: method will only select a visible item.	This one will walk aCollection, selecting and expanding its elements,	until either the last element is selected, or an element is encountered	that cannot be found."	self		expandPathButLast: aCollection;		addSelect: aCollection last</body></methods><methods><class-id>Tools.TreeSelectionModule</class-id> <category>interface opening</category><body package="RuntimePackager">postBuildWith: aBuilder	super postBuildWith: aBuilder.	self treeWidget controller performer: menuPerformer.	self treeWidget rootExpander: expandableRoots.	self treeHolder list expandToLevel: preExpandLevel</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderEditor class</class-id> <category>resources</category><body package="RuntimePackager">selectionMenu	"UIMenuEditor new openOnClass: self andSelector: #selectionMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#label: 'Select all' )			#(#MenuItem				#label: 'Clear all' ) ) #(2 ) #(#selectAll #clearAll ) ) decodeAsLiteralArray</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser class</class-id> <category>resources</category><body package="RuntimePackager">referencesMenu	"MenuEditor new openOnClass: self andSelector: #referencesMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem}				#rawLabel: 'References'				#value: #newReferences )			#(#{UI.MenuItem}				#rawLabel: 'Class References'				#value: #newClassReferences )			#(#{UI.MenuItem}				#rawLabel: 'Browse'				#value: #browseReference )			#(#{UI.MenuItem}				#rawLabel: 'Browse Class'				#value: #browseReferenceClass )			#(#{UI.MenuItem}				#rawLabel: 'Clear Cache'				#value: #clearCache ) ) #(2 2 1 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">targetsMenu	"MenuEditor new openOnClass: self andSelector: #targetsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem}				#rawLabel: 'Add ...'				#value: #addTargetFromUser )			#(#{UI.MenuItem}				#rawLabel: 'Remove'				#value: #removeTarget )			#(#{UI.MenuItem}				#rawLabel: 'Sort'				#value: #sortTargets ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderReferenceBrowser class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: 'Extended References Browser'			#min: #(#{Core.Point} 20 20 )			#bounds: #(#{Graphics.Rectangle} 239 247 798 650 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.TextEditorSpec}					#layout: #(#{UI.LayoutFrame} 7 0 0 0.488834 0 0.987478 0 0.985112 )					#name: #referenceFoundText					#model: #referenceFoundText					#isReadOnly: true )				#(#{UI.LabelSpec}					#layout: #(#{UI.LayoutOrigin} 0 0.436494 1 0 )					#label: 'References to Target' )				#(#{UI.SequenceViewSpec}					#layout: #(#{UI.LayoutFrame} 7 0 0 0.0496278 0 0.404293 0 0.476427 )					#name: #targetsList					#flags: 15					#model: #targetsList					#menu: #targetsMenu )				#(#{UI.SequenceViewSpec}					#layout: #(#{UI.LayoutFrame} 0 0.413238 0 0.0545906 0 0.987478 0 0.476427 )					#name: #referencesList					#flags: 15					#model: #referencesList					#menu: #referencesMenu )				#(#{UI.CheckBoxSpec}					#layout: #(#{UI.LayoutOrigin} 0 0.760286 0 0.00496278 )					#name: #keptItemsFilter					#model: #keptItemsFilter					#label: 'Kept Items Only' )				#(#{UI.LabelSpec}					#layout: #(#{UI.LayoutOrigin} 0 0.175313 1 0 )					#label: 'Target' ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser class</class-id> <category>resources</category><body package="RuntimePackager">contingentClassesMenu	"MenuEditor new openOnClass: self andSelector: #contingentClassesMenu"	&lt;resource: #menu&gt;	^#(#{Menu} #(			#(#{MenuItem}				#rawLabel: 'Select all'				#value: #selectAllContingentClasses )			#(#{MenuItem}				#rawLabel: 'Clear all'				#value: #clearAllContingentClasses )			#(#{MenuItem}				#rawLabel: 'Browse'				#value: #browseContingentClasses )			#(#{MenuItem}				#rawLabel: 'Select class'				#value: #selectContingentClass )			#(#{MenuItem}				#rawLabel: 'References'				#value: #extendedReferenceContingentClasses ) ) #(2 3 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">contingentMethodsMenu	"MenuEditor new openOnClass: self andSelector: #contingentMethodsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem}				#rawLabel: 'Select all'				#value: #selectAllContingentMethods )			#(#{UI.MenuItem}				#rawLabel: 'Select category'				#value: #selectContingentMethodsByCategory )			#(#{UI.MenuItem}				#rawLabel: 'Clear all'				#value: #clearAllContingentMethods )			#(#{UI.MenuItem}				#rawLabel: 'Browse'				#value: #browseContingentMethods )			#(#{UI.MenuItem}				#rawLabel: 'References'				#value: #extendedReferenceContingentMethods ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">deletedClassesMenu	"MenuEditor new openOnClass: self andSelector: #deletedClassesMenu"	&lt;resource: #menu&gt;	^#(#{Menu} #(			#(#{MenuItem}				#rawLabel: 'Select all'				#value: #selectAllDeletedClasses )			#(#{MenuItem}				#rawLabel: 'Clear all'				#value: #clearAllDeletedClasses )			#(#{MenuItem}				#rawLabel: 'Browse'				#value: #browseDeletedClasses )			#(#{MenuItem}				#rawLabel: 'Select class'				#value: #selectDeletedClass )			#(#{MenuItem}				#rawLabel: 'References'				#value: #extendedReferenceDeletedClasses ) ) #(2 3 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">deletedMethodsMenu	"MenuEditor new openOnClass: self andSelector: #deletedMethodsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem}				#rawLabel: 'Select all'				#value: #selectAllDeletedMethods )			#(#{UI.MenuItem}				#rawLabel: 'Select category'				#value: #selectDeletedMethodsByCategory )			#(#{UI.MenuItem}				#rawLabel: 'Clear all'				#value: #clearAllDeletedMethods )			#(#{UI.MenuItem}				#rawLabel: 'Browse'				#value: #browseDeletedMethods )			#(#{UI.MenuItem}				#rawLabel: 'References'				#value: #extendedReferenceDeletedMethods ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">keptClassesMenu	"MenuEditor new openOnClass: self andSelector: #keptClassesMenu"	&lt;resource: #menu&gt;	^#(#{Menu} #(			#(#{MenuItem}				#rawLabel: 'Select all'				#value: #selectAllKeptClasses )			#(#{MenuItem}				#rawLabel: 'Clear all'				#value: #clearAllKeptClasses )			#(#{MenuItem}				#rawLabel: 'Browse'				#value: #browseKeptClasses )			#(#{MenuItem}				#rawLabel: 'Select class'				#value: #selectKeptClass )			#(#{MenuItem}				#rawLabel: 'References'				#value: #extendedReferenceKeptClasses ) ) #(2 3 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">keptMethodsMenu	"MenuEditor new openOnClass: self andSelector: #keptMethodsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem}				#rawLabel: 'Select all'				#value: #selectAllKeptMethods )			#(#{UI.MenuItem}				#rawLabel: 'Select category'				#value: #selectKeptMethodsByCategory )			#(#{UI.MenuItem}				#rawLabel: 'Clear all'				#value: #clearAllKeptMethods )			#(#{UI.MenuItem}				#rawLabel: 'Browse'				#value: #browseKeptMethods )			#(#{UI.MenuItem}				#rawLabel: 'References'				#value: #extendedReferenceKeptMethods ) ) #(3 2 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">mainMenuVW	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenuVW"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Packages/Bundles' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Select all' 							#value: #selectAllCategories ) 						#(#{UI.MenuItem} 							#rawLabel: 'Clear all' 							#value: #clearAllCategories ) 						#(#{UI.MenuItem} 							#rawLabel: 'Find Package ...' 							#value: #findPackage 							#shortcutKeyCharacter: $p 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'Find Class/Variable/Name Space...' 							#value: #findCategoryWithGlobal 							#shortcutKeyCharacter: $f 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'Select Prerequisites' 							#value: #selectPrerequisites 							#enablementSelector: #isPundleSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Keep' 							#value: #keepSelectedPundle 							#enablementSelector: #isPundleSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Delete' 							#value: #deleteSelectedPundle 							#enablementSelector: #isPundleSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Make Contingent' 							#value: #makeSelectedPundleContingent 							#enablementSelector: #isPundleSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Browse' 							#value: #browseSelectedPundle 							#enablementSelector: #isPundleSelected 							#shortcutKeyCharacter: $b 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'Reset to Defaults' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Selected Only' 										#value: #resetSelectedCategoriesToDefaults ) 									#(#{UI.MenuItem} 										#rawLabel: 'All' 										#value: #resetAllCategoriesToDefaults ) ) #(2 ) nil ) ) ) #(2 3 4 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Classes' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Deleted' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllDeletedClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllDeletedClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseDeletedClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select class' 										#value: #selectDeletedClass ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceDeletedClasses ) ) #(2 3 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Contingent' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllContingentClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllContingentClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseContingentClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select class' 										#value: #selectContingentClass ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceContingentClasses ) ) #(2 3 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Kept' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllKeptClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllKeptClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseKeptClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select class' 										#value: #selectKeptClass ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceKeptClasses ) ) #(2 3 ) nil ) ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Methods' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Deleted' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllDeletedMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select category' 										#value: #selectDeletedMethodsByCategory ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllDeletedMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseDeletedMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Implementors' 										#value: #implementorsOfDeletedMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceDeletedMethods ) ) #(3 1 2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Contingent' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllContingentMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select category' 										#value: #selectContingentMethodsByCategory ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllContingentMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseContingentMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Implementors' 										#value: #implementorsOfContingentMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceContingentMethods ) ) #(3 1 2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Kept' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllKeptMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select category' 										#value: #selectKeptMethodsByCategory ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllKeptMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseKeptMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Implementors' 										#value: #implementorsOfKeptMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceKeptMethods ) ) #(3 1 2 ) nil ) ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Help' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Overview' 							#value: #overviewHelp ) 						#(#{UI.MenuItem} 							#rawLabel: 'This Step' 							#value: #stepHelp ) ) #(2 ) nil ) ) ) #(4 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">systemSelectionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #systemSelectionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Select all' 				#value: #selectAllCategories ) 			#(#{UI.MenuItem} 				#rawLabel: 'Clear all' 				#value: #clearAllCategories ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find Package...' 				#value: #findPackage 				#shortcutKeyCharacter: $p 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find Class/Variable/Name Space...' 				#value: #findCategoryWithGlobal 				#shortcutKeyCharacter: $f 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 'Select Prerequisites' 				#value: #selectPrerequisites 				#enablementSelector: #isPundleSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 'Keep' 				#value: #keepSelectedPundle 				#enablementSelector: #isPundleSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 'Delete' 				#value: #deleteSelectedPundle 				#enablementSelector: #isPundleSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 'Make Contingent' 				#value: #makeSelectedPundleContingent 				#enablementSelector: #isPundleSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 'Browse' 				#value: #browseSelectedPundle 				#enablementSelector: #isPundleSelected 				#shortcutKeyCharacter: $b 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 'Reset to Defaults' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Selected Only' 							#value: #resetSelectedCategoriesToDefaults ) 						#(#{UI.MenuItem} 							#rawLabel: 'All' 							#value: #resetAllCategoriesToDefaults ) ) #(2 ) nil ) ) ) #(2 3 4 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsChooser class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionType #cascade #sizeAutoSave true #openType #cascade ) 			#label: 'Runtime Class and Method Selection' 			#min: #(#{Core.Point} 20 20 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1311 956 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.729951 0 0.239808 ) 					#label: 'Kept Classes/Globals' 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.358429 0 0.239808 ) 					#label: 'Contingent Classes/Globals' 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0376432 0 0.239808 ) 					#label: 'Deleted Classes/Globals' 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.765957 0 0.561151 ) 					#label: 'Kept Methods' 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.394435 0 0.561151 ) 					#label: 'Contingent Methods' 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0458265 5 0 0 0.977087 0 0.0611247 ) 					#name: #categoryListTitle 					#flags: 0 					#model: #categoryListTitle 					#tabable: false 					#alignment: #center 					#style: #default 					#isReadOnly: true 					#type: #text ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.0736498 0 0.561151 ) 					#label: 'Deleted Methods' 					#style: #default ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0278232 0 0.29976 0 0.301146 0 0.549161 ) 					#name: #deletedClassesList 					#flags: 15 					#model: #deletedClassesList 					#menu: #deletedClassesMenu 					#multipleSelections: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.309329 0 0.340528 0 0.358429 0 0.395683 ) 					#model: #moveClassesContingentToDeleted 					#label: '&lt;&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.309329 0 0.407674 0 0.358429 0 0.46283 ) 					#model: #moveClassesDeletedToContingent 					#label: '&gt;&gt;' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.364975 0 0.302158 0 0.638298 0 0.551559 ) 					#name: #contingentClassesList 					#flags: 15 					#model: #contingentClassesList 					#menu: #contingentClassesMenu 					#multipleSelections: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.648118 0 0.342926 0 0.697218 0 0.398082 ) 					#model: #moveClassesKeptToContigent 					#label: '&lt;&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.648118 0 0.407674 0 0.697218 0 0.46283 ) 					#model: #moveClassesContingentToKept 					#label: '&gt;&gt;' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.703764 0 0.302158 0 0.977087 0 0.551559 ) 					#name: #keptClassesList 					#flags: 15 					#model: #keptClassesList 					#menu: #keptClassesMenu 					#multipleSelections: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0278232 0 0.618705 0 0.301146 0 0.868105 ) 					#name: #deletedMethodsList 					#flags: 15 					#model: #deletedMethodsList 					#menu: #deletedMethodsMenu 					#multipleSelections: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.309329 0 0.659472 0 0.358429 0 0.714628 ) 					#model: #moveMethodsContingentToDeleted 					#label: '&lt;&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.309329 0 0.726619 0 0.358429 0 0.781775 ) 					#model: #moveMethodsDeletedToContingent 					#label: '&gt;&gt;' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.364975 0 0.618705 0 0.638298 0 0.868105 ) 					#name: #contingentMethodsList 					#flags: 15 					#model: #contingentMethodsList 					#menu: #contingentMethodsMenu 					#multipleSelections: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.648118 0 0.659472 0 0.697218 0 0.714628 ) 					#model: #moveMethodsKeptToContingent 					#label: '&lt;&lt;' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.648118 0 0.726619 0 0.697218 0 0.781775 ) 					#model: #moveMethodsContingentToKept 					#label: '&gt;&gt;' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.703764 0 0.618705 0 0.977087 0 0.868105 ) 					#name: #keptMethodsList 					#flags: 15 					#model: #keptMethodsList 					#menu: #keptMethodsMenu 					#multipleSelections: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0785597 0 0.901679 0 0.229133 0 0.966427 ) 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.754501 0 0.901679 0 0.905074 0 0.966427 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0310966 5 0.0611247 0 0.977087 0 0.229829 ) 					#name: #systemCategoriesList 					#majorKey: #{TreeSelectionModule} 					#minorKey: #multiSelectSpecWithNoScrollbar 					#clientKey: #systemPackagesTree ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionType #cascade #sizeAutoSave true #openType #cascade ) 			#label: 'Runtime Kept Items Viewer' 			#min: #(#{Core.Point} 20 20 ) 			#bounds: #(#{Graphics.Rectangle} 422 341 1024 768 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.60299 0 0.244552 ) 					#label: 'Kept Classes/Globals' 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.121262 0 0.244552 ) 					#label: 'Deleted Classes/Globals' 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.641196 0 0.539952 ) 					#label: 'Kept Methods' 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.159468 0 0.539952 ) 					#label: 'Deleted Methods' 					#style: #default ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.317276 0 0.878935 0 0.700997 0 0.975787 ) 					#name: #showParcelsAsGroup 					#label: 'Show loadable parcels as' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0714286 0 0.305085 0 0.456811 0 0.539952 ) 					#name: #deletedClassesList 					#flags: 15 					#model: #deletedClassesList 					#menu: #deletedClassesMenu 					#multipleSelections: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.534884 0 0.305085 0 0.920266 0 0.539952 ) 					#name: #keptClassesList 					#flags: 15 					#model: #keptClassesList 					#menu: #keptClassesMenu 					#multipleSelections: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0730897 0 0.600484 0 0.458472 0 0.854722 ) 					#name: #deletedMethodsList 					#flags: 15 					#model: #deletedMethodsList 					#menu: #deletedMethodsMenu 					#multipleSelections: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.536545 0 0.600484 0 0.921927 0 0.854722 ) 					#name: #keptMethodsList 					#flags: 15 					#model: #keptMethodsList 					#menu: #keptMethodsMenu 					#multipleSelections: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0697674 0 0.912833 0 0.219269 0 0.975787 ) 					#model: #generateReport 					#label: 'Report' 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.380399 0 0.922518 ) 					#name: #showParcelsAsDeleted 					#model: #showParcelsAs 					#label: 'Deleted' 					#select: #deleted ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.51495 0 0.922518 ) 					#name: #showParcelsAsKept 					#model: #showParcelsAs 					#label: 'Kept' 					#select: #kept ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.774086 0 0.912833 0 0.923588 0 0.975787 ) 					#model: #accept 					#label: 'Close' 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0714286 30 0 0 0.920266 0 0.229829 ) 					#name: #Subcanvas1 					#majorKey: #{TreeSelectionModule} 					#minorKey: #multiSelectSpecWithNoScrollbar 					#clientKey: #systemPackagesTree ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} -115 0.5 6 0 231 21 ) 					#name: #categoryListTitle 					#flags: 0 					#model: #categoryListTitle 					#tabable: false 					#alignment: #center 					#isReadOnly: true 					#type: #text ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderItemsViewer class</class-id> <category>resources</category><body package="RuntimePackager">mainMenuVW	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenuVW"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Package/Bundle' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Select all' 							#value: #selectAllCategories ) 						#(#{UI.MenuItem} 							#rawLabel: 'Clear all' 							#value: #clearAllCategories ) 						#(#{UI.MenuItem} 							#rawLabel: 'Find Package ...' 							#value: #findPackage 							#shortcutKeyCharacter: $p 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'Find Class/Variable/Name Space...' 							#value: #findCategoryWithGlobal 							#shortcutKeyCharacter: $f 							#shortcutModifiers: 3 ) 						#(#{UI.MenuItem} 							#rawLabel: 'Select Prerequisites' 							#value: #selectPrerequisites 							#enablementSelector: #isPundleSelected ) 						#(#{UI.MenuItem} 							#rawLabel: 'Browse Selected' 							#value: #browseSelectedPundle 							#shortcutKeyCharacter: $b 							#shortcutModifiers: 3 ) ) #(2 3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Classes' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Deleted' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllDeletedClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllDeletedClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseDeletedClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select class' 										#value: #selectDeletedClass ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceDeletedClasses ) ) #(2 3 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Kept' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllKeptClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllKeptClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseKeptClasses ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select class' 										#value: #selectKeptClass ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceKeptClasses ) ) #(2 3 ) nil ) ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Methods' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Deleted' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllDeletedMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select category' 										#value: #selectDeletedMethodsByCategory ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllDeletedMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseDeletedMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Implementors' 										#value: #implementorsOfDeletedMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceDeletedMethods ) ) #(3 1 2 ) nil ) ) 						#(#{UI.MenuItem} 							#rawLabel: 'Kept' 							#submenu: #(#{UI.Menu} #(									#(#{UI.MenuItem} 										#rawLabel: 'Select all' 										#value: #selectAllKeptMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Select category' 										#value: #selectKeptMethodsByCategory ) 									#(#{UI.MenuItem} 										#rawLabel: 'Clear all' 										#value: #clearAllKeptMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Browse' 										#value: #browseKeptMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'Implementors' 										#value: #implementorsOfKeptMethods ) 									#(#{UI.MenuItem} 										#rawLabel: 'References' 										#value: #extendedReferenceKeptMethods ) ) #(3 1 2 ) nil ) ) ) #(2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Help' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Overview' 							#value: #overviewHelp ) 						#(#{UI.MenuItem} 							#rawLabel: 'This Step' 							#value: #stepHelp ) ) #(2 ) nil ) ) ) #(4 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">systemSelectionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #systemSelectionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Select all' 				#value: #selectAllCategories ) 			#(#{UI.MenuItem} 				#rawLabel: 'Clear all' 				#value: #clearAllCategories ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find Package...' 				#value: #findPackage 				#shortcutKeyCharacter: $p 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 'Find Class/Variable/Name Space...' 				#value: #findCategoryWithGlobal 				#shortcutKeyCharacter: $f 				#shortcutModifiers: 3 ) 			#(#{UI.MenuItem} 				#rawLabel: 'Select Prerequisites' 				#value: #selectPrerequisites 				#enablementSelector: #isPundleSelected ) 			#(#{UI.MenuItem} 				#rawLabel: 'Browse Selected' 				#value: #browseSelectedPundle 				#shortcutKeyCharacter: $b 				#shortcutModifiers: 3 ) ) #(2 3 1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderMemoryParamEditor class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #runtimeMemoryParameters 				#defaultString: 'Runtime Memory Parameters' 				#catalogID: #RuntimePackager ) 			#min: #(#{Core.Point} 498 395 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 562 290 1060 685 ) 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -110 1 245 0 ) 					#label: 'Space Sizes' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 52 0 0 1 ) 					#label: 'Eden:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 52 0 -60 0.5 77 0 ) 					#name: #edenSize 					#model: #edenSize 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 102 0 0 1 ) 					#label: 'Survivor:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 102 0 -60 0.5 127 0 ) 					#name: #survivorSize 					#model: #survivorSize 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 152 0 0 1 ) 					#label: 'Large:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 152 0 -60 0.5 177 0 ) 					#name: #largeSize 					#model: #largeSize 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 202 0 0 1 ) 					#label: 'Stack:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 202 0 -60 0.5 227 0 ) 					#name: #stackSize 					#model: #stackSize 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -40 0.5 52 0 0 1 ) 					#label: 'Code Cache:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 0.5 52 0 -120 1 77 0 ) 					#name: #codeSize 					#model: #codeSize 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -40 0.5 100 0 0 1 ) 					#label: 'Old Space Headroom:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 0.5 102 0 -120 1 127 0 ) 					#name: #oldSize 					#model: #oldSize 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} -40 0.5 152 0 0 1 ) 					#label: 'Fixed Space Headroom:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 0.5 152 0 -120 1 177 0 ) 					#name: #fixedSize 					#model: #fixedSize 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 252 0 -110 1 385 0 ) 					#label: 'Memory Policy' ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 294 0 0 1 ) 					#name: #Label1 					#label: 'Memory Policy:' ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 295 0 -120 1 320 0 ) 					#name: #ComboBox1 					#model: #memoryPolicyClass 					#comboList: #memoryPolicyClasses ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 20 0 342 0 0 1 ) 					#label: 'Memory Limit:' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 342 0 -60 0.5 367 0 ) 					#name: #memoryUpperBound 					#model: #memoryUpperBound 					#type: #number 					#formatString: '#,##0' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -100 1 17 0 -10 1 42 0 ) 					#model: #accept 					#label: 					#(#{Kernel.UserMessage} 						#key: #ok 						#defaultString: 'OK' 						#catalogID: #RuntimePackager ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -100 1 50 0 -10 1 75 0 ) 					#name: #cancel 					#model: #cancel 					#label: 					#(#{Kernel.UserMessage} 						#key: #cancel 						#defaultString: 'Cancel' 						#catalogID: #RuntimePackager ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -100 1 102 0 -10 1 127 0 ) 					#name: #helpButton 					#model: #stepHelp 					#label: 					#(#{Kernel.UserMessage} 						#key: #help 						#defaultString: 'Help' 						#catalogID: #RuntimePackager ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>RuntimePackager.HierarchyErrorMessage class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #openHierarchyErrors				#defaultString: 'Open Hierarchy Errors' 				#catalogID: #labels ) 			#min: #(#{Core.Point} 186 70 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 992 654 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -46 1 ) 					#model: #errorString 					#isReadOnly: true 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 10 235 97 260 ) 					#name: #ActionButton1 					#model: #accept 					#helpText: 'continue with packaging process' 					#label: 'Proceed' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 107 235 187 260 ) 					#name: #ActionButton2 					#model: #cancel 					#helpText: 'terminate the packaging process' 					#label: 'Terminate' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 390 235 470 260 ) 					#name: #ActionButton3 					#model: #copy 					#helpText: 'copy to clipboard' 					#label: 'Copy' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeExample class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: 'Smalltalk Storage Statistics'			#min: #(#{Core.Point} 40 20 )			#bounds: #(#{Graphics.Rectangle} 290 285 738 632 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.LabelSpec}					#layout: #(#{Graphics.LayoutOrigin} 0 0.0591133 0 0.174041 )					#label: 'Eden bytes' )				#(#{UI.LabelSpec}					#layout: #(#{Graphics.LayoutOrigin} 0 0.0591133 0 0.289086 )					#label: 'Survivor space bytes' )				#(#{UI.LabelSpec}					#layout: #(#{Graphics.LayoutOrigin} 0 0.0591133 0 0.40413 )					#label: 'Large space bytes' )				#(#{UI.LabelSpec}					#layout: #(#{Graphics.LayoutOrigin} 0 0.0591133 0 0.519174 )					#label: 'Old space bytes' )				#(#{UI.LabelSpec}					#layout: #(#{Graphics.LayoutOrigin} 0 0.0591133 0 0.634218 )					#label: 'Perm space bytes' )				#(#{UI.LabelSpec}					#layout: #(#{Graphics.LayoutOrigin} 0 0.438424 0 0.0825959 )					#label: 'Allocated' )				#(#{UI.LabelSpec}					#layout: #(#{Graphics.LayoutOrigin} 0 0.770936 0 0.0825959 )					#label: 'Used' )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.413793 0 0.174041 0 0.633005 0 0.247788 )					#isOpaque: true					#model: #edenAlloc					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.70936 0 0.174041 0 0.928571 0 0.247788 )					#isOpaque: true					#model: #edenUsed					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.413793 0 0.289086 0 0.633005 0 0.362832 )					#isOpaque: true					#model: #survAlloc					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.70936 0 0.289086 0 0.928571 0 0.362832 )					#isOpaque: true					#model: #survUsed					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.413793 0 0.40413 0 0.633005 0 0.477876 )					#isOpaque: true					#model: #largeAlloc					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.70936 0 0.40413 0 0.928571 0 0.477876 )					#isOpaque: true					#model: #largeUsed					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.413793 0 0.519174 0 0.633005 0 0.59292 )					#isOpaque: true					#model: #oldAlloc					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.70936 0 0.519174 0 0.928571 0 0.59292 )					#isOpaque: true					#model: #oldUsed					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.413793 0 0.634218 0 0.633005 0 0.707965 )					#isOpaque: true					#model: #permAlloc					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.70936 0 0.634218 0 0.928571 0 0.707965 )					#isOpaque: true					#model: #permUsed					#alignment: #right					#isReadOnly: true					#type: #number )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.0647321 0 0.824713 0 0.321429 0 0.899425 )					#model: #setValues					#label: 'Refresh'					#defaultable: true )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.368304 0 0.827089 0 0.625 0 0.902017 )					#model: #forceError					#label: 'Force Error'					#defaultable: true )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.LayoutFrame} 0 0.669643 0 0.827089 0 0.926339 0 0.902017 )					#model: #closeRequest					#label: 'Close'					#defaultable: true ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeProgressNotifier class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec		#window:		#(#WindowSpec			#label: 'Progress Notifier'			#min: #(#Point 40 20 )			#bounds: #(#Rectangle 301 362 721 485 ) )		#component:		#(#SpecCollection			#collection: #(				#(#TextEditorSpec					#layout: #(#LayoutFrame 0 0.0119048 0 0.0487805 0 0.985714 0 0.764228 )					#name: #text					#flags: 12					#model: #text					#isReadOnly: true )				#(#InputFieldSpec					#layout: #(#LayoutFrame 0 0.0119048 0 0.821138 0 0.983333 15 0.821138 )					#name: #progressString					#model: #progressString					#tabable: false					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionType #cascade #sizeAutoSave true #openType #cascade ) 			#label: 'Runtime Packager' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 426 384 1024 751 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0367893 0 0.0849858 0 0.598662 0 0.728045 ) 					#name: #stepDescription 					#model: #stepDescription 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.041806 0 0.0169972 0 0.575251 0 0.0708215 ) 					#flags: 0 					#model: #stepTitle 					#alignment: #center 					#isReadOnly: true 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0351171 0 0.815864 0 0.210702 0 0.90085 ) 					#name: #previousStepButton 					#model: #previousStepPushed 					#label: '&lt;&lt; Previous' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.443144 0 0.815864 0 0.618729 0 0.90085 ) 					#name: #doThisStepButton 					#model: #doThisStepPushed 					#label: 'Do this step' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.62709 0 0.815864 0 0.802676 0 0.90085 ) 					#name: #takeDefaultsButton 					#model: #takeDefaultsPushed 					#label: 'Take Defaults' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.219064 0 0.815864 0 0.394649 0 0.90085 ) 					#name: #nextStepButton 					#model: #nextStepPushed 					#label: 'Next  &gt;&gt;' 					#defaultable: true ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.640468 0 0.0679887 0 0.936455 0 0.730878 ) 					#label: 'Steps Completed' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.662207 0 0.141643 ) 					#name: #cleanupDone 					#model: #cleanupDone 					#tabable: false 					#label: 'Clean Up Image' 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.662207 0 0.212465 ) 					#name: #optionsDone 					#model: #optionsDone 					#tabable: false 					#label: 'Set Options' 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.662207 0 0.283286 ) 					#name: #itemsDone 					#model: #itemsDone 					#tabable: false 					#label: 'Specify Kept/Deleted' 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.662207 0 0.354108 ) 					#name: #scanDone 					#model: #scanDone 					#tabable: false 					#label: 'Scan for Unreferenced' 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.662207 0 0.424929 ) 					#name: #reviewDone 					#model: #reviewDone 					#tabable: false 					#label: 'Review Kept/Deleted' 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.662207 0 0.566572 ) 					#name: #testDone 					#model: #testDone 					#tabable: false 					#label: 'Test Application' 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.662207 0 0.637394 ) 					#name: #memoryDone 					#model: #memoryDone 					#tabable: false 					#label: 'Set Memory Params' 					#style: #small ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.662207 0 0.495751 ) 					#name: #saveParcelsDone 					#model: #saveParcelsDone 					#tabable: false 					#label: 'Save Parcels' 					#style: #small ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.847826 0 0.815864 0 0.93311 0 0.90085 ) 					#model: #stepHelp 					#label: 'Help' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderUI class</class-id> <category>resources</category><body package="RuntimePackager">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'File' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Load parameters ...' 							#value: #loadParams ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save parameters ...' 							#value: #saveParams ) 						#(#{UI.MenuItem} 							#rawLabel: 'Open launcher' 							#value: #openLauncher ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save image ...' 							#value: #saveImage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Quit image ...' 							#value: #quitImage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Package Runtime Image' 							#value: #packageRuntimeImage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Exit Runtime Packager' 							#value: #closeRequest ) ) #(2 1 2 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Actions' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Cleanup image' 							#value: #cleanUpImage ) 						#(#{UI.MenuItem} 							#rawLabel: 'Set common options ...' 							#value: #setOptions ) 						#(#{UI.MenuItem} 							#rawLabel: 'Specify kept items ...' 							#value: #chooseKeptItems ) 						#(#{UI.MenuItem} 							#rawLabel: 'Scan unreferenced' 							#value: #traceMessages ) 						#(#{UI.MenuItem} 							#rawLabel: 'Review kept items ...' 							#value: #viewReferencedItems ) 						#(#{UI.MenuItem} 							#rawLabel: 'Save loadable parcels' 							#value: #saveParcels ) 						#(#{UI.MenuItem} 							#rawLabel: 'Test application ...' 							#value: #testApplication ) 						#(#{UI.MenuItem} 							#rawLabel: 'Set memory params ...' 							#value: #setMemoryParams ) 						#(#{UI.MenuItem} 							#rawLabel: 'Strip system' 							#value: #stripSystem ) ) #(2 3 1 1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Help' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Contents' 							#value: #helpContents ) 						#(#{UI.MenuItem} 							#rawLabel: 'Help for Current Step' 							#value: #stepHelp ) ) #(2 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderHelp class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#FullSpec		#window:		#(#WindowSpec			#label: 'Runtime Packager Help'			#min: #(#Point 40 20 )			#bounds: #(#Rectangle 283 274 851 637 ) )		#component:		#(#SpecCollection			#collection: #(				#(#TextEditorSpec					#layout: #(#LayoutFrame 0 0.0328125 0 0.100962 0 0.970312 0 0.846154 )					#name: #helpString					#model: #helpString					#isReadOnly: true )				#(#InputFieldSpec					#layout: #(#LayoutFrame 0 0.028125 0 0.0288462 0 0.967187 0 0.0865385 )					#name: #title					#flags: 0					#model: #title					#tabable: false					#alignment: #center					#isReadOnly: true					#type: #text )				#(#ActionButtonSpec					#layout: #(#LayoutFrame 0 0.828125 0 0.884615 0 0.970312 0 0.961538 )					#model: #closeRequest					#label: 'Close'					#defaultable: true )				#(#ActionButtonSpec					#layout: #(#LayoutFrame 0 0.0328125 0 0.884615 0 0.175 0 0.961538 )					#name: #hardcopy					#model: #hardcopy					#label: 'Print'					#defaultable: true ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor class</class-id> <category>interface specs</category><body package="RuntimePackager">basicsSpec	"UIPainter new openOnClass: self andSelector: #basicsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: 'Basics'			#min: #(#{Core.Point} 40 20 )			#bounds: #(#{Graphics.Rectangle} 243 294 657 600 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 9 12 )					#label: 'Startup Class' )				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 7 80 )					#label: 'Startup Method' )				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 9 149 )					#label: 'Runtime Image Path Name' )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.Rectangle} 10 38 334 63 )					#name: #startupClass					#isOpaque: true					#model: #startupClass					#menu: #startupClassMenu					#type: #string )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.Rectangle} 364 38 396 63 )					#model: #findStartupClass					#label: '?'					#defaultable: true )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.Rectangle} 10 106 334 131 )					#name: #startupMethod					#isOpaque: true					#model: #startupMethod					#menu: #startupMethodMenu					#type: #string )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.Rectangle} 364 106 396 131 )					#model: #findStartupMethod					#label: '?'					#defaultable: true )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.Rectangle} 11 175 335 200 )					#name: #imagePath					#isOpaque: true					#model: #imagePath ) ) ) )</body><body package="RuntimePackager">detailsSpec	"Tools.UIPainter new openOnClass: self andSelector: #detailsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #positionType #cascade #sizeAutoSave true #openType #cascade ) 			#label: 'Details' 			#min: #(#{Core.Point} 417 301 ) 			#max: #(#{Core.Point} 417 301 ) 			#bounds: #(#{Graphics.Rectangle} 512 384 929 685 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 25 192 388 282 ) 					#label: 'Action on last window close' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 25 16 ) 					#name: #removeCompiler 					#model: #removeCompiler 					#label: 'Remove compiler classes' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 25 40 ) 					#name: #headlessImage 					#model: #headlessImage 					#label: 'Build headless image' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 25 64 ) 					#name: #clearParcelPath 					#model: #clearParcelPath 					#label: 'Clear parcel search path' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 25 88 ) 					#name: #doThreeSaves 					#model: #doThreeSaves 					#label: 'Use three-step save procedure' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 25 112 ) 					#name: #skipScan 					#model: #skipScan 					#label: 'Skip default scan for unreferenced items' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 26 214 ) 					#name: #shutdown 					#model: #lastWindowCloseAction 					#label: 'Shutdown image' 					#select: #shutdown ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 201 214 ) 					#model: #lastWindowCloseAction 					#label: 'Continue processing' 					#select: #continue ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 26 242 ) 					#model: #lastWindowCloseAction 					#label: 'Standard Behavior (e.g. open launcher)' 					#select: #standard ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 25 135 ) 					#name: #suppressSplashScreen 					#model: #suppressSplashScreen 					#label: 'Suppress splash screen and herald sound' ) ) ) )</body><body package="RuntimePackager">emptySpec	"UIPainter new openOnClass: self andSelector: #emptySpec"	&lt;resource: #canvas&gt;	^#(#FullSpec		#window:		#(#WindowSpec			#label: 'Unlabeled Canvas'			#bounds: #(#Rectangle 252 286 626 552 ) )		#component:		#(#SpecCollection			#collection: #() ) )</body><body package="RuntimePackager">exceptionsSpec	"UIPainter new openOnClass: self andSelector: #exceptionsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: 'Exceptions'			#min: #(#{Core.Point} 40 20 )			#bounds: #(#{Graphics.Rectangle} 301 288 723 601 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 17 26 )					#label: 'Error Notifier Class' )				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 17 148 )					#label: 'Error Log Path Name' )				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 17 87 )					#label: 'Image Dumper Class' )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.Rectangle} 17 52 343 77 )					#name: #errorNotifierClass					#isOpaque: true					#model: #errorNotifierClass					#menu: #errorNotifierMenu					#type: #string )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.Rectangle} 363 52 395 77 )					#model: #findErrorNotifierClass					#label: '?'					#defaultable: true )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.Rectangle} 17 113 343 138 )					#name: #imageDumperClass					#isOpaque: true					#model: #imageDumperClass					#menu: #imageDumperMenu					#type: #string )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.Rectangle} 363 113 395 138 )					#model: #findImageDumperClass					#label: '?'					#defaultable: true )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.Rectangle} 17 174 343 200 )					#name: #errorLogPath					#isOpaque: true					#model: #errorLogPath ) ) ) )</body><body package="RuntimePackager">parcelsSpec	"Tools.UIPainter new openOnClass: self andSelector: #parcelsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Parcels' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 744 434 1177 766 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0 149 0 -15 1 326 0 ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 112 1 161 22 ) 					#label: 'Parcel' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 43 292 123 313 ) 					#label: 'Path Name' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 34 219 ) 					#label: 'Save Option' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 6 0 22 0 -15 1 140 0 ) 					#name: #parcelList 					#model: #parcelList 					#menu: #parcelsMenu 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 34 162 ) 					#name: #parcelIsLoadable 					#model: #parcelIsLoadable 					#label: 'Parcel is loaded into image at runtime' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 34 186 ) 					#name: #parcelUnloadBeforeStrip 					#model: #parcelUnloadBeforeStrip 					#label: 'Unload before saving runtime image' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 158 221 ) 					#name: #stripParcel 					#model: #parcelSaveOption 					#label: 'Strip unreferenced items and save' 					#select: #stripParcel ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 158 240 ) 					#name: #saveParcel 					#model: #parcelSaveOption 					#label: 'Save full parcel' 					#select: #saveParcel ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Core.Point} 158 259 ) 					#name: #doNotSaveParcel 					#model: #parcelSaveOption 					#label: 'Do not save' 					#select: #doNotSaveParcel ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.Rectangle} 158 288 370 313 ) 					#name: #parcelPath 					#model: #parcelPath ) ) ) )</body><body package="RuntimePackager">platformsSpec	"Tools.UIPainter new openOnClass: self andSelector: #platformsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Platforms' 			#bounds: #(#{Graphics.Rectangle} 139 553 513 819 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.Rectangle} 20 15 298 90 ) 					#label: 'Operating Systems' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 42 39 ) 					#name: #osWindows 					#model: #osWindows 					#label: 'Windows' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 42 63 ) 					#name: #osUnix 					#model: #osUnix 					#label: 'Unix' ) ) ) )</body><body package="RuntimePackager">strippingSpec	"UIPainter new openOnClass: self andSelector: #strippingSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec}		#window:		#(#{UI.WindowSpec}			#label: 'Stripping'			#min: #(#{Core.Point} 40 20 )			#bounds: #(#{Graphics.Rectangle} 367 276 786 589 ) )		#component:		#(#{UI.SpecCollection}			#collection: #(				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 20 209 )					#label: 'Prestrip Class' )				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 20 242 )					#label: 'Prestrip Method' )				#(#{UI.LabelSpec}					#layout: #(#{Core.Point} 20 174 )					#label: 'Trace Level' )				#(#{UI.CheckBoxSpec}					#layout: #(#{Core.Point} 19 13 )					#name: #removeOrganization					#model: #removeOrganization					#label: 'Remove system organization' )				#(#{UI.CheckBoxSpec}					#layout: #(#{Core.Point} 19 35 )					#name: #packageExternalInterfaces					#model: #packageExternalInterfaces					#label: 'Package external interfaces' )				#(#{UI.CheckBoxSpec}					#layout: #(#{Core.Point} 19 57 )					#name: #mergeByteCodes					#model: #mergeByteCodes					#label: 'Merge method and block byte codes' )				#(#{UI.CheckBoxSpec}					#layout: #(#{Core.Point} 19 79 )					#name: #useRuntimeCompiledMethod					#model: #useRuntimeCompiledMethod					#label: 'Use compact compiled methods' )				#(#{UI.CheckBoxSpec}					#layout: #(#{Core.Point} 19 101 )					#name: #mergeLiterals					#model: #mergeLiterals					#label: 'Merge literals' )				#(#{UI.CheckBoxSpec}					#layout: #(#{Core.Point} 19 123 )					#name: #mergeMethods					#model: #mergeMethods					#label: 'Merge methods' )				#(#{UI.CheckBoxSpec}					#layout: #(#{Core.Point} 20 145 )					#name: #stripGlobals					#model: #stripGlobals					#label: 'Remove unreferenced globals' )				#(#{UI.RadioButtonSpec}					#layout: #(#{Core.Point} 148 176 )					#model: #traceLevel					#label: 'None'					#select: 0 )				#(#{UI.RadioButtonSpec}					#layout: #(#{Core.Point} 227 176 )					#model: #traceLevel					#label: 'Medium'					#select: 2 )				#(#{UI.RadioButtonSpec}					#layout: #(#{Core.Point} 321 176 )					#model: #traceLevel					#label: 'High'					#select: 4 )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.Rectangle} 148 209 367 230 )					#name: #prestripClass					#model: #prestripClass					#menu: #prestripClassMenu )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.Rectangle} 381 209 407 230 )					#model: #findPrestripClass					#label: '?'					#defaultable: true )				#(#{UI.InputFieldSpec}					#layout: #(#{Graphics.Rectangle} 148 242 367 263 )					#name: #prestripMethod					#model: #prestripMethod					#menu: #prestripMethodMenu )				#(#{UI.ActionButtonSpec}					#layout: #(#{Graphics.Rectangle} 381 242 407 263 )					#model: #findPrestripMethod					#label: '?'					#defaultable: true ) ) ) )</body><body package="RuntimePackager">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Runtime Packager Common Options' 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 720 450 1306 898 ) 			#flags: 12 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0684931 0 0.908665 0 0.238014 0 0.971897 ) 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.724315 0 0.906323 0 0.893836 0 0.969555 ) 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0256849 0 0.030445 0 0.962329 0 0.86651 ) 					#name: #notebook 					#model: #tabs 					#tabable: false 					#labels: #() ) ) ) )</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderOptionsEditor class</class-id> <category>resources</category><body package="RuntimePackager">errorNotifierMenu	"UIMenuEditor new openOnClass: self andSelector: #errorNotifierMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#label: 'Find class ...' ) ) #(1 ) #(#findErrorNotifierClass ) ) decodeAsLiteralArray</body><body package="RuntimePackager">imageDumperMenu	"UIMenuEditor new openOnClass: self andSelector: #imageDumperMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#label: 'Find class ...' ) ) #(1 ) #(#findImageDumperClass ) ) decodeAsLiteralArray</body><body package="RuntimePackager">mainMenu	"UIMenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#label: 'Help'				#submenu: #(#Menu #(						#(#MenuItem							#label: 'Overview' )						#(#MenuItem							#label: 'This Step' ) ) #(2 ) #(#overviewHelp #stepHelp ) ) ) ) #(1 ) #(nil ) ) decodeAsLiteralArray</body><body package="RuntimePackager">parcelsMenu	"MenuEditor new openOnClass: self andSelector: #parcelsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem}				#rawLabel: 'Update'				#value: #buildParcelList ) ) #(1 ) nil ) decodeAsLiteralArray</body><body package="RuntimePackager">prestripClassMenu	"UIMenuEditor new openOnClass: self andSelector: #prestripClassMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#label: 'Find class ...' ) ) #(1 ) #(#findPrestripClass ) ) decodeAsLiteralArray</body><body package="RuntimePackager">prestripMethodMenu	"UIMenuEditor new openOnClass: self andSelector: #prestripMethodMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#label: 'Find method ...' ) ) #(1 ) #(#findPrestripMethod ) ) decodeAsLiteralArray</body><body package="RuntimePackager">startupClassMenu	"UIMenuEditor new openOnClass: self andSelector: #startupClassMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#label: 'Find class ...' ) ) #(1 ) #(#findStartupClass ) ) decodeAsLiteralArray</body><body package="RuntimePackager">startupMethodMenu	"UIMenuEditor new openOnClass: self andSelector: #startupMethodMenu"	&lt;resource: #menu&gt;	^#(#Menu #(			#(#MenuItem				#label: 'Find method ...' ) ) #(1 ) #(#findStartupMethod ) ) decodeAsLiteralArray</body><body package="RuntimePackager">tabsMenu	"Tools.MenuEditor new openOnClass: self andSelector: #tabsMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Create 					#defaultString: 'Create' 					#catalogID: #labels ) 				#value: #basicsSpec ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Details 					#defaultString: 'Details' 					#catalogID: #labels ) 				#value: #detailsSpec ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Platforms 					#defaultString: 'Platforms' 					#catalogID: #labels ) 				#value: #platformsSpec ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Exceptions 					#defaultString: 'Exceptions' 					#catalogID: #labels ) 				#value: #exceptionsSpec ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Parcels 					#defaultString: 'Parcels' 					#catalogID: #labels ) 				#value: #parcelsSpec ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Stripping 					#defaultString: 'Stripping' 					#catalogID: #labels ) 				#value: #strippingSpec ) ) #(6 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester class</class-id> <category>resources</category><body package="RuntimePackager">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Help' 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Overview' 							#value: #overviewHelp ) 						#(#{UI.MenuItem} 							#rawLabel: 'This Step' 							#value: #stepHelp ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>RuntimePackager.RuntimeBuilderTester class</class-id> <category>interface specs</category><body package="RuntimePackager">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Runtime Application Tester' 			#min: #(#{Core.Point} 20 20 ) 			#bounds: #(#{Graphics.Rectangle} 700 525 1279 909 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.417962 0 0.0164384 ) 					#label: 'Test Controls' 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.176166 0 0.807365 0 0.810017 0 0.883853 ) 					#name: #testStatus 					#flags: 0 					#model: #testStatus 					#alignment: #center 					#isReadOnly: true 					#type: #text ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0362694 0 0.410959 0 0.948186 0 0.764384 ) 					#name: #dynamicItemsText 					#model: #dynamicItemsText 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 0 0.38342 0 0.348958 ) 					#label: 'Dynamic References' 					#style: #default ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.274611 0 0.939726 0 0.709845 15 0.939726 ) 					#name: #progressIndicator 					#flags: 28 					#isOpaque: true 					#model: #progressIndicator 					#style: #system 					#isReadOnly: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0552677 0 0.104167 0 0.229706 0 0.192708 ) 					#name: #saveImage 					#model: #saveImage 					#label: 'Save Image' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.405872 0 0.10411 0 0.580311 0 0.191781 ) 					#name: #beginTest 					#model: #beginTest 					#label: 'Begin Test' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.761658 0 0.104167 0 0.936097 0 0.192708 ) 					#name: #endTest 					#model: #endTest 					#label: 'End Test' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0552677 0 0.210938 0 0.393782 0 0.294271 ) 					#name: #acceptReferences 					#model: #acceptReferences 					#label: 'Accept Dynamic References' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.580311 0 0.203125 0 0.936097 0 0.291667 ) 					#name: #ignoreReferences 					#model: #ignoreReferences 					#label: 'Ignore Dynamic References' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.0359375 0 0.848958 0 0.15 0 0.942708 ) 					#name: #accept 					#model: #accept 					#label: 'OK' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.835937 0 0.848958 0 0.95 0 0.942708 ) 					#name: #cancel 					#model: #cancel 					#label: 'Cancel' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>DeploymentOptionsSystem</class-id> <category>command-line options</category><body package="RuntimePackager">errorLog: fileNameStream	"Set the location of the error log."	&lt;option: '-err'&gt;	| errorLogNames |	errorLogNames := CommandLineInterest argumentsFrom: fileNameStream.	errorLogNames do: [:each |		RuntimePackager.RuntimeManager errorLogPath: each].</body><body package="RuntimePackager">notifierClass: classNameStream	"Set the class to use for error notifiers."	&lt;option: '-notifier'&gt;	| classNames |	classNames := CommandLineInterest argumentsFrom: classNameStream.	classNames do: [:each | self hookNotifierClass: each].</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="RuntimePackager">toolsRuntimePackager	&lt;menuItem: 'Runtime Packager'		nameKey: nil		menu: #(#menuBar #tools)		position: 100.01&gt;	^(#{RuntimePackager.RuntimeBuilderUI} valueOrDo:		[Dialog warn: #RTPStripped &lt;&lt; #RuntimePackager &gt;&gt; 'Runtime Packager has been (partially) stripped, and so has no UI'.		^self ]) open</body></methods><initialize><class-id>RuntimePackager.RuntimeManager</class-id></initialize><initialize><class-id>RuntimePackager.RuntimeErrorNotifier</class-id></initialize><initialize><class-id>RuntimePackager.RuntimeEmergencyNotifier</class-id></initialize><initialize><class-id>RuntimePackager.RuntimeSurrogateManager</class-id></initialize><initialize><class-id>RuntimePackager.RuntimeBuilderUI</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ImageConfigurationSystem</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>allowParcelLoading allowFilein allowSettings allowExpressions useDefaultConfigFile allowDevelopment </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>UserApplication</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>Model</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>StandardSystemController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>locked </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ApplicationStandardSystemController</name><environment>UI</environment><super>UI.StandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventDispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>ErrorDumper</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dumpStream dumpDate dumpTime fileName </inst-vars><class-inst-vars>maximumStackEntriesDumped </class-inst-vars><imports></imports><category>RuntimePackager</category><attributes><package>ErrorNotifier</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>ErrorNotifier</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception context errorFilename </inst-vars><class-inst-vars>errorState errorProcess imageDumperClass errorFilename </class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>ErrorNotifier</package></attributes></class><class><name>ItemSelectionModule</name><environment>Tools</environment><super>Tools.ToolModule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>displayStringBlock iconBlock useMultiSelection useHorizontalScrollBar menuHolder menuPerformer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Modules</category><attributes><package>Tools-Modules</package></attributes></class><class><name>TreeSelectionModule</name><environment>Tools</environment><super>Tools.ItemSelectionModule</super><private>false</private><indexed-type>none</indexed-type><inst-vars>showRoot preExpandLevel treeHolder expandableRoots rootHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Modules</category><attributes><package>Tools-Modules</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>DeploymentOptionsSystem</name><environment>Smalltalk</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isRuntime startInRuntime allowCommandLineOptions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>System-Subsystems</package></attributes></class></st-source>