<?xml version="1.0"?><st-source><!-- Name: DLLCC-DecompilerNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: DLLCC-Decompiler contains code to correctly decompile external methods (C function calls) even if no source code is available).It stores the complete external declarations (c function definitions) in ExternalMethods for retrieving information which are required for complete and correct decompilation.DbIdentifier: bear73DbTrace: 491886DbUsername: aaugustinDbVersion: 8.2 - 2DevelopmentPrerequisites: #(#(#any 'DLLCC' '') #(#any 'AT Parser Compiler' ''))DialectVersion: VisualWorks 7.9PackageName: DLLCC-DecompilerParcel: #('DLLCC-Decompiler')ParcelName: DLLCC-DecompilerPrerequisiteDescriptions: #(#(#name 'DLLCC') #(#name 'AT Parser Compiler' #componentType #package #applicability #store))PrerequisiteParcels: #(#('DLLCC' ''))PrintStringCache: (8.2 - 2,aaugustin)Version: 8.2 - 2Post-Load Block: 	[:package | 	CType initializeKindsDict.	ExternalInterface recompileAllInterfaceMethods]Date: 1:50:02 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:02</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>CUndefinedType</name><environment>External</environment><super>External.CVoidType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>DLLCC-Decompiler</package></attributes></class><class><name>ExternalDecompiler</name><environment>Kernel</environment><super>Kernel.Decompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM- Decompiler</category><attributes><package>DLLCC-Decompiler</package></attributes></class><comment><class-id>Kernel.ExternalDecompiler</class-id><body>ExternalDecompiler is a Decompiler for ExternalMethods.</body></comment><class><name>ExternalMethod</name><environment>External</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>handle specifierFlags argumentKinds structArgSize structReturnSize datumClass resultType virtuals methodSelector external externalDeclaration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>DLLCC-Decompiler</package></attributes></class><comment><class-id>External.ExternalMethod</class-id><body>The class ExternalMethod represents a CompiledMethod that contains additional information required to call external code.  This external code currently conforms to standard C calling conventions supported by a platforms C compiler.  Instances of ExternalMethod are generated by optimized ExternalInterface subclasses.  These methods allow the run-time system to have quick access to information required to construct the external stack frame.NOTE: The layout of this class is well-known to the run-time system as the run-time system directly fetches information from instance variables.  Please do not modify the layout of its instance variables.Instance Variables:	handle	&lt;Integer | nil&gt; The address of the external code.  If the handle is nil the receiver is considered unlinked.	specifierFlags	&lt;Integer&gt; Each bit represents various information about external code such as calling convention (C or Pascal) and segmentation (near or far).  Note that the layout of this flag word is well-known to the run-time system and must not be changed.	argumentKinds &lt;Array of: Integer&gt; an array of integers where each integer indicates the 'kind' of argument.  The first element if the function return kind.	structArgSize	&lt;Integer&gt; The total size in bytes of all structures passed by value to the external code.	structReturnSize	&lt;Integer&gt; The toal size in bytes of a structure return by value.  This variabl is zero for functions that don't return a structure by value.	datumClass		&lt;CDatum&gt; The class used to create instances of the receiver's return type.	resultType	&lt;CType&gt; The type object that represents the return type of the external code.	virtuals		&lt;Array | nil&gt; This variable is nil in a normal interface class an an Array of Class/Handle pairs for a virtual class.  Each Class/Handle pair is used to map an external code address (the handle) with the virtual subclass.	methodSelector	&lt;Symbol&gt; The selector in the receiver's mclass associated with the ExternalMethod.  It was necessary to store the selector in an ExternalMethod because it is not always possible for the run-time system to extract the selector during unlinked call operations.  This selector is used to re-try external calls during an unlinked call address mapping."	external	&lt;Symbol&gt; The external procedure name the ExternalMethod calls.  This name is used when performing an address look-up.	externalDeclaration	&lt;ExternalProcedure&gt;		holds the external procedure instance which is used to decompile external methods,											even if no source code is available.Class Variables:	ExternalObjectNotFoundSignal	&lt;Signal&gt; the signal that is raised if the receiver's external entry-point could not be resolved.</body></comment><shared-variable><name>CUndefined</name><environment>External.CUndefinedType</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC-Decompiler</package></attributes></shared-variable><shared-variable><name>KindsAndTypes</name><environment>External.CType</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>DLLCC-Decompiler</package></attributes></shared-variable><methods><class-id>External.CUndefinedType</class-id> <category>accessing</category><body package="DLLCC-Decompiler">basicComment	^comment</body><body package="DLLCC-Decompiler">comment	^comment isNil ifTrue: ['an undefined type'] ifFalse: [comment]</body><body package="DLLCC-Decompiler">comment: aString 	comment := aString</body></methods><methods><class-id>External.CUndefinedType</class-id> <category>printing</category><body package="DLLCC-Decompiler">basicTypeString	^'undefined'</body><body package="DLLCC-Decompiler">printOn: aStream 	aStream nextPutAll: '/* ' , self comment , ' */ ' , self basicTypeString</body><body package="DLLCC-Decompiler">printOn: aStream forName: varName indent: numTabs 	self printOn: aStream.	self 		printName: varName		on: aStream		wrap: false</body><body package="DLLCC-Decompiler">storeOn: aStream 	aStream		store: self class;		nextPutAll: ' newComment: ' , self basicComment printString</body></methods><methods><class-id>External.CUndefinedType</class-id> <category>testing</category><body package="DLLCC-Decompiler">isVoid	"Answer true if the receiver is a void type."	^false</body></methods><methods><class-id>External.CUndefinedType</class-id> <category>private-accessing</category><body package="DLLCC-Decompiler">kind	"Answer a unique identifier of the receiver's type.  Answer an unused type so it will cause an error on trying 	 to perform a callout with parameters of this type will fail"	^255</body></methods><methods><class-id>External.CUndefinedType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKindsTo: aDict 	self addKind: [CUndefined] to: aDict</body></methods><methods><class-id>External.CUndefinedType class</class-id> <category>instance creation</category><body package="DLLCC-Decompiler">new	^self basicNew</body><body package="DLLCC-Decompiler">newComment: aString 	"Create a new instance which contains &lt;aString&gt; as a Comment"	^(self basicNew)		comment: aString;		yourself</body></methods><methods><class-id>External.CUndefinedType class</class-id> <category>constant access</category><body package="DLLCC-Decompiler">undefined	^CUndefined</body><body package="DLLCC-Decompiler">void	"override the implementation in CVoidType so we don't get a CVoidType instance as a result"	^CUndefined</body></methods><methods><class-id>External.CUndefinedType class</class-id> <category>private access</category><body package="DLLCC-Decompiler">undefinedKind	"Answer an integer representing the receiver's kind -- used by the VM, do not change!	 This is tricky, since 255 is not understood by the VM which will intendedly cause 	 an error when trying to call a function with such parameters."	^255</body></methods><methods><class-id>External.CUndefinedType class</class-id> <category>class initialization</category><body package="DLLCC-Decompiler">initialize	"self initialize."	CUndefined := self				newComment: (#AnUndefinedType &lt;&lt; #com &gt;&gt; 'An undefined type') asString</body></methods><methods><class-id>Kernel.ExternalDecompiler</class-id> <category>private</category><body package="DLLCC-Decompiler">attributeMessagesFor: aBlock method: aMethod	"return the attribute messages for the given method, including the external attribute message	 of external methods"	^aMethod externalAttributeMessages</body><body package="DLLCC-Decompiler">blockFor: aClass method: aMethod builder: aBuilder	| block |	block := self				decompileMethod: aMethod				builder: aBuilder				instVars: aClass allInstVarNames				localVars: OrderedCollection new				copiedVars: #()				tempCount: 0 asValue.	^(aMethod isExternalMethod and: [aMethod primitiveNumber isNil]) ifTrue: [self transformSlowExternalMethod: block for: aMethod] ifFalse: [block]</body><body package="DLLCC-Decompiler">renumber: list startingWith: savedTC	1 to: list size do: [:i | (list at: i) variable name: 't' , (savedTC + i) printString].	"for External Methods using a primitive, we can update parameter names here. For non-primitive ones, 	 the parameter ordering may differ and has to be done later"	method isExternalMethod		ifTrue: 			[(list at: method selector numArgs + 1) variable name: '_errorCode'.			method primitiveNumber notNil				ifTrue: 					[method argNamesFromExternal						ifNil: [self updateExternalArgsIn: method fromVariables: list]						ifNotNil: [:names | names keysAndValuesDo: [:index :name | (list at: index) variable name: name]]]]</body></methods><methods><class-id>Kernel.ExternalDecompiler</class-id> <category>private decompiling slow calls</category><body package="DLLCC-Decompiler">primitiveFailCodeFrom: block	| newStatements newSequence temps |	builder := ProgramNodeBuilder new.	statements := block body statements.	newStatements := statements copyFrom: 2 to: statements size.	temps := block body temporaries				select: [:each | each name asSymbol ~= #_errorCode].	newSequence := builder newSequenceTemporaries: temps				statements: newStatements.	^builder newBlockArguments: block arguments body: newSequence</body><body package="DLLCC-Decompiler">renameExternalParamVarsInBlock: block names: external	"This method is used to rename param vars in external methods which don't use a primitive. This is a little more complex	 because the parameter order of the external function may differ from the method's one"	| messageNode sequence newStatements vars |	messageNode := block body statements first.	(messageNode isMessage and: [messageNode selector = #handle:do:]) ifFalse: [		^ self error: 'ByteCode has changed - decompiler needs to be adapted' ].	sequence := messageNode arguments last body.	statements := sequence statements.	statements last isReturn ifFalse: [ 		^ self error:  'ByteCode has changed - decompiler needs to be adapted' ].	newStatements := statements copyFrom: 1 to: statements size -1.	vars :=  newStatements collect: [:statement|		(statement isMessage and: [ statement selector = #at:put: ]) ifFalse: [ 					^ self error:  'ByteCode has changed - decompiler needs to be adapted' ].		statement arguments last].	external argumentNames 		ifNil: [ external argumentNames: (vars collect: [:each | each name ])]		ifNotNil: [:names | vars keysAndValuesDo: [:index :var | var name: (names at: index)]].</body><body package="DLLCC-Decompiler">transformSlowExternalMethod: block for: aMethod	self renameExternalParamVarsInBlock: block names: aMethod externalDeclaration. 	^ self primitiveFailCodeFrom: block</body><body package="DLLCC-Decompiler">updateExternalArgsIn: aMethod fromVariables: vars	aMethod externalArgNames: ((vars collect: [:var | var name]) copyFrom: 1 to: aMethod selector numArgs)</body></methods><methods><class-id>Kernel.ExternalDecompiler</class-id> <category>private-initialize-release</category><body package="DLLCC-Decompiler">decompile: aSelector in: aClass method: aMethod using: aBuilder	| block key attributes |	(key := aMethod sourcePointer) == SourceFileManager hiddenSourceKey		ifTrue: 			[^(ProgramNode new)				sourcePosition: (SourceFileManager default stringAt: key ifAbsent: []);				yourself].	block := self blockFor: aClass method: aMethod builder: aBuilder.	attributes := self attributeMessagesFor: block method: aMethod.	^builder		newMethodSelector: aSelector		primitive: nil		errorCode: primErrorCode		block: block		attributeMessages: attributes</body></methods><methods><class-id>External.ExternalMethod</class-id> <category>initialize-release</category><body package="DLLCC-Decompiler">for: anExternalAssociation 	"Initialize the receiver to be a method for the given external and the given method selector.  Answer the receiver."	| externalType anExternal |	external := anExternalAssociation value name.	anExternal := anExternalAssociation value.	anExternal isNil ifTrue: [^self].	externalDeclaration := ExternalProcedure name: anExternal name				procedureType: anExternal type.	handle := anExternal referentAddress.	externalType := anExternal type.	specifierFlags := externalType specifierCallFlags.	argumentKinds := externalType argumentKinds.	structArgSize := externalType structArgumentSize.	resultType := externalType resultType.	datumClass := resultType defaultContainerClass.	self computeStructReturnSize.	virtuals := mclass instanceBehavior isVirtual ifTrue: [#()] ifFalse: [nil].</body></methods><methods><class-id>External.ExternalMethod</class-id> <category>decompilation</category><body package="DLLCC-Decompiler">argNamesFromExternal	"Try to extract the argument names from the external declaration"	| argNames |	^(self externalDeclaration isNil 		or: [(argNames := externalDeclaration argumentNames) isNil]) 			ifTrue: [nil]			ifFalse: [argNames]</body><body package="DLLCC-Decompiler">externalArgNames: names 	"Return the extenal declaration. If is does not exist, recreate it by using the information 	 stored in the external method"	^ self externalDeclaration		argumentNames: names;		yourself</body><body package="DLLCC-Decompiler">externalAttributeMessages	"return the external attribute message with is used for decompiling external methods"	"removed code which updated the argument names"	| externalMessage |	externalMessage := Message selector: #C: argument: self externalDeclaration.	^self attributeMessages		ifNil: [Array with: externalMessage]		ifNotNil: [:messages | messages copyWith: externalMessage]</body><body package="DLLCC-Decompiler">externalDeclaration	^externalDeclaration		ifNil: 			[externalDeclaration := ExternalProcedure						name: external						resultType: resultType						argumentKinds: (argumentKinds copyFrom: 2 to: argumentKinds size) asArray						specifierFlags: specifierFlags]</body></methods><methods><class-id>Kernel.SimpleMessageNode</class-id> <category>testing</category><body package="DLLCC-Decompiler">isMessage	^ true</body></methods><methods><class-id>External.ExternalProcedure class</class-id> <category>instance creation</category><body package="DLLCC-Decompiler">name: aName procedureType: procType 	^(self new)		name: aName;		type: procType;		yourself</body><body package="DLLCC-Decompiler">name: aName resultType: resultType argumentKinds: kinds specifierFlags: specifierFlags 	"We have to be careful here, since we can't recreate CStructure Types. In such a case return an UndefinedType"	| argTypes procType |	argTypes := kinds collect: 					[:kind | 					[CType typeForKind: kind ifAbsent: [^nil]] on: Error						do: [:ex | ex return: (CUndefinedType newComment: ex messageText)]].	procType := (CProcedureType 				resultType: resultType				argumentTypes: argTypes				argumentNames: nil)				specifierCallFlags: specifierFlags;				yourself.	^self name: aName procedureType: procType</body><body package="DLLCC-Decompiler">name: aName resultType: resultType argumentKinds: kinds specifierFlags: specifierFlags index: index 	^(self 		name: aName		resultType: resultType		argumentKinds: kinds		specifierFlags: specifierFlags)		index: index;		yourself</body></methods><methods><class-id>External.ExternalProcedure</class-id> <category>accessing</category><body package="DLLCC-Decompiler">argumentNames	^ type isNil ifTrue: [nil] ifFalse: [type argumentNames]</body><body package="DLLCC-Decompiler">argumentNames: names		type isNil		ifTrue: []		ifFalse: [type argumentNames: names]</body><body package="DLLCC-Decompiler">index	"return the vtable index"	^ handle size = 1 		ifTrue: [ handle first ]		ifFalse: [ self error: #IndexNotAvailable &lt;&lt; #com &gt;&gt; 'The index of this method is not available' ]</body><body package="DLLCC-Decompiler">index: anIndex	"set the vtable index"	self handle: (ByteArray with: anIndex).</body></methods><methods><class-id>External.CCompositeType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKindsTo: kindsDict 	kindsDict at: 17		put: [self error: #NotAComposite &lt;&lt; #com &gt;&gt;'Can''t recreate a composite from kind']</body></methods><methods><class-id>External.COopType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKindsTo: kindsDict 	kindsDict at: 15 put: [self new referentClass: Object; yourself]</body></methods><methods><class-id>External.CIntegerType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKindsTo: aDict 	self		addKind: [BooleanChar] to: aDict;		addKind: [BooleanInt] to: aDict;		addKind: [BooleanLong] to: aDict;		addKind: [BooleanLongLong] to: aDict;		addKind: [BooleanShort] to: aDict;		addKind: [HResultLong] to: aDict;		addKind: [SignedChar] to: aDict;		addKind: [SignedShort] to: aDict;		addKind: [SignedInt] to: aDict;		addKind: [SignedLong] to: aDict;		addKind: [SignedLongLong] to: aDict;		addKind: [SyscallLong] to: aDict;		addKind: [UnsignedChar] to: aDict;		addKind: [UnsignedShort] to: aDict;		addKind: [UnsignedInt] to: aDict;		addKind: [UnsignedLong] to: aDict;		addKind: [UnsignedLongLong] to: aDict;		addKind: [WincallLong] to: aDict</body></methods><methods><class-id>Kernel.ProgramNode</class-id> <category>testing</category><body package="DLLCC-Decompiler">isAssignment	^ false</body><body package="DLLCC-Decompiler">isMessage	^ false</body><body package="DLLCC-Decompiler">isReturn	^ false</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>compilation</category><body package="DLLCC-Decompiler">decompilerClass	"return the compiler class used for the receiver"	^ExternalDecompiler</body></methods><methods><class-id>External.ExternalInterface class</class-id> <category>generating methods</category><body package="DLLCC-Decompiler">recompileAllInterfaceMethods	"Recompile all methods in the receiver.  Answer the receiver."	self allSubclassesDo: [:each | each recompileExternalMethods].</body><body package="DLLCC-Decompiler">recompileExternalMethods	"Recompile all external methods in the receiver.  Answer the receiver."	| extClass |	extClass := self externalMethodClass.	self methodDictionary keysAndValuesDo: [:aSelector :method |			method class = extClass ifTrue: [					self recompile: aSelector]]</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>source code management</category><body package="DLLCC-Decompiler">getSourceIfAbsent: aBlock 	"Answer the source code for the receiver.  If the source is not available return the result 	 of the given block "	^self subclassResponsibility</body></methods><methods><class-id>Kernel.AssignmentNode</class-id> <category>testing</category><body package="DLLCC-Decompiler">isAssignment	^ true</body></methods><methods><class-id>External.CType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKind: aKindBlock to: aDict	aDict at: aKindBlock value kind put: aKindBlock.</body><body package="DLLCC-Decompiler">addKindsTo: kindsDict	"Add the the translations for the kinds defined by the instances of this specific subclass.	 The default behavior is to do nothing."</body><body package="DLLCC-Decompiler">initializeKindsDict	"Initialize the 'kinds to types translation dictionary used for decompiling external methods."	"self initializeKindsDict"	KindsAndTypes := IdentityDictionary new.	self allSubclassesDo: [:class | class addKindsTo: KindsAndTypes]</body><body package="DLLCC-Decompiler">typeForKind: aKind ifAbsent: aBlock 	"Get the specific type instance that matches the given kind value.	 Answer the result of the given block if there is no value defined for &lt;aKind&gt;"	KindsAndTypes isNil ifTrue: [self initializeKindsDict].	^(KindsAndTypes at: aKind ifAbsent: [aBlock value]) value</body></methods><methods><class-id>External.CVoidType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKindsTo: aDict 	self addKind: [Void] to: aDict</body></methods><methods><class-id>External.CPointerType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKindsTo: kindsDict 	kindsDict		at: 13 put: [self defaultPointer];		at: 12 put: [self farPointer];		at: 11 put: [self nearPointer];		at: 19 put: [self defaultPointer beOopRef]</body></methods><methods><class-id>Kernel.ReturnNode</class-id> <category>testing</category><body package="DLLCC-Decompiler">isReturn	^ true</body></methods><methods><class-id>External.CExpressionParser</class-id> <category>types-syntax</category><body package="DLLCC-Decompiler">typeSpecifier =	"Place on top of the parse stack a type specifier, one of enum, struct, union, typedef, or scalar type. Fail if a valid type specifier is not present on the input token stream."	enum	| struct	| union	| #void [CVoidType void]	| #undefined [CUndefinedType undefined]	| #float [CLimitedPrecisionRealType float]	| #double [CLimitedPrecisionRealType double]	| #extended [CLimitedPrecisionRealType extended]	| #unsigned		((#char | #'__int8') [CIntegerType unsignedChar] 		| (#short | #'__int16') ((#int | ) [CIntegerType unsignedShort]) 		| #long 			( #long (#int | ) [CIntegerType unsignedLongLong] 				| (#int | ) [CIntegerType unsignedLong]) 		| #'__int64' [CIntegerType unsignedLongLong] 		| (#int | #'__int32' | ) [CIntegerType unsignedInt])	| #signed		((#char | #'__int8') [CIntegerType signedChar] 		| (#short | #'__int16') ((#int | ) [CIntegerType signedShort]) 		| #long 			(#long (#int | ) [CIntegerType signedLongLong] 				| (#int | ) [CIntegerType signedLong]) 		| #'__int64' [CIntegerType signedLongLong] 		| (#int | #'__int32' | ) [CIntegerType signedInt])	| (#'_bool' | #'__bool')		((#char | #'__int8') [CIntegerType booleanChar] 		| (#short | #'__int16') ((#int | ) [CIntegerType booleanShort]) 		| #long 			(#long [CIntegerType booleanLongLong]				| (#int | ) [CIntegerType booleanLong] ) 		| #'__int64' [CIntegerType booleanLongLong] 		| (#int | #'__int32' | ) [CIntegerType booleanInt])	| (#'_hresult' | #'__hresult') (#long [CIntegerType hResultLong])	| (#'_syscall' | #'__syscall') (#unsigned #long [CIntegerType syscallLong])	| (#'_wincall' | #'__wincall') (#unsigned #long [CIntegerType wincallLong])	| (#char | #'__int8') [CIntegerType char] 	| (#short | #'__int16') ((#int | ) [CIntegerType short]) 	| #long 		(#unsigned (#double [CLimitedPrecisionRealType longDouble]			| #long (#int | ) [CIntegerType unsignedLongLong] 			| (#int | ) [CIntegerType unsignedLong] )		| (#signed | ) (#double [CLimitedPrecisionRealType longDouble]			| #long  (#int | ) [CIntegerType signedLongLong] 			| (#int | ) [CIntegerType signedLong] ))	| (#int | #'__int32') [CIntegerType int] 	| #'__int64' [CIntegerType signedLongLong] 	| #'_segment' [CIntegerType short]	| #'_oop' ( $( word $) | [#Object]) [makeOopClass:]	| typedefName</body></methods><methods><class-id>External.CLimitedPrecisionRealType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKindsTo: aDict 	self		addKind: [DoubleType] to: aDict;		addKind: [ExtendedType] to: aDict;		addKind: [FloatType] to: aDict;		addKind: [self double] to: aDict</body></methods><methods><class-id>External.CArrayType class</class-id> <category>types accessing</category><body package="DLLCC-Decompiler">addKindsTo: kindsDict 	kindsDict		at: 22 put: [self new];		at: 21 put: [self new beFar];		at: 20 put: [self new beNear];		at: 19 put: [self new beOopRef]</body></methods><methods><class-id>External.CProcedureType</class-id> <category>accessing</category><body package="DLLCC-Decompiler">specifierCallFlags: flags 	"rebuild the procedure's specifierCallFlags using the given flags."	(flags bitAnd: 16r1) ~= 0 ifTrue: [self beFar].	(flags bitAnd: 16r2) ~= 0 ifTrue: [self beCdecl].	(flags bitAnd: 16r4) ~= 0 ifTrue: [self bePascal].	(flags bitAnd: 16r8) ~= 0 ifTrue: [self beLongcomp].	(flags bitAnd: 16r10) == 0 ifTrue: [self beNoCallback].	(flags bitAnd: 16r20) ~= 0 ifTrue: [self beStdcall].	(flags bitAnd: 16r40) ~= 0 ifTrue: [self beThreaded]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>decompilation</category><body package="DLLCC-Decompiler">externalAttributeMessages	"return the attribute messages including the external declaration attribute message"	^self attributeMessages</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>source code management</category><body package="DLLCC-Decompiler">getSourceIfAbsent: aBlock 	"Answer the source code for the receiver.  Answer the result of the given block 	 if this method has no stored source."	| source |	^(source := self getSource) isNil ifTrue: [aBlock value] ifFalse: [source]</body></methods><initialize><class-id>External.CUndefinedType</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ProgramNode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourcePosition comment compilerHints blockIndex mapEntry returnMapEntry </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CExpressionParser</name><environment>External</environment><super>External.CParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-CParsing</category><attributes><package>DLLCC</package></attributes></class><class><name>CVoidType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>AssignmentNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable value leftArrow assignToArgOK </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>ReturnNode</name><environment>Kernel</environment><super>Kernel.StatementNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>ExternalProcedure</name><environment>External</environment><super>External.ExternalObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>SimpleMessageNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector arguments precedence </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>CProcedureType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>argumentNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Decompiler</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder instVars allParameters localVars copiedVars tempCount stack statements limit primitive primErrorCode lastPc exit lastJumpPc hasValue loopDepth lastAssignment lastAssignVar lastAssignPc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>System-Compiler-Public Access</category><attributes><package>System-Compiler-Public Access</package></attributes></class></st-source>