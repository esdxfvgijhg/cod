<?xml version="1.0"?><st-source><!-- Name: Com- Ole DevelopmentNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.DbIdentifier: bear73DbTrace: 500174DbUsername: alexDbVersion: 8.3 - 4DevelopmentPrerequisites: #(#(#any 'Com- List Choice Dialogs' '') #(#any 'Com- Event-Enabled Application Extensions' '') #(#any 'Com- Ole' '') #(#any 'Com- CodeAnnotations' '') #(#any 'Com- ExtensionsToBase' '') #(#any 'Com- External Data Development Enhancements' '') #(#any 'Com- Interface Adaptors' '') #(#any 'Com- Ole Pools' '') #(#any 'Com- System Configuration Services' '') #(#any 'Com- Win32' '') #(#any 'Tools-Settings' '') #(#any 'Tools-Settings-VW' '') #(#any 'DLLCC' ''))DialectVersion: VisualWorks 7.9HideSource: falsePackageName: Com- Ole DevelopmentParcel: #('ComOleDevelopment')ParcelName: Com- Ole DevelopmentPrerequisiteDescriptions: #(#(#name 'Com- List Choice Dialogs') #(#name 'Com- Event-Enabled Application Extensions') #(#name 'Com- Ole') #(#name 'Com- CodeAnnotations' #componentType #package) #(#name 'Com- ExtensionsToBase' #componentType #package) #(#name 'Com- External Data Development Enhancements' #componentType #package) #(#name 'Com- Interface Adaptors' #componentType #package) #(#name 'Com- Ole Pools' #componentType #package) #(#name 'Com- System Configuration Services' #componentType #package) #(#name 'Com- Win32' #componentType #package) #(#name 'Tools-Settings' #componentType #package) #(#name 'Tools-Settings-VW' #componentType #package) #(#name 'DLLCC' #componentType #package #applicability #store))PrerequisiteParcels: #(#('Com- List Choice Dialogs' '') #('Com- Event-Enabled Application Extensions' '') #('Com- Ole' '') #('Com- CodeAnnotations' '') #('Com- ExtensionsToBase' '') #('Com- External Data Development Enhancements' '') #('Com- Interface Adaptors' '') #('Com- Ole Pools' '') #('Com- System Configuration Services' '') #('Com- Win32' '') #('Tools-Settings' '') #('Tools-Settings-VW' ''))PrintStringCache: (8.3 - 4,alex)SaveSource: trueVersion: 8.3 - 4Post-Load Block: 	[ :pkg |  External.COMTraceManager postLoadActionFor: pkg.]Pre-Unload Block: 	[:t1 |	]Date: 1:50:04 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:04</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>COMInterfaceClassGenerationWizard</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetPackage interfaceName interfaceSuperclass tabs vtableSignatureText myDeclarations selectedTypeRow ownTypes selectedInterfaceRow interfaceDefinitions oldVtable generateInterfaceImplementationClass generateInterfacePointerClass targetNamespace statusText codeGenerationErrors codeGenerationWarnings subCanvasBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>Tools.COMInterfaceClassGenerationWizard</class-id><body>COMInterfaceClassGenerationWizard is a UI to simplify generation of interface classes. The app knows what has to be defined in which place and queries required information.  Instance Variables:	codeGenerationErrors			&lt;BrowserEnvironment&gt;	Contains methods in which code generation problems appeared	codeGenerationWarnings		&lt;BrowserEnvironment&gt;	Contains methods in which warnings were generated	generateInterfaceImplementationClass	&lt;ValueModel&gt;		should an InterfaceImplementationClass be generated?	generateInterfacePointerClass	&lt;ValueModel&gt;			should an interfacePointerClass be generated?	interfaceDefinitions				&lt;SelectionInList&gt;		interface names and their assigned IID	interfaceName					&lt;ValueModel&gt;			the name of the imported interface	interfaceSuperclass			&lt;ValueModel&gt;			the super interface class	myDeclarations				&lt;SelectionInList&gt;		list of declarations required to compile the VTable but do not exist in the system	oldVtable						&lt;ExternalDeclaration&gt;	previous compiled vtable	ownTypes					&lt;ExternalDictionary&gt;	C types which do not currently exist in the System	selectedInterfaceRow			&lt;ValueModel&gt;			the selected line in the interfaces tab	selectedTypeRow				&lt;ValueModel&gt;			selected line in the Declarations tab	statusText					&lt;ValueModel&gt;			the status line	subCanvasBuilder				&lt;UIBuilder&gt;			the UIBuilder for the currently displayed subcanvas. Used to access widgets in it.	tabs							&lt;SelectionInList&gt;		the tabs	targetNamespace				&lt;ValueModel&gt;			the namespace in which the code will be generated	targetPackage				&lt;ValueModel&gt;			the package in which the code will be generated	vtableSignatureText			&lt;ValueModel&gt;			the source code of the vtable</body></comment><class><name>COMInterfaceTraceAdaptor</name><environment>External</environment><super>External.COMInterfaceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfaceBinding </inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><class><name>IUnknownTraceAdaptor</name><environment>External</environment><super>External.COMInterfaceTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>assumeHRESULTReturnValues </inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IUnknownTraceAdaptor</class-id><body>IUnknownTraceAdaptor provides interface function tracing for operations in the IUnknown interface.</body></comment><class><name>IPersistTraceAdaptor</name><environment>External</environment><super>External.IUnknownTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IPersistTraceAdaptor</class-id><body>IPersisteTraceAdaptor provides interface function tracing for operations in the IPersist interface.</body></comment><class><name>COMTraceManager</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMConstants.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMTraceManager</class-id><body>The COMTraceManager class provides development tracing facilities to facilitate debugging certain kinds of problems encountered during COM development (e.g., callbacks from external clients to interfaces implemented in Smalltalk).  COMTraceManager is an abstract class which provides its facilities through class messages.  The trace manager is typically installed in a development image.  By default, it is not present and tracing is disabled in an application execution image.  However, the trace manager can be installed in a deliverable application if desired.  In this case, tracing parameters must be configured suitably by the application (e.g., dump the trace to a specified file).COM trace support is only enabled when the COMTraceManager is installed by registering it with the COMSessionManager:	COMTraceManager installTraceSupport.When the trace manage is installed in the session, trace adaptors are configured on interfaces to enable the user to dynamically enable and disable tracing feedback in a variety of ways.To completely disable tracing support and eliminate any overhead or interference potentially caused by the presence of interface trace adaptors during interface function class, remove the registration of the COMTraceManager with the COMSessionManager:	COMTraceManager uninstallTraceSupport.The COMTraceViewer is the primary user interface tool for viewing interface function trace feedback and configuring tracing control options.	COMTraceViewer open.</body></comment><class><name>IMallocTraceAdaptor</name><environment>External</environment><super>External.IUnknownTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IMallocTraceAdaptor</class-id><body>IMallocTraceAdaptor provides interface function tracing for operations in the IMalloc interface.</body></comment><class><name>COMInterfaceWrapperClassGenerator</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfaceName typeDefinitionClassName interfaceSignatureType vtableDescription functionMap interfaceSpec targetNamespace superinterfaceClass </inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMInterfaceWrapperClassGenerator</class-id><body>COMInterfaceWrapperClassGenerator is the abstract superclass of tools which are used to generate Smalltalk source files for COM interface classes.  The interface class which are generated are a prototype which generally require additional hand customization, notably to review the argument marshalling in interface binding classes, but the prototype class generates the majority of the boilerplate text in interface class methods for you and frequently is able to make an adequate guess at the proper code to generate based on a variety of heristics about COM types.The interface class generators require that you have defined all types referenced by the interface functions and the VTable structure for the interface using the DLL-C Connect facilities of VisualWorks.  You must have compiled the interface types using the standard Microsoft interface declaration macros.  The interface class generation logic requires the existence of a CCompositeType structure definition for the interface VTable that describes the VTable layout and method protocol type signatures.  Currently this builder only supports C-based (as opposed to C++-based) interface declarations (i.e., the VTable function methods must be defined with the leading This argument which is implicit in a C++ specification of the function).</body></comment><class><name>COMInterfaceClassGenerator</name><environment>External</environment><super>External.COMInterfaceWrapperClassGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMInterfaceClassGenerator</class-id><body>The COMInterfaceClassGenerator class is used to generate a prototype definition of a COMInterface interface reference class from a VTable structure definition defined using the DLL-C Connect facilities.  The interface class that is generated is a prototype which implements a simple first guess at the desired methods to support in a COMInterface wrapper class.  Manual modifications are generally required to complete the implementation with a desired set of convenience methods and to provide suitable keyword names for the message selectors.The methods generated in a COMInterface class provide a simple first pass at defining a basic set of messages to invoke all functions in the interface, with result values suitably returned by the message where apropriate.  However, manual review of the protocol is necessary to install suitable argument name keywords in the message selector.  (While it would be possible to generate the prototype message selector to use the actual argument names, this is not done on the grounds that C argument names are generally so unpleasant relative to normal Smalltalk naming conventions that you would end up having to change all of them anyway, in which case we should just use a generic default.)  You will frequently also wish to add convenience methods to the interface class, typically to provide messages which use reasonable defaults or commonly used constants for certain argument values that will make it easier for a Smalltalk programmer to invoke the function for common cases.You will generally want to review all methods which are flagged in the prototype class as containing additional arguments which may be OUT values, since the automatic method generation cannot determine how you would like to return the information when there is more than one OUT value obtained from the function.  Arguments such as structure pointers which are believed to be IN/OUT values should also be checked to verify consistency with the semantic specifications of the interface on who allocates and owns structure buffers.   Remember that the prototype class is generated using only the information available from the VTable structure, which is not sufficient to correctly generate the appropriate code in all cases.  Structure values usually need review, as it is not possible to distinguish between an IN argument provided by the Smalltalk caller and an IN/OUT argument which requires a structure buffer to be allocated by the function method.  The same is true for GUID return values obtained as OUT argument values from an interface function.  Certain string arguments and array buffer arguments are also problematic and should be reviewed carefully.To generate a prototype interface class for a specific interface evaluate:	COMInterfaceClassGenerator generateInterfacePrototypeFor: #IAllDataTypesDispTo generate a prototype interface class for a user-specified interface evaluate:	COMInterfaceClassGenerator generateInterfacePrototype</body></comment><class><name>COMResourceViewer</name><environment>Tools</environment><super>UI.EventEnabledApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exportedInterfacesListModel exportedObjectsListModel </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>Tools.COMResourceViewer</class-id><body>COMResourceViewer is an abstract superclass for COM resource browsers.</body></comment><class><name>COMStorageElementInterfaceTraceAdaptor</name><environment>External</environment><super>External.IUnknownTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMStorageElementInterfaceTraceAdaptor</class-id><body>COMStorageElementInterfaceTraceAdaptor is the abstract superclass for COM storage interface trace adaptors.</body></comment><class><name>IStorageTraceAdaptor</name><environment>External</environment><super>External.COMStorageElementInterfaceTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IStorageTraceAdaptor</class-id><body>IStorageTraceAdaptor provides interface function tracing for operations in the IStorage interface.</body></comment><class><name>TypeDefinitionString</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name typeString isPrimary </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.TypeDefinitionString</class-id><body>TypeDefinitionString is used to store C type definitions in a textual form. They are split into name and definition to ensure the name can not be changed by modifying the definition.They also contain a primary flag to be able to mark types which are directly referenced in a VTable definitionInstance Variables	isPrimary	&lt;Boolean&gt;			flag which determines whether the type directly referenced in the edited VTable	name		&lt;Symbol&gt;			the name of the type	typeString	&lt;String&gt;			the string defining the type. 									Example: For "typedef struct x {int x;int y;} MyStruct" the the typeString would only contain "struct x {int x;int y;}"</body></comment><class><name>COMInterfaceImplementationClassGenerator</name><environment>External</environment><super>External.COMInterfaceWrapperClassGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><class><name>COMFunctionTraceContext</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>functionSelector isTraceEnabled callerType callerReportsFunctionEntry arguments argumentNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMFunctionTraceContext</class-id><body>A COMFunctionTraceContext is used by an interface trace adaptor to collect the information needed to trace an invocation of an interface function.</body></comment><class><name>IStreamTraceAdaptor</name><environment>External</environment><super>External.COMStorageElementInterfaceTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IStreamTraceAdaptor</class-id><body>IStreamTraceAdaptor provides interface function tracing for operations in the IStream interface.</body></comment><class><name>COMTraceViewer</name><environment>Tools</environment><super>UI.EventEnabledApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>windowTitle fileName tracingInstalledForThisView traceEnabledHolder traceCalloutHolder traceCallinHolder traceInternalCallsHolder traceLog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>Tools.COMTraceViewer</class-id><body>The COMTraceViewer allows you to control COM trace settings and view COM trace logging results.To open evaluate:	COMTraceViewer open</body></comment><class><name>IParseDisplayNameTraceAdaptor</name><environment>External</environment><super>External.IUnknownTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IParseDisplayNameTraceAdaptor</class-id><body>IParseDisplayNameTraceAdaptor provides interface function tracing for operations in the IParseDisplayName interface.</body></comment><class><name>COMInterfacePointerClassGenerator</name><environment>External</environment><super>External.COMInterfaceWrapperClassGenerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><class><name>ComSettingsPage</name><environment>Tools</environment><super>Tools.ModularSettingsPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole Development</package></attributes></class><class><name>COMTraceOptionsEditor</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>Tools.COMTraceOptionsEditor</class-id><body>The COMTraceOptionsEditor provides UI services to the COMTraceViewer for editing COM interface trace options.</body></comment><class><name>IEnumTraceAdaptor</name><environment>External</environment><super>External.IUnknownTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IEnumTraceAdaptor</class-id><body>IEnumTraceAdaptor provides interface function tracing for operations in the IEnum family of interfaces.</body></comment><class><name>COMBasicInterfaceTraceAdaptor</name><environment>External</environment><super>External.COMInterfaceTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMBasicInterfaceTraceAdaptor</class-id><body>COMBasicInterfaceTraceAdaptor provides minimal default interface function tracing for operations in a COM interface.  The interface may not conform to the standard COM interface convention that every interface function returns an HRESULT value, so no assumptions are made about the return type of an interface function and only function entry and arguments are logged.</body></comment><class><name>COMArgumentDescription</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMArgumentDescription</class-id><body>A COMArgumentDescription is used by the COM interface class generator tools to collect information about an interface function argument that is used to generate interface wrapper class methods.</body></comment><class><name>COMInterfaceSpec</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name iidString </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMInterfaceSpec</class-id><body>InterfaceInformationSpec contains information about an interface. Currently this only includes the IID and the name of the interface.Instance Variables	iidString 		&lt;String&gt;		the interface ID in textual form	name		&lt;String&gt;		the name of the Interface</body></comment><class><name>IClassFactoryTraceAdaptor</name><environment>External</environment><super>External.IUnknownTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IClassFactoryTraceAdaptor</class-id><body>IClassFactoryTraceAdaptor provides interface function tracing for operations in the IClassFactory interface.</body></comment><class><name>COMResourceBrowser</name><environment>Tools</environment><super>Tools.COMResourceViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specialResourcesListModel ownedInterfacesListModel ownedMemoryListModel </inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>Tools.COMResourceBrowser</class-id><body>The COMResourceBrowser allows you to browse and inspect the COM resources which are in use in the current session.  The resources which are tracked are COM interfaces and OLE memory addresses which are being used, as well as any interfaces exported by COM objects implemented in this process.To open evaluate:	COMResourceBrowser open.</body></comment><class><name>COMExtendedEntryPointDescription</name><environment>External</environment><super>External.COMEntryPointDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMExtendedEntryPointDescription</class-id><body>A COMExtendedEntryPointDescription is used by the COM interface class generator tools to collect information about an interface function that is used to generate interface wrapper class methods.</body></comment><class><name>IDataObjectTraceAdaptor</name><environment>External</environment><super>External.IUnknownTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.IDataObjectTraceAdaptor</class-id><body>IDataObjectTraceAdaptor provides interface function tracing for operations in the IDataObject interface.</body></comment><class><name>COMArgumentProcessingSpecification</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>category calloutArgumentTransformation calloutArgumentReleaseExpression calloutResultBufferConstructor calloutResultBufferExtractor callinArgumentTransformation callinResultReferenceExpression callinResultValueExpression resultReferenceExpression </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMArgumentProcessingSpecification</class-id><body>A COMArgumentProcessingSpecification is used by the COM interface class generator tools to collect information about an interface function argument that is used to generate interface wrapper class methods.</body></comment><class><name>COMExportedObjectsBrowser</name><environment>External</environment><super>Tools.COMResourceViewer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Development Support</category><attributes><package>Com- Ole Development</package></attributes></class><comment><class-id>External.COMExportedObjectsBrowser</class-id><body>The COMExportedObjectsBrowser displays a view on COM interfaces which have been exported to external clients through the ExternalObjectTable callback mechanism.To open evaluate:	COMExportedObjectsBrowser open.</body></comment><shared-variable><name>TraceLog</name><environment>External.COMTraceManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><shared-variable><name>TraceInternalCalls</name><environment>External.COMTraceManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><shared-variable><name>InterfaceTraceOptionsRegistry</name><environment>External.COMTraceManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><shared-variable><name>TraceCallout</name><environment>External.COMTraceManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><shared-variable><name>TraceEnabled</name><environment>External.COMTraceManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><shared-variable><name>TraceCallin</name><environment>External.COMTraceManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><shared-variable><name>TraceAdaptorMap</name><environment>External.COMTraceManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><shared-variable><name>ArgumentProcessingSpecifications</name><environment>External.COMInterfaceWrapperClassGenerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><shared-variable><name>ArgumentAnalysisSelectors</name><environment>External.COMInterfaceWrapperClassGenerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole Development</package></attributes></shared-variable><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>private validating</category><body package="Com- Ole Development">checkBasicInformationValidity	(self isValidPackageName: self targetPackage value)		ifFalse: 			[self statusText				value: ((#PleaseProvideValidTargetPackageName &lt;&lt; #com						&gt;&gt; 'Please provide a valid target package name') asString						asTextEmphasis: #(#bold #red)).			^false].	(self isValidNamespaceName: self targetNamespace value)		ifFalse: 			[self statusText				value: ((#PleaseProvideValidTargetNamespace &lt;&lt; #com						&gt;&gt; 'Please provide a valid target namespace') asString						asTextEmphasis: #(#bold #red)).			^false].	(self generateInterfaceImplementationClass value		or: [self generateInterfacePointerClass value])			ifFalse: 				[Dialog warn: #InterfacesWithoutImplementationOrPointerClass &lt;&lt; #com							&gt;&gt; 'You selected not to generate either an implementation nor an interface pointer class.Interfaces are non-functional. Please select at least one of the two categories to generate. Please use the help function to find out which you may need.'.				^false].	^true</body><body package="Com- Ole Development">checkIIDValidity	(self interfaceDefinitions list		allSatisfy: [:each | each containsValidIIDString])			ifFalse: 				[self statusText					value: ((#PleaseProvideValidIIDsForAllInterfaces &lt;&lt; #com							&gt;&gt; 'Please provide valid interface ids for all interfaces.') asString								asTextEmphasis: #(#bold #red)).				^false].	(self interfaceDefinitions list allSatisfy: 			[:each |			(self interfaceDefinitions list				contains: [:other | other name ~= each name and: [other iidString = each iidString]])					not])		ifFalse: 			[self statusText				value: ((#DuplicateInterfaceIDsPleaseCheck &lt;&lt; #com						&gt;&gt; 'You assigned the same interface ID to two or more interfaces.Please check this.')								asString							asTextEmphasis: #(#bold #red)).			^false].	^true</body><body package="Com- Ole Development">checkOrCreateTargetNamespace	| fullname elements |	fullname := self targetNamespace value trimBlanks.	(fullname asQualifiedReference valueOrDo: [nil])		ifNotNil: [:namespace | ^namespace].	elements := (fullname tokensBasedOn: $.) collect: #asSymbol.	^self findOrCreateNamespaces: elements</body><body package="Com- Ole Development">checkTypesValidity	self myDeclarations list do: 			[:each |			(self isCTypeDefinitionValid: each)				ifFalse: 					[self statusText						value: ((#PleaseFixDefinitionOfType1s &lt;&lt; #com								&gt;&gt; 'Please fix definition of type &lt;1s&gt;' expandMacrosWith: each name)								asString asTextEmphasis: #(#bold #red)).					^false]].	^true</body><body package="Com- Ole Development">checkVTableValidity	^self updateVtableSignature		ifNil: 			[self statusText				value: ((#VTableDefinitionInvalid &lt;&lt; #com						&gt;&gt; 'The provided vtable definition is not valid') asString						asTextEmphasis: #(#bold #red)).			false]		ifNotNil: [true]</body><body package="Com- Ole Development">checkValidity	self checkBasicInformationValidity		ifFalse: 			[self selectTab: #basicInformationSpec.			^false].	self checkTypesValidity		ifFalse: 			[self selectTab: #declarationsSpec.			^false].	self checkVTableValidity		ifFalse: 			[self selectTab: #vtableSpec.			^false].	self checkIIDValidity		ifFalse: 			[self selectTab: #iidDefinitionSpec.			^false].	^true</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>aspects</category><body package="Com- Ole Development">generateInterfaceImplementationClass	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^generateInterfaceImplementationClass isNil		ifTrue:			[generateInterfaceImplementationClass := false asValue]		ifFalse:			[generateInterfaceImplementationClass]</body><body package="Com- Ole Development">generateInterfacePointerClass	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^generateInterfacePointerClass isNil		ifTrue:			[generateInterfacePointerClass := true asValue]		ifFalse:			[generateInterfacePointerClass]</body><body package="Com- Ole Development">interfaceDefinitions	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^interfaceDefinitions isNil		ifTrue:			[interfaceDefinitions :=  SelectionInList new.			interfaceDefinitions selectionIndexHolder compute:				[:v |				self selectedInterfaceRow value: interfaceDefinitions selection].			interfaceDefinitions]		ifFalse:			[interfaceDefinitions]</body><body package="Com- Ole Development">interfaceID	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	| name |	name := self interfaceName value asSymbol.	name ifNil: [^nil].	^(self interfaceDefinitions list detect: [:each | each name = name]		ifNone: [^nil]) iid</body><body package="Com- Ole Development">interfaceName	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	interfaceName isNil ifTrue: [interfaceName := nil asValue].	^interfaceName</body><body package="Com- Ole Development">interfaceSuperclass	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^interfaceSuperclass isNil		ifTrue:			[interfaceSuperclass := IUnknown asValue]		ifFalse:			[interfaceSuperclass]</body><body package="Com- Ole Development">myDeclarations	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^myDeclarations isNil		ifTrue:			[myDeclarations :=  SelectionInList new.			myDeclarations selectionIndexHolder compute:				[:v |				self selectedTypeRow value: myDeclarations selection].			myDeclarations]		ifFalse:			[myDeclarations]</body><body package="Com- Ole Development">selectedInterfaceRow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectedInterfaceRow isNil		ifTrue:			[selectedInterfaceRow := nil asValue]		ifFalse:			[selectedInterfaceRow]</body><body package="Com- Ole Development">selectedTypeRow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectedTypeRow isNil		ifTrue: 			[selectedTypeRow := nil asValue.			selectedTypeRow onChangeSend: #updateTypeRemoveButtonEnablement to: self.			selectedTypeRow]		ifFalse: [selectedTypeRow]</body><body package="Com- Ole Development">statusText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^statusText isNil		ifTrue:			[statusText := String new asValue]		ifFalse:			[statusText]</body><body package="Com- Ole Development">tabs	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	tabs isNil		ifTrue: 			[tabs := SelectionInList with: self tabLabels.			tabs selectionIndexHolder onChangeSend: #tabsChanged to: self].	^tabs</body><body package="Com- Ole Development">targetNamespace	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetNamespace isNil		ifTrue:			[targetNamespace := 'External' asValue]		ifFalse:			[targetNamespace]</body><body package="Com- Ole Development">targetPackage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^targetPackage isNil		ifTrue:			[targetPackage := nil asValue]		ifFalse:			[targetPackage]</body><body package="Com- Ole Development">vtableSignatureText	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	vtableSignatureText isNil		ifTrue: 			[vtableSignatureText := String new asValue.			vtableSignatureText onChangeSend: #modifiedVtableSignature to: self].	^vtableSignatureText</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>events</category><body package="Com- Ole Development">interfaceNameChanged	"If the interface name does not include the I prefix, add it"	| name |	name := self interfaceName value.	(name isNil or: [name isEmpty]) ifTrue: [^self].	(name first: 1) = 'I' ifFalse: [self interfaceName value: 'I' , name]</body><body package="Com- Ole Development">modifiedVtableSignature	self resetStatusText.	self updateVtableSignature		ifNil: 			[self statusText				value: ((#VTableDefinitionInvalid &lt;&lt; #com						&gt;&gt; 'The provided vtable definition is not valid') asString						asTextEmphasis: #(#red #bold))]</body><body package="Com- Ole Development">subAppOpened: aSymbol	"the given subcanvas is displayed. Perform required initializations."	aSymbol = #declarationsSpec ifTrue: [self updateTypeRemoveButtonEnablement]</body><body package="Com- Ole Development">tabsChanged	"Every time, a tab is changed, a new sub canvas gets installed."	| index |	index := self tabs selectionIndex.	subCanvasBuilder := (self builder componentAt: #tabs) widget client: self spec: (self specArray at: index).	self subAppOpened:  (self specArray at: index).</body><body package="Com- Ole Development">typeDefinitionChanged: aString	self resetStatusText.	self updateOwnTypeDefinitions.</body><body package="Com- Ole Development">updateTypeRemoveButtonEnablement	subCanvasBuilder ifNil: [^self].	(subCanvasBuilder componentAt: #ActionButtonRemove)		ifNil: 			["Wrong tab"			^self]		ifNotNil: [:button | button widget isEnabled: self selectedTypeRow value notNil]</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>private</category><body package="Com- Ole Development">addMissingDeclarations: anArray	"Add missing declarations to the list of my declarations which are shown in the referenced type tab"	| list oldList |	list := self myDeclarations list.	oldList := list copy.	list addAll: (anArray reject: [:each | list includes: each]).	oldList = list ifTrue: [^self].	self myDeclarations changed: #list.	self updateInterfaceList</body><body package="Com- Ole Development">createTargetPackage	^ Store.Registry packageNamedOrCreate: self targetPackage value.</body><body package="Com- Ole Development">displayHelpTextFor: aSymbol	Dialog warn: (self class helpTextFor: aSymbol)</body><body package="Com- Ole Development">initializeMyCTypeDefinitions	^ownTypes := ExternalDictionary new</body><body package="Com- Ole Development">interfaceNameFromVtableName: aString	| name |	name := aString reject: [:each | each = $_].	(name last: 4) = 'Vtbl' ifTrue: [name := name allButLast: 4].	^name</body><body package="Com- Ole Development">isValidNamespaceName: aString	| elements |	aString ifNil: [^false].	elements := aString tokensBasedOn: $..	^elements allSatisfy: 			[:each |			each notEmpty				and: [each allSatisfy: [:char | char isAlphaNumeric or: [char = $_]]]]</body><body package="Com- Ole Development">isValidPackageName: string	^string notNil and: 			[string allSatisfy: [:char | char isAlphaNumeric or: [' _-' includes: char]]]</body><body package="Com- Ole Development">resetStatusText	self statusText value: ''</body><body package="Com- Ole Development">resetTypeDefinitions	"Clear my type list and my external dictionary cache"	self initializeMyCTypeDefinitions.	self myDeclarations list: List new</body><body package="Com- Ole Development">selectTab: aSymbol	self tabs selectionIndex: (self specArray indexOf: aSymbol)</body><body package="Com- Ole Development">showErrorsAndWarningsIn: aPackage	codeGenerationErrors := (Refactory.Browser.BrowserEnvironment new				forCodeComponents: (Array with: aPackage)) referencesTo: #incomplete:.	codeGenerationWarnings := (Refactory.Browser.BrowserEnvironment new				forCodeComponents: (Array with: aPackage)) referencesTo: #pleaseReview:.	self updateStatustextForGeneration.</body><body package="Com- Ole Development">updateInterfaceList	"Update the interface definition list (IID list). Add all missing interface definitions to the list	 but take care existing ones are not overwritten since they may already contain a user-provided IID"	| interfaceTypes interfaceDefs |	interfaceTypes := self myDeclarations list				select: [:each | self isInterfaceType: each].	interfaceDefs := interfaceTypes				collect: [:each | COMInterfaceSpec name: each name].	self interfaceName value		ifNotNil: 			[:name |			(interfaceDefs contains: [:each | each name = name asSymbol])				ifFalse: [interfaceTypes := interfaceTypes add: (COMInterfaceSpec name: name)]].	self interfaceDefinitions list addAll: (interfaceDefs				reject: [:interfaceDef | self interfaceDefinitions list includes: interfaceDef]).	self interfaceDefinitions list: (self interfaceDefinitions list				select: [:each | interfaceDefs includes: each])</body><body package="Com- Ole Development">updateOwnTypeDefinitions	"update my external dictionary which is used for compiling the vtable.	 Since types my depend on others, we redefine all types, even thow we can not know here if this is enough."	self myDeclarations list do: 			[:each |			"Removing the type is required. Otherwise redefinition does not seem to be possible"			self myCTypeDefinitions removeKey: each name ifAbsent: [].			(self parseCTypeString: each definitionString addMissingDefinitions: true)				ifNotNil: [:type | self myCTypeDefinitions at: type name put: type]].	self updateInterfaceList</body><body package="Com- Ole Development">updateStatustextForGeneration	| stream |	stream := TextStream on: String new.	stream		nextPutAll: (#GenerationFinished &lt;&lt; #com &gt;&gt; 'Generation finished') asText.	stream nextPutAll: ' '.	self hasErrors		ifTrue: 			[stream emphasize: #(#red #bold)				during: 					[stream nextPutAll: (#Errors1p &lt;&lt; #com &gt;&gt; '&lt;1p&gt; Errors'								expandMacrosWith: self codeGenerationErrors numberSelectors)]].	stream nextPutAll: ' '.	self hasWarnings		ifTrue: 			[stream emphasize: #(#orange #bold)				during: 					[stream nextPutAll: (#Warnings1p &lt;&lt; #com &gt;&gt; '&lt;1p&gt; Warnings'								expandMacrosWith: self codeGenerationWarnings numberSelectors)]].	self statusText value: stream contents</body><body package="Com- Ole Development">updateVtableSignature	| result |	self vtableSignatureText		setValue: (self fixVtableDefinition: self vtableSignatureText value).	result := self parseVTableString: self vtableSignatureText value.	result		ifNotNil: 			[self interfaceName value: (self interfaceNameFromVtableName: result name).			self updateInterfaceList].	^result</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>private accessing</category><body package="Com- Ole Development">currentExternals	^(ExternalDictionary new)		addBackup: self myCTypeDefinitions;		addBackup: COMInterfaceVTableSignatures externals;		yourself</body><body package="Com- Ole Development">definedInterfaceClassesMenu	| classes |	classes := COMInterface allSubclasses sorted: #name ascending.	^Menu labelArray: (classes collect: [:each | each fullName]) values: classes</body><body package="Com- Ole Development">knownIIDConstants	^(COMConstants keys select: [:each | (each first: 4) = 'IID_']) asValue</body><body package="Com- Ole Development">myCTypeDefinitions	^ownTypes ifNil: [self initializeMyCTypeDefinitions]</body><body package="Com- Ole Development">specArray	"Private - The list of associated sub canvaes. See also #labelArray."	^#(#basicInformationSpec #vtableSpec #declarationsSpec #iidDefinitionSpec)</body><body package="Com- Ole Development">tabLabels	"Private - The list of tab names (and/or icons). See also #specArray."	^(OrderedCollection new)		add: 'Basic Information';		add: 'VTable Definition';		add: 'Referenced Types';		add: 'Referenced Interfaces';		yourself</body><body package="Com- Ole Development">typeChoices	^#(#Interface) asValue</body><body package="Com- Ole Development">vtableSignatureMethodSource	| type stream |	type := self updateVtableSignature.	stream := String new writeStream.	stream		nextPutAll: type name;		cr;		crtab.	stream nextPutAll: '&lt;C: ' , self vtableSignatureText value , '&gt;'.	^ stream contents</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>private menus</category><body package="Com- Ole Development">cDeclarationsMenu	| menu item |	menu := Menu new.	item := (MenuItem				labeled: #RescanDefinitions &lt;&lt; #com &gt;&gt; 'Rescan definitions')				value: [self rescanTypeDefinitions];				yourself.	menu addItem: item.	item := (MenuItem labeled: #RemoveDefinition &lt;&lt; #com &gt;&gt; 'RemoveDefinition')				enablement: [self selectedTypeRow value notNil];				value: [self removeSelectedDefinition];				yourself.	menu addItem: item.	^menu</body><body package="Com- Ole Development">codeGenerationErrors	^ codeGenerationErrors</body><body package="Com- Ole Development">codeGenerationWarnings	^ codeGenerationWarnings</body><body package="Com- Ole Development">hasErrors	^self codeGenerationErrors notNil and: [self codeGenerationErrors isEmpty not]</body><body package="Com- Ole Development">hasWarnings	^self codeGenerationWarnings notNil and: [self codeGenerationWarnings isEmpty not]</body><body package="Com- Ole Development">statusBarMenu	| menu item |	menu := Menu new.	item := (MenuItem labeled: #BrowseErrors &lt;&lt; #com &gt;&gt; 'Browse Errors')				enablement: [self hasErrors];				value: [self browseErrors];				yourself.	menu addItem: item.	item := (MenuItem labeled: #BrowseWarnings &lt;&lt; #com &gt;&gt; 'Browse Warnings')				enablement: [self hasWarnings];				value: [self browseWarnings];				yourself.	menu addItem: item.	^menu</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>private C parsing</category><body package="Com- Ole Development">basicParseCString: aString	^CDeclarationParser		parseWithNoPreprocess: (aString , '&gt;') readStream		as: #defineOrSingleDeclaration		declarations: self currentExternals		requestor: (SignallingCompilerErrorHandler handler: self)</body><body package="Com- Ole Development">fixStructNameIn: aString	"We need a struct name which starts with two underscores"	| rStream wStream char1 char2 |	rStream := aString readStream.	wStream := String new writeStream.	wStream nextPutAll: rStream upToSeparator.	rStream skipSeparators.	wStream nextPut: Character space.	char1 := rStream next.	char1 = $_		ifTrue: 			[char2 := rStream next.			char2 = $_				ifTrue: [wStream nextPutAll: '__']				ifFalse: 					[wStream						nextPutAll: '__';						nextPut: char2]]		ifFalse: 			[wStream				nextPutAll: '__';				nextPut: char1].	wStream nextPutAll: rStream upToEnd.	^wStream contents</body><body package="Com- Ole Development">fixVtableDefinition: aString	"Fix all known problems with vtable definitions"	| def index |	def := aString asString trimSeparators.	"DLLCC doesn't like defines inside the definition at the moment"	def := def copyReplaceAll: 'STDMETHODCALLTYPE' with: '__stdcall'.	def := def copyReplaceAll: 'BEGIN_INTERFACE' with: ''.	def := def copyReplaceAll: 'END_INTERFACE' with: ''.	def := def copyReplaceAll: '__RPC__deref_out' with: ''.	"Don't want the type definition, only the structure"	(def first: 7) = 'typedef' ifTrue: [def := (def allButFirst: 7) trimBlanks. ].	"No struct specified. We can't do anything"	(def first: 6) ~= 'struct' ifTrue: [^ def ].	"skip everything after the last closing bracket, including type name or semicolon"	index := def lastIndexOf: $}. def := def first: index.	^self fixStructNameIn: def</body><body package="Com- Ole Development">isCTypeDefinitionValid: aDefinition	^[(self basicParseCString: aDefinition definitionString) result notNil]		on: CompilerError		do: [:ex | ex return: false]</body><body package="Com- Ole Development">isInterfaceType: each	| type |	type := self parseCTypeString: each definitionString				addMissingDefinitions: false.	type ifNil: [^false].	^type baseType isStructure and: [type baseType name = #__IAnonymous]</body><body package="Com- Ole Development">parseCTypeString: aString addMissingDefinitions: addMissingDefinitions	"Parse the given C string and return the result.  the addMissingDefinitions flag tells the method to add currently unknown 	 definitions found while parsing the string to the list of definitions or not. The primary flag determines if referenced types shall be marked as primary.	 Such types can not be deleted by the user."	| result parser newDeclarations newDefinitions |	^	[parser := self basicParseCString: aString.	result := parser result.	result class = Association ifTrue: [result := result value].	addMissingDefinitions		ifTrue: 			[newDeclarations := parser declarations						ownSelect: [:each | each name ~= result name and: [each class = CTypedefType]].			newDefinitions := newDeclarations keys						collect: [:each | TypeDefinitionString name: each primary: false].			self addMissingDeclarations: newDefinitions].	result]			on: CompilerError			do: [:ex | ex return: nil]</body><body package="Com- Ole Development">parseVTableString: aString	"Parse the given Vtable. 	 definitions found while parsing the string to the list of definitions or not. The primary flag determines if referenced types shall be marked as primary.	 Such types can not be deleted by the user."	| result parser newDeclarations newDefinitions |	^	[parser := self basicParseCString: aString.	result := parser result.	result class = Association ifTrue: [result := result value].	"If the user entered a completely new vtable definition, reset all types"	(oldVtable isNil or: [oldVtable name ~= result name])		ifTrue: [self resetTypeDefinitions].	oldVtable := result.	newDeclarations := parser declarations				ownSelect: [:each | each name ~= result name and: [each class = CTypedefType]].	newDefinitions := newDeclarations keys				collect: [:each | TypeDefinitionString name: each primary: true].	self addMissingDeclarations: newDefinitions.	result]			on: CompilerError			do: [:ex | ex return: nil]</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>controller validating</category><body package="Com- Ole Development">containsValidIIDDefinitionString: aController	| aString |	aString := aController editValue.	(aString isNil or: [aString isEmpty]) ifTrue: [^true].	^COMInterfaceSpec isValidIIDString: aString</body><body package="Com- Ole Development">containsValidInterfaceName: aController	| name |	name := aController editValue.	^(name isNil or: [name isEmpty])		or: [Refactory.Browser.Condition validClassName: name]</body><body package="Com- Ole Development">containsValidNamespaceName: anInputBoxController	| string |	string := anInputBoxController editValue.	(string isNil or: [string trimBlanks isEmpty]) ifTrue: [^true].	string := string trimBlanks.	^self isValidNamespaceName: string</body><body package="Com- Ole Development">containsValidPackageName: anInputBoxController	| string |	string := anInputBoxController editValue.	(string isNil or: [string trimBlanks isEmpty]) ifTrue: [^true].	^self isValidPackageName: string</body><body package="Com- Ole Development">containsValidTypeDefinitionString: anInputBoxController	| string def |	string := anInputBoxController editValue.	(string isNil or: [string isEmpty]) ifTrue: [^true].	def := self selectedTypeRow value.	^self isCTypeDefinitionValid: (TypeDefinitionString				name: def name				typeString: string				primary: false)</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>private code generation</category><body package="Com- Ole Development">compileCTypeDefinitions		self myDeclarations list do: [:each |		COMExternalInterface compile: each definitionMethodSource classified: #types ].</body><body package="Com- Ole Development">compileVtableSignature		COMInterfaceVTableSignatures compile: self vtableSignatureMethodSource classified: #'vtables-COM'</body><body package="Com- Ole Development">defineIIDConstant: anIIDInfo	| constant |	constant := COMConstants		defineSharedVariable: ('IID_' , anIIDInfo name) asSymbol		private: false		constant: true		category: 'Interface IIDs'		initializer: anIIDInfo iid storeString.	constant initialize.</body><body package="Com- Ole Development">defineIIDConstants	self interfaceDefinitions list do: [:each | self defineIIDConstant: each]</body><body package="Com- Ole Development">findOrCreateNamespaces: anArray	| startIndex namespace |	startIndex := 2.	namespace := anArray first asQualifiedReference valueOrDo: 					[startIndex := 1.					Smalltalk].	startIndex to: anArray size		do: 			[:each |			namespace := self findOrCreateSubNamespace: (anArray at: each)						in: namespace].	^namespace</body><body package="Com- Ole Development">findOrCreateSubNamespace: aSymbol in: aNamespace	^aNamespace at: aSymbol		ifAbsent: 			[aNamespace				defineNameSpace: aSymbol				private: false				imports: ''				category: 'System-Name Spaces']</body><body package="Com- Ole Development">generateClassesIn: aNameSpace	| anInterfaceName signature |	anInterfaceName := self interfaceName value.	(COMInterfaceClassGenerator new)		superInterfaceID: self interfaceSuperclass value iid;		targetNamespace: aNameSpace;		generateDefinitionPrototypeFor: anInterfaceName.	signature := (COMInterfaceImplementationClassGenerator vtableSignatureForInterface: anInterfaceName).	self generateInterfacePointerClass value		ifTrue: 			[COMInterfacePointerClassGenerator new				superInterfaceID: self interfaceSuperclass value iid;				generateDefinitionPrototypeFor: anInterfaceName				signature: signature].	self generateInterfaceImplementationClass value		ifTrue: 			[COMInterfaceImplementationClassGenerator new				superInterfaceID: self interfaceSuperclass value iid;				generateDefinitionPrototypeFor: anInterfaceName		signature: signature]</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>interface opening</category><body package="Com- Ole Development">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self tabs selectionIndex: 1.	self vtableSignatureText		value: 'struct __IFooVtbl {			HRESULT ( __stdcall * QueryInterface)(IFoo * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IFoo * This);			ULONG ( __stdcall * Release)(IFoo * This);			HRESULT ( __stdcall * InArgTest)(IFoo * This, IFoo2 * punk);			HRESULT ( __stdcall * OutArgTest)(IFoo * This, IFoo3 ** punk);		}'</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard</class-id> <category>actions</category><body package="Com- Ole Development">browseErrors	self codeGenerationErrors openEditor</body><body package="Com- Ole Development">browseWarnings	self codeGenerationWarnings openEditor</body><body package="Com- Ole Development">generateInterfaceClasses	| package namespace |	self resetStatusText.	self checkValidity ifFalse: [^false].	package := self createTargetPackage.	Store.Policies packagePolicy forcePackage: package		while: [ namespace := self checkOrCreateTargetNamespace.				self compileCTypeDefinitions.				self defineIIDConstants.				self compileVtableSignature.				self generateClassesIn: namespace.				self showErrorsAndWarningsIn: package]</body><body package="Com- Ole Development">help	| index |	index := self tabs selectionIndex ifNil: [^self].	self displayHelpTextFor: (self specArray at: index)</body><body package="Com- Ole Development">removeSelectedDefinition	| typeDefinition |	self resetStatusText.	typeDefinition := self myDeclarations selection.	typeDefinition ifNil: [^self].	typeDefinition isPrimary		ifTrue: 			[^Dialog warn: #TypeIsReferencedByVTablyAndCanNotBeRemoved &lt;&lt; #com						&gt;&gt; 'This type is directly referenced by the vtable definition andcan therefore not be deleted'].	self myDeclarations list		removeAtIndex: self myDeclarations selectionIndex.	self myDeclarations changed: #list.	self myCTypeDefinitions removeKey: typeDefinition name ifAbsent: [].	self updateInterfaceList.</body><body package="Com- Ole Development">rescanTypeDefinitions	"Reset the type definitions an recompile the vtable declaration. 	 Re-Add all types"	self resetStatusText.	self resetTypeDefinitions.	self updateVtableSignature.	self updateInterfaceList.</body><body package="Com- Ole Development">selectTargetNamespace	(IncrementalSearchDialog selectNamespace: 'Please select target namespace')		ifNotNil: [:result | self targetNamespace value: result asString]</body><body package="Com- Ole Development">selectTargetPackage	"This stub method was generated by UIDefiner"	(IncrementalSearchDialog selectPackage: 'Please select target package')		ifNotNil: [:result | self targetPackage value: result name]</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard class</class-id> <category>private accessing</category><body package="Com- Ole Development">basicInformationHelpText		^ #basicInformationHelpText &lt;&lt; #com &gt;&gt; 'Basic InformationIn this tab the user may enter primary information. Interface name:	This parameter affects the names of the interface classes wich will be generated and the name of constant which will store the interface IDInterface superclass:	The Wizard will create the new interface classes as subclasses of this Interface.Target Package:	This is the target package into which all code will be generated.Target Namespace:	The namespace in which the Wizard will put generated classes into. Generate InterfacePointer/Implemenation class:	InterfacePointer classes are required when accessing the interface as a client.	InterfaceImplementation classes are required when providing services to other COM clients through the interface'</body><body package="Com- Ole Development">declarationsHelpText		^ #DeclarationsHelpText &lt;&lt; #com &gt;&gt; 'Referenced TypesIn this tab the user can provide type definitions which are used by the vtable (e.g. as parameter types) but currently not known to the VisualWorks system. The type can either be selected from the dropdownlist or entered in the input field.The dropdown list currently only contains the entry "Interface". More types may be added later.For other types, the wizard currently exclusively supports type-definitions, that means types which are defined using the "typedef" keyword in C. Please only provide only the source type of the definition statement as shown below.(The rest of the statement will be added by the wizard)	Type name 		Actual definition 							definition to be provided	myStrcut 		"typedef struct _x {int x;int y;} myStruct"		"struct _x {int x; int y;}"	myLong 		"typedef DWORD myLong" 					"DWORD"	myPointer 		"typedef void * myPointer" 					"void *"	myString 		"typedef unsigned short *myString"			"unsigned short *"'</body><body package="Com- Ole Development">defaultHelpText	^ #NoContextSensitiveHelpAvailable &lt;&lt; #com &gt;&gt; 'HelpCurrently no context sensitive help is available.'</body><body package="Com- Ole Development">iidDefinitionsHelpText		^ #iidDefinitionHelpText &lt;&lt; #com &gt;&gt; 'Interface IDsOn this page you can provide required interface ids. This includes the id of the interface to be defined as well as ids of interfaces which are referenced in the vtable definition. Interface IDs are normally provided in the following formats:            {17306170-4809-423C-9ECC-ABEEC179F671}'</body><body package="Com- Ole Development">vtableInformationText	^ #VtableHelpText &lt;&lt; #com &gt;&gt;'VTable DefinitionIn this tab the vtable definition can be provided. It is normally copied from some header file and looks like the example definition provided below. Please don''t care about referenced undefined types in this step. This will be handled later.'</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard class</class-id> <category>private</category><body package="Com- Ole Development">helpTextFor: aSymbol	aSymbol = #basicInformationSpec ifTrue: [^self basicInformationHelpText].	aSymbol = #vtableSpec ifTrue: [^self vtableInformationText].	aSymbol = #declarationsSpec ifTrue: [^self declarationsHelpText].	aSymbol = #iidDefinitionSpec ifTrue: [^self iidDefinitionsHelpText].	^self defaultHelpText</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>converting</category><body package="Com- Ole Development">asInterfacePointer	" Answer an interface pointer for the receiver's VTable in external memory. "	" probably shouldn't need to support this protocol, since the question should		only arise in cases when the receiver is installed on an outgoing pointer		binding and we assert that the containing COMInterface is careful 		about going directly to its interface binding in any case when this		message would be sent.  But this is safe and consistent with		supporting the #isCOMInterface predicate, so we allow it "	^interfaceBinding asInterfacePointer</body><body package="Com- Ole Development">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	" probably shouldn't need to support this protocol, since the question should		only arise in cases when the receiver is installed on an outgoing pointer		binding and we assert that the containing COMInterface is careful 		about going directly to its interface binding in any case when this		message would be sent.  But this is safe and consistent with		supporting the #isCOMInterface predicate, so we allow it "	^interfaceBinding asPointerParameter</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>private-stack accessing</category><body package="Com- Ole Development">callerReportedExternalFunctionEntry: functionSelector context: callerFunctionMethodContext	" Private - Answer whether the callin binding takes responsibility for reporting entry to the interface function named &lt;aSelector&gt; from an external caller when interface functions are being traced. "	| aMethod |	self isOutgoingInterface		ifTrue: [ ^false ].  " early function entry only occurs from external callin binding "	aMethod := callerFunctionMethodContext mclass compiledMethodAt: callerFunctionMethodContext selector.	^aMethod refersToLiteral: #reportExternalFunctionEntry</body><body package="Com- Ole Development">callerTypeFor: functionSelector from: callerFunctionMethodContext	" Answer the type of the caller which invoked an interface function of the receiver from &lt;callerFunctionMethodContext&gt;. "	self isOutgoingInterface ifTrue: [^#externalCallout].	(self is: callerFunctionMethodContext selector		anExternalInvocationSelectorFor: functionSelector)			ifTrue: [^#externalCallin].	callerFunctionMethodContext selector = functionSelector		ifTrue: [^#internalCallin].	(#(#asInterfacePointer #storeSelfInPointer:)		includes: callerFunctionMethodContext selector) ifTrue: [^#internalCallin].	self error: #ErrUnknownCaller &lt;&lt; #com &gt;&gt; 'unknown caller type'</body><body package="Com- Ole Development">functionSelectorFromContext: aMethodContext	" Answer the interface function selector for the invocation represented by &lt;aMethodContext&gt;. "	| functionSelector |	functionSelector := aMethodContext selector.	functionSelector = #doesNotUnderstand:		ifTrue: [ 			"Assert isTrue: [ ( aMethodContext tempNames at: 1 ) = 'aMessage' ]."			functionSelector := ( aMethodContext tempAt: 1 ) selector ].	^functionSelector</body><body package="Com- Ole Development">getArgumentValuesFor: functionSelector context: aContext	" Answer the message arguments from &lt;aContext&gt;. "	^self getArgumentValuesFrom: aContext 		from: 1 		to: functionSelector numArgs</body><body package="Com- Ole Development">getArgumentValuesFrom: aContext from: startIndex to: stopIndex	" Answer the specified set of message arguments from &lt;aContext&gt;. "	| arguments index |	aContext selector = #doesNotUnderstand:		ifTrue: [			^( aContext tempAt: 1 ) arguments copyFrom: startIndex to: stopIndex ].	arguments := Array new: ( stopIndex - startIndex + 1 ).	index := 1.	startIndex to: stopIndex do: [ :i |		arguments at: index put: ( aContext tempAt: i ).		index := index + 1 ].	^arguments</body><body package="Com- Ole Development">getCallerMethodContextFor: functionSelector from: functionMethodContext	" Answer the method invocation context in the caller which represents the real call on the interface function &lt;functionMethodContext&gt;. "	| callerFunctionMethodContext |	"Assert isTrue: [ functionMethodContext receiver == self ]."		callerFunctionMethodContext := self getPreviousMethodContextFrom: functionMethodContext.	" We have to do the following because we don't always do #getReceiverEntryMethodContextFrom: 		to establish the trace context (??).  Verify if such deviations are in fact still allowed and if		consider whether maybe they should be eliminated so that we can simplify this mess here.  		Well, sort it out at some point in the future, it isn't critical that tracing performance be 		optimally optimized, so it's OK to ignore this for a while "	[ callerFunctionMethodContext receiver == self ]		whileTrue: [ callerFunctionMethodContext := self getPreviousMethodContextFrom: callerFunctionMethodContext ].	"Assert isTrue: [		( self isIncomingInterface			ifTrue: [ callerFunctionMethodContext receiver == interfaceBinding ]			ifFalse: [ 				( callerFunctionMethodContext receiver interfaceBinding == nil  ""releasing does this ""				or: [ callerFunctionMethodContext receiver interfaceBinding == interfaceBinding ] ) ] ) ]."	callerFunctionMethodContext selector asString = ( 'dispatch', functionSelector )		ifTrue: [  " in some cases a dispatch method relays the real invocation, e.g., inner unknown operations "			callerFunctionMethodContext := self getPreviousMethodContextFrom: callerFunctionMethodContext.			"Assert isTrue: [ callerFunctionMethodContext receiver == interfaceBinding ]" ].	"	self isIncomingInterface		ifTrue: [			Assert isTrue: [				callerFunctionMethodContext selector = functionSelector				or: [ callerFunctionMethodContext selector = ( self externalInvocationSelectorFor: functionSelector ) ] ] ]			""ifFalse: [ you can't make any assumptions about the caller in a COMInterface class ]"".	"	^callerFunctionMethodContext</body><body package="Com- Ole Development">getPreviousMethodContextFrom: initialContext	" Answer the method context which called &lt;initialContext&gt;.  Ignore blocks (including exception handlers) and ignore some known special methods which are designed for trace optimization. "	| aContext |	aContext := initialContext sender.		[aContext isBlockContext or: 			[(aContext receiver isCOMInterface or: [aContext receiver isCOMInterfaceBinding]) not				or: [self stackSelectorsToIgnore includes: aContext selector]]]			whileTrue: [aContext := aContext sender].	^aContext</body><body package="Com- Ole Development">stackSelectorsToIgnore	" Answer the special method selectors which are involved in exception handling or COM trace optimizations that we want to ignore while backtracking up a call stack. "	^#( 	" exception handlers "		#handle:do:		#on:do:		#valueOnUnwindDo:		#ifCurtailed:		#valueNowOrOnUnwindDo:		#ensure:		#reportExternalFunctionEntry		)</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>subclass-trace services</category><body package="Com- Ole Development">constructFunctionTraceContextForContext: functionEntryMethodContext	" An interface function call is being started at &lt;functionEntryMethodContext&gt; on the call stack.  Construct the function invocation trace context information. "	| functionSelector callerFunctionMethodContext callerType tracingEnabled aTraceContext |	functionSelector := self functionSelectorFromContext: functionEntryMethodContext.	callerFunctionMethodContext := self getCallerMethodContextFor: functionSelector		from: functionEntryMethodContext.	callerType := self callerTypeFor: functionSelector 		from: callerFunctionMethodContext.	tracingEnabled := ( self isTraceEnabled: callerType function: functionSelector ).	aTraceContext := ( COMFunctionTraceContext on: functionSelector )		callerType: callerType;		yourself.	"Assert isTrue: [ aTraceContext isTraceEnabled not ]."	" only collect additional info if we need it to support #doesNotUnderstand: dispatching or tracing "	( tracingEnabled 	or: [ functionEntryMethodContext selector = #doesNotUnderstand: ] )		ifTrue: [			aTraceContext arguments: ( self getArgumentValuesFor: functionSelector 				context: functionEntryMethodContext ) ].	tracingEnabled		ifTrue: [			aTraceContext				isTraceEnabled: true;				callerReportsFunctionEntry: ( self callerReportedExternalFunctionEntry: functionSelector 					context: callerFunctionMethodContext );				argumentNames: ( self getArgumentNamesFor: functionSelector );				yourself ].	^aTraceContext</body><body package="Com- Ole Development">getCLSIDDescription: aCLSID	" Answer a description of a CLSID. "	| aCOMObjectClass |	aCLSID isNil		ifTrue: [ ^nil printString ].	aCLSID = CLSID_NULL		ifTrue: [ ^'CLSID_NULL' ].	aCOMObjectClass := COMObject classForCLSID: aCLSID		ifNone: [ nil ].	^aCOMObjectClass isNil		ifTrue: [ self getGUIDDescription: aCLSID ]		ifFalse: [ aCOMObjectClass name, ' clsid ', aCLSID asString ]</body><body package="Com- Ole Development">getGUIDDescription: aGUID    " Answer a description of &lt;aGUID&gt;. "	^( COMConstants keyAtValue: aGUID		ifAbsent: [ ^aGUID printString ] )			asString</body><body package="Com- Ole Development">getIIDDescription: anIID	" Answer a description of an IID. "	| interfaceClass |	anIID isNil		ifTrue: [ ^nil printString ].	anIID = IID_NULL		ifTrue: [ ^'IID_NULL' ].	interfaceClass := COMInterface classForIID: anIID		ifNone: [ nil ].	^interfaceClass isNil		ifTrue: [ self getGUIDDescription: anIID ]		ifFalse: [ 'IID_', interfaceClass name, ' ', anIID asString ]</body><body package="Com- Ole Development">isTraceEnabled: callerType function: functionSelector	" Answer whether tracing is enabled for an invocation of &lt;functionSelector&gt; by a caller of type &lt;callerType&gt;. "	^( COMSessionManager isTraceEnabled		and: [ interfaceBinding isTraceTypeEnabled: callerType ] )</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>private-copying</category><body package="Com- Ole Development">copyInterfaceBinding	" Private - answer a copy of the receiver interface binding.  This is used carefully when copying an interface reference. "	"Assert isTrue: [ self isOutgoingInterface ]."	^interfaceBinding copyInterfaceBinding</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>private-trace services</category><body package="Com- Ole Development">defaultArgumentNamesFor: functionSelector		" Answer some default argument names for &lt;functionSelector&gt;. "	| numArgs argumentNames |	numArgs := functionSelector numArgs.	argumentNames := Array new: numArgs.	1 to: numArgs do: [ :i |		argumentNames at: i put: ( 'arg', i printString ) ].	^argumentNames</body><body package="Com- Ole Development">getArgumentNamesFor: functionSelector	" Answer the names of the arguments for the interface function &lt;functionSelector&gt;. "	| vtableDescription functionName entryPointDescription argumentNames |	vtableDescription := interfaceBinding class vtableDescription.	( self isIncomingInterface and: [ vtableDescription isNil ] )		ifTrue: [ 			" backstop for runtime optimization of ptr class state by dropping this info "			^self defaultArgumentNamesFor: functionSelector	 ].	functionName := functionSelector readStream upTo: $:.	entryPointDescription := vtableDescription detect: [ :ept | ept name = functionName ].	argumentNames := entryPointDescription argumentNames.	self isIncomingInterface  " strip This argument from OE external callback "		ifTrue: [ argumentNames := argumentNames copyFrom: 2 to: argumentNames size ].	"Assert isEqual: argumentNames size to: functionSelector numArgs."	^argumentNames</body><body package="Com- Ole Development">is: aSelector anExternalInvocationSelectorFor: functionSelector	" Answer the external invocation selector in a callin binding for &lt;functionSelector&gt;. "	| implicitReceiverArgKeyword |	implicitReceiverArgKeyword := ( functionSelector numArgs = 0		ifTrue: [ ':' ]		ifFalse: [ '_:' ] ).	(( interfaceBinding class callbackSelectorPrefix, functionSelector, implicitReceiverArgKeyword ) asSymbol = aSelector) ifTrue: [ ^ true].	(( interfaceBinding class internalCallbackSelectorPrefix, functionSelector ) asSymbol = aSelector) ifTrue: [ ^ true].	^false</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>finalizing</category><body package="Com- Ole Development">doesNotNeedFinalization	"The receiver no longer needs to be sent the #finalize message when it is not referenced anymore."	interfaceBinding doesNotNeedFinalization.</body><body package="Com- Ole Development">needsFinalization    "The receiver needs to be sent the message #finalize when it is no longer referenced."	interfaceBinding needsFinalization.</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>subclass-exception handlers</category><body package="Com- Ole Development">exceptionHandlerForHRESULTReturnValue: traceContext	" Answer the error handler block to use when an exception occurs during a function invocation of a function which returns an HRESULT.  The exception is reported and passed on. "	^[ :ex |		traceContext isTraceEnabled ifTrue: [			self isIncomingInterface				ifTrue: [ self logErrorExitHRESULT: ( interfaceBinding hresultForException: ex ) ]				ifFalse: [ self logString: ex description tag: (#Exception &lt;&lt; #com &gt;&gt; '***Exception') ].			].		ex pass ]</body><body package="Com- Ole Development">exceptionHandlerForNilReturnValue: traceContext	" Answer the error handler block to use when an exception occurs during a function invocation of a function whose return type is not known but which is known to return nil if an exception occurs.  The exception is reported and passed on. "	^self exceptionHandlerForUnspecifiedReturnValue: traceContext callerErrorValue: nil</body><body package="Com- Ole Development">exceptionHandlerForUnspecifiedReturnValue: traceContext	" Answer the error handler block to use when an exception occurs during a function invocation of a function whose return type is not known.  The exception is reported and passed on. "	^[ :ex |		traceContext isTraceEnabled ifTrue: [			self logString: ex description tag: (#Exception &lt;&lt; #com &gt;&gt; '***Exception').			].		ex pass ]</body><body package="Com- Ole Development">exceptionHandlerForUnspecifiedReturnValue: traceContext callerErrorValue: errorReturnValue	" Answer the error handler block to use when an exception occurs during a function invocation of a function whose return type is not known but which is known to return &lt;errorReturnValue&gt; if an exception occurs.  The exception is reported and passed on. "	^[ :ex |		traceContext isTraceEnabled ifTrue: [ 			self isIncomingInterface				ifTrue: [ self logErrorExitResult: errorReturnValue ]				ifFalse: [ self logString: ex description tag: (#Exception &lt;&lt; #com &gt;&gt; '***Exception') ].			].		ex pass ]</body><body package="Com- Ole Development">exceptionHandlerForZeroReturnValue: traceContext	" Answer the error handler block to use when an exception occurs during a function invocation of a function whose return type is not known but which is known to return 0 if an exception occurs.  The exception is reported and passed on. "	^self exceptionHandlerForUnspecifiedReturnValue: traceContext callerErrorValue: 0</body><body package="Com- Ole Development">hresultForException: anException	" Private - answer the HRESULT to return when &lt;anException&gt; has been raised during an interface function callin invocation. "	self isIncomingInterface		ifTrue: [ ^self interfaceBinding hresultForException: anException ].	"Assert isTrue: [ ex isKindOf: COMError ]."	" ^( ex isKindOf: COMError ) ""	^( anException isNGException and: [ anException originator isKindOf: COMError ] )"	^( COMError handles: anException )		ifTrue: [ anException hresult ]		ifFalse: [ 			self log: ((#FunctionRaisedNonCOMError &lt;&lt; #com &gt;&gt; '***ERROR: Function raised non-COMErrror: &lt;1s&gt;')			expandMacrosWith: anException description).			E_UNEXPECTED ]</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>accessing</category><body package="Com- Ole Development">functionAdaptor	" Answer the interface function adaptor which is configured for the receiver.  Answer nil if this is a direct binding of the interface to the real implementor. "	^implementor functionAdaptor</body><body package="Com- Ole Development">implementingObject	" Answer the COM object in the current process which supports the receiver.  Answer nil if the interface is not supported by a local Smalltalk COM object. "	^self isOutgoingInterface		ifTrue: [ interfaceBinding implementingObject ]		ifFalse: [ 			implementor isCOMInterfaceAdaptor				ifTrue: [ implementor implementingObject ]				ifFalse: [ implementor ] ]</body><body package="Com- Ole Development">interfaceBinding	" Answer the interface binding whose functions are traced by the receiver. "	^interfaceBinding</body><body package="Com- Ole Development">interfaceBinding: anInterfaceBinding	" Specify the interface binding whose functions are traced by the receiver. "	interfaceBinding := anInterfaceBinding.	self initializeVTableSelectors.</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>identity</category><body package="Com- Ole Development">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^interfaceBinding iid</body><body package="Com- Ole Development">iid: anIID	" Set the the interface ID which uniquely identifies the receiver the GUID &lt;anIID&gt;. "	interfaceBinding iid: anIID.</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>private-initialization</category><body package="Com- Ole Development">initializeVTableSelectors	" Private - initialize the list of VTable message selectors supported by the receiver. "	vtableSelectors := interfaceBinding class vtableDescription 		collect: [ :eptDescription | eptDescription selector ].</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>subclass-interface operations</category><body package="Com- Ole Development">invokeInterfaceFunction: traceContext	" Invoke the interface function whose invocation is described by &lt;traceContext&gt;.  Dispatch the message to the implementing object. "	^self invokeInterfaceFunctionWithNoTrace: traceContext</body><body package="Com- Ole Development">invokeInterfaceFunctionWithEntryTrace: traceContext	" Invoke the interface function whose invocation is described by &lt;traceContext&gt;.  Dispatch the message to the implementing object.  Note function entry, but make no further assumptions about return value.  "	| functionSelector result |	functionSelector := traceContext functionSelector.	traceContext isTraceEnabled ifTrue: [		self logFunctionEntry: traceContext.		 ].	[	result := implementor perform: functionSelector 		withArguments: traceContext arguments.	] on: Error 		do: ( self exceptionHandlerForUnspecifiedReturnValue: traceContext ).	^result</body><body package="Com- Ole Development">invokeInterfaceFunctionWithFullTrace: traceContext	" Invoke the interface function whose invocation is described by &lt;traceContext&gt;.   Dispatch the message to the implementing object.  Wrap the actual function invocation with the standard pattern of tracing.  The function return a value of unknown type. "	| functionSelector result |	functionSelector := traceContext functionSelector.	traceContext isTraceEnabled ifTrue: [		self logFunctionEntry: traceContext.		 ].	[	result := implementor perform: functionSelector 		withArguments: traceContext arguments.	] on: Error 		do: ( self exceptionHandlerForUnspecifiedReturnValue: traceContext ).	traceContext isTraceEnabled 		ifTrue: [ self logFunctionExit: traceContext returnValue: result ].	^result</body><body package="Com- Ole Development">invokeInterfaceFunctionWithHRESULTTrace: traceContext	" Invoke the interface function whose invocation is described by &lt;traceContext&gt;.    Dispatch the message to the implementing object.  Wrap the actual function invocation with the standard pattern of tracing.  The function must return an HRESULT value. "	| functionSelector hresult |	functionSelector := traceContext functionSelector.	traceContext isTraceEnabled ifTrue: [		self logFunctionEntry: traceContext.		 ].	[	hresult := implementor perform: functionSelector 		withArguments: traceContext arguments.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled 		ifTrue: [ self logFunctionExit: traceContext hresult: hresult ].	^hresult</body><body package="Com- Ole Development">invokeInterfaceFunctionWithNoTrace: traceContext	" Invoke the interface function whose invocation is described by &lt;traceContext&gt;.  Dispatch the message to the implementing object without any tracing. "	^implementor perform: traceContext functionSelector 		withArguments: traceContext arguments</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>testing</category><body package="Com- Ole Development">isCOMInterface	" Answer whether the receiver is a COM interface. "	^true</body><body package="Com- Ole Development">isCOMInterfaceImplementation	" Answer whether the receiver is a COM interface implemented in this Smalltalk image. "	" probably shouldn't need to support this protocol, since the question should		only arise in cases when the receiver is installed on an outgoing pointer		binding and we assert that the containing COMInterface is careful 		about going directly to its interface binding in any case when this		message would be sent.  But this is safe and consistent with		supporting the #isCOMInterface predicate, so we allow it "	^interfaceBinding isCOMInterfaceImplementation</body><body package="Com- Ole Development">isCOMInterfacePointer	" Answer whether the receiver is a COM interface referencing a VTable in external memory. "	" probably shouldn't need to support this protocol, since the question should		only arise in cases when the receiver is installed on an outgoing pointer		binding and we assert that the containing COMInterface is careful 		about going directly to its interface binding in any case when this		message would be sent.  But this is safe and consistent with		supporting the #isCOMInterface predicate, so we allow it "	^interfaceBinding isCOMInterfacePointer</body><body package="Com- Ole Development">isCOMTraceAdaptor	" Answer whether the receiver is a trace adaptor on a COM interface. "	^true</body><body package="Com- Ole Development">isIncomingInterface	" Answer whether the receiver is tracing an incoming interface supported by a Smalltalk COM object. "	^interfaceBinding isCOMInterfaceImplementation</body><body package="Com- Ole Development">isMTAObject	^ implementor isMTAObject</body><body package="Com- Ole Development">isOutgoingInterface	" Answer whether the receiver is tracing an outgoing interface. "	^interfaceBinding isCOMInterfacePointer</body><body package="Com- Ole Development">isValid	"Answer whether the receiver is a valid interface."	^interfaceBinding isValid</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>subclass-tracing</category><body package="Com- Ole Development">log: aString	" Log a line containing &lt;aString&gt; to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	COMSessionManager traceManager log: aString.</body><body package="Com- Ole Development">logArgumentValues: traceContext	" Log argument values to the COM trace log.  Ignore empty value references.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	| argName argValue |	1 to: traceContext arguments size do: [ :i |		argName := traceContext argumentNames at: i.		argValue := traceContext arguments at: i.		argValue isValueReference			ifTrue: [  				argValue notEmpty  " IN/OUT value reference "					ifTrue: [ self logValue: argValue value tag: argName ] ]			ifFalse: [ self logValue: argValue tag: argName ].		].</body><body package="Com- Ole Development">logCLSID: aCLSID	" Log a CLSID value to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	self logString: ( self getCLSIDDescription: aCLSID ) 		tag: 'CLSID'</body><body package="Com- Ole Development">logCr	" Log a CR to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	COMSessionManager traceManager logCr.</body><body package="Com- Ole Development">logErrorExitHRESULT: hresult	" Log the function return value for an  error exit to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	self logString: hresult asHRESULT constant		tag: #GenKey26 &lt;&lt; #com &gt;&gt; '***EXCEPTION exit with hresult'</body><body package="Com- Ole Development">logErrorExitResult: aValue	" Log the function return value for an  error exit to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	self logValue: aValue 		tag: (#GenKey27 &lt;&lt; #com &gt;&gt; '***EXCEPTION exit with return value')</body><body package="Com- Ole Development">logFlags: flags nameList: flagNames tag: tag	" Log a text description of the set of flags whose names are in &lt;flagNames&gt; with &lt;tag&gt; as a tag on the trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	| hexFlagsString valueDescription |	hexFlagsString := '16r', ( flags printStringRadix: 16 ).	valueDescription := ( flagNames size = 0		ifTrue: [ ((#x1sUnknownFlagNames &lt;&lt; #com &gt;&gt; '&lt;1s&gt; ( unknown flag names )')			expandMacrosWith: hexFlagsString) ]		ifFalse: [			| aStream |			aStream := String new newReadWriteStream.			flagNames do: [ :fn | aStream nextPutAll: fn ] 				separatedBy: [ aStream nextPutAll: ' |' ].			aStream nextPutAll: ' ( ', hexFlagsString, ' )'.			aStream contents ] ).	self logString: valueDescription tag: tag.</body><body package="Com- Ole Development">logFunctionEntry: traceContext	" Log entry to function invocation.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	self		logFunctionHeader: traceContext;		logArgumentValues: traceContext.</body><body package="Com- Ole Development">logFunctionExit: traceContext hresult: hresult	" Log function exit with the specified HRESULT return value to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	hresult succeeded ifTrue: [self logResultValues: traceContext].	self logHRESULT: hresult</body><body package="Com- Ole Development">logFunctionExit: traceContext returnValue: result	" Log function exit with the specified return value to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	" we don't know if the function succeede, so just report result values "	self logResultValues: traceContext.	self logResultValue: result tag: (#Returns &lt;&lt; #com &gt;&gt; 'Returns') asString.</body><body package="Com- Ole Development">logFunctionHeader: traceContext	" Log function invocation header information to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	| callTypeDescription methodDescription |	self isOutgoingInterface		ifTrue: [ 			callTypeDescription := 'Invoking ' ]		ifFalse: [			traceContext callerReportsFunctionEntry				ifTrue: [ 					"Assert isTrue: [ traceContext callerType = #externalCallin ]."					^self ].			callTypeDescription := 				( traceContext callerType = #externalCallin					ifTrue: [ 'External' ]					ifFalse: [ 'Internal' ] ),				' invocation of '.			].	methodDescription := interfaceBinding class name, '&gt;&gt;', traceContext functionSelector.	self		log: callTypeDescription,  methodDescription;		log: self logIndent, 'Interface: ', interfaceBinding printString.	self isIncomingInterface		ifTrue: [ self log: self logIndent2, 'On object: ', self implementingObject printString ].</body><body package="Com- Ole Development">logHRESULT: hresult	" Log an HRESULT value to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	self logString: hresult constant tag: 'hresult'</body><body package="Com- Ole Development">logIID: anIID	" Log an IID value to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	self logString: ( self getIIDDescription: anIID ) 		tag: 'IID'.</body><body package="Com- Ole Development">logIndent	" Aswer the standard indent for log subitems. "	^String with: Character tab</body><body package="Com- Ole Development">logIndent2	" Aswer the standard second-level indent for log subitems. "	^String with: Character tab with: Character tab</body><body package="Com- Ole Development">logInterfaceResultValue: anInterface tag: tag	" Log a description of &lt;anInterface&gt; with &lt;tag&gt; as a tag on the trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	| valueToReport |	" we probably ought to be a little more clever here, so that coercion of a 		not-yet exported interface impl via #asInterfacePointer, which 		would result in allocation of the interface body in external memory,		 isn't done unnecessarily when this is an internal caller.		Review this at some point to determine whether any modifications/improvements		are desirable "	valueToReport := ( ( anInterface isNil "or: [ self isOutgoingInterface ]" )		ifTrue: [ anInterface ]		ifFalse: [ anInterface asInterfacePointer ] ).  " coerce incoming interface references to pointer "	self logInterfaceValue: valueToReport		tag: tag.</body><body package="Com- Ole Development">logInterfaceValue: anInterface tag: tag	" Log a description of &lt;anInterface&gt; with &lt;tag&gt; as a tag on the trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	anInterface isNil  " should not be, but just in case "		ifTrue: [ ^self logString: (#nil1 &lt;&lt; #com &gt;&gt; '(nil)') asString tag: tag ].	self logString: anInterface "asInterfacePointer" interfaceBinding printString 		tag: tag.</body><body package="Com- Ole Development">logResultValue: aValue tag: tag	" Log a description of &lt;aValue&gt; with &lt;tag&gt; as a tag on the trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	" ensure consistent representation of interface values "	aValue isCOMInterface		ifTrue: [ ^self logInterfaceResultValue: aValue tag: tag ].	self logString: aValue printString 		tag: tag.</body><body package="Com- Ole Development">logResultValues: traceContext	" Log result values to the COM trace log.  Infer these from non-nil value references.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	| argName argValue |	1 to: traceContext arguments size do: [ :i |		argName := traceContext argumentNames at: i.		argValue := traceContext arguments at: i.		( argValue isValueReference and: [ argValue notEmpty ] )			ifTrue: [  " OUT or IN/OUT value reference with value returned "				self logResultValue: argValue value tag: argName ].		].</body><body package="Com- Ole Development">logString: aValue tag: tag	" Log &lt;aString&gt; with &lt;tag&gt; as a tag on the trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation.  "	self log: self logIndent, tag asString, ': ', aValue.</body><body package="Com- Ole Development">logValue: aValue tag: tag	" Log a description of &lt;aValue&gt; with &lt;tag&gt; as a tag on the trace log.  The caller is responsible for ensuring that tracing is currently enabled for this function invocation. "	" ensure consistent representation of interface values "	aValue isCOMInterface		ifTrue: [ ^self logInterfaceValue: aValue tag: tag ].	self logString: aValue printString 		tag: tag.</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>external-tracing</category><body package="Com- Ole Development">logExternalFunctionHeaderFor: functionSelector	" Log function invocation header information to the COM trace log.  The standard function named &lt;function&gt; has been invoked by an external caller and the callin interface binding wants to explicitly note its arrival prior to do validation checking on arguments which may result in early exit of the function. "	| methodDescription callerDescription |	methodDescription := interfaceBinding class name, '&gt;&gt;', functionSelector.	callerDescription := 'External'.	self		log: callerDescription, ' invocation of ',  methodDescription;		log: self logIndent, 'Interface: ', interfaceBinding printString;		log: self logIndent2, 'On object: ', self implementingObject printString.</body><body package="Com- Ole Development">logInvalidExternalArg: aValue name: argName	" Log a description of an invalid external callin argument to the trace log. "	self logString: aValue printString, '(not valid)'		tag: argName.</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>printing</category><body package="Com- Ole Development">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt; "	interfaceBinding isNil		ifTrue: [ ^super printOn: aStream ].	self isOutgoingInterface		ifTrue: [			interfaceBinding printOn: aStream.			aStream nextPutAll: ' (traced)'.			^self ]		ifFalse: [			super printOn: aStream.			aStream nextPutAll: ' on: '.			interfaceBinding printOn: aStream ].</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>releasing</category><body package="Com- Ole Development">invalidate	"Set the receiver to be invalid."	self callIndicatesChangeNeeded</body><body package="Com- Ole Development">privateInvalidate	"Set the receiver to be invalid."	interfaceBinding enforceInvalidation.</body><body package="Com- Ole Development">release	" Release the receiver. "	self callIndicatesChangeNeeded</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>private-dispatching</category><body package="Com- Ole Development">doesNotUnderstand: aMessage	" Private - sent to the receiver by the virtual machine when the message &lt;aMessage&gt; sent to the receiver was not implemented by the receiver.  Dispatch the message to the implementing object if &lt;aMessage&gt; represents an interface function. "	( self vtableSelectors includes: aMessage selector )		ifTrue: [ 			| traceContext |			"Assert isEqual: thisContext selector to: #doesNotUnderstand:."			traceContext := self constructFunctionTraceContextForContext: thisContext.			^self invokeInterfaceFunction: traceContext ].	(#(referenceCount isSTAObject isMTAObject) includes: aMessage selector) 		ifTrue: [ ^ implementor perform: aMessage selector ].	^super doesNotUnderstand: aMessage</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor</class-id> <category>private interface operations</category><body package="Com- Ole Development">privateRelease	" Release the receiver. "	interfaceBinding privateRelease.	super privateRelease.</body><body package="Com- Ole Development">referenceCount	^self isOutgoingInterface		ifTrue: [interfaceBinding referenceCount]		ifFalse: [implementor referenceCount]</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor class</class-id> <category>instance creation</category><body package="Com- Ole Development">for: anInterface	" Answer a new instance of the receiver which can provide tracing on function calls through &lt;anInterface&gt;. "	^self forBinding: anInterface interfaceBinding</body><body package="Com- Ole Development">forBinding: anInterfaceBinding	" Answer a new instance of the receiver which can provide tracing on function calls through &lt;anInterface&gt;. "	| realImplementor |	realImplementor := ( anInterfaceBinding isCOMInterfacePointer		ifTrue: [ anInterfaceBinding ]		ifFalse: [			"Assert isTrue: [ anInterfaceBinding isCOMInterfaceImplementation ]."			anInterfaceBinding implementor ] ).	^self new		interfaceBinding: anInterfaceBinding;		implementor: realImplementor;		yourself</body><body package="Com- Ole Development">installOn: anInterface	" Create and install a new instance of the receiver to provide tracing on function calls through &lt;anInterface&gt;. "	| anInterfaceBinding aTraceAdaptor |	"Assert isTrue: [ anInterface isCOMInterface and: [ anInterface isCOMInterfaceBinding not ] ]."	anInterface traceAdaptor notNil		ifTrue: [ ^anInterface ].  " already installed "	anInterfaceBinding := anInterface interfaceBinding.	aTraceAdaptor := self for: anInterface.	anInterfaceBinding isCOMInterfacePointer		ifTrue: [			" install the trace adaptor in place of the callout binding "			"Assert isTrue: [ aTraceAdaptor implementor == anInterface implementor ]."			anInterface implementor: aTraceAdaptor ].	anInterfaceBinding isCOMInterfaceImplementation		ifTrue: [			" install the trace adaptor in place of the callin binding's implementor "			"Assert isTrue: [ aTraceAdaptor implementor == anInterfaceBinding implementor ]."			anInterfaceBinding implementor: aTraceAdaptor.			].	^anInterface</body></methods><methods><class-id>External.COMInterfaceTraceAdaptor class</class-id> <category>tracing</category><body package="Com- Ole Development">removeTracingOn: anInterface	" Remove the trace adaptor on &lt;anInterface&gt;. "	| aTraceAdaptor anInterfaceBinding |	aTraceAdaptor := anInterface traceAdaptor.	aTraceAdaptor isNil		ifTrue: [ ^anInterface ].	anInterfaceBinding := anInterface interfaceBinding.	anInterfaceBinding isCOMInterfacePointer		ifTrue: [ anInterface implementor: aTraceAdaptor implementor ].	anInterfaceBinding isCOMInterfaceImplementation		ifTrue: [ anInterfaceBinding implementor: aTraceAdaptor implementor ].	^anInterface</body></methods><methods><class-id>External.IUnknownTraceAdaptor</class-id> <category>private-accessing</category><body package="Com- Ole Development">assumeHRESULTReturnValues	" Private - answer whether the interface being traced returns HRESULT from all its functions. "	^assumeHRESULTReturnValues</body><body package="Com- Ole Development">assumeHRESULTReturnValues: aBoolean	" Private - specify whether the interface being traced returns HRESULT from all its functions. "	assumeHRESULTReturnValues := aBoolean.</body></methods><methods><class-id>External.IUnknownTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">QueryInterface: iid _: resultReference	" Invoke the IUnknown::QueryInterface function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self logIID: iid].	[hresult := implementor QueryInterface: iid _: resultReference] on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: [self logInterfaceResultValue: resultReference value tag: 'Interface'].			self logHRESULT: hresult].	^hresult</body><body package="Com- Ole Development">basicQueryInterface: iid _: resultReference	" Invoke the IUnknown::QueryInterface function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	"Assert isEqual: traceContext functionSelector to: #QueryInterface:_:."	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self logIID: iid].	[hresult := implementor basicQueryInterface: iid _: resultReference]		on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: [self logInterfaceResultValue: resultReference value tag: 'Interface'].			self logHRESULT: hresult].	^hresult</body><body package="Com- Ole Development">innerAddRef	" Invoke the IUnknown::AddRef function. "	| traceContext referenceCount |	traceContext := self constructFunctionTraceContextForContext: thisContext.	"Assert isEqual: traceContext functionSelector to: #AddRef."	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		].	[	referenceCount := implementor innerAddRef.	] on: Error 		do: ( self exceptionHandlerForZeroReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logValue: referenceCount			tag: 'Returning ref count'.		].	^referenceCount</body><body package="Com- Ole Development">innerQueryInterface: iid _: resultReference	" Invoke the IUnknown::QueryInterface function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	"Assert isEqual: traceContext functionSelector to: #QueryInterface:_:."	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self logIID: iid].	[hresult := implementor innerQueryInterface: iid _: resultReference]		on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: [self logInterfaceResultValue: resultReference value tag: 'Interface'].			self logHRESULT: hresult].	^hresult</body><body package="Com- Ole Development">innerRelease	" Invoke the IUnknown::Release function. "	| traceContext referenceCount |	traceContext := self constructFunctionTraceContextForContext: thisContext.	"Assert isEqual: traceContext functionSelector to: #Release."	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		].	[	referenceCount := implementor innerRelease.	] on: Error 		do: ( self exceptionHandlerForZeroReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logValue: referenceCount			tag: 'Returning ref count'.		].	^referenceCount</body></methods><methods><class-id>External.IUnknownTraceAdaptor</class-id> <category>subclass-interface operations</category><body package="Com- Ole Development">invokeInterfaceFunction: traceContext	" Invoke the interface function whose invocation is described by &lt;traceContext&gt;.  Dispatch the message to the implementing object. "	^assumeHRESULTReturnValues		ifTrue: [ 			self invokeInterfaceFunctionWithHRESULTTrace: traceContext ]		ifFalse: [ 			self invokeInterfaceFunctionWithFullTrace: traceContext ]</body></methods><methods><class-id>External.IUnknownTraceAdaptor</class-id> <category>obsolete</category><body package="Com- Ole Development">AddRef	" Invoke the IUnknown::AddRef function. "	self callIsDispensable.</body><body package="Com- Ole Development">Release	self callIsDispensable.</body><body package="Com- Ole Development">decrementReferenceCount	" Decrement the reference count of the interface referenced by the receiver. "	| traceContext referenceCount |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionEntry: traceContext.		 ].	[	referenceCount := implementor privateDecrementReferenceCount.	] on: Error 		do: ( self exceptionHandlerForZeroReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logValue: referenceCount			tag: 'Ref count'.		].	^referenceCount</body></methods><methods><class-id>External.IUnknownTraceAdaptor</class-id> <category>private</category><body package="Com- Ole Development">privateDecrementReferenceCount	" Decrement the reference count of the interface referenced by the receiver. "	| traceContext referenceCount |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionEntry: traceContext.		 ].	[	referenceCount := implementor privateDecrementReferenceCount.	] on: Error 		do: ( self exceptionHandlerForZeroReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logValue: referenceCount			tag: 'Ref count'.		].	^referenceCount</body></methods><methods><class-id>External.IUnknownTraceAdaptor</class-id> <category>private interface operations</category><body package="Com- Ole Development">privateAddRef	" Invoke the IUnknown::AddRef function. "	| traceContext referenceCount |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		].	[	referenceCount := implementor enforceAddRef.	] on: Error 		do: ( self exceptionHandlerForZeroReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logValue: referenceCount			tag: 'Returning ref count'.		].	^referenceCount</body><body package="Com- Ole Development">privateRelease	" Invoke the IUnknown::Release function. "	| traceContext referenceCount |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionEntry: traceContext.		 ].	[	referenceCount := implementor enforceRelease.	] on: Error 		do: ( self exceptionHandlerForZeroReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logValue: referenceCount			tag: 'Returning ref count'.		].	^referenceCount</body></methods><methods><class-id>External.IUnknownTraceAdaptor</class-id> <category>private-stack accessing</category><body package="Com- Ole Development">functionSelectorFromContext: aMethodContext	" Answer the interface function selector for the invocation represented by &lt;aMethodContext&gt;. "	| functionSelector |	functionSelector := super functionSelectorFromContext: aMethodContext.	( #( #innerAddRef #innerRelease #innerQueryInterface:_: ) includes: functionSelector )		ifTrue: [ ^( functionSelector copyFrom: 'inner' size + 1 to: functionSelector size ) asSymbol ].	( #( #privateAddRef #privateRelease) includes: functionSelector )		ifTrue: [ ^( functionSelector copyFrom: 'private' size + 1 to: functionSelector size ) asSymbol ].	( #( #enforceAddRef #enforceRelease) includes: functionSelector )		ifTrue: [ ^( functionSelector copyFrom: 'enforce' size + 1 to: functionSelector size ) asSymbol ].	( #( #basicQueryInterface:_: ) includes: functionSelector )		ifTrue: [ ^( functionSelector copyFrom: 'basic' size + 1 to: functionSelector size ) asSymbol ].	^functionSelector</body></methods><methods><class-id>External.IUnknownTraceAdaptor</class-id> <category>civilized operations</category><body package="Com- Ole Development">enforceDecRef	" Decrement the reference count of the interface referenced by the receiver. "	^self privateDecrementReferenceCount</body></methods><methods><class-id>External.IUnknownTraceAdaptor class</class-id> <category>instance creation</category><body package="Com- Ole Development">for: anInterface	" Answer a new instance of the receiver which can provide tracing on function calls through &lt;anInterface&gt;. "	^( super for: anInterface )		assumeHRESULTReturnValues: anInterface class canTraceAdaptorAssumeHRESULT;		yourself</body></methods><methods><class-id>External.IUnknownTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IUnknown.</body></methods><methods><class-id>External.IPersistTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">GetClassID: resultReference	" Invoke the IPersist::GetClassID function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [self logFunctionHeader: traceContext].	[hresult := implementor GetClassID: resultReference] on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded ifTrue: [self logCLSID: resultReference value].			self logHRESULT: hresult].	^hresult</body></methods><methods><class-id>External.IPersistTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IPersist.</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>configuring-installation</category><body package="Com- Ole Development">activateTracing	" Activate tracing on any interfaces already in use in this session.  Only exported interfaces and specially known interface pointers can be dynamically modified in this fashion.  In general, any outgoing interfaces already owned by this session will not have tracing installed.  This operation should only be called after the receiver has just been installed into an active session. "	COMSessionManager specialSessionResources keys do: [ :anInterface |		anInterface traceAdaptor isNil			ifTrue: [ self installTracingOn: anInterface ] ].	COMSessionManager allExportedObjects do: [ :aCOMObject |		aCOMObject allocatedInterfacesDo: [ :anInterface |			| anInterfaceBinding |			( ( anInterfaceBinding := anInterface interfaceBinding ) isCOMInterfaceImplementation			and: [ anInterfaceBinding traceAdaptor isNil ] )				ifTrue: [ self installTracingOn: anInterface ].			] ]."	| anInterfaceClass |	COMSessionManager allExportedInterfaces do: [ :anInterfaceImpl |		anInterfaceImpl traceAdaptor isNil			ifTrue: [				anInterfaceClass := anInterfaceImpl class interfaceReferenceClass.				self installTracingOn: ( anInterfaceClass on: anInterfaceImpl ) ].		]."</body><body package="Com- Ole Development">deactivateTracing	" Deactivate tracing on any interfaces already in use in this session.  Only specially known interface pointers are dynamically modified in this fashion.  This operation should only be called when the receiver is being uninstalled in an active session. "	COMSessionManager specialSessionResources keys do: [ :anInterface |		anInterface traceAdaptor notNil			ifTrue: [ self removeTracingOn: anInterface ] ].</body><body package="Com- Ole Development">installTraceSupport	" Register the receiver as the COM session trace manager "	" COMTraceManager installTraceSupport "	COMSessionManager traceManager: self</body><body package="Com- Ole Development">uninstallTraceSupport	" Remove the registration of the receiver as the COM session trace manager "	" COMTraceManager uninstallTraceSupport "	self checkUninstallAllowed.	COMSessionManager traceManager == self		ifTrue: [COMSessionManager traceManager: nil]</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>adaptor registration</category><body package="Com- Ole Development">adaptorClassForIID: anIID	" Answer the trace adaptor class for the interface identified by &lt;anIID&gt;.  Answer nil if no trace adaptor is registered for this interface. "	^self traceAdaptorMap at: anIID		ifAbsent: [ nil ]</body><body package="Com- Ole Development">registerAdaptorClass: aClass forIID: anIID	" Register &lt;aClass&gt; as the interface adaptor class providing tracing on the interface identified by &lt;anIID&gt;. "	self traceAdaptorMap isNil		ifTrue: [ self initializeTraceAdaptorMap ].	self traceAdaptorMap at: anIID put: aClass.</body><body package="Com- Ole Development">removeAdaptorClassForIID: anIID	" Remove the registration of the interface adaptor class providing tracing on the interface identified by &lt;anIID&gt;. "	self traceAdaptorMap removeKey: anIID ifAbsent: [].</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>configuring-trace options</category><body package="Com- Ole Development">callinAndCalloutTraceOptions	" Answer the options for tracing all incoming and outgoing interface function calls. "	^#( #externalCallin #externalCallout )</body><body package="Com- Ole Development">callinOnlyTraceOptions	" Answer the options for tracing only incoming interface function calls. "	^#( #externalCallin )</body><body package="Com- Ole Development">calloutOnlyTraceOptions	" Answer the options for tracing only outgoing interface function calls. "	^#( #externalCallout )</body><body package="Com- Ole Development">disableLogging	" Disable trace logging. "	" COMTraceManager disableLogging "	self traceEnabled: false.</body><body package="Com- Ole Development">disableTraceType: traceType forIID: anIID	" Disable tracing of the option type &lt;traceType&gt; for the interface identified by &lt;anIID&gt;. "	| currentOptions newOptions |	self checkTraceType: traceType.	currentOptions := self interfaceTraceOptionsRegistry at: anIID 		ifAbsent: [ nil ].	newOptions := self newOptionsToDisable: traceType from: currentOptions.	newOptions isNil		ifTrue: [ ^self ].  " already disabled "	newOptions = #( #none )		ifTrue: [			self interfaceTraceOptionsRegistry removeKey: anIID ifAbsent: [].			^self ].	self interfaceTraceOptionsRegistry at: anIID 		put: newOptions.</body><body package="Com- Ole Development">enableLogging	" Enable trace logging. "	" COMTraceManager enableLogging "	self traceLog isNil 		ifTrue: [self error: #ErrNoTraceDest &lt;&lt; #com &gt;&gt; 'no trace destination configured'].	self traceEnabled: true</body><body package="Com- Ole Development">enableTraceType: traceType forIID: anIID	" Enable tracing of the option type &lt;traceType&gt; for the interface identified by &lt;anIID&gt;. "	| currentOptions newOptions |	self checkTraceType: traceType.	self checkTraceAllowedForIID: anIID.	currentOptions := self interfaceTraceOptionsRegistry at: anIID 		ifAbsent: [ nil ].	newOptions := self newOptionsToEnable: traceType from: currentOptions.	newOptions isNil		ifTrue: [ ^self ].  " already enabled "	self interfaceTraceOptionsRegistry at: anIID 		put: newOptions.</body><body package="Com- Ole Development">registerInterfaceTraceOptions: traceOptions forIID: anIID	" Register &lt;traceOptions&gt; as the tracing control options for the interface identified by &lt;anIID&gt;. "	self interfaceTraceOptionsRegistry isNil		ifTrue: [ self initializeInterfaceTraceOptionsRegistry ].	( traceOptions isNil or: [ traceOptions = #( #none ) ] )		ifTrue: [  " disable tracing of this interface "			self interfaceTraceOptionsRegistry removeKey: anIID ifAbsent: [].			^traceOptions ].	self checkTraceAllowedForIID: anIID.	traceOptions = #( #all )		ifTrue: [ 			self interfaceTraceOptionsRegistry at: anIID 				put: self supportedTraceTypes.			^self ].	 " validate the specific trace types "	traceOptions do: [ :aTraceType | 		self checkTraceType: aTraceType ].	self interfaceTraceOptionsRegistry at: anIID 		put: traceOptions.</body><body package="Com- Ole Development">supportedTraceOptions	" Answer the names of the supported trace options that can be specified for interfaces. "	^self supportedTraceTypes, #( #all #none )</body><body package="Com- Ole Development">supportedTraceTypes	" Answer the names of the supported trace types for interfaces. "	^#( #externalCallin #internalCallin #externalCallout )</body><body package="Com- Ole Development">traceCallin: aBoolean	" Specify whether interface function invocations from external callers are traced when COM tracing is enabled. "	TraceCallin := aBoolean.</body><body package="Com- Ole Development">traceCallout: aBoolean	" Specify whether interface function invocations through external interface pointers are traced when COM tracing is enabled. "	TraceCallout := aBoolean.</body><body package="Com- Ole Development">traceEnabled: aBoolean	" Specify whether any trace logging is enabled. "	TraceEnabled := aBoolean.</body><body package="Com- Ole Development">traceInternalCalls: aBoolean	" Answer whether interface function invocations from internal callers on internal interface implementations are traced when COM tracing is enabled. "	TraceInternalCalls := aBoolean.</body><body package="Com- Ole Development">traceOptionsForIID: anIID	" Answer the currently registered tracing control options for the interface identified by &lt;anIID&gt;. "	^self interfaceTraceOptionsRegistry at: anIID 		ifAbsent: [ #( #none ) ]</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>private-configuring</category><body package="Com- Ole Development">clearTraceLog	" Private - clear the trace log and disable logging.. "	self		traceLog: nil;		disableLogging.</body><body package="Com- Ole Development">newOptionsToDisable: traceType from: currentOptions	" Private - answer the updated set of options to register, given &lt;currentOptions&gt;, to disable &lt;traceType&gt;.  Answer nil if the option is already disable and no change is needed. "	currentOptions isNil		ifTrue: [ ^nil ].	( currentOptions includes: traceType )		ifFalse: [ ^nil ].  " already disabled "	^currentOptions = ( Array with: traceType ) 		ifTrue: [ #( #none ) ]		ifFalse: [ currentOptions asOrderedCollection remove: traceType; asArray ]</body><body package="Com- Ole Development">newOptionsToEnable: traceType from: currentOptions	" Private - answer the updated set of options to register, given &lt;currentOptions&gt;, to enable &lt;traceType&gt;.  Answer nil if the option is already enabled and no change is needed. "	currentOptions isNil		ifTrue: [ ^Array with: traceType ].	^( currentOptions includes: traceType )		ifTrue: [ nil ]  " already set "		ifFalse: [ currentOptions, ( Array with: traceType ) ]</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>private-tracing</category><body package="Com- Ole Development">closeLogWindow: logPane	" Private - a log window for logging debug trace has been closed. "	self traceLog == logPane		ifTrue: [ self clearTraceLog ].</body><body package="Com- Ole Development">describeStackEntries: callStack includeArgInfo: includeArgInfoFlag on: aStream	" Private - describe the call stack entries in &lt;callStack&gt; on &lt;aStream&gt;. "	| aContext |	Tools.Note ISSUE.  " This is grungy low-level logic which is replicated both here		and in the COMInterfaceImplementation callin error reporting.  		Figure out where to consolidate this logic (possibly even in Context, 		along the lines of VSE walkback description service).  [DL 18-Sep-96] "	aContext := callStack.	[ aContext notNil ] 		whileTrue: [			aStream nextPutAll: '   '. aContext printOn: aStream. aStream cr.			includeArgInfoFlag ifTrue: [  			" describe method arguments and temps "			aContext class = MethodContext				ifTrue: [					| indent nArgs tempNames |					indent := '        '.					nArgs := MessageSend numberOfArgumentsFor: aContext selector.					tempNames := aContext tempNames.					nArgs &gt; 0						ifTrue: [							aStream nextPutAll: indent; nextPutAll: (#Arguments &lt;&lt; #com &gt;&gt; '-- arguments --') asString; cr.							1 to: nArgs do: [ :i |								aStream nextPutAll: indent; 									nextPutAll: ( tempNames at: i );									nextPutAll: ': ';									nextPutAll: ( aContext tempAt: i ) printString; cr ] ].					tempNames size &gt; nArgs						ifTrue: [							aStream nextPutAll: indent; nextPutAll: (#Temps &lt;&lt; #com &gt;&gt; '-- temps --') asString; cr.							( nArgs + 1 ) to: tempNames size do: [ :i |								aStream nextPutAll: indent; 									nextPutAll: ( tempNames at: i );									nextPutAll: ': ';									nextPutAll: ( aContext tempAt: i ) printString; cr ] ].					].			].		aContext := aContext sender ].</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>configuring-log destination</category><body package="Com- Ole Development">defaultLogFileName	" Answer the name of the default trace log file. "	^'COMTrace.log'</body><body package="Com- Ole Development">logFileName	" Answer the name of the trace log file if tracing is currently configured to log to a file; otherwise answer nil. "	| logDestination |	logDestination := self traceLog.	^logDestination isString		ifTrue: [ logDestination ]		ifFalse: [ nil ]</body><body package="Com- Ole Development">logToFile	" Enable trace logging to the default log file. "	" COMTraceManager logToFile "	self logToFile: self defaultLogFileName.</body><body package="Com- Ole Development">logToFile: aFileName        " Enable trace logging to the file named &lt;aFileName&gt;. "	" COMTraceManager logToFile: 'COMTrace.log' "	self		traceLog: aFileName;		enableLogging.</body><body package="Com- Ole Development">logToTranscript	" Enable trace logging to the Transcript. "	" COMTraceManager logToTranscript "	self		traceLog: Transcript;		enableLogging.</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>configuring-tracing</category><body package="Com- Ole Development">getAdaptorClassFor: interfaceClassToTrace	" Answer the trace adaptor class which has been registered for &lt;interfaceClassToTrace&gt;.  The interface inheritance hierarchy is used to obtain an adaptor from a super-interface trace adaptor is possible. "	| anInterfaceClass aTraceAdaptorClass |	anInterfaceClass := interfaceClassToTrace.	[ anInterfaceClass ~~ COMInterface ]		whileTrue: [			aTraceAdaptorClass := self adaptorClassForIID: anInterfaceClass iid.			aTraceAdaptorClass notNil				ifTrue: [ ^aTraceAdaptorClass ].			anInterfaceClass := anInterfaceClass superclass ].	^nil</body><body package="Com- Ole Development">installTracingOn: anInterface	" Install a trace adaptor on &lt;anInterface&gt;. "	| anInterfaceClass aTraceAdaptorClass |	anInterfaceClass := anInterface class.	( anInterface class allowsTracing not	or: [ anInterface traceAdaptor notNil ] ) " already has tracing installed "		ifTrue: [ ^self ].	aTraceAdaptorClass := anInterfaceClass traceAdaptorClass.	aTraceAdaptorClass notNil		ifTrue: [ 			aTraceAdaptorClass installOn: anInterface.			^self ].	"TBD: otherwise install a COMBasicInterfaceAdaptor on the interface, but only if you add interface-specific trace control "</body><body package="Com- Ole Development">removeTracingOn: anInterface	" Remove the trace adaptor on &lt;anInterface&gt;. "	| aTraceAdaptor |	aTraceAdaptor := anInterface traceAdaptor.	aTraceAdaptor isNil		ifTrue: [ ^anInterface ].	aTraceAdaptor class removeTracingOn: anInterface.</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>private-initialization</category><body package="Com- Ole Development">initialize	" Private - initialize class state. "	self		traceCallout: true;		traceCallin: true;		traceInternalCalls: false;		clearTraceLog.	self interfaceTraceOptionsRegistry isNil		ifTrue: [self initializeInterfaceTraceOptionsRegistry].	self traceAdaptorMap isNil ifTrue: [self initializeTraceAdaptorMap].	"self registerSessionTraceManager."	" don't incur overhead of installation unless user really wants it "	Plugins		installPluginNamed: Plugins reportExternalFunctionEntryKey			block: [:receiver | receiver traceExternalFunctionEntry];		installPluginNamed: Plugins reportExternalFunctionInvalidArgExitKey			block: [:receiver | receiver traceExternalFunctionInvalidArgExit];		installPluginNamed: Plugins reportInvalidExternalArgKey			block: [:receiver :value :aName | receiver traceInvalidExternalArg: value name: aName];		installPluginNamed: Plugins installTracingKey			block: [:receiver | receiver installReporting]</body><body package="Com- Ole Development">initializeInterfaceTraceOptionsRegistry	" Private - initialize the interface trace options registry. "	self interfaceTraceOptionsRegistry: Dictionary new.</body><body package="Com- Ole Development">initializeTraceAdaptorMap	" Private - initialize the trace adaptor registry. "	self traceAdaptorMap: Dictionary new.</body><body package="Com- Ole Development">obsolete	"This class is being removed from the system."	Plugins		removePluginNamed: Plugins installTracingKey;		removePluginNamed: Plugins reportExternalFunctionEntryKey;		removePluginNamed: Plugins reportExternalFunctionInvalidArgExitKey;		removePluginNamed: Plugins reportInvalidExternalArgKey.	self uninstallTraceSupport.	^super obsolete</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>private-accessing</category><body package="Com- Ole Development">getTraceOptionsForIID: anIID	" Answer the trace options for the interface identified by &lt;anIID&gt;.  Do some special stuff so that multiple-identity interface binding classes such as IEnum and IDispatch get the right answer. "	| traceOptions anInterfaceClass |	traceOptions := self interfaceTraceOptionsRegistry at: anIID		ifAbsent: [ nil ].	traceOptions notNil		ifTrue: [ ^traceOptions ].	" handle cases where multiple IID's map onto a single interface wrapper class "	Tools.Note ISSUE.  " This may not be necessary now that the trace context goes		through the interface binding to find this out - this is now probably		redundant with the #isTraceTypeEnabled: predicates in the IDispatch bindings.		[DL 01-May-97] "	anInterfaceClass := COMInterface classForIID: anIID.	anInterfaceClass isNil		ifTrue: [ ^nil ].	anInterfaceClass iid ~= anIID		ifTrue: [ 			traceOptions := self interfaceTraceOptionsRegistry at: anInterfaceClass iid				ifAbsent: [ nil ] ].	^traceOptions</body><body package="Com- Ole Development">interfaceTraceOptionsRegistry	" Answer the mapping registry of IID's to interface trace option. "	^InterfaceTraceOptionsRegistry</body><body package="Com- Ole Development">interfaceTraceOptionsRegistry: aDictionary	" Specify the mapping registry of IID's to interface trace option. "	InterfaceTraceOptionsRegistry := aDictionary.</body><body package="Com- Ole Development">traceAdaptorMap	" Answer the mapping registry of IID's to interface trace adaptors. "	^TraceAdaptorMap</body><body package="Com- Ole Development">traceAdaptorMap: aDictionary	" Set the mapping registry of IID's to interface trace adaptors. "	TraceAdaptorMap := aDictionary.</body><body package="Com- Ole Development">traceLog	" Answer the current trace log (a pane or a file name). "	^TraceLog</body><body package="Com- Ole Development">traceLog: aPaneOrFileName	" Specify the current trace log (a pane or a file name). "	TraceLog := aPaneOrFileName.</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>testing-trace options</category><body package="Com- Ole Development">isTraceEnabled	" Answer whether any trace logging is enabled. "	^TraceEnabled and: [ self traceLog notNil ]</body><body package="Com- Ole Development">isTraceEnabledForIID: anIID	" Answer whether tracing of any sort is enabled for the interface identified by &lt;anIID&gt;. "	^self traceEnabled		and: [ ( self getTraceOptionsForIID: anIID ) notNil ]</body><body package="Com- Ole Development">isTraceTypeEnabled: traceType 	" Answer whether the specified type of tracing is currently enabled. "	self isTraceEnabled ifFalse: [^false].	traceType = #externalCallin ifTrue: [^self traceCallin].	traceType = #internalCallin ifTrue: [^self traceInternalCalls].	traceType = #externalCallout ifTrue: [^self traceCallout].	self error: #ErrUnsupportedTraceType &lt;&lt; #com &gt;&gt; 'unsupported trace type'</body><body package="Com- Ole Development">isTraceTypeEnabled: traceType forIID: anIID	" Answer whether tracing of the option type &lt;traceType&gt; is enabled for the interface identified by &lt;anIID&gt;. "	( self isTraceTypeEnabled: traceType )		ifFalse: [ ^false ].	^self isTraceTypeSet: traceType 		by: ( self getTraceOptionsForIID: anIID )</body><body package="Com- Ole Development">traceCallin	" Answer whether interface function invocations from external callers are traced when COM tracing is enabled. "	^TraceCallin</body><body package="Com- Ole Development">traceCallout	" Answer whether interface function invocations through external interface pointers are traced when COM tracing is enabled. "	^TraceCallout</body><body package="Com- Ole Development">traceEnabled	" Answer whether any trace logging is enabled. "	^TraceEnabled</body><body package="Com- Ole Development">traceInternalCalls	" Answer whether interface function invocations from internal callers on internal interface implementations are traced when COM tracing is enabled. "	^TraceInternalCalls</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>private-testing</category><body package="Com- Ole Development">checkTraceAllowedForIID: anIID	" Private - verify that tracing is allowed for the interface identified by &lt;anIID&gt;. "	| anInterfaceClass |	( anInterfaceClass := COMInterface classForIID: anIID ) allowsTracing		ifFalse: [ self error: ((#tracingNotAllowedFor1s &lt;&lt; #com &gt;&gt; 'tracing not allowed for &lt;1s&gt;')			expandMacrosWith: anInterfaceClass name) ].</body><body package="Com- Ole Development">checkTraceType: traceType	" Private - verify that &lt;traceType&gt; is a supported trace type. "	( self supportedTraceTypes includes: traceType )		ifFalse: [ self error: ((#unknownTraceTypeC1s &lt;&lt; #com &gt;&gt; 'unknown trace type: &lt;1s&gt;')			expandMacrosWith: traceType printString) ].</body><body package="Com- Ole Development">checkUninstallAllowed	" Private - don't let the trace manager be removed out from underneath an active trace viewer window. "	(self traceLog isNil or: 			[self traceLog isString or: [self traceLog == Transcript]	" logging to a file "]) 		ifTrue: [^self].	"Assert isTrue: [ traceLog is a text pane/text collector for a window ]."	self error: #ErrCantUninstallTracing &lt;&lt; #com 				&gt;&gt; 'uninstalling tracing not allowed while trace viewer window still active'</body><body package="Com- Ole Development">isTraceTypeSet: traceType by: traceOptions	" Answer whether the &lt;traceOptions&gt; includes &lt;traceType&gt;. "	traceOptions isNil		ifTrue: [ ^false ].	"^traceOptions = #( #all ) or: [ traceOptions includes: traceType ]"	^traceOptions includes: traceType</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>tracing services</category><body package="Com- Ole Development">log: aString	" Log a line containing &lt;aString&gt; to the COM trace log.  The caller is responsible for ensuring that tracing is currently enabled. "	self traceLog isString		ifTrue: [  " logging to a file "			| aStream |			aStream := "File pathName:" self traceLog asFilename readWriteStream.			aStream				setToEnd;				nextPutAll: aString; cr.			aStream close.]		ifFalse: [ " logging to aTextCollector for the Transcript or a log window text pane "			self traceLog nextPutAll: aString; cr; flush ].</body><body package="Com- Ole Development">logCallStack: nLevels	" Log &lt;nLevels&gt; of the call stack to the trace log.  The caller is responsible for ensuring that tracing is enabled. "	" COMTraceManager logCallStack: 10 "	| callStack walkbackDescription |	callStack := thisContext sender copyStackToDepth: nLevels.	walkbackDescription := ReadWriteStream on: ( String new: 100 ).	self describeStackEntries: callStack 		includeArgInfo: false		on: walkbackDescription.	self log: walkbackDescription contents.</body><body package="Com- Ole Development">logCallStackDetailed: nLevels	" Log &lt;nLevels&gt; of the call stack to the trace log.  Include argument and temp values.  The caller is responsible for ensuring that tracing is enabled. "	" COMTraceManager logCallStackDetailed: 10 "	| callStack walkbackDescription |	callStack := thisContext sender copyStackToDepth: nLevels.	walkbackDescription := ReadWriteStream on: ( String new: 100 ).	self describeStackEntries: callStack 		includeArgInfo: true		on: walkbackDescription.	self log: walkbackDescription contents.</body><body package="Com- Ole Development">logCr	" Log an empty line to the COM trace log. The caller is responsible for ensuring that tracing is enabled. "	self log: ''.</body><body package="Com- Ole Development">logIfTraceEnabled: traceEntry	" Append &lt;traceEntry&gt; to the COM trace log if tracing is currently enabled. "	self isTraceEnabled		ifTrue: [ self logTraceEntry: traceEntry ].</body><body package="Com- Ole Development">logTraceEntry: traceEntry	" Append the value of &lt;traceEntry&gt; to the COM trace log.  The &lt;traceEntry&gt; can be either a string or a block which returns a string.  The caller is responsible for ensuring that tracing is enabled. "	| aString |	aString := ( traceEntry isStringOrUserMessage		ifTrue: [ traceEntry ]		ifFalse: [ traceEntry value ] ) asString.	self log: aString.</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>instance creation</category><body package="Com- Ole Development">new        " Disallow the instantiation of trace manager instances.		This is an abstract class which provides general services. "    ^self shouldNotImplement</body></methods><methods><class-id>External.COMTraceManager class</class-id> <category>parcel load/unload/save</category><body package="Com- Ole Development">postLoadActionFor: aParcel	"		self postLoadActionFor: nil 		"	" Class Initializers "	" Interface Binding Validation "	COMInterfacePointer allSubclassesDo: [:each | each checkVTableValidity].	" Interface VTable Initializers "	COMInterfaceImplementation		allSubclassesDo: [:each | each checkVTableValidity].	" register default interface trace options "	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IUnknown.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IClassFactory.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IEnum.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IDataObject.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IPersist.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IPersistFile.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IPersistStorage.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IPersistStream.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager calloutOnlyTraceOptions		forIID: IID_IMoniker.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IAdviseSink.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IAdviseSink2.	#{Examples.IRandomNumberGenerator} ifDefinedDo: 			[:itf |			COMTraceManager				registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions				forIID: itf iid].	#{Examples.IAllDataTypesDisp} ifDefinedDo: 			[:itf |			COMTraceManager				registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions				forIID: itf iid].	#{Examples.ISmalltalkCommanderDisp} ifDefinedDo: 			[:itf |			COMTraceManager				registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions				forIID: itf iid]</body></methods><methods><class-id>External.IMallocTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">Alloc: anInteger	" Invoke the IMalloc::Alloc function. "	| traceContext anAddress |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		].	[	anAddress := implementor Alloc: anInteger.	] on: Error 		do: ( self exceptionHandlerForUnspecifiedReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logValue: anAddress tag: 'Allocated'.		].	^anAddress</body><body package="Com- Ole Development">DidAlloc: aCOMAddress	" Invoke the IMalloc::DidAlloc function. "	| traceContext result |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionEntry: traceContext.		 ].	[	result := implementor DidAlloc: aCOMAddress.	] on: Error 		do: ( self exceptionHandlerForUnspecifiedReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logString: result printString, ' (', ( result = 1 ) printString, ')'			tag: 'Returns' ].	^result</body><body package="Com- Ole Development">Free: aCOMAddress	" Invoke the IMalloc::Free function. "	| traceContext result |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionEntry: traceContext.		 ].	[	result := implementor Free: aCOMAddress.	] on: Error 		do: ( self exceptionHandlerForUnspecifiedReturnValue: traceContext ).	^result</body></methods><methods><class-id>External.IMallocTraceAdaptor</class-id> <category>extended operations</category><body package="Com- Ole Development">alloc: anInteger addressType: aCOMAddressClass	" Invoke the IMalloc::Alloc function. "	| traceContext anAddress |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		].	[	anAddress := implementor alloc: anInteger addressType: aCOMAddressClass.	] on: Error 		do: ( self exceptionHandlerForUnspecifiedReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logValue: anAddress tag: 'Allocated'.		].	^anAddress</body></methods><methods><class-id>External.IMallocTraceAdaptor</class-id> <category>private-stack accessing</category><body package="Com- Ole Development">functionSelectorFromContext: aMethodContext	" Answer the interface function selector for the invocation represented by &lt;aMethodContext&gt;. "	| functionSelector |	functionSelector := super functionSelectorFromContext: aMethodContext.	functionSelector = #alloc:addressType:		ifTrue: [ ^#Alloc: ].	^functionSelector</body></methods><methods><class-id>External.IMallocTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IMalloc.</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>subclass-definition attributes</category><body package="Com- Ole Development">classCategoryName	" Answer the names of the class category to define for the class. "	^'COM-Interface Binding Prototypes'</body><body package="Com- Ole Development">classComment	" Answer a string containing the class comment for the interface wrapper class. "	self subclassResponsibility.</body><body package="Com- Ole Development">classImportsString	" Answer the imports necessary for this class"	^'External.GUID.COMConstants.* External.GUID.COMStatusCodeConstants.*'</body><body package="Com- Ole Development">classInitializationMethodName	" Answer the name of the class initializer method. "	^'initialize'</body><body package="Com- Ole Development">classInitializationMethodsCategoryName	^ #'private-installation'</body><body package="Com- Ole Development">defaultTypeDefinitionClassName	"Answer a Symbol that indicates the class which defines types transitively reached from an interface table type declaration."	^self class defaultTypeDefinitionClassName</body><body package="Com- Ole Development">functionExternalMethodsCategoryName	^ #'private-invocation'</body><body package="Com- Ole Development">functionMethodsCategoryName	^ #'interface operations'</body><body package="Com- Ole Development">functionSelectorAnonymousKeyword	" Answer the anonymous keyword to use for argument keywords when forming a function method selector. "	^'_'</body><body package="Com- Ole Development">iidDefinitionString	| anIID iidConstantName |	anIID := self interfaceSpec				ifNil: [self class iidFor: self interfaceName]				ifNotNil: [self interfaceSpec iid].	anIID isNil		ifTrue: 			[^(self class incompleteMark: #DefineIIDConstant &lt;&lt; #com						&gt;&gt; '''### DEFINE IID CONSTANT HERE ###''')				asString].	iidConstantName := COMConstants keyAtValueEqual: anIID ifAbsent: [nil].	iidConstantName notNil ifTrue: [^iidConstantName].	^'" ''' , anIID asString , ''' asGUID "'		, (String with: Character cr with: Character tab) , ' ( GUID fromBytes: '		, anIID hexByteString , ' )'</body><body package="Com- Ole Development">interfaceClassNameSuffix	self subclassResponsibility.</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>private-argument analysis</category><body package="Com- Ole Development">computeArgumentAttributesForBSTR: anArgumentDescription	" Private - answer the argument processing attributes for a BSTR argument.  Answer nil if &lt;anArgumentDescription&gt; is not a BSTR. "	| argType |	argType := anArgumentDescription type.	argType name = #BSTR		ifTrue: [ 			^self constructAttributesForDirection: #in				spec: ( self class argumentProcessingSpecificationsFor: #BSTR ) ].	( argType isPointer and: [ argType referentType name = #BSTR ] )		ifTrue: [			^self constructAttributesForDirection: #out				spec: ( self class argumentProcessingSpecificationsFor: #BSTR ) ].	^nil</body><body package="Com- Ole Development">computeArgumentAttributesForCURRENCY: anArgumentDescription	" Private - answer the argument processing attributes for a CURRENCY argument.  Answer nil if &lt;anArgumentDescription&gt; is not a CURRENCY. "	| argType pointerLevelCount direction |	argType := anArgumentDescription type.	( COMExternalInterface getFundamentalTypeOf: argType ) = ( COMExternalInterface getFundamentalTypeOf: COMExternalInterface current CY )		ifFalse: [ ^nil ].	pointerLevelCount := self pointerLevelCountOf: argType.	Assert isTrue: [ pointerLevelCount between: 0 and: 1 ].	direction := ( pointerLevelCount = 0		ifTrue: [ #in ]		ifFalse: [ #out ] ).	^self constructAttributesForDirection: direction		spec: ( self class argumentProcessingSpecificationsFor: #CURRENCY )</body><body package="Com- Ole Development">computeArgumentAttributesForDATE: anArgumentDescription	" Private - answer the argument processing attributes for a DATE argument.  Answer nil if &lt;anArgumentDescription&gt; is not a DATE. "	| argType |	argType := anArgumentDescription type.	argType name = #DATE		ifTrue: [ 			^self constructAttributesForDirection: #in				spec: ( self class argumentProcessingSpecificationsFor: #DATE ) ].	( argType isPointer and: [ argType referentType name = #DATE ] )		ifTrue: [			^self constructAttributesForDirection: #out				spec: ( self class argumentProcessingSpecificationsFor: #DATE ) ].	^nil</body><body package="Com- Ole Development">computeArgumentAttributesForGUID: anArgumentDescription	" Private - answer the argument processing attributes for a GUID argument.  Answer nil if &lt;anArgumentDescription&gt; is not a GUID. "	| pointerLevelCount direction specName |	(self isGUIDArgument: anArgumentDescription) ifFalse: [^nil].	pointerLevelCount := self pointerLevelCountOf: anArgumentDescription type.	"actually, we never see level 2 and in fact you cannot differentiate between an #in and an #out GUID arg, oh well "	specName := #GUID.	direction := pointerLevelCount = 2 ifTrue: [#out] ifFalse: [#in].	^self constructAttributesForDirection: direction		spec: (self class argumentProcessingSpecificationsFor: specName)</body><body package="Com- Ole Development">computeArgumentAttributesForInterface: anArgumentDescription	" Private - answer the argument processing attributes for an interface argument.  Answer nil if &lt;anArgumentDescription&gt; is not an interface value. "	|  pointerLevelCount direction |	( self isInterfaceArgument: anArgumentDescription )		ifFalse: [ ^nil ].	pointerLevelCount := self pointerLevelCountOf: anArgumentDescription type.	Assert isTrue: [ pointerLevelCount between: 1 and: 2 ].	direction := ( pointerLevelCount = 1		ifTrue: [ #in ]		ifFalse: [ #out ] ).	^self constructAttributesForDirection: direction		spec: ( self class argumentProcessingSpecificationsFor: #interface )</body><body package="Com- Ole Development">computeArgumentAttributesForSAFEARRAY: anArgumentDescription	" Private - answer the argument processing attributes for a SAFEARRAY argument.  Answer nil if &lt;anArgumentDescription&gt; is not a SAFEARRAY. "	| argType safeArrayType pointerLevelCount direction |	argType := anArgumentDescription type.	safeArrayType := COMExternalInterface current SAFEARRAY.	( COMExternalInterface getFundamentalTypeOf: argType ) = ( COMExternalInterface getFundamentalTypeOf: safeArrayType )		ifFalse: [ ^nil ].	pointerLevelCount := self pointerLevelCountOf: argType.	Assert isTrue: [ pointerLevelCount between: 1 and: 2 ].	direction := ( pointerLevelCount = 1		ifTrue: [ #in ]		ifFalse: [ #out ] ).	^self constructAttributesForDirection: direction		spec: ( self class argumentProcessingSpecificationsFor: #SAFEARRAY )</body><body package="Com- Ole Development">computeArgumentAttributesForScalar: anArgumentDescription	" Private - answer the argument processing attributes for a scalar argument.  Answer nil if &lt;anArgumentDescription&gt; is not a scalar value. "	|  pointerLevelCount direction |	( self isScalarArgument: anArgumentDescription )		ifFalse: [ ^nil ].	pointerLevelCount := self pointerLevelCountOf: anArgumentDescription type.	Assert isTrue: [ pointerLevelCount between: 0 and: 1 ].	direction := ( pointerLevelCount = 0		ifTrue: [ #in ]		ifFalse: [ #out ] ).	^self constructAttributesForDirection: direction		spec: ( self class argumentProcessingSpecificationsFor: #scalar )</body><body package="Com- Ole Development">computeArgumentAttributesForString: anArgumentDescription 	" Private - answer the argument processing attributes for a string argument.  Answer nil if &lt;anArgumentDescription&gt; is not a string. "	| charType stringType pointerLevelCount direction |	(self isStringArgument: anArgumentDescription) ifFalse: [^nil].	charType := COMExternalInterface 				getFundamentalTypeOf: anArgumentDescription type.	charType = CIntegerType char ifTrue: [stringType := #platformString].	charType = CIntegerType unsignedChar ifTrue: [stringType := #platformString].	charType = CIntegerType short ifTrue: [stringType := #string].	charType = CIntegerType unsignedShort ifTrue: [stringType := #string].	stringType isNil 		ifTrue: [self error: #ErrStringType &lt;&lt; #com &gt;&gt; 'string type problem'].	pointerLevelCount := self pointerLevelCountOf: anArgumentDescription type.	Assert isTrue: [pointerLevelCount between: 1 and: 2].	direction := pointerLevelCount = 1 ifTrue: [#in] ifFalse: [#out].	^self constructAttributesForDirection: direction		spec: (self class argumentProcessingSpecificationsFor: stringType)</body><body package="Com- Ole Development">computeArgumentAttributesForStructure: anArgumentDescription	" Private - answer the argument processing attributes for a structure argument.  Answer nil if &lt;anArgumentDescription&gt; is not a structure value. "	|  pointerLevelCount structureType direction |	( self isStructureArgument: anArgumentDescription )		ifFalse: [ ^nil ].	pointerLevelCount := self pointerLevelCountOf: anArgumentDescription type.	Assert isTrue: [ pointerLevelCount between: 0 and: 2 ].	pointerLevelCount = 0		ifTrue: [			structureType := #structureDatum.			direction := #in ]		ifFalse: [ 			structureType := #structure.			direction := ( pointerLevelCount = 1				ifTrue: [ #inOut ]  " usually this is simply #in, but in some cases is also #inOut "				ifFalse: [ #out ] ) ].	^self constructAttributesForDirection: direction		spec: ( self class argumentProcessingSpecificationsFor: structureType )</body><body package="Com- Ole Development">computeArgumentAttributesForVARIANT: anArgumentDescription	" Private - answer the argument processing attributes for a VARIANT argument.  Answer nil if &lt;anArgumentDescription&gt; is not a VARIANT. "	| argType fundamentalType pointerLevelCount direction |	argType := anArgumentDescription type.	fundamentalType := COMExternalInterface getFundamentalTypeOf: argType.	fundamentalType = ( COMExternalInterface getFundamentalTypeOf: COMExternalInterface current VARIANT )		ifFalse: [ ^nil ].	pointerLevelCount := self pointerLevelCountOf: anArgumentDescription type.	Assert isTrue: [ pointerLevelCount between: 0 and: 2 ].	direction := ( #( #in #inOut #out ) at: pointerLevelCount + 1 ).	^self constructAttributesForDirection: direction		spec: ( self class argumentProcessingSpecificationsFor: #VARIANT )</body><body package="Com- Ole Development">computeArgumentAttributesForVARIANT_BOOL: anArgumentDescription	" Private - answer the argument processing attributes for a VARIANT_BOOL argument.  Answer nil if &lt;anArgumentDescription&gt; is not a VARIANT_BOOL. "	| argType |	argType := anArgumentDescription type.	argType name = #VARIANT_BOOL		ifTrue: [ 			^self constructAttributesForDirection: #in				spec: ( self class argumentProcessingSpecificationsFor: #VARIANT_BOOL ) ].	( argType isPointer and: [ argType referentType name = #VARIANT_BOOL ] )		ifTrue: [			^self constructAttributesForDirection: #out				spec: ( self class argumentProcessingSpecificationsFor: #VARIANT_BOOL ) ].	^nil</body><body package="Com- Ole Development">computeArgumentAttributesOf: anArgumentDescription	" Private - infer the type and likely direction of the argument "	| attributes |	self class argumentAnalysisSelectors do: [ :aOneArgSelector |		attributes := self perform: aOneArgSelector with: anArgumentDescription.		attributes notNil			ifTrue: [ ^anArgumentDescription attributes: attributes ].		].	self standardArgumentCategoryAnalyzers do: [ :aOneArgSelector |		attributes := self perform: aOneArgSelector with: anArgumentDescription.		attributes notNil			ifTrue: [ ^anArgumentDescription attributes: attributes ].		].	" otherwise install the defaults "	attributes := self constructAttributesForDirection: #in 		spec: ( self class argumentProcessingSpecificationsFor: #unknown ).	anArgumentDescription attributes: attributes.</body><body package="Com- Ole Development">constructAttributesForDirection: aDirection spec: anArgProcessingSpec	" Private "	^Array with: aDirection with: anArgProcessingSpec</body><body package="Com- Ole Development">standardArgumentCategoryAnalyzers	" Private - answer the message selectors for the standard argument categories. "	^#(		#computeArgumentAttributesForString:		#computeArgumentAttributesForScalar:		#computeArgumentAttributesForGUID:		#computeArgumentAttributesForInterface:		#computeArgumentAttributesForStructure:		)</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>private-vtable utilities</category><body package="Com- Ole Development">computeExtendedAttributesOf: anEntryPoint	" Private "	anEntryPoint arguments do: [ :anArgumentDescription |		self computeArgumentAttributesOf: anArgumentDescription ].</body><body package="Com- Ole Development">constructEntryPointDescriptionFrom: aBasicEntryPoint	" Private- answer an entry point description with information needed to support interface wrapper class generation. "	| anEntryPoint |	anEntryPoint := COMExtendedEntryPointDescription fromEntryPoint: aBasicEntryPoint.	self computeExtendedAttributesOf: anEntryPoint.	^anEntryPoint</body><body package="Com- Ole Development">constructVTableDescription	" Private - construct a description of the VTable entry points. "	| rawEntryPoints |	rawEntryPoints := self interfaceSignatureType				ifNil: 					[self interfaceSpec constructVTableDescription]				ifNotNil: 					[COMInterfaceImplementation						constructVTableDescriptionOf: self interfaceSignatureType].	^rawEntryPoints		collect: [:aBasicEntryPoint | self constructEntryPointDescriptionFrom: aBasicEntryPoint]</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>subclass-generation services</category><body package="Com- Ole Development">constructClassInitializerMethod	" Answer a string containing the class initialization method for the interface. "	| aStream |	aStream := String new writeStream.	aStream		nextPutAll: self classInitializationMethodName; cr;		tab; nextPutAll: '" ', self interfaceClassName, ' ' , self classInitializationMethodName, ' "'; cr;		cr.	self emitClassInitializationExpressionsOn: aStream.	^aStream contents</body><body package="Com- Ole Development">constructExternalFunctionInvocationMethodFor: anEntryPointDescription	" Answer a string containing the external interface function invocation method for the given entry point. "	self subclassResponsibility.</body><body package="Com- Ole Development">constructExternalProcedureDefinitionFor: aProcedureType 		name: procedureName		nTabsIndent: nTabs 		printSpecifiers: printSpecifiers 		vtableIndex: vtableIndex	" Answer a string containing the external procedure definition for &lt;aProcedureType&gt;. "	| aStream |	aStream := ( String new: 128 ) writeStream.	aProcedureType resultType isProcedurePointer		ifTrue: [ 			self emitPointerProcedureDefinitionFor: aProcedureType 				on: aStream				name: procedureName				nTabsIndent: nTabs 				printSpecifiers: printSpecifiers ]		ifFalse: [ 			self emitSimpleProcedureDefinitionFor: aProcedureType 				on: aStream				name: procedureName				nTabsIndent: nTabs 				printSpecifiers: printSpecifiers ].	aStream nextPutAll: ' = '; print: vtableIndex.	^aStream contents</body><body package="Com- Ole Development">constructFunctionMethodFor: anEntryPointDescription	" Answer a string containing the interface function method for the given entry point. "	self subclassResponsibility.</body><body package="Com- Ole Development">constructMessageHeaderFor: procedureName anonymousKeyword: anonymousKeyword argumentNames: argumentNames	" Answer a string containing the message header for the function &lt;procedureName&gt; with the given &lt;argumentNames&gt;. "	" by default, skip the leading This argument (only used on callback reentry method) "	^self constructMessageHeaderFor: procedureName 		prefix: '' 		anonymousKeyword: anonymousKeyword		argumentNames: argumentNames		startingAt: 2</body><body package="Com- Ole Development">constructMessageHeaderFor: procedureName argumentNames: argumentNames	" Answer a string containing the message header for the function &lt;procedureName&gt; with the given &lt;argumentNames&gt;. "	" by default, skip the leading This argument (only used on callback reentry method) "	^self constructMessageHeaderFor: procedureName 		prefix: '' 		anonymousKeyword: self functionSelectorAnonymousKeyword		argumentNames: argumentNames		startingAt: 2</body><body package="Com- Ole Development">constructMessageHeaderFor: procedureName prefix: keywordPrefix anonymousKeyword: anonymousKeywordargumentNames: argumentNames startingAt: startIndex	" Answer a string containing the message header for the function &lt;procedureName&gt; with the given &lt;argumentNames&gt;.  Prepend the &lt;keywordPrefix&gt; to form the primary keyword of message selector. "	| numArgs argIndex aStream |	numArgs := argumentNames size - startIndex + 1.	argIndex := startIndex.	aStream := String new writeStream.	aStream nextPutAll: keywordPrefix, procedureName.	numArgs &gt; 0		ifTrue: [			aStream nextPutAll: ': ', ( argumentNames at: argIndex ).			[ ( argIndex := argIndex + 1 ) &lt;= argumentNames size ]				whileTrue: [ 					aStream 						nextPutAll: ' ', anonymousKeyword, ': '; 						nextPutAll: ( argumentNames at: argIndex ) ].			].	^aStream contents</body><body package="Com- Ole Development">constructMessageHeaderFor: procedureName prefix: keywordPrefix argumentNames: argumentNames	" Answer a string containing the message header for the function &lt;procedureName&gt; with the given &lt;argumentNames&gt;.  Prepend the &lt;keywordPrefix&gt; to form the primary keyword of message selector.  Ignore the leading argument, which in an interface function from a C structure VTable is the This reference to the receiver. "	" by default, skip the leading This argument (only used on callback reentry method) "	^self constructMessageHeaderFor: procedureName 		prefix: keywordPrefix 		anonymousKeyword: self functionSelectorAnonymousKeyword		argumentNames: argumentNames		startingAt: 2</body><body package="Com- Ole Development">defineClass	" Answer a string containing the class definition for the interface. "	^self targetNamespace		defineClass: self interfaceClassName asSymbol		superclass: superinterfaceClass fullyQualifiedReference		indexedType: #none		private: false		instanceVariableNames: ''		classInstanceVariableNames: ''		imports: self classImportsString		category: self classCategoryName</body><body package="Com- Ole Development">emitClassInitializationExpressionsOn: aStream	" Private - append the expressions for the body of the class initialization method for the interface to &lt;aStream&gt;. "	self subclassResponsibility.</body><body package="Com- Ole Development">emitManualGenerationWarningFor: anEntryPointDescription on: aStream	" Private - generate warning message if there's anything even remotely interesting going on in the function described by &lt;anEntryPointDescription&gt;.  Answer whether a warning was emitted. "	(self isFunctionArgumentProcessingSimpleFor: anEntryPointDescription)		ifTrue: [^false].	aStream		nextPutAll: (self class					reviewMark: (#GeneratedMethodRequiresManualReview1 &lt;&lt; #com							&gt;&gt; '"**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"')								asString),'.';		cr.	^true</body><body package="Com- Ole Development">setClassCommentExpression	" Answer a string containing the class comment definition expression for the interface. "	^self interfaceClass comment:  self classComment</body><body package="Com- Ole Development">sortedFunctionEntryPointsDo: aOneArgBlock	" Enumerate the entry point definitions of the functions for which methods are to be generated in some interesting order. "	functionMap keys asSortedCollection do: [ :aFunctionName |		| anEntryPointDescription |		anEntryPointDescription := functionMap at: aFunctionName.		aOneArgBlock value: anEntryPointDescription ].</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>private-external procedure definition</category><body package="Com- Ole Development">emitPointerProcedureDefinitionFor: aProcedureType 		on: declarationStream		name: procedureName		nTabsIndent: nTabs 		printSpecifiers: printSpecifiers 	" Private - append the procedure definition of a function with a simple (non-procedure pointer) return type on &lt;declarationStream&gt;. "	| subDeclarationStream |	subDeclarationStream := ( String new: 20 ) writeStream.	printSpecifiers 		ifTrue: [ aProcedureType printSpecifiersOn: subDeclarationStream ].	aProcedureType printName: procedureName on: subDeclarationStream wrap: true.	self emitProcedureArgumentDeclarationsFor: aProcedureType 		on: subDeclarationStream 		nTabsIndent: nTabs .	aProcedureType resultType printOn:  declarationStream		forName: subDeclarationStream contents		indent: nTabs.</body><body package="Com- Ole Development">emitProcedureArgumentDeclarationsFor: aProcedureType on: declarationStream nTabsIndent: nTabs 	" Private - generate the argument declarations for &lt;aProcedureType&gt; on &lt;declarationStream&gt;. "	| numArgs |	declarationStream nextPut: $(.	numArgs := aProcedureType numArgs.	numArgs = 1		ifTrue: [ 			aProcedureType isVarArg 				ifFalse: [ declarationStream nextPutAll: 'void' ] ]		ifFalse: [			| argumentNames anArgName |			argumentNames := aProcedureType argumentNames.			anArgName := nil.			2 to: numArgs do: [ :i |    " skip the leading This argument in the C notation "				| anArgType |				anArgType := aProcedureType argumentTypeAt: i.				i &gt; 2 ifTrue: [ declarationStream nextPutAll: ', ' ].				argumentNames notNil					ifTrue: [ anArgName := argumentNames at: i ].				anArgType printOn: declarationStream					forName: anArgName					indent: nTabs ] ].	aProcedureType isVarArg		ifTrue: [			numArgs &gt; 1 				ifTrue: [ declarationStream nextPutAll: ', ' ].			declarationStream nextPutAll: '...' ].	declarationStream nextPut: $).</body><body package="Com- Ole Development">emitSimpleProcedureDefinitionFor: aProcedureType 		on: declarationStream		name: procedureName		nTabsIndent: nTabs 		printSpecifiers: printSpecifiers 	" Private - append the procedure definition of a function with a simple (non-procedure pointer) return type on &lt;declarationStream&gt;. "	declarationStream print: aProcedureType resultType.	printSpecifiers 		ifTrue: [ aProcedureType printSpecifiersOn: declarationStream ].	aProcedureType printName: procedureName on: declarationStream wrap: true.	self emitProcedureArgumentDeclarationsFor: aProcedureType 		on: declarationStream 		nTabsIndent: nTabs.</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>subclass-accessing</category><body package="Com- Ole Development">functionMap	" Answer the table which maps the names of the functions for which methods should be generated to their entry point descriptions. "	^functionMap</body><body package="Com- Ole Development">interfaceName	" Answer the name of the interface whose prototype bindings are being defined. "	^interfaceName</body><body package="Com- Ole Development">interfaceName: anInterfaceName	" Specify the name of the interface whose prototype bindings are being defined. "	interfaceName := anInterfaceName asSymbol.</body><body package="Com- Ole Development">interfaceSignatureType	" Answer the type definition of the structure defining the VTable of the interface whose prototype bindings are being defined. "	^interfaceSignatureType</body><body package="Com- Ole Development">interfaceSignatureType: aCompositeType	" Specify the type definition of the structure defining the VTable of the interface whose prototype bindings are being defined. "	interfaceSignatureType := aCompositeType.</body><body package="Com- Ole Development">typeDefinitionClassName	" Answer the name of the class which contains the type definitions referenced by the functions in the interface being defined. "	^typeDefinitionClassName</body><body package="Com- Ole Development">typeDefinitionClassName: aSymbol	" Specify the name of the class which contains the type definitions referenced by the functions in the interface being defined. "	typeDefinitionClassName := aSymbol.</body><body package="Com- Ole Development">vtableDescription	" Answer the VTable entry point descriptions. "	^vtableDescription</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>subclass-generating</category><body package="Com- Ole Development">generateClassDefinition	" Generate the prototype interface wrapper class for the interface onto the current output stream. "	self 		generateClassDefinitionAndComment;		generateClassMethods;		generateInstanceMethodsSection.</body><body package="Com- Ole Development">generateClassDefinitionAndComment	" Generate the class definition section for the interface onto the current output stream. "	self		defineClass;		setClassCommentExpression</body><body package="Com- Ole Development">generateClassMethods	" Generate the class methods for the interface onto the current output stream. "			self compileClassMethod: self constructClassInitializerMethod in: self classInitializationMethodsCategoryName.</body><body package="Com- Ole Development">generateExternalInvocationFunctionMethods	" Generate the instance methods for invoking the interface functions by callout to an external implementor or to handle callback from an external client to an internal implementation onto the current output stream. "	self sortedFunctionEntryPointsDo: [ :anEntryPointDescription |		| methodDefinition |		methodDefinition := self constructExternalFunctionInvocationMethodFor: anEntryPointDescription.		self compileExternalInvokationMethod: methodDefinition].</body><body package="Com- Ole Development">generateFunctionMethods	" Generate the instance methods for invoking the interface functions from Smalltalk onto the current output stream. "	self sortedFunctionEntryPointsDo: [ :anEntryPointDescription |		| methodDefinition |		methodDefinition := self constructFunctionMethodFor: anEntryPointDescription.		self formatAndCompileInstanceMethod: methodDefinition in: self functionMethodsCategoryName].</body><body package="Com- Ole Development">generateInstanceMethodsSection	" Generate the instance methods for the interface onto the current output stream. "	self 		generateFunctionMethods;		generateExternalInvocationFunctionMethods.</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>subclass-expression generation</category><body package="Com- Ole Development">getDirection: anArgumentSpec	" Private - answer the direction attribute of &lt;anArgumentSpec&gt;. "	^anArgumentSpec attributes at: 1</body><body package="Com- Ole Development">getProcessingSpec: anArgumentSpec	" Private - answer the processing specification attribute of &lt;anArgumentSpec&gt;. "	^anArgumentSpec attributes at: 2</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>subclass-initialization</category><body package="Com- Ole Development">initializeFunctionMap	| nFunctionsInherited |	nFunctionsInherited := self superInterfaceVtable size.	functionMap := Dictionary new.	( nFunctionsInherited + 1 ) to: vtableDescription size do: [ :i |		| anEntryPointDescription |		anEntryPointDescription := vtableDescription at: i.		functionMap at: anEntryPointDescription name put: anEntryPointDescription ].</body><body package="Com- Ole Development">initializeInterfaceAttributes	" Private - initialize derived attributes of the receiver for interface class generation. "	self		initializeVTableDescription;		initializeSuperinterfaceAttributes;		initializeFunctionMap</body><body package="Com- Ole Development">initializeSuperinterfaceAttributes	" Private - initialize the specification of the receiver's superinterface. "	| myFunctionNames superItf |	superinterfaceClass ifNotNil: [^self].	myFunctionNames := self vtableDescription collect: [:ept | ept name].	superItf := self selectSuperInterfaceForVTableDescription.	self superInterfaceID: superItf</body><body package="Com- Ole Development">initializeVTableDescription	" Private - initialize the VTable entry point descriptions. "	vtableDescription := self constructVTableDescription.</body><body package="Com- Ole Development">interfaceClassName	^interfaceName , self interfaceClassNameSuffix</body><body package="Com- Ole Development">selectSuperInterfaceForVTableDescription	| sortFunction sortedInterfaces interfaces myFunctionNames |	myFunctionNames := self vtableDescription collect: [:ept | ept name].	interfaces := self class interfaceInheritanceMap associations.	interfaces := interfaces select: 					[:each |					"Make sure if a similar interface already exists, it is not selected as super interface"					each value ~= myFunctionNames and: 							[(interfaces contains: 									[:other |									each ~= other and: 											[| otherInterfaceClass |											otherInterfaceClass := COMInterface classForIID: other key ifNone: nil.											otherInterfaceClass notNil and: 													[other value = each value and: 															[(COMInterface classForIID: each key ifNone: [UndefinedObject])																includesBehavior: otherInterfaceClass]]]])								not]].	sortFunction := 			[:entry |			(myFunctionNames first: entry value size) = entry value				ifTrue: [entry value size]				ifFalse: [0]]					ascending.	sortedInterfaces := interfaces sorted: sortFunction.	^sortedInterfaces last key</body><body package="Com- Ole Development">superInterfaceID: anIID	"added functionality. If we provide an iid from the outside, we can determine the super interface class directly"	superinterfaceClass := self baseInterfaceClass classForIID: anIID				ifNone: [self baseInterfaceClass classForIID: IID_IUnknown]</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>subclass-testing</category><body package="Com- Ole Development">isArgumentProcessingSimpleFor: anArgumentDescription	" Private - answer whether the argument processing for &lt;anEntryPointDescription&gt; is sufficiently simple that the automatic method generation for the function can be trusted to have generated the correct code. "	| argProcessingSpec |	argProcessingSpec := self getProcessingSpec: anArgumentDescription.	^argProcessingSpec category = #scalar</body><body package="Com- Ole Development">isCharacterType: aType	" Answer whether &lt;aType&gt; is a character. "	| characterTypeNames |	aType = CIntegerType char ifTrue: [^true].	aType = CIntegerType unsignedChar ifTrue: [^true].	aType = CIntegerType unsignedShort ifTrue: [^true].	aType = CIntegerType short ifTrue: [^true].	characterTypeNames := #(#CHAR #WCHAR #OLECHAR #wchar_t #OLECHAR).	(characterTypeNames includes: aType name) ifTrue: [^true].	^aType class == CQualifiedType		and: [characterTypeNames includes: aType type name]</body><body package="Com- Ole Development">isFunctionArgumentProcessingSimpleFor: anEntryPointDescription	" Private - answer whether the argument processing for &lt;anEntryPointDescription&gt; is sufficiently simple that the automatic method generation for the function can be trusted to have generated the correct code. "	| arguments anArgumentDescription |	arguments := anEntryPointDescription arguments.	2 to: arguments size do: [ :i |  " skip the leading This argument for this analysis "		anArgumentDescription := arguments at: i.		( self isArgumentProcessingSimpleFor: anArgumentDescription )			ifFalse: [ ^false ].		].	^true</body><body package="Com- Ole Development">isGUIDArgument: anArgumentDescription	" Answer whether &lt;anArgumentDescription&gt; is a GUID argument. "	| aType |	aType := anArgumentDescription type.	^( #( #CLSID #IID #GUID ) includes: aType name )		or: [ ( COMExternalInterface getFundamentalTypeOf: aType ) = ( COMExternalInterface getFundamentalTypeOf: GUID baseCType ) ]</body><body package="Com- Ole Development">isInterfaceArgument: anArgumentDescription	" Answer whether &lt;anArgumentDescription&gt; is an interface pointer argument.  Use various heuristics to try to make a good guess based on the available information. "	| aType fundamentalType |	aType := anArgumentDescription type.	" the basic model of declaring interface types is to bind them to a generic underlying object body type declaration "	aType isPointer		ifFalse: [ ^false ].	fundamentalType := COMExternalInterface getFundamentalTypeOf: aType.	fundamentalType name = #__IAnonymous		ifTrue: [ ^true ].	" heuristic to detect some older/odd declarations of return values "	( ( #( 'ppvObject' 'ppvObj' 'ppvResult' ) includes: anArgumentDescription name )	and: [ fundamentalType = CVoidType void	and: [ ( self pointerLevelCountOf: aType ) = 2 ] ] )		ifTrue: [ ^true ].	" anything is either definitely not or we just can't figure it out "	^false</body><body package="Com- Ole Development">isScalarArgument: anArgumentDescription	" Answer whether &lt;anArgumentDescription&gt; is a scalar argument. "	| aType fundamentalType |	aType := anArgumentDescription type.	fundamentalType := COMExternalInterface getFundamentalTypeOf: aType.	( fundamentalType isVoid 	or: [ fundamentalType isComposite	or: [ fundamentalType class == COopType ] ] )		ifTrue: [ ^false ].	"Assert isTrue: [ aType isBasic ]."  " floating point guys aren't basic, it seems "	^true</body><body package="Com- Ole Development">isStringArgument: anArgumentDescription	" Answer whether &lt;anArgumentDescription&gt; is a string argument. "	| stringTypeNames aType |	stringTypeNames := #( 		"Win32" #LPCSTR #LPCWSTR #LPSTR #LPWSTR		"COM" #LPCOLESTR #LPOLESTR		"Automation" #BSTR		).	aType := anArgumentDescription type.	[ aType isPointer ]		whileTrue: [ 			( stringTypeNames includes: aType name )				ifTrue: [ ^true ].			aType := aType referentType ].	^( self isCharacterType: aType )		or: [ self isCharacterType: ( COMExternalInterface getRealTypeOf: aType ) ]</body><body package="Com- Ole Development">isStructureArgument: anArgumentDescription	" Answer whether &lt;anArgumentDescription&gt; is a structure argument.  Use various heuristics to try to make a good guess based on the available information. "	^( COMExternalInterface getFundamentalTypeOf: anArgumentDescription type ) isComposite</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>private-type utilities</category><body package="Com- Ole Development">formatSource: aString	| node formatter formattedNode |	^#{Refactory.Browser.RBParser} ifDefinedDo: 			[:parser |			node := parser parseMethod: aString onError: [:s :position | ^aString].			formatter := Refactory.Browser.RBProgramNode formatterClass new.			formattedNode := formatter format: node.			formattedNode asString]		elseDo: [aString]</body><body package="Com- Ole Development">pointerLevelCountOf: aType	" Private - answer the number of pointer levels from &lt;aType&gt; to its fundamental type. "	| nPointerLevels fundamentalType |	nPointerLevels := 0.	fundamentalType := COMExternalInterface getRealTypeOf: aType.	[ fundamentalType isPointer ]		whileTrue: [			nPointerLevels := nPointerLevels + 1.			fundamentalType := fundamentalType referentType ].	^nPointerLevels</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>generating</category><body package="Com- Ole Development">generateClassForInterface: anInterfaceSpec	self		interfaceName: anInterfaceSpec name;		interfaceSpec: anInterfaceSpec;		typeDefinitionClassName: self defaultTypeDefinitionClassName.	self initializeInterfaceAttributes.	self generateClassDefinition</body><body package="Com- Ole Development">generateDefinitionPrototypeFor: anInterfaceName	^self generateDefinitionPrototypeFor: anInterfaceName		signature: (self class vtableSignatureForInterface: anInterfaceName)</body><body package="Com- Ole Development">generateDefinitionPrototypeFor: anInterfaceName signature: anInterfaceSignatureType	self		interfaceName: anInterfaceName;		interfaceSignatureType: anInterfaceSignatureType;		typeDefinitionClassName: self defaultTypeDefinitionClassName.	self initializeInterfaceAttributes.	self generateClassDefinition</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>accessing</category><body package="Com- Ole Development">baseInterfaceClass 	self subclassResponsibility</body><body package="Com- Ole Development">interfaceSpec	^interfaceSpec</body><body package="Com- Ole Development">interfaceSpec: anObject	interfaceSpec := anObject</body><body package="Com- Ole Development">superInterfaceClass	^superinterfaceClass</body><body package="Com- Ole Development">superInterfaceVtable	^self subclassResponsibility</body><body package="Com- Ole Development">targetNamespace: aNamespace		targetNamespace := aNamespace</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>compiling</category><body package="Com- Ole Development">compileClassMethod: aSource in: aProtocol	^self interfaceClass class compile: (self formatSource: aSource)		classified: aProtocol</body><body package="Com- Ole Development">compileInstanceMethod: aSource in: aProtocol	^self interfaceClass compile: aSource classified: aProtocol</body><body package="Com- Ole Development">formatAndCompileInstanceMethod: aSource in: aProtocol	^self compileInstanceMethod: (self formatSource: aSource) in: aProtocol</body><body package="Com- Ole Development">interfaceClass	^ self targetNamespace at: self interfaceClassName asSymbol</body><body package="Com- Ole Development">targetNamespace	^targetNamespace ifNil: [External]</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator</class-id> <category>As yet unclassified</category><body package="Com- Ole Development">compileExternalInvokationMethod: source 		self formatAndCompileInstanceMethod: source in: self functionExternalMethodsCategoryName</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>private-accessing</category><body package="Com- Ole Development">argumentAnalysisSelectors	^ArgumentAnalysisSelectors</body><body package="Com- Ole Development">argumentProcessingSpecifications	^ArgumentProcessingSpecifications</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>subclass-accessing</category><body package="Com- Ole Development">argumentProcessingSpecificationsFor: anArgumentType	^self argumentProcessingSpecifications at: anArgumentType</body><body package="Com- Ole Development">iidConstantNameForInterfaceNamed: aString	"self iidConstantNameForInterfaceNamed: 'IUnknown'"	| binding |	binding := COMConstants bindingFor: 'IID_' , aString asSymbol.	^ binding ifNotNil: [binding key]</body><body package="Com- Ole Development">iidConstantNameOf: anIID	" Answer the name of the IID constant for &lt;anIID&gt;. "	" self iidNameOf: IID_IUnknown "	^ COMConstants keyAtValueEqual: anIID ifAbsent: [ nil ]</body><body package="Com- Ole Development">iidFor: anInterfaceName	" Answer the IID for the interface named &lt;anInterfaceName&gt;. "	" self iidFor: #IUnknown "	^COMConstants at: 'IID_' , anInterfaceName asSymbol ifAbsent: [nil]</body><body package="Com- Ole Development">interfaceInheritanceMap	" Answer the inheritance map from interface names to function names. "	| dict |	dict := Dictionary new.	COMInterfacePointer allSubclasses do: [:each | each iid ifNotNil: [ each vtableDescription ifNotNil: [:desc | dict at: each iid put: (desc collect: #name) ]] ].	COMInterfaceImplementation allSubclasses do: [:each | each iid ifNotNil:[ each vtableDescription ifNotNil: [:desc | dict at: each iid put: (desc collect: #name) ]]].	^ dict</body><body package="Com- Ole Development">interfaceNameForVTable: aStructure 	"Answer a Symbol that represents the interface name of the IID argument. Answer nil if the IID is not known."	| aStructureName suffixIndex |	aStructureName := aStructure type name.	(aStructureName 		findString: '__'		startingAt: 1		ifAbsent: [0]) ~= 1 		ifTrue: [self error: #ErrUnknownVTableNaming &lt;&lt; #com &gt;&gt; 'unknown VTable naming convention '].	suffixIndex := aStructureName 				findString: 'Vtbl'				startingAt: 3				ifAbsent: [self error: #ErrUnknownVTableNaming &lt;&lt; #com &gt;&gt; 'unknown VTable naming convention '].	^aStructureName copyFrom: 3 to: suffixIndex - 1</body><body package="Com- Ole Development">registerArgumentAnalysisSelector: aOneArgSelector	" Register a selector for determining the argument processing specifications of an argument of a certain type. "	self argumentAnalysisSelectors add: aOneArgSelector</body><body package="Com- Ole Development">vtableSignatureForInterface: anInterfaceName	" Answer the interface VTable structure definition for the interface named &lt;anInterface&gt;. "	" self vtableSignatureForInterface: #IUnknown "	^COMInterfaceVTableSignatures externals 		at: ( self vtableSignatureTypeNameFor: anInterfaceName )		ifAbsent: [ nil ]</body><body package="Com- Ole Development">vtableSignatureTypeNameFor: anInterfaceName	" Answer the name of the type definition for the VTable structure of the interface named &lt;anInterfaceName&gt;. "	^( '__', anInterfaceName, 'Vtbl' ) asSymbol</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>subclass-definition attributes</category><body package="Com- Ole Development">defaultTypeDefinitionClassName	"Answer a Symbol that indicates the class which defines types transitively reached from an interface table type declaration."	^#COMExternalInterface</body><body package="Com- Ole Development">definitionTypeDescription	self subclassResponsibility.</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>generation</category><body package="Com- Ole Development">generateClassPrototypesForInterface: anInterface	" Generate a prototype interface class definition all flavors of interface wrapper classes for the interface named &lt;anInterfaceName&gt;. "	" COMInterfaceWrapperClassGenerator generateInterfaceClassPrototypesFor: #IAllDataTypesDisp "	| package |	package := IncrementalSearchDialog				selectPackage: #SelectATargetPackage &lt;&lt; #com &gt;&gt; 'Select a target package'.	package ifNil: [ ^ self ].	Store.Policies packagePolicy forcePackage: package		while: [ self compileVtableSignatureMethodFor: anInterface.	COMInterfaceClassGenerator generatePrototypeForInterface: anInterface.	COMInterfacePointerClassGenerator generatePrototypeForInterface: anInterface.	COMInterfaceImplementationClassGenerator generatePrototypeForInterface: anInterface ].</body><body package="Com- Ole Development">generateInterfaceClassPrototypes	" Generate a prototype interface class definition all flavors of interface wrapper classes.  Prompt the user for the name of the interface. "	" COMInterfaceWrapperClassGenerator generateInterfaceClassPrototypes "	| info anInterfaceName package |	info := self promptForInterface.	info isNil		ifTrue: 			[Screen default ringBell.			^nil].	anInterfaceName := info at: 1.	package := IncrementalSearchDialog				selectPackage: #SelectATargetPackage &lt;&lt; #com &gt;&gt; 'Select a target package'.	package ifNil: [ ^ self ].	Store.Policies packagePolicy forcePackage: package		while: [self generateInterfaceClassPrototypesFor: anInterfaceName]</body><body package="Com- Ole Development">generateInterfaceClassPrototypesFor: anInterfaceName	" Generate a prototype interface class definition all flavors of interface wrapper classes for the interface named &lt;anInterfaceName&gt;. "	" COMInterfaceWrapperClassGenerator generateInterfaceClassPrototypesFor: #IAllDataTypesDisp "	COMInterfaceClassGenerator generateInterfacePrototypeFor: anInterfaceName.	COMInterfacePointerClassGenerator generateInterfacePrototypeFor: anInterfaceName.	COMInterfaceImplementationClassGenerator generateInterfacePrototypeFor: anInterfaceName.</body><body package="Com- Ole Development">generateInterfacePrototype	" Generate a prototype interface class definition.  Prompt the user for the name of the interface. "	" self generateInterfacePrototype "	| info anInterfaceName aVTable |	info := self promptForInterface.	info isNil		ifTrue: 			[Screen default ringBell.			^nil].	anInterfaceName := info at: 1.	aVTable := info at: 2.	self new generateDefinitionPrototypeFor: anInterfaceName signature: aVTable</body><body package="Com- Ole Development">generateInterfacePrototypeFor: anInterfaceName	" Generate a prototype interface class definition for the interface named &lt;anInterfaceName&gt;. "	" self generateInterfacePrototypeFor: #IAdviseSink "	" self generateInterfacePrototypeFor: #IDataObject "	self new generateDefinitionPrototypeFor: anInterfaceName		signature: (self vtableSignatureForInterface: anInterfaceName)</body><body package="Com- Ole Development">generateInterfacePrototypeFor: anInterfaceName signature: anInterfaceSignatureType	" Generate a prototype interface class definition for the interface named &lt;anInterfaceName&gt; whose VTable definition is specified by the structure type &lt;anInterfaceSignatureType&gt;. "	COMInterfaceClassGenerator new		generateDefinitionPrototypeFor: anInterfaceName		signature: anInterfaceSignatureType</body><body package="Com- Ole Development">generatePrototypeForInterface: anInterface	" Generate a prototype interface class definition for the interface named &lt;anInterfaceName&gt;. "	self new generateClassForInterface: anInterface</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>private-installation</category><body package="Com- Ole Development">guidInArgumentTransformationFor: aName type: type	^(type isPointer		ifTrue: ['( self guidAtAddress: &lt;1s&gt; )']		ifFalse: ['( self guidFromStack: &lt;1s&gt; )']) expandMacrosWith: aName</body><body package="Com- Ole Development">guidInParamConstructorFor: argName type: argType	^(argType isPointer		ifTrue: ['&lt;1s&gt; asPointerParameter']		ifFalse: ['&lt;1s&gt; asStructureParameter']) expandMacrosWith: argName</body><body package="Com- Ole Development">initializeArgumentAnalysisSelectors	" COMInterfaceWrapperClassGenerator initializeArgumentAnalysisSelectors "	ArgumentAnalysisSelectors := OrderedCollection new.</body><body package="Com- Ole Development">initializeArgumentProcessingSpecifications	" COMInterfaceWrapperClassGenerator initializeArgumentProcessingSpecifications "	| aSpecification |	ArgumentProcessingSpecifications := IdentityDictionary new.	aSpecification := COMArgumentProcessingSpecification new		category: #unknown;		calloutArgumentTransformation: (self incompleteMark: (#x1sUNKNOWNTYPE &lt;&lt; #com &gt;&gt; '&lt;1s&gt;  "### UNKNOWN TYPE ###"') asString);		callinArgumentTransformation: (self incompleteMark: (#x1sUNKNOWNTYPE &lt;&lt; #com &gt;&gt; '&lt;1s&gt;  "### UNKNOWN TYPE ###"') asString)		yourself.	self registerArgumentProcessingSpecification: aSpecification.</body><body package="Com- Ole Development">registerAutomationArgumentAnalysisSelectors	" Register the extended data type analyzers. "	| extendedArgumentAnalysisSelectors |	extendedArgumentAnalysisSelectors := #(		#computeArgumentAttributesForBSTR:		#computeArgumentAttributesForVARIANT:		#computeArgumentAttributesForSAFEARRAY:		#computeArgumentAttributesForCURRENCY:		#computeArgumentAttributesForDATE:		#computeArgumentAttributesForVARIANT_BOOL:		).	extendedArgumentAnalysisSelectors do: [ :aOneArgSelector |		self registerArgumentAnalysisSelector: aOneArgSelector ].</body><body package="Com- Ole Development">registerAutomationArgumentProcessingSpecifications	" Private - register the basic specifications. "	| aSpecification |	aSpecification := COMArgumentProcessingSpecification new		category: #BSTR;		calloutArgumentTransformation: 'BSTR allocateString: &lt;1s&gt;';  " don't need paren's because assigned to temp "		calloutArgumentReleaseExpression:  '&lt;1s&gt; release';		calloutResultBufferConstructor: 'BSTR resultValueBuffer';		callinArgumentTransformation: '( self stringAtBSTRPointer: &lt;1s&gt; )';		callinResultValueExpression: 'self bstrResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';		yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := COMArgumentProcessingSpecification new		category: #VARIANT;		resultReferenceExpression: 'COMVariantValueReference new';		calloutArgumentTransformation: '&lt;1s&gt; asCOMVariant asPointerParameter "?? CHECK ??"';		calloutResultBufferConstructor: 'COMStructure resultValueBufferFor: #VARIANT';		callinArgumentTransformation: '( self variantValueFrom: &lt;1s&gt; )';		callinResultReferenceExpression: 'COMVariantValueReference new';		callinResultValueExpression: 'self variantResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';		yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := COMArgumentProcessingSpecification new		category: #SAFEARRAY;		calloutArgumentTransformation: 'COMSafeArray fromCollection: &lt;1s&gt; elementType: ', (self incompleteMark: 'VT_xxx');			" don't need paren's because assigned to temp "		calloutArgumentReleaseExpression:  '&lt;1s&gt; release';		calloutResultBufferConstructor: 'COMSafeArray resultValueBufferFor: ', (self incompleteMark: 'VT_xxx');		callinArgumentTransformation: '( self safeArrayValueAtAddress: &lt;1s&gt; typeCode: ', (self incompleteMark: 'VT_xxx');		callinResultValueExpression: 'self safeArrayResultPointerAtAddress: &lt;1s&gt; put: &lt;2s&gt; value elementType: ', (self incompleteMark: 'VT_xxx');		yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := COMArgumentProcessingSpecification new		category: #CURRENCY;		calloutArgumentTransformation: '( COMExternalInterface asCYParameter: &lt;1s&gt; )';		calloutResultBufferConstructor: 'COMStructure resultValueBufferFor: #CY';		callinArgumentTransformation: '( self currencyValueAtAddress: &lt;1s&gt; )';		callinResultValueExpression: 'self currencyResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';		yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := COMArgumentProcessingSpecification new		category: #DATE;		calloutArgumentTransformation: '( COMExternalInterface asDATEParameter: &lt;1s&gt; )';		calloutResultBufferConstructor: 'COMDate resultValueBuffer';		callinArgumentTransformation: '( self dateValueAtAddress: &lt;1s&gt; )';		callinResultValueExpression: 'self dateResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';		yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := COMArgumentProcessingSpecification new		category: #VARIANT_BOOL;		calloutArgumentTransformation: '( COMExternalInterface asVARIANT_BOOL: &lt;1s&gt; )';		calloutResultBufferConstructor: 'COMExternalInterface scalarResultBufferFor: #VARIANT_BOOL';		calloutResultBufferExtractor: '( COMExternalInterface booleanFromVARIANT_BOOL: &lt;1s&gt; contents )';		callinArgumentTransformation: '( self booleanFromVariantBool: &lt;1s&gt; )';		callinResultValueExpression: 'self variantBoolResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';		yourself.	self registerArgumentProcessingSpecification: aSpecification.</body><body package="Com- Ole Development">registerBasicArgumentProcessingSpecifications	" Private - register the basic specifications. "	| aSpecification |	aSpecification := (COMArgumentProcessingSpecification new)				category: #scalar;				calloutArgumentTransformation: '&lt;1s&gt;';				calloutResultBufferConstructor: 						[:argName :argType |						" no transformation needed "						self scalarCalloutResultBufferConstructor: argType];				callinArgumentTransformation: '&lt;1s&gt;';				callinResultValueExpression: 'self scalarResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';				yourself.	" no transformation needed "	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := (COMArgumentProcessingSpecification new)				category: #platformString;				calloutArgumentTransformation: '&lt;1s&gt; asStringParameter';				calloutResultBufferConstructor: (self							reviewMark: 'COMExternalInterface platformStringPointerType gcMalloc');				callinArgumentTransformation: '( COMExternalInterface stringFromPointer: &lt;1s&gt; )';				callinResultValueExpression: (self							reviewMark: 'self stringResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value');				yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := (COMArgumentProcessingSpecification new)				category: #string;				calloutArgumentTransformation: '&lt;1s&gt; asUnicodeParameter';				calloutResultBufferConstructor: 'COMExternalInterface unicodeResultBuffer';				callinArgumentTransformation: '( self stringAtAddress: &lt;1s&gt; )';				callinResultValueExpression: 'self stringResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';				yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := (COMArgumentProcessingSpecification new)				category: #structureDatum;				calloutArgumentTransformation: '&lt;1s&gt; asStructureParameter';				callinArgumentTransformation: '( self structureFrom: &lt;1s&gt; )';				yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := (COMArgumentProcessingSpecification new)				category: #structure;				calloutArgumentTransformation: '&lt;1s&gt; asPointerParameter';				calloutResultBufferConstructor: 						[:argName :argType |						self structureCalloutResultBufferConstructor: argType];				callinArgumentTransformation: '( self structureAtAddress: &lt;1s&gt; )';				callinResultValueExpression: 'self structureResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';				yourself.	self registerArgumentProcessingSpecification: aSpecification</body><body package="Com- Ole Development">registerCOMArgumentProcessingSpecifications	" Private - register the basic specifications. "	| aSpecification |	aSpecification := (COMArgumentProcessingSpecification new)				category: #interface;				resultReferenceExpression: 						[:argName :argType |						self interfaceResultReferenceExpression: argName type: argType];				calloutArgumentTransformation: '&lt;1s&gt; asPointerParameter';				calloutResultBufferConstructor: 						[:argName :argType |						self interfaceCalloutResultBufferConstructor: argName type: argType];				callinArgumentTransformation: 						[:argName :argType |						self interfaceCallinArgumentTransformation: argName type: argType];				callinResultValueExpression: 'self interfaceResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';				yourself.	self registerArgumentProcessingSpecification: aSpecification.	aSpecification := (COMArgumentProcessingSpecification new)				category: #GUID;				calloutArgumentTransformation: 						[:argName :argType |						self guidInParamConstructorFor: argName type: argType];				calloutResultBufferConstructor: 'GUID resultValuePointerBuffer';				callinArgumentTransformation: 						[:argName :argType |						self guidInArgumentTransformationFor: argName type: argType];				callinResultValueExpression: 'self guidPointerResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value';				yourself.	"calloutArgumentTransformation: '&lt;1s&gt; asPointerParameter';"	" strictly correct, but not necessary "	self registerArgumentProcessingSpecification: aSpecification	"	aSpecification := COMArgumentProcessingSpecification new		yourself.	self registerArgumentProcessingSpecification: aSpecification."</body><body package="Com- Ole Development">scalarCalloutResultBufferConstructor: argType	| aType referentTypeName |	aType := COMExternalInterface getRealTypeOf: argType.	Assert isTrue: [aType isPointer].	aType := aType referentType.	referentTypeName := aType isTypeDefinition				ifTrue: [aType name printString]				ifFalse: 					[aType isScalarType						ifTrue: [aType storeString]						ifFalse: [self incompleteMark: 'unknown type: ' , aType printString , '']].	^'COMExternalInterface scalarResultBufferFor: &lt;1s&gt;'		expandMacrosWith: referentTypeName</body><body package="Com- Ole Development">structureCalloutResultBufferConstructor: argType	| aType aTypeName |	aType := argType.	[(aType := COMExternalInterface getRealTypeOf: aType) isPointer]		whileTrue: [aType := aType referentType].	Assert isTrue: [aType isComposite].	aTypeName := COMStructure registeredStructureNameOf: aType name.	^'COMStructure resultValuePointerBufferFor: &lt;1p&gt;'		expandMacrosWith: aTypeName</body><body package="Com- Ole Development">typeStringForScalarType: aType	| aString |	aString := aType printString.	^(aString includes: Character space) ifTrue: [nil] ifFalse: [aString]</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>subclass-registration</category><body package="Com- Ole Development">registerArgumentProcessingSpecification: anArgumentProcessingSpecification	self argumentProcessingSpecifications at: anArgumentProcessingSpecification category		put: anArgumentProcessingSpecification.</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>utilities</category><body package="Com- Ole Development">incompleteMark: aString	^'(Tools.Note incomplete:' , aString asString printString,')'</body><body package="Com- Ole Development">promptForInterface	" Prompt the user for the name of an interface to generate.  Answer nil if none selected. "	| allKnownVTableStructures interfaceNames anInterfaceName |	allKnownVTableStructures := self systemWideInterfaceVtbls.	interfaceNames := Dictionary new.	allKnownVTableStructures		do: [:aStruct | interfaceNames at: (self interfaceNameForVTable: aStruct) put: aStruct].	anInterfaceName := ListDialog				openOn: interfaceNames keys asSortedCollection				title: #ChooseAnInterface &lt;&lt; #com &gt;&gt; 'Choose an Interface'.	anInterfaceName isNil ifTrue: [^nil].	^Array with: anInterfaceName with: (interfaceNames at: anInterfaceName)</body><body package="Com- Ole Development">reviewMark: aString	^'(Tools.Note pleaseReview: [&lt;1s&gt;] )' expandMacrosWith: aString</body><body package="Com- Ole Development">systemWideInterfaceVtbls	"Answer a set of all interface vtbl structures in the system."	" self systemWideInterfaceVtbls "	^CCompositeType allInstances select: [:baseType |		| allProcPtrs memberSize |		memberSize := 0.		allProcPtrs := true.		baseType isComposite			and: [(baseType size &gt; 0)			and: [baseType membersDo: [:compName :member |				memberSize := memberSize + 1.				member value isProcedurePointer ifFalse: [allProcPtrs := false]].				allProcPtrs			and: [(memberSize &gt;= 3)			and: [(baseType memberNameAt: 1) == #QueryInterface				and: [(baseType memberNameAt: (baseType slotsPerMember + 1)) == #AddRef				and: [(baseType memberNameAt: (baseType slotsPerMember * 2 + 1)) == #Release]]]]]]]</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>private compiling</category><body package="Com- Ole Development">compileVtableSignatureMethodFor: anInterfaceSpec	COMInterfaceVTableSignatures		compile: (self vtableSignatureCodeFor: anInterfaceSpec)		classified: #'vtables-com'</body><body package="Com- Ole Development">vtableSignatureCodeFor: anInterfaceTypeSpec	| signatureName source |	signatureName := COMInterfaceVTableSignatures vtableSignatureNameFor: anInterfaceTypeSpec name.	source := String new writeStream.	source		nextPutAll: signatureName;		cr;		cr.	source		tab;		nextPutAll: '&lt;C: struct ' , signatureName , ' {';		cr.	anInterfaceTypeSpec constructVTableDescription do: [:each |		source tab. 		each signatureType pointerType printOn: source forName: each name.		source nextPut: $; ; cr.].	source nextPutAll: '}&gt;'. 	^source contents</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	"For PostLoadAction: "	self initializeArgumentProcessingSpecifications.	self registerBasicArgumentProcessingSpecifications.	self registerCOMArgumentProcessingSpecifications.	self registerAutomationArgumentProcessingSpecifications.	self initializeArgumentAnalysisSelectors.	self registerAutomationArgumentAnalysisSelectors</body></methods><methods><class-id>External.COMInterfaceWrapperClassGenerator class</class-id> <category>utils interface</category><body package="Com- Ole Development">iEnumResultReferenceExpressionTypeName: aTypeName	| anIID anIIDName |	anIID := self iidFor: aTypeName.	^'( External.IEnum forIID: '		, (((IEnumPointer supportsIID: anIID)				and: [(anIIDName := self iidConstantNameOf: anIID) notNil])					ifTrue: [anIIDName]					ifFalse: [self unknownEnumeratorIDSourceFor: aTypeName])			, ' ) asValueReference'</body><body package="Com- Ole Development">interfaceCallinArgumentTransformation: argName type: argType	| aType aTypeName |	aType := argType.	[aType isPointer] whileTrue: [aType := aType baseType referentType].	aTypeName := aType name.	^'( self interfaceAtAddress: ' , argName		, ' type: (External.COMInterface classForIID:'			, ((self iidConstantNameForInterfaceNamed: aTypeName)					ifNil: [self unknownIIDSourceFor: aTypeName])			, '))'</body><body package="Com- Ole Development">interfaceCalloutResultBufferConstructor: argName type: argType	| aType aTypeName |	aType := argType.	[aType isPointer] whileTrue: [aType := aType baseType referentType].	aTypeName := aType name.	(aTypeName notNil and: [aTypeName first = $I])		ifTrue: 			[('IEnum*' match: aTypeName)				ifTrue: 					[| anIID anIIDName |					anIID := self iidFor: aTypeName.					^'External.IEnumPointer resultValueBufferForIID: '						, (((IEnumPointer supportsIID: anIID)								and: [(anIIDName := self iidConstantNameOf: anIID) notNil])									ifTrue: [anIIDName]									ifFalse: [self unknownEnumeratorIDSourceFor: aTypeName])]				ifFalse: 					[^'External.COMInterfacePointer resultValueBufferForIID: '						, ((self iidConstantNameForInterfaceNamed: aTypeName)								ifNil: [self unknownIIDSourceFor: aTypeName])]].	^self		incompleteMark: '### TBD: ''''IFooPointer resultValueBuffer'''' or ''''COMInterfacePointer resultValueBufferForIID: iid'''' ###'</body><body package="Com- Ole Development">interfaceResultReferenceExpression: argName type: argType	| aType aTypeName |	aType := argType.	[aType isPointer]		whileTrue: [aType := (COMExternalInterface getRealTypeOf: aType) referentType].	aTypeName := aType name.	(aTypeName notNil and: [aTypeName first = $I])		ifTrue: 			[(aTypeName indexOfSubCollection: 'IEnum' startingAt: 1) = 1				ifTrue: [^self iEnumResultReferenceExpressionTypeName: aTypeName]				ifFalse: 					[^'External.COMInterfaceValueReference forIID: '						, ((self iidConstantNameForInterfaceNamed: aTypeName)								ifNil: [self unknownIIDSourceFor: aTypeName])]].	^self incompleteMark: 'Not sure what to dodo about ' , argName</body><body package="Com- Ole Development">unknownEnumeratorIDSourceFor: aTypeName	^self incompleteMark: 'unknown enumerator IID for interface ' , aTypeName</body><body package="Com- Ole Development">unknownIIDSourceFor: aTypeName	^self incompleteMark: 'IID for ' , aTypeName , ' is unknown'</body></methods><methods><class-id>External.COMInterfaceClassGenerator</class-id> <category>subclass-definition attributes</category><body package="Com- Ole Development">classComment	" Answer a string containing the class comment for the interface wrapper class. "	^((#ProvideExplanationOfInterface &lt;&lt; #com &gt;&gt; '### Provide a brief explanation of the &lt;1s&gt; interface ####')			expandMacrosWith: interfaceName)</body><body package="Com- Ole Development">functionSelectorAnonymousKeyword	" Answer the anonymous keyword to use for argument keywords when forming a function method selector. "	^'with'</body><body package="Com- Ole Development">interfaceClassNameSuffix	^''</body></methods><methods><class-id>External.COMInterfaceClassGenerator</class-id> <category>subclass-generating</category><body package="Com- Ole Development">generateExternalInvocationFunctionMethods	" Generate the instance methods for invoking the interface functions by callout to an external implementor or to handle callback from an external client to an internal implementation onto the current output stream. "	" Do nothing for the receiver - its interface binding provides the external function invocation "</body></methods><methods><class-id>External.COMInterfaceClassGenerator</class-id> <category>subclass-testing</category><body package="Com- Ole Development">isArgumentProcessingSimpleFor: anArgumentDescription	" Private - answer whether the argument processing for &lt;anEntryPointDescription&gt; is sufficiently simple that the automatic method generation for the function can be trusted to have generated the correct code. "	| direction argProcessingSpec |	( super isArgumentProcessingSimpleFor: anArgumentDescription )		ifTrue: [ ^true ].	direction := self getDirection: anArgumentDescription.	argProcessingSpec := self getProcessingSpec: anArgumentDescription.	^argProcessingSpec category = #interface and: [ direction = #in ]</body></methods><methods><class-id>External.COMInterfaceClassGenerator</class-id> <category>subclass-generation services</category><body package="Com- Ole Development">constructExternalFunctionInvocationMethodFor: anEntryPointDescription	" Answer a string containing the external interface function invocation method for the given entry point. "	self shouldNotImplement</body><body package="Com- Ole Development">constructFunctionMethodFor: anEntryPointDescription	" Answer a string containing the interface function method for the given entry point. "	| functionName procedureName argumentNames numArgs lastArgDescription inOutArgNames outArgNames incomingArgumentNames functionCallArgumentNames resultReferenceName resultReferenceExpression aStream |	functionName := anEntryPointDescription name.	procedureName := functionName asSelector.	" impose Smalltalk leading lowerCase convention "	argumentNames := anEntryPointDescription argumentNames.	numArgs := argumentNames size.	lastArgDescription := anEntryPointDescription arguments last.	inOutArgNames := (anEntryPointDescription arguments				select: [:ept | (self getDirection: ept) = #inOut])					collect: [:ept | ept name].	outArgNames := (anEntryPointDescription arguments				select: [:ept | (self getDirection: ept) = #out])					collect: [:ept | ept name].	(self getDirection: lastArgDescription) = #out		ifTrue: 			[" last argument value is an out value to return from the function "			| argProcessingSpec |			argProcessingSpec := self getProcessingSpec: lastArgDescription.			incomingArgumentNames := argumentNames copyFrom: 1 to: numArgs - 1.			resultReferenceName := 'resultReference'.			functionCallArgumentNames := incomingArgumentNames						, (Array with: resultReferenceName).			outArgNames := outArgNames copyFrom: 1 to: outArgNames size - 1.			resultReferenceExpression := argProcessingSpec						constructResultReferenceExpressionFor: lastArgDescription name						type: lastArgDescription type]		ifFalse: 			[incomingArgumentNames := argumentNames.			functionCallArgumentNames := incomingArgumentNames].	aStream := (String new: 128) writeStream.	aStream nextPutAll: (self				constructMessageHeaderFor: procedureName				anonymousKeyword: self functionSelectorAnonymousKeyword				argumentNames: incomingArgumentNames).	aStream		crtab;		nextPutAll: '" Invoke the ' , self interfaceName , '::' , functionName					, ' function. "';		cr;		cr.	resultReferenceName		ifNotNil: 			[aStream				tab;				nextPutAll: '| ' , resultReferenceName , ' |';				cr].	(self emitManualGenerationWarningFor: anEntryPointDescription on: aStream)		ifTrue: 			[inOutArgNames size &gt; 0				ifTrue: 					[aStream						tab;						nextPutAll: (self class reviewMark: '"Check [in, out] arguments:"');						crtab;						nextPutAll: '"'.					inOutArgNames do: [:argName | aStream nextPutAll: argName]						separatedBy: [aStream space].					aStream						nextPutAll: ' ".';						cr].			outArgNames size &gt; 0				ifTrue: 					[aStream						tab;						nextPutAll: (self class									reviewMark: '"***WARNING: Possible [out] arguments: "');						crtab; nextPutAll: '"'.					outArgNames do: [:argName | aStream nextPutAll: argName]						separatedBy: [aStream space].					aStream						nextPutAll: ' ".';						cr].			aStream cr].	resultReferenceName isNil		ifTrue: 			[aStream				tab;				nextPut: $^]		ifFalse: 			[aStream				tab;				nextPutAll: resultReferenceName , ' := ' , resultReferenceExpression , '.';				crtab].	aStream		nextPutAll: 'interface ';		nextPutAll: (self					constructMessageHeaderFor: functionName					anonymousKeyword: super functionSelectorAnonymousKeyword					argumentNames: functionCallArgumentNames).	resultReferenceName notNil		ifTrue: 			[aStream				nextPutAll: '.';				crtab;				nextPutAll: '^' , resultReferenceName , ' value'].	^aStream contents</body><body package="Com- Ole Development">emitClassInitializationExpressionsOn: aStream	" Private - append the expressions for the body of the class initialization method for the interface to &lt;aStream&gt;. "	aStream		nextPutAll: 'self iid: ', self iidDefinitionString, '.'; cr;		nextPutAll: 'self updateAndRegister.'.</body><body package="Com- Ole Development">emitManualGenerationWarningFor: anEntryPointDescription on: aStream	" Private - generate warning message if there's anything even remotely interesting going on in the function described by &lt;anEntryPointDescription&gt;.  Answer whether a warning was emitted. "	(self isFunctionArgumentProcessingSimpleFor: anEntryPointDescription)		ifTrue: [^false].	aStream		nextPutAll: (self class					reviewMark: (#GeneratedMethodRequiresManualReview &lt;&lt; #com							&gt;&gt; '"**** NOTE: Automatically generated method, requires manual review ****"')								asString),'.';		cr.	^true</body></methods><methods><class-id>External.COMInterfaceClassGenerator</class-id> <category>accessing</category><body package="Com- Ole Development">baseInterfaceClass 	^ COMInterface</body><body package="Com- Ole Development">superInterfaceVtable	^(self superInterfaceClass interfaceImplementationClass		ifNil: [self superInterfaceClass interfacePointerClass]) vtableDescription</body></methods><methods><class-id>External.COMInterfaceClassGenerator class</class-id> <category>subclass-definition attributes</category><body package="Com- Ole Development">definitionTypeDescription	^'Interface Binding'</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-operation</category><body package="Com- Ole Development">cleanUpResourceLists	" Private - the Clean Up Lists button has been pressed. "	self clearLists.	ObjectMemory garbageCollect.  " force garbage collect to clean up finalization registries "	self updateResourceLists.</body><body package="Com- Ole Development">clearExportedLists	" Private - clear the lists of exported resources "	self 		setExportedInterfaces: ( Array with: #( ) with: #( ) );		setExportedObjects: #( ).</body><body package="Com- Ole Development">clearLists	" Private - clear the lists of resources "	self clearExportedLists.</body><body package="Com- Ole Development">getExportedInterfaceList	" Private - answer the unsorted list of interface implementations to display in the exported interfaces list. "	^self subclassResponsibility</body><body package="Com- Ole Development">initializeMenus	" Private - initialize the menus before the window is opened. "	self 		updateCleanupMenu;		updateClipboardMenu.</body><body package="Com- Ole Development">selectionChangedInExportedInterfacesList	" Private - an item has been selected in the exported interfaces list. "	| aResource aResourceListMenu |	aResource := self selectedExportedInterface.	aResourceListMenu := self exportedInterfacesMenu.	aResource isNil		ifTrue: [ self disableMenu: aResourceListMenu ]		ifFalse: [ self enableMenu: aResourceListMenu ].	aResource notNil		ifTrue: [ 			| implementingObject |			implementingObject := aResource implementingObject.			self selectedExportedObject ~~ implementingObject				ifTrue: [ self setExportedObjectSelection: implementingObject ] ].</body><body package="Com- Ole Development">selectionChangedInExportedObjectsList	" Private - an item has been selected in the exported objects list. "	| aResource aResourceListMenu |	aResource := self selectedExportedObject.	aResourceListMenu := self exportedObjectsMenu.	aResource isNil		ifTrue: [ self disableMenu: aResourceListMenu ]		ifFalse: [ self enableMenu: aResourceListMenu ].	aResource notNil		ifTrue: [			| selectedInterface |			selectedInterface := self selectedExportedInterface.			( selectedInterface isNil 			or: [ selectedInterface implementingObject ~~ aResource ] )				ifTrue: [					| anInterface |					anInterface := self exportedInterfaces 						detect: [ :ifImpl | ifImpl implementingObject == aResource ]						ifNone: [ nil ].  " should not be, but we'll be careful "					self setExportedInterfaceSelection: anInterface.					].			].</body><body package="Com- Ole Development">updateExportedResourceLists	" Private - update the lists of exported resources "	| exportedObjectsList exportedInterfacesDict exportedInterfacesList 	  separatorsList nInterfaces anInterfaceList |	exportedInterfacesDict := self organizeInterfaceImplementations:		self getExportedInterfaceList.	exportedObjectsList := self sortObjects:		exportedInterfacesDict keys.	exportedInterfacesList := OrderedCollection new.	separatorsList := OrderedCollection new.	nInterfaces := 0.	exportedObjectsList do: [ :anOLEObject |		anInterfaceList := exportedInterfacesDict at: anOLEObject.		exportedInterfacesList addAll: anInterfaceList.		nInterfaces := nInterfaces + anInterfaceList size.		anOLEObject == exportedObjectsList last			ifFalse: [ separatorsList add: nInterfaces ].		].	self setExportedInterfaces: ( Array		with: exportedInterfacesList asArray		with: separatorsList asArray ).	self setExportedObjects: exportedObjectsList.</body><body package="Com- Ole Development">updateResourceLists	" Private - update the lists of resources "	self subclassResponsibility.</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-cleanup menu</category><body package="Com- Ole Development">cleanupMenu	" Private - answer the Cleanup menu in the receiver's view. "	^self menuNamed: #cleanup</body><body package="Com- Ole Development">cleanupReleaseAllObjects	" Private - release all exported objects "	| ownedInterfacesOnExportedObjects |	( MessageBox confirm: (#GenKey80 &lt;&lt; #com &gt;&gt; 'Releasing exported objects, which may still in use by another application, is dangerous!  Do you want to proceed?') asString )		ifFalse: [ Screen default ringBell. ^self ].	ownedInterfacesOnExportedObjects := COMSessionManager allOwnedInterfaces		select: [ :anInterface | anInterface implementingObject notNil ].  " a reference to our own object... "	self exportedObjects do: [ :anCOMObject |		anCOMObject forceRelease ].	ownedInterfacesOnExportedObjects do: [ :anInterface |		anInterface enforceInvalidation ].	self updateResourceLists.</body><body package="Com- Ole Development">cleanupReleaseAllResources	" Private - release all exported objects "	COMSessionManager sessionExportsResources		ifTrue: [  " if we only own stuff, this is pretty safe, but if we export any objects it can get tricky "			( MessageBox confirm: (#GenKey82 &lt;&lt; #com &gt;&gt; 'Releasing all resources, particularly exported objects which may still be in use by another application, is dangerous!  This operation can also fail unpredictably if any exported objects own interfaces which are released out from underneath them by the order of this mass-destruction utility.  Do you want to proceed?') asString )				ifFalse: [ Screen default ringBell. ^self ].			].	COMSessionManager allOwnedInterfaces do: [ :anInterface |		self releaseOwnedInterface: anInterface ].	self exportedObjects do: [ :anCOMObject |		anCOMObject forceRelease ].	COMSessionManager allOwnedMemoryAddresses do: [ :anAddress |		self releaseOwnedMemory: anAddress ].	self updateResourceLists.	COMSessionManager sessionHasResources		ifTrue: [ MessageBox warning: (#GenKey81 &lt;&lt; #com &gt;&gt; 'Not all resources were released succesfully.') asString ].</body><body package="Com- Ole Development">cleanupRevokeClassFactories	" Private - revoke all class factories exported from this session. "	| orphanFactories |	COMSessionManager revokeAllClassFactories.	" do some extra cleanup in case leftover guys are cluttering up the factory registry "	orphanFactories := COMClassFactoryObject registeredClassFactories		select: [ :cf | cf isInUse not and: [ cf isRegistered not ] ].	orphanFactories do: [ :aClassFactory |		COMClassFactoryObject classFactoryRegistry remove: aClassFactory ifAbsent: [] ].	"	COMClassFactoryObject registeredClassFactories size &gt; 0		ifTrue: [ COMClassFactoryObject registeredClassFactories asArray inspect ].	"	self updateResourceLists.</body><body package="Com- Ole Development">updateCleanupMenu	" Private - enable/disable items in the Cleanup menu to reflect the current state of the view. "	self updateCleanupMenu: self cleanupMenu.</body><body package="Com- Ole Development">updateCleanupMenu: aMenu	" Private - enable/disable items in the Cleanup menu to reflect the current state of the view. "	self setEnabledStateOfMenuItems: #( #cleanupRevokeClassFactories ) 		in: aMenu 		to: ( COMClassFactoryObject registeredClassFactories size &gt; 0 ).	self setEnabledStateOfMenuItems: #( #cleanupReleaseAllObjects ) 		in: aMenu 		to: ( self exportedObjects size &gt; 0 ).	self setEnabledStateOfMenuItems: #( #cleanupReleaseAllResources ) 		in: aMenu 		to: COMSessionManager sessionHasResources.</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-clipboard menu</category><body package="Com- Ole Development">clipboardClearClipboard	" Private - clear the clipboard "	IDataObject clearClipboard.	self updateResourceLists.</body><body package="Com- Ole Development">clipboardCopyToClipboard	" Private - remove the selected data object the clipboard "	| anIDataObject |	anIDataObject := self selectedExportedObject queryInterface: IID_IDataObject.	anIDataObject copyToClipboard.	self setExportedObjectSelection: self selectedExportedObject value	" kludge to force menu update "</body><body package="Com- Ole Development">clipboardMenu	" Private - answer the Clipboard menu in the receiver's view. " 	^self menuNamed: #clipboard</body><body package="Com- Ole Development">clipboardRemoveFromClipboard	" Private - remove the selected data object from the clipboard "	IDataObject clearClipboard.	self updateResourceLists.</body><body package="Com- Ole Development">updateClipboardMenu	" Private - enable/disable items in the Clipboard menu to reflect the current state of the view. "	self updateClipboardMenu: self clipboardMenu.</body><body package="Com- Ole Development">updateClipboardMenu: aMenu	" Private - enable/disable items in the Clipboard menu to reflect the current state of the view. "	| aCOMObject anIDataObject selectedObjectIsOnClipboard |	aCOMObject := self selectedExportedObject.	aCOMObject notNil ifTrue: [anIDataObject := aCOMObject queryInterface: IID_IDataObject].	selectedObjectIsOnClipboard := anIDataObject notNil and: [anIDataObject isClipboardObject].	self		setEnabledStateOfMenuItems: #(#clipboardRemoveFromClipboard)		in: aMenu		to: (anIDataObject notNil and: [selectedObjectIsOnClipboard]).	self		setEnabledStateOfMenuItems: #(#clipboardCopyToClipboard)		in: aMenu		to: (anIDataObject notNil and: [selectedObjectIsOnClipboard not])</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-utilities</category><body package="Com- Ole Development">constructInterfaceImplList: unsortedInterfaceImpls	" Private - answer a list of lists which organizes the collection of interfaces into sublists associated with an implementing object. "	| interfacesDict interfacesList |	interfacesDict := self organizeInterfaceImplementations: unsortedInterfaceImpls.	interfacesList := OrderedCollection new.	( self sortObjects: interfacesDict keys ) do: [ :anObject |		interfacesList add: ( interfacesDict at: anObject ) ].	^interfacesList asArray</body><body package="Com- Ole Development">organizeInterfaceImplementations: unsortedInterfaceImpls	" Private - answer a dictionary which organizes the collection of interfaces into sublists accessed by the implementing object. "	| interfacesDict |	interfacesDict := IdentityDictionary new.	unsortedInterfaceImpls do: [ :anInterface |		( interfacesDict at: anInterface implementingObject 				ifAbsentPut: [ OrderedCollection new ] )			add: anInterface ].	interfacesDict keys do: [ :anObject |		interfacesDict at: anObject			put: ( self sortInterfaces: ( interfacesDict at: anObject ) ).		].	^interfacesDict</body><body package="Com- Ole Development">sortInterfaces: unsortedInterfaces	" Private - answer a sorted list containing the elements of &lt;unsortedInterfaces&gt;. "	| sortedCollection |	sortedCollection := SortedCollection sortBlock: [ :if1 :if2 |		if1 printString &lt;= if2 printString ].	sortedCollection addAll: unsortedInterfaces.	^sortedCollection asArray</body><body package="Com- Ole Development">sortObjects: unsortedObjects	" Private - answer a sorted list containing the elements of &lt;unsortedObjects&gt;. "	| sortedCollection |	sortedCollection := SortedCollection sortBlock: [ :if1 :if2 |		if1 class name &lt;= if2 class name ].	sortedCollection addAll: unsortedObjects.	^sortedCollection asArray</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-accessing</category><body package="Com- Ole Development">exportedInterfaces	" Private - answer the list of exported interfaces. "	^self exportedInterfacesListModel list</body><body package="Com- Ole Development">exportedInterfacesMenu	" Private - answer the pane menu associated with the exported interfaces resource list. "	^self builder menuAt: #menuSpecExportedInterfaces</body><body package="Com- Ole Development">exportedObjects	" Private - answer the list of exported objects. "	^self exportedObjectsListModel list</body><body package="Com- Ole Development">exportedObjectsMenu	" Private - answer the pane menu associated with the exported objects resource list. "	^self builder menuAt: #menuSpecExportedObjects</body><body package="Com- Ole Development">selectedExportedInterface	" Private - answer the current selection in the list of exported interfaces. "	^self exportedInterfacesListModel selection</body><body package="Com- Ole Development">selectedExportedObject	" Private - answer the current selection in the list of exported objects. "	^self exportedObjectsListModel selection</body><body package="Com- Ole Development">setExportedInterfaceSelection: anExportedInterface	" Private - record the selected object. "	self exportedInterfacesListModel selection: anExportedInterface.</body><body package="Com- Ole Development">setExportedInterfaces: aList	" Private - set the list of exported interfaces. "	self setExportedInterfaceSelection: nil.  " clear the selection "	self exportedInterfacesListModel list: aList first.  " Ignore the separators information on VW, not yet supported "</body><body package="Com- Ole Development">setExportedObjectSelection: anExportedObject	" Private - record the selected object. "	self exportedObjectsListModel selection: anExportedObject.</body><body package="Com- Ole Development">setExportedObjects: aList	" Private - set the list of exported objects. "	self setExportedObjectSelection: nil.  " clear the selection "	self exportedObjectsListModel list: aList.</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-aspects</category><body package="Com- Ole Development">exportedInterfacesListModel	" Private - answer the model for the exported interfaces list. "	^exportedInterfacesListModel</body><body package="Com- Ole Development">exportedObjectsListModel	" Private - answer the model for the exported objects list. "	^exportedObjectsListModel</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-initialization</category><body package="Com- Ole Development">initialize	" Private - initialize a newly created instance. "	super initialize.	exportedInterfacesListModel := SelectionInList new.	exportedObjectsListModel := SelectionInList new.	" register handlers for list selection #changed events "	exportedInterfacesListModel selectionHolder		onChangeSend: #selectionChangedInExportedInterfacesList to: self.	exportedObjectsListModel selectionHolder		onChangeSend: #selectionChangedInExportedObjectsList to: self.</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-resource list menus</category><body package="Com- Ole Development">inspectExportedInterface	" Private "	| selectedResource |	selectedResource := self selectedExportedInterface.	Assert notNil: selectedResource.  " otherwise menu should have been disabled "	selectedResource inspect.</body><body package="Com- Ole Development">inspectExportedObject	" Private "	| selectedResource |	selectedResource := self selectedExportedObject.	Assert notNil: selectedResource.  " otherwise menu should have been disabled "	selectedResource inspect.</body><body package="Com- Ole Development">releaseExportedInterface	" Private "	| selectedResource resourceList |	selectedResource := self selectedExportedInterface.	Assert notNil: selectedResource.  " otherwise menu should have been disabled "	( MessageBox confirm: (#GenKey83 &lt;&lt; #com &gt;&gt; 'Releasing an exported object which is still in use by another application is dangerous!  Do you really want to do this?') asString )		ifFalse: [ Screen default ringBell. ^self ].	resourceList := self exportedInterfaces reject: [ :aResource | 		aResource == selectedResource ].	self releaseExportedInterface: selectedResource.	selectedResource implementingObject referenceCount = 0		ifTrue: [ self updateResourceLists ]  " the object just went away "		ifFalse: [ self setExportedInterfaces: resourceList ].</body><body package="Com- Ole Development">releaseExportedObject	" Private "	| selectedResource |	selectedResource := self selectedExportedObject.	Assert notNil: selectedResource.  " otherwise menu should have been disabled "	( MessageBox confirm: (#GenKey84 &lt;&lt; #com &gt;&gt; 'Releasing an exported interface which is still in use by another application is dangerous!  Do you really want to do this?') asString )		ifFalse: [ Screen default ringBell. ^self ].	selectedResource forceRelease.	self updateResourceLists.</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-window events</category><body package="Com- Ole Development">windowBuilt	" Private - the window has been constructed by the builder and is about to be opened.  Initialize the window contents and menu states. "	self 		updateResourceLists;		initializeMenus.</body></methods><methods><class-id>Tools.COMResourceViewer</class-id> <category>private-releasing</category><body package="Com- Ole Development">releaseExportedInterface: anInterfaceImplementation	" Private - release &lt;anInterfaceImplementation&gt;. "	anInterfaceImplementation enforceRelease.</body><body package="Com- Ole Development">releaseOwnedInterface: anInterfacePointer	" Private - release &lt;anInterfacePointer&gt;. "	( anInterfacePointer isTraceTypeEnabled: #externalCallout )		ifTrue: [ anInterfacePointer asInterfaceReference enforceRelease ]		ifFalse: [ anInterfacePointer enforceRelease ].</body><body package="Com- Ole Development">releaseOwnedMemory: aMemoryAddress	" Private - release &lt;aMemoryAddress&gt;. "	aMemoryAddress enforceRelease.</body></methods><methods><class-id>Tools.COMResourceViewer class</class-id> <category>interface specs</category><body package="Com- Ole Development">eventHandlersSpec	" Answer the specifications for connecting components of the application using events "	^super eventHandlersSpec, #(		#( #applicationWindow			#( #built #windowBuilt )			)		)</body></methods><methods><class-id>External.COMStorageElementInterfaceTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">Commit: grfCommitFlags	" Invoke the IStream::Commit or IStorage::Commit function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		self logCommitFlags: grfCommitFlags.		].	[	hresult := implementor Commit: grfCommitFlags.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logHRESULT: hresult.		].	^hresult</body></methods><methods><class-id>External.COMStorageElementInterfaceTraceAdaptor</class-id> <category>subclass-tracing</category><body package="Com- Ole Development">logBufferDescription: buffer	| description |	description := ( buffer isExternalAddress		ifTrue: [ buffer printString ]		ifFalse: [ ((#a1sOf2sBytes &lt;&lt; #com &gt;&gt; '(a &lt;1s&gt; of &lt;2s&gt; bytes)')			expandMacrosWith: buffer class name			with: buffer sizeInBytes printString) ] ).	self logString: description tag: (#pv &lt;&lt; #com &gt;&gt; 'pv').</body><body package="Com- Ole Development">logCommitFlags: grfCommitFlags	" Load a description of the commit flags to the COM trace log. "	| flagNames  |	flagNames := OrderedCollection new.	( grfCommitFlags bitAnd: STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE ) ~= 0		ifTrue: [ flagNames add: 'STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE' ].	( grfCommitFlags bitAnd: STGC_DEFAULT ) ~= 0		ifTrue: [ flagNames add: 'STGC_DEFAULT' ].	( grfCommitFlags bitAnd: STGC_ONLYIFCURRENT ) ~= 0		ifTrue: [ flagNames add: 'STGC_ONLYIFCURRENT' ].	( grfCommitFlags bitAnd: STGC_OVERWRITE ) ~= 0		ifTrue: [ flagNames add: 'STGC_OVERWRITE' ].	self logFlags: grfCommitFlags 		nameList: flagNames 		tag: 'grfCommitFlags'."COMConstants keys asSortedCollection asArray	select: [ :k | ( k readStream upTo: $_ ) = 'STGC' ]"</body></methods><methods><class-id>External.IStorageTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">CreateStorage: storageName _: grfMode _: dwStgFmt _: reserved2 _: resultReference	" Invoke the IStorage::CreateStorage function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		self 			logValue: storageName tag: 'pwcsName';			logStorageModeFlags: grfMode.		dwStgFmt ~=  0			ifTrue: [ self logValue: dwStgFmt tag: 'dwStgFmt' ].		].	[	hresult := implementor CreateStorage: storageName _: grfMode _: dwStgFmt _: reserved2 _: resultReference.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logFunctionExit: traceContext hresult: hresult ].	^hresult</body><body package="Com- Ole Development">CreateStream: streamName _: grfMode _: reserved1 _: reserved2 _: resultReference	" Invoke the IStorage::CreateStream function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		self logValue: streamName tag: 'pwcsName'.		self logStorageModeFlags: grfMode.		].	[	hresult := implementor CreateStream: streamName _: grfMode _: reserved1 _: reserved2 _: resultReference.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logFunctionExit: traceContext hresult: hresult ].	^hresult</body><body package="Com- Ole Development">OpenStorage: storageName _: pstgPriority _: grfMode _: snbExclude _: reserved _: resultReference	" Invoke the IStorage::OpenStorage function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		self 			logValue: storageName tag: 'pwcsName';			logValue: pstgPriority tag: 'pstgPriority';			logStorageModeFlags: grfMode;			logValue: snbExclude tag: 'snbExclude'.		].	[	hresult := implementor OpenStorage: storageName _: pstgPriority _: grfMode _: snbExclude _: reserved _: resultReference.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logFunctionExit: traceContext hresult: hresult ].	^hresult</body><body package="Com- Ole Development">OpenStream: streamName  _: reserved1 _: grfMode _: reserved2 _: resultReference	" Invoke the IStorage::OpenStream function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		self logValue: streamName tag: 'pwcsName'.		self logStorageModeFlags: grfMode.		].	[	hresult := implementor OpenStream: streamName  _: reserved1 _: grfMode _: reserved2 _: resultReference.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logFunctionExit: traceContext hresult: hresult ].	^hresult</body><body package="Com- Ole Development">SetClass: clsid	" Invoke the IStorage::SetClass function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		self logCLSID: clsid.		].	[	hresult := implementor SetClass: clsid.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logHRESULT: hresult ].	^hresult</body></methods><methods><class-id>External.IStorageTraceAdaptor</class-id> <category>subclass-tracing</category><body package="Com- Ole Development">logStorageModeFlags: grfMode	" Load a description of the storage mode flags to the COM trace log. "	| flagNames  |	flagNames := OrderedCollection new.	( grfMode bitAnd: STGM_CONVERT ) ~= 0		ifTrue: [ flagNames add: 'STGM_CONVERT' ].	( grfMode bitAnd: STGM_CREATE ) ~= 0		ifTrue: [ flagNames add: 'STGM_CREATE' ].	( grfMode bitAnd: STGM_DELETEONRELEASE ) ~= 0		ifTrue: [ flagNames add: 'STGM_DELETEONRELEASE' ].	( grfMode bitAnd: STGM_DIRECT ) ~= 0		ifTrue: [ flagNames add: 'STGM_DIRECT' ].	( grfMode bitAnd: STGM_FAILIFTHERE ) ~= 0		ifTrue: [ flagNames add: 'STGM_FAILIFTHERE' ].	( grfMode bitAnd: STGM_PRIORITY ) ~= 0		ifTrue: [ flagNames add: 'STGM_PRIORITY' ].	( grfMode bitAnd: STGM_READ ) ~= 0		ifTrue: [ flagNames add: 'STGM_READ' ].	( grfMode bitAnd: STGM_READWRITE ) ~= 0		ifTrue: [ flagNames add: 'STGM_READWRITE' ].	( grfMode bitAnd: STGM_SHARE_DENY_NONE ) ~= 0		ifTrue: [ flagNames add: 'STGM_SHARE_DENY_NONE' ].	( grfMode bitAnd: STGM_SHARE_DENY_READ ) ~= 0		ifTrue: [ flagNames add: 'STGM_SHARE_DENY_READ' ].	( grfMode bitAnd: STGM_SHARE_DENY_WRITE ) ~= 0		ifTrue: [ flagNames add: 'STGM_SHARE_DENY_WRITE' ].	( grfMode bitAnd: STGM_SHARE_EXCLUSIVE ) ~= 0		ifTrue: [ flagNames add: 'STGM_SHARE_EXCLUSIVE' ].	( grfMode bitAnd: STGM_SIMPLE ) ~= 0		ifTrue: [ flagNames add: 'STGM_SIMPLE' ].	( grfMode bitAnd: STGM_TRANSACTED ) ~= 0		ifTrue: [ flagNames add: 'STGM_TRANSACTED' ].	( grfMode bitAnd: STGM_WRITE ) ~= 0		ifTrue: [ flagNames add: 'STGM_WRITE' ].	self logFlags: grfMode 		nameList: flagNames 		tag: 'grfMode'."COMConstants keys asSortedCollection asArray	select: [ :k | ( k readStream upTo: $_ ) = 'STGM' ]"</body></methods><methods><class-id>External.IStorageTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IStorage.</body></methods><methods><class-id>External.TypeDefinitionString</class-id> <category>comparing</category><body package="Com- Ole Development">= anObject	^self class = anObject class and: [self name = anObject name]</body><body package="Com- Ole Development">hash	^self name hash</body></methods><methods><class-id>External.TypeDefinitionString</class-id> <category>printing</category><body package="Com- Ole Development">printOn: aStream	super printOn: aStream.	aStream nextPutAll: '(' , self name , ')'</body></methods><methods><class-id>External.TypeDefinitionString</class-id> <category>accessing</category><body package="Com- Ole Development">definitionMethodSource		| stream |	stream := String new writeStream.	stream nextPutAll: self name;cr;crtab.	stream nextPutAll: '&lt;C: ',self definitionString,'&gt;'.	^ stream contents.</body><body package="Com- Ole Development">definitionString	^(typeString notNil and: [name notNil])		ifTrue: ['typedef ' , typeString , ' ' , name]		ifFalse: ['']</body><body package="Com- Ole Development">isPrimary	^isPrimary</body><body package="Com- Ole Development">isPrimary: anObject	isPrimary := anObject</body><body package="Com- Ole Development">name	^name</body><body package="Com- Ole Development">name: anObject	name := anObject</body><body package="Com- Ole Development">typeString	^typeString</body><body package="Com- Ole Development">typeString: anObject	typeString := anObject</body></methods><methods><class-id>External.TypeDefinitionString class</class-id> <category>instance creation</category><body package="Com- Ole Development">guessTypeString: aName	^(aName first: 1) = 'I' ifTrue: ['Interface'] ifFalse: [nil]</body><body package="Com- Ole Development">name: aName primary: aBool	^self		name: aName		typeString: (self guessTypeString: aName)		primary: aBool</body><body package="Com- Ole Development">name: aName typeString: typeString primary: aBool	^(self new)		name: aName;		typeString: typeString;		isPrimary: aBool;		yourself</body></methods><methods><class-id>External.COMInterfaceImplementationClassGenerator</class-id> <category>subclass-definition attributes</category><body package="Com- Ole Development">callbackFunctionMethodPrefix	^'invoke'</body><body package="Com- Ole Development">classComment	" Answer a string containing the class comment for the interface wrapper class. "	^((#InstancesProvideExternalCallbackBinding &lt;&lt; #com &gt;&gt; 'Instances of the receiver provide the host-level external callback binding for the &lt;1s&gt; interface.')			expandMacrosWith: interfaceName)</body><body package="Com- Ole Development">interfaceClassNameSuffix	^'Implementation'</body></methods><methods><class-id>External.COMInterfaceImplementationClassGenerator</class-id> <category>subclass-expression generation</category><body package="Com- Ole Development">constructExceptionHandlerExpressionFor: anEntryPointDescription callerType: callerType on: aStream	" Private - append the expressions for the body of the class initialization method for the interface to &lt;aStream&gt;. "	| returnType handlerSelector |	returnType := anEntryPointDescription resultType.	handlerSelector := ( returnType name = #HRESULT		ifTrue: [ #exceptionHandlerForHRESULTReturnValue: ]		ifFalse: [			returnType = CVoidType void 				ifTrue: [ #exceptionHandlerForNilReturnValue: ]				ifFalse: [ returnType class = CIntegerType					ifTrue: [ #exceptionHandlerForZeroReturnValue: ]					ifFalse: [ #exceptionHandlerForNilReturnValue: ] ] ] ).  " what to do?! "	^'( self ', handlerSelector, ' ', callerType printString, ' )'</body></methods><methods><class-id>External.COMInterfaceImplementationClassGenerator</class-id> <category>subclass-generation services</category><body package="Com- Ole Development">constructExternalFunctionInvocationMethodFor: anEntryPointDescription	" Answer a string containing the external interface function invocation method for the given entry point. "	| procedureName argumentNames numArgs incomingArgumentNames functionCallArgumentExpressions resultValueName pointerArgNames clearBufferExpressions tempNames tempExpressions nResultValues resultHandlingExpressions aStream |	procedureName := anEntryPointDescription name.	argumentNames := anEntryPointDescription argumentNames.	numArgs := argumentNames size.	incomingArgumentNames := Array new: numArgs.	functionCallArgumentExpressions := Array new: numArgs.	"Assert isEqual: ( anEntryPointDescription arguments at: 1 ) name to: 'This'."	" by convention, anyway "	incomingArgumentNames at: 1 put: (argumentNames at: 1).	functionCallArgumentExpressions at: 1 put: (argumentNames at: 1).	clearBufferExpressions := OrderedCollection new.	tempNames := OrderedCollection new.	tempExpressions := OrderedCollection new.	pointerArgNames := OrderedCollection new.	resultHandlingExpressions := OrderedCollection new.	resultValueName := anEntryPointDescription isHRESULTFunction				ifTrue: ['hresult']				ifFalse: ['resultValue'].	nResultValues := 0.	2 to: numArgs		do: 			[:i |			| anArgumentDescription argName direction argProcessingSpec anExpression |			anArgumentDescription := anEntryPointDescription arguments at: i.			argName := anArgumentDescription name.			Assert isEqual: argName to: (argumentNames at: i).			direction := self getDirection: anArgumentDescription.			argProcessingSpec := self getProcessingSpec: anArgumentDescription.			incomingArgumentNames at: i put: argName.	" we never mess with these guys "			anArgumentDescription type isPointer				ifTrue: [pointerArgNames add: argName].			(direction = #in or: [direction = #inOut])				ifTrue: 					[anExpression := argProcessingSpec								constructCallinArgumentTransformationExpressionFor: argName								type: anArgumentDescription type.					functionCallArgumentExpressions at: i put: anExpression]				ifFalse: 					[| suffix aTempName |					Assert isTrue: [direction = #out].					clearBufferExpressions						add: 'self clearResultBufferAtAddress: ' , argName , '.'.					suffix := nResultValues = 0								ifTrue: ['']								ifFalse: [nResultValues printString].					aTempName := 'resultReference' , suffix.					functionCallArgumentExpressions at: i put: aTempName.					tempNames add: aTempName.					anExpression := argProcessingSpec								constructCallinResultReferenceExpressionFor: argName								type: anArgumentDescription type.					tempExpressions add: aTempName , ' := ' , anExpression , '.'.					anExpression := argProcessingSpec								constructCallinResultValueExpressionFor: argName								resultReferenceName: aTempName.					resultHandlingExpressions add: anExpression , '.'.					nResultValues := nResultValues + 1]].	aStream := (String new: 128) writeStream.	aStream nextPutAll: (self				constructMessageHeaderFor: procedureName				prefix: self callbackFunctionMethodPrefix				anonymousKeyword: self functionSelectorAnonymousKeyword				argumentNames: incomingArgumentNames				startingAt: 1).	aStream		crtab;		nextPutAll: '" Private - invoke the ' , self interfaceName , '::'					, procedureName , ' function for an external caller. "';		cr;		crtab;		nextPutAll: '" ' , (self							constructExternalProcedureDefinitionFor: anEntryPointDescription									signatureType							name: procedureName							nTabsIndent: 0							printSpecifiers: true							vtableIndex: anEntryPointDescription vtableIndex)					, ' "';		cr;		cr.	aStream		tab;		nextPutAll: '^[  " terminate exception stack unwind at function invocation boundary "';		cr.	tempNames size = 0		ifTrue: 			[(self emitManualGenerationWarningFor: anEntryPointDescription on: aStream)				ifTrue: [aStream cr].			self emitPointerArgumentCheckingFor: pointerArgNames on: aStream.			aStream				tab;				nextPutAll: 'implementor '.			aStream nextPutAll: (self constructMessageHeaderFor: procedureName						argumentNames: functionCallArgumentExpressions).			aStream cr]		ifFalse: 			[aStream				tab;				nextPutAll: '| ' , resultValueName , ' '.			tempNames do: 					[:aTempName |					aStream						nextPutAll: aTempName;						space].			aStream				nextPutAll: '|';				cr.			(self emitManualGenerationWarningFor: anEntryPointDescription on: aStream)				ifTrue: [aStream cr].			self emitPointerArgumentCheckingFor: pointerArgNames on: aStream.			clearBufferExpressions do: 					[:anExpression |					aStream						tab;						nextPutAll: anExpression;						cr].			tempExpressions do: 					[:anExpression |					aStream						tab;						nextPutAll: anExpression;						cr].			aStream				tab;				nextPutAll: resultValueName , ' := implementor '.			aStream nextPutAll: (self constructMessageHeaderFor: procedureName						argumentNames: functionCallArgumentExpressions).			aStream				nextPutAll: '.';				cr.			resultHandlingExpressions size &gt; 0				ifTrue: 					[aStream						tab;						nextPutAll: '( HRESULT succeeded: hresult )';						cr;						tab;						tab;						nextPutAll: 'ifTrue: [';						cr.					resultHandlingExpressions do: 							[:anExpression |							aStream								tab;								tab;								tab;								nextPutAll: anExpression;								cr].					aStream						tab;						tab;						tab;						nextPutAll: '].';						cr].			aStream				tab;				nextPutAll: resultValueName;				cr].	aStream		tab;		nextPutAll: '] on: self rootExceptions';		cr;		tab;		tab;		nextPutAll: 'do: ' , (self							constructExceptionHandlerExpressionFor: anEntryPointDescription							callerType: #externalCallin							on: aStream).	^aStream contents</body><body package="Com- Ole Development">constructFunctionMethodFor: anEntryPointDescription	" Answer a string containing the interface function method for the given entry point. "	| procedureName argumentNames returnsHresult nOutArguments aStream tabCount |	procedureName := anEntryPointDescription name.	argumentNames := anEntryPointDescription argumentNames copy.	returnsHresult := ( anEntryPointDescription resultType name = #HRESULT ).	nOutArguments := 0.	2 to: argumentNames size do: [ :i |		| anArgumentDescription direction argName |		anArgumentDescription := anEntryPointDescription arguments at: i.		direction := self getDirection: anArgumentDescription.		direction = #out			ifTrue: [				argName := 'resultReference', 					( nOutArguments = 0						ifTrue: [ '' ]						ifFalse: [ nOutArguments printString ] ).				argumentNames at: i put: argName.				nOutArguments := nOutArguments + 1 ].		].	aStream := ( String new: 128 ) writeStream.	aStream nextPutAll: ( self constructMessageHeaderFor: procedureName		argumentNames: argumentNames ).	aStream 		crtab; nextPutAll: '" Invoke the ', self interfaceName, '::', procedureName, ' function. "'; cr;		cr.	aStream tab.	returnsHresult 		ifTrue: [			aStream nextPutAll: '| hresult |'; crtab; nextPutAll: 'hresult := '.			tabCount := 2 ]		ifFalse: [ 			aStream nextPutAll: '^'.			tabCount := 1 ].	aStream nextPutAll: '[  " terminate exception stack unwind at function invocation boundary "'; cr.	tabCount timesRepeat: [ aStream tab ].	aStream nextPutAll: 'implementor '.	aStream nextPutAll: ( self constructMessageHeaderFor: procedureName		argumentNames: argumentNames ).	aStream cr.	tabCount timesRepeat: [ aStream tab ].	aStream nextPutAll: '] on: self rootExceptions'; cr.	( tabCount + 1 ) timesRepeat: [ aStream tab ].	aStream nextPutAll: 'do: ',			( self constructExceptionHandlerExpressionFor: anEntryPointDescription 				callerType: #internalCallin 				on: aStream ).	returnsHresult		ifTrue: [			aStream 				nextPut: $.; cr;				tab; nextPutAll: 'self checkHresult: hresult.'; cr;				tab; nextPutAll: '^hresult' ].	^aStream contents</body><body package="Com- Ole Development">emitClassInitializationExpressionsOn: aStream	" Private - append the expressions for the body of the class initialization method for the interface to &lt;aStream&gt;. "	aStream		nextPutAll: 'self iid: ', self iidDefinitionString, '.'; cr;		nextPutAll: 'self vtableSignatureTypeName: ', 			( self class vtableSignatureTypeNameFor: self interfaceName ) printString, '.'; cr;		nextPutAll: 'self updateAndRegister.'.</body><body package="Com- Ole Development">emitPointerArgumentCheckingFor: pointerArgNames on: aStream	" Private "	pointerArgNames size = 0		ifTrue: [ ^self ].	aStream 		tab; nextPutAll: '"### optional - add checking for NULL argument pointers:'; cr;		tab; nextPutAll: 'self reportExternalFunctionEntry.'; cr.	pointerArgNames do: [ :aPointerArgName |		aStream tab; nextPutAll: aPointerArgName, ' isNull ifTrue: [ ^E_INVALIDARG ].'; cr ].	aStream tab; nextPutAll: '###"'; cr.</body></methods><methods><class-id>External.COMInterfaceImplementationClassGenerator</class-id> <category>accessing</category><body package="Com- Ole Development">baseInterfaceClass 	^ COMInterfaceImplementation</body><body package="Com- Ole Development">superInterfaceVtable	^self superInterfaceClass vtableDescription</body></methods><methods><class-id>External.COMInterfaceImplementationClassGenerator class</class-id> <category>subclass-definition attributes</category><body package="Com- Ole Development">definitionTypeDescription	^'Interface Callin Binding'</body></methods><methods><class-id>External.COMFunctionTraceContext</class-id> <category>accessing</category><body package="Com- Ole Development">argumentNames	" Answer the names of the function arguments. "	^argumentNames</body><body package="Com- Ole Development">argumentNames: anArrayOfStrings	" Specify the names of the function arguments. " 	argumentNames := anArrayOfStrings.</body><body package="Com- Ole Development">arguments	" Answer the argument values from the caller. "	^arguments</body><body package="Com- Ole Development">arguments: anArrayOfValues	" Specify the argument values from the caller. "	arguments := anArrayOfValues.</body><body package="Com- Ole Development">callerReportsFunctionEntry	" Answer whether the caller reports function entry. "	^callerReportsFunctionEntry</body><body package="Com- Ole Development">callerReportsFunctionEntry: aBoolean	" Specify whether the caller reports function entry. "	callerReportsFunctionEntry := aBoolean.</body><body package="Com- Ole Development">callerType	" Answer the caller type that invoked the function. "	^callerType</body><body package="Com- Ole Development">callerType: aCallerType	" Specify the caller type that invoked the function. "	callerType := aCallerType.</body><body package="Com- Ole Development">functionSelector	" Answer the message selector of the interface function. "	^functionSelector</body><body package="Com- Ole Development">isTraceEnabled: aBoolean	" Specify whether tracing is enabled. "	isTraceEnabled := aBoolean.</body></methods><methods><class-id>External.COMFunctionTraceContext</class-id> <category>private-accessing</category><body package="Com- Ole Development">functionSelector: aSelector	" Specify the message selector of the interface function. "	functionSelector := aSelector.</body></methods><methods><class-id>External.COMFunctionTraceContext</class-id> <category>testing</category><body package="Com- Ole Development">isTraceEnabled	" Answer whether tracing is currently enabled for the function invocation represented by the receiver. "	^isTraceEnabled and: [ COMSessionManager isTraceEnabled ]</body></methods><methods><class-id>External.COMFunctionTraceContext class</class-id> <category>instance creation</category><body package="Com- Ole Development">on: functionSelector	" Answer a new instance of the receiver for tracing a function invocation of &lt;functionSelector&gt;. Tracing is disabled by default. "	^self new 		functionSelector: functionSelector;		isTraceEnabled: false;		yourself</body></methods><methods><class-id>External.IStreamTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">Read: buffer _: count _: resultReference	" Invoke the IStream::Read function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		self logBufferDescription: buffer.		self logValue: count value tag: 'cb'.		].	[	hresult := implementor Read: buffer _: count _: resultReference.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logFunctionExit: traceContext hresult: hresult ].	^hresult</body><body package="Com- Ole Development">Write: buffer _: count _: resultReference	" Invoke the IStream::Write function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [		self logFunctionHeader: traceContext.		self logBufferDescription: buffer.		self logValue: count value tag: 'cb'.		].	[	hresult := implementor Write: buffer _: count _: resultReference.	] on: Error 		do: ( self exceptionHandlerForHRESULTReturnValue: traceContext ).	traceContext isTraceEnabled ifTrue: [		self logFunctionExit: traceContext hresult: hresult ].	^hresult</body></methods><methods><class-id>External.IStreamTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IStream.</body></methods><methods><class-id>Tools.COMTraceViewer</class-id> <category>private-window events</category><body package="Com- Ole Development">aboutToCloseWindow	" Private - the window is about to close. "	tracingInstalledForThisView		ifTrue: [			( MessageBox confirm: (#GenKey86 &lt;&lt; #com &gt;&gt; 'You activated tracing support when you opened this trace viewer.  Deactivate it again now that you are closing this trace viewer?') asString )				ifFalse: [ tracingInstalledForThisView := false ].  " don't clear things out when we go away "			].</body><body package="Com- Ole Development">aboutToOpenWindow	" Private - the window is about to be opened. "	tracingInstalledForThisView		ifTrue: [ COMSessionManager traceManager activateTracing ].</body><body package="Com- Ole Development">windowClosed	" Private - the window has been closed. "	COMSessionManager traceManager closeLogWindow: traceLog.	"Assert isTrue: [ COMSessionManager isTraceEnabled not ]."	traceLog := nil.	tracingInstalledForThisView		ifTrue: [			COMSessionManager traceManager 				deactivateTracing;				uninstallTraceSupport.			].</body><body package="Com- Ole Development">windowOpened	" Private - the window has been opened. "	"traceLog controller: ( self componentNamed: #traceLogPane ) component controller."	COMSessionManager traceManager		traceLog: traceLog;		traceEnabled: true.</body></methods><methods><class-id>Tools.COMTraceViewer</class-id> <category>private-operation</category><body package="Com- Ole Development">configureInterfaceExternalCallin	" Private - open an editor which allows the user to configure trace options for external callout of interface functions. "	COMTraceOptionsEditor editInterfaceTraceOptionsForExternalCallin.</body><body package="Com- Ole Development">configureInterfaceExternalCallout	" Private - open an editor which allows the user to configure trace options for external callout of interface functions. "	COMTraceOptionsEditor editInterfaceTraceOptionsForExternalCallout.</body></methods><methods><class-id>Tools.COMTraceViewer</class-id> <category>private-initialization</category><body package="Com- Ole Development">initialize	" Private - initialize a new instance. "	tracingInstalledForThisView := false.	traceEnabledHolder := ( AspectAdaptor subject: COMSessionManager traceManager )		accessWith: #traceEnabled		assignWith: #traceEnabled:.	traceCallinHolder := ( AspectAdaptor subject: COMSessionManager traceManager )		accessWith: #traceCallin		assignWith: #traceCallin:.	traceCalloutHolder := ( AspectAdaptor subject: COMSessionManager traceManager )		accessWith: #traceCallout		assignWith: #traceCallout:.	traceInternalCallsHolder := ( AspectAdaptor subject: COMSessionManager traceManager )		accessWith: #traceInternalCalls		assignWith: #traceInternalCalls:.	traceLog := TextWindowTextCollector new.  "old: COMTraceLogAdaptor new"</body></methods><methods><class-id>Tools.COMTraceViewer</class-id> <category>aspects</category><body package="Com- Ole Development">traceCallinHolder	" Answer the value model for the callin tracing check box. "	^traceCallinHolder</body><body package="Com- Ole Development">traceCalloutHolder	" Answer the value model for the callout tracing check box. "	^traceCalloutHolder</body><body package="Com- Ole Development">traceEnabledHolder	" Answer the value model for the trace enablement check box. "	^traceEnabledHolder</body><body package="Com- Ole Development">traceInternalCallsHolder	" Answer the value model for the internal call tracing check box. "	^traceInternalCallsHolder</body><body package="Com- Ole Development">traceLog	" Answer the value model for the trace log pane. "	^traceLog</body></methods><methods><class-id>Tools.COMTraceViewer</class-id> <category>private-accessing</category><body package="Com- Ole Development">tracingInstalledForThisView: aBoolean	" Private "	tracingInstalledForThisView := aBoolean.</body></methods><methods><class-id>Tools.COMTraceViewer</class-id> <category>private-view creation</category><body package="Com- Ole Development">textMenu	"Answer a Menu of operations on the source code that is to 	be displayed when the operate menu button is pressed."	^ParagraphEditor editGroup</body><body package="Com- Ole Development">traceLogComponent	"Construct a view for the trace log text."	| aTextView textEditor |	aTextView := TextCollectorView new model: self traceLog.	textEditor := TextEditorController new.	textEditor menuHolder: ( ValueHolder with: self textMenu ).	aTextView controller: textEditor.	^aTextView</body></methods><methods><class-id>Tools.COMTraceViewer class</class-id> <category>interface specs</category><body package="Com- Ole Development">eventHandlersSpec	" Answer the specifications for connecting components of the application using events "	^super eventHandlersSpec, #(		#( #applicationWindow			#( #built #aboutToOpenWindow )			#( #opened #windowOpened ) 			#( #aboutToClose #aboutToCloseWindow )			#( #closed #windowClosed ) 			)		)</body></methods><methods><class-id>Tools.COMTraceViewer class</class-id> <category>opening</category><body package="Com- Ole Development">open	" Open a view in which COM tracing can be viewed/controlled. "	" COMTraceViewer open "	| tracingInstalledForThisView aTraceViewer |	tracingInstalledForThisView := false.	COMSessionManager traceManager isNil		ifTrue: [ 			| msg |			( COMSessionManager allOwnedInterfaces size &gt; 0 			"or: [ COMSessionManager allExportedInterfaces size &gt; 0 ]" )				ifTrue: [					msg := #GenKey88 &lt;&lt; #com &gt;&gt; 'Tracing support is not currently activated and there are interfaces already in use which will not be traced if you proceed.  Install and activate tracing?'.					]				ifFalse: [					msg := #GenKey87 &lt;&lt; #com &gt;&gt; 'Tracing support is not currently activated.  Install and activate tracing?'.					].			( MessageBox confirm: msg )				ifFalse: [ Screen default ringBell. ^nil ].			tracingInstalledForThisView := true. ].	tracingInstalledForThisView		ifTrue: [ COMTraceManager installTraceSupport ].	aTraceViewer := self new.	aTraceViewer tracingInstalledForThisView: tracingInstalledForThisView.	self openOn: aTraceViewer.	^aTraceViewer</body></methods><methods><class-id>External.IParseDisplayNameTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">ParseDisplayName: anIBindContext _: aDisplayName _: nCharsConsumedReference _: resultReference	" Invoke the IParseDisplayName::ParseDisplayName function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self				logInterfaceValue: anIBindContext tag: 'bindContext';				logValue: aDisplayName tag: 'Display name'.			nCharsConsumedReference notEmpty				ifTrue: [self logValue: nCharsConsumedReference value tag: 'nCharsEaten']].		[hresult := implementor				ParseDisplayName: anIBindContext				_: aDisplayName				_: nCharsConsumedReference				_: resultReference]			on: Error			do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: 					[self						logInterfaceResultValue: resultReference value tag: 'Moniker';						logValue: nCharsConsumedReference value tag: 'nCharsEaten'].			self logHRESULT: hresult].	^hresult</body></methods><methods><class-id>External.IParseDisplayNameTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IParseDisplayName.</body></methods><methods><class-id>External.COMInterfacePointerClassGenerator</class-id> <category>subclass-generation services</category><body package="Com- Ole Development">constructExternalFunctionInvocationMethodFor: anEntryPointDescription	" Answer a string containing the external interface function invocation method for the given entry point. "	| procedureName argumentNames procedureDefinition aStream |	procedureName := anEntryPointDescription name.	argumentNames := anEntryPointDescription argumentNames.	procedureDefinition := self constructExternalProcedureDefinitionFor: anEntryPointDescription signatureType		name: procedureName		nTabsIndent: 0 		printSpecifiers: true 		vtableIndex: anEntryPointDescription vtableIndex.	aStream := ( String new: 128 ) writeStream.	aStream nextPutAll: ( self constructMessageHeaderFor: procedureName		prefix: self primitiveFunctionMethodPrefix		argumentNames: argumentNames ).	aStream		crtab; nextPutAll: '" Private - invoke the ', self interfaceName, '::', procedureName, ' function. "'; cr;		crtab; nextPutAll: '&lt;COM: ';			nextPutAll: procedureDefinition;			nextPutAll: '&gt;';		crtab; nextPutAll: '^self externalAccessFailedWith: _errorCode'.	^aStream contents</body><body package="Com- Ole Development">constructFunctionMethodFor: anEntryPointDescription	" Answer a string containing the interface function method for the given entry point. "	| procedureName argumentNames numArgs incomingArgumentNames primitiveCallArgumentExpressions resultValueName tempNames tempExpressions resultHandlingExpressions tempReleaseExpressions aStream |	procedureName := anEntryPointDescription name.	argumentNames := anEntryPointDescription argumentNames.	numArgs := argumentNames size.	incomingArgumentNames := Array new: numArgs.	primitiveCallArgumentExpressions := Array new: numArgs.	"Assert isEqual: ( anEntryPointDescription arguments at: 1 ) name to: 'This'."	" by convention, anyway "	incomingArgumentNames at: 1 put: (argumentNames at: 1).	primitiveCallArgumentExpressions at: 1 put: (argumentNames at: 1).	tempNames := OrderedCollection new.	tempExpressions := OrderedCollection new.	resultHandlingExpressions := OrderedCollection new.	tempReleaseExpressions := OrderedCollection new.	resultValueName := anEntryPointDescription isHRESULTFunction				ifTrue: ['hresult']				ifFalse: ['resultValue'].	2 to: numArgs		do: 			[:i |			| anArgumentDescription argName direction argProcessingSpec argumentTransformationExpression |			anArgumentDescription := anEntryPointDescription arguments at: i.			argName := anArgumentDescription name.			Assert isEqual: argName to: (argumentNames at: i).			direction := self getDirection: anArgumentDescription.			argProcessingSpec := self getProcessingSpec: anArgumentDescription.			(direction = #in or: [direction = #inOut])				ifTrue: 					[incomingArgumentNames at: i put: argName.					argumentTransformationExpression := argProcessingSpec								constructCalloutArgumentTransformationExpressionFor: argName								type: anArgumentDescription type.					argProcessingSpec requiresTempForCalloutArgument						ifTrue: 							[| aTempName aReleaseExpression |							aTempName := argName , 'Arg'.							tempNames add: aTempName.							tempExpressions								add: aTempName , ' := ' , argumentTransformationExpression , '.'.							primitiveCallArgumentExpressions at: i								put: aTempName , ' asPointerParameter'.							aReleaseExpression := argProcessingSpec										constructCalloutArgumentReleaseExpressionFor: aTempName.							tempReleaseExpressions add: aReleaseExpression]						ifFalse: 							[primitiveCallArgumentExpressions at: i								put: argumentTransformationExpression]]				ifFalse: 					[| suffix aTempName anExpression |					Assert isTrue: [direction = #out].					suffix := tempNames size = 0								ifTrue: ['']								ifFalse: [tempNames size printString].					incomingArgumentNames at: i put: 'resultReference' , suffix.					aTempName := i = numArgs								ifTrue: ['resultBuffer']								ifFalse: [anArgumentDescription name].					tempNames add: aTempName.					anExpression := argProcessingSpec								constructCalloutResultBufferExpressionFor: argName								type: anArgumentDescription type.					tempExpressions add: aTempName , ' := ' , anExpression , '.'.					primitiveCallArgumentExpressions at: i						put: aTempName , ' asPointerParameter'.					anExpression := argProcessingSpec								constructCalloutResultBufferContentsExpressionFor: aTempName.					resultHandlingExpressions						add: 'resultReference' , suffix , ' value: ' , anExpression , '.']].	aStream := (String new: 128) writeStream.	aStream nextPutAll: (self constructMessageHeaderFor: procedureName				argumentNames: incomingArgumentNames).	aStream		crtab;		nextPutAll: '" Invoke the ' , self interfaceName , '::' , procedureName					, ' function. "';		cr;		cr.	tempNames size = 0		ifTrue: 			[(self emitManualGenerationWarningFor: anEntryPointDescription on: aStream)				ifTrue: [aStream cr].			aStream				tab;				nextPutAll: '^self ';				nextPutAll: (self							constructMessageHeaderFor: procedureName							prefix: self primitiveFunctionMethodPrefix							argumentNames: primitiveCallArgumentExpressions)]		ifFalse: 			[aStream				tab;				nextPutAll: '| ' , resultValueName , ' '.			tempNames do: 					[:aTempName |					aStream						nextPutAll: aTempName;						space].			aStream				nextPutAll: '|';				cr.			(self emitManualGenerationWarningFor: anEntryPointDescription on: aStream)				ifTrue: [aStream cr].			tempExpressions do: 					[:anExpression |					aStream						tab;						nextPutAll: anExpression;						cr].			tempReleaseExpressions size &gt; 0				ifTrue: 					[aStream						tab;						nextPut: $[;						cr].			aStream				tab;				nextPutAll: resultValueName , ' := self '.			aStream nextPutAll: (self						constructMessageHeaderFor: procedureName						prefix: self primitiveFunctionMethodPrefix						argumentNames: primitiveCallArgumentExpressions).			aStream				nextPutAll: '.';				cr.			resultHandlingExpressions do: 					[:anExpression |					aStream						tab;						nextPutAll: anExpression;						cr].			tempReleaseExpressions size &gt; 0				ifTrue: 					[aStream						tab;						nextPutAll: '] ensure: [';						cr.					tempReleaseExpressions do: 							[:anExpression |							aStream								tab;								tab;								nextPutAll: anExpression , '.';								cr].					aStream						tab;						tab;						nextPutAll: '].';						cr].			aStream				tab;				nextPutAll: '^' , resultValueName].	^aStream contents</body><body package="Com- Ole Development">emitClassInitializationExpressionsOn: aStream	" Private - append the expressions for the body of the class initialization method for the interface to &lt;aStream&gt;. "	aStream		nextPutAll: 'self iid: ', self iidDefinitionString, '.'; cr;		nextPutAll: 'self updateAndRegister.'.</body></methods><methods><class-id>External.COMInterfacePointerClassGenerator</class-id> <category>subclass-definition attributes</category><body package="Com- Ole Development">classComment	" Answer a string containing the class comment for the interface wrapper class. "	^((#InstancesProvideCalloutBinding &lt;&lt; #com &gt;&gt; 'Instances of the receiver provide the host-level external callout binding for the &lt;1s&gt; interface.')			expandMacrosWith: interfaceName)</body><body package="Com- Ole Development">interfaceClassNameSuffix	^'Pointer'</body><body package="Com- Ole Development">primitiveFunctionMethodPrefix	^'invoke'</body></methods><methods><class-id>External.COMInterfacePointerClassGenerator</class-id> <category>accessing</category><body package="Com- Ole Development">baseInterfaceClass 	^ COMInterfacePointer</body><body package="Com- Ole Development">superInterfaceVtable	^self superInterfaceClass vtableDescription</body></methods><methods><class-id>External.COMInterfacePointerClassGenerator</class-id> <category>As yet unclassified</category><body package="Com- Ole Development">compileExternalInvokationMethod: source 	"tempoary workaround. The RBFormatter currently does not work for COM method sources. For now,	 disable formatting invocation methods in COMInterfacePointer subclasses"		self compileInstanceMethod: source in: self functionExternalMethodsCategoryName</body></methods><methods><class-id>External.COMInterfacePointerClassGenerator class</class-id> <category>subclass-definition attributes</category><body package="Com- Ole Development">definitionTypeDescription	^(#InterfaceCalloutBinding &lt;&lt; #com &gt;&gt; 'Interface Callout Binding') asString</body></methods><methods><class-id>Tools.ComSettingsPage</class-id> <category>interface management</category><body package="Com- Ole Development">postBuildWith: aBuilder	"The settings page (the receiver) wants to be the last dependent in the dependents collection	 for triggerChannel.   This is to ensure that the transcript changes are applied at 	 the right time.  If this was not done, then #setupTranscript is sent too soon and the right changes	 would not be applied."	super postBuildWith: aBuilder.	manager triggerChannel retractInterestsFor: self.	manager triggerChannel		onChangeSend: #triggered		to: self</body></methods><methods><class-id>Tools.ComSettingsPage</class-id> <category>initialize-release</category><body package="Com- Ole Development">manager: aSettingsManager	super manager: aSettingsManager.	self	when: (self moduleForSettingWithId: #(#com #defaultLCID)) valueHolder		valueSatisfies: [:v | v isNil]		enable: (self moduleForSettingWithId: #(#com #customLCID)).	manager triggerChannel		onChangeSend: #triggered		to: self</body></methods><methods><class-id>Tools.ComSettingsPage</class-id> <category>notifications</category><body package="Com- Ole Development">triggered	COMSessionManager defaultLocaleIDInitializer value.	(self moduleForSettingWithId: #(#com #customLCID)) valueHolder value: COMSessionManager defaultLocaleID</body></methods><methods><class-id>Tools.COMTraceOptionsEditor class</class-id> <category>private-utilities</category><body package="Com- Ole Development">allTraceableInterfaceClasses	" Private - answer a list of all interface classes which allow tracing.  Ignore abstract classes and duplicate IID mappings. "	| allTraceableInterfaceClasses allTraceableIIDs |	allTraceableInterfaceClasses := OrderedCollection new.	allTraceableIIDs := Set new.	COMInterface withAllSubclasses do: [ :anInterfaceClass |		| anIID |		( ( anIID := anInterfaceClass iid ) notNil   " ignore abstract classes "		and: [ anInterfaceClass allowsTracing   " ignore guys which don't ever want to be traced "		and: [ ( allTraceableIIDs includes: anIID ) not ] ] )  " ignore subclasses of already-mapped IID's "			ifTrue: [				allTraceableInterfaceClasses add: anInterfaceClass.				allTraceableIIDs add: anIID ] ].	^allTraceableInterfaceClasses asArray</body><body package="Com- Ole Development">constructOptionsInfoMapFor: traceType	" Private - construct a list of all supported interfaces and their current setting for. "	" options map key is a description of the interface.  For trace type #all, value is:		#( &lt;iid&gt; &lt;current trace options&gt; )	For a specific trace type, value is:		#( &lt;iid&gt; &lt;currently enabled state&gt; )	"	| allTraceableInterfaceClasses optionsInfoMap addEntryBlock |	allTraceableInterfaceClasses := self allTraceableInterfaceClasses.	optionsInfoMap := Dictionary new.	addEntryBlock := [ :anInterfaceDescription :anIID :currentOptions |		| optionInfo |		optionInfo := ( traceType = #all			ifTrue: [ currentOptions ]			ifFalse: [ ( currentOptions notNil and: [ currentOptions includes: traceType ] ) ] ).		optionsInfoMap at: anInterfaceDescription 			put: ( Array with: anIID with: optionInfo ) ].	" construct info for all the standard guys "	allTraceableInterfaceClasses do: [ :anInterfaceClass |		addEntryBlock value: anInterfaceClass name asString 			value: anInterfaceClass iid			value: ( COMTraceManager traceOptionsForIID: anInterfaceClass iid ).		].	" now check for trace options for IID's which map onto shared wrapper classes "	COMTraceManager interfaceTraceOptionsRegistry keysAndValuesDo: [ :anIID :currentOptions |		| anInterfaceClass |		anInterfaceClass := allTraceableInterfaceClasses detect: [ :c | c iid = anIID ]			ifNone: [ nil ].		anInterfaceClass isNil			ifTrue: [  " aha, a multiple identity guy "				anInterfaceClass := allTraceableInterfaceClasses					detect: [ :c | ( c supportsIID: anIID ) and: [ c iid ~= anIID ] ]					ifNone: [ nil ].				anInterfaceClass notNil					ifTrue: [						addEntryBlock value: anInterfaceClass name, '-', anIID asString 							value: anIID							value: currentOptions ].				] ].	^optionsInfoMap</body><body package="Com- Ole Development">createListDialogFor: traceType	| aListDialog |	aListDialog := MultiSelectListDialog new.	aListDialog		title: #InterfaceTraceOptions &lt;&lt; #com &gt;&gt; 'Interface Trace Options';		textLines: ( Array			"Version 1 was:			with: 'Set trace options for ', ( self traceTypeDescriptionFor: traceType ), '.'			with: 'Select interface(s) to enable tracing.'			with: '(Deselect to disable tracing)' 			"			with: ((#x1sFunctionTracingC &lt;&lt; #com &gt;&gt; '&lt;1s&gt; function tracing:')				expandMacrosWith: (self traceTypeDescriptionFor: traceType))			with: ( String with: Character tab), (#selectToEnableOption &lt;&lt; #com &gt;&gt; '- select to enable') asString			with: ( String with: Character tab),(#deselectToDisableOption &lt;&lt; #com &gt;&gt; '- deselect to disable') asString			).	^aListDialog</body><body package="Com- Ole Development">openInterfaceTraceOptionsDialogFor: traceType 	" Private - open a dialog for editing the enablement state of the interface trace option &lt;traceType&gt;. "	| optionsInfoMap interfaceDescriptionList selectedEntries aListDialog |	(COMTraceManager supportedTraceTypes includes: traceType) 		ifFalse: [self error: #ErrUnknownTraceType &lt;&lt; #com &gt;&gt; 'unknown trace type'].	optionsInfoMap := self constructOptionsInfoMapFor: traceType.	interfaceDescriptionList := optionsInfoMap keys asSortedCollection asArray.	selectedEntries := OrderedCollection new.	1 to: interfaceDescriptionList size		do: 			[:i | 			((optionsInfoMap at: (interfaceDescriptionList at: i)) at: 2) 				ifTrue: [selectedEntries add: i]	" currently enabled? "].	aListDialog := self createListDialogFor: traceType.	aListDialog		maxEntriesToShow: (30 min: interfaceDescriptionList size);		returnItems: false.	selectedEntries := aListDialog openOn: interfaceDescriptionList				selection: selectedEntries.	selectedEntries isNil ifTrue: [^self].	1 to: interfaceDescriptionList size		do: 			[:i | 			| interfaceDescription anIID |			interfaceDescription := interfaceDescriptionList at: i.			anIID := (optionsInfoMap at: interfaceDescription) at: 1.			(selectedEntries includes: i) 				ifTrue: [COMTraceManager enableTraceType: traceType forIID: anIID]				ifFalse: [COMTraceManager disableTraceType: traceType forIID: anIID]]</body><body package="Com- Ole Development">traceTypeDescriptionFor: traceType 	traceType = #externalCallin ifTrue: [^(#ExternalCallin &lt;&lt; #com &gt;&gt; 'External callin') asString].	traceType = #externalCallout ifTrue: [^(#ExternalCallout &lt;&lt; #com &gt;&gt; 'External callout') asString].	traceType = #internalCallin ifTrue: [^(#InternalCalls &lt;&lt; #com &gt;&gt; 'Internal calls ') asString].	self error: #ErrUnknownTraceType &lt;&lt; #com &gt;&gt; 'unknown trace type'</body></methods><methods><class-id>Tools.COMTraceOptionsEditor class</class-id> <category>utility dialogs</category><body package="Com- Ole Development">editInterfaceTraceOptionsForExternalCallin	" Open a dialog which allows the current interface trace options for external function callin to be edited. "	" COMTraceOptionsEditor editInterfaceTraceOptionsForExternalCallin "	self openInterfaceTraceOptionsDialogFor: #externalCallin</body><body package="Com- Ole Development">editInterfaceTraceOptionsForExternalCallout	" Open a dialog which allows the current interface trace options for external function callout to be edited. "	" COMTraceOptionsEditor editInterfaceTraceOptionsForExternalCallout "	self openInterfaceTraceOptionsDialogFor: #externalCallout</body><body package="Com- Ole Development">editInterfaceTraceOptionsForInternalCallin	" Open a dialog which allows the current interface trace options for internal function callin to be edited. "	" COMTraceOptionsEditor editInterfaceTraceOptionsForInternalCallin "	self openInterfaceTraceOptionsDialogFor: #internalCallin</body></methods><methods><class-id>External.IEnumTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">Clone: resultReference	" Invoke the IEnum::Clone function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [self logFunctionHeader: traceContext].	[hresult := implementor Clone: resultReference] on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: [self logInterfaceResultValue: resultReference value tag: 'IEnum'].			self logHRESULT: hresult].	^hresult</body><body package="Com- Ole Development">Next: cElements _: elementBuffer _: resultReference	" Invoke the IEnum::Next function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self logValue: cElements tag: 'cElements'].	[hresult := implementor Next: cElements _: elementBuffer _: resultReference]		on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: 					["...log returned elements..."					self logValue: resultReference value tag: 'Count fetched'].			self logHRESULT: hresult].	^hresult</body></methods><methods><class-id>External.IEnumTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IEnum</body></methods><methods><class-id>External.COMBasicInterfaceTraceAdaptor</class-id> <category>subclass-interface operations</category><body package="Com- Ole Development">invokeInterfaceFunction: traceContext	" Invoke the interface function whose invocation is described by &lt;traceContext&gt;.  Dispatch the message to the implementing object.  Wrap the actual function invocation with the standard pattern of mininal tracing. "	^self invokeInterfaceFunctionWithEntryTrace: traceContext</body></methods><methods><class-id>External.COMArgumentDescription</class-id> <category>accessing</category><body package="Com- Ole Development">attributes	" Answer the attributes associated with the argument. "	^attributes</body><body package="Com- Ole Development">attributes: argAttributes	" Specify the attributes of the argument. "	attributes := argAttributes.</body><body package="Com- Ole Development">name	" Answer the name of the argument. "	^name</body><body package="Com- Ole Development">name: aString	" Specify the name of the argument. "	name := aString.</body><body package="Com- Ole Development">type	" Answer the C type of the argument. "	^type</body><body package="Com- Ole Development">type: aType	" Specify the C type of the argument. "	type := aType.</body></methods><methods><class-id>External.COMArgumentDescription</class-id> <category>printing</category><body package="Com- Ole Development">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	self name isNil		ifTrue: [ ^self ].	self attributes isNil		ifTrue: [ aStream nextPutAll: ' ( ', self name, ' )' ]		ifFalse: [			| typeDescription direction |			typeDescription := ( self attributes at: 2 ) category.			direction := self attributes at: 1.			aStream nextPutAll: ' ( [', direction, ', ', typeDescription, '] ', self type printString, self name, ')' ].</body></methods><methods><class-id>External.COMInterfaceSpec</class-id> <category>accessing</category><body package="Com- Ole Development">iid	^COMConstants at: self iidString asSymbol		ifAbsent: 			[('{########-####-####-####-############}' match: self iidString)				ifTrue: [GUID fromString: self iidString]				ifFalse: [nil]]</body><body package="Com- Ole Development">iidString	^iidString</body><body package="Com- Ole Development">iidString: anObject	iidString := anObject ifNotNil: [self class fixGuidString: anObject]</body><body package="Com- Ole Development">name	^name</body><body package="Com- Ole Development">name: anObject	name := anObject</body></methods><methods><class-id>External.COMInterfaceSpec</class-id> <category>comparing</category><body package="Com- Ole Development">= anObject	^self class = anObject class and: [self name = anObject name]</body><body package="Com- Ole Development">hash	^self name hash</body></methods><methods><class-id>External.COMInterfaceSpec</class-id> <category>testing</category><body package="Com- Ole Development">containsValidIIDString	^ self class isValidIIDString: self iidString</body><body package="Com- Ole Development">needsIIDDefinition	^(COMConstants includesKey: self iidString asSymbol) not</body></methods><methods><class-id>External.COMInterfaceSpec class</class-id> <category>private</category><body package="Com- Ole Development">fixGuidString: aString	| guid |	guid := aString trimBlanks.	('{########-####-####-####-############}' match: guid) ifTrue: [^guid].	('(########-####-####-####-############)' match: guid)		ifTrue: [^'{' , (guid copyFrom: 2 to: guid size - 1) , '}'].	('########-####-####-####-############' match: guid)		ifTrue: [^'{' , guid , '}'].	^guid</body><body package="Com- Ole Development">guessIIDStringFor: aSymbol	^(COMConstants bindingFor: ('IID_' , aSymbol) asSymbol)		ifNotNil: [:binding | binding key]</body></methods><methods><class-id>External.COMInterfaceSpec class</class-id> <category>instance creation</category><body package="Com- Ole Development">name: aSymbol	^self name: aSymbol iidString: (self guessIIDStringFor: aSymbol)</body><body package="Com- Ole Development">name: aName iidString: anIIDString	^ self new		name: aName;		iidString: anIIDString;		yourself</body></methods><methods><class-id>External.COMInterfaceSpec class</class-id> <category>testing</category><body package="Com- Ole Development">isValidIIDString: aString	| key |	aString ifNil: [^false].	key := aString trimBlanks.	((key first: 4) = 'IID_' and: [COMConstants includesKey: key asSymbol])		ifTrue: [^true].	^(GUID fromString: (self fixGuidString: key)) notNil</body></methods><methods><class-id>External.IClassFactoryTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">CreateInstance: controllingUnknown _: iid _: resultReference	" Invoke the IClassFactory::CreateInstance function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self				logInterfaceValue: controllingUnknown tag: 'Controlling unknown';				logIID: iid].		[hresult := implementor				CreateInstance: controllingUnknown				_: iid				_: resultReference]			on: Error			do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: 					[self logInterfaceResultValue: resultReference value tag: 'Created object'].			self logHRESULT: hresult].	^hresult</body></methods><methods><class-id>External.IClassFactoryTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self  forIID: IID_IClassFactory.</body></methods><methods><class-id>Tools.COMResourceBrowser</class-id> <category>private-operation</category><body package="Com- Ole Development">cleanUpLists	" Private - the Clean Up Lists button has been pressed. "</body><body package="Com- Ole Development">clearLists	" Private - clear the lists of resources "	super clearLists.	self clearOwnedLists.</body><body package="Com- Ole Development">clearOwnedLists	" Private - clear the lists of owned resources "	self 		setOwnedInterfaces: #();		setOwnedMemory: #( ).</body><body package="Com- Ole Development">selectionChangedInOwnedInterfacesList	" Private - an item has been selected in the owned interfaces list. "	| aResource aResourceListMenu |	aResource := self selectedOwnedInterface.	aResourceListMenu := self ownedInterfacesMenu.	aResource isNil		ifTrue: [ self disableMenu: aResourceListMenu ]		ifFalse: [ self enableMenu: aResourceListMenu ].</body><body package="Com- Ole Development">selectionChangedInOwnedMemoryList	" Private - an item has been selected in the owned memory addresses list. "	| aResource aResourceListMenu |	aResource := self selectedOwnedMemory.	aResourceListMenu := self ownedMemoryMenu.	aResource isNil		ifTrue: [ self disableMenu: aResourceListMenu ]		ifFalse: [ self enableMenu: aResourceListMenu ].</body><body package="Com- Ole Development">selectionChangedInSpecialResourcesList	" Private - an item has been selected in the special resources list.  Update the description. "	| aSpecialResource |	aSpecialResource := self specialResourcesListModel selection.	self setSpecialResourceDescription: 		( self getSpecialResourceDescriptionOf: aSpecialResource ).</body><body package="Com- Ole Development">updateOwnedResourceLists	" Private - update the lists of owned resources "	| specialResourceList |	specialResourceList := COMSessionManager specialSessionResources keys asArray		collect: [ :aResource |			aResource isCOMInterfacePointer 				ifTrue: [ aResource asInterfacePointer ]				ifFalse: [ aResource ] ].	self setSpecialResources: ( self sortObjects: specialResourceList ).	self setOwnedInterfaces: ( self sortInterfaces: 		( COMSessionManager allOwnedInterfaces			"reject: [ :anInterface | specialResourceList includes: anInterface ]" ) ).	self setOwnedMemory: ( self sortObjects:		( COMSessionManager allOwnedMemoryAddresses			"reject: [ :anInterface | specialResourceList includes: anInterface ]" ) ).</body><body package="Com- Ole Development">updateResourceLists	" Private - update the lists of resources "	self		updateOwnedResourceLists;		updateExportedResourceLists.	self validateAllocatedInterfaces.	self updateCleanupMenu.</body><body package="Com- Ole Development">validateAllocatedInterfaces	" Private - verify that the allocated and exported interfaces lists are consistent.  We display the exported list, so if they are not the same then display the allocated list. "	| exportsList allocatedList problemsFound |	exportsList := COMSessionManager allExportedInterfaces.	allocatedList := COMSessionManager allAllocatedInterfaces				select: [:each | each hasExternalResources].	problemsFound := false.	(exportsList elementsEqual: allocatedList)		ifFalse: 			[problemsFound := true.			COMExportedObjectsBrowser open.			MessageBox				notify: (#COMResourceTrackingProblem &lt;&lt; #com						&gt;&gt; 'COM Resource Tracking Problem') asString				withText: (#GenKey78 &lt;&lt; #com						&gt;&gt; 'The allocated interfaces registry is different than the exported interfaces list obtained from the ExternalObjectTable and displayed in this browser.  This is unexpected and should be reported to the OLE developers.')							asString].	exportsList := (exportsList				collect: [:anInterface | anInterface implementingObject]) asSet.	allocatedList := (allocatedList				collect: [:anInterface | anInterface implementingObject]) asSet.	(exportsList elementsEqual: allocatedList)		ifFalse: 			[problemsFound				ifFalse: 					[COMExportedObjectsBrowser open.					problemsFound := true].			MessageBox				notify: (#COMResourceTrackingProblem &lt;&lt; #com						&gt;&gt; 'COM Resource Tracking Problem') asString				withText: (#GenKey77 &lt;&lt; #com						&gt;&gt; 'The allocated interfaces registry has a different list of implementing objects than the exported objects list obtained from the ExternalObjectTable and displayed in this browser.  This is unexpected and should be reported to the OLE developers.')							asString].	^problemsFound</body></methods><methods><class-id>Tools.COMResourceBrowser</class-id> <category>private-utilities</category><body package="Com- Ole Development">getExportedInterfaceList	" Private - answer the unsorted list of interface implementations to display in the exported interfaces list. "	^COMSessionManager allAllocatedInterfaces</body><body package="Com- Ole Development">getSpecialResourceDescriptionOf: aSpecialResource	" Private - answer a description of the special resource "	| specialResourcesMap description resourceWrapper |	aSpecialResource isNil		ifTrue: [ ^'' ].	specialResourcesMap := COMSessionManager specialSessionResources.	description := specialResourcesMap at: aSpecialResource		ifAbsent: [			resourceWrapper := specialResourcesMap keys				detect: [ :aResource |					aResource isCOMInterface 					and: [ aResource asInterfacePointer = aSpecialResource ] ]				ifNone: [ nil ].			resourceWrapper isNil				ifTrue: [ #DescriptionNotFound &lt;&lt; #com &gt;&gt; '( description not found )' ] 				ifFalse: [ '( ', ( specialResourcesMap at: resourceWrapper ), ' ) ' ] ].	^description</body></methods><methods><class-id>Tools.COMResourceBrowser</class-id> <category>private-initialization</category><body package="Com- Ole Development">initialize	" Private - initialize a newly created instance. "	super initialize.	specialResourcesListModel := SelectionInList new.	ownedInterfacesListModel := SelectionInList new.	ownedMemoryListModel := SelectionInList new.	" register handlers for list selection #changed events "	specialResourcesListModel selectionHolder		onChangeSend: #selectionChangedInSpecialResourcesList to: self.	ownedInterfacesListModel selectionHolder		onChangeSend: #selectionChangedInOwnedInterfacesList to: self.	ownedMemoryListModel selectionHolder		onChangeSend: #selectionChangedInOwnedMemoryList to: self.</body></methods><methods><class-id>Tools.COMResourceBrowser</class-id> <category>private-resource list menus</category><body package="Com- Ole Development">inspectOwnedInterface	" Private "	| selectedResource |	selectedResource := self selectedOwnedInterface.	Assert notNil: selectedResource.  " otherwise menu should have been disabled "	selectedResource inspect.</body><body package="Com- Ole Development">inspectOwnedMemory	" Private "	| selectedResource |	selectedResource := self selectedOwnedMemory.	Assert notNil: selectedResource.  " otherwise menu should have been disabled "	selectedResource inspect.</body><body package="Com- Ole Development">releaseOwnedInterface	" Private "	| selectedResource implementingObject resourceList |	selectedResource := self selectedOwnedInterface.	Assert notNil: selectedResource.  " otherwise menu should have been disabled "	resourceList := self ownedInterfaces reject: [ :aResource | 		aResource == selectedResource ].	implementingObject := selectedResource implementingObject.	self releaseOwnedInterface: selectedResource.	self setOwnedInterfaceSelection: nil.	self setOwnedInterfaces: resourceList.	( implementingObject notNil	and: [ implementingObject referenceCount = 0 ] )		ifTrue: [ self updateResourceLists ]  " the object just went away "		ifFalse: [ self updateCleanupMenu ].</body><body package="Com- Ole Development">releaseOwnedMemory	" Private "	| selectedResource resourceList |	selectedResource := self selectedOwnedMemory.	Assert notNil: selectedResource.  " otherwise menu should have been disabled "	resourceList := self ownedMemoryAddresses reject: [ :aResource | 		aResource == selectedResource ].	self releaseOwnedMemory: selectedResource.	self setOwnedMemorySelection: nil.	self setOwnedMemory: resourceList.	self updateCleanupMenu.</body></methods><methods><class-id>Tools.COMResourceBrowser</class-id> <category>private-accessing</category><body package="Com- Ole Development">ownedInterfaces	" Private - answer the list of owned interfaces. "	^self ownedInterfacesListModel list</body><body package="Com- Ole Development">ownedInterfacesMenu	" Private - answer the pane menu associated with the owned interfaces resource list. "	^self builder menuAt: #menuSpecOwnedInterfaces</body><body package="Com- Ole Development">ownedMemoryAddresses	" Private - answer the list of owned memory addresses. "	^self ownedMemoryListModel list</body><body package="Com- Ole Development">ownedMemoryMenu	" Private - answer the pane menu associated with the owned memory addresses resource list. "	^self builder menuAt: #menuSpecOwnedMemory</body><body package="Com- Ole Development">selectedOwnedInterface	" Private - answer the current selection in the list of owned interfaces. "	^self ownedInterfacesListModel selection</body><body package="Com- Ole Development">selectedOwnedMemory	" Private - answer the current selection in the list of owned memory address. "	^self ownedMemoryListModel selection</body><body package="Com- Ole Development">setOwnedInterfaceSelection: aValue	" Private - set the current selection in the list of owned interfaces. "	self ownedInterfacesListModel selection: aValue.</body><body package="Com- Ole Development">setOwnedInterfaces: aList	" Private - set the list of owned interfaces. "	self ownedInterfacesListModel list: aList.</body><body package="Com- Ole Development">setOwnedMemory: aList	" Private - set the list of owned memory addresses. "	self ownedMemoryListModel list: aList.</body><body package="Com- Ole Development">setOwnedMemorySelection: aValue	" Private - set the current selection in the list of owned memory address. "	self ownedMemoryListModel selection: aValue.</body><body package="Com- Ole Development">setSpecialResourceDescription: aString	" Private "	self builder isNil ifTrue: [ ^self ].  " punt pre-open notifications from dependency mechanisms "	( self componentNamed: #specialResourceDescription ) 		"was: labelString: aString."  " tacky, displays as bold "		label: ( Label with: aString asText )</body><body package="Com- Ole Development">setSpecialResources: aList	" Private - set the list of special resources. "	self specialResourcesListModel list: aList.</body></methods><methods><class-id>Tools.COMResourceBrowser</class-id> <category>private-aspects</category><body package="Com- Ole Development">ownedInterfacesListModel	" Private - answer the model for the owned interfaces list. "	^ownedInterfacesListModel</body><body package="Com- Ole Development">ownedMemoryListModel	" Private - answer the model for the owned memory list. "	^ownedMemoryListModel</body><body package="Com- Ole Development">specialResourcesListModel	" Private - answer the model for the special resources list. "	^specialResourcesListModel</body></methods><methods><class-id>Tools.COMResourceBrowser</class-id> <category>private-registry menu</category><body package="Com- Ole Development">registryInspectAllocatedInterfaces	" Private - inspect the registry containing allocated COM interfaces exported from this process. "	COMSessionManager allocatedInterfacesRegistry inspect.</body><body package="Com- Ole Development">registryInspectHostResources	" Private - inspect the registry containing Win32 host resources. "	SystemExternalResourcesRegistry currentRegistry inspect.</body><body package="Com- Ole Development">registryInspectOwnedInterfaces	" Private - inspect the registry containing COM interfaces owned by this process. "	COMSessionManager ownedInterfacesRegistry inspect.</body><body package="Com- Ole Development">registryInspectOwnedMemory	" Private - inspect the registry containing COM memory addresses owned by this process. "	COMSessionManager ownedMemoryRegistry inspect.</body></methods><methods><class-id>External.COMExtendedEntryPointDescription</class-id> <category>accessing</category><body package="Com- Ole Development">arguments	" Answer the argument descriptors. "	^arguments</body><body package="Com- Ole Development">signatureType: aProcedureType	"Set the procedure type which defines the signature of the entry point described by the receiver."	| procedureTypeWithFiddledArgNames |	procedureTypeWithFiddledArgNames := aProcedureType copy.	procedureTypeWithFiddledArgNames argumentNames: 		( self constructWrapperMethodArgumentNamesFrom: aProcedureType argumentNames ).	super signatureType: procedureTypeWithFiddledArgNames.	self initializeArguments</body></methods><methods><class-id>External.COMExtendedEntryPointDescription</class-id> <category>private-initialization</category><body package="Com- Ole Development">constructWrapperMethodArgumentNamesFrom: rawArgumentNames        "Answer the argument names to use in a wrapper method which accesses the entry point described by the receiver.  "	" Ensure that the arg names follow the Smalltalk lower-case convention for local variables, both to conform to the usual style and to avoid name space scope warnings in the event that an uppercased arg name from the header file or type library has a name which is used by a class in the Smalltalk global name space. "	| lowerCasedArgNames |	lowerCasedArgNames := rawArgumentNames copy.	1 to: lowerCasedArgNames size do: [ :i |		| anArgName firstChar |		anArgName := lowerCasedArgNames at: i .		( firstChar := anArgName first ) isUppercase			ifTrue: [				anArgName := anArgName copy.				anArgName at: 1 put: firstChar asLowercase.				" ensure we don't introduce any collisions by this case change "				( lowerCasedArgNames includes: anArgName )					ifTrue: [						| index backupArgName |						index := 1.						[ lowerCasedArgNames includes: ( backupArgName := anArgName, index printString ) ]							 whileTrue: [ index := index + 1 ].						anArgName := backupArgName ].				lowerCasedArgNames at: i put: anArgName ].		].	^lowerCasedArgNames</body><body package="Com- Ole Development">initializeArguments	" Private - initialize the argument descriptors. "	| argumentNames argumentTypes nArgs anArgumentDescriptor |	argumentNames := self argumentNames.	argumentTypes := self argumentTypes.	nArgs := argumentTypes size.	arguments := Array new: nArgs.	1 to: nArgs do: [ :i |		anArgumentDescriptor := COMArgumentDescription new			name: ( argumentNames at: i );			type: ( argumentTypes at: i );			yourself.		arguments at: i put: anArgumentDescriptor ].</body></methods><methods><class-id>External.COMExtendedEntryPointDescription</class-id> <category>testing</category><body package="Com- Ole Development">isHRESULTFunction	" Answer whether the receiver answers an HRESULT value. "	| aType |	aType := self resultType.	^aType name = #HRESULT		or: [ ( COMExternalInterface getFundamentalTypeOf: aType ) = CIntegerType hResultLong ]</body></methods><methods><class-id>External.COMExtendedEntryPointDescription class</class-id> <category>instance creation</category><body package="Com- Ole Development">fromEntryPoint: anEntryPointDesciption	" Answer a new instance of the receiver with the attributes of &lt;anEntryPointDescription&gt;. "	^self name: anEntryPointDesciption name 		type: anEntryPointDesciption signatureType 		vtableIndex: anEntryPointDesciption vtableIndex 		selector: anEntryPointDesciption selector</body></methods><methods><class-id>External.IDataObjectTraceAdaptor</class-id> <category>subclass-tracing</category><body package="Com- Ole Development">logDirection: dwDirection	| valueDescription |	valueDescription := ( 		dwDirection = DATADIR_GET ifTrue: [ 'DATADIR_GET' ]		ifFalse: [ dwDirection = DATADIR_SET ifTrue: [ 'DATADIR_SET' ]		ifFalse: [ '( unknown direction: ', dwDirection printString, ' )' ] ] ).	self logString: valueDescription tag: 'dwDirection'.</body></methods><methods><class-id>External.IDataObjectTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole Development">DAdvise: aFormatEtc _: advf _: anAdviseSink _: resultReference	" Invoke the IDataObject::DAdvise function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [self logFunctionEntry: traceContext].		[hresult := implementor				DAdvise: aFormatEtc				_: advf				_: anAdviseSink				_: resultReference]			on: Error			do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: [self logValue: resultReference value tag: 'Connection token'].			self logHRESULT: hresult].	^hresult</body><body package="Com- Ole Development">EnumDAdvise: resultReference	" Invoke the IDataObject::EnumDAdvise function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled ifTrue: [self logFunctionHeader: traceContext].	[hresult := implementor EnumDAdvise: resultReference] on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: 					[self logInterfaceResultValue: resultReference value tag: 'IEnumSTATDATA'].			self logHRESULT: hresult].	^hresult</body><body package="Com- Ole Development">EnumFormatEtc: dwDirection _: resultReference	" Invoke the IDataObject::EnumFormatEtc function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self logDirection: dwDirection].	[hresult := implementor EnumFormatEtc: dwDirection _: resultReference]		on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: 					[self logInterfaceResultValue: resultReference value tag: 'IEnumFORMATETC'].			self logHRESULT: hresult].	^hresult</body><body package="Com- Ole Development">GetDataHere: aFormatEtc _: aStgMedium	" Invoke the IDataObject::GetDataHere function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self logValue: aFormatEtc tag: 'pformatetc'].	[hresult := implementor GetDataHere: aFormatEtc _: aStgMedium] on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: [self logResultValue: aStgMedium tag: 'Set STGMEDIUM'].			self logHRESULT: hresult].	^hresult</body></methods><methods><class-id>External.IDataObjectTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Ole Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IDataObject.</body></methods><methods><class-id>External.COMArgumentProcessingSpecification</class-id> <category>accessing</category><body package="Com- Ole Development">callinArgumentTransformation	" Answer the expression for transforming an argument of this category from the form provided by an external caller. "	^callinArgumentTransformation</body><body package="Com- Ole Development">callinArgumentTransformation: aTransformationSpecification	" Specify the expression for transforming an argument of this category from the form provided by an external caller. "	" pattern is generally of the form 		'( self fooAtAddress: &lt;1s&gt; )'	where 		&lt;1&gt; - name of the input argument	"	self checkExpressionSpecification: aTransformationSpecification 		nArgs: 2.  " &lt;1&gt; - argName; &lt;2&gt; - argType "	callinArgumentTransformation := aTransformationSpecification.</body><body package="Com- Ole Development">callinResultReferenceExpression	" Answer the expression for constructing a result reference for an argument of this category when processing an external callin. "	^callinResultReferenceExpression</body><body package="Com- Ole Development">callinResultReferenceExpression: aConstructorSpecification	" Specify the expression for constructing a result reference for an argument of this category when processing an external callin. "	self checkExpressionSpecification: aConstructorSpecification 		nArgs: 2.  " &lt;1&gt; - argName; &lt;2&gt; - argType "	callinResultReferenceExpression := aConstructorSpecification.</body><body package="Com- Ole Development">callinResultValueExpression	" Answer the expression for returning an value of this category ing the form needed by an external caller. "	^callinResultValueExpression</body><body package="Com- Ole Development">callinResultValueExpression: aPattern	" Specify the expression for returning an value of this category in the form needed by an external caller. "	" pattern is generally of the form 		'self xxxResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value'	where 		&lt;1&gt; - name of the input argument		&lt;2&gt; - name of the result reference temp	"	self checkExpressionSpecification: aPattern 		nArgs: 2.  " &lt;1&gt; - argName; &lt;2&gt; - resultReferenceName "	callinResultValueExpression := aPattern.</body><body package="Com- Ole Development">calloutArgumentReleaseExpression	" Answer the expression for releasing an argument of this category from the form needed for external callout. "	^calloutArgumentReleaseExpression</body><body package="Com- Ole Development">calloutArgumentReleaseExpression: aPattern	" Specify the expression for releasing an argument of this category from the form needed for external callout. "	" pattern is generally of the form 		'&lt;1s&gt; release'	where 		&lt;1&gt; - name of the temp allocated for the transformed argument	"	self checkExpressionSpecification: aPattern 		nArgs: 1.  " &lt;1&gt; - argBufferName "	calloutArgumentReleaseExpression := aPattern.</body><body package="Com- Ole Development">calloutArgumentTransformation	" Answer the expression for transforming an argument of this category to the form needed for external callout. "	^calloutArgumentTransformation</body><body package="Com- Ole Development">calloutArgumentTransformation: aTransformationSpecification	" Specify the expression for transforming an argument of this category to the form needed for external callout. "	" pattern is generally of the form 		'&lt;1s&gt; asFooParameter'	where 		&lt;1&gt; - name of the input argument	"	self checkExpressionSpecification: aTransformationSpecification 		nArgs: 2.  " &lt;1&gt; - argName; &lt;2&gt; - argType "	calloutArgumentTransformation := aTransformationSpecification.</body><body package="Com- Ole Development">calloutResultBufferConstructor	" Answer the expression for allocating a result value buffer for an argument of this category in the form needed for external callout. "	^calloutResultBufferConstructor</body><body package="Com- Ole Development">calloutResultBufferConstructor: aConstructorSpecification	" Specify the expression for allocating a return value buffer for an argument of this category in the form needed for external callout. "	" pattern is generally of the form 		'Foo resultValueBuffer'	and the buffer is manipulated using #asPointerParameter and #contents"	self checkExpressionSpecification: aConstructorSpecification 		nArgs: 2.  " &lt;1&gt; - argName; &lt;2&gt; - argType "	calloutResultBufferConstructor := aConstructorSpecification.</body><body package="Com- Ole Development">calloutResultBufferExtractor	" Answer the expression for extracting the contents of a result value buffer for an argument of this category in the form needed for obtaining the OUT value after an external callout. "	^calloutResultBufferExtractor</body><body package="Com- Ole Development">calloutResultBufferExtractor: aConstructorSpecification	" Specify the expression for extracting the contents of a result value buffer for an argument of this category in the form needed for obtaining the OUT value after an external callout. "	" pattern is generally of the form 		'&lt;1s&gt; contents'	where 		&lt;1&gt; - name of the result buffer	"	self checkExpressionSpecification: aConstructorSpecification 		nArgs: 1.  " &lt;1&gt; - resultBufferName "	calloutResultBufferExtractor := aConstructorSpecification.</body><body package="Com- Ole Development">category	" Answer the category of argument. "	^category</body><body package="Com- Ole Development">category: aCategory	" Specify the category of argument. "	category := aCategory.</body><body package="Com- Ole Development">resultReferenceExpression	" Answer the expression for constructing a result reference for an argument of this category. "	^resultReferenceExpression</body><body package="Com- Ole Development">resultReferenceExpression: aConstructorSpecification	" Answer the expression for constructing a result reference for an argument of this category. "	self checkExpressionSpecification: aConstructorSpecification 		nArgs: 2.  " &lt;1&gt; - argName; &lt;2&gt; - argType "	resultReferenceExpression := aConstructorSpecification.</body></methods><methods><class-id>External.COMArgumentProcessingSpecification</class-id> <category>expression generation</category><body package="Com- Ole Development">constructCallinArgumentTransformationExpressionFor: argName type: argType	" Answer the expression for transforming an argument of this category from the form provided by an external caller. "	| transformer |	transformer := self callinArgumentTransformation.	transformer isNil		ifTrue: [ ^(#x1sCHECKTHIS &lt;&lt; #com &gt;&gt; '&lt;1s&gt; "### CHECK THIS ###''') expandMacrosWith: argName ].	transformer isString		ifTrue: [ ^transformer expandMacrosWith: argName with: argType ].	^transformer value: argName value: argType</body><body package="Com- Ole Development">constructCallinResultReferenceExpressionFor: argName type: argType	" Answer the expression for allocating a result reference for an argument of this category. "	| transformer |	transformer := self callinResultReferenceExpression.	transformer isNil		ifTrue: [ ^'nil asValueReference' ].	transformer isString		ifTrue: [ ^transformer expandMacrosWith: argName with: argType ].	^transformer value: argName value: argType</body><body package="Com- Ole Development">constructCallinResultValueExpressionFor: argName resultReferenceName: resultReferenceName	" Answer the expression for transforming an argument of this category from the form provided by an external caller. "	| transformer |	transformer := self callinResultValueExpression.	transformer isNil		ifTrue: [ 			^'"### self xxxResultAtAddress: &lt;1s&gt; put: &lt;2s&gt; value ###"'				expandMacrosWith: argName with: resultReferenceName ].	transformer isString		ifTrue: [ ^transformer expandMacrosWith: argName with: resultReferenceName ].	^transformer value: argName value: resultReferenceName</body><body package="Com- Ole Development">constructCalloutArgumentReleaseExpressionFor: argBufferName	" Answer the expression for releasing an argument of this category from the form needed for external callout. "	| transformer |	transformer := self calloutArgumentReleaseExpression.	transformer isNil		ifTrue: [ ^nil ].	transformer isString		ifTrue: [ ^transformer expandMacrosWith: argBufferName ].	^transformer value: argBufferName</body><body package="Com- Ole Development">constructCalloutArgumentTransformationExpressionFor: argName type: argType	" Answer the expression for transforming an argument of this category to the form required for external callout. "	| transformer |	transformer := self calloutArgumentTransformation.	transformer isNil		ifTrue: [ ^argName ].	transformer isString		ifTrue: [ ^transformer expandMacrosWith: argName with: argType ].	^transformer value: argName value: argType</body><body package="Com- Ole Development">constructCalloutResultBufferContentsExpressionFor: resultBufferName	" Answer the expression for extracting the contents of a result buffer of this category from the form obtained after external callout. "	| transformer |	transformer := self calloutResultBufferExtractor.	transformer isNil		ifTrue: [ ^'&lt;1s&gt; contents' expandMacrosWith: resultBufferName ].	transformer isString		ifTrue: [ ^transformer expandMacrosWith: resultBufferName ].	^transformer value: resultBufferName</body><body package="Com- Ole Development">constructCalloutResultBufferExpressionFor: argName type: argType	" Answer the expression for allocating a return value buffer for an argument of this category in the form needed for external callout. "	| transformer |	transformer := self calloutResultBufferConstructor.	transformer isNil		ifTrue: [ ^(#AllocateOutBuffer &lt;&lt; #com &gt;&gt; '###Allocate OUT value buffer here###') asString ].	transformer isString		ifTrue: [ ^transformer expandMacrosWith: argName with: argType ].	^transformer value: argName value: argType</body><body package="Com- Ole Development">constructResultReferenceExpressionFor: argName type: argType	" Answer the expression for allocating a result reference for an argument of this category. "	| transformer |	transformer := self resultReferenceExpression.	transformer isNil		ifTrue: [ ^'nil asValueReference' ].	transformer isString		ifTrue: [ ^transformer expandMacrosWith: argName with: argType ].	^transformer value: argName value: argType</body></methods><methods><class-id>External.COMArgumentProcessingSpecification</class-id> <category>printing</category><body package="Com- Ole Development">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	category notNil		ifTrue: [ aStream nextPutAll: ' ( ', category printString, ' )' ].</body></methods><methods><class-id>External.COMArgumentProcessingSpecification</class-id> <category>testing</category><body package="Com- Ole Development">requiresTempForCalloutArgument	" Answer whether the callout argument transformation requires a temp variable which must be released. "	^self calloutArgumentReleaseExpression notNil</body></methods><methods><class-id>External.COMArgumentProcessingSpecification</class-id> <category>private-validation</category><body package="Com- Ole Development">checkExpressionSpecification: anExpressionSpec nArgs: nArgs 	" Private - verify that &lt;anExpressionSpec&gt; is acceptable. "	anExpressionSpec isString ifTrue: [^true].	anExpressionSpec class == BlockClosure 		ifTrue: 			[anExpressionSpec numArgs = nArgs 				ifFalse: [self error: #ErrInvalidBlock &lt;&lt; #com &gt;&gt; 'invalid block'].			^true].	self error: #ErrUnknownSpecType &lt;&lt; #com &gt;&gt; 'unknown specification type'</body></methods><methods><class-id>External.COMExportedObjectsBrowser</class-id> <category>private-utilities</category><body package="Com- Ole Development">getExportedInterfaceList	" Private - answer the unsorted list of interface implementations to display in the exported interfaces list. "	^COMSessionManager allExportedInterfaces</body></methods><methods><class-id>External.COMExportedObjectsBrowser</class-id> <category>private-operation</category><body package="Com- Ole Development">updateResourceLists	" Private - update the lists of resources "	self updateExportedResourceLists.	"??self validateAllocatedInterfaces.??"	self updateCleanupMenu.</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>private-stack accessing</category><body package="Com- Ole Development">getCallerMethodContextFrom: initialContext	" Private - answer the method invocation context in the caller which represents the initial call to the receiver for the interface function &lt;functionMethodContext&gt;.  This should either be an interface function message or #doesNotUnderstand: "	"Assert isTrue: [ initialContext receiver == self ]."	| myTraceAdaptor functionMethodContext |	myTraceAdaptor := self traceAdaptor.	functionMethodContext := myTraceAdaptor				getPreviousMethodContextFrom: initialContext.	^functionMethodContext</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-tracing</category><body package="Com- Ole Development">traceExternalFunctionEntry	" Report entry from an external caller to the interface function . "	| functionCallinContext functionSelector |	self isExternalCallinTracingEnabled		ifFalse: [ ^self ].	functionCallinContext := self getCallerMethodContextFrom: thisContext.	functionSelector := self functionSelectorFromContext: functionCallinContext.	"Assert isTrue: [ self isInterfaceFunctionSelector: functionSelector ]."	self traceAdaptor logExternalFunctionHeaderFor: functionSelector.</body><body package="Com- Ole Development">traceExternalFunctionInvalidArgExit	" Private - report an invalid argument value to the COM trace log if &lt;aValue&gt; is not valid.  The caller is responsible for ensuring that tracing is enabled. "	self traceAdaptor logHRESULT: E_INVALIDARG.</body><body package="Com- Ole Development">traceInvalidExternalArg: aValue name: argName	self traceAdaptor logInvalidExternalArg: aValue name: argName</body></methods><methods><class-id>External.CTypedefType</class-id> <category>testing</category><body package="Com- Ole Development">isTypeDefinition	^ true</body></methods><methods><class-id>External.COMInterfaceVTableSignatures class</class-id> <category>binary storage</category><body package="Com- Ole Development">extensionMethodsWereAdded: sels	"Ugh.  This is truly horrible.  Because of the split between the	 COMInterfaceVTableSignatures hierarchy and its clients, the various	 subclasses of COMInterfaceImplementation it is necessary to get	 those clients to rebuild their vtables every time the receiver	 defines different types.  Otherwise the vtables won't share	 exactly the right types and disaster will follow."	super extensionMethodsWereAdded: sels.	COMInterfaceImplementation vtableSignaturesPool: self externals.</body></methods><methods><class-id>External.COMInterfaceVTableSignatures class</class-id> <category>accessing</category><body package="Com- Ole Development">vtableSignatureNameFor: aName	^ '__',aName,'Vtbl'</body></methods><methods><class-id>External.CScalarType</class-id> <category>testing</category><body package="Com- Ole Development">isScalarType	^ true</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>validation</category><body package="Com- Ole Development">validateResourceTracking	" Verify that all COM resources being tracked are in the expected places and in expected states. "	" COMSessionManager validateResourceTracking "	| misplacedResources allocatedInterfaces exportedInterfaces |	misplacedResources := ( SystemExternalResourcesRegistry currentRegistry weakObjects		select: [ :aResource | 			aResource isCOMInterface			or: [ aResource isCOMExternalAddress ] ] )		asArray.	misplacedResources notEmpty		ifTrue: [ 			misplacedResources inspect.			COMDevelopmentWarning raiseSignal: #WarnResourcesInExtReg &lt;&lt; #com &gt;&gt; 'COM resources found in system external resources registry.  This is bad!'. ].	allocatedInterfaces := self allAllocatedInterfaces.	exportedInterfaces := self allExportedInterfaces.	( allocatedInterfaces elementsEqual: exportedInterfaces )		ifFalse: [			COMDevelopmentWarning raiseSignal: #WarnIntTrackingMixed &lt;&lt; #com &gt;&gt; 'Allocated/exported interface tracking mismatch found.'.			].</body></methods><methods><class-id>External.IUnknown class</class-id> <category>private-tracing</category><body package="Com- Ole Development">traceAdaptorClass	" Answer the trace adaptor class which services instances of the receiver. "	^COMSessionManager traceManager getAdaptorClassFor: self</body></methods><methods><class-id>External.CType</class-id> <category>testing</category><body package="Com- Ole Development">isScalarType	^ false</body><body package="Com- Ole Development">isTypeDefinition	^ false</body></methods><methods><class-id>External.COMStructure class</class-id> <category>type description</category><body package="Com- Ole Development">describeAccessingProtocolFor: aStructureTypeName	" Display a report describing the accessing protocol for the structure named &lt;aStructureTypeName&gt; when it is wrapped by an instance of the receiver or one of its subclasses. "	self describeAccessingProtocolForType: ( self typeNamed: aStructureTypeName ) 		using: ( self classForStructureNamed: aStructureTypeName ifNone: [ COMStructure ] ).</body><body package="Com- Ole Development">describeAccessingProtocolForType: aStructureType	" Display a report describing the accessing protocol for the structure &lt;aStructureType&gt; when it is wrapped by an instance of the receiver or one of its subclasses. "	self describeAccessingProtocolForType: aStructureType 		using: ( self classForStructureNamed: aStructureType name ifNone: [ COMStructure ] ).</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>private</category><body package="Com- Ole Development">comPoolMapCodeString	"This is the workspace code mentioned in the Release notes for COM Connect 5i.0.  It helps you fix up your pre5i classes to use the new imports instead of the no longer existing COM dictionaries -- sorry for being tricky here."^(ByteArray fromPackedString: '_GA/[61MXW@ \7U3\FU#]D5!\G0MCWA/[61MXW@ N#4 QF%#]F%/[&amp;E2^RA.YW\.CP$"P4=MKRAA]WQ/[VE4ZV=.HEA/[613HEA!\&amp;M%[BHM\F=/[D5!\BA!YFP:HBMCS45A]WQ/[VE4ZV=.P6=.\7Q![''Q3HB4&gt;HB]E^GQ%\&amp;9![B9CS45A]WQ/[VE4ZV=.TF=/[GL.P4=MPWU4[65!]F%/[$M/[''M4XV94\28*I28M\F=/[D5!\BA!YFP:HBMWZV83L$9LT4M/[''M4XV94\2@-O"@''QW!4YWI.XV0.P4=MPWU4[65!]F%/[%A/[613K%])[#L2S$1SP6=.\7Q![''Q3K"(''K 4ICP$"P6=-HB4 PWU4[65!]F%/["AE^FE-\F1%\2AP[6=,\2HM\F=/[D5!\BA!YFP:HBMW[7I$NSUC[693]FE.]GL KS8 I4U8]FU2[&amp;E,K$M/[TE5]F=-XWQ)[69E^FE-\F1%TF=/[GL.U6=2YC$5P6=.\7Q![''Q3K"(''K 50[6=,SVE0HFE$YC( H4U8X6U,P6=.\7Q![''Q3HB4&gt;HB]E^GQ%\&amp;9![B9C[65A]WQ/[VE4ZV=.QW!![WA,YUA/[613K$U8X6U,P6=.\7Q![''Q3K"(''K 4ICP$"P6=-KRAO[FT TF=/[GL TFE2X6U,H 50[6=,SVE0HFE$YC( H4MOSTM/[''M4XV94\2@-O"@''QW!4YWI.XV0.Q5UIQB9CS45C[693]FE.]GL.J"\.CWA/[61MXW@ XVQ$N"@#P4=MT7Q!]GU3P6=$YTM/[''M4XV94\2@-O"@''QW!4YWI.XV0.Q5UIQB9CS45S]FE4]WMC[6Q%P6=.\7Q![''Q3K"(''K 4ICP$"P6=-KRAWZV83L"AP[6=,\2APXWI#YV0"CWA/[61MXW@ XVQ$N"@#P4M/[''M4XV94\2@-O"]E^GQ%\&amp;9![B9C[65WZV83L%A/[613K$MC[693]FE.]GL.J"\.CWA/[61MXW@ XVQ$N"@#U6%.L3IC[693]FE.]GL KS8 I4U8]FU2[&amp;E,K$M/[U])[#L2TF=/[GL.U6%.L3IC[693]FE.]GL.J"\.CWA/[61MXW@ XVQ$N"@#U6%.L3IC[65-[69DZVE,[6]C[693]FE.]GL KS8 I4U8]FU2[&amp;E,K$M/[U])[#L2TF=/[GL.U6%.L3IC[65-[69DZVE,[6]C[693]FE.]GL.J"\.CP53]WM0YVM4SVE0HC(=HDQ)X7Q)[69!\''$ [&amp;U7K 5S^WM4YV5U]F%,\2A![F1C[FE3\6U3QF&lt;:HE,:X613HG0MBW1)[WA/\''Q3HFI!YD=.YWM&lt;CP%)[WA/\''Q3HC(=HFM,\2A!\49![VUS\FE#YRA)[WA/\''QDYVY)[&amp;%4ZV=.\28MBVI!YD=.YWL N#4 ZV50[7I4\2A3YV1%X7P:HE,:ZRA&lt;HF$ ZWMDYVY)[&amp;U$HF9/]E4.CP%"XVQO[&amp;U3HF%3QV50]G$ ZVYFXV13YS( V7M5\7A%X7QMXW@ XWP:HFM,\2A0]WP:HFI!YD=.YWM]WR8MCP53]WM0YVM4SVE0HF-%^WMA[&amp;QVXV15YWMD[3( V3)#[GL N&amp;I!YDQ%Y''L _B@MBW1''[6=$QFU&amp;\2A3]GI%XV4 \6=-YUA!\&amp;M%[GM&lt;CP%3]GI%XV4 N#4 JEM4\&amp;%.Y2A.YW\:HCP0JRA7\&amp;%4YUM4\&amp;U![R8MBV]/[6QDYVY3HC(=HB!#[GL XWMNXV5%T7A!X6T ZV50[7I4QFU&amp;ZV9)]F%/[''L)HGM%[FU#]C( V3))HG0 ZRA)\4Q%Y&amp;%.YVQ]K 4IY6=/YDQ%Y''L YF&lt;:HE,:YVE#ZBA&lt;HGM4\&amp;U![RA.YW!4TGU4PV1,N"A%XVM(HFQ%Y&amp;%.ZWQ)[69S]GI)[&amp;\;X7I]K 4IX&amp;E$QFU&amp;\2A$[3( V3)%XVM(HG0 CP$I_FY)^FU$QFU&amp;_@4IBVY)^FU$QFU&amp;HC(=HGA/[61MXW@ XWP:HFU!X6  [&amp;E-YRA)Y$E"\6U.]C( [&amp;%,K 4IBVY)^FU$QFU&amp;HF9/]D9)[B@MBP$IZVYT\''U%N"A[\7Q2YVE-HF9%^GQP]WQA[F0:HFY)^FU$QFU&amp;HC-#\%4MBP$IZVYFXV13YS( V5Q2XV93X7I)\GP CP$IBP$IBWM([7\:HB ''OCE3O"A(XWL X&amp;='']WL ZV50[7I4HB4&gt;OCI3O"A)Y69/\&amp;%.Y2\ CP$IBP$IBP$IBVU8\FE.YD5!X7I/\5])]F :HFM,\2A0\&amp;%.]EM4\&amp;%.Y2@MBP$IBP$IBP$I]6%4ZC( YVE#ZBA0\&amp;%.]EM4\&amp;%.Y2$ N04IBP$IBP%#\"9]WR8MBVM,\2A!\49![VUS\FE#YRA)[WA/\''Q3N"A3]GI%XV4 X6=.]FU.]GL.H@4IX613HGI%X&amp;%.YDE,[D5%]F!/YGL.CP$(\6=-YUA!\&amp;M%[GL N#4 TFE2X6U,HGA!\&amp;M%[GL \6U,YVM4N"A[N&amp;EPXWI#YV0 _B@(XUA!\&amp;M%[BA$YVY)[&amp;U$P61!\7M%\2A)[&amp;M,]VQ%\3( X613JU4)HF9/]D9)[@4IBV%&amp;UGI5YS( V7M/[VUPXWI#YV13HFQ/N"A[N&amp;U!X6  _BA%XVM(HF5!\&amp;-A\4Q)\''Q9WU5]K 4MQF%![F=''HG]!\&amp;8:HB]SXWY%HFE.^RA/Y"A9[7U2HGA!\&amp;M%[GL ]F!!]BA7YWI%WF5!\&amp;-%YBA!\2ADZWI4^R0 ZR9%K"A!\&amp;T ]6%4ZBA!HB( ZV8 ]F!%WEA!\&amp;M%[DI2[7]3YWH.I2A7ZWQ(P5I3') asString</body></methods><methods><class-id>External.COMInterface class</class-id> <category>VTable utilities</category><body package="Com- Ole Development">describeInterfaceFunctions	" Display a description of the functions in the interface represented by the receiver. "	| interfaceClasses inheritedChunks aPointerClass vtableDescription 	  aStream chunkIndex nextChunk 	  anEntryPoint nArgs argumentNames argumentTypes |	" construct list of inherited interface specifications "    interfaceClasses := self allSuperclasses reverse,        ( Array with: self ).	interfaceClasses := interfaceClasses 		copyFrom: (interfaceClasses indexOf: IUnknown )		to: interfaceClasses size.	inheritedChunks := OrderedCollection new.	interfaceClasses do: [ :aClass |		( aPointerClass := aClass interfacePointerClass ) notNil			ifTrue: [				inheritedChunks add: ( Array with: aClass name					with: aPointerClass vtableDescription size ) ].		].	vtableDescription := self interfacePointerClass vtableDescription.	aStream := ReadWriteStream on: String new.	aStream		nextPutAll: ((#NamedInterfaceFuncs &lt;&lt; #com &gt;&gt; '&lt;1s&gt; Interface Functions') expandMacrosWith: self name); cr;		tab; nextPutAll: 'IID: ', self iid printString; cr.	chunkIndex := 0.	nextChunk := 0.	1 to: vtableDescription size do: [ :i |		anEntryPoint := vtableDescription at: i.		argumentNames := anEntryPoint argumentNames.		argumentTypes := anEntryPoint argumentTypes.		nArgs := argumentTypes size.		i &gt; nextChunk			ifTrue: [				chunkIndex := chunkIndex + 1.				nextChunk := ( inheritedChunks at: chunkIndex ) at: 2.				aStream cr; nextPutAll: 					'== ', ( (inheritedChunks at: chunkIndex ) at: 1 ), ' Functions =='; cr; cr.				].		aStream 			nextPutAll: ( i - 1 ) printString, '. ', anEntryPoint name;				"nextPutAll: ' ( VTable index ', anEntryPoint vtableIndex printString, ' )';" 				nextPutAll: ' ( ', nArgs printString;				nextPutAll: ( nArgs = 1 ifTrue: [#spaceArgument &lt;&lt; #com &gt;&gt; ' argument' ] ifFalse: [#spaceArguments &lt;&lt; #com &gt;&gt;  ' arguments' ] ) asString; 				nextPutAll: ' )'; cr;			tab; tab; nextPutAll: '#', anEntryPoint selector ; cr.		1 to: nArgs do: [ :argIndex |			aStream tab; tab; tab; nextPutAll: ( argumentNames at: argIndex ), ': ';				nextPutAll: ( argumentTypes at: argIndex ) printString; cr ].		aStream tab; tab; nextPutAll: (#ResultTypeColonSpace &lt;&lt; #com &gt;&gt; 'Result type: ') asString, anEntryPoint resultType printString; cr.			].	"aStream nextPutAll: '( ', vtableDescription size printString, ' functions)'; cr."	TextWindow openOn: aStream contents		label: ((#NamedInterfaceFuncs &lt;&lt; #com &gt;&gt; '&lt;1s&gt; Interface Functions') expandMacrosWith: self name).</body><body package="Com- Ole Development">functionNames	" Answer the names of the functions in the interface represented by the receiver, in VTable order. "	^self interfacePointerClass vtableDescription 		collect: [ :ept | ept name ]</body></methods><methods><class-id>External.COMInterface</class-id> <category>private-tracing</category><body package="Com- Ole Development">installReporting	" Private - install a trace adaptor on the receiver if appropriate. "	| aTraceManager |	( aTraceManager := COMSessionManager traceManager ) notNil		ifTrue: [ aTraceManager installTracingOn: self ].</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>subclass-tracing</category><body package="Com- Ole Development">traceOptions	" Private - answer the trace options currently registered for the receiver. "	^COMSessionManager traceManager getTraceOptionsForIID: self iid</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-com</category><body package="Com- Ole Development">modelForTraceInstallation	"Return a pluggable adaptor that knows how to install and uninstall the trace support."	| valueModel |	valueModel := PluggableAdaptor on: COMTraceManager.	valueModel 		getBlock: [:m | COMSessionManager traceManager ~= nil]		putBlock: 			[:m :v | 			v 				ifTrue: [m installTraceSupport]				ifFalse: 					[					[m checkUninstallAllowed.					m uninstallTraceSupport] on: Error							do: [:ex | Dialog warn: ex messageText]]]		updateBlock: [:m :a :p | true].	^valueModel</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard class</class-id> <category>interface specs</category><body package="Com- Ole Development">basicInformationSpec	"Tools.UIPainter new openOnClass: self andSelector: #basicInformationSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 422 315 1181 764 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 60 0 ) 					#name: #labelInterfaceSuperclass 					#label: 'Interface Superclass' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 100 0 ) 					#name: #LabelPackage 					#label: 'Target Package' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 20 0 ) 					#name: #Label1 					#label: 'Interface Name' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 17 0 -10 1 36 0 ) 					#name: #InputField1 					#model: #interfaceName 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #interfaceNameChanged 						#requestValueChangeSelector: 						#containsValidInterfaceName: ) 					#tabable: false 					#helpText: 'This value is automatically determined from the vtable declaration' 					#isReadOnly: true ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 57 0 -10 1 76 0 ) 					#name: #interfaceSuperclass 					#model: #interfaceSuperclass 					#menu: #definedInterfaceClassesMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 97 0 -50 1 116 0 ) 					#name: #targetPackage 					#model: #targetPackage 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#containsValidPackageName: ) 					#tabable: true 					#isReadOnly: false 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 1 93 0 -10 1 116 0 ) 					#name: #selectTargetPackage 					#model: #selectTargetPackage 					#label: '...' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0 140 0 ) 					#name: #Label2 					#label: 'Target Namespace' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 130 0 137 0 -50 1 156 0 ) 					#name: #targetNamespace 					#model: #targetNamespace 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#containsValidNamespaceName: ) 					#tabable: true 					#isReadOnly: false 					#type: #string ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -40 1 132 0 -10 1 155 0 ) 					#name: #ActionButton2 					#model: #selectTargetNamespace 					#label: '...' 					#defaultable: true ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 130 0 173 0 ) 					#name: #generateInterfaceImplementationClass 					#model: #generateInterfaceImplementationClass 					#label: 'Generate InterfaceImplementation class' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Graphics.LayoutOrigin} 130 0 203 0 ) 					#name: #generateInterfacePointerClass 					#model: #generateInterfacePointerClass 					#label: 'Generate InterfacePointer class' ) ) ) )</body><body package="Com- Ole Development">declarationsSpec	"Tools.UIPainter new openOnClass: self andSelector: #declarationsSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 711 288 1470 737 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -40 1 ) 					#name: #myDeclarations 					#model: #myDeclarations 					#menu: #cDeclarationsMenu 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedTypeRow name' 							#label: 'Type Name' 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedTypeRow typeString' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: 								#typeDefinitionChanged: 								#requestValueChangeSelector: 								#containsValidTypeDefinitionString: ) 							#label: 'Source Type' 							#labelIsImage: false 							#width: 300 							#rendererType: #Text 							#editorType: #ComboBox 							#choices: #typeChoices 							#noScroll: false 							#formatString: '' ) ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 10 0 -30 1 23 23 ) 					#name: #ActionButtonRescan 					#model: #rescanTypeDefinitions 					#helpText: 'Rescan Types' 					#label: 'â»' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 40 0 -30 1 23 23 ) 					#name: #ActionButtonRemove 					#flags: 40 					#model: #removeSelectedDefinition 					#helpText: 'Remove selected type' 					#label: 'Ã' 					#defaultable: true ) ) ) )</body><body package="Com- Ole Development">iidDefinitionSpec	"Tools.UIPainter new openOnClass: self andSelector: #iidDefinitionSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 421 202 1180 651 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -10 1 ) 					#name: #interfaceDefinitions 					#model: #interfaceDefinitions 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedInterfaceRow name' 							#label: 'Interface Name' 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedInterfaceRow iidString' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#requestValueChangeSelector: 								#containsValidIIDDefinitionString: ) 							#label: 'Interface ID' 							#labelIsImage: false 							#width: 300 							#rendererType: #Text 							#editorType: #ComboBox 							#choices: #knownIIDConstants 							#noScroll: false 							#formatString: '' ) ) ) ) ) )</body><body package="Com- Ole Development">vtableSpec	"Tools.UIPainter new openOnClass: self andSelector: #vtableSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 421 226 1180 675 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -10 1 ) 					#name: #vtableSignatureText 					#model: #vtableSignatureText 					#tabRequiresControl: true ) ) ) )</body><body package="Com- Ole Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Interface Class Generator' 			#bounds: #(#{Graphics.Rectangle} 421 228 1180 672 ) 			#flags: 4 			#menu: #mainMenu ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 -10 1 -50 1 ) 					#name: #tabs 					#model: #tabs 					#labels: #() ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -120 1 -40 1 -10 1 -10 1 ) 					#name: #generateInterfaceClasses 					#model: #generateInterfaceClasses 					#label: 'Generate Classes' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 -40 1 -130 1 -10 1 ) 					#name: #InputField1 					#model: #statusText 					#menu: #statusBarMenu 					#isReadOnly: true ) ) ) )</body></methods><methods><class-id>Tools.COMInterfaceClassGenerationWizard class</class-id> <category>resources</category><body package="Com- Ole Development">mainMenu	"Tools.MenuEditor new openOnClass: self andSelector: #mainMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #File 					#defaultString: 'File' 					#catalogID: #menus ) 				#nameKey: #MenuFile 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 'Reset C Definitions' 							#value: #rescanTypeDefinitions ) ) #(1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 'Help' 				#nameKey: #HelpSubmenu 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Help 								#defaultString: 'Help' 								#catalogID: #menus ) 							#value: #help ) ) #(1 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.COMResourceViewer class</class-id> <category>resources</category><body package="Com- Ole Development">menuSpecExportedInterfaces	"Tools.MenuEditor new openOnClass: self andSelector: #menuSpecExportedInterfaces"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#value: #inspectExportedInterface ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Release 					#defaultString: 'Release' 					#catalogID: #com ) 				#value: #releaseExportedInterface ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Com- Ole Development">menuSpecExportedObjects	"Tools.MenuEditor new openOnClass: self andSelector: #menuSpecExportedObjects"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#value: #inspectExportedObject ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Release 					#defaultString: 'Release' 					#catalogID: #com ) 				#value: #releaseExportedObject ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.COMTraceViewer class</class-id> <category>interface specs</category><body package="Com- Ole Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #COMTraceViewer 				#defaultString: 'COM Trace Viewer' 				#catalogID: #com ) 			#min: #(#{Core.Point} 394 121 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1314 1080 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 72 0 -8 1 -8 1 ) 					#name: #traceLogPane 					#flags: 9 					#component: #traceLogComponent ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 8 8 ) 					#model: #traceEnabledHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #enabletracing 						#defaultString: 'enable tracing' 						#catalogID: #com ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 132 8 ) 					#model: #traceCalloutHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #tracecallout 						#defaultString: 'trace callout' 						#catalogID: #com ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 132 30 ) 					#model: #traceCallinHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #tracecallin 						#defaultString: 'trace callin' 						#catalogID: #com ) ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 132 50 ) 					#model: #traceInternalCallsHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #traceinternalcalls 						#defaultString: 'trace internal calls' 						#catalogID: #com ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 270 32 390 56 ) 					#name: #configureInterfaceExternalCallinButton 					#model: #configureInterfaceExternalCallin 					#label: 					#(#{Kernel.UserMessage} 						#key: #CallinOpts 						#defaultString: 'Callin options...' 						#catalogID: #com ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 270 4 390 30 ) 					#name: #configureInterfaceExternalCalloutButton 					#model: #configureInterfaceExternalCallout 					#label: 					#(#{Kernel.UserMessage} 						#key: #CalloutOpts 						#defaultString: 'Callout options...' 						#catalogID: #com ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.COMResourceBrowser class</class-id> <category>interface specs</category><body package="Com- Ole Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ResourceBrowser 				#defaultString: 'COM Resource Browser' 				#catalogID: #com ) 			#bounds: #(#{Graphics.Rectangle} 96 74 595 554 ) 			#flags: 4 			#menu: #menuSpec ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 145 0 -5 0.5 0 0.6 ) 					#name: #ownedInterfacesListView 					#model: #ownedInterfacesListModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectOwnedInterface ) 					#menu: #menuSpecOwnedInterfaces 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 40 0 -20 1 79 0 ) 					#name: #specialResourcesListView 					#model: #specialResourcesListModel 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 145 0 -20 1 0 0.6 ) 					#name: #ownedMemoryListView 					#model: #ownedMemoryListModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectOwnedMemory ) 					#menu: #menuSpecOwnedMemory 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 20 0 0 0.7 -10 0.5 -20 1 ) 					#name: #exportedInterfacesListView 					#model: #exportedInterfacesListModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectExportedInterface ) 					#menu: #menuSpecExportedInterfaces 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 0 0.7 -20 1 -20 1 ) 					#name: #exportedObjectsListView 					#model: #exportedObjectsListModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectExportedObject ) 					#menu: #menuSpecExportedObjects 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0.5 80 0 ) 					#name: #specialResourceDescription ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 20 20 125 50 ) 					#model: #updateResourceLists 					#label: 					#(#{Kernel.UserMessage} 						#key: #Updatelists 						#defaultString: 'Update lists' 						#catalogID: #com ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 20 110 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #OwnedInterfacesColon 						#defaultString: 'Owned interfaces:' 						#catalogID: #com ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0.5 110 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #OwnedMemoryColon 						#defaultString: 'Owned memory:' 						#catalogID: #com ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 -30 0.7 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ExportedInterfacesColon 						#defaultString: 'Exported interfaces:' 						#catalogID: #com ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0.5 -30 0.7 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ExportedObjectsColon 						#defaultString: 'Exported objects:' 						#catalogID: #com ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0.5 10 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #SpecialResourcesColon 						#defaultString: 'Special resources:' 						#catalogID: #com ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 20 65 125 95 ) 					#model: #cleanUpResourceLists 					#label: 					#(#{Kernel.UserMessage} 						#key: #CleanUpLists 						#defaultString: 'Clean up lists' 						#catalogID: #com ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.COMResourceBrowser class</class-id> <category>resources</category><body package="Com- Ole Development">menuSpec	"Tools.MenuEditor new openOnClass: self andSelector: #menuSpec"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cleanup 					#defaultString: 'Cleanup' 					#catalogID: #com ) 				#nameKey: #cleanup 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RevokeClassFactories 								#defaultString: 'Revoke all class factories' 								#catalogID: #com ) 							#value: #cleanupRevokeClassFactories ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReleaseAllObjects 								#defaultString: 'Release all objects' 								#catalogID: #com ) 							#value: #cleanupReleaseAllObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReleaseAllResouces 								#defaultString: 'Release all resources' 								#catalogID: #com ) 							#value: #cleanupReleaseAllResources ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Clipboard 					#defaultString: 'Clipboard' 					#catalogID: #com ) 				#nameKey: #clipboard 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CopyToClipboard 								#defaultString: 'Copy to clipboard' 								#catalogID: #com ) 							#value: #clipboardCopyToClipboard ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveFromClipboard 								#defaultString: 'Remove from clipboard' 								#catalogID: #com ) 							#value: #clipboardRemoveFromClipboard ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClearClipboard 								#defaultString: 'Clear clipboard' 								#catalogID: #com ) 							#value: #clipboardClearClipboard ) ) #(2 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Registries 					#defaultString: 'Registries' 					#catalogID: #com ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OwnedInterfaces 								#defaultString: 'Owned interfaces' 								#catalogID: #com ) 							#value: #registryInspectOwnedInterfaces ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #OwnedMemory 								#defaultString: 'Owned memory' 								#catalogID: #com ) 							#value: #registryInspectOwnedMemory ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #AllocatedInterfaces 								#defaultString: 'Allocated interfaces' 								#catalogID: #com ) 							#value: #registryInspectAllocatedInterfaces ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #HostResources 								#defaultString: 'Host resources' 								#catalogID: #com ) 							#value: #registryInspectHostResources ) ) #(2 1 1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Com- Ole Development">menuSpecOwnedInterfaces	"Tools.MenuEditor new openOnClass: self andSelector: #menuSpecOwnedInterfaces"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#value: #inspectOwnedInterface ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Release 					#defaultString: 'Release' 					#catalogID: #com ) 				#value: #releaseOwnedInterface ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="Com- Ole Development">menuSpecOwnedMemory	"Tools.MenuEditor new openOnClass: self andSelector: #menuSpecOwnedMemory"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#value: #inspectOwnedMemory ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Release 					#defaultString: 'Release' 					#catalogID: #com ) 				#value: #releaseOwnedMemory ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>External.COMExportedObjectsBrowser class</class-id> <category>interface specs</category><body package="Com- Ole Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #ExportedObjectsBrowser 				#defaultString: 'COM Exported Objects Browser' 				#catalogID: #com ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1299 920 ) 			#flags: 4 			#menu: #menuSpec ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 140 0 -10 0.5 -15 1 ) 					#name: #exportedInterfacesListView 					#model: #exportedInterfacesListModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectExportedInterface ) 					#menu: #menuSpecExportedInterfaces 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0.5 140 0 -15 1 -15 1 ) 					#name: #exportedObjectsListView 					#model: #exportedObjectsListModel 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #inspectExportedObject ) 					#menu: #menuSpecExportedObjects 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 268 86 ) 					#name: #specialResourceDescription ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 110 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ExportedInterfacesColon 						#defaultString: 'Exported interfaces:' 						#catalogID: #com ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 10 0.5 110 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ExportedObjectsColon 						#defaultString: 'Exported objects:' 						#catalogID: #com ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 15 15 120 45 ) 					#model: #updateResourceLists 					#label: 					#(#{Kernel.UserMessage} 						#key: #Updatelists 						#defaultString: 'Update lists' 						#catalogID: #com ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 15 60 120 90 ) 					#model: #cleanUpResourceLists 					#label: 					#(#{Kernel.UserMessage} 						#key: #CleanUpLists 						#defaultString: 'Clean up lists' 						#catalogID: #com ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>External.COMExportedObjectsBrowser class</class-id> <category>resources</category><body package="Com- Ole Development">menuSpec	"Tools.MenuEditor new openOnClass: self andSelector: #menuSpec"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cleanup 					#defaultString: 'Cleanup' 					#catalogID: #com ) 				#nameKey: #cleanup 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RevokeClassFactories 								#defaultString: 'Revoke all class factories' 								#catalogID: #com ) 							#value: #cleanupRevokeClassFactories ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReleaseAllObjects 								#defaultString: 'Release all objects' 								#catalogID: #com ) 							#value: #cleanupReleaseAllObjects ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReleaseAllResouces 								#defaultString: 'Release all resources' 								#catalogID: #com ) 							#value: #cleanupReleaseAllResources ) ) #(1 2 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Clipboard 					#defaultString: 'Clipboard' 					#catalogID: #com ) 				#nameKey: #clipboard 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #CopyToClipboard 								#defaultString: 'Copy to clipboard' 								#catalogID: #com ) 							#value: #clipboardCopyToClipboard ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #RemoveFromClipboard 								#defaultString: 'Remove from clipboard' 								#catalogID: #com ) 							#value: #clipboardRemoveFromClipboard ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ClearClipboard 								#defaultString: 'Clear clipboard' 								#catalogID: #com ) 							#value: #clipboardClearClipboard ) ) #(2 1 ) nil ) ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Com- Ole Development">comBrowseResources	"Open the COM resource browser."	&lt;menuItem: #(#BrowseResources #com 'Browse Resources...')		nameKey: nil		menu: #(#menuBar  #tools #comc)		position: 10.01&gt;	#{COMResourceBrowser} 		ifDefinedDo: [:resourceBrowserClass | resourceBrowserClass open]		elseDo: [ MessageBox warning: (#GenKey131 &lt;&lt; #com &gt;&gt; 'The COMResourceBrowser is no longer available.') asString ]</body><body package="Com- Ole Development">comGeneratePrototypeInterfaceClasses	"Prompt the user for the name of an interface whose VTable has been defined and generate prototype interface classes for the selected interface."	&lt;menuItem: #(#GenerateInterfaceClasses #com 'Generate Interface Classes...')		nameKey: nil		menu: #(#menuBar  #tools #comc)		position: 10.02&gt;	#{COMInterfaceWrapperClassGenerator} 		ifDefinedDo: [:interfaceGeneratorClass | interfaceGeneratorClass generateInterfaceClassPrototypes]		elseDo: [ MessageBox warning: (#GenKey132 &lt;&lt; #com &gt;&gt; 'The COM interface generation tools are no longer available.') asString]</body><body package="Com- Ole Development">comGeneratePrototypeInterfaceClassesWizard	"Prompt the user for the name of an interface whose VTable has been defined and generate prototype interface classes for the selected interface."	&lt;menuItem: #(#GenerateInterfaceClassesWizzard #com 'Generate Interface Classes... (Wizard)')		nameKey: nil		menu: #(#menuBar  #tools #comc)		position: 10.01&gt;	#{Tools.COMInterfaceClassGenerationWizard} 		ifDefinedDo: [:wizard | wizard open]		elseDo: [ MessageBox warning: (#PleaseLoadCOMOleDevelopment &lt;&lt; #com &gt;&gt; 'The COM interface generation tools are not available. Please load the parcel COM OleDevelopment') asString]</body><body package="Com- Ole Development">comInstallTraceManager	" Toggle the installed state of the COM trace manager. "	&lt;menuItem: #(#InstallTraceManager #com 'Install Trace Manager')		nameKey: nil		menu: #(#menuBar  #tools #comc)		position: 10.03&gt;	| traceManagerClass toolsMenu comMenu installTracingItem traceViewerItem installLabel uninstallLabel shouldInstall |	(traceManagerClass := #{COMTraceManager} valueOrDo: nil) isNil 		ifTrue:  			[MessageBox warning: (#GenKey136 &lt;&lt; #com &gt;&gt; 'The COMTraceManager is no longer available.') asString.		      ^self].	toolsMenu := ( menuBar value atNameKey: #tools ) submenu.	comMenu := ( toolsMenu atNameKey: #comc ) submenu.		"Alt: ( toolsMenu menuItemLabeled: 'COM' ) submenu "	installTracingItem := comMenu menuItemWithValue: #comInstallTraceManager.	traceViewerItem := comMenu menuItemWithValue: #comOpenTraceViewer.	installLabel := (#InstallTraceManager &lt;&lt; #com &gt;&gt; 'Install Trace Manager') asString.	uninstallLabel := (#UninstallTraceManager &lt;&lt; #com &gt;&gt; 'Uninstall Trace Manager') asString.	shouldInstall := COMSessionManager traceManager isNil.	" in the current implementation, the COM menu is not updated on display,		so it is possible for the menu state to get out of synch with the actual		state of the trace manager installation if this has been toggled		programmatically.  In lieu of a correct implementation of the menu		item to always display the correct state, leave a backstop in place "	( shouldInstall not and: [ installTracingItem label = installLabel ] )		ifTrue: [ shouldInstall := true ].	( shouldInstall and: [ installTracingItem label = uninstallLabel ] )		ifTrue: [ shouldInstall := false ].	shouldInstall		ifTrue: 			[traceManagerClass installTraceSupport.			installTracingItem label: uninstallLabel.			traceViewerItem enable]		ifFalse: 			[traceManagerClass traceLog notNil		                ifTrue: 						["??traceManagerClass clearTraceLog.??"  " dangerous to yank out from underneath open viewer "						MessageBox warning: (#GenKey133 &lt;&lt; #com &gt;&gt; 'Cannot uninstall COM trace manager at this time- trace logging is currently still in use.  You may need to close yourtrace viewer before uninstalling the trace support.') asString.						^self].			traceManagerClass uninstallTraceSupport.			installTracingItem label: installLabel.			traceViewerItem disable ]</body><body package="Com- Ole Development">comOpenTraceViewer	"Open a COM trace viewer. "	&lt;menuItem: #(#TraceViewer #com 'Trace Viewer...')		nameKey: nil		menu: #(#menuBar  #tools #comc)		position: 10.04&gt;	| traceViewerClass |	(traceViewerClass := #{COMTraceViewer} valueOrDo: nil) isNil 		ifTrue:  			[MessageBox warning: (#GenKey137 &lt;&lt; #com &gt;&gt; 'The COM trace viewer is no longer available.') asString.			^self].	"in the current implementation, the COM menu is not updated on display,	so it is possible for the menu state to get out of synch with the actual	state of the trace manager installation if this has been toggled	programmatically.  In lieu of a correct implementation of the menu	item to always display the correct state, leave a backstop in place "	COMSessionManager traceManager isNil		ifTrue: 			[| traceManagerClass |		        traceManagerClass := #{COMTraceManager} valueOrDo: 					[MessageBox warning: (#GenKey136 &lt;&lt; #com &gt;&gt; 'The COMTraceManager is no longer available.') asString.					^self ].		        (MessageBox confirm: (#GenKey135 &lt;&lt; #com &gt;&gt; 'COM tracing support is not currently activated.Install the COM trace manager and proceed to open a trace viewer?') asString)					ifFalse: 						[self comInstallTraceManager.  " fix up the menu state at this point "						^self ].				"install tracing to synch the image with what the menu already alleges  to be the case"				traceManagerClass installTraceSupport].	traceViewerClass open.</body><body package="Com- Ole Development">comOpenWorkspaceCode	"Open the workspace code referenced in the readme. "	&lt;menuItem: #(#NewPoolMappings #com 'New PoolDictionary Mappings...')		nameKey: nil		menu: #(#menuBar  #tools #comc)		position: 10.06&gt;	(TextWindow label: #WorkspacePoolConvert &lt;&lt; #com &gt;&gt; 'Workspace code to Help migrate old system PoolDictionary References.')		textCollector nextPutAll: self class comPoolMapCodeString</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-com</category><body package="Com- Ole Development">com01DefaultDirectory	&lt;setting: #(com defaultDirectory)&gt;	^(StringSetting forNameOfDirectory on: COMSessionManager aspect: #defaultCOMDirectoryName)		label: #DefaultDirectory &lt;&lt; #com &gt;&gt; 'Default directory';		helpText: #comDefaultDirHelpText &lt;&lt; #com &gt;&gt; 'Specifies the directory of the COMConnect distribution where COM related files (e.g. examples) are located.'</body><body package="Com- Ole Development">com02TraceSupport	&lt;setting: #(com traceSupport)&gt;	| valueModel |	valueModel := self modelForTraceInstallation.	^(BooleanSetting on: valueModel)		label: #InstallTraceSupport &lt;&lt; #com &gt;&gt; 'Install Trace Support';		helpText: #traceSupportHelp &lt;&lt; #com &gt;&gt; 'When tracing is installed, tracing on specific types of function calls and individual interfaces can be dynamically enabled and disabled. COM tracing is optionally enabled and disabled during application development, so that the overhead of interface function tracing is incurred only when needed.'</body><body package="Com- Ole Development">com04ErrorNotifierClass	&lt;setting: #(com errorReporting errorNotifierClass)&gt;	| choices notifierEnumeration |	choices := OrderedCollection with: COMErrorReporter.	#{RuntimePackager.RuntimeErrorNotifier} 		ifDefinedDo: [:class | choices addAll: class allSubclasses].	notifierEnumeration := EnumerationSetting 				keys: (choices collect: [:each | each name])				choices: choices.	^(notifierEnumeration on: ImageConfiguration aspect: #errorNotifierClass)		default: ImageConfiguration defaultErrorNotifierClass;		label: #ErrorNotifierClass &lt;&lt; #com &gt;&gt; 'Error Notifier Class';		helpText: #ErrorNotifierClassHelp &lt;&lt; #com &gt;&gt;'For this option, choose the class that provides the level of detail and interaction desired to open notifiers or write stack dump files for COM call-in or call-out errors.  If the selection is not COMErrorReporter, log enablement and file path depend on that class.  For example, if the selected class is RuntimeDebugNotifier ensure RuntimeManager #errorLogPath:, #errorNotifierClass:, and #imageDumperClass: have been set.'</body><body package="Com- Ole Development">com05LogToFile	&lt;setting: #(com errorReporting logToFile)&gt;	^(BooleanSetting on: ImageConfiguration aspect: #logToFile)		label: #LogErrorsToFile &lt;&lt; #com &gt;&gt; 'Log Errors To File';			default: true;		helpText: #LogErrorsToFileHelp &lt;&lt; #com &gt;&gt; 'When this option is enabled, COM call errors are logged to the file declared in Error Log Path.'</body><body package="Com- Ole Development">com06ErrorLogPath	&lt;setting: #(com errorReporting errorLogPath)&gt;	^(StringSetting forNameOfFile on: ImageConfiguration aspect: #errorLogPath)		label: #ErrorLogPath &lt;&lt; #com &gt;&gt; 'Error Log Path';		default: 'error.log';		helpText: #ErrorLogPathHelp &lt;&lt; #com &gt;&gt; 'The file path to write COM logs to if error logging is enabled.'</body><body package="Com- Ole Development">com07DefaultLCID	&lt;setting: #(#com #defaultLCID)&gt;	| choices labels |	choices := Array				with: COMSessionManager defaultDefaultLCIDInitializerBlock				with: [COMSessionManager defaultLocaleID: Win32ExternalInterface defaultUserLCID]				with: nil.	labels := Array				with: #USEnglish &lt;&lt; #com &gt;&gt; 'US English'				with: #UserDefault &lt;&lt; #com &gt;&gt; 'User Default LCID'				with: #EnterCustomLCID &lt;&lt; #com &gt;&gt; 'Custom LCID...'.	^((EnumerationSetting		keys: #(#USEnglish #UserDefault #Custom)		choices: choices		labels: labels)		on: COMSessionManager aspect: #defaultLocaleIDInitializer)		label: #defaultLCID &lt;&lt; #com &gt;&gt; 'Default LCID';		default: nil;		helpText: #DefaultLCIDHelp &lt;&lt; #com &gt;&gt; 'The LCID used by default by Dispatch Drivers during communication with Automation Servers. This will change interpretation of parameters formats in the server application and also the language of member names if the server supports this.'</body><body package="Com- Ole Development">com07UseNativeDialogs	&lt;setting: #(com useNativeDialogs)&gt;	^(BooleanSetting on: MessageBox aspect: #useNativeDialogs)		label: #UseNativeDialogs &lt;&lt; #com &gt;&gt; 'Use native dialogs';		helpText: #UseNativeDialogsHelp &lt;&lt; #com &gt;&gt; 'Determines whether COM Connect uses native dialogs for displaying messages.'</body><body package="Com- Ole Development">com08customLCID	&lt;setting: #(com customLCID)&gt;	^((IntegerSetting min: 0) 			on: COMSessionManager aspect: #defaultLocaleID)		default: 1033;		label: #CustomLCID &lt;&lt; #labels &gt;&gt; 'Custom Locale ID';		helpText: #CustomLCIDHelpText &lt;&lt; #dialogs &gt;&gt; 'If ''Use Custom LCID'' is selected a special Locale ID may be provided which will be used by default by COMDispatchDrivers for communicating with servers.'</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>pages</category><body package="Com- Ole Development">comErrorReportingPage	&lt;settingsPage: #(com errorReporting)&gt;	| settingsPage |	settingsPage := (ModularSettingsPage new)				label: #ErrorNotify &lt;&lt; #labels &gt;&gt; 'Error Notifications';				icon: (ListIconLibrary visualFor: #bug);				settings: (self settingsWithPrefix: #(#com #errorReporting)).	settingsPage 		when: (settingsPage 						moduleForSettingWithId: #(#com #errorReporting #errorNotifierClass)) 				valueHolder		valueSatisfies: [:value | value == COMErrorReporter]		enableAll: (Array with: (settingsPage 						moduleForSettingWithId: #(#com #errorReporting #logToFile))				with: (settingsPage 						moduleForSettingWithId: #(#com #errorReporting #errorLogPath))).	^settingsPage</body><body package="Com- Ole Development">comPage		&lt;settingsPage: #(#com)&gt;	^(ComSettingsPage new)		label: #COM &lt;&lt; #com &gt;&gt; 'COM';		icon: (ListIconLibrary visualFor: #com);		settings: (self settingsWithPrefix: #(#com)).</body></methods><initialize><class-id>External.IUnknownTraceAdaptor</class-id></initialize><initialize><class-id>External.IPersistTraceAdaptor</class-id></initialize><initialize><class-id>External.COMTraceManager</class-id></initialize><initialize><class-id>External.IMallocTraceAdaptor</class-id></initialize><initialize><class-id>External.COMInterfaceWrapperClassGenerator</class-id></initialize><initialize><class-id>External.IStorageTraceAdaptor</class-id></initialize><initialize><class-id>External.IStreamTraceAdaptor</class-id></initialize><initialize><class-id>External.IParseDisplayNameTraceAdaptor</class-id></initialize><initialize><class-id>External.IEnumTraceAdaptor</class-id></initialize><initialize><class-id>External.IClassFactoryTraceAdaptor</class-id></initialize><initialize><class-id>External.IDataObjectTraceAdaptor</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>COMInterfaceBinding</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>iid </class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>EventEnabledApplicationModel</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><class><name>CType</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>specifierFlags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>COMInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface </inst-vars><class-inst-vars>iid </class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>CTypedefType</name><environment>External</environment><super>External.CQualifiedType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>ModularSettingsPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settings modules spec preferredModuleClasses enablementTrackers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>COMInterfaceAdaptor</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>implementor vtableSelectors </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>COMEntryPointDescription</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name selector vtableIndex signatureType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceImplementation</name><environment>External</environment><super>External.COMInterfaceBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfacePointer implementor </inst-vars><class-inst-vars>vtableSignatureTypeName vtable vtableSelectors </class-inst-vars><imports>			External.CConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>CScalarType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>kind numBits printName storeSelector atSelector atPutSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class></st-source>