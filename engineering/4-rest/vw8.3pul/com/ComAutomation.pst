<?xml version="1.0"?><st-source><!-- Name: Com- AutomationNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.DbIdentifier: bear73DbTrace: 497469DbUsername: alexDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'Com- External Data Enhancements' '') #(#any 'Com- Win32' '') #(#any 'Com- Ole' '') #(#any 'Com- Automation Pools' '') #(#any 'Com- Win32 Pools' '') #(#any 'Com- Ole Pools' '') #(#any 'Com- System Configuration Services' '') #(#any 'Com- ExtensionsToBase' '') #(#any 'Com- CodeAnnotations' '') #(#any 'DLLCC' ''))DialectVersion: VisualWorks 7.9PackageName: Com- AutomationParcel: #('ComAutomation')ParcelName: Com- AutomationPrerequisiteDescriptions: #(#(#name 'Com- External Data Enhancements') #(#name 'Com- Win32') #(#name 'Com- Ole') #(#name 'Com- Automation Pools') #(#name 'Com- Win32 Pools') #(#name 'Com- Ole Pools' #componentType #package) #(#name 'Com- System Configuration Services' #componentType #package) #(#name 'Com- ExtensionsToBase' #componentType #package) #(#name 'Com- CodeAnnotations' #componentType #package) #(#name 'DLLCC' #componentType #package #applicability #store))PrerequisiteParcels: #(#('Com- External Data Enhancements' '') #('Com- Win32' '') #('Com- Ole' '') #('Com- Automation Pools' '') #('Com- Win32 Pools' '') #('Com- Ole Pools' '') #('Com- System Configuration Services' '') #('Com- ExtensionsToBase' '') #('Com- CodeAnnotations' ''))PrintStringCache: (8.3 - 2,alex)Version: 8.3 - 2Post-Load Block: 	[ :pkg |  External.COMVariantStructure postLoadFrom: pkg.	#{AdvancedDispatchDriver} initialize.	COMDispatchSpecificationTable addDependent: DispUserDefTypeSpec.	External.GUID installEnhancedIIDLookupFunctionality.]Pre-Unload Block: 	[:t1 |	External.GUID removeEnhancedIIDLookupFunctionality.	ObjectMemory removeDependent: COMDispatchSpecificationTable.]Date: 1:50:05 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:05</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>IConnectionPointContainerPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>IConnectionPointPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>IProvideClassInfoPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>ITypeCompPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.CConstants.*			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>ITypeInfoPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>ITypeLibPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchInterfacePointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>IDispatchPointer</name><environment>External</environment><super>External.COMDispatchInterfacePointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchInterfaceImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>IDispatchImplementation</name><environment>External</environment><super>External.COMDispatchInterfaceImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>IConnectionPoint</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>IConnectionPointContainer</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>IProvideClassInfo</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>ITypeComp</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypeLibraryInterface</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>ITypeInfo</name><environment>External</environment><super>External.COMTypeLibraryInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>ITypeLib</name><environment>External</environment><super>External.COMTypeLibraryInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchInterface</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			External.Win32NLSConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>IDispatch</name><environment>External</environment><super>External.COMDispatchInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMAutomationConstants.*			External.COMConstants.*			External.Win32NLSConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVariantStructure</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeDescription fixedArrayDataPointer </inst-vars><class-inst-vars></class-inst-vars><imports>			External.CConstants.*			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVariantValue</name><environment>External</environment><super>External.COMVariantStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCode </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_VARIANT</name><environment>External</environment><super>External.COMVariantStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_VARIANTARG</name><environment>External</environment><super>External.COM_VARIANT</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_ARRAYDESC</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_BLOB</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_CY</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_DISPPARAMS</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>marshaledArgumentsCache </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_ELEMDESC</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_EXCEPINFO</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_SAFEARRAY</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeDescription accessor lowerBounds </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.COM_SAFEARRAY</class-id><body>A SAFEARRAY is an array which carries information about its dimensionality and bounds, as well as the actual data of the array elements.  The data referred to by the array descriptor is stored in column-major order (as in Visual Basic and FORTRAN), withe the left-most dimension changing first; this is in contrast to the row-major storage convention used by C and Pascal.The current implementation OLE_SAFEARRAY only allows for single-dimension arrays, although the SAFEARRAY struct can be used for multi-dimensional arrays./* INTERNAL COMMENT */// SAFEARRAY structure definition/* the following is what RPC knows how to remote */            /* size is 16 */typedef struct  tagSAFEARRAY    {    unsigned short cDims;    unsigned short fFeatures;    unsigned long cbElements;    unsigned long cLocks;    BYTE *pvData;    /* [size_is] */ SAFEARRAYBOUND rgsabound[ 1 ];    }    SAFEARRAY;            /* size is 4 */typedef struct tagSAFEARRAY *LPSAFEARRAY;/* here is the standard definition */typedef struct FARSTRUCT tagSAFEARRAY {    unsigned short cDims;    unsigned short fFeatures;#if defined(WIN32)    unsigned long cbElements;    unsigned long cLocks;#else    unsigned short cbElements;    unsigned short cLocks;    unsigned long handle;               // unused but kept for compatiblity#endif    void HUGEP* pvData;    SAFEARRAYBOUND rgsabound[1];} SAFEARRAY, FAR* LPSAFEARRAY;</body></comment><class><name>COM_SAFEARRAYBOUND</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_TYPEDESC</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_DECIMAL</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypeLibraryStructure</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeInterface </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_FUNCDESC</name><environment>External</environment><super>External.COMTypeLibraryStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_TLIBATTR</name><environment>External</environment><super>External.COMTypeLibraryStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_TYPEATTR</name><environment>External</environment><super>External.COMTypeLibraryStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMAbstractMemberSpecification</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM-Automation-Dispatch Specifications</category><attributes><package>Com- Automation</package></attributes></class><class><name>GeneralPropertySpecification</name><environment>External</environment><super>External.COMAbstractMemberSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertyGetSpecification propertySetSpecification isVTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMAutomationID</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>VersionIndependentProgID</name><environment>External</environment><super>External.COMAutomationID</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispTypeSpec</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispSimpleTypeSpec</name><environment>External</environment><super>External.DispTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typecode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMRecord</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structure recordInfo memberNames typeDescription ownsMemory </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM- UDT Support</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.COMRecord</class-id><body>COMRecord is a class to manage COM Structures, so called userdefined datatypes (UDTs).  Instance Variables:	memberNames	&lt;Collection&gt;					a cache for membernames	memoryPolicy	&lt;COMRecordMemoryPolicy&gt;	a policy which determines memory-release behavior	recordInfo	&lt;IRecordInfo&gt;						the recordInfo used to perform any actions with the record	structure	&lt;CPointer&gt;							my address	typeDescription	&lt;DispStructureDescription&gt;		a detailed type description, including element types</body></comment><class><name>WindowsLocale</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.Win32NLSConstants.*			</imports><category>Com- Ole</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDateResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMAutomationServerClassFactoryObject</name><environment>External</environment><super>External.COMClassFactoryObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectCLSID dispatchInterfaceIID automationObjectClass specificationTable typeLibraries </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispUserDefTypeSpec</name><environment>External</environment><super>External.DispTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typelib docs typeFlags guid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispComponentTypeSpec</name><environment>External</environment><super>External.DispUserDefTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>elements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation Extensions</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispEnumTypeSpec</name><environment>External</environment><super>External.DispComponentTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispRefTypeSpec</name><environment>External</environment><super>External.DispTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispArrayTypeSpec</name><environment>External</environment><super>External.DispRefTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>CArrayTypeSpec</name><environment>External</environment><super>External.DispArrayTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation Extensions</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchSpecificationTable</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties specificationKey methodSpecifications propertySpecifications eventSpecifications </inst-vars><class-inst-vars>cachedSpecificationTables </class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMLookupSpecificationPolicy</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVariantLookupSpecificationPolicy</name><environment>External</environment><super>External.COMLookupSpecificationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>AbstractCOMClient</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventSink specificationTable propAccessor localeID valueAdaptor eventSpecificationTable type </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMAutomationConstants.*			private External.COMConstants.*			private External.External.COMStatusCodeConstants.*			private Win32NLSConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMReturnValueDescription</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type flags </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>CachingWeakRegistry</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>protectedReferences values numberOfProtectedEntries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.CachingWeakRegistry</class-id><body>CachingWeakRegistry is a registry with caches the last 10 added objectsInstance Variables	safedRefs	&lt;OrderedCollection&gt;	description of safedRefs	values	&lt;Dictionary&gt;	description of values</body></comment><class><name>COMLazyInitializeLookupSpecificationPolicy</name><environment>External</environment><super>External.COMVariantLookupSpecificationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchInterfaceAdaptor</name><environment>External</environment><super>External.IUnknownAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMAutomationObject</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iDispatch valueAdaptor </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			External.Win32NLSConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchObject</name><environment>External</environment><super>External.COMAutomationObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>publishedObject registrationToken </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDualInterfaceObject</name><environment>External</environment><super>External.COMDispatchObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>dualInterfaceClass specificationTable typeLibraries useAdaptorBinding </class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><class><name>AutomationApplication</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>application </inst-vars><class-inst-vars>defaultSpecificationPolicy </class-inst-vars><imports></imports><category>COM-Automation-Controller Samples</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispObjectTypeSpec</name><environment>External</environment><super>External.DispUserDefTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>InterfaceTypeSpec</name><environment>External</environment><super>External.DispObjectTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alternativeRepresentation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation Extensions</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMSafeArrayAccessor</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>safeArray </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMPrimitiveSafeArrayAccessor</name><environment>Smalltalk</environment><super>COMSafeArrayAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMSpecificPrimSafeArrayAccessor</name><environment>Smalltalk</environment><super>COMPrimitiveSafeArrayAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMByteSafeArrayAccessor</name><environment>Smalltalk</environment><super>COMSpecificPrimSafeArrayAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMSafeArrayPointerResultBuffer</name><environment>External</environment><super>External.Win32PointerResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCode </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>ProgID</name><environment>External</environment><super>External.COMAutomationID</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>IClassFactory2</name><environment>External</environment><super>External.IClassFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.IClassFactory2</class-id><body>### Provide a brief explanation of the IClassFactory2 interface ####</body></comment><class><name>CombindedConstantDescription</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>constants </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.CombindedConstantDescription</class-id><body>CombindedConstantDescription represents a combination of enumeration constantsInstance Variables	constants	&lt;(Collection of: ConstantDescription&gt;	the contained constants</body></comment><class><name>IClassFactory2Implementation</name><environment>External</environment><super>External.IClassFactoryImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.IClassFactory2Implementation</class-id><body>Instances of the receiver provide the host-level external callback binding for the IClassFactory2 interface.</body></comment><class><name>VariantChangeTypeNotification</name><environment>External</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Automation</package></attributes></class><class><name>AutomationArgument</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>ExistingArgument</name><environment>External</environment><super>External.AutomationArgument</super><private>false</private><indexed-type>none</indexed-type><inst-vars>indexSpec value argumentDescription originalValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>NamedAutomationArgument</name><environment>External</environment><super>External.ExistingArgument</super><private>false</private><indexed-type>none</indexed-type><inst-vars>originalIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMCall</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driver memberName arguments specification flags namedArguments </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMAutomationConstants.*			private External.COMConstants.*			private External.COMStatusCodeConstants.*			private Win32NLSConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchMemberSpecification</name><environment>External</environment><super>External.COMAbstractMemberSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memberID returnValueDescription vtableIndex flags parameters description optionalParameterCount </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM-Automation-Dispatch Specifications</category><attributes><package>Com- Automation</package></attributes></class><class><name>COM_VARDESC</name><environment>External</environment><super>External.COMTypeLibraryStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>BSTR</name><environment>External</environment><super>External.ExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVariant</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.Win32NLSConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMSpecificationPolicy</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>updateSpecificationTable lookupPolicy autoWrapIDispatch policySymbol </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.Win32NLSConstants.*			</imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchMethodSpecification</name><environment>External</environment><super>External.COMDispatchMemberSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM-Automation-Dispatch Specifications</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchParameterizedPropertySpecification</name><environment>External</environment><super>External.GeneralPropertySpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertyPutRefSpecification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchError</name><environment>External</environment><super>Core.COMError</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exceptionInfo exceptionDescription </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispUnionDescription</name><environment>External</environment><super>External.DispComponentTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sizeInBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation Extensions</category><attributes><package>Com- Automation</package></attributes></class><class><name>SpecialVariantArg</name><environment>External</environment><super>External.COM_VARIANTARG</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memoryPolicy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>TypeElementDescription</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>docs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.TypeElementDescription</class-id><body>TypeElementDescription is an abstract superclass vor elements of COM composite types (structs, unions, enumerations).Subclasses must implement the following messages:	accessing		typeName	browser support		referencedTypesDo:Instance Variables:	docs	&lt;Dictionary&gt;		a dictionary of information read from a typelibrary</body></comment><class><name>COMLicenseManager</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classes iLicenseManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDate</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypeCompilerLookupSpecificationPolicy</name><environment>External</environment><super>External.COMLookupSpecificationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeComp typeInfo </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>RecordAccessElement</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM- UDT Support</category><attributes><package>Com- Automation</package></attributes></class><class><name>VariantMemoryPolicy</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ownsMemory ownsReferencedMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM- UDT Support</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchPropertySpecification</name><environment>External</environment><super>External.GeneralPropertySpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessMode memberID vtableIndex returnValueDescription flags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>BSTRMemoryAddress</name><environment>External</environment><super>External.Win32MemoryAddress</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispPtrTypeSpec</name><environment>External</environment><super>External.DispRefTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>Nothing</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.Nothing</class-id><body>Nothing can be passed as parameter value to omit indexed optional parameters in COM Automation calls.</body></comment><class><name>ILicenseManager</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.ILicenseManager</class-id><body>### Provide a brief explanation of the ILicenseManager interface ####</body></comment><class><name>COMDispatchEventSpecification</name><environment>External</environment><super>External.COMDispatchMethodSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>IRecordInfo</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>PropertyAccessSpecification</name><environment>External</environment><super>External.COMDispatchMemberSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector propertySpecification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>PropertyGetAccessSpecification</name><environment>External</environment><super>External.PropertyAccessSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>IRecordInfoPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Ole</category><attributes><package>Com- Automation</package></attributes></class><class><name>VTableInterfaceTypeSpec</name><environment>External</environment><super>External.InterfaceTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMNoLookupSpecificationPolicy</name><environment>External</environment><super>External.COMLookupSpecificationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVariantEnumerator</name><environment>External</environment><super>External.COMStructureEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variantTypes </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVTableSpecificationTable</name><environment>External</environment><super>External.COMDispatchSpecificationTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars>unfiltered </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMCurrency</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispModuleTypeSpec</name><environment>External</environment><super>External.DispUserDefTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>IClassFactory2Pointer</name><environment>External</environment><super>External.IClassFactoryPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.IClassFactory2Pointer</class-id><body>Instances of the receiver provide the host-level external callout binding for the IClassFactory2 interface.</body></comment><class><name>COM_PARAMDESC</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypedLookupSpecificationPolicy</name><environment>External</environment><super>External.COMVariantLookupSpecificationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.COMTypedLookupSpecificationPolicy</class-id><body>TypedLookupSpecificationPolicy is a lookup policy which is installed automatically in DispatchDrivers for which a type is provided. This ensures that type method specifications are taken from this type instead of trying other lookup mechanisms. </body></comment><class><name>COMAutomationClientWrapper</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMAutomationConstants.*			private External.COMConstants.*			private External.External.COMStatusCodeConstants.*			private Win32NLSConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.COMAutomationClientWrapper</class-id><body>This class is used to dispatch generic com calls the correct automation methods implemented by a com client.Instance Variables	client	&lt;AbstractCOMClient&gt;	The actual COMClient</body></comment><class><name>PropertySetAccessSpecification</name><environment>External</environment><super>External.PropertyAccessSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>DispDriverAccessor</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>driver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVTableMethodSpecification</name><environment>External</environment><super>External.COMDispatchMethodSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVariantValueReference</name><environment>External</environment><super>External.ValueReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCode </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispatchInterfaceTypeSpec</name><environment>External</environment><super>External.InterfaceTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>EMBEDDED_SAFEARRAY</name><environment>External</environment><super>External.COM_SAFEARRAY</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fixedSizeDataPointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM- UDT Support</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMSpecificationQuery</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>member arguments kinds namedArguments </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMAutomationConstants.*			private External.COMConstants.*			private External.COMStatusCodeConstants.*			private Win32NLSConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypeLibraryLookupSpecificationPolicy</name><environment>External</environment><super>External.COMLookupSpecificationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>functionMap propertyMap propertyVariableMap typeInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMEventSink</name><environment>External</environment><super>External.COMAutomationObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configuration </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.COMEventSink</class-id><body>COMEventSink is the server object used to receive events from COM objects via Automation.Instance Variables:	configuration	&lt;SinkConfiguration&gt;	The configuration stores information used at runtime.</body></comment><class><name>COMRecordMemoryPolicy</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ownsMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM- UDT Support</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispAliasTypeSpec</name><environment>External</environment><super>External.DispUserDefTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actualType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.DispAliasTypeSpec</class-id><body>DispAliasTypeSpec represents a named Alias type. An Alias type knowns its actual type and delegates most of the calls to it.Instance Variables	actualType		&lt;DispTypeSpec&gt;		the actual type which I give a new name</body></comment><class><name>ILicenseManagerPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.ILicenseManagerPointer</class-id><body>Instances of the receiver provide the host-level external callout binding for the ILicenseManager interface.</body></comment><class><name>COMAutomationServer</name><environment>External</environment><super>External.COMDispatchObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatchInterfaceIID specificationTable clsid typeLibraries </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMWordSafeArrayAccessor</name><environment>Smalltalk</environment><super>COMSpecificPrimSafeArrayAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypeCompilerBoundResource</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name typeInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispStructureSpec</name><environment>External</environment><super>External.DispComponentTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sizeInBytes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation Extensions</category><attributes><package>Com- Automation</package></attributes></class><class><name>SafeArray</name><environment>Smalltalk</environment><super>Core.KeyedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data bounds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMClient</name><environment>External</environment><super>External.AbstractCOMClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfaces flags </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMConstants.*			private External.COMStatusCodeConstants.*			</imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchDriver</name><environment>External</environment><super>External.AbstractCOMClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatchInterface specificationPolicy </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMAutomationConstants.*			private External.COMConstants.*			private External.External.COMStatusCodeConstants.*			private Win32NLSConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMDispatchValueAdaptor</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>client </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMUntypedSpecificationPolicy</name><environment>External</environment><super>External.COMSpecificationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>AutomationClassMember</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>member interface </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>MissingName</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM-Automation-Dispatch Specifications</category><attributes><package>Com- Automation</package></attributes></class><class><name>IndexedAutomationArgument</name><environment>External</environment><super>External.ExistingArgument</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>CoclassDescriptor</name><environment>External</environment><super>External.DispObjectTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Ole</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypedSpecificationPolicy</name><environment>External</environment><super>External.COMSpecificationPolicy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>OLEAutomationDLL</name><environment>External</environment><super>External.COMDynamicLinkLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.CConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			private External.OLEAutomationDLLDictionary.*			</imports><category>COM-Automation-Host Bindings</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>oleaut32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Automation</package></attributes></class><class><name>TypeLibDescriptor</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>guid version lcid name platform filename docs types cache </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>Com- Ole</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMVariantResultBuffer</name><environment>External</environment><super>External.Win32StructureResultBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMParameterDescription</name><environment>External</environment><super>External.COMReturnValueDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name defaultValue </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypeCompilerBoundType</name><environment>External</environment><super>External.COMTypeCompilerBoundResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeComp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>ComponentElementDescription</name><environment>External</environment><super>External.TypeElementDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation Browser</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.ComponentElementDescription</class-id><body>ComponentElementDescriptions are elements of COM structures and unionsInstance Variables:	index	&lt;Integer&gt;		Index of the element inside the Component	type		&lt;DispTypeSpec&gt;	type of the element</body></comment><class><name>COMTypeLibrary</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryName name iTypeLib libraryID majorVersion minorVersion lcid helpDirectory typeInfoOfGuids iTypeInfo fileName </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>RecordAccessPath</name><environment>External</environment><super>Core.OrderedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM- UDT Support</category><attributes><package>Com- Automation</package></attributes></class><class><name>ConstantDescription</name><environment>External</environment><super>External.TypeElementDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>AutomationClassSpecificationTable</name><environment>External</environment><super>External.COMDispatchSpecificationTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMAbstractRegistration</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeLibraries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ImageServerRegistration</category><attributes><package>Com- Automation</package></attributes></class><class><name>RecordArrayElementAccessElement</name><environment>External</environment><super>External.RecordAccessElement</super><private>false</private><indexed-type>none</indexed-type><inst-vars>index </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM- UDT Support</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMModuleSpecificationTable</name><environment>External</environment><super>External.COMDispatchSpecificationTable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>COMTypeCompilerBoundName</name><environment>External</environment><super>External.COMTypeCompilerBoundResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Dispatch Policies</category><attributes><package>Com- Automation</package></attributes></class><class><name>SinkConfiguration</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionPointIID connectionPointInterface registrationToken specificationTable sinkInterface </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.SinkConfiguration</class-id><body>SinkConfiguration is used to store data and functionality shared between COMEventSink and GenericCOMEventSink server instances.Instance Variables:	connectionPointIID			&lt;GUID&gt;					The IID of  the ConnectionPoint used	connectionPointInterface	&lt;IConnectionPoint&gt;		ConnectionPointInterface	sinkInterface				&lt;IUnknown&gt;				The interface used to receive events	specificationTable			&lt;Dictionary&gt;				description of specificationTable	registrationToken			&lt;Object&gt;					the token received from the event source needed to unregister the Sink later</body></comment><class><name>COMSafeArray</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structure </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMAutomationRegistration</name><environment>External</environment><super>External.COMAbstractRegistration</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clsid majorVersion minorVersion activeXOn automationOption versionIndependentProgID versionIndependentDescription enginePath imagePath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>ImageServerRegistration</category><attributes><package>Com- Automation</package></attributes></class><class><name>CollectionDispDriverAccessor</name><environment>External</environment><super>External.DispDriverAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>COMSafeArrayReferenceAccessor</name><environment>Smalltalk</environment><super>COMSafeArrayAccessor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>MissingAutomationArgument</name><environment>External</environment><super>External.AutomationArgument</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>BSTRStringPointerArrayResultBuffer</name><environment>External</environment><super>External.Win32ArrayResultBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>ILicenseManagerImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.ILicenseManagerImplementation</class-id><body>Instances of the receiver provide the host-level external callback binding for the ILicenseManager interface.</body></comment><class><name>AutomationOwnedReference</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>element container </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.AutomationOwnedReference</class-id><body>The class describes a containment relationship between two elements. The class provides the ability to store the owner of the contained elementSubclasses must implement the following messages:	testing		isMethodOrPropertySpecificationInstance Variables:	container	&lt;DispUserDefTypeSpec&gt;	the container of the element	element		&lt;Object&gt;					the element which is contained</body></comment><class><name>BSTRStringPointerResultBuffer</name><environment>External</environment><super>External.Win32PointerResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Host Bindings</category><attributes><package>Com- Automation</package></attributes></class><class><name>PropertyPutRefSpecification</name><environment>External</environment><super>External.PropertySetAccessSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><comment><class-id>External.PropertyPutRefSpecification</class-id><body>PropertyPutRefSpecifications are specs for put-ref calls.</body></comment><shared-variable><name>UsedTypeLibraries</name><environment>External.COMTypeLibrary</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>ValidDefaultPolicies</name><environment>External.COMSpecificationPolicy</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>DefaultPolicy</name><environment>External.COMSpecificationPolicy</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>DecoderSelectors</name><environment>External.COMVariantStructure</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>EncoderSelectors</name><environment>External.COMVariantStructure</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>UseOptimization</name><environment>COMSafeArrayAccessor</environment><private>false</private><constant>false</constant><category>optimization level</category><initializer>true</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>UdtDefaultTypeClass</name><environment>External.DispUserDefTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>UdtTypeMap</name><environment>External.DispUserDefTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>SupportedIIDs</name><environment>External.IDispatch</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>DefinedTypes</name><environment>External.DispSimpleTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>IdentityDictionary new</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>CTypesDict</name><environment>External.DispSimpleTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>ReleaseSelectors</name><environment>External.DispSimpleTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>UnmarshalSelectors</name><environment>External.DispSimpleTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>NumericTypeCodes</name><environment>External.DispSimpleTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>MarshalSelectors</name><environment>External.DispSimpleTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>Default</name><environment>External.MissingAutomationArgument</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>TypeLibraries</name><environment>External.COMLicenseManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>Classes</name><environment>External.COMLicenseManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>OLEAutomationDLLDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>AdvancedDispatchDriver</name><environment>External</environment><private>false</private><constant>true</constant><category>Backwards Compatibility</category><initializer>COMDispatchDriver</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>TypeLibSearchPaths</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>SupportedTypeCodes</name><environment>COMPrimitiveSafeArrayAccessor</environment><private>false</private><constant>false</constant><category>accessor types</category><initializer>Set new		add: VT_I1;		add: VT_I2;		add: VT_I4;		add: VT_I8;		add: VT_UI1;		add: VT_UI2;		add: VT_UI4;		add: VT_UI8;		add: VT_INT;		add: VT_UINT;		add: VT_R4;		add: VT_R8;		yourself</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>TypeCodeClassMap</name><environment>External.DispTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>DefaultClass</name><environment>External.DispTypeSpec</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>Replacements</name><environment>External.WindowsLocale</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>None</name><environment>External.COMCall</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>1</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>SpecificationPolicy</name><environment>External.COMClient</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>COMSpecificationPolicy newCompletePolicy</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>ClassBindings</name><environment>External.DispComponentTypeSpec</environment><private>false</private><constant>false</constant><category>binding support</category><initializer>IdentityDictionary new</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>ExtTypeLibIDMap</name><environment>External.COMRegistryInterface</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>STRepresentations</name><environment>External.COMVariant</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>VBTypeCodeRepresentations</name><environment>External.COMVariant</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>TypeCodesToFilter</name><environment>External.COMVariant</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>CTypeRepresentations</name><environment>External.COMVariant</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>TypeCodeNameMap</name><environment>External.COMVariant</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation</package></attributes></shared-variable><shared-variable><name>LiteralTypeMap</name><environment>External.COMAbstractMemberSpecification</environment><private>false</private><constant>false</constant><category>private-literal representation</category><attributes><package>Com- Automation</package></attributes></shared-variable><methods><class-id>External.IConnectionPointContainerPointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeEnumConnectionPoints: ppEnum	" Private - invoke the IConnectionPointContainer::EnumConnectionPoints function. "	" HRESULT EnumConnectionPoints(            /* [out] */ LPENUMCONNECTIONPOINTS *ppEnum); "	&lt;COM: HRESULT __stdcall  EnumConnectionPoints(LPENUMCONNECTIONPOINTS * ppEnum) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeFindConnectionPoint: iid _: ppCP	" Private - invoke the IConnectionPointContainer::FindConnectionPoint function. "	" HRESULT FindConnectionPoint(            /* [in] */ REFIID iid,            /* [out] */ LPCONNECTIONPOINT *ppCP); "	&lt;COM: HRESULT __stdcall  FindConnectionPoint(const IID * const iid, LPCONNECTIONPOINT * ppCP) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IConnectionPointPointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeAdvise: pUnkSink _: pdwCookie	" Private - invoke the IConnectionPoint::Advise function. "	" HRESULT Advise(            /* [in] */ LPUNKNOWN pUnkSink            /* [out] */ DWORD *pdwCookie); "	&lt;COM: HRESULT __stdcall  Advise(LPUNKNOWN pUnkSink, DWORD * pdwCookie) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeEnumConnections: ppEnum	" Private - invoke the IConnectionPoint::EnumConnections function. "	" HRESULT EnumConnections(            /* [out] */ LPENUMCONNECTIONS *ppEnum); "	&lt;COM: HRESULT __stdcall  EnumConnections(LPENUMCONNECTIONS * ppEnum) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetConnectionInterface: pIID	" Private - invoke the IConnectionPoint::GetConnectionInterface function. "	" HRESULT GetConnectionInterface(            /* [out] */ IID *pIID); "	&lt;COM: HRESULT __stdcall  GetConnectionInterface(IID * pIID) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetConnectionPointContainer: ppCPC	" Private - invoke the IConnectionPoint::GetConnectionPointContainer function. "	" HRESULT GetConnectionPointContainer(            /* [out] */ IConnectionPointContainer **ppCPC); "	&lt;COM: HRESULT __stdcall  GetConnectionPointContainer(IConnectionPointContainer * * ppCPC) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IConnectionPointPointer</class-id> <category>interface operations</category><body package="Com- Automation">Unadvise: dwCookie		" Invoke the IConnectionPoint::Unadvise function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Unadvise(            /* [in] */ DWORD dwCookie); "	&lt;COM: HRESULT __stdcall  Unadvise(DWORD dwCookie) = 6&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IProvideClassInfoPointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeGetClassInfo: ppTI	" Private - invoke the IProvideClassInfo::GetClassInfo function. "	" HRESULT GetClassInfo(            /* [out] */ LPTYPEINFO * ppTI); "	&lt;COM: HRESULT __stdcall  GetClassInfo(LPTYPEINFO * ppTI) = 3&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.ITypeCompPointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeBind: szName _: lHashVal _: fFlags _: pptinfo _: pdesckind _: pbindptr	" Private - invoke the ITypeComp::Bind function. "        "HRESULT Bind(            /* [in] */ LPOLESTR szName,            /* [in] */ ULONG lHashVal,            /* [in] */ WORD fFlags,            /* [out] */ ITypeInfo *__RPC_FAR *pptinfo,            /* [out] */ DESCKIND *pdesckind,            /* [switch_is][out] */ BINDPTR *pbindptr);"	&lt;COM: HRESULT __stdcall  Bind(LPOLESTR szName, ULONG lHashVal, WORD fFlags, ITypeInfo * * pptinfo, DESCKIND * pdesckind, BINDPTR * pbindptr) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeBindType: szName _: lHashVal  _: ppTInfo _: ppTComp	" Private - invoke the ITypeComp::Bind function. "        "HRESULT STDMETHODCALLTYPE BindType(             /* [in] */ LPOLESTR szName,            /* [in] */ ULONG lHashVal,            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo,            /* [out] */ ITypeComp __RPC_FAR *__RPC_FAR *ppTComp) "	&lt;COM: HRESULT __stdcall  BindType(LPOLESTR szName, ULONG lHashVal, ITypeInfo  * * ppTInfo, ITypeComp * *ppTComp) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.ITypeInfoPointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeAddressOfMember: memid _: invkind _: ppv	" Private - invoke the ITypeInfo::AddressOfMember function. "	" HRESULT AddressOfMember(            /* [in] */ MEMBERID memid,            /* [in] */ INVOKEKIND invkind,            /* [out] */ void **ppv); "	&lt;COM: HRESULT __stdcall  AddressOfMember(MEMBERID memid, INVOKEKIND invkind, void * * ppv) = 15&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeCreateInstance: puncOuter _: riid _: ppvObj	" Private - invoke the ITypeInfo::CreateInstance function. "	" HRESULT CreateInstance(            /* [in] */ IUnknown *puncOuter,            /* [in] */ REFIID riid,            /* [out] */ void **ppvObj); "	&lt;COM: HRESULT __stdcall  CreateInstance(IUnknown * puncOuter, const IID * const riid, void * * ppvObj) = 16&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetContainingTypeLib: pptlib _: pindex	" Private - i~~oke the ITypeInfo::GetContainingTypeLib function. "	" HRESULT GetContainingTypeLib(            /* [out] */ ITypeLib **pptlib,            /* [out] */ UINT *pindex); "	&lt;COM: HRESULT __stdcall  GetContainingTypeLib(ITypeLib * * pptlib, UINT * pindex) = 18&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetDllEntry: memid _:  invkind _: pbstrDllName _: pbstrName _: pwOrdinal	" Private - invoke the ITypeInfo::GetDllEntry function. "	" HRESULT GetDllEntry(            /* [in] */ MEMBERID memid,            /* [in] */ INVOKEKIND invkind,            /* [out] */ BSTR *pbstrDllName,            /* [out] */ BSTR *pbstrName,            /* [out] */ WORD *pwOrdinal); "	&lt;COM: HRESULT __stdcall  GetDllEntry(MEMBERID memid, INVOKEKIND invkind, BSTR * pbstrDllName, BSTR * pbstrName, WORD * pwOrdinal) = 13&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetDocumentation: memid _:  pbstrName _: pbstrDocString _: pdwHelpContext _: pbstrHelpFile	" Private - invoke the ITypeInfo::GetDocumentation function. "	" HRESULT GetDocumentation(            /* [in] */ MEMBERID memid,            /* [out] */ BSTR *pbstrName,            /* [out] */ BSTR *pbstrDocString,            /* [out] */ DWORD *pdwHelpContext,            /* [out] */ BSTR *pbstrHelpFile); "	&lt;COM: HRESULT __stdcall  GetDocumentation(MEMBERID memid, BSTR * pbstrName, BSTR * pbstrDocString, DWORD * pdwHelpContext, BSTR * pbstrHelpFile) = 12&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetFuncDesc: index _: pppfuncdesc	" Private - invoke the ITypeInfo::GetFuncDesc function. "	" HRESULT GetFuncDesc(            /* [in] */ UINT index,            /* [out] */ FUNCDESC **pppfuncdesc); "	&lt;COM: HRESULT __stdcall  GetFuncDesc(UINT index, FUNCDESC * * pppfuncdesc) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetIDsOfNames: rglpszNames _: cNames _: rgmemid	" Private - invoke the ITypeInfo::GetIDsOfNames function. "	" HRESULT GetIDsOfNames(            /* [size_is][in] */ OLECHAR **rglpszNames,            /* [in] */ UINT cNames,            /* [size_is][out] */ MEMBERID *rgmemid); "	&lt;COM: HRESULT __stdcall  GetIDsOfNames(OLECHAR * * rglpszNames, UINT cNames, MEMBERID * rgmemid) = 10&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetImplTypeFlags: index _: pimpltypeflags	" Private - invoke the ITypeInfo::GetImplTypeFlags function. "	" HRESULT GetImplTypeFlags(            /* [in] */ UINT index,            /* [out] */ INT *pimpltypeflags); "	&lt;COM: HRESULT __stdcall  GetImplTypeFlags(UINT index, INT * pimpltypeflags) = 9&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetMops: memid _: pbstrMops	" Private - i~~oke the ITypeInfo::GetMops function. "	" HRESULT GetMops(            /* [in] */ MEMBERID memid,            /* [out] */ BSTR *pbstrMops); "	&lt;COM: HRESULT __stdcall  GetMops(MEMBERID memid, BSTR * pbstrMops) = 17&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetNames: memid _: rgbstrNames _: cMaxNames _: pcNames	" Private - invoke the ITypeInfo::GetNames function. "	" HRESULT GetNames(            /* [in] */ MEMBERID memid,            /* [length_is][size_is][out] */ BSTR *rgbstrNames,            /* [in] */ UINT cMaxNames,            /* [out] */ UINT *pcNames); "	&lt;COM: HRESULT __stdcall  GetNames(MEMBERID memid, BSTR * rgbstrNames, UINT cMaxNames, UINT * pcNames) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetRefTypeInfo: hreftype _: pptinfo	" Private - invoke the ITypeInfo::GetRefTypeInfo function. "	" HRESULT GetRefTypeInfo(            /* [in] */ HREFTYPE hreftype,            /* [out] */ ITypeInfo **pptinfo); "	&lt;COM: HRESULT __stdcall  GetRefTypeInfo(HREFTYPE hreftype, ITypeInfo * * pptinfo) = 14&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetRefTypeOfImplType: index _: hpreftype	" Private - invoke the ITypeInfo::GetRefTypeOfImplType function. "	" HRESULT GetRefTypeOfImplType(            /* [in] */ UINT index,            /* [out] */ HREFTYPE *hpreftype); "	&lt;COM: HRESULT __stdcall  GetRefTypeOfImplType(UINT index, HREFTYPE * hpreftype) = 8&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: TYPE_E_ELEMENTNOTFOUND</body><body package="Com- Automation">invokeGetTypeAttr: pptypeattr	" Private - invoke the ITypeInfo::GetTypeAttr function. "	" HRESULT GetTypeAttr(            /* [out] */ TYPEATTR **pptypeattr); "	&lt;COM: HRESULT __stdcall  GetTypeAttr(TYPEATTR * * pptypeattr) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetTypeComp: pptcomp	" Private - invoke the ITypeInfo::GetTypeComp function. "	" HRESULT GetTypeComp(            /* [out] */ ITypeComp **pptcomp); "	&lt;COM: HRESULT __stdcall  GetTypeComp(ITypeComp * * pptcomp) = 4&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetVarDesc: index _: ppvardesc	" Private - invoke the ITypeInfo::GetVarDesc function. "	" HRESULT GetVarDesc(            /* [in] */ UINT index,            /* [out] */ VARDESC **ppvardesc); "	&lt;COM: HRESULT __stdcall  GetVarDesc(UINT index, VARDESC * * ppvardesc) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeInvoke: pvInstance _:  memid _: wFlags _: pdispparams _: pvarResult _: pexcepinfo _: puArgErr	" Private - invoke the ITypeInfo::Invoke function. "	" HRESULT Invoke(            /* [unique][in] */ void *pvInstance,            /* [in] */ MEMBERID memid,            /* [in] */ WORD wFlags,            /* [in] */ DISPPARAMS *pdispparams,            /* [out] */ VARIANT *pvarResult,            /* [out] */ EXCEPINFO *pexcepinfo,            /* [out] */ UINT *puArgErr); "	&lt;COM: HRESULT __stdcall  Invoke(void * pvInstance, MEMBERID memid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr) = 11&gt;	" dispatch invocation error conditions has special exception generation support "	^self externalAccessFailedWith: _errorCode		allowHRESULT: DISP_E_EXCEPTION		or: DISP_E_TYPEMISMATCH</body><body package="Com- Automation">invokeReleaseFuncDesc: pfuncdesc	" Private - invoke the ITypeInfo::ReleaseFuncDesc function. "	" void ReleaseFuncDesc(            /* [in] */ FUNCDESC *pfuncdesc); "	&lt;COM: void __stdcall  ReleaseFuncDesc(FUNCDESC * pfuncdesc) = 20&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeReleaseTypeAttr: ptypeattr	" Private - invoke the ITypeInfo::ReleaseTypeAttr function. "	" void ReleaseTypeAttr(            /* [in] */ TYPEATTR *ptypeattr); "	&lt;COM: void __stdcall  ReleaseTypeAttr(TYPEATTR * ptypeattr) = 19&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeReleaseVarDesc: pvardesc	" Private - invoke the ITypeInfo::ReleaseVarDesc function. "	" void ReleaseVarDesc(            /* [in] */ VARDESC *pvardesc); "	&lt;COM: void __stdcall  ReleaseVarDesc(VARDESC * pvardesc) = 21&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.ITypeLibPointer</class-id> <category>interface operations</category><body package="Com- Automation">GetTypeInfoCount	" Invoke the ITypeLib::GetTypeInfoCount function."	" UINT GetTypeInfoCount( void); "	&lt;COM: UINT __stdcall  GetTypeInfoCount(void) = 3&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.ITypeLibPointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeFindName: szNameBuf _: lHashVal _: rgptinfo _: rgmemid _: pcFound	" Private - invoke the ITypeLib::FindName function. "	" HRESULT FindName(            /* [in] */ LPOLESTR szNameBuf,            /* [in] */ ULONG lHashVal,            /* [length_is][size_is][out] */ ITypeInfo **rgptinfo,            /* [length_is][size_is][out] */ MEMBERID *rgmemid,            /* [out][in] */ USHORT *pcFound); "	&lt;COM: HRESULT __stdcall  FindName(LPOLESTR szNameBuf, ULONG lHashVal, ITypeInfo * * rgptinfo, MEMBERID * rgmemid, USHORT * pcFound) = 11&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetDocumentation: index _: pbstrName _: pbstrDocString _: pdwHelpContext _: pbstrHelpFile	" Private - invoke the ITypeLib::GetDocumentation function. "	" HRESULT GetDocumentation(            /* [in] */ INT index,            /* [out] */ BSTR *pbstrName,            /* [out] */ BSTR *pbstrDocString,            /* [out] */ DWORD *pdwHelpContext,            /* [out] */ BSTR *pbstrHelpFile); "	&lt;COM: HRESULT __stdcall  GetDocumentation(INT index, BSTR * pbstrName, BSTR * pbstrDocString, DWORD * pdwHelpContext, BSTR * pbstrHelpFile) = 9&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetLibAttr: pptlibattr	" Private - invoke the ITypeLib::GetLibAttr function. "	" HRESULT GetLibAttr(            /* [out] */ TLIBATTR **pptlibattr); "	&lt;COM: HRESULT __stdcall  GetLibAttr(TLIBATTR * * pptlibattr) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetTypeComp: pptcomp	" Private - invoke the ITypeLib::GetLibAttr function. "	" HRESULT GetTypeComp(            /* [out] */ ITypeComp **pptcomp); "	&lt;COM: HRESULT __stdcall  GetTypeComp(ITypeComp * * pptcomp) = 8&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetTypeInfo: index _: ppitinfo	" Private - invoke the ITypeLib::GetTypeInfo function. "	" HRESULT GetTypeInfo(            /* [in] */ UINT index,            /* [out] */ ITypeInfo **ppitinfo); "	&lt;COM: HRESULT __stdcall  GetTypeInfo(UINT index, ITypeInfo * * ppitinfo) = 4&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetTypeInfoOfGuid: guid _: pptinfo	" Private - invoke the ITypeLib::GetTypeInfoOfGuid function. "	" HRESULT GetTypeInfoOfGuid(            /* [in] */ REFGUID guid,            /* [out] */ ITypeInfo **pptinfo); "	&lt;COM: HRESULT __stdcall  GetTypeInfoOfGuid(const GUID * const guid, ITypeInfo * * pptinfo) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetTypeInfoType: index _: ptkind	" Private - invoke the ITypeLib::GetTypeInfoType function. "	" HRESULT GetTypeInfoType(            /* [in] */ UINT index,            /* [out] */ TYPEKIND *ptkind); "	&lt;COM: HRESULT __stdcall  GetTypeInfoType(UINT index, TYPEKIND * ptkind) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeIsName: szNameBuf _: lHashVal _: pfName	" Private - invoke the ITypeLib::IsName function. "	" HRESULT IsName(            /* [in] */ LPOLESTR szNameBuf,            /* [in] */ ULONG lHashVal,            /* [out] */ BOOL *pfName); "	&lt;COM: HRESULT __stdcall  IsName(LPOLESTR szNameBuf, ULONG lHashVal, BOOL * pfName) = 10&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeReleaseTLibAttr: ptlibattr	" Private - invoke the ITypeLib::ReleaseTLibAttr function. "	" void ReleaseTLibAttr(            /* [in] */ TLIBATTR *ptlibattr); "	&lt;COM: void __stdcall  ReleaseTLibAttr(TLIBATTR * ptlibattr) = 12&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.COMDispatchInterfacePointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeGetIDsOfNames: riid _: rgszNames _: cNames _: lcid _: rgdispid	" Private - invoke the IDispatch::GetIDsOfNames function. "	" HRESULT GetIDsOfNames(            /* [in] */ REFIID riid,            /* [size_is][in] */ LPOLESTR *rgszNames,            /* [in] */ UINT cNames,            /* [in] */ LCID lcid,            /* [size_is][out][in] */ DISPID *rgdispid); "	&lt;COM: HRESULT __stdcall  GetIDsOfNames(const IID * const riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid) = 5&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: DISP_E_UNKNOWNNAME</body><body package="Com- Automation">invokeGetTypeInfo: itinfo _: lcid _: pptinfo	" Private - invoke the IDispatch::GetTypeInfo function. "	" HRESULT GetTypeInfo(            /* [in] */ UINT itinfo,            /* [in] */ LCID lcid,            /* [out] */ ITypeInfo **pptinfo); "	&lt;COM: HRESULT __stdcall  GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo * * pptinfo) = 4&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetTypeInfoCount: pctinfo	" Private - invoke the IDispatch::GetTypeInfoCount function. "	" HRESULT GetTypeInfoCount(            /* [out] */ UINT *pctinfo); "	&lt;COM: HRESULT __stdcall  GetTypeInfoCount(UINT * pctinfo) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeInvoke: dispidMember _: riid _: lcid _: wFlags _: pdispparams _: pvarResult _: pexcepinfo _: puArgErr	" Private - invoke the IDispatch::Invoke function. "	" HRESULT Invoke(            /* [in] */ DISPID dispidMember,            /* [in] */ REFIID riid,            /* [in] */ LCID lcid,            /* [in] */ WORD wFlags,            /* [unique][in] */ DISPPARAMS *pdispparams,            /* [unique][out][in] */ VARIANT *pvarResult,            /* [out] */ EXCEPINFO *pexcepinfo,            /* [out] */ UINT *puArgErr); "	&lt;COM: HRESULT __stdcall  Invoke(DISPID dispidMember, const IID * const riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr) = 6&gt;	" dispatch invocation error conditions has special exception generation support "	^self externalAccessFailedWith: _errorCode		allowHRESULT: DISP_E_EXCEPTION		or: DISP_E_TYPEMISMATCH</body></methods><methods><class-id>External.IRecordInfoPointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeGetField: pvData _: szFieldName _: pvarField        &lt;COM:  HRESULT __stdcall GetField(             /* [in] */ PVOID pvData,            /* [in] */ LPCOLESTR szFieldName,            /* [out] */ VARIANT *pvarField) = 10&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetFieldNames: pcNames _: rgBstrNames         &lt;COM:  HRESULT __stdcall GetFieldNames(             /* [out][in] */ ULONG *pcNames,            /* [length_is][size_is][out] */ BSTR *rgBstrNames) = 14&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetFieldNoCopy: pvData _: szFieldName _: pvarField _: ppvDataCArray        &lt;COM:  HRESULT __stdcall GetFieldNoCopy(             /* [in] */ PVOID pvData,            /* [in] */ LPCOLESTR szFieldName,            /* [out] */ VARIANT *pvarField,            /* [out] */ PVOID *ppvDataCArray) = 11&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetGuid: pguid        &lt;COM:  HRESULT __stdcall GetGuid( /* [out] */ GUID *pguid) = 6&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetName: pbstrName        &lt;COM:  HRESULT __stdcall GetName( /* [out] */ BSTR *pbstrName) = 7&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetSize: pcbSize        &lt;COM:  HRESULT __stdcall GetSize(/* [out] */ ULONG *pcbSize) = 8&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetTypeInfo: ppTypeInfo        &lt;COM:  HRESULT __stdcall GetTypeInfo( /* [out] */ ITypeInfo **ppTypeInfo) = 9&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeIsMatchingType: pRecordInfo         &lt;COM:  BOOL __stdcall IsMatchingType(             /* [in] */ IRecordInfo *pRecordInfo) = 15&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokePutField: wFlags _: pvData _: szFieldName _: pvarField        &lt;COM:  HRESULT __stdcall PutField(             /* [in] */ ULONG wFlags,            /* [out][in] */ PVOID pvData,            /* [in] */ LPCOLESTR szFieldName,            /* [in] */ VARIANT *pvarField) = 12&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokePutFieldNoCopy: wFlags _: pvData _: szFieldName _: pvarField        &lt;COM:  HRESULT __stdcall PutFieldNoCopy(             /* [in] */ ULONG wFlags,            /* [out][in] */ PVOID pvData,            /* [in] */ LPCOLESTR szFieldName,            /* [in] */ VARIANT *pvarField) = 13&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRecordClear: pvExisting        &lt;COM: HRESULT _stdcall RecordClear( /* [in] */ PVOID pvExisting) = 4&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRecordCopy: pvExisting _: pvNew        &lt;COM: HRESULT __stdcall RecordCopy(             /* [in] */ PVOID pvExisting,            /* [out] */ PVOID pvNew) = 5&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRecordCreate        &lt;COM:  PVOID __stdcall RecordCreate( void) = 16&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRecordCreateCopy: pvSource _: ppvDest        &lt;COM:  HRESULT __stdcall RecordCreateCopy(             /* [in] */ PVOID pvSource,            /* [out] */ PVOID *ppvDest) = 17&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRecordDestroy: pvRecord        &lt;COM:  HRESULT __stdcall RecordDestroy(             /* [in] */ PVOID pvRecord) = 18&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRecordInit: pvNew        &lt;COM: HRESULT __stdcall RecordInit( /* [out] */ PVOID pvNew) = 3&gt;	^ self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IClassFactory2Pointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeCreateInstanceLic: pUnkOuter _: pUnkReserved _: riid _: bstrKey _: ppvObj	" Private - invoke the IClassFactory2::CreateInstanceLic function. "	&lt;COM: HRESULT __stdcall  CreateInstanceLic(IUnknown * pUnkOuter, IUnknown * pUnkReserved, REFIID riid, BSTR bstrKey, PVOID * ppvObj) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeGetLicInfo: pLicInfo	" Private - invoke the IClassFactory2::GetLicInfo function."	&lt;COM: HRESULT __stdcall  GetLicInfo(LICINFO * pLicInfo) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRequestLicKey: dwReserved _: pBstrKey	" Private - invoke the IClassFactory2::RequestLicKey function."	&lt;COM: HRESULT __stdcall  RequestLicKey(DWORD dwReserved, BSTR * pBstrKey) = 6&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.ILicenseManagerPointer</class-id> <category>private-invocation</category><body package="Com- Automation">invokeCreateInstance: class _: pUnkOuter _: riid _: license _: ppvObject	" Private - invoke the ILicenseManager::CreateInstance function. "	&lt;COM: HRESULT __stdcall  CreateInstance(CLSID * class, IUnknown * pUnkOuter, REFIID riid, BSTR license, void * * ppvObject) = 4&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeIsDevelopment: class _: result	" Private - invoke the ILicenseManager::IsDevelopment function. "	&lt;COM: HRESULT __stdcall  IsDevelopment(CLSID * class, BOOL * result) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeQueryLicenseKey: class _: result	" Private - invoke the ILicenseManager::QueryLicenseKey function. "	&lt;COM: HRESULT __stdcall  QueryLicenseKey(CLSID * class, BSTR * result) = 5&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-type libraries</category><body package="Com- Automation">invokeGetRecordInfoFromTypeInfo: pTypeInfo _: ppRecInfo	&lt;C: HRESULT GetRecordInfoFromTypeInfo(		ITypeInfo  *pTypeInfo,		IRecordInfo** ppRecInfo )&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeLHashValOfNameSys: syskind _: lcid _: szName        " Private - WINOLEAUTAPI_(ULONG) LHashValOfNameSys(		SYSKIND syskind, LCID lcid, const OLECHAR * szName); "	&lt;C: ULONG __stdcall  LHashValOfNameSys(SYSKIND syskind, LCID lcid, const OLECHAR * szName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeLoadRegTypeLib: rguid        _: wVerMajor        _: wVerMinor        _: lcid        _: pptlib    " Private - invoke the LoadRegTypeLib function. "    "WINOLEAUTAPI LoadRegTypeLib(        REFGUID rguid,        WORD wVerMajor,        WORD wVerMinor,        LCID lcid,        ITypeLib * * pptlib);"	&lt;C: HRESULT __stdcall  LoadRegTypeLib(REFGUID rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib * * pptlib)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeLoadTypeLib: szFile _: pptlib    "Private - WINOLEAUTAPI LoadTypeLib(		const OLECHAR  *szFile, ITypeLib * * pptlib);"	&lt;C: HRESULT __stdcall  LoadTypeLib(const OLECHAR * szFile, ITypeLib * * pptlib)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeLoadTypeLibEx: szFile _: regkind _: pptlib	"HRESULT LoadTypeLibEx(   		LPCOLESTR  szFile,		REGKIND  regkind,  		ITypeLib **  pptlib   );"	&lt;C: HRESULT __stdcall  LoadTypeLibEx(LPCOLESTR szFile, REGKIND  regkind, ITypeLib * * pptlib)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeQueryPathOfRegTypeLib: guid        _: wMaj        _: wMin        _: lcid        _: lpbstrPathName    " Private - WINOLEAUTAPI        QueryPathOfRegTypeLib(            REFGUID guid,            unsigned short wMaj,            unsigned short wMin,            LCID lcid,            LPBSTR lpbstrPathName);"	&lt;C: HRESULT __stdcall  QueryPathOfRegTypeLib( 			REFGUID guid, 			unsigned short wMaj,			unsigned short wMin,			LCID lcid,			LPBSTR lpbstrPathName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRegisterTypeLibForUser: ptlib _: szFullPath _: szHelpDir	"Private. Invoke the RegisterTypeLibrary function."	"HRESULT RegisterTypeLibForUser(		ITypeLib * ptlib, 		OLECHAR * szFullPath, 		OLECHAR * szHelpDir ); "	&lt;C: HRESULT __stdcall  RegisterTypeLibForUser(ITypeLib * ptlib, OLECHAR * szFullPath, OLECHAR * szHelpDir )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRegisterTypeLibrary: ptlib _: szFullPath _: szHelpDir	"Private. Invoke the RegisterTypeLibrary function."	"HRESULT RegisterTypeLib(		ITypeLib * ptlib, 		OLECHAR * szFullPath, 		OLECHAR * szHelpDir ); "	&lt;C: HRESULT __stdcall  RegisterTypeLib(ITypeLib * ptlib, OLECHAR * szFullPath, OLECHAR * szHelpDir )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeUnRegisterTypeLibrary: libID _: wVerMajor _: wVerMinor _: lcid _: syskind        "Removes type library information from the system registry. Use this API to allow applications to properly uninstall themselves. In-process objects typically call this API from DllUnregisterServer. Raise an exception if an error occurs. No exception is raised when the library is not found (TYPE_E_REGISTRYACCESS, TYPE_E_CANTLOADLIBRARY).  Answer the result code. "	"HRESULT UnRegisterTypeLib( 		REFGUID libID, 		unsigned short wVerMajor, 		unsigned short wVerMinor,		LCID lcid, 		SYSKIND syskind 		);"	&lt;C: HRESULT __stdcall  UnRegisterTypeLib(REFGUID libID,  unsigned short wVerMajor, unsigned short wVerMinor, LCID lcid, SYSKIND syskind )&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: TYPE_E_REGISTRYACCESS 		or: TYPE_E_CANTLOADLIBRARY.</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-active object registration</category><body package="Com- Automation">invokeGetActiveObject: rclsid _: pvReserved _: ppunk		" Private - invoke the GetActiveObject function. "	"WINOLEAUTAPI GetActiveObject(		REFCLSID rclsid,		void * pvReserved,		IUnknown * * ppunk);"	&lt;C: HRESULT __stdcall  GetActiveObject(const CLSID * const rclsid, void * pvReserved, IUnknown * * ppunk)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: MK_E_UNAVAILABLE</body><body package="Com- Automation">invokeRegisterActiveObject: punk _: rclsid _: dwFlags _: pdwRegister		" Private - invoke the RegisterActiveObject function. "	"WINOLEAUTAPI RegisterActiveObject(		IUnknown FAR* punk,		REFCLSID rclsid,		DWORD dwFlags,		DWORD FAR* pdwRegister);"	&lt;C: HRESULT __stdcall  RegisterActiveObject(IUnknown * punk, const CLSID * const rclsid, DWORD dwFlags, DWORD * pdwRegister)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeRevokeActiveObject: dwRegister _: pvReserved		" Private - invoke the RevokeActiveObject function. "	"WINOLEAUTAPI RevokeActiveObject(		DWORD dwRegister,		void * pvReserved);"	&lt;C: HRESULT __stdcall  RevokeActiveObject(DWORD dwRegister, void * pvReserved)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-VARTYPE conversions</category><body package="Com- Automation">invokeVarBstrFromCy: cyIn _: lcid _: dwFlags _: pbstrOut	&lt;C: HRESULT _stdcall VarBstrFromCy(CURRENCY cyIn, LCID lcid,   ULONG dwFlags, BSTR *pbstrOut )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVarCyFromStr: strIn _: lcid _: dwFlags _: pcyOut	&lt;C: HRESULT __stdcall VarCyFromStr(   LPCOLESTR strIn, LCID lcid, ULONG dwFlags, CY *pcyOut)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVarR4FromR8: dblIn _: pfltOut	"Private - WINOLEAUTAPI VarR4FromR8(double dblIn, float FAR* pfltOut);"	&lt;C: HRESULT __stdcall  VarR4FromR8(double dblIn, float * pfltOut)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVarR8FromR4: fltIn _: pdblOut	"Private - WINOLEAUTAPI VarR8FromR4(float fltIn, double FAR* pdblOut);"	&lt;C: HRESULT __stdcall  VarR8FromR4(float fltIn, double * pdblOut)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-safe arrays</category><body package="Com- Automation">invokeGetRecordInfoFromGuids: rGuidTypeLib _: uVerMajor _: uVerMinor _: lcid _: rGuidTypeInfo _: ppRecInfo 	&lt;C: HRESULT _stdcall GetRecordInfoFromGuids(  			REFGUID  rGuidTypeLib,  			ULONG   uVerMajor,  			ULONG   uVerMinor,			LCID    lcid,			REFGUID rGuidTypeInfo,			IRecordInfo **ppRecInfo )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayAccessData: psa _: ppvData		" Private "	" WINOLEAUTAPI SafeArrayAccessData(SAFEARRAY * psa, void HUGEP* * ppvData);"	&lt;C: HRESULT __stdcall  SafeArrayAccessData(SAFEARRAY * psa, void _far * * ppvData)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayAllocData: psa	" Private "	"WINOLEAUTAPI SafeArrayAllocData(SAFEARRAY * psa);"	"&lt;api: SafeArrayAllocData structIn hresult&gt;"	&lt;C: HRESULT __stdcall  SafeArrayAllocData(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayAllocDescriptor: cDims _: ppsaOut		" Private "	"WINOLEAUTAPI	SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY * * ppsaOut);"	&lt;C: HRESULT __stdcall  SafeArrayAllocDescriptor(unsigned int cDims, SAFEARRAY * * ppsaOut)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayAllocDescriptorEx: vt _: cDims _: ppsaOut		" Private "	&lt;C: HRESULT __stdcall SafeArrayAllocDescriptorEx(VARTYPE  vt,  unsigned int  cDims, SAFEARRAY**  ppsaOut )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayCopy: psa _: ppsaOut		" Private "	"WINOLEAUTAPI SafeArrayCopy(	    SAFEARRAY * psa,	    SAFEARRAY * * ppsaOut);"	&lt;C: HRESULT __stdcall  SafeArrayCopy(SAFEARRAY * psa, SAFEARRAY * * ppsaOut)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayCreate: vt _: cDims _: rgsabound		" Private "	"WINOLEAUTAPI_(SAFEARRAY *) SafeArrayCreate(	    VARTYPE vt,	    unsigned int cDims,	    SAFEARRAYBOUND * rgsabound);"	&lt;C: SAFEARRAY *  __stdcall  SafeArrayCreate(VARTYPE vt, unsigned int cDims, SAFEARRAYBOUND * rgsabound)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayCreateEx: vt _: cDims _: rgsabound _: pvExtra		" Private "	&lt;C: SAFEARRAY *  __stdcall   SafeArrayCreateEx(VARTYPE  vt, unsigned int  cDims, SAFEARRAYBOUND * rgsabound,  PVOID  pvExtra)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayCreateVector: vt _: cDims _: rgsabound		" Private "	"SAFEARRAY * SafeArrayCreateVector(   		VARTYPE vt,             		long lLbound,		unsigned int cElements )"	&lt;C: SAFEARRAY *  __stdcall  SafeArrayCreateVector(VARTYPE vt, long cDims, unsigned int rgsabound)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayDestroy: psa	" Private "	"WINOLEAUTAPI SafeArrayDestroy(SAFEARRAY * psa);"	&lt;C: HRESULT __stdcall  SafeArrayDestroy(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayDestroyData: psa	" Private "	"WINOLEAUTAPI SafeArrayDestroyData(SAFEARRAY * psa);"	&lt;C: HRESULT __stdcall  SafeArrayDestroyData(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayDestroyDescriptor: psa	" Private "	"WINOLEAUTAPI SafeArrayDestroyDescriptor(SAFEARRAY * psa);"	&lt;C: HRESULT __stdcall  SafeArrayDestroyDescriptor(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayGetDim: psa	" Private "	"WINOLEAUTAPI_(unsigned int) SafeArrayGetDim(SAFEARRAY * psa);"	&lt;C: unsigned int __stdcall  SafeArrayGetDim(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayGetElement: psa _: rgIndices _: pv		" Private "	"WINOLEAUTAPI SafeArrayGetElement(	    SAFEARRAY * psa,	    long * rgIndices,	    void * pv);"	&lt;C: HRESULT __stdcall  SafeArrayGetElement(SAFEARRAY * psa, long * rgIndices, void * pv)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayGetElemsize: psa	" Private "	"WINOLEAUTAPI_(unsigned int) SafeArrayGetElemsize(SAFEARRAY * psa);"	&lt;C: unsigned int __stdcall  SafeArrayGetElemsize(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayGetLBound: psa _: nDim _: plLbound		" Private "	"WINOLEAUTAPI	SafeArrayGetLBound(SAFEARRAY * psa, unsigned int nDim, long * plLbound);"	&lt;C: HRESULT __stdcall  SafeArrayGetLBound(SAFEARRAY * psa, unsigned int nDim, long * plLbound)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation"> invokeSafeArrayGetRecordInfo: psa _: prinfo		&lt;C: HRESULT SafeArrayGetRecordInfo(  				  SAFEARRAY *psa, 			  IRecordInfo **prinfo  )&gt;	^ self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayGetUBound: psa _: nDim _: plUbound		" Private "	"WINOLEAUTAPI	SafeArrayGetUBound(SAFEARRAY * psa, unsigned int nDim, long * plUbound);"	&lt;C: HRESULT __stdcall  SafeArrayGetUBound(SAFEARRAY * psa, unsigned int nDim, long * plUbound)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayGetVartype: psa _: pvt	" Private "	&lt;C: HRESULT SafeArrayGetVartype(  				SAFEARRAY *psa, 				VARTYPE *pvt  )&gt;		^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayLock: psa	" Private "	"WINOLEAUTAPI SafeArrayLock(SAFEARRAY * psa);"	&lt;C: HRESULT __stdcall  SafeArrayLock(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayPtrOfIndex: psa index: rgIndices buffer: ppvData	" Private "	&lt;C: HRESULT __stdcall SafeArrayPtrOfIndex(SAFEARRAY *psa,long *rgIndices,void **ppvData)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayPutElement: psa _: rgIndices _: pv	"Private. pv: Pointer to the data to assign to the array. The variant types VT_DISPATCH, VT_UNKNOWN, and VT_BSTR are pointers, and do not require another level of indirection."	"WINOLEAUTAPI SafeArrayPutElement(	    SAFEARRAY * psa,	    long * rgIndices,	    void * pv);"	&lt;C: HRESULT __stdcall  SafeArrayPutElement(SAFEARRAY * psa, long * rgIndices, void * pv)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayRedim: psa _: psaboundNew	" Private "	"WINOLEAUTAPI SafeArrayRedim(SAFEARRAY * psa, SAFEARRAYBOUND * psaboundNew);"	&lt;C: HRESULT __stdcall  SafeArrayRedim(SAFEARRAY * psa, SAFEARRAYBOUND * psaboundNew)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArraySetRecordInfo: psa _: pRecordInfo 	" Private "	"WINOLEAUTAPI SafeArrayUnlock(SAFEARRAY * psa);"	&lt;C: HRESULT SafeArraySetRecordInfo(  SAFEARRAY *psa,   IRecordInfo *pRecordInfo  )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayUnaccessData: psa	" Private "	"WINOLEAUTAPI SafeArrayUnaccessData(SAFEARRAY * psa);"	&lt;C: HRESULT __stdcall  SafeArrayUnaccessData(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSafeArrayUnlock: psa	" Private "	"WINOLEAUTAPI SafeArrayUnlock(SAFEARRAY * psa);"	&lt;C: HRESULT __stdcall  SafeArrayUnlock(SAFEARRAY * psa)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-BSTR</category><body package="Com- Automation">invokeSysAllocString: aString		" Private - WINOLEAUTAPI_(BSTR) SysAllocString(const OLECHAR *);"	&lt;C: BSTR __stdcall  SysAllocString(const OLECHAR * )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSysAllocString: pch len: cch	&lt;C: BSTR __stdcall SysAllocStringLen(const OLECHAR   *pch, unsigned int  cch)&gt;</body><body package="Com- Automation">invokeSysFreeString: bstr		" Private - WINOLEAUTAPI_(void) SysFreeString(BSTR)"	&lt;C: void __stdcall  SysFreeString(BSTR)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSysReAllocString: pbstr _: sz	"Private. Invoke SysReAllocString."	"WINOLEAUTAPI_(INT)  SysReAllocString(BSTR *, const OLECHAR *)"	"HRESULT SysReAllocString( 		BSTR * pbstr, 		OLECHAR * sz ); "	&lt;C: INT __stdcall  SysReAllocString(BSTR *pbstr, const OLECHAR * sz)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSysStringLen: bstr		" Private - WINOLEAUTAPI_(unsigned int) SysStringLen(BSTR)"	&lt;C: unsigned int __stdcall  SysStringLen(BSTR)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-variants</category><body package="Com- Automation">invokeVariantChangeType: pvargDest _: pvargSrc _: wFlags _: vt	" Private "	"WINOLEAUTAPI VariantChangeType(		VARIANTARG * pvargDest,		VARIANTARG * pvarSrc,		unsigned short wFlags,		VARTYPE vt);"	&lt;C: HRESULT __stdcall  VariantChangeType(VARIANTARG * pvargDest, VARIANTARG * pvargSrc, unsigned short wFlags, VARTYPE vt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVariantChangeTypeEx: pvargDest _: pvarSrc _: lcid _: wFlags _: vt	" Private "	"WINOLEAUTAPI VariantChangeTypeEx(		VARIANTARG * pvargDest,		VARIANTARG * pvarSrc,		LCID lcid,		unsigned short wFlags,		VARTYPE vt);"	&lt;C: HRESULT __stdcall  VariantChangeTypeEx(VARIANTARG * pvargDest, VARIANTARG * pvarSrc, LCID lcid, unsigned short wFlags, VARTYPE vt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVariantClear: pvarg	" Private "    "WINOLEAUTAPI VariantClear(VARIANTARG * pvarg);"	&lt;C: HRESULT __stdcall  VariantClear(VARIANTARG * pvarg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVariantCopy: pvargDest _: pvargSrc	" Private "	"WINOLEAUTAPI VariantCopy(		VARIANTARG * pvargDest,		VARIANTARG * pvargSrc);"	&lt;C: HRESULT __stdcall  VariantCopy(VARIANTARG * pvargDest, VARIANTARG * pvargSrc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVariantCopyInd: pvarDest _: pvargSrc	" Private "	"WINOLEAUTAPI VariantCopyInd(		VARIANT * pvarDest,		VARIANTARG * pvargSrc);"	&lt;C: HRESULT __stdcall  VariantCopyInd(VARIANT * pvarDest, VARIANTARG * pvargSrc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVariantInit: pvarg	" Private "    "WINOLEAUTAPI_(void) VariantInit(VARIANTARG * pvarg);"	&lt;C: void __stdcall  VariantInit(VARIANTARG * pvarg)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-time</category><body package="Com- Automation">invokeDosDateTimeToVariantTime: wDosDate        _: wDosTime        _: pvtime	"Private. Invoke DosDateTimeToVariantTime."    "WINOLEAUTAPI_(int) DosDateTimeToVariantTime(            unsigned short wDosDate,            unsigned short wDosTime,            double * pvtime);"	&lt;C: int __stdcall DosDateTimeToVariantTime(			unsigned short wDosDate,			unsigned short wDosTime,			double * pvtime)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeSystemTimeToVariantTime: lpSystemTime        _: pvtime	"Private. Invoke SystemTimeToVariantTime."	"WINOLEAUTAPI_(INT) SystemTimeToVariantTime(		LPSYSTEMTIME lpSystemTime, 		DOUBLE *pvtime);"	&lt;C: int __stdcall SystemTimeToVariantTime(		LPSYSTEMTIME lpSystemTime, 		DOUBLE *pvtime)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVariantTimeToDosDateTime: vtime        _: pwDosDate        _: pwDosTime    "Private. Invoke VariantTimeToDosDateTime. "    "WINOLEAUTAPI_(int) VariantTimeToDosDateTime(            double vtime,            unsigned short * pwDosDate,            unsigned short * pwDosTime);"	&lt;C: int __stdcall VariantTimeToDosDateTime(		double vtime,		unsigned short * pwDosDate,		unsigned short * pwDosTime)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Automation">invokeVariantTimeToSystemTime: vtime        _: lpSystemTime    "Private. Invoke VariantTimeToSystemTime. "    "INT VariantTimeToSystemTime (		double  vtime,              		LPSYSTEMTIME  lpSystemTime );"	&lt;C: int __stdcall VariantTimeToSystemTime (		double  vtime,              		LPSYSTEMTIME  lpSystemTime )&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-fonts</category><body package="Com- Automation">invokeOleCreateFontIndirect: lpFontDesc iid: riid result: lplpvObj	&lt;C: HRESULT OleCreateFontIndirect( 		/*_In_ */  LPFONTDESC lpFontDesc,  		/*_In_ */  REFIID riid,  		/*_Out_*/  LPVOID *lplpvObj)&gt;</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-pictures</category><body package="Com- Automation">invokeOleCreatePictureIndirect: lpPictDesc iid: riid owned: fOwn result: lplpvObj&lt;C: HRESULT OleCreatePictureIndirect(  		/*_In_*/   PICTDESC *lpPictDesc,  		/*_In_*/  REFIID riid,  		/*_In_*/   BOOL fOwn,  		/*_Out_*/  LPVOID *lplpvObj)&gt;</body></methods><methods><class-id>External.Win32KernelDLL</class-id> <category>private-invocation</category><body package="Com- Automation">invokeGetLocaleInfo: aLocale lcType: LCType  lpLCData: lpLCData cchData: cchData	&lt;C: int GetLocaleInfoW( LCID aLocale, LCTYPE LCType,	LPWSTR lpLCData, int cchData)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-safe arrays</category><body package="Com- Automation">HUGEP	&lt;C: #define HUGEP &gt;</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>structs</category><body package="Com- Automation">FONTDESC	&lt;C: typedef struct tagFONTDESC {  		UINT     cbSizeofstruct;  		LPOLESTR lpstrName;  		CY       cySize;  		SHORT    sWeight;  		SHORT    sCharset;  		BOOL     fItalic;  		BOOL     fUnderline;  		BOOL     fStrikethrough; } FONTDESC&gt;</body><body package="Com- Automation">PICTDESC&lt;C: typedef struct tagPICTDESC {  UINT  cbSizeofstruct;  UINT  picType;  union {    struct {      HBITMAP  hbitmap;      HPALETTE hpal;    } bmp;    struct {      HMETAFILE hmeta;      int       xExt;      int       yExt;    } wmf;    struct {      HICON hicon;    } icon;    struct {      HENHMETAFILE hemf;    } emf;  } u;} PICTDESC&gt;</body></methods><methods><class-id>External.Win32KernelDLL</class-id> <category>types</category><body package="Com- Automation">LCTYPE	&lt;C: typedef unsigned int LCTYPE&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>types-automation</category><body package="Com- Automation">BLOB	&lt;C: typedef struct tagBLOB BLOB&gt;</body><body package="Com- Automation">CONNECTDATA	&lt;C: typedef struct tagCONNECTDATA CONNECTDATA&gt;</body><body package="Com- Automation">IEnumVARIANT	"&lt;C: typedef struct __IEnumVARIANT IEnumVARIANT&gt;"	&lt;C: typedef struct __IAnonymous IEnumVARIANT&gt;</body><body package="Com- Automation">LPBLOB	&lt;C: typedef struct tagBLOB * LPBLOB&gt;</body><body package="Com- Automation">LPBSTR	&lt;C: typedef BSTR * LPBSTR&gt;</body><body package="Com- Automation">LPCONNECTDATA	&lt;C: typedef struct tagCONNECTDATA * LPCONNECTDATA&gt;</body><body package="Com- Automation">LPDISPATCH	&lt;C: typedef IDispatch * LPDISPATCH&gt;</body><body package="Com- Automation">LPSAFEARRAY	&lt;C: typedef SAFEARRAY* LPSAFEARRAY&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>enums-automation</category><body package="Com- Automation">VARENUM	&lt;C: enum VARENUM {			VT_EMPTY, 			VT_NULL, 			VT_I2, 			VT_I4, 			VT_R4, 			VT_R8, 			VT_CY, 			VT_DATE, 			VT_BSTR, 			VT_DISPATCH, 			VT_ERROR, 			VT_BOOL, 			VT_VARIANT, 			VT_UNKNOWN, 			VT_I1 = 16, 			VT_UI1, 			VT_UI2, 			VT_UI4, 			VT_I8, 			VT_UI8, 			VT_INT, 			VT_UINT, 			VT_VOID, 			VT_HRESULT, 			VT_PTR, 			VT_SAFEARRAY, 			VT_CARRAY, 			VT_USERDEFINED, 			VT_LPSTR, 			VT_LPWSTR, 			VT_FILETIME = 64, 			VT_BLOB, 			VT_STREAM, 			VT_STORAGE, 			VT_STREAMED_OBJECT, 			VT_STORED_OBJECT, 			VT_BLOB_OBJECT, 			VT_CF, 			VT_CLSID		}&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>unions-automation customizations</category><body package="Com- Automation">VariantValue		" This type definition is extracted from tagVARIANT's definition		of the union field containing the value of a VARIANT[ARG]. "	&lt;C: union VariantValue {                LONGLONG llVal;                LONG lVal;		      	                BYTE bVal;				                SHORT iVal;				                FLOAT fltVal;				                DOUBLE dblVal;			                VARIANT_BOOL boolVal; /*new, same as bool?*/                _VARIANT_BOOL bool;	                SCODE scode;			                CY cyVal;				                DATE date;				                BSTR bstrVal;			                IUnknown *punkVal;		                IDispatch *pdispVal;		                SAFEARRAY *parray;	                BYTE *pbVal;			                SHORT *piVal;			                LONG *plVal;				                LONGLONG *pllVal;                FLOAT *pfltVal;			                DOUBLE *pdblVal;		                VARIANT_BOOL *pboolVal;                _VARIANT_BOOL *pbool;	                SCODE *pscode;			                CY *pcyVal;				                DATE *pdate;				                BSTR *pbstrVal;			                IUnknown **ppunkVal;	                IDispatch **ppdispVal;	                SAFEARRAY **pparray;	                VARIANT *pvarVal;                PVOID byref;                CHAR cVal;                USHORT uiVal;							                ULONG ulVal;							                ULONGLONG ullVal;                INT intVal;                UINT uintVal;                DECIMAL *pdecVal;                CHAR *pcVal;                USHORT *puiVal;	                ULONG *pulVal;                ULONGLONG *pullVal;                INT *pintVal;                UINT *puintVal;                struct __tagBRECORD {				                    PVOID pvRecord;                    IRecordInfo *pRecInfo;                    } recordData;                }&gt;</body></methods><methods><class-id>External.COMInterfaceVTableSignatures</class-id> <category>vtables-automation</category><body package="Com- Automation">__IConnectionPointContainerVtbl	"	&lt;C: struct __IConnectionPointContainer {			struct __IConnectionPointContainerVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IConnectionPointContainer IConnectionPointContainer&gt;	"	&lt;C: struct __IConnectionPointContainerVtbl {			HRESULT ( __stdcall * QueryInterface)(IConnectionPointContainer * This, const IID * const riid, LPVOID * ppvObj);			ULONG ( __stdcall * AddRef)(IConnectionPointContainer * This);			ULONG ( __stdcall * Release)(IConnectionPointContainer * This);			HRESULT ( __stdcall * EnumConnectionPoints)(IConnectionPointContainer * This, LPENUMCONNECTIONPOINTS * ppEnum);			HRESULT ( __stdcall * FindConnectionPoint)(IConnectionPointContainer * This, const IID * const iid, LPCONNECTIONPOINT * ppCP);		}&gt;</body><body package="Com- Automation">__IConnectionPointVtbl	"	&lt;C: struct __IConnectionPoint {			struct __IConnectionPointVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IConnectionPoint IConnectionPoint&gt;	"	&lt;C: struct __IConnectionPointVtbl {			HRESULT ( __stdcall * QueryInterface)(IConnectionPoint * This, const IID * const riid, LPVOID * ppvObj);			ULONG ( __stdcall * AddRef)(IConnectionPoint * This);			ULONG ( __stdcall * Release)(IConnectionPoint * This);			HRESULT ( __stdcall * GetConnectionInterface)(IConnectionPoint * This, IID * pIID);			HRESULT ( __stdcall * GetConnectionPointContainer)(IConnectionPoint * This, IConnectionPointContainer * * ppCPC);			HRESULT ( __stdcall * Advise)(IConnectionPoint * This, LPUNKNOWN pUnkSink, DWORD * pdwCookie);			HRESULT ( __stdcall * Unadvise)(IConnectionPoint * This, DWORD dwCookie);			HRESULT ( __stdcall * EnumConnections)(IConnectionPoint * This, LPENUMCONNECTIONS * ppEnum);		}&gt;</body><body package="Com- Automation">__IDispatchVtbl	"	&lt;C: struct __IDispatch {			struct __IDispatchVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IDispatch IDispatch&gt;	"	&lt;C: struct __IDispatchVtbl {			HRESULT ( __stdcall * QueryInterface)(IDispatch * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IDispatch * This);			ULONG ( __stdcall * Release)(IDispatch * This);			HRESULT ( __stdcall * GetTypeInfoCount)(IDispatch * This, UINT * pctinfo);			HRESULT ( __stdcall * GetTypeInfo)(IDispatch * This, UINT itinfo, LCID lcid, ITypeInfo * * pptinfo);			HRESULT ( __stdcall * GetIDsOfNames)(IDispatch * This, const IID * const riid, LPOLESTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid);			HRESULT ( __stdcall * Invoke)(IDispatch * This, DISPID dispidMember, const IID * const riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);		}&gt;</body><body package="Com- Automation">__IProvideClassInfoVtbl	"	&lt;C: struct __IProvideClassInfo {			struct __IProvideClassInfoVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IProvideClassInfo IProvideClassInfo&gt;	"	&lt;C: struct __IProvideClassInfoVtbl {			HRESULT ( __stdcall * QueryInterface)(IProvideClassInfo * This, const IID * const riid, LPVOID * ppvObj);			ULONG ( __stdcall * AddRef)(IProvideClassInfo * This);			ULONG ( __stdcall * Release)(IProvideClassInfo * This);			HRESULT ( __stdcall * GetClassInfo)(IProvideClassInfo * This, LPTYPEINFO * ppTI);		}&gt;</body><body package="Com- Automation">__ITypeCompVtbl	"	&lt;C: struct __ITypeComp {			struct __ITypeCompVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __ITypeComp ITypeComp&gt;	"	&lt;C: struct __ITypeCompVtbl {			HRESULT ( __stdcall * QueryInterface)(ITypeComp * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(ITypeComp * This);			ULONG ( __stdcall * Release)(ITypeComp * This);			HRESULT ( __stdcall * Bind)(ITypeComp * This, LPOLESTR szName, ULONG lHashVal, WORD fFlags, ITypeInfo * * pptinfo, DESCKIND * pdesckind, BINDPTR * pbindptr);			HRESULT ( __stdcall * BindType)(ITypeComp * This, LPOLESTR szName, ULONG lHashVal, ITypeInfo * * pptinfo, ITypeComp * * pptcomp);		}&gt;</body><body package="Com- Automation">__ITypeInfoVtbl	"	&lt;C: struct __ITypeInfo {			struct __ITypeInfoVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __ITypeInfo ITypeInfo&gt;	"	&lt;C: struct __ITypeInfoVtbl {			HRESULT ( __stdcall * QueryInterface)(ITypeInfo * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(ITypeInfo * This);			ULONG ( __stdcall * Release)(ITypeInfo * This);			HRESULT ( __stdcall * GetTypeAttr)(ITypeInfo * This, TYPEATTR * * pptypeattr);			HRESULT ( __stdcall * GetTypeComp)(ITypeInfo * This, ITypeComp * * pptcomp);			HRESULT ( __stdcall * GetFuncDesc)(ITypeInfo * This, UINT index, FUNCDESC * * pppfuncdesc);			HRESULT ( __stdcall * GetVarDesc)(ITypeInfo * This, UINT index, VARDESC * * ppvardesc);			HRESULT ( __stdcall * GetNames)(ITypeInfo * This, MEMBERID memid, BSTR * rgbstrNames, UINT cMaxNames, UINT * pcNames);			HRESULT ( __stdcall * GetRefTypeOfImplType)(ITypeInfo * This, UINT index, HREFTYPE * hpreftype);			HRESULT ( __stdcall * GetImplTypeFlags)(ITypeInfo * This, UINT index, INT * pimpltypeflags);			HRESULT ( __stdcall * GetIDsOfNames)(ITypeInfo * This, OLECHAR * * rglpszNames, UINT cNames, MEMBERID * rgmemid);			HRESULT ( __stdcall * Invoke)(ITypeInfo * This, void * pvInstance, MEMBERID memid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr);			HRESULT ( __stdcall * GetDocumentation)(ITypeInfo * This, MEMBERID memid, BSTR * pbstrName, BSTR * pbstrDocString, DWORD * pdwHelpContext, BSTR * pbstrHelpFile);			HRESULT ( __stdcall * GetDllEntry)(ITypeInfo * This, MEMBERID memid, INVOKEKIND invkind, BSTR * pbstrDllName, BSTR * pbstrName, WORD * pwOrdinal);			HRESULT ( __stdcall * GetRefTypeInfo)(ITypeInfo * This, HREFTYPE hreftype, ITypeInfo * * pptinfo);			HRESULT ( __stdcall * AddressOfMember)(ITypeInfo * This, MEMBERID memid, INVOKEKIND invkind, void * * ppv);			HRESULT ( __stdcall * CreateInstance)(ITypeInfo * This, IUnknown * puncOuter, const IID * const riid, void * * ppvObj);			HRESULT ( __stdcall * GetMops)(ITypeInfo * This, MEMBERID memid, BSTR * pbstrMops);			HRESULT ( __stdcall * GetContainingTypeLib)(ITypeInfo * This, ITypeLib * * pptlib, UINT * pindex);			void ( __stdcall * ReleaseTypeAttr)(ITypeInfo * This, TYPEATTR * ptypeattr);			void ( __stdcall * ReleaseFuncDesc)(ITypeInfo * This, FUNCDESC * pfuncdesc);			void ( __stdcall * ReleaseVarDesc)(ITypeInfo * This, VARDESC * pvardesc);		}&gt;</body><body package="Com- Automation">__ITypeLibVtbl	"	&lt;C: struct __ITypeLib {			struct __ITypeLibVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __ITypeLib ITypeLib&gt;	"	&lt;C: struct __ITypeLibVtbl {			HRESULT ( __stdcall * QueryInterface)(ITypeLib * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(ITypeLib * This);			ULONG ( __stdcall * Release)(ITypeLib * This);			UINT ( __stdcall * GetTypeInfoCount)(ITypeLib * This);			HRESULT ( __stdcall * GetTypeInfo)(ITypeLib * This, UINT index, ITypeInfo * * ppitinfo);			HRESULT ( __stdcall * GetTypeInfoType)(ITypeLib * This, UINT index, TYPEKIND * ptkind);			HRESULT ( __stdcall * GetTypeInfoOfGuid)(ITypeLib * This, const GUID * const guid, ITypeInfo * * pptinfo);			HRESULT ( __stdcall * GetLibAttr)(ITypeLib * This, TLIBATTR * * pptlibattr);			HRESULT ( __stdcall * GetTypeComp)(ITypeLib * This, ITypeComp * * pptcomp);			HRESULT ( __stdcall * GetDocumentation)(ITypeLib * This, INT index, BSTR * pbstrName, BSTR * pbstrDocString, DWORD * pdwHelpContext, BSTR * pbstrHelpFile);			HRESULT ( __stdcall * IsName)(ITypeLib * This, LPOLESTR szNameBuf, ULONG lHashVal, BOOL * pfName);			HRESULT ( __stdcall * FindName)(ITypeLib * This, LPOLESTR szNameBuf, ULONG lHashVal, ITypeInfo * * rgptinfo, MEMBERID * rgmemid, USHORT * pcFound);			void ( __stdcall * ReleaseTLibAttr)(ITypeLib * This, TLIBATTR * ptlibattr);		}&gt;</body></methods><methods><class-id>Core.CommandLineInterest class</class-id> <category>dependencies-pragma</category><body package="Com- Automation">setCOMDefaultDirectory: comDirectoryStream 	"Set the COM default directory from the command line. This is useful for images which do not allow	 access to VisualWorks settings. Leave it unchanged if it is unspecified."	&lt;triggerAtSystemEvent: #returnFromSnapshot option: '-COMPath'&gt;	| paths |	paths := CommandLineInterest argumentsFrom: comDirectoryStream.	paths isEmpty 		ifFalse: [COMSessionManager defaultCOMDirectoryName: paths first]</body><body package="Com- Automation">setTypeLibSearchPaths: typeLibDirectoryStream 	&lt;triggerAtSystemEvent: #returnFromSnapshot option: '-typeLibPath'&gt;	COMSessionManager typeLibSearchPaths: (CommandLineInterest argumentsFrom: typeLibDirectoryStream)</body></methods><methods><class-id>External.IConnectionPointContainerPointer</class-id> <category>interface operations</category><body package="Com- Automation">EnumConnectionPoints: resultReference		" Invoke the IConnectionPointContainer::EnumConnectionPoints function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumConnectionPoints.	hresult := self invokeEnumConnectionPoints: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">FindConnectionPoint: iid _: resultReference		" Invoke the IConnectionPointContainer::FindConnectionPoint function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IConnectionPointPointer resultValueBuffer.	hresult := self invokeFindConnectionPoint: iid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.IConnectionPointContainerPointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IConnectionPointContainer.	self updateAndRegister</body></methods><methods><class-id>External.IConnectionPointPointer</class-id> <category>interface operations</category><body package="Com- Automation">Advise: anIUnknownSink _: resultReference	" Invoke the IConnectionPoint::Advise function.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #DWORD.		[self invokeAdvise: anIUnknownSink asPointerParameter		_: resultBuffer asPointerParameter]			on: COMError			do: [:ex | ^ex hresult].	resultReference value: resultBuffer contents.	^S_OK</body><body package="Com- Automation">EnumConnections: resultReference		" Invoke the IConnectionPoint::EnumConnections function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumConnections.	hresult := self invokeEnumConnections: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetConnectionInterface: resultReference		" Invoke the IConnectionPoint::GetConnectionInterface function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := GUID resultValueBuffer.	hresult := self invokeGetConnectionInterface: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetConnectionPointContainer: resultReference		" Invoke the IConnectionPoint::GetConnectionPointContainer function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IConnectionPointContainerPointer resultValueBuffer.	hresult := self invokeGetConnectionPointContainer: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.IConnectionPointPointer class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	"must be: xContainerPointer, xPointer, xPoint and xPointContainer"	^super prerequisitesForLoading		addLast: IConnectionPointContainerPointer;		yourself</body></methods><methods><class-id>External.IConnectionPointPointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IConnectionPoint.	self updateAndRegister</body></methods><methods><class-id>External.IProvideClassInfoPointer</class-id> <category>interface operations</category><body package="Com- Automation">GetClassInfo: resultReference	" Invoke the IProvideClassInfo::GetClassInfo function.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer |	resultBuffer := ITypeInfoPointer resultValueBuffer.	[self invokeGetClassInfo: resultBuffer asPointerParameter] on: COMError		do: [:ex | ^ex hresult].	resultReference value: resultBuffer contents.	^S_OK</body></methods><methods><class-id>External.IProvideClassInfoPointer class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: IConnectionPointPointer;		"?"		yourself</body></methods><methods><class-id>External.IProvideClassInfoPointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IProvideClassInfo.	self updateAndRegister</body></methods><methods><class-id>External.ITypeCompPointer</class-id> <category>interface operations</category><body package="Com- Automation">Bind: szName _: lHashVal _: wFlags _: typeInfoResultReference _: descKindResultReference _: bindPtrResultReference		" Invoke the ITypeComp::Bind function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult typeInfoResultBuffer descKindBuffer bindPtrBuffer 	  descKind  aBindPtr aPointer structName |	typeInfoResultBuffer := ITypeInfoPointer resultValueBuffer.	descKindBuffer := COMExternalInterface scalarResultBufferFor: #DESCKIND.	bindPtrBuffer :=  COMExternalInterface structureResultBufferFor: #BINDPTR.	hresult := self invokeBind: szName asUnicodeParameter		_: lHashVal		_: wFlags		_: typeInfoResultBuffer asPointerParameter		_: descKindBuffer asPointerParameter		_: bindPtrBuffer asPointerParameter.	typeInfoResultReference value: typeInfoResultBuffer contents.	descKind :=  descKindBuffer contents.	descKindResultReference value: descKind.	aBindPtr := bindPtrBuffer contents.  " this is an address in COM memory "	descKind = DESCKIND_FUNCDESC		ifTrue: [ 			aPointer := aBindPtr memberAt: #lpfuncdesc.			structName := #FUNCDESC ].	descKind = DESCKIND_VARDESC		ifTrue: [ 			aPointer := aBindPtr memberAt: #lpvardesc.			structName := #VARDESC ].	structName notNil 		ifTrue: [			| aCOMAddress aStructure |			" This is all kinda tricky.  It may be better to just bring the structure				data into Smalltalk memory at this point and release the				backing COM memory immediately.  But for now we'll do it this way "			aCOMAddress := COMMemoryAddress fromPointer: aPointer.			"Assert isTrue: [ aCOMAddress hasFinalization not ]."			aStructure := COMStructure createStructureNamed: structName 				atAddress: aCOMAddress.			aStructure needsFinalization.  " We own this and have to return it to COM. "			bindPtrResultReference value: aStructure ].	^hresult</body><body package="Com- Automation">BindType: szName _: lHashVal _: typeInfoResultReference _: typeCompResultReference 		" Invoke the ITypeComp::BindType function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult typeInfoResultBuffer typeCompResultValue |	typeInfoResultBuffer := ITypeInfoPointer resultValueBuffer.	typeCompResultValue := NULL.   " (reserved for future use) "	hresult := self invokeBindType: szName asUnicodeParameter		_: lHashVal		_: typeInfoResultBuffer asPointerParameter		_: typeCompResultValue. 	typeInfoResultReference value: typeInfoResultBuffer contents.	^hresult</body></methods><methods><class-id>External.ITypeCompPointer class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: IProvideClassInfoPointer;		yourself</body></methods><methods><class-id>External.ITypeCompPointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_ITypeComp.	self updateAndRegister</body></methods><methods><class-id>External.ITypeInfoPointer</class-id> <category>interface operations</category><body package="Com- Automation">AddressOfMember: memberID _: invkind _: resultReference		" Invoke the ITypeInfo::AddressOfMember function.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface scalarResultBufferFor: CVoidType void pointerType.	hresult := self invokeAddressOfMember: memberID 		_:  invkind 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">CreateInstance: controllingUnknown _: iid _: resultReference		" Invoke the ITypeInfo::CreateInstance function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := self invokeCreateInstance: controllingUnknown asPointerParameter		_:  iid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetContainingTypeLib: typeLibraryReference _: indexReference		" Invoke the ITypeInfo::GetContainingTypeLib function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer indexValueBuffer |	resultBuffer := ITypeLibPointer resultValueBuffer.	indexValueBuffer := COMExternalInterface scalarResultBufferFor: #UINT.	hresult := self invokeGetContainingTypeLib: resultBuffer asPointerParameter		_: indexValueBuffer asPointerParameter.	typeLibraryReference value: resultBuffer contents.	indexReference value: indexValueBuffer contents.	^hresult</body><body package="Com- Automation">GetDllEntry: memberID _:  invkind _: dllNameReference _: entryPointNameReference _: ordinalReference		" Invoke the ITypeInfo::GetDllEntry function.		Raise an exception if an error occurs.  Answer the result code. "	| dllNameBuffer entryPointNameBuffer pwOrdinalBuffer hresult |	dllNameBuffer := BSTR resultValueBuffer.	entryPointNameBuffer := BSTR resultValueBuffer.	pwOrdinalBuffer := COMExternalInterface scalarResultBufferFor: #WORD.	hresult := self invokeGetDllEntry: memberID 		_:  invkind 		_: dllNameBuffer asPointerParameter 		_: entryPointNameBuffer asPointerParameter 		_: pwOrdinalBuffer asPointerParameter.	dllNameReference value: dllNameBuffer contents.	entryPointNameReference value: entryPointNameBuffer contents.	ordinalReference value: pwOrdinalBuffer contents.	^hresult</body><body package="Com- Automation">GetDocumentation: memberID _: nameReference _: docStringReference _: helpContextIDReference _: helpFileReference		" Invoke the ITypeInfo::GetDocumentation function.		Raise an exception if an error occurs.  Answer the result code. "	| nameBuffer docStringBuffer helpContextIDBuffer helpFileBuffer hresult |	nameReference notNil		ifTrue: [ nameBuffer := BSTR resultValueBuffer ].	docStringReference notNil 		ifTrue: [ docStringBuffer := BSTR resultValueBuffer ].	helpContextIDReference notNil 		ifTrue: [ helpContextIDBuffer := COMExternalInterface scalarResultBufferFor: #DWORD ].	helpFileReference notNil		ifTrue: [ helpFileBuffer := BSTR resultValueBuffer ].	hresult := self invokeGetDocumentation: memberID 		_: nameBuffer asPointerParameter 		_: docStringBuffer asPointerParameter		_: helpContextIDBuffer asPointerParameter		_: helpFileBuffer asPointerParameter.	nameReference notNil		ifTrue: [ nameReference value: nameBuffer contents ].	docStringReference notNil 		ifTrue: [ docStringReference value: docStringBuffer contents ].	helpContextIDReference notNil 		ifTrue: [ helpContextIDReference value: helpContextIDBuffer contents ].	helpFileReference notNil		ifTrue: [ helpFileReference value: helpFileBuffer contents ].	^hresult</body><body package="Com- Automation">GetFuncDesc: index _: resultReference        " Invoke the ITypeInfo::GetFuncDesc function.        Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult aFuncDesc |	resultBuffer := COMStructure resultValuePointerBufferFor: #FUNCDESC.	hresult := self invokeGetFuncDesc: index		_: resultBuffer asPointerParameter.	aFuncDesc := resultBuffer contents.	aFuncDesc checkToEnsureExternalMemoryBacking.   " Have to leave it out in COM memory... "	" Don't track finalization on the address, because it can't be		released properly independently of the containing ITypeInfo "	"Assert isTrue: [		aFuncDesc hasFinalization		and: [ aFuncDesc structure hasFinalization not ] ]."	resultReference value: aFuncDesc.	^hresult</body><body package="Com- Automation">GetIDsOfNames: rglpszNames _: cNames _: resultReference		" Invoke the ITypeInfo::GetIDsOfNames function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult namesBuffer dispidArrayBuffer dispidList "dispidPointer"  |	"Assert isTrue: [ cNames = rglpszNames size ]."	namesBuffer := COMExternalInterface createUnicodeArrayBuffer: rglpszNames.	dispidArrayBuffer := COMExternalInterface arrayResultBufferFor: #DISPID count: cNames.	"?? dispidArrayBuffer atAllPut: DISPID_UNKNOWN. ??"	[	hresult := self invokeGetIDsOfNames: namesBuffer  asPointerParameter 		_: cNames		_: dispidArrayBuffer asPointerParameter.	dispidList := dispidArrayBuffer contents.	"Assert isTrue: [ dispidList size = cNames ]."	resultReference value: dispidList.	] ensure: [ 		namesBuffer enforceRelease ].	^hresult</body><body package="Com- Automation">GetImplTypeFlags: index _: resultReference		" Invoke the ITypeInfo::GetImplTypeFlags function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #INT.	hresult := self invokeGetImplTypeFlags: index		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetMops: memberID _: resultReference		" Invoke the ITypeInfo::GetMops function.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := BSTR resultValueBuffer.	hresult := self invokeGetMops: memberID		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetNames: memberId	_: nameListReference	_: cMaxNames	_: countReference		"Invoke the ITypeInfo::GetNames function.		Raise an exception if an error occurs.  Answer the result code."	| hresult bstrBuffer countBuffer count nameList |	bstrBuffer := BSTR resultValueArrayBuffer: cMaxNames.   " buffer of BSTRMemoryAddress... "	countBuffer := COMExternalInterface scalarResultBufferFor: #UINT.	hresult := self invokeGetNames: memberId		_: bstrBuffer asPointerParameter		_: cMaxNames		_: countBuffer asPointerParameter.	count := countBuffer contents.	countReference value: count.	nameList := bstrBuffer copyFrom: 1 to: count.  "BSTRs and buffer is freed by this call."	nameListReference value: nameList.	^hresult</body><body package="Com- Automation">GetRefTypeInfo: hreftype _: resultReference		" Invoke the ITypeInfo::GetRefTypeInfo function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeInfoPointer resultValueBuffer.	hresult := self invokeGetRefTypeInfo: hreftype		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetRefTypeOfImplType: index _: resultReference	" Invoke the ITypeInfo::GetRefTypeOfImplType function. 		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface scalarResultBufferFor: #HREFTYPE.	hresult := self invokeGetRefTypeOfImplType: index				_: resultBuffer asPointerParameter.	hresult succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult</body><body package="Com- Automation">GetTypeAttr: resultReference        " Invoke the ITypeInfo::GetTypeAttr function.        Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult aTypeAttr |	resultBuffer := COMStructure resultValuePointerBufferFor: #TYPEATTR.	hresult := self invokeGetTypeAttr: resultBuffer asPointerParameter.	aTypeAttr := resultBuffer contents.	aTypeAttr checkToEnsureExternalMemoryBacking.   " Have to leave it out in COM memory... "	" Don't track finalization on the address, because it can't be		released properly independently of the containing ITypeInfo "	"Assert isTrue: [		aTypeAttr hasFinalization		and: [ aTypeAttr structure hasFinalization not ] ]."	resultReference value: aTypeAttr.	^hresult</body><body package="Com- Automation">GetTypeComp: resultReference		" Invoke the ITypeInfo::GetTypeComp function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeCompPointer resultValueBuffer.	hresult := self invokeGetTypeComp: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetVarDesc: index _: resultReference        " Invoke the ITypeInfo::GetVarDesc function.        Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult aVarDesc |	resultBuffer := COMStructure resultValuePointerBufferFor: #VARDESC.	hresult := self invokeGetVarDesc: index		_: resultBuffer asPointerParameter.	aVarDesc := resultBuffer contents.	aVarDesc checkToEnsureExternalMemoryBacking.   " Have to leave it out in COM memory... "	" Don't track finalization on the address, because it can't be		released properly independently of the containing ITypeInfo "	"Assert isTrue: [		aVarDesc hasFinalization		and: [ aVarDesc structure hasFinalization not ] ]."	resultReference value: aVarDesc.	^hresult</body><body package="Com- Automation">Invoke: anInterface _: memberID _: dispatchFlags _: dispatchParams _: resultReference _: exceptionInfoReference _: argErrorReference	" Invoke the ITypeInfo::Invoke function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer exceptionInfoBuffer argErrorIndexBuffer |	resultReference == nil		ifFalse: [resultBuffer := COMStructure resultValueBufferFor: #VARIANT].	exceptionInfoBuffer := COMStructure resultValueBufferFor: #EXCEPINFO.	argErrorIndexBuffer := COMExternalInterface scalarResultBufferFor: #UINT.	hresult := self				invokeInvoke: anInterface asPointerParameter				_: memberID				_: dispatchFlags				_: dispatchParams asPointerParameter				_: resultBuffer asPointerParameter				_: exceptionInfoBuffer asPointerParameter				_: argErrorIndexBuffer asPointerParameter.	hresult succeeded		ifTrue: 			[resultReference notNil				ifTrue: [resultReference value: resultBuffer contents].			exceptionInfoBuffer enforceRelease]		ifFalse: 			[hresult = DISP_E_EXCEPTION				ifTrue: [exceptionInfoReference value: exceptionInfoBuffer contents]				ifFalse: [exceptionInfoBuffer enforceRelease].	" caller still needs to clean up "			hresult = DISP_E_TYPEMISMATCH				ifTrue: [argErrorReference value: argErrorIndexBuffer contents]			" Note that ordinarily we should be signalling the dispatch error here.				However, in this case we let the client raise the exception because they				have better context for providing user feedback "			"self signalDispatchError: hresult exceptionInfo: exceptionInfo argError: argError"].	argErrorIndexBuffer enforceRelease.	^hresult</body><body package="Com- Automation">ReleaseFuncDesc: aFuncDesc		" Invoke the ITypeInfo::ReleaseFuncDesc function. "	^self invokeReleaseFuncDesc: aFuncDesc asPointerParameter</body><body package="Com- Automation">ReleaseTypeAttr: aTypeAttr		" Invoke the ITypeInfo::ReleaseTypeAttr function. "	^self invokeReleaseTypeAttr: aTypeAttr asPointerParameter</body><body package="Com- Automation">ReleaseVarDesc: aVarDesc		" Invoke the ITypeInfo::ReleaseVarDesc function. "	^self invokeReleaseVarDesc: aVarDesc asPointerParameter</body></methods><methods><class-id>External.ITypeInfoPointer class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: ITypeCompPointer;				yourself</body></methods><methods><class-id>External.ITypeInfoPointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_ITypeInfo.	self updateAndRegister</body></methods><methods><class-id>External.ITypeLibPointer</class-id> <category>interface operations</category><body package="Com- Automation">FindName: aString _: lHashVal _: typeInfosReference _: memberIDsReference _: countReference		" Invoke the ITypeLib::FindName function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult nMemberIDs typeInfoArrayBuffer memidArrayBuffer countFoundBuffer countFound |	nMemberIDs := countReference value.	nMemberIDs == nil		ifTrue: [ nMemberIDs := 1 ].  " default is to find the first instance "	typeInfoArrayBuffer := ITypeInfoPointer resultValueArrayBuffer: nMemberIDs.	memidArrayBuffer := COMExternalInterface arrayResultBufferFor: #MEMBERID count: nMemberIDs.	countFoundBuffer := COMExternalInterface scalarResultBufferFor: #USHORT.	countFoundBuffer contents: nMemberIDs.	hresult := self invokeFindName: aString asUnicodeParameter		_: lHashVal 		_: typeInfoArrayBuffer asPointerParameter 		_: memidArrayBuffer asPointerParameter		_: countFoundBuffer asPointerParameter.	( countFound := countFoundBuffer contents ) &gt; 0		ifTrue: [			| typeInfoList memberIDs |			memberIDs := memidArrayBuffer copyFrom: 1 to: countFound.			typeInfoList := typeInfoArrayBuffer copyFrom: 1 to: countFound.			false ifTrue: [  " here's what the old stuff did "			| lpTypeInfo lpMemberID |			memberIDs := Array new: countFound.			typeInfoList := Array new: countFound.			lpTypeInfo := typeInfoArrayBuffer copy.			lpMemberID := memidArrayBuffer copy.			1 to: countFound do: [ :i |				typeInfoList at: i					put: ( ITypeInfoPointer fromReturnValue: lpTypeInfo contents ).				memberIDs at: i put: lpMemberID contents.				lpTypeInfo increment.				lpMemberID increment ].			].			typeInfosReference value: typeInfoList.			memberIDsReference value: memberIDs ].	countReference value: countFound.	^hresult</body><body package="Com- Automation">GetDocumentation: index _: nameReference _: docStringReference _: helpContextIDReference _: helpFileReference		" Invoke the ITypeLib::GetDocumentation function.		Raise an exception if an error occurs.  Answer the result code. "	| nameBuffer docStringBuffer helpContextIDBuffer helpFileBuffer hresult |	nameReference notNil		ifTrue: [ nameBuffer := BSTR resultValueBuffer ].	docStringReference notNil 		ifTrue: [ docStringBuffer := BSTR resultValueBuffer ].	helpContextIDReference notNil 		ifTrue: [ helpContextIDBuffer := COMExternalInterface scalarResultBufferFor: #DWORD ].	helpFileReference notNil		ifTrue: [ helpFileBuffer := BSTR resultValueBuffer ].	hresult := self invokeGetDocumentation: index 		_: nameBuffer asPointerParameter 		_: docStringBuffer asPointerParameter		_: helpContextIDBuffer asPointerParameter		_: helpFileBuffer asPointerParameter.	nameReference notNil		ifTrue: [ nameReference value: nameBuffer contents ].	docStringReference notNil 		ifTrue: [ docStringReference value: docStringBuffer contents ].	helpContextIDReference notNil 		ifTrue: [ helpContextIDReference value: helpContextIDBuffer contents ].	helpFileReference notNil		ifTrue: [ helpFileReference value: helpFileBuffer contents ].	^hresult</body><body package="Com- Automation">GetLibAttr: resultReference		" Invoke the ITypeLib::GetLibAttr function.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult aTLibAttr |	resultBuffer := COMStructure resultValuePointerBufferFor: #TLIBATTR.	hresult := self invokeGetLibAttr: resultBuffer asPointerParameter.	aTLibAttr := resultBuffer contents.	aTLibAttr checkToEnsureExternalMemoryBacking.   " Have to leave it out in COM memory... "	" Don't track finalization on the address, because it can't be		released properly independently of the containing ITypeLib "	"Assert isTrue: [		aTLibAttr hasFinalization		and: [ aTLibAttr structure hasFinalization not ] ]."	resultReference value: aTLibAttr.	^hresult</body><body package="Com- Automation">GetTypeComp: resultReference		" Invoke the ITypeLib::GetLibAttr function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeCompPointer resultValueBuffer.	hresult := self invokeGetTypeComp: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetTypeInfo: index _: resultReference		" Invoke the ITypeLib::GetTypeInfo function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeInfoPointer resultValueBuffer.	hresult := self invokeGetTypeInfo: index 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetTypeInfoOfGuid: aGUID _: resultReference		" Invoke the ITypeLib::GetTypeInfoOfGuid function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeInfoPointer resultValueBuffer.	hresult := self invokeGetTypeInfoOfGuid: aGUID		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetTypeInfoType: index _: resultReference		" Invoke the ITypeLib::GetTypeInfoType function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #TYPEKIND.	hresult := self invokeGetTypeInfoType: index 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">IsName: aString _: lHashVal _: resultReference		" Invoke the ITypeLib::IsName function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #BOOL.	hresult := self invokeIsName: aString asUnicodeParameter		_: lHashVal		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.  " a Boolean value "	^hresult</body><body package="Com- Automation">ReleaseTLibAttr: aTLibAttr		" Invoke the ITypeLib::ReleaseTLibAttr function. "	^self invokeReleaseTLibAttr: aTLibAttr asPointerParameter</body></methods><methods><class-id>External.ITypeLibPointer class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: ITypeInfoPointer;				yourself</body></methods><methods><class-id>External.ITypeLibPointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_ITypeLib.	self updateAndRegister</body></methods><methods><class-id>External.COMDispatchInterfacePointer</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^VT_DISPATCH</body></methods><methods><class-id>External.COMDispatchInterfacePointer</class-id> <category>interface operations</category><body package="Com- Automation">GetIDsOfNames: riid _: names _: cNames _: lcid _: resultReference		" Invoke the IDispatch::GetIDsOfNames function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult namesBuffer nIDs dispidArrayBuffer |	"Assert isTrue: [ cNames = names size ]."	namesBuffer := COMExternalInterface createUnicodeArrayBuffer: names.	nIDs := cNames.	riid = IID_NULL		ifFalse: [ nIDs := nIDs + 1 ].	dispidArrayBuffer := COMExternalInterface arrayResultBufferFor: #DISPID count: nIDs.	"?? dispidArrayBuffer atAllPut: DISPID_UNKNOWN. ??"	[	hresult := self invokeGetIDsOfNames: riid		_: namesBuffer asPointerParameter 		_: cNames		_: lcid 		_: dispidArrayBuffer asPointerParameter.	(hresult succeeded)		ifTrue: [			| dispidList "lpDISPID" |			dispidList := dispidArrayBuffer contents.			"Assert isTrue: [ dispidList size = nIDs ]."			resultReference value: dispidList ].	] ensure: [ 		namesBuffer enforceRelease ].	^hresult</body><body package="Com- Automation">GetTypeInfo: itinfo _: lcid _: resultReference		" Invoke the IDispatch::GetTypeInfo function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeInfoPointer resultValueBuffer.	hresult := [ self invokeGetTypeInfo: itinfo 		_: lcid 		_: resultBuffer asPointerParameter ] on: COMError do: [:ex | ^ ex hresult].	(hresult succeeded)		ifTrue: [ resultReference value: resultBuffer contents ].	^ S_OK</body><body package="Com- Automation">GetTypeInfoCount: resultReference		" Invoke the IDispatch::GetTypeInfoCount function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #UINT.	hresult := [ self invokeGetTypeInfoCount: resultBuffer asPointerParameter ] on: COMError do: [:ex | ex return: ex hresult ].	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">Invoke: dispidMember    _: riid    _: lcid    _: wFlags    _: pdispparams    _: resultReference    _: exceptionInfoReference    _: argErrorReference        "Invoke the IDispatch::Invoke function.        Raise an exception if an error occurs.  Answer the result code."	| hresult resultBuffer exceptionInfoBuffer argErrorIndexBuffer |	resultReference == nil		ifFalse: [ resultBuffer := COMStructure resultValueBufferFor: #VARIANT ].	exceptionInfoBuffer := COMStructure resultValueBufferFor: #EXCEPINFO.	argErrorIndexBuffer := COMExternalInterface scalarResultBufferFor: #UINT.	hresult := self invokeInvoke: dispidMember		_: riid		_: lcid		_: wFlags		_: pdispparams asPointerParameter		_: resultBuffer asPointerParameter		_: exceptionInfoBuffer asPointerParameter		_: argErrorIndexBuffer asPointerParameter.	(hresult succeeded)		ifTrue: [			resultReference notNil				ifTrue: [ resultReference value: resultBuffer contents ].			exceptionInfoBuffer enforceRelease ]		ifFalse: [			hresult = DISP_E_EXCEPTION				ifTrue: [ exceptionInfoReference value: exceptionInfoBuffer contents ]  " caller needs to clean up "				ifFalse: [ exceptionInfoBuffer enforceRelease ].			hresult = DISP_E_TYPEMISMATCH				ifTrue: [ argErrorReference value: argErrorIndexBuffer contents ].			" Note that ordinarily we should be signalling the dispatch error here.				However, in this case we let the client raise the exception because they				have better context for providing user feedback "			"self signalDispatchError: hresult exceptionInfo: exceptionInfo argError: argError"			 ].	argErrorIndexBuffer enforceRelease.	^hresult</body></methods><methods><class-id>External.COMDispatchInterfacePointer class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: ITypeLibPointer;				yourself</body></methods><methods><class-id>External.COMDispatchInterfacePointer class</class-id> <category>testing</category><body package="Com- Automation">isDispatch	" Answer whether the receiver is a dispatch interface which supports IDispatch. "	^true</body></methods><methods><class-id>External.COMDispatchInterfacePointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IDispatchInterface.  "A special generic dispathc interface IID is used for internal			identification of the abstract Smalltalk dispatch interface class under which			dual interfaces are implemented. "	self updateAndRegister</body></methods><methods><class-id>External.IDispatchPointer</class-id> <category>identity</category><body package="Com- Automation">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid</body><body package="Com- Automation">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;. "	"Assert isTrue: [ self iid isNil or: [ self iid = anIID ] ]."	iid := anIID.</body></methods><methods><class-id>External.IDispatchPointer</class-id> <category>private-initialization</category><body package="Com- Automation">initialize	"Private - Initialize any private state within the receiver.  Subclasses that override this method should ensure they send 'super initialize'.  Answer the receiver."	super initialize.	self initializeIID.</body><body package="Com- Automation">initializeIID	"Private - Initialize the IID of the interface represented by the receiver."	self iid: IID_IDispatch.</body></methods><methods><class-id>External.IDispatchPointer</class-id> <category>private-tracing</category><body package="Com- Automation">isTraceTypeEnabled: callerType	" Private - answer whether tracing of the specified type is currently enabled for the receiver. "	^( super isTraceTypeEnabled: callerType )		or: [ self isTraceTypeEnabled: callerType forIID: IID_IDispatch ]</body></methods><methods><class-id>External.IDispatchPointer class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMDispatchInterfacePointer;				yourself</body></methods><methods><class-id>External.IDispatchPointer class</class-id> <category>identity</category><body package="Com- Automation">supportsIID: aGUID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^( super supportsIID: aGUID )		or: [ IDispatch supportsDispatchIID: aGUID ]</body></methods><methods><class-id>External.IDispatchPointer class</class-id> <category>external-transformations</category><body package="Com- Automation">resultValueBufferForIID: anIID	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an interface pointer instance of with the dispatch interface IID GUID &lt;anIID&gt;.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	( self supportsIID: anIID )		ifFalse: [ self error: ((#NotDispatchInterface &lt;&lt; #com &gt;&gt; 'not a dispatch interface IID: &lt;1s&gt;')			expandMacrosWith: anIID asString) ].	^COMInterfacePointerResultBuffer for: self iid: anIID</body></methods><methods><class-id>External.IDispatchPointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IDispatch.	self updateAndRegister</body></methods><methods><class-id>External.COMDispatchInterfaceImplementation</class-id> <category>interface operations</category><body package="Com- Automation">GetIDsOfNames: riid _: nameList _: cNames _: lcid _: resultReference	"Invoke the IDispatch::GetIDsOfNames function.	Raise an exception if an error occurs.  Answer the result code."	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetIDsOfNames: riid			_: nameList 			_: cNames			_: lcid 			_: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult allow: DISP_E_UNKNOWNNAME.	^hresult</body><body package="Com- Automation">GetTypeInfo: itinfo _: lcid _: resultReference	"Invoke the IDispatch::GetTypeInfo function.	Raise an exception if an error occurs.  Answer the result code."	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetTypeInfo: itinfo 			_: lcid 			_: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Automation">GetTypeInfoCount: resultReference	"Invoke the IDispatch::GetTypeInfoCount function.	Raise an exception if an error occurs.  Answer the result code."	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetTypeInfoCount: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Automation">Invoke: dispidMember _: riid _: lcid _: wFlags _: pdispparams _: resultReference _: exceptionInfoReference _: argErrorReference	"Invoke the IDispatch::Invoke function.	Raise an exception if an error occurs.  Answer the result code."	| hresult |	hresult := 			[" terminate exception stack unwind at function invocation boundary "			implementor				Invoke: dispidMember				_: riid				_: lcid				_: wFlags				_: pdispparams				_: resultReference				_: exceptionInfoReference				_: argErrorReference]					on: self rootExceptions					do: (self exceptionHandlerForDispatchInvoke: #internalCallin							exceptionInfo: exceptionInfoReference).	self checkHresult: hresult allow: DISP_E_EXCEPTION or: DISP_E_TYPEMISMATCH.	hresult succeeded		ifFalse: 			[" Note that ordinarily we should be signalling the dispatch error here.				However, in this case we let the client raise the exception because they				have better context for providing user feedback "			"self signalDispatchError: hresult exceptionInfo: exceptionInfo argError: argError"			].	^hresult</body></methods><methods><class-id>External.COMDispatchInterfaceImplementation</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^VT_DISPATCH</body></methods><methods><class-id>External.COMDispatchInterfaceImplementation</class-id> <category>private-invocation</category><body package="Com- Automation">invokeGetIDsOfNames: this _: riid _: rgszNames _: cNames _: lcid _: rgdispid	" Private - invoke the IDispatch::GetIDsOfNames function for an external caller. "	"HRESULT GetIDsOfNames(		/* [in] */ REFIID riid,		/* [size_is][in] */ LPOLESTR *rgszNames,		/* [in] */ UINT cNames,		/* [in] */ LCID lcid,		/* [size_is][out][in] */ DISPID *rgdispid)"	^	[" terminate exception stack unwind at external callin boundary "	| anIID hresult names resultReference ids lpDISPID |	self reportExternalFunctionEntry.	(riid isValid and: [rgszNames isValid and: [rgdispid isValid]])		ifFalse: [^E_INVALIDARG].	anIID := self guidAtAddress: riid.	" must be IID_NULL in OLE 2.0 "	names := self getArrayOfStrings: cNames fromUnicodeArray: rgszNames.	resultReference := nil asValueReference.	hresult := implementor				GetIDsOfNames: anIID				_: names				_: cNames				_: lcid				_: resultReference.	hresult succeeded		ifTrue: 			[ids := resultReference value.			"Assert isTrue: [ ids size = cNames ]."			lpDISPID := rgdispid copy.			1 to: cNames				do: 					[:index |					lpDISPID contents: (ids at: index).					lpDISPID increment]].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Automation">invokeGetTypeInfo: this _: itinfo _: lcid _: pptinfo        " Private - invoke the IDispatch::GetTypeInfo function for an external caller. "	"HRESULT GetTypeInfo(		/* [in] */ UINT itinfo,		/* [in] */ LCID lcid,		/* [out] */ ITypeInfo **pptinfo)"	^[   " terminate exception stack unwind at external callin boundary "	|  resultReference hresult |	self reportExternalFunctionEntry.	pptinfo isValid		ifFalse: [ ^E_INVALIDARG ].	self clearPointerResultValueAtAddress: pptinfo.	resultReference := nil asValueReference.	hresult := implementor GetTypeInfo: itinfo		_: lcid		_: resultReference.	(hresult succeeded)		ifTrue: [ self interfaceResultAtAddress: pptinfo put: resultReference value ].    hresult	] on: self rootExceptions  		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Automation">invokeGetTypeInfoCount: this _: pctinfo	" Private - invoke the IDispatch::GetTypeInfoCount function for an external caller. "	" HRESULT GetTypeInfoCount(		/* [out] */ UINT *pctinfo)"	^[   " terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pctinfo isValid		ifFalse: [ ^E_INVALIDARG ].	self clearScalarResultValueAtAddress: pctinfo.	resultReference := nil asValueReference.	hresult := implementor GetTypeInfoCount: resultReference.	(hresult succeeded)        ifTrue: [ self scalarResultAtAddress: pctinfo put: resultReference value ].    hresult	] on: self rootExceptions  		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Automation">invokeInvoke: this _: dispidMember _: riid _: lcid _: wFlags _: pdispparams _: pvarResult _: pexcepinfo _: puArgErr	" Private - invoke the IDispatch::Invoke function for an external caller. " 	"HRESULT Invoke(		/* [in] */ DISPID dispidMember,		/* [in] */ REFIID riid,            /* [in] */ LCID lcid,            /* [in] */ WORD wFlags,            /* [unique][in] */ DISPPARAMS *pdispparams,            /* [unique][out][in] */ VARIANT *pvarResult,            /* [out] */ EXCEPINFO *pexcepinfo,            /* [out] */ UINT *puArgErr)"	" The arguments &lt;pvarResult&gt;, &lt;pexcepinfo&gt; and &lt;puArgErr&gt; can be NULL."	^[   " terminate exception stack unwind at external callin boundary "	| anIID dispParams exceptionInfoReference argErrorReference		resultReference hresult |	self reportExternalFunctionEntry.	( riid isValid and: [ pdispparams isValid ] )		ifFalse: [ 			self isExternalCallinTracingEnabled ifTrue: [				self reportIfInvalidExternalArg: riid 					name: 'riid'.				self reportIfInvalidExternalArg: pdispparams 					name: 'pdispparams'.				self reportExternalFunctionInvalidArgExit ].			^E_INVALIDARG ].	anIID := self guidAtAddress: riid.  " must be IID_NULL in OLE 2.0 "	dispParams := self structureAtAddress: pdispparams.  " type: #DISPPARAMS "	self clearStructureResultAtAddress: pexcepinfo.	self clearScalarResultValueAtAddress: puArgErr.	pvarResult isValid		ifTrue: [ resultReference := COMVariantValueReference new ].	exceptionInfoReference := nil asValueReference.	argErrorReference := nil asValueReference.	hresult := implementor Invoke: dispidMember		_: anIID		_: lcid		_: wFlags		_: dispParams  " object must unmarshall values, which is somewhat asymmetric design "		_: resultReference		_: exceptionInfoReference		_: argErrorReference.	( (hresult succeeded)	and: [ resultReference notNil and: [ ( COMVariant isValid: resultReference value ) not ] ] )		ifTrue: [ hresult := DISP_E_EXCEPTION ].    (hresult succeeded)        ifTrue: [            pvarResult isValid                ifTrue: [ self variantResultAtAddress: pvarResult put: resultReference  ] ]        ifFalse: [            ( hresult = DISP_E_EXCEPTION 		and: [ pexcepinfo isValid ] )                ifTrue: [ self structureResultAtAddress: pexcepinfo put: exceptionInfoReference value ].            ( ( hresult = DISP_E_TYPEMISMATCH or: [ hresult = DISP_E_PARAMNOTFOUND ] ) 		and: [ puArgErr isValid ] )                ifTrue: [ self scalarResultAtAddress: puArgErr put: argErrorReference value ].            ].    hresult	] on: self rootExceptions  		do: ( self exceptionHandlerForDispatchInvoke: #externalCallin exceptionInfo: pexcepinfo )</body></methods><methods><class-id>External.COMDispatchInterfaceImplementation class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: IDispatchPointer;				yourself</body></methods><methods><class-id>External.COMDispatchInterfaceImplementation class</class-id> <category>subclass-instance creation</category><body package="Com- Automation">adaptorClass	" Private - answer the interface binding adaptor class for the receiver. "	^COMDispatchInterfaceAdaptor</body></methods><methods><class-id>External.COMDispatchInterfaceImplementation class</class-id> <category>testing</category><body package="Com- Automation">isDispatch	" Answer whether the receiver is a dispatch interface which supports IDispatch. "	^true</body></methods><methods><class-id>External.COMDispatchInterfaceImplementation class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IDispatchInterface.  "A special generic dispathc interface IID is used for internal			identification of the abstract Smalltalk dispatch interface class under which			dual interfaces are implemented. "	self vtableSignatureTypeName: #__IDispatchVtbl.	self updateAndRegister</body></methods><methods><class-id>External.IDispatchImplementation</class-id> <category>private-initialization</category><body package="Com- Automation">initializeIID	"Private - Initialize the IID of the interface represented by the receiver."	self iid: IID_IDispatch.</body></methods><methods><class-id>External.IDispatchImplementation</class-id> <category>private-tracing</category><body package="Com- Automation">isTraceTypeEnabled: callerType	" Private - answer whether tracing of the specified type is currently enabled for the receiver. "	^( super isTraceTypeEnabled: callerType )		or: [ self isTraceTypeEnabled: callerType forIID: IID_IDispatch ]</body></methods><methods><class-id>External.IDispatchImplementation</class-id> <category>private-accessing</category><body package="Com- Automation">implementor: anObject		"Private - Set the implementor of the interface to &lt;anObject&gt;."	super implementor: anObject.	" sneaky way to hook up instance initialization "	self iid isNil		ifTrue: [ self initializeIID ].</body></methods><methods><class-id>External.IDispatchImplementation</class-id> <category>identity</category><body package="Com- Automation">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid</body><body package="Com- Automation">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;. "	iid := anIID.</body></methods><methods><class-id>External.IDispatchImplementation class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMDispatchInterfaceImplementation;				yourself</body></methods><methods><class-id>External.IDispatchImplementation class</class-id> <category>identity</category><body package="Com- Automation">supportsIID: aGUID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^( super supportsIID: aGUID )		or: [ IDispatch supportsDispatchIID: aGUID ]</body></methods><methods><class-id>External.IDispatchImplementation class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IDispatch.	self vtableSignatureTypeName: #__IDispatchVtbl.	self updateAndRegister</body></methods><methods><class-id>External.IConnectionPoint</class-id> <category>interface operations</category><body package="Com- Automation">advise: anIUnknownSink		" Register an event notification sink &lt;anIUnknownSink&gt; for this connection point.		The connection point will call QueryInterface to obtain the interface it expects on the sink.		Answer a token which identifies the advise connection. "	| resultReference |	resultReference := nil asValueReference.	interface Advise: anIUnknownSink _: resultReference.	^resultReference value</body><body package="Com- Automation">connectionsEnumerator		" Answer an enumerator on the currently connected event advise sinks		registered on this connection point. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumConnections ) asValueReference.	interface EnumConnections: resultReference.	^resultReference value</body><body package="Com- Automation">getConnectionInterface		" Answer the IID Guid of the interface for which this		connection point is able to call implementations (the 'name'		of the connection point). "	| resultReference |	resultReference := nil asValueReference.	interface GetConnectionInterface: resultReference.	^resultReference value</body><body package="Com- Automation">getConnectionPointContainer		" Answer the connection point container object which supports this connection point. "	| resultReference |	resultReference := IConnectionPointContainer new asValueReference.	interface GetConnectionPointContainer: resultReference.	^resultReference value</body><body package="Com- Automation">unadvise: connectionToken		" Revoke an advise connection previously established with IConnectionPoint::Advise.		Raise an exception if an error occurs.  Answer the result code. "	^interface Unadvise: connectionToken</body></methods><methods><class-id>External.IConnectionPoint</class-id> <category>accessing</category><body package="Com- Automation">connections	" Answer the currently connected event advise sinks		registered on this connection point. "	| anEnumerator contents |	anEnumerator := self connectionsEnumerator.	contents := anEnumerator contents.	^contents</body></methods><methods><class-id>External.IConnectionPoint class</class-id> <category>private-registration</category><body package="Com- Automation">enumeratorIID	" Answer the IID of the interface which enumerates collections containing instances of the receiver. "	^IID_IEnumConnectionPoints</body><body package="Com- Automation">registerEnumeratorIID	" Private - register the IID of the interface which enumerates collections containing instances of the receiver. "	IEnum		registerEnumeratorIID: self enumeratorIID		for: self.</body><body package="Com- Automation">removeEnumeratorIID	" Private - remove the registration of the IID of the interface which enumerates collections containing instances of the receiver. "	IEnum removeEnumeratorIID: self enumeratorIID.</body></methods><methods><class-id>External.IConnectionPoint class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">obsolete	self removeIID.	self removeEnumeratorIID.	super obsolete</body><body package="Com- Automation">prerequisitesForLoading	"must be: xContainerPointer, xPointer, xPoint and xPointContainer"	^super prerequisitesForLoading		addLast: IDispatchImplementation;		addLast: IConnectionPointPointer;		yourself</body></methods><methods><class-id>External.IConnectionPoint class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IConnectionPoint.	self updateAndRegister.	self registerEnumeratorIID</body></methods><methods><class-id>External.IConnectionPointContainer</class-id> <category>interface operations</category><body package="Com- Automation">connectionPointsEnumerator		" Answer an enumerator on the connection points contained in the connectable object. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumConnectionPoints ) asValueReference.	interface EnumConnectionPoints: resultReference.	^resultReference value</body><body package="Com- Automation">findConnectionPoint: iid		" Answer the connection point associated with the IID given by the Guid &lt;iid&gt;. "	| resultReference |	resultReference := IConnectionPoint new asValueReference.	[ interface FindConnectionPoint: iid _: resultReference ] on: Error do: [:ex | ex return: nil ].	^resultReference value</body></methods><methods><class-id>External.IConnectionPointContainer</class-id> <category>accessing</category><body package="Com- Automation">connectionPoints	" Answer the connection points contained in the connectable object. "	| anEnumerator contents |	anEnumerator := self connectionPointsEnumerator.	contents := anEnumerator contents.	^contents</body></methods><methods><class-id>External.IConnectionPointContainer class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	"must be: xContainerPointer, xPointer, xPoint and xPointContainer"	^super prerequisitesForLoading		addLast: IConnectionPoint;		yourself</body></methods><methods><class-id>External.IConnectionPointContainer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IConnectionPointContainer.	self updateAndRegister</body></methods><methods><class-id>External.IProvideClassInfo</class-id> <category>interface operations</category><body package="Com- Automation">getClassInfo		" Answer a CoClass ITypeInfo describing the connectable object. "	| resultReference |	resultReference := ITypeInfo new asValueReference.	interface GetClassInfo: resultReference.	^resultReference value</body></methods><methods><class-id>External.IProvideClassInfo class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: IConnectionPointContainer;		yourself</body></methods><methods><class-id>External.IProvideClassInfo class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IProvideClassInfo.	self updateAndRegister</body></methods><methods><class-id>External.ITypeComp</class-id> <category>interface operations</category><body package="Com- Automation">bind: aName flags: wFlags lcid: lcid	"Answer a COMTypeCompilerBoundName describing a FUNCDESC, VARDESC or ITypeComp describing &lt;aName&gt;.    Note: The answered FUNCDESC or VARDESC must have it's typeInterface released."	| hash typeInfoResultReference descKindResultReference bindPtrResultReference descKind |	hash := ITypeInfo lHashValueOfName: aName lcid: lcid.	typeInfoResultReference := ITypeInfo new asValueReference.	descKindResultReference := nil asValueReference.	bindPtrResultReference := nil asValueReference.	interface		Bind: aName		_: hash		_: wFlags		_: typeInfoResultReference		_: descKindResultReference		_: bindPtrResultReference.	descKind := descKindResultReference value.	descKind = DESCKIND_NONE ifTrue: [^nil].	(descKind = DESCKIND_FUNCDESC or: [descKind = DESCKIND_VARDESC])		ifTrue: 			[bindPtrResultReference value typeInterface: typeInfoResultReference value	" to support releasing "].	^COMTypeCompilerBoundName		name: aName		typeInfo: typeInfoResultReference value		description: bindPtrResultReference value</body><body package="Com- Automation">bindType: aName lcid: lcid    "Answer describing COMTypeCompilerBoundType describing &lt;aName&gt;, which must be released."    | hash typeInfoResultReference typeCompResultReference |    hash := ITypeInfo lHashValueOfName: aName lcid: lcid.    typeInfoResultReference := ITypeInfo new asValueReference.    typeCompResultReference := ITypeComp new asValueReference.    interface BindType: aName        _: hash        _: typeInfoResultReference        _: typeCompResultReference. "last arg will be nil (reserved by OLE for future USE)"    ^COMTypeCompilerBoundType	  name: aName        typeInfo: typeInfoResultReference value        typeComp: typeCompResultReference value</body></methods><methods><class-id>External.ITypeComp class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: IProvideClassInfo;		yourself</body></methods><methods><class-id>External.ITypeComp class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_ITypeComp.	self updateAndRegister</body></methods><methods><class-id>External.COMTypeLibraryInterface</class-id> <category>interface operations</category><body package="Com- Automation">getDocumentation        " Answer documentation attributes describing the receiver. "    ^self getDocumentation: MEMBERID_NIL</body><body package="Com- Automation">getDocumentation: elementId		" Answer the documentation information about the element 		specified by &lt;elementId&gt; in the receiver.  The element id		is an index for a type library or a memberID for a type description. "	| nameReference docStringReference helpContextIDReference helpFileReference |	nameReference := nil asValueReference.	docStringReference := nil asValueReference.	helpContextIDReference := nil asValueReference.	helpFileReference := nil asValueReference.	interface GetDocumentation: elementId 		_: nameReference 		_: docStringReference 		_: helpContextIDReference 		_: helpFileReference.	^Dictionary new		at: 'id' put: elementId;		at: 'name' put: nameReference value;		at: 'documentation' put: docStringReference value;		at: 'helpContextID' put: helpContextIDReference value;		at: 'helpFile' put: helpFileReference value;		yourself</body><body package="Com- Automation">getDocumentationName        " Answer the name from documentation attributes describing the receiver. "    ^self getDocumentationName: MEMBERID_NIL</body><body package="Com- Automation">getDocumentationName: elementId		" Answer the name from documentation information about the element specified by &lt;elementId&gt; in the receiver.  The element id is an index for a type library or a memberID for a type description. "	| nameReference |	nameReference := nil asValueReference.	interface GetDocumentation: elementId 		_: nameReference 		_: nil 		_: nil		_: nil.	^nameReference value</body><body package="Com- Automation">getTypeComp		" Answer a type compiler that can be used to bind to the receiver. "	| resultReference |	resultReference := ITypeComp new asValueReference.	interface GetTypeComp: resultReference.	^resultReference value</body></methods><methods><class-id>External.COMTypeLibraryInterface class</class-id> <category>hash services</category><body package="Com- Automation">lHashValueOfName: aMemberName	" Answer a hash value for &lt;aMemberName&gt; that can be be used when binding to type library members. "	^self lHashValueOfName: aMemberName 		sysKind: self sysKind		lcid: STDOLE_LCID</body><body package="Com- Automation">lHashValueOfName: aMemberName lcid: lcid	" Answer a hash value for &lt;aMemberName&gt; that can be be used when binding to type library members. "	^self lHashValueOfName: aMemberName 		sysKind: self sysKind		lcid: lcid</body><body package="Com- Automation">lHashValueOfName: aMemberName sysKind: sysKind lcid: lcid	" Answer a hash value for &lt;aMemberName&gt; that can be be used when binding to type library members. "	^OLEAutomationDLL current LHashValOfNameSys: sysKind 		_: lcid 		_: aMemberName</body><body package="Com- Automation">sysKind	" Answer the SYSKIND value of the current platform. "	^SYS_WIN32"A more generalized multi-platform version:	HostInterface isWin32        ifTrue: [ ^SYS_WIN32 ].    HostInterface isMac        ifTrue: [ ^SYS_MAC ].    OLEError signal: 'Unsupported Operating System.' "</body></methods><methods><class-id>External.COMTypeLibraryInterface class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: ITypeComp;		yourself</body></methods><methods><class-id>External.COMTypeLibraryInterface class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: nil.	" this is an abstract class which does not correspond to any real interface. "</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>interface operations-dispatching</category><body package="Com- Automation">invoke: anInterface memberId: memberID flags: dispatchFlags parameters: dispatchParams hasReturnValue: hasReturnValue	" Invoke the method or property get/set function identified by &lt;memberID&gt;		of the object of &lt;anInterface&gt;.  Answer the result vaue, if any.  		Raise an exception if an error occurs. "	| resultReference exceptionInfoReference argErrorReference hresult |	hasReturnValue ifTrue: [resultReference := nil asValueReference].	exceptionInfoReference := nil asValueReference.	argErrorReference := nil asValueReference.	hresult := interface				Invoke: anInterface				_: memberID				_: dispatchFlags				_: dispatchParams				_: resultReference				_: exceptionInfoReference				_: argErrorReference.	hresult succeeded		ifFalse: 			[self				signalDispatchError: hresult				exceptionInfo: exceptionInfoReference value				argError: argErrorReference value].	hasReturnValue ifTrue: [^resultReference value]</body><body package="Com- Automation">invokeMethod: memberID with: dispatchParams interface: anInterface		" Invoke the method identified by &lt;memberID&gt; of the		object &lt;anInterface&gt;, passing the arguments &lt;dispatchParams&gt;.		Return the result value, if any. "    ^self invoke: anInterface 		memberId: memberID 		flags: DISPATCH_METHOD 		parameters: dispatchParams		hasReturnValue: true</body><body package="Com- Automation">invokePropertyGet: memberID with: dispatchParams interface: anInterface		" Get the property value identified by &lt;memberID&gt; of the		object &lt;anInterface&gt;, passing the arguments &lt;dispatchParams&gt;.		Return the value. "    ^self invoke: anInterface 		memberId: memberID 		flags: DISPATCH_PROPERTYGET 		parameters: dispatchParams		hasReturnValue: true</body><body package="Com- Automation">invokePropertyPut: memberID with: dispatchParams interface: anInterface		" Set the property value identified by &lt;memberID&gt; of the		object &lt;anInterface&gt;, passing the arguments &lt;dispatchParams&gt;. "    ^self invoke: anInterface 		memberId: memberID 		flags: DISPATCH_PROPERTYPUT 		parameters: dispatchParams		hasReturnValue: false</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>interface operations-creating</category><body package="Com- Automation">createInstance		" Create an uninitialized instance of the receiver's class		and answer its IUnknown interface. "    ^self createInstance: IID_IUnknown controllingUnknown: nil</body><body package="Com- Automation">createInstance: anIID controllingUnknown: controllingUnknown		" Create an uninitialized instance of the receiver's class.		The object is created as a non-control object within an aggregate		if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.        Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "    | resultReference |    resultReference := COMInterfaceValueReference forIID: anIID.    interface CreateInstance: controllingUnknown        _: anIID        _: resultReference.    ^resultReference value</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>interface operations-accessing</category><body package="Com- Automation">addressOfMember: memberID kind: invkind		" Answer the address of a static function or variable identified by &lt;memberID&gt;		either a method or property function according to the INVOKE type &lt;invkind&gt;.		Raise an exception if an error occurs. "	| resultReference |	resultReference := nil asValueReference.	interface AddressOfMember: memberID _: invkind _: resultReference.	^resultReference value</body><body package="Com- Automation">getContainingTypeLib		" Answer the type library containing the receiver. "	| resultReference |	resultReference := ITypeLib new asValueReference.	interface GetContainingTypeLib: resultReference 		_: nil asValueReference.	^resultReference value</body><body package="Com- Automation">getContainingTypeLibIndex        " Answer the index which identifies the receiver in its containing type library. "	| resultReference typeLibReference |	resultReference := nil asValueReference.	typeLibReference := ITypeLib new asValueReference.	interface GetContainingTypeLib: typeLibReference 		_: resultReference.	^resultReference value</body><body package="Com- Automation">getDllEntryPointDescription: memberID kind: invokeKind		" Answer the DLL entry point description of &lt;memberID&gt;,		which is a method or property get/set function per &lt;invokeKind&gt;. "	| dllNameReference entryPointNameReference ordinalReference |	dllNameReference := nil asValueReference.	entryPointNameReference := nil asValueReference.	ordinalReference := nil asValueReference.	interface GetDllEntry: memberID 		_:  invokeKind 		_: dllNameReference 		_: entryPointNameReference 		_: ordinalReference.	^Dictionary new		at: 'dllName' put: dllNameReference value;		at: 'entryPointName' put: entryPointNameReference value;		at: 'ordinal' put: ordinalReference value;		yourself</body><body package="Com- Automation">getFuncDesc: index		" Answer a function description of the &lt;index&gt;-the function in the receiver. "	| resultReference |	resultReference := nil asValueReference.	interface GetFuncDesc: index _: resultReference.	resultReference value typeInterface: self.  " to support releasing "	^resultReference value</body><body package="Com- Automation">getIDsOfNames: memberNames		" Answer a list of member id's corresponding to the		list of member names in &lt;memberNames&gt;. "	| resultReference |	resultReference := nil asValueReference.	interface GetIDsOfNames: memberNames		_: memberNames size 		_: resultReference.	^resultReference value</body><body package="Com- Automation">getImplTypeFlags: index		" Answer the type flags of a component object class member. "	| resultReference |	resultReference := nil asValueReference.	interface GetImplTypeFlags: index _: resultReference.	^resultReference value</body><body package="Com- Automation">getMethodEntryPointDescription: memberID		" Answer the DLL entry point description of method &lt;memberID&gt;. "	^self getDllEntryPointDescription: memberID 		kind: INVOKE_FUNC</body><body package="Com- Automation">getMops: memberID		" Answer the name of the structure marshalling operation of the receiver. "	| resultReference |	resultReference := nil asValueReference.	interface GetMops: memberID _: resultReference.	^resultReference value</body><body package="Com- Automation">getName: memberID	"Answer the name of the member identified by &lt;memberID&gt;. Variables have one name. For functions, use getNames:count since functions have one name plus parameter names."	| names |	names := self getNames: memberID count: 1.	^names at: 1</body><body package="Com- Automation">getNames: memberID count: numberOfNames		" Answer a list of the names of the member identified by &lt;memberID&gt;. 		If there are more than &lt;numberOfNames&gt; names, answer the first &lt;numberOfNames&gt;.		Variables have one name, functions have one plus the number of parameters. "    | nameListReference |    nameListReference := nil asValueReference.    interface GetNames: memberID        _: nameListReference        _: numberOfNames        _: nil asValueReference.    ^nameListReference value</body><body package="Com- Automation">getPropertyGetEntryPointDescription: memberID		" Answer the DLL entry point description of the property get method &lt;memberID&gt;. "	^self getDllEntryPointDescription: memberID 		kind: INVOKE_PROPERTYGET</body><body package="Com- Automation">getPropertySetEntryPointDescription: memberID		" Answer the DLL entry point description of the property set method &lt;memberID&gt;. "	^self getDllEntryPointDescription: memberID 		kind: INVOKE_PROPERTYPUT</body><body package="Com- Automation">getRefTypeInfo: refType		" Answer an ITypeInfo which accesses the type descriptions of any		types referenced by this type reference. "	| resultReference |	refType isNil 		ifTrue: [ ^nil ].	resultReference := ITypeInfo new asValueReference.	interface GetRefTypeInfo: refType _: resultReference.	^resultReference value</body><body package="Com- Automation">getRefTypeOfImplType: index		" Retrieve the type description of the specified interface type		for a member which is a component object class. "	| resultReference |	resultReference := nil asValueReference.	interface GetRefTypeOfImplType: index _: resultReference.	^resultReference value</body><body package="Com- Automation">getTypeAttr		" Answer the type attribute description of the receiver. "	| resultReference |	resultReference := nil asValueReference.	interface GetTypeAttr: resultReference.	resultReference value typeInterface: self.  " to support releasing "	^resultReference value</body><body package="Com- Automation">getVarDesc: index		" Answer a variable description of the &lt;index&gt;-the member in the receiver. "	| resultReference |	resultReference := nil asValueReference.	interface GetVarDesc: index _: resultReference.	resultReference value typeInterface: self.  " to support releasing "	^resultReference value</body><body package="Com- Automation">withTypeAttrDo: aBlock	| typeAttr |	typeAttr := self getTypeAttr.	^ [ aBlock value: typeAttr ] ensure: [ typeAttr enforceRelease ]</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>interfaces operations-releasing</category><body package="Com- Automation">releaseFuncDesc: aFuncDesc		" Release a FUNCDESC previously obtained from ITypeInfo::GetFuncDesc. "	interface ReleaseFuncDesc: aFuncDesc.</body><body package="Com- Automation">releaseTypeAttr: aTypeAttr		" Release a TYPEATTR previously obtained from ITypeInfo::GetTypeAttr. "	interface ReleaseTypeAttr: aTypeAttr.</body><body package="Com- Automation">releaseVarDesc: aVarDesc		" Release a VARDESC previously obtained from ITypeInfo::GetVarDesc. "	interface ReleaseVarDesc: aVarDesc.</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>testing</category><body package="Com- Automation">implementsDispatching	"Answer whether the interface described by the receiver implements IDispatch either by deriving from IDispatch or by implementing a dual interface.  Answer false if the receiver does not describe an interaface."	^self isDispatch or: [ self inheritsFromIDispatch ]</body><body package="Com- Automation">inheritsFrom: anInterfaceName	"Answer whether the interface described by the receiver inherits from &lt;anInterfaceName&gt;.  Answer false if the receiver does not describe an interface."	| aTypeInfo inherits |	self isInterface ifFalse: [^false].	(aTypeInfo := self superTypeInfo) isNil ifTrue: [^false].	inherits := (aTypeInfo getDocumentation at: 'name') = anInterfaceName.	inherits ifTrue: [^true].	"We have not found IDispatch, so recurse up the inheritance chain."	inherits := aTypeInfo inheritsFrom: anInterfaceName.	^inherits</body><body package="Com- Automation">inheritsFromIDispatch	"Answer wheter the interface described by the receiver inherits from IDispatch. If the receiver does not describe an interafce, answer false."		^self inheritsFrom: 'IDispatch'</body><body package="Com- Automation">isCoclass	"Answer whether the receiver describes a dispatch interface."	^self typekind = TKIND_COCLASS</body><body package="Com- Automation">isDefaultInterface: flags	^ (flags bitAnd: IMPLTYPEFLAG_FDEFAULT) = IMPLTYPEFLAG_FDEFAULT</body><body package="Com- Automation">isDispatch	"Answer whether the receiver describes a dispatch interface."	^self typekind = TKIND_DISPATCH</body><body package="Com- Automation">isDualInterface	^ self withTypeAttrDo: [:typeAttr | typeAttr isDualInterface ]</body><body package="Com- Automation">isImplementedItf: flags	^ (flags bitAnd: IMPLTYPEFLAG_FSOURCE) = 0</body><body package="Com- Automation">isInterface	"Answer whether the receiver describes an interface."	^self typekind = TKIND_INTERFACE</body><body package="Com- Automation">supportsDispatch	^  self isDispatch or: [ self isDualInterface ]</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>accessing</category><body package="Com- Automation">alternativeTypeInfo	"Answer the alternative ITypeInfo for IDispatch/VTable representation"	^ self isDualInterface 		ifTrue: [ self getRefTypeInfo: ( self getRefTypeOfImplType: -1) ] 		ifFalse: [ nil ]</body><body package="Com- Automation">getMember: aMemberID	" Answer the element in the receiver whose member ID is &lt;aMemberID&gt;.  Answer nil if no such member is found. "	| aTypeAttr nFunctions nVariables aFuncDesc aVarDesc |	aTypeAttr := self getTypeAttr.	[	nFunctions := aTypeAttr functionCount.	nVariables := aTypeAttr variableCount.	] ensure: [		aTypeAttr enforceRelease ].	0 to: ( nFunctions - 1 ) do: [ :i |		aFuncDesc := self getFuncDesc: i.		aFuncDesc memberID = aMemberID			ifTrue: [ ^aFuncDesc ].		aFuncDesc enforceRelease ].	0 to: ( nVariables - 1 ) do: [ :i |		aVarDesc := self getVarDesc: i.		aVarDesc memberID = aMemberID			ifTrue: [ ^aVarDesc ].		aVarDesc enforceRelease ].	^nil</body><body package="Com- Automation">itfTypeInfo	"Answer the ITypeInfo from which the reciever VTable typeinfo for dual interfaces"	^self getRefTypeInfo: ( self getRefTypeOfImplType: -1)</body><body package="Com- Automation">refTypeCode	"Query &lt;refType&gt; to determine the type code of the receiver."	"code := 0."	| code kind |	self withTypeAttrDo:    			[:typeAttr | 			kind := typeAttr typekind. 			kind = TKIND_ENUM ifTrue: [code := VT_INT].			kind = TKIND_INTERFACE ifTrue: [code := typeAttr guid].			kind = TKIND_DISPATCH ifTrue: [code := VT_DISPATCH	"typeAttr guid"].			kind = TKIND_COCLASS ifTrue: [code := VT_UNKNOWN	"typeAttr guid"].			kind = TKIND_ALIAS 				ifTrue: [code := typeAttr tdescAlias typeCodeUsing: self].			code = VT_INT ifTrue: [code := VT_I4].			^code]</body><body package="Com- Automation">superTypeInfo	"Answer the ITypeInfo from which the reciever is derived.  Answer nil if there is none."	^self getRefTypeInfo: ( self getRefTypeOfImplType: 0 )</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>accessing type attributes</category><body package="Com- Automation">guid	^ self withTypeAttrDo: [:attr | attr guid ]</body><body package="Com- Automation">typeCount	"return the number of implemented types"	^ self withTypeAttrDo: [:typeAttr | typeAttr typeCount ]</body><body package="Com- Automation">typeFlags    "Answer the kind of type this ITypeInfo describes."	^ self withTypeAttrDo: [:attr | attr typeFlags ]</body><body package="Com- Automation">typekind    "Answer the kind of type this ITypeInfo describes."        ^ self withTypeAttrDo: [:typeAttr | typeAttr typekind ]</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>enumerating</category><body package="Com- Automation">dispatchInterfacesDo: aBlock	self referencedTypesAndFlagsDo: [:refTypeInfo :flags |		refTypeInfo supportsDispatch 			ifTrue: [ aBlock value: refTypeInfo value: flags  ]].</body><body package="Com- Automation">functionsDo: aBlock	"enumerate over the functions."	| func |	self withTypeAttrDo: [:attr |		0 to: attr functionCount -1 do: [:index |			func := (self getFuncDesc: index).			[ aBlock value: func ] ensure: [ func enforceRelease ]]].</body><body package="Com- Automation">implementedInterfacesDo: aBlock	self referencedTypesAndFlagsDo: [:refTypeInfo :flags |		((self isImplementedItf: flags) )			ifTrue: [ aBlock value: refTypeInfo  ]].</body><body package="Com- Automation">variablesDo: aBlock	"enumerate over the variables. Put please be carefull, 	 variables are release immediately after block execution and	 may not be used afterwards"	| var |	self withTypeAttrDo: [:attr |		0 to: attr variableCount -1 do: [:index |			var := (self getVarDesc: index).			[ aBlock value: var ] ensure: [ var enforceRelease ]]].</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>private tools</category><body package="Com- Automation">referencedTypesAndFlagsDo: aBlock	| refTypeIndex refTypeFlags refType |	0 to: self typeCount - 1		do: 			[:index |			refTypeIndex := self getRefTypeOfImplType: index.			refTypeFlags := self getImplTypeFlags: index.			refType := [self getRefTypeInfo: refTypeIndex] on: Error do: [:ex | ex return: nil].			refType ifNotNil: [aBlock value: refType value: refTypeFlags]]</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>converting</category><body package="Com- Automation">asDispatchTypeInfo	^  self isInterface		ifTrue: [ self alternativeTypeInfo ]				ifFalse: [ self ]</body><body package="Com- Automation">asVTableTypeInfo	^  self isInterface		ifTrue: [ self ]		ifFalse: [ self alternativeTypeInfo ]</body></methods><methods><class-id>External.ITypeInfo class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMTypeLibraryInterface;		yourself</body></methods><methods><class-id>External.ITypeInfo class</class-id> <category>subclass-tracing</category><body package="Com- Automation">canTraceAdaptorAssumeHRESULT	" Answer whether a trace adaptor configured on an instance of the receiver can assume that the functions in the interface represented by the receiver follow the standard COM convention of returning an HRESULT as the function return value, with OUT values returned via parameter values. "	^false</body></methods><methods><class-id>External.ITypeInfo class</class-id> <category>instance creation</category><body package="Com- Automation">forIID: anIID	^COMTypeLibrary typeInfoForIID: anIID</body></methods><methods><class-id>External.ITypeInfo class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_ITypeInfo.	self updateAndRegister</body></methods><methods><class-id>External.ITypeLib</class-id> <category>interface operations</category><body package="Com- Automation">findAllOccurrencesOfName: aString	" Find all occurrences of the type named &lt;aString&gt; in the type library. "	^self findAllOccurrencesOfName: aString		hashValue: ( self class lHashValueOfName: aString )</body><body package="Com- Automation">findAllOccurrencesOfName: aString hashValue: hashValue	" Find all occurrences of the type named &lt;aString&gt; in the type library.  Answer a collection of the elements which define the member in a type info in the type library. "	| typeInfosReference memberIDsReference countFoundReference countFound members aTypeInfo aMember |	typeInfosReference := nil asValueReference.	memberIDsReference := nil asValueReference.	countFoundReference := self getTypeInfoCount asValueReference.	interface		FindName: aString		_: hashValue		_: typeInfosReference		_: memberIDsReference		_: countFoundReference.	countFound := countFoundReference value.	countFound = 0 ifTrue: [^nil].	members := Array new: countFound.	1 to: countFound		do: 			[:i |			aTypeInfo := (typeInfosReference value at: i) asInterfaceReference.			aMember := aTypeInfo getMember: (memberIDsReference value at: i).			aMember notNil ifTrue: [members at: i put: aMember]].	^members</body><body package="Com- Automation">findAllOccurrencesOfName: aString lcid: localeID	" Find all occurrences of the type named &lt;aString&gt; in the type library. "	^self findAllOccurrencesOfName: aString		hashValue: ( self class lHashValueOfName: aString lcid: localeID )</body><body package="Com- Automation">findName: aString	" Find the first occurrence of the type named &lt;aString&gt; in the type library. "	^self findName: aString		hashValue: ( self class lHashValueOfName: aString )</body><body package="Com- Automation">findName: aString hashValue: hashValue	" Find the first occurrence of the type named &lt;aString&gt; in the type library.  Answer the element which defines the member in a type info in the type library. "	| typeInfosReference memberIDsReference countFoundReference countFound aTypeInfo aMember memberId |	typeInfosReference := nil asValueReference.	memberIDsReference := nil asValueReference.	countFoundReference := 1 asValueReference.	interface		FindName: aString		_: hashValue		_: typeInfosReference		_: memberIDsReference		_: countFoundReference.	countFound := countFoundReference value.	countFound = 0 ifTrue: [^nil].	aTypeInfo := (typeInfosReference value at: 1) asInterfaceReference.	memberId := memberIDsReference value at: 1.	memberId = MEMBERID_NIL ifTrue: [^aTypeInfo].	aMember := aTypeInfo getMember: memberId.	^aMember</body><body package="Com- Automation">findName: aString lcid: localeID	" Find the first occurrence of the type named &lt;aString&gt; in the type library. "	^self findName: aString		hashValue: ( self class lHashValueOfName: aString lcid: localeID )</body><body package="Com- Automation">getLibAttr 		" Answer the library attribute description of the receiver. "	| resultReference |	resultReference := nil asValueReference.	interface GetLibAttr: resultReference.	resultReference value typeInterface: self.  " to support releasing "	^resultReference value</body><body package="Com- Automation">getTypeInfo: index		" Answer the &lt;index&gt;-th type description in the type library. "	| resultReference |	resultReference := ITypeInfo new asValueReference.	interface GetTypeInfo: index _: resultReference.	^resultReference value</body><body package="Com- Automation">getTypeInfoCount		" Answer the number of type descriptions in the type library. "	^interface GetTypeInfoCount</body><body package="Com- Automation">getTypeInfoOfGuid: aGUID 		" Answer the type description corresponding to &lt;aGUID&gt; in the type library. "	| resultReference |	resultReference := ITypeInfo new asValueReference.	interface GetTypeInfoOfGuid: aGUID _: resultReference.	^resultReference value</body><body package="Com- Automation">getTypeInfoType: index		" Answer the type of the &lt;index&gt;-th type description in the type library. "	| resultReference |	resultReference := nil asValueReference.	interface GetTypeInfoType: index _: resultReference.	^resultReference value</body><body package="Com- Automation">isName: aString hash: lHashVal		" Answer whether &lt;aString&gt; is the name of a type or		a member in the type library. "	| resultReference |	resultReference := nil asValueReference.	interface IsName: aString _: lHashVal _: resultReference.	^resultReference value</body><body package="Com- Automation">releaseTLibAttr: aTLibAttr		" Release a TLIBATTR previously obtained from ITypeLib::GetLibAttr. "	interface ReleaseTLibAttr: aTLibAttr.</body><body package="Com- Automation">typeDescriptionCount		" Answer the number of type descriptions in the type library. "	^self getTypeInfoCount</body></methods><methods><class-id>External.ITypeLib</class-id> <category>registration</category><body package="Com- Automation">registerTypeLibrary: fullPathName helpDirectory: helpDirName	"Adds information about a type library to the system registry. ""&lt;szFullPath &gt;:	Fully qualified path specification for the type library being registered. &lt;szHelpDir &gt;:	Directory in which the Help file for the library being registered can be found. Can be Null. The function RegisterTypeLib can be used during application initialization to register the application's type library correctly. In addition to filling in a complete registry entry under the type library key, RegisterTypeLib adds entries for each of the dispinterfaces and Automation-compatible interfaces, including dual interfaces. This information is required to create instances of these interfaces. Coclasses are not registered (that is, RegisterTypeLib does not write any values to the CLSID key of the coclass). "	OLEAutomationDLL current RegisterTypeLibrary: self		_: fullPathName 		_: helpDirName</body><body package="Com- Automation">registerTypeLibraryForUser: fullPathName helpDirectory: helpDirName	"Adds information about a type library to the system registry. ""&lt;szFullPath &gt;:	Fully qualified path specification for the type library being registered. &lt;szHelpDir &gt;:	Directory in which the Help file for the library being registered can be found. Can be Null. The function RegisterTypeLib can be used during application initialization to register the application's type library correctly. In addition to filling in a complete registry entry under the type library key, RegisterTypeLib adds entries for each of the dispinterfaces and Automation-compatible interfaces, including dual interfaces. This information is required to create instances of these interfaces. Coclasses are not registered (that is, RegisterTypeLib does not write any values to the CLSID key of the coclass). "	OLEAutomationDLL current RegisterTypeLibForUser: self		_: fullPathName 		_: helpDirName</body></methods><methods><class-id>External.ITypeLib</class-id> <category>enumerating</category><body package="Com- Automation">collect: aBlock	"Collect the the results of the evaluation of the block for each contained typeinfo.	 Please be aware that typeInfos are released automatically afterwards.	 For keeping them create a separate reference inside the block or use #select:"	| array |	array := Array new: self getTypeInfoCount. 	self keysAndValuesDo: [:index :typeInfo |		array at: index put: (aBlock value: typeInfo) ].	^ array</body><body package="Com- Automation">detect: aBlock ifNone: exceptionBlock	"Answer the ITypeInfo of the first member of the receiver that         causes &lt;aBlock&gt; to evaluate to true (with that         element as the argument).  If no such element is         found, evaluate &lt;exceptionBlock&gt; (with no arguments)."	| anITypeInfo |	0 to: self getTypeInfoCount - 1		do: 			[:index |			anITypeInfo := self getTypeInfo: index.			(aBlock value: anITypeInfo) ifTrue: [^anITypeInfo]].	^exceptionBlock value</body><body package="Com- Automation">keysAndValuesDo: aBlock	"Enumerate over the collection of contained typeinfos. Each typeinfo is released after		the enumeration. For keeping typeinfos please use #select: or, 		inside create a separate reference inside the parameter block"	| anITypeInfo |	0 to: self getTypeInfoCount - 1		do: 			[:index |			anITypeInfo := self getTypeInfo: index.			aBlock value: index + 1 value: anITypeInfo]</body><body package="Com- Automation">select: aBlock	"For each member defined in the receiver, evaluate         &lt;aBlock&gt; with that member's ITypeInfo as the argument.         Answer a new collection containing those elements         of the receiver for which &lt;aBlock&gt; evaluates to true."	| memberTypeInfos anITypeInfo |	memberTypeInfos := OrderedCollection new.	0 to: self getTypeInfoCount - 1		do: 			[:index |			anITypeInfo := self getTypeInfo: index.			(aBlock value: anITypeInfo) ifTrue: [memberTypeInfos add: anITypeInfo]].	^memberTypeInfos</body></methods><methods><class-id>External.ITypeLib</class-id> <category>accessing</category><body package="Com- Automation">guid	^ [ self getLibAttr ] withResultDoAndRelease: [:attr | attr guid ]</body><body package="Com- Automation">path	| tLibAttr |	tLibAttr := self getLibAttr.	^	[self class		queryPathOfRegTypeLibrary: tLibAttr guid		majorVersion: tLibAttr majorVersion		minorVersion: tLibAttr minorVersion		lcid: tLibAttr lcid]			on: Error			do: [:ex | ex return: nil]</body></methods><methods><class-id>External.ITypeLib</class-id> <category>private</category><body package="Com- Automation">withLibAttrDo: aBlock 	| libAttr |	libAttr := self getLibAttr.	^ [ aBlock value: libAttr ] 		ensure: [ libAttr enforceRelease ].</body></methods><methods><class-id>External.ITypeLib</class-id> <category>methods</category><body package="Com- Automation">isName: aName	^self isName: aName hash: 0</body></methods><methods><class-id>External.ITypeLib class</class-id> <category>registry services</category><body package="Com- Automation">queryPathOfRegTypeLibrary: typeLibraryID	" Answer the path name of the type library registered under the GUID &lt;typeLibraryID&gt; for the current version. "	^self queryPathOfRegTypeLibrary: typeLibraryID lcid: STDOLE_LCID</body><body package="Com- Automation">queryPathOfRegTypeLibrary: typeLibraryID lcid: lcid	" Answer the path name of the type library registered under the GUID &lt;typeLibraryID&gt; for the current version with the specified locale ID. "	| versionNumbers |	versionNumbers := COMRegistryInterface typeLibraryCurrentVersionNumbers: typeLibraryID.	^self queryPathOfRegTypeLibrary: typeLibraryID 		majorVersion: ( versionNumbers at: 1 )		minorVersion: ( versionNumbers at: 2 )		lcid: lcid</body><body package="Com- Automation">queryPathOfRegTypeLibrary: typeLibraryID majorVersion: verMajor minorVersion: verMinor lcid: lcid	" Answer the path name of the type library registered under the GUID &lt;typeLibraryID&gt; for the specified version and locale ID&gt; "	| resultReference |	resultReference := nil asValueReference.	OLEAutomationDLL current QueryPathOfRegTypeLib: typeLibraryID 		_: verMajor 		_: verMinor 		_: lcid 		_: resultReference.	^resultReference value</body><body package="Com- Automation">unRegister: aGUID majorVersion: verMajor minorVersion: verMinor lcid: lcid        " Removes type library information from the system registry. Use this API to allow applications to properly uninstall themselves. In-process objects typically call this API from DllUnregisterServer. The following errors do not raise a COMError: TYPE_E_REGISTRYACCESS, TYPE_E_CANTLOADLIBRARY. If the oleaut32.dll DLL on this system does not support the UnRegisterTypeLib API, E_FAIL is returned (Windows 95 GA)."	( OLEAutomationDLL current includesEntryPoint: 'UnRegisterTypeLib' )		ifFalse: [ 			COMDevelopmentWarning raiseSignal:(#ErrNamedAutoNoUnRegister &lt;&lt; #com &gt;&gt; 'The &lt;1s&gt; DLL on this system does not support the UnRegisterTypeLib API.' expandMacrosWith: OLEAutomationDLL fileName).			^E_FAIL ].	^OLEAutomationDLL current UnRegisterTypeLibrary: aGUID		_: verMajor		_: verMinor		_: lcid		_: self sysKind</body></methods><methods><class-id>External.ITypeLib class</class-id> <category>instance creation</category><body package="Com- Automation">pathName: aPathName	" Answer a new instance of the receiver for the type library in the file named &lt;aPathName&gt;. "	| resultReference |	resultReference := self new asValueReference.	OLEAutomationDLL current LoadTypeLib: aPathName 		_: resultReference.	^resultReference value</body><body package="Com- Automation">registeredID: aGUID	" Answer a new instance of the receiver for the type library published in the system registry under the ID &lt;aGUID&gt;. "	^self registeredID: aGUID lcid: STDOLE_LCID</body><body package="Com- Automation">registeredID: aGUID lcid: lcid	" Answer a new instance of the receiver for the type library published in the system registry under the ID &lt;aGUID&gt;. "	| versionNumbers |	versionNumbers := COMRegistryInterface typeLibraryCurrentVersionNumbers: aGUID.	versionNumbers isNil 		ifTrue: [ ^nil ].   "?? COMError hresult: TYPE_E_LIBNOTREGISTERED ??"	^self registeredID: aGUID 		majorVersion: ( versionNumbers at: 1 )		minorVersion: ( versionNumbers at: 2 )		lcid: lcid</body><body package="Com- Automation">registeredID: aGUID majorVersion: verMajor minorVersion: verMinor lcid: lcid	" Answer a new instance of the receiver for the type library published in the system registry under the ID &lt;aGUID&gt;. "	| resultReference |	resultReference := self new asValueReference.	OLEAutomationDLL current LoadRegTypeLib: aGUID		_: verMajor		_: verMinor		_: lcid		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.ITypeLib class</class-id> <category>subclass-tracing</category><body package="Com- Automation">canTraceAdaptorAssumeHRESULT	" Answer whether a trace adaptor configured on an instance of the receiver can assume that the functions in the interface represented by the receiver follow the standard COM convention of returning an HRESULT as the function return value, with OUT values returned via parameter values. "	^false</body></methods><methods><class-id>External.ITypeLib class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">initialize	self iid: IID_ITypeLib.	self updateAndRegister</body><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: ITypeInfo;		yourself</body></methods><methods><class-id>External.COMDispatchInterface</class-id> <category>interface operations</category><body package="Com- Automation">getIDsOfNames: names		" Answer the DISPID's corresponding to a set of argument names. "	^self getIDsOfNames: names localeID: STDOLE_LCID</body><body package="Com- Automation">getIDsOfNames: names localeID: lcid		" Map a set of argument names into the corresponding set of		DISPID's which can be used with IDispatch::Invoke.		a corresponding set of DISPID's which can be used with IDispatch::Invoke.		Raise an exception if an error occurs.  Answer the DISPID's."	| resultReference |	resultReference := nil asValueReference.	interface GetIDsOfNames: IID_NULL 		_: names 		_: names size 		_: lcid 		_: resultReference.	^resultReference value</body><body package="Com- Automation">getTypeInfo	" Retrieve the ITypeInfo type information for the current locale. "	^(self getTypeInfoForLocale: COMSessionManager defaultLocaleID)		ifNil: [self getTypeInfoUsingTypeLibraries]</body><body package="Com- Automation">getTypeInfoCount		" Answer the number of type information interfaces that an		object provides.  (This will be either 0 or 1). "	| resultReference |	resultReference := nil asValueReference.	interface GetTypeInfoCount: resultReference.	^resultReference value</body><body package="Com- Automation">getTypeInfoForLocale: lcid		" Answer the ITypeInfo type information for the locale specified by &lt;lcid&gt;. "	| resultReference |	resultReference := ITypeInfo new asValueReference.	interface GetTypeInfo: 0 		_: lcid		_: resultReference.	^resultReference value</body><body package="Com- Automation">hasTypeInfo		" Answer whether the object provides type information. "	^self getTypeInfoCount = 1</body><body package="Com- Automation">invoke: dispidMember	localeID: lcid	flags: dispatchFlags	parameters: dispatchParameters	result: resultReference		"Invoke the method or property get/set function of the object 		identified by the DISPID &lt;dispidMember&gt; .		If a result value is expected, return it sending #value: to &lt;resultReference&gt;.		Answer the result value (nil if none).  Raise an exception if an error occurs. "	| exceptionInfoReference argErrorReference hresult |	exceptionInfoReference := nil asValueReference.	argErrorReference := nil asValueReference.	hresult := interface Invoke: dispidMember		_: IID_NULL		_: lcid		_: dispatchFlags		_: dispatchParameters		_: resultReference		_: exceptionInfoReference		_: argErrorReference.	(hresult succeeded)		ifFalse: [			self signalDispatchError: hresult 				exceptionInfo: exceptionInfoReference value				argError: argErrorReference value.			].	^resultReference == nil		ifTrue: [ nil ]  " no result value " 		ifFalse: [ resultReference value ]</body><body package="Com- Automation">invokeGet: dispidMember with: dispatchParameters localeID: lcid	"The member &lt;dispidMember&gt; is invoked as a method or as a property if a property has the same name. Answer the value of the property or the method call."	^self invoke: dispidMember		localeID: lcid		flags: DISPATCH_METHOD | DISPATCH_PROPERTYGET		parameters: dispatchParameters		result: self newValueReference</body><body package="Com- Automation">invokeMethod: dispidMember with: dispatchParameters		" Invoke the method identified by the DISPID &lt;dispidMember&gt;.		Answer the result value (nil if none). "	^self invokeMethod: dispidMember 		with: dispatchParameters 		localeID: STDOLE_LCID 		result: self newValueReference</body><body package="Com- Automation">invokeMethod: dispidMember with: dispatchParameters localeID: lcid		" Invoke the method identified by the DISPID &lt;dispidMember&gt;.		Answer the result value (nil if none). "	^self invokeMethod: dispidMember 		with: dispatchParameters 		localeID: lcid 		result: self newValueReference</body><body package="Com- Automation">invokeMethod: dispidMember with: dispatchParameters localeID: lcid result: resultReference		" Invoke the method identified by the DISPID &lt;dispidMember&gt;.		Answer the result value (nil if none). "	^self invoke: dispidMember		localeID: lcid		flags: DISPATCH_METHOD		parameters: dispatchParameters		result: resultReference</body><body package="Com- Automation">invokePropertyGet: dispidMember with: dispatchParameters		" Answer the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self invokePropertyGet: dispidMember 		with: dispatchParameters 		localeID: STDOLE_LCID</body><body package="Com- Automation">invokePropertyGet: dispidMember with: dispatchParameters localeID: lcid		" Answer the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self invoke: dispidMember		localeID: lcid		flags: DISPATCH_PROPERTYGET		parameters: dispatchParameters		result: self newValueReference</body><body package="Com- Automation">invokePropertyPut: dispidMember flags: flags with: dispatchParameters localeID: lcid		" Set the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self invoke: dispidMember		localeID: lcid		flags: flags		parameters: dispatchParameters		result: nil   " no return value "</body><body package="Com- Automation">invokePropertyPut: dispidMember with: dispatchParameters		" Set the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self invokePropertyPut: dispidMember 		with: dispatchParameters 		localeID: STDOLE_LCID</body><body package="Com- Automation">invokePropertyPut: dispidMember with: dispatchParameters localeID: lcid		" Set the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self invoke: dispidMember		localeID: lcid		flags: DISPATCH_PROPERTYPUT		parameters: dispatchParameters		result: nil   " no return value "</body><body package="Com- Automation">threadedInvoke: dispidMember localeID: lcid flags: dispatchFlags parameters: dispatchParameters result: resultReference	"Invoke the method or property get/set function of the object 		identified by the DISPID &lt;dispidMember&gt; .		If a result value is expected, return it sending #value: to &lt;resultReference&gt;.		Answer the result value (nil if none).  Raise an exception if an error occurs. "	| exceptionInfoReference argErrorReference hresult |	exceptionInfoReference := nil asValueReference.	argErrorReference := nil asValueReference.	hresult := COMThreadManager performInMTA:					[interface						Invoke: dispidMember						_: IID_NULL						_: lcid						_: dispatchFlags						_: dispatchParameters						_: resultReference						_: exceptionInfoReference						_: argErrorReference].	hresult succeeded		ifFalse: 			[self				signalDispatchError: hresult				exceptionInfo: exceptionInfoReference value				argError: argErrorReference value].	^resultReference == nil ifTrue: [nil] ifFalse: [resultReference value]	" no result value "</body><body package="Com- Automation">threadedInvokeGet: dispidMember with: dispatchParameters localeID: lcid	"The member &lt;dispidMember&gt; is invoked as a method or as a property if a property has the same name. Answer the value of the property or the method call."	^self threadedInvoke: dispidMember		localeID: lcid		flags: DISPATCH_METHOD | DISPATCH_PROPERTYGET		parameters: dispatchParameters		result: self newValueReference</body><body package="Com- Automation">threadedInvokeMethod: dispidMember with: dispatchParameters		" Invoke the method identified by the DISPID &lt;dispidMember&gt;.		Answer the result value (nil if none). "	^self threadedInvokeMethod: dispidMember 		with: dispatchParameters 		localeID: STDOLE_LCID 		result: self newValueReference</body><body package="Com- Automation">threadedInvokeMethod: dispidMember with: dispatchParameters localeID: lcid		" Invoke the method identified by the DISPID &lt;dispidMember&gt;.		Answer the result value (nil if none). "	^self threadedInvokeMethod: dispidMember 		with: dispatchParameters 		localeID: lcid 		result: self newValueReference</body><body package="Com- Automation">threadedInvokeMethod: dispidMember with: dispatchParameters localeID: lcid result: resultReference		" Invoke the method identified by the DISPID &lt;dispidMember&gt;.		Answer the result value (nil if none). "	^self threadedInvoke: dispidMember		localeID: lcid		flags: DISPATCH_METHOD		parameters: dispatchParameters		result: resultReference</body><body package="Com- Automation">threadedInvokePropertyGet: dispidMember with: dispatchParameters		" Answer the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self threadedInvokePropertyGet: dispidMember 		with: dispatchParameters 		localeID: STDOLE_LCID</body><body package="Com- Automation">threadedInvokePropertyGet: dispidMember with: dispatchParameters localeID: lcid		" Answer the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self threadedInvoke: dispidMember		localeID: lcid		flags: DISPATCH_PROPERTYGET		parameters: dispatchParameters		result: self newValueReference</body><body package="Com- Automation">threadedInvokePropertyPut: dispidMember with: dispatchParameters		" Set the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self threadedInvokePropertyPut: dispidMember 		with: dispatchParameters 		localeID: STDOLE_LCID</body><body package="Com- Automation">threadedInvokePropertyPut: dispidMember with: dispatchParameters localeID: lcid		" Set the value of the property identified by the DISPID &lt;dispidMember&gt;. "	^self threadedInvoke: dispidMember		localeID: lcid		flags: DISPATCH_PROPERTYPUT		parameters: dispatchParameters		result: nil   " no return value "</body></methods><methods><class-id>External.COMDispatchInterface</class-id> <category>accessing</category><body package="Com- Automation">dispatchInterface		"Answer the dispatch interface used by the receiver."	^self</body><body package="Com- Automation">specificationTable	| typeInfo |	typeInfo := self getTypeInfo.	^COMDispatchSpecificationTable specificationTableFor: typeInfo</body></methods><methods><class-id>External.COMDispatchInterface</class-id> <category>converting</category><body package="Com- Automation">asDispatchDriver	" Answer a dispatch driver on the receiver. "	^COMDispatchDriver on: self</body><body package="Com- Automation">asDispatchDriverResult	" Answer a dispatch driver on the receiver. "	^ COMDispatchDriver onNew: self</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^VT_DISPATCH</body></methods><methods><class-id>External.COMDispatchInterface</class-id> <category>private-error handling</category><body package="Com- Automation">checkInterfaceBindingIID: anInterfaceBinding 	" Private - verify that a consistent binding is being installed in the receiver. "	anInterfaceBinding isDispatch 		ifFalse: [self error: #ErrIIDMismatch &lt;&lt; #com &gt;&gt; 'IID mismatch']</body></methods><methods><class-id>External.COMDispatchInterface</class-id> <category>dispatch support</category><body package="Com- Automation">newValueReference    " Answer a new value reference for a reference argument to a dispatch interface member. "    ^self class newValueReference</body></methods><methods><class-id>External.COMDispatchInterface class</class-id> <category>subclass-tracing</category><body package="Com- Automation">traceAdaptorClass	" Answer the trace adaptor class which services instances of the receiver. "	| aTraceAdaptorClass |	aTraceAdaptorClass := super traceAdaptorClass.	" allow dual interfaces to inherit standard IDispatch tracing "	( self iid ~= IID_IDispatch	and: [ aTraceAdaptorClass == IUnknown traceAdaptorClass ] )		ifTrue: [ 			aTraceAdaptorClass := IDispatch traceAdaptorClass ].	^aTraceAdaptorClass</body></methods><methods><class-id>External.COMDispatchInterface class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: ITypeLib;		yourself</body></methods><methods><class-id>External.COMDispatchInterface class</class-id> <category>dispatch support</category><body package="Com- Automation">newValueReference    " Answer a new value reference for a reference argument to a dispatch interface member. "    ^COMVariantValueReference new</body><body package="Com- Automation">valueReferenceOn: aValue    " Answer a new value reference for a reference argument to a dispatch interface member with initial value &lt;aValue&gt;. "    ^COMVariantValueReference on: aValue</body></methods><methods><class-id>External.COMDispatchInterface class</class-id> <category>testing</category><body package="Com- Automation">isDispatch	" Answer whether the receiver is a dispatch interface which supports IDispatch. "	^true</body></methods><methods><class-id>External.COMDispatchInterface class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IDispatchInterface.  "A special generic dispathc interface IID is used for internal			identification of the abstract Smalltalk dispatch interface class under which			dual interfaces are implemented. "	self updateAndRegister.</body></methods><methods><class-id>External.IDispatch</class-id> <category>private-initialization</category><body package="Com- Automation">initialize		" Private - initialize a new instance of the receiver. "	self initializeIID.</body><body package="Com- Automation">initializeIID	"Private - Initialize the IID of the interface represented by the receiver."	self iid: IID_IDispatch.</body></methods><methods><class-id>External.IDispatch</class-id> <category>copying</category><body package="Com- Automation">copy        " Answer a copy of the receiver.  The copy is not separately        reference counted and should not be released unless the        it is explicitly reference counted. "    ^self class forIID: self iid        binding: self copyInterfaceBinding</body></methods><methods><class-id>External.IDispatch</class-id> <category>comparing</category><body package="Com- Automation">= anObject	" Answer whether the receiver and &lt;anObject&gt; represent the same interface. "	^anObject isCOMInterface 		and: [ ( self iid = anObject iid or: [ self class supportsIID: anObject iid ] )		and: [ self sameBindingAs: anObject ] ]</body></methods><methods><class-id>External.IDispatch</class-id> <category>identity</category><body package="Com- Automation">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid</body><body package="Com- Automation">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;. "	iid := anIID.	interface notNil 		ifTrue: [ interface iid: anIID ].</body></methods><methods><class-id>External.IDispatch class</class-id> <category>instance creation</category><body package="Com- Automation">forBinding: anInterfaceBinding	" Answer a new instance of the receiver with callin/callout binding &lt;anInterfaceBinding&gt;. "	^self new		interfaceBinding: anInterfaceBinding;			iid: anInterfaceBinding iid;		yourself</body><body package="Com- Automation">forIID: anIID	" Answer a new instance of the receiver for the interface specified by &lt;anIID&gt;. "	^self forIID: anIID binding: nil</body><body package="Com- Automation">new	" Answer a new instance of the receiver. "	^super new initialize</body></methods><methods><class-id>External.IDispatch class</class-id> <category>subclass-registration</category><body package="Com- Automation">registerIID        " Private - register the receiver as the interface class for its IID.  IDispatch actually registers a family of interface ID's. "	| pointerBindingClass callinBindingClass |	"Assert isTrue: [ self supportedIIDs includes: self iid ]."  " so we don't need explicit 'super registerIID' "	pointerBindingClass := self interfacePointerClass.	callinBindingClass := self interfaceImplementationClass.	self supportedIIDs do: [ :anIID |		pointerBindingClass registerIID: anIID 			forClass: pointerBindingClass.		callinBindingClass registerIID: anIID 			forClass: callinBindingClass.		self registerIID: anIID forClass: self ].</body><body package="Com- Automation">removeIID	" Private - remove the registration of the receiver as the interface class for its IID.  IDispatch actually registers a family of interface ID's. "	| pointerBindingClass callinBindingClass |	"Assert isTrue: [ self supportedIIDs includes: self iid ]."  " so we don't need explicit 'super removeIID' "	pointerBindingClass := self interfacePointerClass.	callinBindingClass := self interfaceImplementationClass.	self supportedIIDs do: [ :anIID |		pointerBindingClass notNil			ifTrue: [ pointerBindingClass removeIID: anIID ]			ifFalse: [ COMInterfacePointer removeInterfacePointerClassForIID: anIID ].  " remove order backstop "		callinBindingClass notNil			ifTrue: [ callinBindingClass removeIID: anIID ]			ifFalse: [ COMInterfacePointer removeInterfaceImplementationClassForIID: anIID ].    " remove order backstop "		self removeIID: anIID ].</body></methods><methods><class-id>External.IDispatch class</class-id> <category>identity</category><body package="Com- Automation">supportsDispatchIID: anIID	" Answer whether the receiver represents the dispatch interface identified by the IID &lt;anIID&gt;. "	^self supportedIIDs includes: anIID</body><body package="Com- Automation">supportsIID: anIID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^( super supportsIID: anIID )		or: [ self supportsDispatchIID: anIID ]</body></methods><methods><class-id>External.IDispatch class</class-id> <category>registration</category><body package="Com- Automation">registerDispatchIID: anIID	" Register the GUID &lt;anIID&gt; as the IID of a dispatch interface which is supported by an instance of the receiver. "    ( anIID isNil or: [ anIID = IID_NULL ] )        ifTrue: [ ^nil ].  " ignore null IID's of abstract interface classes "	self supportedIIDs add: anIID.	self registerIID: anIID forClass: self</body><body package="Com- Automation">removeDispatchIID: anIID	" Remove the registration of the GUID &lt;anIID&gt; as the IID of a dispatch interface which is supported by an instance of the receiver. "	self supportedIIDs remove: anIID ifAbsent: [].	self removeIID: anIID.</body></methods><methods><class-id>External.IDispatch class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMDispatchInterface;		yourself</body></methods><methods><class-id>External.IDispatch class</class-id> <category>private-accessing</category><body package="Com- Automation">supportedIIDs	" Private - answer the dispatch interface id's which can be represented by instances of the receiver. "	^SupportedIIDs ifNil: [self initializeSupportedIIDs]</body><body package="Com- Automation">supportedIIDs: aCollectionOfIIDs	" Private - specify the set of dispatch interface IID's that can be represented by instances of the receiver. "	SupportedIIDs := aCollectionOfIIDs.</body></methods><methods><class-id>External.IDispatch class</class-id> <category>private-instance creation</category><body package="Com- Automation">forIID: anIID binding: anInterfaceBinding	" Private - answer a new instance of the receiver with IID &lt;anIID&gt; which uses the callin/callout binding &lt;anInterfaceBinding&gt;. "	^self new		iid: anIID;		interfaceBinding: anInterfaceBinding;		yourself</body></methods><methods><class-id>External.IDispatch class</class-id> <category>private-installation</category><body package="Com- Automation">constructSupportedIIDs	" Private - answer the dispatch interface id's which can be represented by instances of the receiver. "	^Set		with: IID_IDispatch		with: IID_IFontDisp		with: IID_IPictureDisp</body><body package="Com- Automation">initializeSupportedIIDs	" Private - initialize the list of interfaces which are supported by the receiver. "	self supportedIIDs: self constructSupportedIIDs.	^ SupportedIIDs</body></methods><methods><class-id>External.IDispatch class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IDispatch.	self updateAndRegister.</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>private-value encoding</category><body package="Com- Automation">getInterfaceFrom: aValue	^aValue		ifNotNil: 			[(aValue isCOMInterface and: [aValue iid = self containedInterfaceIID])				ifTrue: [aValue]				ifFalse: 					["Query the correct interface"					aValue queryInterface: self typeDescription iid]]</body><body package="Com- Automation">ownCOMRecord	"return the variant's owned com record needed for setting values in it"	^ (COMRecord basicStructure: self recordPointer recordInfo: self recordInfo)		configureAsReferencedSubStruct;		yourself</body><body package="Com- Automation">privateClearRecordPointer	(self recordValueAt: #pvRecord) ifNotNil: 			[:pointer | 			pointer isValid 				ifTrue: 					["release the old record"					self recordInfo recordClear: pointer.					self recordValueAt: #pvRecord put: nil]]</body><body package="Com- Automation">privateRecordPointer	^ self recordValueAt: #pvRecord</body><body package="Com- Automation">privateSetRecordPointerTo: aValue 	self recordValueAt: #pvRecord put: aValue</body><body package="Com- Automation">recordPointer	^ self privateRecordPointer 		ifNil: [ self createRecordPointer ]		ifNotNil: [:pointer | 				pointer isValid 					ifTrue: [ pointer ]					ifFalse: [ self createRecordPointer ]]</body><body package="Com- Automation">xBOOL: aValue	"Private"	"Store &lt;aValue&gt; as a BOOL."	" VARIANT_BOOL: 0 == FALSE, -1 == TRUE "	self valueAt: #boolVal 		put: ( ( self asBoolean: aValue ) 			ifTrue: [ VARIANT_TRUE ] 			ifFalse: [ VARIANT_FALSE ])</body><body package="Com- Automation">xBSTR: aValue	"Private"	"Store &lt;aValue&gt; as a BSTR."	| aBstr allocated aBSTR |	aBstr := aValue ifNotNil: [ ( aValue isString		ifTrue: [ allocated := true. 			aBSTR := BSTRMemoryAddress allocateString: aValue.			[ aBSTR asPointerParameter ] ensure: [aBSTR enforceInvalidation ] ]		ifFalse: [			allocated := false. 			aValue class == BSTR				ifFalse: [ COMError raiseSignal: #ErrExpConvertToBSTR  &lt;&lt; #com &gt;&gt; 'explicit conversion to String or BSTR required' ].			aValue "structure" ] )].	self valueAt: #bstrVal put: aBstr asPointerParameter.	" ownership responsibility for releasing the BSTR now belongs to the structure "</body><body package="Com- Automation">xCY: aValue	"Private"    "Store &lt;aValue&gt; as a CURRENCY."	self 		valueAt: #cyVal 		put: ( COM_CY fromNumber: aValue ) contents.</body><body package="Com- Automation">xDATE: aValue    "Private"    "Store &lt;aValue&gt; as a DATE."	| aCOMDate |	aCOMDate := COMDate fromValue: aValue.	self valueAt: #date put: aCOMDate value.</body><body package="Com- Automation">xDECIMAL: aValue	"Private"	"Set the DECIMAL value"	| decimal |	decimal := self asCOM_DECIMAL.	[decimal value: aValue asCOMDecimalCompatibleValue]		ensure: [decimal enforceInvalidation]</body><body package="Com- Automation">xDISPATCH: inValue	"Private"	"Store &lt;aValue&gt; as an IDispatch."	self subclassResponsibility</body><body package="Com- Automation">xEMPTY: aValue	"Private"	"Store 0 to represent EMPTY."	self valueAt: #lVal put: 0.</body><body package="Com- Automation">xERROR: aValue	"Private"	"Store &lt;aValue&gt; as an SCODE."	self valueAt: #scode put: ( self asInteger: aValue ).</body><body package="Com- Automation">xI1: aValue	"Private"	"Store &lt;aValue&gt; as a char (signed char)."	self valueAt: #cVal put: ( self asInteger: aValue ).</body><body package="Com- Automation">xI2: aValue	"Private"	"Store &lt;aValue&gt; as a short."	self valueAt: #iVal put: ( self asInteger: aValue ).</body><body package="Com- Automation">xI4: aValue	"Private"	"Store &lt;aValue&gt; as a long."	self valueAt: #lVal put: ( self asInteger: aValue ).</body><body package="Com- Automation">xI8: aValue	"Private"	"Store &lt;aValue&gt; as a 8 byte integer."	self valueAt: #llVal put: ( self asInteger: aValue ).</body><body package="Com- Automation">xINT: aValue	"Private"	"Store &lt;aValue&gt; as a int."	self valueAt: #intVal put: ( self asInteger: aValue ).</body><body package="Com- Automation">xIllegal: anObject	"Private"	"This is a catch-all for vt values that cannot appear in VARIANTs."	self xIllegal</body><body package="Com- Automation">xNULL: aValue	"Private"	"Store 0 to represent NULL."	self valueAt: #lVal put: 0.</body><body package="Com- Automation">xR4: aValue	"Private"	"Store &lt;aValue&gt; as a float."	self valueAt: #fltVal put: ( self asFloat: aValue ).</body><body package="Com- Automation">xR8: aValue	"Private"	"Store &lt;aValue&gt; as a double."	self valueAt: #dblVal put: ( self asDouble: aValue ).</body><body package="Com- Automation">xRECORD: aValue 	"Private"	aValue setCOMRecordInVariant: self.</body><body package="Com- Automation">xUI1: aValue	"Private"	"Store &lt;aValue&gt; as an unsigned byte."	self valueAt: #bVal		put: ( ( self asInteger: aValue ) bitAnd: 16rFF ).</body><body package="Com- Automation">xUI2: aValue	"Private"	"Store &lt;aValue&gt; as an unsigned short."	self xI2: ( CIntegerType short cast: ( self asInteger: aValue ) ).</body><body package="Com- Automation">xUI4: aValue	"Private"	"Store &lt;aValue&gt; as an unsigned long."	self xI4: ( CIntegerType long cast: ( self asInteger: aValue ) ).</body><body package="Com- Automation">xUI8: aValue	"Private"	"Store &lt;aValue&gt; as a unsigned 8 byte int."	self valueAt: #ullVal put: ( self asInteger: aValue ).</body><body package="Com- Automation">xUINT: aValue	"Private"	"Store &lt;aValue&gt; as an unsigned integer."	self valueAt: #uintVal put: ( self asInteger: aValue ).</body><body package="Com- Automation">xUNKNOWN: aValue	"Private"	"Store &lt;aValue&gt; as an IUnknown."	self subclassResponsibility</body><body package="Com- Automation">xVARIANT: aValue	"Private"	"This is illegal since VARIANTs may only be passed by reference."	self xIllegal: aValue.</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>private-accessing</category><body package="Com- Automation">arrayElementType	^ self typeDescription arrayElementType</body><body package="Com- Automation">basicRefPointer: anAddress	"Private. Set the pointer to the VT_BYREF value.	Note: This method is not re-implemented in COM_VARIANT to raise an error. This would lead to too much code duplication (in COM_VARIANTARG) especially if you consider all of the other pointer field accessors that could be implemented."	self valueAt: #byref put: anAddress asPointerParameter.</body><body package="Com- Automation">getBasicValue		" Private - answer the basic value of the variant.		The type of the UNION field is specified by the VARTYPE value in the vt field. 		The type VT_ARRAY (8192) is handled in the code and not through this table."	self typeCode isNil ifTrue: [ ^nil ].	^self perform:		( DecoderSelectors			at: self noRefTypeCode + 1			ifAbsent: [ #xIllegal ] )</body><body package="Com- Automation">getSAFEARRAY	"Private. Get the receiver's structure of type VT_ARRAY | VT_BYREF, a SAFEARRAY structure"	^self getStructureByPointer: #SAFEARRAY</body><body package="Com- Automation">getStructureByPointer: aStructureSymbol	"Private. Get the structure of type &lt;aStructureSymbol&gt; pointed to by the receiver."	| lpValue lpStructure comStructureClass |	lpValue := self refPointer.	lpValue isNil 		ifTrue: [ ^nil ].	comStructureClass := COMStructure classForStructureNamed: aStructureSymbol.	lpStructure := comStructureClass type pointerType cast: lpValue.	^comStructureClass temporaryOn: lpStructure</body><body package="Com- Automation">refPointer	"Private. Answer the pointer to the VT_BYREF value.	Note: This method is not re-implemented in COM_VARIANT to raise an error. This would lead to too much code duplication (in COM_VARIANTARG) especially if you consider all of the other pointer field accessors that could be implemented."	| lpValue |	lpValue := self valueAt: #byref.	^lpValue isNull		ifTrue: [ nil ]		ifFalse: [ lpValue ]</body><body package="Com- Automation">refPointer: anAddress	^ self basicRefPointer: anAddress.</body><body package="Com- Automation">setArrayValue: aValue		" Private - set the value of the variant to the external representation of  an array containing the elements of &lt;aValue&gt;.  The type of the array elements is specified by the VARTYPE value which is modified by VT_ARRAY in the vt field. "	| safeArrayClass |	self containsFixedSizeArray ifTrue: [ ^ self safeArrayStructure at: #() put: aValue ].	safeArrayClass := COMStructure classForStructureNamed: #SAFEARRAY.	( aValue "isCollection" isKindOf: Collection )		ifTrue: [ 			^self safeArrayStructure:				( safeArrayClass fromCollection: aValue type: self arrayElementType ) ].	aValue class = COMSafeArray		ifTrue: [ ^self safeArrayStructure: aValue structure copy ].	( aValue isCOMStructure and: [ aValue isKindOf: safeArrayClass ] )		ifTrue: [ 			Tools.Note ISSUE.  " This probably shouldn't be supported.  Introduced COMSafeArray				as the public interface the safe arrays.  [DL 03-Apr-96] "			Assert shouldNotBe.			^self safeArrayStructure: aValue copy].	^COMError raiseSignal: #ErrCollectionTypeForArray &lt;&lt; #com &gt;&gt;'Collection required for variant type ARRAY.'</body><body package="Com- Automation">setBasicValue: aValue		" Private - set the basic value of the variant to the external representation of &lt;aValue&gt;.		The type of the UNION field is specified by the VARTYPE value in the vt field.		The type VT_ARRAY (8192) is handled in the code and not through this table."	      "An VT_ARRAY occured and produced and xIllegal because it was             not masked out. Assuming noRefTypeCode solution from COM 1.1e patches seems 		to be generally unsafe. Using baseTypeCode again - 		maybe that should be done in general. [AA 07/2004]"	self		perform:			( EncoderSelectors				at: self baseTypeCode + 1				ifAbsent: [ #xIllegal: ] )		with: aValue.</body><body package="Com- Automation">valueAt: memberName		" Private - answer the element named &lt;memberName&gt; in the value union. "	self subclassResponsibility.</body><body package="Com- Automation">valueAt: memberName put: aValue		" Private - set the element named &lt;memberName&gt; in the value union. "	self subclassResponsibility.</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>private-value decoding</category><body package="Com- Automation">containedInterfaceIID	^ self typeDescription iid</body><body package="Com- Automation">xBOOL	"Private"	"Translate the value to a boolean."	" VARIANT_BOOL: 0 == FALSE, -1 == TRUE "	^( VARIANT_FALSE = ( self valueAt: #boolVal  ) ) not</body><body package="Com- Automation">xBSTR	"Private"	"Translate the value to a string."	^( BSTR temporaryOn:		( BSTRMemoryAddress fromPointer:			( self valueAt: #bstrVal ) ) )				asString</body><body package="Com- Automation">xCY	"Private"    "Translate the value to a CURRENCY."	^( ( COMStructure classForStructureNamed: #CY )		temporaryOn: ( self valueAt: #cyVal  ) ) value</body><body package="Com- Automation">xDATE	"Private"    "Translate the value to a Timestamp."    ^( COMDate fromDATEValue: ( self valueAt: #date ) ) asTimestamp</body><body package="Com- Automation">xDISPATCH	"Private"	"Translate the value to an IDispatch object."	| aPointer |	aPointer := self valueAt: #pdispVal.	^aPointer isNull		ifTrue: [ nil ]		ifFalse: [ (IDispatchPointer newParameterAtAddress: aPointer) asInterfaceReference ]</body><body package="Com- Automation">xEMPTY	"Private"	"No value was specified."	^nil</body><body package="Com- Automation">xERROR	"Private"	"Translate the value to an SCODE."	| value |	value := HRESULT newCode: (self valueAt: #scode).	^value = DISP_E_PARAMNOTFOUND ifTrue: [Nothing] ifFalse: [value]</body><body package="Com- Automation">xI2	"Private"	"Translate the value to a 2-byte signed integer."	^self valueAt: #iVal</body><body package="Com- Automation">xI4	"Private"	"Translate the value to a 4-byte integer."	^self valueAt: #lVal</body><body package="Com- Automation">xIllegal	"Private"	"This is a catch-all for vt values that cannot appear in VARIANTs."	COMError raiseSignal: #ErrIllegalVTVariant &lt;&lt; #com &gt;&gt; 'Illegal VT for a VARIANT structure'</body><body package="Com- Automation">xNULL	"Private"	"Translate the value to a NULL value."	^nil</body><body package="Com- Automation">xR4	"Private"	"Translate the value to a Float."	^self valueAt: #fltVal</body><body package="Com- Automation">xR8	"Private"	"Translate the value to a Float."	^self valueAt: #dblVal</body><body package="Com- Automation">xRECORD	"Private - return a COMRecord which will not be finalized as it's memory is still managed by myself"	^self ownCOMRecord copy		"The comrecord is a copy of the original record. and has it's own memory areas.		 Memory referenced by the Record will not be released by the variant"		configureAsFullRecord;		yourself</body><body package="Com- Automation">xUI1	"Private"	"Translate the value to an unsigned byte."	^self valueAt: #bVal</body><body package="Com- Automation">xUI2	"Private"	"Translate the value to a 2-byte unsigned integer."	^CIntegerType unsignedShort cast: ( self xI2 )</body><body package="Com- Automation">xUI4	"Private"	"Translate the value to a 4-byte unsigned integer."	^CIntegerType unsignedLong cast: ( self xI4 )</body><body package="Com- Automation">xUNKNOWN	"Private"	"Translate the value to an IUnknown object."	| aPointer |	aPointer := self valueAt: #punkVal.	^aPointer isNull		ifTrue: [nil]		ifFalse: 			[((COMInterfacePointer classForIID: self containedInterfaceIID)				newParameterAtAddress: aPointer) asInterfaceReference]</body><body package="Com- Automation">xVARIANT	"Private"	"This is illegal since VARIANTs may only be passed by reference."	^self xIllegal</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>testing</category><body package="Com- Automation">allowsReference	"Subclass responsibility. Only COM_VARIANTs cannot accept references"	^self subclassResponsibility</body><body package="Com- Automation">containsInterface	"Answer whether the receiver contains 		an IDispatch or IUnknown, 		a reference to an IDispatch or IUnknown,		an array of IDispatch or IUnknown." 	^COMVariant containsInterfaceTypeCode: self typeCode.</body><body package="Com- Automation">containsRecord	^ self noRefTypeCode = VT_RECORD</body><body package="Com- Automation">containsValue	^ (self typeDescription variantContainsValue: self)</body><body package="Com- Automation">isArrayOfVariantOrInterface	"Answer whether the receiver contains a VARIANT or reference to a VARIANT." 		"Later implemented something in COMVariant class. Should probably be changed to:		 ^ COMVariant isArrayOfInterfacesOrVariant: self typeCode        [AA 09/2004]"	| elemTypecode |	^self isSafeArray and: [		elemTypecode := self arrayElementTypeCode.		(COMVariant isInterfaceTypeCode: elemTypecode) or: [COMVariant isVariantType: elemTypecode]		]</body><body package="Com- Automation">isBSTR 	^COMVariant isBstrType: self typeCode</body><body package="Com- Automation">isCOMInterface	"Added for compatibility with Interface bindings/interfaces - 	 used for OLEAutomationDLL&gt;releaseSafeArrayPutBuffer:for: [AA 08/2004] " 	^ self isInterface</body><body package="Com- Automation">isDecimal	"Answer whether the receiver contains a DECIMAL." 	^COMVariant isDecimalType: self typeCode</body><body package="Com- Automation">isEmpty	"Answer whether the receiver contains a VARIANT or reference to a VARIANT." 	^COMVariant isEmpty: self typeCode</body><body package="Com- Automation">isInterface	"Answer true if the receiver is typed to contain an IDispatch or IUnknown. Answer true if the receiver is typed to contain a pointer to an IDispatch or IUnknown. Answer false otherwise." 	^COMVariant isInterfaceTypeCode: self typeCode</body><body package="Com- Automation">isReference	"Answer &lt;true&gt; if the receiver's value is passed by reference."	^COMVariant isReferenceType: self typeCode</body><body package="Com- Automation">isSafeArray	"Answer whether the receiver contains a SAFEARRAY." 	^COMVariant isArrayType: self typeCode</body><body package="Com- Automation">isVariant	"Answer whether the receiver contains a VARIANT or reference to a VARIANT." 	^COMVariant isVariantType: self typeCode</body><body package="Com- Automation">isVariantByRef	"Answer whether the receiver is of type VT_VARIANT | VT_BYREF"	^self isVariant and: [self isReference]</body><body package="Com- Automation">isVariantPointer	"Answer whether the receiver contains a VARIANT or reference to a VARIANT." 	^COMVariant isVariantPointerType: self typeCode</body><body package="Com- Automation">valueMatchesMyType: anObject	"Check if the current type configuration of the variant allows holding the given value"	^self typeDescription canVariantContainValue: anObject		ofType: anObject comTypeDescription</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>accessing</category><body package="Com- Automation">arrayElementTypeCode	"Answer the type code, i.e. without ref or array type code bits."	^COMVariant arrayElementTypeCodeOf: self typeCode</body><body package="Com- Automation">asCOM_DECIMAL	"Private!!!"	"This method typecasts this VARIANT to a decimal - 	 only allowed when typecode is VT_DECIMAL"	| decType decimal |	self isDecimal		ifFalse: 			[self error: #ConvertingToDecimalOnlyAllowedForDecimalVariants &lt;&lt; #com						&gt;&gt; 'Converting a variant to a decimal is only allowed for variants containing decimals'].	decType := COM_DECIMAL type.	decimal := structure isPointer				ifTrue: [decType pointerType cast: structure]				ifFalse: [decType defaultDatumClass newDatum: structure datum ofType: decType].	^COM_DECIMAL temporaryOn: decimal</body><body package="Com- Automation">baseTypeCode	"Answer the type code of the basic value, i.e. without refs, arrays, etc."	^COMVariant baseTypeCodeOf: self typeCode</body><body package="Com- Automation">basicTypeCode: aTypecode	self subclassResponsibility</body><body package="Com- Automation">basicTypeDescription: anObject	(typeDescription ~= anObject) ifTrue: [		anObject 			ifNil: [ self basicTypeCode: VT_NULL ] 			ifNotNil: [ self basicTypeCode: anObject typecode ].		typeDescription := anObject.		self containsRecord ifTrue: [ 			self initRecordInfo ]].</body><body package="Com- Automation">basicValue: aValue 	"Set the variant value to the external representation of &lt;aValue&gt;. 	The type of the UNION field is specified by the VARTYPE value in the vt field."	self isReference 		ifTrue: [^self setRefValue: aValue].	(aValue isCOMStructure and: [aValue isVARIANT])		ifTrue: [^aValue convertTo: self].	self isSafeArray		ifTrue: [self setArrayValue: aValue]		ifFalse: [self setBasicValue: aValue]</body><body package="Com- Automation">comTypeDescription	^self typeDescription</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^self typeCode</body><body package="Com- Automation">commonSetRefValue: aValue	self refVariantValue		ifNil: [^nil]		ifNotNil: [:lpValue | lpValue basicValue: aValue]</body><body package="Com- Automation">fixedArrayDataPointer	^fixedArrayDataPointer</body><body package="Com- Automation">fixedArrayDataPointer: aPointer	fixedArrayDataPointer := aPointer.</body><body package="Com- Automation">getRealRefValue	"Answer the variant value.  The type of the UNION field is specified by the VARTYPE value in the vt field."	"Experimental - may fail because of missing recordInfo"	^ COMVariantValueReference on: (self refVariantValue realValue) 	"self realValueReferenceFrom: self refPointer type: self noRefTypeDescription"</body><body package="Com- Automation">getRefValue	"Answer the variant value.  The type of the UNION field is specified by the VARTYPE value in the vt field."	"Experimental - may fail because of missing recordInfo"	^self valueReferenceFrom: self refPointer type: self noRefTypeDescription</body><body package="Com- Automation">noRefTypeCode	"Answer the type code, without refs, but with arrays."	^COMVariant noRefTypeCodeOf: self typeCode</body><body package="Com- Automation">noRefTypeDescription	"Answer the type code, without refs, but with arrays."	^self typeDescription noRefType</body><body package="Com- Automation">realValue	"Answer the variant value. 	The type of the UNION field is specified by the VARTYPE value in the vt field."	self isReference		ifTrue: [ ^self getRealRefValue ].	self isSafeArray		ifTrue: [^self safeArrayStructure].	^self getBasicValue</body><body package="Com- Automation">refVariantValue 	| lpValue |	lpValue := self refPointer.	lpValue isNil		ifTrue: [ ^nil ].	"Create a temporary COMVariantValue to set the new value &lt;aValue&gt;.	Set the type code of the accessor object to the type code of new value and copy &lt;aValue&gt;.	[GDG 6/12/1998]"	"Bug - we just stored the correct type and now suddenly use a calculated value?	 Fixed this to use it my noRefTypeCode"	^ ( COMVariantValue typeDescription: self typeDescription noRefType pointer: lpValue )		fixedArrayDataPointer: self fixedArrayDataPointer;		yourself</body><body package="Com- Automation">setRefValue: aDispatchValueReference	"Set the variant value to the external representation of the object held by &lt;aDispatchValueReference&gt;.	A VARIANTARG can contain a reference to a VARIANT (VT_VARIANT | VT_BYREF).	The reference cannot be nested though, the VARIANT must contain a non-VARIANT value. "	^ aDispatchValueReference setVariantRefValueIn: self.</body><body package="Com- Automation">simpleRefVariantValue 	| lpValue |	lpValue := self refPointer.	lpValue isNil		ifTrue: [ ^nil ].	"Create a temporary COMVariantValue to set the new value &lt;aValue&gt;.	Set the type code of the accessor object to the type code of new value and copy &lt;aValue&gt;.	[GDG 6/12/1998]"	"Bug - we just stored the correct type and now suddenly use a calculated value?	 Fixed this to use it my noRefTypeCode"	^ ( COMVariantValue type: self noRefTypeCode pointer: lpValue )</body><body package="Com- Automation">typeCode	"Answer the type code of the receiver."	^self subclassResponsibility</body><body package="Com- Automation">typeCode: aTypeCode	self typeCode = aTypeCode ifTrue: [^self].	(self typeCode notNil and: [self isEmpty not]) ifTrue: [self clearVariant].	self basicTypeCode: aTypeCode</body><body package="Com- Automation">typeDescription	^typeDescription ifNil: [typeDescription := self computeTypeDescription]</body><body package="Com- Automation">typeDescription: aTypeDescription	self typeDescription = aTypeDescription ifTrue: [^self].	self isEmpty ifFalse: [self clearVariant].	self basicTypeDescription: aTypeDescription</body><body package="Com- Automation">value	"Answer the variant value. 	The type of the UNION field is specified by the VARTYPE value in the vt field."	self isReference		ifTrue: [ ^self getRefValue ].	self isSafeArray		ifTrue: [^self safeArrayStructure asArray].	^self getBasicValue</body><body package="Com- Automation">value: aValue	"Set the variant value to the external representation of &lt;aValue&gt;. 	The type of the UNION field is specified by the VARTYPE value in the vt field."	(self valueMatchesMyType: aValue)		ifTrue: [self containsValue ifTrue: [self releaseValue]]		ifFalse: 			[VariantChangeTypeNotification raiseRequest				ifTrue: [self typeDescription: aValue comTypeDescription]				ifFalse: 					[^self error: #TypeChangeDenied &lt;&lt; #com								&gt;&gt; 'The required change of a variant type was denied']].	self basicValue: aValue</body><body package="Com- Automation">xDECIMAL	"Private"	"get the DECIMAL value"	| decimal |	decimal := self asCOM_DECIMAL.	^[decimal value] ensure: [decimal enforceInvalidation]</body><body package="Com- Automation">xI1	"Private"	"get the 1-byte signed integer value."	^self valueAt: #cVal</body><body package="Com- Automation">xI8	"Private"	"get the 8-byte integer value"	^self valueAt: #llVal</body><body package="Com- Automation">xINT	"Private"	"get the integer value."	^self valueAt: #intVal</body><body package="Com- Automation">xUI8	"Private"	"get the 8-byte unsigned integer value."	^self valueAt: #ullVal</body><body package="Com- Automation">xUINT	"Private"	"get the unsigned integer value."	^self valueAt: #uintVal</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream		" Append a text description of the receiver to &lt;aStream&gt; "	super printOn: aStream.	( self structure isNil 	or: [ self isValid not ] )		ifTrue: [ ^self ].  " uninitialized instance "	aStream 		nextPutAll: ' (';		nextPutAll: self typeCodeDescription;"		nextPutAll: ', ';		nextPutAll: self valueDescription;"		nextPutAll: ')'.</body><body package="Com- Automation">typeCodeDescription		" Answer a string describing the type code of the receiver. "	^COMVariant typeCodeDescriptionOf: self typeCode</body><body package="Com- Automation">valueDescription	" Answer a string describing the value of the receiver. "	| val |	^[(val := self value) printString] on: COMError		do: [:ex | ^(#illegalValueType &lt;&lt; #com &gt;&gt; '(illegal value type)') asString]	" was: Error "</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>private-coercing</category><body package="Com- Automation">asBoolean: aValue		" Private - answer &lt;aValue&gt; as a Boolean. "	( aValue == true or: [ aValue == false ] )		ifTrue: [ ^aValue ].	aValue isString		ifTrue: [			( aValue sameAs: 'true' )				ifTrue: [ ^true ].			( aValue sameAs: 'false' )				ifTrue: [ ^false ].			].	^[ ( self asNumber: aValue ) asInteger ~= FALSE ]		on: MessageNotUnderstood		do: [ :ex | COMError raiseSignal: #ErrBooleanCoerce &lt;&lt; #com &gt;&gt; 'boolean coercion failed' ]</body><body package="Com- Automation">asDouble: aValue		" Private - answer &lt;aValue&gt; as a double-precision float. "	^[ ( self asNumber: aValue ) asDouble ]		on: MessageNotUnderstood		do: [ :ex | COMError raiseSignal: #ErrDoubleCoerce &lt;&lt; #com &gt;&gt; 'double coercion failure' ]</body><body package="Com- Automation">asFloat: aValue		" Private - answer &lt;aValue&gt; as a Float. "	^[ ( self asNumber: aValue ) asFloat ]		on: MessageNotUnderstood		do: [ :ex | COMError raiseSignal: #ErrFloatCoerce &lt;&lt; #com &gt;&gt;'float coercion failure' ]</body><body package="Com- Automation">asInteger: aValue		" Private - answer &lt;aValue&gt; as an integer. "	^[ ( self asNumber: aValue ) asInteger ]		on: MessageNotUnderstood		do: [ :ex | COMError raiseSignal: #ErrIntegerCoerce &lt;&lt; #com &gt;&gt; 'integer coercion failure' ]</body><body package="Com- Automation">asNumber: aValue 	"Private - answer &lt;aValue&gt; as a number."	aValue isInteger ifTrue: [^aValue].	aValue == nil ifTrue: [^0].	(aValue isKindOf: Boolean)		ifTrue: [^aValue coerceToCInteger].	(aValue class = ConstantDescription) ifTrue: [ ^ aValue value ].	aValue isNothing ifTrue: [^ DISP_E_PARAMNOTFOUND asInteger].	^aValue isString		ifTrue: [Number readFrom: aValue readStream]		ifFalse: [aValue]</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>private-releasing</category><body package="Com- Automation">clear	"Release external resources by using COM VariantClear API call.	 There are different implementations since COMVariantValue does not contain a complete Variant structure"	self subclassResponsibility</body><body package="Com- Automation">clearVariant	" Private - clear the VARIANTARG structure.  Release any referenced memory. "	self clear</body><body package="Com- Automation">releaseResources	"Private - release resources owned by the receiver. "	self clearVariant.	Tools.Note ISSUE.  " Added the following during VW port.  Isn't this		a memory leak bug in the VW/OLE prototype implementation?  [DL 03-Apr-96] "	super releaseResources.</body><body package="Com- Automation">releaseValue		| storedType |	storedType := self typeDescription.	self clear.	self basicTypeDescription: storedType.</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>private</category><body package="Com- Automation">computeTypeDescription 	^ DispTypeSpec fromVariant: self .</body><body package="Com- Automation">createRecordPointer	self privateSetRecordPointerTo: self recordInfo recordCreate.	^ self privateRecordPointer</body><body package="Com- Automation">errorTypeChangeNotAllowed	^ self error: #ChangingTypesOfVariantsIsNotAllowed &lt;&lt; #com &gt;&gt; 'Changing the type of a variant is not allowed'</body><body package="Com- Automation">initRecordInfo	| recordInfo |	recordInfo := self typeDescription recordInfo.	self recordValueAt: #pRecInfo put: recordInfo asPointerParameter.	recordInfo enforceInvalidation.</body><body package="Com- Automation">recordInfo	^(IRecordInfoPointer		newTemporaryInterfacePointerAtAddress: (self recordValueAt: #pRecInfo))			ifNotNil: [:recInfoPointer | recInfoPointer asInterfaceReference]</body><body package="Com- Automation">recordInfo: aRecordInfo	| recInfo |	(IRecordInfoPointer		newUncountedInterfacePointerAtAddress: (self recordValueAt: #pRecInfo))			ifNotNil: [:recInfoPointer | recInfoPointer enforceRelease].	recInfo := aRecordInfo ifNotNil: [ aRecordInfo asSeparateInterfacePointer ].	self recordValueAt: #pRecInfo put: recInfo asPointerParameter.	recInfo ifNotNil: [ recInfo enforceInvalidation ].</body><body package="Com- Automation">recordValueAt: anObject 	self subclassResponsibility</body><body package="Com- Automation">recordValueAt: aValue put: anObject 	self subclassResponsibility</body><body package="Com- Automation">setRecordPointerTo: aPointer	self privateClearRecordPointer.	self privateSetRecordPointerTo: aPointer.</body><body package="Com- Automation">withRecordInfoDo: aBlock	| recInfo |	^ (self containsRecord and: [ (recInfo := self recordInfo) notNil ])		ifFalse:[ self withReferencedRecordInfoDo: aBlock ]		ifTrue: [ aBlock value: recInfo ].</body><body package="Com- Automation">withReferencedRecordInfoDo: aBlock 	"my recordInfo is nil, try referenced or safearray recordInfos"	self isReference ifTrue: [ 		^ self simpleRefVariantValue withRecordInfoDo: aBlock ].	self isSafeArray ifTrue: [ 		^ self getSAFEARRAY withRecordInfoDo: aBlock ].	self error: (#CantGetRecordInfo &lt;&lt; #com &gt;&gt; 'Can not get RecordInfo')</body></methods><methods><class-id>External.COMVariantStructure</class-id> <category>private-support</category><body package="Com- Automation">containsFixedSizeArray	^fixedArrayDataPointer notNil and: [fixedArrayDataPointer isValid]</body><body package="Com- Automation">safeArrayStructure	" Private. "	| lpSafeArray aSafeArrayStruct |	lpSafeArray := self valueAt: #parray.	lpSafeArray isNull ifTrue: [^nil].	lpSafeArray class == CPointer 		ifTrue: 			[Tools.Note ISSUE.			Assert shouldNotBe.	" Bug workaround for union accessing??! 				We should be getting a structure pointer out of the #parray field.				Cloned slimey hack from COMMemoryAddress #allocateStructure:				[DL/GG 06-May-96] "			lpSafeArray := CCompositePointer newDatum: lpSafeArray datum						ofType: lpSafeArray type].	self containsFixedSizeArray 		ifTrue: [ aSafeArrayStruct := (COMStructure classForStructureNamed: #FIXEDSIZESAFEARRAY) 						temporaryOn: lpSafeArray fixedSizeDataPointer: self fixedArrayDataPointer ]		ifFalse: [ aSafeArrayStruct := (COMStructure classForStructureNamed: #SAFEARRAY) 						temporaryOn: lpSafeArray].	^aSafeArrayStruct</body><body package="Com- Automation">safeArrayStructure: aSafeArray 	"Private"	aSafeArray isInExternalMemory 		ifFalse: 			[^self 				error: #ErrARRAYInExt &lt;&lt; #com &gt;&gt; 'Variant ARRAY data must be in external memory.'].	self valueAt: #parray put: aSafeArray asPointerParameter.	aSafeArray enforceInvalidation.</body><body package="Com- Automation">valueReferenceFrom: lpValue type: baseTypeDescription	"Private. Answer a COMVariantValueReference with the data pointed to by &lt;lpValue&gt; of VT type code &lt;baseTypeCode&gt;. If &lt;lpValue&gt; is nil , answer nil."	lpValue isNil 		ifTrue: [ ^nil ].	^(COMVariantValueReference on: 		(COMVariantValue 			"Experimental: may fail because of missing IRecordInfo"			typeDescription:  baseTypeDescription			pointer: lpValue) value)		typeCode: baseTypeDescription typecode; yourself</body></methods><methods><class-id>External.COMVariantStructure class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">postLoadFrom: aParcel	"A Parcel's post-load method must be a class method taking one	 argument, the Parcel being loaded. "	COMStructure registerAutomationStructureSpecifications.</body><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: IDispatch;		yourself</body></methods><methods><class-id>External.COMVariantStructure class</class-id> <category>private-installation</category><body package="Com- Automation">clearTranslationMaps	"Create empty translation maps used to find selectors for setting/getting	  variant values"	DecoderSelectors := Array new: self vtMax + 1 withAll: #xIllegal.	EncoderSelectors := Array new: self vtMax + 1 withAll: #xIllegal:.</body><body package="Com- Automation">initializeTranslationMaps		" Private - initialize the type translation mapping specifications		for encoding and decoding variant values.   To support a new		variant type code, implement an encoding and decoding method		and register them in the translating maps defined here, indexed		by the variant type code for translation lookup. "		"self initializeTranslationMaps"		self clearTranslationMaps.		self registerSelector: #xEMPTY for: VT_EMPTY.		self registerSelector: #xNULL for: VT_NULL.		self registerSelector:  #xI1 for: VT_I1.				self registerSelector: #xI2 for: VT_I2.		self registerSelector: #xI4 for: VT_I4.		self registerSelector: #xI8 for: VT_I8.						self registerSelector: #xINT for: VT_INT.		self registerSelector: #xUI1 for: VT_UI1.		self registerSelector: #xUI2 for: VT_UI2.		self registerSelector: #xUI4 for: VT_UI4.		self registerSelector: #xUI8 for: VT_UI8.		self registerSelector: #xUINT for: VT_UINT.		self registerSelector: #xR4 for: VT_R4.		self registerSelector: #xR8 for: VT_R8.		self registerSelector: #xCY for: VT_CY.		self registerSelector: #xDATE for: VT_DATE.		self registerSelector: #xBSTR for: VT_BSTR.		self registerSelector: #xDISPATCH for: VT_DISPATCH.		self registerSelector: #xERROR for: VT_ERROR.		self registerSelector: #xBOOL for: VT_BOOL.		self registerSelector: #xVARIANT for: VT_VARIANT.		self registerSelector: #xUNKNOWN for: VT_UNKNOWN.		self registerSelector: #xDECIMAL for: VT_DECIMAL.		self registerSelector: #xRECORD for: VT_RECORD.</body><body package="Com- Automation">registerDecoder: decSymbol encoder: encSymbol for: aCode 	"register the given symbols as encoder/decoder or as the setter/getter for 	 values of the given type code"	(self includesSelector: decSymbol) 		ifFalse: 			[self 				error: (#InvalidDecoderSelector &lt;&lt; #com &gt;&gt; 'Invalid decoder selector &lt;1s&gt;' 						expandMacrosWith: decSymbol)].	DecoderSelectors at: aCode + 1 put: decSymbol.	(self includesSelector: decSymbol) 		ifFalse: 			[self 				error: (#InvalidEncoderSelector &lt;&lt; #com &gt;&gt; 'Invalid encoder selector &lt;1s&gt;' 						expandMacrosWith: encSymbol)].	EncoderSelectors at: aCode + 1 put: encSymbol</body><body package="Com- Automation">registerSelector: decSymbol for: aCode	"register the given symbol as encoder/decoder or as the setter/getter for 	 values of the given type code"	^ self registerDecoder: decSymbol encoder: (decSymbol,':') asSymbol for: aCode</body><body package="Com- Automation">vtMax	"the maximum basic typecode known to be supported by variants"	^ VT_RECORD</body></methods><methods><class-id>External.COMVariantStructure class</class-id> <category>instance creation</category><body package="Com- Automation">new: anInteger	"Answer a new instance of the receiver with size &lt;anInteger&gt; bytes."	self error: #ThisOperationIsCurrentlyNotSupported &lt;&lt; #com &gt;&gt; 'This operation is currently supported'.</body><body package="Com- Automation">type: aTypeCode value: aValue	"Answer a new instance of the receiver that represents &lt;aValue&gt; as type &lt;aTypeCode&gt;."	"VT_VARIANT, alone (without VT_BYREF) is not a legal value for the vt field in a structure, adjust."	| typeCode |	aTypeCode = VT_VARIANT		ifTrue: [ typeCode := aValue comVariantType ]		ifFalse: [ typeCode := aTypeCode ].	^ (self classForTypeCode: aTypeCode) new		basicTypeCode: typeCode;		basicValue: aValue;		yourself</body><body package="Com- Automation">typeDescription: aType value: aValue	"Answer a new instance of the receiver that represents &lt;aValue&gt; as type &lt;aTypeCode&gt;."	"VT_VARIANT, alone (without VT_BYREF) is not a legal value for the vt field in a structure, adjust."	| type |	aType isVariant		ifTrue: [type := DispTypeSpec fromVariantTypeCode: aValue comVariantType]		ifFalse: [type := aType].	^((self classForTypeCode: type typecode) new)		basicTypeDescription: type;		basicValue: aValue;		yourself</body><body package="Com- Automation">value: aValue	^ self type: aValue comVariantType value: aValue</body></methods><methods><class-id>External.COMVariantStructure class</class-id> <category>private</category><body package="Com- Automation">classForTypeCode: aTypeCode	^(COMVariant isReferenceType: aTypeCode)		ifTrue: [COM_VARIANTARG]		ifFalse: [COM_VARIANT]</body></methods><methods><class-id>External.COMVariantStructure class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: nil.	self initializeTranslationMaps.	self updateAndRegister</body></methods><methods><class-id>External.COMVariantValue</class-id> <category>accessing</category><body package="Com- Automation">basicTypeCode: anInteger	"Set the receiver's type code to be &lt;anInteger&gt;."	typeDescription := nil.	typeCode := anInteger.</body><body package="Com- Automation">setValue: aValue		" Set the value to &lt;aValue&gt;. "	self value: aValue.</body><body package="Com- Automation">typeCode	"Answer the type code of the receiver."	^typeCode</body></methods><methods><class-id>External.COMVariantValue</class-id> <category>private-accessing</category><body package="Com- Automation">valueAt: memberName		" Private - answer the element named &lt;memberName&gt; in the value union. "	^self memberAt: memberName</body><body package="Com- Automation">valueAt: memberName put: aValue		" Private - set the element named &lt;memberName&gt; in the value union. "	self memberAt: memberName put: aValue.</body></methods><methods><class-id>External.COMVariantValue</class-id> <category>testing</category><body package="Com- Automation">allowsReference	"Answer true, only COM_VARIANTs cannot accept references."	^true</body></methods><methods><class-id>External.COMVariantValue</class-id> <category>private</category><body package="Com- Automation">recordValueAt: aName 	^ (self structure refMemberAt: #recordData) memberAt: aName asSymbol</body><body package="Com- Automation">recordValueAt: aName put: aValue	(self structure refMemberAt: #recordData) memberAt: aName asSymbol put: aValue</body></methods><methods><class-id>External.COMVariantValue</class-id> <category>private-value encoding</category><body package="Com- Automation">xDISPATCH: inValue	"Private"	"Store &lt;aValue&gt; as an IDispatch."	| aValue interface |	aValue := inValue.	aValue notNil		ifTrue: 			[aValue isCOMInterface				ifTrue: 					[aValue isDispatch ifFalse: [COMError raiseSignal: 'IDispatch required']]				ifFalse: 					[(aValue respondsTo: #dispatchInterface)						ifTrue: [aValue := aValue dispatchInterface]]].	"A Variant must be separately reference counted"	interface := aValue ifNotNil: [aValue asSeparateInterfacePointer].	[self valueAt: #pdispVal put: interface asPointerParameter]		ensure: [interface enforceInvalidation]</body><body package="Com- Automation">xUNKNOWN: aValue	"Private"	"Store &lt;aValue&gt; as an IUnknown."	| actualInterface interface |	actualInterface := self getInterfaceFrom: aValue.	interface := actualInterface				ifNotNil: [actualInterface asSeparateInterfacePointer].	[self valueAt: #punkVal put: interface asPointerParameter]		ensure: [interface enforceInvalidation]</body></methods><methods><class-id>External.COMVariantValue</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	super initialize.	typeCode := VT_EMPTY.</body></methods><methods><class-id>External.COMVariantValue</class-id> <category>private-releasing</category><body package="Com- Automation">asTemporaryCompleteVariant	"return a temporary but complete variant instance which shares my memory.	 Internal - Pleas don't use. Only used for releasing"	| completeVariant castedUnion completeVariantStruct |	completeVariantStruct := (self class typeNamed: #VARIANT) malloc.	completeVariantStruct memberAt: #vt put: self typeCode.	"[AA 2005/02/09] cast my data into the type of the union member of the variant. 	 Common casting does not work since the union types do not seem to match, 	 although they actually do. Maybe someone should fix CCompoundType&gt;&gt;="	castedUnion := (self structure contents)				type: (completeVariantStruct memberAt: #u) type;				yourself.	completeVariantStruct memberAt: #u put: castedUnion.	completeVariant := COM_VARIANT temporaryOn: completeVariantStruct.	^completeVariant</body><body package="Com- Automation">clear	"Create a new VARIANT, including type description. Copy my data into this variant and call clear it. This will	 free BSTRs or interfaces if contained. Aftewards set my type to empty (which does nothing).	 My memory area remains unchanged as we can not be sure here that we own the entire memory area"	self asTemporaryCompleteVariant enforceRelease.	self basicTypeCode: VT_EMPTY</body></methods><methods><class-id>External.COMVariantValue class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMVariantStructure;		yourself</body></methods><methods><class-id>External.COMVariantValue class</class-id> <category>instance creation</category><body package="Com- Automation">type: aTypeCode pointer: aPointer    "Answer a new instance of the receiver using &lt;aPointer&gt; as its contents."	^( self temporaryOn: ( self type pointerType cast: aPointer ) )		typeCode: aTypeCode;		yourself</body><body package="Com- Automation">typeDescription: aType pointer: aPointer    "Answer a new instance of the receiver using &lt;aPointer&gt; as its contents."	^( self temporaryOn: ( self type pointerType cast: aPointer ) )		basicTypeDescription: aType;		yourself</body></methods><methods><class-id>External.COMVariantValue class</class-id> <category>subclass-instance creation</category><body package="Com- Automation">privateNew	" Private - answer a new instance of the receiver. "	^ super privateNew initialize</body></methods><methods><class-id>External.COMVariantValue class</class-id> <category>private</category><body package="Com- Automation">classForTypeCode: aTypeCode	^self</body></methods><methods><class-id>External.COMVariantValue class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #VariantValue.	" new type introduced		to support the Smalltalk binding layer.  This is the		union field #u from the VARIANT[ARG] structure. "	self updateAndRegister</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>converting</category><body package="Com- Automation">asCOMVariant	" Answer the receiver as a COM VARIANT.  Answer nil if the receiver cannot be represented by a known VARIANT type. "	^self</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>testing</category><body package="Com- Automation">allowsReference	"Answer false, only COM_VARIANTs cannot accept references."	^false</body><body package="Com- Automation">isVARIANT	"Answer &lt;true&gt; if the receiver supports the VARIANT protocol."	^true</body><body package="Com- Automation">isVariantClearRequired	"answer whether clearing the variant requires variantClear to be called to clear it"		self containsRecord ifTrue: [ ^true ].	self isBSTR ifTrue: [ ^ true ].	self isSafeArray ifTrue: [ ^ true ].		self isInterface ifTrue: [^ true ].		^ false</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>private-accessing</category><body package="Com- Automation">valueAt: memberName		" Private - answer the element named &lt;memberName&gt; in the value union. "	^self unionMemberAt: ( 'u.', memberName ) asSymbol</body><body package="Com- Automation">valueAt: memberName put: aValue		" Private - set the element named &lt;memberName&gt; in the value union. "	self unionMemberAt: ( 'u.', memberName ) asSymbol		put: aValue.</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>coercing</category><body package="Com- Automation">coerceTo: aTypeCode		" Answer a new VARIANT which is created by coercing		the receiver's VARTYPE to &lt;aTypeCode&gt;. "	| destVariant |	destVariant := ( self class classForType: aTypeCode ) new.	Tools.Note ISSUE.   " Temporarily patch in the following.  Storage management		of variants needs to be reviewd on VW.  [DL 15-Apr-96] "	destVariant gcCopyToHeap.	OLEAutomationDLL current VariantChangeType: destVariant		_: self		_: 0		_: aTypeCode.	^destVariant</body><body package="Com- Automation">convertTo: destVariant		" Convert the value of the receiver to type type of &lt;destVariant&gt;,		storing the new value in &lt;destVariant&gt;."	OLEAutomationDLL current VariantChangeType: destVariant		_: self		_: 0		_: destVariant typeCode.	^destVariant</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>accessing</category><body package="Com- Automation">basicTypeCode: anInteger	"Set the type code to &lt;anInteger&gt;."	typeDescription := nil.	self memberAt: #vt put: anInteger</body><body package="Com- Automation">getRealRefValue	"This is not a legal message for this data type, it is OK for the variantarg subclass though."	^self allowsReference		ifTrue: [super getRealRefValue]		ifFalse: [self noRefAllowedError]</body><body package="Com- Automation">getRefValue	"This is not a legal message for this data type, it is OK for the variantarg subclass though."	^self allowsReference		ifTrue: [super getRefValue]		ifFalse: [self noRefAllowedError]</body><body package="Com- Automation">setRefValue: aDispatchValueReference	"This is not a legal message for this data type"	^self noRefAllowedError</body><body package="Com- Automation">setVariantRefValueIn: aVariant	aVariant commonSetRefValue: self value.</body><body package="Com- Automation">typeCode	"Answer the type code."	^self memberAt: #vt</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>private-error</category><body package="Com- Automation">noRefAllowedError	"Raise an error since the user is trying to use a plain variant with by reference methods."	self 		error: #ErrTypeCantAccess &lt;&lt; #com &gt;&gt; 'This type cannot access references to values.'</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>private</category><body package="Com- Automation">recordValueAt: aName	^((self structure memberAt: #u) memberAt: #recordData) memberAt: aName</body><body package="Com- Automation">recordValueAt: aName put: aValue	((self structure refMemberAt: #u) refMemberAt: #recordData) memberAt: aName		put: aValue asPointerParameter</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>private-initializing</category><body package="Com- Automation">initialize	"Private. The VariantInit function initializes the VARIANTARG by setting the vt field to VT_EMPTY. Unlike VariantClear, this function does not interpret the current contents of the VARIANTARG. Use VariantInit to initialize new local variables of type VARIANTARG (or VARIANT)."	Tools.Note ISSUE.  " This isn't hooked up properly in all cases, I don't think.  [DL 15-Apr-06] "	OLEAutomationDLL current VariantInit: self</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>private-value encoding</category><body package="Com- Automation">xDISPATCH: inValue	"Private"	"Store &lt;aValue&gt; as an IDispatch."	| aValue interface |	aValue := inValue isValueReference ifTrue: [inValue value] ifFalse: [inValue].	aValue notNil		ifTrue: 			[aValue isCOMInterface				ifTrue: 					[aValue isDispatch						ifFalse: 							[COMError raiseSignal: #IDispatchRequired &lt;&lt; #com &gt;&gt; 'IDispatch required']]				ifFalse: 					[(aValue respondsTo: #dispatchInterface)						ifTrue: [aValue := aValue dispatchInterface]						ifFalse: 							[COMError raiseSignal: #IDispatchRequired &lt;&lt; #com &gt;&gt; 'IDispatch required']]].	interface := aValue ifNotNil: [aValue asSeparateInterfacePointer].	[self valueAt: #pdispVal put: interface asPointerParameter]		ensure: [interface enforceInvalidation]</body><body package="Com- Automation">xUNKNOWN: aValue	"Private"	"Store &lt;aValue&gt; as an IUnknown."	| actualInterface interface |	actualInterface := self getInterfaceFrom: aValue.	"A Variant must be separately reference counted"	interface := actualInterface				ifNotNil: [actualInterface asSeparateInterfacePointer].	[self valueAt: #punkVal put: interface asPointerParameter]		ensure: [interface enforceInvalidation]</body></methods><methods><class-id>External.COM_VARIANT</class-id> <category>private-releasing</category><body package="Com- Automation">clear	" Clear the contents of the receiver to release any structures allocated for its value. "	"Use this function to clear variables of type VARIANTARG (or VARIANT) before the memory containing the VARIANTARG is freed.The function clears a VARIANTARG by setting the vt field to VT_EMPTY and the wReserved field to 0. The current contents of the VARIANTARG are released first. If the vt field is VT_BSTR, the string is freed. If the vt field is VT_DISPATCH, the object is released. If the vt field has the VT_ARRAY bit set, the array is freed.In certain cases, it may be preferable to clear a variant in code without calling VariantClear. For example, you can change the type of a VT_I4 variant to another type without calling this function. However, you must call VariantClear if a VT_type is received but cannot be handled. Using VariantClear in these cases ensures that code will continue to work if Automation adds new variant types in the future."	self isVariantClearRequired 		ifTrue: [ [OLEAutomationDLL current VariantClear: self ] on: Error do: [:ex | self basicTypeCode: VT_EMPTY ]]		ifFalse: [self basicTypeCode: VT_EMPTY].	typeDescription := nil.</body><body package="Com- Automation">releaseValue		| type |	type := self typeDescription.	self clear.	self typeDescription: type.</body></methods><methods><class-id>External.COM_VARIANT class</class-id> <category>accessing</category><body package="Com- Automation">classForType: aTypeCode	" Answer the VARIANT structure wrapper class that best represents the type &lt;aTypeCode&gt;. "	^COMStructure classForStructureNamed:		( ( COMVariant isReferenceType: aTypeCode )			ifTrue: [ #VARIANTARG ]			ifFalse: [ #VARIANT ] )</body><body package="Com- Automation">enumeratorIID	" Answer the IID of the interface which enumerates collections containing instances of the receiver. "	^IID_IEnumVARIANT</body></methods><methods><class-id>External.COM_VARIANT class</class-id> <category>instance creation</category><body package="Com- Automation">new	" Answer a new instance of the receiver. "	^super new		initialize; 		yourself</body><body package="Com- Automation">newInFixedSpace	" Answer a new instance of the receiver with an internal byte buffer allocated in fixed space. "	^super new		initialize; 		yourself</body></methods><methods><class-id>External.COM_VARIANT class</class-id> <category>external-transformations</category><body package="Com- Automation">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a VARIANT value.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value.  By default, contents are returned as the actual value of the VARIANT.  If this is not desired, the caller must configure the buffer to return the actual VARIANT by sending #extractContentsAsVariant "	^COMVariantResultBuffer for: self 		type: self baseCType</body></methods><methods><class-id>External.COM_VARIANT class</class-id> <category>private-registration</category><body package="Com- Automation">registerEnumeratorIID	" Private - register the IID of the interface which enumerates collections containing instances of the receiver. "	IEnum		registerEnumeratorIID: self enumeratorIID		for: #VARIANT.  " hardwire name so subclass is benign "</body><body package="Com- Automation">removeEnumeratorIID	" Private - remove the registration of the IID of the interface which enumerates collections containing instances of the receiver. "	IEnum removeEnumeratorIID: self enumeratorIID.</body></methods><methods><class-id>External.COM_VARIANT class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMVariantValue;		yourself</body></methods><methods><class-id>External.COM_VARIANT class</class-id> <category>private-installation</category><body package="Com- Automation">ClassFinalizer    " COM_VARIANT ClassFinalizer "	self removeStructureName.	self removeEnumeratorIID.</body><body package="Com- Automation">obsolete	Tools.Note ISSUEin72. "I noticed this method was named obosolete which appears to be a typing 	mistake."	self ClassFinalizer.	super obsolete.</body></methods><methods><class-id>External.COM_VARIANT class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #VARIANT.	self updateAndRegister.	self registerEnumeratorIID</body></methods><methods><class-id>External.COM_VARIANTARG</class-id> <category>testing</category><body package="Com- Automation">allowsReference	"Answer true, only COM_VARIANTs cannot accept references."	^true</body></methods><methods><class-id>External.COM_VARIANTARG</class-id> <category>private-value encoding</category><body package="Com- Automation">referenceCheck	"Raise a COMError if the VT_BYREF flag is not set."	self isReference 		ifFalse: [ COMError raiseSignal: #ErrVariantMissingByref &lt;&lt; #com &gt;&gt; 'Cannot use a COM VARIANTARG with a VT_VARIANT value without VT_BYREF' ].</body><body package="Com- Automation">setRefDecimal: aValue	"private - set the BYREF decimal value. Decimals use up complete variant size"	^ self setRefVariant: aValue typeCode: VT_DECIMAL</body><body package="Com- Automation">setRefVariant: aValue typeCode: varType	"Private. Set thereceiver to hold a value of type VT_DECIMAL | VT_BYREF"	| aVariant var |	self referenceCheck.	varType isNil ifTrue: [COMError raiseSignal: #ErrValueNotMapVARType &lt;&lt; #com &gt;&gt; 'The value passed in does not map to a COM VARTYPE.'].	aVariant := self getVARIANTByRef.	aVariant isNil		ifTrue: [			"This should only happen in a client."			var := (COM_VARIANT type: varType value: aValue).			self basicRefPointer: var.			var enforceInvalidation ]		ifFalse: 			[			aVariant basicTypeCode: varType.			aVariant basicValue: aValue]</body><body package="Com- Automation">xVARIANT: aValue 	"Private. Set thereceiver to hold a value of type VT_VARIANT | VT_BYREF"	^ self setRefVariant: aValue typeCode: aValue comVariantType.</body></methods><methods><class-id>External.COM_VARIANTARG</class-id> <category>private-value decoding</category><body package="Com- Automation">getRefDecimal	"Private. get the BYREF decimal value"	| comVariant |	comVariant := self getVARIANTByRef.	comVariant isNil ifTrue: [ ^COMVariantValueReference new ].	^ (COMVariantValueReference on: comVariant value)		 typeCode: comVariant typeCode;		yourself</body><body package="Com- Automation">getRefRECORD	"Private. get the BYREF RECORD value"	| record |	record := COMRecord basicStructure: self recordPointer copy recordInfo: self recordInfo copy.	record configureAsReferencedSubStruct.	SystemGlobalRegistries safe: self forLifeTimeOf: record.	^ (COMVariantValueReference on: record)		 typeCode: VT_RECORD;		yourself</body><body package="Com- Automation">xVARIANT	"Private. Get the receiver's value of type VT_VARIANT | VT_BYREF "	| lpValue comVariant baseTypeCode |	comVariant := self getVARIANTByRef.	comVariant isNil ifTrue: [ ^COMVariantValueReference new ].	comVariant isReference		ifTrue: [ 			"According the Automation documentation, nested references are NOT allowed. But, it happens with MSIE 4.01 event BeforeNavigate2 argument #5: 'PostData', which is supposed to be an 'address' (VT_VARIANT | VT_BYREF).Instead of causing a walkback, answer a reference on the unwrapped structure the client can interpret as it sees fit. We choose to answer the structure and not the Smalltalk wrapper to force the client code to deal with this situation and interpret the bytes. Passing the &lt;comVariant&gt; back is OK since the memory will have not be released by the time the call reaches the client code. The memory is released after the client returns from the event notification. OTOH, for a value returned by reference, the memory would be freed. We cannot tell which is which from here. For now, pass the data along.[Gary 12/7/1998]"			"Now support nested variant pointers for removing trouble with [out] argument marshalling 			 after call, e.g. with beforeNavigate2 event of IExplorer [AA 2006/02/16] - return a nested 			 COMVariantValueReference on the actual value"			^ (COMVariantValueReference on: comVariant value) 					typeCode: comVariant typeCode;					yourself	].	"Experimental - may fail because of missing IRecordInfo"	baseTypeCode := comVariant typeDescription.	lpValue := comVariant structure refMemberAt: #u.	^self valueReferenceFrom: lpValue type: baseTypeCode</body></methods><methods><class-id>External.COM_VARIANTARG</class-id> <category>accessing</category><body package="Com- Automation">basicTypeCode: anInteger	"Set the type code to &lt;anInteger&gt;."	super basicTypeCode: anInteger.	(COMVariant isReferenceType: anInteger) ifTrue: [self allocateMemory]</body><body package="Com- Automation">commonSetRefValue: aValue 	"Set the variant value to the external representation of the object held by 	&lt;aDispatchValueReference&gt;. 	A VARIANTARG can contain a reference to a VARIANT (VT_VARIANT | VT_BYREF). 	The reference cannot be nested though, the VARIANT must contain a non-VARIANT value."	Tools.Note portingISSUE. "COM 7.2 used 'self baseTypeCode = VT_VARIANT' here"	^self isVariant		ifTrue: [			Tools.Note ISSUE.			"Why do we need the assumption bolted in here 			that the value is wrapped in a typed value reference 			(a COMDispatchValueReference)? 			That's OK, but then I can't just simply set the value 			of this directly, which seems bogus. [DL 09-Aug-96]"			"This is the case where a VARIANTARG contains a VT_VARIANT | VT_BYREF."			self xVARIANT: aValue ]		ifFalse: [			self isDecimal 					ifTrue: [ self setRefDecimal:  aValue] 				ifFalse: [				self containsRecord 					ifTrue: [self xRECORD: aValue ]					ifFalse: [ super commonSetRefValue: aValue]]]</body><body package="Com- Automation">getRealRefValue	"Answer the variant value reference. The type of the UNION field is specified by the VARTYPE value in the vt 	field. A VARIANTARG can contain references to other types. References to VARIANT are handled specially."	^self isVariant 		ifTrue: [self xVARIANT]		ifFalse: 			[self isDecimal 				ifTrue: [self getRefDecimal]				ifFalse: 					[self containsRecord ifTrue: [self getRefRECORD] ifFalse: [super getRealRefValue]]]</body><body package="Com- Automation">getRefValue	"Answer the variant value reference. The type of the UNION field is specified by the VARTYPE value in the vt 	field. A VARIANTARG can contain references to other types. References to VARIANT are handled specially."	^self isVariant 		ifTrue: [self xVARIANT]		ifFalse: 			[self isDecimal 				ifTrue: [self getRefDecimal]				ifFalse: 					[self containsRecord ifTrue: [self getRefRECORD] ifFalse: [super getRefValue]]]</body><body package="Com- Automation">refVariant	" get the value of an VariantArg. Only used for type detection.	  #getRefValue was not used since this causes addRef	  for possibly contained interfaces. [AA 09/2004]"	self isVariant		ifTrue: [^self getVARIANTByRef]		ifFalse: 			["For safety - let the caller know there is no referenced variant"			^nil]</body><body package="Com- Automation">setRefValue: aDispatchValueReference	"This is not a legal message for this data type, it is OK for the variantarg subclass though."	^ aDispatchValueReference setVariantRefValueIn: self.</body></methods><methods><class-id>External.COM_VARIANTARG</class-id> <category>private-accessing</category><body package="Com- Automation">allocateMemory	"Private - allocate memory for a reference value."	"note: happens on a client, not a server."	Tools.Note ISSUE. "The original VS implementation used the OLE 			task memory allocator for variants and dispatch params. 			The VW/OLE prototype used the heap. Install the latter, 			at least for now until storage allocation for these guys 			is reviewed and cleaned up. [DL 02-Apr-96]"			"VS implementation: 			| variantArgAddress | 			variantArgAddress := OLEMemoryAddress allocateMemory: self elementSize. 			variantArgAddress doesNotNeedFinalization. 			self addressAtOffset: self valueOffset put: variantArgAddress 			"	( (self isSafeArray and: [ self isReference not]) or: [ self isVariant or: [self isDecimal]] )		ifTrue: [			"will be allocated elsewhere (as in #xVARIANT: and #setSAFEARRAYByRef:), mark nil"			^self refPointer: nil].	(self containsRecord) ifTrue: [ ^ self ].	"All other type codes, no variant by ref. Arrays are at least a pointer to a structure."	 self refPointer: COMVariantValue new</body><body package="Com- Automation">getVARIANTByRef	"Private. Get the receiver's value of type VT_VARIANT | VT_BYREF"	| lpValue lpVariant |	self referenceCheck.	lpValue := self refPointer.	lpValue isNil 		ifTrue: [ ^nil ].	lpVariant := COM_VARIANT type pointerType cast: lpValue.	"Always return a variantarg here, even if its current type is not BYREF. 	The byref variant is also used for setting values, so the referenced variant type may change and get the 	BYREF flag set afterwards. If we have a simple Variant in this situation it will complain that it can not store	byref values. Although this case is normally forbidden by the VARIANT standard, it happened in the BeforeNavigate2 	Event of the Microsoft Internet Explorer. "	^ COM_VARIANTARG temporaryOn: lpVariant</body><body package="Com- Automation">refPointer: anAddress 	"Private"	"Set the pointer to the VT_BYREF value."	self basicRefPointer: anAddress.	anAddress enforceInvalidation.</body></methods><methods><class-id>External.COM_VARIANTARG</class-id> <category>private-releasing</category><body package="Com- Automation">clearVariant	" Private - clear the VARIANTARG structure.  Release any referenced memory. "	self releaseReference.	^ super clearVariant</body><body package="Com- Automation">releaseReference	" Private - clear the VARIANTARG structure.  Release any referenced memory. "	Tools.Note ISSUE.	" Can we just make this part of #clear?  If that is treated as a private		operation, which it probably should be, then let's shift this code there		and be done with it.  [DL 09-Aug-96] "	(self isValid and: [self isReference])		ifTrue: 			[" VariantClear does not release ref'd value "			self containsRecord				ifTrue: 					[^(self value value)						configureAsFullRecord;						enforceRelease]				ifFalse: 					[self isVariant						ifTrue: [self refVariant enforceRelease]						ifFalse: [self refVariantValue enforceRelease].					Tools.Note ISSUE	" Is the following useful or simply overzealous?? [DL 09-Aug-96] "].			self refPointer: nil]</body></methods><methods><class-id>External.COM_VARIANTARG</class-id> <category>As yet unclassified</category><body package="Com- Automation">releaseValue	self isReference		ifTrue: 			[self isVariant				ifTrue: [self refVariant clear]				ifFalse: [self refVariantValue clear]]		ifFalse: [super releaseValue]</body></methods><methods><class-id>External.COM_VARIANTARG class</class-id> <category>accessing</category><body package="Com- Automation">enumeratorIID	" Answer the IID of the interface which enumerates collections containing instances of the receiver. "	" VARIANTARG structures do not have an enumerator interface defined,		although the superclass VARIANT structure does "	^nil</body></methods><methods><class-id>External.COM_VARIANTARG class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_VARIANT;		yourself</body></methods><methods><class-id>External.COM_VARIANTARG class</class-id> <category>private-installation</category><body package="Com- Automation">ClassFinalizer    " COM_VARIANTARG ClassFinalizer "self removeStructureName.</body></methods><methods><class-id>External.COM_VARIANTARG class</class-id> <category>instance creation</category><body package="Com- Automation">forReference: aValue	" Answer a new instance of the receiver which passes &lt;aValue&gt; by reference. "    Tools.Note ISSUE. Tools.Note notYetImplemented.	" TO DO: implement a generic constructer of variants		which handles the typing automatically. 	E.g.,	^self new		vt: ( ( self typeFor: aValue ) | VT_BYREF );		value: aValue	"</body></methods><methods><class-id>External.COM_VARIANTARG class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #VARIANTARG.	self updateAndRegister.</body></methods><methods><class-id>External.COM_ARRAYDESC</class-id> <category>accessing</category><body package="Com- Automation">bounds	| bounds ptr |	bounds := Array new: self dims.	ptr := structure refMemberAt: #rgbounds.	1 to: self dims do: [:index |		bounds at: index put: 			(Interval  from: (ptr memberAt: #lLbound) size: (ptr memberAt: #cElements)).			ptr increment ].	^ bounds</body><body package="Com- Automation">dims	^ self memberAt: #cDims</body><body package="Com- Automation">rgbounds	^ structure refMemberAt: #rgbounds</body><body package="Com- Automation">typeCodeUsing: iTypeInfo	"Answer the integer that defines the type of the variable."	^self typeDescription typeCodeUsing: iTypeInfo</body><body package="Com- Automation">typeDescription	"Answer the type description member of the structure."	^self structureMemberAt: #tdescElem</body></methods><methods><class-id>External.COM_ARRAYDESC</class-id> <category>accessing-type information</category><body package="Com- Automation">sizeInBytes     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly. "	| nBytesBoundsStruct |	nBytesBoundsStruct := COM_SAFEARRAYBOUND sizeInBytes.		"( self typeProvider typeNamed: #SAFEARRAYBOUND ) sizeof"	^self class fixedDataSizeInBytes 		+ ( ( self memberAt: #cDims ) * nBytesBoundsStruct )</body></methods><methods><class-id>External.COM_ARRAYDESC class</class-id> <category>subclass-testing</category><body package="Com- Automation">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" an ARRAYDESC structure cannot be allocated in fixed space because the DLLCC		compilation technology for the trailing array of SAFEARRAYBOUND structures		appears to rest on the assumption that a pointer can be formed relative to the		base of the structure in order to access the array, which is only true when		the structure is itself a pointer into external memory "	^false</body></methods><methods><class-id>External.COM_ARRAYDESC class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_VARIANTARG;		yourself</body></methods><methods><class-id>External.COM_ARRAYDESC class</class-id> <category>accessing-type information</category><body package="Com- Automation">fixedDataSizeInBytes     " Answer the size in bytes of the fixed data layout portion of the structure represented by instances of the receiver.   An ARRAYDESC structure has a variable number of trailing SAFEARRAYBOUND structures, one for each array dimension. "	"^( COMExternalInterface typeNamed: #TYPEDESC ) sizeof + COMTypeAccessor USHORT sizeof + alignment packing "	^12</body><body package="Com- Automation">sizeInBytes     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly. "	self shouldNotImplement.  " depends on the number of array dimensions "</body></methods><methods><class-id>External.COM_ARRAYDESC class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #ARRAYDESC.	self updateAndRegister</body></methods><methods><class-id>External.COM_BLOB</class-id> <category>accessing</category><body package="Com- Automation">cbSize	" Answer the size in bytes of the data. "	^self memberAt: #cbSize</body><body package="Com- Automation">data	" Answer the data. "	| lpBytes |	lpBytes := self memberAt: #pBlobData.	^lpBytes isNull		ifTrue: [ nil ]		ifFalse: [ lpBytes ]</body></methods><methods><class-id>External.COM_BLOB</class-id> <category>converting</category><body package="Com- Automation">asByteArray	" Answer the bytes referenced by the receiver. "	| nBytes lpBytes bytes |	nBytes := self memberAt: #cbSize.	nBytes = 0		ifTrue: [ ^nil ].	lpBytes := self data.	Assert isValid: [ lpBytes ].	bytes := ByteArray new: nBytes.	lpBytes copyAt: 0		to: bytes		size: nBytes		startingAt: 1.	^bytes</body></methods><methods><class-id>External.COM_BLOB class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_ARRAYDESC;		yourself</body></methods><methods><class-id>External.COM_BLOB class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #BLOB.	self updateAndRegister</body></methods><methods><class-id>External.COM_CY</class-id> <category>accessing</category><body package="Com- Automation">unscaledInteger	"Answer the receiver as an unscaled integer."	^self memberAt: #int64</body><body package="Com- Automation">unscaledInteger: aNumber	"Set the receiver to hold &lt;aNumber&gt; as a fixed point with a scale of 4."	self memberAt: #int64 put: aNumber</body><body package="Com- Automation">value	"Answer the receiver as a fixed point (with scale 4)."	^FixedPoint numerator: self unscaledInteger		denominator: self denominator		scale: self scale</body><body package="Com- Automation">value: aNumber	"Set the receiver to hold &lt;aNumber&gt; as a fixed point with a scale of 4."	| aFixedPoint |	aFixedPoint := aNumber asFixedPoint: self scale.	self unscaledInteger: ( aFixedPoint * self denominator ) asInteger</body></methods><methods><class-id>External.COM_CY</class-id> <category>private-dimensions</category><body package="Com- Automation">denominator	"Private. Answer the denominator of the receiver to use with a FixedPoint."	^self class denominator</body><body package="Com- Automation">scale	"Private. Answer the scale of the receiver to use with a FixedPoint."	^self class scale</body></methods><methods><class-id>External.COM_CY</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	"Append the string representation of the receiver to aStream."	| valueString |	super printOn: aStream.	self isValid		ifTrue: [ valueString := self value printString ]		ifFalse: [ valueString := 'invalid' ].	aStream 		nextPutAll: ' (';		nextPutAll: valueString;		nextPut: $)</body></methods><methods><class-id>External.COM_CY class</class-id> <category>instance creation</category><body package="Com- Automation">fromNumber: aNumber	" Answer a new instance of the receiver that represents the unscaled numeric value &lt;aNumber&gt; in type CURRENCY.  &lt;aNumber&gt; is expected to be a kind of Number that responds to asFixedPoint: "	( COMCurrency validate: aNumber )		ifTrue: [ ^self new value: aNumber ]</body></methods><methods><class-id>External.COM_CY class</class-id> <category>private-dimensions</category><body package="Com- Automation">denominator	"Private. Answer the denominator of the receiver to use with a FixedPoint."	^10000</body><body package="Com- Automation">scale	"Private. Answer the scale of the receiver to use with a FixedPoint."	^4</body></methods><methods><class-id>External.COM_CY class</class-id> <category>external-transformations</category><body package="Com- Automation">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a CY or CURRENCY value.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^super resultValueBuffer		valueConstructionAction: [ :aCOMCY | aCOMCY value ];		yourself</body></methods><methods><class-id>External.COM_CY class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_BLOB;		yourself</body></methods><methods><class-id>External.COM_CY class</class-id> <category>private-installation</category><body package="Com- Automation">ClassFinalizer    " COMStructure ClassFinalizer "	self removeStructureName: #CURRENCY.	"super ClassFinalizer."</body><body package="Com- Automation">obsolete	self ClassFinalizer.	super obsolete.</body></methods><methods><class-id>External.COM_CY class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #CY.	self updateAndRegister.	self registerStructureName: #CURRENCY for: self	" the CURRENCY type is a synonym for CY and we want to handle both of those types through this wrapper "</body></methods><methods><class-id>External.COM_DISPPARAMS</class-id> <category>accessing</category><body package="Com- Automation">argumentCount	^ self memberAt: #cArgs</body><body package="Com- Automation">argumentIDs	"Answer the DISPIDs of the named arguments."	| nArgs dispids lpDISPID |	( nArgs := self memberAt: #cNamedArgs ) = 0		ifTrue: [ ^#() ].	dispids := Array new: nArgs.	lpDISPID := self memberAt: #rgdispidNamedArgs.	" the argument ID's are packed from last to first "	1 to: nArgs do:		[ :index |		dispids			at: ( nArgs - index + 1 )			put: lpDISPID contents.		lpDISPID increment ].	^dispids</body><body package="Com- Automation">argumentIDs: anArray	"Set the DISPID of named arguments to the integers in &lt;anArray&gt;."	| nArgs lprgNamedArgDispids lpDispid |	( nArgs := anArray size ) = 0		ifTrue: [ ^self ].	lprgNamedArgDispids := COMExternalInterface current DISPID malloc: nArgs.	lpDispid := lprgNamedArgDispids copy.	"The arguments are packed from last to first."	anArray reverseDo: [ :dispid |          lpDispid contents: dispid.          lpDispid increment ].	self		memberAt: #cNamedArgs put: nArgs;		memberAt: #rgdispidNamedArgs put: lprgNamedArgDispids.</body><body package="Com- Automation">argumentValues	"Answer the argument values."	^self arguments collect: [ :each | each value ]</body><body package="Com- Automation">arguments	" Answer the argument values as a list of VARIANTARG values.  The returned value is only valid within the lifetime of the containing DISPPARAMS structure, after which time the underlying storage backing the argument values is released and the VARIANTARG wrappers will be left with deadly dangling pointers. "	| nArgs arguments lpVariantArg |	nArgs := self memberAt: #cArgs.	arguments := Array new: nArgs.	lpVariantArg := self memberAt: #rgvarg.	" the arguments are packed from last to first "	1 to: nArgs do: [ :index |		" Note that we construct the arguments list of VARIANTARG wrappers			using the actual pointer to the external buffer.  This means			that the lifetime of the arguments return value provided			by this operation must be contained within the lifetime of			the DISPPARAMS itself.  It is the responsibility of the client			to ensure that the DISPARAMS is not released until			the arguments vector is unpacked into actual values. "		arguments at: ( nArgs - index + 1 )			put: ( COMStructure createStructureNamed: #VARIANTARG				atAddress: lpVariantArg copy ).		lpVariantArg increment ].	^arguments</body><body package="Com- Automation">arguments: anArray    "Set the arguments to the VARIANTARGS in &lt;anArray&gt;."	| nArgs lpVariantsBuffer lpVariantArg |	( nArgs := anArray size ) = 0		ifTrue: [ ^self ].	lpVariantsBuffer := COMExternalInterface current VARIANTARG calloc: nArgs.	lpVariantArg := lpVariantsBuffer copy.	"The arguments are packed from last to first."	anArray reverseDo: [ :aVariant |		" can omit VariantInit here because the VARIANT[ARG] structure bytes 			that we're stuffing in here are already properly set "		"OLEAutomationDLL current VariantCopy: lpVariantArg _: aVariant asPointerParameter."		lpVariantArg contents: aVariant asStructureParameter.		"The body of the variant is copied to the DISPPARAMS array. However, it may still reference other memory.		Therefore only release the variant structure"		aVariant releaseStructure.		lpVariantArg increment ].    self        memberAt: #cArgs put: nArgs;        memberAt: # rgvarg put: lpVariantsBuffer.</body><body package="Com- Automation">marshaledArgumentsCache: anObject	"cache pre-marshaled Objects in order to protect them from frinalization during the call.	 This is required since byref-objects are put into variants. Variants are not responsible for reference	  counting of by-ref objects so we are responsible here"	marshaledArgumentsCache := anObject</body><body package="Com- Automation">namedArgumentCount	^ self memberAt: #cNamedArgs</body></methods><methods><class-id>External.COM_DISPPARAMS</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseResources	" Private - release resources owned by the receiver. "	self structure notNil		ifTrue: [			self 				releaseArguments;				releaseArgumentIDs ].	super releaseResources.</body></methods><methods><class-id>External.COM_DISPPARAMS</class-id> <category>private-releasing</category><body package="Com- Automation">releaseArgumentIDs	" Private - release the named argument DISPID's allocated for the receiver. "	| aPointer |	( aPointer := self memberAt: #rgdispidNamedArgs ) isNull		ifFalse: [ aPointer free ].</body><body package="Com- Automation">releaseArguments	" Private - release the arguments allocated for the receiver. "	| nArgs lpVariantsBuffer lpVariantArg aVariantArg |	self marshaledArgumentsCache: nil.	(nArgs := self memberAt: #cArgs) = 0 ifTrue: [^self].	" release each variant value and the buffer itself "	lpVariantsBuffer := self memberAt: #rgvarg.	lpVariantArg := lpVariantsBuffer copy.	1 to: nArgs		do: 			[:index |			aVariantArg := COMStructure createStructureNamed: #VARIANTARG						atAddress: lpVariantArg copy.			"only VT_BYREF | VT_VARIANT types reference a foreign variant to be cleared"			aVariantArg isVariantByRef ifTrue: [aVariantArg refVariant clearVariant].			aVariantArg clearVariant.			lpVariantArg increment].	lpVariantsBuffer free</body></methods><methods><class-id>External.COM_DISPPARAMS class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_CY;		yourself</body></methods><methods><class-id>External.COM_DISPPARAMS class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #DISPPARAMS.	self updateAndRegister</body></methods><methods><class-id>External.COM_ELEMDESC</class-id> <category>accessing</category><body package="Com- Automation">idlDescription	"Answer the IDL description member of the structure."	^COMStructure createStructureNamed: #PARAMDESC		atAddress: (self unionMemberAt: #'u.idldesc')</body><body package="Com- Automation">parameterDescription	"Answer the IDL description member of the structure."	^COMStructure createStructureNamed: #PARAMDESC		atAddress: (self unionMemberAt: #'u.paramdesc')</body><body package="Com- Automation">typeCode	"Answer the integer that identifies the type of the element."	^self typeDescription typeCode</body><body package="Com- Automation">typeCodeUsing: iTypeInfo	"Answer the integer that identifies the type of the element."	^self typeDescription typeCodeUsing: iTypeInfo</body><body package="Com- Automation">typeDescription	"Answer the type description member of the structure."	^self structureMemberAt: #tdesc</body></methods><methods><class-id>External.COM_ELEMDESC class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_DISPPARAMS;		yourself</body></methods><methods><class-id>External.COM_ELEMDESC class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #ELEMDESC.	self updateAndRegister</body></methods><methods><class-id>External.COM_EXCEPINFO</class-id> <category>accessing</category><body package="Com- Automation">description		" Answer a textual, human-readable description of the error. "	^self bstrMemberAt: #bstrDescription</body><body package="Com- Automation">description: aString		" Specify a textual, human-readable description of the error. "	self bstrMemberAt: #bstrDescription put: aString.</body><body package="Com- Automation">helpFile		" Answer the fully qualified path name of a Help file		which contains information about the error. "	^self bstrMemberAt: #bstrHelpFile</body><body package="Com- Automation">helpFile: aString		" Specify the fully qualified path name of a Help file		which contains information about the error. "	self bstrMemberAt: #bstrHelpFile put: aString.</body><body package="Com- Automation">setInvocationExceptionDescription: descriptionString	" Set the receiver's state to describe an invocation exception from a Smalltak COM object. "	self 		sourceName: 'VisualWorks';		description: descriptionString.</body><body package="Com- Automation">sourceName		" Answer a textual, human-readable name of the source of the exception		(typically the application name). "	^self bstrMemberAt: #bstrSource</body><body package="Com- Automation">sourceName: aString		" Specify a textual, human-readable name of the source of the exception		(typically the application name). "	self bstrMemberAt: #bstrSource put: aString.</body><body package="Com- Automation">wCode		^self memberAt: #wCode</body></methods><methods><class-id>External.COM_EXCEPINFO</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt;. "	| aString |	super printOn: aStream.	( aString := self description ) notNil		ifTrue: [ aStream nextPutAll: ' (', aString, ')' ].</body></methods><methods><class-id>External.COM_EXCEPINFO</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseResources	"Private - release resources owned by the receiver."	#( #bstrDescription #bstrHelpFile #bstrSource ) do: [ :aMemberName |		self releaseBstrMemberAt: aMemberName ].	super releaseResources</body></methods><methods><class-id>External.COM_EXCEPINFO class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_ELEMDESC;		yourself</body></methods><methods><class-id>External.COM_EXCEPINFO class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #EXCEPINFO.	self updateAndRegister</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>accessing</category><body package="Com- Automation">bounds        " Answer an Array of bounds data. "	| dims rgsabound bounds |	dims := self memberAt: #cDims.	rgsabound := self memberAt: #rgsabound.	bounds := Array new: dims.	1 to: dims do: [ : index |		bounds			at: index			put: ( rgsabound at: index - 1 ).    ].    ^bounds</body><body package="Com- Automation">cDims	"Answer the count of dimensions in this array as stored in the receiver."	^self memberAt: #cDims</body><body package="Com- Automation">comTypeDescription	^self typeDescription</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "    ^VT_ARRAY | self typeDescription typeCode</body><body package="Com- Automation">dimensions	"Answer the number of dimensions in the receiver."	^OLEAutomationDLL current SafeArrayGetDim: self</body><body package="Com- Automation">elementCountAt: aDimensionIndex        " Private - Answer the number of elements of the        Nth dimension &lt;aDimensionIndex&gt; of the receiver."    ^( ( self upperBoundAt: aDimensionIndex )         - ( self lowerBoundAt: aDimensionIndex )        + 1 )</body><body package="Com- Automation">elementSize	"Answer the size, in bytes, of an element."	^OLEAutomationDLL current SafeArrayGetElemsize: self</body><body package="Com- Automation">lowerBoundAt: aDimensionIndex        " Private - Answer the lower bound of the Nth dimension &lt;aDimensionIndex&gt; of the receiver."	| bound |	bound := (lowerBounds ifNil: [ lowerBounds := Array new: self dimensions ])			at: aDimensionIndex.	bound isNil 			ifTrue: [		lowerBounds at: aDimensionIndex put: (self basicLowerBoundAt: aDimensionIndex) ].	^ lowerBounds at: aDimensionIndex</body><body package="Com- Automation">numElements	| bounds |	bounds := self reversedBounds.	bounds isEmpty ifTrue: [ ^ 0 ].	^ bounds inject: 1 into: [:all :each | all* each ].</body><body package="Com- Automation">recordInfo	^ OLEAutomationDLL current safeArrayGetRecordInfo: self</body><body package="Com- Automation">recordInfo: aRecordInfo	^ OLEAutomationDLL current SafeArraySetRecordInfo: self  _: aRecordInfo</body><body package="Com- Automation">reversedBounds	^self bounds reverse collect: [:bound | bound memberAt: #cElements]</body><body package="Com- Automation">setRGSBounds: aBounds        " Answer an Array of bounds data. "	self memberAt: #rgsabound put: aBounds</body><body package="Com- Automation">typeCode    " Answer the type code of the receiver as defined by the programmer.    The type code is set when the receiver is created with the class method #new:typeCode:.    Note that this is different than the fFeature flags, which does not always tell you the type    of a Safe Array. If a Safe Array is not made up of VARIANT, BSTR, DISPATCH or    UNKNOWN (as determined from the fFeatures flags), you must tell the Safe Array what is    the type of its elements. For example, VT_BOOL or VT_I4. This must be done in order for    the code what how to interpret the data pointer it receives and how to layout memory to set    values.    Note that for most dispatch interfaces, VT_VARIANT is used. "    ^self typeDescription typecode</body><body package="Com- Automation">typeCode: aTypeCode    " Set the type code of the receiver.    The type code is set when the receiver is created with the class method #new:typeCode:.    Note that this is different than the fFeature flags, which does not always tell you the type    of a Safe Array. If a Safe Array is not made up of VARIANT, BSTR, DISPATCH or    UNKNOWN (as determined from the fFeatures flags), you must tell the Safe Array what is    the type of it's elements. For example, VT_BOOL or VT_I4. This must be done in order for    the code to tell how to interpret the data pointer it receives and how to layout memory to set    values.    Note that for most disptach interfaces, VT_VARIANT is used. "    ( self isCompatibleTypeCode: aTypeCode )        ifFalse: [ COMError raiseSignal: #ErrFFeaturesIncompat &lt;&lt; #com &gt;&gt; 'fFeatures is set and incompatible request.' ].    self typeDescription: (DispTypeSpec fromVariantTypeCode: aTypeCode)</body><body package="Com- Automation">typeDescription	^typeDescription ifNil: [ typeDescription := DispTypeSpec fromVariant: self typeCode: ( 		OLEAutomationDLL current SafeArrayGetVartype: self) ]</body><body package="Com- Automation">typeDescription: anObject	typeDescription := anObject.</body><body package="Com- Automation">upperBoundAt: aDimensionIndex        " Private - Answer the upper bound of the Nth dimension &lt;aDimensionIndex&gt; of the receiver."    | resultReference |    resultReference := nil asValueReference.    OLEAutomationDLL current SafeArrayGetUBound: self        _: aDimensionIndex        _: resultReference.    ^resultReference value</body><body package="Com- Automation">withRecordInfoDo: aBlock	| recInfo |	recInfo :=  self recordInfo.			^ aBlock value: recInfo</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>private-testing</category><body package="Com- Automation">hasFeature: aFeatureFlag        " Private - Answer whether the FADF feature flag &lt;aFeatureFlag&gt; is set. "    ^( ( self memberAt: #fFeatures ) bitAnd: aFeatureFlag ) ~= 0</body><body package="Com- Automation">isCompatibleTypeCode: aTypeCode        " Private - Answer whether &lt;aTypeCode&gt; can be set by looking at the fFeatures flag. "    ( aTypeCode ~= VT_BSTR and: [ self isArrayOfBSTR ] )        ifTrue: [ ^false ].    ( aTypeCode ~= VT_VARIANT and: [ self isArrayOfVARIANT ] )        ifTrue: [ ^false ].    ( aTypeCode ~= VT_DISPATCH and: [ self isArrayOfDISPATCH ] )        ifTrue: [ ^false ].    ( aTypeCode ~= VT_UNKNOWN and: [ self isArrayOfUNKNOWN ] )        ifTrue: [ ^false ].    ^true</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>testing</category><body package="Com- Automation">canBeReleased	"Answer whether the receiver can be released from memory."	^( self isAllocatedOnStack or: [ self isAllocatedStatically ] ) not</body><body package="Com- Automation">isAllocatedOnStack	"Answer whether or not the array is allocated on the stack. "    ^self hasFeature: FADF_AUTO</body><body package="Com- Automation">isAllocatedStatically	"Answer whether or not the array is allocated statically. "    ^self hasFeature: FADF_STATIC</body><body package="Com- Automation">isArrayOfBSTR        " Answer whether or not the receiver is an array of BSTRs. "    ^self hasFeature: FADF_BSTR</body><body package="Com- Automation">isArrayOfDISPATCH        " Answer whether or not the receiver is an array of DISPATCHs. "    ^self hasFeature: FADF_DISPATCH</body><body package="Com- Automation">isArrayOfDecimal        " Answer whether or not the receiver is an array of BSTRs. "    ^self typeCode = VT_DECIMAL</body><body package="Com- Automation">isArrayOfStructs	^ self typeDescription isStructure</body><body package="Com- Automation">isArrayOfUNKNOWN        " Answer whether or not the receiver is an array of UNKNOWNs. "    ^self hasFeature: FADF_UNKNOWN</body><body package="Com- Automation">isArrayOfVARIANT        " Answer whether or not the receiver is an array of VARIANTs. "    ^self hasFeature: FADF_VARIANT</body><body package="Com- Automation">isEmbedded	"Answer whether or not the array is embedded in a structure. "    ^self hasFeature: FADF_EMBEDDED</body><body package="Com- Automation">isFixedSize	"Answer whether or not the array is not to be resize or re-allocated. "    ^self hasFeature: FADF_FIXEDSIZE</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>private-accessing</category><body package="Com- Automation">accessor	^ accessor ifNil: [ accessor := COMSafeArrayAccessor onSafeArray: self ]</body><body package="Com- Automation">basicLowerBoundAt: aDimensionIndex        " Private - Answer the lower bound of the Nth dimension &lt;aDimensionIndex&gt; of the receiver."    | resultReference |    resultReference := nil asValueReference.    OLEAutomationDLL current SafeArrayGetLBound: self        _: aDimensionIndex        _: resultReference.    ^resultReference value</body><body package="Com- Automation">referenceAccessor	^ COMSafeArrayReferenceAccessor onSafeArray: self</body><body package="Com- Automation">rgsabound        " Answer the address of the array data. "	^self structureMemberAt: #rgsabound</body><body package="Com- Automation">setCollection: aCollection 	" Private - Set the values in receiver to the ones in &lt;aCollection&gt;. "	^self accessor setCollection: aCollection</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>accessing-type information</category><body package="Com- Automation">sizeInBytes     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly. "	| nBytesBoundsStruct |	nBytesBoundsStruct := COM_SAFEARRAYBOUND sizeInBytes.		"( self typeProvider typeNamed: #SAFEARRAYBOUND ) sizeof"	^self class fixedDataSizeInBytes 		+ ( ( self memberAt: #cDims ) * nBytesBoundsStruct )</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>locking</category><body package="Com- Automation">lock		" Increment the receiver's lock count and place a pointer to the 		array data in its pvData field. "	OLEAutomationDLL current SafeArrayLock: self.</body><body package="Com- Automation">unlock		" Decrement the receiver's lock count so it can be freed or resized. "	OLEAutomationDLL current SafeArrayUnlock: self.</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseData	"Destroys all the data in a safe array. 	This function is typically used when freeing safe arrays that contain elements with data types other than variants. If objects are stored in the array, Release is called on each object in the array."	^OLEAutomationDLL current SafeArrayDestroyData: self.</body><body package="Com- Automation">releaseDescriptor	"Destroy the descriptor of the safeArray, not the data"	OLEAutomationDLL current SafeArrayDestroyDescriptor: self.	self structure enforceInvalidation.	self structure: nil.</body><body package="Com- Automation">releaseResources	" Private - release resources owned by the receiver. "	self canBeReleased ifFalse: [ ^self ].	OLEAutomationDLL current SafeArrayDestroy: self.	self structure enforceInvalidation.	self structure: nil.	super releaseResources</body><body package="Com- Automation">releaseStructure	" Private - release the structure itself. "	self isInExternalMemory 		ifTrue: [ self structure free ].	self structure: nil.	" Added the following code since I got in trouble when SafeArrays should be release 	  whose structure had alread been set to nil. Assuming the was caused by calling	  releaseStructure [AA 09/2004]"	self hasFinalization ifTrue: 		[ self doesNotNeedFinalization ].</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>converting</category><body package="Com- Automation">asArray	" Answer the values in receiver as an Array.        If an element is an interface, AddRef is called on that interface by COM from SafeArrayGetElement before returning.	  For backwards compatibility reasons this implementation will return a simple smalltalk array. 	  For converting the COM SafeArray into multiDimensional Smalltalk Array representation, 	  please use #asStRepresentation"	^self accessor asCollectionOfClass: Array</body><body package="Com- Automation">asElementsByteArray        " Answer the values in receiver as a ByteArray.        If an element is an interface, AddRef is called on that interface by COM from SafeArrayGetElement before returning."    ^self accessor asCollectionOfClass: ByteArray</body><body package="Com- Automation">asStRepresentation	"Answer the Smalltalk representation of this SafeArray that is either a multidimensional 	 array or a common Smalltalk array. This method has been added for not breaking backwards 	 compatibility by changing #asArray implementation"	^self dimensions &gt; 1 		ifTrue: [self asMultidimensionalArray]		ifFalse: [self asArray]</body><body package="Com- Automation">baseComVariantType	"Answer the type code which should be used to represent the receiver as a COM VARIANT value."	^VT_ARRAY</body><body package="Com- Automation">changeBounds: newBounds	"Changes the right-most (least significant) bound of a safe array.&lt;bounds&gt; [COM_SAFEARRAYBOUND] is a new safe array bound structure that contains the new array boundary. You can change only the least significant dimension of an array. If you reduce the bound of an array, SafeArrayRedim deallocates the array elements outside the new array boundary. If the bound of an array is increased, SafeArrayRedim allocates and initializes the new array elements. The data is preserved for elements that exist in both the old and new array."	^OLEAutomationDLL current SafeArrayRedim: self _: newBounds</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>private-converting</category><body package="Com- Automation">asMultidimensionalArray	| array bounds index |	bounds := self reversedBounds.	array := SafeArray new: bounds.	index := #().	self 		multiAt: index		bounds: bounds		into: array.	^array</body><body package="Com- Automation">multiAt: indices bounds: bounds into: array 	| cIndex |	(cIndex := indices size) &lt; bounds size 		ifTrue: 			[1 to: (bounds at: cIndex + 1)				do: 					[:index | 					self 						multiAt: (indices copyWith: index)						bounds: bounds						into: array]]		ifFalse: [array at: indices put: (self at: indices)]</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>accessing elements</category><body package="Com- Automation">at: indices        " Answer the element of the array at the position specified by &lt;indices&gt;.        If the element is an interface, the API calls AddRef on the interface before returning.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "	^ self accessor at: indices</body><body package="Com- Automation">at: indices put: aValue        " Set the element of the array at the position specified by &lt;indices&gt; to &lt;aValue&gt;.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "	^  self accessor at: indices put: aValue</body><body package="Com- Automation">referenceAt: indices	"Answer a reference variant to the element at the given index"	^ self referenceAccessor at: indices</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>copying</category><body package="Com- Automation">copy		" Answer a new SAFEARRAY which is a copy of the receiver. "	| resultReference |	resultReference := nil asValueReference.	OLEAutomationDLL current SafeArrayCopy: self _: resultReference.	Tools.Note ISSUE.  " Following was bug in VS 3.1.1 [DL 03-Apr-96] "	"^resultReference copy"	^resultReference value		typeCode: self typeCode;		yourself</body></methods><methods><class-id>External.COM_SAFEARRAY</class-id> <category>As yet unclassified</category><body package="Com- Automation">errorInvalidIndex		COMError hresult: DISP_E_BADINDEX</body></methods><methods><class-id>External.COM_SAFEARRAY class</class-id> <category>accessing-type information</category><body package="Com- Automation">fixedDataSizeInBytes     " Answer the size in bytes of the fixed data layout portion of the structure represented by instances of the receiver.   A SAFEARRAY structure has a variable-length array of SAFEARRAYBOUND structures, one per array dimension, as the last member of the structure. "	"^self baseCType sizeof - ( COMExternalInterface typeNamed: #SAFEARRAYBOUND ) sizeof"	^16</body><body package="Com- Automation">sizeInBytes     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly. "	self shouldNotImplement.  " depends on the number of array dimensions "</body></methods><methods><class-id>External.COM_SAFEARRAY class</class-id> <category>subclass-testing</category><body package="Com- Automation">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" a SAFEARRAY structure cannot be allocated in fixed space because the DLLCC		compilation technology for the trailing array of SAFEARRAYBOUND structures		appears to rest on the assumption that a pointer can be formed relative to the		base of the structure in order to access the array, which is only true when		the structure is itself a pointer into external memory "	^false</body></methods><methods><class-id>External.COM_SAFEARRAY class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_EXCEPINFO;		yourself</body></methods><methods><class-id>External.COM_SAFEARRAY class</class-id> <category>private-instance creation</category><body package="Com- Automation">boundsForIndices: indices        " Private - Answer a ByteArray buffer suitable for an API call.        The buffer contains a flattened Array of SAFEARRAYBOUND structures        defined by the Array &lt;indices&gt;. The leftmost element is the most-significant        and the rightmost element is the least significant."	| safeArrayBoundClass lpBoundsArray lpBound |	safeArrayBoundClass := COMStructure classForStructureNamed: #SAFEARRAYBOUND.	lpBoundsArray := safeArrayBoundClass type gcMalloc: indices size.	lpBound := lpBoundsArray copy.	indices do: [ :size |		self setBound: ( safeArrayBoundClass temporaryOn: lpBound )			forSize: size.		lpBound increment ].    ^lpBoundsArray</body><body package="Com- Automation">canBeElement: aValue        " Private - Answer whether or not &lt;aValue&gt; can be an element of a Safe Array.        Even though Strings and Symbols are Collections, they are considered to be atomic."        " NOTE: Collections cannot be elements in this implementation, since we are building        a multi-dimensional Safe Array. It is important to note that one could build a Safe        Array of VT_VARIANT types where each variant would itself contain a Safe Array,        such a scheme would present the overhead of a Safe Array for each element though."	"        Answer false if &lt;aValue&gt; is a Collection.        Answer false if &lt;aValue&gt; is a ByteArray.        Answer true if &lt;aValue&gt; is a String or a Symbol. "	Tools.Note ISSUE.  " Not clear whether #isCollection will be supported in Jigsaw.		Back it out, but review this when Core protocol is settled.  [DL 15-Aug-96] "	( aValue isString or: [ aValue isSymbol ] )		ifTrue: [ ^true ].	Tools.Note ISSUE.  " What about WordArray and other kinds of collections		which didn't exist in VSE?? "	( aValue isByteArray)		ifTrue: [ ^false ].	"Dictionaries can hold structures"	(aValue isKindOf: Dictionary ) ifTrue: [^ true ].	^( ( aValue isCollection) and: [ aValue class isPointers ] ) not	"VSE 3.1.2 implementation was:    aValue isByteArray         ifTrue: [ ^false ].    ^( aValue isCollection and: [ aValue class isPointers ] ) not"</body><body package="Com- Automation">fixVariantArrayBounds: someDims and: otherDims 	| index lastIndex |	index := 1.	lastIndex := someDims size min: otherDims size.		[index &lt;= lastIndex 		and: [(someDims at: index) = (otherDims at: index)]] 			whileTrue: [index := index + 1].	^ (someDims copyFrom: 1 to: index - 1)</body><body package="Com- Automation">setBound: aSafeArrayBound forSize: nElements        " Private - initialize the SAFEARRAYBOUNDS structure with an element count of &lt;nElements&gt; and the lower bound set to zero. "    ^aSafeArrayBound        elementCount: nElements;        lowerBound: 0;        yourself</body></methods><methods><class-id>External.COM_SAFEARRAY class</class-id> <category>private dimension utilities</category><body package="Com- Automation">collectionBoundaries: aCollection typeCode: aTypeCode 	"calculate the dimentsion of the given collection considering the typeCode that should be used	 for storing the collection's values"	^aCollection isMultidimensional 		ifTrue: [aCollection bounds]		ifFalse: 			[(aTypeCode bitAnd: VT_VARIANT) = VT_VARIANT 				ifTrue: [self variantCollectionBoundaries: aCollection]				ifFalse: [self nonVarCollectionBoundaries: aCollection]]</body><body package="Com- Automation">getBounds: aCollection onErrorDo: aBlock 	| firstSubDim currentSubDim |	(self canBeElement: aCollection) ifTrue: [^#()].	(aCollection isEmpty) ifTrue: [  ^ #(0) ].	(firstSubDim := self getBounds: aCollection first onErrorDo: aBlock) isNil 		ifTrue: [^nil].	2 to: aCollection size		do: 			[:index | 			currentSubDim := self getBounds: (aCollection at: index) onErrorDo: aBlock.			(self matchBoundsOf: firstSubDim and: currentSubDim) 				ifFalse: [firstSubDim := aBlock value: firstSubDim value: currentSubDim]].	^(Array with: aCollection size), firstSubDim</body><body package="Com- Automation">matchBoundsOf: anArray and: anotherArray	"check whether the two collections match, that is,	  whether the size of given collection is 	  (in any dimension) valid "	anArray size = anotherArray size 		ifFalse: [ ^ false ].			anArray keysAndValuesDo: [:index :element |		element = (anotherArray at: index)			ifFalse: [ ^ false ]].		^ true</body><body package="Com- Automation">nonVarCollectionBoundaries: aCollection 	"get the dimensions of the collection which shall be converted into a safeArray which does not hold	 variants. That means that it has to be be a square array - meaning, that the number of elements within 	 each dimension must be equal. Otherwise raise an error"	^self getBounds: aCollection		onErrorDo: [:firstColl :currentColl | self error: 'dimension mismatch']</body><body package="Com- Automation">variantCollectionBoundaries: aCollection 	"give a block which modifies the value of the first Dimension array valueHolder, that corrects it to	  the maximum matching size of both arrays "	^self getBounds: aCollection		onErrorDo: 			[:firstDims :currentDims | 			self fixVariantArrayBounds: firstDims and: currentDims]</body></methods><methods><class-id>External.COM_SAFEARRAY class</class-id> <category>dimension utilities</category><body package="Com- Automation">isMatrixLike: aCollection 	"Check whether aCollection is square like, meaning the number of elements 	  within each dimension must be equal."	"	(self isMatrixLike: #(1 #(2 3))) 						== false"	"	(self isMatrixLike: #(#(1 2 3) #(2 3 3))) 				== true"	"	(self isMatrixLike: #(#(#(1) #(2) #(3)) #(#(2) #(3) #(3)))) 	== true"	self getBounds: aCollection		onErrorDo: [:firstDims :currentDims | ^false].	^true</body></methods><methods><class-id>External.COM_SAFEARRAY class</class-id> <category>instance creation</category><body package="Com- Automation">boundForSize: nElements	" Answer a SAFEARRAYBOUNDS structure with an element count of &lt;nElements&gt; and the lower bound set to zero. "	| aSafeArrayBound |	Tools.Note ISSUE.  " Not sure we need this any more on VW.  Remove?  [DL 27-Mar-96] "		" And if we do keep it should this guy be gcCopyToHeap'd? [DL 16-Apr-96] "	aSafeArrayBound := COMStructure createStructureNamed: #SAFEARRAYBOUND.	self setBound: aSafeArrayBound forSize: nElements.	^aSafeArrayBound</body><body package="Com- Automation">fromCollection: aCollection type: aType	" Create a new instance of the receiver that contains the data in &lt;aCollection&gt; typed according to &lt;typeCode&gt;."	| values indices aSafeArrayStruct |	values := (( ( aCollection isKindOf: ByteArray ) or: [aCollection isMultidimensional])		ifTrue: [ aCollection ]		ifFalse: [ aCollection asArray ] ).	indices := self collectionBoundaries: values typeCode: aType typecode.	aSafeArrayStruct := self new: indices type: aType.	aSafeArrayStruct setCollection: values.	^aSafeArrayStruct</body><body package="Com- Automation">fromCollection: aCollection typeCode: typeCode	" Create a new instance of the receiver that contains the data in &lt;aCollection&gt; typed according to &lt;typeCode&gt;."	| values indices aSafeArrayStruct |	values := (( ( aCollection isKindOf: ByteArray ) or: [aCollection isMultidimensional])		ifTrue: [ aCollection ]		ifFalse: [ aCollection asArray ] ).	indices := self collectionBoundaries: values typeCode: typeCode.	aSafeArrayStruct := self new: indices typeCode: typeCode.	aSafeArrayStruct setCollection: values.	^aSafeArrayStruct</body><body package="Com- Automation">new: indices type: aType	" Create a new instance of the receiver with the dimensions defined by the Array &lt;indices&gt;.  The leftmost element is the most-significant and the rightmost element is the least significant.  The elements typed according to &lt;typeCode&gt;. "	| aSafeArrayStruct |	aSafeArrayStruct := aType newSafeArray: indices size				bounds: (self boundsForIndices: indices).	aSafeArrayStruct		typeDescription: aType;		needsFinalization.	^aSafeArrayStruct</body><body package="Com- Automation">new: indices typeCode: typeCode	" Create a new instance of the receiver with the dimensions defined by the Array &lt;indices&gt;.  The leftmost element is the most-significant and the rightmost element is the least significant.  The elements typed according to &lt;typeCode&gt;. "	| aSafeArrayStruct |	aSafeArrayStruct := OLEAutomationDLL current				SafeArrayCreate: typeCode				_: indices size				_: (self boundsForIndices: indices).	aSafeArrayStruct		typeCode: typeCode;		needsFinalization.	^aSafeArrayStruct</body></methods><methods><class-id>External.COM_SAFEARRAY class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #SAFEARRAY.	self updateAndRegister</body></methods><methods><class-id>External.COM_SAFEARRAYBOUND</class-id> <category>accessing</category><body package="Com- Automation">elementCount	^self memberAt: #cElements</body><body package="Com- Automation">elementCount: anInteger	self memberAt: #cElements put: anInteger.</body><body package="Com- Automation">lowerBound	^self memberAt: #lLbound</body><body package="Com- Automation">lowerBound: anInteger	self memberAt: #lLbound put: anInteger.</body><body package="Com- Automation">upperBound	^self lowerBound + self elementCount - 1</body></methods><methods><class-id>External.COM_SAFEARRAYBOUND</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream        " Append a textual representation of the receiver to aStream. "    super printOn: aStream.    self isValid ifFalse: [ ^self ].    aStream        nextPutAll: ' { ';        nextPutAll: self elementCount printString, ', ', self lowerBound printString;        nextPutAll: ' } '.</body></methods><methods><class-id>External.COM_SAFEARRAYBOUND class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_SAFEARRAY;		yourself</body></methods><methods><class-id>External.COM_SAFEARRAYBOUND class</class-id> <category>instance creation</category><body package="Com- Automation">arrayOfDimensions: dimArray	"Answer a ExternalBuffer that represents an array of SAFEARRAYBOUND whose size is the size of &lt;dimArray&gt; and whose contents represent the dimensions specified in &lt;dimArray&gt;."Tools.Note ISSUE; notYetPorted."VS/OLE implementation was: 	| size array |	size := self sizeInBytes.	array := ExternalBuffer new: size * dimArray size.	1 to: dimArray size do:		[:index |		array uLongAtOffset: index - 1 * size put: (dimArray at: index)].	^array"</body></methods><methods><class-id>External.COM_SAFEARRAYBOUND class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #SAFEARRAYBOUND.	self updateAndRegister</body></methods><methods><class-id>External.COM_TYPEDESC</class-id> <category>accessing</category><body package="Com- Automation">arrayType	^COMStructure createStructureNamed: #ARRAYDESC		atAddress: ( self unionMemberAt: #'u.lpadesc' )</body><body package="Com- Automation">hreftype	^self unionMemberAt: #'u.hreftype'</body><body package="Com- Automation">ptrType	^COMStructure createStructureNamed: #TYPEDESC 		atAddress: ( self unionMemberAt: #'u.lptdesc' )</body><body package="Com- Automation">typeCode	"Answer the type code."	^self vt</body><body package="Com- Automation">typeCodeUsing: iTypeInfo	"Answer the type code using &lt;iTypeInfo&gt;, an ITypeInfo, to retrieve additional type information if needed."	| code refType |	code := self vt.	code = VT_PTR		ifTrue:			[code := self ptrType typeCodeUsing: iTypeInfo.			^code isInteger				ifTrue: [VT_BYREF | code]				ifFalse: [code]].	code = VT_SAFEARRAY		ifTrue:			[code := self arrayType typeCodeUsing: iTypeInfo.			^code isInteger				ifTrue: [VT_ARRAY | code]				ifFalse: [code]].	code = VT_USERDEFINED		ifTrue:			[refType := iTypeInfo getRefTypeInfo: self hreftype.			code := self refTypeCode: refType.			^code].	^code</body><body package="Com- Automation">vt	"Answer the type code."	^self memberAt: #vt</body></methods><methods><class-id>External.COM_TYPEDESC</class-id> <category>private-utilities</category><body package="Com- Automation">refTypeCode: refType	"Query &lt;refType&gt; to determine the type code of the receiver."	^ refType refTypeCode</body></methods><methods><class-id>External.COM_TYPEDESC class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_SAFEARRAYBOUND;		yourself</body></methods><methods><class-id>External.COM_TYPEDESC class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #TYPEDESC.	self updateAndRegister</body></methods><methods><class-id>External.COM_DECIMAL</class-id> <category>accessing</category><body package="Com- Automation">Hi32	"Answer the Hi32 value of the receiver."	^self memberAt: #Hi32</body><body package="Com- Automation">Hi32: aValue	"Set the Hi32 value of the receiver."	^self memberAt: #Hi32 put: aValue</body><body package="Com- Automation">Lo64	"Answer the Lo64 value of the receiver."	^self unionMemberAt: 'u2.Lo64' asSymbol</body><body package="Com- Automation">Lo64: aValue	"Set the Lo64 value of the receiver."	^self unionMemberAt: 'u2.Lo64' asSymbol put: aValue</body><body package="Com- Automation">scale	"Answer the scale of the receiver."	^self signscaleStruct memberAt: #scale</body><body package="Com- Automation">scale: aValue	"Set the scale of the receiver."	self signscaleStruct memberAt: #scale put: aValue</body><body package="Com- Automation">scaledHi32	"Answer the Hi32 value of the receiver."	^self Hi32 * ( "2 raisedTo: 64" 18446744073709551616 )</body><body package="Com- Automation">sign	"Answer the sign of the receiver."	^self signscaleStruct memberAt: #sign</body><body package="Com- Automation">sign: aValue	"Set the sign of the receiver."	self signscaleStruct memberAt: #sign put: aValue</body><body package="Com- Automation">signscaleStruct	"Answer the signscale struct of the receiver."	"Need this method since the dot notation is only supported for one level."	^self referenceToNestedMemberAt: 'u1.s1' asSymbol</body><body package="Com- Automation">value	"Answer the receiver as a fixed point."	| sign |	sign := self sign = 16r80 ifTrue: [ -1 ] ifFalse: [ 1 ].	^FixedPoint numerator: sign * ( self scaledHi32 + self Lo64 )		denominator: (10 ** self scale)		scale: self scale</body><body package="Com- Automation">value: aFixedPoint	"Set the receiver to hold &lt;aNumber&gt; as a fixed point."	| aNum loBits |	aFixedPoint &gt; 0		ifTrue: [ self sign: 0 ]		ifFalse: [ self sign: 16r80 ].	self scale: aFixedPoint scale.	aNum := ( aFixedPoint * ( 10 raisedTo: aFixedPoint scale ) ) truncated abs.	loBits := aNum bitAnd: 16rFFFFFFFFFFFFFFFF.	self Lo64: loBits.	self Hi32: ( aNum bitShift: -64 ).</body></methods><methods><class-id>External.COM_DECIMAL</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	"Append the string representation of the receiver to aStream."	self isValid		ifFalse: [ ^super printOn: aStream ].	self value printOn: aStream.</body></methods><methods><class-id>External.COM_DECIMAL class</class-id> <category>instance creation</category><body package="Com- Automation">fromNumber: aNumber	" Answer a new instance of the receiver that represents the unscaled numeric value &lt;aNumber&gt; in type DECIMAL. "	^self new value: aNumber</body></methods><methods><class-id>External.COM_DECIMAL class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_TYPEDESC;		yourself</body></methods><methods><class-id>External.COM_DECIMAL class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #DECIMAL.	self updateAndRegister</body></methods><methods><class-id>External.COMTypeLibraryStructure</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseResources	" Private - release resources owned by the receiver. "	self structure == nil ifTrue: [^self].	" already released "		[(typeInterface notNil and: [typeInterface isValid])		ifTrue: [self releaseStructure]		ifFalse: 			[self structure: nil.	" Make sure structure vestiges are removed "			COMDevelopmentWarning				raiseSignal: (#WarnNamedUnableToRelease &lt;&lt; #com						&gt;&gt; 'Unable to release &lt;1s&gt; (interface already released)'							expandMacrosWith: self class name)]]			ensure: [typeInterface := nil].	super releaseResources</body><body package="Com- Automation">releaseStructure	" Private - release the receiver back to the interface from whence it came. "	self subclassResponsibility.</body></methods><methods><class-id>External.COMTypeLibraryStructure</class-id> <category>accessing</category><body package="Com- Automation">typeInterface	" Answer the type library interface from which the receiver was obtained. "	^typeInterface</body><body package="Com- Automation">typeInterface: anInterface	" Set the type library interface from which the receiver was obtained.  This is not a separate reference counted copy of the interface.  The client of the type library interfaces and these structures must ensure that the interface from which this structure was obtained is not released until the structures obtained from it are all released. "	typeInterface ifNotNil: [ SystemGlobalRegistries unprotect: typeInterface referencedBy: self ].	typeInterface :=  anInterface copy.	anInterface ifNotNil: [ SystemGlobalRegistries safe: typeInterface forLifeTimeOf: self ].</body></methods><methods><class-id>External.COMTypeLibraryStructure</class-id> <category>testing</category><body package="Com- Automation">isFuncDesc	" Answer whether the receiver is a FUNCDESC structure. "	^false</body><body package="Com- Automation">isVarDesc	" Answer whether the receiver is a VARDESC structure. "	^false</body></methods><methods><class-id>External.COMTypeLibraryStructure</class-id> <category>external-validation</category><body package="Com- Automation">checkToEnsureExternalMemoryBacking	" Private - check that the receiver's storage is still in external memory. "	" This is a correctness check for use by host binding layer  functions to ensure that type library structures obtained from the type library and type info interfaces are correctly imported into the system.  A failure of this check indicates a defect in the result buffer used to import these structures. "	(COMDevelopmentWarning displayWarningMessages 		and: [self isInExternalMemory not]) 			ifTrue: 				[COMDevelopmentWarning 					raiseSignal: (#WarnNamedStrucInMem &lt;&lt; #com 							&gt;&gt; 'The structure data of a &lt;1s&gt; has been been incorrectly brought into Smalltalk memory.  There is a problem in the function binding implementation which imported this structure value into the image that must be corrected.' 								expandMacrosWith: self class structureName)]</body></methods><methods><class-id>External.COMTypeLibraryStructure class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_DECIMAL;		yourself</body></methods><methods><class-id>External.COM_FUNCDESC</class-id> <category>accessing</category><body package="Com- Automation">flags 	^self memberAt: #wFuncFlags</body><body package="Com- Automation">functionKind	"Answer the code that describes how the function is invoked."	^self memberAt: #funckind</body><body package="Com- Automation">getName	"Answer the variable name."	^self typeInterface getName: self memberID</body><body package="Com- Automation">invocationStyle	"Answer the code that describes how the function is invoked."	^self memberAt: #invkind</body><body package="Com- Automation">memberID	"Answer the unique identifier of the member."	^self memberAt: #memid</body><body package="Com- Automation">oVft	^ self vtableOffset / CPointerType defaultPointer sizeof</body><body package="Com- Automation">optionalParameterCount	"Answer the number of optional parameters."	^self memberAt: #cParamsOpt</body><body package="Com- Automation">parameterCount	"Answer the total number of parameters, including optional parameters."	^self memberAt: #cParams</body><body package="Com- Automation">parameterTypeCodes	"Answer an array of descriptors for the parameters."	^self parameterValueDescriptions collect: [ :each | each typeCode ]</body><body package="Com- Automation">parameterTypeCodesUsing: iTypeInfo	"Answer an array of descriptors for the parameters."	^self parameterValueDescriptions collect: [ :each | 		each typeCodeUsing: iTypeInfo ]</body><body package="Com- Automation">parameterValueDescriptions    "Answer an array of descriptors for the parameters."	| elemDescPointer nParms elemDescs |	elemDescPointer := self memberAt: #lprgelemdescParam.	nParms := self parameterCount.	elemDescs := Array new: nParms.	( 1 to: nParms ) do: [ :i |		elemDescs at: i put: ( COMStructure createStructureNamed: #ELEMDESC			atAddress: elemDescPointer copy ).		elemDescPointer increment ].	^elemDescs</body><body package="Com- Automation">parameters	"Answer an array of descriptors for the parameters."	| names optParamCount descriptions params |	names := self typeInterface getNames: self memberID				count: self parameterCount + 1.	optParamCount := self optionalParameterCount.	descriptions := self parameterValueDescriptions.	params := Array new: descriptions size.	descriptions keysAndValuesDo: 			[:index :each | 			params at: index				put: (COMParameterDescription 						fromElemDesc: each						typeInfo: self typeInterface						name: (names at: index + 1 ifAbsent: [ nil ]))].	params size to: params size - optParamCount + 1		by: -1		do: [:index | (params at: index) beOptional].	^params</body><body package="Com- Automation">propertyValueDescription	"Answer the type description of a property desribed by a FUNCDESC"	^self returnValueDescription</body><body package="Com- Automation">returnValue	"Answer the in-image type description of the return type"	^COMReturnValueDescription fromElemDesc: self returnValueDescription typeInfo: self typeInterface</body><body package="Com- Automation">returnValueDescription	"Answer the type and IDL descriptions of the return value."	^self structureMemberAt: #elemdescFunc</body><body package="Com- Automation">typeCode	"Answer the integer that defines the type of the variable."	^self returnValueDescription typeCode</body><body package="Com- Automation">typeCodeUsing: iTypeInfo	"Answer the integer that defines the type of the variable."	^self returnValueDescription typeCodeUsing: iTypeInfo</body><body package="Com- Automation">vtableIndex	"Return the vtable index if the function is virtual"	^ (self isVirtualFunction or: [self isPureVirtualFunction]) ifTrue: [self oVft] ifFalse: [ nil ]</body><body package="Com- Automation">vtableOffset	"return the offset of the member in the vtable"	^ self memberAt: #oVft</body></methods><methods><class-id>External.COM_FUNCDESC</class-id> <category>testing</category><body package="Com- Automation">isDispatch	" Answer whether the function described by the receiver is a dispatch interface function. "	^self invocationStyle = DISPATCH_METHOD</body><body package="Com- Automation">isFuncDesc	" Answer whether the receiver is a FUNCDESC structure. "	^true</body><body package="Com- Automation">isPropertyGet	" Answer whether the function described by the receiver is a dispatch interface property getter function. "	^self invocationStyle = DISPATCH_PROPERTYGET</body><body package="Com- Automation">isPropertyPut	" Answer whether the function described by the receiver is a dispatch interface property setter function. "	^self invocationStyle = DISPATCH_PROPERTYPUT</body><body package="Com- Automation">isPropertyPutRef	" Answer whether the function described by the receiver is a dispatch interface property setter function. "	^self invocationStyle = DISPATCH_PROPERTYPUTREF</body><body package="Com- Automation">isPropertySpecification	^self isPropertyGet or: [self isPropertyPut or: [self isPropertyPutRef]]</body><body package="Com- Automation">isRestricted	" Answer whether the function described by the receiver is a restricted-access function whose visibility should be limited in tools. "	^( ( self memberAt: #wFuncFlags ) bitAnd: FUNCFLAG_FRESTRICTED ) = FUNCFLAG_FRESTRICTED</body></methods><methods><class-id>External.COM_FUNCDESC</class-id> <category>private-accessing</category><body package="Com- Automation">elemdescFunc	^self structureMemberAt: #elemdescFunc</body></methods><methods><class-id>External.COM_FUNCDESC</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseStructure	" Private - release the receiver back to the interface from whence it came. "	self structure == nil		ifTrue: [ ^self ].  " already released "	typeInterface releaseFuncDesc: self.	self structure enforceInvalidation.	self structure: nil.</body></methods><methods><class-id>External.COM_FUNCDESC</class-id> <category>testing function kind</category><body package="Com- Automation">isNonVirtualFunction	^ self functionKind = FUNC_NONVIRTUAL</body><body package="Com- Automation">isPureDispatchFunction	"Function can only be called through IDispatch"	^ self functionKind = FUNC_DISPATCH</body><body package="Com- Automation">isPureVirtualFunction	^ self functionKind = FUNC_PUREVIRTUAL</body><body package="Com- Automation">isStaticFunction	^ self functionKind = FUNC_STATIC</body><body package="Com- Automation">isVirtualFunction	^ self functionKind = FUNC_VIRTUAL</body></methods><methods><class-id>External.COM_FUNCDESC class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMTypeLibraryStructure;		yourself</body></methods><methods><class-id>External.COM_FUNCDESC class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #FUNCDESC.	self updateAndRegister</body></methods><methods><class-id>External.COM_TLIBATTR</class-id> <category>accessing</category><body package="Com- Automation">guid	" Answer the unique ID of the type library. "	^self guidMemberAt: #guid</body><body package="Com- Automation">guid: aGuid	" Set the unique ID of the type library. "	self guidMemberAt: #guid put: aGuid.</body><body package="Com- Automation">majorVersion	^ self memberAt: #wMajorVerNum</body><body package="Com- Automation">minorVersion	^ self memberAt: #wMinorVerNum</body><body package="Com- Automation">systemIdentifier	"Answer the code that identifies the operating system this library was built for."	^self memberAt: #syskind</body></methods><methods><class-id>External.COM_TLIBATTR</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseStructure	" Private - release the receiver back to the interface from whence it came. "	self structure == nil		ifTrue: [ ^self ].  " already released "	typeInterface releaseTLibAttr: self.	self structure enforceInvalidation.	self structure: nil.</body></methods><methods><class-id>External.COM_TLIBATTR class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_FUNCDESC;		yourself</body></methods><methods><class-id>External.COM_TLIBATTR class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #TLIBATTR.	self updateAndRegister</body></methods><methods><class-id>External.COM_TYPEATTR</class-id> <category>accessing</category><body package="Com- Automation">functionCount	"Answer the number of functions contained in this interface."	^self memberAt: #cFuncs</body><body package="Com- Automation">guid	" Answer the GUID which identifies the type described by this TYPEATTR. "    ^self guidMemberAt: #guid</body><body package="Com- Automation">idldescType	^self structureMemberAt: #idldescType</body><body package="Com- Automation">instanceSizeInBytes	^ self memberAt: #cbSizeInstance</body><body package="Com- Automation">lcid	" Answer the GUID which identifies the type described by this TYPEATTR. "    ^self memberAt: #lcid</body><body package="Com- Automation">schema	" Answer the schema string of the receiver. "	^self unicodePointerMemberAt: #lpstrSchema</body><body package="Com- Automation">tdescAlias	^self structureMemberAt: #tdescAlias</body><body package="Com- Automation">typeCount	"Answer the number of types contained in this type definition."	^self memberAt: #cImplTypes</body><body package="Com- Automation">typeFlags	"Answer the typeflags of this type"	^self memberAt: #wTypeFlags</body><body package="Com- Automation">typekind	" Answer the kind of type this TYPEATTR describes. "	^self memberAt: #typekind</body><body package="Com- Automation">variableCount	"Answer the number of variables contained in this interface."	^self memberAt: #cVars</body></methods><methods><class-id>External.COM_TYPEATTR</class-id> <category>testing</category><body package="Com- Automation">isDualInterface	^ (self typeFlags bitAnd: TYPEFLAG_FDUAL) ~= 0</body></methods><methods><class-id>External.COM_TYPEATTR</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseStructure	" Private - release the receiver back to the interface from whence it came. "	self structure == nil		ifTrue: [ ^self ].  " already released "	typeInterface releaseTypeAttr: self.	self structure enforceInvalidation.	self structure: nil.</body></methods><methods><class-id>External.COM_TYPEATTR class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_TLIBATTR;		yourself</body></methods><methods><class-id>External.COM_TYPEATTR class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #TYPEATTR.	self updateAndRegister</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>accessing</category><body package="Com- Automation">flags	^ 0</body><body package="Com- Automation">getSpecification	"Return the get specification. This may differ for properties, for methods this is usually the member	 itself"	^ self</body><body package="Com- Automation">getSpecificationForDisplay	"Return the specification which is used for displaying the member. This may differ for properties, for methods this is usually the member	 itself"	^ self getSpecification</body><body package="Com- Automation">kind	^ self subclassResponsibility</body><body package="Com- Automation">member 	"returns the member. Please see AutomationClassMember for other implementation"	^ self</body><body package="Com- Automation">memberID	"Return the memberID for this member. A better name would be default member ID (properties may have twoo) 	 but the members are accessed using perform in some places so the name can not be changed"	^ self subclassResponsibility</body><body package="Com- Automation">name		"Answer the name of the receiver."	^name</body><body package="Com- Automation">name: aString		"Set the receiver's name to be &lt;aString&gt;."	name := aString.</body><body package="Com- Automation">parameterTypeCodes	"Set the receiver's parameter types to be &lt;anArray&gt;."	^ self parameters collect: [:each | each type typecode]</body><body package="Com- Automation">parameterTypeCodes: typeCodes	self parameterTypes: (typeCodes				collect: [:each | DispTypeSpec fromVariantTypeCode: each])</body><body package="Com- Automation">parameterTypes: typeCodes	self subclassResponsibility</body><body package="Com- Automation">parameters 	self subclassResponsibility</body><body package="Com- Automation">setSpecification	"Return the writing specification - by default this is the specification itself. For Properties, this will be an access specification"	^ self</body><body package="Com- Automation">typeCode	self subclassResponsibility</body><body package="Com- Automation">typeCode: aTypeCode	"literal encoding compatibility"	self subclassResponsibility</body><body package="Com- Automation">typeName	self subclassResponsibility</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>testing</category><body package="Com- Automation">isEqualTo: aSpecification	^self isVTable		ifTrue: [aSpecification isEqualTo: self asDispatchSpecification]		ifFalse: [self basicIsEqualTo: aSpecification asDispatchSpecification]</body><body package="Com- Automation">isEventSpecification		" Answer whether the receiver is a method member specification. "	^ false</body><body package="Com- Automation">isMethodSpecification		" Answer whether the receiver is a method member specification. "	^false</body><body package="Com- Automation">isPropertyAccessSpecification	^ false</body><body package="Com- Automation">isPropertySpecification		" Answer whether the receiver is a property member specification. "	^false</body><body package="Com- Automation">isVTable	^ false</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream		" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	self name notNil		ifTrue: [			aStream				nextPutAll: ' ( ';				nextPutAll: self name;				nextPutAll: ', DISPID ';				nextPutAll: self memberID printString;				nextPutAll: ' )' ].</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>literal representation</category><body package="Com- Automation">decodeAttribute: aSymbol fromLiteral: aLiteralValue		" Apply the value &lt;aLiteralValue&gt; for the attribute named &lt;aSymbol&gt; to the receiver. "	aSymbol = #typeCode:		ifTrue: [ ^self typeCode: ( self class typeCodeFromLiteral: aLiteralValue ) ].	aSymbol = #parameterTypes:		ifTrue: [ 			^self parameterTypeCodes: ( aLiteralValue collect: [ :aLiteral |				self class typeCodeFromLiteral: aLiteral ] ) ].	self perform: aSymbol with: aLiteralValue "decodeAsLiteralArray".</body><body package="Com- Automation">literalArrayEncoding	"Return a literal suitable for reconstituting the receiver."	^LiteralArrayEncoder encode: self</body><body package="Com- Automation">literalEncodingType    " Answer the type which describes instance of the receiver in a literal encoding. "	^self class literalEncodingType</body><body package="Com- Automation">literallyEncodedAttributes	^  self class literallyEncodedAttributes</body><body package="Com- Automation">postLiteralDecodingInitialize	^ self</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>private</category><body package="Com- Automation">modifyTypeCode: aTypeCode	self subclassResponsibility</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>selector construction utilities</category><body package="Com- Automation">defaultArgumentKeyword    "Answer the default anonymous keyword string used for arguments."	^self class defaultArgumentKeyword</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>private flags constants</category><body package="Com- Automation">nonBrowsableFlag	self subclassResponsibility</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>error raising</category><body package="Com- Automation">raiseInvalidNumberOfArguments		self error: #InvalidNumberOfArguments &lt;&lt; #com &gt;&gt; 'Invalid number of arguments'.</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>comparing</category><body package="Com- Automation">= aPropertyAccessSpec	aPropertyAccessSpec class = self class ifFalse: [^false].	^ aPropertyAccessSpec name = self name</body><body package="Com- Automation">hash	self subclassResponsibility</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>private emphasised texts</category><body package="Com- Automation">printDoc: description on: aStream headlineEmphasis: headlineEmphasis 	description ifNotNil: [:doc | 			aStream				nextPutAllText: (Text string: 'Documentation:' emphasis: headlineEmphasis); cr;				nextPutAll: doc;cr;cr]</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>private tools</category><body package="Com- Automation">basicIsEqualTo: aSpec	self subclassResponsibility.</body><body package="Com- Automation">checkEqualityOf: object1 and: object2	"Check equality of subspecs. If one of the specs isNil, return true"	object1 ifNil: [ ^ true].	object2 ifNil: [ ^ true].	^ object1 basicIsEqualTo: object2</body><body package="Com- Automation">parametersEqual: parameters1 and: parameters2	parameters1 size = parameters2 size ifFalse: [^false].	parameters1 with: parameters2		do: [:p1 :p2 | (p1 basicIsEqualTo: p2) ifFalse: [^false]].	^true</body></methods><methods><class-id>External.COMAbstractMemberSpecification</class-id> <category>converting</category><body package="Com- Automation">asDispatchSpecification	"return your self as a Dispatch version. Subclasses may override this"	^ self</body></methods><methods><class-id>External.COMAbstractMemberSpecification class</class-id> <category>private-accessing</category><body package="Com- Automation">literalTypeMap	" Private- answer the mapping from the type field of a dispatch specification literal to the representing class. "	^LiteralTypeMap</body><body package="Com- Automation">literalTypeMap: aDictionary	" Private- Specifiy the mapping from the type field of a dispatch specification literal to the representing class. "	LiteralTypeMap := aDictionary.</body></methods><methods><class-id>External.COMAbstractMemberSpecification class</class-id> <category>selector construction utilities</category><body package="Com- Automation">defaultArgumentKeyword    "Answer the default anonymous keyword string used for arguments."    ^'_:'</body></methods><methods><class-id>External.COMAbstractMemberSpecification class</class-id> <category>literal representation</category><body package="Com- Automation">literalEncodingType    " Answer the type which describes instance of the receiver in a literal encoding. "	self subclassResponsibility.</body><body package="Com- Automation">literallyEncodedAttributes	^ #(name)</body><body package="Com- Automation">typeCodeFromLiteral: aLiteralValue		" Answer the type code described by the literal &lt;aLiteralValue&gt; "	| aTypeCode literal |	aLiteralValue isNil ifTrue: [ ^ nil ].	aLiteralValue class == Array "isArray"		ifTrue: [			aLiteralValue first = #GUID				ifTrue: [ ^aLiteralValue decodeAsLiteralArray ].			aTypeCode := 0.			aLiteralValue do: [ :aLiteral |				aTypeCode := aTypeCode | ( self typeCodeFromLiteral: aLiteral ) ].			^aTypeCode ].	"AR54709 - fix for literal specif which wrongly contain #VT_PTR elements"	literal :=  (aLiteralValue = #VT_PTR)		ifTrue: [ #VT_BYREF ]		ifFalse: [ aLiteralValue ].	^COMVariant typeCodeNameMap keyAtValueEqual: literal asString</body><body package="Com- Automation">typeCodeLiteral: aTypeCode		" Answer the literal describing &lt;aTypeCode&gt;. "	| baseTypeCode typeCodeList |	aTypeCode isInteger		ifFalse: [ ^aTypeCode literalArrayEncoding ].  " GUID "	baseTypeCode := COMVariant arrayElementTypeCodeOf: aTypeCode.	baseTypeCode = aTypeCode		ifTrue: [ ^( COMVariant typeCodeNameOf: aTypeCode ) asSymbol ].	typeCodeList := OrderedCollection new.	( COMVariant isArrayType: aTypeCode )		ifTrue: [ typeCodeList add:			( COMVariant typeCodeNameOf: VT_ARRAY ) asSymbol ].	typeCodeList add: ( self typeCodeLiteral: baseTypeCode ).	( COMVariant isReferenceType: aTypeCode )		ifTrue: [ typeCodeList add:			( COMVariant typeCodeNameOf: VT_BYREF ) asSymbol ].	^typeCodeList asArray</body></methods><methods><class-id>External.COMAbstractMemberSpecification class</class-id> <category>instance creation</category><body package="Com- Automation">decodeFromLiteralArray: anArray        " Answer a new instance of the receiver containing the dispatch specifications in the literal representation &lt;anArray&gt;. "	| aSpecificationClass |	aSpecificationClass := self literalTypeMap at: anArray first		ifAbsent: [ ^self decodeLiteralArray: anArray ].	^aSpecificationClass oldStyleDecodeFromLiteralArray: anArray</body><body package="Com- Automation">decodeLiteralArray: anArray	^ (LiteralArrayEncoder decode: anArray) postLiteralDecodingInitialize</body><body package="Com- Automation">forDescription: aMemberDesc typeInfo: anITypeInfo		" Answer a new instance of the receiver initialized for the member 		described by the type library member description structure &lt;aMemberDesc&gt;.  		Additional type information is proved by the ITypeInfo interface &lt;anITypeInfo&gt;. "	self subclassResponsibility</body></methods><methods><class-id>External.COMAbstractMemberSpecification class</class-id> <category>private-literal representation</category><body package="Com- Automation">registerLiteralType: aDispatchSpecificationType forClass: aClass	" Private - register the type field &lt;aDispatchSpecificationType&gt; and the class &lt;aClass&gt; which generates and decodes literals of that type. "	LiteralTypeMap == nil		ifTrue: [ LiteralTypeMap := Dictionary new ].	LiteralTypeMap at: aDispatchSpecificationType put: aClass.</body><body package="Com- Automation">removeLiteralType: aDispatchSpecificationType forClass: aClass	" Private - remove the registration the type field &lt;aDispatchSpecificationType&gt; and the class &lt;aClass&gt; which generates and decodes literals of that type. "	LiteralTypeMap == nil		ifTrue: [ ^self ].	LiteralTypeMap removeKey: aDispatchSpecificationType ifAbsent: [].</body></methods><methods><class-id>External.COMAbstractMemberSpecification class</class-id> <category>private</category><body package="Com- Automation">descriptionFor: memberID typeInfo: anITypeInfo	| docs |	docs := (anITypeInfo getDocumentation: memberID) ifNil: [^nil].	^docs at: 'documentation'</body></methods><methods><class-id>External.COMAbstractMemberSpecification class</class-id> <category>constants</category><body package="Com- Automation">eventKindName	^ #event</body><body package="Com- Automation">methodKindName	^ #method</body><body package="Com- Automation">propertyKindName	^ #property</body></methods><methods><class-id>External.COMAbstractMemberSpecification class</class-id> <category>private tools</category><body package="Com- Automation">lastParameterIsResultValue: aSpecification	| param |	aSpecification returnsHRESULT ifFalse: [^false].	aSpecification hasParameters ifFalse: [^false].	param := aSpecification parameters last.	^param isReturnValue</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>testing</category><body package="Com- Automation">basicIsEqualTo: aSpecification	aSpecification ifNil: [^false].	aSpecification isPropertySpecification ifFalse: [^false].	(self checkEqualityOf: self getSpecification		and: aSpecification getSpecification) ifFalse: [^false].	^self checkEqualityOf: self setSpecification		and: aSpecification setSpecification</body><body package="Com- Automation">isParameterized	"Not the same as hasParamters - just determine the type of property spec"	^ false</body><body package="Com- Automation">isPropertySpecification	" Answer whether the receiver is a property member specification. "	^true</body><body package="Com- Automation">isReadOnly		" Answer whether the property described by the receiver is read-only. "	^self accessMode = 1</body><body package="Com- Automation">isVTable	^isVTable</body><body package="Com- Automation">isWriteOnly		" Answer whether the property described by the receiver is write-only. "	^self accessMode = 2</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>private-initialization</category><body package="Com- Automation">initializePropertyGetSpecification	self subclassResponsibility</body><body package="Com- Automation">initializePropertySetSpecification	self subclassResponsibility</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>accessing</category><body package="Com- Automation">accessMode	self subclassResponsibility</body><body package="Com- Automation">anySpecification	self subSpecificationsDo: [:each | ^each].	^nil</body><body package="Com- Automation">anyWriteSpecification	self writeSpecificationsDo: [:each | ^each].	^nil</body><body package="Com- Automation">description	^self anySpecification description</body><body package="Com- Automation">description: aString	self specifications do: [:each | each description: aString]</body><body package="Com- Automation">getSpecification	^ self propertyGetSpecification</body><body package="Com- Automation">getSpecificationForDisplay	"return the access specification which is used for dispalying"	^ self propertyGetSpecificationForDisplay</body><body package="Com- Automation">isVTable: anObject	isVTable := anObject</body><body package="Com- Automation">kind	^ #property</body><body package="Com- Automation">memberID	self subSpecificationsDo: [:spec | ^ spec memberID].	^ nil</body><body package="Com- Automation">name: newName 	(name notNil and: [ name ~= newName ])		ifTrue: [ COMError raiseSignal: #ErrMergeSameProperty &lt;&lt; #com 						&gt;&gt; 'merge must be the same property' ].	name := newName.</body><body package="Com- Automation">propertyGetSpecification	^propertyGetSpecification</body><body package="Com- Automation">propertyGetSpecification: anObject	propertyGetSpecification		ifNotNil: 			[self error: #PropertyOperationAllreadyDefined &lt;&lt; #com						&gt;&gt; 'Property operation already defined'].	propertyGetSpecification := anObject</body><body package="Com- Automation">propertyGetSpecificationForDisplay	^self propertyGetSpecification		ifNil: [self synthesizePropertyGetSpecification]		ifNotNil: [:spec | spec specificationForDisplay ]</body><body package="Com- Automation">propertySetSpecification	^propertySetSpecification</body><body package="Com- Automation">propertySetSpecification: anObject	propertySetSpecification		ifNotNil: 			[ "ignore property putRefs"].	propertySetSpecification := anObject</body><body package="Com- Automation">setSpecification	^ self propertySetSpecification</body><body package="Com- Automation">specifications	| collection |	collection := OrderedCollection new.	self subSpecificationsDo: [:each | collection add: each].	^collection asArray</body><body package="Com- Automation">valueFromTextRepresentation: aValue	^ self propertyGetSpecificationForDisplay type valueFromTextRepresentation: aValue.</body><body package="Com- Automation">writePropertySpecificationForArguments: arguments	^ self propertySetSpecification</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>initialize-release</category><body package="Com- Automation">disableReadAccess		" Set the receiver's access mode flags to indicate that the property is not readable. "	self subclassResponsibility</body><body package="Com- Automation">disableWriteAccess		" Set the receiver's access mode flags to indicate that the property is not writeable. "	self subclassResponsibility</body><body package="Com- Automation">initialize		isVTable := false.	^ super initialize</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>printing</category><body package="Com- Automation">attributeDescriptions	self isReadOnly ifTrue: [^ (#ReadOnlyInBraces &lt;&lt; #com &gt;&gt; '[readonly]')].	self isWriteOnly ifTrue: [^ (#WriteOnlyInBraces &lt;&lt; #com &gt;&gt; '[writeonly]')].	^ ''</body><body package="Com- Automation">typeName	^ (#Property &lt;&lt; #com &gt;&gt; 'Property') asString</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>literal representation</category><body package="Com- Automation">decodeAttribute: aSymbol fromLiteral: aLiteralValue		" Apply the value &lt;aLiteralValue&gt; for the attribute named &lt;aSymbol&gt; to the receiver. "	aSymbol = #accessMode:		ifTrue: [ 			aLiteralValue = 'readOnly'				ifTrue: [ ^self disableWriteAccess ].			aLiteralValue = 'writeOnly'				ifTrue: [ ^self disableReadAccess ].			].	aSymbol = #getSelector:		ifTrue: [  ^self getSpecification selector: aLiteralValue ].	aSymbol = #setSelector:		ifTrue: [  ^self setSpecification selector: aLiteralValue ].				^ super decodeAttribute: aSymbol fromLiteral: aLiteralValue</body><body package="Com- Automation">decodeLiteralAttributes: attributes	attributes		keysAndValuesDo: [:key :value | self decodeAttribute: key fromLiteral: value]</body><body package="Com- Automation">postLiteralDecodingInitialize	super postLiteralDecodingInitialize.	self subSpecificationsDo: [:spec | spec propertySpecification: self]</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>private</category><body package="Com- Automation">anyWriteSpecificationDo: aBlock elseDo: anotherBlock	^self propertySetSpecification		ifNil: anotherBlock		ifNotNil: [:spec | aBlock value: spec]</body><body package="Com- Automation">modifyTypeCode: aTypeCode	"The original implementation used no-ref typcodes for methods but typecodes including reference flags	 for properties"	^ aTypeCode</body><body package="Com- Automation">subSpecificationsDo: aBlock	self propertyGetSpecification ifNotNil: [:spec| aBlock value: spec].	self propertySetSpecification ifNotNil: [:spec| aBlock value: spec].</body><body package="Com- Automation">synthesizePropertyGetSpecification	self writeSpecificationsDo: [:each | ^each asPropertyGetSpecification].	^nil</body><body package="Com- Automation">synthesizePropertySetSpecification		^self propertyGetSpecification asPropertySetSpecification</body><body package="Com- Automation">writeSpecificationsDo: aBlock	self propertySetSpecification ifNotNil: [:spec | aBlock value: spec]</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>private emphasised texts</category><body package="Com- Automation">isIUnknownType	"Check if the actual type of this property is IUnknown, that is a non-automation interface"	^self propertyGetSpecificationForDisplay returnValueDescription type typecode		= External.COMAutomationConstants.VT_UNKNOWN</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>specification construction</category><body package="Com- Automation">mergeOperationDescription: aFuncDesc typeInfo: anITypeInfo	"General property specification don't need merging"</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>comparing</category><body package="Com- Automation">= aPropertySpec	aPropertySpec isPropertySpecification ifFalse: [^false].	self name = aPropertySpec name ifFalse: [^false].	self getSpecification = aPropertySpec getSpecification ifFalse: [^false].	^self setSpecification = aPropertySpec setSpecification</body></methods><methods><class-id>External.GeneralPropertySpecification class</class-id> <category>instance creation</category><body package="Com- Automation">new		" Answer a new instance of the receiver. "	^super new initialize</body><body package="Com- Automation">oldStyleDecodeFromLiteralArray: anArray	" Answer a new instance of the receiver containing the dispatch specifications in the literal representation &lt;anArray&gt;. "	| attributes hasParameters aSpecificationClass aDispatchSpecification |	attributes := Dictionary new.	4 to: anArray size		by: 2		do: [:i | attributes at: (anArray at: i) put: (anArray at: i + 1)].	hasParameters := (attributes includesKey: #parameterTypes:)				or: [attributes includesKey: #parameterized:].	aSpecificationClass := hasParameters				ifTrue: [COMDispatchParameterizedPropertySpecification]				ifFalse: [COMDispatchPropertySpecification].	aDispatchSpecification := aSpecificationClass				name: (anArray at: 2)				memberID: (anArray at: 3)				typeCode: VT_VOID.	aDispatchSpecification decodeLiteralAttributes: attributes.	^aDispatchSpecification</body></methods><methods><class-id>External.GeneralPropertySpecification class</class-id> <category>literal representation</category><body package="Com- Automation">literalEncodingType    " Answer the type which describes instance of the receiver in a literal encoding. "	^'property'</body><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(propertyGetSpecification propertySetSpecification isVTable)</body></methods><methods><class-id>External.COMAutomationID</class-id> <category>converting</category><body package="Com- Automation">asGUID	^self id asGUID</body><body package="Com- Automation">asString	^self id asString</body></methods><methods><class-id>External.COMAutomationID</class-id> <category>accessing</category><body package="Com- Automation">applicationName	^self asArrayOfSubstrings at: 1</body><body package="Com- Automation">className	^self asArrayOfSubstrings at: 2</body><body package="Com- Automation">id	^id</body><body package="Com- Automation">id: aValue	id := aValue</body></methods><methods><class-id>External.COMAutomationID</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream 	"Append to the argument aStream a sequence of characters	that describes the receiver."	super printOn: aStream.	aStream 		nextPutAll: ' (';		nextPutAll: self id asString;		nextPut: $)</body></methods><methods><class-id>External.COMAutomationID</class-id> <category>private-accessing</category><body package="Com- Automation">asArrayOfSubstrings	^self id asArrayOfSubstringsSeparatedBy: $.</body></methods><methods><class-id>External.COMAutomationID class</class-id> <category>instance creation</category><body package="Com- Automation">fromProgID: aProgIDOrGuid	| id |	( id := COMRegistryInterface progIDFromVersionIndependentProgID: aProgIDOrGuid ) isNil		ifTrue: [ ^nil ].	^self new 		id: id</body></methods><methods><class-id>External.VersionIndependentProgID</class-id> <category>accessing</category><body package="Com- Automation">version	"Answer the version string or nil."	^self asArrayOfSubstrings at: 3 ifAbsent: [ nil ]</body><body package="Com- Automation">versionNumber	"Answer the version number or nil."	| ver |	^( ver := self version ) isNil		ifTrue: [ nil ]		ifFalse: [ ver asNumber ]</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">arrayElementType	^ self</body><body package="Com- Automation">cType	self subclassResponsibility</body><body package="Com- Automation">name 	^ COMVariant basicVBRepresentationForType: self typecode</body><body package="Com- Automation">noRefType	^ self</body><body package="Com- Automation">pointerType	^ DispPtrTypeSpec referentType: self</body><body package="Com- Automation">pointerTypeCode	^ self typecode bitOr: VT_BYREF</body><body package="Com- Automation">typecode	self subclassResponsibility</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>testing</category><body package="Com- Automation">isArray	^ false</body><body package="Com- Automation">isByref	^ false</body><body package="Com- Automation">isClassOrInterface	^ false</body><body package="Com- Automation">isHRESULT	^ false</body><body package="Com- Automation">isInterface	^ false</body><body package="Com- Automation">isInterfacePointer	^ false</body><body package="Com- Automation">isNumeric		^ false</body><body package="Com- Automation">isStructure	^ false</body><body package="Com- Automation">isUserdefined	"answer wether this type is a userdefined one"	^ false</body><body package="Com- Automation">isVariant	^ false</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>comparing</category><body package="Com- Automation">= anObject 	^ anObject equalsCOMTypeSpec: self</body><body package="Com- Automation">derivesFromType: aType	^ self = aType</body><body package="Com- Automation">equalsCOMTypeSpec: aDispTypeSpec	^self class = aDispTypeSpec class		and: [self typecode = aDispTypeSpec typecode]</body><body package="Com- Automation">hash	^ self typecode</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	aStream nextPutAll: (self name), '(Automation)'</body><body package="Com- Automation">printOn: aStream name: name	aStream nextPutAll: name,' (',(self name), ', Automation)'</body><body package="Com- Automation">printPtrTypeOn: aStream	aStream nextPutAll: 'Byref '.	self printOn: aStream.</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>private</category><body package="Com- Automation">isPointerByref		"Answer whether a pointer of my type is byref"	^ true</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">argumentValueFromByrefArgument: anArgument	^anArgument isValueReference		ifTrue: [anArgument value]		ifFalse: [anArgument]</body><body package="Com- Automation">convertToSTObject: aCOMObjectValue 	"convert the given COM Object value to a real ST object. This may require conversions	 in certain cases. Default behavior is to return the value itself"	^ aCOMObjectValue</body><body package="Com- Automation">createOutArgument	^ self shouldNotImplement</body><body package="Com- Automation">createPtrOutArgument	^ self cType calloc.</body><body package="Com- Automation">createPtrPtrOutArgument	^ self cType pointerType malloc</body><body package="Com- Automation">freeArgument: anArgument	anArgument release</body><body package="Com- Automation">freePtrArgument: anArgument	anArgument contents ifNotNil: [:contents | self freeArgument: contents ].	anArgument enforceRelease.</body><body package="Com- Automation">invalidateInParameterValueIn: aSmalltalkValue	self shouldNotImplement</body><body package="Com- Automation">invalidatePtrInParameterValueIn: aSmalltalkValue	^ self</body><body package="Com- Automation">invalidatePtrPtrInParameterValueIn: aSmalltalkValue	self shouldNotImplement</body><body package="Com- Automation">marshalInArgument: anArgument	self subclassResponsibility</body><body package="Com- Automation">marshalPointerArgument: anArgument	| marshaled |	marshaled := self				marshalInArgument: (self argumentValueFromByrefArgument: anArgument).	^(self createPtrOutArgument)		contents: marshaled;		yourself</body><body package="Com- Automation">newResultParameter	^ self shouldNotImplement</body><body package="Com- Automation">newResultPointerParameter	^ ValueReference new.</body><body package="Com- Automation">newResultPtrPtrParameter		^ self shouldNotImplement</body><body package="Com- Automation">newSafeArray: dims bounds: bounds	| typecode aSafeArrayStruct |	typecode := self typecode.	aSafeArrayStruct := OLEAutomationDLL current SafeArrayCreate: typecode		_: dims		_: bounds.	^ aSafeArrayStruct typeCode: typecode;		yourself</body><body package="Com- Automation">newSafeArrayDescriptor: dims bounds: bounds	| aSafeArrayStruct resultReference |	resultReference := nil asValue.	OLEAutomationDLL current SafeArrayAllocDescriptorEx: self typecode _: dims		_: resultReference.	aSafeArrayStruct := resultReference value.	^ aSafeArrayStruct 		setRGSBounds: bounds;		typeDescription: self;		typeCode: self typecode;		yourself</body><body package="Com- Automation">primitiveArgumentFor: aValue	^ aValue</body><body package="Com- Automation">releaseRecordElement: aVariant	"Default behavior - do nothing"	^ self</body><body package="Com- Automation">releaseServerArgument: each	^ self</body><body package="Com- Automation">setRefPointer: aPointer in: aVariant	aVariant refPointer: aPointer.</body><body package="Com- Automation">unmarshalOutParam: aParam	self subclassResponsibility</body><body package="Com- Automation">unmarshalOutParameter: aMarshaledValue into: aSmalltalkValue 	self shouldNotImplement</body><body package="Com- Automation">unmarshalPtrOutParameter: aMarshaledValue into: aSmalltalkValue 	aSmalltalkValue isValueReference ifTrue: [ 		aSmalltalkValue value: (self unmarshalOutParam: aMarshaledValue contents) ].</body><body package="Com- Automation"> unmarshalPtrPtrOutParameter: aMarshaledValue into: aSmalltalkValue 	self shouldNotImplement</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>testing variant</category><body package="Com- Automation">canVariantContainByRefValue: anObject ofType: aType	aType isByref ifFalse: [^false].	^self canVariantContainValue: anObject value ofType: aType referentType</body><body package="Com- Automation">canVariantContainValue: anObject ofType: aType	^aType typecode = self typecode</body><body package="Com- Automation">variantContainsRefValue: aVariant	^aVariant refVariantValue ifNotNil: [:refValue | refValue containsValue]</body><body package="Com- Automation">variantContainsValue: aVariant	^ (aVariant valueAt: #parray) isValid</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>literal array encoding</category><body package="Com- Automation">literalArrayEncoding	^ LiteralArrayEncoder encode: self</body><body package="Com- Automation">literallyEncodedAttributes	^self class literallyEncodedAttributes</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: client	^aValue</body><body package="Com- Automation">preMarshalPtrAutomationParameter: anIDispatch client: aCOMDispatchValueAdaptor 	"Default Implementation"		^ self preMarshalAutomationParameter: anIDispatch client: aCOMDispatchValueAdaptor</body><body package="Com- Automation">releaseUnusedAutomationOutValue: aResult inValue: anObject	"release an unused result"	^self</body><body package="Com- Automation">unmarshalAutomationResult: aValue	^ aValue</body><body package="Com- Automation">unmarshalAutomationResult: aValue into: aResultReference	self shouldNotImplement</body><body package="Com- Automation">unmarshalPtrAutomationResult: aValue into: aResultReference	aResultReference isValueReference		ifTrue: 			[aResultReference value: (self unmarshalAutomationResult: aValue value)]		ifFalse: [self releaseUnusedAutomationOutValue: aValue inValue: aResultReference]</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>converting</category><body package="Com- Automation">asInParameterType	^ self shouldNotImplement</body></methods><methods><class-id>External.DispTypeSpec class</class-id> <category>private</category><body package="Com- Automation">baseClass	^ DispTypeSpec</body><body package="Com- Automation">classFor: typeCode	^ self typeCodeClassMap at: typeCode ifAbsent: [ self defaultClass ]</body><body package="Com- Automation">classForAutomationTypeCode: aTypeCode 	aTypeCode isNil ifTrue: [ 		^ nil ].	(aTypeCode bitAnd: VT_BYREF) = VT_BYREF ifTrue: [		^  self classFor: VT_PTR ].	(aTypeCode bitAnd: VT_ARRAY) = VT_ARRAY ifTrue: [		^  self classFor: VT_SAFEARRAY ].	^ nil</body><body package="Com- Automation">classForVariantTypeCode: typeCode	^ self typeCodeClassMap at: typeCode ifAbsent: [ 		(self classForAutomationTypeCode: typeCode) ifNil: [ self defaultClass ] ]</body><body package="Com- Automation">defaultClass 	^ DefaultClass</body><body package="Com- Automation">ensureNotDefaultClass	DefaultClass == self ifTrue: [ DefaultClass := nil ].</body><body package="Com- Automation">initializeClassMap 	TypeCodeClassMap := Dictionary new.	self baseClass allSubclassesDo: [:each | 		each installInClassMap: TypeCodeClassMap ].	^ TypeCodeClassMap</body><body package="Com- Automation">installInClassMap: aClassMap	^ self typeCodes do: [:typeCode |			aClassMap at: typeCode put: self ].</body><body package="Com- Automation">registerAsDefaultClass	DefaultClass := self</body><body package="Com- Automation">typeCodeClassMap	^ TypeCodeClassMap ifNil: [ self initializeClassMap ]</body><body package="Com- Automation">typeCodes	"specific subclasses may return values for expressing that they are responsible for the typeCode"	^ #()</body></methods><methods><class-id>External.DispTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFrom: aTypeDesc typeInfo: anITypeInfo	self subclassResponsibility</body><body package="Com- Automation">basicFromVariant: aVariant typeCode: aTypeCode	^ self basicFromVariantTypeCode: aTypeCode</body><body package="Com- Automation">basicFromVariantTypeCode: aTypeCode	self subclassResponsibility</body></methods><methods><class-id>External.DispTypeSpec class</class-id> <category>instance creation</category><body package="Com- Automation">forTypeDesc: aTypeDesc typeInfo: anITypeInfo	^ (self classFor: aTypeDesc typeCode) basicFrom: aTypeDesc typeInfo: anITypeInfo</body><body package="Com- Automation">fromVariant: aVariant	| typeCode |	typeCode := aVariant typeCode.	^ self fromVariant: aVariant typeCode: typeCode</body><body package="Com- Automation">fromVariant: aVariant typeCode: typeCode	^ (self classForVariantTypeCode: typeCode) basicFromVariant: aVariant typeCode: typeCode</body><body package="Com- Automation">fromVariantTypeCode: aTypeCode	^ (self classForVariantTypeCode: aTypeCode) basicFromVariantTypeCode: aTypeCode</body></methods><methods><class-id>External.DispTypeSpec class</class-id> <category>literal array encoding</category><body package="Com- Automation">decodeFromLiteralArray: anArray	^ LiteralArrayEncoder decode: anArray</body></methods><methods><class-id>External.DispTypeSpec class</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: anObject	^aValue</body><body package="Com- Automation">preMarshalPtrAutomationParameter: anIDispatch client: aCOMDispatchValueAdaptor 		^  self preMarshalAutomationParameter: anIDispatch client: aCOMDispatchValueAdaptor</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>testing</category><body package="Com- Automation">canContainNumeric: anObject ofType: aType	self isNumeric ifFalse: [^false].	aType isNumeric ifFalse: [^false].	"Check if my CType can contain the value"	[self cType coerceForAssignment: anObject] on: Error do: [:ex | ^false].	^ true</body><body package="Com- Automation">isHRESULT	^ self typecode = VT_HRESULT</body><body package="Com- Automation">isInterfacePointer	^ COMVariant isInterfaceTypeCode: self typecode</body><body package="Com- Automation">isNumeric		^ self class numericTypeCodes includes: self typecode</body><body package="Com- Automation">isString	^ COMVariant isBStringType: self typecode</body><body package="Com- Automation">isVariant	^ COMVariant isVariantType: self typecode.</body><body package="Com- Automation">isVoid	^ self typecode = VT_VOID</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">cType	^ self class cTypeForTypeCode: self typecode</body><body package="Com- Automation">iid	"return the iid for types which describe interfaces"	self typecode = VT_DISPATCH ifTrue: [ ^ External.COMConstants.IID_IDispatch ].	self typecode = VT_UNKNOWN ifTrue: [ ^ External.COMConstants.IID_IUnknown ].</body><body package="Com- Automation">typecode	^typecode</body><body package="Com- Automation">typecode: anObject	typecode := anObject</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">createPtrPtrOutArgument	^ self isInterfacePointer 		ifTrue: [ COMInterfacePointer resultValueBufferForIID: self iid]		ifFalse: [ super createPtrPtrOutArgument ]</body><body package="Com- Automation">freeArgument: anArgument	^ self releaseSelector ifNotNil: [:sel | self perform: sel with: anArgument ].</body><body package="Com- Automation">invalidatePtrInParameterValueIn: aSmalltalkValue	self isInterfacePointer ifTrue: [ ^ aSmalltalkValue value enforceInvalidation ].</body><body package="Com- Automation">marshalInArgument: anArgument	^ self perform: self marshalSelector with: anArgument</body><body package="Com- Automation">marshalPointerArgument: anArgument	| argument |	self isVoid ifTrue: [^anArgument asPointerParameter].	self isInterfacePointer		ifTrue: 			[argument := self argumentValueFromByrefArgument: anArgument.			argument enforceAddRef]		ifFalse: [argument := anArgument].	^super marshalPointerArgument: argument</body><body package="Com- Automation">marshalSelector	^ self class marshalSelectors at: self typecode</body><body package="Com- Automation">primitiveArgumentFor: aValue	^ self isString 		ifTrue: [ aValue asPointerParameter ]		ifFalse:[ super primitiveArgumentFor: aValue ]</body><body package="Com- Automation">releaseRecordElement: aVariant	"Default behavior - do nothing"	(self isString or: [self isVariant]) 		ifTrue: [ aVariant refVariantValue clear ].</body><body package="Com- Automation">releaseSelector	^ self class releaseSelectors at: self typecode ifAbsent: [ nil ]</body><body package="Com- Automation">releaseServerArgument: anArg	anArg isCOMInterfacePointer ifTrue: [ anArg enforceRelease ].</body><body package="Com- Automation">unmarshalOutParam: aParam	^ self perform: self unmarshalSelector with: aParam</body><body package="Com- Automation"> unmarshalPtrPtrOutParameter: aMarshaledValue into: aSmalltalkValue 	self isInterfacePointer ifTrue: [ aSmalltalkValue value: aMarshaledValue contents asInterfaceReference ]. 	super unmarshalPtrPtrOutParameter: aMarshaledValue into: aSmalltalkValue</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>private</category><body package="Com- Automation">isPointerByref		"Answer whether a pointer of my type is byref"	^ self isVoid not</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>private Marshaling</category><body package="Com- Automation">marshalBStr: aString	| bstr |	^aString		ifNotNil: 			[bstr := BSTRMemoryAddress allocateString: aString.			[bstr asPointerParameter] ensure: [bstr enforceInvalidation]]</body><body package="Com- Automation">marshalBool: aBoolean	^aBoolean ifTrue: [ VARIANT_TRUE ] ifFalse: [ VARIANT_FALSE ]</body><body package="Com- Automation">marshalCString: aString	^ aString copyToHeap.</body><body package="Com- Automation">marshalCY: aCurrency	| cy |	cy := COM_CY fromNumber: aCurrency.	^[cy asStructureParameter] ensure: [cy enforceInvalidation]</body><body package="Com- Automation">marshalDate: aDate	^ (COMDate fromValue: aDate) value</body><body package="Com- Automation">marshalDecimal: aDecimal	| decimal |	decimal := COM_DECIMAL fromNumber: aDecimal.	^[decimal asStructureParameter] ensure: [decimal enforceInvalidation]</body><body package="Com- Automation">marshalFiletime: aDate	| filetime |	filetime := aDate asTimestamp asFileTime.	^[filetime asStructureParameter] ensure: [filetime enforceInvalidation]</body><body package="Com- Automation">marshalFloat: aNumber	^ aNumber</body><body package="Com- Automation">marshalGuid: aGuid	^ aGuid</body><body package="Com- Automation">marshalHResult: aHResult	^HRESULT formatHResult: aHResult asInteger</body><body package="Com- Automation">marshalInt: anInteger	| anInt |	anInt := anInteger isInteger				ifTrue: [anInteger]				ifFalse: 					[[anInteger asInteger] on: Error						do: [:ex | self error: #InvalidValue &lt;&lt; #com &gt;&gt; 'Invalid value']].	(self validIntegerRange includes: anInt)		ifFalse: [self error: #InvalidValue &lt;&lt; #com &gt;&gt; 'Invalid value'].	^anInt</body><body package="Com- Automation">marshalInterface: anInterface 	^ anInterface asPointerParameter</body><body package="Com- Automation">marshalVariant: aValue	| var type |	type := aValue comVariantType.	var := COM_VARIANTARG type: type value: aValue.		^ [ var asStructureParameter ] ensure: [ var enforceInvalidation]</body><body package="Com- Automation">marshalWString: aString	^ aString copyToHeapUnicode</body><body package="Com- Automation">unmarshalSelector	^ self class unmarshalSelectors at: self typecode</body><body package="Com- Automation">validIntegerRange	| cType |	cType := self cType baseType.	^  cType minVal to: cType maxVal</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>private releasing</category><body package="Com- Automation">doNothingWith: aValue	^ aValue</body><body package="Com- Automation">releaseBStr: aPointer	^OLEAutomationDLL current SysFreeString: aPointer</body><body package="Com- Automation">releaseBoolean: aBool	^ self</body><body package="Com- Automation">releaseCString: aPointer	aPointer free</body><body package="Com- Automation">releaseCY: aPointer	(COM_CY temporaryOn: aPointer) enforceRelease</body><body package="Com- Automation">releaseDate: aDate	^ aDate</body><body package="Com- Automation">releaseDecimal: aDecimal	^ self</body><body package="Com- Automation">releaseFiletime: aFiletime	^ self</body><body package="Com- Automation">releaseInterface: anInterface	^ self</body><body package="Com- Automation">releaseVariant: aCOMVariant	^ (COM_VARIANTARG temporaryOn: aCOMVariant) enforceRelease</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>private Unmarshaling</category><body package="Com- Automation">unmarshalBStr: aPointer	^ BSTR stringAtPointer: aPointer</body><body package="Com- Automation">unmarshalBool: aVariantValue	^ aVariantValue = VARIANT_TRUE</body><body package="Com- Automation">unmarshalCString: aPointer	^ aPointer copyCStringFromHeap</body><body package="Com- Automation">unmarshalCY: aPointer	^(COM_CY temporaryOn: aPointer) value</body><body package="Com- Automation">unmarshalDate: aDouble	^ (COMDate fromDATEValue: aDouble) asTimestamp</body><body package="Com- Automation">unmarshalDecimal: aStructure	^ (COM_DECIMAL temporaryOn: aStructure) value</body><body package="Com- Automation">unmarshalFiletime: aStructure	^ (COM_FILETIME temporaryOn: aStructure) asTimestamp</body><body package="Com- Automation">unmarshalFloat: aFloat	^ aFloat</body><body package="Com- Automation">unmarshalHResult: anInteger	^anInteger asHRESULT</body><body package="Com- Automation">unmarshalInterface: aPointer	| pointer |	aPointer isValid ifFalse: [^ nil ].	pointer := (COMInterfacePointer classForIID: self iid)				newResultInterfacePointerAtAddress: aPointer.	^pointer asInterfaceReference</body><body package="Com- Automation">unmarshalVariant: aPointer	^(COM_VARIANTARG temporaryOn: aPointer) value</body><body package="Com- Automation">unmarshalWString: aPointer	^ aPointer copyUnicodeStringFromHeap</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>testing variant</category><body package="Com- Automation">canVariantContainValue: anObject ofType: aType	aType isByref ifTrue: [^false].	self isVariant ifTrue: [^true].	(self isInterfacePointer and: [ anObject isNil ]) ifTrue: [^ true ].	(self canContainNumeric: anObject ofType: aType) ifTrue: [^ true].	^super canVariantContainValue: anObject ofType: aType</body><body package="Com- Automation">variantContainsRefValue: aVariant	self isVariant		ifTrue: [^aVariant refVariant ifNotNil: [:refVar | refVar containsValue]].	^ super variantContainsRefValue: aVariant</body><body package="Com- Automation">variantContainsValue: aVariant	"simplified check ... does the variant contain any non-null data"	^ (aVariant valueAt: #byref) isValid</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: client	^self isVariant		ifTrue: [aValue dispatchTypeClass preMarshalAutomationParameter: aValue client: client]		ifFalse: [super preMarshalAutomationParameter: aValue client: client]</body><body package="Com- Automation">preMarshalPtrAutomationParameter: anObject client: aCOMDispatchValueAdaptor	self isVariant		ifTrue: 			[^anObject dispatchTypeClass preMarshalPtrAutomationParameter: anObject				client: aCOMDispatchValueAdaptor].	^super preMarshalPtrAutomationParameter: anObject		client: aCOMDispatchValueAdaptor</body><body package="Com- Automation">releaseUnusedAutomationOutValue: aResult inValue: anObject	"release an unused result"	self isInterface		ifTrue: [aResult value ifNotNil: [:value | value enforceRelease]]</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>copying</category><body package="Com- Automation">shallowCopy	^ self</body></methods><methods><class-id>External.DispSimpleTypeSpec class</class-id> <category>initialize-release</category><body package="Com- Automation">cTypeForTypeCode: aTypeCode	^ self cTypesDict at: aTypeCode</body><body package="Com- Automation">cTypesDict	^ CTypesDict ifNil: [ CTypesDict := self initializeCTypesDict ].</body><body package="Com- Automation">initializeCTypesDict	^ Dictionary new		at: VT_INT 	put: CIntegerType int;		at: VT_UINT 	put: CIntegerType unsignedInt;		at: VT_I1		put: CIntegerType char;		at: VT_I2		put: CIntegerType short;		at: VT_I4		put: CIntegerType long;		at: VT_I8		put: CIntegerType longLong;		at: VT_UI1	put: CIntegerType unsignedChar;		at: VT_UI2	put: CIntegerType unsignedShort;		at: VT_UI4	put: CIntegerType unsignedLong;		at: VT_UI8	put: CIntegerType unsignedLongLong;		at: VT_VARIANT put: COMExternalInterface current VARIANTARG;		at: VT_HRESULT put: COMExternalInterface current HRESULT;		at: VT_BSTR		put: CIntegerType unsignedShort pointerType;		at: VT_VOID		put: CVoidType void;		at: VT_UNKNOWN put: (COMExternalInterface current __IAnonymous) pointerType;		at: VT_DISPATCH put: (COMExternalInterface current __IAnonymous) pointerType;		at: VT_CY put: COMExternalInterface current CY;		at: VT_BOOL put: COMExternalInterface current _VARIANT_BOOL;		at: VT_CLSID put: COMExternalInterface current GUID;		at: VT_DATE put: CLimitedPrecisionRealType double;		at: VT_DECIMAL put: COMExternalInterface current DECIMAL;		at: VT_ERROR put: COMExternalInterface current SCODE;		at: VT_FILETIME put: COMExternalInterface current FILETIME;		at: VT_R4 put: CLimitedPrecisionRealType float;		at: VT_R8 put: CLimitedPrecisionRealType double;		at: VT_LPSTR put: CIntegerType unsignedChar pointerType;		at: VT_LPWSTR put: CIntegerType unsignedShort pointerType;		yourself</body><body package="Com- Automation">initializeMarshalSelectors	^(IdentityDictionary new)		at: VT_INT put: #marshalInt:;		at: VT_UINT put: #marshalInt:;		at: VT_I1 put: #marshalInt:;		at: VT_I2 put: #marshalInt:;		at: VT_I4 put: #marshalInt:;		at: VT_I8 put: #marshalInt:;		at: VT_BOOL put: #marshalBool:;		at: VT_UI1 put: #marshalInt:;		at: VT_UI2 put: #marshalInt:;		at: VT_UI4 put: #marshalInt:;		at: VT_UI8 put: #marshalInt:;		at: VT_VARIANT put: #marshalVariant:;		at: VT_HRESULT put: #marshalHResult:;		at: VT_BSTR put: #marshalBStr:;		at: VT_VOID put: nil;		at: VT_UNKNOWN put: #marshalInterface:;		at: VT_DISPATCH put: #marshalInterface:;		at: VT_CY put: #marshalCY:;		at: VT_CLSID put: #marshalGuid:;		at: VT_DATE put: #marshalDate:;		at: VT_DECIMAL put: #marshalDecimal:;		at: VT_ERROR put: #marshalHResult:;		at: VT_FILETIME put: #marshalFiletime:;		at: VT_R4 put: #marshalFloat:;		at: VT_R8 put: #marshalFloat:;		at: VT_LPSTR put: #marshalCString:;		at: VT_LPWSTR put: #marshalWString:;		yourself</body><body package="Com- Automation">initializeReleaseSelectors	^(IdentityDictionary new)		at: VT_VARIANT put: #releaseVariant:;		at: VT_BSTR put: #releaseBStr:;		at: VT_UNKNOWN put: #releaseInterface:;		at: VT_DISPATCH put: #releaseInterface:;		at: VT_CY put: #releaseCY:;		at: VT_BOOL put: #releaseBoolean:;		at: VT_CLSID put: #releaseGuid:;		at: VT_DATE put: #releaseDate:;		at: VT_DECIMAL put: #releaseDecimal:;		at: VT_FILETIME put: #releaseFiletime:;		at: VT_LPSTR put: #releaseCString:;		at: VT_LPWSTR put: #releaseCString:;		yourself</body><body package="Com- Automation">initializeUnMarshalSelectors	^(IdentityDictionary new)		at: VT_INT put: #doNothingWith:;		at: VT_UINT put: #doNothingWith:;		at: VT_I1 put: #doNothingWith:;		at: VT_I2 put: #doNothingWith:;		at: VT_I4 put: #doNothingWith:;		at: VT_I8 put: #doNothingWith:;		at: VT_BOOL put: #unmarshalBool:;		at: VT_UI1 put: #doNothingWith:;		at: VT_UI2 put: #doNothingWith:;		at: VT_UI4 put: #doNothingWith:;		at: VT_UI8 put: #doNothingWith:;		at: VT_VARIANT put: #unmarshalVariant:;		at: VT_HRESULT put: #unmarshalHResult:;		at: VT_BSTR put: #unmarshalBStr:;		at: VT_VOID put: nil;		at: VT_UNKNOWN put: #unmarshalInterface:;		at: VT_DISPATCH put: #unmarshalInterface:;		at: VT_CY put: #unmarshalCY:;		at: VT_CLSID put: #unmarshalGuid:;		at: VT_DATE put: #unmarshalDate:;		at: VT_DECIMAL put: #unmarshalDecimal:;		at: VT_ERROR put: #unmarshalHResult:;		at: VT_FILETIME put: #unmarshalFiletime:;		at: VT_R4 put: #unmarshalFloat:;		at: VT_R8 put: #unmarshalFloat:;		at: VT_LPSTR put: #unmarshalCString:;		at: VT_LPWSTR put: #unmarshalWString:;		yourself</body><body package="Com- Automation">marshalSelectors	^ MarshalSelectors ifNil: [ MarshalSelectors := self initializeMarshalSelectors ]</body><body package="Com- Automation">obsolete	self ensureNotDefaultClass.	super obsolete.</body><body package="Com- Automation">releaseSelectors	^ ReleaseSelectors ifNil: [ ReleaseSelectors := self initializeReleaseSelectors ]</body><body package="Com- Automation">unmarshalSelectors	^ UnmarshalSelectors ifNil: [ UnmarshalSelectors := self initializeUnMarshalSelectors ]</body></methods><methods><class-id>External.DispSimpleTypeSpec class</class-id> <category>literal array encoding</category><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(typecode)</body></methods><methods><class-id>External.DispSimpleTypeSpec class</class-id> <category>private</category><body package="Com- Automation">createTypeInstanceFor: aTypeCode	"private - used for creating new instances. Please do not call this method but #fromVariantTypeCode: "	^self		basicNew		typecode: aTypeCode;		yourself</body><body package="Com- Automation">definedTypes	^ DefinedTypes</body><body package="Com- Automation">initializeNumericTypeCodes	^NumericTypeCodes := (OrderedCollection new)				add: VT_INT;				add: VT_UINT;				add: VT_UI1;				add: VT_UI2;				add: VT_UI4;				add: VT_UI8;				add: VT_I1;				add: VT_I2;				add: VT_I4;				add: VT_I8;				add: VT_R4;				add: VT_R8;				asArray</body><body package="Com- Automation">numericTypeCodes	^ NumericTypeCodes ifNil: [ self initializeNumericTypeCodes ]</body></methods><methods><class-id>External.DispSimpleTypeSpec class</class-id> <category>instance creation</category><body package="Com- Automation">new	"Creating new instances of simple types is not supported. 	Please use public instance creation api from DispTypeSpec"	^ self shouldNotImplement</body></methods><methods><class-id>External.DispSimpleTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFrom: aTypeDesc typeInfo: anITypeInfo	^self basicFromVariantTypeCode: aTypeDesc typeCode</body><body package="Com- Automation">basicFromVariantTypeCode: aTypeCode	^self definedTypes at: aTypeCode		ifAbsentPut: [self createTypeInstanceFor: aTypeCode]</body></methods><methods><class-id>External.DispSimpleTypeSpec class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	"self initialize"	self registerAsDefaultClass.	CTypesDict := nil.	MarshalSelectors := nil.	UnmarshalSelectors := nil.		ReleaseSelectors := nil.</body></methods><methods><class-id>External.DispSimpleTypeSpec class</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalPtrAutomationParameter: anObject client: aCOMDispatchValueAdaptor	^anObject isCOMInterface		ifTrue: 			[anObject				addRef;				yourself]		ifFalse: 			[super preMarshalPtrAutomationParameter: anObject				client: aCOMDispatchValueAdaptor]</body></methods><methods><class-id>External.COMRecord</class-id> <category>converting</category><body package="Com- Automation">asCOMRecordSpecifiedBy: aRecordInfo	"I am already a COM Record - no conversion needed"	^ self</body><body package="Com- Automation">asPointerParameter	^ self structure asPointerParameter</body><body package="Com- Automation">asSTObject	^ self type convertToSTObject: self</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Answer nil if the receiver cannot be represented as by a known variant type. "	^ VT_RECORD</body><body package="Com- Automation">doesNotUnderstand: aMessage	| member |	member := aMessage selector.	aMessage arguments size &gt; 1  		ifTrue: [ ^ super doesNotUnderstand: aMessage ].	member last = $: 		ifTrue: [ 			member := member copyFrom: 1 to: member size - 1.			^ self memberAt: member asSymbol put: aMessage arguments first onMemberNotFoundDo: [ super doesNotUnderstand: aMessage  ] ]		ifFalse: [ 			^ self  memberAt: member asSymbol onMemberNotFoundDo: [ super doesNotUnderstand: aMessage ] ].</body><body package="Com- Automation">setCOMRecordInVariant: aVariant	^aVariant		recordInfo: self recordInfo;		setRecordPointerTo: self copyStructure</body></methods><methods><class-id>External.COMRecord</class-id> <category>comparing</category><body package="Com- Automation">= another	^ self class = another class and: [ 		self basicStructure = self basicStructure and: [			self recordInfo = another recordInfo ]]</body><body package="Com- Automation">hash	^ (self recordInfo hash bitShift: 5) bitOr: self basicStructure hash</body></methods><methods><class-id>External.COMRecord</class-id> <category>member accessing</category><body package="Com- Automation">basicMemberAt: aSymbol	^ self memberAt: aSymbol onMemberNotFoundDo: [ MemberNotFoundError raise]</body><body package="Com- Automation">basicMemberAt: aSymbol put: aValue	^ self memberAt: aSymbol put: aValue onMemberNotFoundDo: [ MemberNotFoundError raise ]</body><body package="Com- Automation">basicRefMemberAt: aSymbol	^ self refMemberAt: aSymbol onMemberNotFoundDo: [ MemberNotFoundError raise ]</body><body package="Com- Automation">memberAt: aSymbol	| path |	path := self splitAccessPath: aSymbol.	^ path getMemberIn: self.</body><body package="Com- Automation">memberAt: aSymbol put: aValue	| path |	path := self splitAccessPath: aSymbol.	^ path setValue: aValue in: self</body><body package="Com- Automation">refMemberAt: aSymbol	| path |	path := self splitAccessPath: aSymbol.	^ path getMemberReferenceIn:  self</body></methods><methods><class-id>External.COMRecord</class-id> <category>marshaling</category><body package="Com- Automation">setDictEntriesIn: aDictionary usingType: aTypeDescription	self typesNamesAndMembersDo: [:type :name :value |			aDictionary at:  name asSymbol put: (type convertToSTObject: value value value)  ].	^ aDictionary</body><body package="Com- Automation">setVariablesIn: anObject usingType: aTypeDescription	self typesNamesAndMembersDo: [:type :name :value |			anObject perform: (name,':') asSymbol with: (type convertToSTObject: value value value)  ].	^ anObject</body></methods><methods><class-id>External.COMRecord</class-id> <category>binding support</category><body package="Com- Automation">bindTypeTo: aClass	"Bind my type to a class. Unmarshaling records of my type using the asSTObject message will 	automatically be converted to instances of the given class"	^ self type bindTo: aClass</body></methods><methods><class-id>External.COMRecord</class-id> <category>private member accessing</category><body package="Com- Automation">memberAt: aSymbol onMemberNotFoundDo: aBlock	^ [ self postProcessMember: (self recordInfo getField: self structure _: aSymbol) ] on: COMError do: [:ex |		ex hresult = -2147319785 			ifTrue: [ aBlock value ]			ifFalse:[ ex pass ]]</body><body package="Com- Automation">memberAt: aSymbol put: aValue onMemberNotFoundDo: aBlock	"This implementation will allow putting values into nested structures."	| aVariant type |	aVariant := self refMemberAt: aSymbol onMemberNotFoundDo: aBlock.	"We have to ensure that reference memory currently contained in the member is released before the	 element is overwritten. A record should not be destroyed as it is embedded in the outer struct, 	 not referenced."	type := self elementTypeAt: aSymbol.	type releaseRecordElement: aVariant.	aVariant value: aValue asValue.	aVariant enforceRelease.</body><body package="Com- Automation">refMemberAt: aSymbol onMemberNotFoundDo: aBlock 	^[ self recordInfo getFieldNoCopy: self structure _: aSymbol] on: COMError		do: [:ex | 			ex hresult = -2147319785 				ifTrue: [aBlock value] 				ifFalse: [ex pass]]</body></methods><methods><class-id>External.COMRecord</class-id> <category>private</category><body package="Com- Automation">allocateStructure	self structure: (self recordInfo recordCreate).	^ self basicStructure</body><body package="Com- Automation">elementTypeAt: aName	| elementName element |	elementName := aName asSymbol.	element := self type elements detect: [:each | each name asSymbol = elementName ].	^ element type.</body><body package="Com- Automation">finalizationRegistry	"Private - Answer the WeakRegistry to be used for finalizing instances of the receiver."	" This is a bit odd to map wrapper structures into the address registry, perhaps,		but it's not unreasonable and it does work "	^COMSessionManager ownedMemoryRegistry</body><body package="Com- Automation">postProcessMember: aMember 	^aMember class = self class 		ifTrue: 			[aMember				configureAsSubrecord;				yourself]		ifFalse: [aMember]</body><body package="Com- Automation">privateRelease	self ownsMemory 		ifTrue: [			self doesNotNeedFinalization.			(self basicStructure notNil and: [self basicStructure isValid]) 				ifTrue: 					["release fields"					self recordInfo recordDestroy: self basicStructure.					self structure: nil].			self recordInfo: nil ]		ifFalse: [ self privateInvalidate ].	^ super release</body></methods><methods><class-id>External.COMRecord</class-id> <category>accessing</category><body package="Com- Automation">basicStructure	^structure</body><body package="Com- Automation">bytes	| size data |	size := self sizeInBytes.	data := ByteArray new: size.	self structure copyAt: 0 to: data size: size startingAt: 1.	^ data</body><body package="Com- Automation">comTypeDescription	^  self type</body><body package="Com- Automation">memberNames	^memberNames ifNil: [self computeMemberNames]</body><body package="Com- Automation">ownsMemory	^ownsMemory</body><body package="Com- Automation">ownsMemory: anObject	ownsMemory := anObject</body><body package="Com- Automation">recordInfo	^recordInfo ifNil: [ self computeRecordInfo. recordInfo ]</body><body package="Com- Automation">recordInfo: anObject	SystemGlobalRegistries unprotect: recordInfo referencedBy: self.	recordInfo := anObject.	SystemGlobalRegistries safe: anObject forLifeTimeOf: self.</body><body package="Com- Automation">sizeInBytes	^  self recordInfo getSize</body><body package="Com- Automation">structure	^structure ifNil: [self allocateStructure ]</body><body package="Com- Automation">structure: anObject	structure := anObject</body><body package="Com- Automation">type	^typeDescription ifNil: [self computeType]</body><body package="Com- Automation">value: anObject	anObject putValuesIntoCOMRecord: self.</body></methods><methods><class-id>External.COMRecord</class-id> <category>private computing</category><body package="Com- Automation">computeMemberNames	^memberNames := self recordInfo getFieldNames</body><body package="Com- Automation">computeRecordInfo	^ nil</body><body package="Com- Automation">computeType	| typeInfo |	typeInfo := recordInfo getTypeInfo.	^typeDescription := DispUserDefTypeSpec fromTypeInfo: typeInfo</body></methods><methods><class-id>External.COMRecord</class-id> <category>enumerating</category><body package="Com- Automation">membersDo: aBlock	| member |	self memberNames do: 			[:name |			member := self refMemberAt: name.			[aBlock value: member] ensure: [aBlock release]]</body><body package="Com- Automation">typesAndMembersDo: aBlock 	self type elements do: 			[:element | 			[self refMemberAt: element name] 				withResultDoAndRelease: [:var | aBlock value: element type value: var]]</body><body package="Com- Automation">typesNamesAndMembersDo: aBlock 	self type elements do: 			[:element | 			[self refMemberAt: element name] 				withResultDoAndRelease: [:var | aBlock value: element type value: element name value: var]]</body></methods><methods><class-id>External.COMRecord</class-id> <category>testing</category><body package="Com- Automation">isValid	^ (self basicStructure notNil and: [self basicStructure isValid])</body></methods><methods><class-id>External.COMRecord</class-id> <category>private tools</category><body package="Com- Automation">splitAccessPath: aSymbol	^ RecordAccessPath fromString: aSymbol</body></methods><methods><class-id>External.COMRecord</class-id> <category>private-session management</category><body package="Com- Automation">shutdownImage	self isValid 		ifTrue: 			[COMDevelopmentWarning raiseSignal: #ErrNamedUnreleasedRecordAtExit &lt;&lt; #com 						&gt;&gt; 'Unreleased COM Record found at image exit']</body></methods><methods><class-id>External.COMRecord</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	self needsFinalization.	self configureAsFullRecord.</body></methods><methods><class-id>External.COMRecord</class-id> <category>configuring</category><body package="Com- Automation">configureAsFullRecord	"configure the COMRecord to be the owner of all referenced memory areas"	self ownsMemory: true</body><body package="Com- Automation">configureAsReferenceSubStructForRelease	self ownsMemory: false</body><body package="Com- Automation">configureAsReferencedSubStruct	"Configure the structure to be a reference to a substruct. That is, neither my memory	 nor the memory referenced by members belongs to me. I am not allowed to free any of	 it"	self ownsMemory: false</body><body package="Com- Automation">configureAsSafeArrayGetBuffer	self ownsMemory: true</body><body package="Com- Automation">configureAsSubrecord	self ownsMemory: true</body></methods><methods><class-id>External.COMRecord</class-id> <category>copying</category><body package="Com- Automation">copy	^(self class structure: (self copyStructure)		recordInfo: self recordInfo)		configureAsSubrecord;		yourself</body><body package="Com- Automation">copyStructure	^self recordInfo recordCreateCopy: self structure</body></methods><methods><class-id>External.COMRecord</class-id> <category>releasing</category><body package="Com- Automation">enforceInvalidation	^self privateInvalidate</body><body package="Com- Automation">enforceRelease	^ self privateRelease</body><body package="Com- Automation">invalidate	self callIndicatesChangeNeeded</body><body package="Com- Automation">privateInvalidate	self doesNotNeedFinalization.	structure := nil.	recordInfo enforceInvalidation.	self recordInfo: nil.</body><body package="Com- Automation">release	self callIsDispensable.</body></methods><methods><class-id>External.COMRecord</class-id> <category>finalizing</category><body package="Com- Automation">finalize	self privateRelease.</body></methods><methods><class-id>External.COMRecord class</class-id> <category>instance creation</category><body package="Com- Automation">basicStructure: aStructure recordInfo: iRecordInfo 	^(self basicNew)		structure: aStructure;		recordInfo: iRecordInfo;		yourself</body><body package="Com- Automation">new	^ super new initialize</body><body package="Com- Automation">newWith: aRecordInfo	^ self new		recordInfo: aRecordInfo;		allocateStructure;		yourself</body><body package="Com- Automation">recordInfo: iRecordInfo value: aValue	^(self new)		recordInfo: iRecordInfo;		value: aValue;		yourself</body><body package="Com- Automation">structure: aStructure recordInfo: iRecordInfo 	^(self new)		structure: aStructure;		recordInfo: iRecordInfo;		yourself</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing monetary</category><body package="Com- Automation">internationalMonetaryDigits	"self deGerman internationalMonetaryDigits"	^ self getIntInfo:  LOCALE_IINTLCURRDIGITS</body><body package="Com- Automation">internationalMonetarySymbol	"self deGerman internationalMonetarySymbol"	^ self getInfo:  LOCALE_SINTLSYMBOL</body><body package="Com- Automation">localMonetaryDigits	"self deGerman localMonetaryDigits"	^ self getIntInfo:  LOCALE_ICURRDIGITS</body><body package="Com- Automation">localMonetarySymbol	"self deGerman localMonetarySymbol"	^ self getInfo:  LOCALE_SCURRENCY</body><body package="Com- Automation">monetaryDecimalSeparator	^ self getInfo:  LOCALE_SMONDECIMALSEP</body><body package="Com- Automation">monetaryGrouping	^ self getInfo:  LOCALE_SMONGROUPING</body><body package="Com- Automation">monetarySymbolIsSeparatedFromAmountBySpace	^ self getBooleanInfo: LOCALE_IPOSSEPBYSPACE</body><body package="Com- Automation">monetarySymbolIsSeparatedFromNegativeAmountBySpace	^ self getBooleanInfo: LOCALE_INEGSEPBYSPACE</body><body package="Com- Automation">monetarySymbolPrecedesAmount	^ self getBooleanInfo: LOCALE_IPOSSYMPRECEDES</body><body package="Com- Automation">monetarySymbolPrecedesNegativeAmount	^ self getBooleanInfo: LOCALE_INEGSYMPRECEDES</body><body package="Com- Automation">monetaryThousandSeparator	^ self getInfo:  LOCALE_SMONTHOUSANDSEP</body><body package="Com- Automation">negativeCurrencyMode	^ self getInfo: LOCALE_INEGCURR</body><body package="Com- Automation">posititiveCurrencyMode	^ self getInfo:  LOCALE_ICURRENCY</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing date constants</category><body package="Com- Automation">abbreviatedNameForDay1	"monday"	^ self getInfo:  LOCALE_SABBREVDAYNAME1</body><body package="Com- Automation">abbreviatedNameForDay2	"tuesday"	^ self getInfo:  LOCALE_SABBREVDAYNAME2</body><body package="Com- Automation">abbreviatedNameForDay3	"wednesday"	^ self getInfo:  LOCALE_SABBREVDAYNAME3</body><body package="Com- Automation">abbreviatedNameForDay4	"thursday"	^ self getInfo:  LOCALE_SABBREVDAYNAME4</body><body package="Com- Automation">abbreviatedNameForDay5	"friday"	^ self getInfo:  LOCALE_SABBREVDAYNAME5</body><body package="Com- Automation">abbreviatedNameForDay6	"saturday"	^ self getInfo:  LOCALE_SABBREVDAYNAME6</body><body package="Com- Automation">abbreviatedNameForDay7	"sunday"	^ self getInfo:  LOCALE_SABBREVDAYNAME7</body><body package="Com- Automation">abbreviatedNameForDay: anIndex	^ self perform: (#abbreviatedNameForDay,anIndex printString) asSymbol</body><body package="Com- Automation">abbreviatedNameForMonth1	^ self getInfo:  LOCALE_SABBREVMONTHNAME1</body><body package="Com- Automation">abbreviatedNameForMonth10	^ self getInfo:  LOCALE_SABBREVMONTHNAME10</body><body package="Com- Automation">abbreviatedNameForMonth11	^ self getInfo:  LOCALE_SABBREVMONTHNAME11</body><body package="Com- Automation">abbreviatedNameForMonth12	^ self getInfo:  LOCALE_SABBREVMONTHNAME12</body><body package="Com- Automation">abbreviatedNameForMonth13	^ self getInfo:  LOCALE_SABBREVMONTHNAME13</body><body package="Com- Automation">abbreviatedNameForMonth2	^ self getInfo:  LOCALE_SABBREVMONTHNAME2</body><body package="Com- Automation">abbreviatedNameForMonth3	^ self getInfo:  LOCALE_SABBREVMONTHNAME3</body><body package="Com- Automation">abbreviatedNameForMonth4	^ self getInfo:  LOCALE_SABBREVMONTHNAME4</body><body package="Com- Automation">abbreviatedNameForMonth5	^ self getInfo:  LOCALE_SABBREVMONTHNAME5</body><body package="Com- Automation">abbreviatedNameForMonth6	^ self getInfo:  LOCALE_SABBREVMONTHNAME6</body><body package="Com- Automation">abbreviatedNameForMonth7	^ self getInfo:  LOCALE_SABBREVMONTHNAME7</body><body package="Com- Automation">abbreviatedNameForMonth8	^ self getInfo:  LOCALE_SABBREVMONTHNAME8</body><body package="Com- Automation">abbreviatedNameForMonth9	^ self getInfo:  LOCALE_SABBREVMONTHNAME9</body><body package="Com- Automation">abbreviatedNameForMonth: anIndex	^ self perform: (#abbreviatedNameForMonth,anIndex printString) asSymbol</body><body package="Com- Automation">longNameForDay1	"monday"	^ self getInfo:  LOCALE_SDAYNAME1</body><body package="Com- Automation">longNameForDay2	"tuesday"	^ self getInfo:  LOCALE_SDAYNAME2</body><body package="Com- Automation">longNameForDay3	"wednesday"	^ self getInfo:  LOCALE_SDAYNAME3</body><body package="Com- Automation">longNameForDay4	"thursday"	^ self getInfo:  LOCALE_SDAYNAME4</body><body package="Com- Automation">longNameForDay5	"friday"	^ self getInfo:  LOCALE_SDAYNAME5</body><body package="Com- Automation">longNameForDay6	"saturday"	^ self getInfo:  LOCALE_SDAYNAME6</body><body package="Com- Automation">longNameForDay7	"sunday"	^ self getInfo:  LOCALE_SDAYNAME7</body><body package="Com- Automation">longNameForDay: anIndex	^ self perform: (#longNameForDay,anIndex printString) asSymbol</body><body package="Com- Automation">longNameForMonth1	"january"	^ self getInfo:  LOCALE_SMONTHNAME1</body><body package="Com- Automation">longNameForMonth10	"oct"	^ self getInfo:  LOCALE_SMONTHNAME10</body><body package="Com- Automation">longNameForMonth11	"nov"	^ self getInfo:  LOCALE_SMONTHNAME11</body><body package="Com- Automation">longNameForMonth12	"dec."	^ self getInfo:  LOCALE_SMONTHNAME12</body><body package="Com- Automation">longNameForMonth13	"... if exists"	^ self getInfo:  LOCALE_SMONTHNAME13</body><body package="Com- Automation">longNameForMonth2	"feb."	^ self getInfo:  LOCALE_SMONTHNAME2</body><body package="Com- Automation">longNameForMonth3	"march"	^ self getInfo:  LOCALE_SMONTHNAME3</body><body package="Com- Automation">longNameForMonth4	"april"	^ self getInfo:  LOCALE_SMONTHNAME4</body><body package="Com- Automation">longNameForMonth5	"may"	^ self getInfo:  LOCALE_SMONTHNAME5</body><body package="Com- Automation">longNameForMonth6	"june"	^ self getInfo:  LOCALE_SMONTHNAME6</body><body package="Com- Automation">longNameForMonth7	"july"	^ self getInfo:  LOCALE_SMONTHNAME7</body><body package="Com- Automation">longNameForMonth8	"august"	^ self getInfo:  LOCALE_SMONTHNAME8</body><body package="Com- Automation">longNameForMonth9	"sept"	^ self getInfo:  LOCALE_SMONTHNAME9</body><body package="Com- Automation">longNameForMonth: anIndex	^ self perform: (#longNameForMonth,anIndex printString) asSymbol</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing date and time</category><body package="Com- Automation">amDesignator	"self usEnglish amDesignator"	^ self getInfo:  LOCALE_S1159</body><body package="Com- Automation">centuryFormatSpecifier	^ self getInfo:  LOCALE_ICENTURY</body><body package="Com- Automation">dateSeparator	^ self getInfo:  LOCALE_SDATE</body><body package="Com- Automation">firstDayOfWeekSpecifier	^ self getInfo:  LOCALE_IFIRSTDAYOFWEEK</body><body package="Com- Automation">firstWeekOfYearSpecifier	^ self getInfo:  LOCALE_IFIRSTWEEKOFYEAR</body><body package="Com- Automation">leadingZerosInDayField	"short date format"	^ self getInfo:  LOCALE_IDAYLZERO</body><body package="Com- Automation">leadingZerosInMonthField	"short date format"	^ self getInfo:  LOCALE_IMONLZERO</body><body package="Com- Automation">leadingZerosInTimeField	^ self getInfo:  LOCALE_ITLZERO</body><body package="Com- Automation">longDateFormat	^ self getInfo:  LOCALE_SLONGDATE</body><body package="Com- Automation">longDateFormatOrdering	^ self getInfo:  LOCALE_ILDATE</body><body package="Com- Automation">pmDesignator	^ self getInfo:  LOCALE_S2359</body><body package="Com- Automation">shortDateFormat	^ self getInfo:  LOCALE_SSHORTDATE</body><body package="Com- Automation">shortDateFormatOrdering	^ self getInfo:  LOCALE_IDATE</body><body package="Com- Automation">timeFormat	"self deGerman timeFormat"	^ self getInfo:  LOCALE_STIMEFORMAT</body><body package="Com- Automation">timeFormatSpecifier	^ self getInfo: LOCALE_ITIME</body><body package="Com- Automation">timeMarkerPosition	^ self getInfo:  LOCALE_ITIMEMARKPOSN</body><body package="Com- Automation">timeSeparator	^ self getInfo:  LOCALE_STIME</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing number formats</category><body package="Com- Automation">decimalSeparator	^ self getInfo: LOCALE_SDECIMAL</body><body package="Com- Automation">digitGrouping	^ self getInfo: LOCALE_SGROUPING</body><body package="Com- Automation">leadingZeros	^ self getInfo: LOCALE_ILZERO</body><body package="Com- Automation">nativeDigits	^ self getInfo: LOCALE_SNATIVEDIGITS</body><body package="Com- Automation">negativeNumberModeIdentifier	^ self getInfo: LOCALE_INEGNUMBER</body><body package="Com- Automation">numberOfFractionalDigits	^ self getInfo: LOCALE_IDIGITS</body><body package="Com- Automation">thousandSeparator	^ self getInfo: LOCALE_STHOUSAND</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>private</category><body package="Com- Automation">getBooleanInfo: type	^ (self getInfo: type) = '1'</body><body package="Com- Automation">getEnumInfo: type dict: aDictionary onError: aBlock	^ aDictionary at: (self getInfo: type) ifAbsent: aBlock</body><body package="Com- Automation">getInfo: type	^ Win32KernelDLL current getLocaleInfo: id lcType: type</body><body package="Com- Automation">getIntInfo: type	^ Number readFromString: (self getInfo: type)</body><body package="Com- Automation">nextTokenFrom: aStream	| writeStream char isAlpha |	aStream atEnd ifTrue: [ ^ '' ].	writeStream := (String new: 5) writeStream.	char := aStream next.	writeStream nextPut: char.	isAlpha := char isAlphabetic.	[ aStream atEnd not and: [ (char := aStream peek) isAlphabetic = isAlpha ]] whileTrue: [ 		writeStream nextPut: char.  aStream skip: 1. ].	^ writeStream contents.</body><body package="Com- Automation">replaceTemplatesIn: aString using: aValue	| readStream writeStream token |	readStream := aString readStream.	writeStream := (String new: aString size) writeStream.	[ token := self nextTokenFrom: readStream. token notEmpty ] whileTrue: [		 writeStream nextPutAll: (self replaceToken: token using: aValue) ].	^ writeStream contents</body><body package="Com- Automation">replaceToken: aToken using: aValue	^ (self class replacements at: aToken ifAbsent: [ ^ aToken ]) value: self value: aValue</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing country</category><body package="Com- Automation">abbreviatedCountryName	^ self getInfo:  LOCALE_SABBREVCTRYNAME</body><body package="Com- Automation">countryCode	^ self getInfo:  LOCALE_ICOUNTRY</body><body package="Com- Automation">englishCountryName	^ self getInfo:  LOCALE_SENGCOUNTRY</body><body package="Com- Automation">localizedCountryName	^ self getInfo:  LOCALE_SCOUNTRY</body><body package="Com- Automation">nativeCountryName	^ self getInfo:  LOCALE_SNATIVECTRYNAME</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing</category><body package="Com- Automation">calendarTypeID	^ self getInfo:  LOCALE_ICALENDARTYPE</body><body package="Com- Automation">id	^id</body><body package="Com- Automation">id: anObject	id := anObject</body><body package="Com- Automation">listItemSeparator	^ self getInfo: LOCALE_SLIST</body><body package="Com- Automation">mesurementName		^self		getEnumInfo: LOCALE_IMEASURE		dict:			((Dictionary new)				at: '0' put: #metric;				at: '1' put: #us;				yourself)		onError: [self error: #UnknownMetric &lt;&lt; #com &gt;&gt; 'Unknown metric']</body><body package="Com- Automation">negativeSign	^ self getInfo: LOCALE_SNEGATIVESIGN</body><body package="Com- Automation">negativeSignPosition	^ self getInfo: LOCALE_INEGSIGNPOSN</body><body package="Com- Automation">positiveSign	^ self getInfo: LOCALE_SPOSITIVESIGN</body><body package="Com- Automation">positiveSignPosition	^ self getInfo: LOCALE_IPOSSIGNPOSN</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing language</category><body package="Com- Automation">abbreviatedLanguageName		^self getInfo: LOCALE_SABBREVLANGNAME</body><body package="Com- Automation">englishLanguageName		^self getInfo: LOCALE_SENGLANGUAGE</body><body package="Com- Automation">languageCode		^self getInfo: LOCALE_ILANGUAGE</body><body package="Com- Automation">localizedLanguageName	"(self withID: 1041) localizedLanguageName"		^self getInfo: LOCALE_SLANGUAGE</body><body package="Com- Automation">nativeLanguageName	"(self withID: 1041) nativeLanguageName"		^self getInfo: LOCALE_SNATIVELANGNAME</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing win 400</category><body package="Com- Automation">fontSignature	^ self getInfo: LOCALE_FONTSIGNATURE</body><body package="Com- Automation">iso3166AbbreviatedCountryName	^ self getInfo: LOCALE_SISO3166CTRYNAME</body><body package="Com- Automation">iso639AbbreviatedLanguageName	^ self getInfo: LOCALE_SISO639LANGNAME</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing calendar settings</category><body package="Com- Automation">additionalCalendarTypesSpecifier	^ self getInfo: LOCALE_IOPTIONALCALENDAR</body><body package="Com- Automation">calendarTypeSpecifier	^ self getInfo: LOCALE_ICALENDARTYPE</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing win 500</category><body package="Com- Automation">defaultEBCDICCodepage		^self getIntInfo: LOCALE_IDEFAULTEBCDICCODEPAGE</body><body package="Com- Automation">digitSubstitution		^self getEnumInfo: LOCALE_IDIGITSUBSTITUTION		dict: (Dictionary new at: '0' put: #context; at: '1' put: #none; at: '2' put: #national; yourself)		onError: [ self error: (#UnknownDigitSubstitution &lt;&lt; #com &gt;&gt; 'Unknown digitSubstitution')].</body><body package="Com- Automation">englishCurrencyName		^self getInfo: LOCALE_SENGCURRNAME</body><body package="Com- Automation">nativeCurrencyName		^self getInfo: LOCALE_SNATIVECURRNAME</body><body package="Com- Automation">paperSize		^self		getEnumInfo: LOCALE_IPAPERSIZE		dict:			((Dictionary new)				at: '1' put: #letter;				at: '5' put: #legal;				at: '8' put: #a3;				at: '9' put: #a4;				yourself)		onError: [self error: 'Unknown paper format']</body><body package="Com- Automation">sortName		^self getInfo: LOCALE_SSORTNAME</body><body package="Com- Automation">yearMonthFormatString		^self getInfo: LOCALE_SYEARMONTH</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>accessing defaults</category><body package="Com- Automation">defaultANSICodePage	^ self getInfo: LOCALE_IDEFAULTANSICODEPAGE</body><body package="Com- Automation">defaultCountryCode	^ self getInfo: LOCALE_IDEFAULTCOUNTRY</body><body package="Com- Automation">defaultLanguageCode	^ self getInfo: LOCALE_IDEFAULTLANGUAGE</body><body package="Com- Automation">defaultMACCodePage	^ self getInfo: LOCALE_IDEFAULTMACCODEPAGE</body><body package="Com- Automation">defaultOEMCodePage	^ self getInfo: LOCALE_IDEFAULTCODEPAGE</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>examples</category><body package="Com- Automation">formatTime: aTime	"self deGerman formatTime: Time now"	"self usEnglish formatTime: Time now"	^ self replaceTemplatesIn: self timeFormat using: aTime</body><body package="Com- Automation">longLocalDateFormatFor: aDate	"self usEnglish longLocalDateFormatFor: Date today"	^ self replaceTemplatesIn: self longDateFormat using: aDate</body><body package="Com- Automation">shortLocalDateFormatFor: aDate	"self deGerman shortLocalDateFormatFor: Date today"	^ self replaceTemplatesIn: self shortDateFormat using: aDate</body></methods><methods><class-id>External.WindowsLocale</class-id> <category>printing</category><body package="Com- Automation">isoRepresentation		^self iso639AbbreviatedLanguageName , '_' , self iso3166AbbreviatedCountryName</body><body package="Com- Automation">name		^ self id = 0 		ifTrue: [ 'Any' ]		ifFalse: [ self isoRepresentation ]</body><body package="Com- Automation">printOn: aStream		super printOn: aStream.	aStream nextPutAll: '(',self isoRepresentation,')'</body></methods><methods><class-id>External.WindowsLocale class</class-id> <category>constants</category><body package="Com- Automation">deGerman	^ self withID: 1024</body><body package="Com- Automation">newUserDefault	^ self withID: 0</body><body package="Com- Automation">usEnglish	^ self withID: 1033</body></methods><methods><class-id>External.WindowsLocale class</class-id> <category>instance creation</category><body package="Com- Automation">withID: anID	^ self new		id: anID;		yourself</body></methods><methods><class-id>External.WindowsLocale class</class-id> <category>private</category><body package="Com- Automation">initReplacements		^ Replacements := (Dictionary new)		at: 'dddd' put: [:locale :aValue | locale longNameForDay: aValue weekdayIndex];		at: 'MMMM' put: [:locale :aValue | locale longNameForMonth: aValue monthIndex];		at: 'MM' put: [:locale :aValue | aValue monthIndex printFormat: '00'];		at: 'M' put: [:locale :aValue | aValue monthIndex printString];		at: 'yyyy' put: [:locale :aValue | aValue year printFormat: '0000'];		at: 'dd' put: [:locale :aValue | aValue dayOfMonth printFormat: '00'];		at: 'd' put: [:locale :aValue | aValue dayOfMonth printString];		at: 'HH' put: [:locale :aTime | aTime hours printFormat: '00' ];		at: 'hh' put: [:locale :aTime | (aTime hours \\ 12) printFormat: '00' ];		at: 'h' put: [:locale :aTime | (aTime hours \\ 12) printString ];		at: 'mm' put: [:locale :aTime | aTime minutes printFormat: '00' ];		at: 'ss' put: [:locale :aTime | aTime seconds printFormat: '00' ];		at: 'tt' put: [:locale :aTime | aTime hours &lt; 12 ifTrue: [ locale amDesignator ] ifFalse: [ locale pmDesignator ] ];		yourself</body><body package="Com- Automation">replacements	^ Replacements ifNil: [ self initReplacements ].</body></methods><methods><class-id>External.COMDateResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Automation">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^COMExternalInterface current DATE</body></methods><methods><class-id>External.COMDateResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Automation">getResultValue	" Private - answer the contents as a Timestamp representing the DATE value. "	^( COMDate fromValue: buffer contents ) asTimestamp</body></methods><methods><class-id>External.COMAutomationServerClassFactoryObject</class-id> <category>subclass-object creation</category><body package="Com- Automation">createObject	"Private. Answer a new instance of the object class."	^self objectClass on: self automationObjectClass new		clsid: self objectCLSID		specificationTable: self specificationTable		typeLibraries: self typeLibraries</body><body package="Com- Automation">createObjectFor: aControllingUnknown	"Private. Answer a new instance of the object class which will be used as an inner object in the aggregate controlled by &lt;aControllingUnknown&gt;."	| anAutomationServer |	anAutomationServer := self objectClass forControllingUnknown: aControllingUnknown.	anAutomationServer isNil		ifTrue: [ ^nil ].	anAutomationServer		clsid: self objectCLSID;		publishedObject: self automationObjectClass new;		specificationTable: self specificationTable;		typeLibraries: self typeLibraries.	^anAutomationServer</body></methods><methods><class-id>External.COMAutomationServerClassFactoryObject</class-id> <category>accessing</category><body package="Com- Automation">automationObjectClass	" Answer the class whose instances are created by the receiver for publication via an instance of the automation server class. "	^automationObjectClass</body><body package="Com- Automation">dispatchInterfaceIID	" Answer the IID of the dispatch interface which is supported by the automation servers which are instantiated by the receiver. "	^dispatchInterfaceIID</body><body package="Com- Automation">dispatchInterfaceIID: anIID	" Set the IID of the dispatch interface which is supported by the automation servers which are instantiated by the receiver. "	dispatchInterfaceIID := anIID.</body><body package="Com- Automation">objectCLSID	" Answer the CLSID of objects which are instantiated by the receiver. "	^objectCLSID</body><body package="Com- Automation">specificationTable	" Answer the specification table which is used by an instance of the automation server for dispatching method and property member invocations to the published object instance.  The specifications must be indexed by the DISPID of the interface members. "	^specificationTable</body><body package="Com- Automation">typeLibraries	"Answer the type library dictionary. The dictionary keys are LCIDs and the values are instances of COMTypeLibrary."	^typeLibraries</body><body package="Com- Automation">typeLibraries: aDictionary 	"Set the type library dictionary. The keys are LCIDs."	aDictionary notNil 		ifTrue: 			[(aDictionary keys reject: [:each | each isInteger]) isEmpty 				ifFalse: 					[self error: #ErrKeysBeLCIDS &lt;&lt; #com 								&gt;&gt; 'The keys must be integer values representing LCIDs.']].	typeLibraries := aDictionary</body><body package="Com- Automation">typeLibraryHolder	^ self automationObjectClass</body></methods><methods><class-id>External.COMAutomationServerClassFactoryObject</class-id> <category>private-accessing</category><body package="Com- Automation">automationObjectClass: aClass	" Private - specify the class whose instances are created by the receiver for publication via an instance of the automation server class. "	automationObjectClass := aClass.</body><body package="Com- Automation">objectCLSID: aCLSID	" Private - set the CLSID of objects which are instantiated by the receiver. "	objectCLSID := aCLSID.	super objectCLSID: aCLSID.</body><body package="Com- Automation">specificationTable: aDispatchSpecificationTable	" Private - set the specification table which is used by an instance of the automation server for dispatching method and property member invocations to the published object instance.  The specifications must be indexed by the DISPID of the interface members. "	specificationTable := aDispatchSpecificationTable.</body></methods><methods><class-id>External.COMAutomationServerClassFactoryObject</class-id> <category>private-IClassFactory2 operations</category><body package="Com- Automation">licenseProvider	^ self automationObjectClass</body></methods><methods><class-id>External.COMAutomationServerClassFactoryObject class</class-id> <category>instance creation</category><body package="Com- Automation">forCLSID: aGUID	" Answer a new instance of the receiver which creates instances of the COM objects implemented by the COM object class which supports the CLSID specified by the GUID &lt;aCLSID&gt;.   Answer nil if the CLSID is not supported. "	" an automation server class factory requires additional information for correct operation "	self shouldNotImplement.</body><body package="Com- Automation">forClass: aCOMObjectClass	" Answer a new instance of the receiver which creates instances of the COM objects implemented by &lt;anOLEObjectClass&gt;. "	" an automation server class factory requires additional information for correct operation "	self shouldNotImplement.</body><body package="Com- Automation">forClass: anAutomationServerClass automationObjectClass: aClass clsid: aCLSID specificationTable: aDispatchSpecificationTable typeLibraries: aDictionary 	" Answer a new instance of the receiver which creates instances of the generic COM automation server &lt;anAutomationServerClass&gt; to publish an instance of &lt;aClass&gt; as a COM automation object with CLSID &lt;aCLSID&gt;.  The dispatch specifications for the properties and methods which are published for &lt;aClass&gt; are defined in &lt;aDispatchSpecificationTable&gt;, which must be indexed by the DISPID of the interface members. "	aDispatchSpecificationTable specificationKey = #memberID 		ifFalse: 			[self error: #ErrIndexedByDISPID &lt;&lt; #com 						&gt;&gt; 'automation server dispatch specifications must be indexed by DISPID'].	^(self new)		objectClass: anAutomationServerClass;		automationObjectClass: aClass;		objectCLSID: aCLSID;		specificationTable: aDispatchSpecificationTable;		typeLibraries: aDictionary;		yourself</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>testing</category><body package="Com- Automation">equalsCOMTypeSpec: aDispTypeSpec	(super equalsCOMTypeSpec: aDispTypeSpec) ifFalse: [^false].	^self hasGuid		ifTrue: [aDispTypeSpec guid = self guid]		ifFalse: 			[self name = aDispTypeSpec name and: [self typelib = aDispTypeSpec typelib]]</body><body package="Com- Automation">hasGuid	^ self guid notNil</body><body package="Com- Automation">isCoclass	^ false</body><body package="Com- Automation">isControl	^ (self typeFlags bitAnd: TYPEFLAG_FCONTROL) ~= 0</body><body package="Com- Automation">isEnumType	^ false</body><body package="Com- Automation">isHidden	^ (self typeFlags bitAnd: TYPEFLAG_FHIDDEN) ~= 0</body><body package="Com- Automation">isUserdefined	"answer wether this type is a userdefined one"	^ true</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">docs	^docs ifNil: [ self computeDocs ]</body><body package="Com- Automation">docs: anObject	docs := anObject.	docs		associationsDo: [:each | each value isNil ifTrue: [docs removeKey: each key]]</body><body package="Com- Automation">elements	self subclassResponsibility</body><body package="Com- Automation">fullName 	^ (self typelib ifNil: [ '' ] ifNotNil: [ typelib shortName ,'.']), self name</body><body package="Com- Automation">fullNameWithKind	^ self kindname,' ',self fullName</body><body package="Com- Automation">guid	^guid</body><body package="Com- Automation">guid: anObject	guid := anObject</body><body package="Com- Automation">name	^self docs ifNotNil: [:aDictionary | aDictionary at: self nameKey ifAbsent: [nil]]</body><body package="Com- Automation">name: aName	docs ifNil: [ docs := Dictionary new ].	docs at: self nameKey put:  aName.</body><body package="Com- Automation">nameKey	^'name'</body><body package="Com- Automation">nameOrNil	^docs ifNotNil: [docs at: 'name' ifAbsent: [nil]]</body><body package="Com- Automation">typeFlags	^typeFlags</body><body package="Com- Automation">typeFlags: anObject	typeFlags := anObject</body><body package="Com- Automation">typekind	^ self class typekinds first</body><body package="Com- Automation">typelib	^typelib</body><body package="Com- Automation">typelib: anObject	typelib := anObject</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>comparing</category><body package="Com- Automation">hash	^ (typelib hash bitShift: 5) bitOr: self name hash</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	typeFlags := 0.</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>printing</category><body package="Com- Automation">kindname	self subclassResponsibility</body><body package="Com- Automation">printOn: aStream	self printOn: aStream name: self name</body><body package="Com- Automation">printOn: aStream name: aName	aStream nextPutAll: (aName ifNil: [ '~unnamed~' ]) ,'(',self kindname,')'</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>browser support</category><body package="Com- Automation">member	"return my automation member - browser support"	^ nil</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>compacting</category><body package="Com- Automation">compact</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>accessing documentation</category><body package="Com- Automation">documentation	^self docs at: 'documentation' ifAbsent: [nil]</body><body package="Com- Automation">helpContextId	^ self docs at: 'helpContextID' ifAbsent: [ nil ]</body><body package="Com- Automation">helpFile	^ self docs at: 'helpFile' ifAbsent: [nil]</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>private</category><body package="Com- Automation">computeDocs	^self asTypeInfo ifNotNil: 			[:typeInfo |			self docs: typeInfo getDocumentation.			docs]</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>literal array encoding</category><body package="Com- Automation">literallyEncodedAttributes	"If we do not have a guid, we must store the name. Otherwise it will not be possible to find the type	 in the type-library again"	| attributes |	attributes := super literallyEncodedAttributes.	^self hasGuid		ifTrue: [#(#guid) , attributes]		ifFalse: [#(#name) , attributes]</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>converting</category><body package="Com- Automation">asTypeInfo	| result |	self hasGuid ifTrue: [result := self asTypeInfoUsingGuid].	result isNil ifTrue: [result := self asTypeInfoUsingName].	^result</body><body package="Com- Automation">asTypeInfoUsingGuid	| comTypelib |	comTypelib := self typelib				ifNil: [^nil]				ifNotNil: [:typeLib | typeLib asTypeLib].	^	[comTypelib typeInfoOfGuidAt: self guid			"Superclass implementation returns a separate reference counted typeinfo. The above type info 		 is cached and automatically released by the typelibrary. Therefore we need to create a copy here"]			ensure: [comTypelib enforceRelease]</body><body package="Com- Automation">asTypeInfoUsingName	"Convert type type into a ITypeInfo interface"	| comTypelib |	self nameOrNil ifNil: [^nil].	comTypelib := self typelib asTypeLib.	^[comTypelib typeInfoNamed: self name] ensure: [comTypelib enforceRelease]</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>initialize-release</category><body package="Com- Automation">obsolete	 self ensureNotUdtDefaultTypeClass.	 ^ super obsolete</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>private compacting</category><body package="Com- Automation">compactAllTypes 	self allSubclassesDo: [:aClass | aClass compactTypes ].</body><body package="Com- Automation">compactTypes	self allInstancesDo: [:each | each compact ].</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>private initialization</category><body package="Com- Automation">initializeUdtTypeMap	UdtTypeMap := Dictionary new.	self udtBaseTypeClass allSubclassesDo: [:each |		each registerUdtTypesIn: UdtTypeMap ].	^ UdtTypeMap</body><body package="Com- Automation">registerUdtTypesIn: aDictionary	self typekinds do: [:each |		aDictionary at: each put: self ].</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>instance creation</category><body package="Com- Automation">completeFromTypeInfo: refTypeInfo 	^ self fromTypeInfo: refTypeInfo</body><body package="Com- Automation">fromTypeInfo: refTypeInfo 	| class |	class := self udtClassFor: refTypeInfo ifNil: [^ nil].	^class basicFromTypeInfo: refTypeInfo</body><body package="Com- Automation">fromTypeInfo: refTypeInfo typeLibDescription: typeLibDescription	| class |	class := self udtClassFor: refTypeInfo ifNil: [^nil].	^class basicFromTypeInfo: refTypeInfo typeLib: typeLibDescription</body><body package="Com- Automation">new	^ super new initialize</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>private</category><body package="Com- Automation">ensureNotUdtDefaultTypeClass	UdtDefaultTypeClass == self ifTrue: [ UdtDefaultTypeClass := nil ].</body><body package="Com- Automation">registerAsUdtDefaultTypeClass	UdtDefaultTypeClass := self</body><body package="Com- Automation">typeCodes	^ self = self udtBaseTypeClass 			ifTrue: [ Array with: VT_USERDEFINED ]			ifFalse: [ #() ]</body><body package="Com- Automation">typeLibDescFrom: anITypeInfo	| lib |	lib := anITypeInfo getContainingTypeLib.	^TypeLibDescriptor fromITypeLib: lib</body><body package="Com- Automation">udtBaseTypeClass 	^ DispUserDefTypeSpec</body><body package="Com- Automation">udtClassFor: aTypeInfo ifNil: aBlock	^ self udtTypeMap at: aTypeInfo typekind ifAbsent: aBlock</body><body package="Com- Automation">udtDefaultTypeClass	^ UdtDefaultTypeClass ifNil: [ self error: (#UdtDefaultTypeClassNotSet &lt;&lt; #com &gt;&gt;'UDT default Typeclass not set') ]</body><body package="Com- Automation">udtTypeMap	^ UdtTypeMap ifNil: [ self initializeUdtTypeMap ]</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFrom: aTypeDesc typeInfo: anITypeInfo	| refTypeInfo |	refTypeInfo := [anITypeInfo getRefTypeInfo: aTypeDesc hreftype] on: Error do: [:ex | ^nil].	^self fromTypeInfo: refTypeInfo</body><body package="Com- Automation">basicFromTypeInfo: refTypeInfo 	^self basicFromTypeInfo: refTypeInfo typeLib: (self typeLibDescFrom: refTypeInfo)</body><body package="Com- Automation">basicFromTypeInfo: refTypeInfo typeLib: aTypeLibDescriptor	| docs |	^ aTypeLibDescriptor typeDescriptionForTypeInfo: refTypeInfo				ifAbsentPut: 					[docs := refTypeInfo getDocumentation.					(self new)						typelib: aTypeLibDescriptor;						docs: docs;						typeFlags: refTypeInfo typeFlags;						guid: refTypeInfo guid;						yourself].</body><body package="Com- Automation">basicFromVariantTypeCode: aTypeCode	self shouldNotImplement</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds	self subclassResponsibility</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>updating</category><body package="Com- Automation">update: anAspect with: aParameter from: anObject	(anAspect = #clearCache and: [ anObject = COMDispatchSpecificationTable]) ifTrue: [ self compactAllTypes. ]</body></methods><methods><class-id>External.DispUserDefTypeSpec class</class-id> <category>literal array encoding</category><body package="Com- Automation">literallyEncodedAttributes	^super literallyEncodedAttributes , #(#typeFlags #typelib)</body></methods><methods><class-id>External.DispComponentTypeSpec</class-id> <category>compacting</category><body package="Com- Automation">compact	super compact.	elements := nil.</body></methods><methods><class-id>External.DispComponentTypeSpec</class-id> <category>private</category><body package="Com- Automation">addCElement: each toType: type index: index	type		at: each name asSymbol		put: (self cElementValue: each)</body><body package="Com- Automation">addElement: element into: coll	coll add: element.</body><body package="Com- Automation">cElementValue: anElement	"retrieve the c value for an element"	self subclassResponsibility</body><body package="Com- Automation">computeElements	| typeInfo |	typeInfo := self asTypeInfo.	self computeElementsFrom: typeInfo.	^elements</body><body package="Com- Automation">computeElementsFrom: typeInfo 	self elements: (self elementsFrom: typeInfo)</body><body package="Com- Automation">elementsFrom: aTypeInfo 	| coll |	coll := self newElementCollection.	aTypeInfo variablesDo: 			[:variable | 			self addElement: (self elementClass fromVarDesc: variable) into: coll].	^coll</body><body package="Com- Automation">newCType	self subclassResponsibility</body><body package="Com- Automation">newElementCollection	self subclassResponsibility</body></methods><methods><class-id>External.DispComponentTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">bindTo: aClass	self class bind: self to: aClass.</body><body package="Com- Automation">cType	| type index |	type := (self newCType)				name: self name;				yourself.	index := 1.	self elements do: 			[:each |			self addCElement: each toType: type index: index.			index := index + 1].	^type</body><body package="Com- Automation">elementClass	self subclassResponsibility</body><body package="Com- Automation">elementNamed: aName	| tempName |	tempName := aName asString.	^ self elements detect: [:each | each name = tempName] ifNone: [ nil ]</body><body package="Com- Automation">elements	^elements ifNil: [ self computeElements ]</body><body package="Com- Automation">elements: anObject	elements := anObject</body><body package="Com- Automation">unbind	self class unbind: self</body></methods><methods><class-id>External.DispComponentTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">convertToSTObject: aCOMObject		| aClass |	aClass := self class		stClassForCOMType: self		ifNone: [ self noSuitableClassFound ].	^aClass fromUDTObject: aCOMObject ofType: self</body><body package="Com- Automation">noSuitableClassFound		^self		error:			#ClassNotKnownForConversion &lt;&lt; #com &gt;&gt;					'Don''t know to which class to convert the COM Object'</body></methods><methods><class-id>External.DispComponentTypeSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds	^ #()</body></methods><methods><class-id>External.DispComponentTypeSpec class</class-id> <category>instance creation</category><body package="Com- Automation">completeFromTypeInfo: refTypeInfo 	^ (super completeFromTypeInfo: refTypeInfo)			computeElementsFrom: refTypeInfo;			yourself</body></methods><methods><class-id>External.DispComponentTypeSpec class</class-id> <category>binding support</category><body package="Com- Automation">bind: aType to: aClass	aType hasGuid		ifTrue: 	[ self guidBind: aType to: aClass ] 		ifFalse:	[ self weakBind: aType to: aClass ]</body><body package="Com- Automation">stClassForCOMType: aType ifNone: aBlock	"Return the ST class suitable for representing instances of the given COM Type.	 The ST Class has to be bound to the COM type before "		| binding |	binding := aType hasGuid		ifTrue:			[self guidBindingFor: aType ifAbsent: [^aBlock value]]		ifFalse:			[self weakBindingFor: aType ifAbsent: [^aBlock value]].	^binding valueOrDo: aBlock</body><body package="Com- Automation">unbind: aType 	aType hasGuid		ifTrue: 	[ self removeGuidBindingFor: aType] 		ifFalse:	[ self removeWeakBindingFor: aType  ]</body></methods><methods><class-id>External.DispComponentTypeSpec class</class-id> <category>private binding support</category><body package="Com- Automation">classBindings	^  ClassBindings</body><body package="Com- Automation">guidBind: aType to: aClass		^self classBindings		at: (self guidKeyFor: aType)		put: aClass fullyQualifiedReference</body><body package="Com- Automation">guidBindingFor: aType ifAbsent: aBlock		^self classBindings		at: (self guidKeyFor: aType)		ifAbsent: aBlock</body><body package="Com- Automation">guidKeyFor: aType		^aType guid asString asSymbol</body><body package="Com- Automation">removeGuidBindingFor: aType		self classBindings		removeKey: (self guidKeyFor: aType)		ifAbsent: []</body><body package="Com- Automation">removeWeakBindingFor: aType		self classBindings		removeKey: (self weakKeyFor: aType)		ifAbsent: []</body><body package="Com- Automation">weakBind: aType to: aClass		^self classBindings		at: (self weakKeyFor: aType)		put: aClass fullName asQualifiedReference</body><body package="Com- Automation">weakBindingFor: aType ifAbsent: aBlock		^self classBindings		at: (self weakKeyFor: aType)		ifAbsent: aBlock</body><body package="Com- Automation">weakKeyFor: aType	^aType fullName asSymbol</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">constantNamed: aName ifAbsent: aBlock	^ self constants at: aName asSymbol ifAbsent: aBlock</body><body package="Com- Automation">constants	^ self elements</body><body package="Com- Automation">elementClass	^ ConstantDescription</body><body package="Com- Automation">elementNamed: aName	^self elements at: aName asSymbol ifAbsent: [nil]</body><body package="Com- Automation">kindname	^  (#TKindEnum &lt;&lt; #com &gt;&gt; 'Enumeration') asString</body><body package="Com- Automation">typecode	^ VT_I4</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>private</category><body package="Com- Automation">addElement: element into: coll	coll at: element name asSymbol put: element.</body><body package="Com- Automation">cElementValue: anElement	"retrieve the c value for an element"	^  anElement value</body><body package="Com- Automation">constantForValue: aValue ifNone: aBlock	"return the constant that is associated with the given value"	^self constants detect: [:constant | constant value = aValue] ifNone: aBlock</body><body package="Com- Automation">newCType	^ CEnumerationType new</body><body package="Com- Automation">newElementCollection	^ IdentityDictionary new</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">constantsWithValue: aValue 	| temps value |	temps := self constants asSortedCollection: [:a :b | a value &gt; b value].	value := aValue.	temps := temps select: [:each | 	(value bitAnd: each value) = each value ifTrue: [ value := value bitAnd: each value bitInvert. true ] ifFalse: [false]  ].	^ temps</body><body package="Com- Automation">convertToNumber: aValue	^ (self constants at: aValue ifAbsent: [ ^ aValue ]) value</body><body package="Com- Automation">marshalCollectionInParam: aCollection	^ aCollection inject: 0 into: [:sum :each | sum bitOr: (self marshalInArgument: each) ].</body><body package="Com- Automation">marshalInArgument: anArgument	^ anArgument marshalCOMEnumType: self</body><body package="Com- Automation">marshalSymbolInParam: aSymbol	| element |	element := (self elementNamed: aSymbol)				ifNil: 					[self error: #UnknownEnumConstant &lt;&lt; #com &gt;&gt; 'Unknown enumeration constant'].	^element value</body><body package="Com- Automation">unmarshalOutParam: aParam	(self constantForValue: aParam ifNone: [nil])		ifNotNil: [:element | ^element].	^ CombindedConstantDescription withConstants: (self constantsWithValue: aParam)</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>testing</category><body package="Com- Automation">isEnumType	^ true</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>testing variant</category><body package="Com- Automation">canVariantContainValue: anObject ofType: aType	^anObject isInteger or: [anObject isSymbol]</body><body package="Com- Automation">variantContainsValue: aVariant	"Enums are stored as integers. Is the integerValue non-zero"	^ (aVariant valueAt: #lVal) ~= 0</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: anObject	aValue isSymbol		ifTrue: 			[^(self constants at: aValue				ifAbsent: 					[self error: #InvalidConstantName &lt;&lt; #com &gt;&gt; 'Invalid constant name'])					value].	aValue class = ConstantDescription ifTrue: [^aValue value].	^aValue</body><body package="Com- Automation">unmarshalAutomationResult: aValue	^ self constantForValue: aValue ifNone: [ aValue ]</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>As yet unclassified</category><body package="Com- Automation">marshalInteger: anInteger	"The integer was passed directly. Do not check if it matches a constant since it might be a combination"		^ anInteger</body></methods><methods><class-id>External.DispEnumTypeSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds	^ Array with: TKIND_ENUM</body></methods><methods><class-id>External.DispEnumTypeSpec class</class-id> <category>marshaling</category><body package="Com- Automation">findConstant: aValue forClient: aValueAdaptor	| tokens |	tokens := (aValue tokensBasedOn: $.) collect: [:each | each asSymbol].	^tokens size = 2		ifTrue: [self findFullySpecifiedEnumConstant: tokens client: aValueAdaptor]		ifFalse: [(self findUnspecifiedEnumConstant: aValue client: aValueAdaptor) ifNil: [aValue]]</body><body package="Com- Automation">findFullySpecifiedEnumConstant: tokens client: aValueAdaptor	^aValueAdaptor client enumConstantNamed: tokens last		inTypeNamed: tokens first</body><body package="Com- Automation">findUnspecifiedEnumConstant: aName client: aValueAdaptor	^aValueAdaptor client enumConstantNamed: aName</body></methods><methods><class-id>External.DispEnumTypeSpec class</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: client	^aValue isSymbol		ifTrue: 			[(self findConstant: aValue forClient: client)				ifNil: 					[self error: (#Constant1sDoesNotExist &lt;&lt; #com &gt;&gt; 'constant ''&lt;1s&gt;'' does not exist' expandMacrosWith: aValue)]				ifNotNil: [:constant | constant value]]		ifFalse: [aValue class = ConstantDescription ifTrue: [aValue value] ifFalse: [aValue]]</body></methods><methods><class-id>External.DispRefTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">arrayElementType	^ self referentType arrayElementType</body><body package="Com- Automation">name	^ referentType name</body><body package="Com- Automation">referentType	^referentType</body><body package="Com- Automation">referentType: anObject	referentType := anObject</body></methods><methods><class-id>External.DispRefTypeSpec</class-id> <category>comparing</category><body package="Com- Automation">derivesFromType: aType 	^referentType ifNil: [false]		ifNotNil: [referentType derivesFromType: aType]</body></methods><methods><class-id>External.DispRefTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFromVariant: aVariant typeCode: aTypeCode	^ self new		referentType: (self baseClass fromVariant: aVariant typeCode: (aTypeCode bitAnd: self automationTypeCode bitInvert));		yourself</body><body package="Com- Automation">basicFromVariantTypeCode: aTypeCode	^ self new		referentType: (self baseClass fromVariantTypeCode: (aTypeCode bitAnd: self automationTypeCode bitInvert));		yourself</body></methods><methods><class-id>External.DispRefTypeSpec class</class-id> <category>private accessing</category><body package="Com- Automation">automationTypeCode	self subclassResponsibility</body></methods><methods><class-id>External.DispRefTypeSpec class</class-id> <category>literal array encoding</category><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(#referentType)</body></methods><methods><class-id>External.DispArrayTypeSpec</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	aStream nextPutAll: 'Array of '.	referentType printOn: aStream.</body></methods><methods><class-id>External.DispArrayTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">arrayElementType	^ self referentType</body><body package="Com- Automation">basicTypecode	^ VT_ARRAY</body><body package="Com- Automation">cType	^ COMExternalInterface current SAFEARRAY pointerType</body><body package="Com- Automation">name	^'Array'.</body><body package="Com- Automation">typecode	^ referentType typecode bitOr: self basicTypecode</body></methods><methods><class-id>External.DispArrayTypeSpec</class-id> <category>testing</category><body package="Com- Automation">isArray	^ true</body></methods><methods><class-id>External.DispArrayTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">convertToSTObject: aCOMObjectValue 	"convert the given COM Object value to a real ST object. "	^ aCOMObjectValue collect: [:each |			[ referentType convertToSTObject: each ] ensure: [ 				(each class = COMRecord) ifTrue: [ each enforceRelease ]]]	"Unmarshaling SafeArray causes the COMRecords to be created for 'SafeArrayGetElement'. These records must be released	 manually as to be seen above"</body><body package="Com- Automation">freeArgument: anArgument	^ (COM_SAFEARRAY onNew: anArgument) enforceRelease</body><body package="Com- Automation">isArrayOfInterfaceOrVariant	^ COMVariant isArrayOfInterfacesOrVariants: self typecode</body><body package="Com- Automation">marshal: aParam	^ COM_SAFEARRAY fromCollection: aParam type: self referentType.</body><body package="Com- Automation">marshalInArgument: anArgument	| safeArray |	safeArray := COM_SAFEARRAY fromCollection: anArgument type: self referentType .	^ [ safeArray asPointerParameter ] ensure: [ safeArray enforceInvalidation ]</body><body package="Com- Automation">releaseRecordElement: aVariant	"release the safearray"	| safearray |	safearray := aVariant realValue value.	"For some reason it causes problems to release the array elements which have been automatically created 	 by the COM API at first access. The currently only way to 'guess this situation is the occurence of an empty 	 array although this may cause memory loss in other situations - this is better than causing the heap to be 	 damaged"	safearray numElements &gt; 0 ifTrue: [		safearray enforceRelease ].</body><body package="Com- Automation">setRefPointer: aPointer in: aVariant	"We are about to create a variant of type VT_BYREF | VT_SAFEARRAY.	 using the given pointer. Create the VariantValue holding the "	| refVariant |	refVariant := COMVariantValue typeDescription: self pointerType pointer: aPointer.	aVariant refPointer: refVariant asPointerParameter.	refVariant enforceInvalidation.</body><body package="Com- Automation">unmarshalOutParam: aParam	^(COM_SAFEARRAY temporaryOn: aParam)		typeDescription: referentType;		asArray</body></methods><methods><class-id>External.DispArrayTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFrom: aTypeDesc typeInfo: anITypeInfo	^ self new		referentType:  (DispTypeSpec forTypeDesc: aTypeDesc arrayType typeDescription typeInfo: anITypeInfo);		yourself</body><body package="Com- Automation">basicFromVariantTypeCode: aTypeCode	^ (super basicFromVariantTypeCode: aTypeCode)		yourself</body></methods><methods><class-id>External.DispArrayTypeSpec class</class-id> <category>private accessing</category><body package="Com- Automation">automationTypeCode	^ VT_ARRAY</body></methods><methods><class-id>External.DispArrayTypeSpec class</class-id> <category>private</category><body package="Com- Automation">typeCodes	^ Array with: VT_ARRAY with: VT_SAFEARRAY</body></methods><methods><class-id>External.CArrayTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">basicTypecode	^ VT_CARRAY</body><body package="Com- Automation">bounds	^bounds</body><body package="Com- Automation">bounds: anObject	bounds := anObject</body><body package="Com- Automation">cType	^ referentType cType pointerType</body></methods><methods><class-id>External.CArrayTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">convertToSTObject: aCOMObjectValue 	"convert the given COM Object value to a real ST object."	^ aCOMObjectValue collect: [:each |			[referentType convertToSTObject: each] ensure: [ each enforceInvalidation] ]</body><body package="Com- Automation">releaseRecordElement: aVariant	"not tested - fixed size arrays should be part of the record. 	wont release them"	^ self</body><body package="Com- Automation">setRefPointer: aPointer in: aVariant	"We are about to create a reference variant to a fixed size array. This is analogous to the COMRecords, but there we don't need	 such an implemententation as we have the IRecordInfo:GetFieldNoCopy() method"	| refVariant safeArray safeArraybounds |	safeArraybounds := bounds collect: [:interval | interval size ].	safeArray := EMBEDDED_SAFEARRAY new: safeArraybounds  type: self referentType fixedSizeDataPointer: aPointer.	refVariant := COMVariantValue typeDescription: self pointerType pointer: safeArray asPointerParameter.	aVariant refPointer: refVariant asPointerParameter.	safeArray enforceInvalidation.</body></methods><methods><class-id>External.CArrayTypeSpec class</class-id> <category>private accessing</category><body package="Com- Automation">automationTypeCode	^ VT_CARRAY</body></methods><methods><class-id>External.CArrayTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFrom: aTypeDesc typeInfo: anITypeInfo	^ (super basicFrom: aTypeDesc typeInfo: anITypeInfo)			bounds: (self boundsFromArayDesc: aTypeDesc arrayType)</body><body package="Com- Automation">boundsFromArayDesc: anArrayDesc	^ anArrayDesc bounds</body></methods><methods><class-id>External.CArrayTypeSpec class</class-id> <category>private</category><body package="Com- Automation">typeCodes	^ Array with: VT_CARRAY</body></methods><methods><class-id>External.CArrayTypeSpec class</class-id> <category>literal array encoding</category><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(#bounds)</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>accessing-properties</category><body package="Com- Automation">clsid	" Answer the CLSID of the OLE object which supports the receiver's specifications. "	^self propertyAt: #clsid</body><body package="Com- Automation">clsid: aCLSID	" Specifiy the CLSID of the OLE object which supports the receiver's specifications. "	self propertyAt: #clsid put: aCLSID.</body><body package="Com- Automation">iid	" Answer the IID of the interface which defines the receiver's specifications. "	^self propertyAt: #iid</body><body package="Com- Automation">iid: anIID	" Specifiy the IID of the interface which defines the receiver's specifications. "	| currentIID |	( ( currentIID := self iid ) notNil 	and: [ anIID notNil	and: [ currentIID ~= anIID ] ] )		ifTrue: [			COMDevelopmentWarning raiseSignal: #ErrMixedIIDDispatchSpec &lt;&lt; #com &gt;&gt;				'Mixing specifications from different interfaces in a single dispatch specification table (IID mismatch detected).'.			^self ].	self propertyAt: #iid put: anIID.</body><body package="Com- Automation">lcid	" Answer the locale ID of the specification table. "	^self propertyAt: #lcid</body><body package="Com- Automation">lcid: anLCID	" Set the locale ID of the specification table. "	| currentLCID |	( ( currentLCID := self lcid ) notNil 	and: [ anLCID notNil	and: [ currentLCID ~= anLCID ] ] )		ifTrue: [			COMDevelopmentWarning raiseSignal:				#ErrMixedLcidDispatchSpec &lt;&lt; #com &gt;&gt; 'Mixing specifications from different locale ID''s in a single dispatch specification table (lcid mismatch detected).'.			^self ].	self propertyAt: #lcid put: anLCID.</body><body package="Com- Automation">name	" Answer the name of the specification table. "	^self propertyAt: #name</body><body package="Com- Automation">name: aString	" Set the name of the specification table. "	| currentName |	( ( currentName := self name ) notNil 	and: [ aString notNil	and: [ currentName ~= aString ] ] )		ifTrue: [			COMDevelopmentWarning raiseSignal:				#ErrMixedNameDispatchSpec &lt;&lt; #com &gt;&gt; 'Mixing specifications from different interfaces in a single dispatch specification table (name mismatch detected).'.			^self ].	self propertyAt: #name put: aString.</body><body package="Com- Automation">optionalProperties		" Answer a dictionary containing the names and values of any		optional (non-standard) attributes of the receiver. "	| optionalProperties standardPropertyNames |	optionalProperties := Dictionary new.	properties isNil		ifTrue: [ ^optionalProperties ].	standardPropertyNames := self standardPropertyNames.	properties keysAndValuesDo: [ :name :value |		( standardPropertyNames includes: name )			ifFalse: [ optionalProperties at: name put: value ] ].	^optionalProperties</body><body package="Com- Automation">propertyAt: propertyName         "Answer the value associated with &lt;propertyName&gt;        in the properties dictionary."    properties isNil ifTrue: [ ^nil ].    ^properties at: propertyName ifAbsent: [ nil ]</body><body package="Com- Automation">propertyAt: propertyName ifAbsent: aBlock        "Answer the value associated with &lt;propertyName&gt;        in the properties dictionary; if absent,         answer the result of evaluating &lt;aBlock&gt;."    properties isNil ifTrue: [ ^aBlock value ].    ^properties at: propertyName ifAbsent: aBlock</body><body package="Com- Automation">propertyAt: propertyName ifAbsentPut: aBlock        "Answer the value associated with &lt;propertyName&gt;        in the properties dictionary; if absent, evaluate		&lt;aBlock&gt;, put the evaluation result at &lt;propertyName&gt;, and        answer the result."    properties isNil 		ifTrue: [ properties := IdentityDictionary new ].    ^properties at: propertyName 		ifAbsent: [ properties at: propertyName put: aBlock value ]</body><body package="Com- Automation">propertyAt: propertyName put: aValue        "Set the value associated with &lt;propertyName&gt;        in the properties dictionary."    properties isNil 		ifTrue: [ properties := IdentityDictionary new ].    aValue isNil ifTrue: [ ^properties removeKey: propertyName ifAbsent: [ ] ].    ^properties at: propertyName put: aValue</body><body package="Com- Automation">standardPropertyNames		" Answer the names of the properties which are standard attributes		of a dispatch specification table and handled specially when generating 		a literal encoding. "	^#( #name #clsid #iid #lcid )</body><body package="Com- Automation">typeLib	^ self propertyAt: #TypeLibrary ifAbsent: [ nil ]</body><body package="Com- Automation">typeLib: aTypeLibDescriptor	self propertyAt: #TypeLibrary put: aTypeLibDescriptor.</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>private-accessing</category><body package="Com- Automation">properties        "Private - Answer the properties Dictionary."    ^properties</body><body package="Com- Automation">properties: aDictionary        "Private - Set the properties Dictionary."    properties := aDictionary.</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>literal representation</category><body package="Com- Automation">decodeSpecificationFromLiteral: aLiteralValue		" Decode the dispatch specification described by &lt;aLiteralValue&gt;		and add it to the receiver. "	self add: ( COMDispatchMemberSpecification decodeFromLiteralArray: aLiteralValue ).</body><body package="Com- Automation">decodeSpecificationsFromLiteralArray: anArray		" Decode the dispatch specifications described by the literals in &lt;anArray&gt;		and add them to the receiver. "	self decodeSpecificationsFromLiteralArray: anArray		startingAt: 1.</body><body package="Com- Automation">decodeSpecificationsFromLiteralArray: anArray startingAt: startIndex		" Decode the dispatch specifications described by the literals in &lt;anArray&gt;.		starting from &lt;startIndex&gt;, and add them to the receiver. "	startIndex to: anArray size do: [ :i |		self decodeSpecificationFromLiteral: ( anArray at: i ) ].</body><body package="Com- Automation">literalArrayEncoding	"Return a literal suitable for reconstituting the receiver."	"Specification tables partly behave like collections"	^self literalArrayEncodingForStockAttributes		, self literalArrayEncodingForElements</body><body package="Com- Automation">literalArrayEncodingForElements	^(self internalTableValues sorted: #name ascending) asArray		literalArrayEncoding</body><body package="Com- Automation">literalArrayEncodingForStockAttributes	^LiteralArrayEncoder encode: self</body><body package="Com- Automation">literallyEncodedAttributes		^ #(#specificationKey: #name: #clsid: #iid: #lcid: #typeLib:)</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>private-construction</category><body package="Com- Automation">addSuperclassSpecificationsFor: anITypeInfo	| subSpecTable guid |	anITypeInfo referencedTypesAndFlagsDo: 			[:iTypeInfo :flags |			((flags bitAnd: IMPLTYPEFLAG_FRESTRICTED) = IMPLTYPEFLAG_FRESTRICTED				or: [(guid := iTypeInfo guid) = IID_IDispatch or: [guid = IID_IUnknown]])					ifFalse: 						[subSpecTable := self class basicConstructSpecificationTable: iTypeInfo									specificationKey: self specificationKey.						self addAll: subSpecTable values.						self addSuperclassSpecificationsFor: iTypeInfo]]</body><body package="Com- Automation">addTypeLibraryInformationFor: anITypeInfo	| typeLib |	typeLib := anITypeInfo getContainingTypeLib.	self typeLib: (TypeLibDescriptor fromITypeLib: typeLib)</body><body package="Com- Automation">formatKey: aKey	^self specificationKey = #name		ifTrue: [aKey asLowercase asSymbol]		ifFalse: [aKey]</body><body package="Com- Automation">getTypeInfoName: anITypeInfo		" Private - answer the name in &lt;anITypeInfo&gt;. "	^[ anITypeInfo getDocumentationName ]		on: COMError		do: [ :ex | ^nil ].</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>accessing-specifications</category><body package="Com- Automation">add: aSpecification	" Add &lt;aSpecification&gt; to the dispatch specification table. "	^self at: (aSpecification perform: self specificationKey)		put: aSpecification</body><body package="Com- Automation">addAll: aCollection		" Add the specifications in &lt;aCollection&gt; to the dispatch specification table. "	aCollection do: [ :aSpecification | self add: aSpecification ].</body><body package="Com- Automation">at: key	" Answer the specification whose key equals &lt;key&gt;.        If not found, report an error. "	^self at: key		ifAbsent: 			[(KeyNotFoundError receiver: self selector: #at: index: key) raiseRequest]</body><body package="Com- Automation">at: key ifAbsent: exceptionBlock	" Answer the specification whose key equals &lt;key&gt;.        If not found,  answer the result of evaluating &lt;exceptionBlock&gt;."	^self		at: key		types: nil		ifAbsent: exceptionBlock</body><body package="Com- Automation">at: key put: aSpecification	" Add &lt;aSpecification&gt; to the dispatch specification table under &lt;key&gt;. "	| formattedKey |	formattedKey := self formatKey: key.	self privateAt: formattedKey put: aSpecification.	^aSpecification</body><body package="Com- Automation">at: key types: types ifAbsent: exceptionBlock	" Answer the specification whose key equals &lt;key&gt;.        If not found,  answer the result of evaluating &lt;exceptionBlock&gt;."	^ self privateAt: (self formatKey: key) types: types ifAbsent: exceptionBlock.</body><body package="Com- Automation">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone: [ self notFoundError]</body><body package="Com- Automation">detect: aBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock types: nil ifNone: exceptionBlock</body><body package="Com- Automation">detect: aBlock types: aType ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	(self internalTablesForTypes: aType)		do: [:table | table do: [:each | (aBlock value: each) ifTrue: [^each]]].	^exceptionBlock value</body><body package="Com- Automation">do: aBlock	"Answer the receiver.  For each specification         in the receiver, evaluate &lt;aBlock&gt; with         that specification as the argument."	self internalTables do: [:table | table do: aBlock]</body><body package="Com- Automation">getSpecificationOfType: types where: anAttribute isEqualTo: aKey ifAbsent: aBlock	^self specificationKey = anAttribute		ifTrue: [self at: aKey types: types ifAbsent: aBlock]		ifFalse: 			[self detect: [:each | (each perform: anAttribute) = aKey] ifNone: aBlock]</body><body package="Com- Automation">interface	^DispatchInterfaceTypeSpec name: self name iid: self iid</body><body package="Com- Automation">keys	"Answer a Set containing all of the keys in the receiver.	 We do not know if the tables are (Identity)Dictionaries. Let them decide whether to return an IdentitySet or a Set"	^self internalTables inject: self createInternalTable keys		into: 			[:all :table |			all				addAll: table keys;				yourself]</body><body package="Com- Automation">keysAndValuesDo: aBlock	self internalTables do: [:each | each keysAndValuesDo: aBlock]</body><body package="Com- Automation">removeKey: aKey        "Answer the receiver with the key/value pair whose         key equals &lt;aKey&gt; removed.  If such a pair is not found,         report an error."    ^ self removeKey: aKey ifAbsent: [ self notFoundError]</body><body package="Com- Automation">removeKey: aKey ifAbsent: exceptionBlock	"Answer the receiver with the key/value pair whose         key equals &lt;aKey&gt; removed.  If such a pair is not found,         answer the result of evaluating the &lt;exceptionBlock&gt;. "	^self removeKey: aKey types: nil ifAbsent: exceptionBlock</body><body package="Com- Automation">removeKey: aKey types: types ifAbsent: exceptionBlock	"Answer the receiver with the key/value pair whose         key equals &lt;aKey&gt; removed.  If such a pair is not found,         answer the result of evaluating the &lt;exceptionBlock&gt;. "	| tablesWithKey |	tablesWithKey := (self internalTablesForTypes: types)				select: [:each | each includesKey: aKey].	tablesWithKey do: [:each | each removeKey: aKey].	tablesWithKey isEmpty ifTrue: [exceptionBlock value]</body><body package="Com- Automation">size	" Answer the number of specifications in the receiver. "	^self internalTables inject: 0 into: [:sum :each | sum + each size]</body><body package="Com- Automation">specificationKey		" Answer the attribute used to look up specifications in the dispatch table. "	^specificationKey</body><body package="Com- Automation">specificationKey: aSymbol		" Specify the attribute used to look up specifications in the dispatch table. "	specificationKey := aSymbol.	self initializeInternalTables.</body><body package="Com- Automation">specificationTable	" Answer the table of dispatch specifications. "	| result |	self deprecated: #(#version '8.2' #sunset '8.3').	result := self createInternalTable.	self internalTables do: [:each | result addAll: each associations].	^result</body><body package="Com- Automation">specificationTable: aDictionary	" Specify the table of dispatch specifications. "	self deprecated: #(#version '8.2' #sunset '8.3').	self initializeInternalTables.	self addAll: aDictionary.</body><body package="Com- Automation">values	"Answer a Bag containing all the values of the         key/value pairs in the receiver."	^self internalTables inject: self createInternalTable values		into: 			[:all :table |			all				addAll: table values;				yourself]</body><body package="Com- Automation">withSpecificationKey: aSymbol	" Return a DispatchSpecificationTable with the given attribute used to look up specifications. "	^specificationKey = aSymbol		ifTrue: [self]		ifFalse: 			[self class				newSecifications: self values				specificationKey: aSymbol				properties: properties]</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>copying</category><body package="Com- Automation">copyEmpty	" Answer an empty copy of the receiver s.t. the properties are copied but the specification table is empty. "	| aCopy |	aCopy := self class new.	aCopy specificationKey: self specificationKey.	properties notNil		ifTrue: [ aCopy copyPropertiesFrom: self ].	^aCopy</body><body package="Com- Automation">copyPropertiesFrom: aSpecificationTable 	" Copy the properties attached to &lt;aSpecificationTable&gt; to the receiver. "	aSpecificationTable properties 		keysAndValuesDo: [:name :value | self propertyAt: name put: value]</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>specification construction</category><body package="Com- Automation">addEventSpecifications: anITypeInfo		" Add the event specifications defined by &lt;anITypeInfo&gt; to the receiver's specification table. "	| aTypeAttr |	aTypeAttr := anITypeInfo getTypeAttr.	aTypeAttr isNil		ifTrue: [ ^self ].	[	self addEventSpecifications: anITypeInfo typeAttr: aTypeAttr.	] ensure: [		aTypeAttr enforceRelease ].</body><body package="Com- Automation">addEventSpecifications: anITypeInfo typeAttr: aTypeAttr	" Add the event specifications defined by &lt;anITypeInfo&gt; to the receiver's specification table. "	| nFunctions aFuncDesc aDispatchSpecification |	self iid: aTypeAttr guid.	" IID of this connection point interface "	self name: (self getTypeInfoName: anITypeInfo).	" descriptive name "	self lcid: aTypeAttr lcid.	nFunctions := aTypeAttr functionCount.	1 to: nFunctions		do: 			[:index |			aFuncDesc := anITypeInfo getFuncDesc: index - 1.			aFuncDesc == nil				ifTrue: 					[" should not be... "					COMDevelopmentWarning						raiseSignal: (#ErrNamedNoEventSpec &lt;&lt; #com								&gt;&gt; 'Problem constructing event specifications (no FUNCDESC for index &lt;1p&gt;)'									expandMacrosWith: index)]				ifFalse: 					[aDispatchSpecification := COMDispatchEventSpecification forDescription: aFuncDesc								typeInfo: anITypeInfo.					self add: aDispatchSpecification]]</body><body package="Com- Automation">addMethodSpecifications: anITypeInfo	" Add the method specifications defined by &lt;anITypeInfo&gt; to the receiver's specification table. "	anITypeInfo withTypeAttrDo: 			[:aTypeAttr |			[self addMethodSpecifications: anITypeInfo typeAttr: aTypeAttr]				on: COMError				do: [:ex | ex return]]</body><body package="Com- Automation">addMethodSpecifications: anITypeInfo typeAttr: aTypeAttr	" Add the method specifications defined by &lt;anITypeInfo&gt; to the receiver's specification table. "	| nFunctions aFuncDesc aDispatchSpecification |	self iid: aTypeAttr guid.	" IID of the dispatch interface "	self name: (self getTypeInfoName: anITypeInfo).	" descriptive name "	self lcid: aTypeAttr lcid.	nFunctions := aTypeAttr functionCount.	1 to: nFunctions		do: 			[:index |			aFuncDesc := anITypeInfo getFuncDesc: index - 1.						[((self shouldAddSpecification: aFuncDesc) and: [aFuncDesc isDispatch])				ifTrue: 					[aDispatchSpecification := self defaultMethodSpecificationClass								forDescription: aFuncDesc								typeInfo: anITypeInfo.					self add: aDispatchSpecification]]					ensure: [aFuncDesc enforceRelease]]</body><body package="Com- Automation">addPropertySpecificationForFuncDesc: aFuncDesc typeInfo: anITypeInfo	aFuncDesc isPropertySpecification ifFalse: [^self].	(self shouldAddSpecification: aFuncDesc) ifFalse: [^self].	self createOrUpdatePropertySpecForFuncDesc: aFuncDesc typeInfo: anITypeInfo</body><body package="Com- Automation">addPropertySpecifications: anITypeInfo	" Add the property specifications defined by &lt;anITypeInfo&gt; to the receiver's specification table. "	| aTypeAttr |	aTypeAttr := anITypeInfo getTypeAttr.		[[self addPropertySpecifications: anITypeInfo typeAttr: aTypeAttr]		on: COMError		do: [:ex | ex return]]			ensure: [aTypeAttr enforceRelease]</body><body package="Com- Automation">addPropertySpecifications: anITypeInfo typeAttr: aTypeAttr	" Add the property specifications defined by &lt;anITypeInfo&gt; to the receiver's specification table. "	| nVariables nFunctions aDispatchSpecification aVarDesc aFuncDesc |	self iid: aTypeAttr guid.	" IID of the dispatch interface "	self name: (self getTypeInfoName: anITypeInfo).	" descriptive name "	self lcid: aTypeAttr lcid.	nVariables := aTypeAttr variableCount.	nFunctions := aTypeAttr functionCount.	" construct the simple get/set property specifications "	1 to: nVariables		do: 			[:index |			aVarDesc := anITypeInfo getVarDesc: index - 1.			aVarDesc isDispatch				ifTrue: 					[aDispatchSpecification := COMDispatchPropertySpecification								forDescription: aVarDesc								typeInfo: anITypeInfo.					self add: aDispatchSpecification].			aVarDesc enforceRelease].	" construct the property specifications for parameterized get/set functions "	1 to: nFunctions		do: 			[:index |			aFuncDesc := anITypeInfo getFuncDesc: index - 1.			self addPropertySpecificationForFuncDesc: aFuncDesc						typeInfo: anITypeInfo.			aFuncDesc enforceRelease]</body><body package="Com- Automation">createOrUpdatePropertySpecForFuncDesc: aFuncDesc typeInfo: anITypeInfo	| aDispatchSpecification keyValue |	keyValue := self keyValueForDescription: aFuncDesc.	aDispatchSpecification := self				at: keyValue				types: (Array with: COMAbstractMemberSpecification propertyKindName)				ifAbsent: [nil].	aDispatchSpecification		ifNil: 			[aDispatchSpecification := self newPropertySpecificationFor: aFuncDesc						typeInfo: anITypeInfo.			aDispatchSpecification isVTable: anITypeInfo isInterface.			self add: aDispatchSpecification.			"The newly created specification already contains the access specifiction. It is not required to add it again"			^aDispatchSpecification].	aDispatchSpecification mergeOperationDescription: aFuncDesc		typeInfo: anITypeInfo</body><body package="Com- Automation">installArgumentKeyword: argumentKeyword	" Install &lt;argumentKeyword&gt; as the anonymous keyword for argument values in the receiver's selector(s). "	self do: [ :aDispatchSpec |		aDispatchSpec installArgumentKeyword: argumentKeyword ].</body><body package="Com- Automation">keyValueForDescription: aFuncDesc	specificationKey = #memberID ifTrue: [^aFuncDesc memberID].	specificationKey = #name ifTrue: [^aFuncDesc getName asSymbol].	COMError raiseSignal: #ErrKeyNotSupported &lt;&lt; #com				&gt;&gt; 'key not supported for property construction'</body><body package="Com- Automation">newPropertySpecificationFor: aFuncDesc typeInfo: anITypeInfo	^(aFuncDesc parameterCount = 0		ifTrue: [COMDispatchPropertySpecification]		ifFalse: [self defaultParameterizedPropertySpecificationClass])			forDescription: aFuncDesc			typeInfo: anITypeInfo</body><body package="Com- Automation">shouldAddSpecification: aFuncDesc	^aFuncDesc isRestricted not</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>constants</category><body package="Com- Automation">defaultMethodSpecificationClass	^ COMDispatchMethodSpecification</body><body package="Com- Automation">defaultParameterizedPropertySpecificationClass	^ COMDispatchParameterizedPropertySpecification</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>testing</category><body package="Com- Automation">includesKey: key	"Answer true if the receiver contains &lt;key&gt;,         else answer false."	| formattedKey |	formattedKey := self formatKey: key.	self internalTables do: [:each | (each includesKey: formattedKey) ifTrue: [^true]].	^false</body><body package="Com- Automation">isEmpty	" Answer whether the receiver contains no specifications. "	self internalTables do: [:each | each notEmpty ifTrue: [^false]].	^true</body><body package="Com- Automation">isQualifiedByMemberID	^ self specificationKey == #memberID</body><body package="Com- Automation">isQualifiedByName	^ self specificationKey == #name</body><body package="Com- Automation">notEmpty	" Answer whether the receiver contains any specifications. "	^self isEmpty not</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>configuring</category><body package="Com- Automation">applySpecificationOn: aDispatchDriver	aDispatchDriver specificationTable: self.</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>private</category><body package="Com- Automation">checkForKeyCollision: key specification: aSpecification inTable: table	" Private - check for collisions. Return the member that shall be put into the table "	| existing |	existing := table at: key ifAbsent: [^aSpecification].	existing = aSpecification ifTrue: [^aSpecification].	(existing isEqualTo: aSpecification)		ifTrue: [^self selectBetterFromEquivalents: (Array with: existing with: aSpecification)].	COMDevelopmentWarning displayWarningMessages		ifTrue: 			[COMDevelopmentWarning				raiseSignal: (#ErrNamedSpecTableColsn &lt;&lt; #com						&gt;&gt; 'Specification table element collision for key &lt;1s&gt; (existing &lt;2s&gt; is being replaced by a &lt;3s&gt;).'							expandMacrosWith: key storeString							with: existing literalEncodingType							with: aSpecification literalEncodingType)].	"Continue with one of the after showing a warning"	^aSpecification</body><body package="Com- Automation">internalTableFor: aSpecification ifNone: aBlock	aSpecification isMethodSpecification ifTrue: [^methodSpecifications].	aSpecification isPropertySpecification ifTrue: [^propertySpecifications].	aSpecification isEventSpecification ifTrue: [^eventSpecifications].	^ aBlock value</body><body package="Com- Automation">internalTableValues	^self internalTables inject: nil		into: [:all :each | all ifNil: [each values] ifNotNil: [all addAll: each values. all]]</body><body package="Com- Automation">internalTables	^ Array with: methodSpecifications with: propertySpecifications with: eventSpecifications</body><body package="Com- Automation">internalTablesForType: aSymbol	aSymbol isNil ifTrue: [^ self internalTables].	aSymbol = COMAbstractMemberSpecification propertyKindName ifTrue: [ ^ (Array with: propertySpecifications)].	aSymbol = COMAbstractMemberSpecification methodKindName ifTrue: [ ^ (Array with: methodSpecifications)].	aSymbol = COMAbstractMemberSpecification eventKindName ifTrue: [^ (Array with: eventSpecifications)].	self error: #UnknownMemberType &lt;&lt; #com &gt;&gt; 'Unknown member type'</body><body package="Com- Automation">internalTablesForTypes: types	types isNil ifTrue: [^self internalTablesForType: nil].	^types inject: OrderedCollection new		into: 			[:all :each |			all				addAll: (self internalTablesForType: each);				yourself]</body><body package="Com- Automation">notFoundError	"Raise a signal indicating that an object is not in the collection."	^self class notFoundSignal raise</body><body package="Com- Automation">privateAt: key ifAbsent: exceptionBlock	" Answer the specification whose key equals &lt;key&gt;.        If not found,  answer the result of evaluating &lt;exceptionBlock&gt;."	^ self privateAt: key types: nil ifAbsent: exceptionBlock</body><body package="Com- Automation">privateAt: formattedKey put: aSpecification	| table newSpecification |	table := self internalTableFor: aSpecification ifNone: [nil].	newSpecification := self		checkForKeyCollision: formattedKey		specification: aSpecification		inTable: table.	table at: formattedKey put: newSpecification</body><body package="Com- Automation">privateAt: key types: types ifAbsent: exceptionBlock	" Answer the specification whose key equals &lt;key&gt;.        If not found,  answer the result of evaluating &lt;exceptionBlock&gt;."	(self internalTablesForTypes: types)		do: [:table | table at: key ifPresent: [:value | ^value]].	^exceptionBlock value</body><body package="Com- Automation">selectBetterFromEquivalents: members	"We have two equivalen specifications, probably a Vtable and an Automation member.	 Select the Automation member as it is safer"	^members detect: [:each | each isVTable not] ifNone: [members any]</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	"Append to the argument aStream a sequence of characters	that describes the receiver."	super printOn: aStream.	aStream		nextPutAll: ' (indexed by ';		nextPutAll: self specificationKey printString;		nextPutAll: ', ';		nextPutAll: self size printString;		nextPutAll: ' entries)'</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>initialize-release</category><body package="Com- Automation">createInternalTable	^specificationKey == #name		ifTrue: [IdentityDictionary new]		ifFalse: [Dictionary new]</body><body package="Com- Automation">initializeInternalTables	"Initialize my internal specification table. If the specification key is name, the keys will be symbols.	 In this case I can use an IdentityDictionary. Otherwise use a Dictionary since memberIDs may exceed	 SmallInteger range and may not be findable any more."	propertySpecifications := self createInternalTable.	methodSpecifications := self createInternalTable.	eventSpecifications := self createInternalTable.</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>accessing</category><body package="Com- Automation">allSpecifications	| result |	result := OrderedCollection new.	self internalTables do: [:table | result addAll: table associations].	^result</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>comparing</category><body package="Com- Automation">= anObject	anObject class = self class ifFalse: [^ false ].	self properties = anObject properties ifFalse: [ ^ false].	self specificationKey = anObject specificationKey ifFalse: [^false ].	^ self internalTables = anObject internalTables</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>enumerating</category><body package="Com- Automation">reject: aBlock	| newSpecs |	newSpecs := self createInternalTable.	self internalTables do: [:table | newSpecs addAll: (table reject: aBlock)].	^self class		newSecifications: newSpecs		specificationKey: self specificationKey		properties: self properties copy</body><body package="Com- Automation">select: aBlock	| newSpecs |	newSpecs := self createInternalTable.	self internalTables do: [:table | newSpecs addAll: (table select: aBlock)].	^self class		newSecifications: newSpecs		specificationKey: self specificationKey		properties: self properties copy</body></methods><methods><class-id>External.COMDispatchSpecificationTable class</class-id> <category>instance creation</category><body package="Com- Automation">constructEventSinkSpecificationTable: anITypeInfo	" Answer a new instance of the receiver containing the event specifications defined by &lt;anITypeInfo&gt; and the IID of this connection point interface.  The specification table is indexed by the DISPID of the event. "	^self constructEventSpecificationTable: anITypeInfo 		specificationKey: #memberID</body><body package="Com- Automation">constructEventSpecificationTable: anITypeInfo specificationKey: aSymbol	" Answer a new instance of the receiver containing the event specifications defined by &lt;anITypeInfo&gt; and the IID of this connection point interface.  The specification table is indexed by the attribute &lt;aSymbol&gt; of the specifications. "	^self new		specificationKey: aSymbol;		addEventSpecifications: anITypeInfo;		yourself</body><body package="Com- Automation">constructIncomingMethodSpecificationTable: anITypeInfo	" Answer a new instance of the receiver containing the method specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the DISPID of the method. "	^self constructMethodSpecificationTable: anITypeInfo 		specificationKey: #memberID</body><body package="Com- Automation">constructIncomingPropertySpecificationTable: anITypeInfo	" Answer a new instance of the receiver containing the property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the DISPID of the property. "	^self constructPropertySpecificationTable: anITypeInfo 		specificationKey: #memberID</body><body package="Com- Automation">constructIncomingSpecificationTable: anITypeInfo	" Answer a new instance of the receiver containing the method and property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the DISPID of the members. "	^self constructSpecificationTable: anITypeInfo 		specificationKey: #memberID</body><body package="Com- Automation">constructMethodSpecificationTable: anITypeInfo	" Answer a new instance of the receiver containing the method specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the message selector of the method. "	^self constructMethodSpecificationTable: anITypeInfo 		specificationKey: #selector</body><body package="Com- Automation">constructMethodSpecificationTable: anITypeInfo specificationKey: aSymbol	" Answer a new instance of the receiver containing the method specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the attribute &lt;aSymbol&gt; of the specifications. "	^self new		specificationKey: aSymbol;		addMethodSpecifications: anITypeInfo;		yourself</body><body package="Com- Automation">constructPropertySpecificationTable: anITypeInfo	" Answer a new instance of the receiver containing the property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the name of the property. "	^self constructPropertySpecificationTable: anITypeInfo 		specificationKey: #name</body><body package="Com- Automation">constructPropertySpecificationTable: anITypeInfo specificationKey: aSymbol	" Answer a new instance of the receiver containing the property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the attribute &lt;aSymbol&gt; of the specifications. "	^self new		specificationKey: aSymbol;		addPropertySpecifications: anITypeInfo;		yourself</body><body package="Com- Automation">constructSpecificationTable: anITypeInfo	" Answer a new instance of the receiver containing the method and property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the name of the member. "	^self constructSpecificationTable: anITypeInfo 		specificationKey: #name</body><body package="Com- Automation">constructSpecificationTable: anITypeInfo specificationKey: aSymbol	" Answer a new instance of the receiver containing the method and property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the attribute &lt;aSymbol&gt; of the specifications. "	| specTable |	anITypeInfo		ifNil: 			[^(self new)				specificationKey: aSymbol;				yourself].	specTable := self basicConstructSpecificationTable: anITypeInfo				specificationKey: aSymbol.	specTable addSuperclassSpecificationsFor: anITypeInfo.	^specTable</body><body package="Com- Automation">decodeFromLiteralArray: anArray		" Answer a new instance of the receiver containing the dispatch specifications in the literal representation &lt;anArray&gt;. "	| aDispatchSpecificationTable index element |	aDispatchSpecificationTable := self new.	index := 2.	" restore any stock properties, notably the key "	[ index &lt; anArray size and: [ ( element := anArray at: index ) isSymbol ] ]		whileTrue: [			aDispatchSpecificationTable perform: element				with: ( anArray at: index + 1 ) decodeAsLiteralArray.			index := index + 2.			].	aDispatchSpecificationTable decodeSpecificationsFromLiteralArray: anArray		startingAt: index.	^aDispatchSpecificationTable</body><body package="Com- Automation">new	" Answer a new instance of the receiver. "	^super new initialize</body><body package="Com- Automation">newNamedTable	" Answer a new instance of the receiver which will index its specifications by name. "    ^self new        specificationKey: #name;        yourself</body><body package="Com- Automation">newSecifications: specifications specificationKey: aSymbol properties: properties	"Answer a new instance with the given specifications and specification key"		^(self new)		specificationKey: aSymbol;		addAll: specifications;		properties: properties;		yourself</body></methods><methods><class-id>External.COMDispatchSpecificationTable class</class-id> <category>caching</category><body package="Com- Automation">basicClearSpecificationTables	cachedSpecificationTables := nil.	self changed: #clearCache.</body><body package="Com- Automation">cachedSpecificationTables	^ cachedSpecificationTables ifNil: [ cachedSpecificationTables  := CachingWeakRegistry new ]</body><body package="Com- Automation">clearSpecificationTables	"self clearSpecificationTables"	self withAllSubclasses do: [:each | each basicClearSpecificationTables ].</body><body package="Com- Automation">forInterface: anInterface	^self specificationTableForGuid: anInterface iid		ifAbsentPut: 			[anInterface getTypeInfo				ifNotNil: 					[:typeInfo |					[self constructSpecificationTable: typeInfo] ensure: [typeInfo enforceRelease]]]</body><body package="Com- Automation">specificationTableFor: typeInfo	^typeInfo		ifNil: [self newNamedTable]		ifNotNil: 			[self specificationTableForGuid: typeInfo guid				ifAbsentPut: 					[self constructSpecificationTable: typeInfo]]</body><body package="Com- Automation">specificationTableFor: typeInfo specificationKey: aKey	^(self specificationTableFor: typeInfo) withSpecificationKey: aKey</body><body package="Com- Automation">specificationTableForGuid: aGuid ifAbsentPut: aBlock	^ self cachedSpecificationTables at: aGuid ifAbsentPut: aBlock</body></methods><methods><class-id>External.COMDispatchSpecificationTable class</class-id> <category>session management</category><body package="Com- Automation">pause	self clearSpecificationTables.</body><body package="Com- Automation">setUp	self clearSpecificationTables.</body></methods><methods><class-id>External.COMDispatchSpecificationTable class</class-id> <category>utilities</category><body package="Com- Automation">getClassTypeInfoOf: anInterface	" Answer the ITypeInfo describing the class 		of the object supporting &lt;anInterface&gt;. 		Answer nil if type information is not available. "	| anIProvideClassInfo |	anIProvideClassInfo := [anInterface queryInterface: IID_IProvideClassInfo] on: COMError				do: 					[:ex |					ex hresult = REGDB_E_IIDNOTREG ifTrue: [^nil].	" event support not installed "					ex pass].	anIProvideClassInfo isNil ifTrue: [^nil].	^ anIProvideClassInfo getClassInfo</body><body package="Com- Automation">getEventTypeInfoFromClassTypeInfo: typeInfoControlClass		" Answer the ITypeInfo describing the primary event interface		of the object whose class is described by &lt;typeInfoControlClass&gt;. 		Answer nil if there is no event interface supported. "	| typeAttrControlClass typeCount index implTypeFlags refType 	  typeInfoEvents |	typeAttrControlClass := typeInfoControlClass getTypeAttr.	typeAttrControlClass == nil		ifTrue: [ ^nil ].	" this shouldn't be necessary if the ITypeInfo came from IProvideClassInfo,		but it's safe to double-check "	( typeAttrControlClass typekind ~= TKIND_COCLASS )		ifTrue: [ 			typeAttrControlClass enforceRelease.			^nil ].		[	typeCount := typeAttrControlClass typeCount.	index := 0.	[ index &lt; typeCount ] 		whileTrue: [   " enumerate the control's types to find the primary event set "			implTypeFlags := typeInfoControlClass getImplTypeFlags: index.			( ( implTypeFlags bitAnd: IMPLTYPEFLAG_FSOURCE ) = IMPLTYPEFLAG_FSOURCE			and: [ ( refType := typeInfoControlClass getRefTypeOfImplType: index ) ~~ nil ] )				ifTrue: [					( implTypeFlags bitAnd: IMPLTYPEFLAG_FDEFAULT ) = IMPLTYPEFLAG_FDEFAULT						ifTrue: [  " explicitly identified default event set "							typeInfoEvents notNil								ifTrue: [ typeInfoEvents enforceRelease ].							typeInfoEvents := typeInfoControlClass getRefTypeInfo: refType.							typeAttrControlClass enforceRelease.							^typeInfoEvents ].					" by default, the first outgoing interface is assumed to be the primary event set "					typeInfoEvents isNil						ifTrue: [ typeInfoEvents := typeInfoControlClass getRefTypeInfo: refType ].					].			index := index + 1 ] 	]	ensure: [		typeAttrControlClass enforceRelease ].	^typeInfoEvents</body><body package="Com- Automation">getEventTypeInfoOf: anInterface	" Answer the ITypeInfo describing the primary event interface		of the object supporting &lt;anInterface&gt;. 		Answer nil if the object does not support events. "	| typeInfoControlClass |	anInterface ifNil: [^nil].	typeInfoControlClass := self getClassTypeInfoOf: anInterface.	typeInfoControlClass isNil ifTrue: [^nil].	^self getEventTypeInfoFromClassTypeInfo: typeInfoControlClass</body></methods><methods><class-id>External.COMDispatchSpecificationTable class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	(COMSystem current)		when: #setUp send: #setUp to: self;		when: #confirmSave send: #pause to: self</body></methods><methods><class-id>External.COMDispatchSpecificationTable class</class-id> <category>initialize-release</category><body package="Com- Automation">obsolete	COMSystem current removeAllActionsWithReceiver: self.	^ super obsolete.</body></methods><methods><class-id>External.COMDispatchSpecificationTable class</class-id> <category>private</category><body package="Com- Automation">basicConstructSpecificationTable: anITypeInfo specificationKey: aSymbol	" Answer a new instance of the receiver containing the method and property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the attribute &lt;aSymbol&gt; of the specifications. "	^(self new)		addTypeLibraryInformationFor: anITypeInfo;		specificationKey: aSymbol;		addMethodSpecifications: anITypeInfo;		addPropertySpecifications: anITypeInfo;		yourself</body></methods><methods><class-id>External.COMLookupSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">allowsSpecificationTableUpdates	"Answer whether it makes sense for the receiver to update the specification table ."    ^self subclassResponsibility</body><body package="Com- Automation">canSupportIDispatch: anIDispatch forLocaleID: aLocaleID	"Answer whether or not the receiver configured as it is can support performing it's	lookups an &lt;anIDispatch&gt; for the given LCID &lt;aLocaleID&gt;."	^self subclassResponsibility</body><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^self subclassResponsibility</body></methods><methods><class-id>External.COMLookupSpecificationPolicy</class-id> <category>converting</category><body package="Com- Automation">fromLiteralArrayEncoding: anArray 	"Initialize the receiver with the information in the literal array (see literalArrayEncoding)."	2 to: anArray size by: 2 do:		[:i | self perform: (anArray at: i) with: (anArray at: i + 1)].</body><body package="Com- Automation">literalArrayEncoding	"Return a literal suitable for reconstituting the receiver."	| a |	a := Array new: 1.	a at: 1 put: self class name.	^a</body></methods><methods><class-id>External.COMLookupSpecificationPolicy</class-id> <category>description</category><body package="Com- Automation">description	"Answer a description for the recevier."	^self subclassResponsibility</body></methods><methods><class-id>External.COMLookupSpecificationPolicy</class-id> <category>private lookup-method</category><body package="Com- Automation">initialSpecificationTableFor: aDispatchDriver	^ COMDispatchSpecificationTable newNamedTable</body><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    for: anOLEDispatchDriver    "Lookup and answer a new method specification for &lt;aName&gt;. The    parameters &lt;argValuesArray&gt; and &lt;anOLEDispatchDriver&gt; may be used    by certain policy subclasses towards this purpose.    Answer nil if &lt;aName&gt; does not exist."    ^self subclassResponsibility</body><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    withNamedArguments: argValuesDictionary    for: anOLEDispatchDriver    "Lookup and answer a new method specification for &lt;aName&gt;. The    parameters &lt;argValuesArray&gt;, &lt;argValuesDictionary&gt; and &lt;anOLEDispatchDriver&gt; may be used    by certain policy subclasses towards this purpose.    Answer nil if &lt;aName&gt; does not exist."    ^self subclassResponsibility</body></methods><methods><class-id>External.COMLookupSpecificationPolicy</class-id> <category>private lookup-property</category><body package="Com- Automation">propertySpecification: aName    withGetArguments: argValuesArray    for: anOLEDispatchDriver    "Lookup and answer a new property specification for &lt;aName&gt;. The    parameters &lt;argValuesArray&gt; and &lt;anOLEDispatchDriver&gt; may be used    by certain policy subclasses towards this purpose.    Answer nil if &lt;aName&gt; does not exist."    ^self subclassResponsibility</body></methods><methods><class-id>External.COMLookupSpecificationPolicy</class-id> <category>lookup</category><body package="Com- Automation">specificationFor: aSpecificationQuery kind: aKind on: aDispatchDriver	aKind = COMAbstractMemberSpecification methodKindName		ifTrue: 			[^self				methodSpecification: aSpecificationQuery member				withArguments: aSpecificationQuery arguments				withNamedArguments: aSpecificationQuery namedArguments				for: aDispatchDriver].	aKind = COMAbstractMemberSpecification propertyKindName		ifTrue: 			[^self				propertySpecification: aSpecificationQuery member				withGetArguments: aSpecificationQuery arguments				for: aDispatchDriver].	self error: #UnsupportedKind &lt;&lt; #com &gt;&gt; 'Unsupported call type'</body><body package="Com- Automation">specificationFor: aSpecificationQuery on: aDispatchDriver ifAbsent: aBlock	aSpecificationQuery kinds do: 			[:aKind |			(self specificationFor: aSpecificationQuery kind: aKind on: aDispatchDriver)				ifNotNil: [:each | ^ each]].	^aBlock value</body></methods><methods><class-id>External.COMLookupSpecificationPolicy class</class-id> <category>converting</category><body package="Com- Automation">decodeFromLiteralArray: anArray	" Answer a new instance of the receiver from the attributes specifications in the literal representation &lt;anArray&gt;. "	^self new fromLiteralArrayEncoding: anArray</body></methods><methods><class-id>External.COMVariantLookupSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">allowsSpecificationTableUpdates	"Answer whether it makes sense for the receiver to update the specification table ."    ^true</body><body package="Com- Automation">canSupportIDispatch: anIDispatch forLocaleID: aLocaleID	^true</body><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^false</body></methods><methods><class-id>External.COMVariantLookupSpecificationPolicy</class-id> <category>description</category><body package="Com- Automation">description	"Answer a description for the recevier."	^'variant'</body></methods><methods><class-id>External.COMVariantLookupSpecificationPolicy</class-id> <category>private-lookup</category><body package="Com- Automation">buildParameterNames: parameterNames memberIDs: memberIDs    "Private. Build a (partial) array of parameter names from &lt;memberIDs&gt;. The dispatch    parameter construction code uses the position of a name in the array as the    IDs."    | maxID partialParameterNames index parameterMemberIDs |    parameterNames isEmpty        ifTrue: [ ^parameterNames ].    ( memberIDs size &lt;= 1 )        ifTrue: [ ^parameterNames ].    maxID := 0.    parameterMemberIDs := memberIDs copyFrom: 2 to: memberIDs size.    parameterMemberIDs do: [ : each | maxID := maxID max: each ].    partialParameterNames := Array new: ( maxID + 1 ).    index := 1.    parameterMemberIDs do: [ : each |        "Member IDs in the list are 0-based."        partialParameterNames at: ( each + 1 ) put: ( parameterNames at: index ).        index := index + 1 ].    ^partialParameterNames</body><body package="Com- Automation">parameterNamesFor: anArray 		^ (1 to: anArray size) collect: [:i | 'param',i printString ].</body><body package="Com- Automation">parameterTypesFor: argValuesArray	"Answer an Array where each element is a VT_VARIANT or a VT_VARIANT | VT_BREF. If an of the element of &lt;argValuesArray&gt; is a COMVariantValueReference with a defined type code, use it. This allows the user to specify a type code for an argument passed by reference when the default mapping to VT_VARIANT is not accepted by a server."	^argValuesArray collect: 			[:e |			| typeCode |			typeCode := e isValueReference						ifTrue: 							[(e class == COMVariantValueReference and: [e typeCode notNil])								ifTrue: [e typeCode]								ifFalse: [VT_VARIANT | VT_BYREF]]						ifFalse: [VT_VARIANT].			DispTypeSpec fromVariantTypeCode: typeCode]</body></methods><methods><class-id>External.COMVariantLookupSpecificationPolicy</class-id> <category>private lookup-property</category><body package="Com- Automation">propertySpecification: aName withGetArguments: argValuesArray for: anOLEDispatchDriver	"Lookup and answer a new property specification for &lt;aName&gt;."	| memberIDs aMemberID |	memberIDs := anOLEDispatchDriver getIDsOfNames: (Array with: aName).	memberIDs isNil ifTrue: [^nil].	aMemberID := memberIDs first.	^argValuesArray size = 0		ifTrue: [COMDispatchPropertySpecification name: aName memberID: aMemberID typeCode: VT_VARIANT]		ifFalse: 			[COMDispatchParameterizedPropertySpecification				name: aName				memberID: aMemberID 				type: (DispTypeSpec fromVariantTypeCode: VT_VARIANT)				parameterNames: (self parameterNamesFor: argValuesArray)				parameterTypes: (self parameterTypesFor: argValuesArray)]</body></methods><methods><class-id>External.COMVariantLookupSpecificationPolicy</class-id> <category>private lookup-method</category><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    for: anOLEDispatchDriver    "Lookup and answer a new method specification for &lt;aName&gt;."    | memberIDs aMemberID |    memberIDs := anOLEDispatchDriver getIDsOfNames: ( Array with: aName ).    memberIDs isNil        ifTrue: [ ^nil ].    aMemberID := memberIDs first.    ^COMDispatchMethodSpecification name: aName        memberID: aMemberID        typeCode: VT_VARIANT        parameterNames: (self parameterNamesFor: argValuesArray)        parameterTypes: ( self parameterTypesFor: argValuesArray )</body><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    withNamedArguments: argValuesDictionary    for: anOLEDispatchDriver    "Lookup and answer a new method specification for &lt;aName&gt;."    | memberIDs aMemberID parameterNames parameterTypes parameterValues |    parameterNames := argValuesDictionary keys asArray.    "Get the DISPIDs of the parameterNames."    memberIDs := anOLEDispatchDriver getIDsOfNames: ( ( Array with: aName ), parameterNames ).    memberIDs isNil        ifTrue: [ ^nil ].    aMemberID := memberIDs first.    parameterNames := self buildParameterNames: parameterNames memberIDs: memberIDs.	    "Build &lt;parameterValues&gt; in the same order as &lt;parameterNames&gt; in order to calculate &lt;parameterTypes&gt;."    parameterValues := Array new: parameterNames size.    argValuesDictionary keysDo: [ :key | 	parameterValues at: ( parameterNames indexOf: key ) put: ( argValuesDictionary at: key ) ].    parameterTypes := self parameterTypesFor: ( argValuesArray, parameterValues ).    "Answer a new specification"    ^COMDispatchMethodSpecification name: aName        memberID: aMemberID        typeCode: VT_VARIANT        parameterNames: parameterNames        parameterTypes: parameterTypes</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>private-accessing</category><body package="Com- Automation">defaultValueAdaptorClass	" Private - answer the default value adaptor class used by the receiver. "	^COMDispatchValueAdaptor</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>private accessing</category><body package="Com- Automation">getTypeInfo	^self subclassResponsibility</body><body package="Com- Automation">specificationTable: anObject	specificationTable := anObject</body><body package="Com- Automation">typeLibrary	self subclassResponsibility</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>printing</category><body package="Com- Automation">safePrintStringForInspector	^ [ self printString ] on: Error do: [:ex | ex return: super safePrintStringForInspector ]</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>dispatching</category><body package="Com- Automation">getMethod: aName	"Answer the value of the property or method call named &lt;aName&gt;."	^self getMethod: aName withArguments: #( )</body><body package="Com- Automation">getMethod: aName with: aValue	"Answer the value of the property or method call named &lt;aName&gt;."	^self getMethod: aName withArguments: ( Array with: aValue )</body><body package="Com- Automation">getMethod: aName withArguments: argValuesArray	"Answer the value of the property or method named &lt;propertyName&gt;. &lt;argValuesArray&gt; is the Array of argument values for a parameterized property. Raise an exception if the property is not supported."	^(COMCall forPropertyGet: aName client: self arguments: argValuesArray) 		mightBeMethod: true;		invoke</body><body package="Com- Automation">getProperty: propertyName		"Answer the value of the property named &lt;propertyName&gt;."	^self getProperty: propertyName withArguments: #( )</body><body package="Com- Automation">getProperty: aName with: aValue	"Answer the value of the property or method call named &lt;aName&gt;."	^self getProperty: aName withArguments: ( Array with: aValue )</body><body package="Com- Automation">getProperty: propertyName withArguments: argValuesArray	"Answer the value of the control's property named &lt;propertyName&gt;. 	&lt;argValuesArray&gt; is the Array of argument values for a parameterized property. 	Raise an exception if the property is not supported."	^ (COMCall forPropertyGet: propertyName client: self arguments: argValuesArray) invoke</body><body package="Com- Automation">invokeMethod: aMethodName		" Invoke the method named &lt;aMethodName&gt;.  Answer the result value (nil if none). "	^self invokeMethod: aMethodName 		withArguments: #( ) 		result: self newValueReference</body><body package="Com- Automation">invokeMethod: aMethodName with: aValue		" Invoke the method named &lt;aMethodName&gt; with the single argument &lt;aValue&gt;.  Answer the result value (nil if none). "	^self invokeMethod: aMethodName 		withArguments: ( Array with: aValue )		result: self newValueReference</body><body package="Com- Automation">invokeMethod: aMethodName withArguments: argValuesArray        " Invoke the method named &lt;aMethodName&gt; with the arguments        in &lt;argValuesArray&gt;.  Answer the result value (nil if none). "    ^self invokeMethod: aMethodName        withArguments: argValuesArray        result: self newValueReference</body><body package="Com- Automation">invokeMethod: aMethodName withArguments: argValuesArray result: resultReference	" Invoke the method named &lt;aMethodName&gt; with the arguments        in &lt;argValuesArray&gt;.  Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| comCall result |	comCall := COMCall forMethod: aMethodName client: self arguments: argValuesArray.	result := comCall invoke.		resultReference value: result.	^ result</body><body package="Com- Automation">invokeMethod: aMethodName withArguments: argValuesArray withNamedArguments: argValuesDictionary        " Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Answer the result value (nil if none). "    ^self invokeMethod: aMethodName        withArguments: argValuesArray        withNamedArguments: argValuesDictionary        result: self newValueReference</body><body package="Com- Automation">invokeMethod: aMethodName withArguments: argValuesArray withNamedArguments: argValuesDictionary result: resultReference	" Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| aCOMCall result |	aCOMCall := COMCall forMethod: aMethodName			client: self			arguments: argValuesArray			namedArguments: argValuesDictionary.	result := aCOMCall invoke.	resultReference value: result.	^ result</body><body package="Com- Automation">invokeMethod: aMethodName withNamedArguments: argValuesDictionary        " Invoke the method named &lt;aMethodName&gt; with named arguments        in &lt;argValuesDictionary&gt;.  Answer the result value (nil if none). "    ^self invokeMethod: aMethodName withArguments: argValuesDictionary</body><body package="Com- Automation">invokeProcedure: aMethodName	" Invoke the statement named &lt;aMethodName&gt;.  Answer nil since a procedure has no return value."	^self invokeProcedure: aMethodName 		withArguments: #( ) 		result: self newValueReference</body><body package="Com- Automation">invokeProcedure: aMethodName with: aValue		" Invoke the method named &lt;aMethodName&gt; with the single argument &lt;aValue&gt;.  Answer the result value (nil if none). "	^self invokeProcedure: aMethodName 		withArguments: ( Array with: aValue )		result: self newValueReference</body><body package="Com- Automation">invokeProcedure: aMethodName withArguments: argValuesArray        " Invoke the method named &lt;aMethodName&gt; with the arguments        in &lt;argValuesArray&gt;.  Answer the result value (nil if none). "    ^self invokeProcedure: aMethodName        withArguments: argValuesArray        result: self newValueReference</body><body package="Com- Automation">invokeProcedure: aMethodName withArguments: argValuesArray result: resultReference	" Invoke the method named &lt;aMethodName&gt; with the arguments        in &lt;argValuesArray&gt;.  Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| aCOMCall result |	aCOMCall := COMCall forMethod: aMethodName client: self arguments: argValuesArray.	aCOMCall isProcedure: true.	result := aCOMCall invoke.	resultReference value: result.	^ result</body><body package="Com- Automation">invokeProcedure: aMethodName withArguments: argValuesArray withNamedArguments: argValuesDictionary        " Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Answer the result value (nil if none). "    ^self invokeProcedure: aMethodName        withArguments: argValuesArray        withNamedArguments: argValuesDictionary        result: self newValueReference</body><body package="Com- Automation">invokeProcedure: aMethodName withArguments: argValuesArray withNamedArguments: argValuesDictionary result: resultReference	" Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| instance result |	instance := COMCall				forMethod: aMethodName				client: self				arguments: argValuesArray				namedArguments: argValuesDictionary.	instance isProcedure: true.	result := instance invoke.	resultReference value: result.	^result</body><body package="Com- Automation">invokeProcedure: aMethodName withNamedArguments: argValuesDictionary        " Invoke the method named &lt;aMethodName&gt; with named arguments        in &lt;argValuesDictionary&gt;.  Answer the result value (nil if none). "    ^self invokeProcedure: aMethodName        withArguments: #( )        withNamedArguments: argValuesDictionary        result: self newValueReference</body><body package="Com- Automation">setProperty: propertyName value: aValue		"Set the value of the property named &lt;propertyName&gt; to &lt;aValue&gt;. "	^self setProperty: propertyName withArguments: ( Array with: aValue )</body><body package="Com- Automation">setProperty: propertyName withArguments: argValuesArray	"Set the value of the control's property named &lt;propertyName&gt; 	to the last element of &lt;argValuesArray&gt;. &lt;argValuesArray&gt; is an 	Array of values for an indexed property. It may contain only one element, 	the new value, for unindexed properties. 	Raise an exception if the property is not supported."	| aCOMCall |	aCOMCall := COMCall forPropertySet: propertyName client: self arguments: argValuesArray.	^ aCOMCall invoke</body><body package="Com- Automation">threadedGetMethod: aName	"Answer the value of the property or method call named &lt;aName&gt;."	^self threadedGetMethod: aName withArguments: #( )</body><body package="Com- Automation">threadedGetMethod: aName with: aValue	"Answer the value of the property or method call named &lt;aName&gt;."	^self threadedGetMethod: aName withArguments: ( Array with: aValue )</body><body package="Com- Automation">threadedGetMethod: aName withArguments: argValuesArray	"Answer the value of the property or method named &lt;propertyName&gt;. &lt;argValuesArray&gt; is the Array of argument values for a parameterized property. Raise an exception if the property is not supported."	^(COMCall forPropertyGet: aName client: self arguments: argValuesArray)				mightBeMethod: true;				isThreaded: true;				invoke</body><body package="Com- Automation">threadedGetProperty: propertyName		"Answer the value of the property named &lt;propertyName&gt;."	^self threadedGetProperty: propertyName withArguments: #( )</body><body package="Com- Automation">threadedGetProperty: aName with: aValue	"Answer the value of the property or method call named &lt;aName&gt;."	^self threadedGetProperty: aName withArguments: ( Array with: aValue )</body><body package="Com- Automation">threadedGetProperty: propertyName withArguments: argValuesArray	"Answer the value of the control's property named &lt;propertyName&gt;. 	&lt;argValuesArray&gt; is the Array of argument values for a parameterized property. 	Raise an exception if the property is not supported."	^(COMCall		forPropertyGet: propertyName		client: self		arguments: argValuesArray)		isThreaded: true;		invoke</body><body package="Com- Automation">threadedInvokeMethod: aMethodName		" Invoke the method named &lt;aMethodName&gt;.  Answer the result value (nil if none). "	^self threadedInvokeMethod: aMethodName 		withArguments: #( ) 		result: self newValueReference</body><body package="Com- Automation">threadedInvokeMethod: aMethodName with: aValue		" Invoke the method named &lt;aMethodName&gt; with the single argument &lt;aValue&gt;.  Answer the result value (nil if none). "	^self threadedInvokeMethod: aMethodName 		withArguments: ( Array with: aValue )		result: self newValueReference</body><body package="Com- Automation">threadedInvokeMethod: aMethodName withArguments: argValuesArray        " Invoke the method named &lt;aMethodName&gt; with the arguments        in &lt;argValuesArray&gt;.  Answer the result value (nil if none). "    ^self threadedInvokeMethod: aMethodName        withArguments: argValuesArray        result: self newValueReference</body><body package="Com- Automation">threadedInvokeMethod: aMethodName withArguments: argValuesArray result: resultReference	" Invoke the method named &lt;aMethodName&gt; with the arguments        in &lt;argValuesArray&gt;.  Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| result |	result := (COMCall				forMethod: aMethodName				client: self				arguments: argValuesArray)				isThreaded: true;				invoke.	resultReference value: result.	^result</body><body package="Com- Automation">threadedInvokeMethod: aMethodName withArguments: argValuesArray withNamedArguments: argValuesDictionary        " Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Answer the result value (nil if none). "    ^self threadedInvokeMethod: aMethodName        withArguments: argValuesArray        withNamedArguments: argValuesDictionary        result: self newValueReference</body><body package="Com- Automation">threadedInvokeMethod: aMethodName withArguments: argValuesArray withNamedArguments: argValuesDictionary result: resultReference	" Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| comCall result |	comCall := COMCall				forMethod: aMethodName				client: self				arguments: argValuesArray				namedArguments: argValuesDictionary.	comCall isThreaded: true.	result := comCall invoke.	resultReference value: result.	^result</body><body package="Com- Automation">threadedInvokeMethod: aMethodName withNamedArguments: argValuesDictionary        " Invoke the method named &lt;aMethodName&gt; with named arguments        in &lt;argValuesDictionary&gt;.  Answer the result value (nil if none). "    ^self threadedInvokeMethod: aMethodName        withArguments: #( )        withNamedArguments: argValuesDictionary        result: self newValueReference</body><body package="Com- Automation">threadedInvokeProcedure: aMethodName	" Invoke the statement named &lt;aMethodName&gt;.  Answer nil since a procedure has no return value."	^self threadedInvokeProcedure: aMethodName 		withArguments: #( ) 		result: self newValueReference</body><body package="Com- Automation">threadedInvokeProcedure: aMethodName with: aValue		" Invoke the method named &lt;aMethodName&gt; with the single argument &lt;aValue&gt;.  Answer the result value (nil if none). "	^self threadedInvokeProcedure: aMethodName 		withArguments: ( Array with: aValue )		result: self newValueReference</body><body package="Com- Automation">threadedInvokeProcedure: aMethodName withArguments: argValuesArray        " Invoke the method named &lt;aMethodName&gt; with the arguments        in &lt;argValuesArray&gt;.  Answer the result value (nil if none). "    ^self threadedInvokeProcedure: aMethodName        withArguments: argValuesArray        result: self newValueReference</body><body package="Com- Automation">threadedInvokeProcedure: aMethodName withArguments: argValuesArray result: resultReference	" Invoke the method named &lt;aMethodName&gt; with the arguments        in &lt;argValuesArray&gt;.  Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| aCOMCall result |	aCOMCall := COMCall				forMethod: aMethodName				client: self				arguments: argValuesArray.	aCOMCall		isThreaded: true;		isProcedure: true.	result := aCOMCall invoke.	resultReference value: result.	^result</body><body package="Com- Automation">threadedInvokeProcedure: aMethodName withArguments: argValuesArray withNamedArguments: argValuesDictionary        " Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Answer the result value (nil if none). "    ^self threadedInvokeProcedure: aMethodName        withArguments: argValuesArray        withNamedArguments: argValuesDictionary        result: self newValueReference</body><body package="Com- Automation">threadedInvokeProcedure: aMethodName withArguments: argValuesArray withNamedArguments: argValuesDictionary result: resultReference	" Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| comCall result |	comCall := COMCall				forMethod: aMethodName				client: self				arguments: argValuesArray				namedArguments: argValuesDictionary.	comCall		isThreaded: true;		isProcedure: true.	result := comCall invoke.	resultReference value: result.	^result</body><body package="Com- Automation">threadedInvokeProcedure: aMethodName withNamedArguments: argValuesDictionary        " Invoke the method named &lt;aMethodName&gt; with named arguments        in &lt;argValuesDictionary&gt;.  Answer the result value (nil if none). "    ^self threadedInvokeProcedure: aMethodName        withArguments: #( )        withNamedArguments: argValuesDictionary        result: self newValueReference</body><body package="Com- Automation">threadedSetProperty: propertyName value: aValue		"Set the value of the property named &lt;propertyName&gt; to &lt;aValue&gt;. "	^self threadedSetProperty: propertyName withArguments: ( Array with: aValue )</body><body package="Com- Automation">threadedSetProperty: propertyName withArguments: argValuesArray	"Set the value of the control's property named &lt;propertyName&gt; 	to the last element of &lt;argValuesArray&gt;. &lt;argValuesArray&gt; is an 	Array of values for an indexed property. It may contain only one element, 	the new value, for unindexed properties. 	Raise an exception if the property is not supported."	^(COMCall		forPropertySet: propertyName		client: self		arguments: argValuesArray)		isThreaded: true;		invoke</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>accessing</category><body package="Com- Automation">clsid	^ self subclassResponsibility</body><body package="Com- Automation">computeSpecificationTable	self subclassResponsibility</body><body package="Com- Automation">dispatchInterface	self subclassResponsibility</body><body package="Com- Automation">eventSink	^ eventSink ifNil: [ 			self needsFinalization.			eventSink := self computeEventSink ]</body><body package="Com- Automation">localeID	" Answer the receiver's locale ID. "    ^localeID</body><body package="Com- Automation">localeID: lcid	" Set the receiver's locale ID. "	localeID := lcid.</body><body package="Com- Automation">specificationPolicy	" Answer the receiver's specification policy. "    ^ self subclassResponsibility</body><body package="Com- Automation">specificationProvider	"Answer the object which can provide call specifications."	^self</body><body package="Com- Automation">specificationTable	" Answer the dispatch specification table of the receiver. "	^specificationTable ifNil: [self computeSpecificationTable]</body><body package="Com- Automation">type	type ifNil: [type := self computeType].	^type == self class noTypeMarker ifTrue: [nil] ifFalse: [type]</body><body package="Com- Automation">type: anObject	type := anObject.	"Flush the specification table"	self specificationTable: nil</body><body package="Com- Automation">typeNamed: aName	^ self typeLibrary typeNamed: aName</body><body package="Com- Automation">valueAdaptor		" Answer the adaptor which manages transformations between		Smalltalk values and OLE dispatch parameters for the receiver. "	^valueAdaptor</body><body package="Com- Automation">valueAdaptor: aValueAdaptor		" Specify the adaptor which manages transformations between		Smalltalk values and OLE dispatch parameters for the receiver. "	valueAdaptor := aValueAdaptor.</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>announcements-configuring</category><body package="Com- Automation">unsubscribe: anObject	self eventSink ifNil: 			[^self error: #CantRegisterForEventsEventSink &lt;&lt; #com 						&gt;&gt; 'Can not register for events: can''t get Event Sink'].	^self eventSink unsubscribe: anObject</body><body package="Com- Automation">unsubscribe: anObject from: announcementClassOrSet	self eventSink ifNil: 			[^self error: #CantRegisterForEventsEventSink &lt;&lt; #com 						&gt;&gt; 'Can not register for events: can''t get Event Sink'].	^self eventSink unsubscribe: anObject from: announcementClassOrSet</body><body package="Com- Automation">when: announcementClassOrSet do: aBlock for: anObject	self eventSink ifNil: 			[^self error: #CantRegisterForEventsEventSink &lt;&lt; #com 						&gt;&gt; 'Can not register for events: can''t get Event Sink'].	^self eventSink when: announcementClassOrSet do: aBlock for: anObject</body><body package="Com- Automation">when: anAnnouncementOrSymbol send: aSelectorSymbol to: anObject	self eventSink ifNil: 			[^self error: #CantRegisterForEventsEventSink &lt;&lt; #com 						&gt;&gt; 'Can not register for events: can''t get Event Sink'].	^self eventSink when: anAnnouncementOrSymbol send: aSelectorSymbol to: anObject</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>dispatch support</category><body package="Com- Automation">newValueReference	"Private. Answer a new value reference."	^self class newValueReference</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>messages</category><body package="Com- Automation">comClientInvalidMessage	^#DispDriverInvalid &lt;&lt; #com 		&gt;&gt; 'This dispatch driver has been released and is invalid.'</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>testing</category><body package="Com- Automation">hasSpecificationNamed: aKey		" Answer whether the receiver has a specification 		for the dispatch member identified by &lt;aKey&gt; "	self specificationTable isNil ifTrue: [ ^false ].	^self specificationTable includesKey: aKey</body><body package="Com- Automation">isMTAObject	^self anyInterface isMTAObject</body><body package="Com- Automation">isValid	^ self subclassResponsibility</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>private errors</category><body package="Com- Automation">errorTryingToCallMethodLikeProperty	^self error: #TryingToCallMethodLikeProperty &lt;&lt; #com				&gt;&gt; 'You are trying to call a method like a property. Please use method calling syntax instead.'</body><body package="Com- Automation">errorTryingToCallPropertyAsMethod	^self error: #TryingToCallPropertyLikeMethod &lt;&lt; #com				&gt;&gt; 'You are trying to call a property as if it was method. Please use property access syntax instead.'</body><body package="Com- Automation">signalMemberNotFound	self subclassResponsibility</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>private</category><body package="Com- Automation">accessor	"return the the object used for accessing me"	^ propAccessor ifNil: [ propAccessor := DispDriverAccessor for: self ]</body><body package="Com- Automation">computeEventSink	| eventSpecifications sink |	eventSpecifications := self eventSpecificationTable ifNil: [^nil].	sink := COMEventSink iid: eventSpecifications iid				specificationTable: eventSpecifications.	^(sink establishConnectionTo: self dispatchInterface)		ifTrue: [sink]		ifFalse: [nil]</body><body package="Com- Automation">computeEventSpecificationTable	| eventIID iids eventTypeInfo |	eventTypeInfo := COMDispatchSpecificationTable				getEventTypeInfoOf: self dispatchInterface.	eventTypeInfo		ifNil: 			[iids := self connectionPointIIDs.			iids size &gt; 1				ifTrue: 					[COMDevelopmentWarning						raiseSignal: 'only supporting one event interface at the moment'].			iids isEmpty				ifFalse: 					[eventIID := iids first.					eventTypeInfo := ITypeInfo forIID: eventIID]].	eventTypeInfo ifNil: [^nil].	^COMDispatchSpecificationTable specificationTableFor: eventTypeInfo		specificationKey: #memberID</body><body package="Com- Automation">computeType	^[self getTypeInfo] withResultDoAndRelease: 			[:typeInfo |			typeInfo				ifNil: [self class noTypeMarker]				ifNotNil: [DispUserDefTypeSpec fromTypeInfo: typeInfo]]</body><body package="Com- Automation">connectionPointIIDs	| container connectionPoints |	container := (self queryInterface: IID_IConnectionPointContainer) ifNil: [^#()].	connectionPoints := [container connectionPoints] on: COMError do: [:ex | ex return: #()].	^connectionPoints collect: [:each | each getConnectionInterface]</body><body package="Com- Automation">disconnectEventSink	eventSink		ifNotNil: 			["only disconnect the sink and release all held interfaces"			eventSink disconnect.			eventSink := nil]</body><body package="Com- Automation">eventSpecificationTable	^eventSpecificationTable ifUnInitializedDo: 			[eventSpecificationTable := self computeEventSpecificationTable]</body><body package="Com- Automation">eventSpecificationTable: aSpecificationTable	eventSpecificationTable := aSpecificationTable</body><body package="Com- Automation">threadedQueryInterface: anIID	^COMThreadManager performInMTA: [self queryInterface: anIID]</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>private dispatching</category><body package="Com- Automation">actualReceiverFor: aCOMCall	aCOMCall isDispatch ifTrue: [ ^ self automationWrapper ].	^ nil</body><body package="Com- Automation">automationWrapper 	^ COMAutomationClientWrapper on: self</body><body package="Com- Automation">wrapResult: aResult args: anArray namedArgs: anObject for: aSpec	self subclassResponsibility</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>initialize-release</category><body package="Com- Automation">disconnectEvents	eventSink		ifNotNil: 			[" disconnect the sink, release all held interfaces  and release all references to objects in the event handlers"			eventSink disconnect; releaseEventTable.			eventSink := nil]</body><body package="Com- Automation">enforceRelease	self doesNotNeedFinalization.	self disconnectEvents	"only disconnect the sink and release all held interfaces"</body><body package="Com- Automation">initialize	" Private - initialize a new instance of the receiver. "	self		localeID: COMSessionManager defaultLocaleID;		valueAdaptor: (self defaultValueAdaptorClass forClient: self).	eventSpecificationTable := UnInitializedValue any.	super initialize</body><body package="Com- Automation">initializeControl	"When creating an ActiveX control without embedding it, it may be required to initialize it using 	 IPersistStreamInit::InitNew(). Otherwise all subsequent calls may fail"	(self queryInterface: IID_IPersistStreamInit)		ifNotNil: 			[:interface |			[interface initNew] on: COMError do: [:ex | ex return].			interface enforceRelease]</body><body package="Com- Automation">release	self callIsDispensable.	eventSink := nil</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>private accessing interfaces</category><body package="Com- Automation">anyInterface	^self subclassResponsibility</body><body package="Com- Automation">performInCorrespondingApartment: aBlock	^ self isMTAObject 		ifTrue: [ COMThreadManager performInMTA: aBlock ]		ifFalse: [ COMThreadManager performInSTA: aBlock ]</body><body package="Com- Automation">queryInterface: anIID	| iid |	iid := GUID iidFor: anIID clsidBlock: [self clsid].	iid ifNil: [COMInterface couldNotDetermineInterfaceFor: anIID].	^self queryInterfaceIID: iid</body><body package="Com- Automation">queryInterfaceIID: anIID	^self anyInterface queryInterfaceIID: anIID</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>event accessing</category><body package="Com- Automation">actionForEvent: anEventNameSymbol	^eventSink		ifNil: [nil]		ifNotNil: [:sink | sink actionForEvent: anEventNameSymbol]</body><body package="Com- Automation">canTriggerEvent: anEventNameSymbol	^eventSink		ifNil: [false]		ifNotNil: [:sink | sink canTriggerEvent: anEventNameSymbol]</body><body package="Com- Automation">hasActionForEvent: anEventNameSymbol	"Do we have the event? 	Don''t use the accessor, otherwise we might create the sink which isn't desired here"	^eventSink		ifNil: [false]		ifNotNil: [:sink | sink hasActionForEvent: anEventNameSymbol]</body><body package="Com- Automation">removeActionsForEvent: anEventSymbol	"Remove the event handler for anEventSymbol. 	 Don''t use the accessor, otherwise we might create the sink which isn't desired here"	^eventSink		ifNotNil: 			[:sink |			sink removeActionsForEvent: anEventSymbol.			sink eventTable isEmpty ifTrue: [self disconnectEvents]]</body><body package="Com- Automation">removeActionsSatisfying: aBlock forEvent: anEventNameSymbol	"Remove all actions for the event &lt;anEventNameSymbol&gt; that satisfy &lt;aBlock&gt;.	Don''t use the accessor, otherwise we might create the sink which isn't desired here"	^eventSink		ifNotNil: 			[:sink |			sink removeActionsSatisfying: aBlock forEvent: anEventNameSymbol.			sink eventTable isEmpty ifTrue: [self disconnectEvents]]</body><body package="Com- Automation">removeAllActionsWithReceiver: anObject	"Remove eventhandlers which send to anObject.	Don''t use the accessor, otherwise we might create the sink which isn't desired here"	^eventSink		ifNotNil: 			[:sink |			sink removeAllActionsWithReceiver: anObject.			sink eventTable isEmpty ifTrue: [self disconnectEvents]]</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>event configuring</category><body package="Com- Automation">when: anEventNameSymbol evaluate: anAction	^self eventSink		ifNotNil: [:sink | sink when: anEventNameSymbol evaluate: anAction]</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>private automation dispatching</category><body package="Com- Automation">getDispatchPropertySpec: aCOMCall	"Answer the value of the control's property named &lt;propertyName&gt;. 	&lt;argValuesArray&gt; is the Array of argument values for a parameterized property. 	Raise an exception if the property is not supported."	| dispParams propertyValue getSpec actualSpec aDispatchSpec argValuesArray |	aDispatchSpec := aCOMCall specification.	argValuesArray := aCOMCall arguments.	actualSpec := aDispatchSpec member.	getSpec := actualSpec propertyGetSpecification asDispatchSpecification.	(getSpec checkArguments: argValuesArray)		ifFalse: [getSpec raiseInvalidNumberOfArguments].	dispParams := self valueAdaptor parametersForPropertyGet: getSpec				arguments: argValuesArray.		[propertyValue := self specificationPolicy				invokePropertyGet: getSpec				with: dispParams				on: self.	self valueAdaptor		updateReferenceArguments: argValuesArray		fromParameters: dispParams		types: getSpec parameterTypeDescriptions]			ensure: [dispParams enforceRelease].	^propertyValue</body><body package="Com- Automation">invokeDispatchMethodSpec: aCOMCall withArguments: argValuesArray withNamedArguments: argValuesDictionary result: resultReference	" Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| aDispatchSpec dispParams resultValue |	aDispatchSpec := aCOMCall specification member.	dispParams := self valueAdaptor				parametersForMethod: aDispatchSpec				arguments: argValuesArray				namedArguments: argValuesDictionary.		[resultValue := self specificationPolicy				invokeMethod: aDispatchSpec				with: dispParams				on: self				result: resultReference.	self valueAdaptor		updateReferenceArguments: argValuesArray				, argValuesDictionary values asArray		fromParameters: dispParams		types: aDispatchSpec parameterTypeDescriptions]			ensure: [dispParams enforceRelease].	^resultValue</body><body package="Com- Automation">invokeDispatchProcedureSpec: aCOMCall withArguments: argValuesArray result: resultReference	| dispParams resultValue aDispatchSpec |	aDispatchSpec := aCOMCall specification member.	dispParams := self valueAdaptor parametersForMethod: aDispatchSpec				arguments: argValuesArray.		[resultValue := self specificationPolicy				invokeProcedure: aDispatchSpec				with: dispParams				on: self				result: resultReference.	self valueAdaptor		updateReferenceArguments: argValuesArray		fromParameters: dispParams		types: aDispatchSpec parameterTypeDescriptions]			ensure: [dispParams enforceRelease].	^resultValue</body><body package="Com- Automation">invokeDispatchProcedureSpec: aCOMCall withArguments: argValuesArray withNamedArguments: argValuesDictionary result: resultReference	" Invoke the method named &lt;aMethodName&gt; with positional arguments        in &lt;argValuesArray&gt; and named arguments in &lt;argValuesDictionary&gt;.        Store the result value into the &lt;resultReference&gt;.        Answer the result value (nil if none).  Raise an exception if the method is not defined. "	| aDispatchSpec dispParams resultValue |	aDispatchSpec := aCOMCall specification member.	dispParams := self valueAdaptor				parametersForMethod: aDispatchSpec				arguments: argValuesArray				namedArguments: argValuesDictionary.		[resultValue := self specificationPolicy				invokeProcedure: aDispatchSpec				with: dispParams				on: self				result: resultReference.	self valueAdaptor		updateReferenceArguments: argValuesArray				, argValuesDictionary values asArray		fromParameters: dispParams		types: aDispatchSpec parameterTypeDescriptions]			ensure: [dispParams enforceRelease].	^resultValue</body><body package="Com- Automation">setDispatchPropertySpec: aCOMCall withArguments: argValuesArray	| setSpec dispParams actualSpec aDispatchSpec result |	aDispatchSpec := aCOMCall specification.	actualSpec := aDispatchSpec member.	setSpec := actualSpec				writePropertySpecificationForArguments: argValuesArray.	dispParams := self valueAdaptor parametersForPropertySet: setSpec				arguments: argValuesArray.	^	[result := self dispatchInterface				invokePropertyPut: setSpec memberID				flags: setSpec invokationType				with: dispParams				localeID: self localeID.	self valueAdaptor		updateReferenceArguments: argValuesArray		fromParameters: dispParams		types: setSpec parameterTypeDescriptions.	result]			ensure: [dispParams enforceRelease]</body></methods><methods><class-id>External.AbstractCOMClient</class-id> <category>lookup</category><body package="Com- Automation">basicSpecificationFor: aSpecificationQuery ifAbsent: aBlock	self specificationTable ifNil: [^aBlock value].	^ self specificationTable		getSpecificationOfType: aSpecificationQuery kinds		where: #name		isEqualTo: aSpecificationQuery member asString		ifAbsent: aBlock</body><body package="Com- Automation">basicSpecificationType: aType named: aKey ifAbsent: aBlock	^(self specificationTable ifNil: [^aBlock value])		getSpecificationOfType: aType		where: #name		isEqualTo: aKey asString		ifAbsent: aBlock</body><body package="Com- Automation">enumConstantNamed: aName	^self typeLibrary enumConstantNamed: aName</body><body package="Com- Automation">enumConstantNamed: aName inTypeNamed: aTypeName	^ self typeLibrary enumConstantNamed: aName inTypeNamed: aTypeName</body><body package="Com- Automation">specificationFor: aQuery  ifAbsent: aBlock	" Answer the specification identified by the name &lt;aKey&gt;		in the receiver's dispatch specification table.		Raise an exception if the member is not supported. "	^self specificationPolicy		specificationFor: aQuery		on: self		ifAbsent: aBlock</body><body package="Com- Automation">specificationNamed: aKey		" Answer the specification identified by the name &lt;aKey&gt;		in the receiver's dispatch specification table.		Raise an exception if the member is not supported. "	^self specificationNamed: aKey		ifNone: [ self signalMemberNotFound ]</body><body package="Com- Automation">specificationNamed: aName ifNone: aBlock	" Answer the specification identified by the name &lt;aKey&gt;		in the receiver's dispatch specification table.		Raise an exception if the member is not supported. "	^self specificationPolicy		specificationFor: (COMSpecificationQuery forName: aName)		on: self		ifAbsent: aBlock</body></methods><methods><class-id>External.AbstractCOMClient class</class-id> <category>instance creation</category><body package="Com- Automation">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>External.AbstractCOMClient class</class-id> <category>dispatch support</category><body package="Com- Automation">newValueReference    " Answer a new value reference for a reference argument to a dispatch interface member. "    ^COMDispatchInterface newValueReference</body><body package="Com- Automation">valueReferenceOn: aValue    " Answer a new value reference for a reference argument to a dispatch interface member with initial value &lt;aValue&gt;. "    ^COMDispatchInterface valueReferenceOn: aValue</body></methods><methods><class-id>External.AbstractCOMClient class</class-id> <category>private accessing</category><body package="Com- Automation">noTypeMarker	"Return the constant which is used to describe that it was not possible to compute a type"	^ #NoType</body></methods><methods><class-id>External.AbstractCOMClient class</class-id> <category>instance creation-on existing interface</category><body package="Com- Automation">onNew: anInterface	self subclassResponsibility</body><body package="Com- Automation">onNewAndInitialize: anInterface	" Answer a new instance of the receiver which uses        the dispatch interface &lt;anIDispatch&gt; to invoke        dispatch member functions.  The functions and properties        are built the default specification policy. "	^(self onNew: anInterface)		initializeControl;		yourself</body></methods><methods><class-id>External.COMReturnValueDescription</class-id> <category>accessing</category><body package="Com- Automation">clearFlag: aFlag	flags := flags bitAnd: aFlag bitInvert</body><body package="Com- Automation">flags	^flags</body><body package="Com- Automation">flags: anObject	flags := anObject</body><body package="Com- Automation">name	^ (#ReturnValue &lt;&lt; #com &gt;&gt; 'ReturnValue')</body><body package="Com- Automation">setFlag: aFlag	flags := flags bitOr: aFlag</body><body package="Com- Automation">testFlag: aFlag	^ (flags bitAnd: aFlag) = aFlag</body><body package="Com- Automation">type	^ type</body><body package="Com- Automation">type: anObject	type := anObject</body><body package="Com- Automation">typecode	^ type ifNil: [ nil ] ifNotNil: [ type typecode ]</body></methods><methods><class-id>External.COMReturnValueDescription</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	aStream nextPutAll: 		((#Param1sAs2p &lt;&lt; #com &gt;&gt; '&lt;1s&gt; as &lt;2p&gt;') expandMacrosWith: (self name ifNil: ['(unnamed)']) with: self type)</body></methods><methods><class-id>External.COMReturnValueDescription</class-id> <category>converting</category><body package="Com- Automation">asParamName: aName	^ COMParameterDescription name: aName type: self type flags: self flags defaultValue: nil</body><body package="Com- Automation">cType	^ self type cType</body></methods><methods><class-id>External.COMReturnValueDescription</class-id> <category>testing</category><body package="Com- Automation">basicIsEqualTo: aParameter	aParameter ifNil: [^ false].	^ aParameter type = self type</body><body package="Com- Automation">carriesValue	^ self typecode ~= VT_VOID</body><body package="Com- Automation">isByref	^self type isByref</body></methods><methods><class-id>External.COMReturnValueDescription</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	flags := 0.</body></methods><methods><class-id>External.COMReturnValueDescription</class-id> <category>private</category><body package="Com- Automation">vbTypeName	^ self type name</body></methods><methods><class-id>External.COMReturnValueDescription</class-id> <category>literal array encoding</category><body package="Com- Automation">literalArrayEncoding	^ LiteralArrayEncoder encode: self</body><body package="Com- Automation">literallyEncodedAttributes	^  self class literallyEncodedAttributes</body></methods><methods><class-id>External.COMReturnValueDescription</class-id> <category>comparing</category><body package="Com- Automation">= anObject	^anObject class = self class		and: [self type = anObject type and: [self flags = anObject flags]]</body><body package="Com- Automation">hash	^ self name hash bitOr: [ self type hash ]</body></methods><methods><class-id>External.COMReturnValueDescription class</class-id> <category>instance creation</category><body package="Com- Automation">fromElemDesc: elemDesc typeInfo: anITypeInfo 	^self type: (DispTypeSpec forTypeDesc: elemDesc typeDescription				typeInfo: anITypeInfo)		flags: elemDesc parameterDescription flags</body><body package="Com- Automation">new	^ super new initialize</body><body package="Com- Automation">newEmpty	^self type: (DispTypeSpec fromVariantTypeCode: VT_VOID)</body><body package="Com- Automation">type: aType 	^ self new		type: aType;		yourself</body><body package="Com- Automation">type: aType flags: flags 	^(self new)		type: aType;		flags: flags;		yourself</body><body package="Com- Automation">typeCode: aTypeCode	^ self new 		type: (DispTypeSpec fromVariantTypeCode: aTypeCode);		yourself</body></methods><methods><class-id>External.COMReturnValueDescription class</class-id> <category>literal array encoding</category><body package="Com- Automation">decodeFromLiteralArray: anArray	^ LiteralArrayEncoder decode: anArray</body><body package="Com- Automation">literallyEncodedAttributes	^  #(flags type)</body></methods><methods><class-id>External.CachingWeakRegistry</class-id> <category>accessing</category><body package="Com- Automation">at: key ifAbsent: aBlock	^ values at: key ifAbsent: aBlock</body><body package="Com- Automation">at: key ifAbsentPut: aBlock	^values at: key ifAbsent: [self at: key put: aBlock value]</body><body package="Com- Automation">at: key put: aValue	values at: key put: aValue.	self protectReferenceTo: aValue.	^aValue</body><body package="Com- Automation">size	^values size</body></methods><methods><class-id>External.CachingWeakRegistry</class-id> <category>private accessing</category><body package="Com- Automation">numberOfProtectedEntries	^numberOfProtectedEntries ifNil: [10]</body><body package="Com- Automation">numberOfProtectedEntries: aNumber	numberOfProtectedEntries := aNumber.</body><body package="Com- Automation">protectReferenceTo: aValue	self protectedReferences size &gt;= self numberOfProtectedEntries ifTrue: [self protectedReferences removeFirst].	self protectedReferences addLast: aValue</body><body package="Com- Automation">protectedReferences	^ protectedReferences</body></methods><methods><class-id>External.CachingWeakRegistry</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	"Initialize a newly created instance. This method must answer the receiver."	protectedReferences := OrderedCollection new.	values := WeakEqualityDictionary new</body></methods><methods><class-id>External.CachingWeakRegistry class</class-id> <category>instance creation</category><body package="Com- Automation">new	^super new initialize</body></methods><methods><class-id>External.COMLazyInitializeLookupSpecificationPolicy</class-id> <category>description</category><body package="Com- Automation">description	"Answer a description for the recevier."	^(#lazyInitialization &lt;&lt; #com &gt;&gt; 'lazy initialization') asString</body></methods><methods><class-id>External.COMLazyInitializeLookupSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">allowsSpecificationTableUpdates	"We don't allow updates as the tables are shared between several objects. 	 Some members may be provided by instance behaviour"    ^false</body><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^true</body></methods><methods><class-id>External.COMLazyInitializeLookupSpecificationPolicy</class-id> <category>lookup</category><body package="Com- Automation">initialSpecificationTableFor: aDispatchDriver	| typeInfo |	typeInfo := aDispatchDriver getTypeInfo.	^ COMDispatchSpecificationTable specificationTableFor: typeInfo specificationKey: #name</body></methods><methods><class-id>External.COMDispatchInterfaceAdaptor</class-id> <category>interface operations</category><body package="Com- Automation">GetIDsOfNames: riid _: names _: cNames _: lcid _: resultReference	" Invoke the IDispatch::GetIDsOfNames function. "	^self triggerEvent: #GetIDsOfNames:_:_:_:_:  withArguments: ( Array		with: riid 		with: names  		with: cNames 		with: lcid ), ( Array		with: resultReference )</body><body package="Com- Automation">GetTypeInfo: itinfo _: lcid _: resultReference	" Invoke the IDispatch::GetTypeInfo function. "	^self triggerEvent: #GetTypeInfo:_:_: withArguments: ( Array		with: itinfo		with: lcid 		with: resultReference )</body><body package="Com- Automation">GetTypeInfoCount: resultReference	" Invoke the IDispatch::GetTypeInfoCount function. "	^self triggerEvent: #GetTypeInfoCount: with: resultReference</body><body package="Com- Automation">Invoke: dispidMember    _: riid    _: lcid    _: wFlags    _: pdispparams    _: resultReference    _: exceptionInfoReference    _: argErrorReference	"Invoke the IDispatch::Invoke function. "	^self triggerEvent: #Invoke:_:_:_:_:_:_:_: withArguments: ( Array		with: dispidMember		with: riid		with: lcid		with: wFlags ), ( Array		with: pdispparams		with: resultReference		with: exceptionInfoReference		with: argErrorReference )</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>subclass-initializing</category><body package="Com- Automation">createIDispatch		" Private - create an IDispatch interface on the receiver. "	^IDispatch directBindingOn: self</body><body package="Com- Automation">defaultValueAdaptorClass	" Private - answer the default value adaptor class used by the receiver. "	^COMDispatchValueAdaptor</body><body package="Com- Automation">initialize		" Private - initialize a new instance. "	super initialize.	self valueAdaptor: (self defaultValueAdaptorClass forClient: self).</body><body package="Com- Automation">initializeInterfaces		" Private - Allocate any interfaces which are expected to be required 		during the object's lifetime. "	super initializeInterfaces.	iDispatch := self createIDispatch.</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>private-IDispatch operations</category><body package="Com- Automation">GetIDsOfNames: iid _: nameList _: cNames _: lcid _: resultReference	"Private. Implement the IDispatch::GetIDsOfNames function. May be reimplemented by subclasses which can map dispatch member names to the correspoding DISPID value."	^self unimplementedFunction</body><body package="Com- Automation">GetTypeInfo: itinfo _: lcidRequest _: resultReference	"Private. Implement the IDispatch::GetTypeInfo function. May be reimplemented by subclasses."	^self unimplementedFunction</body><body package="Com- Automation">GetTypeInfoCount: resultReference	"Private. Implement the IDispatch::GetTypeInfoCount function. May be reimplemented by subclasses."	^self unimplementedFunction</body><body package="Com- Automation">Invoke: dispidMember	_: iid	_: lcid	_: wFlags	_: dispParams	_: resultReference	_: exceptionInfoReference	_: argErrorReference	"Private. Implement the IDispatch::Invoke function. Must be reimplemented by subclasses."	^self unimplementedFunction</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>private-accessing</category><body package="Com- Automation">dispatchInterface: anInterface		"Private - set the dispatch interface supported by the receiver."	iDispatch := anInterface.</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>accessing</category><body package="Com- Automation">dispatchInterface		" Answer the dispatch interface supported by the receiver.		Note that this is not a separately reference counted copy of the interface. "	^iDispatch</body><body package="Com- Automation">valueAdaptor		" Answer the adaptor which manages transformations between		Smalltalk values and OLE dispatch parameters for the receiver. "	^valueAdaptor</body><body package="Com- Automation">valueAdaptor: aValueAdaptor		" Specify the adaptor which manages transformations between		Smalltalk values and OLE dispatch parameters for the receiver. "	valueAdaptor := aValueAdaptor.</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>private-error handling</category><body package="Com- Automation">createExceptionInfoWith: descriptionString	" Private - create an OLE automation EXCEPINFO structure with the given &lt;descriptionString&gt;. "	^( COMStructure createStructureNamed: #EXCEPINFO )		setInvocationExceptionDescription: descriptionString;		yourself</body><body package="Com- Automation">reportCallinError: anException	" Private - an exception has occurred during the invocation of a VTable function.  Report the error so that the problem can be diagnosed. "	| myDispatchBinding |	myDispatchBinding := self dispatchInterface interfaceBinding.	myDispatchBinding reportCallinError: anException.	" following is no longer be needed, now handled by the trace adaptor:	myDispatchBinding ifTraceEnabled: [ 		myDispatchBinding traceAdaptor logErrorExitHRESULT: DISP_E_EXCEPTION ].	"</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>subclass-enumerating</category><body package="Com- Automation">allocatedInterfacesDo: aOneArgBlock		" Private - enumerate the interfaces supported by the receiver		which have been allocated during its lifetime and		evaluate &lt;aOneArgBlock&gt; with each. "	super allocatedInterfacesDo: aOneArgBlock.	iDispatch notNil		ifTrue: [ aOneArgBlock value: iDispatch ].</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>subclass-exception handlers</category><body package="Com- Automation">handleDispatchInvokeException: anException exceptionInfo: exceptionInfoReference	" Private - handle &lt;anException&gt; which has occurred during IDispatch::Invoke processing.  Answer the HRESULT to return to the caller. "	self reportCallinError: anException.	exceptionInfoReference notNil		ifTrue: [			exceptionInfoReference value: 				( self createExceptionInfoWith: anException description ) ].	^DISP_E_EXCEPTION</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>subclass-accessing</category><body package="Com- Automation">getInterfaceForIID: iid		" Private - answer the interface identified by the GUID &lt;iid&gt;.		Answer nil if the requested interface is not supported by the receiver. "	iid = IID_IDispatch		ifTrue: [ ^iDispatch ].	^nil</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>subclass-releasing</category><body package="Com- Automation">resetAllocatedInterfaces		" Private - reset the references to the interfaces supported by the receiver. "	super resetAllocatedInterfaces.	iDispatch := nil.</body></methods><methods><class-id>External.COMAutomationObject</class-id> <category>private-LCIDs</category><body package="Com- Automation">translateLCID: lcid	"Answer the real LCID if &lt;lcid&gt; is a request for a system or user default."	(lcid = LOCALE_SYSTEM_DEFAULT)		ifTrue: [^Win32ExternalInterface defaultSystemLCID].	lcid = LOCALE_USER_DEFAULT		ifTrue: [^Win32ExternalInterface defaultUserLCID].	^lcid</body></methods><methods><class-id>External.COMAutomationObject class</class-id> <category>active object registration</category><body package="Com- Automation">registerActiveObject: anIUnknown clsid: aClassId	" Register the object which supports &lt;anIUnknown&gt; with COM as the active automation object of the class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.   Answer the registration token. "	| aCLSID resultReference |	aCLSID := IClassFactory getCLSID: aClassId.	resultReference := nil asValueReference.	OLEAutomationDLL current RegisterActiveObject: anIUnknown		_: aCLSID		_: 0 		_: resultReference.	^resultReference value</body><body package="Com- Automation">revokeActiveObject: registration	" Revoke the registration of an active automation object, using the registration token obtained from RegisterActiveObject. "	OLEAutomationDLL current RevokeActiveObject: registration _: nil.</body></methods><methods><class-id>External.COMAutomationObject class</class-id> <category>initialization</category><body package="Com- Automation">install		"		self install			"	Tools.Note ISSUEin72. "This method did exist in 7.2 but the called methods were not defined any more"	"self initWin32NLSConstantsPool.	self initCOMAutomationConstantsPool."</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>accessing</category><body package="Com- Automation">dispatchInterfaceIID	"Answer the IID of the dispatch interface which is supported by the receiver. Must be reimplemented by a subclass"	^self subclassResponsibility</body><body package="Com- Automation">publishedObject	"Answer the object being published as a COM automation object by supporting IDispatch on it."	^publishedObject</body><body package="Com- Automation">publishedObject: anObject	"Set the object being published as a COM automation object by supporting IDispatch on it."	publishedObject := anObject.</body><body package="Com- Automation">specificationTable 	"Answer the receiver's specification table for dispatching method and property member invocations.	 This method was added so that code critic does not complain about 'method not implemented' "	^ self subclassResponsibility</body><body package="Com- Automation">typeLibraries	"Answer the type library dictionary. The dictionary keys are LCIDs and the values are instances of COMTypeLibrary. Must be reimplemented by a subclass"	^self subclassResponsibility</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>converting</category><body package="Com- Automation">asCOMVariant	" Answer the receiver as a COM VARIANT.  Answer nil if the receiver cannot be represented by a known VARIANT type. "	^( COMStructure classForStructureNamed: #VARIANT )		type: self comVariantType		value: self dispatchInterface</body><body package="Com- Automation">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."    ^self dispatchInterface asPointerParameter</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^VT_DISPATCH</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>private-accessing</category><body package="Com- Automation">registrationToken	"Answer the receiver's registration token from the RegisterActiveObject API."	^registrationToken</body><body package="Com- Automation">registrationToken: aToken	"Set the receiver's registration token from the RegisterActiveObject API."	^registrationToken := aToken</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>private-IDispatch operations</category><body package="Com- Automation">GetIDsOfNames: iid _: names _: cNames _: lcid _: resultReference		" Private - Implement the IDispatch::GetIDsOfNames function. "	"Get IDs of names for a dispatch member    Map a single member and an optional set of argument names into    a corresponding set of DISPID's which can be used with IDispatch::Invoke.    The first element is the DISPID of the member name; subsequent    elements represent each of the member's parameters.	Answer the result code."	| memberName dispidMember dispidList aDispatchSpecification |	"?? ^DISP_EUNKNOWNLCID if not supported locale? ??"	memberName := names at: 1.	aDispatchSpecification := self specificationTable 		detect: [ :each | each name sameAs: memberName ]         ifNone: [ nil ].    dispidMember := ( aDispatchSpecification == nil        ifTrue: [ DISPID_UNKNOWN ]        ifFalse: [ aDispatchSpecification memberID ] ).	cNames = 1        ifTrue: [ dispidList := Array with: dispidMember ]        ifFalse: [            dispidList := Array new: cNames.            dispidList atAllPut: DISPID_UNKNOWN.  " parameter name mappings not supported "            dispidList at: 1 put: dispidMember ].	resultReference value: dispidList.    ^( dispidMember = DISPID_UNKNOWN	or: [ cNames &gt; 1 ] )        ifTrue: [ DISP_E_UNKNOWNNAME ]        ifFalse: [ S_OK ]</body><body package="Com- Automation">GetTypeInfo: itinfo _: lcidRequest _: resultReference	"Private. Implement the IDispatch::GetTypeInfo function."	| typeInfo typeLibrary lcid |	self hasTypeLibraries ifFalse: [^E_FAIL].	itinfo ~~ 0 ifTrue: [^DISP_E_BADINDEX].	lcid := self translateLCID: lcidRequest.	typeLibrary := self typeLibraries at: lcid				ifAbsent: 					[self typeLibraries at: LOCALE_NEUTRAL						ifAbsent: 							[self typeLibraries at: (self fallbackTranslateLCID: lcidRequest)								ifAbsent: [^DISP_E_UNKNOWNLCID]]].	typeInfo := typeLibrary typeInfoOfGuidAt: self dispatchInterfaceIID.	typeInfo isNil ifTrue: [^E_FAIL].	" or do we want to return NULL in some suitable fashion? "	resultReference value: typeInfo.	^S_OK</body><body package="Com- Automation">GetTypeInfoCount: resultReference	"Private. Implement the IDispatch::GetTypeInfoCount function."	| count |	count := ( self clsid notNil and: [ self hasTypeLibraries ] )		ifTrue: [ 1 ] 		ifFalse: [ 0 ].	resultReference value: count.	^S_OK</body><body package="Com- Automation">Invoke: dispidMember _: iid _: lcid _: wFlags _: dispParams _: resultReference _: exceptionInfoReference _: argErrorReference	" Private - implement the IDispatch::Invoke function. "	| aDispatchSpecification |	aDispatchSpecification := self specificationTable at: dispidMember				ifAbsent: [nil].	aDispatchSpecification isNil ifTrue: [^DISP_E_MEMBERNOTFOUND].		[aDispatchSpecification isMethodSpecification		ifTrue: 			[^self				invokeMethod: aDispatchSpecification				lcid: lcid				dispParams: dispParams				flags: wFlags				resultReference: resultReference				exceptionInfo: exceptionInfoReference				argError: argErrorReference].	aDispatchSpecification isPropertySpecification		ifTrue: 			[(wFlags bitAnd: DISPATCH_PROPERTYGET) ~= 0				ifTrue: 					[^self						invokePropertyGet: aDispatchSpecification						lcid: lcid						dispParams: dispParams						resultReference: resultReference						expectionInfo: exceptionInfoReference						argError: argErrorReference].			(wFlags bitAnd: DISPATCH_PROPERTYPUT) ~= 0				ifTrue: 					[^self						invokePropertySet: aDispatchSpecification						lcid: lcid						dispParams: dispParams						resultReference: resultReference						exceptionInfo: exceptionInfoReference						argError: argErrorReference].			^E_NOTIMPL]]			on: Error			do: 				[:ex |				^self handleDispatchInvokeException: ex					exceptionInfo: exceptionInfoReference].	^E_UNEXPECTED</body><body package="Com- Automation">fallbackTranslateLCID: lcid	"Backwards compatibility - in earlier versions COM Connect translated the neutral locale	 into the system's default locale. This is normally not done any more and may cause calls to	 AutomationServers created with previous COM Connect versions to fail. We added this 	compatibility code to ensure old Automation Servers continue to work."	^lcid = COMTypeLibrary lcidNeutral		ifTrue: [COMSessionManager defaultLocaleID]		ifFalse: [lcid]</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>subclass-initializing</category><body package="Com- Automation">createIDispatch		" Private - create an IDispatch interface on the receiver. "	^super createIDispatch		iid: self dispatchInterfaceIID;		yourself</body><body package="Com- Automation">registerActiveObject	"Register the receiver with COM as the active automation object. Answer the registration token."	self registrationToken: ( self class registerActiveObject: self innerUnknown clsid: self clsid )</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>subclass-testing</category><body package="Com- Automation">hasTypeLibraries	"Answer whether there are any type library objects."	^self typeLibraries notEmpty</body><body package="Com- Automation">isRegistered	" Answer whether the receiver is registered with COM as the active object of its class. "	^self registrationToken notNil</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>private-invocation</category><body package="Com- Automation">invokeMethod: aDispatchSpecification arguments: arguments resultReference: resultReference 	"Private - invoke the method described by &lt;aDispatchSpecification&gt; 	of the published object."	| resultValue typeCode |	resultValue := (MessageSend 			forReceiver: self publishedObject 			selector: aDispatchSpecification selector) 		evaluateWithArguments: arguments.	resultReference notNil		ifTrue: [			typeCode := aDispatchSpecification typeCode.			typeCode = VT_VOID ifTrue: [				"COM raises an error on the client if VT_VOID is used even if type libraries describe 				the return type as void. GG Apr-23-1997"				typeCode := VT_EMPTY].			resultReference typeCode: typeCode.			typeCode = VT_EMPTY ifFalse: [resultReference value: resultValue]].	^S_OK</body><body package="Com- Automation">invokeMethod: aDispatchSpecification lcid: lcid dispParams: dispParams flags: wFlags resultReference: resultReference  exceptionInfo: exceptionInfoReference argError: argErrorReference	| arguments hresult |	(wFlags bitAnd: DISPATCH_METHOD) = 0		ifTrue: 			[exceptionInfoReference value: (self						createExceptionInfoWith: (#IncorrectDispatchFlags &lt;&lt; #com								&gt;&gt; 'Incorrect dispatch invocation flags: DISPATCH_METHOD flag not set for method &lt;1s&gt;.'									expandMacrosWith: aDispatchSpecification name)).			^DISP_E_EXCEPTION].	(dispParams argumentCount &lt; aDispatchSpecification requiredParameterCount		or: [dispParams argumentCount &gt; aDispatchSpecification parameterCount])			ifTrue: [^DISP_E_BADPARAMCOUNT].	arguments := self valueAdaptor				argumentsForMethod: aDispatchSpecification				parameters: dispParams				localeID: lcid.	arguments isInteger		ifTrue: 			[argErrorReference value: arguments.			^DISP_E_TYPEMISMATCH].	hresult := self				invokeMethod: aDispatchSpecification				arguments: (arguments collect: [:each | each value])				resultReference: resultReference.	(hresult succeeded		and: [(COMVariant isValid: resultReference value) not])			ifTrue: 				[exceptionInfoReference					value: (self createInvalidResultExceptionInfo: resultReference value).				^DISP_E_EXCEPTION].	self valueAdaptor updateReturnReferenceArguments: arguments		fromParameters: dispParams.	^hresult</body><body package="Com- Automation">invokePropertyGet: aDispatchSpecification    arguments: arguments    resultReference: resultReference        " Private - get the value of the property member described by &lt;aDispatchSpecification&gt;        of the published object. "	| resultValue |	resultValue := ( MessageSend forReceiver: self publishedObject		selector: aDispatchSpecification selector )			evaluateWithArguments: arguments.	resultReference notNil		ifTrue: [			resultReference				typeCode: aDispatchSpecification typeCode;				value: resultValue ].	^S_OK</body><body package="Com- Automation">invokePropertyGet: aDispatchSpecification lcid: lcid dispParams: dispParams resultReference: resultReference expectionInfo: exceptionInfoReference argError: argErrorReference	| arguments hresult getSpecification |	aDispatchSpecification isWriteOnly		ifTrue: 			[exceptionInfoReference value: (self						createExceptionInfoWith: (#CantReadWriteOnlyProperty &lt;&lt; #com								&gt;&gt; 'Cannot read value of writeOnly property &lt;1s&gt;.'									expandMacrosWith: aDispatchSpecification name)).			^DISP_E_EXCEPTION].	getSpecification := aDispatchSpecification getSpecification.	(dispParams argumentCount &lt; getSpecification requiredParameterCount		or: [dispParams argumentCount &gt; getSpecification parameterCount])			ifTrue: [^DISP_E_BADPARAMCOUNT].	arguments := self valueAdaptor				argumentsForPropertyGet: getSpecification				parameters: dispParams				localeID: lcid.	arguments isInteger		ifTrue: 			[argErrorReference value: arguments.			^DISP_E_TYPEMISMATCH].	hresult := self				invokePropertyGet: getSpecification				arguments: (arguments collect: [:each | each value])				resultReference: resultReference.	(hresult succeeded and: [(COMVariant isValid: resultReference value) not])		ifTrue: 			[exceptionInfoReference				value: (self createInvalidResultExceptionInfo: resultReference value).			^DISP_E_EXCEPTION].	^hresult</body><body package="Com- Automation">invokePropertySet: aDispatchSpecification    arguments: arguments    resultReference: resultReference        " Private - set the value of the property member described by &lt;aDispatchSpecification&gt;        of the published object. "	| resultValue |	resultValue := ( MessageSend forReceiver: self publishedObject		selector: aDispatchSpecification selector )			evaluateWithArguments: arguments.	( resultReference notNil	and: [ aDispatchSpecification setSpecification hasParameters	and: [ aDispatchSpecification setSpecification hasResult ] ] )		ifTrue: [			resultReference				typeCode: aDispatchSpecification setSpecification typeCode;				value: resultValue ].	^S_OK</body><body package="Com- Automation">invokePropertySet: aDispatchSpecification lcid: lcid dispParams: dispParams resultReference: resultReference exceptionInfo: exceptionInfoReference argError: argErrorReference	| arguments setSpecification hresult |	aDispatchSpecification isReadOnly		ifTrue: 			[exceptionInfoReference value: (self						createExceptionInfoWith: (#CantSetReadOnlyProperty &lt;&lt; #com								&gt;&gt; 'Cannot set value of readOnly property &lt;1s&gt;.'									expandMacrosWith: aDispatchSpecification name)).			^DISP_E_EXCEPTION].	setSpecification := aDispatchSpecification setSpecification.	(dispParams argumentCount &lt; setSpecification requiredParameterCount		or: [dispParams argumentCount &gt; setSpecification parameterCount])			ifTrue: [^DISP_E_BADPARAMCOUNT].	arguments := self valueAdaptor				argumentsForPropertySet: setSpecification				parameters: dispParams				localeID: lcid.	arguments isInteger		ifTrue: 			[argErrorReference value: arguments.			^DISP_E_TYPEMISMATCH].	hresult := self				invokePropertySet: setSpecification				arguments: (arguments collect: [:each | each value])				resultReference: resultReference.	(hresult succeeded and: [(COMVariant isValid: resultReference value) not])		ifTrue: 			[exceptionInfoReference				value: (self createInvalidResultExceptionInfo: resultReference value).			^DISP_E_EXCEPTION].	^hresult</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>subclass-accessing</category><body package="Com- Automation">getInterfaceForIID: iid		" Private - answer the interface identified by the GUID &lt;iid&gt;.		Answer nil if the requested interface is not supported by the receiver. "	( iid = IID_IDispatch	or: [ iid = self dispatchInterfaceIID ] )		ifTrue: [ ^self dispatchInterface ]. 	^super getInterfaceForIID: iid</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>subclass-releasing</category><body package="Com- Automation">forceRelease	" Private - attempt to forcibly release the receiver.  Answer whether successful.  This is a dangerous thing to do and is primarily a developer debugging facility. "	self isRegistered		ifTrue: [			( Dialog confirm: ((#ActiveObjectRevokedBeforeRelease &lt;&lt; #com &gt;&gt; 'The active object registration of &lt;1s&gt; must be revoked before it can be released.  Proceed?')			expandMacrosWith: self printString) )				ifFalse: [ ^false ].			self revokeActiveObject ].	^super forceRelease</body><body package="Com- Automation">releaseResources	" Private - release resources associated with the receiver. "	self revokeActiveObject.	super releaseResources.</body><body package="Com- Automation">revokeActiveObject	"Revoke the registration of an active automation object, using the registration token obtained from RegisterActiveObject."	self registrationToken notNil		ifTrue: [			| connectionToken |			connectionToken := self registrationToken.			self registrationToken: nil.			self class revokeActiveObject: connectionToken ].</body></methods><methods><class-id>External.COMDispatchObject</class-id> <category>subclass-error handling</category><body package="Com- Automation">createInvalidResultExceptionInfo: resultValue	" Private - construct the exception information to describe an invalid result value. "	^self createExceptionInfoWith:		((#ResultCannotBeMapped &lt;&lt; #com &gt;&gt; 'The result cannot be mapped to a COM Automation data type. The class of the value is &lt;1s&gt; and the value is &lt;2s&gt;.')			expandMacrosWith: resultValue class name			with: resultValue printString).</body></methods><methods><class-id>External.COMDispatchObject class</class-id> <category>instance creation</category><body package="Com- Automation">on: anObject		" Answer a new instance of the receiver which publishes &lt;anObject&gt;		as a COM automation object which supports IDispatch. "	^self new		publishedObject: anObject;		yourself</body></methods><methods><class-id>External.COMDualInterfaceObject</class-id> <category>accessing</category><body package="Com- Automation">clsid: aGUID	"Set the CLSID supported by the receiver to &lt;aGUID&gt;.  Since CLSID is already known for a dual interface object, do nothing. "		aGUID ~= self clsid		ifTrue: [ COMDevelopmentWarning raiseSignal: (#ErrNamedBadCLSID &lt;&lt; #com &gt;&gt;  'Trying to set inconsistent CLSID on &lt;1p&gt;' expandMacrosWith:self) ].</body><body package="Com- Automation">dispatchInterfaceIID	"Answer the IID of the dispatch interface which is supported by the receiver."	^self class dispatchInterfaceIID</body><body package="Com- Automation">dualInterfaceClass	"Answer the dual interface class of the receiver, a subclass of COMDispatchInterface."	^self class dualInterfaceClass</body><body package="Com- Automation">enumConstantNamed: aName	"Compatibility to COMDispatchDriver"	^ self typeLibraries enumConstantNamed: aName</body><body package="Com- Automation">enumConstantNamed: constant inTypeNamed: typeName	"Compatibility to COMDispatchDriver"	^ self typeLibraries detect: [:typeLib | typeLib enumConstantNamed: constant inTypeNamed: typeName ] ifNone: [ nil ]</body><body package="Com- Automation">specificationTable	"Private. Answer the receiver's specification table for dispatching method and property member invocations."	^self class specificationTable</body><body package="Com- Automation">specificationTable: aSpecificationTable	"Private. Set the receiver's specification table for dispatching method and property member invocations. Save the IID from the table in the receiver."	self class specificationTable: aSpecificationTable</body><body package="Com- Automation">typeLibraries	"Answer the type library dictionary. The dictionary keys are LCIDs and the values are instances of COMTypeLibrary."	^self class typeLibraries</body><body package="Com- Automation">typeLibraries: aDictionary	"Set the type library dictionary. The keys are LCIDs."	self class typeLibraries: aDictionary</body><body package="Com- Automation">useAdaptorBinding	"Answer whether or not to use an interface adaptor."	^self class useAdaptorBinding</body></methods><methods><class-id>External.COMDualInterfaceObject</class-id> <category>subclass-initializing</category><body package="Com- Automation">createIDispatch	"Private. Create a dual interface on the receiver."	^self useAdaptorBinding		ifTrue: [ self dualInterfaceClass adaptorBindingOn: self ]		ifFalse: [ self dualInterfaceClass directBindingOn: self ]</body></methods><methods><class-id>External.COMDualInterfaceObject class</class-id> <category>accessing</category><body package="Com- Automation">dispatchInterfaceIID	"Answer the IID of the dispatch interface which is supported by the receiver."	^self dualInterfaceClass iid</body><body package="Com- Automation">dualInterfaceClass	"Answer the dual interface class of the receiver, a subclass of COMDispatchInterface."	^dualInterfaceClass</body><body package="Com- Automation">dualInterfaceClass: aClass	"Set the dual interface class of the receiver, a subclass of COMDispatchInterface."	dualInterfaceClass := aClass</body><body package="Com- Automation">specificationTable	"Private. Answer the receiver's specification table for dispatching method and property member invocations. May be nil."	^specificationTable</body><body package="Com- Automation">specificationTable: aSpecificationTable	"Private. Set the receiver's specification table for dispatching method and property member invocations. May be nil."	specificationTable := aSpecificationTable</body><body package="Com- Automation">typeLibraries	"Answer the type library dictionary. The dictionary keys are LCIDs and the values are instances of COMTypeLibrary. If the receiver has type libraries, then register event handlers to perform clean up operations. Answer nil or a Dictionary."	typeLibraries isNil 		ifTrue: [ 			| tmp |			tmp := self getTypeLibrariesForAllLanguages.			tmp size &gt; 0				ifTrue: [ self registerTypeLibraryEventHandlers ].			typeLibraries := tmp ]. 	^typeLibraries</body><body package="Com- Automation">typeLibraries: aDictionary	"Set the type library dictionary. The keys are LCIDs."	typeLibraries := aDictionary</body><body package="Com- Automation">useAdaptorBinding	"Answer whether or not to use an interface adaptor."	^useAdaptorBinding</body><body package="Com- Automation">useAdaptorBinding: aBoolean	"Set whether or not to use an interface adaptor."	useAdaptorBinding := aBoolean</body></methods><methods><class-id>External.COMDualInterfaceObject class</class-id> <category>type libraries</category><body package="Com- Automation">getTypeLibraries	"Concrete suclasses should reimplement this message when one or more type libraries exists for an object."	^nil</body><body package="Com- Automation">getTypeLibrariesForAllLanguages	"Make a dictionary of all type libraries. The keys are LCIDs. Answer nil or a new Dictionary."	| collection libs |	collection := self getTypeLibraries.	collection isNil ifTrue: [ ^nil ].	libs := Dictionary new.	collection do: [ : aTypeLibrary |		libs at: aTypeLibrary lcid put: aTypeLibrary ].	^libs</body><body package="Com- Automation">hasTypeLibraries	"Answer whether there are any type library objects."	| libs |	libs := self typeLibraries.	libs isNil ifTrue: [ ^nil ].	^libs notEmpty</body><body package="Com- Automation">registerTypeLibraries	"Register the type libraries." 	self typeLibrariesDo: [ : aTypeLibrary | aTypeLibrary createRegistration ]</body><body package="Com- Automation">releaseTypeLibraries	"Release the type libraries."	| toBeReleased |	"This test does not use self to avoid loading."	typeLibraries isNil ifTrue: [ ^self ].	toBeReleased := typeLibraries.	typeLibraries := nil.	toBeReleased do: [ : aTypeLibrary | aTypeLibrary enforceRelease ].</body><body package="Com- Automation">typeLibrariesDo: aOneArgBlock 	"Evaluate &lt;aOneArgBlock&gt; for each non-nil type library entry."	| libs |	libs := self typeLibraries.	libs isNil ifTrue: [^self].	libs do: [:aTypeLibrary | aTypeLibrary notNil ifTrue: [aOneArgBlock value: aTypeLibrary]]</body><body package="Com- Automation">typeLibraryEnglish	"Answer a type library for the english language for the application or nil."	^self typeLibraries at: Win32ExternalInterface lcidEnglish ifAbsent: [ nil ]</body><body package="Com- Automation">typeLibraryNeutral	"Answer a type library for the english language for the application or nil."	^self typeLibraries at: Win32ExternalInterface lcidNeutral ifAbsent: [ nil ]</body><body package="Com- Automation">unregisterTypeLibraries	"Unregister the type libraries." 	self typeLibrariesDo: [ : aTypeLibrary | aTypeLibrary removeRegistration ]</body><body package="Com- Automation">updateTypeLibraries	"Update the registry for each type library defined by the application. See also COMTypeLibrary&gt;&gt;updateRegistration."	self typeLibrariesDo: [ : aTypeLibrary | aTypeLibrary updateRegistration ]</body></methods><methods><class-id>External.COMDualInterfaceObject class</class-id> <category>obsolete</category><body package="Com- Automation">registerServer	"registerServer was renamed to registerClassFactoryAndLibraries in COM 1.1e patches. 	 This method is for backwards-compatibility [AA 08/2004]"	^ self registerClassFactoryAndLibraries</body></methods><methods><class-id>External.COMDualInterfaceObject class</class-id> <category>private-initialization</category><body package="Com- Automation">finalize	"Finalize the receiver."	self 		clsid: nil;		dualInterfaceClass: nil;		useAdaptorBinding: nil;		specificationTable: nil;		removeSessionEventHandlers.</body><body package="Com- Automation">initialize	"Initialize the receiver."	self useAdaptorBinding: false</body><body package="Com- Automation">obsolete	"The receiver was removed from the system and is now obsolete. Perform any necessary clean-up. Answer the receiver."	self finalize.	^super obsolete</body></methods><methods><class-id>External.COMDualInterfaceObject class</class-id> <category>session management</category><body package="Com- Automation">registerClassFactoryAndLibraries	"Make sure the type libraries are ok and register the class factory for the object server application. This method can be invoked to test a COM object from the same image it will be published from or during server application startup.  Answer the class factory."	self updateTypeLibraries.	^self registerServerClassFactory</body><body package="Com- Automation">registerStartUpApplicationEventHandler	"Install the event handler for a receiver that is the main object in the COM object model. This object will receive the #startUpApplication message when a deployment image is started."	COMSystem current 		when: #deploymentStartup		send: #startUpApplication to: self.</body><body package="Com- Automation">registerTypeLibraryEventHandlers	"Install the event handlers for the receiver."	COMSessionManager 		when: #shutdownImage		send: #releaseTypeLibraries to: self.	COMSessionManager 		when: #confirmSaveImage		send: #releaseTypeLibraries to: self</body><body package="Com- Automation">removeSessionEventHandlers	"Remove the registration of any session event handlers for the receiver."	COMSystem current removeAllActionsWithReceiver: self.	COMSessionManager removeAllActionsWithReceiver: self.</body><body package="Com- Automation">startUpApplication	"Start up the Automation object server."	"Initialize COM and verify that the application is being run as an object server."	COMSessionManager initializeAutomationServer.	"Make sure the type libraries are ok and register the class factory for the object server application. This method can be invoked to test a COM object from the same image it will be published from."	self registerClassFactoryAndLibraries.	"Arrange for server application termination "	COMSessionManager exitIfNotInUse: false.</body></methods><methods><class-id>External.COMDualInterfaceObject class</class-id> <category>installation</category><body package="Com- Automation">installRuntime	" Prepare the receiver for deployment in a runtime image configuration as the main top level object in the application model.  Each subclass can extend this method and place installation code in it.  You should make sure this version gets called in any case. 	The following takes place in the default implementation of #installRuntime	1) Check that we are not installing an abstract superclass by accident.	2) Run initialize. The class initializer should have done the #initialize, but we want to start fresh.	3) Register to receceive #startUpApplication.	4) Release and register type libraries."	| abstractClasses |	abstractClasses := ( OrderedCollection new		add: Object; 		add: COMObject; 		add: COMAutomationObject; 		add: COMDispatchObject;		add: COMDualInterfaceObject;		yourself ).	( abstractClasses includes: self )		ifTrue: [ ^self error: #ErrShouldNotInstallAbsCls &lt;&lt; #com &gt;&gt; 'Should not install an abstract class.' ].	"The class initializer should have done the #initialize, but we want to start fresh."	self initialize.	self registerStartUpApplicationEventHandler.	self releaseTypeLibraries.	self registerTypeLibraries.</body><body package="Com- Automation">unregister	"Uninstall this Automation server sample."	" self unregister "	self unregisterTypeLibraries.	self releaseTypeLibraries.	self removeSessionEventHandlers.</body></methods><methods><class-id>Examples.AutomationApplication</class-id> <category>notices</category><body package="Com- Automation">enforceRelease	^ self privateRelease.</body></methods><methods><class-id>Examples.AutomationApplication</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	^ self needsFinalization</body></methods><methods><class-id>Examples.AutomationApplication</class-id> <category>releasing</category><body package="Com- Automation">release	"Make the application quit and release the receiver's resources."	self callIsDispensable.	^ self privateRelease.</body><body package="Com- Automation">releaseApplication	"Default - do nothing. Subclasses may call Quit or something"	self application: nil.</body></methods><methods><class-id>Examples.AutomationApplication</class-id> <category>accessing</category><body package="Com- Automation">application	"Answer the Excel Application controller."	application isNil		ifTrue: 			[self				application: (COMDispatchDriver createObject: self class applicationName						specificationPolicy: self class specificationPolicy).			self class eventSpecificationTable				ifNotNil: [:table | self application eventSpecificationTable: table].			self class specificationTable				ifNotNil: [:table | self application specificationTable: table]].	^application</body><body package="Com- Automation">application: aDispatchDriver	"Answer the Excel Application controller."	application		ifNotNil: 			[SystemGlobalRegistries unprotect: application referencedBy: self.			application enforceRelease].	application := aDispatchDriver.	application		ifNotNil: [SystemGlobalRegistries safe: application forLifeTimeOf: self]</body></methods><methods><class-id>Examples.AutomationApplication</class-id> <category>private</category><body package="Com- Automation">privateRelease	"Make the application quit and release the receiver's resources."	self releaseApplication.	^super release</body></methods><methods><class-id>Examples.AutomationApplication</class-id> <category>finalization</category><body package="Com- Automation">finalize	^ self privateRelease</body></methods><methods><class-id>Examples.AutomationApplication class</class-id> <category>accessing</category><body package="Com- Automation">applicationName	self subclassResponsibility</body><body package="Com- Automation">specificationPolicy	^COMSpecificationPolicy perform: self specificationPolicyName</body><body package="Com- Automation">specificationPolicyName	^ defaultSpecificationPolicy ifNil: [ COMSpecificationPolicy defaultPolicy ]</body><body package="Com- Automation">specificationPolicyName: aPolicy	defaultSpecificationPolicy := aPolicy.</body></methods><methods><class-id>Examples.AutomationApplication class</class-id> <category>specification table support</category><body package="Com- Automation">eventSpecificationTable	^self literalEventSpecification decodeAsLiteralArray</body><body package="Com- Automation">literalEventSpecification	^ nil</body><body package="Com- Automation">literalSpecification	^ nil</body><body package="Com- Automation">specificationTable	^ self literalSpecification decodeAsLiteralArray</body></methods><methods><class-id>Examples.AutomationApplication class</class-id> <category>instance creation</category><body package="Com- Automation">new	^ super new initialize</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>private testing</category><body package="Com- Automation">isPointerByref		"Answer whether a pointer of my type is byref. A simple Interface Pointer is not a byref parameter"	^ false</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">cType	^ COMExternalInterface externals at: #__IAnonymous</body><body package="Com- Automation">methods	^ self elements</body><body package="Com- Automation">pointerTypeCode	^ self typecode</body><body package="Com- Automation">specificationTable	self subclassResponsibility</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>comparing</category><body package="Com- Automation">equalsCOMTypeSpec: anotherDescriptor	^anotherDescriptor class = self class		and: [anotherDescriptor guid = self guid]</body><body package="Com- Automation">hash	^ self guid hash</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>printing</category><body package="Com- Automation">printPtrTypeOn: aStream	self printOn: aStream name: self name, 'Pointer'.</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>converting</category><body package="Com- Automation">asTypeInfoUsing: aTypeLib	^ aTypeLib typeInfoOfGuidAt: self guid</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>private</category><body package="Com- Automation">guidName	^ 'IID'</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>testing</category><body package="Com- Automation">isClassOrInterface	^ true</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">createPtrPtrOutArgument	^ COMInterfacePointer resultValueBufferForIID: self iid</body><body package="Com- Automation">freePtrArgument: anArgument	^ self</body><body package="Com- Automation">iid	self subclassResponsibility</body><body package="Com- Automation">invalidatePtrInParameterValueIn: aSmalltalkValue	self shouldNotImplement.</body><body package="Com- Automation">invalidatePtrPtrInParameterValueIn: aSmalltalkValue	aSmalltalkValue value enforceInvalidation</body><body package="Com- Automation">marshalInArgument: anArgument	^ self shouldNotImplement</body><body package="Com- Automation">newResultPtrPtrParameter	^ COMInterfaceValueReference forIID: self iid</body><body package="Com- Automation">releaseRecordElement: aVariant	"Fort interfaces we should release the variant - for update the reference count"	^ aVariant refVariantValue clear</body><body package="Com- Automation">releaseServerArgument: anArg	anArg isCOMInterfacePointer ifTrue: [ anArg enforceRelease ].</body><body package="Com- Automation">unmarshalOutParam: aParam	self shouldNotImplement</body><body package="Com- Automation">unmarshalPtrAutomationResult: aValue into: aResultReference	"the result is not an out value - do nothing. We need a PtrPtr to this type to mark an out value"	^ self</body><body package="Com- Automation">unmarshalPtrPtrOutParameter: aMarshaledValue into: aSmalltalkValue	aSmalltalkValue value: (aMarshaledValue contents				ifNil: [nil]				ifNotNil: [:value | value asInterfaceReference])</body></methods><methods><class-id>External.DispObjectTypeSpec</class-id> <category>testing variant</category><body package="Com- Automation">variantContainsRefValue: aVariant	"does the variant contain a valid pointer. We don't use the refVariantValue here 	 since objects are described as VT_??? | VT_PTR "	^ (aVariant valueAt: #pdispVal) isValid</body></methods><methods><class-id>External.DispObjectTypeSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds		^ #()</body></methods><methods><class-id>External.InterfaceTypeSpec</class-id> <category>browser support</category><body package="Com- Automation">elements	"return all possible protocol items"	^self specificationTable values</body></methods><methods><class-id>External.InterfaceTypeSpec</class-id> <category>private testing</category><body package="Com- Automation">isDualInterface	^(self typeFlags bitAnd: TYPEFLAG_FDUAL) = TYPEFLAG_FDUAL</body><body package="Com- Automation">representsDispatch	^  self typekind = TKIND_DISPATCH</body><body package="Com- Automation">representsVTableInterface	^  self typekind = TKIND_INTERFACE</body></methods><methods><class-id>External.InterfaceTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">iid	^ self guid</body><body package="Com- Automation">marshalPointerArgument: anArgument	^ anArgument interfaceForIID: self guid</body></methods><methods><class-id>External.InterfaceTypeSpec</class-id> <category>private</category><body package="Com- Automation">defaultInterfaceClass	self subclassResponsibility</body><body package="Com- Automation">specificationTable	"Return the specification table for this interface. This should be only called on interfaces"	| tableClass |	tableClass := self specificationTableClass.	^tableClass specificationTableForGuid: self guid		ifAbsentPut: [tableClass specificationTableFor: self asTypeInfo specificationKey: #name]</body><body package="Com- Automation">specificationTableClass	self subclassResponsibility</body></methods><methods><class-id>External.InterfaceTypeSpec</class-id> <category>converting</category><body package="Com- Automation">dispatchType	self subclassResponsibility</body><body package="Com- Automation">representationForTypekind: aTypeKind	^aTypeKind = self typekind ifTrue: [self] ifFalse: [self alternativeRepresentation]</body><body package="Com- Automation">vtableType	self subclassResponsibility</body></methods><methods><class-id>External.InterfaceTypeSpec</class-id> <category>testing</category><body package="Com- Automation">isDispatch	^ false</body><body package="Com- Automation">isInterface	^ true</body></methods><methods><class-id>External.InterfaceTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">alternativeRepresentation	^self isDualInterface		ifTrue: 			[alternativeRepresentation				ifNil: [alternativeRepresentation := self computerAlternativeRepresentation]]		ifFalse: [nil]</body><body package="Com- Automation">computerAlternativeRepresentation	"Compute the alternative representation for a Dual Interface - that is, vor a DispatchSpec compute the VTable spec and the 	other way around"	| typeInfo typeInfo2 |	typeInfo := self asTypeInfo.	typeInfo2 := typeInfo alternativeTypeInfo.	^typeInfo2 ifNotNil: [DispUserDefTypeSpec fromTypeInfo: typeInfo2]</body></methods><methods><class-id>External.InterfaceTypeSpec</class-id> <category>unknown protocol</category><body package="Com- Automation">asTypeInfo	^super asTypeInfo		ifNotNil: 			[:typeInfo |			typeInfo typekind = self typekind				ifTrue: [typeInfo]				ifFalse: [typeInfo alternativeTypeInfo]]</body></methods><methods><class-id>External.InterfaceTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">name: aName iid: anIID	| docs |	docs := (Dictionary new)				at: 'name' put: aName;				yourself.	^(self new)		typelib: nil;		docs: docs;		typeFlags: 0;		guid: anIID;		yourself</body></methods><methods><class-id>COMSafeArrayAccessor</class-id> <category>private accessing</category><body package="Com- Automation">at: indices putArray: anArray        " Private - Set the elements indexed at &lt;indices&gt; to &lt;anArray&gt;.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices.        Passing in an empty Array for &lt;indices&gt; sets all the        elements in the receiver. "    | upperBound runningCoords changeIndex |    upperBound := safeArray elementCountAt: indices size + 1.    anArray size &lt; upperBound        ifTrue: [ upperBound := anArray size ].    runningCoords := indices, #( 0 ).    changeIndex := runningCoords size.    1 to: upperBound do: [ : index |        runningCoords at: changeIndex put: index.        self            privateAt: runningCoords            put: ( anArray at: index ) ].</body><body package="Com- Automation">at: indices putElement: aValue        " Private - Set the element indexed at &lt;indices&gt; to in &lt;aValue&gt;.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "    OLEAutomationDLL current SafeArrayPutElement: safeArray        _: ( self normalizeCoordinates: indices )        _: aValue.</body><body package="Com- Automation">checkCoordinates: indices        " Private - Check the given coordinates"    1 to: indices size do: [ : index |           (( indices at: index )  between: 1 and: ( safeArray elementCountAt: index ))		ifFalse: [^ false ].    ].    ^ true</body><body package="Com- Automation">collectionAt: indices collectionClass: aCollectionClass        " Private - Answer a &lt;aCollectionClass&gt; of elements indexed at &lt;indices&gt;.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices.        If an element is an interface, AddRef is called on that interface by COM from SafeArrayGetElement before returning.        Passing in an empty Array for &lt;indices&gt; answers all the        elements in the receiver. "    | upperBound answer runningCoords changeIndex |    upperBound := safeArray elementCountAt: indices size + 1.    answer := aCollectionClass new: upperBound.    (self checkCoordinates: indices) ifFalse: [ ^ safeArray errorInvalidIndex ].    runningCoords := indices, #( 0 ).    changeIndex := runningCoords size.    1 to: upperBound do: [ : index |        runningCoords at: changeIndex put: index.        answer            at: index            put: ( self privateAt: runningCoords ) ].    ^answer</body><body package="Com- Automation">elementAt: indices        " Private - Answer the value at &lt;indices&gt;.        If the element is an interface, the API calls AddRef on the interface before returning.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "	| resultReference |	resultReference := nil asValueReference.	OLEAutomationDLL current SafeArrayGetElement: safeArray		_: ( self normalizeCoordinates: indices )		_: resultReference.	^resultReference value</body><body package="Com- Automation">normalizeCoordinates: indices        " Private - Answer a new Array with the &lt;indices&gt; normalized to 0-based indexing        and accounting for the lower bound of each dimension. "    | answer |    answer := Array new: indices size.    1 to: answer size do: [ : index |        answer            at: index            put: ( ( indices at: index ) - 1 + ( safeArray lowerBoundAt: index ) )    ].    ^answer</body><body package="Com- Automation">privateArrayAt: indices        " Private - Answer an Array of elements indexed at &lt;indices&gt;.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices.        If an element is an interface, AddRef is called on that interface by COM from SafeArrayGetElement before returning.        Passing in an empty Array for &lt;indices&gt; answers all the elements in the receiver. "	^self collectionAt: indices collectionClass: Array</body><body package="Com- Automation">privateAt: indices        " Answer the element of the array at the position specified by &lt;indices&gt;.        If the element is an interface, the API calls AddRef on the interface before returning.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "    | depth |    depth := safeArray cDims - indices size.    depth &lt; 0        ifTrue: [ COMError raiseSignal: #ErrInvalidIndicies &lt;&lt; #com &gt;&gt; 'Invalid array indices.' ].    depth = 0        ifTrue: [ ^self elementAt: indices ].    ^self privateArrayAt: indices</body><body package="Com- Automation">privateAt: indices put: aValue    | depth | depth := safeArray cDims - indices size.    depth &lt; 0        ifTrue: [ COMError raiseSignal: #ErrInvalidIndicies &lt;&lt; #com &gt;&gt; 'Invalid array indices.' ].    depth = 0        ifTrue: [ ^self at: indices putElement: aValue ].    ^ self at: indices putArray: aValue</body><body package="Com- Automation">safeArray	^safeArray</body><body package="Com- Automation">setMultidimensionalCollection: aCollection 	aCollection 		keysAndValuesDo: [:key :value | value isNil ifFalse: [self at: key putElement: value]]</body><body package="Com- Automation">wrapIndex: index	^index isCollection ifTrue: [index] ifFalse: [Array with: index]</body></methods><methods><class-id>COMSafeArrayAccessor</class-id> <category>accessing safearray elements</category><body package="Com- Automation">asCollectionOfClass: aCollectionClass        " Private - Answer a &lt;aCollectionClass&gt;. If an element is an interface, AddRef is called on that interface by COM from SafeArrayGetElement before returning. Passing in an empty Array for &lt;indices&gt; answers all the elements in the receiver. "	^self collectionAt: #( ) collectionClass: aCollectionClass</body><body package="Com- Automation">at: indices        " Answer the element of the array at the position specified by &lt;indices&gt;.        If the element is an interface, the API calls AddRef on the interface before returning.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "   ^ self privateAt: (self wrapIndex: indices)</body><body package="Com- Automation">at: indices put: aValue	^ self privateAt: (self wrapIndex: indices) put: aValue</body><body package="Com- Automation">setCollection: aCollection 	" Private - Set the values in receiver to the ones in &lt;aCollection&gt;. "	^aCollection isMultidimensional 		ifTrue: [self setMultidimensionalCollection: aCollection]		ifFalse: [self at: #() putArray: aCollection]</body></methods><methods><class-id>COMSafeArrayAccessor</class-id> <category>initialize-release</category><body package="Com- Automation">safeArray: anObject	safeArray := anObject</body></methods><methods><class-id>COMSafeArrayAccessor class</class-id> <category>private</category><body package="Com- Automation">classFor: aSafeArray	| currClass |	self useOptimization ifFalse: [ ^ self].	currClass := self.	self allSubclassesDo: [:each |		((each supports: aSafeArray) and: [(each isBetterThan: currClass) ])  ifTrue: [ currClass := each] ].	^ currClass</body><body package="Com- Automation">isBetterThan: aClass	^ self includesBehavior: aClass</body><body package="Com- Automation">supports: aSafeArray	self subclassResponsibility</body></methods><methods><class-id>COMSafeArrayAccessor class</class-id> <category>instance creation</category><body package="Com- Automation">onSafeArray: aSafeArray	^ (self classFor: aSafeArray) new		safeArray: aSafeArray;		yourself</body></methods><methods><class-id>COMSafeArrayAccessor class</class-id> <category>accessing</category><body package="Com- Automation">useOptimization	^UseOptimization</body><body package="Com- Automation">useOptimization: aBoolean	^ UseOptimization := aBoolean</body></methods><methods><class-id>COMPrimitiveSafeArrayAccessor</class-id> <category>accessing safearray elements</category><body package="Com- Automation">asCollectionOfClass: aCollectionClass        " Private - Answer a &lt;aCollectionClass&gt;. If an element is an interface, AddRef is called on that interface by COM from SafeArrayGetElement before returning. Passing in an empty Array for &lt;indices&gt; answers all the elements in the receiver. "	^ self withLockedSafeArrayDo: [ super asCollectionOfClass: aCollectionClass ]</body><body package="Com- Automation">at: indices 	" Answer the element of the array at the position specified by &lt;indices&gt;.        If the element is an interface, the API calls AddRef on the interface before returning.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "	^self withLockedSafeArrayDo: [super at: indices]</body><body package="Com- Automation">at: indices put: aValue	^ self withLockedSafeArrayDo: [ super at: indices put: aValue ]</body><body package="Com- Automation">setCollection: aCollection 	" Private - Set the values in receiver to the ones in &lt;aCollection&gt;. "	^aCollection isMultidimensional 		ifTrue: [self setMultidimensionalCollection: aCollection]		ifFalse: [self at: #() put: aCollection]</body></methods><methods><class-id>COMPrimitiveSafeArrayAccessor</class-id> <category>private accessing</category><body package="Com- Automation">at: indices putBasicCollection: aCollection	"put a one-dimensional collection into the safearray at the given position."	| dll elSize ptr var index |	aCollection isEmpty ifTrue: [^self].	dll := OLEAutomationDLL current.	index := indices copyWith: (safeArray lowerBoundAt: indices size + 1).	ptr := dll safeArrayPtrOfIndex: safeArray index: index.	elSize := dll SafeArrayGetElemsize: safeArray.	var := COMVariantValue type: safeArray typeCode pointer: ptr.	aCollection do: 			[:each |			[var value: each] on: VariantChangeTypeNotification				do: [^COMError hresult: External.COMStatusCodeConstants.E_INVALIDARG].			var structure datum: var structure datum + elSize]</body><body package="Com- Automation">basicCollectionAt: indices	| dll elSize ptr var lowIndex numElements collection |	dll := OLEAutomationDLL current.	lowIndex := indices copyWith: 1.	lowIndex := self normalizeCoordinates: lowIndex.	numElements := safeArray elementCountAt: lowIndex size.	numElements = 0 ifTrue: [^ #() ].	ptr := dll safeArrayPtrOfIndex: safeArray index: lowIndex.	elSize := dll SafeArrayGetElemsize: safeArray.	collection := self collectionClass new: numElements.	var := COMVariantValue type: safeArray typeCode pointer: ptr.	1 to: numElements  do: [:index | 		collection at: index put: var value.		var structure datum: var structure datum + elSize. ].	^ collection</body><body package="Com- Automation">collectionAt: indices collectionClass: aCollectionClass        " Private - Answer a &lt;aCollectionClass&gt; of elements indexed at &lt;indices&gt;.     	  If we still are not at the lowest level of the savearray, use the super implementation, otherwise	  use the optimized version"	| collection |	^ (safeArray dimensions - (indices size)) &gt; 1 		ifTrue: [ super collectionAt: indices collectionClass: aCollectionClass ]		ifFalse: [ 			collection := self privateAt: indices.			collection class = aCollectionClass 				ifTrue: [ collection ]				ifFalse:[ aCollectionClass withAll: collection ]]</body><body package="Com- Automation">collectionClass	^ Array</body><body package="Com- Automation">privateAt: indices        " Answer the element of the array at the position specified by &lt;indices&gt;.        If the element is an interface, the API calls AddRef on the interface before returning.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "    | depth |    depth := safeArray cDims - indices size.    depth &lt; 0        ifTrue: [ COMError raiseSignal: #ErrInvalidIndicies &lt;&lt; #com &gt;&gt; 'Invalid array indices.' ].    depth = 1 	  ifTrue: [ ^ self basicCollectionAt: indices ].    depth = 0        ifTrue: [ ^self elementAt: indices ].    ^self privateArrayAt: indices</body><body package="Com- Automation">privateAt: indices put: aValue	| depth |	depth := safeArray cDims - indices size.    	depth &lt; 0        	ifTrue: [ COMError raiseSignal: #ErrInvalidIndicies &lt;&lt; #com &gt;&gt; 'Invalid array indices.' ].   	depth = 1 		ifTrue: [ ^ self at: indices putBasicCollection: aValue. ].   	depth = 0		ifTrue: [ ^self at: indices putElement: aValue ].    ^ self at: indices putArray: aValue</body></methods><methods><class-id>COMPrimitiveSafeArrayAccessor</class-id> <category>private locking</category><body package="Com- Automation">withLockedSafeArrayDo: aBlock	"perform the block with the safearray locked"	safeArray lock.	^ aBlock ensure: [ safeArray unlock ].</body></methods><methods><class-id>COMPrimitiveSafeArrayAccessor class</class-id> <category>private</category><body package="Com- Automation">initializeSupportedTypeCodes	^  SupportedTypeCodes := Set new		add: VT_I1;		add: VT_I2;		add: VT_I4;		add: VT_I8;		add: VT_UI1;		add: VT_UI2;		add: VT_UI4;		add: VT_UI8;		add: VT_INT;		add: VT_UINT;		add: VT_R4;		add: VT_R8;		yourself</body><body package="Com- Automation">supports: aSafeArray	^ (self typeCodes includes: aSafeArray typeCode)		and: [ aSafeArray dimensions = 1 ]</body><body package="Com- Automation">typeCodes	^ SupportedTypeCodes ifNil: [ SupportedTypeCodes := self initializeSupportedTypeCodes ]</body></methods><methods><class-id>COMSpecificPrimSafeArrayAccessor</class-id> <category>private accessing</category><body package="Com- Automation">at: indices putBasicCollection: aCollection 	"put a one-dimensional collection into the safearray at the given position."	| ptr index newColl |	aCollection isEmpty ifTrue: [ ^ self ]. 	newColl := (aCollection isKindOf: self collectionClass)		ifTrue: 	[ aCollection ]		ifFalse:	[ self collectionClass withAll: aCollection ].	index := indices copyWith: 1.	index := self normalizeCoordinates: index.	ptr := OLEAutomationDLL current safeArrayPtrOfIndex: safeArray index: index.	ptr copyAt: 0		from: newColl		size: newColl sizeInBytes		startingAt: 1.</body><body package="Com- Automation">basicCollectionAt: indices 	| dll elSize ptr lowIndex numElements collection |	dll := OLEAutomationDLL current.	lowIndex := indices copyWith: 1.	numElements := safeArray elementCountAt: lowIndex size.	(numElements = 0) ifTrue: [^ #() ].	lowIndex := self normalizeCoordinates: lowIndex.	ptr := dll safeArrayPtrOfIndex: safeArray index: lowIndex.	elSize := safeArray elementSize.	collection := self collectionClass new: numElements.	ptr 		copyAt: 0		to: collection		size: elSize * numElements		startingAt: 1.	^collection</body><body package="Com- Automation">collectionClass	^ self subclassResponsibility</body></methods><methods><class-id>COMSpecificPrimSafeArrayAccessor class</class-id> <category>private</category><body package="Com- Automation">supports: aSafeArray	"I am an abstract class and do not support any specific type of SAFEARRAY content."	^false</body></methods><methods><class-id>COMByteSafeArrayAccessor</class-id> <category>private accessing</category><body package="Com- Automation">collectionClass	^ ByteArray</body></methods><methods><class-id>COMByteSafeArrayAccessor class</class-id> <category>private</category><body package="Com- Automation">supports: aSafeArray	"I support linear safearray of type VT_UI1."	^ (aSafeArray typeCode = VT_UI1)		and: [ aSafeArray dimensions = 1 ]</body></methods><methods><class-id>External.COMSafeArrayPointerResultBuffer</class-id> <category>private-operation</category><body package="Com- Automation">assumeOwnershipOfResources: anArray	" The values in &lt;anArray&gt; have just been brought into the system.  Assume ownership responsibility for any COM interfaces and memory in the elements in &lt;anArray&gt;. "	COMSafeArray enumerateInterfacesIn: anArray		do: [ :anElement |			" safe array unpacking shouldn't acquire ownership, we only know 				enough to do that correctly at a point such as this where				we know that resources are entering the system and thus				becoming our responsibility (well, someone's, anyway) "			"Assert isTrue: [ anElement interfaceBinding hasFinalization not ]."			anElement interfaceBinding needsFinalization ].</body><body package="Com- Automation">canArrayContainOwnedResources	" Private - answer whether the array that has just been brought into the system can contain any COM resources for which we need to assume ownership responsibility. "	^typeCode = VT_DISPATCH		or: [ typeCode = VT_VARIANT  " can be anything, so we have to go look "		or: [ typeCode = VT_UNKNOWN ] ]</body></methods><methods><class-id>External.COMSafeArrayPointerResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Automation">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^COMSafeArray baseCType pointerType</body></methods><methods><class-id>External.COMSafeArrayPointerResultBuffer</class-id> <category>private-accessing</category><body package="Com- Automation">typeCode: aTypeCode	" Private - specify the variant type code of the elements in the array. "	typeCode := aTypeCode.</body></methods><methods><class-id>External.COMSafeArrayPointerResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Automation">getResultValue	" Private - convert the contents into a collection.  Release the external COM memory of the SAFEARRAY.  Answer the string. "	| lpSafeArray aSafeArrayStruct anArray |	lpSafeArray := buffer contents.	lpSafeArray isValid ifFalse: [^nil].	aSafeArrayStruct := (COM_SAFEARRAY fromReturnValue: lpSafeArray)				typeCode: typeCode;				yourself.	anArray := aSafeArrayStruct asArray.	Tools.Note ISSUE.	" Gary - shouldn't we now release the COM memory of the safe array?		(Either here, if convenient, or by reimplementing the #releaseBuffer method)		[Deb 16-May-97] "	"aSafeArrayStruct release."	^anArray</body></methods><methods><class-id>External.COMSafeArrayPointerResultBuffer class</class-id> <category>instance creation</category><body package="Com- Automation">for: aVariantTypeCode 	" Answer a new instance of the receiver which is used for bringing a COM safe array containing elements of type &lt;aVariantTypeCode&gt; in the system via a buffer in which a pointer to a SAFEARRAY is obtained. "	aVariantTypeCode isInteger 		ifFalse: [self error: #ErrMustBeVTType &lt;&lt; #com &gt;&gt; 'must specify a VT_ type code'].	"... and in the allowed range of VT_ values... "	^(self basicNew)		typeCode: aVariantTypeCode;		initialize;		yourself</body><body package="Com- Automation">new	" Answer a new instance of the receiver. "	" must specify a type code "	self shouldNotImplement.</body></methods><methods><class-id>External.ProgID class</class-id> <category>instance creation</category><body package="Com- Automation">fromCLSID: aGUID	"Answer an instance of the receiver with a representing a valid ID. &lt;aGUID&gt; can be a CLSID or a ProgID."	| id |	id := aGUID isString		ifTrue: [ aGUID asGUID ].	id isNil 		ifTrue: [ ^nil ].	^self new		id: id asProgID.</body></methods><methods><class-id>External.IClassFactory2</class-id> <category>interface operations</category><body package="Com- Automation">createInstanceLic: pUnkOuter with: pUnkReserved with: riid with: bstrKey	" Invoke the IClassFactory2::CreateInstanceLic function. "	| resultReference |	resultReference := COMInterfaceValueReference forIID: riid.	interface CreateInstanceLic: pUnkOuter _: pUnkReserved _: riid _: bstrKey _: resultReference.	^resultReference value</body><body package="Com- Automation">getLicInfo	| pLicInfo type info |	type := COMExternalInterface current LICINFO.	pLicInfo := type gcCalloc.	pLicInfo memberAt: #cbLicInfo put: type sizeof.	self getLicInfo: pLicInfo.	info := COMLicenseInfo fromLicInfo: pLicInfo.	^info</body><body package="Com- Automation">getLicInfo: pLicInfo	" Invoke the IClassFactory2::GetLicInfo function. "	" HRESULT __stdcall  GetLicInfo(LICINFO * pLicInfo) = 5 "	^interface GetLicInfo: pLicInfo</body><body package="Com- Automation">requestLicKey	^self requestLicKey: 0</body><body package="Com- Automation">requestLicKey: dwReserved	" Invoke the IClassFactory2::RequestLicKey function. "	| resultReference |	resultReference := nil asValueReference.	interface RequestLicKey: dwReserved _: resultReference.	^resultReference value</body></methods><methods><class-id>External.IClassFactory2</class-id> <category>private</category><body package="Com- Automation">privateCreateInstanceIID: anIID options: options result: resultReference	options licenseKey isNil		ifTrue: 			[^super				privateCreateInstanceIID: anIID				options: options				result: resultReference].	^interface		CreateInstanceLic: options controllingUnknown		_: nil		_: anIID		_: options licenseKey		_: resultReference</body></methods><methods><class-id>External.IClassFactory2 class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IClassFactory2.	self updateAndRegister.	self factoryClassWithLicensingSupport: self.</body></methods><methods><class-id>External.IClassFactory2 class</class-id> <category>private-installation</category><body package="Com- Automation">obsolete	self factoryClassWithLicensingSupport: nil.	^ super obsolete</body></methods><methods><class-id>External.CombindedConstantDescription</class-id> <category>comparing</category><body package="Com- Automation">= aConstantValue	^ aConstantValue equalToEnumConstant: self</body><body package="Com- Automation">equalToEnumConstant: anEnumConstant	^ self value = anEnumConstant value and: [ self name = anEnumConstant name ]</body><body package="Com- Automation">~= aConstantValue	^ (self = aConstantValue) not</body></methods><methods><class-id>External.CombindedConstantDescription</class-id> <category>accessing</category><body package="Com- Automation">constants	^constants</body><body package="Com- Automation">constants: anObject	constants := anObject</body><body package="Com- Automation">equalFromInteger: anInteger	^ self value = anInteger</body><body package="Com- Automation">name	| name |	name := String new.	self constants do: [:each | name := name , each name]		separatedBy: [name := name , ' | '].	^name</body><body package="Com- Automation">value	^self constants inject: 0 into: [:sum :each | sum bitOr: each value]</body></methods><methods><class-id>External.CombindedConstantDescription class</class-id> <category>instance creation</category><body package="Com- Automation">withConstants: anArray	^(self new)		constants: anArray;		yourself</body></methods><methods><class-id>External.IClassFactory2Implementation</class-id> <category>private-invocation</category><body package="Com- Automation">invokeCreateInstanceLic: this _: pUnkOuter _: pUnkReserved _: riid _: bstrKey _: ppvObject	" Private - invoke the IClassFactory2::CreateInstanceLic function for an external caller. "	" HRESULT __stdcall  CreateInstanceLic(IUnknown * pUnkOuter, IUnknown * pUnkReserved, REFIID riid, BSTR bstrKey, PVOID * ppvObj) = 7 "	| controllingUnknown iid |	^	[" terminate exception stack unwind at function invocation boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	(riid isValid and: [ppvObject isValid]) ifFalse: [^E_INVALIDARG].	bstrKey isValid ifFalse: [^E_INVALIDARG].	controllingUnknown := self interfaceAtAddress: pUnkOuter type: IUnknown.	iid := self guidAtAddress: riid.	self clearPointerResultValueAtAddress: ppvObject.	resultReference := nil asValueReference.	hresult := implementor				CreateInstanceLic: controllingUnknown				_: (self interfaceAtAddress: pUnkReserved type: IUnknown)				_: iid				_: (self stringAtBSTRPointer: bstrKey)				_: resultReference.	(HRESULT succeeded: hresult)		ifTrue: [self interfaceResultAtAddress: ppvObject put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Automation">invokeGetLicInfo: this _: pLicInfo	" Private - invoke the IClassFactory2::GetLicInfo function for an external caller. "	" HRESULT __stdcall  GetLicInfo(LICINFO * pLicInfo) = 5 "	^[  " terminate exception stack unwind at function invocation boundary "	self reportExternalFunctionEntry.	pLicInfo isValid ifFalse: [ ^E_INVALIDARG ].	implementor GetLicInfo: ( self structureAtAddress: pLicInfo )	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Automation">invokeRequestLicKey: this _: dwReserved _: pBstrKey	" Private - invoke the IClassFactory2::RequestLicKey function for an external caller. "	" HRESULT __stdcall  RequestLicKey(DWORD dwReserved, BSTR * pBstrKey) = 6 "	^[  " terminate exception stack unwind at function invocation boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pBstrKey isNull ifTrue: [ ^E_INVALIDARG ].	self clearResultBufferAtAddress: pBstrKey.	resultReference := nil asValueReference.	hresult := implementor RequestLicKey: dwReserved _: resultReference.	( HRESULT succeeded: hresult )		ifTrue: [			self bstrResultAtAddress: pBstrKey put: resultReference value.			].	hresult	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IClassFactory2Implementation</class-id> <category>interface operations</category><body package="Com- Automation">CreateInstanceLic: pUnkOuter _: pUnkReserved _: riid _: bstrKey _: resultReference	" Invoke the IClassFactory2::CreateInstanceLic function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor CreateInstanceLic: pUnkOuter _: pUnkReserved _: riid _: bstrKey _: resultReference		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Automation">GetLicInfo: pLicInfo	" Invoke the IClassFactory2::GetLicInfo function. "	" HRESULT __stdcall  GetLicInfo(LICINFO * pLicInfo) = 5 "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetLicInfo: pLicInfo		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Automation">RequestLicKey: dwReserved _: resultReference	" Invoke the IClassFactory2::RequestLicKey function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor RequestLicKey: dwReserved _: resultReference		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IClassFactory2Implementation class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	" IClassFactory2Implementation ClassInitializer "	self iid: IID_IClassFactory2.	self vtableSignatureTypeName: #__IClassFactory2Vtbl.	self updateAndRegister</body></methods><methods><class-id>External.VariantChangeTypeNotification</class-id> <category>constants</category><body package="Com- Automation">defaultResumeValue	^ true</body></methods><methods><class-id>External.AutomationArgument</class-id> <category>updating arguments</category><body package="Com- Automation">updateServerArgumentIn: aVariantArray	self subclassResponsibility</body></methods><methods><class-id>External.AutomationArgument</class-id> <category>accessing</category><body package="Com- Automation">value	self subclassResponsibility</body></methods><methods><class-id>External.ExistingArgument</class-id> <category>accessing</category><body package="Com- Automation">argumentDescription	^argumentDescription</body><body package="Com- Automation">argumentDescription: anObject	argumentDescription := anObject</body><body package="Com- Automation">indexSpec	^indexSpec</body><body package="Com- Automation">indexSpec: anObject	indexSpec := anObject</body><body package="Com- Automation">originalIndex	self subclassResponsibility</body><body package="Com- Automation">originalValue	^originalValue</body><body package="Com- Automation">originalValue: anObject	originalValue := anObject</body><body package="Com- Automation">value	^ value</body><body package="Com- Automation">value: anObject	value := anObject</body></methods><methods><class-id>External.ExistingArgument</class-id> <category>As yet unclassified</category><body package="Com- Automation">argumentType		^ argumentDescription type</body></methods><methods><class-id>External.ExistingArgument</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	aStream nextPutAll: 'arg('.	value printOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>External.ExistingArgument</class-id> <category>testing</category><body package="Com- Automation">hasValueChanged	^(value value == originalValue value) not</body></methods><methods><class-id>External.ExistingArgument</class-id> <category>updating arguments</category><body package="Com- Automation">updateServerArgumentIn: aVariantArray	| variant |	argumentDescription isByref ifFalse: [^self].	self hasValueChanged ifFalse: [^self].	variant := aVariantArray at: self originalIndex.	variant value: self value</body></methods><methods><class-id>External.NamedAutomationArgument</class-id> <category>accessing</category><body package="Com- Automation">argumentID	^ self indexSpec</body><body package="Com- Automation">argumentID: anIndex	^ self indexSpec: anIndex</body><body package="Com- Automation">originalIndex	^originalIndex</body><body package="Com- Automation">originalIndex: anObject	originalIndex := anObject</body></methods><methods><class-id>External.NamedAutomationArgument class</class-id> <category>instance creation</category><body package="Com- Automation">argumentID: anIndex originalIndex: originalIndex argumentDescription: argDescription value: aValue	^(self new)		argumentID: anIndex;		originalIndex: originalIndex;		argumentDescription: argDescription;		originalValue: aValue copy;		value: aValue;		yourself</body></methods><methods><class-id>External.COMCall</class-id> <category>testing</category><body package="Com- Automation">isDispatch	^ self specification isVTable not</body><body package="Com- Automation">isProcedure	^ self testFlag: #isProcedure</body><body package="Com- Automation">isProcedure: aBoolean	self setFlag: #isProcedure to: aBoolean.</body><body package="Com- Automation">isPropertyGet	^ self testFlag: #isPropertyGet</body><body package="Com- Automation">isPropertyGet: aBoolean	self isPropertySet ifTrue: [ self error: #CanNotBeSetAndGet &lt;&lt; #com &gt;&gt; 'A call can not be property set and Get at the same time' ].	^ self setFlag: #isPropertyGet</body><body package="Com- Automation">isPropertySet	^ self testFlag: #isPropertySet</body><body package="Com- Automation">isPropertySet: aBoolean	self isPropertyGet ifTrue: [ self error: #CanNotBeSetAndGet &lt;&lt; #com &gt;&gt; 'A call can not be property set and Get at the same time' ].	^ self setFlag: #isPropertySet</body><body package="Com- Automation">isThreaded	^ self testFlag: #isThreaded</body><body package="Com- Automation">isThreaded: aBoolean	self setFlag: #isThreaded to: aBoolean.</body><body package="Com- Automation">memberExists	^ None ~= self specification</body><body package="Com- Automation">mightBeMethod	^ self testFlag: #mightBeMethod</body><body package="Com- Automation">mightBeMethod: aBoolean	self setFlag: #mightBeMethod to: aBoolean.</body></methods><methods><class-id>External.COMCall</class-id> <category>accessing</category><body package="Com- Automation">arguments	^arguments</body><body package="Com- Automation">arguments: anObject	arguments := anObject</body><body package="Com- Automation">detectCallTypeLazy	self setFlag: #shouldDetectCallType.</body><body package="Com- Automation">driver: anObject	driver := anObject</body><body package="Com- Automation">flags	^flags ifNil: [ flags := IdentitySet new ].</body><body package="Com- Automation">memberName	^memberName</body><body package="Com- Automation">memberName: anObject	memberName := anObject</body><body package="Com- Automation">namedArguments	^namedArguments</body><body package="Com- Automation">namedArguments: anObject	namedArguments := anObject</body><body package="Com- Automation">prefix: anObject	anObject = #get ifTrue: [^self isPropertyGet: true].	anObject = #set ifTrue: [^self isPropertySet: true].	anObject isNil ifTrue: [^self].	^self		error: #UnknownPrefixForCOMCall &lt;&lt; #com &gt;&gt; 'Unknown Prefix for COM Call'</body><body package="Com- Automation">shouldDetectCallType	^ self testFlag: #shouldDetectCallType.</body><body package="Com- Automation">specification	^specification ifNil: [specification := self computeSpecification]</body></methods><methods><class-id>External.COMCall</class-id> <category>private flags</category><body package="Com- Automation">clearFlag: aSymbol	self flags remove: aSymbol ifAbsent: [].</body><body package="Com- Automation">setFlag: aSymbol	self flags add: aSymbol.</body><body package="Com- Automation">setFlag: aSymbol to: aBoolean	aBoolean ifTrue: [self setFlag: aSymbol] ifFalse: [self clearFlag: aSymbol]</body><body package="Com- Automation">testFlag: aSymbol	^ self flags includes: aSymbol.</body></methods><methods><class-id>External.COMCall</class-id> <category>private invoking</category><body package="Com- Automation">invokeMethod	| result receiver |	self specification isPropertySpecification		ifTrue: [^driver errorTryingToCallMethodLikeProperty].	receiver := driver actualReceiverFor: self.	result := receiver				invokeMethodSpec: self				withArguments: arguments				withNamedArguments: namedArguments.	^self		wrapResult: result		args: arguments		namedArgs: namedArguments		forSpecification: specification getSpecification</body><body package="Com- Automation">invokeProcedure	| result receiver |	specification isPropertySpecification		ifTrue: [^driver errorTryingToCallMethodLikeProperty].	receiver := driver actualReceiverFor: self.	result := receiver				invokeProcedureSpec: self				withArguments: arguments				withNamedArguments: namedArguments.	^self		wrapResult: result		args: arguments		namedArgs: namedArguments		forSpecification: specification getSpecification</body><body package="Com- Automation">invokePropertyGet	| receiver result actualSpec |	actualSpec := self specification member.	actualSpec isPropertySpecification		ifFalse: 			[^self mightBeMethod				ifTrue: [self invokeMethod]				ifFalse: [driver errorTryingToCallMethodLikeProperty]].	self namedArguments notEmpty		ifTrue: 			[self error: #PropertyGetWithNamedArgumentsUnsupported &lt;&lt; #com						&gt;&gt; 'Getting a property with named arguments is currently unsupported'].	actualSpec isWriteOnly		ifTrue: 			[self				error: #PropertyIsWriteOnly &lt;&lt; #com &gt;&gt; 'This is a write-only property.'].	receiver := driver actualReceiverFor: self.	result := receiver getPropertySpec: self.	^self		wrapResult: result		args: arguments		namedArgs: namedArguments		forSpecification: specification propertyGetSpecification</body><body package="Com- Automation">invokePropertySet	| actualSpec result |	self namedArguments notEmpty		ifTrue: 			[self error: #PropertyGetWithNamedArgumentsUnsupported &lt;&lt; #com						&gt;&gt; 'Getting a property with named arguments is currently unsupported'].	actualSpec := self specification member.	actualSpec isPropertySpecification		ifFalse: [driver errorTryingToCallMethodLikeProperty].	actualSpec isReadOnly		ifTrue: [self error: #PropertyIsReadOnly &lt;&lt; #com &gt;&gt; 'Property is read-only'].	result := (driver actualReceiverFor: self) setPropertySpec: self				withArguments: arguments.	^self		wrapResult: result		args: arguments		namedArgs: namedArguments		forSpecification: (actualSpec				writePropertySpecificationForArguments: arguments)</body><body package="Com- Automation">performInCorrespondingAppartment: aBlock	"We do not want to move the call to the STA if #threaded is not specified.	If the call is already inside a threaded callback, the callout will be on	them MTA again"	^self isThreaded		ifTrue: [COMThreadManager performInMTA: aBlock]		ifFalse: [COMThreadManager performInSTA: aBlock]</body><body package="Com- Automation">wrapResult: result args: args namedArgs: namedArgs forSpecification: aSpec	"Wrap the result and out parameters into a Client Class if requried"	"Not nice, but for Dispatch calls the Specification Policy has already wrapped the result.	Maybe should be refactored "	^driver		wrapResult: result		args: args		namedArgs: namedArgs		for: aSpec</body></methods><methods><class-id>External.COMCall</class-id> <category>invoking</category><body package="Com- Automation">invoke	self memberExists ifFalse: [driver signalMemberNotFound].	self isPropertyGet		ifTrue: [^self performInCorrespondingAppartment: [self invokePropertyGet]].	self isPropertySet		ifTrue: [^self performInCorrespondingAppartment: [self invokePropertySet]].	self isProcedure		ifTrue: [^self performInCorrespondingAppartment: [self invokeProcedure]].	^self performInCorrespondingAppartment: [self invokeMethod]</body></methods><methods><class-id>External.COMCall</class-id> <category>private</category><body package="Com- Automation">addArgumentName: argumentName index: index indexed: indexed value: aValue	"Add an argument for this COM Call. ArgumentsName is the previously parsed name for this argument. It may be nil 	if the argument is not named. 'index' is the index of the argument. 'Indexed' expressed if all previous parameters are indexed ones.	'aValue' is the argument value"	^argumentName		ifNil: 			[indexed				ifTrue: 					[self arguments add: aValue.					indexed]				ifFalse: 					[self error: #IndexedArgAfterNamedArg &lt;&lt; #com								&gt;&gt; 'An indexed argument followed a named one. This is not allowed.']]		ifNotNil: 			[self namedArguments at: argumentName asSymbol put: aValue.			false]</body><body package="Com- Automation">addSingleParametersFrom: aMessage	self extractArgsFrom: aMessage arguments keywords: aMessage selector keywords.</body><body package="Com- Automation">computeCallTypeAndSpecification	| prefix name aSpec |	^	[aSpec := driver specificationProvider				specificationFor: self createMethodAndPropertyQuery				ifAbsent: [nil].	aSpec notNil ifTrue: [^aSpec].	prefix := (self memberName first: 3) asLowercase asSymbol.	(self class knownCallTypes includes: prefix) ifFalse: [^None].	name := self memberName allButFirst: 3.	aSpec := driver specificationProvider				specificationFor: (self createPropertyQueryName: name)				ifAbsent: [^None].	self memberName: name.	self prefix: prefix.	aSpec]			ensure: [self clearFlag: #shouldDetectCallType]</body><body package="Com- Automation">computeSpecification	^self shouldDetectCallType		ifTrue: [self computeCallTypeAndSpecification]		ifFalse: 			[driver specificationProvider specificationFor: self createQuery				ifAbsent: [None]]</body><body package="Com- Automation">defaultMemberNameFrom: keyword lastIndex: lastIndex	^self isThreaded		ifTrue: [keyword copyFrom: self class threadedModifier size + 1 to: lastIndex]		ifFalse: [keyword copyFrom: 1 to: lastIndex]</body><body package="Com- Automation">extractArgsFrom: messageArgs keywords: keywords	| indexed argName values keyword argProcessingBlock |	argProcessingBlock :=			[:argumentName :index |			argumentName				ifNil: 					[indexed						ifTrue: [self arguments add: (messageArgs at: index)]						ifFalse: 							[self error: #IndexedArgAfterNamedArg &lt;&lt; #com										&gt;&gt; 'An indexed argument followed a named one. This is not allowed.']]				ifNotNil: 					[self namedArguments at: argumentName asSymbol put: (messageArgs at: index).					indexed := false]].	self arguments: OrderedCollection new.	self namedArguments: Dictionary new.	(keywords size = 1 and: [keywords first last ~= $:]) ifTrue: [^self].	indexed := true.	values := self getMemberAndArgumentNameFrom: keywords first.	self memberName: values first.	argName := values last.	argProcessingBlock value: argName value: 1.	2 to: keywords size		do: 			[:index |			keyword := keywords at: index.			argName := self getArgumentNameFrom: keyword.			argProcessingBlock value: argName value: index].	self arguments: self arguments asArray</body><body package="Com- Automation">getArgumentNameFrom: keyword	| size |	size := keyword size.	size &lt; 4 ifTrue: [^nil].	keyword first ~= $_ ifTrue: [^nil].	(keyword last: 2) ~= '_:' ifTrue: [^nil].	^keyword copyFrom: 2 to: size - 2</body><body package="Com- Automation">getMemberAndArgumentNameFrom: keyword	| size firstUnderscorePosition name argName |	size := keyword size.	size &lt; 5		ifTrue: 			[^Array with: (self defaultMemberNameFrom: keyword lastIndex: size - 1)				with: nil].	(keyword last: 2) = '_:'		ifFalse: 			[^Array with: (self defaultMemberNameFrom: keyword lastIndex: size - 1)				with: nil].	firstUnderscorePosition := keyword				prevIndexOf: $_				from: size - 2				to: 2.	(firstUnderscorePosition isNil or: [firstUnderscorePosition = (size - 2)])		ifTrue: 			[^Array with: (self defaultMemberNameFrom: keyword lastIndex: size - 1)				with: nil].	name := self defaultMemberNameFrom: keyword				lastIndex: firstUnderscorePosition - 1.	argName := keyword copyFrom: firstUnderscorePosition + 1 to: size - 2.	^Array with: name with: argName</body><body package="Com- Automation">setMemberAndArgumentsFrom: aMessage	aMessage arguments isEmpty		ifTrue: 			[self memberName: (self defaultMemberNameFrom: aMessage selector						lastIndex: aMessage selector size).			arguments := #().			namedArguments := Dictionary new]		ifFalse: 			[aMessage arguments size &gt; 1				ifTrue: [self setMemberNameAndArgumentsFromMultipleKeywords: aMessage]				ifFalse: [self setMemberNameAndArgumentsFromSingleKeyword: aMessage]].	self detectCallTypeLazy</body><body package="Com- Automation">setMemberNameAndArgumentsFromMultipleKeywords: aMessage	| indexed argName values keyword |	self arguments: OrderedCollection new.	self namedArguments: Dictionary new.	values := self				getMemberAndArgumentNameFrom: aMessage selector keywords first.	self memberName: values first.	argName := values last.	indexed := self				addArgumentName: argName				index: 1				indexed: true				value: aMessage arguments first.	2 to: aMessage selector keywords size		do: 			[:index |			keyword := aMessage selector keywords at: index.			argName := self getArgumentNameFrom: keyword.			indexed := self						addArgumentName: argName						index: 1						indexed: indexed						value: (aMessage arguments at: index)].	self arguments: self arguments asArray</body><body package="Com- Automation">setMemberNameAndArgumentsFromSingleKeyword: aMessage	"The selector seems to be something like #doSomethingWithArguments:. Check if this is the case.	 If yes, the only argument should be an array or dictionary. If not try the normal approach where there is a keyword for each argument"	| aMemberName |	aMemberName := aMessage selector.	self isThreaded		ifTrue: 			[aMemberName := aMemberName allButFirst: self class threadedModifier size].	(aMemberName last: self class withArgumentsSuffix size)		= self class withArgumentsSuffix			ifFalse: [^self setMemberNameAndArgumentsFromMultipleKeywords: aMessage].	self		memberName: (aMemberName allButLast: self class withArgumentsSuffix size).	aMessage arguments first setArgumentsInCOMCall: self</body><body package="Com- Automation">specification: aSpecification	^specification := aSpecification</body></methods><methods><class-id>External.COMCall</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	super initialize.	arguments := #().	namedArguments := Dictionary new.</body><body package="Com- Automation">initializeForMessage: aMessage	self isThreaded: (self class threadedFlagFrom: aMessage selector).	self setMemberAndArgumentsFrom: aMessage.</body></methods><methods><class-id>External.COMCall</class-id> <category>private query creation</category><body package="Com- Automation">createMethodAndPropertyQuery	"This query will prefer methods"	^COMSpecificationQuery		forMethodOrProperty: self memberName		arguments: self arguments		namedArguments: self namedArguments</body><body package="Com- Automation">createMethodQuery	^COMSpecificationQuery		forMethod: self memberName		arguments: self arguments		namedArguments: #()</body><body package="Com- Automation">createPropertyAndMethodQuery	"This query will prefer properties"	^COMSpecificationQuery		forPropertyOrMethod: self memberName		arguments: self arguments		namedArguments: self namedArguments</body><body package="Com- Automation">createPropertyQueryName: name	^COMSpecificationQuery		forProperty: name		arguments: self arguments		namedArguments: self namedArguments</body><body package="Com- Automation">createPropertySetQuery	^COMSpecificationQuery		forPropertyOrMethod: self memberName		arguments: (self arguments allButLast: 1)		namedArguments: self namedArguments</body><body package="Com- Automation">createQuery	"We always query methods and properties to avoid that the variant lookup policy may create the wrong kind of specification."	self isPropertyGet ifTrue: [^self createPropertyAndMethodQuery].	self isPropertySet ifTrue: [^self createPropertySetQuery].	^self createMethodAndPropertyQuery</body></methods><methods><class-id>External.COMCall class</class-id> <category>instance creation</category><body package="Com- Automation">forMessage: aMessage driver: aDispatchDriver	^(self new)		driver: aDispatchDriver;		initializeForMessage: aMessage;		yourself</body><body package="Com- Automation">forMethod: aMethodName client: aClient arguments: arguments 	| instance |	instance := self new			memberName: aMethodName;			driver: aClient;			yourself.	arguments setArgumentsInCOMCall: instance.	^ instance</body><body package="Com- Automation">forMethod: aMethodName client: aClient arguments: args namedArguments: namedArgs	^ self new			memberName: aMethodName;			driver: aClient;			arguments: args;			namedArguments: namedArgs;			yourself</body><body package="Com- Automation">forPropertyGet: aPropertyName client: aClient arguments: args	^ self new			memberName: aPropertyName;			isPropertyGet: true;			driver: aClient;			arguments: args;			yourself</body><body package="Com- Automation">forPropertySet: aPropertyName client: aClient arguments: args	^ self new			memberName: aPropertyName;			isPropertySet: true;			driver: aClient;			arguments: args;			yourself</body><body package="Com- Automation">forSpecification: aSpecification  client: aClient arguments: arguments	^self new		driver: aClient;		specification: aSpecification;		arguments: arguments;		yourself</body><body package="Com- Automation">new	^ super new initialize</body></methods><methods><class-id>External.COMCall class</class-id> <category>private accessing</category><body package="Com- Automation">knownCallTypes	^#(#get #set)</body><body package="Com- Automation">knownSuffixes	^(Array with: self withArgumentsSuffix)</body><body package="Com- Automation">threadedModifier	^#threaded</body></methods><methods><class-id>External.COMCall class</class-id> <category>private</category><body package="Com- Automation">suffixFrom: aKeyword	^self knownSuffixes detect: [:each | (aKeyword last: each size) = each]		ifNone: [nil]</body><body package="Com- Automation">threadedFlagFrom: memberName	^(memberName first: self threadedModifier size) asSymbol		= self threadedModifier</body><body package="Com- Automation">withArgumentsSuffix	^'WithArguments:'</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>accessing</category><body package="Com- Automation">description	^ description</body><body package="Com- Automation">description: aString	description := aString.</body><body package="Com- Automation">flags		^flags		ifNil:			[self flags: 0.			flags]</body><body package="Com- Automation">flags: anObject		^ flags := anObject</body><body package="Com- Automation">memberID	^ memberID</body><body package="Com- Automation">memberID: anInteger		"Set the receiver's member ID to the DISPID &lt;anInteger&gt;."	memberID := anInteger</body><body package="Com- Automation">optionalParameterCount        " Answer the number of optional parameters allowed by this method ( -1, 0 or &gt;0). "	^ optionalParameterCount ifNil: [		optionalParameterCount := self computeOptionalParameterCount ]</body><body package="Com- Automation">optionalParameterCount: anInteger	" Specify the number of optional parameters allowed by this method ( -1, 0 or &gt;0). "	self subclassResponsibility</body><body package="Com- Automation">parameterCount	^ self parameters size</body><body package="Com- Automation">parameterNames	^ self subclassResponsibility</body><body package="Com- Automation">parameterTypeDescriptions		"Answer the parameter types of the receiver."	^self parameterTypes</body><body package="Com- Automation">parameterTypes		"Answer the parameter types of the receiver."	^self parameters collect: [:param | param type]</body><body package="Com- Automation">parameterTypes: anArray	"Set the receiver's parameter types to be &lt;anArray&gt;."	self parameters		ifNil: 			[self				parameters: (anArray collect: [:each | COMParameterDescription type: each])]		ifNotNil: 			[:params |			params isEmpty				ifTrue: 					[self						parameters: (anArray collect: [:each | COMParameterDescription type: each])]				ifFalse: 					[1 to: (params size min: anArray size)						do: [:index | (params at: index) type: (anArray at: index)]]]</body><body package="Com- Automation">parameters: anObject	parameters := anObject</body><body package="Com- Automation">requiredParameterCount	" Answer the number of required parameters. "	| nOptionalParms nParms |	nOptionalParms := self optionalParameterCount.	nParms := self parameterCount.	^nParms - (nOptionalParms max: 0)</body><body package="Com- Automation">returnValueDescription	^returnValueDescription</body><body package="Com- Automation">returnValueDescription: anObject	returnValueDescription := anObject</body><body package="Com- Automation">specifications	^ Array with: self</body><body package="Com- Automation">type	^  self returnValueDescription type</body><body package="Com- Automation">typeCode		"Answer the type code of the receiver."	^ self returnValueDescription ifNil: [ nil ] ifNotNil: [:type | self modifyTypeCode: type typecode ]</body><body package="Com- Automation">typeCode: anInteger		"Set the receiver's type code to be &lt;anInteger&gt;."	self returnValueDescription: (COMReturnValueDescription typeCode: anInteger)</body><body package="Com- Automation">vtableIndex	^vtableIndex</body><body package="Com- Automation">vtableIndex: anObject	vtableIndex := anObject</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>selector construction utilities</category><body package="Com- Automation">constructSelectorForName: aName nArgs: nArgs argumentKeyword: argumentKeyword	" Answer a selector which is constructed for &lt;aName&gt; with &lt;nArgs&gt; arguments, using &lt;argumentKeyword&gt; as necessary. "	| aStream |	aStream := WriteStream on: ( String new: aName size * 2 ).	aStream nextPutAll: aName.	nArgs &gt; 0		ifTrue: [			aStream nextPut: $:.			nArgs - 1 timesRepeat: [ aStream nextPutAll: argumentKeyword ] ].	^aStream contents asSymbol</body><body package="Com- Automation">installArgumentKeyword: argumentKeyword	" Install &lt;argumentKeyword&gt; as the anonymous keyword for argument values in the receiver's selector(s). "	" Default is to do nothing.  Reimplemented by subclasses with parameters. "</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>private-accessing</category><body package="Com- Automation">parameterNamed: aName	^self parameters detect: [:each | each name = aName ]</body><body package="Com- Automation">parameters	^parameters</body><body package="Com- Automation">resultValue	^ self returnValueDescription</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>testing</category><body package="Com- Automation">hasParameters		" Answer whether the receiver has parameters. "	self subclassResponsibility</body><body package="Com- Automation">hasResult	^ self returnValueDescription ifNil: [ false ] ifNotNil: [:aTypeCode |		aTypeCode carriesValue and: [ aTypeCode type isHRESULT not ]]</body><body package="Com- Automation">returnsHRESULT	^ self returnValueDescription type isHRESULT</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>private emphasised texts</category><body package="Com- Automation">hasResultToDisplay	"Answer whether I have a result type which can be displayed in the browser.	 Subclasses may override this behavior"	^ self hasResult</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>browser support</category><body package="Com- Automation">actualMember	^ self</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>private</category><body package="Com- Automation">computeOptionalParameterCount	| count |	count := 0. 	self parameters reverseDo: [:param |		param isOptional ifFalse: [ ^ count ].		count  := count + 1. ].	^ count</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>comparing</category><body package="Com- Automation">= aPropertyAccessSpec	super = aPropertyAccessSpec ifFalse: [ ^false ].	aPropertyAccessSpec memberID = self memberID ifFalse: [^false].	aPropertyAccessSpec flags = self flags ifFalse: [^false].	aPropertyAccessSpec parameters = self parameters ifFalse: [^false].	aPropertyAccessSpec returnValueDescription = self returnValueDescription ifFalse: [^false].	^ aPropertyAccessSpec vtableIndex = self vtableIndex</body><body package="Com- Automation">hash 	^ self memberID</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>converting</category><body package="Com- Automation">asCOMEntryPointDescription	^  COMEntryPointDescription name: self name		type: self vtableSignature		vtableIndex: self vtableIndex</body><body package="Com- Automation">vtableSignature	| type cParams cNames |	type := self cType.	cParams := (Array with: COMExternalInterface new IUnknown pointerType)				, type argumentTypes.	cNames := (Array with: 'this') , type argumentNames.	^CProcedureType		resultType: type resultType		argumentTypes: cParams		argumentNames: cNames</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>private vtable calls</category><body package="Com- Automation">cArgumentTypes	^ self parameters collect: [:each | each cType ].</body><body package="Com- Automation">cParameterNames	^ self parameterNames</body><body package="Com- Automation">cType	^(CProcedureType		resultType: self returnValueDescription cType		argumentTypes: self cArgumentTypes		argumentNames: self cParameterNames)		beStdcall;		yourself</body><body package="Com- Automation">externalProcedure	^ ExternalProcedure name: self name procedureType: self cType index: self vtableIndex</body><body package="Com- Automation">freeArguments: marshaled 	self parameters keysAndValuesDo: [:index :paramDesc |			paramDesc freeArgument: (marshaled at: index)].</body><body package="Com- Automation">isTransformingCall	^self parameters notEmpty and: [self parameters last isResultValue]</body><body package="Com- Automation">marshalArguments: arguments	| newArguments |	newArguments := Array new: arguments size.	self parameters keysAndValuesDo: [:index :parameterDesc |			newArguments at: index put: (parameterDesc marshalArgument: (arguments at: index)) ].	^ newArguments</body><body package="Com- Automation">performCallOn: anInterface withArguments: arguments	| external marshaledArguments hresult primitiveArguments |	external := self externalProcedure.	external owner: anInterface asInterfacePointer.	marshaledArguments := self marshalArguments: arguments.	^	[primitiveArguments := self primitiveArguments: marshaledArguments.	hresult := COMExternalMethod				call: external				from: anInterface asInterfacePointer				withArgs: primitiveArguments				onErrorDo: [:sysError | External.COMStatusCodeConstants.E_UNEXPECTED].	(self returnsHRESULT not or: [hresult succeeded])		ifTrue: [self unmarshalArguments: marshaledArguments into: arguments]		ifFalse: [COMError hresult: hresult].	hresult]			ensure: [self freeArguments: marshaledArguments]</body><body package="Com- Automation">performNormalVTableCallTo: anInterface withArguments: arguments	^self performCallOn: anInterface withArguments: arguments</body><body package="Com- Automation">performTransformingVTableCallTo: anInterface withParameters: arguments	| newArguments |	arguments size = self parameters size		ifTrue: 			[arguments last isValueReference				ifFalse: [self raiseInvalidNumberOfArguments].			COMDevelopmentWarning raiseSignal: #LastArgumentIsOutArgument &lt;&lt; #com						&gt;&gt; 'the last argument is an out argument and does not need to be specified'.			newArguments := arguments]		ifFalse: 			[newArguments := arguments copyWith: self parameters last newArgumentValue].	self performNormalVTableCallTo: anInterface withArguments: newArguments.	^newArguments last value</body><body package="Com- Automation">primitiveArguments: arguments	| primitiveArgs value |	primitiveArgs := Array new: arguments size.	self parameters keysAndValuesDo: [:index :each | 		value := arguments at: index.		primitiveArgs at: index put: (each type primitiveArgumentFor: value).].	^ primitiveArgs</body><body package="Com- Automation">unmarshalArguments: marshaled into: originalArguments	self parameters keysAndValuesDo: [:index :paramDesc |			paramDesc unmarshal: (marshaled at: index) into: (originalArguments at: index).].</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>calling</category><body package="Com- Automation">autoWrapParameterAt: index value: aValue	self hasParameters		ifFalse: [self error: #InvalidIndex &lt;&lt; #com &gt;&gt; 'Invalid Index'].	^(self parameters at: index) type isByref		ifTrue: [aValue asValue]		ifFalse: [aValue]</body></methods><methods><class-id>External.COMDispatchMemberSpecification</class-id> <category>vtable calls</category><body package="Com- Automation">performCallOn: anInterface withParameters: arguments	^self isTransformingCall		ifTrue: 			[self performTransformingVTableCallTo: anInterface withParameters: arguments]		ifFalse: 			[self performNormalVTableCallTo: anInterface withArguments: arguments]</body></methods><methods><class-id>External.COMDispatchMemberSpecification class</class-id> <category>literal representation</category><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(flags memberID vtableIndex parameters returnValueDescription description)</body></methods><methods><class-id>External.COM_VARDESC</class-id> <category>accessing</category><body package="Com- Automation">constantValue	"Answer the constant value of a VAR_CONST description."	| lpVariant |	Assert isTrue: [ self isConstant ].	lpVariant := self unionMemberAt: #'u.lpvarValue'.	lpVariant isNull		ifTrue: [ ^nil ].	^( ( COMStructure classForStructureNamed: #VARIANT ) temporaryOn: lpVariant )		value</body><body package="Com- Automation">flags 	^self memberAt: #wVarFlags</body><body package="Com- Automation">getDocumentation	^ self typeInterface getDocumentation: self memberID</body><body package="Com- Automation">getName	"Answer the variable name."	^self typeInterface getName: self memberID</body><body package="Com- Automation">memberID	"Answer the unique identifier of the member."	^self memberAt: #memid</body><body package="Com- Automation">oInst    "This is the offset of the variable within the instance, if varkind = VAR_PERINSTANCE."	^self unionMemberAt: #'u.oInst'</body><body package="Com- Automation">propertyValueDescription	"return the element description which describes the return value a property described by this VARDESC.	 This implementation is analogue to the one in COM_FUNCDESC"		^ self variableValueDescription</body><body package="Com- Automation">typeCode	"Answer the integer that defines the type of the variable."	^self variableValueDescription typeCode</body><body package="Com- Automation">typeCodeUsing: iTypeInfo	"Answer the integer that defines the type of the variable."	^self variableValueDescription typeCodeUsing: iTypeInfo</body><body package="Com- Automation">variableValueDescription	"Answer the type and IDL descriptions of the variable's value."	^self structureMemberAt: #elemdescVar</body><body package="Com- Automation">vtableIndex	"Variables are only accessible using dispatching. They don't have a vtable index"	^ nil</body></methods><methods><class-id>External.COM_VARDESC</class-id> <category>testing</category><body package="Com- Automation">isConstant	" Answer whether the receiver describes a constant value. "	^( self memberAt: #varkind ) = VAR_CONST</body><body package="Com- Automation">isDispatch	" Answer whether the variable described by the receiver is a dispatch interface. "    ^( self memberAt: #varkind )  = VAR_DISPATCH</body><body package="Com- Automation">isVarDesc	" Answer whether the receiver is a VARDESC structure. "	^true</body></methods><methods><class-id>External.COM_VARDESC</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseStructure	" Private - release the receiver back to the interface from whence it came. "	self structure == nil		ifTrue: [ ^self ].  " already released "	typeInterface releaseVarDesc: self.	self structure enforceInvalidation.	self structure: nil.</body></methods><methods><class-id>External.COM_VARDESC class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_TYPEATTR;		yourself</body></methods><methods><class-id>External.COM_VARDESC class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #VARDESC.	self updateAndRegister</body></methods><methods><class-id>External.BSTR</class-id> <category>testing</category><body package="Com- Automation">isValid	"Answer whether the receiver is valid (accessible)."	^structure class isBits   " internal byte buffer "		or: [ super isValid ]</body></methods><methods><class-id>External.BSTR</class-id> <category>accessing-type information</category><body package="Com- Automation">memberNames	" Answer the names of the members in the structure accessed by the receiver. "	" need to override this so that #doesNotUnderstand: isn't confused "	^#( )</body><body package="Com- Automation">type	" Answer the C data type of the structure accessed by the receiver. "	^self class baseCType</body></methods><methods><class-id>External.BSTR</class-id> <category>private-accessing</category><body package="Com- Automation">byteIndexOfCharAt: anInteger        "Private - answer the index of the first byte of          the character at &lt;anInteger&gt; in the receiver. "	Tools.Note ISSUE.  " This is a mess, review this implementation completely.  [DL 14-Aug-96] "	^anInteger + anInteger + 2</body><body package="Com- Automation">computeCharPointerForOffset: anInteger	" Private - answer the USHORT pointer corresponding to the byte offset &lt;anInteger&gt;.  Offsets are zero relative. "	| address |	Tools.Note ISSUE.  " This is a mess, review this implementation completely.  [DL 14-Aug-96] "	address := self structure asPointer referentAddress.	address := address - self sizeFieldSizeInBytes. " Re-compensate for the ULONG length field "	^( CIntegerType unsignedShort pointerType cast: address + anInteger )</body><body package="Com- Automation">getSizeField	" Private "	^self isInExternalMemory		ifTrue: [ self structure getSizeField ]		ifFalse: [ self structure unsignedLongAt: 1 ]</body><body package="Com- Automation">setSizeField: anInteger	" Private "	self isInExternalMemory		ifTrue: [ Tools.Note ISSUE.  " Should we allow this? [DL 14-Aug-96] " Assert shouldNotBe ]		ifFalse: [ self structure unsignedLongAt: 1 put: anInteger ]</body><body package="Com- Automation">sizeFieldSizeInBytes	" Private "	^self class sizeFieldSizeInBytes</body><body package="Com- Automation">sizeInBytes	" Private - answer the size in bytes of the receiver. "Tools.Note ISSUE.  " This is inconsistent with superclass semantics, for which #sizeInBytes describes	the structure, not as in this case the (string) data referenced by the structure.	Review and resolve.  [DL 18-May-97] "	^self sizeFieldSizeInBytes + self stringSizeInBytes</body><body package="Com- Automation">stringSizeInBytes	" Private "	^self getSizeField</body><body package="Com- Automation">structure: aStructure	" Private - set the structure "	structure := (aStructure isNil or: [aStructure isExternalAddress not])				ifTrue: [aStructure]				ifFalse: [aStructure asBSTRMemoryAddress].	self initializeProtocolMap</body><body package="Com- Automation">uShortAtOffset: anInteger        "Answer the word (16 bits) at anInteger in the receiver.         Offsets are zero relative."	^self isInExternalMemory		ifTrue: [ ( self computeCharPointerForOffset: anInteger ) contents ]		ifFalse: [ self structure unsignedShortAt: anInteger + 1 ]</body><body package="Com- Automation">uShortAtOffset: anInteger put: aUnicodeCharacterValue        "Store a word, anObject, at anInteger in the receiver.         Offsets are zero relative."	^self isInExternalMemory		ifTrue: [ ( self computeCharPointerForOffset: anInteger ) contents: aUnicodeCharacterValue ]		ifFalse: [ self structure unsignedShortAt: anInteger + 1 put: aUnicodeCharacterValue ]</body></methods><methods><class-id>External.BSTR</class-id> <category>accessing-contents</category><body package="Com- Automation">at: anInteger	"Answer the character at position &lt;anInteger&gt; in the receiver string."	self checkIndex: anInteger.	^Character value: ( self uShortAtOffset: ( self byteIndexOfCharAt: anInteger ) )</body><body package="Com- Automation">at: anInteger put: aCharacter	" Store &lt;aCharacter&gt; (or a legal integer character code value) in the &lt;anInteger&gt;-th index position in the receiver.  Answer aCharacter. "	| cv |	self checkIndex: anInteger.	self checkCharacter: aCharacter.	cv := ( aCharacter isInteger		ifTrue: [ aCharacter ]		ifFalse: [ aCharacter asInteger ] ).	self uShortAtOffset: ( self byteIndexOfCharAt: anInteger ) put: cv.	^aCharacter</body><body package="Com- Automation">do: aBlock	"Answer the receiver.  For each character in the receiver, evaluate &lt;aBlock&gt; with that character as the argument."	1 to: self size do: [ :i |		aBlock value: ( self at: i ) ].</body><body package="Com- Automation">reAllocateString: aString	"Allocates a new BSTR and copies the passed string into it, then frees the BSTR referenced by the receiver, and finally resets the receiver to point to the new BSTR. "	OLEAutomationDLL current SysReAllocString: self _: aString</body><body package="Com- Automation">size	" Answer the number of characters in the receiver string. "	^self stringSizeInBytes / 2</body></methods><methods><class-id>External.BSTR</class-id> <category>subclass-initializing</category><body package="Com- Automation">initializeProtocolMap	" Private - initialize the protocol map of dynamic message selectors supported by the receiver.  Do nothing for the receiver. "</body></methods><methods><class-id>External.BSTR</class-id> <category>converting</category><body package="Com- Automation">asByteArray	"Answer a ByteArray whose contents are the bytes of the receiver."	self isValid ifFalse: [ ^nil ].	^self bytesAtOffset: ( self isInExternalMemory ifTrue: [ 0 ] ifFalse: [ self sizeFieldSizeInBytes ] )		count: self stringSizeInBytes</body><body package="Com- Automation">asGUID	" Answer the GUID specified by the receiver if it is a syntactically legal string representation of a GUID. "	^self asString asGUID</body><body package="Com- Automation">asString	"Answer the receiver converted to a String.  An invalid BSTR is mapped to nil."	self isValid 		ifFalse: [ ^nil ].	^self isInExternalMemory		ifTrue: [ self class stringAtPointer: self asPointerParameter ]		ifFalse: [ 			Tools.Note ISSUE.  " Review this, it looks fishy [DL 18-May-97] "			"			| nBytes |			nBytes := self stringSizeInBytes.			( TwoByteString new: nBytes )				replaceElementsFrom: 1 to: nBytes withTwoByteString: self asByteArray startingAt: 1;				yo}rself 			"			TwoByteString fromBytes: self asByteArray ]</body></methods><methods><class-id>External.BSTR</class-id> <category>private-validation</category><body package="Com- Automation">checkCharacter: aCharacter 	"Private - Report an error if the argument         aCharacter is not an instance of class Character."	aCharacter isInteger 		ifTrue: 			[(aCharacter between: 0 and: 16rFFFF) 				ifFalse: 					[^COMError 						raiseSignal: (#ErrNamedCantHold &lt;&lt; #com &gt;&gt; '&lt;1s&gt; can''t hold &lt;2s&gt;' 								expandMacrosWith: self class name								with: aCharacter printString)].			^self].	Tools.Note ISSUE.	" Type-testing protocol for Jigsaw?? [DL 14-Aug-96] "	aCharacter class == Character 		ifFalse: 			[^COMError 				raiseSignal: (#ErrNamedCantHold &lt;&lt; #com &gt;&gt; '&lt;1s&gt; can''t hold &lt;2s&gt;' 						expandMacrosWith: self class name						with: aCharacter class name)]	"isCharacter"</body><body package="Com- Automation">checkIndex: anInteger        "Private - Check that the argument &lt;anInteger&gt;         is a valid character position index for the receiver.         If it is found to be invalid, report the error."    anInteger isInteger        ifFalse: [            ^COMError raiseSignal: #ErrStringIndex &lt;&lt; #com &gt;&gt; 'strings are indexed by integers'].    ( anInteger between: 1 and: self size )        ifFalse: [ ^self errorInBounds: anInteger ]</body><body package="Com- Automation">errorInBounds: anInteger        "Private - Report an error to the effect that         &lt;anInteger&gt; is an invalid index for the receiver."    ^COMError raiseSignal: (#ErrNamedIndexOutOfBounds &lt;&lt; #com &gt;&gt; 'index: &lt;1p&gt; is outside of string bounds' expandMacrosWith: anInteger)</body></methods><methods><class-id>External.BSTR</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	"Append the receiver as a quoted string to aStream, doubling all internal single quote characters."	aStream nextPutAll: self class name; space; nextPut: $&lt;.	self isValid		ifTrue: [ 			self do: [ :character |				aStream nextPut: character.				character = $'					ifTrue: [ aStream nextPut: character ] ] ]			ifFalse: [ aStream nextPutAll: (#invalid &lt;&lt; #com &gt;&gt; 'invalid') asString].	aStream nextPut: $&gt;</body></methods><methods><class-id>External.BSTR</class-id> <category>finalizing</category><body package="Com- Automation">doesNotNeedFinalization	^ structure doesNotNeedFinalization</body><body package="Com- Automation">hasFinalization	^ structure hasFinalization</body><body package="Com- Automation">needsFinalization	^ structure needsFinalization</body></methods><methods><class-id>External.BSTR</class-id> <category>subclass-releasing</category><body package="Com- Automation">releaseStructure	" Private - release the structure itself. "	self isInExternalMemory 		ifTrue: [ self structure enforceRelease ].	self structure: nil.</body></methods><methods><class-id>External.BSTR</class-id> <category>releasing</category><body package="Com- Automation">destroyReference	" Destroy this memory reference (without releasing it).  This service is used to relinquish ownership of the BSTR. "	self callIndicatesChangeNeeded</body></methods><methods><class-id>External.BSTR</class-id> <category>inspecting</category><body package="Com- Automation">inspectorClass	^Inspector</body></methods><methods><class-id>External.BSTR class</class-id> <category>external-transformations</category><body package="Com- Automation">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery. "	^COMExternalInterface current BSTR</body><body package="Com- Automation">resultValueArrayBuffer: count	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an array of &lt;count&gt; BSTR strings which are realized from instances of the receiver allocated by the called function in COM task memory.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^BSTRStringPointerArrayResultBuffer new: count</body><body package="Com- Automation">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a BSTR string which is realized from an instance of the receiver allocated by the called function in COM task memory.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^BSTRStringPointerResultBuffer new</body><body package="Com- Automation">resultValueReadOnlyBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a BSTR string which is realized from an instance of the receiver allocated by the called function in COM task memory.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value.  The COM memory of the BSTR is not released. "	^Win32UnicodeStringPointerResultBuffer new</body><body package="Com- Automation">stringAtPointer: aPointer	" Answer a platform String containing the characters in the BSTR	string in external memory referenced by &lt;aPointer&gt;. "	Tools.Note ISSUE.  " Make up your mind, either make this a public service or nuke it [DL 16-May-97] "	Tools.Note portingPatch.  " This probably shouldn't be necessary, but use		temporarily to patch some guys. [DL 29-Feb-96] "	^COMExternalInterface stringFromUnicodePointer: aPointer</body></methods><methods><class-id>External.BSTR class</class-id> <category>instance creation</category><body package="Com- Automation">allocateString: aString	" Allocate a BSTR in external COM memory and copy the characters of &lt;aString&gt; into it.  Answer a new instance of the receiver on the address of the BSTR in external memory. "	^self onNew: ( BSTRMemoryAddress allocateString: aString )</body><body package="Com- Automation">fromString: aString	" Answer a BSTR containing the characters of &lt;aString&gt;. "	" note that no special conversion is required, since strings are 		maintained internally in Unicode encoding "	^self fromUnicode: aString</body><body package="Com- Automation">fromUnicode: aUnicodeString	" Answer a BSTR containing the characters of &lt;aUnicodeString&gt;. "	| aBstr |	aBstr := self new: aUnicodeString size.	1 to: aUnicodeString size do: [ :i |		aBstr at: i put: ( aUnicodeString at: i ) ].	^aBstr</body><body package="Com- Automation">new	" Answer a new instance of the receiver. "	self shouldNotImplement.  " need to specify a size or contents "</body><body package="Com- Automation">new: anInteger        "Answer a new instance of the receiver that can contain &lt;anInteger&gt; Unicode characters."	| nBytesContents |	Tools.Note ISSUE.  " Review this vs. #useFixedSpace notion [DL 17-May-97] "	nBytesContents := anInteger + anInteger.	^( self onNew: ( UninterpretedBytes new: nBytesContents + self sizeFieldSizeInBytes ) )		setSizeField: nBytesContents;		yourself</body><body package="Com- Automation">newInFixedSpace	" Answer a new instance of the receiver with an internal byte buffer allocated in fixed space. "	self shouldNotImplement.  " need to specify a size or contents "</body></methods><methods><class-id>External.BSTR class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COM_VARDESC;		yourself</body></methods><methods><class-id>External.BSTR class</class-id> <category>private-type information</category><body package="Com- Automation">sizeFieldSizeInBytes	" Private "	"^CIntegerType unsignedLong sizeof"	^4</body></methods><methods><class-id>External.BSTR class</class-id> <category>subclass-accessing</category><body package="Com- Automation">typeProvider	" Answer the object which can provide definitions from the type name space of the receiver. "	^COMExternalInterface</body></methods><methods><class-id>External.BSTR class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #BSTR.</body></methods><methods><class-id>External.COMVariant class</class-id> <category>value validation</category><body package="Com- Automation">isValid: aValue	"Answer whether &lt;aValue&gt; is legal to place in a Variant."	| typeCode |	( typeCode := aValue comVariantType ) isNil		ifTrue: [ ^false ].	typeCode = VT_CY 		ifTrue: [ ^COMCurrency isValid: aValue ].	^true</body></methods><methods><class-id>External.COMVariant class</class-id> <category>error reporting</category><body package="Com- Automation">errorNoVariant	" Generate an OLE exception indicating that a value cannot be represented as an OLE variant. "	COMError hresult: DISP_E_BADVARTYPE  "?? DISP_E_TYPEMISMATCH ??"</body></methods><methods><class-id>External.COMVariant class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: BSTR;		yourself</body></methods><methods><class-id>External.COMVariant class</class-id> <category>private-accessing</category><body package="Com- Automation">cTypeCodeRepresentations	^CTypeRepresentations		ifNil: [self computeCTypeCodeRepresentations]</body><body package="Com- Automation">typeCodeNameMap		" Private - answer the mapping dictionary from type code values to names. "	^TypeCodeNameMap</body><body package="Com- Automation">typeCodeNameMap: aDictionary		" Private - set the mapping dictionary from type code values to names. "	TypeCodeNameMap := aDictionary.</body><body package="Com- Automation">vbTypeCodeRepresentations	^ VBTypeCodeRepresentations ifNil: [ self computeVBTypeCodeRepresentations ]</body></methods><methods><class-id>External.COMVariant class</class-id> <category>private-installation</category><body package="Com- Automation">initialize	"Private - initialize the class state."	self initializeTypeCodeNameMap</body><body package="Com- Automation">initializeTypeCodeNameMap		" Private - initialize the type name mapping specifications. "	| aMap |	aMap := Dictionary new.	COMAutomationConstants keysAndValuesDo: [ :key :value |		( key size &gt; 3		and: [ ( key copyFrom: 1 to: 3 ) = 'VT_' ] )			ifTrue: [ aMap at: value put: key asString ] ].	self typeCodeNameMap: aMap.</body><body package="Com- Automation">isBStringType: aTypeCode 	" Answer whether &lt;aTypeCode&gt; is an array type (VT_ARRAY). Answer false if &lt;aTypeCode&gt; isNil."	^aTypeCode isNil 		ifTrue: [false]		ifFalse: [(self noRefTypeCodeOf: aTypeCode) = VT_BSTR]</body><body package="Com- Automation">isDecimalType: aTypeCode	"return whether the given type code describes as decimal"	^ (self arrayElementTypeCodeOf: aTypeCode) = VT_DECIMAL</body></methods><methods><class-id>External.COMVariant class</class-id> <category>type code analysis</category><body package="Com- Automation">arrayElementTypeCodeOf: aTypeCode	"Answer the type code of the value specified by &lt;aTypeCode&gt;, without the VT_BYREF or VT_ARRAY modifiers. Answer nil if &lt;aTypeCode&gt; isNil."	aTypeCode isNil ifTrue: [ ^nil ].	^aTypeCode maskClear: VT_BYREF | VT_ARRAY</body><body package="Com- Automation">baseTypeCodeOf: aTypeCode		"Answer the type code of the basic value specified by &lt;aTypeCode&gt;, 		i.e. without modifiers such as reference or array."	Tools.Note ISSUE.  " Was this FF or FFFF?? [DL 01-Nov-95] " 	aTypeCode isNil ifTrue: [ ^nil ].	^aTypeCode bitAnd: 16rFF</body><body package="Com- Automation">containsInterfaceTypeCode: aTypeCode	" Answer true if &lt;aTypeCode&gt; describes		an IDispatch or IUnknown, 		or a reference to an IDispatch or IUnknown,		or an array of IDispatch or IUnknown.	Answer false otherwise. " 	aTypeCode isNil ifTrue: [ ^false ].	( aTypeCode bitAnd: VT_DISPATCH ) = VT_DISPATCH ifTrue: [ ^true ].	( aTypeCode bitAnd: VT_UNKNOWN ) = VT_UNKNOWN ifTrue: [ ^true ].	^false</body><body package="Com- Automation">isArrayOfInterfacesOrVariants: aTypeCode	" Answer whether &lt;aTypeCode&gt; is an array type (VT_ARRAY). Answer false if &lt;aTypeCode&gt; isNil."	| baseType |	^ (self isArrayType: aTypeCode) and: [ 			baseType := self arrayElementTypeCodeOf: aTypeCode.			((self isInterfaceTypeCode: baseType) or: [self isVariantType: baseType])]</body><body package="Com- Automation">isArrayType: aTypeCode	" Answer whether &lt;aTypeCode&gt; is an array type (VT_ARRAY). Answer false if &lt;aTypeCode&gt; isNil."	aTypeCode isNil ifTrue: [ ^false ].	^( aTypeCode bitAnd: VT_ARRAY ) = VT_ARRAY</body><body package="Com- Automation">isBstrType: aTypeCode	aTypeCode isNil ifTrue: [ ^false ].	^aTypeCode = VT_BSTR or: [ aTypeCode = ( VT_BSTR | VT_BYREF ) ]</body><body package="Com- Automation">isEmpty: aTypeCode	aTypeCode isNil ifTrue: [ ^false ].	^ aTypeCode  = VT_EMPTY</body><body package="Com- Automation">isInterfaceTypeCode: aTypeCode	"Answer true if &lt;aTypeCode&gt; is typed to contain an IDispatch or IUnknown. Answer true if &lt;aTypeCode&gt; is typed to contain a pointer to an IDispatch or IUnknown. Answer false otherwise." 	| tc |	tc := self noRefTypeCodeOf: aTypeCode.	^( tc = VT_DISPATCH ) or: [ tc = VT_UNKNOWN ]</body><body package="Com- Automation">isReferenceType: aTypeCode	" Answer whether &lt;aTypeCode&gt; is a reference type (VT_BYREF). Answer false if &lt;aTypeCode&gt; isNil. "	aTypeCode isNil ifTrue: [ ^false ].	^( aTypeCode bitAnd: VT_BYREF ) = VT_BYREF</body><body package="Com- Automation">isVariantPointerType: aTypeCode	" Answer whether &lt;aTypeCode&gt; is a VT_VARIANT | VT_BYREF type. 	Answer true if &lt;aTypeCode&gt; =  VT_VARIANT | BT_BYREF	Answer false otherwise."	aTypeCode isNil ifTrue: [ ^false ].	^ aTypeCode = ( VT_VARIANT | VT_BYREF )</body><body package="Com- Automation">isVariantType: aTypeCode	" Answer whether &lt;aTypeCode&gt; is a VT_VARIANT type (but not an array of VT_VARIANT). 	Answer true if &lt;aTypeCode&gt; =  VT_VARIANT	Answer true if &lt;aTypeCode&gt; =  VT_VARIANT | BT_BYREF	Answer false otherwise."	aTypeCode isNil ifTrue: [ ^false ].	^aTypeCode = VT_VARIANT or: [ aTypeCode = ( VT_VARIANT | VT_BYREF ) ]</body><body package="Com- Automation">noRefTypeCodeOf: aTypeCode              "Answer the type code of the value specified by &lt;aTypeCode&gt;,without the VT_BYREF reference modifier. Answer nil if &lt;aTypeCode&gt; isNil."        aTypeCode isNil ifTrue: [ ^nil ].	  aTypeCode class == GUID ifTrue: [ ^ aTypeCode ].        ^aTypeCode maskClear: VT_BYREF</body></methods><methods><class-id>External.COMVariant class</class-id> <category>type description</category><body package="Com- Automation">basicCRepresentationForType: aTypeCode	"return the VB representation of a given typeCode"	^self cTypeCodeRepresentations		at: (self arrayElementTypeCodeOf: aTypeCode)		ifAbsent: nil</body><body package="Com- Automation">basicVBRepresentationForType: aTypeCode 	"return the VB representation of a given typeCode"	^(self vbTypeCodeRepresentations 		at: (self arrayElementTypeCodeOf: aTypeCode)		ifAbsent: [self typeCodeNameOf: aTypeCode]) asString</body><body package="Com- Automation">typeCodeDescriptionOf: aTypeCode		" Answer a string describing the type code &lt;aTypeCode&gt;. "	| baseTypeCode baseTypeCodeName description |	baseTypeCode := self arrayElementTypeCodeOf: aTypeCode.	baseTypeCodeName := self typeCodeNameOf: baseTypeCode.	baseTypeCode = aTypeCode		ifTrue: [ ^baseTypeCodeName ].	" decode type modifiers "	description := baseTypeCodeName.	( self isArrayType: aTypeCode )		ifTrue: [ description := 'VT_ARRAY | ', description ].	( self isReferenceType: aTypeCode )		ifTrue: [ description := description, ' | VT_BYREF' ].	^description</body><body package="Com- Automation">typeCodeForCRepresentation: aString	"return the the typecode for the given C representation"	^self cTypeCodeRepresentations		keyAtValueEqual: aString		ifAbsent: nil</body><body package="Com- Automation">typeCodeNameOf: aTypeCode		" Answer the name of the VT type &lt;aTypeCode&gt;. "	^self typeCodeNameMap at: aTypeCode		ifAbsent: [  " undefined, probably an initialization problem in the name map "			Tools.Note ISSUE.  " Gary - the nil check was added in VSE 3.1.2.  When can				this ever happen??  [DL 08-Aug-96] "			( aTypeCode isNil or: [ aTypeCode &lt;= 8 ] )				ifTrue: [ aTypeCode printString ]				ifFalse: [ aTypeCode printStringRadix: 16 ] ]</body></methods><methods><class-id>External.COMVariant class</class-id> <category>private computing</category><body package="Com- Automation">computeCTypeCodeRepresentations	^CTypeRepresentations := (IdentityDictionary new: 64)				at: 0 put: 'VOID';				at: 1 put: 'NULL';				at: 2 put: 'short';				at: 3 put: 'long';				at: 4 put: 'float';				at: 5 put: 'double';				at: 6 put: 'CURRENCY';				at: 7 put: 'DATE';				at: 8 put: 'BSTR';				at: 9 put: 'IDispatch*';				at: 10 put: 'ERROR';				at: 11 put: 'boolean';				at: 12 put: 'VARIANT';				at: 13 put: 'IUnknown*';				at: 16 put: 'I1';				at: 17 put: 'char';				at: 18 put: 'UI2';				at: 19 put: 'UI4';				at: 20 put: 'I8';				at: 21 put: 'UI8';				at: 22 put: 'INT';				at: 23 put: 'UINT';				at: 24 put: 'void';				at: 25 put: 'HRESULT';				at: 26 put: 'PTR';				at: 27 put: 'SAFEARRAY';				at: 28 put: 'CARRAY';				at: 29 put: 'USERDEFINED';				at: 30 put: 'LPSTR';				at: 31 put: 'LPWSTR';				at: 64 put: 'FILETIME';				at: 65 put: 'BLOB';				at: 66 put: 'STREAM';				at: 67 put: 'STORAGE';				at: 68 put: 'STREAMED_OBJECT';				at: 69 put: 'STORED_OBJECT';				at: 70 put: 'BLOB_OBJECT';				at: 71 put: 'CF';				at: 72 put: 'CLSID';				yourself</body><body package="Com- Automation">computeVBTypeCodeRepresentations	| integer |	integer := #VBInteger &lt;&lt; #com &gt;&gt; 'Integer'.		^ VBTypeCodeRepresentations := Dictionary new		at: VT_INT put: integer;		at: VT_UINT put: integer;		at: VT_I1 put: integer;		at: VT_I2 put: integer;		at: VT_I4 put: integer;		at: VT_I8 put: integer;		at: VT_UI1 put: integer;		at: VT_UI2 put: integer;		at: VT_UI4 put: integer;		at: VT_UI8 put: integer;		at: VT_R4 put: (#VBFloat &lt;&lt; #com &gt;&gt; 'Float');		at: VT_R8 put: (#VBDouble &lt;&lt; #com &gt;&gt;'Double');		at: VT_CY put: (#VBCurrency &lt;&lt; #com &gt;&gt;'Currency');		at: VT_DATE put: (#VBDate &lt;&lt; #com &gt;&gt;'Date');	"	at: VT_DECIMAL put: (#VBDecimal &lt;&lt; #com &gt;&gt;'Fixedpoint');  not yet supported"		at: VT_BOOL put: (#VBBool &lt;&lt; #com &gt;&gt;'Boolean');		at: VT_BSTR put: (#VBString &lt;&lt; #com &gt;&gt;'String');		at: VT_LPSTR put: (#VBString &lt;&lt; #com &gt;&gt;'String'); 		at: VT_LPWSTR put: (#VBString &lt;&lt; #com &gt;&gt;'String'); 		at: VT_DISPATCH put: (#VBObject &lt;&lt; #com &gt;&gt;'Object');		at: VT_UNKNOWN put: (#VBObject &lt;&lt; #com &gt;&gt;'Object');		at: VT_VARIANT put: (#VBVariant &lt;&lt; #com &gt;&gt;'Variant');		at: VT_STREAM put: (#VBStream &lt;&lt; #com &gt;&gt;'Stream');		at: VT_HRESULT put: (#HResult &lt;&lt; #com &gt;&gt;'HResult');		at: VT_RECORD put: (#TKindRecord &lt;&lt; #com &gt;&gt;'Record');		yourself</body></methods><methods><class-id>External.COMVariant class</class-id> <category>instance creation</category><body package="Com- Automation">new		" Answer a new instance of the receiver. "	Tools.Note ISSUEin72. "Changed from self invalidMassage"	self shouldNotImplement.</body></methods><methods><class-id>External.COMVariant class</class-id> <category>variant encoding</category><body package="Com- Automation">createTypeCodesToFilter	^TypeCodesToFilter := (OrderedCollection new)				add: 						[:each |						each = (VT_NULL | VT_BYREF) ifTrue: [VT_VARIANT | VT_BYREF] ifFalse: [each]];				add: 						[:each |						each = (VT_EMPTY | VT_BYREF) ifTrue: [VT_VARIANT | VT_BYREF] ifFalse: [each]];				add: 						[:each |						(each bitAnd: VT_PTR) = VT_PTR							ifTrue: [(each maskClear: VT_PTR) bitOr: VT_BYREF]							ifFalse: [each]];				yourself</body><body package="Com- Automation">filterTypeCode: aTypeCode	| typeCode modified newValue |	typeCode := aTypeCode.	modified := false.		[self typeCodesToFilter do: 			[:filter |			newValue := filter value: typeCode.			newValue ~= typeCode				ifTrue: 					[modified := true.					typeCode := newValue]].	modified]			whileTrue: [modified := false].	^typeCode</body><body package="Com- Automation">typeCodesToFilter	^TypeCodesToFilter ifNil: [self createTypeCodesToFilter]</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>accessing</category><body package="Com- Automation">autoWrapIDispatch	"Answer whether the receiver should wrap IDispatch interfaces with an OLEDispatchDriver."    ^autoWrapIDispatch</body><body package="Com- Automation">autoWrapIDispatch: aBoolean	"Specify whether the receiver should wrap IDispatch interfaces with an OLEDispatchDriver."    autoWrapIDispatch := aBoolean.</body><body package="Com- Automation">lookupPolicy	"Answer the receiver's lookup policy."     ^lookupPolicy</body><body package="Com- Automation">lookupPolicy: aLookupPolicy 	"Set the receiver's lookup policy. Raise a COMError if &lt;aLookupPolicy&gt; is invalid."	(aLookupPolicy isKindOf: COMLookupSpecificationPolicy) 		ifFalse: 			[^COMError 				raiseSignal: (#ErrNamedNotLookupPolicy &lt;&lt; #com 						&gt;&gt; '&lt;1s&gt; is not a lookup policy.' 							expandMacrosWith: aLookupPolicy class asString)].	self isTyped = aLookupPolicy isTyped 		ifFalse: 			[^COMError 				raiseSignal: #ErrTypePolicyMixed &lt;&lt; #com &gt;&gt; 'Type policy mismatch.'].	lookupPolicy := aLookupPolicy</body><body package="Com- Automation">policySymbol	"Answer the base policySymbol the receiver was created with. Used for cloning new policies."    ^policySymbol</body><body package="Com- Automation">policySymbol: aPolicySymbol 	"Private. Set the base policySymbol the receiver was created with. Used for cloning new policies. Raise a COMError if &lt;aPolicySymbol&gt; is invalid."	(self validatePolicy: aPolicySymbol) ifTrue: [policySymbol := aPolicySymbol]</body><body package="Com- Automation">updateSpecificationTable    "Answer whether or not new specifications that have been looked up should    be added to the dispatch driver's specification table."    ^updateSpecificationTable</body><body package="Com- Automation">updateSpecificationTable: aBoolean    "Set whether or not new specifications that have been looked up should    be added to the dispatch driver's specification table."    updateSpecificationTable := aBoolean</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>private-literal representation</category><body package="Com- Automation">literalArrayEncoding	"Answer a literal suitable for reconstituting the receiver."	| restoreStateActions literalEncoding |	restoreStateActions := self prepareForLiteralEncoding.	literalEncoding := OrderedCollection new: 6.	literalEncoding add: self class name.	literalEncoding 		add: #lookupPolicy:;		add: self lookupPolicy literalArrayEncoding.	self autoWrapIDispatch notNil ifTrue: [		literalEncoding 			add: #autoWrapIDispatch:;			add: self autoWrapIDispatch ].	self updateSpecificationTable notNil ifTrue: [		literalEncoding 			add: #updateSpecificationTable:;			add: self updateSpecificationTable ].	restoreStateActions do: [ :anAction | anAction evaluate ].	^literalEncoding asArray</body><body package="Com- Automation">prepareForLiteralEncoding	"Prepare the receiver for generation of the literal encoding representing its state.  Answer a collection of actions which can be evaluated following literal generation to restore any temporary state. "	| restoreStateActions |	" description is constructed at design time to support the property editor "	restoreStateActions := OrderedCollection new.	self autoWrapIDispatch = self defaultAutoWrapIDispatch		ifTrue: [ 			restoreStateActions add: ( MessageSend receiver: self				selector: #autoWrapIDispatch:				argument: self autoWrapIDispatch ).			self autoWrapIDispatch: nil ].	self updateSpecificationTable = self defaultUpdateSpecificationTable		ifTrue: [ 			restoreStateActions add: ( MessageSend receiver: self				selector: #updateSpecificationTable:				argument: self updateSpecificationTable ).			self updateSpecificationTable: nil ].	^restoreStateActions</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">allowsSpecificationTableUpdates	"Answer whether it makes sense for the receiver to update the specification table ."    ^self lookupPolicy allowsSpecificationTableUpdates</body><body package="Com- Automation">canSupportIDispatch: anIDispatch	"Answer whether or not the receiver configured as it is can support performing it's	lookups an &lt;anIDispatch&gt;."	^self canSupportIDispatch: anIDispatch forLocaleID: LOCALE_USER_DEFAULT</body><body package="Com- Automation">canSupportIDispatch: anIDispatch forLocaleID: aLocaleID	"Answer whether or not the receiver configured as it is can support performing it's	lookups an &lt;anIDispatch&gt; for the given LCID &lt;aLocaleID&gt;."	^self lookupPolicy canSupportIDispatch: anIDispatch forLocaleID: aLocaleID</body><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^self subclassResponsibility</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>releasing</category><body package="Com- Automation">release	"Release resources from the recevier."	self lookupPolicy release.	super release</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>converting</category><body package="Com- Automation">fromLiteralArrayEncoding: anArray 	"Initialize the receiver with the information in the literal array (see literalArrayEncoding)."	2 to: anArray size by: 2 do:		[:i | self perform: (anArray at: i) with: (anArray at: i + 1) decodeAsLiteralArray].</body><body package="Com- Automation">newPolicy	"Answer a new initialized policy."	^self class newPolicy: self policySymbol</body><body package="Com- Automation">wrapResultValue: aValue ofType: aType from: aDispatchDriver	"Private. If &lt;aValue&gt; is a dispatch interface, we may wrap it with an OLEDispatchDriver."	^aType unmarshalAutomationResult: aValue</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>private-initializing</category><body package="Com- Automation">defaultAutoWrapIDispatch	^true</body><body package="Com- Automation">defaultUpdateSpecificationTable	^true</body><body package="Com- Automation">initialize	"Private."	self updateSpecificationTable: self defaultUpdateSpecificationTable.	self autoWrapIDispatch: self defaultAutoWrapIDispatch</body><body package="Com- Automation">validatePolicy: aPolicySymbol	^self class validatePolicy: aPolicySymbol</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>printing</category><body package="Com- Automation">description	"Answer a string describing the receiver."	^( self isTyped		ifTrue: [ 'typed' ]		ifFalse: [ 'untyped' ] ), 	' with ''', self lookupPolicy description, ''' lookup policy'.</body><body package="Com- Automation">printOn: aStream	"Append to the argument, aStream, the class name of the receiver (with it's lookup policy)."	super printOn: aStream.	aStream nextPutAll: ((#x1sLookupPolicy &lt;&lt; #com &gt;&gt; ' (''&lt;1s&gt;'' lookup policy)')			expandMacrosWith: self lookupPolicy description).</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>invocation</category><body package="Com- Automation">invokeGet: aDispatchSpec with: dispParams on: aDispatchDriver	"Get the value of the property or method described by &lt;aDispatchSpec&gt;. May be overriden by a subclass."	| resultValue |	resultValue := aDispatchDriver dispatchInterface				invokeGet: aDispatchSpec memberID				with: dispParams				localeID: aDispatchDriver localeID.	^self wrapResultValue: resultValue ofType: aDispatchSpec type from: aDispatchDriver</body><body package="Com- Automation">invokeMethod: aDispatchSpec with: dispParams on: aDispatchDriver result: resultReference	"Invoke the method described by &lt;aDispatchSpec&gt;. 	Use this message when a procedure and a function have the same name (and DISPID) and you	want to invoke the function. May be overriden by a subclass."	| typeCode resultValue |	typeCode := aDispatchSpec typeCode.	resultValue := aDispatchDriver dispatchInterface				invokeMethod: aDispatchSpec memberID				with: dispParams				localeID: aDispatchDriver localeID				result: ((typeCode = VT_EMPTY or: [typeCode = VT_VOID])						ifTrue: [nil]						ifFalse: [resultReference]).	^self wrapResultValue: resultValue ofType: aDispatchSpec type from: aDispatchDriver</body><body package="Com- Automation">invokeProcedure: aSpecification with: dispParams on: aDispatchDriver result: resultReference	"Invoke the procedure described by &lt;aDispatchSpec&gt;. There is no return value for a procedure. 	Use this message when a procedure and a function have the same name (and DISPID) and you	want to invoke the procedure. This is neccessary in Word 95 (where procedures are called statements.)	May be overriden by a subclass."	| resultValue |	aSpecification typeCode: VT_VOID.	resultValue := self				invokeMethod: aSpecification				with: dispParams				on: aDispatchDriver				result: nil.	self wrapResultValue: resultValue ofType: aSpecification type from: aDispatchDriver.	self updateSpecificationTable		ifTrue: 			[aDispatchDriver specificationTable at: aSpecification name				put: aSpecification].	^resultValue</body><body package="Com- Automation">invokePropertyGet: aDispatchSpec with: dispParams on: aDispatchDriver	"Get the property described by &lt;aDispatchSpec&gt;. May be overriden by a subclass."	| resultValue  |	resultValue := aDispatchDriver dispatchInterface				invokePropertyGet: aDispatchSpec memberID				with: dispParams				localeID: aDispatchDriver localeID.	^self wrapResultValue: resultValue ofType: aDispatchSpec returnValueDescription type from: aDispatchDriver</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>lookup</category><body package="Com- Automation">initialSpecificationTableFor: aDispatchDriver	^ lookupPolicy initialSpecificationTableFor: aDispatchDriver</body><body package="Com- Automation">specificationFor: aSpecificationQuery on: aDriver ifAbsent: aBlock	^aDriver basicSpecificationFor: aSpecificationQuery		ifAbsent: 			[| newSpecification |			newSpecification := self lookupPolicy						specificationFor: aSpecificationQuery						on: aDriver						ifAbsent: [^aBlock value].			self updateSpecificationTable				ifTrue: 					[aDriver specificationTable at: aSpecificationQuery member						put: newSpecification].			newSpecification]</body></methods><methods><class-id>External.COMSpecificationPolicy</class-id> <category>configuring</category><body package="Com- Automation">applySpecificationOn: aDispatchDriver	aDispatchDriver specificationPolicy: self.</body></methods><methods><class-id>External.COMSpecificationPolicy class</class-id> <category>accessing</category><body package="Com- Automation">defaultPolicy	"Answer the default policy symbol."	^DefaultPolicy</body><body package="Com- Automation">defaultPolicy: aSymbol 	"Verify and set the default policy symbol to &lt;aSymbol&gt;."	(self validDefaultPolicies includes: aSymbol) 		ifFalse: 			[^COMError 				raiseSignal: (#ErrNamedInvalidSpecPolicy &lt;&lt; #com 						&gt;&gt; 'Invalid specification policy: &lt;1p&gt;' expandMacrosWith: aSymbol)].	DefaultPolicy := aSymbol</body><body package="Com- Automation">validDefaultPolicies	"Answer the valid set of policies."	^ValidDefaultPolicies ifNil: [ self initializeValidDefaultPolicies ].</body></methods><methods><class-id>External.COMSpecificationPolicy class</class-id> <category>instance creation</category><body package="Com- Automation">decodeFromLiteralArray: anArray	" Answer a new instance of the receiver from the attributes specifications in the literal representation &lt;anArray&gt;. "	^self new fromLiteralArrayEncoding: anArray</body><body package="Com- Automation">new	"Private. Answer a new instance of the receiver."	^super new initialize</body><body package="Com- Automation">newCompletePolicy    "Answer a new complete specification policy configured with no additional lookup."    ^COMTypedSpecificationPolicy new	  policySymbol: #newCompletePolicy;        lookupPolicy: COMNoLookupSpecificationPolicy new;	  updateSpecificationTable: false;        yourself</body><body package="Com- Automation">newDefaultPolicy	"Answer a new default policy. Raise a COMError if the Default Policy symbol is invalid."	^self newPolicy: self defaultPolicy</body><body package="Com- Automation">newLazyInitializePolicy	"Answer a new complete specification policy configured with no additional lookup."		^(COMTypedSpecificationPolicy new)		policySymbol: #newLazyInitializePolicy;		lookupPolicy: COMLazyInitializeLookupSpecificationPolicy new;		updateSpecificationTable: false;		yourself</body><body package="Com- Automation">newPolicy: aPolicySymbol 	"Answer a policy defiend by &lt;aPolicySymbol&gt;. Raise a COMError if &lt;aPolicySymbol&gt; is invalid."	^aPolicySymbol isNil		ifTrue: [nil]		ifFalse: 			[(self validatePolicy: aPolicySymbol) ifTrue: [self perform: aPolicySymbol]]</body><body package="Com- Automation">newTypeCompilerPolicy    "Answer a new specification policy configured with type compiler lookup."    ^COMTypedSpecificationPolicy new	  policySymbol: #newTypeCompilerPolicy;        lookupPolicy: COMTypeCompilerLookupSpecificationPolicy new;        yourself</body><body package="Com- Automation">newTypeLibraryPolicy    "Answer a new specification policy configured with type library lookup."    ^COMTypedSpecificationPolicy new	  policySymbol: #newTypeLibraryPolicy;        lookupPolicy: COMTypeLibraryLookupSpecificationPolicy new;        yourself</body><body package="Com- Automation">newTypedPolicy    "Answer a new specification policy configured with type library lookup."    ^COMTypedSpecificationPolicy new	  policySymbol: #newTypedPolicy;        lookupPolicy: COMTypedLookupSpecificationPolicy new;        yourself</body><body package="Com- Automation">newVariantPolicy    "Answer a new specification policy configured with variant data types."    ^COMUntypedSpecificationPolicy new	  policySymbol: #newVariantPolicy;        lookupPolicy: COMVariantLookupSpecificationPolicy new;        yourself</body></methods><methods><class-id>External.COMSpecificationPolicy class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMVariant;		yourself</body></methods><methods><class-id>External.COMSpecificationPolicy class</class-id> <category>private-initialization</category><body package="Com- Automation">initialize	"Private. Initialize the receiver."	self defaultPolicy: #newLazyInitializePolicy</body><body package="Com- Automation">initializeValidDefaultPolicies	^ValidDefaultPolicies := (Set new)				add: #newTypeCompilerPolicy;				add: #newTypeLibraryPolicy;				add: #newVariantPolicy;				add: #newCompletePolicy;				add: #newLazyInitializePolicy;				add: #newTypedPolicy;				yourself</body><body package="Com- Automation">validatePolicy: aSymbol	"Answer true if the policy symbol &lt;aSymbol&gt; is valid. Raise an OLEError if invalid."	( self validDefaultPolicies includes: aSymbol )		ifFalse: [ ^COMError raiseSignal: (#ErrNamedInvalidSpecPolicy &lt;&lt; #com 						&gt;&gt; 'Invalid specification policy: &lt;1p&gt;' expandMacrosWith: aSymbol) ].	^true</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>private-accessing</category><body package="Com- Automation">selectorAttribute		" Private - answer the selector of the receiver.  Do not construct if not allocated. "	^selector</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>accessing</category><body package="Com- Automation">kind	^ #method</body><body package="Com- Automation">optionalParameterCount: anInteger	" Specify the number of optional parameters allowed by this method ( -1, 0 or &gt;0). "	parameters		ifNil: [optionalParameterCount := anInteger]		ifNotNil: 			[self parameters size to: (self parameters size - anInteger + 1 max: 1)				by: -1				do: [:index | (self parameters at: index) beOptional].			optionalParameterCount := self updateOptionalParameterCount]</body><body package="Com- Automation">parameterNames	"Answer the parameter names of the receiver. The answer may contain nil entries which for some automation objects like Excel indicate optional arguments."	| names |	^self parameters ifNotNil: [:params | 			names := OrderedCollection new.			params do: [:each | each basicName ifNotNil: [:aName | names add: aName asString ]].			names asArray			]</body><body package="Com- Automation">parameterNames: anArray 	"Set the receiver's parameter names to be &lt;anArray&gt;."	self parameters ifNil: 			[self parameters: (anArray collect: [:each | COMParameterDescription name: (each ifNil: [ MissingName])])]		ifNotNil: 			[:params | 			params isEmpty 				ifTrue: 					["Created previously as default"					self parameters: (anArray collect: [:each | COMParameterDescription name: (each ifNil: [ MissingName])])]				ifFalse: 					[ 1 to: (anArray size min: self parameters size) do: [:index | 							(self parameters at: index) name: ((anArray at: index) ifNil: [MissingName])]]]</body><body package="Com- Automation">selector		"Answer the selector of the receiver."	selector isNil		ifTrue: [ selector := self defaultSelector. ].	^selector</body><body package="Com- Automation">selector: aSymbol		"Set the selector of the receiver to &lt;aSymbol&gt;."	selector := aSymbol.</body><body package="Com- Automation">typeCode: anInteger	"Set the receiver's type code to be &lt;anInteger&gt;."	^super typeCode: (COMVariant noRefTypeCodeOf: anInteger)</body><body package="Com- Automation">updateOptionalParameterCount	| i |	i := 0.	self parameters reverseDo: [:each | 		each isOptional ifFalse: [ ^ i ].		i := i + 1 ]. 	^ self parameterCount</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>testing</category><body package="Com- Automation">hasOptionalParameters	^ self optionalParameterCount &gt; 0</body><body package="Com- Automation">hasParameters        " Answer whether the receiver has parameters. "    ^self parameterCount &gt; 0</body><body package="Com- Automation">isMethodSpecification		" Answer whether the receiver is a method member specification. "	^true</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>private-initialization</category><body package="Com- Automation">defaultSelector        " Private - answer the default selector used to invoke the        method described by the receiver. "	^self constructSelectorWith: self defaultArgumentKeyword</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>selector construction utilities</category><body package="Com- Automation">installArgumentKeyword: argumentKeyword	" Install &lt;argumentKeyword&gt; as the anonymous keyword for argument values in the receiver's selector(s). "	argumentKeyword = self defaultArgumentKeyword		ifTrue: [ ^self ].  " lazy allocation construction will do the right thing "	self hasParameters		ifTrue: [ self selector: ( self constructSelectorWith: argumentKeyword ) ]</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>private</category><body package="Com- Automation">modifyTypeCode: aTypeCode	"The original implementation used no-ref typcodes for methods but typecodes including reference flags	 for properties, so we remove the reference flag here."	^ COMVariant noRefTypeCodeOf: aTypeCode</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>converting</category><body package="Com- Automation">asVtableSpecification	self halt</body><body package="Com- Automation">checkArguments: arguments	arguments size = self parameters size ifTrue: [ ^ true ].	arguments size &gt; self parameters size ifTrue: [ ^ false ].	arguments size &lt;  self parameters size - self optionalParameterCount ifTrue: [  ^ false ]. 	^ true</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>utilities</category><body package="Com- Automation">constructSelectorWith: argumentKeyword	" Answer a message selector used to invoke the method described by the receiver which is formed from the method name and using &lt;argumentKeyword&gt; as the anonymous keyword for argument values. "	( self name == nil	or: [ self parameters == nil ] )		ifTrue: [ ^COMError raiseSignal: #ErrImproperSpec&lt;&lt; #com &gt;&gt; 'improperly constructed specification' ].	^self constructSelectorForName: self name 		nArgs: self parameterCount 		argumentKeyword: argumentKeyword</body></methods><methods><class-id>External.COMDispatchMethodSpecification</class-id> <category>private tools</category><body package="Com- Automation">basicIsEqualTo: aSpecification 		aSpecification ifNil: [^ false].	aSpecification isMethodSpecification ifFalse: [ ^ false].	aSpecification memberID = self memberID ifFalse: [ ^ false].	aSpecification name = self name ifFalse: [ ^ false].	^ self parametersEqual: self parameters and: aSpecification parameters</body></methods><methods><class-id>External.COMDispatchMethodSpecification class</class-id> <category>literal representation</category><body package="Com- Automation">literalEncodingType	" Answer the type which describes instance of the receiver in a literal encoding. "	^'method'</body><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(optionalParameterCount selector)</body></methods><methods><class-id>External.COMDispatchMethodSpecification class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMSpecificationPolicy;		yourself</body></methods><methods><class-id>External.COMDispatchMethodSpecification class</class-id> <category>private-initialization</category><body package="Com- Automation">initialize	" Private - initialize class state. "	self registerLiteralType: self literalEncodingType forClass: COMDispatchMethodSpecification.</body></methods><methods><class-id>External.COMDispatchMethodSpecification class</class-id> <category>instance creation</category><body package="Com- Automation">forDescription: aFuncDesc typeInfo: anITypeInfo	" Answer a new instance of the receiver initialized for the method        described by the FUNCDESC &lt;descr&gt;.  Additional type information        is proved by the ITypeInfo interface &lt;anITypeInfo&gt;. "	| resultType |	resultType := COMReturnValueDescription				fromElemDesc: aFuncDesc elemdescFunc				typeInfo: anITypeInfo.	^(self		name: aFuncDesc getName		memberID: aFuncDesc memberID		vtableIndex: aFuncDesc vtableIndex		resultType: resultType		parameters: aFuncDesc parameters		optionalParameters: aFuncDesc optionalParameterCount)		flags: aFuncDesc flags;		description: (self descriptionFor: aFuncDesc memberID typeInfo: anITypeInfo);		yourself</body><body package="Com- Automation">name: aString memberID: anInteger resultType: aTypeCode parameters: parameters optionalParameters: optParamCount	" Answer a new instance of the receiver for the method named &lt;aString&gt;        which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.        The parameters are described by an array of name/type pairs.        The type code &lt;aTypeCode&gt; specifies the type of the method return value. "	^(self new)		name: aString;		memberID: anInteger;		returnValueDescription: aTypeCode;		parameters: parameters;		optionalParameterCount: optParamCount;		yourself</body><body package="Com- Automation">name: aString    memberID: anInteger    type: aType    parameterNames: anArrayOfStrings    parameterTypes: anArrayOfTypes    optionalParameterCount: aParameterCount        " Answer a new instance of the receiver for the method named &lt;aString&gt;        which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.        The type code &lt;aTypeCode&gt; specifies the type of the method return value. "    ^self new        name: aString;        memberID: anInteger;        type: aType;        parameterNames: anArrayOfStrings;        parameterTypes: anArrayOfTypes;        optionalParameterCount: aParameterCount;        yourself</body><body package="Com- Automation">name: aString    memberID: anInteger    typeCode: aTypeCode        " Answer a new instance of the receiver for the method named &lt;aString&gt;        which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.        The type code &lt;aTypeCode&gt; specifies the type of the method return value. "    ^self new        name: aString;        memberID: anInteger;        typeCode: aTypeCode;        parameterNames: #( );        parameterTypes: #( );        optionalParameterCount: 0;        yourself</body><body package="Com- Automation">name: aString    memberID: anInteger    typeCode: aTypeCode    parameterNames: anArrayOfStrings    parameterTypeCodes: anArrayOfTypeCodes        " Answer a new instance of the receiver for the method named &lt;aString&gt;        which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.        The type code &lt;aTypeCode&gt; specifies the type of the method return value. "    ^self new        name: aString;        memberID: anInteger;        typeCode: aTypeCode;        parameterNames: anArrayOfStrings;        parameterTypes: (anArrayOfTypeCodes collect: [:each | External.DispTypeSpec fromVariantTypeCode: each ]) ;        optionalParameterCount: 0;        yourself</body><body package="Com- Automation">name: aString    memberID: anInteger    typeCode: aTypeCode    parameterNames: anArrayOfStrings    parameterTypes: anArrayOfTypes        " Answer a new instance of the receiver for the method named &lt;aString&gt;        which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.        The type code &lt;aTypeCode&gt; specifies the type of the method return value. "    ^self new        name: aString;        memberID: anInteger;        typeCode: aTypeCode;        parameterNames: anArrayOfStrings;        parameterTypes: anArrayOfTypes;        optionalParameterCount: 0;        yourself</body><body package="Com- Automation">name: aString    memberID: anInteger    typeCode: aTypeCode    parameterNames: anArrayOfStrings    parameterTypes: anArrayOfTypes    optionalParameterCount: aParameterCount        " Answer a new instance of the receiver for the method named &lt;aString&gt;        which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.        The type code &lt;aTypeCode&gt; specifies the type of the method return value. "    ^self new        name: aString;        memberID: anInteger;        typeCode: aTypeCode;        parameterNames: anArrayOfStrings;        parameterTypes: anArrayOfTypes;        optionalParameterCount: aParameterCount;        yourself</body><body package="Com- Automation">name: aString    memberID: anInteger    typeCode: aTypeCode    parameters: parameterDescriptionPairs        " Answer a new instance of the receiver for the method named &lt;aString&gt;        which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.        The parameters are described by an array of name/type pairs.        The type code &lt;aTypeCode&gt; specifies the type of the method return value. "    ^self new        name: aString;        memberID: anInteger;        typeCode: aTypeCode;        parameterNames: ( parameterDescriptionPairs            collect: [ :arr | arr at: 1 ] );        parameterTypeCodes: ( parameterDescriptionPairs            collect: [ :arr | arr at: 2 ] );        optionalParameterCount: 0;        yourself</body><body package="Com- Automation">name: aString memberID: anInteger vtableIndex: anIndex resultType: aTypeCode parameters: parameters optionalParameters: optParamCount	" Answer a new instance of the receiver for the method named &lt;aString&gt;        which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.        The parameters are described by an array of name/type pairs.        The type code &lt;aTypeCode&gt; specifies the type of the method return value. "	^(self new)		name: aString;		memberID: anInteger;		vtableIndex: anIndex;		returnValueDescription: aTypeCode;		parameters: parameters;		optionalParameterCount: optParamCount;		yourself</body><body package="Com- Automation">oldStyleDecodeFromLiteralArray: anArray		" Answer a new instance of the receiver containing the dispatch specifications in the literal representation &lt;anArray&gt;. "	| aDispatchSpecification |	aDispatchSpecification := self name: ( anArray at: 2 )		memberID: ( anArray at: 3 )		typeCode: VT_VOID.	4 to: anArray size by: 2 do: [ :i |		aDispatchSpecification decodeAttribute: ( anArray at: i )			fromLiteral: ( anArray at: i + 1 ) ].	^aDispatchSpecification</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>testing</category><body package="Com- Automation">basicIsEqualTo: aSpecification	(super basicIsEqualTo: aSpecification) ifFalse: [^false].	^self checkEqualityOf: self propertyPutRefSpecification		and: aSpecification propertyPutRefSpecification</body><body package="Com- Automation">isParameterized	"Not the same as hasParamters - just determine the type of property spec"	^ true</body><body package="Com- Automation">isReadOnlyFlagSet	^ self isReadOnly</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>literal representation</category><body package="Com- Automation">decodeAttribute: aSymbol fromLiteral: aLiteralValue	" Apply the value &lt;aLiteralValue&gt; for the attribute named &lt;aSymbol&gt; to the receiver. "	aSymbol = #putResultTypeCode:		ifTrue: 			[^self propertySetSpecification				returnValueDescription: (COMReturnValueDescription						typeCode: (self class typeCodeFromLiteral: aLiteralValue))].	^super decodeAttribute: aSymbol fromLiteral: aLiteralValue</body><body package="Com- Automation">decodeLiteralAttributes: attributes	| accessMode |	accessMode := attributes removeKey: #accessMode: ifAbsent: [nil].	accessMode		ifNotNil: [self decodeAttribute: #accessMode: fromLiteral: accessMode].	super decodeLiteralAttributes: attributes.</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>private emphasised texts</category><body package="Com- Automation">hasResultToDisplay	"Answer whether I have a result type which can be displayed in the browser.	 Subclasses may override this behavior"	^ self propertyGetSpecificationForDisplay hasResult</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>initialize-release</category><body package="Com- Automation">disableReadAccess	"Remove the get access specification to indicate that the receiver is write-only"	propertyGetSpecification := nil.</body><body package="Com- Automation">disableWriteAccess		"Remove the property Set access procification to indicate that the property is read-only"	propertySetSpecification := nil.	propertyPutRefSpecification := nil.</body><body package="Com- Automation">initializeForName: aName memberID: aMemberID typeCode: aTypeCode	| retVal |	retVal := COMReturnValueDescription typeCode: aTypeCode.	self name: aName.	propertyGetSpecification := PropertyAccessSpecification				forPropertyGet: self				parameters: #()				returnValue: retVal				vtableIndex: nil				memberID: aMemberID				flags: 0.	propertySetSpecification := PropertyAccessSpecification				forPropertyPut: self				parameters: #()				returnValue: (COMReturnValueDescription typeCode: VT_VOID)				vtableIndex: nil				memberID: aMemberID				flags: 0.	propertyPutRefSpecification := nil.	self optionalParameterCount: 0</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>specification construction</category><body package="Com- Automation">mergeOperationDescription: aFuncDesc typeInfo: anITypeInfo	" Merge the parameter and type information for the property get/set function        described by the FUNCDESC &lt;aFuncDesc&gt; into the receiver.        &lt;anITypeInfo&gt; is the ITypeInfo interface that provides additional type information.        This service is used to merge the propert set specifications when the        receiver was constructed from the property specification or vice versa. "	self add: (PropertyAccessSpecification				fromFuncDesc: aFuncDesc				property: self				typeInfo: anITypeInfo)</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>accessing</category><body package="Com- Automation">accessMode	| mode |	mode := 0.	self subSpecificationsDo: [:each | mode := mode bitOr: each accessMode].	^mode</body><body package="Com- Automation">add: aSpecification	^ aSpecification addTo: self.</body><body package="Com- Automation">installArgumentKeyword: argumentKeyword	" Install &lt;argumentKeyword&gt; as the anonymous keyword for argument values in the receiver's selector(s). "	argumentKeyword = self defaultArgumentKeyword ifTrue: [^self].	" lazy allocation construction will do the right thing "	self writeSpecificationsDo: 			[:spec |			spec selector: (spec constructSelectorWith: argumentKeyword)].	self propertyGetSpecification		ifNotNil: 			[:spec |			spec selector: (self propertyGetSpecificationForDisplay						constructSelectorWith: argumentKeyword)]</body><body package="Com- Automation">optionalParameterCount: aSmallInteger	self		subSpecificationsDo: [:spec | spec optionalParameterCount: aSmallInteger]</body><body package="Com- Automation">parameterNames: names	"Set the parameter names"	| setNames getNames |	self isReadOnly		ifTrue: [getNames := names]		ifFalse: 			["If the property is writable, the newValue property may not contained in the names collection"			self writeSpecificationsDo: 					[:spec |					names size &lt; spec parameterCount						ifTrue: 							[setNames := names copyWith: 'newValue'.							getNames := names]						ifFalse: 							[setNames := names.							getNames := names allButLast: 1].					spec parameterNames: setNames]].	(self isWriteOnly not and: [getNames size &gt; 0])		ifTrue: 			[" works for nil too"			self propertyGetSpecification parameterNames: getNames]</body><body package="Com- Automation">parameterTypes: types	"Set the parameter-types. This is done for old-style literal-arrays"	| newTypes |	newTypes := self isReadOnly				ifTrue: [types]				ifFalse: 					["If the property can be written, the parameter types include a specification for the newValue parameter.					  This parameter must be removed for the getter"					self writeSpecificationsDo: [:spec | spec parameterTypes: types].					types allButLast: 1].	(self isWriteOnly not and: [newTypes size &gt; 0])		ifTrue: 			[" works for nil too"			self propertyGetSpecification parameterTypes: newTypes]</body><body package="Com- Automation">propertyPutRefSpecification	^propertyPutRefSpecification</body><body package="Com- Automation">propertyPutRefSpecification: anObject	propertyPutRefSpecification := anObject</body><body package="Com- Automation">typeCode: aSmallInteger 	"for compatibility with literal encoding"		| retVal |	retVal := COMReturnValueDescription typeCode: aSmallInteger.	self isWriteOnly ifFalse: [ self propertyGetSpecification returnValueDescription: retVal ].</body><body package="Com- Automation">writePropertySpecificationForArguments: arguments	| coll |	coll := OrderedCollection new.	self writeSpecificationsDo: [:each | coll add: each].	coll size = 1 ifTrue: [^coll any].	^coll detect: [:each | each acceptsArguments: arguments]		ifNone: 			[self error: #NoSpecificationMatchingArgumentsFound &lt;&lt; #com						&gt;&gt; 'No specification counts which machtes the provided arguments']</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>converting</category><body package="Com- Automation">asDispatchSpecification	"return your self as a Dispatch version. Subclasses may override this"	^self isVTable		ifTrue: [self privateAsDispatchSpecification]		ifFalse: [self]</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>private</category><body package="Com- Automation">anyWriteSpecificationDo: aBlock elseDo: anotherBlock	^super anyWriteSpecificationDo: aBlock		elseDo: 			[self propertyPutRefSpecification				ifNil: anotherBlock				ifNotNil: [:spec | aBlock value: spec]]</body><body package="Com- Automation">privateAsDispatchSpecification	^self class		name: self name		getSpecification: (self getSpecification				ifNotNil: [:spec | spec asDispatchSpecification])		putSpecification: (self setSpecification				ifNotNil: [:spec | spec asDispatchSpecification])		putRefSpecification: (self propertyPutRefSpecification				ifNotNil: [:spec | spec asDispatchSpecification])</body><body package="Com- Automation">subSpecificationsDo: aBlock	super subSpecificationsDo: aBlock.	self propertyPutRefSpecification ifNotNil: [:spec | aBlock value: spec]</body><body package="Com- Automation">writeSpecificationsDo: aBlock	super writeSpecificationsDo: aBlock.	self propertyPutRefSpecification ifNotNil: [:spec | aBlock value: spec]</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification</class-id> <category>comparing</category><body package="Com- Automation">= aPropertySpec	^ super = aPropertySpec and: [ propertyPutRefSpecification = aPropertySpec propertyPutRefSpecification ]</body><body package="Com- Automation">hash	self subSpecificationsDo: [:each | ^each hash].	^0</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification class</class-id> <category>private-initialization</category><body package="Com- Automation">initialize	" Private - initialize class state. "	self registerLiteralType: self literalEncodingType forClass: COMDispatchPropertySpecification.	" backwards compatibility for VS 3.1[.1]; superseded by explicit #accessMode: attribute in VS 3.1.2 "	#( 'readOnlyProperty' 'writeOnlyProperty' ) do: [ :aLiteralType |		self registerLiteralType: aLiteralType forClass: COMDispatchPropertySpecification ].</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMDispatchMethodSpecification;		yourself</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification class</class-id> <category>instance creation</category><body package="Com- Automation">forDescription: aFuncDesc typeInfo: anITypeInfo	| instance |	instance := self new.	instance isVTable: anITypeInfo isInterface.	instance add: (PropertyAccessSpecification				fromFuncDesc: aFuncDesc				property: instance				typeInfo: anITypeInfo).	^instance</body><body package="Com- Automation">name: aName getSpecification: getSpecification putSpecification: putSpecification	^(self new)		name: aName;		propertyGetSpecification: getSpecification;		propertySetSpecification: putSpecification;		yourself</body><body package="Com- Automation">name: aName getSpecification: getSpecification putSpecification: putSpecification putRefSpecification: putRefSpecification	^(self new)		name: aName;		propertyGetSpecification: getSpecification;		propertySetSpecification: putSpecification;		propertyPutRefSpecification: putRefSpecification;		yourself</body><body package="Com- Automation">name: aString memberID: anInteger type: aType parameterNames: names parameterTypes: types	" Answer a new instance of the receiver for the property named &lt;aString&gt;		which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.		The type code &lt;aTypeCode&gt; specifies the type of the property value. "	| instance params returnValueDescription |	instance := self new.	instance name: aString.	returnValueDescription := COMReturnValueDescription type: aType.	params := (1 to: names size) collect: 					[:index |					| aName type |					aName := names at: index.					type := types at: index.					COMParameterDescription						name: aName						type: type						flags: 0						defaultValue: nil].	instance add: (PropertyAccessSpecification				forPropertyGet: instance				parameters: params				returnValue: returnValueDescription				vtableIndex: nil				memberID: anInteger				flags: 0).	instance add: (PropertyAccessSpecification				forPropertyPut: instance				parameters: (params						copyWith: (returnValueDescription asParamName: 'newValue'))				returnValue: nil				vtableIndex: nil				memberID: anInteger				flags: 0).	^instance</body><body package="Com- Automation">name: aByteString memberID: aLargePositiveInteger typeCode: aSmallInteger 	^ self new		initializeForName: aByteString memberID: aLargePositiveInteger typeCode: aSmallInteger;		yourself</body></methods><methods><class-id>External.COMDispatchParameterizedPropertySpecification class</class-id> <category>literal representation</category><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(#propertyPutRefSpecification #isVTable)</body></methods><methods><class-id>External.COMDispatchError</class-id> <category>accessing</category><body package="Com- Automation">exceptionDescription		" Answer the IDispatch exception description. "	^exceptionDescription</body><body package="Com- Automation">exceptionDescription: aString        " Set the IDispatch exception description. "	exceptionDescription := aString.	aString notNil		ifTrue: [ self messageText: self messageText, ' ', aString ].</body><body package="Com- Automation">exceptionInfo		" Answer the IDispatch exception information. "	^exceptionInfo</body><body package="Com- Automation">exceptionInfo: info		" Set the IDispatch exception information. "	exceptionInfo := info.</body></methods><methods><class-id>External.COMDispatchError</class-id> <category>class-signalling</category><body package="Com- Automation">hresult: anInteger description: aString info: info        "Signal a newly created instance of the receiver with the result code set to &lt;anInteger&gt;."	^self 		hresultAttribute: anInteger;		ensureMessageTextInstalled;		exceptionDescription: aString;		exceptionInfo: info;		yourself</body></methods><methods><class-id>External.COMDispatchError</class-id> <category>private-defaults</category><body package="Com- Automation">defaultAction	ImageConfiguration errorNotifierClass notify: self context: thisContext sender</body></methods><methods><class-id>External.COMDispatchError class</class-id> <category>class-signalling</category><body package="Com- Automation">hresult: anInteger description: aString info: info        "Signal a newly created instance of the receiver with the result code set to &lt;anInteger&gt;."    ^( self new hresult: anInteger description: aString info: info )		raiseSignal</body></methods><methods><class-id>External.DispUnionDescription</class-id> <category>accessing</category><body package="Com- Automation">elementClass	"Return the class which usually represents my elements"		^ ComponentElementDescription</body><body package="Com- Automation">kindname	^  (#TKindUnion &lt;&lt; #com &gt;&gt; 'Union') asString</body><body package="Com- Automation">sizeInBytes	^sizeInBytes</body><body package="Com- Automation">sizeInBytes: anObject	sizeInBytes := anObject</body><body package="Com- Automation">typecode	^ VT_RECORD</body></methods><methods><class-id>External.DispUnionDescription</class-id> <category>private</category><body package="Com- Automation">cElementValue: anElement	"retrieve the c value for an element"	^  anElement index -&gt; anElement cType</body><body package="Com- Automation">newCType	^ CCompositeType new			dataSize: self sizeInBytes;			beUnion;			yourself</body><body package="Com- Automation">newElementCollection	^ SortedCollection sortBlock: [:a :b | a index &lt; b index]</body></methods><methods><class-id>External.DispUnionDescription</class-id> <category>marshaling</category><body package="Com- Automation">marshalInArgument: anArgument	| datum type |	type := self cType.	datum := type new.	anArgument marshalUnionType: self cType: type intoStruct: datum.	^ datum</body><body package="Com- Automation">unmarshalOutParam: aParam	^ aParam</body></methods><methods><class-id>External.DispUnionDescription class</class-id> <category>private constants</category><body package="Com- Automation">typekinds	^ Array with: TKIND_UNION</body></methods><methods><class-id>External.DispUnionDescription class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFromTypeInfo: refTypeInfo typeLib: aTypeLibDescriptor 	^ (super basicFromTypeInfo: refTypeInfo typeLib: aTypeLibDescriptor)					sizeInBytes: (refTypeInfo withTypeAttrDo: [:typeAttr | typeAttr instanceSizeInBytes ]);			yourself</body></methods><methods><class-id>External.SpecialVariantArg</class-id> <category>configuring</category><body package="Com- Automation">beRecordGetRefValueAccessor	"configure the receiver to be an accessor for the get-field-no-copy operation of a COMRecord.	  The ownsMemory behaviour doesnt matter, the variant does not own referenced memory 	  and may not free it "	self memoryPolicy 		ownsMemory: true;		ownsReferencedMemory: false.</body><body package="Com- Automation">beRecordGetValueAccessor	"configure the receiver to be an accessor for the get field	 operation of a COMRecord. It owns outside memory, but not refernced memory - this memory is very probably 	 not copied by the #getfield operation"	self memoryPolicy 		ownsMemory: true;		ownsReferencedMemory: false.</body><body package="Com- Automation">beRecordReleaseAccessor	"configure the receiver to be an accessor for releasing elements of a COMRecord. The variant owns both, directly referenced	 memory areas like BSTR elements and referenced ares marked using VT_BYREF, altough members without VT_BSTR	 mark will not appear"	self memoryPolicy 		ownsMemory: true;		ownsReferencedMemory: true.</body><body package="Com- Automation">beSafeArrayElementReference	"configure the receiver to be a direct reference to a SafeArray's element"	self memoryPolicy 		ownsMemory: false;		ownsReferencedMemory: false.</body></methods><methods><class-id>External.SpecialVariantArg</class-id> <category>accessing</category><body package="Com- Automation">comVariantType	" Assuming the COMVariantType of a Variant is VT_VARIANT "	^ self isReference 		ifTrue: 	[  VT_VARIANT | VT_BYREF ]		ifFalse:	[  VT_VARIANT  ]</body><body package="Com- Automation">memoryPolicy	^memoryPolicy ifNil: [ memoryPolicy := VariantMemoryPolicy new ]</body><body package="Com- Automation">memoryPolicy: anObject	memoryPolicy := anObject</body></methods><methods><class-id>External.SpecialVariantArg</class-id> <category>private-releasing</category><body package="Com- Automation">clearVariant	" Private - clear the VARIANTARG structure.  Release any referenced memory. "	Tools.Note ISSUE.	" Can we just make this part of #clear?  If that is treated as a private		operation, which it probably should be, then let's shift this code there		and be done with it.  [DL 09-Aug-96] "	self isValid ifTrue: [		(self memoryPolicy ownsReferencedMemory and: [self isReference]) 			ifTrue: [self releaseReference].		self memoryPolicy ownsMemory 			ifTrue: [ self clear]].</body><body package="Com- Automation">releaseReference	| lpValue |	self containsRecord ifTrue: [ ^ self value enforceRelease ].	self isSafeArray ifTrue: [ ^ self realValue value enforceRelease ].	( lpValue := self refPointer ) notNil				ifTrue: [   " VariantClear does not release ref'd value "					lpValue free.					Tools.Note ISSUE.  " Is the following useful or simply overzealous?? [DL 09-Aug-96] "					self refPointer: nil. ].</body></methods><methods><class-id>External.SpecialVariantArg class</class-id> <category>instance creation</category><body package="Com- Automation">typeDescription: aType pointer: aPointer	" Answer a new instance of the receiver that represents &lt;aValue&gt; as type &lt;aTypeCode&gt;. "	| aVariant |	aVariant := self new.	"VT_VARIANT, alone (without VT_BYREF) is not a legal value for the vt field in a structure, adjust type code to the value being set."	aVariant typeDescription: aType.	aVariant isReference		ifFalse: [ self error: (#OnlyByrefVariantsSupported &lt;&lt; #com &gt;&gt; 'It is not supported to create references to existing data pointers using no-BYREF variants') ].	aType setRefPointer: aPointer in: aVariant.	aVariant beSafeArrayElementReference.	^aVariant</body></methods><methods><class-id>External.SpecialVariantArg class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #specialVARIANTARG.	self updateAndRegister</body></methods><methods><class-id>External.TypeElementDescription</class-id> <category>comparing</category><body package="Com- Automation">= another	^ self class = another class and: [		self hash = another hash]</body><body package="Com- Automation">hash	^ self name hash</body></methods><methods><class-id>External.TypeElementDescription</class-id> <category>accessing</category><body package="Com- Automation">docs	^docs ifNil: [self computeDocs ]</body><body package="Com- Automation">docs: anObject	docs := anObject</body><body package="Com- Automation">documentation	^self docs at: 'documentation' ifAbsent: [ nil ]</body><body package="Com- Automation">name	^self docs ifNil: [^nil] ifNotNil: [docs at: 'name' ifAbsent: [^nil]]</body><body package="Com- Automation">name: aName	self docs at: 'name' put: aName</body><body package="Com- Automation">typeName	"Return the name of my type - I am a constant, so return it"	self subclassResponsibility</body></methods><methods><class-id>External.TypeElementDescription</class-id> <category>private</category><body package="Com- Automation">computeDocs 	^ docs := Dictionary new</body></methods><methods><class-id>External.TypeElementDescription class</class-id> <category>instance creation</category><body package="Com- Automation">docs: docs 	^(self new)		docs: docs;		yourself</body><body package="Com- Automation">fromVarDesc: varDesc 	^self docs: varDesc getDocumentation</body></methods><methods><class-id>External.COMLicenseManager</class-id> <category>ILicenseManager protocol</category><body package="Com- Automation">CreateInstance: clsid _: aControllingUnknown _: iid _: license _: resultReference	| factory |	factory := self class registeredClasses at: clsid ifAbsent: [^E_INVALIDARG].	^factory		CreateInstanceLic: aControllingUnknown		_: nil		_: iid		_: license		_: resultReference</body><body package="Com- Automation">IsDevelopment: classId _: resultReference	| factory |	factory := self class registeredClasses at: classId ifAbsent: [^E_INVALIDARG].	resultReference		value: (factory requiresLicensedCreation: factory licenseProvider) not.	^S_OK</body><body package="Com- Automation">QueryLicenseKey: clsid _: resultReference	| factory |	factory := self class registeredClasses at: clsid ifAbsent: [^E_INVALIDARG].	^factory RequestLicKey: 0 _: resultReference</body></methods><methods><class-id>External.COMLicenseManager</class-id> <category>subclass-accessing</category><body package="Com- Automation">getInterfaceForIID: anIID	^anIID = IID_ILicenseManager ifTrue: [self iLicenseManager] ifFalse: [nil]</body></methods><methods><class-id>External.COMLicenseManager</class-id> <category>subclass-enumerating</category><body package="Com- Automation">allocatedInterfacesDo: aOneArgBlock	" Private - enumerate the interfaces supported by the receiver which have been allocated during its lifetime and evaluate &lt;aOneArgBlock&gt; with each.  Should be reimplemented by each subclass.  The subclass implementation should invoke the superclass method before enumerating the allocated interfaces managed in subclass storage. "	super allocatedInterfacesDo: aOneArgBlock.	self iLicenseManager ifNotNil: [:itf | aOneArgBlock value: itf]</body></methods><methods><class-id>External.COMLicenseManager</class-id> <category>accessing interfaces</category><body package="Com- Automation">iLicenseManager	^iLicenseManager ifNil: [iLicenseManager := ILicenseManager directBindingOn: self]</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>registering classes for instance creation</category><body package="Com- Automation">registerClass: aClass	"Register the given class and make it available for clients through the	 ILicenseManager::CrreateInstance() method"	| factory |	factory := self factoryForClass: aClass.	"If the class is not a subclass of COMObject the method assumes it is class published over Automation."	^self registerFactory: factory</body><body package="Com- Automation">registerFactory: aClassFactory	self registeredClasses at: aClassFactory objectCLSID put: aClassFactory.</body><body package="Com- Automation">resetRegisteredClasses	Classes := nil.</body><body package="Com- Automation">revokeAllClassFactories	self resetRegisteredClasses.</body><body package="Com- Automation">revokeFactory: aClassFactory	self registeredClasses removeKey: aClassFactory objectCLSID.</body><body package="Com- Automation">revokeRegistrationForClass: aClass	self registeredClasses removeKey: aClass clsid.</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>com registration</category><body package="Com- Automation">comRegistrationSpec	"Returns the specification which allows registering the component from the command-line"	^ COMAutomationRegistration new		versionIndependentDescription: 'VisualWorks COM License Manager';		versionIndependentProgID: 'VisualWorks.COMLicenseManager';		typeLibraries: self typeLibraries;		majorVersion: 1;		minorVersion: 0;		clsid: self clsid;		yourself</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>private</category><body package="Com- Automation">factoryForClass: aClass	"self factoryForClass: Examples.AutomationAllDataTypes"	^(aClass inheritsFrom: COMObject)		ifTrue: [aClass newClassFactory]		ifFalse: 			["If the class is not a subclass of COMObject the method assumes it is a class published via Automation."			COMAutomationServerClassFactoryObject				forClass: COMAutomationServer				automationObjectClass: aClass				clsid: aClass clsid				specificationTable: aClass specificationTable				typeLibraries: aClass typeLibraries]</body><body package="Com- Automation">registeredClasses 	^ Classes ifNil: [ Classes := Dictionary new ].</body><body package="Com- Automation">try: aBlock with: anObject	[aBlock value: anObject] on: Error do: [:ex | ex return]</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>installation</category><body package="Com- Automation">installRuntime	self registerSessionEventHandlers;		releaseTypeLibraries;		registerTypeLibraries.</body><body package="Com- Automation">registerClassFactoryAndLibraries	"Make sure the type libraries are ok and register the class factory for the object server application. This method can be invoked to test a COM object from the same image it will be published from or during server application startup.  Answer the class factory."	self updateTypeLibraries.	^self registerServerClassFactory</body><body package="Com- Automation">registerSessionEventHandlers	"Install the event handlers for the receiver."	"Tests	COMSessionManager actionListForEvent: #shutdownImage.	COMSessionManager actionListForEvent: #confirmSaveImage.	COMSystem current actionListForEvent: #deploymentStartup	"	self removeSessionEventHandlers.  " always safe "	COMSessionManager 		when: #shutdownImage		send: #releaseTypeLibraries to: self.	COMSessionManager 		when: #confirmSaveImage		send: #releaseTypeLibraries to: self.	COMSystem current 		when: #deploymentStartup		send: #startUpApplication to: self.</body><body package="Com- Automation">removeSessionEventHandlers	"Remove the registration of any session event handlers for the receiver."	COMSystem current removeAllActionsWithReceiver: self.	COMSessionManager removeAllActionsWithReceiver: self.</body><body package="Com- Automation">unregister	"Uninstall this Automation server sample."	" self unregister "	self unregisterTypeLibraries.	self releaseTypeLibraries.	COMSystem current removeAllActionsWithReceiver: self.</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>identity</category><body package="Com- Automation">defaultClsid	^GUID		fromBytes: #[16rCF 16r10 16r74 16r37 16r50 16r65 16rB7 16r43 16r9D 16rA0 16rC0 16r79 16rB0 16rD6 16r7E 16r15]</body><body package="Com- Automation">lcid	^Win32ExternalInterface lcidNeutral</body><body package="Com- Automation">typeLibraryID	^GUID		fromBytes: #[16r30 16r72 16r7A 16r47 16r13 16r5F 16r9D 16r44 16r94 16r5C 16r72 16r39 16rBF 16r3F 16r7B 16rE7]</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	super initialize.	self clsid: self defaultClsid</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>finalization</category><body package="Com- Automation">finalize	"This method is run at COM Connect un-installation time."	" self finalize "	super finalize.	self clsid: nil.	TypeLibraries := nil.</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>session management</category><body package="Com- Automation">registerTypeLibraryEventHandlers	"Install the event handlers for the receiver."	COMSessionManager 		when: #shutdownImage		send: #releaseTypeLibraries to: self.	COMSessionManager 		when: #confirmSaveImage		send: #releaseTypeLibraries to: self</body><body package="Com- Automation">releaseTypeLibraries	self typeLibraries do: [:each | each enforceRelease ].	"release type libraries of published classes"	self registeredClasses do: [:each | self try: #releaseTypeLibraries with: each typeLibraryHolder].</body><body package="Com- Automation">startUpApplication	"Start up the Automation object server."	"Initialize COM and verify that the application is being run as an object server."	COMSessionManager initializeAutomationServer.	"Make sure the type libraries are ok and register the class factory for the object server application. This method can be invoked to test a COM object from the same image it will be published from."	self registerClassFactoryAndLibraries</body></methods><methods><class-id>External.COMLicenseManager class</class-id> <category>type libraries</category><body package="Com- Automation">getTypeLibraries	"Answer a Collection of the type libraries used for the application. The locale ID must be specified for each COMTypeLibrary since the framework will use this field as an index."	| myTypeLibraries lib |	myTypeLibraries := Dictionary new.	lib := self newTypeLibraryNeutral.	myTypeLibraries at: lib lcid put: lib.	^myTypeLibraries</body><body package="Com- Automation">newTypeLibraryNeutral	"Answer a type library for the English language for the application."	^(COMTypeLibrary new)		libraryID: self typeLibraryID;		lcid: self lcid;		directoryName: '$(VISUALWORKS}\com\VWLicenseManager';		fileName: 'VWLicenseManager.tlb';		majorVersion: 1;		minorVersion: 0</body><body package="Com- Automation">registerTypeLibraries	"Register the type libraries."	self typeLibraries do: [:aTypeLibrary | aTypeLibrary createRegistration].	self registeredClasses		do: [:each | self try: #registerTypeLibraries with: each typeLibraryHolder]</body><body package="Com- Automation">typeLibraries	"Answer the type library dictionary. The dictionary keys are LCIDs and the values are instances of COMTypeLibrary. If the receiver has type libraries, then register event handlers to perform clean up operations. Answer nil or a Dictionary."	TypeLibraries isNil 		ifTrue: [ 			| tmp |			tmp := self getTypeLibraries.			tmp size &gt; 0				ifTrue: [ self registerTypeLibraryEventHandlers ].			TypeLibraries := tmp ]. 	^TypeLibraries</body><body package="Com- Automation">unregisterTypeLibraries	"Unregister the type libraries." 	self typeLibraries do: [ : aTypeLibrary | aTypeLibrary removeRegistration ].	self registeredClasses do: [:each | self try: #unregisterTypeLibraries with: each typeLibraryHolder ].</body><body package="Com- Automation">updateTypeLibraries	"Update the registry for each type library defined by the application. See also COMTypeLibrary&gt;&gt;updateRegistration."	self typeLibraries do: [:aTypeLibrary | aTypeLibrary updateRegistration].	self registeredClasses		do: [:each | self try: #updateTypeLibraries with: each typeLibraryHolder]</body></methods><methods><class-id>External.COMDate</class-id> <category>private-accessing</category><body package="Com- Automation">setDateValue: aDate    "Private - Set the value of the receiver to &lt;aDate&gt;."	" VS version was: "	"self value: ( aDate day + 367.0 )"	self value: 		( ( aDate subtractDate: self class baseDate ) asDouble			+ 2 )</body><body package="Com- Automation">setTimeStampValue: aTimeStamp    "Private. Set the value of receiver to a &lt;aTimeStamp&gt;."    | resultReference |    resultReference := nil asValueReference.    OLEAutomationDLL current SystemTimeToVariantTime: aTimeStamp        _: resultReference.    self value: resultReference value.</body><body package="Com- Automation">value: aDouble		" Private - set the value of the receiver to the VT_DATE double-precision value &lt;aDouble&gt; . "	value := aDouble.</body></methods><methods><class-id>External.COMDate</class-id> <category>converting</category><body package="Com- Automation">asDate	"Answer a Date representing the date described by the receiver."	"Note: Midnight Jan1, 1900 = 2.0, 1900 was not a leap year."	" VS version was: "	"^Date fromDays: self value truncated - 367"		^self class baseDate addDays: ( self value asInteger - 2 )</body><body package="Com- Automation">asTimestamp	"Answer a Timestamp representing the date described by the receiver.A variant time is stored as an 8-byte real value (double), representing a date between January 1, 1753 and December 31, 2078, inclusive. The value 2.0 represents January 1, 1900; 3.0 represents January 2, 1900, and so on. Adding 1 to the value increments the date by a day. The fractional part of the value represents the time of day. Therefore, 2.5 represents noon on January 1, 1900; 3.25 represents 6:00 a.m. on January 2, 1900, and so on. Negative numbers represent the dates prior to December 30, 1899.    "	| resultReferenceSystemTime |	resultReferenceSystemTime := nil asValueReference.	OLEAutomationDLL current VariantTimeToSystemTime: self value		_: resultReferenceSystemTime.	"Assert isTrue: [ self asDate = resultReferenceSystemTime value asDate ]."	^resultReferenceSystemTime value asTimestamp</body></methods><methods><class-id>External.COMDate</class-id> <category>accessing</category><body package="Com- Automation">value		" Answer the VT_DATE double-precision value of the receiver. "	^value</body></methods><methods><class-id>External.COMDate</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt;. "	self asTimestamp printOn: aStream</body></methods><methods><class-id>External.COMDate class</class-id> <category>instance creation</category><body package="Com- Automation">fromDATEValue: aDouble		" Answer a new instance of the receiver for the double-precision VT_DATE value &lt;aDouble&gt;. "	^self new value: aDouble</body><body package="Com- Automation">fromDate: aDate		"Answer a new instance of the receiver that represents 		the same date as &lt;aDate&gt;."    ^self new setDateValue: aDate</body><body package="Com- Automation">fromTimeStamp: aTimeStamp	"OBSOLETE"        "Answer a new instance of the receiver that represents        the same date and time as &lt;aTimeStamp&gt;."    ^self new setTimeStampValue: aTimeStamp</body><body package="Com- Automation">fromTimestamp: aTimeStamp        "Answer a new instance of the receiver that represents        the same date and time as &lt;aTimeStamp&gt;."    ^self new setTimeStampValue: aTimeStamp</body><body package="Com- Automation">fromValue: aValue	"Private. Answer &lt;aValue&gt; as a COM DATE structure."	Tools.Note portingPatch.  " Bring in #isFoo guys??  Use #isKindOf: ?? [DL 13-Mar-96] "	aValue class == COMDate		ifTrue: [ ^aValue ].	( aValue "isDate" isKindOf: Date )		ifTrue: [ ^self fromDate: aValue ].	( aValue "isTimeStamp" isKindOf: Timestamp )		ifTrue: [ ^self fromTimeStamp: aValue ].	( aValue isKindOf: LimitedPrecisionReal )		ifTrue: [ ^COMDate fromDATEValue: aValue ].	COMError raiseSignal: #ErrNotConvertToDate &lt;&lt; #com &gt;&gt; 'Could not convert to a COM DATE.'</body><body package="Com- Automation">now	"Answer the current system time."	^self fromTimeStamp: Win32_SYSTEMTIME now asTimestamp</body></methods><methods><class-id>External.COMDate class</class-id> <category>external-transformations</category><body package="Com- Automation">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a COM DATE.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^COMDateResultBuffer new</body></methods><methods><class-id>External.COMDate class</class-id> <category>private-converting</category><body package="Com- Automation">baseDate	"Answer the Date which defines the baseline for representing OLE Date values."	"A COM automation date is defined relative to January 1, 1900 (2.0d)"	^Date newDay: 1 monthNumber: 1 year: 1900</body></methods><methods><class-id>External.COMTypeCompilerLookupSpecificationPolicy</class-id> <category>accessing</category><body package="Com- Automation">typeComp: anOLEDispatchDriver	"Answer the cached type compiler or initialize the cache from &lt;anOLEDispatchDriver&gt;."	typeComp notNil		ifTrue: [ ^typeComp ].	^typeComp := ( self typeInfoFor: anOLEDispatchDriver ) getTypeComp</body><body package="Com- Automation">typeInfoFor: anOLEDispatchDriver	"Answer the cached type information.or initialize the cache from &lt;anOLEDispatchDriver&gt;."	typeInfo notNil		ifTrue: [ ^typeInfo ].	^typeInfo := anOLEDispatchDriver getTypeInfo</body></methods><methods><class-id>External.COMTypeCompilerLookupSpecificationPolicy</class-id> <category>private-lookup</category><body package="Com- Automation">bind: flags name: aName dispatchDriver: anOLEDispatchDriver    "Private."	| aTypeComp |	aTypeComp := self typeComp: anOLEDispatchDriver.	^aTypeComp bind: aName flags: flags lcid: anOLEDispatchDriver localeID.</body><body package="Com- Automation">bind: flags name: aName typeInfo: anITypeInfo lcid: lcid	"Private."	| aTypeComp |	aTypeComp := anITypeInfo getTypeComp.	^aTypeComp bind: aName flags: flags lcid: lcid</body></methods><methods><class-id>External.COMTypeCompilerLookupSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">allowsSpecificationTableUpdates	"Answer whether it makes sense for the receiver to update the specification table ."    ^true</body><body package="Com- Automation">canSupportIDispatch: anIDispatch forLocaleID: aLocaleID	| canSupportPolicy anITypeInfo anITypeComp |	[anITypeInfo := anIDispatch getTypeInfoForLocale: aLocaleID] on: COMError do: [:ex | ^false].	[anITypeComp := anITypeInfo getTypeComp] on: COMError do: [:ex | ^false].	canSupportPolicy := anITypeComp notNil.	^canSupportPolicy</body><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^true</body></methods><methods><class-id>External.COMTypeCompilerLookupSpecificationPolicy</class-id> <category>description</category><body package="Com- Automation">description	"Answer a description for the recevier."	^'type compiler'</body></methods><methods><class-id>External.COMTypeCompilerLookupSpecificationPolicy</class-id> <category>releasing</category><body package="Com- Automation">release	"Release resources associated with the receiver."	typeComp enforceRelease.	typeComp := nil.	typeInfo := nil.	super release</body></methods><methods><class-id>External.COMTypeCompilerLookupSpecificationPolicy</class-id> <category>private lookup-method</category><body package="Com- Automation">methodSpecification: aName withArguments: argValuesArray for: anOLEDispatchDriver	"Lookup and answer a new method specification for &lt;aName&gt;."	^(self bind: INVOKE_FUNC name: aName dispatchDriver: anOLEDispatchDriver)		ifNotNil: 			[:aBoundName |						[COMDispatchMethodSpecification forDescription: aBoundName description				typeInfo: (self typeInfoFor: anOLEDispatchDriver)]					ensure: [aBoundName release]]</body><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    withNamedArguments: argValuesDictionary    for: anOLEDispatchDriver    "Lookup and answer a new method specification for &lt;aName&gt;."    ^self methodSpecification: aName        withArguments: argValuesArray        for: anOLEDispatchDriver</body></methods><methods><class-id>External.COMTypeCompilerLookupSpecificationPolicy</class-id> <category>private lookup-property</category><body package="Com- Automation">propertyAccessSpecificationForFunction: aName flags: flags for: anOLEDispatchDriver	"Lookup and answer a new property specification for &lt;aName&gt;."	| aBoundName |	aBoundName := self				bind: flags				name: aName				dispatchDriver: anOLEDispatchDriver.	aBoundName isNil ifTrue: [^nil].	^PropertyAccessSpecification fromFuncDesc: aBoundName description</body><body package="Com- Automation">propertySpecFromFunctionNamed: aName arguments: argValuesArray for: anOLEDispatchDriver	| getSpec putSpec |	getSpec := self				propertyAccessSpecificationForFunction: aName				flags: INVOKE_PROPERTYGET				for: anOLEDispatchDriver.	putSpec := self				propertyAccessSpecificationForFunction: aName				flags: INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF				for: anOLEDispatchDriver.	(getSpec isNil and: [putSpec isNil]) ifTrue: [^nil].	^COMDispatchParameterizedPropertySpecification		name: aName		getSpecification: getSpec		putSpecification: putSpec</body><body package="Com- Automation">propertySpecification: aName flags: flags withGetArguments: argValuesArray for: anOLEDispatchDriver	"Lookup and answer a new property specification for &lt;aName&gt;."	| aBoundName specification aPropertyClass |	aBoundName := self				bind: flags				name: aName				dispatchDriver: anOLEDispatchDriver.	aBoundName isNil ifTrue: [^nil].	aBoundName isVariable		ifTrue: [aPropertyClass := COMDispatchPropertySpecification].	aBoundName isFunction		ifTrue: 			[aPropertyClass := aBoundName parameterCount = 0						ifTrue: [COMDispatchPropertySpecification]						ifFalse: [COMDispatchParameterizedPropertySpecification]].	specification := aPropertyClass forDescription: aBoundName description				typeInfo: (self typeInfoFor: anOLEDispatchDriver).	^specification</body><body package="Com- Automation">propertySpecification: aName withGetArguments: argValuesArray for: anOLEDispatchDriver	"Lookup and answer a new property specification for &lt;aName&gt;."	^(self		propertySpecificationFromVarNamed: aName		arg: argValuesArray		for: anOLEDispatchDriver)			ifNil: 				[self					propertySpecFromFunctionNamed: aName					arguments: argValuesArray					for: anOLEDispatchDriver]</body><body package="Com- Automation">propertySpecificationFromVarNamed: aName arg: argValuesArray for: anOLEDispatchDriver	^	[self		propertySpecification: aName		flags: INVOKE_PROPERTYGET | INVOKE_PROPERTYPUT | INVOKE_PROPERTYPUTREF		withGetArguments: argValuesArray		for: anOLEDispatchDriver]			on: COMError			do: [:ex | ex return: nil]</body></methods><methods><class-id>External.RecordAccessElement</class-id> <category>member accessing</category><body package="Com- Automation">getMemberIn: aRecord	^ aRecord basicMemberAt: name</body><body package="Com- Automation">getMemberReferenceIn: aRecord	^ aRecord basicRefMemberAt: name</body><body package="Com- Automation">setValue: aValue in: aRecord	^ aRecord basicMemberAt: name put: aValue.</body></methods><methods><class-id>External.RecordAccessElement</class-id> <category>accessing</category><body package="Com- Automation">name	^name</body><body package="Com- Automation">name: anObject	name := anObject.</body></methods><methods><class-id>External.RecordAccessElement class</class-id> <category>instance creation</category><body package="Com- Automation">fromString: aString	^ (aString includes: $[) 		ifTrue: [ RecordArrayElementAccessElement basicFromString: aString ]		ifFalse:[  self newName: aString]</body><body package="Com- Automation">newName: aName	^ self new		name: aName;		yourself</body></methods><methods><class-id>External.VariantMemoryPolicy</class-id> <category>accessing</category><body package="Com- Automation">ownsMemory	"Answer whether the owner of this policy owns external memory"	^ownsMemory ifNil: [ false]</body><body package="Com- Automation">ownsMemory: anObject	ownsMemory := anObject</body><body package="Com- Automation">ownsReferencedMemory	"Answer whether the owner of this policy owns external memory marked as BYREF"	^ownsReferencedMemory ifNil: [ false]</body><body package="Com- Automation">ownsReferencedMemory: anObject	ownsReferencedMemory := anObject</body></methods><methods><class-id>External.VariantMemoryPolicy</class-id> <category>testing</category><body package="Com- Automation">ownsAnyMemory	^ self ownsMemory or: [self ownsReferencedMemory ]</body></methods><methods><class-id>External.COMDispatchPropertySpecification</class-id> <category>private-initialization</category><body package="Com- Automation">disableReadAccess		" Set the receiver's access mode flags to indicate that the property is not readable. "	accessMode := ( accessMode bitXor: 1 ).</body><body package="Com- Automation">disableWriteAccess		" Set the receiver's access mode flags to indicate that the property is not writeable. "	accessMode := ( accessMode bitXor: 2 ).</body><body package="Com- Automation">enableReadAccess		" Set the receiver's access mode flags to indicate that the property is readable. "	accessMode := ( accessMode bitOr: 1 ).</body><body package="Com- Automation">enableReadWriteAccess		" Set the receiver's access mode flags to indicate that the property is readable and writeable. "	accessMode := ( accessMode bitOr: 3 ).</body><body package="Com- Automation">enableWriteAccess		" Set the receiver's access mode flags to indicate that the property is writeable. "	accessMode := ( accessMode bitOr: 2 ).</body><body package="Com- Automation">initialize		" Private - initialize a new instance. "	accessMode := 0.	self enableReadWriteAccess.</body><body package="Com- Automation">initializePropertyGetSpecification	^self isWriteOnly		ifTrue: [nil]		ifFalse: 			[PropertyAccessSpecification				forPropertyGet: self				parameters: self parameters				returnValue: self returnValueDescription				vtableIndex: self vtableIndex				memberID: self memberID				flags: self flags]</body><body package="Com- Automation">initializePropertySetSpecification	^self isReadOnly		ifTrue: [nil]		ifFalse: 			[PropertyAccessSpecification				forPropertyPut: self				parameters: (self parameters						copyWith: (self returnValueDescription asParamName: 'newValue'))				returnValue: COMReturnValueDescription newEmpty				vtableIndex: self vtableIndex				memberID: self memberID				flags: self flags]</body></methods><methods><class-id>External.COMDispatchPropertySpecification</class-id> <category>accessing</category><body package="Com- Automation">accessMode	^accessMode</body><body package="Com- Automation">accessMode: anObject	accessMode := anObject</body><body package="Com- Automation">flags	^flags</body><body package="Com- Automation">flags: anObject	flags := anObject</body><body package="Com- Automation">memberID	^ memberID</body><body package="Com- Automation">memberID: anObject	memberID := anObject</body><body package="Com- Automation">parameterTypes: typeCodes	self shouldNotImplement</body><body package="Com- Automation">parameters	^  #()</body><body package="Com- Automation">propertyGetSpecification	^propertyGetSpecification ifNil: [ propertyGetSpecification := self initializePropertyGetSpecification ].</body><body package="Com- Automation">propertySetSpecification	^propertySetSpecification ifNil: [ propertySetSpecification := self initializePropertySetSpecification ].</body><body package="Com- Automation">returnValueDescription	^returnValueDescription</body><body package="Com- Automation">returnValueDescription: anObject	returnValueDescription := anObject</body><body package="Com- Automation">selectors	| coll |	coll := Set new.	self		subSpecificationsDo: [:spec | coll add: spec selector].	^coll asArray</body><body package="Com- Automation">typeCode: aSmallInteger 	"for compatibility with literal encoding"		returnValueDescription := COMReturnValueDescription typeCode: aSmallInteger.</body><body package="Com- Automation">vtableIndex	^vtableIndex</body><body package="Com- Automation">vtableIndex: anObject	vtableIndex := anObject</body></methods><methods><class-id>External.COMDispatchPropertySpecification</class-id> <category>comparing</category><body package="Com- Automation">hash	^self memberID</body></methods><methods><class-id>External.COMDispatchPropertySpecification</class-id> <category>testing</category><body package="Com- Automation">isVTable	^false</body></methods><methods><class-id>External.COMDispatchPropertySpecification class</class-id> <category>parcel load/unload/save</category><body package="Com- Automation">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMDispatchMethodSpecification;		yourself</body></methods><methods><class-id>External.COMDispatchPropertySpecification class</class-id> <category>private-initialization</category><body package="Com- Automation">initialize	" Private - initialize class state. "	self registerLiteralType: self literalEncodingType forClass: COMDispatchPropertySpecification.	" backwards compatibility for VS 3.1[.1]; superseded by explicit #accessMode: attribute in VS 3.1.2 "	#( 'readOnlyProperty' 'writeOnlyProperty' ) do: [ :aLiteralType |		self registerLiteralType: aLiteralType forClass: COMDispatchPropertySpecification ].</body></methods><methods><class-id>External.COMDispatchPropertySpecification class</class-id> <category>instance creation</category><body package="Com- Automation">forDescription: aVarDesc typeInfo: anITypeInfo	" Answer a new instance of the receiver initialized for the property 		described by the VARDESC &lt;aVarDesc&gt;.  Additional type information		is proved by the ITypeInfo interface &lt;anITypeInfo&gt;. "	| propertyName |	propertyName := aVarDesc getName.	^(self		name: propertyName		memberID: aVarDesc memberID		type: (COMReturnValueDescription				fromElemDesc: aVarDesc propertyValueDescription				typeInfo: anITypeInfo))		vtableIndex: aVarDesc vtableIndex "may also be a FUNCDESC";		description: (self descriptionFor: aVarDesc memberID typeInfo: anITypeInfo);		flags: aVarDesc flags;		yourself</body><body package="Com- Automation">name: aString memberID: anInteger type: aType		" Answer a new instance of the receiver for the property named &lt;aString&gt;		which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.		The type code &lt;aTypeCode&gt; specifies the type of the property value. "	^self new		name: aString;		memberID: anInteger;		returnValueDescription: aType;		yourself</body><body package="Com- Automation">name: aString memberID: anInteger typeCode: aTypeCode		" Answer a new instance of the receiver for the property named &lt;aString&gt;		which is identified by the DISPID &lt;anInteger&gt; in its dispatch interface.		The type code &lt;aTypeCode&gt; specifies the type of the property value. "	^self new		name: aString;		memberID: anInteger;		typeCode: aTypeCode;		yourself</body></methods><methods><class-id>External.COMDispatchPropertySpecification class</class-id> <category>literal representation</category><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(accessMode flags memberID returnValueDescription vtableIndex)</body></methods><methods><class-id>External.COMDispatchPropertySpecification class</class-id> <category>accessing</category><body package="Com- Automation">defaultPropertySpecification	^self name: #DefaultProperty memberID: 0 typeCode: VT_VARIANT</body></methods><methods><class-id>External.BSTRMemoryAddress</class-id> <category>subclass-accessing</category><body package="Com- Automation">atOffset: anInteger	"Private - answer the byte at the zero relative offset &lt;anInteger&gt; in the memory referenced by the receiver."	" We want an offset of zero in a BSTR to correspond to the		beginning of the actually allocated data (the length field), 		which lies four bytes before the pointer value that we are actually at."	^super atOffset: anInteger - 4</body><body package="Com- Automation">atOffset: anInteger put: aByte        " Private - set the byte at the zero relative offset &lt;anInteger&gt; in the memory referenced by the receiver to &lt;aByte&gt;. "	" We want an offset of zero in a BSTR to correspond to the		beginning of the actually allocated data (the length field), 		which lies four bytes before the pointer value that we are actually at."     ^super atOffset: ( anInteger - 4 ) put: aByte</body></methods><methods><class-id>External.BSTRMemoryAddress</class-id> <category>private-accessing</category><body package="Com- Automation">getSizeField	" Private "	^( CIntegerType unsignedLong pointerType cast: self asPointer ) decrement contents</body></methods><methods><class-id>External.BSTRMemoryAddress</class-id> <category>subclass-releasing</category><body package="Com- Automation">finalizationRegistry		"Private - Answer the WeakRegistry to be used for finalizing instances of the receiver."    ^COMSessionManager ownedMemoryRegistry</body><body package="Com- Automation">releaseMemory        "Private - Release the memory at the receiver's address."    OLEAutomationDLL current SysFreeString: self.</body></methods><methods><class-id>External.BSTRMemoryAddress</class-id> <category>accessing</category><body package="Com- Automation">copyFrom: start to: stop 	"Answer a new collection containing the elements 		of the receiver indexed from start through stop.  "	"Note: As with &gt;&gt;atOffset:, we need to offset the indices 		to the left by four bytes. And we need to be careful 		of things like shortcut replaceFrom:to:withStartingAt:		implementations that don't actually go through our at: method."	| nBytes bytes |	self isValid ifFalse: [self error: #ErrInvalidPointer &lt;&lt; #com &gt;&gt; 'invalid pointer'].	nBytes := stop - start + 1.	bytes := ByteArray new: nBytes.	1 to: nBytes do: [:i | bytes at: i put: (self at: i)].	^bytes</body></methods><methods><class-id>External.BSTRMemoryAddress</class-id> <category>private-session management</category><body package="Com- Automation">shutdownImage	"Private - The image session is being shut down.  All allocated interfaces should have already been released at this point; cannot release now because memory allocators and OLEDLL are closed. "	self isValid		ifTrue: [ COMDevelopmentWarning raiseSignal: (#ErrNamedBSTRUnreleased &lt;&lt; #com &gt;&gt;'Unreleased BSTR found at image exit: &lt;1p&gt;' expandMacrosWith: self) ].</body></methods><methods><class-id>External.BSTRMemoryAddress</class-id> <category>converting</category><body package="Com- Automation">asBSTRMemoryAddress	^ self</body></methods><methods><class-id>External.BSTRMemoryAddress class</class-id> <category>instance creation</category><body package="Com- Automation">allocateMemory: allocationSpecification flags: allocFlags	"Should not allocate memory directly"	^OLEAutomationDLL current SysAllocStringLen: allocationSpecification</body><body package="Com- Automation">allocateString: aString        " Allocate a BSTR in external memory and copy the characters 		of &lt;aString&gt; into it.  Answer a new instance of the receiver 		with the address of the BSTR copy in external memory. "	^OLEAutomationDLL current SysAllocString: aString</body><body package="Com- Automation">fromResultPointer: aPointer	"Answer a new instance of the receiver which references the external memory identified by &lt;aPointer&gt;. "	^(self new)		pointer: aPointer;		needsFinalization;		yourself</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">cType	^ referentType cType pointerType</body><body package="Com- Automation">freeArgument: anArgument	referentType freePtrArgument: anArgument.</body><body package="Com- Automation">iid	^self isInterfacePointer		ifTrue: [referentType iid]		ifFalse: 			[self error: #TypeDoesNotDescribeAndInterface &lt;&lt; #com						&gt;&gt; 'Type does not describe an interface']</body><body package="Com- Automation">newResultParameter	^ self referentType newResultPointerParameter</body><body package="Com- Automation">newResultPointerParameter	^ self referentType newResultPtrPtrParameter</body><body package="Com- Automation">noRefType	^ referentType noRefType</body><body package="Com- Automation">recordInfo	^ referentType recordInfo</body><body package="Com- Automation">typecode	"Return the pointer typecode of the referent type. The referent type may be nil if	 a referred typelibrary could not be loaded during parsing. In this case use VT_VOID"	^ referentType ifNil: [ VT_VOID ] ifNotNil: [:type | type pointerTypeCode ]</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>testing</category><body package="Com- Automation">isByref	"Answer whether this type is byref"	^ referentType isPointerByref</body><body package="Com- Automation">isInterfacePointer	^referentType isInterface or: 			["Coclasses can also be seen as interfaces as in COM coclasses can not be referenced but only interfaces"			referentType isCoclass]</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	referentType printPtrTypeOn: aStream.</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">createOutArgument	^ self referentType createPtrOutArgument</body><body package="Com- Automation">createPtrOutArgument	^ self referentType createPtrPtrOutArgument</body><body package="Com- Automation">invalidateInParameterValueIn: aSmalltalkValue	referentType invalidatePtrInParameterValueIn: aSmalltalkValue</body><body package="Com- Automation">invalidatePtrInParameterValueIn: aSmalltalkValue	^ self invalidatePtrPtrInParameterValueIn: aSmalltalkValue</body><body package="Com- Automation">marshalInArgument: anArgument	^ self referentType marshalPointerArgument: anArgument</body><body package="Com- Automation">primitiveArgumentFor: aValue	^ aValue asPointerParameter</body><body package="Com- Automation">releaseRecordElement: aVariant	"Default behavior - do nothing"	^ referentType releaseRecordElement: aVariant</body><body package="Com- Automation">unmarshalOutParam: aParam	| ref |	ref := ValueReference new.	self unmarshalOutParameter: aParam into: ref.	^ ref value</body><body package="Com- Automation">unmarshalOutParameter: aMarshaledValue into: aSmalltalkValue 	^ self referentType unmarshalPtrOutParameter: aMarshaledValue into: aSmalltalkValue</body><body package="Com- Automation">unmarshalPtrOutParameter: aMarshaledValue into: aSmalltalkValue 	^ self referentType unmarshalPtrPtrOutParameter: aMarshaledValue into: aSmalltalkValue</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>testing variant</category><body package="Com- Automation">canVariantContainValue: anObject ofType: aType	^referentType canVariantContainByRefValue: anObject ofType: aType</body><body package="Com- Automation">variantContainsValue: aVariant	^ referentType variantContainsRefValue: aVariant</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>comparing</category><body package="Com- Automation">= aDispTypeSpec	^super = aDispTypeSpec and: [referentType = aDispTypeSpec referentType]</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: client	^aValue isValueReference		ifTrue: 			[aValue copy				value: (referentType preMarshalPtrAutomationParameter: aValue value client: client);				yourself]		ifFalse: [(referentType preMarshalPtrAutomationParameter: aValue client: client) asValueReference]</body><body package="Com- Automation">unmarshalAutomationResult: aValue	^referentType isClassOrInterface		ifTrue: [aValue]		ifFalse: 			[aValue value: (referentType unmarshalAutomationResult: aValue value)]</body><body package="Com- Automation">unmarshalAutomationResult: aValue into: aResultReference	"unmarshal the automation resultValue into the given value reference"	"if my referentType is a class or custom interface, I am not an out parameter"	referentType unmarshalPtrAutomationResult: aValue into: aResultReference	"		 isClassOrInterface		ifFalse: 			[aResultReference isValueReference				ifTrue: 					[aResultReference						value: (referentType unmarshalAutomationResult: aValue value)]				ifFalse: 										referentType releaseUnusedOutValue: aValue]]"</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>converting</category><body package="Com- Automation">asInParameterType	^ referentType</body></methods><methods><class-id>External.DispPtrTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFrom: aTypeDesc typeInfo: anITypeInfo	^ self new 		referentType: (DispTypeSpec forTypeDesc: aTypeDesc ptrType typeInfo: anITypeInfo);		yourself</body><body package="Com- Automation">referentType: aType	^ self new 		referentType: aType		yourself</body></methods><methods><class-id>External.DispPtrTypeSpec class</class-id> <category>private accessing</category><body package="Com- Automation">automationTypeCode	^ VT_BYREF</body></methods><methods><class-id>External.DispPtrTypeSpec class</class-id> <category>private</category><body package="Com- Automation">typeCodes	^ Array with: VT_PTR</body></methods><methods><class-id>External.DispPtrTypeSpec class</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: client	| referentType |	^aValue isValueReference		ifTrue: 			[| realValue |			realValue := aValue value.			referentType := realValue dispatchTypeClass.			aValue copy value: (referentType preMarshalPtrAutomationParameter: realValue client: client)]		ifFalse: 			[referentType := aValue dispatchTypeClass.			(referentType preMarshalPtrAutomationParameter: aValue client: client) asValueReference]</body></methods><methods><class-id>External.Nothing class</class-id> <category>testing</category><body package="Com- Automation">isNothing	"Answer that I represent nothing"	^ true</body></methods><methods><class-id>External.Nothing class</class-id> <category>converting</category><body package="Com- Automation">comVariantType	"Return the type used to express that a parameter was not provided"	^External.COMAutomationConstants.VT_ERROR</body></methods><methods><class-id>External.Nothing class</class-id> <category>marshaling</category><body package="Com- Automation">dispatchTypeClass	"We do not require a special type class"	^DispSimpleTypeSpec</body></methods><methods><class-id>External.ILicenseManager</class-id> <category>interface operations</category><body package="Com- Automation">createInstance: classID	"Create an Instance of the class identified by the given class id"	^self		createInstance: classID		controllingUnknown: nil		iid: IID_IUnknown		licenseKey: nil</body><body package="Com- Automation">createInstance: class controllingUnknown: pUnkOuter iid: riid licenseKey: license	" Invoke the ILicenseManager::CreateInstance function. "	| resultReference |	resultReference := COMInterfaceValueReference forIID: riid.	interface		CreateInstance: class		_: pUnkOuter		_: riid		_: license		_: resultReference.	^resultReference value</body><body package="Com- Automation">createInstance: clsID iid: anIID licenseKey: aString	"Create an instance of the class identified by &lt;clsID&gt; using the given license key &lt;aString&gt;.	 The method returns an interface specified by &lt;anIID&gt;"	^self		createInstance: clsID		controllingUnknown: nil		iid: anIID		licenseKey: aString</body><body package="Com- Automation">createInstance: clsID licenseKey: aString	"Create an instance of the class identified by &lt;clsID&gt; using the given license key.	 The method returns an IUnknown interface"	^self		createInstance: clsID		controllingUnknown: nil		iid: IID_IUnknown		licenseKey: aString</body><body package="Com- Automation">isDevelopment: class	" Invoke the ILicenseManager::IsDevelopment function. "	| resultReference |	resultReference := nil asValueReference.	interface IsDevelopment: class _: resultReference.	^resultReference value</body><body package="Com- Automation">queryLicenseKey: class	" Invoke the ILicenseManager::QueryLicenseKey function. "	| resultReference |	resultReference := nil asValueReference.	interface QueryLicenseKey: class _: resultReference.	^resultReference value</body></methods><methods><class-id>External.ILicenseManager</class-id> <category>instance creation</category><body package="Com- Automation">createCOMClientWithOptions: options 	"Create a COMClient with the specified options."	^ self createCOMClientWithOptions: options class: COMClient</body><body package="Com- Automation">createCOMClientWithOptions: options class: aClass	"Create a COMClient (COMClient/DispatchDriver) with the specified options."	| anInterface |	anInterface:= self createInstanceWithOptions: options.	^aClass onNewAndInitialize: anInterface</body><body package="Com- Automation">createDispatchDriverWithOptions: options 	"Create a COMClient with the specified options."	^ self createCOMClientWithOptions: options class: COMDispatchDriver</body><body package="Com- Automation">createInstanceWithOptions: options	" Create an uninitialized instance of the class manufactured by the receiver.  The object is created as an inner object within an aggregate if the IUnknown of a controlling object is specified in &lt;options controllingUnknown&gt;.  Answer a single interface specified by the GUID &lt;options iid&gt; or an array of interfaces specified by&lt;options iids&gt;. The interface can be created threaded by setting &lt;options threaded&gt;. The licenseKey can be specified in &lt;options licenseKey&gt;."	| iids firstInterface otherInterfaces creationBlock clsid |	clsid := IClassFactory getCLSID: options clsid.	iids := self class decodeIIdsFromOptions: options clsidBlock: [self clsid].	creationBlock :=			[self				createInstance: clsid				controllingUnknown: options controllingUnknown				iid: iids first				licenseKey: options licenseKey].	firstInterface := options threaded				ifTrue: [COMThreadManager performInMTA: creationBlock]				ifFalse: [creationBlock value].	options hasMultipleIIDs ifFalse: [^firstInterface].	otherInterfaces := (iids allButFirst: 1)				collect: [:iid | firstInterface queryInterface: iid].	^(Array with: firstInterface) , otherInterfaces</body></methods><methods><class-id>External.ILicenseManager class</class-id> <category>private-installation</category><body package="Com- Automation">initialize	" ILicenseManager initialize "	self iid: IID_ILicenseManager.	self updateAndRegister</body></methods><methods><class-id>External.COMDispatchEventSpecification</class-id> <category>testing</category><body package="Com- Automation">isEventSpecification		" Answer whether the receiver is a method member specification. "	^true</body><body package="Com- Automation">isMethodSpecification		" Answer whether the receiver is a method member specification. "	^false</body></methods><methods><class-id>External.COMDispatchEventSpecification</class-id> <category>private-accessing</category><body package="Com- Automation">typeName	^ 'Event'</body></methods><methods><class-id>External.COMDispatchEventSpecification</class-id> <category>accessing</category><body package="Com- Automation">kind	^ #event</body></methods><methods><class-id>External.COMDispatchEventSpecification class</class-id> <category>instance creation</category><body package="Com- Automation">forMethodSpec: aMethodSpecification	^ self name: aMethodSpecification name		memberID: aMethodSpecification memberID		resultType: aMethodSpecification returnValueDescription		parameters: aMethodSpecification parameters		optionalParameters: aMethodSpecification optionalParameterCount</body></methods><methods><class-id>External.IRecordInfo</class-id> <category>interface operations</category><body package="Com- Automation">getField: pvData _: szFieldName 	| hresult resultReference |	resultReference := COMVariantValueReference new.	hresult := interface GetField: pvData _: szFieldName _: resultReference.	hresult ~= S_OK ifTrue: [ ^ COMError hresult: hresult ].	^ resultReference value</body><body package="Com- Automation">getFieldNames	| countReference arrayReference hresult |	countReference := ValueReference on: 255.	arrayReference := ValueReference new.	hresult := interface GetFieldNames: countReference _: arrayReference.	hresult ~= S_OK ifTrue: [		COMError hresult: hresult ].	countReference value = arrayReference value size 		ifTrue: [ ^ arrayReference value ].	"repeat the call with the correct array size"	hresult := interface GetFieldNames: countReference _: arrayReference.	^ arrayReference value</body><body package="Com- Automation">getFieldNoCopy: pvData _: szFieldName	| hresult resultReference referenceDataCArray |	resultReference := COMVariantValueReference new.	referenceDataCArray := ValueReference new.	hresult := interface GetFieldNoCopy: pvData _: szFieldName _: resultReference _: referenceDataCArray.	hresult ~= S_OK ifTrue: [ ^ COMError hresult: hresult ].	resultReference value fixedArrayDataPointer: referenceDataCArray value.	^ resultReference value</body><body package="Com- Automation">getGuid	| resultReference hresult |	resultReference := ValueReference new.	hresult := interface GetGuid: resultReference.	hresult ~= S_OK ifTrue: [ COMError hresult: hresult ].	^ resultReference value</body><body package="Com- Automation">getName	| resultReference hresult |	resultReference := ValueReference new.	hresult := interface GetName: resultReference.	hresult ~= S_OK ifTrue: [ COMError hresult: hresult ].	^ resultReference value</body><body package="Com- Automation">getSize	| resultReference hresult |	resultReference := ValueReference new.	hresult := interface GetSize: resultReference.	hresult ~= S_OK ifTrue: [ COMError hresult: hresult ].	^ resultReference value</body><body package="Com- Automation">getTypeInfo	| resultReference hresult |	resultReference := COMInterfaceValueReference forIID: ITypeInfo iid.	hresult := interface GetTypeInfo: resultReference.	hresult ~= S_OK ifTrue: [ COMError hresult: hresult ].	^ resultReference value</body><body package="Com- Automation">isMatchingType: pRecordInfo	^ interface IsMatchingType: pRecordInfo</body><body package="Com- Automation">putField: pvData _: szFieldName _: pvarField	| wFlags hresult |	wFlags := External.COMAutomationConstants.INVOKE_PROPERTYPUTREF.	hresult := interface PutField: wFlags _: pvData _: szFieldName _: pvarField.	hresult ~= S_OK ifTrue: [ COMError hresult: hresult ].	^ self</body><body package="Com- Automation">putFieldNoCopy: pvData _: szFieldName _: pvarField	"no copy version is not needed since we always copy values. Therefore it is not implemented yet"	| wFlags hresult |	wFlags := External.COMAutomationConstants.INVOKE_PROPERTYPUTREF.	hresult := interface PutField: wFlags _: pvData _: szFieldName _: pvarField.	hresult ~= S_OK ifTrue: [ COMError hresult: hresult ].	^ self</body><body package="Com- Automation">recordClear: pvExisting	^ (interface RecordClear: pvExisting)  = S_OK</body><body package="Com- Automation">recordCopy: pvExisting _: pvNew	^ (interface RecordCopy: pvExisting _: pvNew)  = S_OK</body><body package="Com- Automation">recordCreate	^ interface RecordCreate</body><body package="Com- Automation">recordCreateCopy: pvSource 	| resultReference |	resultReference := ValueReference new.	interface RecordCreateCopy: pvSource _: resultReference.	^ resultReference value</body><body package="Com- Automation">recordDestroy: pvRecord	^ (interface RecordDestroy: pvRecord) = S_OK</body><body package="Com- Automation">recordInit: pvNew	^ (interface RecordInit: pvNew) = S_OK</body></methods><methods><class-id>External.IRecordInfo</class-id> <category>instance creation</category><body package="Com- Automation">createRecord	^ COMRecord newWith: self</body><body package="Com- Automation">createRecordWith: aValue	| instance |	instance := self createRecord.	instance value: aValue.	^ instance</body></methods><methods><class-id>External.IRecordInfo class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IRecordInfo.	self updateAndRegister</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>accessing</category><body package="Com- Automation">accessMode	self subclassResponsibility</body><body package="Com- Automation">invokationType		self subclassResponsibility</body><body package="Com- Automation">kind	self shouldNotImplement</body><body package="Com- Automation">name	^ self propertySpecification name</body><body package="Com- Automation">name: aName	^ self propertySpecification name: aName</body><body package="Com- Automation">optionalParameterCount: num        " Answer the number of optional parameters allowed by this method ( -1, 0 or &gt;0). "	| numParams |	num &gt; self parameters size ifTrue: [		self error: #InvalidArgumentNumberSpecified &lt;&lt; #com &gt;&gt; 'Invalid Argument number specified' ]. 	numParams := self parameters size.	1 to: numParams do: [:index |		(self parameters at: numParams - index + 1) beOptional: (index &lt;= num) ].</body><body package="Com- Automation">parameterNames: anArray	(self parameters isNil or: [self parameters isEmpty])		ifTrue: [^ self defineNewParametersByNames: anArray ].		self updateParameterNames: anArray</body><body package="Com- Automation">parameterTypeCodes: anArray	(self parameters isNil or: [self parameters isEmpty])		ifTrue: [^self defineNewParamsByTypes: anArray].	^ self updateParamterTypes: anArray</body><body package="Com- Automation">propertySpecification	^propertySpecification</body><body package="Com- Automation">propertySpecification: anObject	propertySpecification := anObject</body><body package="Com- Automation">selector	  ^ selector ifNil: [ selector := self defaultSelector ]</body><body package="Com- Automation">selector: anObject	selector := anObject</body><body package="Com- Automation">selectorAttribute		" Private - answer the selector of the receiver.  Do not construct if not allocated. "	^selector</body><body package="Com- Automation">selectors	^ Array with: self selector</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>private-accessing</category><body package="Com- Automation">defaultSelector    ^ self constructSelectorWith: self defaultArgumentKeyword</body><body package="Com- Automation">defineNewParametersByNames: anArray	self		parameters: (anArray collect: 					[:each |					COMParameterDescription						name: each						type: (DispTypeSpec fromVariantTypeCode: VT_VARIANT)						flags: 0						defaultValue: nil])</body><body package="Com- Automation">defineNewParamsByTypes: anArray	| newParams |	newParams := OrderedCollection new.	anArray keysAndValuesDo: 			[:index :typeCode |			newParams add: (COMParameterDescription						name: 'param' , index printString						type: (DispTypeSpec fromVariantTypeCode: typeCode)						flags: 0						defaultValue: nil)].	self parameters: newParams asArray</body><body package="Com- Automation">updateParameterNames: anArray	self parameters size ~= anArray size ifTrue: 		[self error: #GivenArrayDoesNotMatchSpecifiedParams &lt;&lt; #com &gt;&gt; 'The given Array does not match previously specified parameters'].	self parameters with: anArray do: [:param :aName | param name: aName ].</body><body package="Com- Automation">updateParamterTypes: anArray	self parameters size ~= anArray size		ifTrue: 			[self error: #GivenArrayDoesNotMatchSpecifiedParams &lt;&lt; #com						&gt;&gt; 'The given Array does not match previously specified parameters'].	self parameters with: anArray		do: [:param :typeCode | param type: (DispTypeSpec fromVariantTypeCode: typeCode)]</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>testing</category><body package="Com- Automation">basicIsEqualTo: anAccessSpecification 		anAccessSpecification ifNil: [^ false].	anAccessSpecification isPropertyAccessSpecification ifFalse: [ ^ false].	self isPropertyGet = anAccessSpecification isPropertyGet ifFalse: [ ^ false].	self memberID = anAccessSpecification memberID ifFalse: [ ^ false].	self name = anAccessSpecification name ifFalse: [ ^ false].	(self parametersEqual: self parameters and: anAccessSpecification parameters) ifFalse: [ ^ false].	^ true</body><body package="Com- Automation">hasOptionalParameters	^ self optionalParameterCount &gt; 0</body><body package="Com- Automation">hasParameters 	^ self parameters notEmpty</body><body package="Com- Automation">isPropertyAccessSpecification	^ true</body><body package="Com- Automation">isPropertyGet	^ false</body><body package="Com- Automation">isPropertySet	^ false</body><body package="Com- Automation">showInNavigatorWithFlags: newFlags	self shouldNotImplement</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>browser support</category><body package="Com- Automation">actualMember	^ self propertySpecification</body><body package="Com- Automation">browserIcon	^ nil</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>private</category><body package="Com- Automation">constructSelectorWith: argumentKeyword	" Answer a message selector used to set the value of the property described by the receiver which is formed from the property name and using &lt;argumentKeyword&gt; as the anonymous keyword for argument values. "	| nArgs |	(self name == nil or: [self parameters == nil])		ifTrue: 			[^COMError raiseSignal: #ErrImproperSpec &lt;&lt; #com						&gt;&gt; 'improperly constructed specification'].	self parameters isEmpty		ifTrue: [^(self selectorPrefix , self name) asSymbol].	nArgs := self parameters size.	^self		constructSelectorForName: self selectorPrefix , self name		nArgs: nArgs		argumentKeyword: argumentKeyword</body><body package="Com- Automation">modifyTypeCode: aTypeCode	"The original implementation used no-ref typcodes for methods but typecodes including reference flags	 for properties"	^ aTypeCode</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>utilities</category><body package="Com- Automation">addTo: aGeneralPropertySpecification	self subclassResponsibility</body><body package="Com- Automation">selectorPrefix	" Answer the standard prefix for a property accessor which gets the value of the property. "	self subclassResponsibility</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>private emphasised texts</category><body package="Com- Automation">simplifiedStRepresentations	"return ST representations of this member with simplified syntax"	^ self shouldNotImplement</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>private flags constants</category><body package="Com- Automation">hiddenFlag	self shouldNotImplement</body><body package="Com- Automation">nonBrowsableFlag	self shouldNotImplement</body><body package="Com- Automation">restrictedFlag	self shouldNotImplement</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>As yet unclassified</category><body package="Com- Automation">simplifiedStRepresentation		self subclassResponsibility</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>converting</category><body package="Com- Automation">asDispatchSpecification	"convert a VTable property access spefication into a Dispatch access Specification"	^self isDispatchSpecification		ifTrue: [self]		ifFalse: [self privateAsDispatchSpecification]</body><body package="Com- Automation">checkArguments: arguments	arguments size = self parameters size ifTrue: [ ^ true ].	arguments size &gt; self parameters size ifTrue: [ ^ false ].	arguments size &lt;  (self parameters size - self optionalParameterCount) ifTrue: [  ^ false ]. 	^ true</body><body package="Com- Automation">privateAsDispatchSpecification	| params resultType |	(self class lastParameterIsResultValue: self)		ifTrue: 			[params := self parameters allButLast: 1.			resultType := self parameters last asReturnValueDescription]		ifFalse: 			[params := self parameters.			resultType := COMReturnValueDescription typeCode: VT_VOID].	^self class		basicForProperty: self propertySpecification		parameters: params		returnValue: resultType		vtableIndex: nil		memberID: self memberID		flags: self flags</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>printing</category><body package="Com- Automation">isDispatchSpecification	^self isVTableSpecification not</body><body package="Com- Automation">isVTableSpecification	^self returnValueDescription type isHRESULT</body><body package="Com- Automation">specificationForDisplay	"Return a specification which is suitable for being displayed"	^self asDispatchSpecification</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>vtable calls</category><body package="Com- Automation">acceptsArguments: arguments	| parameterSpecs spec usedSpecs |	spec := self asDispatchSpecification.	arguments size &lt; (spec parameterCount - spec optionalParameterCount) ifTrue: [^ false].	parameterSpecs := spec parameters.	usedSpecs := parameterSpecs first: arguments size.	usedSpecs with: arguments do: [:paramSpec :arg | 		 (paramSpec canAcceptArgument: arg) ifFalse: [ ^ false]].	^true</body><body package="Com- Automation">parameterNames	^self parameters collect: [:each | each name]</body></methods><methods><class-id>External.PropertyAccessSpecification</class-id> <category>comparing</category><body package="Com- Automation">= aPropertySpec	aPropertySpec ifNil: [^false].	aPropertySpec isPropertyAccessSpecification ifFalse: [^false].	aPropertySpec isPropertyGet = self isPropertyGet ifFalse: [^false].	^super = aPropertySpec</body></methods><methods><class-id>External.PropertyAccessSpecification class</class-id> <category>private</category><body package="Com- Automation">classFor: aFuncDesc	aFuncDesc isPropertyGet ifTrue: [ ^ PropertyGetAccessSpecification].	aFuncDesc isPropertyPut  ifTrue: [ ^ PropertySetAccessSpecification].	aFuncDesc isPropertyPutRef  ifTrue: [ ^ PropertyPutRefSpecification].	self error: #UnsupportedPropertyOperation &lt;&lt; #com &gt;&gt; 'Unsupported Property operation'</body><body package="Com- Automation">propertyGetClass 	 ^ PropertyGetAccessSpecification</body><body package="Com- Automation">propertySetClass 	 ^ PropertySetAccessSpecification</body></methods><methods><class-id>External.PropertyAccessSpecification class</class-id> <category>instance creation</category><body package="Com- Automation">basicForProperty: aProperty parameters: parameters returnValue: returnValue vtableIndex: vtIndex memberID: memberID flags: anObject	^(self new)		propertySpecification: aProperty;		parameters: parameters;		returnValueDescription: returnValue;		vtableIndex: vtIndex;		memberID: memberID;		yourself</body><body package="Com- Automation">forDescription: aMemberDesc typeInfo: anITypeInfo		self shouldNotImplement</body><body package="Com- Automation">forPropertyGet: aProperty parameters: parameters returnValue: returnValue vtableIndex: vtIndex memberID: memberID flags: flags	^self propertyGetClass		basicForProperty: aProperty		parameters: parameters		returnValue: returnValue		vtableIndex: vtIndex		memberID: memberID		flags: flags</body><body package="Com- Automation">forPropertyPut: aProperty parameters: parameters returnValue: returnValue vtableIndex: vtIndex memberID: memberID flags: flags	^self propertySetClass		basicForProperty: aProperty		parameters: parameters		returnValue: returnValue		vtableIndex: vtIndex		memberID: memberID		flags: flags</body><body package="Com- Automation">fromFuncDesc: aFuncDesc	^((self classFor: aFuncDesc) new)		parameters: aFuncDesc parameters;		returnValueDescription: aFuncDesc returnValue;		vtableIndex: aFuncDesc vtableIndex;		memberID: aFuncDesc memberID;		flags: aFuncDesc flags;		yourself</body><body package="Com- Automation">fromFuncDesc: aFuncDesc property: propertySpec typeInfo: anITypeInfo	^((self classFor: aFuncDesc) new)		propertySpecification: propertySpec;		name: aFuncDesc getName;		parameters: aFuncDesc parameters;		returnValueDescription: aFuncDesc returnValue;		vtableIndex: aFuncDesc vtableIndex;		memberID: aFuncDesc memberID;		flags: aFuncDesc flags;		description: (self descriptionFor: aFuncDesc memberID typeInfo: anITypeInfo);		yourself</body></methods><methods><class-id>External.PropertyAccessSpecification class</class-id> <category>literal representation</category><body package="Com- Automation">literalEncodingType		self shouldNotImplement</body><body package="Com- Automation">literallyEncodedAttributes	^#(parameters returnValueDescription vtableIndex memberID optionalParameterCount selector flags)</body></methods><methods><class-id>External.PropertyGetAccessSpecification</class-id> <category>accessing</category><body package="Com- Automation">accessMode	^ 1</body><body package="Com- Automation">invokationType		^ DISPATCH_PROPERTYGET</body></methods><methods><class-id>External.PropertyGetAccessSpecification</class-id> <category>utilities</category><body package="Com- Automation">addTo: aGeneralPropertySpecification	aGeneralPropertySpecification propertyGetSpecification: self.</body><body package="Com- Automation">selectorPrefix	" Answer the standard prefix for a property accessor which gets the value of the property. "	^ 'get'</body></methods><methods><class-id>External.PropertyGetAccessSpecification</class-id> <category>testing</category><body package="Com- Automation">isPropertyGet	^ true</body></methods><methods><class-id>External.PropertyGetAccessSpecification</class-id> <category>converting</category><body package="Com- Automation">asPropertySetSpecification	| newParams |	^self returnsHRESULT		ifTrue: 			["VTable call - the return is an HRESULT and the last parameter is the actual result value"			  newParams := (self parameters allButLast: 1) copyWith: self parameters last asInParameter.				self class				forPropertyPut: self propertySpecification				parameters: (newParams)				returnValue: nil				vtableIndex: nil				memberID: self memberID				flags: self flags]		ifFalse: 			[self class				forPropertyPut: self propertySpecification				parameters: (self parameters						copyWith: (self returnValueDescription asParamName: #newValue))				returnValue: nil				vtableIndex: nil				memberID: self memberID				flags: self flags]</body></methods><methods><class-id>External.IRecordInfoPointer</class-id> <category>interface operations</category><body package="Com- Automation">GetField: pvData _: szFieldName _: resultReference	| pvarField hresult |	pvarField := SpecialVariantArg new			beRecordGetValueAccessor;			yourself.	hresult := self invokeGetField: pvData _: szFieldName gcCopyToHeapUnicode _: pvarField asPointerParameter.	resultReference value: pvarField value.	"We still need the memory of COMRecords - so don't release it"	self releaseGetFieldBuffer: pvarField.	^ hresult</body><body package="Com- Automation">GetFieldNames: numNames _: resultReference	| pcNames rgBstrNames hresult maxNames |	pcNames := COMExternalInterface current ULONG gcMalloc.	pcNames contents: numNames value.	maxNames := numNames value.	rgBstrNames := resultReference ifNil: [ nil] ifNotNil: [		BSTR resultValueArrayBuffer: numNames value ].	hresult := self invokeGetFieldNames: pcNames asPointerParameter _: rgBstrNames asPointerParameter.	numNames value: pcNames contents.	resultReference ifNotNil: [		resultReference value: (rgBstrNames getResultValuesFrom: 1 to: (numNames value min: maxNames)).				rgBstrNames enforceRelease].	^ hresult</body><body package="Com- Automation">GetFieldNoCopy: pvData _: szFieldName _: resultReference _: referenceDataCArray	| hresult ppvDataCArray pvarField |	ppvDataCArray := CVoidType void pointerType gcCalloc.	pvarField := SpecialVariantArg new		beRecordGetValueAccessor;		yourself.	hresult := self invokeGetFieldNoCopy: pvData 				_: szFieldName gcCopyToHeapUnicode				_: pvarField asPointerParameter				_: ppvDataCArray.	"We return the Variant to allow writing to the element"	resultReference value: pvarField .	referenceDataCArray value: ppvDataCArray contents.	^ hresult</body><body package="Com- Automation">GetGuid: resultReference	| pguid hresult |	pguid := GUID resultValueBuffer.	hresult := self invokeGetGuid: pguid.	hresult = S_OK 				ifTrue: 	[ resultReference value: pguid contents ]		ifFalse:	[ pguid enforceRelease ].	^ hresult</body><body package="Com- Automation">GetName: resultReference	| pbstrName hresult |	pbstrName := BSTR resultValueBuffer.	hresult := self invokeGetName: pbstrName.	hresult = S_OK 		ifTrue: [ resultReference value: pbstrName contents ]		ifFalse:[ pbstrName enforceRelease ].	^ hresult</body><body package="Com- Automation">GetSize: resultReference	| hresult pcbSize |	pcbSize := COMExternalInterface scalarResultBufferFor: #ULONG.	hresult := self invokeGetSize: pcbSize asPointerParameter.	hresult = S_OK 		ifTrue: [ resultReference value: pcbSize contents ]		ifFalse:[ pcbSize enforceRelease ].	^ hresult</body><body package="Com- Automation">GetTypeInfo: resultReference	| hresult ppTypeInfo |	ppTypeInfo := ITypeInfoPointer resultValueBuffer.	hresult := self invokeGetTypeInfo: ppTypeInfo asPointerParameter.	hresult = S_OK 		ifTrue: [ resultReference value: ppTypeInfo contents asInterfaceReference]		ifFalse:[ ppTypeInfo enforceRelease ].	^ hresult</body><body package="Com- Automation">IsMatchingType: pRecordInfo	^  self invokeIsMatchingType: pRecordInfo</body><body package="Com- Automation">PutField: wFlags _: pvData _: szFieldName _: pvarField	| hresult |	hresult := self invokePutField: wFlags _: pvData _: szFieldName gcCopyToHeapUnicode 			_: pvarField asPointerParameter.	^ hresult</body><body package="Com- Automation">PutFieldNoCopy: wFlags _: pvData _: szFieldName _: pvarField	| hresult |	hresult := self invokePutFieldNoCopy: wFlags _: pvData _: szFieldName _: pvarField.	^ hresult</body><body package="Com- Automation">RecordClear: pvExisting	^ self invokeRecordClear: pvExisting</body><body package="Com- Automation">RecordCopy: pvExisting _: pvNew	^ self invokeRecordCopy: pvExisting _: pvNew</body><body package="Com- Automation">RecordCreate	^ self invokeRecordCreate</body><body package="Com- Automation">RecordCreateCopy: pvSource _: resultReference	| ppvDest hresult |	ppvDest := CVoidType void pointerType gcMalloc.	hresult := self invokeRecordCreateCopy: pvSource _: ppvDest.	resultReference value: ppvDest contents.	^ hresult</body><body package="Com- Automation">RecordDestroy: pvRecord	^ self invokeRecordDestroy: pvRecord</body><body package="Com- Automation">RecordInit: pvNew	^ self invokeRecordInit: pvNew</body></methods><methods><class-id>External.IRecordInfoPointer</class-id> <category>private</category><body package="Com- Automation">releaseGetFieldBuffer: aVariant	aVariant enforceRelease.</body></methods><methods><class-id>External.IRecordInfoPointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IRecordInfo.	self updateAndRegister</body></methods><methods><class-id>External.VTableInterfaceTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">constructVTableDescription	"construct a vtable description used by Interface class generators"	| specifications allSpecifications  sortedSpecifications |	specifications := self fullVtableSpecification specificationTable. 	allSpecifications := specifications inject: OrderedCollection new into: [:coll :each | 		coll addAll: each specifications; yourself ].	sortedSpecifications := (allSpecifications asSortedCollection: [:a :b |		a vtableIndex &lt; b vtableIndex ]) asArray.	^ sortedSpecifications collect: [:each | each asCOMEntryPointDescription ]</body><body package="Com- Automation">kindname	^  (#TKindInterface &lt;&lt; #com &gt;&gt; 'Interface' ) asString</body><body package="Com- Automation">typecode	^ VT_UNKNOWN</body></methods><methods><class-id>External.VTableInterfaceTypeSpec</class-id> <category>private</category><body package="Com- Automation">defaultInterfaceClass	^ IAnonymous</body><body package="Com- Automation">fullVtableSpecification		^ [self asTypeInfo ] withResultDoAndRelease: [:typeInfo|		COMVTableSpecificationTable constructFullSpecificationTable: typeInfo specificationKey: #name]</body><body package="Com- Automation">specificationTableClass	^COMVTableSpecificationTable</body></methods><methods><class-id>External.VTableInterfaceTypeSpec</class-id> <category>converting</category><body package="Com- Automation">dispatchType	^ self alternativeRepresentation</body><body package="Com- Automation">vtableType	^ self</body></methods><methods><class-id>External.VTableInterfaceTypeSpec</class-id> <category>printing</category><body package="Com- Automation">protocolFilterName	^ self name,' (VTable)'</body></methods><methods><class-id>External.VTableInterfaceTypeSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds		^ Array with: TKIND_INTERFACE</body></methods><methods><class-id>External.COMNoLookupSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">allowsSpecificationTableUpdates	"Answer whether it makes sense for the receiver to update the specification table ."    ^false</body><body package="Com- Automation">canSupportIDispatch: anIDispatch forLocaleID: aLocaleID	^true</body><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^true</body></methods><methods><class-id>External.COMNoLookupSpecificationPolicy</class-id> <category>description</category><body package="Com- Automation">description	"Answer a description for the recevier."	^(#noLookup &lt;&lt; #com &gt;&gt; 'no lookup') asString</body></methods><methods><class-id>External.COMNoLookupSpecificationPolicy</class-id> <category>private lookup-property</category><body package="Com- Automation">propertySpecification: aName    withGetArguments: argValuesArray    for: anOLEDispatchDriver    "No lookups are allowed for complete specifications, answer nil."    ^nil</body></methods><methods><class-id>External.COMNoLookupSpecificationPolicy</class-id> <category>private lookup-method</category><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    for: anOLEDispatchDriver    "No lookups are allowed for complete specifications, answer nil."    ^nil</body><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    withNamedArguments: argValuesDictionary    for: anOLEDispatchDriver    "No lookups are allowed for complete specifications, answer nil."    ^nil</body></methods><methods><class-id>External.COMVariantEnumerator</class-id> <category>private-accessing</category><body package="Com- Automation">variantTypes: variantTypesArray	" Private - specify the variant type of each element in the receiver's collection. "	variantTypes := variantTypesArray.</body></methods><methods><class-id>External.COMVariantEnumerator</class-id> <category>subclass-operation</category><body package="Com- Automation">packCurrentElementInto: lpStruct	" Private - pack the element at the current index into the receiver into the element buffer at &lt;lpStruct&gt;.  Answer whether successful. "	| anElement |	anElement := self elements at: currentIndex.	anElement isNil		ifTrue: [ ^false ].  " perhaps somewhat obstinate, but hey, it's really a bug in the guy who constructed me "	( COM_VARIANT temporaryOn: lpStruct )		typeCode: ( variantTypes at: currentIndex );		value: anElement.	^true</body></methods><methods><class-id>External.COMVariantEnumerator class</class-id> <category>subclass-instance creation</category><body package="Com- Automation">checkElementValidity: elements	" Private - verify that the collection is a collection of valid elements, per COM enumeration model.  Anything which can be converted successfully to a VARIANT is acceptable. "</body><body package="Com- Automation">checkEnumeratorIID: anIID	" Private - verify that the IID is a supported enumeration interface. "	anIID = IID_IEnumVARIANT		ifFalse: [ COMError raiseSignal: (#ErrNamedIncorrectEnumIID &lt;&lt; #com &gt;&gt; 'incorrect enumerator IID for VARIANT: &lt;1s&gt;'  expandMacrosWith: anIID asString) ].</body><body package="Com- Automation">checkVariantTypes: variantTypeList elements: elements 	" Private - verify that the elements in the collection can be transformed into variant values."	1 to: elements size		do: 			[:i | 			(variantTypeList at: i) isNil 				ifTrue: 					[COMError 						raiseSignal: (#ErrNamedVariantCoerce &lt;&lt; #com 								&gt;&gt; 'can''t coerce to VARIANT: &lt;1p&gt;' expandMacrosWith: (elements at: i))]]</body><body package="Com- Automation">forIID: anIID elements: anOrderedCollection bufferElementType: aCType	"Answer a new instance of the receiver which enumerates the homogeneous collection &lt;anOrderedCollection&gt; of elements into a buffer containing instances of the C data type &lt;aCType&gt;.  The enumerator interface IID is specified by the GUID &lt;anIID&gt;. "	| variantTypeList anEnumerator |	variantTypeList := anOrderedCollection collect: [ :anElement |		anElement comVariantType ].	self checkVariantTypes: variantTypeList 		elements: anOrderedCollection.	anEnumerator := super forIID: anIID 		elements: anOrderedCollection 		bufferElementType: aCType.	anEnumerator variantTypes: variantTypeList.	^anEnumerator</body></methods><methods><class-id>External.COMVariantEnumerator class</class-id> <category>instance creation</category><body package="Com- Automation">forIID: anIID elements: anOrderedCollection	" Answer a new instance of the receiver which enumerates a collection of strings. "	self checkEnumeratorIID: anIID.	^self forIID: anIID		elements: anOrderedCollection		bufferElementType: ( COMStructure classForStructureNamed: #VARIANT ) baseCType</body><body package="Com- Automation">on: anOrderedCollection	" Answer a new instance of the receiver which enumerates the values in &lt;anOrderedCollection&gt; as VARIANT structures. "	^self forIID: IID_IEnumVARIANT elements: anOrderedCollection</body></methods><methods><class-id>External.COMVTableSpecificationTable</class-id> <category>constants</category><body package="Com- Automation">defaultMethodSpecificationClass	^ COMVTableMethodSpecification</body></methods><methods><class-id>External.COMVTableSpecificationTable</class-id> <category>accessing-specifications</category><body package="Com- Automation">interface	^ VTableInterfaceTypeSpec name: self name iid: self iid</body></methods><methods><class-id>External.COMVTableSpecificationTable</class-id> <category>accessing</category><body package="Com- Automation">unfiltered	^unfiltered ifNil: [ false ]</body><body package="Com- Automation">unfiltered: anObject	unfiltered := anObject</body></methods><methods><class-id>External.COMVTableSpecificationTable</class-id> <category>specification construction</category><body package="Com- Automation">shouldAddSpecification: aFuncDesc	^ self unfiltered or: [ aFuncDesc isRestricted not ]</body></methods><methods><class-id>External.COMVTableSpecificationTable</class-id> <category>private-construction</category><body package="Com- Automation">formatKey: aKey	^self specificationKey = #name ifTrue: [aKey asSymbol] ifFalse: [aKey]</body></methods><methods><class-id>External.COMVTableSpecificationTable</class-id> <category>private</category><body package="Com- Automation">addFullSuperclassSpecificationsFor: anITypeInfo	| subSpecTable |	anITypeInfo referencedTypesAndFlagsDo: 			[:iTypeInfo :flags |			subSpecTable := self class basicConstructFullSpecificationTable: iTypeInfo						specificationKey: self specificationKey.			self addAll: subSpecTable values.			self addFullSuperclassSpecificationsFor: iTypeInfo]</body></methods><methods><class-id>External.COMVTableSpecificationTable class</class-id> <category>private</category><body package="Com- Automation">basicConstructFullSpecificationTable: anITypeInfo specificationKey: aSymbol	" Answer a new instance of the receiver containing the method and property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the attribute &lt;aSymbol&gt; of the specifications. "	^self new		unfiltered: true;		specificationKey: aSymbol;		addMethodSpecifications: anITypeInfo;		addPropertySpecifications: anITypeInfo;		addTypeLibraryInformationFor: anITypeInfo;		yourself</body></methods><methods><class-id>External.COMVTableSpecificationTable class</class-id> <category>instance creation</category><body package="Com- Automation">constructFullSpecificationTable: anITypeInfo specificationKey: aSymbol	" Answer a new instance of the receiver containing the method and property specifications defined by &lt;anITypeInfo&gt;.  The specification table is indexed by the attribute &lt;aSymbol&gt; of the specifications. "	| specTable |	anITypeInfo		ifNil: 			[^(self new)				specificationKey: aSymbol;				yourself].	specTable := self basicConstructFullSpecificationTable: anITypeInfo				specificationKey: aSymbol.	specTable addFullSuperclassSpecificationsFor: anITypeInfo.	^specTable</body></methods><methods><class-id>External.COMCurrency class</class-id> <category>values</category><body package="Com- Automation">max	"Answer the a FixedPoint for the largest COM currency: 922337203685477.580"	^922337203685477.5807s4</body><body package="Com- Automation">min	"Answer the a FixedPoint for the smallest COM currency: -922337203685477.580"	^-922337203685477.5807s4</body><body package="Com- Automation">zero	"Answer the COM Currency zero."	^0.0000s4</body></methods><methods><class-id>External.COMCurrency class</class-id> <category>coercion</category><body package="Com- Automation">fromNumber: aNumber	"Answer &lt;aNumber&gt; as a FixedPoint with the proper scale for a COM Currency."	self validate: aNumber.	^aNumber asFixedPoint: self scale.</body></methods><methods><class-id>External.COMCurrency class</class-id> <category>validation</category><body package="Com- Automation">isInRange: aNumber	"Answer whether &lt;aNumber&gt; in the range for a COM Currency."	^( aNumber asFixedPoint: self scale ) 		between: self min 		and: self max</body><body package="Com- Automation">isValid: aNumber	"Answer whether &lt;aNumber&gt; in the range for a COM Currency and suitable for COM."	" This method pattern matches #validate: "	( aNumber isKindOf: Number )		ifFalse: [ ^false ].	( self isInRange: aNumber )		ifFalse: [ ^false ].	^true</body><body package="Com- Automation">validate: aNumber 	"Raise a COMError if a &lt;aNumber&gt; in not a Number or is not the range for a COM Currency. "	(aNumber isKindOf: Number) 		ifFalse: 			[^COMError 				raiseSignal: (#ErrNamedNotNumber &lt;&lt; #com &gt;&gt; '&lt;1p&gt; is not a kind of Number.' 						expandMacrosWith: aNumber)].	(self isInRange: aNumber) 		ifFalse: 			[^COMError 				raiseSignal: (#ErrNamedNotCurrencyRange &lt;&lt; #com 						&gt;&gt; '&lt;1p&gt; is out of range for a COM Currency.' expandMacrosWith: aNumber)].	^true</body></methods><methods><class-id>External.COMCurrency class</class-id> <category>range</category><body package="Com- Automation">denominator	"Answer the denominator of the receiver to use with a FixedPoint."	^COM_CY denominator</body><body package="Com- Automation">scale	"Answer the scale of all COM Currencies."	^COM_CY scale</body><body package="Com- Automation">step	"Answer the level of granularity."	^0.0001s4</body></methods><methods><class-id>External.DispModuleTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">cType	"A module does not have a C type"	^ nil</body><body package="Com- Automation">elements	^ self specificationTable values</body><body package="Com- Automation">typecode	"There is no typecode for modules"	^ nil</body></methods><methods><class-id>External.DispModuleTypeSpec</class-id> <category>printing</category><body package="Com- Automation">kindname	^  (#TKindModule &lt;&lt; #com &gt;&gt; 'Module') asString</body></methods><methods><class-id>External.DispModuleTypeSpec</class-id> <category>private</category><body package="Com- Automation">specificationTable	"Return the specification table for this interface. This should be only called on interfaces"	| typeInfo |	^self specificationTableClass specificationTableForGuid: self guid		ifAbsentPut: 			[typeInfo := self asTypeInfo.			self specificationTableClass constructSpecificationTable: typeInfo]</body><body package="Com- Automation">specificationTableClass	^ COMModuleSpecificationTable</body></methods><methods><class-id>External.DispModuleTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">marshalInArgument: anArgument	self shouldNotImplement</body><body package="Com- Automation">unmarshalOutParam: aParam	self shouldNotImplement</body></methods><methods><class-id>External.DispModuleTypeSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds		^ Array with: TKIND_MODULE</body></methods><methods><class-id>External.IClassFactory2Pointer</class-id> <category>interface operations</category><body package="Com- Automation">CreateInstanceLic: pUnkOuter _: pUnkReserved _: riid _: bstrKey _: resultReference1	" Invoke the IClassFactory2::CreateInstanceLic function. "	"**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	| hresult bstrKeyArg resultBuffer |	bstrKeyArg := bstrKey ifNil: [nil] ifNotNil: [BSTR allocateString: bstrKey].	resultBuffer := COMInterfacePointer resultValueBufferForIID: riid.	hresult := self				invokeCreateInstanceLic: pUnkOuter asPointerParameter				_: pUnkReserved asPointerParameter				_: riid				_: bstrKeyArg asPointerParameter				_: resultBuffer asPointerParameter.	resultReference1 value: resultBuffer contents.	^hresult</body><body package="Com- Automation">GetLicInfo: pLicInfo	" Invoke the IClassFactory2::GetLicInfo function. ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^self invokeGetLicInfo: pLicInfo asPointerParameter</body><body package="Com- Automation">RequestLicKey: dwReserved _: resultReference	" Invoke the IClassFactory2::RequestLicKey function. ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	| hresult resultBuffer |	resultBuffer := BSTR resultValueBuffer.	hresult := self invokeRequestLicKey: dwReserved _: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.IClassFactory2Pointer class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self iid: IID_IClassFactory2.	self updateAndRegister</body></methods><methods><class-id>External.COM_PARAMDESC</class-id> <category>testing</category><body package="Com- Automation">hasDefaultValue	^ self isdefaultValueFlagSet and: [self isOptionalFlagSet ]</body><body package="Com- Automation">isOptionalFlagSet	^ (self flags bitAnd: PARAMFLAG_FOPT) ~= 0</body><body package="Com- Automation">isdefaultValueFlagSet	^ (self flags bitAnd: PARAMFLAG_FHASDEFAULT) ~= 0</body></methods><methods><class-id>External.COM_PARAMDESC</class-id> <category>private</category><body package="Com- Automation">extendedDescription	^ self memberAt: #pparamdescex</body></methods><methods><class-id>External.COM_PARAMDESC</class-id> <category>accessing</category><body package="Com- Automation">defaultValue	^self hasDefaultValue 		ifTrue: 			[(COM_VARIANTARG 				temporaryOn: (self extendedDescription refMemberAt: #varDefaultValue)) value]		ifFalse: [nil]</body><body package="Com- Automation">flags	^ self memberAt: #wParamFlags</body></methods><methods><class-id>External.COM_PARAMDESC class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #PARAMDESC.	self updateAndRegister</body></methods><methods><class-id>External.COMTypedLookupSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">allowsSpecificationTableUpdates	"We don't allow updates as the tables are shared between several objects. 	 Some members may be provided by instance behaviour"    ^false</body><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^true</body></methods><methods><class-id>External.COMTypedLookupSpecificationPolicy</class-id> <category>lookup</category><body package="Com- Automation">initialSpecificationTableFor: aDispatchDriver	^aDispatchDriver type specificationTable</body></methods><methods><class-id>External.COMTypedLookupSpecificationPolicy class</class-id> <category>instance creation</category><body package="Com- Automation">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>External.COMAutomationClientWrapper</class-id> <category>accessing</category><body package="Com- Automation">client	^client</body><body package="Com- Automation">client: anObject	client := anObject</body></methods><methods><class-id>External.COMAutomationClientWrapper</class-id> <category>dispatching</category><body package="Com- Automation">getPropertySpec: aCOMCall	^client getDispatchPropertySpec: aCOMCall</body><body package="Com- Automation">invokeMethodSpec: aMethodSpec withArguments: args withNamedArguments: namedArgs	^ client invokeDispatchMethodSpec: aMethodSpec withArguments: args withNamedArguments: namedArgs result: nil asValueReference.</body><body package="Com- Automation">invokeProcedureSpec: aCOMCall withArguments: argValuesArray withNamedArguments: argValuesDictionary	^client invokeDispatchProcedureSpec: aCOMCall withArguments: argValuesArray withNamedArguments: argValuesDictionary result: nil asValueReference</body><body package="Com- Automation">setPropertySpec: aDispatchSpec withArguments: argValuesArray	^ client setDispatchPropertySpec: aDispatchSpec withArguments: argValuesArray</body></methods><methods><class-id>External.COMAutomationClientWrapper class</class-id> <category>instance creation</category><body package="Com- Automation">on: aClient	^ self new		client: aClient;		yourself</body></methods><methods><class-id>External.PropertySetAccessSpecification</class-id> <category>accessing</category><body package="Com- Automation">accessMode	^ 2</body><body package="Com- Automation">invokationType		^ DISPATCH_PROPERTYPUT</body></methods><methods><class-id>External.PropertySetAccessSpecification</class-id> <category>testing</category><body package="Com- Automation">isPropertySet	^ true</body></methods><methods><class-id>External.PropertySetAccessSpecification</class-id> <category>converting</category><body package="Com- Automation">asPropertyGetSpecification	^self class		forPropertyGet: self propertySpecification		parameters: (self parameters allButLast: 1)		returnValue: self parameters last asReturnValueNoDereference		vtableIndex: self vtableIndex		memberID: self memberID		flags: self flags</body></methods><methods><class-id>External.PropertySetAccessSpecification</class-id> <category>utilities</category><body package="Com- Automation">addTo: aGeneralPropertySpecification	aGeneralPropertySpecification propertySetSpecification: self.</body><body package="Com- Automation">selectorPrefix	" Answer the standard prefix for a property accessor which gets the value of the property. "	^ 'set'</body></methods><methods><class-id>External.DispDriverAccessor</class-id> <category>accessing</category><body package="Com- Automation">driver	"return the dispatch driver I am assigned to"	^driver</body><body package="Com- Automation">driver: anObject	"set the dispatch driver"	driver := anObject</body><body package="Com- Automation">specificationTable	"return my DispatchDriver's specificationTable"	^ driver specificationTable</body></methods><methods><class-id>External.DispDriverAccessor</class-id> <category>printing</category><body package="Com- Automation">printDriverOn: aStream	driver basicPrintOn: aStream.	aStream nextPutAll: ' (Automation)'</body></methods><methods><class-id>External.DispDriverAccessor</class-id> <category>testing</category><body package="Com- Automation">isValid	"return whether I am assigned to a valid dispatch driver"	^ driver isValid</body></methods><methods><class-id>External.DispDriverAccessor</class-id> <category>accessing specs</category><body package="Com- Automation">parameterlessPropertySpecs	"return only my parameterless property specifications"	^ driver specificationTable specificationTable select: [:spec | 		spec isPropertySpecification and: [spec propertyGetSpecificationForDisplay hasParameters not ]].</body></methods><methods><class-id>External.DispDriverAccessor class</class-id> <category>private</category><body package="Com- Automation">classFor: aDispatchDriver	self allSubclassesDo: [:aClass |		(aClass isResponsibleFor: aDispatchDriver) ifTrue: [^ aClass ]]	.	^ self.</body><body package="Com- Automation">driver: aDispatchDriver	"set the dispatch driver"	^ self new		driver: aDispatchDriver;		yourself</body><body package="Com- Automation">isResponsibleFor: aDispatchDriver	"Return whether this class is responsible for the given dispatch driver"	^ false</body></methods><methods><class-id>External.DispDriverAccessor class</class-id> <category>instance creation</category><body package="Com- Automation">for: aDispatchDriver	^ (self classFor: aDispatchDriver) 		driver: aDispatchDriver</body></methods><methods><class-id>External.COMVTableMethodSpecification</class-id> <category>private emphasised texts</category><body package="Com- Automation">getSpecificationForDisplay	^ self asDispatchSpecification</body><body package="Com- Automation">hasResultToDisplay	"Answer whether I have a result type which can be displayed in the browser.	 Subclasses may override this behavior"	^ super hasResultToDisplay or: [ self lastParameterIsResultValue ]</body><body package="Com- Automation">lastParameterIsResultValue	^ self class lastParameterIsResultValue: self</body></methods><methods><class-id>External.COMVTableMethodSpecification</class-id> <category>testing</category><body package="Com- Automation">isEqualTo: aSpecification	^aSpecification isEqualTo: self asDispatchSpecification</body><body package="Com- Automation">isVTable	^ true</body></methods><methods><class-id>External.COMVTableMethodSpecification</class-id> <category>converting</category><body package="Com- Automation">asDispatchSpecification	| params resultType |	self lastParameterIsResultValue		ifTrue: 			[params := self parameters allButLast: 1.			resultType := self parameters last asReturnValueDescription]		ifFalse: 			[params := self parameters.			resultType := COMReturnValueDescription typeCode: VT_VOID].	^COMDispatchMethodSpecification		name: self name		memberID: self memberID		resultType: resultType		parameters: params		optionalParameters: self optionalParameterCount</body></methods><methods><class-id>External.COMVariantValueReference</class-id> <category>converting</category><body package="Com- Automation">asCOMVariant	" Answer a VARIANT which represents the value referenced by the receiver. "	| aVariant |	aVariant := COMStructure createStructureNamed: #VARIANT.	self setCOMVariant: aVariant.	^aVariant</body><body package="Com- Automation">setCOMVariant: aVariant	" Set the type and value of the COM VARIANT &lt;aVariant&gt; to describe the value referenced by the receiver. "	| emptyTypeCodes |	emptyTypeCodes := Array with: VT_VARIANT with: VT_NULL with: VT_EMPTY with: VT_VOID.	self value notNil		ifTrue: [			aVariant				typeCode: ( "COMVariant supportedVariantTypeForTypeCode:"					( ( self typeCode isNil or: [ emptyTypeCodes includes: self typeCode] )                    			ifTrue: [ self value comVariantType ]						ifFalse: [ self typeCode ] ) );				basicValue: self value ].</body></methods><methods><class-id>External.COMVariantValueReference</class-id> <category>accessing</category><body package="Com- Automation">comVariantType	"A COMVariantValueReference is a Pointer to the value. This is only used if the value reference itself should be	 put into a variant, that is if we have a nested variant, which are normally forbidden in COM but appear as the postdata parameter 	 in the InternetExplorer #beforeNavigate2 event. The outer variant then has the typeCode VT_VARIANT | VT_BYREF.	 The stored typecode is the one of the inner object and can't be used here. So return the appropriate type"	^COMVariant filterTypeCode: (typeCode				ifNil: [VT_VARIANT | self baseComVariantType]				ifNotNil: [typeCode | self baseComVariantType])</body><body package="Com- Automation">typeCode	" Answer the type of the variant value referenced by the receiver. "	^typeCode</body><body package="Com- Automation">typeCode: aTypeCode	" Set the type of the variant value referenced by the receiver to &lt;aTypeCode&gt;. "	typeCode := aTypeCode.</body></methods><methods><class-id>External.COMVariantValueReference</class-id> <category>printing</category><body package="Com- Automation">printValueOn: aStream	" Append a text description of value referenced by the receiver to &lt;aStream&gt; "	super printValueOn: aStream.	typeCode notNil		ifTrue: [			aStream nextPutAll: ' (', ( COMVariant typeCodeDescriptionOf: typeCode ), ')' ].</body></methods><methods><class-id>External.COMVariantValueReference</class-id> <category>testing</category><body package="Com- Automation">isArrayOfVariantOrInterface	^COMVariant isArrayOfInterfacesOrVariants: self typeCode</body></methods><methods><class-id>External.DispatchInterfaceTypeSpec</class-id> <category>printing</category><body package="Com- Automation">protocolFilterName	^ self name,' (Dispatch)'</body></methods><methods><class-id>External.DispatchInterfaceTypeSpec</class-id> <category>private</category><body package="Com- Automation">defaultInterfaceClass	^IDispatch</body><body package="Com- Automation">specificationTableClass	^COMDispatchSpecificationTable</body></methods><methods><class-id>External.DispatchInterfaceTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">kindname	^ self isDualInterface		ifTrue: [(#DualInterface &lt;&lt; #com &gt;&gt; 'Dual Interface') asString]		ifFalse: [(#TKindDispatch &lt;&lt; #com &gt;&gt; 'Dispatch') asString]</body><body package="Com- Automation">typecode	^ VT_DISPATCH</body></methods><methods><class-id>External.DispatchInterfaceTypeSpec</class-id> <category>converting</category><body package="Com- Automation">dispatchType	^ self</body><body package="Com- Automation">vtableType	^ self alternativeRepresentation</body></methods><methods><class-id>External.DispatchInterfaceTypeSpec</class-id> <category>testing</category><body package="Com- Automation">isDispatch	^ true</body></methods><methods><class-id>External.DispatchInterfaceTypeSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds		^ Array with:  TKIND_DISPATCH</body></methods><methods><class-id>External.EMBEDDED_SAFEARRAY</class-id> <category>accessing</category><body package="Com- Automation">dataPointer	^ self memberAt: #pvData</body><body package="Com- Automation">dataPointer: aPointer	^ self memberAt: #pvData put: aPointer.</body><body package="Com- Automation">fixedSizeDataPointer	^fixedSizeDataPointer</body><body package="Com- Automation">fixedSizeDataPointer: anObject	fixedSizeDataPointer := anObject</body></methods><methods><class-id>External.EMBEDDED_SAFEARRAY</class-id> <category>accessing elements</category><body package="Com- Automation">at: indices	"We restore the fixed data pointer and restore the original one afterwards"	^ self withDataPointerDo: [ super at: indices	]</body><body package="Com- Automation">at: indices put: newValue	"We restore the fixed data pointer and restore the original one afterwards"	^ self withDataPointerDo: [ super at: indices put: newValue ]</body><body package="Com- Automation">referenceAt: indices	"Answer a reference variant to the element at the given index"	^ self withDataPointerDo: [ super referenceAt: indices ]</body></methods><methods><class-id>External.EMBEDDED_SAFEARRAY</class-id> <category>private</category><body package="Com- Automation">withDataPointerDo: aBlock	| oldPointer |	oldPointer := self dataPointer.	self dataPointer: self fixedSizeDataPointer.	^ [ aBlock value ] ensure: [ self dataPointer: oldPointer ].</body></methods><methods><class-id>External.EMBEDDED_SAFEARRAY class</class-id> <category>instance creation</category><body package="Com- Automation">new: bounds type: aType fixedSizeDataPointer: fsArrayDataPointer	"We retain the original null data pointer and only exchange it when accessing elements	 to avoid the value is not restored"	^ (self newWithoutDataArea: bounds type: aType) 			fixedSizeDataPointer: fsArrayDataPointer;		yourself.</body><body package="Com- Automation">newWithoutDataArea: indices type: aType	" Create a new embedded safearray, that is, we don't create the data area, as it is provided by somebody else"	^ (aType newSafeArrayDescriptor: indices size bounds: ( self boundsForIndices: indices ))		typeDescription: aType;		yourself</body><body package="Com- Automation">temporaryOn: aPointer fixedSizeDataPointer: fsArrayDataPointer	"We retain the original null data pointer and only exchange it when accessing elements	 to avoid the value is not restored"	^ (self temporaryOn: aPointer) 			fixedSizeDataPointer: fsArrayDataPointer;		yourself.</body></methods><methods><class-id>External.EMBEDDED_SAFEARRAY class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	self structureName: #FIXEDSIZESAFEARRAY.	self updateAndRegister</body></methods><methods><class-id>External.COMSpecificationQuery</class-id> <category>accessing</category><body package="Com- Automation">arguments	^arguments</body><body package="Com- Automation">arguments: anObject	arguments := anObject</body><body package="Com- Automation">kinds	^kinds</body><body package="Com- Automation">kinds: anObject	kinds := anObject</body><body package="Com- Automation">member	^member</body><body package="Com- Automation">member: anObject	member := anObject</body><body package="Com- Automation">namedArguments	^namedArguments</body><body package="Com- Automation">namedArguments: anObject	namedArguments := anObject</body></methods><methods><class-id>External.COMSpecificationQuery class</class-id> <category>instance creation simplified</category><body package="Com- Automation">forEvent: aName arguments: arguments namedArguments: namedArguments	^self		name: aName		kind: COMAbstractMemberSpecification eventKindName		arguments: arguments		namedArguments: namedArguments</body><body package="Com- Automation">forMethod: aName	^self forMethod: aName arguments: nil namedArguments: nil</body><body package="Com- Automation">forMethod: aName arguments: arguments namedArguments: namedArguments	^self		name: aName		kind: COMAbstractMemberSpecification methodKindName		arguments: arguments		namedArguments: namedArguments</body><body package="Com- Automation">forMethodOrProperty: aName arguments: arguments namedArguments: namedArguments	^self		name: aName		kinds: (Array with: COMAbstractMemberSpecification methodKindName				with: COMAbstractMemberSpecification propertyKindName)		arguments: arguments		namedArguments: namedArguments</body><body package="Com- Automation">forName: aName	^self new		member: aName;		yourself</body><body package="Com- Automation">forProperty: aName	^self forProperty: aName arguments: nil namedArguments: nil</body><body package="Com- Automation">forProperty: aName arguments: arguments namedArguments: namedArguments	^self		name: aName		kind: COMAbstractMemberSpecification propertyKindName		arguments: arguments		namedArguments: namedArguments</body><body package="Com- Automation">forPropertyOrMethod: aName arguments: arguments namedArguments: namedArguments	^self		name: aName		kinds: (Array with: COMAbstractMemberSpecification propertyKindName				with: COMAbstractMemberSpecification methodKindName)		arguments: arguments		namedArguments: namedArguments</body></methods><methods><class-id>External.COMSpecificationQuery class</class-id> <category>instance creation</category><body package="Com- Automation">name: aName kind: kind arguments: arguments namedArguments: namedArguments	^self		name: aName		kinds: (Array with: kind)		arguments: arguments		namedArguments: namedArguments</body><body package="Com- Automation">name: aName kinds: kinds arguments: arguments namedArguments: namedArgs	^(self new)		member: aName;		kinds: kinds;		arguments: arguments;		namedArguments: namedArgs;		yourself</body></methods><methods><class-id>External.COMTypeLibraryLookupSpecificationPolicy</class-id> <category>private-accessing</category><body package="Com- Automation">functionMapFor: anITypeInfo    "Private. Answer the Dictionary of function names and indices. The    Dictionary is built from &lt;anITypeInfo&gt; the first time."    functionMap isNil        ifTrue: [ functionMap := self buildFunctionMapFor: anITypeInfo ].    ^functionMap</body><body package="Com- Automation">propertyMapFor: anITypeInfo    "Private. Answer the Dictionary of property names and indices. The    Dictionary is built from &lt;anITypeInfo&gt; the first time."    propertyMap isNil        ifTrue: [ propertyMap := self buildPropertyMapFor: anITypeInfo ].    ^propertyMap</body><body package="Com- Automation">propertyVariableIndexFor: anITypeInfo    "Private. Answer the Dictionary of variable names and indices. The    Dictionary is built from &lt;anITypeInfo&gt; the first time."    propertyVariableMap isNil        ifTrue: [ propertyVariableMap := self buildPropertyVariableMapFor: anITypeInfo ].    ^propertyVariableMap</body></methods><methods><class-id>External.COMTypeLibraryLookupSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">allowsSpecificationTableUpdates	"Answer whether it makes sense for the receiver to update the specification table ."    ^true</body><body package="Com- Automation">canSupportIDispatch: anIDispatch forLocaleID: aLocaleID	| canSupportPolicy anITypeInfo |	[ anITypeInfo := anIDispatch getTypeInfoForLocale: aLocaleID ] 		on: COMError do: [ : ex | ^false ].	canSupportPolicy := anITypeInfo notNil.	^canSupportPolicy</body><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^true</body></methods><methods><class-id>External.COMTypeLibraryLookupSpecificationPolicy</class-id> <category>accessing</category><body package="Com- Automation">typeInfoFor: anOLEDispatchDriver	"Answer the cached type information.or initialize the cache from &lt;anOLEDispatchDriver&gt;."	typeInfo notNil		ifTrue: [ ^typeInfo ].	^typeInfo := anOLEDispatchDriver getTypeInfo</body></methods><methods><class-id>External.COMTypeLibraryLookupSpecificationPolicy</class-id> <category>description</category><body package="Com- Automation">description	"Answer a description for the recevier."	^'type library'</body></methods><methods><class-id>External.COMTypeLibraryLookupSpecificationPolicy</class-id> <category>releasing</category><body package="Com- Automation">release	"Release resources associated with the receiver."	typeInfo := nil.	super release</body></methods><methods><class-id>External.COMTypeLibraryLookupSpecificationPolicy</class-id> <category>private-initializing</category><body package="Com- Automation">buildFunctionMapFor: anITypeInfo    "Private. Answer a Dictionary where the keys are the function names from each    FUNCDESC from &lt;anITypeInfo&gt; and the values are indices into that &lt;anITypeInfo&gt; where    full information can be obtained."    | nFunctions aTypeAttr aFuncDesc indexMap |    aTypeAttr := anITypeInfo getTypeAttr.    [    nFunctions := aTypeAttr functionCount.    indexMap := Dictionary new: nFunctions.    1 to: nFunctions do:        [ :index |        aFuncDesc := anITypeInfo getFuncDesc: index - 1.        [ ( aFuncDesc isRestricted not and: [ aFuncDesc isDispatch ] )            ifTrue: [                | nameList name |                nameList := anITypeInfo getNames: aFuncDesc memberID count: 1.                name := nameList at: 1.                indexMap at: name put: index - 1 ].        ] ensure: [ aFuncDesc enforceRelease ].        ]    ] ensure: [ aTypeAttr enforceRelease ].    ^indexMap</body><body package="Com- Automation">buildPropertyMapFor: anITypeInfo    "Private. Answer a Dictionary where the keys are the property names from each    FUNCDESC from &lt;anITypeInfo&gt; and the values are indices into that &lt;anITypeInfo&gt; where    full information can be obtained."    | nFunctions aTypeAttr aFuncDesc indexMap |    aTypeAttr := anITypeInfo getTypeAttr.    [    nFunctions := aTypeAttr functionCount.    indexMap := Dictionary new: nFunctions.    1 to: nFunctions do:        [ :index |        aFuncDesc := anITypeInfo getFuncDesc: index - 1.        aFuncDesc isRestricted            ifFalse: [                ( aFuncDesc isPropertyGet                or: [ aFuncDesc isPropertyPut                or: [ aFuncDesc isPropertyPutRef ] ] )                    ifTrue: [                        | nameList name saveIndex |                        nameList := anITypeInfo getNames: aFuncDesc memberID count: 1.                        name := nameList at: 1.                        saveIndex := index - 1.                        " Save multiple indices in a list for the same name."                        ( indexMap includesKey: name )                            ifTrue: [					" In VSE, this test was isArray and the blocks ifTrue:ifFalse: instead. [GG Apr-29-1997]"                                ( indexMap at: name ) isInteger                                    ifFalse: [ indexMap at: name put: ( ( indexMap at: name ), ( Array with: saveIndex ) ) ]                                    ifTrue: [ indexMap at: name put: ( Array with: saveIndex ) ] ]                            ifFalse: [ indexMap at: name put: saveIndex ] ].                ].        aFuncDesc enforceRelease ].    ] ensure: [ aTypeAttr enforceRelease ].    ^indexMap</body><body package="Com- Automation">buildPropertyVariableMapFor: anITypeInfo    "Private. Answer a Dictionary where the keys are the variable names from each    VARDESC from &lt;anITypeInfo&gt; and the values are indices into that &lt;anITypeInfo&gt; where    full information can be obtained."    | nVariables aTypeAttr aVarDesc indexMap |    aTypeAttr := anITypeInfo getTypeAttr.    [    nVariables := aTypeAttr variableCount.    indexMap := Dictionary new: nVariables.    1 to: nVariables do:        [ :index |        aVarDesc := anITypeInfo getVarDesc: index - 1.        [ aVarDesc isDispatch            ifTrue: [                | nameList name |                nameList := anITypeInfo getNames: aVarDesc memberID count: 1.                name := nameList at: 1.                indexMap at: name put: index - 1 ].        ] ensure: [ aVarDesc enforceRelease ].        ]    ] ensure: [ aTypeAttr enforceRelease ].    ^indexMap</body></methods><methods><class-id>External.COMTypeLibraryLookupSpecificationPolicy</class-id> <category>private lookup-method</category><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    for: anOLEDispatchDriver    "Lookup and answer a new method specification for &lt;aName&gt;."	| index map anITypeInfo |	anITypeInfo := self typeInfoFor: anOLEDispatchDriver.	map := self functionMapFor: anITypeInfo.	index := map at: (self formatKey: aName) ifAbsent: [ ^nil ].	^self methodSpecificationAt: index for: anITypeInfo</body><body package="Com- Automation">methodSpecification: aName    withArguments: argValuesArray    withNamedArguments: argValuesDictionary    for: anOLEDispatchDriver    "Lookup and answer a new method specification for &lt;aName&gt;."    ^self methodSpecification: aName        withArguments: argValuesArray        for: anOLEDispatchDriver</body><body package="Com- Automation">methodSpecificationAt: index for: anITypeInfo	"Private. Answer a new method specification for the FUNCDESC in &lt;anITypeInfo&gt; at &lt;index&gt;."	| aFuncDesc |	aFuncDesc := anITypeInfo getFuncDesc: index.	^	["We checked for restricted and dispatch already when the index was built."	COMDispatchMethodSpecification forDescription: aFuncDesc		typeInfo: anITypeInfo]			ensure: [aFuncDesc enforceRelease]</body></methods><methods><class-id>External.COMTypeLibraryLookupSpecificationPolicy</class-id> <category>private lookup-property</category><body package="Com- Automation">formatKey: aStringOrSymbol	^aStringOrSymbol asString</body><body package="Com- Automation">propertySpecification: aName    withGetArguments: argValuesArray    for: anOLEDispatchDriver    "Lookup and answer a new property specification for &lt;aName&gt;."    | map indexOrArray anITypeInfo specification list |    specification := self propertyVariableSpecification: aName        withArguments: argValuesArray        for: anOLEDispatchDriver.     specification notNil        ifTrue: [ ^specification ].    anITypeInfo := self typeInfoFor: anOLEDispatchDriver.    map := self propertyMapFor: anITypeInfo.    indexOrArray := map at: aName ifAbsent: [ ^nil ].    indexOrArray isInteger        ifFalse: [ list := indexOrArray ]        ifTrue: [ list := Array with: indexOrArray ].    ^self propertySpecificationAt: list for: anITypeInfo</body><body package="Com- Automation">propertySpecificationAt: list for: anITypeInfo	"Private. Answer a new property specification for the FUNCDESC in &lt;anITypeInfo&gt; at &lt;index&gt;."	| aFuncDesc specification aPropertyClass |	list do: 			[:index |			aFuncDesc := anITypeInfo getFuncDesc: index.						["We checked for restricted and dispatch already when the index was built."			specification isNil				ifTrue: 					[aPropertyClass := aFuncDesc parameterCount = 0								ifTrue: [COMDispatchPropertySpecification]								ifFalse: [COMDispatchParameterizedPropertySpecification].					specification := aPropertyClass forDescription: aFuncDesc								typeInfo: anITypeInfo]				ifFalse: 					[" Merge the get/set info with the previously processed set/get info "					specification isParameterized						ifTrue: 							["Only merge parameterized properties."							specification mergeOperationDescription: aFuncDesc typeInfo: anITypeInfo]]]					ensure: [aFuncDesc enforceRelease]].	^specification</body><body package="Com- Automation">propertyVariableSpecification: aName    withArguments: argValuesArray    for: anOLEDispatchDriver    "Private. Lookup and answer a new property specification for &lt;aName&gt;."    | map index anITypeInfo |    anITypeInfo := self typeInfoFor: anOLEDispatchDriver.    map := self propertyVariableIndexFor: anITypeInfo.    index := map at: aName ifAbsent: [ ^nil ].    ^self propertyVariableSpecificationAt: index for: anITypeInfo</body><body package="Com- Automation">propertyVariableSpecificationAt: index for: anITypeInfo	"Private. Answer a new property specification for the VARDESC in &lt;anITypeInfo&gt; at &lt;index&gt;."	| aVarDesc |	aVarDesc := anITypeInfo getVarDesc: index.	^	["We checked for restricted and dispatch already when the index was built."	COMDispatchPropertySpecification forDescription: aVarDesc		typeInfo: anITypeInfo]			ensure: [aVarDesc enforceRelease]</body></methods><methods><class-id>External.COMEventSink</class-id> <category>events</category><body package="Com- Automation">canTriggerEvent: eventName        "Answer &lt;true&gt; if the receiver can trigger an event        named &lt;eventName&gt;."	^( super canTriggerEvent: eventName )		or: [ self hasEvent: eventName ]</body><body package="Com- Automation">eventNameFromSpecification: each	^ each name asSymbol</body><body package="Com- Automation">hasEvent: eventName	"Answer whether the receiver receives notifications		for an event named &lt;eventName&gt;."	| name |	self configuration specificationTable isNil ifTrue: [^false].	name := self formatEventName: eventName.	^self configuration specificationTable		contains: [:each | (self eventNameFromSpecification: each) = name]</body><body package="Com- Automation">supportedEvents	"Answer the names of the events for which notifications are receiver. "	^self configuration specificationTable values		collect: [:each | self eventNameFromSpecification: each]</body></methods><methods><class-id>External.COMEventSink</class-id> <category>private-operation</category><body package="Com- Automation">actionToTriggerEvent: anEventName	" Private - answer the action to evaluate with the event name and arguments to trigger the event &lt;anEventName&gt;.  Answer nil if there is nothing to do. "	| relayAction eventAction |	relayAction := self actionForEvent: #eventNotification:arguments:.	eventAction := self actionForEvent: anEventName.	( relayAction isNil and: [ eventAction isNil ] )		ifTrue: [ ^nil ].	" answer a block which will perform the following:	self triggerEvent: #eventNotification:arguments:		withArguments: ( Array with: eventName with: arguments ).	self triggerIndividualEvents		ifTrue: [ self triggerEvent: eventName withArguments: arguments ].	"	^[ :eventName :arguments |		relayAction notNil			ifTrue: [ relayAction evaluateWithArguments: ( Array with: eventName with: arguments ) ].		eventAction  notNil			ifTrue: [ eventAction evaluateWithArguments: arguments ].		]</body><body package="Com- Automation">formatEventName: aSymbol 		^ (aSymbol copyUpTo: $:) asSymbol</body></methods><methods><class-id>External.COMEventSink</class-id> <category>subclass-releasing</category><body package="Com- Automation">forceRelease    " Private - attempt to forcibly release the receiver.  Answer whether successful.  This is a dangerous thing to do and is primarily a developer debugging facility. "	self releaseResources.</body><body package="Com- Automation">releaseResources	" Private - release resources associated with the receiver. "	self configuration disconnect.	super releaseResources</body></methods><methods><class-id>External.COMEventSink</class-id> <category>event accessing</category><body package="Com- Automation">actionForEvent: anEventNameSymbol	^super actionForEvent: (self formatEventName: anEventNameSymbol)</body><body package="Com- Automation">actionListForEvent: anEventNameSymbol	^super actionListForEvent: (self formatEventName: anEventNameSymbol)</body><body package="Com- Automation">hasActionForEvent: anEventNameSymbol	^ super hasActionForEvent: (self formatEventName: anEventNameSymbol)</body><body package="Com- Automation">removeActionsForEvent: anEventNameSymbol	^super removeActionsForEvent: (self formatEventName: anEventNameSymbol)</body><body package="Com- Automation">removeActionsSatisfying: aBlock forEvent: anEventNameSymbol	^super removeActionsSatisfying: aBlock		forEvent: (self formatEventName: anEventNameSymbol)</body></methods><methods><class-id>External.COMEventSink</class-id> <category>private-events</category><body package="Com- Automation">setActionList: actionSequence forEvent: eventName	^super setActionList: actionSequence		forEvent: (self formatEventName: eventName)</body></methods><methods><class-id>External.COMEventSink</class-id> <category>subclass-accessing</category><body package="Com- Automation">getInterfaceForIID: iid	" Private - answer the interface identified by the GUID &lt;iid&gt;.		Answer nil if the requested interface is not supported by the receiver. "	iid = self configuration connectionPointIID		ifTrue: [^self dispatchInterface].	^super getInterfaceForIID: iid</body></methods><methods><class-id>External.COMEventSink</class-id> <category>accessing</category><body package="Com- Automation">configuration	^configuration</body><body package="Com- Automation">connectionPointIID: anIID	" Set the IID of the connection point which is dispatching		event notifications to the receiver to &lt;anIID. "	(self configuration connectionPointIID notNil		and: [self configuration connectionPointIID ~= IID_IDispatch])			ifTrue: 				[COMError					raiseSignal: #ErrCantChangeIID &lt;&lt; #com &gt;&gt; 'cannot change IID of event set'].	self configuration connectionPointIID: anIID.	"Assert isTrue: [ self dispatchInterface iid = IID_IDispatch ]."	self dispatchInterface iid: anIID</body><body package="Com- Automation">disconnect	"release the connection and the connection interface"	self configuration disconnect</body></methods><methods><class-id>External.COMEventSink</class-id> <category>subclass-initializing</category><body package="Com- Automation">createIDispatch	" Private - create an IDispatch interface on the receiver. "	^(super createIDispatch)		iid: (self configuration connectionPointIID ifNil: [IID_IDispatch]);		yourself</body><body package="Com- Automation">initialize	" Private - initialize a new instance. "	configuration := SinkConfiguration new.	SystemGlobalRegistries safe: configuration forLifeTimeOf: self.	configuration connectionPointIID: IID_IDispatch.	" default init value until real event set IID is supplied "	super initialize.	configuration sinkInterface: self dispatchInterface</body></methods><methods><class-id>External.COMEventSink</class-id> <category>private-IDispatch operations</category><body package="Com- Automation">GetIDsOfNames: iid _: nameList _: cNames _: lcid _: resultReference		" Private - Implement the IDispatch::GetIDsOfNames function. "	"Get IDs of names for the event notifications.    Map a single member and an optional set of argument names into    a corresponding set of DISPID's which can be used with IDispatch::Invoke.    The first element is the DISPID of the member name; subsequent    elements represent each of the member's parameters.	Answer the result code."    | eventName aDispatchSpecification dispidEvent dispidList |	Tools.Note ISSUE.  " ^DISP_EUNKNOWNLCID if not supported locale [DL 30-Oct-95] " 	Tools.Note ISSUE.  " Steve's original implementation lowercased		the event name here and did straight equal.  Doesn't		seem like a good assumption unless lowercase		was enforced when the event specifications		were constructed. [DL 30-Oct-95] "     eventName := nameList at: 1.    aDispatchSpecification := self configuration specificationTable 		detect: [ :each | each name sameAs: eventName ]         ifNone: [ nil ].    dispidEvent := ( aDispatchSpecification == nil        ifTrue: [ DISPID_UNKNOWN ]        ifFalse: [ aDispatchSpecification memberID ] ).	cNames = 1        ifTrue: [ dispidList := Array with: dispidEvent ]        ifFalse: [            dispidList := Array new: cNames.            dispidList atAllPut: DISPID_UNKNOWN.  " parameter name mappings not supported "            dispidList at: 1 put: dispidEvent ].    resultReference value: dispidList.    ^( dispidEvent = DISPID_UNKNOWN	or: [ cNames &gt; 1 ] )        ifTrue: [ DISP_E_UNKNOWNNAME ]        ifFalse: [ S_OK ]</body><body package="Com- Automation">Invoke: dispidMember _: iid _: lcid _: wFlags _: dispParams _: resultReference _: exceptionInfoReference _: argErrorReference	" Private - implement the IDispatch::Invoke function.		Reflect the received event notification into the image		as an application event. "	"VB clients may set both flags as they sometimes can not detemine the call type"	| eventSpec eventName eventAction arguments |	(wFlags = DISPATCH_METHOD		or: [wFlags = (DISPATCH_METHOD bitOr: DISPATCH_PROPERTYGET)])			ifFalse: [^E_INVALIDARG].	eventSpec := self configuration specificationTable at: dispidMember				ifAbsent: [^DISP_E_MEMBERNOTFOUND].	eventName := self eventNameFromSpecification: eventSpec.	self logIfTraceEnabled: 			[#ComEventNotification &lt;&lt; #com &gt;&gt; '&lt;t&gt;COM event &lt;1s&gt; notification received'				expandMacrosWith: eventSpec name].	eventAction := self actionToTriggerEvent: eventName.	eventAction isNil ifTrue: [^S_OK].		[" realize the event arguments as Smalltalk values only when someone really cares "	arguments := self valueAdaptor				argumentsForMethod: eventSpec				parameters: dispParams				localeID: lcid.	arguments isInteger		ifTrue: 			[argErrorReference value: arguments.			^DISP_E_TYPEMISMATCH].	self logIfTraceEnabled: 			[#NamedArgumentsColon &lt;&lt; #com &gt;&gt; '&lt;tt&gt;arguments: &lt;1p&gt;'				expandMacrosWith: arguments].	eventAction value: eventName		value: (arguments collect: [:each | each value])	" alt: evaluateWithArguments: ( Array with: eventName with: arguments )"]			on: Error			do: 				[:ex |				^self handleDispatchInvokeException: ex					exceptionInfo: exceptionInfoReference].	"proposed Fix"	self valueAdaptor updateReturnReferenceArguments: arguments		fromParameters: dispParams.	^S_OK</body></methods><methods><class-id>External.COMEventSink</class-id> <category>releasing</category><body package="Com- Automation">release	"Remove references to objects that may refer to the receiver. Answers self. "	" Note that we are careful not to invoke IUnknown::Release on the receiver, as is done by default for a COMObject as part of the convenience protocol of supporting the IUnknown operations directly on the object, which is strictly incorrect in the COM architecture because clients should never have direct access to anything but an interface but generally convenient for the Smalltalk COM developer who is actually creating a COMObject instance.  A COM event sink object is a Smalltalk object which happens to use COM services in its implementation.  It is used by a Smalltalk client who creates the event sink, connects it to some event source object, and then disconnects the event sink when they are done.  Although the creator should not ordinarily release the event sink itself, unless they have specifically acquired an interface reference themselves via #queryInterface: that they thus own and are responsible for releasiong, it would not be surprising for a Smalltalk programmer to (incorrectly) send #release to the sink object they created because they've gotten used to the COM rule 'always send #release when you're done using your COM resource', forgetting that this is not an interface that they have acquired but Just Another Smalltalk Object that they created.  Anyway, we want to be safe and protect against inadvertent reference counting bugs that would result from the inherited semantics of the COMObject convenience method.  Really bad things happen when you release an object you don't own out from underneath whoever really owns it and presumably is still trying to use it. "	self objectRelease.	self configuration releaseConnection.  " disconnect if the sink was still connected "</body></methods><methods><class-id>External.COMEventSink</class-id> <category>As yet unclassified</category><body package="Com- Automation">specificationTable	^self configuration specificationTable</body></methods><methods><class-id>External.COMEventSink</class-id> <category>connecting</category><body package="Com- Automation">establishConnectionTo: anInterface	" Establish an event connection to the event source object 		which supports &lt;anInterface&gt;. "	^configuration establishConnectionTo: anInterface</body></methods><methods><class-id>External.COMEventSink</class-id> <category>initialize-release</category><body package="Com- Automation">configureIID: anIID specificationTable: specificationTable	self connectionPointIID: anIID.	self configuration specificationTable: specificationTable</body></methods><methods><class-id>External.COMEventSink</class-id> <category>finalization</category><body package="Com- Automation">finalize		"Don't release the connection point interface explicitely. It will also be finalized automatically."	self configuration connectionPointInterface: nil.	super finalize.</body></methods><methods><class-id>External.COMEventSink class</class-id> <category>subclass-events</category><body package="Com- Automation">constructEventsTriggered        "Private - answer the set of events that instances of the        receiver can trigger."	^super constructEventsTriggered		add: #eventNotification:arguments: ;		yourself</body></methods><methods><class-id>External.COMEventSink class</class-id> <category>instance creation</category><body package="Com- Automation">iid: anIID specificationTable: aSpecificationTable	" Answer a new instance of the receiver which will receive event		notifications from the connection point specified by &lt;anIID&gt;.		The incoming event notifications are described by the		specifications in &lt;aSpecificationTable&gt;.  "	^(self new)		configureIID: anIID specificationTable: aSpecificationTable;		yourself</body></methods><methods><class-id>External.COMRecordMemoryPolicy</class-id> <category>accessing</category><body package="Com- Automation">ownsMemory	^ownsMemory ifNil: [ false ]</body><body package="Com- Automation">ownsMemory: anObject	ownsMemory := anObject</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>accessing</category><body package="Com- Automation">actualType	^actualType</body><body package="Com- Automation">actualType: anObject	actualType := anObject</body><body package="Com- Automation">cType	^ CTypedefType new		name: self name;		type: self actualType cType;		yourself</body><body package="Com- Automation">elements	^ actualType elements</body><body package="Com- Automation">iid	^ actualType iid</body><body package="Com- Automation">kindname	^  (#TKindAlias &lt;&lt; #com &gt;&gt; 'Alias') asString</body><body package="Com- Automation">methods	^ self actualType methods</body><body package="Com- Automation">typecode	^actualType ifNotNil: [actualType typecode]</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>testing</category><body package="Com- Automation">isArray	^ actualType isArray</body><body package="Com- Automation">isByref	^ actualType isByref</body><body package="Com- Automation">isClassOrInterface	^ actualType isClassOrInterface</body><body package="Com- Automation">isStructure	^ actualType isStructure</body><body package="Com- Automation">isVariant	^ actualType isVariant</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>comparing</category><body package="Com- Automation">derivesFromType: aType	^ self = aType or: [ actualType notNil and: [ actualType derivesFromType: aType ]]</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>printing</category><body package="Com- Automation">printPtrTypeOn: aStream	^ actualType printOn: aStream name: self name</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>testing variant</category><body package="Com- Automation">variantContainsRefValue: aVariant	"ask the actual type"	^ actualType variantContainsRefValue: aVariant</body><body package="Com- Automation">variantContainsValue: aVariant	"ask the actual type"	^ actualType variantContainsValue: aVariant</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>marshaling</category><body package="Com- Automation">convertToSTObject: aCOMObject	^ self actualType convertToSTObject: aCOMObject</body><body package="Com- Automation">createOutArgument	^ self actualType createOutArgument</body><body package="Com- Automation">createPtrOutArgument	^ self actualType createPtrOutArgument</body><body package="Com- Automation">createPtrPtrOutArgument	^ self actualType createPtrPtrOutArgument</body><body package="Com- Automation">freeArgument: anArgument	^ self actualType freeArgument: anArgument</body><body package="Com- Automation">freePtrArgument: anArgument	^ self actualType freePtrArgument: anArgument</body><body package="Com- Automation">invalidateInParameterValueIn: aSmalltalkValue	^ self actualType invalidateInParameterValueIn: aSmalltalkValue</body><body package="Com- Automation">invalidatePtrInParameterValueIn: aSmalltalkValue	^ self actualType invalidatePtrInParameterValueIn: aSmalltalkValue</body><body package="Com- Automation">invalidatePtrPtrInParameterValueIn: aSmalltalkValue	^ self actualType invalidatePtrPtrInParameterValueIn: aSmalltalkValue</body><body package="Com- Automation">marshalInArgument: anArgument	^ self actualType marshalInArgument: anArgument</body><body package="Com- Automation">marshalPointerArgument: anArgument	^ self actualType marshalPointerArgument: anArgument</body><body package="Com- Automation">newResultParameter	^self actualType newResultParameter</body><body package="Com- Automation">newResultPointerParameter	^ self actualType newResultPointerParameter</body><body package="Com- Automation">newResultPtrPtrParameter	^ self actualType newResultPtrPtrParameter</body><body package="Com- Automation">newSafeArray: dims bounds: bounds	^ self actualType newSafeArray: dims bounds: bounds</body><body package="Com- Automation">newSafeArrayDescriptor: dims bounds: bounds	^ self actualType newSafeArrayDescriptor: dims bounds: bounds yourself</body><body package="Com- Automation">primitiveArgumentFor: aValue	^ self actualType primitiveArgumentFor: aValue</body><body package="Com- Automation">releaseRecordElement: aVariant	^ self actualType releaseRecordElement: aVariant</body><body package="Com- Automation">releaseServerArgument: anArg	^ self actualType releaseServerArgument: anArg</body><body package="Com- Automation">setRefPointer: aPointer in: aVariant	^ self actualType setRefPointer: aPointer in: aVariant</body><body package="Com- Automation">unmarshalOutParam: aParam	^ self actualType unmarshalOutParam: aParam</body><body package="Com- Automation">unmarshalOutParameter: aMarshaledValue into: aSmalltalkValue	^ self actualType unmarshalOutParameter: aMarshaledValue		into: aSmalltalkValue</body><body package="Com- Automation">unmarshalPtrOutParameter: aMarshaledValue into: aSmalltalkValue	^ self actualType unmarshalPtrOutParameter: aMarshaledValue		into: aSmalltalkValue</body><body package="Com- Automation">unmarshalPtrPtrOutParameter: aMarshaledValue into: aSmalltalkValue	^ self actualType unmarshalPtrPtrOutParameter: aMarshaledValue		into: aSmalltalkValue</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>marshaling automation</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: client	^ self actualType preMarshalAutomationParameter: aValue client: client</body><body package="Com- Automation">preMarshalPtrAutomationParameter: anIDispatch client: aCOMDispatchValueAdaptor	"Default Implementation"	^ self actualType preMarshalPtrAutomationParameter: anIDispatch		client: aCOMDispatchValueAdaptor</body><body package="Com- Automation">releaseUnusedAutomationOutValue: aResult inValue: anObject	"release an unused result"	^ self actualType releaseUnusedAutomationOutValue: aResult		inValue: anObject</body><body package="Com- Automation">unmarshalAutomationResult: aValue	^ self actualType unmarshalAutomationResult: aValue</body><body package="Com- Automation">unmarshalAutomationResult: aValue into: aResultReference	^ self actualType unmarshalAutomationResult: aValue into: aResultReference</body><body package="Com- Automation">unmarshalPtrAutomationResult: aValue into: aResultReference	^ self actualType unmarshalPtrAutomationResult: aValue		into: aResultReference</body></methods><methods><class-id>External.DispAliasTypeSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFromTypeInfo: refTypeInfo typeLib: aTypeLibDesc 	^refTypeInfo withTypeAttrDo: 			[:attr | 			(super basicFromTypeInfo: refTypeInfo typeLib: aTypeLibDesc)				actualType: (self baseClass forTypeDesc: attr tdescAlias							typeInfo: refTypeInfo);				yourself]</body></methods><methods><class-id>External.DispAliasTypeSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds	^ Array with: TKIND_ALIAS</body></methods><methods><class-id>External.DispAliasTypeSpec class</class-id> <category>literal array encoding</category><body package="Com- Automation">literallyEncodedAttributes	^ super literallyEncodedAttributes, #(actualType)</body></methods><methods><class-id>External.ILicenseManagerPointer</class-id> <category>interface operations</category><body package="Com- Automation">CreateInstance: class _: pUnkOuter _: riid _: license _: resultReference1	" Invoke the ILicenseManager::CreateInstance function. "	"**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	| hresult licenseArg resultBuffer |	licenseArg := license ifNotNil: [BSTR allocateString: license].	resultBuffer := COMInterfacePointer resultValueBufferForIID: riid.		[hresult := self				invokeCreateInstance: class				_: pUnkOuter asPointerParameter				_: riid				_: licenseArg asPointerParameter				_: resultBuffer asPointerParameter.	resultReference1 value: resultBuffer contents]			ensure: [licenseArg enforceRelease].	^hresult</body><body package="Com- Automation">IsDevelopment: class _: resultReference	" Invoke the ILicenseManager::IsDevelopment function. ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #BOOL.	hresult := self invokeIsDevelopment: class _: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Automation">QueryLicenseKey: class _: resultReference	" Invoke the ILicenseManager::QueryLicenseKey function. ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	| hresult resultBuffer |	resultBuffer := BSTR resultValueBuffer.	hresult := self invokeQueryLicenseKey: class _: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.ILicenseManagerPointer class</class-id> <category>private-installation</category><body package="Com- Automation">initialize	" ILicenseManagerPointer initialize "	self iid: IID_ILicenseManager.	self updateAndRegister</body></methods><methods><class-id>External.COMAutomationServer</class-id> <category>accessing</category><body package="Com- Automation">clsid	"Answer the CLSID supported by the receiver."		^clsid</body><body package="Com- Automation">clsid: aGUID	"Set the CLSID supported by the receiver to &lt;aGUID&gt;."		clsid := aGUID</body><body package="Com- Automation">dispatchInterfaceIID	"Answer the IID of the dispatch interface which is supported by the receiver."	^dispatchInterfaceIID</body><body package="Com- Automation">dispatchInterfaceIID: anIID	"Set the IID of the dispatch interface which is supported by the receiver to &lt;anIID&gt;."	dispatchInterfaceIID := anIID.	self dispatchInterface notNil		ifTrue: [ self dispatchInterface iid: anIID ].</body><body package="Com- Automation">specificationTable	"Answer the receiver's specification table for dispatching method and property member invocations."	^specificationTable</body><body package="Com- Automation">specificationTable: aSpecificationTable	"Set the receiver's specification table for dispatching method and property member invocations. Save the IID from the table in the receiver."	specificationTable := aSpecificationTable.	self dispatchInterfaceIID: aSpecificationTable iid.</body><body package="Com- Automation">typeLibraries	"Answer the type library dictionary. The dictionary keys are LCIDs and the values are instances of COMTypeLibrary."	^typeLibraries</body><body package="Com- Automation">typeLibraries: aDictionary	"Set the type library dictionary. The keys are LCIDs."	typeLibraries := aDictionary</body></methods><methods><class-id>External.COMAutomationServer</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	self publishedObject notNil		ifTrue: [ aStream nextPutAll: ' for ', self publishedObject printString; cr ].</body></methods><methods><class-id>External.COMAutomationServer</class-id> <category>subclass-initializing</category><body package="Com- Automation">initialize	"Private. Initialize a new instance."	self dispatchInterfaceIID: IID_IDispatch.	super initialize.</body></methods><methods><class-id>External.COMAutomationServer class</class-id> <category>class factory services</category><body package="Com- Automation">classFactoryClass		" Answer the class factory object class which creates		instances of the receiver. "	^COMAutomationServerClassFactoryObject</body><body package="Com- Automation">newClassFactory	" Answer a new class factory which creates instances of the receiver. "	" an automation server class factory needs to know what class		is being published and what specifications to use. 		This information must be provided by the client when		configuring an automation server. "	self shouldNotImplement.</body><body package="Com- Automation">newClassFactoryForClass: aClass clsid: aCLSID specificationTable: aDispatchSpecificationTable typeLibraries: aDictionary 	"Answer a new class factory which creates instances of the receiver which publish a new instance of 	&lt;aClass&gt; as a COM automation object with CLSID &lt;aCLSID&gt;. The dispatch specifications for the 	properties and methods which are published for &lt;aClass&gt; are defined in 	&lt;aDispatchSpecificationTable&gt;, which must be indexed by the DISPID of the interface members.	It is possible that you must implement a dual interface BUT that you know that all client	access will be done via the VTable. In this case, the spec table becomes unecessary 	overhead."	(aDispatchSpecificationTable notNil and: [aDispatchSpecificationTable specificationKey = #memberID])		ifFalse: [self error: 'Automation server dispatch specifications must be indexed by DISPID'].	^self classFactoryClass		forClass: self		automationObjectClass: aClass		clsid: aCLSID		specificationTable: aDispatchSpecificationTable		typeLibraries: aDictionary</body><body package="Com- Automation">registerClassFactory	" Register a class factory to create instances of the receiver.  Answer the class factory.  Answer nil if class factory registration failed. "	" an automation server class factory needs to know what class		is being published and what specifications to use. 		This information must be provided by the client when		configuring an automation server. "	self shouldNotImplement.</body><body package="Com- Automation">registerClassFactoryForClass: aClass	" Register a class factory to create instances of &lt;aClass&gt;.  Answer the class factory.  Answer nil if class factory registration failed. "	^self registerClassFactoryForClass: aClass 		clsid: aClass clsid 		specificationTable: aClass specificationTable		typeLibraries: aClass typeLibraries</body><body package="Com- Automation">registerClassFactoryForClass: aClass clsid: aCLSID specificationTable: aDispatchSpecificationTable typeLibraries: aDictionary 	" Register a class factory to create instances of &lt;aClass&gt;.  Answer the class factory.  Answer nil if class factory registration failed. "	" while ordinarily we prefer not to clutter object implementatations with tracing support,		which in general is better handling through the non-intrusive interface tracing		facilities, class factory registration is such a fundamental operation that		in this case we add tracing to facilitate debugging application problems. "	| aClassFactory |	self logIfTraceEnabled: 			[#NamedRegClassFactory &lt;&lt; #com 				&gt;&gt; 'Registering class factory for &lt;1s&gt; ( CLSID &lt;2p&gt; ) ...' 					expandMacrosWith: aClass name					with: aCLSID].	aClassFactory := COMSessionManager classFactoryForCLSID: aCLSID.	aClassFactory notNil 		ifTrue: 			[| message |			message := (#ErrNamedRegUnnecessary &lt;&lt; #com 						&gt;&gt; 'Registration is unnecessary: a class factory is already registered for class &lt;1s&gt; ( CLSID &lt;2s&gt; ).' 							expandMacrosWith: aClass name							with: aCLSID asString) asString.			self logIfTraceEnabled: message.			COMDevelopmentWarning raiseSignal: message.			^aClassFactory].	aClassFactory := self 				newClassFactoryForClass: aClass				clsid: aCLSID				specificationTable: aDispatchSpecificationTable				typeLibraries: aDictionary.	[aClassFactory registerAsMultipleUseLocalServer] on: COMError		do: 			[:ex | 			self isTraceEnabled 				ifTrue: 					[self						logTraceEntry: #ClassFactoryRegFailed &lt;&lt; #com 									&gt;&gt; '***ERROR: class factory registration failed:';						logTraceEntry: '    ' , ex description;						logCr].			^nil].	self logIfTraceEnabled: 			[#DoneRegisteringFactory &lt;&lt; #com &gt;&gt; '...done registering class factory'].	^aClassFactory</body><body package="Com- Automation">registerServerClassFactory	" Register a class factory for an object server to create instances of the receiver.  Terminate the object server application if registration fails.  Answer the class factory if registration succeeds. "	" an automation server class factory needs to know what class		is being published and what specifications to use. 		This information must be provided by the client when		configuring an automation server. "	self shouldNotImplement.</body><body package="Com- Automation">registerServerClassFactoryForClass: aClass	" Register a class factory for an object server to create instances of &lt;aClass&gt;.  Terminate the object server application if registration fails.  Answer the class factory if registration succeeds. "	| aClassFactory |	aClassFactory := self registerClassFactoryForClass: aClass 		clsid: aClass clsid 		specificationTable: aClass specificationTable		typeLibraries: aClass typeLibraries.	aClassFactory isNil		ifTrue: [			COMSessionManager terminateServer:				((#FactoryRegistrationFailed &lt;&lt; #com &gt;&gt; 'Class factory registration for &lt;1s&gt; failed')			expandMacrosWith: aClass name) ].	^aClassFactory</body></methods><methods><class-id>External.COMAutomationServer class</class-id> <category>instance creation</category><body package="Com- Automation">on: anObject clsid: aGUID specificationTable: aSpecificationTable typeLibraries: aDictionary		" Answer a new instance of the receiver which publishes &lt;anObject&gt;		as a COM automation object which supports a dispatch interface		with the methods and properties described by &lt;aSpecificationTable&gt;. "	^self new		publishedObject: anObject;		specificationTable: aSpecificationTable;		typeLibraries: aDictionary;		clsid: aGUID;		yourself</body></methods><methods><class-id>COMWordSafeArrayAccessor</class-id> <category>private accessing</category><body package="Com- Automation">collectionClass	^ WordArray</body></methods><methods><class-id>COMWordSafeArrayAccessor class</class-id> <category>private</category><body package="Com- Automation">supports: aSafeArray	"I support linear safearray of type VT_UI2."	^ (aSafeArray typeCode = VT_UI2)		and: [ aSafeArray dimensions = 1 ]</body></methods><methods><class-id>External.COMTypeCompilerBoundResource</class-id> <category>private-accessing</category><body package="Com- Automation">name: aName	name := aName</body><body package="Com- Automation">typeInfo: anITypeInfo    typeInfo := anITypeInfo</body></methods><methods><class-id>External.COMTypeCompilerBoundResource</class-id> <category>accessing</category><body package="Com- Automation">name		^name</body><body package="Com- Automation">typeInfo    ^typeInfo</body></methods><methods><class-id>External.DispStructureSpec</class-id> <category>accessing</category><body package="Com- Automation">elementClass		^ ComponentElementDescription</body><body package="Com- Automation">kindname	^  (#TKindRecord &lt;&lt; #com &gt;&gt; 'Record') asString</body><body package="Com- Automation">recordInfo	| typeInfo |	typeInfo := self asTypeInfo.	^ OLEAutomationDLL current getRecordInfoFromTypeInfo: typeInfo</body><body package="Com- Automation">sizeInBytes	^sizeInBytes</body><body package="Com- Automation">sizeInBytes: anObject	sizeInBytes := anObject</body><body package="Com- Automation">typecode	^ VT_RECORD</body></methods><methods><class-id>External.DispStructureSpec</class-id> <category>private</category><body package="Com- Automation">cElementValue: anElement	"retrieve the c value for an element"	^  anElement index -&gt; anElement type cType</body><body package="Com- Automation">newCType	^ CCompositeType new			dataSize: self sizeInBytes;			beStructure;			yourself</body><body package="Com- Automation">newElementCollection	^ SortedCollection sortBlock: [:a :b | a index &lt; b index]</body></methods><methods><class-id>External.DispStructureSpec</class-id> <category>testing</category><body package="Com- Automation">isStructure	^ true</body></methods><methods><class-id>External.DispStructureSpec</class-id> <category>instance creation</category><body package="Com- Automation">new	"Create a new instance of the given type"	^ COMRecord newWith: self recordInfo.</body></methods><methods><class-id>External.DispStructureSpec</class-id> <category>marshaling</category><body package="Com- Automation">createPtrOutArgument	^self new</body><body package="Com- Automation">freePtrArgument: anArgument	^ self</body><body package="Com- Automation">marshalInArgument: anArgument	"VB6 does not support BYVAL UDT parameters. "	^ self error: (#ByValUDTParametersUnsupported &lt;&lt; #com &gt;&gt; 'BYVAL UDT Parameters are currently unsupported').		"| cType datum |	cType := self cType.	datum := cType new.	anArgument marshalStructureType: self cType: cType intoStruct: datum.	^ datum"</body><body package="Com- Automation">marshalPointerArgument: anArgument	^	[| value |	value := anArgument isValueReference				ifTrue: [anArgument value]				ifFalse: [anArgument].	[self recordInfo ] withResultDoAndRelease: [:recInfo | value asCOMRecordSpecifiedBy: recInfo ] ]			on: Error			do: [super marshalPointerArgument: anArgument]</body><body package="Com- Automation">newSafeArray: dims bounds: bounds	| aSafeArrayStruct recInfo |	recInfo := self recordInfo.	^ [ aSafeArrayStruct := OLEAutomationDLL current SafeArrayCreateEx: self		_: dims		_: bounds		_: recInfo.	aSafeArrayStruct typeDescription: self ]	ensure: [ recInfo enforceInvalidation "recordinfo is managed by safeArray" ].</body><body package="Com- Automation">newSafeArrayDescriptor: dims bounds: bounds	| aSafeArrayDescriptor recInfo |	aSafeArrayDescriptor := super newSafeArrayDescriptor: dims bounds: bounds.	recInfo := self recordInfo.	[aSafeArrayDescriptor recordInfo: recInfo]		ensure: [recInfo enforceInvalidation. "Managed by safeArray"].	^aSafeArrayDescriptor</body><body package="Com- Automation">noSuitableClassFound		^ Dictionary</body><body package="Com- Automation">unmarshalOutParam: aParam	"BYREF out paramters are handled in #unmarshalPtrOutParam:	 BYVAL out parameters are not possible"	^ self shouldNotImplement</body><body package="Com- Automation">unmarshalPtrOutParameter: aMarshaledValue into: aSmalltalkValue 	aSmalltalkValue value: aMarshaledValue</body></methods><methods><class-id>External.DispStructureSpec class</class-id> <category>private constants</category><body package="Com- Automation">typekinds	^ Array with: TKIND_RECORD</body></methods><methods><class-id>External.DispStructureSpec class</class-id> <category>private</category><body package="Com- Automation">typeCodes	"specific subclasses may return values for expressing that they are responsible for the typeCode"	^ Array with: VT_RECORD</body></methods><methods><class-id>External.DispStructureSpec class</class-id> <category>private instance creation</category><body package="Com- Automation">basicFromTypeInfo: refTypeInfo typeLib: aTypeLibDescriptor 	^ (super basicFromTypeInfo: refTypeInfo typeLib: aTypeLibDescriptor)					sizeInBytes: (refTypeInfo withTypeAttrDo: [:typeAttr | typeAttr instanceSizeInBytes ]);			yourself</body><body package="Com- Automation">basicFromVariant: aVariant typeCode: aTypeCode	| typeInfo |	^aVariant withRecordInfoDo: 			[:recordInfo |			typeInfo := recordInfo getTypeInfo.			self basicFromTypeInfo: typeInfo]</body></methods><methods><class-id>SafeArray</class-id> <category>private accessing</category><body package="Com- Automation">at: anIndexArray putCollection: aCollection 	^aCollection isMultidimensional 		ifTrue: [self at: anIndexArray putMultiCollection: aCollection]		ifFalse: [self at: anIndexArray putSequenceableCollection: aCollection]</body><body package="Com- Automation">at: anIndexArray putElement: anObject 	^data at: (self marshaledIndexFor: anIndexArray) put: anObject</body><body package="Com- Automation">at: anIndexArray putMultiCollection: aCollection 	| upperBounds |	upperBounds := anIndexArray , aCollection bounds.	self checkBounds: upperBounds.	self 		enumFrom: anIndexArray		to: upperBounds		do: 			[:key | 			self at: key				put: (aCollection at: (key copyFrom: anIndexArray size + 1 to: key size))]</body><body package="Com- Automation">at: anIndexArray putSequenceableCollection: aCollection 	self 		checkSize: aCollection size		forDimension: anIndexArray size + 1		indices: anIndexArray.	self 		recursiveFrom: anIndexArray		forBranchDo: 			[:currentIndices | 			self at: currentIndices				putCollection: (aCollection at: currentIndices last)]		forLeafDo: 			[:currentIndices | 			"allow collections that do not have all elements set "			aCollection size &gt;= currentIndices last 				ifTrue: 					[self at: currentIndices putElement: (aCollection at: currentIndices last)]]</body><body package="Com- Automation">copyArrayFrom: startIndices to: endIndices 	^ data copyFrom: (self marshaledIndexFor: (self startIndicesForSubArrayAt: startIndices)) to: (self marshaledIndexFor: endIndices)</body><body package="Com- Automation">copySubCollectionFrom: startIndices to: endIndices 	| start end newArray newBounds |	start := startIndices size + 1.	end := endIndices size.	newBounds := self subCollectionBoundsFor: startIndices.	newArray := SafeArray new: newBounds.	self 		enumFrom: startIndices		to: endIndices		do: 			[:currentIndices | 			newArray at: (currentIndices copyFrom: start to: end)				put: (self elementAt: currentIndices)].	^newArray</body><body package="Com- Automation">elementAt: anIndexArray 	^data at: (self marshaledIndexFor: anIndexArray)</body><body package="Com- Automation">subCollectionAt: anIndexArray 	| endIndices |	anIndexArray isEmpty ifTrue: [^self].	endIndices := self endIndicesForSubCollectionAt: anIndexArray.	^ ((self bounds size - (anIndexArray size)) = 1) 		ifTrue: 	[ self copyArrayFrom: anIndexArray to: endIndices]		ifFalse: [self copySubCollectionFrom: anIndexArray to: endIndices]</body></methods><methods><class-id>SafeArray</class-id> <category>private</category><body package="Com- Automation">printLayer: currentIndices on: aStream 	aStream nextPut: ${.	self 		recursiveFrom: currentIndices		forBranchDo: [:subIndices | self printLayer: subIndices on: aStream]		forLeafDo: 			[:indices | 			indices last &gt; 1 ifTrue: [aStream nextPut: Character space].			(self elementAt: indices) printOn: aStream].	aStream nextPut: $}</body><body package="Com- Automation">species	"Return OrderedCollection since it is used for selecting"	^ OrderedCollection</body></methods><methods><class-id>SafeArray</class-id> <category>accessing</category><body package="Com- Automation">at: indices 	" SafeArrays should accept array syntax like 'anArray at: 1' which will return another MultiArray"	| tempIndices |	tempIndices := self checkBounds: indices.	^tempIndices size &lt; bounds size 		ifTrue: [self subCollectionAt: tempIndices]		ifFalse: [self elementAt: tempIndices]</body><body package="Com- Automation">at: key ifAbsent: aBlock 	"SafeArray should not implement at:ifAbsent: as there might be &lt;nil&gt; elements."	^self shouldNotImplement</body><body package="Com- Automation">at: indices put: anObject 	"put anObject at: indices, where indices may be a collection of index numbers or		 just a number"	| tempIndices |	tempIndices := self checkBounds: indices.	^tempIndices size &lt; bounds size 		ifTrue: [self at: tempIndices putCollection: anObject]		ifFalse: [self at: tempIndices putElement: anObject]</body><body package="Com- Automation">bounds	"return the SafeArray bounds array"	^bounds</body><body package="Com- Automation">dimensions	"return the number of dimensions of the SafeArray"	^bounds size</body><body package="Com- Automation">size	"Answer the size of the receiver, that is the number of data elements"	^data size</body><body package="Com- Automation">valuesFromCollection: aCollection 	"set the receiver's values to the values contained in the collection"	self at: #() put: aCollection.	^self</body></methods><methods><class-id>SafeArray</class-id> <category>removing</category><body package="Com- Automation">remove: oldObject ifAbsent: anExceptionBlock 	"can't remove elements from a fixed size Object"	self shouldNotImplement</body><body package="Com- Automation">removeKey: key ifAbsent: aBlock	"It is not possible to remove an key from a SafeArray"	^self shouldNotImplement</body></methods><methods><class-id>SafeArray</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream 	aStream nextPutAll: 'SafeArray'.	self printLayer: #() on: aStream</body></methods><methods><class-id>SafeArray</class-id> <category>private enumerating</category><body package="Com- Automation">enumFrom: startIndices to: endIndices do: aBlock	"this version enumerates through the array, starting with an array which does not contain all dimensions"	| tempIndices depth |	depth := startIndices size + 1.	tempIndices := self startIndicesForSubArrayAt: startIndices.	^ self enumFrom: tempIndices to: endIndices startingAt: depth do: aBlock.</body><body package="Com- Automation">enumFrom: startIndices to: endIndices startingAt: depth do: aBlock 	| tempIndices evalBlock |	tempIndices := startIndices copy.	evalBlock := depth &lt; endIndices size 				ifTrue: 					[					[self 						enumFrom: tempIndices						to: endIndices						startingAt: depth + 1						do: aBlock]]				ifFalse: [[aBlock value: tempIndices copy]].	(startIndices at: depth) to: (endIndices at: depth)		do: 			[:runIndex | 			tempIndices at: depth put: runIndex.			evalBlock value]</body><body package="Com- Automation">recursiveFrom: anIndexArray forBranchDo: aBranchBlock forLeafDo: aLeafBlock 	"recurse the the collection by calling aBranchblock for dimensions lower than the last one	 and executing the leaf block for elements in the last dimension."	"aBranchBlock and aLeafBlock are blocks that expect  one argument: the current indices collection "	| depth evalBlock tempIndices |	tempIndices := anIndexArray copyWith: 0.	depth := tempIndices size.	evalBlock := depth &lt; self dimensions 				ifTrue: [aBranchBlock]				ifFalse: [aLeafBlock].	1 to: (bounds at: depth)		do: 			[:runIndex | 			tempIndices at: depth put: runIndex.			evalBlock value: tempIndices]</body></methods><methods><class-id>SafeArray</class-id> <category>initialize-release</category><body package="Com- Automation">bounds: anObject	bounds := anObject.	data := Array new: (self sizeForBounds: bounds).</body></methods><methods><class-id>SafeArray</class-id> <category>comparing</category><body package="Com- Automation">= anObject 	"Answer whether the receiver and the argument represent the same object.	Also can compare SafeArrays with nested sequenceable collections"	(self class isNormalCollection: anObject) 		ifTrue: [^self equalsCollection: anObject].	^self class = anObject class 		and: [bounds = anObject bounds and: [anObject dataEquals: data]]</body></methods><methods><class-id>SafeArray</class-id> <category>converting</category><body package="Com- Automation">asArray	"Answer the values in the given order"	^data</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  	  Since Smalltalk Collections can contain anything use VT_VARIANT if the elements in the receiver 	  match to more than one COM variant type. "	| elementClasses first |	first := nil.	elementClasses := Set new.	self do: 			[:e | 			first isNil ifTrue: [first := e].			elementClasses add: e comVariantType].	"More than one kind of object: map to a SAFEARRAY of VARIANTs"	elementClasses size &gt; 1 ifTrue: [^8204	"VT_ARRAY | VT_VARIANT"].	"Empty array: map to a SAFEARRAY of VARIANTs since CreateSafeArray must take a legal type."	first isNil ifTrue: [^8204	"VT_ARRAY | VT_VARIANT"].	"If the collections contains arrays, return variant as element type"	(first comVariantType bitAnd: 8192) = 8192 		ifTrue: [^8204	"VT_ARRAY | VT_VARIANT"].	"VT_ARRAY"	"VT_ARRAY"	"Other cases: get the type of the element for the SAFEARRAY."	^first comVariantType | 8192	"VT_ARRAY"</body></methods><methods><class-id>SafeArray</class-id> <category>private tools</category><body package="Com- Automation">checkBounds: indices 	"test wether the given indices are inside my bounds.	  returns the possibly modified indicies in the common	  array format"	| tempIndices |	tempIndices := indices isSequenceable 				ifTrue: [indices]				ifFalse: [Array with: indices].	tempIndices size &gt; bounds size 		ifTrue: [self subscriptBoundsError: tempIndices].	tempIndices keysAndValuesDo: 			[:index :element | 			(element isInteger not 				or: [((1 to: (bounds at: index)) includes: element) not]) 					ifTrue: [self subscriptBoundsError: tempIndices]].	^tempIndices</body><body package="Com- Automation">checkSize: aSize forDimension: aDimension indices: indices 	aSize &gt; (self bounds at: aDimension) 		ifTrue: [self subscriptBoundsError: indices]</body><body package="Com- Automation">dataEquals: otherData 	"compare my data with the data of an other SafeArray"	^data = otherData</body><body package="Com- Automation">endIndicesForSubCollectionAt: indices 	| newBounds |	newBounds := Array new: bounds size.	indices keysAndValuesDo: [:index :value | newBounds at: index put: value].	indices size + 1 to: bounds size		do: [:index | newBounds at: index put: (bounds at: index)].	^newBounds</body><body package="Com- Automation">marshaledIndexFor: indices 	"calculate the physical index for an element"	| sum |	sum := 0.	indices keysAndValuesDo: 			[:index :el | 			sum := sum * (bounds at: index).			sum := sum + (el - 1)].	^sum + 1</body><body package="Com- Automation">sizeForBounds: aBoundsArray 	"calculate the physical dateSize for an Array with the given bounds"	^aBoundsArray inject: 1 into: [:product :current | product * current]</body><body package="Com- Automation">startIndicesForSubArrayAt: indices 	| newBounds |	newBounds := Array new: bounds size.	indices keysAndValuesDo: [:index :value | newBounds at: index put: value].	indices size + 1 to: bounds size do: [:index | newBounds at: index put: 1].	^newBounds</body><body package="Com- Automation">subCollectionBoundsFor: indices 	"return the bounds for the subcollection at &lt;indices&gt;.	 Indices should be a sequenceable collection which does not specify	 all my dimensions."	"| newBounds newSize oldStartIndex |	newSize := bounds size - indices size.	newBounds := Array new: (newSize).	oldStartIndex := indices size.	1 to: newSize do: [:index |		newBounds at: index put: (bounds at:(oldStartIndex + index)) ].	^ newBounds."	^bounds copyFrom: indices size + 1 to: bounds size</body></methods><methods><class-id>SafeArray</class-id> <category>testing</category><body package="Com- Automation">equalsCollection: aCollection 	"test whether the receiver is ''equal'' to a nested sequenceable collection"	bounds first = aCollection size ifFalse: [^false].	1 to: bounds first		do: [:index | (self at: index) = (aCollection at: index) ifFalse: [^false]].	^true</body><body package="Com- Automation">isMatrixLike	"return whether the collection is like a matrix, that means the number of elements is 	 equal within each dimension"	^ true</body><body package="Com- Automation">isMultidimensional	"answer whether the collection is multidimensional,	 which is true for SafeArrays"	^ true</body></methods><methods><class-id>SafeArray</class-id> <category>adding</category><body package="Com- Automation">add: newObject 	"adding elements is not supported by SafeArrays"	self shouldNotImplement</body></methods><methods><class-id>SafeArray</class-id> <category>enumerating</category><body package="Com- Automation">do: aBlock 	"Evaluate aBlock for each of the receiver's values."	^ data do: aBlock</body><body package="Com- Automation">keysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."	^self keysDo: [:key | aBlock value: key value: (self elementAt: key)]</body><body package="Com- Automation">keysDo: aBlock 	"Evaluate aBlock for each of the receiver's keys."	^ self enumFrom: #() to: self bounds do: [:key |		aBlock value: key]</body></methods><methods><class-id>SafeArray class</class-id> <category>private testing</category><body package="Com- Automation">isCollection: aCollection	^ COMSafeArray isCollection: aCollection</body><body package="Com- Automation">isNormalCollection: aCollection	^  aCollection isSequenceable and: [ aCollection isString not and: [aCollection isSymbol not] ]</body><body package="Com- Automation">validatePolicy: aSymbol	^ (aSymbol == #strict) or: [aSymbol == #tolerant]</body></methods><methods><class-id>SafeArray class</class-id> <category>instance creation</category><body package="Com- Automation">fromSequenceableCollection: aCollection 	"create a new SafeArray from the given SequenceableCollection. "	"self fromSequenceableCollection: #(#(1 2 3) #(4 5 6))"	"self fromSequenceableCollection: #(#(1 2 3) #(4 5))"	"self fromSequenceableCollection: #(#(#('AAA' 'AAB') #('ABA') #('ACA')) #(#('BAA') #('BBA') #('BCA') #('BDA')) )"	"self fromSequenceableCollection: #(1 #(4 5))"	^ self fromSequenceableCollection: aCollection policy: self defaultPolicy</body><body package="Com- Automation">new: bounds	"Create a new SafeArray with the given bounds"	"self new: #(2 3)"	^ (self basicNew)			bounds: bounds;			yourself</body><body package="Com- Automation">strictFromSequenceableCollection: aCollection 	"create a new SafeArray from the given SequenceableCollection using the strict 	  boundary calculation policy "	^ self fromSequenceableCollection: aCollection policy: #strict</body><body package="Com- Automation">tolerantFromSequenceableCollection: aCollection 	"create a new SafeArray from the given SequenceableCollection using the tolerant boundary	 calculation policy. "	^ self fromSequenceableCollection: aCollection policy: #tolerant</body></methods><methods><class-id>SafeArray class</class-id> <category>private constants</category><body package="Com- Automation">defaultPolicy	^ #strict</body></methods><methods><class-id>SafeArray class</class-id> <category>private instance creation</category><body package="Com- Automation">correctBounds: bounds and: otherBounds policy: aSymbol 	| newCollection lastIndex |	newCollection := OrderedCollection new.	lastIndex := bounds size min: otherBounds size.	1 to: lastIndex do: [:index |		(bounds at: index) ~= (otherBounds at: index)			ifTrue: [ aSymbol == #strict				ifTrue: 	[ ^ newCollection asArray ]				ifFalse: 	[ newCollection addLast: ((bounds at: index) max: (otherBounds at: index))]]			ifFalse: [ newCollection addLast: (bounds at: index)]		].	^ newCollection asArray</body><body package="Com- Automation">fromSequenceableCollection: aCollection policy: aSymbol 	"create a new SafeArray from the given Collection using the provided policy.	 Valid policy symbols are #tolerant and #strict"	"self fromSequenceableCollection: #(#(1 2 3) #(4 5)) policy: #tolerant"	"self fromSequenceableCollection: #(#(1 2 3) #(4 5)) policy: #strict"	| dimensions |	(self validatePolicy: aSymbol)		ifFalse: [ self error: (#InvalidCreationPolicy &lt;&lt; #com &gt;&gt; 'The specified policy for creating the SafeArray is invalid.')].	dimensions := self getBoundsFromCollection: aCollection policy: aSymbol.	dimensions isEmpty ifTrue: [^nil].	^(self new: dimensions)		valuesFromCollection: aCollection;		yourself</body><body package="Com- Automation">getBoundsFromCollection: aCollection policy: aSymbol 	| subBounds index otherBounds |	((self isCollection: aCollection) not or: [aCollection isEmpty]) ifTrue: [^#()].	subBounds := self getBoundsFromCollection: aCollection first				policy: aSymbol.	index := 2.	[subBounds notEmpty and: [index &lt;= aCollection size]] whileTrue: [			otherBounds := self getBoundsFromCollection: (aCollection at: index) policy: aSymbol.			subBounds := self 						correctBounds: subBounds						and: otherBounds						policy: aSymbol.			index := index + 1].	^(Array with: aCollection size) , subBounds</body></methods><methods><class-id>External.COMClient</class-id> <category>accessing</category><body package="Com- Automation">clsid	^self iPersist ifNotNil: [:itf | itf getClassID]</body><body package="Com- Automation">specificationPolicy	" Answer the receiver's specification policy. "    ^ self class specificationPolicy</body><body package="Com- Automation">typeLibrary	^ self type typelib</body></methods><methods><class-id>External.COMClient</class-id> <category>testing</category><body package="Com- Automation">isValid	^ self anyInterface isValid</body><body package="Com- Automation">supportedCallTypes	| coll |	coll := OrderedCollection new.	self supportsVTable ifTrue: [ coll add: #VTable ].	self supportsDispatching ifTrue: [ coll add: #Dispatch ].	^ coll asArray</body><body package="Com- Automation">supportsDispatching	^self testFlag: #supportsDispatching</body><body package="Com- Automation">supportsDispatching: aBoolean	self setFlag: #supportsDispatching to: aBoolean.</body><body package="Com- Automation">supportsVTable	^self testFlag: #supportsVTable</body><body package="Com- Automation">supportsVTable: aBoolean	^self setFlag: #supportsVTable to: aBoolean.</body></methods><methods><class-id>External.COMClient</class-id> <category>private errors</category><body package="Com- Automation">errorInterfaceInaccessible	^self error: #CanNonAccessRequiredInterface &lt;&lt; #com				&gt;&gt; 'Can not access required interface'</body></methods><methods><class-id>External.COMClient</class-id> <category>private accessing interfaces</category><body package="Com- Automation">addInterface: anInterface	^ self interfaceAt: anInterface iid put: anInterface.</body><body package="Com- Automation">anyInterface	^self interfaces detect: [:each | each notNil and: [each isValid]]		ifNone: [nil]</body><body package="Com- Automation">dispatchInterface	^ self interfaceForIID: IID_IDispatch</body><body package="Com- Automation">iPersist	^ self interfaceForIID: IID_IPersist</body><body package="Com- Automation">iUnknown	^ self interfaceForIID: IID_IUnknown</body><body package="Com- Automation">iUnknown: anInterface	self interfaces at: IID_IUnknown put: anInterface.</body><body package="Com- Automation">interfaceAt: anIID put: anInterface	^ self interfaces at: anIID put: anInterface.</body><body package="Com- Automation">interfaceForIID: anIID	| iid |	iid := GUID iidFor: anIID clsidBlock: [self clsid].	^self interfaceForIID: iid		ifAbsentPut: 			[self performInCorrespondingApartment: 					[(self queryInterfaceIID: iid)						ifNotNil: 							[:itf |							self flushSpecificationTable.							itf]]]</body><body package="Com- Automation">interfaceForIID: anIID ifAbsentPut: aBlock	^ self interfaces at: anIID ifAbsentPut: aBlock.</body><body package="Com- Automation">interfaces	^interfaces</body><body package="Com- Automation">interfaces: aDictionary	interfaces := aDictionary.</body><body package="Com- Automation">interfacesDo: aBlock	^self interfaces		do: [:each | (each notNil and: [each isValid]) ifTrue: [aBlock value: each]]</body></methods><methods><class-id>External.COMClient</class-id> <category>private accessing</category><body package="Com- Automation">basicSpecificationType: aType named: aKey ifAbsent: aBlock	^(self specificationTable ifNil: [^aBlock value])		basicAt: aKey		types: aType		ifAbsent: aBlock</body><body package="Com- Automation">computePartialSpecificationTable	| table |	table := AutomationClassSpecificationTable newNamedTable.	self dispatchInterface.	self interfacesDo: 			[:each |each specificationTable						do: [:member | table add: (AutomationClassMember interface: each specificationTable interface member: member)]].	^ table</body><body package="Com- Automation">computeSpecificationTable	^specificationTable := self type				ifNil: [self computePartialSpecificationTable]				ifNotNil: 					[AutomationClassSpecificationTable						forCoclass: self type						supports: (self supportedCallTypes)						specificationKey: #name						includeEvents: true]</body><body package="Com- Automation">getTypeInfo	^(COMDispatchSpecificationTable getClassTypeInfoOf: self anyInterface)		ifNil: 			[self clsid ifNotNil: [:clsid | COMTypeLibrary typeInfoForCLSID: clsid]]</body></methods><methods><class-id>External.COMClient</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Answer nil if the receiver cannot be represented as by a known variant type. "	^ External.COMAutomationConstants.VT_UNKNOWN</body></methods><methods><class-id>External.COMClient</class-id> <category>comparing</category><body package="Com- Automation">= anObject	^ (anObject iUnknown) = (self iUnknown)</body></methods><methods><class-id>External.COMClient</class-id> <category>private</category><body package="Com- Automation">flags	^flags ifNil: [ flags := IdentitySet new ].</body><body package="Com- Automation">flushSpecificationTable		specificationTable := nil.</body><body package="Com- Automation">immediateReleaseInterfaces	self interfaces do: [:each | (each notNil and: [ each isValid]) ifTrue: [ each enforceRelease ]].</body><body package="Com- Automation">setFlag: aSymbol	^ self flags add: aSymbol</body><body package="Com- Automation">setFlag: aSymbol to: aBoolean	aBoolean ifTrue: [self flags add: aSymbol] ifFalse: [self flags remove: aSymbol ifAbsent: []]</body><body package="Com- Automation">signalMemberNotFound	^ COMError hresult: E_NOTIMPL</body><body package="Com- Automation">testFlag: aSymbol	^ self flags includes: aSymbol</body><body package="Com- Automation">wrapResult: aResult	^aResult isCOMInterface		ifTrue: [COMClient onNew: aResult]		ifFalse: [aResult]</body><body package="Com- Automation">wrapResult: aResult args: anArray namedArgs: namedArgs for: aSpec	| params |	params := aSpec parameters copyFrom: 1 to: anArray size.	anArray with: params		do: 			[:value :paramDesc |			(paramDesc isOutParameter				and: [value isValueReference and: [value value isCOMInterface]])					ifTrue: [value value: (COMClient onNew: value value)]].	namedArgs keysAndValuesDo: [:key :value | |paramDesc |			paramDesc := aSpec parameterNamed: key.			(paramDesc isOutParameter				and: [value isValueReference and: [value value isCOMInterface]])					ifTrue: [value value: (COMClient onNew: value value)]].	^self wrapResult: aResult</body></methods><methods><class-id>External.COMClient</class-id> <category>error handling</category><body package="Com- Automation">doesNotUnderstand: aMessage	| call |	call := COMCall forMessage: aMessage driver: self.	call memberExists ifFalse: [ ^ super doesNotUnderstand: aMessage ].	^ call invoke.</body></methods><methods><class-id>External.COMClient</class-id> <category>initialize-release</category><body package="Com- Automation">enforceRelease	self immediateReleaseInterfaces.	self interfaces: Dictionary new.	super enforceRelease.</body><body package="Com- Automation">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	self interfaces: Dictionary new.	self supportsVTable: true.	self supportsDispatching: true.</body></methods><methods><class-id>External.COMClient</class-id> <category>private dispatching</category><body package="Com- Automation">actualReceiverFor: aCOMCall	^(super actualReceiverFor: aCOMCall)		ifNil: [self interfaceForCall: aCOMCall]</body><body package="Com- Automation">interfaceForCall: aCOMCall	| iid |	iid := aCOMCall specification interface iid.	^ (self interfaceForIID: iid) ifNil: [^ self errorInterfaceInaccessible].</body></methods><methods><class-id>External.COMClient</class-id> <category>finalization</category><body package="Com- Automation">finalize	"Finalize the object and perform required cleanup operations"	self interfaces: Dictionary new.	^super enforceRelease</body></methods><methods><class-id>External.COMClient</class-id> <category>lookup</category><body package="Com- Automation">basicSpecificationFor: aSpecificationQuery ifAbsent: aBlock	^(self specificationTable ifNil: [^aBlock value])		basicAt: aSpecificationQuery member		types: aSpecificationQuery kinds		ifAbsent: aBlock</body></methods><methods><class-id>External.COMClient class</class-id> <category>private accessing</category><body package="Com- Automation">specificationPolicy	" Answer the receiver's specification policy. "    ^ SpecificationPolicy</body></methods><methods><class-id>External.COMClient class</class-id> <category>instance creation (licensing support)</category><body package="Com- Automation">createObject: aClassIdOrProgId iid: anIID licenseKey: aLicenseKey	"Answer a newly created and initialized instance."	| options |	options := (COMCreationOptions newForVTable)				clsid: aClassIdOrProgId;				iid: anIID;				licenseKey: aLicenseKey;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aClassIdOrProgId licenseKey: aLicenseKey	"Answer a newly created and initialized instance."	| options |	options := (COMCreationOptions newForVTable)				clsid: aClassIdOrProgId;				iid: IID_IUnknown;				licenseKey: aLicenseKey;				yourself.	^self createInstanceWithOptions: options</body></methods><methods><class-id>External.COMClient class</class-id> <category>instance creation</category><body package="Com- Automation">createInstanceWithOptions: options	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	Note: This is equivalent to the VBA CreateObject() function."	| result aGuid type |	aGuid := options clsid asGUID.	type := COMTypeLibrary typeForGUID: aGuid.	result := self				onNewAndInitialize: (IClassFactory createInstanceWithOptions: options).	result type: type.	^result</body><body package="Com- Automation">createObject: aClassIdOrProgId	"Answer a newly created and initialized instance."	| options |	options := (COMCreationOptions newForVTable)				clsid: aClassIdOrProgId;				iid: IID_IUnknown;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aClassIdOrProgId iid: anIID	"Answer a newly created and initialized instance."	| options |	options := (COMCreationOptions newForVTable)				clsid: aClassIdOrProgId;				iid: anIID;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">onNew: anInterface	| instance |	instance := (self new)				needsFinalization;				yourself.	anInterface isCOMInterface		ifTrue: [instance addInterface: anInterface]		ifFalse: 			["assume we got a collection of interdaces"			anInterface do: [:each | instance addInterface: each]].	^instance</body><body package="Com- Automation">threadedCreateObject: aClassIdOrProgId	"Answer a newly created and initialized instance."	| options |	self		deprecated: #(#initial '8.1' #use #createInstanceWithOptions: #sunset '8.2').	options := (COMCreationOptions newForVTable)				clsid: aClassIdOrProgId;				iid: IID_IUnknown;				threaded: true;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">threadedCreateObject: aClassIdOrProgId iid: anIID	"Answer a newly created and initialized instance whose base interface exists in the mta."	| options |	self		deprecated: #(#initial '8.1' #use #createInstanceWithOptions: #sunset '8.2').	options := (COMCreationOptions newForVTable)				clsid: aClassIdOrProgId;				iid: anIID;				threaded: true;				yourself.	^self createInstanceWithOptions: options</body></methods><methods><class-id>External.COMClient class</class-id> <category>instance creation (license manager support)</category><body package="Com- Automation">createObject: aProgIDOrCLSID licenseManager: anILicenseManager licenseKey: aLicenseKey	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt; using the given license manager and the given license key.	 This method should be used when creating objects which are licensed using the VisualWorks COM Licensing mechanism."	| options |	self		deprecated: #(#initial '8.1' #use #'ILicenseManager&gt;createCOMClientWithOptions:' #sunset '8.2').	options := (COMCreationOptions newForVTable)				iid: IID_IUnknown;				clsid: aProgIDOrCLSID;				licenseKey: aLicenseKey;				yourself.	^anILicenseManager createCOMClientWithOptions: options</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>converting</category><body package="Com- Automation">asCOMVariant	" Answer the receiver as a COM VARIANT.  Answer nil if the receiver cannot be represented by a known VARIANT type. "	^( COMStructure classForStructureNamed: #VARIANT )		type: self comVariantType		value: self dispatchInterface</body><body package="Com- Automation">asDispatchDriver	" Answer a dispatch driver on the receiver. "	^self</body><body package="Com- Automation">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."    ^self dispatchInterface asPointerParameter</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^VT_DISPATCH</body><body package="Com- Automation">wrapResult: aValue	^(aValue isKindOf: IDispatch)		ifTrue: 			[(aValue asDispatchDriverResult)				localeID: self localeID;				specificationPolicy: self specificationPolicy newPolicy;				yourself]		ifFalse: [aValue]</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>testing</category><body package="Com- Automation">canSupportTypeCompilerPolicy	"Answer whether the receiver can support looking up specifications from a type compiler."	^COMTypeCompilerLookupSpecificationPolicy new		canSupportIDispatch: self dispatchInterface 		forLocaleID: self localeID</body><body package="Com- Automation">canSupportTypeLibraryPolicy	"Answer whether the receiver can support looking up specifications from a type library."	^COMTypeLibraryLookupSpecificationPolicy new		canSupportIDispatch: self dispatchInterface 		forLocaleID: self localeID</body><body package="Com- Automation">isMethod: aMethodName	"Answer if there is a method named &lt;aMethodName&gt;."	^(self specificationPolicy		specificationFor: (COMSpecificationQuery forMethod: aMethodName)		on: nil		ifAbsent: [nil]) notNil</body><body package="Com- Automation">isProperty: aPropertyName	"Answer if there is property named &lt;aPropertyName&gt;."	^(self specificationPolicy		specificationFor: (COMSpecificationQuery forProperty: aPropertyName)		on: self		ifAbsent: [nil]) notNil</body><body package="Com- Automation">isValid	"Answer &lt;true&gt; if the receiver is valid."		^self dispatchInterface notNil and: [ self dispatchInterface isValid ]</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>accessing</category><body package="Com- Automation">anyInterface	^self dispatchInterface</body><body package="Com- Automation">clsid	^ self dispatchInterface clsid</body><body package="Com- Automation">dispatchDriverForInterfaceIID: anIID	"Return a DispatchDriver for the same object but for the interface with the given IID.	 This perform a typecasting and may be required for objects implementing several 	 Dispatch Interfaces"	^(self dispatchInterface queryInterface: anIID)		ifNil: [nil]		ifNotNil: [:interface | (interface castToIID: IID_IDispatch) asDispatchDriver]</body><body package="Com- Automation">dispatchInterface	"Answer the dispatch interface used by the receiver."	^dispatchInterface</body><body package="Com- Automation">dispatchInterface: anIDispatch	"Set the dispatch interface used by the receiver to &lt;anIDispatch&gt;."	anIDispatch ~= dispatchInterface		ifTrue: 			[(dispatchInterface notNil and: [anIDispatch notNil])				ifTrue: [self error: #ErrIDispatchSet &lt;&lt; #com &gt;&gt; 'IDispatch is already set'].			dispatchInterface := anIDispatch]</body><body package="Com- Automation">getDefaultPropertyValue	| spec call |	spec := COMDispatchPropertySpecification defaultPropertySpecification.	call := COMCall forSpecification: spec client: self arguments: #().	^call invoke</body><body package="Com- Automation">getDocumentation	" Retrieve documentation from the ITypeInfo type information for the current locale. "	| anITypeInfo |	(anITypeInfo := self getTypeInfo) isNil ifTrue: [^nil].	^anITypeInfo getDocumentation</body><body package="Com- Automation">getName	" Retrieve the name documentation from the ITypeInfo type information for the current locale. "		| anITypeInfo |	( anITypeInfo := self getTypeInfo ) isNil		ifTrue: [ ^nil ].	^ anITypeInfo getDocumentationName</body><body package="Com- Automation">getTypeInfo	"Retrieve the ITypeInfo interface for the current locale or answer nil if the receiver does not have one. The answer must be released by the caller."		| useLCID |	( self isValid and: [ self dispatchInterface hasTypeInfo ] )		ifFalse: [ ^nil ].	useLCID := self localeID.	useLCID isNil  		ifTrue: [ useLCID := LOCALE_USER_DEFAULT ].	^ (self dispatchInterface getTypeInfoForLocale: useLCID) ifNotNil: #asDispatchTypeInfo</body><body package="Com- Automation">name	" Answer the name of dispatch specification table of the receiver. "	| aName |	self specificationTable isNil ifTrue: [ ^nil ].	aName := self specificationTable name.	aName notNil		ifTrue: [ ^aName ].	aName := self getName.	( aName isNil )		ifTrue: [ ^nil ].	self name: aName.	^aName</body><body package="Com- Automation">name: aString	" Answer the name of dispatch specification table of the receiver. "	self specificationTable isNil ifTrue: [ ^nil ].	self specificationTable name: aString</body><body package="Com- Automation">specificationNames		" Answer the dispatch member names defined in the receiver's 		dispatch specification table. "	self specificationTable isNil ifTrue: [ ^nil ].	^self specificationTable keys</body><body package="Com- Automation">specificationPolicy	" Answer the receiver's specification policy. "    ^specificationPolicy</body><body package="Com- Automation">specificationPolicy: aSpecificationPolicy	" Set the receiver's specification policy. "	self specificationPolicy release.	specificationPolicy := aSpecificationPolicy.</body><body package="Com- Automation">specificationTable: aSpecificationTable	"Set the dispatch specification table of the receiver to &lt;aSpecificationTable&gt;.. "	| anLCID |	super specificationTable: aSpecificationTable.	aSpecificationTable		ifNotNil: 			[anLCID := specificationTable lcid.			anLCID notNil ifTrue: [self localeID: anLCID]]</body><body package="Com- Automation">specificationsDo: aOneArgBlock		" Enumerate the dispatch specifications defined in the		receiver's specification table, evaluating &lt;aOneArgBlock&gt; for each. "	self specificationTable isNil ifTrue: [ ^nil ].	^self specificationTable do: aOneArgBlock</body><body package="Com- Automation">type: anObject	super type: anObject.	self specificationPolicy: COMSpecificationPolicy newTypedPolicy.</body><body package="Com- Automation">typeLibrary	| typeInfo iTypeLib |	^self specificationTable typeLib		ifNil: 			[typeInfo := self getTypeInfo.			iTypeLib := typeInfo getContainingTypeLib.			TypeLibDescriptor fromITypeLib: iTypeLib]</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>dispatching</category><body package="Com- Automation">getIDsOfNames: names	"Answer the IDs for the &lt;names&gt;."    ^self dispatchInterface getIDsOfNames: names localeID: self localeID</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>identity</category><body package="Com- Automation">iid		"Answer the interface ID GUID which uniquely identifies the receiver. "	^self dispatchInterface iid</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>private-accessing</category><body package="Com- Automation">defaultLocaleID	" Private - answer the default LCID for the receiver. "	^COMSessionManager defaultLocaleID</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>printing</category><body package="Com- Automation">basicPrintOn: aStream 	| aString |	aString := self name ifNil: ['unnamed' ].	aString isEmpty ifTrue: [ aString := 'unnamed' ].	aStream nextPutAll: (aString first isVowel ifTrue: ['an '] ifFalse: ['a ']);			nextPutAll: aString.</body><body package="Com- Automation">printOn: aStream 	self accessor printDriverOn: aStream</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>comparing</category><body package="Com- Automation">= anObject	^anObject class = self class		and: [anObject dispatchInterface = self dispatchInterface]</body><body package="Com- Automation">hash	^ self dispatchInterface hash</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>private dispatching</category><body package="Com- Automation">actualReceiverFor: aCOMCall	^(super actualReceiverFor: aCOMCall)		ifNil: [self error: #CanNotDispatchCall &lt;&lt; #com &gt;&gt; 'Can not dispatch call']</body><body package="Com- Automation">doesNotUnderstand: aMessage	" Private - sent to the receiver by the virtual machine when the message &lt;aMessage&gt;		sent to the receiver was not implemented by the receiver.  Forward the message		to the automation object if this is dynamic protocol for a supported member. "	| call |	call := COMCall forMessage: aMessage driver: self.	^call invoke</body><body package="Com- Automation">signalMemberNotFound	"Private."    COMError hresult: DISP_E_MEMBERNOTFOUND</body><body package="Com- Automation">wrapResult: aResult args: anArray namedArgs: anObject for: aSpec	^self wrapResult: aResult</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>private-initialization</category><body package="Com- Automation">computeSpecificationTable	^specificationTable := specificationPolicy				initialSpecificationTableFor: self</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>private accessing interfaces</category><body package="Com- Automation">iUnknown	^ self queryInterface: IID_IUnknown</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>releasing</category><body package="Com- Automation">release	" Release the dispatch interface associated with the receiver. "	dispatchInterface := nil.	super release.</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>initialize-release</category><body package="Com- Automation">enforceRelease	" Release the dispatch interface associated with the receiver. "	super enforceRelease.	(dispatchInterface notNil and: [dispatchInterface isValid])		ifTrue: [dispatchInterface enforceRelease].	dispatchInterface := nil</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>notices</category><body package="Com- Automation">enforceInvalidation	^ self dispatchInterface enforceInvalidation</body></methods><methods><class-id>External.COMDispatchDriver</class-id> <category>finalization</category><body package="Com- Automation">finalize	"Finalize the object. This message is sent by WeakDictionary.	The default is to do nothing. Subclasses might want to override 	this method."	self disconnectEventSink.	dispatchInterface := nil</body></methods><methods><class-id>External.COMDispatchDriver class</class-id> <category>instance creation-from IDispatch</category><body package="Com- Automation">on: anIDispatch         " Answer a new instance of the receiver which uses        the dispatch interface &lt;anIDispatch&gt; to invoke        dispatch member functions.  The functions and properties        are built the default specification policy. "    ^self new	  dispatchInterface: anIDispatch;        specificationPolicy: COMSpecificationPolicy newDefaultPolicy;        yourself</body><body package="Com- Automation">on: anIDispatch specificationPolicy: aSpecificationPolicy        " Answer a new instance of the receiver which uses        the dispatch interface &lt;anIDispatch&gt; to invoke        dispatch member functions.  The functions and properties        are built by &lt;aSpecificationPolicy&gt;. "    ^self new	  dispatchInterface: anIDispatch;        specificationPolicy: aSpecificationPolicy;        specificationTable: COMDispatchSpecificationTable newNamedTable;        yourself</body><body package="Com- Automation">on: anIDispatch specificationTable: aSpecificationTable        " Answer a new instance of the receiver which uses        the dispatch interface &lt;anIDispatch&gt; to invoke        dispatch member functions.  The supported functions        are described by the invocation specifications in        &lt;aSpecificationTable&gt;. "    ^self new	  dispatchInterface: anIDispatch;        specificationPolicy: COMSpecificationPolicy newCompletePolicy;        specificationTable: aSpecificationTable;        yourself</body><body package="Com- Automation">onNew: anIDispatch	" Answer a new instance of the receiver which uses        the dispatch interface &lt;anIDispatch&gt; to invoke        dispatch member functions.  The functions and properties        are built the default specification policy. "		^(self new)		dispatchInterface: anIDispatch;		specificationPolicy: COMSpecificationPolicy newDefaultPolicy;		needsFinalization;		yourself</body><body package="Com- Automation">onNew: anIDispatch specificationTable: aSpecificationTable	" Answer a new instance of the receiver which uses        the dispatch interface &lt;anIDispatch&gt; to invoke        dispatch member functions.  The supported functions        are described by the invocation specifications in        &lt;aSpecificationTable&gt;. "	^self		on: anIDispatch specificationTable: aSpecificationTable;		needsFinalization;		yourself</body></methods><methods><class-id>External.COMDispatchDriver class</class-id> <category>instance creation-from identifiers</category><body package="Com- Automation">createInstanceWithOptions: options	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	Note: This is equivalent to the VBA CreateObject() function."	| result |	result := self		onNewAndInitialize: (IClassFactory createInstanceWithOptions: options).	options applySpecificationOn: result.	^ result</body><body package="Com- Automation">createObject: aProgIDOrCLSID	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	Note: This is equivalent to the VBA CreateObject() function."	| options |	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aCLSIDOrProgID context: aClassContext	"Create an instance of the OLE object described by &lt;aCLSIDOrProgID&gt;, an instance of GUID or String.	The new OLE object is created within &lt;aClassContext&gt;, in/out process, local/remote."	| options |	options := (COMCreationOptions newForDispatch)				clsid: aCLSIDOrProgID;				context: aClassContext;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aCLSIDOrProgID context: aClassContext serverName: serverName	"Create an instance of the OLE object described by &lt;aCLSIDOrProgID&gt;, an instance of GUID or String.	The new OLE object is created within &lt;aClassContext&gt;, in/out process, local/remote."	| options |	self		deprecated: #(#initial '8.1' #use #createInstanceWithOptions: #sunset '8.2').	options := (COMCreationOptions newForDispatch)				clsid: aCLSIDOrProgID;				context: aClassContext;				serverName: serverName;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aCLSIDOrProgID serverName: serverName	"Create a new instance of the OLE object class specified by &lt;aCLSIDOrProgID&gt; on the machine &lt;serverName&gt;.	Note: This is equivalent to the VBA CreateObject() function."	| options |	options := (COMCreationOptions newForDispatch)				clsid: aCLSIDOrProgID;				serverName: serverName;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aProgIDOrCLSID specificationPolicy: aPolicy	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	Note: This is equivalent to the VBA CreateObject() function."	| options |	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				specification: aPolicy;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aProgIDOrCLSID specificationTable: specificationTable	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	Note: This is equivalent to the VBA CreateObject() function."	| options |	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				specification: specificationTable;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">onActiveObject: aCLSIDOrProgID	" Answer a new instance of the receiver on the active object	of the automation object class &lt;aCLSID&gt;.	Raise an OLEError if there is no active object. 	Note: this is equivalent to VBA's GetObject(,ProgID) function."	^self onNew: ( IDispatch onActiveObject: aCLSIDOrProgID )</body><body package="Com- Automation">pathName: aFileName	" Answer a new instance of the receiver on the automation object	in the file named &lt;aPathName&gt;. 	Note: this is equivalent to VBA's GetObject(FileName) function."	^self onNew: ( IDispatch pathName: aFileName )</body><body package="Com- Automation">pathName: aFileName progID: aClassName	"Create an new Automation object of the class named &lt;aProgIDOrCLSID&gt; and	load &lt;aFileName&gt; into it. Answer an instance of the reciever on the automation	object. The automation class &lt;aProgIDOrCLSID&gt; must support IPersistFile.	Note: this is equivalent to VBA's GetObject(FileName,ProgID) function."		^self onNew: ( IDispatch pathName: aFileName progID: aClassName )</body><body package="Com- Automation">threadedCreateObject: aProgIDOrCLSID	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	Note: This is equivalent to the VBA CreateObject() function."	| options |	self		deprecated: #(#initial '8.1' #use #createInstanceWithOptions: #sunset '8.2').	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				threaded: true;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">threadedCreateObject: aProgIDOrCLSID specificationPolicy: aPolicy	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	Note: This is equivalent to the VBA CreateObject() function."	| options |	self		deprecated: #(#initial '8.1' #use #createInstanceWithOptions: #sunset '8.2').	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				threaded: true;				policy: aPolicy;				yourself.	^self createInstanceWithOptions: options</body></methods><methods><class-id>External.COMDispatchDriver class</class-id> <category>instance creation (licensing manager support)</category><body package="Com- Automation">createObject: aProgIDOrCLSID licenseManager: anILicenseManager licenseKey: aLicenseKey	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt; using the given license manager and the given license key.	 This method should be used when creating objects which are licensed using the VisualWorks COM Licensing mechanism."	| options |	self		deprecated: #(#initial '8.1' #use #'ILicenseManager&gt;createDispatchDriverWithOptions:' #sunset '8.2').	options := (COMCreationOptions newForDispatch)				iid: IID_IDispatch;				clsid: aProgIDOrCLSID;				licenseKey: aLicenseKey;				yourself.	^anILicenseManager createDispatchDriverWithOptions: options</body></methods><methods><class-id>External.COMDispatchDriver class</class-id> <category>instance creation (licensing support)</category><body package="Com- Automation">createObject: aProgIDOrCLSID context: aClassContext licenseKey: aLicenseKey	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	This method should be used if the COM object requires a license key"	| options |	self		deprecated: #(#initial '8.1' #use #createInstanceWithOptions: #sunset '8.2').	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				context: aClassContext;				licenseKey: aLicenseKey;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aProgIDOrCLSID context: aClassContext serverName: serverName licenseKey: aLicenseKey	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	This method should be used if the COM object requires a license key"	| options |	self		deprecated: #(#initial '8.1' #use #createInstanceWithOptions: #sunset '8.2').	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				context: aClassContext;				licenseKey: aLicenseKey;				serverName: serverName;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aProgIDOrCLSID licenseKey: aLicenseKey	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	This method should be used if the COM object requires a license key"	| options |	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				licenseKey: aLicenseKey;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aProgIDOrCLSID licenseKey: aLicenseKey specificationPolicy: aPolicy	"Create a new instance of the OLE object class specified by &lt;aProgIDOrCLSID&gt;.	This method should be used if the COM object requires a license key"	| options |	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				licenseKey: aLicenseKey;				specification: aPolicy;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createObject: aProgIDOrCLSID licenseKey: aLicenseKey specificationTable: aSpecificationTable	| options |	options := (COMCreationOptions newForDispatch)				clsid: aProgIDOrCLSID;				licenseKey: aLicenseKey;				specification: aSpecificationTable;				yourself.	^self createInstanceWithOptions: options</body></methods><methods><class-id>External.COMDispatchValueAdaptor</class-id> <category>private-parameter construction</category><body package="Com- Automation">argumentValuesFromDispParams: dispParams	" get the argumentValues from dispatchParams."	^dispParams arguments collect: [:each | each value]</body><body package="Com- Automation">constructDispidsForNames: parameterNames values: valueArray 	" Private - answer an array of DISPID's constructed according to zero-based        position in &lt;parameterNames&gt; for the values &lt;valueArray&gt;. "	| dispidArray index |	dispidArray := valueArray collect: 					[:aValue | 					index := self indexOf: aValue inParameters: parameterNames.					" Ensure the parameter name exists, otherwise the API call will fail. "					index = 0 						ifTrue: 							[COMError 								raiseSignal: (#ErrNamedInvalidArg &lt;&lt; #com 										&gt;&gt; 'Argument name &lt;1p&gt; is invalid.' expandMacrosWith: aValue)].					" Adjust to zero-based C style indexing "					index - 1].	^dispidArray</body><body package="Com- Automation">constructVariantsForTypes: parameterTypes values: valueArray	" Private - answer an array of VARIANTARG's constructed according		to the type codes in &lt;parameterTypes&gt; for the values &lt;valueArray&gt;. "	| i |	i := 0.	parameterTypes size &lt; valueArray size		ifTrue: [COMError hresult: DISP_E_BADPARAMCOUNT].	^valueArray		collect: [:aValue | self createVariant: (parameterTypes at: (i := i + 1)) value: aValue]</body><body package="Com- Automation">createDispParams		" Private - create a new instance of a DISPPARAMS structure. 		The client is responsible for ensuring that the structure is released. "	"^COMStructure createStructureNamed: #DISPPARAMS"	| aDispParams |	Tools.Note ISSUE.  " Review this quick-and-dirty port.  Do we really have		to clear everything on the heap and is there a fast way		to initialize it to null?  [DL 13-Mar-96] "	aDispParams := COMExternalInterface current DISPPARAMS malloc.	aDispParams		memberAt: #cArgs put: 0;		memberAt: #rgvarg put: nil;		memberAt: #rgdispidNamedArgs put: nil;		memberAt: #cNamedArgs put: 0.	^( COMStructure classForStructureNamed: #DISPPARAMS ) onNew: aDispParams</body><body package="Com- Automation">createVariant: aType value: aValue		" Private - answer a newly created VARIANTARG structure. "	"	[AA 08/2004 ] Compensating the additional AddRef Call for Interfaces in SafeArrays 		when releasing the buffer in COM_DISPPARAMS releaseArguments. 		The problem appears when we compensate AddRef Calls here and the server 		exchanges an interface element in a safeArray - we must release the safeArray then. 		So we don't compensate it here but after the invocation. "	^ ( COMStructure classForStructureNamed: #VARIANTARG )		typeDescription: aType		value: (aType preMarshalAutomationParameter: aValue client: self)</body><body package="Com- Automation">indexOf: aString inParameters: parameterNames	"Answer the index of the first occurrence of &lt;aString&gt; within &lt;parameterNames&gt;.  If the receiver does not contain &lt;aString&gt;, answer 0. The search ignores case differences."	| index |	index := 0.	parameterNames do: [ : aName |		index := index + 1.		( aName notNil and: [ aName sameAs: aString ] )			ifTrue: [ ^index ] ].	^0</body><body package="Com- Automation">typeCodeFor: aTypeCode		" Private - answer the variant type code to use for &lt;aTypeCode. "	Tools.Note ISSUE.  " Steve's original implementation carried the following remark.		What to do?? [DL 24-Oct-95] " 	"TEMPORARY: need to determine how to handle user-defined interface types."	Tools.Note ISSUE.  " Maybe don't need false option anymore, GUID's were 		handled back in #refTypeCode: [Deb/Steve [DL 09-Nov-95] " 	^aTypeCode isInteger		ifTrue: [ aTypeCode ]		ifFalse: [ VT_UNKNOWN ]</body></methods><methods><class-id>External.COMDispatchValueAdaptor</class-id> <category>parameter construction</category><body package="Com- Automation">parametersFor: aDispatchSpecification arguments: valueArray	" Answer the dispatch parameters corresponding to the argument values	in &lt;valueArray&gt; which can be used to invoke the dispatch method described by &lt;aDispatchSpecification&gt;. "	| dispParams |	dispParams := self createDispParams.	dispParams arguments: (self				constructVariantsForTypes: aDispatchSpecification parameterTypeDescriptions				values: valueArray).	^dispParams</body><body package="Com- Automation">parametersForMethod: aDispatchSpecification arguments: valueArray        " Answer the dispatch parameters corresponding to the argument values in &lt;valueArray&gt; which can be used to invoke the dispatch method described by &lt;aDispatchSpecification&gt;. "	^self parametersFor: aDispatchSpecification arguments: valueArray</body><body package="Com- Automation">parametersForMethod: aDispatchSpecification    arguments: valueArray    namedArguments: valueDictionary        " Answer the dispatch parameters corresponding to the argument values in        &lt;valueArray&gt; and named arguments in &lt;valueDictionary&gt; which can be used        to invoke the dispatch method described by &lt;aDispatchSpecification&gt;. "    | dispParams positionalArguments namedArguments    dispidArray namedParameterTypes parameterTypes    valuesCount dispidArrayValues namedArgumentsValues index |    dispParams := self createDispParams.    positionalArguments := self        constructVariantsForTypes: aDispatchSpecification parameterTypeDescriptions        values: valueArray.    "It is critical that the order of the elements in the &lt;dispidArrayValues&gt; and &lt;namedArgumentsValues&gt;    be perfectly matched. To insure this we traverse the &lt;valueDictionary&gt; parameter to build both arrays at    the same time."    valuesCount := valueDictionary size.    dispidArrayValues := Array new: valuesCount.    namedArgumentsValues := Array new: valuesCount.    index := 1.    valueDictionary keysAndValuesDo: [ :key :value |        dispidArrayValues at: index put: key.        namedArgumentsValues at: index put: value.        index := index + 1.    ].    dispidArray := self        constructDispidsForNames: aDispatchSpecification parameterNames        values: dispidArrayValues.    dispidArray size &gt; 0         ifTrue: [            dispParams argumentIDs: dispidArray.            " Collect the parameter types for the named arguments."            parameterTypes := aDispatchSpecification parameterTypeDescriptions.            namedParameterTypes := dispidArray collect: [ :i | parameterTypes at: i + 1 ].            namedArguments := self                constructVariantsForTypes: namedParameterTypes                values: namedArgumentsValues.            dispParams arguments: ( positionalArguments, namedArguments ).]        ifFalse: [ dispParams arguments: positionalArguments ].    ^dispParams</body><body package="Com- Automation">parametersForPropertyGet: aDispatchSpecification arguments: valueArray        " Answer the dispatch parameters corresponding to the argument values        in &lt;valueArray&gt; which can be used to get the value        of the property described by &lt;aDispatchSpecification&gt;. "    | dispParams |Tools.Note ISSUE. "GG to do replace with: ^self parametersFor: aDispatchSpecification arguments: valueArray"    dispParams := self createDispParams.    aDispatchSpecification hasParameters        ifFalse: [  " simple property get "            dispParams arguments: #( ).            ^dispParams ].    " parameterized property "    "Note ASSERT: ( aDispatchSpecification isReadOnly        ifTrue: [ aDispatchSpecification parameterTypes size = valueArray size ]  ""not handling opt args""        ifFalse: [ aDispatchSpecification parameterTypes size - 1 = valueArray size ] )."    dispParams arguments: ( self        constructVariantsForTypes: aDispatchSpecification parameterTypeDescriptions        values: valueArray ).    ^dispParams</body><body package="Com- Automation">parametersForPropertySet: aDispatchSpecification arguments: valueArray        " Answer the dispatch parameters corresponding to the argument values        in &lt;valueArray&gt; which can be used to set the value        of the property described by &lt;aDispatchSpecification&gt;. "    | dispParams |    dispParams := self createDispParams.    dispParams argumentIDs: ( Array with: DISPID_PROPERTYPUT ).    aDispatchSpecification hasParameters        ifFalse: [  " simple property get "            dispParams arguments: ( Array                with: ( self createVariant: aDispatchSpecification type                    value: ( valueArray at: 1 ) ) ).            ^dispParams ].    " parameterized property "    "Note ASSERT: aDispatchSpecification parameterTypes size = valueArray size."    "not handling opt args"    dispParams arguments: ( self        constructVariantsForTypes: aDispatchSpecification parameterTypeDescriptions        values: valueArray ).    ^dispParams</body></methods><methods><class-id>External.COMDispatchValueAdaptor</class-id> <category>accessing</category><body package="Com- Automation">client	^client</body><body package="Com- Automation">client: anObject	client := anObject</body></methods><methods><class-id>External.COMDispatchValueAdaptor</class-id> <category>argument construction</category><body package="Com- Automation">argumentFromValues: valueArray dispParams: dispParams specification: aDispatchSpecification	| arguments indexedArgCount types argID1 |	valueArray size &gt; aDispatchSpecification parameters size		ifTrue: [COMError hresult: DISP_E_BADPARAMCOUNT].	arguments := Array new: aDispatchSpecification parameterCount				withAll: MissingAutomationArgument default.	indexedArgCount := valueArray size - dispParams namedArgumentCount.	types := aDispatchSpecification parameters.	1 to: indexedArgCount		do: 			[:index |			arguments at: index				put: (IndexedAutomationArgument						index: index						argumentDescription: (types at: index)						value: (valueArray at: index))].	dispParams argumentIDs doWithIndex: 			[:argID :index |			argID1 := argID = DISPID_PROPERTYPUT						ifTrue: [arguments size]						ifFalse: [argID + 1].			arguments at: argID1				put: (NamedAutomationArgument						argumentID: argID						originalIndex: indexedArgCount + index						argumentDescription: (types at: argID1)						value: (valueArray at: indexedArgCount + index))].	^arguments</body><body package="Com- Automation">argumentsForMethod: aDispatchSpecification parameters: dispParams localeID: lcid	" Answer the argument values corresponding to the dispatch parameters		in &lt;dispParams&gt; which have been used to invoke the dispatch method		described by &lt;aDispatchSpecification&gt;. "	Tools.Note ISSUE.	" TO DO: Check supplied types against expected types 		-&gt; answer mismatch index for DISP_E_TYPEMISMATCH if problem found.		Allow null specification for OLEFontObject.  [DL 30-Oct-95]  "	^self		argumentFromValues: (self argumentValuesFromDispParams: dispParams)		dispParams: dispParams		specification: aDispatchSpecification</body><body package="Com- Automation">argumentsForPropertyGet: aDispatchSpecification parameters: dispParams localeID: lcid	" Answer the argument values corresponding to the dispatch parameters		in &lt;dispParams&gt; which have been used to get the value of the property		described by &lt;aDispatchSpecification&gt;. "	Tools.Note ISSUE.	" TO DO: Check supplied types against expected types 		-&gt; answer mismatch index for DISP_E_TYPEMISMATCH if problem found.		Allow null specification for OLEFontObject.  [DL 30-Oct-95]  "	^self		argumentFromValues: (self argumentValuesFromDispParams: dispParams)		dispParams: dispParams		specification: aDispatchSpecification</body><body package="Com- Automation">argumentsForPropertySet: aDispatchSpecification parameters: dispParams localeID: lcid	" Answer the argument values corresponding to the dispatch parameters		in &lt;dispParams&gt; which have been used to set the value of the property		described by &lt;aDispatchSpecification&gt;. "	Tools.Note ISSUE.	" TO DO: Check supplied types against expected types 		-&gt; answer mismatch index for DISP_E_TYPEMISMATCH if problem found.		Allow null specification for OLEFontObject.  [DL 30-Oct-95]  "	^self		propertySetArgumentFromValues: (self argumentValuesFromDispParams: dispParams)		dispParams: dispParams		specification: aDispatchSpecification</body><body package="Com- Automation">propertySetArgumentFromValues: valueArray dispParams: dispParams specification: aDispatchSpecification	| arguments indexedArgCount types argID1 type |	arguments := Array new: valueArray size				withAll: MissingAutomationArgument default.	indexedArgCount := valueArray size - dispParams namedArgumentCount.	types := aDispatchSpecification parameters.	1 to: indexedArgCount		do: 			[:index |			arguments at: index				put: (IndexedAutomationArgument						index: index						argumentDescription: (types at: index)						value: (valueArray at: index))].	dispParams argumentIDs doWithIndex: 			[:argID :index |			argID1 := (argID = DISPID_PROPERTYPUT) ifTrue: [ arguments size ] ifFalse: [ argID + 1 ].			type := index &gt; types size ifTrue: [ aDispatchSpecification returnValueDescription ] ifFalse: [ types at: argID1 ].			arguments at: argID1				put: (NamedAutomationArgument						argumentID: argID						originalIndex: indexedArgCount + index						argumentDescription: type						value: (valueArray at: indexedArgCount + index))].	^arguments</body></methods><methods><class-id>External.COMDispatchValueAdaptor</class-id> <category>argument updating</category><body package="Com- Automation">update: anArgValue from: aVariant type: aType	| var |	(aVariant isReference)				ifTrue: 					[var := aVariant value.					aType unmarshalAutomationResult: var into: anArgValue]</body><body package="Com- Automation">updateReferenceArguments: argValuesArray fromParameters: dispParams types: types	" Update any reference values provided the caller in &lt;argValuesArray&gt; 		from the returned values of the dispatch parameters &lt;dispParams&gt;. "	| arguments indexedArgumentCount namedArgumentCount argumentIDs anArgValue aType aVariant |	arguments := dispParams arguments.	arguments size = 0 ifTrue: [^self].	argumentIDs := dispParams argumentIDs.	"For SetProperty one named argument with index -3 (DISPID_PROPERTYPUT) is used"	argumentIDs = #(-3) ifTrue: [ argumentIDs := #() ].	namedArgumentCount := argumentIDs size.	indexedArgumentCount := dispParams argumentCount - namedArgumentCount.	1 to: indexedArgumentCount do:  [:index |			aVariant := arguments at: index.			anArgValue := argValuesArray at: index.			aType := types at: index.			self update: anArgValue from: aVariant type: aType].	1 to: namedArgumentCount do:  [:namedIndex |	| index |			index := indexedArgumentCount + namedIndex.			aVariant := arguments at: index.			anArgValue := argValuesArray at: index.			aType := types at: (argumentIDs at: namedIndex) + 1.			self update: anArgValue from: aVariant type: aType]</body><body package="Com- Automation">updateReturnReferenceArguments: argValuesArray fromParameters: dispParams	" Update any reference values in &lt;dispParams&gt; using &lt;argValuesArray&gt; on server.	   arguments holding interfaces/SafeArrays of interfaces are separate reference counted 	   and will be invalidated afterwards "	| arguments |	arguments := dispParams arguments.	arguments size = 0 ifTrue: [^self].	argValuesArray do: [:each | each updateServerArgumentIn: arguments]</body></methods><methods><class-id>External.COMDispatchValueAdaptor class</class-id> <category>instance creation</category><body package="Com- Automation">forClient: aClient	^ self new		client: aClient;		yourself</body></methods><methods><class-id>External.COMUntypedSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^false</body></methods><methods><class-id>External.COMUntypedSpecificationPolicy</class-id> <category>private-initializing</category><body package="Com- Automation">defaultUpdateSpecificationTable    "Private. We do not keep specifications for the untyped policy.    Since it is easy to create them and they all hold the same generic    information with VT_VARIANTs. This frees us from growing the    parameter types array with more VT_VARIANT entries."    ^false</body></methods><methods><class-id>External.COMUntypedSpecificationPolicy</class-id> <category>private-invocation</category><body package="Com- Automation">isReturnTypeException: aCOMDispatchError    "Private. Answer whether or not the error was caused by generically invoking    a void function and asking for a return type."	( aCOMDispatchError hresult ~= DISP_E_EXCEPTION	or: [ aCOMDispatchError exceptionInfo isNil ] )            ifTrue: [ ^false ].	"Is the following just good for MS Word?"	aCOMDispatchError exceptionInfo wCode = 5007		ifTrue: [ ^true ].	aCOMDispatchError exceptionDescription = (#NonFunctionCalledAsFunction &lt;&lt; #com &gt;&gt; 'Non function called as function') asString		ifTrue: [ ^true ].	^false</body></methods><methods><class-id>External.COMUntypedSpecificationPolicy</class-id> <category>invocation</category><body package="Com- Automation">invokeMethod: aSpecification with: dispParams on: aDispatchDriver result: resultReference	"Invoke the method described by &lt;aDispatchSpec&gt;. 	Use this message when a procedure and a function have the same name (and DISPID) and you	want to invoke the function."	| resultValue |		[resultValue := super				invokeMethod: aSpecification				with: dispParams				on: aDispatchDriver				result: resultReference]			on: COMError			do: 				[:ex |				(self isReturnTypeException: ex)					ifFalse: [ex pass]					ifTrue: 						[aSpecification typeCode: VT_VOID.						resultValue := super									invokeMethod: aSpecification									with: dispParams									on: aDispatchDriver									result: nil.						self wrapResultValue: resultValue ofType: aSpecification type from: aDispatchDriver.						self updateSpecificationTable							ifTrue: 								[aDispatchDriver specificationTable at: aSpecification name									put: aSpecification]]].	^resultValue</body></methods><methods><class-id>External.AutomationClassMember</class-id> <category>accessing</category><body package="Com- Automation">interface	^interface</body><body package="Com- Automation">interface: anObject	interface := anObject</body><body package="Com- Automation">member	^member</body><body package="Com- Automation">member: anObject	member := anObject</body></methods><methods><class-id>External.AutomationClassMember</class-id> <category>error handling</category><body package="Com- Automation">doesNotUnderstand: aMessage	^ member perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>External.AutomationClassMember</class-id> <category>comparing</category><body package="Com- Automation">= aMember		^aMember class = self class		and: [interface = aMember interface and: [member = aMember member]]</body></methods><methods><class-id>External.AutomationClassMember</class-id> <category>vtable calls</category><body package="Com- Automation">performCallOn: aVTableObject withParameters: parameters	^(aVTableObject interfaceForIID: self interface iid)		ifNil: 			[self error: #CanNotPerformDispatchCallOnVTableObject &lt;&lt; #com						&gt;&gt; 'In the current version it is not supported to perform Dispatch Calls on this COM VTable Objects. Please use a COMDispatchDriver insteadUnmatched string quote -&gt;']		ifNotNil: [:anInterface | self member  performCallOn: anInterface withParameters: parameters]</body></methods><methods><class-id>External.AutomationClassMember</class-id> <category>As yet unclassified</category><body package="Com- Automation">equalsCOMTypeSpec: aTypeSpec 		^ false</body></methods><methods><class-id>External.AutomationClassMember</class-id> <category>testing</category><body package="Com- Automation">isEqualTo: anMember	^anMember isEqualTo: self member</body></methods><methods><class-id>External.AutomationClassMember class</class-id> <category>instance creation</category><body package="Com- Automation">interface: anInterface member: aMember	^ self new		interface:  anInterface;		member: aMember;		yourself</body></methods><methods><class-id>External.MissingName class</class-id> <category>converting</category><body package="Com- Automation">asString	^ nil</body></methods><methods><class-id>External.IndexedAutomationArgument</class-id> <category>accessing</category><body package="Com- Automation">index	^ self indexSpec</body><body package="Com- Automation">index: anObject	self indexSpec: anObject</body><body package="Com- Automation">originalIndex	^ self index</body></methods><methods><class-id>External.IndexedAutomationArgument class</class-id> <category>instance creation</category><body package="Com- Automation">index: anIndex argumentDescription: argDescription value: aValue	^(self new)		index: anIndex;		argumentDescription: argDescription;		originalValue: aValue copy;		value: aValue;		yourself</body></methods><methods><class-id>External.CoclassDescriptor</class-id> <category>accessing</category><body package="Com- Automation">clsid	^ self guid</body><body package="Com- Automation">implementedInterfaces	"return all implemented interfaces"	| coll aTypeInfo itf2 |	coll := OrderedCollection new.	aTypeInfo := self asTypeInfo.	aTypeInfo implementedInterfacesDo: 			[:itf |			coll addLast: (DispUserDefTypeSpec fromTypeInfo: itf).			itf isDualInterface				ifTrue: 					[itf2 := itf alternativeTypeInfo.					coll addLast: (DispUserDefTypeSpec fromTypeInfo: itf2)]].	^coll</body><body package="Com- Automation">kindname	^  (#TKindCoclass &lt;&lt; #com &gt;&gt; 'COClass') asString</body><body package="Com- Automation">progID	^self registryFolder		ifNil: [nil]		ifNotNil: [:clsEntry | (clsEntry at: 'ProgID' ifAbsent: [^nil]) value]</body><body package="Com- Automation">specificationTable	^self specificationTableWithEvents: false specificationKey: #name</body><body package="Com- Automation">specificationTableWithEvents: aBoolean specificationKey: key	^AutomationClassSpecificationTable		forCoclass: self		specificationKey: key		includeEvents: aBoolean</body><body package="Com- Automation">typecode	^ VT_UNKNOWN</body><body package="Com- Automation">versionIndependentProgID	^ self registryFolder		ifNil: [ nil ]		ifNotNil: [:clsEntry | clsEntry at: 'VersionIndependentProgID' ifAbsent: [ nil ] ]</body></methods><methods><class-id>External.CoclassDescriptor</class-id> <category>private</category><body package="Com- Automation">dispatchDriverClass	^ COMDispatchDriver</body><body package="Com- Automation">guidName	^ 'ClsID'</body><body package="Com- Automation">registryFolder	| clsidsEntry |	clsidsEntry := Win32RegistrationDatabase classesRoot at: 'clsid'.	^ clsidsEntry at: self clsid asString asSymbol ifAbsent: [ nil ].</body></methods><methods><class-id>External.CoclassDescriptor</class-id> <category>accessing typelib</category><body package="Com- Automation">lcid		^ self typelib lcid</body><body package="Com- Automation">locale		^ self typelib locale</body><body package="Com- Automation">version	^ self typelib version</body></methods><methods><class-id>External.CoclassDescriptor</class-id> <category>instance creation</category><body package="Com- Automation">new	^ self dispatchDriverClass createObject: self guid.</body></methods><methods><class-id>External.CoclassDescriptor</class-id> <category>testing</category><body package="Com- Automation">implementsDispatching	"answer whether the coclass implements an IDispatch interface"	| aTypeInfo |	aTypeInfo := self asTypeInfo.	aTypeInfo implementedInterfacesDo: [:itf | itf isDispatch ifTrue: [^true]].	^false</body><body package="Com- Automation">isCoclass	^ true</body><body package="Com- Automation">isCreatable		^self hasGuid and: [self isRegistered and: [self implementsDispatching]]</body><body package="Com- Automation">isRegistered	| dbEntry |	dbEntry := Win32RegistrationDatabase classesRoot at: 'clsid'.	^ dbEntry includesKey: self guid asString</body></methods><methods><class-id>External.CoclassDescriptor</class-id> <category>browser support</category><body package="Com- Automation">defaultInterface	"return all implemented interfaces"	| aTypeInfo |	aTypeInfo := self asTypeInfo.	aTypeInfo dispatchInterfacesDo: 			[:itf :flags |			((aTypeInfo isImplementedItf: flags) and: [itf isDefaultInterface: flags])				ifTrue: [^InterfaceTypeSpec fromTypeInfo: itf]].	^nil</body><body package="Com- Automation">dispatchInterfaces	"return all dispatch  interfaces"	| coll aTypeInfo |	coll := OrderedCollection new.	aTypeInfo := self asTypeInfo.	aTypeInfo		dispatchInterfacesDo: [:itf :flags | coll addLast: (DispUserDefTypeSpec fromTypeInfo: itf)].	^coll</body><body package="Com- Automation">elements	"return all possible protocol items"		^(self specificationTableWithEvents: true specificationKey: #name) members asSet</body><body package="Com- Automation">eventDispatchInterfaces	"return all implemented interfaces"	| coll aTypeInfo |	coll := OrderedCollection new.	aTypeInfo := self asTypeInfo.	aTypeInfo dispatchInterfacesDo: 			[:itf :flags |			(aTypeInfo isImplementedItf: flags)				ifFalse: [coll addLast: (DispUserDefTypeSpec fromTypeInfo: itf)]].	^coll</body><body package="Com- Automation">implementedDispatchInterfaces	"return all implemented interfaces"	| coll aTypeInfo |	coll := OrderedCollection new.	aTypeInfo := self asTypeInfo.	aTypeInfo dispatchInterfacesDo: 			[:itf :flags |			(aTypeInfo isImplementedItf: flags)				ifTrue: [coll addLast: (DispUserDefTypeSpec fromTypeInfo: itf)]].	^coll</body></methods><methods><class-id>External.CoclassDescriptor</class-id> <category>marshaling</category><body package="Com- Automation">iid	^ External.COMConstants.IID_IUnknown</body><body package="Com- Automation">marshalPointerArgument: anArgument	^ anArgument queryInterface: External.COMConstants.IID_IUnknown</body></methods><methods><class-id>External.CoclassDescriptor class</class-id> <category>private constants</category><body package="Com- Automation">typekinds		^ Array with: TKIND_COCLASS</body></methods><methods><class-id>External.CoclassDescriptor class</class-id> <category>instance creation</category><body package="Com- Automation">newEmptyType	^ self new</body></methods><methods><class-id>External.COMTypedSpecificationPolicy</class-id> <category>testing</category><body package="Com- Automation">isTyped	"Answer whether the receiver represents a fully typed specification policy."    ^true</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private-invocation-safe arrays</category><body package="Com- Automation">SafeArrayGetVartype: psa 	| pvt |	pvt := COMExternalInterface scalarResultBufferFor: #VARTYPE.	^ (self invokeSafeArrayGetVartype: psa asPointerParameter _: pvt asPointerParameter) = S_OK		ifTrue: [ pvt contents ]		ifFalse:  [ nil ]</body><body package="Com- Automation">createSafeArrayGetBufferFor: aSafeArray	" Private - answer an element buffer suitable for the SafeArray get API. "	| aVariant |	aSafeArray isArrayOfVARIANT		ifTrue: [ 			aVariant := COMStructure createStructureNamed: #VARIANT.			Tools.Note ISSUE.  " Can we drop this heap copy?  [DL 10-May-97] "			Assert isTrue: [ aVariant isSafeForExternalFunctionArgument ].   			aVariant copyToHeap.			^aVariant ].	( aSafeArray isArrayOfDISPATCH )		ifTrue: [ ^IDispatchPointer baseCType malloc ].	( aSafeArray isArrayOfUNKNOWN )		ifTrue: [ ^IUnknownPointer baseCType malloc ].    " None of the above means that the typeCode should be set because    we have a Safe Array of a VT basic type, like for example VT_BOOL or VT_I4. "    aSafeArray typeCode isNil        ifTrue: [ COMError raiseSignal: #ErrSafeArrayTypeUnset &lt;&lt; #com &gt;&gt;'The Safe Array typeCode is not set.' ].	aSafeArray isArrayOfDecimal 		ifTrue: [ ^ COM_DECIMAL fromNumber: FixedPoint zero].	aSafeArray isArrayOfStructs ifTrue: [		^ (COMRecord newWith: aSafeArray recordInfo) 			configureAsSafeArrayGetBuffer; 			yourself ].	aVariant := COMVariantValue new		typeCode: aSafeArray typeCode;		yourself.	Tools.Note ISSUE.  " Can we drop this heap copy?  [DL 10-May-97] "	Assert isTrue: [ aVariant isSafeForExternalFunctionArgument ].   	aVariant copyToHeap.	^aVariant</body><body package="Com- Automation">createSafeArrayPutBufferFor: aSafeArray value: aValue	" Private - answer an element buffer suitable for the SafeArray put API	containing the value &lt;aValue&gt;. "	| aVariant |	aSafeArray isArrayOfVARIANT		ifTrue: [^self createSafeArrayPutBufferForVARIANT: aValue].	aSafeArray isArrayOfBSTR		ifTrue: [^self createSafeArrayPutBufferForBSTR: aValue].	aSafeArray isArrayOfDISPATCH		ifTrue: 			[^(aValue isCOMInterface and: [aValue isDispatch])				ifTrue: [aValue]				ifFalse: 					[ aValue dispatchInterface]].	aSafeArray isArrayOfUNKNOWN		ifTrue: 			[^(aValue isCOMInterface and: [aValue iid = IID_IUnknown])				ifTrue: [^aValue]				ifFalse: [aValue iUnknown]].	" None of the above means that the typeCode should be set because		we have a Safe Array of a VT basic type, like for example VT_BOOL or VT_I4. "	aSafeArray typeCode isNil		ifTrue: 			[COMError raiseSignal: #ErrSafeArrayTypeUnset &lt;&lt; #com						&gt;&gt; 'The Safe Array typeCode is not set.'].	aSafeArray isArrayOfDecimal ifTrue: [^COM_DECIMAL fromNumber: aValue].	aSafeArray isArrayOfStructs		ifTrue: 			[^aSafeArray				withRecordInfoDo: [:recInfo | aValue asCOMRecordSpecifiedBy: recInfo]].	aVariant := COMVariantValue typeDescription: aSafeArray typeDescription				value: aValue.	Tools.Note ISSUE.	" Can we drop this heap copy?  [DL 10-May-97] "	Assert isTrue: [aVariant isSafeForExternalFunctionArgument].	aVariant copyToHeap.	^aVariant</body><body package="Com- Automation">createSafeArrayPutBufferForBSTR: aValue	" Private - answer a newly allocated element buffer containing &lt;aValue&gt; as a BSTR. "	"Since a BSTR is a pointer, there is no need for an additional level of indirection.  We will pass the BSTR pointer directly to the API, without wrapping it in a VARIANT record."	^aValue isString		ifTrue: [External.BSTR allocateString: aValue]		ifFalse: [aValue]</body><body package="Com- Automation">createSafeArrayPutBufferForVARIANT: aValue	" Private - answer a newly allocated element buffer containing &lt;aValue&gt; as a VARIANT. "	^COM_VARIANT value: aValue</body><body package="Com- Automation">elementFromSafeArrayGetBuffer: elementBuffer for: aSafeArray	" Private - answer the value in the element buffer from the SafeArray get API. "	aSafeArray isArrayOfDISPATCH		ifTrue: [ 			^ (External.IDispatchPointer newResultInterfacePointerAtAddress: elementBuffer contents) asInterfaceReference ].	aSafeArray isArrayOfUNKNOWN		ifTrue: [ 			^ (External.IUnknownPointer newResultInterfacePointerAtAddress: elementBuffer contents) asInterfaceReference ].		aSafeArray isArrayOfStructs		ifTrue: [ ^ elementBuffer ].    " None of the above means that the typeCode should be set because    we have a Safe Array of a VT basic type, like for example VT_BOOL or VT_I4. "    ^elementBuffer value</body><body package="Com- Automation">releaseSafeArrayGetBuffer: elementBuffer for: aSafeArray	" Private - answer an element buffer suitable for the SafeArray get API. "	"Invalidate the elementBuffer structure for variant element buffers containing	 interfaces in order to avoid #release calls (in COM sense) caused by 	VariantClear [AA 08/2004]"	(aSafeArray isArrayOfVARIANT) ifTrue: [		"Finalization will release the variant"		^  self  ].	(aSafeArray isArrayOfStructs) ifTrue: [ 		^ self ].	( aSafeArray isArrayOfDISPATCH or: [aSafeArray isArrayOfUNKNOWN])		ifTrue: [ ^elementBuffer free  ].    elementBuffer enforceRelease.</body><body package="Com- Automation">releaseSafeArrayPutBuffer: elementBuffer for: aSafeArray originalValue: aValue	" Private - release any resources associated with the &lt;elementBuffer&gt;. 	  [AA 09/2004] need to release BSTR, since SafeArrayPutEllement copies the string."    aSafeArray isArrayOfBSTR ifTrue: [ 		(aValue == elementBuffer) ifTrue: [ ^ self ].		elementBuffer enforceRelease. 		^ self ].     ( aSafeArray isArrayOfDISPATCH     or: [ aSafeArray isArrayOfUNKNOWN ] )        ifTrue: [ ^self ].	Tools.Note portingISSUE. 	"Alex: we created a temporary variant, addRef was not called when storing an interface	 in the temporary variant but release would be called if we called automatically if we called	 ClearVariant. Maybe a better way would be to add the VT_BYREF flag to the variant but	 I think there might appear side effects when storing the interface in the safeArray or later	 when releasing the safeArray (it might not release the interface in this case)"	((aSafeArray isArrayOfVARIANT))		ifTrue: [ ^ self ].	" otherwise we have a basic value in a variant value buffer "	aSafeArray isArrayOfStructs ifTrue: [ 		  elementBuffer == aValue 				ifTrue: [ "No buffer has been created before as the 						value is already a COMRecord"						^ self ]				ifFalse: [ "We may not release the referenced memory as it is now 						  owned by the SafeArray"						 ^ elementBuffer enforceRelease ]].	elementBuffer enforceRelease.</body><body package="Com- Automation">safeArrayIndicesAsParameter: indices		" Private - answer the array of integer &lt;indices&gt; as a buffer		of LONG values. "	| indexBuffer indexPointer |	Tools.Note ISSUE.  " This needs to be reworked to use some suitable COMExternalInterface facility [DL 11-May-97] "	indexBuffer := Win32ExternalInterface current LONG gcMalloc: indices size.	indexPointer := indexBuffer copy.	indices do: [ :anIndex |		indexPointer contents: anIndex.		indexPointer increment ].	^indexBuffer</body><body package="Com- Automation">safeArrayStructureFromPointer: aPointer type: aType	"Private. Answer a COM SAFEARRAY structure based on &lt;aPointer&gt; answered from a COM API used to create Safe Arrays. Raise a COMError if the SAFEARRAY could not be allocated. The answer is marked as needing to be finalized." 	| aSafeArray |	aPointer isNull 		ifTrue: [^COMError raiseSignal: #ErrAllocFailed &lt;&lt; #com &gt;&gt; 'allocation failed' ].	aSafeArray := COMStructure 		createStructureNamed: #SAFEARRAY 		atAddress: (COMMemoryAddress fromPointer: aPointer).	aSafeArray 		typeDescription: aType;		needsFinalization.	^aSafeArray</body><body package="Com- Automation">safeArrayStructureFromPointer: aPointer typeCode: typeCode	"Private. Answer a COM SAFEARRAY structure based on &lt;aPointer&gt; answered from a COM API used to create Safe Arrays. Raise a COMError if the SAFEARRAY could not be allocated. The answer is marked as needing to be finalized." 	| aSafeArray |	aPointer isNull 		ifTrue: [^COMError raiseSignal: #ErrAllocFailed &lt;&lt; #com &gt;&gt; 'allocation failed' ].	aSafeArray := COMStructure 		createStructureNamed: #SAFEARRAY 		atAddress: (COMMemoryAddress fromPointer: aPointer).	aSafeArray 		typeCode: typeCode;		needsFinalization.	^aSafeArray</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-safe arrays</category><body package="Com- Automation">SafeArrayAccessData: safeArray _: resultReference		" Increment the lock count of the SAFEARRAY &lt;safeArray&gt; 		store the ExternalAddress of its data into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMMemoryAddress resultValueBuffer.	hresult := self invokeSafeArrayAccessData: safeArray asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Automation">SafeArrayAllocData: safeArray	"Allocate memory to store the data of the SAFEARRAY &lt;safeArray&gt;. 		&lt;safeArray&gt; must have been created by SafeArrayAllocDescriptor().		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeSafeArrayAllocData: safeArray asPointerParameter) asHRESULT</body><body package="Com- Automation">SafeArrayAllocDescriptor: cDims _: resultReference		" Allocate the memory for a new SAFEARRAY descriptor. 		The number of dimensions is given by &lt;cDims&gt;. 		Store the newly created SAFEARRAY into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult aSafeArray |	resultBuffer := COMStructure resultValuePointerBufferFor: #SAFEARRAY.	hresult := self invokeSafeArrayAllocDescriptor: cDims 		_: resultBuffer asPointerParameter.	aSafeArray := resultBuffer contents.	Assert isTrue: [ aSafeArray isInExternalMemory ].  " Have to leave it out there... "Tools.Note ISSUE.  " Believe the following will fail and that in fact it should - COM_SAFEARRAY itself		uses finalization and will clean things up, so this memory address should not		be separately marked for finalization [which it used to be?? which was thus a bug??!]		[Deb 14-May-97] "	Assert isTrue: [ aSafeArray structure hasFinalization ].	resultReference value: aSafeArray.	^hresult asHRESULT</body><body package="Com- Automation">SafeArrayAllocDescriptorEx: vt _: cDims _: resultReference		" Allocate the memory for a new SAFEARRAY descriptor. 		The number of dimensions is given by &lt;cDims&gt;. 		Store the newly created SAFEARRAY into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult aSafeArray |	resultBuffer := COMStructure resultValuePointerBufferFor: #SAFEARRAY.	hresult := self invokeSafeArrayAllocDescriptorEx: vt 		_: cDims 		_: resultBuffer asPointerParameter.	aSafeArray := resultBuffer contents.	Assert isTrue: [ aSafeArray isInExternalMemory ].  " Have to leave it out there... "Tools.Note ISSUE.  " Believe the following will fail and that in fact it should - COM_SAFEARRAY itself		uses finalization and will clean things up, so this memory address should not		be separately marked for finalization [which it used to be?? which was thus a bug??!]		[Deb 14-May-97] "	Assert isTrue: [ aSafeArray structure hasFinalization ].	resultReference value: aSafeArray.	^hresult asHRESULT</body><body package="Com- Automation">SafeArrayCopy: safeArray _: resultReference		" Create a new SAFEARRAY by copying the existing &lt;safeArray&gt;		and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult aSafeArray |	resultBuffer := COMStructure resultValuePointerBufferFor: #SAFEARRAY.	hresult := self invokeSafeArrayCopy: safeArray asPointerParameter 		_: resultBuffer asPointerParameter.	aSafeArray := resultBuffer contents.	Assert isTrue: [ aSafeArray isInExternalMemory ].  " Have to leave it out there... "Tools.Note ISSUE.  " Believe the following will fail and that in fact it should - COM_SAFEARRAY itself		uses finalization and will clean things up, so this memory address should not		be separately marked for finalization [which it used to be?? which was thus a bug??!]		[Deb 14-May-97] "	Assert isTrue: [ aSafeArray structure hasFinalization ].	resultReference value: aSafeArray.	^hresult asHRESULT</body><body package="Com- Automation">SafeArrayCreate: vt _: cDims _: bounds		" Answer a new SAFEARRAY whose type is &lt;vt&gt; with the 		number of dimensions &lt;cDims&gt;.  &lt;bounds&gt; is a packed array 		of SAFEARRAYBOUNDS that specifies the number of elements 		for each dimension.  Raise a COMError if the SAFEARRAY could not be allocated."    ^self safeArrayStructureFromPointer: ( self invokeSafeArrayCreate: vt 			_: cDims 			_: bounds asPointerParameter)		typeCode: vt</body><body package="Com- Automation">SafeArrayCreateEx: type _: cDims _: bounds _: pvExtra		" Answer a new SAFEARRAY whose type is &lt;vt&gt; with the 		number of dimensions &lt;cDims&gt;.  &lt;bounds&gt; is a packed array 		of SAFEARRAYBOUNDS that specifies the number of elements 		for each dimension.  Raise a COMError if the SAFEARRAY could not be allocated."    ^self safeArrayStructureFromPointer: ( self invokeSafeArrayCreateEx: type typecode			_: cDims 			_: bounds asPointerParameter			_: pvExtra asPointerParameter)		type: type</body><body package="Com- Automation">SafeArrayCreateVector: vt _: lLbound _: cElements		" Creates a one-dimensional array whose lower bound is always zero. A safe array created with SafeArrayCreateVector is a fixed size, so the constant FADF_FIXEDSIZE is always set. Raise a COMError if the SAFEARRAY could not be allocated."    ^self safeArrayStructureFromPointer: ( self invokeSafeArrayCreateVector: vt 			_: lLbound 			_: cElements )		typeCode: vt</body><body package="Com- Automation">SafeArrayDestroy: safeArray	"Destroys an existing array descriptor and all of the data in the array. If objects are stored in the array, Release is called on each object in the array. &lt;safeArray&gt; is an array descriptor created by SafeArrayCreate.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeSafeArrayDestroy: safeArray asPointerParameter) asHRESULT</body><body package="Com- Automation">SafeArrayDestroyData: safeArray	" Destroys all the data in a safe array. This function is typically used when freeing safe arrays that contain elements with data types other than variants. If objects are stored in the array, Release is called on each object in the array.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeSafeArrayDestroyData: safeArray asPointerParameter) asHRESULT</body><body package="Com- Automation">SafeArrayDestroyDescriptor: safeArray	" Destroys a descriptor of a safe array. This function is typically used to destroy the descriptor of a safe array that contains elements with data types other than variants. Destroying the array descriptor does not destroy the elements in the array. Before destroying the array descriptor, call SafeArrayDestroyData to free the elements.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeSafeArrayDestroyDescriptor: safeArray asPointerParameter)		asHRESULT</body><body package="Com- Automation">SafeArrayGetDim: safeArray		" Answer the number of dimensions in the SAFEARRAY &lt;safeArray&gt;. "	^self invokeSafeArrayGetDim: safeArray asPointerParameter</body><body package="Com- Automation">SafeArrayGetElement: aSafeArray _: indices _: resultReference		" Retrieve an element from the SAFEARRAY &lt;aSafeArray&gt;. 		The indices (one per dimension) that specify the desired element 		are in the packed array &lt;indices&gt;.  		If the element is an interface, the API calls AddRef on the interface before returning.		Raise an exception if an error occurs.  Answer the result code. "	| elementBuffer hresult |	elementBuffer := self createSafeArrayGetBufferFor: aSafeArray.	[	hresult := self invokeSafeArrayGetElement: aSafeArray asPointerParameter		_: ( self safeArrayIndicesAsParameter: indices ) 		_: elementBuffer asPointerParameter.	resultReference value: 		( self elementFromSafeArrayGetBuffer: elementBuffer for: aSafeArray ).	] ensure: [		self releaseSafeArrayGetBuffer: elementBuffer for: aSafeArray ].	^hresult asHRESULT</body><body package="Com- Automation">SafeArrayGetElementReference: aSafeArray _: indices _: resultReference 	" Retrieve an element from the SAFEARRAY &lt;aSafeArray&gt;. 		The indices (one per dimension) that specify the desired element 		are in the packed array &lt;indices&gt;.  		If the element is an interface, the API calls AddRef on the interface before returning.		Raise an exception if an error occurs.  Answer the result code. "	| pointer |	pointer := self safeArrayPtrOfIndex: aSafeArray index: indices.	resultReference 		value: (self createVariantReferenceOnSafeArrayElementPtr: pointer				type: aSafeArray typeDescription pointerType)</body><body package="Com- Automation">SafeArrayGetElemsize: safeArray		" Answer the size (in bytes) of an element in the SAFEARRAY &lt;safeArray&gt;. "	^self invokeSafeArrayGetElemsize: safeArray asPointerParameter</body><body package="Com- Automation">SafeArrayGetLBound: safeArray _: nDim _: resultReference		" Retrieve the lower bound of the &lt;nDim&gt; dimension of the SAFEARRAY 		&lt;safeArray&gt; and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #LONG.	hresult := self invokeSafeArrayGetLBound: safeArray asPointerParameter		_: nDim 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Automation">SafeArrayGetUBound: safeArray _: nDim _: resultReference		" Retrieve the upper bound of the &lt;nDim&gt; dimension of the SAFEARRAY 		&lt;safeArray&gt; and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #LONG.	hresult := self invokeSafeArrayGetUBound: safeArray asPointerParameter 		_: nDim 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Automation">SafeArrayLock: safeArray	" Increment the lock count of the SAFEARRAY &lt;safeArray&gt; 		and ensure that the data pointer is valid.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeSafeArrayLock: safeArray asPointerParameter) asHRESULT</body><body package="Com- Automation">SafeArrayPutElement: aSafeArray _: indices _: aValue	" Store the element &lt;aValue&gt; into the SAFEARRAY &lt;aSafeArray&gt;. 		The indices (one per dimension) that specify the desired element are 		in the packed array &lt;indices&gt;. 		Raise an exception if an error occurs.  Answer the result code. "	| elementBuffer hresult |	elementBuffer := self createSafeArrayPutBufferFor: aSafeArray value: aValue.	^	[hresult := self				invokeSafeArrayPutElement: aSafeArray asPointerParameter				_: (self safeArrayIndicesAsParameter: indices)				_: elementBuffer asPointerParameter.	hresult asHRESULT]			ensure: 				[self					releaseSafeArrayPutBuffer: elementBuffer					for: aSafeArray					originalValue: aValue]</body><body package="Com- Automation">SafeArrayRedim: safeArray _: bounds	" Change the least-significant dimension of the SAFEARRAY &lt;safeArray&gt;. 		The packed array &lt;bounds&gt; specifies the new dimensions. 		Only the final element of &lt;bounds&gt; may be different that the existing bounds.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeSafeArrayRedim: safeArray asPointerParameter		_: bounds asPointerParameter) asHRESULT</body><body package="Com- Automation">SafeArraySetRecordInfo: aSafeArray _: aRecordInfo	^(self invokeSafeArraySetRecordInfo: aSafeArray asPointerParameter		_: aRecordInfo asPointerParameter) asHRESULT</body><body package="Com- Automation">SafeArrayUnaccessData: safeArray	" Decrement the lock count of the SAFEARRAY &lt;safeArray&gt; 		and invalidate the pointer returned by SafeArrayAccessData.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeSafeArrayUnaccessData: safeArray asPointerParameter)		asHRESULT</body><body package="Com- Automation">SafeArrayUnlock: safeArray	" Decrement the lock count of the SAFEARRAY &lt;safeArray&gt; 		so that it can be freed or redimensioned.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeSafeArrayUnlock: safeArray asPointerParameter) asHRESULT</body><body package="Com- Automation">safeArrayGetRecordInfo: aSafeArray	| resultBuffer |	resultBuffer := IRecordInfoPointer resultValueBuffer.	^ (self invokeSafeArrayGetRecordInfo: aSafeArray asPointerParameter _: resultBuffer asPointerParameter) = S_OK		ifTrue: 	[ resultBuffer contents asInterfaceReference ]		ifFalse: 	[  nil ].</body><body package="Com- Automation">safeArrayPtrOfIndex: aSafeArray index: indices	| ppvData result |	ppvData := CVoidType void pointerType gcMalloc.	result := (self				invokeSafeArrayPtrOfIndex: aSafeArray asPointerParameter				index: (self safeArrayIndicesAsParameter: indices)				buffer: ppvData) asHRESULT.	^result = S_OK		ifTrue: [ppvData contents]		ifFalse: [COMError hresult: result]</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-type libraries</category><body package="Com- Automation">LHashValOfNameSys: syskind _: lcid _: szName	" Answer a hash value for a name which can be used	with the ITypeComp bind operations or ITypeLib::IsName. "	^self invokeLHashValOfNameSys: syskind 		_: lcid 		_: szName asUnicodeParameter</body><body package="Com- Automation">LoadRegTypeLib: guid _: verMajor _: verMinor _: lcid _: resultReference        " Load the registered type library in the key named &lt;guid&gt;.        Obtain its ITypeLib interface and store it into &lt;resultReference&gt;.        Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeLibPointer resultValueBuffer.	hresult := self invokeLoadRegTypeLib: guid		_: verMajor		_: verMinor		_: lcid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Automation">LoadTypeLib: aString _: resultReference		" Load and register the type library in the file named &lt;aString&gt;.		Obtain its ITypeLib interface and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeLibPointer resultValueBuffer.	hresult := self invokeLoadTypeLib: aString asUnicodeParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Automation">LoadTypeLibEx: aString _: regkind _: resultReference		" Loads a type library &lt;aString&gt; and (optionally through the REGKIND argument) registers it in the system registry.		Obtain its ITypeLib interface and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ITypeLibPointer resultValueBuffer.	hresult := self invokeLoadTypeLibEx: aString asUnicodeParameter		_: regkind		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Automation">QueryPathOfRegTypeLib: guid _: verMajor _: verMinor _: lcid _: pathNameReference 	" Get the path name of registered type library for the key named &lt;guid&gt;.        Obtain its path name and store it into &lt;pathNameReference&gt;.        Raise an exception if an error occurs.  Answer the result code. "	| hresult pathNameBSTR |	pathNameBSTR := External.BSTR resultValueBuffer.	hresult := self 				invokeQueryPathOfRegTypeLib: guid				_: verMajor				_: verMinor				_: lcid				_: pathNameBSTR asPointerParameter.	pathNameReference value: pathNameBSTR contents.	^hresult asHRESULT</body><body package="Com- Automation">RegisterTypeLibForUser: anITypeLib _: szFullPath _: szHelpDir	"Adds information about a type library to the system registry for the current user. Answer the result code. "	^(self		invokeRegisterTypeLibForUser: anITypeLib asPointerParameter		_: szFullPath asUnicodeParameter		_: szHelpDir asUnicodeParameter) asHRESULT</body><body package="Com- Automation">RegisterTypeLibrary: anITypeLib _: szFullPath _: szHelpDir	"Adds information about a type library to the system registry. Answer the result code. "	"&lt;anITypeLib&gt;:	Pointer to the type library being registered. &lt;szFullPath &gt;:	Fully qualified path specification for the type library being registered. &lt;szHelpDir &gt;:	Directory in which the Help file for the library being registered can be found. Can be Null. The function RegisterTypeLib can be used during application initialization to register the application's type library correctly. In addition to filling in a complete registry entry under the type library key, RegisterTypeLib adds entries for each of the dispinterfaces and Automation-compatible interfaces, including dual interfaces. This information is required to create instances of these interfaces. Coclasses are not registered (that is, RegisterTypeLib does not write any values to the CLSID key of the coclass). "	^(self		invokeRegisterTypeLibrary: anITypeLib asPointerParameter		_: szFullPath asUnicodeParameter		_: szHelpDir asUnicodeParameter) asHRESULT</body><body package="Com- Automation">UnRegisterTypeLibrary: libID _: wVerMajor _: wVerMinor _: lcid _: syskind	"Removes type library information from the system registry. Use this API to allow applications to properly uninstall themselves. In-process objects typically call this API from DllUnregisterServer. Raise an exception if an error occurs. No exception is raised when the library is not found (TYPE_E_REGISTRYACCESS, TYPE_E_CANTLOADLIBRARY).  Answer the result code. "	^(self		invokeUnRegisterTypeLibrary: libID		_: wVerMajor		_: wVerMinor		_: lcid		_: syskind) asHRESULT</body><body package="Com- Automation">getRecordInfoFromGuids: rGuidTypeLib _: uVerMajor _: uVerMinor _: lcid _: rGuidTypeInfo	| ppRecInfo result |	ppRecInfo := IRecordInfoPointer resultValueBuffer.	result := (self				invokeGetRecordInfoFromGuids: rGuidTypeLib asPointerParameter				_: uVerMajor				_: uVerMinor				_: lcid				_: rGuidTypeInfo asPointerParameter				_: ppRecInfo asPointerParameter) asHRESULT.	result = S_OK ifTrue: [^ppRecInfo contents]</body><body package="Com- Automation">getRecordInfoFromGuids: rGuidTypeLib _: uVerMajor _: uVerMinor _: lcid _: rGuidTypeInfo _: resultReference	| ppRecInfo result |	ppRecInfo := IRecordInfoPointer resultValueBuffer.	result := (self				invokeGetRecordInfoFromGuids: rGuidTypeLib asPointerParameter				_: uVerMajor				_: uVerMinor				_: lcid				_: rGuidTypeInfo asPointerParameter				_: ppRecInfo asPointerParameter) asHRESULT.	result = S_OK ifTrue: [resultReference value: ppRecInfo contents]</body><body package="Com- Automation">getRecordInfoFromTypeInfo: pTypeInfo	| ppRecInfo result |	ppRecInfo := IRecordInfoPointer resultValueBuffer.	result := (self				invokeGetRecordInfoFromTypeInfo: pTypeInfo asPointerParameter				_: ppRecInfo asPointerParameter) asHRESULT.	result = S_OK ifTrue: [^ppRecInfo contents asInterfaceReference]</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-BSTR</category><body package="Com- Automation">SysAllocString: aString        " Allocate a BSTR in external memory and copy the characters 		of &lt;aString&gt; into it.  Answer the address of the BSTR copy 		in external memory. "    | bstr |    bstr := self invokeSysAllocString: aString asUnicodeParameter.    bstr isNull 		ifTrue: [ ^COMError raiseSignal: #ErrAllocFailed &lt;&lt; #com &gt;&gt; 'allocation failed' ].    ^( BSTRMemoryAddress fromPointer: bstr )        needsFinalization;        yourself</body><body package="Com- Automation">SysAllocStringLen: size        " Allocate a BSTR in external memory and copy the characters 		of &lt;aString&gt; into it.  Answer the address of the BSTR copy 		in external memory. "    | bstr |    bstr := self invokeSysAllocString: nil len: size.    bstr isNull 		ifTrue: [ ^COMError raiseSignal: #ErrAllocFailed &lt;&lt; #com &gt;&gt; 'allocation failed' ].    ^( BSTRMemoryAddress fromPointer: bstr )        needsFinalization;        yourself</body><body package="Com- Automation">SysFreeString: aBstr		" Free a BSTR string previously allocated by a BSTR API service. "	^self invokeSysFreeString: aBstr asPointerParameter</body><body package="Com- Automation">SysReAllocString: aBSTR _: aString	"Allocates a new BSTR and copies the passed string into it, then frees the BSTR referenced by &lt;aBSTR&gt;, and finally resets &lt;aBSTR&gt; to point to the new BSTR."	| resultBuffer hresult |	resultBuffer := BSTR baseCType malloc.	[	resultBuffer contents: aBSTR asPointerParameter.Tools.Note ISSUE.  " Header file declares INT return, *NOT* HRESULT.  Resolve and do something suitable to the following. [DL/GG 31-Mar-97] "	hresult := self invokeSysReAllocString: resultBuffer		_: aString asUnicodeParameter.Tools.Note ISSUE.  " Need to figure out exactly how to suck the bits back. ""DEBUG" self halt.	"???? aBSTR structure pointer datum: resultBuffer contents.  ???"	] ensure: [		resultBuffer free ].	^hresult asHRESULT</body><body package="Com- Automation">SysStringLen: aBstr		" Answer the length in characters of a BSTR string 		previously allocated by a BSTR API service. "	^self invokeSysStringLen: aBstr asPointerParameter</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-time</category><body package="Com- Automation">DosDateTimeToVariantTime: aDate	_: aTime	_: resultReference	" Convert the date/time value &lt;aDate&gt; and &lt;aTime&gt; to the double representation in which time values are stored in variant structures.  Store the variante encoding into &lt;resultReference&gt;.  Answer whether successful. "	| resultBuffer statusCode |	resultBuffer := COMExternalInterface scalarResultBufferFor: Double baseCType.	statusCode := self invokeDosDateTimeToVariantTime: ( COMExternalInterface dosDateFromDate: aDate )		_: ( COMExternalInterface dosTimeFromTime: aTime )		_: resultBuffer asPointerParameter.	statusCode = TRUE 		ifFalse: [ COMError raiseSignal: #ErrConversion &lt;&lt; #com &gt;&gt; 'Conversion error.' ].	resultReference value: resultBuffer contents.	^statusCode</body><body package="Com- Automation">SystemTimeToVariantTime: aTimestamp	_: resultReference	" Convert the date/time value &lt;aTimestamp&gt; to it's double representation.  Store the double encoding into &lt;resultReference&gt;.  Answer whether successful. "	| resultBuffer statusCode aSystemTime |	resultBuffer := COMExternalInterface scalarResultBufferFor: Double baseCType.	aSystemTime := Win32_SYSTEMTIME fromTimestamp: aTimestamp.	statusCode := self invokeSystemTimeToVariantTime: aSystemTime asPointerParameter		_: resultBuffer asPointerParameter.	statusCode = TRUE 		ifFalse: [ COMError raiseSignal: 'Conversion error.' ].	resultReference value: resultBuffer contents.	^statusCode = TRUE</body><body package="Com- Automation">VariantTimeToDosDateTime: variantTime	_: resultReferenceDosDate	_: resultReferenceDosTime    "Convert the variant representation of a date and time to MS-DOS data and time values. Answer whether successful.A variant time is stored as an 8-byte real value (double), representing a date between January 1, 1753 and December 31, 2078, inclusive. The value 2.0 represents January 1, 1900; 3.0 represents January 2, 1900, and so on. Adding 1 to the value increments the date by a day. The fractional part of the value represents the time of day. Therefore, 2.5 represents noon on January 1, 1900; 3.25 represents 6:00 a.m. on January 2, 1900, and so on. Negative numbers represent the dates prior to December 30, 1899."	| dosDateBuffer dosTimeBuffer statusCode |	dosDateBuffer := COMExternalInterface scalarResultBufferFor: CIntegerType unsignedShort.	dosTimeBuffer := COMExternalInterface scalarResultBufferFor: CIntegerType unsignedShort.	statusCode := self invokeVariantTimeToDosDateTime: variantTime		_: dosDateBuffer asPointerParameter		_: dosTimeBuffer asPointerParameter.	statusCode = TRUE 		ifFalse: [ COMError raiseSignal: #ErrConversion &lt;&lt; #com &gt;&gt; 'Conversion error.' ].	resultReferenceDosDate value: 		( COMExternalInterface dateFromDosDate: dosDateBuffer contents ).	resultReferenceDosTime value: 		( COMExternalInterface timeFromDosTime: dosTimeBuffer contents ).	^statusCode = TRUE</body><body package="Com- Automation">VariantTimeToSystemTime: variantTime	_: resultReferenceSystemTime    "Convert the variant representation of a date and time to SYSTEMTIME date and time values. Answer whether successful.A variant time is stored as an 8-byte real value (double), representing a date between January 1, 1753 and December 31, 2078, inclusive. The value 2.0 represents January 1, 1900; 3.0 represents January 2, 1900, and so on. Adding 1 to the value increments the date by a day. The fractional part of the value represents the time of day. Therefore, 2.5 represents noon on January 1, 1900; 3.25 represents 6:00 a.m. on January 2, 1900, and so on. Negative numbers represent the dates prior to December 30, 1899.Using the SYSTEMTIME structure is useful because: 1) It spans all time/date periods. MS-DOS date/time is limited to representing only those dates between 1/1/1980 and 12/31/2107. 2) The date/time elements are all easily accessible without needing to do any bit decoding. 3) The National Language Support data and time formatting functions GetDateFormat and GetTimeFormat take a SYSTEMTIME value as input. 4) It is the default Win32 time and date data format supported by Windows NT and Windows 95. "	| systemTimeBuffer statusCode |	systemTimeBuffer := Win32_SYSTEMTIME resultValueBuffer.	statusCode := self invokeVariantTimeToSystemTime: variantTime		_: systemTimeBuffer asPointerParameter.	statusCode = TRUE 		ifFalse: [ COMError raiseSignal: 'Conversion error.' ].	resultReferenceSystemTime value: systemTimeBuffer contents.	^statusCode = TRUE</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>private - safe arrays</category><body package="Com- Automation">createVariantReferenceOnSafeArrayElementPtr: aPointer type: aType	^ SpecialVariantArg typeDescription: aType pointer: aPointer.</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-variants</category><body package="Com- Automation">VariantChangeType: pvargDest _: pvargSrc _: wFlags _: vt	" Coerce the type of the source variant &lt;pvargSrc&gt; to the		new type specified by the VARTYPE code &lt;vt&gt; and store		the result into &lt;pvargDest&gt;.  The flags which control the type coercion		are specified by &lt;wFlags&gt;, which may be 0 or VARIANT_NOVALUEPROP. 		Source and destination may be identical for in-place type conversion.		Raise an exception if an error occurs.  Answer the result code. "	COMExternalInterface checkInOutStructureParameter: pvargDest.	" pvargSrc is converted in-place if pvargDest is the same			as the source.  However, preceding check ensures			that the modified structure is indeed in external memory			in this case, so we can safely treat pvargSrc as 			a #structIn arg at this point. "	^(self		invokeVariantChangeType: pvargDest asPointerParameter		_: pvargSrc asPointerParameter		_: wFlags		_: vt) asHRESULT</body><body package="Com- Automation">VariantChangeTypeEx: pvargDest _: pvargSrc _: lcid _: wFlags _: vt	" Coerce the type of the source variant &lt;pvargSrc&gt; to the		new type specified by the VARTYPE code &lt;vt&gt; and store		the result into &lt;pvargDest&gt;.  The flags which control the type coercion		are specified by &lt;wFlags&gt;, which may be 0 or VARIANT_NOVALUEPROP. 		Source and destination may be identical for in-place type conversion.		&lt;lcid&gt; is the local identifier that is used to control conversion to 		locale-specific types such as strings.		Raise an exception if an error occurs.  Answer the result code. "	COMExternalInterface checkInOutStructureParameter: pvargDest.	" pvargSrc is converted in-place if pvargDest is the same			as the source.  However, preceding check ensures			that the modified structure is indeed in external memory			in this case, so we can safely treat pvargSrc as 			a #structIn arg at this point. "	^(self		invokeVariantChangeTypeEx: pvargDest asPointerParameter		_: pvargSrc asPointerParameter		_: lcid		_: wFlags		_: vt) asHRESULT</body><body package="Com- Automation">VariantClear: aVariant	" Clear the contents of &lt;aVariant&gt; before its memory is released. 		Raise an exception if an error occurs.  Answer the result code. "	COMExternalInterface checkInOutStructureParameter: aVariant.	^(self invokeVariantClear: aVariant asPointerParameter) asHRESULT</body><body package="Com- Automation">VariantCopy: pvargDest _: argSrc	" Copy the contents of  the VARIANT &lt;argSrc&gt; to the		destination VARIANT &lt;pvargDest&gt;, which is first cleared.		Raise an exception if an error occurs.  Answer the result code. "	COMExternalInterface checkInOutStructureParameter: pvargDest.	^(self invokeVariantCopy: pvargDest asPointerParameter		_: argSrc asPointerParameter) asHRESULT</body><body package="Com- Automation">VariantCopyInd: pvarDest _: argSrc	" Copy the contents of the source VARIANT &lt;pvargSrc&gt; into 		the destination VARIANT &lt;pvarDest&gt;, which is first cleared.		If the source variant is VT_BYREF then dereference the contents 		to guarantee that the result is not VT_BYREF.		Raise an exception if an error occurs.  Answer the result code. "	COMExternalInterface checkInOutStructureParameter: pvarDest.	^(self invokeVariantCopyInd: pvarDest asPointerParameter		_: argSrc asPointerParameter) asHRESULT</body><body package="Com- Automation">VariantInit: aVariant	" Initialize a new VARIANT by setting its type to VT_EMPTY		and clearing its wReserved field to 0. "	COMExternalInterface checkInOutStructureParameter: aVariant.	^self invokeVariantInit: aVariant asPointerParameter</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-pictures</category><body package="Com- Automation">OleCreatePictureIndirect: lpPictDesc iid: iid owned: fOwn	| buffer hresult |	buffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := (self				invokeOleCreatePictureIndirect: lpPictDesc				iid: iid asPointerParameter				owned: fOwn				result: buffer asPointerParameter) asHRESULT.	^hresult succeeded		ifTrue: [buffer contents asInterfaceReference]		ifFalse: [COMError raiseSignal: hresult]</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-VARTYPE conversions</category><body package="Com- Automation">VarBstrFromCy: cyIn lcid: lcid flags: dwFlags result: result	| pbstrOut hresult |	pbstrOut := External.BSTR resultValueBuffer.	hresult := (self				invokeVarBstrFromCy: cyIn				_: lcid				_: dwFlags				_: pbstrOut asPointerParameter) asHRESULT.	hresult succeeded		ifTrue: [result value: pbstrOut contents]		ifFalse: [pbstrOut release].	^hresult</body><body package="Com- Automation">VarCyFromStr: aString lcid: lcid flags: dwFlags result: resultReference	| pcyOut hresult pString |	pcyOut := External.COM_CY resultValueBuffer.	"disable automatical unmarshaling"	pcyOut valueConstructionAction: nil.	pString := External.BSTR allocateString: aString.	hresult := (self				invokeVarCyFromStr: pString asPointerParameter				_: lcid				_: dwFlags				_: pcyOut asPointerParameter) asHRESULT.	hresult succeeded		ifTrue: [resultReference value: pcyOut contents]		ifFalse: [COMError hresult: hresult].	^hresult</body><body package="Com- Automation">VarR4FromR8: dblIn _: resultReference		" Convert the 8-byte floating point value &lt;dblin&gt; which corresponds to 		the C type #double to a 4-byte array which represents the value as the C type #float.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface scalarResultBufferFor: CLimitedPrecisionRealType float.	hresult := self invokeVarR4FromR8: dblIn		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Automation">VarR8FromR4: fltIn _: resultReference		" Convert the the 4-byte value &lt;fltIn&gt;, which represents the value as the C type #float,		to a Float which represents the C type #double.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface scalarResultBufferFor: CLimitedPrecisionRealType double.	hresult := self invokeVarR8FromR4: fltIn		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-active object registration</category><body package="Com- Automation">GetActiveObject: clsid _: reserved _: resultReference	" Get the active object of the class specified by the GUID &lt;clsid&gt;.		Obtain its IUnknown interface and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IUnknownPointer resultValueBuffer.	hresult := self				invokeGetActiveObject: clsid				_: reserved asPointerParameter				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Automation">RegisterActiveObject: anIUnknown _: clsid _: dwFlags _: resultReference		" Register the object &lt;anIUnknown&gt; with OLE as an active		object of the class specified by the GUID &lt;clsid&gt;.		Store the registration token into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #DWORD.	hresult := self invokeRegisterActiveObject: anIUnknown asPointerParameter 		_: clsid		_: dwFlags 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Automation">RevokeActiveObject: registrationToken _: reserved	" Revoke the registration of an active object, using		the &lt;registrationToken&gt; obtained from RegisterActiveObject.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeRevokeActiveObject: registrationToken		_: reserved asPointerParameter) asHRESULT</body></methods><methods><class-id>External.OLEAutomationDLL</class-id> <category>API operations-fonts</category><body package="Com- Automation">OleCreateFontIndirect: fontDesc iid: iid	| buffer hresult |	buffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := (self				invokeOleCreateFontIndirect: fontDesc asPointerParameter				iid: iid				result: buffer asPointerParameter) asHRESULT.	^hresult succeeded		ifTrue: [buffer contents asInterfaceReference]		ifFalse: [COMError raiseSignal: hresult]</body></methods><methods><class-id>External.OLEAutomationDLL class</class-id> <category>subclass-initialization</category><body package="Com- Automation">getCurrent        "Private - get (open) an instance of the receiver."	OLEDLL current.  " ensure the OLE is loaded and initialized "	^super getCurrent</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>accessing</category><body package="Com- Automation">basicEnumConstantNamed: aName	^self cachedConstants at: aName asSymbol		ifAbsent: 			[(self computeEnumConstantNamed: aName)				ifNotNil: 					[:constant |					self cachedConstants at: aName asSymbol put: constant.					constant]]</body><body package="Com- Automation">basicEnumConstantNamed: aName inTypeNamed: aTypeName	^(self basicTypeNamed: aTypeName)		ifNotNil: 			[:type |			type constantNamed: aName				ifAbsent: 					[self error: #EnumDoesNotContainConstant &lt;&lt; #com								&gt;&gt; 'The specified enumeration does not contain the constant']]</body><body package="Com- Automation">basicTypeNamed: aName	^self types at: aName asSymbol		ifAbsent: [self withTypeLibDo: [:lib | lib basicTypeNamed: aName]]</body><body package="Com- Automation">cachedConstants	^cache ifNil: [ cache := IdentityDictionary new ]</body><body package="Com- Automation">containedTypeDescriptions	"Return descriptions of all contained types"	| collection |	collection := OrderedCollection new.	self containedTypeDescriptionsDo: [:typeDesc |		collection add: typeDesc ].	^ collection</body><body package="Com- Automation">docs	| iTypeLib |	^docs ifNil: 			[docs := self withTypeLibDo: 							[:aComTypeLib | 							aComTypeLib ifNil: [ Dictionary new]								ifNotNil: 									[iTypeLib := aComTypeLib typeLib.									iTypeLib getDocumentation]]]</body><body package="Com- Automation">docs: anObject	docs := anObject</body><body package="Com- Automation">enumConstantNamed: aName	^self cachedConstants at: aName asSymbol		ifAbsent: 			[(self computeEnumConstantNamed: aName)				ifNil: [COMTypeLibrary enumConstantNamed: aName ]				ifNotNil: 					[:constant |					self cachedConstants at: aName asSymbol put: constant.					constant]]</body><body package="Com- Automation">enumConstantNamed: aName inTypeNamed: aTypeName	^(self typeNamed: aTypeName)		ifNil: [COMTypeLibrary enumConstantNamed: aName inTypeNamed: aTypeName]		ifNotNil: [:type | type constantNamed: aName ifAbsent: [nil]]</body><body package="Com- Automation">filename	^filename</body><body package="Com- Automation">filename: anObject	filename := anObject</body><body package="Com- Automation">fullName		^self name</body><body package="Com- Automation">guid	^guid</body><body package="Com- Automation">guid: anObject	guid := anObject</body><body package="Com- Automation">guidForName: aName	^ (self typeNamed: aName) ifNotNil: [:type | type guid ]</body><body package="Com- Automation">helpContextId	^ self docs at: 'helpContextID' ifAbsent: [ nil ]</body><body package="Com- Automation">helpFile	^ self docs at: 'helpFile' ifAbsent: [ nil]</body><body package="Com- Automation">lcid	^ lcid</body><body package="Com- Automation">lcid: aNumber	lcid := aNumber.</body><body package="Com- Automation">locale	^ WindowsLocale withID: self lcid</body><body package="Com- Automation">majorVersion	^self versionTokens		ifNil: [nil]		ifNotNil: [:tokens | Number readFromString: tokens first]</body><body package="Com- Automation">minorVersion	^self versionTokens		ifNil: [nil]		ifNotNil: [:tokens | Number readFromString: (tokens at: 2)]</body><body package="Com- Automation">name	^name</body><body package="Com- Automation">name: anObject	name := anObject</body><body package="Com- Automation">platform	^platform</body><body package="Com- Automation">platform: anObject	platform := anObject asSymbol</body><body package="Com- Automation">qualityRatingForCurrentSystem	^ self majorVersion * 10 + self minorVersion.</body><body package="Com- Automation">safeName	^ self name ifNil: [ 'unnamed' ]</body><body package="Com- Automation">shortName	^ self docs at: 'name' ifAbsent: [ nil ]</body><body package="Com- Automation">syskind: aSystemIdentifier	self platform: (self class platformNameFor: aSystemIdentifier).</body><body package="Com- Automation">typeDescriptionForTypeInfo: typeInfo ifAbsentPut: aBlock	| res key |	key := typeInfo getDocumentationName asSymbol.	res := self types at: key ifAbsent: [^self types at: key put: aBlock value].	^res typekind = typeInfo typekind		ifTrue: [res]		ifFalse: [self types at: key put: aBlock value]</body><body package="Com- Automation">typeForGUID: aGUID	^self types detect: [:each | each guid = aGUID]		ifNone: [self withTypeLibDo: [:lib | lib typeForGUID: aGUID]]</body><body package="Com- Automation">typeNamed: aName	^self types at: aName asSymbol		ifAbsent: [self withTypeLibDo: [:lib | lib typeNamed: aName]]</body><body package="Com- Automation">types	^ types ifNil: [ types := WeakDictionary new ]</body><body package="Com- Automation">version	^version</body><body package="Com- Automation">version: anObject	version := anObject</body><body package="Com- Automation">versionTokens	^self version ifNil: [nil] ifNotNil: [:v | v tokensBasedOn: $.]</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>comparing</category><body package="Com- Automation">= aTypeLibDescriptor	^ aTypeLibDescriptor class = self class and: [	  aTypeLibDescriptor guid = self guid and: [	  aTypeLibDescriptor lcid = self lcid and: [	  aTypeLibDescriptor version = self version and: [	  aTypeLibDescriptor platform = self platform  ]]]]</body><body package="Com- Automation">hash	^ self guid hash</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	aStream nextPutAll: (self name ifNil: ['unnamed' ]),' ',self version, ' (',self locale name,')'</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>enumerating</category><body package="Com- Automation">containedTypeDescriptionsDo: aBlock	"enumerate over the type descriptions of all contained types"	self containedTypeInfosDo: [:typeInfo |		aBlock value: (DispUserDefTypeSpec fromTypeInfo: typeInfo typeLibDescription: self)		].</body><body package="Com- Automation">containedTypeInfosDo: aBlock 	"Return descriptions of all contained types"	^(self withTypeLibDo: 			[:comTypeLib | 			[comTypeLib typeLib keysAndValuesDo: [:index :each | aBlock value: each]] 				on: Error				do: [:ex | ex return]])</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>converting</category><body package="Com- Automation">asTypeLib	self registeredTypeLib ifNotNil: [:lib | ^lib].	self typeLibForFile ifNotNil: [:lib | ^lib].	^ self error: #CanNotFindTypeLib &lt;&lt; #com &gt;&gt; 'Can not find type library'</body><body package="Com- Automation">registeredTypeLib	self guid ifNil: [^nil].	^(COMTypeLibrary new)		libraryID: self guid;		lcid: self lcid;		majorVersion: self majorVersion;		minorVersion: self minorVersion;		yourself</body><body package="Com- Automation">typeLibForFile	| file aFile |	aFile := self filename ifNil: [^nil].	file := [aFile asFilename] on: Error do: [:ex | ^ nil].	(COMTypeLibrary new)		fileName: file tail;		directoryName: file head;		yourself</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>private computing</category><body package="Com- Automation">computeEnumConstantNamed: aName	self types do: 			[:type |			type isEnumType				ifTrue: 					[(type constantNamed: aName asSymbol ifAbsent: [nil])						ifNotNil: [:constant | ^constant]]].	self containedTypeDescriptionsDo: 			[:type |			type isEnumType				ifTrue: 					[(type constantNamed: aName asSymbol ifAbsent: [nil])						ifNotNil: [:constant | ^constant]]].	^ nil</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>tools</category><body package="Com- Automation">withTypeLibDo: aBlock	^self asTypeLib		ifNotNil: 			[:typeLib |			typeLib existsInSystem				ifTrue: [[aBlock value: typeLib] ensure: [typeLib enforceRelease]]]</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>literal array encoding</category><body package="Com- Automation">literalArrayEncoding	^LiteralArrayEncoder encode: self</body><body package="Com- Automation">literallyEncodedAttributes	^self guid		ifNil: [self class literallyEncodedAttributes copyWith: #filename]		ifNotNil: [self class literallyEncodedAttributes copyWith: #guid]</body></methods><methods><class-id>External.TypeLibDescriptor</class-id> <category>testing</category><body package="Com- Automation">matchesCurrentPlatform	OSHandle currentOS = #win32 ifFalse: [^false].	ObjectMemory is64Bit		ifTrue: [self platform = #win64 ifTrue: [^true]]		ifFalse: [self platform = #win32 ifTrue: [^true]].	^self serverIsOutOfProcess and: [#(#win32 #win64) includes: self platform]</body><body package="Com- Automation">serverIsOutOfProcess	^[self filename asFilename extension equivalentTo: '.exe' ignoreCase: true]		on: Error		do: [:ex | ex return: false]</body></methods><methods><class-id>External.TypeLibDescriptor class</class-id> <category>utils</category><body package="Com- Automation">platformNameFor: sysKind	sysKind = SYS_WIN32  ifTrue:  [^ #win32 ]. 	sysKind = SYS_WIN64  ifTrue:  [^ #win64 ]. 	sysKind = SYS_WIN16  ifTrue:  [^ #win16 ]. 	sysKind = SYS_MAC  ifTrue:  [^ #mac ]. 	^ self error: (#UnknownPlatformIdentifier &lt;&lt; #com &gt;&gt; 'Unknow platform identifier').</body></methods><methods><class-id>External.TypeLibDescriptor class</class-id> <category>instance creation</category><body package="Com- Automation">forGuid: aGuid version: aString	"This version will create a new instance without looking at the cache"		^ self new		guid: aGuid;		version: aString;		lcid: 0;		yourself</body><body package="Com- Automation">forGuid: aGuid version: aString lcid: lcid	"This version will create a new instance without looking at the cache"		^ self new		guid: aGuid;		version: aString;		lcid: lcid;		yourself</body><body package="Com- Automation">forInterfaceId: anIID	"This methods retu"	| interfaces itf typeLibEntry |	interfaces := (COMRegistryInterface classesRegistry at: 'Interface').	itf := interfaces at: anIID asString ifAbsent: [ ^nil ].	typeLibEntry := itf at: 'TypeLib' ifAbsent: [ ^ nil].	^ self forGuid: (typeLibEntry value) version: (typeLibEntry namedValueAt: 'Version' ifAbsent: [ nil ])</body><body package="Com- Automation">fromITypeLib: anITypeLib	"This instance creation method will look into the cache before creating a new instance"		^anITypeLib		withLibAttrDo:			[:attr | 			self knownTypeLibs				at:					(COMRegistryInterface						keyForGuid: attr guid						lcid: attr lcid						platform: (self platformNameFor: attr systemIdentifier)						version:							attr majorVersion printString , '.' , attr minorVersion printString)				ifAbsentPut:					[(self new)						guid: attr guid;						lcid: attr lcid;						name: anITypeLib getDocumentationName;						version:								attr majorVersion printString , '.' , attr minorVersion printString;						syskind: attr systemIdentifier;						filename: anITypeLib path]]</body></methods><methods><class-id>External.TypeLibDescriptor class</class-id> <category>literal array encoding</category><body package="Com- Automation">decodeFromLiteralArray: anArray	^ LiteralArrayEncoder decode: anArray</body><body package="Com- Automation">literallyEncodedAttributes	^#(#lcid #name #platform #version)</body></methods><methods><class-id>External.TypeLibDescriptor class</class-id> <category>private</category><body package="Com- Automation">knownTypeLibs	^ COMRegistryInterface extTypeLibraryIDMap</body></methods><methods><class-id>External.COMVariantResultBuffer</class-id> <category>accessing</category><body package="Com- Automation">extractContentsAsValue	" Extract the contents of the buffer as the value of the variant. "	self valueConstructionAction: #getValue: .</body><body package="Com- Automation">extractContentsAsVariant	" Extract the contents of the buffer as the variant structure itself. "	self valueConstructionAction: nil.</body></methods><methods><class-id>External.COMVariantResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Automation">applyValueConstructionActionTo: aValue	" Private "	valueConstructionAction = #getValue:		ifTrue: [ 			"We actually apply this during the buffer release: ^self getValue: aValue"			^aValue ].	^super applyValueConstructionActionTo: aValue</body><body package="Com- Automation">getValue: aCOMVariant	" Private - the standard value construction action is to extract the value. "	| aValue |	aValue := aCOMVariant value.	^ aValue</body></methods><methods><class-id>External.COMVariantResultBuffer</class-id> <category>subclass-initialization</category><body package="Com- Automation">initialize	" Private - initialize a new instance. "	self extractContentsAsValue.	super initialize.</body></methods><methods><class-id>External.COMVariantResultBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Automation">releaseBufferContents	" Private - release the contents of the buffer if necessary.  Don't let an interface result value get released out from underneath us. "	valueConstructionAction = #getValue:		ifTrue: [			| aVariant |			aVariant := value.			value := self getValue: aVariant.			"This method contained a bug: SafeArrays of Interfaces must be released here			 since the #getValue-Call above will call SafeArrayGetElement which will call an addRef on each 			 contained interface. The handling is ok for simple interface variants since it has no such mechanisms			 [AA: 08/2004]" ].</body></methods><methods><class-id>External.COMParameterDescription</class-id> <category>accessing</category><body package="Com- Automation">basicName	"return the parameter's name without trying to guess it"	^ name</body><body package="Com- Automation">basicName: newName	"addedFor literal specification support"	name := newName</body><body package="Com- Automation">defaultValue	^defaultValue</body><body package="Com- Automation">defaultValue: anObject	defaultValue := anObject</body><body package="Com- Automation">name	"return the parameter's name"	^self nameIfNone: [self defaultName]</body><body package="Com- Automation">name: anObject	"set the parameter's name"	name := anObject</body><body package="Com- Automation">nameIfNone: aBlock	"return the parameter's name"	^name ifNil: aBlock		ifNotNil: [name asString ifNil: aBlock]</body></methods><methods><class-id>External.COMParameterDescription</class-id> <category>testing</category><body package="Com- Automation">beInParameter	^ self setFlag: PARAMFLAG_FIN</body><body package="Com- Automation">beOutParameter	^ self setFlag: PARAMFLAG_FOUT</body><body package="Com- Automation">beResultValue	flags := ((flags bitOr: PARAMFLAG_FRETVAL) bitOr: PARAMFLAG_FOUT) bitAnd: PARAMFLAG_FIN bitInvert</body><body package="Com- Automation">canAcceptArgument: anArgument	"test if the parameter can marshal the argument"	| marshaled |	marshaled := [self marshalArgument: anArgument] on: Error do: [:ex | ^false].	self freeArgument: marshaled.	^true</body><body package="Com- Automation">hasDefaultFlag	^ self testFlag: PARAMFLAG_FHASDEFAULT</body><body package="Com- Automation">hasDefaultValue	^ (self hasDefaultFlag and: [self isOptional ])</body><body package="Com- Automation">isArray	^ self type isArray</body><body package="Com- Automation">isByval	^ self isByref not</body><body package="Com- Automation">isInOutParameter	^ self isInParameter and: [ self isOutParameter ]</body><body package="Com- Automation">isInParameter	^ self testFlag: PARAMFLAG_FIN</body><body package="Com- Automation">isInterface	^ self type isInterface</body><body package="Com- Automation">isOptional 	^ self testFlag: PARAMFLAG_FOPT</body><body package="Com- Automation">isOutParameter	^ self testFlag: PARAMFLAG_FOUT</body><body package="Com- Automation">isResultValue	^self isReturnValue		or: [self isOutParameter and: [self isInParameter not]]</body><body package="Com- Automation">isReturnValue	^self testFlag: PARAMFLAG_FRETVAL</body><body package="Com- Automation">isString	^ self type isString</body><body package="Com- Automation">isVariant	^ self type isVariant</body></methods><methods><class-id>External.COMParameterDescription</class-id> <category>option accessing</category><body package="Com- Automation">beMandatory	"let this parameter be an mandatory parameter"	self clearFlag: PARAMFLAG_FOPT</body><body package="Com- Automation">beOptional	"let this parameter be an optional parameter"	self setFlag: PARAMFLAG_FOPT</body><body package="Com- Automation">beOptional: aBoolean	"let this parameter be an optional or mandatory parameter"	aBoolean 		ifTrue: [ self beOptional ]		ifFalse: [ self beMandatory ].</body></methods><methods><class-id>External.COMParameterDescription</class-id> <category>converting</category><body package="Com- Automation">asInParameter	self isInParameter ifTrue: [^self].	^COMParameterDescription		name: self name		type: self type asInParameterType		flags: PARAMFLAG_FIN		defaultValue: self defaultValue</body><body package="Com- Automation">asReturnValueDescription	^ COMReturnValueDescription			type: self type referentType			flags: 0</body><body package="Com- Automation">asReturnValueNoDereference	"Turn the paramter into a returnvalue without dereferening the type"	^ COMReturnValueDescription			type: self type			flags: self flags</body></methods><methods><class-id>External.COMParameterDescription</class-id> <category>private</category><body package="Com- Automation">defaultName	^  self isResultValue ifTrue: ['result'] ifFalse: ['unnamed']</body></methods><methods><class-id>External.COMParameterDescription</class-id> <category>vtable calls</category><body package="Com- Automation">freeArgument: anArgument	^ self type freeArgument: anArgument</body><body package="Com- Automation">marshalArgument: anArgument	^ self isInParameter 		ifTrue: 	[ self type marshalInArgument: anArgument ]		ifFalse: 	[ self type createOutArgument  ]</body><body package="Com- Automation">newArgumentValue	^ self type newResultParameter</body><body package="Com- Automation">unmarshal: aMarshaledValue into: aSmalltalkValue	(self isOutParameter or: [ self isResultValue ]) ifFalse: [ ^ self ]. 	self isInParameter ifTrue: [ self type invalidateInParameterValueIn: aSmalltalkValue ].	self type unmarshalOutParameter: aMarshaledValue into: aSmalltalkValue.</body></methods><methods><class-id>External.COMParameterDescription</class-id> <category>comparing</category><body package="Com- Automation">= anObject	^super = anObject and: 			[self basicName = anObject basicName and: [self defaultValue = anObject defaultValue]]</body></methods><methods><class-id>External.COMParameterDescription</class-id> <category>marshaling</category><body package="Com- Automation">preMarshalAutomationParameter: aValue client: aClient	^(self isOptional and: [aValue isNothing])		ifTrue: [aValue]		ifFalse: [self type preMarshalAutomationParameter: aValue client: aClient]</body></methods><methods><class-id>External.COMParameterDescription class</class-id> <category>instance creation</category><body package="Com- Automation">fromElemDesc: elemDesc typeInfo: anITypeInfo name: aName	^ (self fromElemDesc: elemDesc typeInfo: anITypeInfo)		name: aName;		defaultValue: (elemDesc parameterDescription defaultValue);		yourself</body><body package="Com- Automation">name: aName		^ self new		name: aName;		yourself</body><body package="Com- Automation">name: aName type: aType  flags: flags defaultValue: defaultValue	^ (self type: aType  flags: flags)		defaultValue: defaultValue;		name: aName;		yourself.</body></methods><methods><class-id>External.COMParameterDescription class</class-id> <category>literal array encoding</category><body package="Com- Automation">literallyEncodedAttributes	^super literallyEncodedAttributes, #(basicName defaultValue)</body></methods><methods><class-id>External.COMTypeCompilerBoundType</class-id> <category>accessing</category><body package="Com- Automation">typeComp    ^typeComp</body></methods><methods><class-id>External.COMTypeCompilerBoundType</class-id> <category>private-accessing</category><body package="Com- Automation">typeComp: anITypeComp	typeComp := anITypeComp</body></methods><methods><class-id>External.COMTypeCompilerBoundType</class-id> <category>releasing</category><body package="Com- Automation">release	| temp |	temp := self typeComp.	self typeComp: nil.	temp enforceRelease.	self typeInfo: nil.	super release</body></methods><methods><class-id>External.COMTypeCompilerBoundType class</class-id> <category>instance creation</category><body package="Com- Automation">name: aName typeInfo: anITypeInfo typeComp: aTypeComp    "Answer a new instance of the receiver initialized with the arguments."    ^self new	  name: aName;        typeInfo: anITypeInfo;        typeComp: aTypeComp;        yourself</body></methods><methods><class-id>External.ComponentElementDescription</class-id> <category>testing</category><body package="Com- Automation">hasDefaultValue	"parameter compatibility"	^ false</body></methods><methods><class-id>External.ComponentElementDescription</class-id> <category>accessing</category><body package="Com- Automation">cType 	^ type cType</body><body package="Com- Automation">index	^index</body><body package="Com- Automation">index: anObject	index := anObject</body><body package="Com- Automation">type	^type</body><body package="Com- Automation">type: anObject	type := anObject</body><body package="Com- Automation">typeName		^ 'Element'</body></methods><methods><class-id>External.ComponentElementDescription</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	aStream nextPutAll: self name, ' as ' , self type name</body></methods><methods><class-id>External.ComponentElementDescription class</class-id> <category>instance creation</category><body package="Com- Automation">fromVarDesc: aVarDesc 	^(super fromVarDesc: aVarDesc)		type: (DispTypeSpec 					forTypeDesc: aVarDesc variableValueDescription typeDescription					typeInfo: aVarDesc typeInterface);		index: aVarDesc oInst;		yourself</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>accessing</category><body package="Com- Automation">basicTypeNamed: aString	^(self typeInfoNamed: aString)		ifNotNil: [:typeInfo | DispUserDefTypeSpec fromTypeInfo: typeInfo]</body><body package="Com- Automation">directoryName	"Answer the directory name of the library. If the directory name has not been set, set it to the current directory."	directoryName isNil ifTrue: [		directoryName := self getDirName ].	^directoryName</body><body package="Com- Automation">directoryName: aString	"Set the dir name of the library."	directoryName := aString</body><body package="Com- Automation">fileName	"Answer the file name of the library."	^fileName</body><body package="Com- Automation">fileName: aString	"Set the file name of the library."	fileName := aString</body><body package="Com- Automation">fullPathName	"Answer the full path name of the library."	^ self fullPathNameOnError: [		self error: (#TypeLibraryName &lt;&lt; #com &gt;&gt; 'type library name') asString ifInvalid: self fileName ]</body><body package="Com- Automation">fullPathNameOnError: aBlock 	"Answer the full path name of the library."	^self fileName ifNil: aBlock		ifNotNil: 			[:fName | 			| pathPrefix |			pathPrefix := self directoryName isNil 						ifTrue: [String new]						ifFalse: [COMSessionManager absolutePathName: self directoryName].			pathPrefix , fName]</body><body package="Com- Automation">guid	^ self libraryID ifNil: [ self typeLib guid ]</body><body package="Com- Automation">helpDirectory	"Answer the help dir name of the library."	^helpDirectory</body><body package="Com- Automation">helpDirectory: aString	"Set the help dir name of the library."	helpDirectory := aString</body><body package="Com- Automation">lcid	"Answer the LCID of the library."	^lcid</body><body package="Com- Automation">lcid: aNumber	"Set the LCID of the library."	lcid := aNumber</body><body package="Com- Automation">libraryID	"Answer the GUID of the library."	^libraryID</body><body package="Com- Automation">libraryID: aGUID	"Set the GUID of the library."	libraryID := aGUID</body><body package="Com- Automation">majorVersion	"Answer the major version of the library."	^majorVersion</body><body package="Com- Automation">majorVersion: aNumber	"Set the major version of the library."	majorVersion := aNumber</body><body package="Com- Automation">minorVersion	"Answer the minor version of the library."	^minorVersion</body><body package="Com- Automation">minorVersion: aNumber	"Set the minor version of the library."	minorVersion := aNumber</body><body package="Com- Automation">name	"Answer the name of the library."	^name</body><body package="Com- Automation">name: aString	"Set the name of the library."	name := aString</body><body package="Com- Automation">typeForGUID: aGUID	| typeInfo |	typeInfo := self typeInfoOfGuidAt: aGUID ifAbsent: [^nil].	^DispUserDefTypeSpec fromTypeInfo: typeInfo</body><body package="Com- Automation">typeInfo	"Answer the type info interface, an instance of ITypeInfo."	iTypeInfo notNil ifTrue: [ ^iTypeInfo ].	^iTypeInfo := self typeLib getTypeInfo: 0.</body><body package="Com- Automation">typeInfoNamed: aString	^[self typeLib ifNotNil: [:library | library findName: aString]]		on: COMError		do: [:ex | ex return: nil]</body><body package="Com- Automation">typeInfoOfGuidAt: aGUID	"Answer the type info interface, an instance of ITypeInfo."	^self typeInfoOfGuidAt: aGUID ifAbsent: nil</body><body package="Com- Automation">typeInfoOfGuidAt: aGUID ifAbsent: aBlock	"Answer the type info interface, an instance of ITypeInfo."	^self typeInfoOfGuids at: aGUID		ifAbsentPut: 			[[self typeLib ifNotNil: [:typeLib | typeLib getTypeInfoOfGuid: aGUID]]				on: COMError				do: [:ex | ^ aBlock value]]</body><body package="Com- Automation">typeLib	"Answer the library interface, an instance of ITypeLib."	iTypeLib notNil ifTrue: [^iTypeLib].	self libraryID isNil 		ifTrue: 			[self fileName isNil 				ifTrue: [self error: #ErrIDAndFileNil &lt;&lt; #com &gt;&gt; 'ID and filename cannot be both nil'].			^iTypeLib := [ ITypeLib pathName: self fullPathName ] on: Error do: [:ex | ex return: nil ]].	^iTypeLib := self loadRegisteredLibrary</body><body package="Com- Automation">typeNamed: aString	^ (self basicTypeNamed: aString) ifNil: [self class typeNamed: aString]</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>private-accessing</category><body package="Com- Automation">getDirName	"Answer the current directory."	^Filename defaultDirectoryName</body><body package="Com- Automation">immediateReleaseTypeInfoOfGuids	"Set the dictionary that keeps track of GUID type infos to &lt;aDictionary&gt;. Release the previous dictionary before overwriting it."	self typeInfoOfGuids do: [:each | each enforceRelease ].	self typeInfoOfGuids: Dictionary new.</body><body package="Com- Automation">typeInfoOfGuids	"Answer the dictionary that keeps track of GUID type infos to &lt;aDictionary&gt;."	^typeInfoOfGuids</body><body package="Com- Automation">typeInfoOfGuids: aDictionary	"Set the dictionary that keeps track of GUID type infos to &lt;aDictionary&gt;. Release the previous dictionary before overwriting it."	typeInfoOfGuids := aDictionary</body><body package="Com- Automation">typeLib: anITypeLib	"Set the library interface to &lt;anITypeLib&gt; and answer it. Release previous reference if present."	^iTypeLib := anITypeLib</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>testing</category><body package="Com- Automation">existsInSystem	^[self typeLib notNil] on: COMError do: [:ex | ex return: false]</body><body package="Com- Automation">isLoaded	"Answer whether the library is loaded."		"Do not use 'self typeLib' as not to load."	^iTypeLib notNil</body><body package="Com- Automation">libraryFileExists	"Answer whether the library file exists as specifed."	^self fullPathName asFilename definitelyExists</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream 	"Append to the argument aStream a sequence of characters	that describes the receiver."	| docs |	super printOn: aStream.	self isLoaded 		ifFalse: [ ^aStream nextPutAll: ' (not loaded)' ].	docs := self typeLib getDocumentation.	aStream 		nextPutAll: ' (';		nextPutAll: ( docs at: 'name' );		nextPutAll: ': ';		nextPutAll: ( docs at: 'documentation' );		nextPut: $).</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>releasing</category><body package="Com- Automation">enforceRelease	"Release the library."	self typeInfoOfGuids: Dictionary new.	iTypeLib		ifNotNil: 			[iTypeLib enforceRelease.			iTypeLib := nil]</body><body package="Com- Automation">release	"Release the library."	"Mutator actually performs the release."	self typeInfoOfGuids: Dictionary new.	self typeLib: nil</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>loading</category><body package="Com- Automation">getRegisteredLibrary	"Answer a new type library interface from the receiver's library ID and LCID. If the major and minor versions have both been specified, load using those as well. Uses registry information to load a type library."	self error: (#TypeLibraryID &lt;&lt; #com &gt;&gt; 'Type library ID') asString ifInvalid: self libraryID.	( self majorVersion isNil or: [ self minorVersion isNil ] )		ifTrue: [			^ITypeLib 				registeredID: self libraryID 				lcid: self lcid ]		ifFalse: [			^ITypeLib 				registeredID: self libraryID 				majorVersion: self majorVersion				minorVersion: self minorVersion				lcid: self lcid ]</body><body package="Com- Automation">loadFromFullPathName	"Loads the type library from a full path name. Loading also registers the type library. Answer true if loaded. Raise an error if the library cannot be loaded."	self libraryFileExists 		ifFalse: 			[self error: #ErrTypeLibNotExist &lt;&lt; #com &gt;&gt; 'The type library file does not exist.'].	self typeLib: (ITypeLib pathName: self fullPathName).	^self isLoaded</body><body package="Com- Automation">loadRegisteredLibrary	"Get and save a type library interface in the receiver. Answer the type library interface. See getRegisteredLibrary."	^self typeLib: self getRegisteredLibrary</body><body package="Com- Automation">loadedRegisteredLibrary	"Uses registry information to load a type library."	[ self loadRegisteredLibrary ]		on: COMError		do: [ :ex | "Ignore load errors" ].	^self isLoaded</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>converting</category><body package="Com- Automation">asInterfaceReference	"Answer a civilized interface reference on the receiver."	^self typeLib asInterfaceReference</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>registration</category><body package="Com- Automation">createRegistration	"Makes sure that a library is properly registered. (1) Load the type library from its file name and register the dispatch interfaces (2). This is normally done once when the application is installed."	[	"(1) If loadFromFullPathName succeeds, it will also have registered the type library for us for the next time."	self updatePath. "Update the path in case we are on another system"	self loadFromFullPathName		ifFalse: [ ^false ].	"(2) Ensure that the type library is registered and add dispatch interfaces from the library."	self register.	] ensure: [ self enforceRelease ].	^true</body><body package="Com- Automation">register	"Adds information about a type library to the system registry."	self libraryFileExists 		ifFalse: 			[self error: #ErrTypeLibNotExist &lt;&lt; #com &gt;&gt; 'The type library file does not exist.'].	self registerGlobally ifFalse: [ self registerForCurrentUser ].</body><body package="Com- Automation">registerForCurrentUser	"Adds information about a type library to the system registry."	"On Windows Vista we usually can only register the TypeLibrary for the current user. Try this instead" 	self typeLib registerTypeLibraryForUser: self fullPathName		helpDirectory: self helpDirectory</body><body package="Com- Automation">registerGlobally	"Try a global registration. This will work on Windows XP and below. On Windows Vista this will fail"		[self typeLib registerTypeLibrary: self fullPathName		helpDirectory: self helpDirectory]			on: Error			do: [:ex | ^false].	^true</body><body package="Com- Automation">removeRegistration	"Removes type library information from the system registry. Use this API to allow applications to properly uninstall themselves. In-process objects typically call this API from DllUnregisterServer."	^ITypeLib unRegister: self libraryID 		majorVersion: majorVersion		minorVersion: minorVersion		lcid: self lcid</body><body package="Com- Automation">updateRegistration	"Makes sure that a library is properly registered. (1) Try to load the library as registered. If ok, (2) update the registry with dispatch interface information from the type library. If (1) fails, then try to load the type library from it's file name (3) and register the dispatch interfaces. This method normally called when the application is started."	"(1) Registeration check."	[	self updatePath. "Update the path in case we are on another system"	self loadedRegisteredLibrary		ifTrue: [ 			"(2) Ensure that the type library is registered and add dispatch interfaces from the library."			self register.			^true ].		"(3) If loadFromFullPathName succeeds, it will also have registered the type library for us for the next time."	self loadFromFullPathName		ifFalse: [ ^false ].	"(4) Ensure that the type library is registered and add dispatch interfaces from the library."	self register.	] ensure: [ self enforceRelease ].	^true</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>private-error</category><body package="Com- Automation">error: aName ifInvalid: aValue	"Raise an error with the message &lt;aName&gt; in the message if &lt;aValue&gt; is nil."	aValue isNil ifFalse: [ ^self ].	self error: (#ErrNamedSetToValue &lt;&lt; #com &gt;&gt; 'The &lt;1s&gt; should be set to a value.' expandMacrosWith: aName)</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>private tools</category><body package="Com- Automation">extLCIDForVersion: version 	"Answer the LCID of the library for the given version &lt;#(major minor)&gt;. 	 If it is not defined inside the typelibrary, get a common valid LCID for the typeLibrary 	 from the registry"	| lcIDs commonLCIDs |	^lcid ifNil: 			[version ifNil: [^nil].			(lcIDs := COMRegistryInterface localesForTypeLibrary: self libraryID						versionString: version first printString , '.' , version last printString) 					ifNil: [^nil].			commonLCIDs := Array 						with: Win32ExternalInterface defaultUserLCID						with: Win32ExternalInterface defaultSystemLCID						with: Win32ExternalInterface lcidEnglish.			lcIDs detect: [:anLCID | commonLCIDs includes: anLCID]				ifNone: [lcIDs isEmpty ifTrue: [STDOLE_LCID] ifFalse: [lcIDs first]]]</body><body package="Com- Automation">extVersion	"Answer the version of this typeLibrary. If it is not defined use the latest registered version"	^ (majorVersion isNil or: [minorVersion isNil])		ifTrue: 	[ COMRegistryInterface typeLibraryCurrentVersionNumbers: self libraryID ]		ifFalse:	[ Array with: majorVersion with: minorVersion ]</body><body package="Com- Automation">foundDirectoriesDo: aBlock 	"Scan the type-library directory for a missing type-library.  Perform aBlock for the first matching library"	| coll |	self fileName ifNil: [^self].	coll := OrderedCollection new.	COMSessionManager typeLibSearchPaths do: 			[:each | 			self 				scan: each asFilename				for: self fileName				into: coll].	coll isEmpty 		ifTrue: 			[COMSessionManager hasTypeLibSearchPath 				ifTrue: 					[self 						error: (#NoTypeLibraryFoundInDir &lt;&lt; #com								&gt;&gt; 'No typelibrary found matching ''&lt;1s&gt;'' while scanning ''&lt;2p&gt;''' 									expandMacrosWith: self fileName									with: COMSessionManager typeLibSearchPaths asArray)].			^self].	coll size = 1 ifTrue: [^aBlock value: coll first].	(HeadlessImage isHeadless not and: 			[ImageConfiguration isDevelopment 				or: [COMSessionManager commandLineIncludesDebug]]) 		ifTrue: 			["Only allow selecting the type library in debug or development case"			(Dialog 				choose: (#MultipleTypeLibsFoundPleaseSelectOne &lt;&lt; #com						&gt;&gt; ' Multiple typelibrary files found for "&lt;1s&gt;"- please select one' 							expandMacrosWith: self fileName)				fromList: (coll collect: [:each | each asString])				values: coll				lines: 8				cancel: nil) ifNotNil: aBlock]		ifFalse: 			[self 				error: (#MultipleTypeLibsFoundHeadless &lt;&lt; #com						&gt;&gt; 'Multiple possible type libraries found in search path ''&lt;1p&gt;'' for &lt;2s&gt; - unable to match' 							expandMacrosWith: COMSessionManager typeLibSearchPaths asArray							with: self fileName)]</body><body package="Com- Automation">pathName: aFileOrString 	| path |	path := aFileOrString asFilename.	self fileName: path tail.	self directoryName: path head</body><body package="Com- Automation">queryLibraryFileDo: aBlock 	"Query the user for a valid TypeLibrary filename if headfull otherwise quit the image. Perform aBlock with the non-nil response."	(HeadlessImage isHeadless not and: 			[ImageConfiguration isDevelopment 				or: [COMSessionManager commandLineIncludesDebug]]) 		ifTrue: 			[| choice |			choice := Dialog 						choose: (#UnableToLocateTypeLib &lt;&lt; #com 								&gt;&gt; 'Unable to locate type library "&lt;1s&gt;"' 									expandMacrosWith: self fullPathName)						labels: (Array with: #SelectFile &lt;&lt; #com &gt;&gt; 'Select file'								with: #Debug &lt;&lt; #com &gt;&gt; 'Debug')						values: #(#select #continue)						default: #continue.			choice = #select 				ifTrue: 					[(Dialog 						requestFileName: #SelectFile &lt;&lt; #com &gt;&gt; 'Select file'						default: self fileName						version: #old						ifFail: nil) ifNotNil: aBlock]]</body><body package="Com- Automation">registeredPathDo: aBlock 	"Access the path of a type-library from the registry. If the typelibrary is registered, evaluate aBlock with its path"	| version anLCID |	self libraryID ifNil: [^self].	(version := self extVersion) ifNil: [^self].	(anLCID := self extLCIDForVersion: version) ifNil: [^self].	(	[ITypeLib 		queryPathOfRegTypeLibrary: self libraryID		majorVersion: version first		minorVersion: version last		lcid: (anLCID ifNil: [STDOLE_LCID])] 			on: COMError			do: [:ex | ex return: nil]) 			ifNotNil: [:path | path asFilename definitelyExists ifTrue: [aBlock value: path]]</body><body package="Com- Automation">scan: aDirectory for: aName into: aCollection 	"Scan the following directory for a typelibrary file named &lt;aName&gt;. Put all matching files	 into &lt;aCollection&gt;.  Don't raise an error here if a directory does not exist - this might be an out of date COM-Directory"	aDirectory definitelyExists ifFalse: [^self].	aDirectory directoryContents do: 			[:each | 			| file |			file := aDirectory construct: each.			file isDirectory 				ifTrue: 					[self 						scan: file						for: aName						into: aCollection]				ifFalse: 					[each asLowercase = aName asLowercase ifTrue: [aCollection addLast: file]]]</body><body package="Com- Automation">updatePath	"Update the path of the type-library if necessary at server startup."	| fullPath |	fullPath := self fullPathNameOnError: nil.	(fullPath notNil and: [fullPath asFilename definitelyExists]) 		ifTrue: [^self].	self registeredPathDo: [:path | ^self pathName: path].	self foundDirectoriesDo: [:path | ^self pathName: path].	self queryLibraryFileDo: [:path | ^self pathName: path].	self 		error: (#UnableToLocateTypeLib &lt;&lt; #com				&gt;&gt; 'Unable to locate type library "&lt;1s&gt;"' 					expandMacrosWith: self fullPathName)</body></methods><methods><class-id>External.COMTypeLibrary</class-id> <category>initializing</category><body package="Com- Automation">finalize	self enforceRelease.</body><body package="Com- Automation">initialize	"Initialize the receiver."	self lcid: STDOLE_LCID.	self typeInfoOfGuids: Dictionary new.	self needsFinalization.</body><body package="Com- Automation">startup	iTypeInfo := nil.	iTypeLib := nil.	typeInfoOfGuids := Dictionary new.</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>LCID definitions</category><body package="Com- Automation">lcidEnglish	"OBSOLETE. Use Win32ExternalInterface class&gt;&gt;lcidEnglish"	"Answer the English LCID."	^Win32ExternalInterface lcidEnglish</body><body package="Com- Automation">lcidGerman	"Answer the German LCID."	^16r0407</body><body package="Com- Automation">lcidNeutral	"Answer the Neutral LCID."	^16r0</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>instance creation</category><body package="Com- Automation">libraryID: aLibID	"Answer a new instance of the receiver representing the library identified by the the GUID &lt;aLibID&gt;."	"fetch information about all versions of the typelibrary from the registry and select one of them. 	This ensures we us a valid combination of values which sometimes is required"	| versions |	versions := COMRegistryInterface allLibraryDescriptorsFor: aLibID asString.	^versions isEmpty		ifTrue: [self new libraryID: aLibID asGUID]		ifFalse: 			[(self selectBestVersion: versions)				ifNil: 					["just try it anyway"					self new libraryID: aLibID asGUID]				ifNotNil: [:descriptor | descriptor asTypeLib]]</body><body package="Com- Automation">new	"Answer a new initialized instance of the receiver."	^super new initialize</body><body package="Com- Automation">pathName: aPathName	"Answer a new instance of the receiver representing the type library in the file named &lt;aPathName&gt;."	^self new pathName: aPathName</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>registering used libraries</category><body package="Com- Automation">clearUsed		self usedTypeLibraries: nil.</body><body package="Com- Automation">unused: aGUID	^ self usedTypeLibraries removeKey: aGUID ifAbsent: [ ^ self ].</body><body package="Com- Automation">usedTypeLibraries: aDictionaryOrNil	UsedTypeLibraries := aDictionaryOrNil.</body><body package="Com- Automation">using: aGUID	self usedTypeLibraries at: aGUID ifAbsentPut: [ TypeLibDescriptor forGuid: aGUID version: nil].</body><body package="Com- Automation">using: aGUID lcid: lcid	self usedTypeLibraries at: aGUID ifAbsentPut: [ TypeLibDescriptor forGuid: aGUID version: nil lcid: lcid].</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>accessing</category><body package="Com- Automation">typeLibraryContainingClassWithId: aClsid	^ (COMRegistryInterface typeLibraryIDForCLSID: aClsid)		ifNotNil: [:tlibID | COMTypeLibrary libraryID: tlibID].</body><body package="Com- Automation">typeLibraryContainingInterfaceWithId: iid	^ (COMRegistryInterface typeLibraryIDForIID: iid)		ifNotNil: [:tlibID | COMTypeLibrary libraryID: tlibID].</body><body package="Com- Automation">usedTypeLibraries	^ UsedTypeLibraries ifNil: [ UsedTypeLibraries := Dictionary new ].</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>startup</category><body package="Com- Automation">flushTypeLibraries	self allInstances do: [:each | each startup ].</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>class initialization</category><body package="Com- Automation">initialize	COMSystem current when: #startupCompleted send: #flushTypeLibraries to: self.</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>runtime support</category><body package="Com- Automation">iidForSymbol: aSymbol	self usedTypeLibraries do: [:each | 		(each guidForName: aSymbol) ifNotNil: [:guid | ^ guid ]].	^ nil</body><body package="Com- Automation">vtableSpecificationTableFor: anIID	^ (self typeForGUID: anIID) vtableType specificationTable</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>initialize-release</category><body package="Com- Automation">obsolete	COMSystem current removeAllActionsWithReceiver: self.	super obsolete.</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>accessing types</category><body package="Com- Automation">enumConstantNamed: aName	self usedTypeLibraries		do: [:each | (each basicEnumConstantNamed: aName) ifNotNil: [:constant | ^constant]].	^ nil</body><body package="Com- Automation">enumConstantNamed: aName inTypeNamed: aTypeName	self usedTypeLibraries		do: [:each | (each basicEnumConstantNamed: aName inTypeNamed: aTypeName) ifNotNil: [:constant | ^constant]].	^ nil</body><body package="Com- Automation">typeForGUID: aGUID	self usedTypeLibraries		do: [:each | (each typeForGUID: aGUID) ifNotNil: [:type | ^type]].	(COMTypeLibrary typeLibraryContainingClassWithId: aGUID)		ifNotNil: [:tlib | ^tlib typeForGUID: aGUID].	(COMTypeLibrary typeLibraryContainingInterfaceWithId: aGUID)		ifNotNil: [:tlib | ^tlib typeForGUID: aGUID].	^nil</body><body package="Com- Automation">typeForIID: aGUID	self usedTypeLibraries		do: [:each | (each typeForGUID: aGUID) ifNotNil: [:type | ^type]].	(COMTypeLibrary typeLibraryContainingInterfaceWithId: aGUID)		ifNotNil: [:tlib | ^tlib typeForGUID: aGUID].	^nil</body><body package="Com- Automation">typeInfoForCLSID: aClsid	| typeInfo typeLib |	self usedTypeLibraries do: 			[:typeLibDesc |			typeLib := typeLibDesc asTypeLib.			typeInfo := [typeLib typeInfoOfGuidAt: aClsid] on: Error						do: [:ex | ex return: nil].			typeInfo ifNotNil: [^typeInfo]].	^(COMTypeLibrary typeLibraryContainingClassWithId: aClsid)		ifNotNil: [:tlib | tlib typeInfoOfGuidAt: aClsid]</body><body package="Com- Automation">typeInfoForIID: anIID	| typeInfo typeLib |	self usedTypeLibraries do: 			[:typeLibDesc |			typeLib := typeLibDesc asTypeLib.			typeInfo := [typeLib typeInfoOfGuidAt: anIID] on: Error						do: [:ex | ex return: nil].			typeInfo ifNotNil: [^typeInfo]].	^(self typeLibraryContainingInterfaceWithId: anIID)		ifNotNil: [:lib | lib typeInfoOfGuidAt: anIID]</body><body package="Com- Automation">typeNamed: aName	self usedTypeLibraries do: [:each | 		(each basicTypeNamed: aName) ifNotNil: [:type | ^ type ]].	^ nil</body></methods><methods><class-id>External.COMTypeLibrary class</class-id> <category>As yet unclassified</category><body package="Com- Automation">selectBestVersion: anOrderedCollection	| sorted |	sorted := (anOrderedCollection select: #matchesCurrentPlatform)				sorted: #qualityRatingForCurrentSystem descending.	^sorted isEmpty ifTrue: [nil] ifFalse: [sorted first]</body></methods><methods><class-id>External.RecordAccessPath</class-id> <category>member accessing</category><body package="Com- Automation">getMemberIn: aRecord 	| refElement |	refElement := self getReferenceToPreviousElementIn: aRecord.	^self last getMemberIn: refElement</body><body package="Com- Automation">getMemberReferenceIn:  aRecord	| refElement |	refElement := self getReferenceToPreviousElementIn: aRecord.	^ self last getMemberReferenceIn: refElement.</body><body package="Com- Automation">setValue: aValue in:  aRecord 	| refElement |	refElement := self getReferenceToPreviousElementIn: aRecord.	^ self last setValue: aValue in: refElement.</body></methods><methods><class-id>External.RecordAccessPath</class-id> <category>private</category><body package="Com- Automation">getReferenceToPreviousElementIn: aRecord 	"Return a reference to the last but one element in the path."	| refElement refVariant |	refElement := aRecord.	1 to: self size - 1		do: 			[:index | 			refVariant := (self at: index) getMemberReferenceIn: aRecord.			refElement := refVariant value value].	^refElement</body></methods><methods><class-id>External.RecordAccessPath class</class-id> <category>instance creation</category><body package="Com- Automation">fromString: aString 	| tokens pathElements |	tokens := aString tokensBasedOn: $..	pathElements := tokens 				collect: [:each | RecordAccessElement fromString: each].	^pathElements size = 1 		ifTrue: [pathElements first]		ifFalse: 			[ self withAll: (tokens collect: [:each | RecordAccessElement fromString: each])]</body></methods><methods><class-id>External.ConstantDescription</class-id> <category>accessing</category><body package="Com- Automation">typeName	"Return the name of my type - I am a constant, so return it"	^ 'Constant'</body><body package="Com- Automation">value	^value</body><body package="Com- Automation">value: anObject	value := anObject</body></methods><methods><class-id>External.ConstantDescription</class-id> <category>testing</category><body package="Com- Automation">isConstant	^ true</body><body package="Com- Automation">respondsToArithmetic 	^ true</body></methods><methods><class-id>External.ConstantDescription</class-id> <category>comparing</category><body package="Com- Automation">= aConstantValue	^ aConstantValue equalToEnumConstant: self</body><body package="Com- Automation">equalToEnumConstant: anEnumConstant	^ self value = anEnumConstant value and: [ self name = anEnumConstant name ]</body><body package="Com- Automation">~= aConstantValue	^ (self = aConstantValue) not</body></methods><methods><class-id>External.ConstantDescription</class-id> <category>arithmetic</category><body package="Com- Automation">equalFromInteger: anInteger	^ self value = anInteger</body></methods><methods><class-id>External.ConstantDescription</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	aStream nextPutAll: 'Constant: ';		nextPutAll: self name;		nextPutAll: ' = ';		print: self value.</body></methods><methods><class-id>External.ConstantDescription</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Answer nil if the receiver cannot be represented as by a known variant type. "	^ External.COMAutomationConstants.VT_INT</body></methods><methods><class-id>External.ConstantDescription class</class-id> <category>instance creation</category><body package="Com- Automation">fromVarDesc: aVarDesc 	^(super fromVarDesc: aVarDesc)		value: aVarDesc constantValue;		yourself</body><body package="Com- Automation">name: aName value: aValue	^ self new		name: aName;		value: aValue;		yourself</body></methods><methods><class-id>External.AutomationClassSpecificationTable</class-id> <category>accessing</category><body package="Com- Automation">addEventSpecTables: specTables	specTables do: 			[:specTable |			specTable do: 					[:member |					self addSpec: (COMDispatchEventSpecification forMethodSpec: member)						interface: specTable interface]]</body><body package="Com- Automation">addSpec: member interface: interface		^self		add:			(AutomationClassMember				interface: interface				member: member)</body><body package="Com- Automation">addSpecTables: specTables		specTables		do:			[:specTable | specTable do: [:member | self addSpec: member interface: specTable interface]]</body><body package="Com- Automation">defaultInterface	^ self propertyAt: #defaultInterface</body><body package="Com- Automation">defaultInterface: anObject	self propertyAt: #defaultInterface put: anObject</body><body package="Com- Automation">supports: anArray	(anArray includes: #VTable) ifFalse: [ self supportsVTable: false ].	(anArray includes: #Dispatch) ifFalse: [ self supportsDispatch: false ].</body><body package="Com- Automation">supportsDispatch	^ self propertyAt: #supportsDispatch ifAbsent: [ true ]</body><body package="Com- Automation">supportsDispatch: aBoolean	^ self propertyAt: #supportsDispatch put: aBoolean</body><body package="Com- Automation">supportsVTable	^ self propertyAt: #supportsVTable ifAbsent: [ true ]</body><body package="Com- Automation">supportsVTable: aBoolean	^ self propertyAt: #supportsVTable put: aBoolean</body></methods><methods><class-id>External.AutomationClassSpecificationTable</class-id> <category>accessing-specifications</category><body package="Com- Automation">at: key put: aSpecification	" Add &lt;aSpecification&gt; to the dispatch specification table under &lt;key&gt;. "	aSpecification isEventSpecification		ifFalse: 			[aSpecification isVTable				ifTrue: [self supportsVTable not ifTrue: [^self]]				ifFalse: [self supportsDispatch ifFalse: [^self]]].	self atAllKeysFor: key put: aSpecification.	^aSpecification</body><body package="Com- Automation">at: key types: types ifAbsent: exceptionBlock	" Answer the specification whose key equals &lt;key&gt;.        If not found,  answer the result of evaluating &lt;exceptionBlock&gt;."	^(self		basicAt: key		types: types		ifAbsent: [^exceptionBlock value]) member</body><body package="Com- Automation">basicAt: key ifAbsent: exceptionBlock	| member |	member := self privateAt: (self formatVTableKey: key) ifAbsent: [nil].	member ifNotNil: [^member].	self isQualifiedByName ifFalse: [^exceptionBlock value].	"Now try to retrieve the member using the lowercase key"	member := self privateAt: (self formatAutomationKey: key) ifAbsent: [nil].	^(member notNil and: [member member isVTable not])		ifTrue: [member]		ifFalse: [exceptionBlock value]</body><body package="Com- Automation">basicAt: key types: types ifAbsent: exceptionBlock	| member |	member := self privateAt: (self formatVTableKey: key) types: types ifAbsent: [nil].	member ifNotNil: [^member].	self isQualifiedByName ifFalse: [^exceptionBlock value].	"Now try to retrieve the member using the lowercase key"	member := self privateAt: (self formatAutomationKey: key) types: types ifAbsent: [nil].	^(member notNil and: [member member isVTable not])		ifTrue: [member]		ifFalse: [exceptionBlock value]</body><body package="Com- Automation">getSpecificationOfType: aType where: anAttribute isEqualTo: aKey ifAbsent: aBlock	^(super		getSpecificationOfType: aType		where: anAttribute		isEqualTo: aKey		ifAbsent: [^aBlock value]) member</body><body package="Com- Automation">members	^ super values</body><body package="Com- Automation">values        "Answer a Bag containing all the values of the         key/value pairs in the receiver."    ^ super values collect: [:each | each member ]</body></methods><methods><class-id>External.AutomationClassSpecificationTable</class-id> <category>private-construction</category><body package="Com- Automation">formatAutomationKey: aKey	^self specificationKey = #name		ifTrue: [ ('Automation!',aKey asLowercase) asSymbol]		ifFalse: [aKey]</body><body package="Com- Automation">formatKey: aKey	^self formatVTableKey: aKey</body><body package="Com- Automation">formatKey: aKey forStoring: aSpecification	^aSpecification isVTable		ifTrue: [self formatVTableKey: aKey]		ifFalse: [self formatAutomationKey: aKey]</body><body package="Com- Automation">formatVTableKey: aKey	^self specificationKey = #name ifTrue: [aKey asSymbol] ifFalse: [aKey]</body></methods><methods><class-id>External.AutomationClassSpecificationTable</class-id> <category>private-validation</category><body package="Com- Automation">fullyQualifiedKeyNameFor: key spec: aSpec	specificationKey = #name		ifTrue: [^(aSpec interface name , '::' , key) asSymbol].	^key</body></methods><methods><class-id>External.AutomationClassSpecificationTable</class-id> <category>private</category><body package="Com- Automation">atAllKeysFor: key put: aSpecification	| formattedKey oldSpec |	formattedKey := self formatKey: key forStoring: aSpecification.	oldSpec := self privateAt: formattedKey types: (Array with: aSpecification kind) ifAbsent: [nil].	(self defaultInterface isNil		or: [aSpecification interface = self defaultInterface or: [oldSpec isNil]])			ifTrue: [self privateAt: formattedKey put: aSpecification].	self privateAt: (self fullyQualifiedKeyNameFor: key spec: aSpecification)		put: aSpecification</body><body package="Com- Automation">selectBetterFromEquivalents: members	"We have two equivalen specifications, probably a Vtable and an Automation member.	 If supported, select the Automation member as it is safer"	self supportsDispatch		ifTrue: [^members detect: [:each | each isVTable not] ifNone: [members any]].	^super selectBetterFromEquivalents: members</body></methods><methods><class-id>External.AutomationClassSpecificationTable class</class-id> <category>instance creation</category><body package="Com- Automation">forCoclass: aCoclass specificationKey: aSymbol includeEvents: aBoolean	^ self forCoclass: aCoclass supports: #(#VTable #Dispatch) specificationKey: aSymbol includeEvents: aBoolean</body><body package="Com- Automation">forCoclass: aCoclass supports: aSymbolArray specificationKey: aSymbol includeEvents: aBoolean		| eventTables |	eventTables := aBoolean 		ifTrue: [ (aCoclass eventDispatchInterfaces collect: [:each | each specificationTable]) ]		ifFalse: [ #() ].	^self new		clsid: aCoclass clsid;		name: aCoclass name;		typeLib: aCoclass typelib;		supports: aSymbolArray;		specificationKey: aSymbol;		defaultInterface: aCoclass defaultInterface;		addSpecTables: (aCoclass implementedInterfaces collect: [:each | each specificationTable]);		addEventSpecTables: eventTables;			yourself</body></methods><methods><class-id>External.COMAbstractRegistration</class-id> <category>private-type library</category><body package="Com- Automation">defaultLCIDTypeLibIdDo: aBlock 	"Find the TypeLib for the current locale LCID and evaluate aBlock with its ID string. Use the library for the user default LCID.  If that is absent use the system default (0) or, if that is missing, the first type library in the typeLibraries collection."	typeLibraries at: Win32ExternalInterface defaultUserLCID		ifPresent: [:value | ^aBlock value: value libraryID asString].	typeLibraries at: 0		ifPresent: [:value | ^aBlock value: value libraryID asString].	typeLibraries isEmpty 		ifFalse: [aBlock value: typeLibraries values first libraryID asString]</body><body package="Com- Automation">registerTypeLibraries	"Register the type libraries." 	self typeLibraries do: [ : aTypeLibrary | 		aTypeLibrary createRegistration ]</body><body package="Com- Automation">unregisterTypeLibraries	"Unregister the type libraries." 	self typeLibraries do: [ : aTypeLibrary | 		aTypeLibrary removeRegistration ]</body></methods><methods><class-id>External.COMAbstractRegistration</class-id> <category>printing</category><body package="Com- Automation">installOn: aStream 	"Variation of #storeOn: that appends a formatted code expression to aStream necessary to recreate the receiver in a class method.  Used by the COM Automation Wizard"	aStream		store: self class;		nextPutAll: ' new '</body><body package="Com- Automation">storeRegistrationOn: aStream 	"Store registration entries in REGEDIT file format to aStream"	self entriesSorted do: 			[:association | 			aStream nextPutAll: association key.			association value ifNotNil: 					[:value | 					aStream						space;						nextPut: $=;						space;						nextPutAll: value].			aStream cr]</body></methods><methods><class-id>External.COMAbstractRegistration</class-id> <category>accessing</category><body package="Com- Automation">entriesSorted	^ self sortEntries: self registrationEntries.</body><body package="Com- Automation">registrationEntries 	^Dictionary new</body><body package="Com- Automation">sortEntries: aDictionary	| sortedAssociations |	sortedAssociations := aDictionary associations.	SequenceableCollectionSorter sort: sortedAssociations		using: [:a :b | (a key occurrencesOf: $\) &lt;= (b key occurrencesOf: $\)].	^sortedAssociations</body><body package="Com- Automation">typeLibraries	^typeLibraries</body><body package="Com- Automation">typeLibraries: aDictionary	"Set the type library dictionary. The dictionary keys are LCIDs and the values are instances of COMTypeLibrary."		typeLibraries := aDictionary</body></methods><methods><class-id>External.COMAbstractRegistration</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	typeLibraries := Dictionary new.</body></methods><methods><class-id>External.COMAbstractRegistration</class-id> <category>registration</category><body package="Com- Automation">register	"Register all my entries and type libraries"	self registerTypeLibraries.	^ self registerGlobally or: [ self registerForCurrentUser ]</body><body package="Com- Automation">unregister	"Remove all my entries and type libraries from the Registry"	self unregisterTypeLibraries.	^ self unregisterGlobally or: [ self unregisterForCurrentUser ]</body></methods><methods><class-id>External.COMAbstractRegistration</class-id> <category>private registration</category><body package="Com- Automation">currentUserClassesBase	^Win32RegistrationDatabase currentUser at: 'Software\Classes'</body><body package="Com- Automation">globalClassesBase	^Win32RegistrationDatabase classesRoot</body><body package="Com- Automation">registerForCurrentUser	| clsRoot |	clsRoot := self currentUserClassesBase.	^self registerIn: clsRoot</body><body package="Com- Automation">registerGlobally	"Register all my entries and type libraries"	^ self registerIn: Win32RegistrationDatabase classesRoot.</body><body package="Com- Automation">registerIn: clsRoot	^self registerSettings: self registrationEntries in: clsRoot</body><body package="Com- Automation">registerSettings: aDictionary in: clsRoot	| sortedEntries |	clsRoot isNil ifTrue: [^false].	sortedEntries := self sortEntries: aDictionary.	sortedEntries do: 			[:association |			[clsRoot at: association key put: association value] on: Error				do: [:ex | ^false]].	^true</body><body package="Com- Automation">unregisterForCurrentUser	"Remove all my entries and type libraries from the Registry"	^self unregisterIn: self currentUserClassesBase.</body><body package="Com- Automation">unregisterGlobally	"Remove all my entries and type libraries from the Registry"	^self unregisterIn: self globalClassesBase.</body><body package="Com- Automation">unregisterIn: clsRoot	self entriesSorted		reverseDo: [:association | clsRoot removeKey: association key].	^true</body></methods><methods><class-id>External.COMAbstractRegistration class</class-id> <category>instance creation</category><body package="Com- Automation">new	^super new initialize</body></methods><methods><class-id>External.RecordArrayElementAccessElement</class-id> <category>accessing</category><body package="Com- Automation">index	^index</body><body package="Com- Automation">index: anObject	index := anObject</body></methods><methods><class-id>External.RecordArrayElementAccessElement</class-id> <category>member accessing</category><body package="Com- Automation">getMemberIn: aRecord	| array variant |	variant := aRecord basicRefMemberAt: name.	^	[array := variant realValue value.	array at: index]			ensure: [variant invalidate]</body><body package="Com- Automation">getMemberReferenceIn: aRecord	| variant safeArray |	variant := super getMemberReferenceIn: aRecord.	^ [ safeArray := variant realValue value.	 safeArray referenceAt: self index. ]	ensure: [ variant enforceRelease ].</body><body package="Com- Automation">setValue: aValue in: aRecord	| refVariant safeArray |	refVariant := aRecord basicRefMemberAt: name.	safeArray := refVariant realValue value.	safeArray at: index put: aValue.</body></methods><methods><class-id>External.RecordArrayElementAccessElement class</class-id> <category>instance creation</category><body package="Com- Automation">basicFromString: aString	| aStream indexString indexCollection aName |	aStream := aString readStream.	aName := aStream upTo: $[.	indexString := aStream upTo: $].	indexCollection := indexString tokensBasedOn: $,.	indexCollection := indexCollection collect: [:each | Number readFromString: each ].	^ self newName: aName asSymbol index: indexCollection.</body><body package="Com- Automation">newName: aName index: indexCollection	^ (self newName: aName)		index: indexCollection;		yourself</body></methods><methods><class-id>External.COMModuleSpecificationTable</class-id> <category>specification construction</category><body package="Com- Automation">addPropertySpecifications: anITypeInfo typeAttr: aTypeAttr        " Add the property specifications defined by &lt;anITypeInfo&gt; to the receiver's specification table. "    | nVariables nFunctions aDispatchSpecification       aVarDesc aFuncDesc names      aPropertyName keyValue |    self iid: aTypeAttr guid.  " IID of the dispatch interface "    self name: ( self getTypeInfoName: anITypeInfo ).  " descriptive name "    self lcid: aTypeAttr lcid.    nVariables := aTypeAttr variableCount.    nFunctions := aTypeAttr functionCount.    " construct the simple get/set property specifications "    1 to: nVariables do:        [ :index |        aVarDesc := anITypeInfo getVarDesc: index - 1.        aVarDesc isDispatch            ifTrue: [                aDispatchSpecification := COMDispatchPropertySpecification                    forDescription: aVarDesc                    typeInfo: anITypeInfo.                self add: aDispatchSpecification ] 			ifFalse: [ 				aVarDesc isConstant					ifTrue: [ self add: (ConstantDescription fromVarDesc: aVarDesc) ]					ifFalse:[self halt]].        aVarDesc enforceRelease ].    " construct the property specifications for parameterized get/set functions "    1 to: nFunctions do:        [ :index |        aFuncDesc := anITypeInfo getFuncDesc: index - 1.        aFuncDesc isRestricted            ifFalse: [                ( aFuncDesc isPropertyGet                or: [ aFuncDesc isPropertyPut                or: [ aFuncDesc isPropertyPutRef ] ] )                    ifTrue: [                        names := anITypeInfo getNames: aFuncDesc memberID                            count: 1.                        aPropertyName := names at: 1.                        keyValue := ( specificationKey = #memberID                            ifTrue: [ aFuncDesc memberID ]                            ifFalse: [ specificationKey = #name                                ifTrue: [ aPropertyName ]                                ifFalse: [ COMError raiseSignal: #ErrKeyNotSupported &lt;&lt; #com &gt;&gt; 'key not supported for property construction' ] ] ).                        aDispatchSpecification := self at: keyValue                            ifAbsent: [ nil ].                        aDispatchSpecification isNil                            ifTrue: [                                aDispatchSpecification := ( aFuncDesc parameterCount = 0						ifTrue: [ COMDispatchPropertySpecification ]						ifFalse: [ COMDispatchParameterizedPropertySpecification ] )                                    	forDescription: aFuncDesc                                    	typeInfo: anITypeInfo.                                self add: aDispatchSpecification ]                            ifFalse: [  " merge the get/set info with the previously processed set/get info "                                aDispatchSpecification isParameterized                                     ifTrue: [  " only parameterized properties need merging "                                        aDispatchSpecification mergeOperationDescription: aFuncDesc                                            typeInfo: anITypeInfo ] ].                        ].                ].        aFuncDesc enforceRelease ].</body></methods><methods><class-id>External.COMTypeCompilerBoundName</class-id> <category>testing</category><body package="Com- Automation">isFunction    ^self description isFuncDesc</body><body package="Com- Automation">isVariable    ^self description isVarDesc</body></methods><methods><class-id>External.COMTypeCompilerBoundName</class-id> <category>private-accessing</category><body package="Com- Automation">description: aDesc    description := aDesc</body></methods><methods><class-id>External.COMTypeCompilerBoundName</class-id> <category>accessing</category><body package="Com- Automation">description    ^description</body><body package="Com- Automation">parameterCount    ^self isFunction        ifTrue: [ self description parameterCount ]        ifFalse: [ 0 ]</body></methods><methods><class-id>External.COMTypeCompilerBoundName</class-id> <category>releasing</category><body package="Com- Automation">release    | temp |    temp := self description.    self description: nil.    temp enforceRelease.    self typeInfo: nil.    super release.</body></methods><methods><class-id>External.COMTypeCompilerBoundName class</class-id> <category>instance creation</category><body package="Com- Automation">name: aName typeInfo: anITypeInfo description: aDesc    "Answer a new instance of the receiver initialized with the arguments."    ^self new	  name: aName;        typeInfo: anITypeInfo;        description: aDesc;        yourself</body></methods><methods><class-id>External.SinkConfiguration</class-id> <category>accessing</category><body package="Com- Automation">connectionPointIID	^connectionPointIID</body><body package="Com- Automation">connectionPointIID: anObject	connectionPointIID := anObject</body><body package="Com- Automation">connectionPointInterface	^connectionPointInterface</body><body package="Com- Automation">connectionPointInterface: anObject	connectionPointInterface := anObject</body><body package="Com- Automation">registrationToken	^registrationToken</body><body package="Com- Automation">registrationToken: anObject	registrationToken := anObject</body><body package="Com- Automation">sinkInterface	^sinkInterface</body><body package="Com- Automation">sinkInterface: anObject	sinkInterface := anObject</body><body package="Com- Automation">specificationTable	^specificationTable</body><body package="Com- Automation">specificationTable: anObject	specificationTable := anObject</body></methods><methods><class-id>External.SinkConfiguration</class-id> <category>tools</category><body package="Com- Automation">basicEstablishConnectionTo: anInterface	" Establish an event connection to the event source object 		which supports &lt;anInterface&gt;. "	" obtain the outgoing dispatch interface of the connection point		from the event source object "	| anIConnectionPointContainer anIConnectionPoint aRegistrationToken |	anIConnectionPointContainer := anInterface				queryInterface: IID_IConnectionPointContainer.	anIConnectionPointContainer == nil ifTrue: [^false].	anIConnectionPoint := anIConnectionPointContainer				findConnectionPoint: self connectionPointIID.	"The connection point container may cause problems if the dispatch driver is released before it"	anIConnectionPoint == nil ifTrue: [^false].	" connect our incoming dispatch interface for the event set to the source "	aRegistrationToken := anIConnectionPoint advise: self sinkInterface.	aRegistrationToken ifNil: [^false].	self		connectionPointInterface: anIConnectionPoint;		registrationToken: aRegistrationToken.	^true</body><body package="Com- Automation">disconnect	"release the connection and the connection interface"	self		releaseConnection;		releaseConnectionInterface</body><body package="Com- Automation">establishConnectionTo: anInterface	COMThreadManager isActiveProcessAnMTAProcess		ifTrue: 			[COMDevelopmentWarning				raiseSignal: #RegisteringEventHandlersInMTAIsAssumedDangerous &lt;&lt; #com						&gt;&gt; 'Registering Event handler in an MTA is assumed dangerous and may cause image freezes'].	^COMThreadManager		performInSTA: [self basicEstablishConnectionTo: anInterface]</body><body package="Com- Automation">formatEventName: aSymbol 		^ (aSymbol copyUpTo: $:) asSymbol</body><body package="Com- Automation">releaseConnection	" Release the event connection. "	| connectionTokenToRelease |	self registrationToken notNil ifFalse: [^self].	connectionTokenToRelease := self registrationToken.	self registrationToken: nil.	[self connectionPointInterface unadvise: connectionTokenToRelease]		on: COMError		do: 			[:ex |			COMDevelopmentWarning				raiseSignal: (#COMEventSinkDisconnectFailed &lt;&lt; #com						&gt;&gt; 'COM event sink disconnect failed: &lt;1s&gt;'							expandMacrosWith: ex description)]</body><body package="Com- Automation">releaseConnectionInterface	" Private - release the connection point. "		| anInterface |	self connectionPointInterface ifNil: [^self].	anInterface := self connectionPointInterface.	self connectionPointInterface: nil.	anInterface enforceRelease</body></methods><methods><class-id>External.COMSafeArray</class-id> <category>converting</category><body package="Com- Automation">asArray	" Answer the elements of the receiver as an Array. "	^self structure asArray</body><body package="Com- Automation">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	^self structure asPointerParameter</body><body package="Com- Automation">asStRepresentation	" Answer the elements of the receiver as an general Smalltalk representation of the receiver. 	  This can be a Multidimensional or a common array."	^self structure asStRepresentation</body><body package="Com- Automation">asStructureParameter	"Answer the receiver in a form suitable for passing as a structure parameter to an external function call."	^self structure asStructureParameter</body></methods><methods><class-id>External.COMSafeArray</class-id> <category>accessing</category><body package="Com- Automation">at: indices        " Answer the element of the array at the position specified by &lt;indices&gt;.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "	^self structure at: indices</body><body package="Com- Automation">at: indices put: aValue        " Set the element of the array at the position specified by &lt;indices&gt; to &lt;aValue&gt;.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "	^self structure at: indices put: aValue</body><body package="Com- Automation">baseComVariantType 	^VT_ARRAY</body><body package="Com- Automation">bounds	"return the bounds of the COMSafeArray"	^self structure reversedBounds</body><body package="Com- Automation">comVariantType	"Answer the type code which should be used to represent the receiver as a COM VARIANT value."	^self baseComVariantType | self structure typeCode</body><body package="Com- Automation">dimensions	"Answer the number of dimensions in the receiver."	^self structure dimensions</body></methods><methods><class-id>External.COMSafeArray</class-id> <category>private-accessing</category><body package="Com- Automation">structure	" Private - answer the SAFEARRAY structure for the array. "	^structure</body><body package="Com- Automation">structure: aSafeArrayStructure	" Private - set the SAFEARRAY structure for the array. "	structure := aSafeArrayStructure.</body></methods><methods><class-id>External.COMSafeArray</class-id> <category>copying</category><body package="Com- Automation">copy	" Answer a new safe array which is a copy of the receiver. "	^self class new		structure: self structure copy;		yourself</body></methods><methods><class-id>External.COMSafeArray</class-id> <category>releasing</category><body package="Com- Automation">destroyReference	" Destroy this safe array reference (without releasing it).  This service is used to relinquish ownership of the safe array. "	self callIndicatesChangeNeeded</body><body package="Com- Automation">enforceInvalidation	" Destroy this safe array reference (without releasing it).  This service is used to relinquish ownership of the safe array. "	^ self privateInvalidate</body><body package="Com- Automation">enforceRelease		" Release any system resources associated with the receiver. "	^ self privateRelease</body><body package="Com- Automation">release	" Release any system resources associated with the receiver. "	self callIsDispensable.	self structure: nil.	super release</body></methods><methods><class-id>External.COMSafeArray</class-id> <category>private</category><body package="Com- Automation">privateInvalidate	" Destroy this safe array reference (without releasing it).  This service is used to relinquish ownership of the safe array. "	self structure enforceInvalidation. 	self structure: nil.</body><body package="Com- Automation">privateRelease		" Release any system resources associated with the receiver. "	self structure notNil		ifTrue: [			self structure enforceRelease.			self structure: nil ].	super release.</body></methods><methods><class-id>External.COMSafeArray class</class-id> <category>instance creation</category><body package="Com- Automation">fromCollection: aCollection	" Answer a new instance of the receiver which contains the elements in &lt;aCollection&gt;.  Do not use this method for empty collections, instead, use fromCollection:elementType: and specify the array type."	^self fromCollection: aCollection 		elementType: ( COMVariant arrayElementTypeCodeOf: aCollection comVariantType )</body><body package="Com- Automation">fromCollection: aCollection elementType: aTypeCode	" Answer a new instance of the receiver which contains the elements in &lt;aCollection&gt; represented as values of the VARTYPE &lt;aTypeCode&gt;. "	^self new		structure: ( ( COMStructure classForStructureNamed: #SAFEARRAY )			fromCollection: aCollection			typeCode: aTypeCode );		yourself</body></methods><methods><class-id>External.COMSafeArray class</class-id> <category>utilities</category><body package="Com- Automation">acquireInterfacesIn: anIndexedCollection	"not required any more"		^ self</body><body package="Com- Automation">enumerateInterfacesIn: aCollection do: aOneArgBlock	" Enumerate the elements in &lt;aCollection&gt;, recursively enumerating the contents of elements which are themselves collections, and evaluate &lt;anOneArgBlock&gt; for each element which is a COM interface.  This service is used on collections which have been obtained from or which are being put into a SAFEARRAY, where nested arrays are represented as collections of collections. " 	aCollection do: [ :anElement |		( self isCollection: anElement )			ifTrue: [ self enumerateInterfacesIn: anElement do: aOneArgBlock ]			ifFalse: [ 				anElement isCOMInterface					ifTrue: [ aOneArgBlock value: anElement ] ] ].</body><body package="Com- Automation">isCollection: anElement	"Private." 	^( anElement isKindOf: Collection ) and: [ anElement isString not ]</body><body package="Com- Automation">releaseInterfacesIn: aCollection	"obsolete - left for backwards compatibility"	^ self</body></methods><methods><class-id>External.COMSafeArray class</class-id> <category>external-transformations</category><body package="Com- Automation">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery."	^COMExternalInterface current SAFEARRAY</body><body package="Com- Automation">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a safe array of automation data type values.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^COMSafeArrayPointerResultBuffer for: VT_VARIANT</body><body package="Com- Automation">resultValueBufferFor: aVariantType	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a safe array of &lt;aVariantType&gt; values.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^COMSafeArrayPointerResultBuffer for: aVariantType</body></methods><methods><class-id>External.COMAutomationRegistration</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	super initialize.	activeXOn := automationOption := true.	majorVersion := 1.	minorVersion := 0.</body></methods><methods><class-id>External.COMAutomationRegistration</class-id> <category>accessing</category><body package="Com- Automation">activeXOn	"return whether the '/Programmable' option should be added to the command line"	^ activeXOn</body><body package="Com- Automation">activeXOn: aBoolean	"set the value which determines whether the '/Programmable' option should be added to the command line"	activeXOn := aBoolean.</body><body package="Com- Automation">automationOption	"return whether the '/Automation' option should be added to the command line"	^ automationOption</body><body package="Com- Automation">automationOption: aBoolean	"Set the value which determines whether the '/Automation' option should be added to the command line"	automationOption := aBoolean.</body><body package="Com- Automation">clsid	^ clsid</body><body package="Com- Automation">clsid: aClassID	clsid := aClassID</body><body package="Com- Automation">enginePath	"Answer the virtual machine path "	^enginePath ifNil: [ImageConfiguration commandLine first]</body><body package="Com- Automation">enginePath: aString	enginePath := aString</body><body package="Com- Automation">imagePath	"Answer the path to this image"	^imagePath ifNil: [ObjectMemory imageName]</body><body package="Com- Automation">imagePath: aString	imagePath := aString</body><body package="Com- Automation">localServer32CommandLine	"Answer the command line of the local server"	^ (self formatPath: self enginePath) ,' ',  (self formatPath:self imagePath),' ', 		(self automationOption ifTrue: ['/Automation' ] ifFalse: [ '' ])</body><body package="Com- Automation">majorVersion	^ majorVersion</body><body package="Com- Automation">majorVersion: aNumber	majorVersion := aNumber</body><body package="Com- Automation">minorVersion		^ minorVersion</body><body package="Com- Automation">minorVersion: aNumber		minorVersion := aNumber</body><body package="Com- Automation">progID	"Return the version-specific progid of this coclass - e.g. &lt;VisualWorks.AllDataTypes.1&gt;"	^'&lt;1s&gt;.&lt;2p&gt;' expandMacrosWith: self versionIndependentDescription		with: self majorVersion</body><body package="Com- Automation">setPathsDefault	imagePath := enginePath := nil.</body><body package="Com- Automation">version: aNumber 	| decimalStream |	majorVersion := aNumber truncated.	decimalStream := aNumber fractionPart printString readStream.	decimalStream skipThrough: $..	minorVersion := Number readFrom: decimalStream</body><body package="Com- Automation">versionIndependentDescription	^ versionIndependentDescription</body><body package="Com- Automation">versionIndependentDescription: aString	versionIndependentDescription := aString.</body><body package="Com- Automation">versionIndependentProgID	^versionIndependentProgID</body><body package="Com- Automation">versionIndependentProgID: aString	versionIndependentProgID := aString</body><body package="Com- Automation">versionSpecificDescription	"Return the version-specific description for the COM coclass"	^'&lt;1s&gt; &lt;2p&gt;.&lt;3p&gt;' 		expandMacrosWith: self versionIndependentDescription		with: self majorVersion		with: self minorVersion</body></methods><methods><class-id>External.COMAutomationRegistration</class-id> <category>private</category><body package="Com- Automation">classIdString	"Return the ClassId of the COM coclass as string"	^ self clsid asString</body><body package="Com- Automation">formatPath: aPath	"utility - put the given path into quotation marks if required"	| path |	path := aPath asFilename asAbsoluteFilename asString.	^ (path includes: Character space)		ifTrue: 	[ '"', path,'"' ]		ifFalse:	[ path ]</body></methods><methods><class-id>External.COMAutomationRegistration</class-id> <category>printing</category><body package="Com- Automation">installOn: aStream 	"Variation of #storeOn: that appends a formatted code expression to aStream as necessary to recreate the receiver in a class method.  Used by the COM Automation Wizard"	super installOn: aStream.	aStream cr; tab; nextPutAll: 'versionIndependentDescription: '; print: self versionIndependentDescription; nextPut:$;.	aStream cr; tab; nextPutAll: 'versionIndependentProgID: '; print: self versionIndependentProgID; nextPut:$;.	aStream cr; tab; nextPutAll: 'clsid: self clsid;'.	aStream cr; tab; nextPutAll:	'typeLibraries: self typeLibraries;'.	aStream cr; tab; nextPutAll: 'majorVersion: '; print: self majorVersion; nextPut:$;.	aStream cr; tab; nextPutAll: 'minorVersion: '; print: self minorVersion; nextPut:$;.	activeXOn ifFalse:[aStream cr; tab; nextPutAll: 'activeXOn: false;'].	automationOption ifFalse:[aStream cr; tab; nextPutAll: 'automationOption: false;'].	aStream cr; tab; nextPutAll: 'yourself.'</body><body package="Com- Automation">storeRegistrationOn: aStream 	"Store registration entries in REGEDIT file format to aStream"	aStream cr.	aStream		nextPutAll: (#GenKey115 &lt;&lt; #com 					&gt;&gt; '; Application version independent registrations.') asString;		cr.	aStream nextPutAll: ('HKEY_CLASSES_ROOT\&lt;1s&gt; = &lt;2s&gt;&lt;n&gt;' 				expandMacrosWith: self versionIndependentProgID				with: self versionIndependentDescription).	aStream nextPutAll: ('HKEY_CLASSES_ROOT\&lt;1s&gt;\Clsid = &lt;2s&gt;&lt;n&gt;' 				expandMacrosWith: self versionIndependentProgID				with: self classIdString).	aStream cr.	aStream		nextPutAll: (#GenKey114 &lt;&lt; #com &gt;&gt; '; Application version registrations.') 					asString;		cr.	aStream nextPutAll: ('HKEY_CLASSES_ROOT\&lt;1s&gt; = &lt;2s&gt;&lt;n&gt;' 				expandMacrosWith: self progID				with: self versionSpecificDescription).	aStream nextPutAll: ('HKEY_CLASSES_ROOT\&lt;1s&gt;\Clsid = &lt;2s&gt;&lt;n&gt;' 				expandMacrosWith: self progID				with: self classIdString).	aStream nextPutAll: ('HKEY_CLASSES_ROOT\CLSID\&lt;1s&gt; = &lt;2s&gt;&lt;n&gt;' 				expandMacrosWith: self classIdString				with: self versionSpecificDescription).	aStream nextPutAll: ('HKEY_CLASSES_ROOT\CLSID\&lt;1s&gt;\ProgID = &lt;2s&gt;&lt;n&gt;' 				expandMacrosWith: self classIdString				with: self progID).	aStream 		nextPutAll: ('HKEY_CLASSES_ROOT\CLSID\&lt;1s&gt;\VersionIndependentProgID  = &lt;2s&gt;&lt;n&gt;' 				expandMacrosWith: self classIdString				with: self versionIndependentProgID).	aStream 		nextPutAll: ('HKEY_CLASSES_ROOT\CLSID\&lt;1s&gt;\LocalServer32  = &lt;2s&gt;&lt;n&gt;' 				expandMacrosWith: self classIdString				with: self localServer32CommandLine).	self defaultLCIDTypeLibIdDo: 			[:idString | 			aStream nextPutAll: ('HKEY_CLASSES_ROOT\CLSID\&lt;1s&gt;\TypeLib  = &lt;2s&gt;&lt;n&gt;' 						expandMacrosWith: self classIdString						with: idString)].	aStream nextPutAll: ('HKEY_CLASSES_ROOT\CLSID\&lt;1s&gt;\Programmable&lt;n&gt;' 				expandMacrosWith: self classIdString)</body></methods><methods><class-id>External.COMAutomationRegistration</class-id> <category>registration</category><body package="Com- Automation">registrationEntries	| clsIDKey registrationEntries |	clsIDKey := 'CLSID\' , self classIdString.	registrationEntries := super registrationEntries.	registrationEntries		at: self versionIndependentProgID put: self versionIndependentDescription;		at: self versionIndependentProgID , '\CLSID' put: self classIdString;		at: self progID put: self versionSpecificDescription;		at: self progID , '\Clsid' put: self classIdString;		at: clsIDKey put: self versionSpecificDescription;		at: clsIDKey , '\ProgID' put: self progID;		at: clsIDKey , '\VersionIndependentProgID'			put: self versionIndependentProgID;		at: clsIDKey , '\LocalServer32' put: self localServer32CommandLine.	self defaultLCIDTypeLibIdDo: 			[:idString | 			registrationEntries at: clsIDKey , '\TypeLib' put: idString].	self activeXOn 		ifTrue: [registrationEntries at: clsIDKey , '\Programmable' put: '   '].	^registrationEntries</body></methods><methods><class-id>External.CollectionDispDriverAccessor</class-id> <category>accessing</category><body package="Com- Automation">add: anObject	^ driver invokeMethod: 'Add' with: anObject</body><body package="Com- Automation">at: index 	"Query the automation Item at index &lt;index&gt;"	| param |	param := self getItemSpecification getSpecification autoWrapParameterAt: 1 value: index.	^ driver getMethod: #Item with: param.</body><body package="Com- Automation">at: index put: aValue	"Set the automation Item at index &lt;index&gt;"	^ driver setProperty: #Item withArguments: (Array with: index with: aValue).</body><body package="Com- Automation">collectionSpecies	^ OrderedCollection</body><body package="Com- Automation">getItemSpecification	^ self driver specificationNamed: #Item ifNone: [ nil ]</body><body package="Com- Automation">removeAtIndex: anIndex	^ driver invokeMethod: 'Remove' with: anIndex.</body><body package="Com- Automation">size	"Query the size of the automation collection"	^  driver isValid ifTrue: [ driver getProperty: #Count ] ifFalse: [ 0 ]</body></methods><methods><class-id>External.CollectionDispDriverAccessor</class-id> <category>private</category><body package="Com- Automation">notFoundError	"Raise a signal indicating that an object is not in the collection."	^self class notFoundSignal raise</body></methods><methods><class-id>External.CollectionDispDriverAccessor</class-id> <category>enumerating</category><body package="Com- Automation">detect: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	^self detect: aBlock ifNone: [self notFoundError]</body><body package="Com- Automation">detect: aBlock ifNone: exceptionBlock 	"Evaluate aBlock with each of the receiver's elements as the argument.	Answer the first element for which aBlock evaluates to true."	self do: [:each | (aBlock value: each) ifTrue: [^each]].	^exceptionBlock value</body><body package="Com- Automation">do: aBlock	^ self keysAndValuesDo: [:index :value | aBlock value: value ]</body><body package="Com- Automation">doWithIndex: aBlock	^self keysAndValuesDo: [:index :value | aBlock value: value value: index ]</body><body package="Com- Automation">keysAndValuesDo: aBlock	1 to: self size do: [:index |		aBlock value: index value: (self at: index) ].</body><body package="Com- Automation">select: aBlock 	"Evaluate aBlock with each of the receiver's elements as the argument. 	Collect into a new collection like the receiver, only those elements for which	aBlock evaluates to true.  Answer the new collection."	| newCollection |	newCollection := self species new.	self do: [:each | (aBlock value: each) ifTrue: [newCollection add: each]].	^newCollection</body></methods><methods><class-id>External.CollectionDispDriverAccessor</class-id> <category>printing</category><body package="Com- Automation">printDriverOn: aStream	driver basicPrintOn: aStream.	aStream nextPutAll: ' Collection (Automation)'</body></methods><methods><class-id>External.CollectionDispDriverAccessor</class-id> <category>testing</category><body package="Com- Automation">isCollection	^ true</body></methods><methods><class-id>External.CollectionDispDriverAccessor class</class-id> <category>private</category><body package="Com- Automation">isResponsibleFor: aDispatchDriver	(aDispatchDriver specificationTable includesKey: 'Item') ifFalse: [^false].	(aDispatchDriver specificationTable includesKey: '_NewEnum')		ifFalse: [^false].	(aDispatchDriver specificationTable includesKey: 'Count')		ifFalse: [^false].	^	[aDispatchDriver getMethod: 'Count'.	true] on: Error			do: [:ex | ex return: false]</body></methods><methods><class-id>COMSafeArrayReferenceAccessor</class-id> <category>private accessing</category><body package="Com- Automation">elementAt: indices        " Private - Answer the value at &lt;indices&gt;.        If the element is an interface, the API calls AddRef on the interface before returning.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "	| resultReference |	resultReference := nil asValueReference.	OLEAutomationDLL current SafeArrayGetElementReference: safeArray		_: (self normalizeCoordinates: indices)		_: resultReference.	^resultReference value</body><body package="Com- Automation">privateAt: indices        " Answer the element of the array at the position specified by &lt;indices&gt;.        If the element is an interface, the API calls AddRef on the interface before returning.        The array of indices is from least to most significant.        The receiver is interpreted as having 1-based indices. "    | depth |    depth := safeArray cDims - indices size.    depth &lt; 0        ifTrue: [ COMError raiseSignal: #ErrInvalidIndicies &lt;&lt; #com &gt;&gt; 'Invalid array indices.' ].    depth = 0        ifTrue: [ ^self elementAt: indices ].    ^self error: (#AccessingReferencesToSubArraysNotAllowed &lt;&lt; #com &gt;&gt; 'It is not allowed to access references to subarrays')</body></methods><methods><class-id>COMSafeArrayReferenceAccessor class</class-id> <category>private</category><body package="Com- Automation">supports: aSafeArray		^ false</body></methods><methods><class-id>COMSafeArrayReferenceAccessor class</class-id> <category>instance creation</category><body package="Com- Automation">onSafeArray: aSafeArray	^ self new		safeArray: aSafeArray;		yourself</body></methods><methods><class-id>External.MissingAutomationArgument</class-id> <category>accessing</category><body package="Com- Automation">value	^ nil</body></methods><methods><class-id>External.MissingAutomationArgument</class-id> <category>updating arguments</category><body package="Com- Automation">updateServerArgumentIn: aVariantArray	^ self</body></methods><methods><class-id>External.MissingAutomationArgument class</class-id> <category>instance creation</category><body package="Com- Automation">default	^ Default ifNil: [ Default := self new ].</body></methods><methods><class-id>External.BSTRStringPointerArrayResultBuffer</class-id> <category>accessing</category><body package="Com- Automation">atAllPut: aValue 	"Put &lt;aValue&gt; in every element of the receiver's buffer."	self shouldNotImplement.</body></methods><methods><class-id>External.BSTRStringPointerArrayResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Automation">getResultValuesFrom: startIndex to: stopIndex 	" Private. Convert the contents into a array.  Answer the array. "	| nValues anArray lplpBstr lpBstr aString |	buffer isPointer 		ifFalse: [self error: #ErrNotImplemented &lt;&lt; #com &gt;&gt; 'not yet implemented'].	" believe this is not gonna be polymorphic, sigh [DL 11-May-97] "	lplpBstr := buffer copy.	nValues := stopIndex - startIndex + 1.	anArray := Array new: nValues.	1 to: nValues		do: 			[:i | 			lpBstr := lplpBstr contents.			aString := BSTRStringPointerResultBuffer stringFromBSTRPointer: lpBstr.	"BSTRStringPointerBuffer"			anArray at: i put: aString.			lplpBstr increment].	^anArray</body></methods><methods><class-id>External.BSTRStringPointerArrayResultBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Automation">releaseBufferContents	| lplpBstr lpBstr |	lplpBstr := buffer copy.	1 to: self bufferElementCount		do: 			[:i |			lpBstr := lplpBstr contents.			lpBstr isValid ifTrue: [ BSTRStringPointerResultBuffer releaseBSTRAtPointer: lpBstr ].			lplpBstr increment].</body></methods><methods><class-id>External.BSTRStringPointerArrayResultBuffer class</class-id> <category>instance creation</category><body package="Com- Automation">new: nElements	" Answer a new instance of the receiver with a buffer of &lt;nElements&gt;. "	^self basicNew		bufferElementType: BSTR baseCType;		bufferElementCount: nElements;		initialize;		yourself</body><body package="Com- Automation">type: aType count: nElements	" Answer a new instance of the receiver with a buffer for &lt;nElements&gt; of type &lt;aType&gt;. "	" use #new: because we already know this is BSTR-land "	self shouldNotImplement.</body></methods><methods><class-id>External.ILicenseManagerImplementation</class-id> <category>interface operations</category><body package="Com- Automation">CreateInstance: class _: pUnkOuter _: riid _: license _: resultReference	" Invoke the ILicenseManager::CreateInstance function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor CreateInstance: class _: pUnkOuter _: riid _: license _: resultReference		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Automation">IsDevelopment: class _: resultReference	" Invoke the ILicenseManager::IsDevelopment function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor IsDevelopment: class _: resultReference		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Automation">QueryLicenseKey: class _: resultReference	" Invoke the ILicenseManager::QueryLicenseKey function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor QueryLicenseKey: class _: resultReference		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.ILicenseManagerImplementation</class-id> <category>private-invocation</category><body package="Com- Automation">invokeCreateInstance: this _: class _: pUnkOuter _: riid _: license _: ppvObject	" Private - invoke the ILicenseManager::CreateInstance function for an external caller. "	" HRESULT __stdcall  CreateInstance(CLSID * class, IUnknown * pUnkOuter, REFIID riid, BSTR license, void * * ppvObject) = 4 "	"**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^	[" terminate exception stack unwind at function invocation boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	class isNull ifTrue: [^E_INVALIDARG].	riid isNull ifTrue: [^E_INVALIDARG].	ppvObject isNull ifTrue: [^E_INVALIDARG].	self clearResultBufferAtAddress: ppvObject.	resultReference := nil asValueReference.	hresult := implementor				CreateInstance: (self guidAtAddress: class)				_: (self interfaceAtAddress: pUnkOuter type: IUnknown)				_: (self guidAtAddress: riid)				_: (self stringAtBSTRPointer: license)				_: resultReference.	(HRESULT succeeded: hresult)		ifTrue: [self interfaceResultAtAddress: ppvObject put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Automation">invokeIsDevelopment: this _: class _: result	" Private - invoke the ILicenseManager::IsDevelopment function for an external caller. "	" HRESULT __stdcall  IsDevelopment(CLSID * class, BOOL * result) = 3 "	"**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^	[" terminate exception stack unwind at function invocation boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	class isNull ifTrue: [^E_INVALIDARG].	result isNull ifTrue: [^E_INVALIDARG].	self clearResultBufferAtAddress: result.	resultReference := nil asValueReference.	hresult := implementor IsDevelopment: (self guidAtAddress: class)				_: resultReference.	(HRESULT succeeded: hresult)		ifTrue: [self scalarResultAtAddress: result put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Automation">invokeQueryLicenseKey: this _: class _: result	" Private - invoke the ILicenseManager::QueryLicenseKey function for an external caller. "	" HRESULT __stdcall  QueryLicenseKey(CLSID * class, BSTR * result) = 5 "	"**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^	[" terminate exception stack unwind at function invocation boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	class isNull ifTrue: [^E_INVALIDARG].	result isNull ifTrue: [^E_INVALIDARG].	self clearResultBufferAtAddress: result.	resultReference := nil asValueReference.	hresult := implementor QueryLicenseKey: (self guidAtAddress: class)				_: resultReference.	(HRESULT succeeded: hresult)		ifTrue: [self bstrResultAtAddress: result put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Automation">invokeRelease: this		"Private - invoke the IUnknown::Release function for an external caller. "	" ULONG Release( void); "	^[   " terminate exception stack unwind at external callin boundary "	self dispatchRelease.	] on: self rootExceptions   		do: ( self exceptionHandlerForZeroReturnValue: #externalCallin )</body></methods><methods><class-id>External.ILicenseManagerImplementation class</class-id> <category>private-installation</category><body package="Com- Automation">initialize	" ILicenseManagerImplementation initialize "	self iid: IID_ILicenseManager.	self vtableSignatureTypeName: #__ILicenseManagerVtbl.	self updateAndRegister</body></methods><methods><class-id>External.AutomationOwnedReference</class-id> <category>testing</category><body package="Com- Automation">equalsCOMTypeSpec: t1	^false</body></methods><methods><class-id>External.BSTRStringPointerResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Automation">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^BSTR baseCType</body></methods><methods><class-id>External.BSTRStringPointerResultBuffer</class-id> <category>subclass-testing</category><body package="Com- Automation">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" force to external memory, at least until you figure out how to work with fixed space "	^false</body></methods><methods><class-id>External.BSTRStringPointerResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Automation">getResultValue	" Private - convert the contents into a String.  Release the external COM memory of the BSTR.  Answer the string. "	^self class stringFromBSTRPointer: buffer contents</body></methods><methods><class-id>External.BSTRStringPointerResultBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Automation">releaseBufferContents	" Private - release the contents of the buffer if necessary.   Should be reimplemented by subclasses which manage buffers containing pointers to owned memory. "	self class releaseBSTRAtPointer:  buffer contents</body></methods><methods><class-id>External.BSTRStringPointerResultBuffer class</class-id> <category>private-object construction</category><body package="Com- Automation">releaseBSTRAtPointer: lpBstr	" Private - convert the contents of the BSTR at &lt;lpBstr&gt; into a String.  Release the external COM memory of the BSTR.  Answer the string. "	| aBSTR |	lpBstr isNull		 ifTrue: [ ^nil ].	aBSTR := BSTR onNew: ( BSTRMemoryAddress fromPointer: lpBstr ).	aBSTR enforceRelease.	"lpBstr contents: 0."  " overzealous, perhaps, but darned safe "</body><body package="Com- Automation">stringFromBSTRPointer: lpBstr	" Private - convert the contents of the BSTR at &lt;lpBstr&gt; into a String.  Release the external COM memory of the BSTR.  Answer the string. "	lpBstr isNull ifTrue: [^nil].	^(BSTR temporaryOn: (BSTRMemoryAddress fromPointer: lpBstr)) asString</body></methods><methods><class-id>External.PropertyPutRefSpecification</class-id> <category>utilities</category><body package="Com- Automation">addTo: aGeneralPropertySpecification	aGeneralPropertySpecification propertyPutRefSpecification: self.</body></methods><methods><class-id>External.PropertyPutRefSpecification</class-id> <category>accessing</category><body package="Com- Automation">invokationType		^ DISPATCH_PROPERTYPUTREF</body></methods><methods><class-id>External.COMStructure class</class-id> <category>automation data type conversions</category><body package="Com- Automation">externalFloatFromInternalFloat: aFloat	" Answer a 4-byte array that represents &lt;aFloat&gt; as a C type #float, where &lt;aFloat&gt; corresponds to the C type #double.  A COMError will be signaled if &lt;aFloat&gt; cannot be represented as a #float."	| resultReference |	resultReference := nil asValueReference.	OLEAutomationDLL current VarR4FromR8: aFloat _: resultReference.	^resultReference value</body><body package="Com- Automation">internalFloatFromExternalFloat: singleFloatBytes	" Answer a Float, representin the value as the C type #double, which is created by converting the 4-byte array &lt;singleFloatBytes&gt;, corresponding to the C type #float.  A COMError will be signaled if &lt;singleFloatBytes&gt; cannot be represented as a #double. "	| resultReference |	resultReference := nil asValueReference.	OLEAutomationDLL current VarR8FromR4: singleFloatBytes _: resultReference.	^resultReference value</body></methods><methods><class-id>External.COMStructure class</class-id> <category>private-installation</category><body package="Com- Automation">registerAutomationStructureSpecifications	" Private - register specifications for automation structures "	| aProtocolMap |	" ( COMExternalInterface typeNamed: #CONNECTDATA ) type type "	aProtocolMap := IdentityDictionary new		" dwCookie is a simple DWORD, so the usual #memberAt: is fine "		at: #pUnk   " #memberGet "			put: ( Array with: #interfaceMemberAt:type:				with: ( Array with: '&lt;memberName&gt;' with: IUnknown ) );		at: #pUnk:  " #memberSet  "			put: #( #interfaceMemberAt:put: #( '&lt;memberName&gt;' '&lt;1&gt;' ) ) ;  		yourself.	COMStructure registerTypeName: #CONNECTDATA 		adaptorProtocol: aProtocolMap.	" the system is sensitive to typedefs, unfortunately, so we have to watch out for them "	COMStructure registerStructureNameSynonyms: #CONNECTDATA.	IEnum registerEnumeratorIID: IID_IEnumConnections		for: #CONNECTDATA.</body><body package="Com- Automation">unregisterAutomationStructureSpecifications	" Private - remove the registration of protocol specifications for automation structures "	COMStructure unregisterTypeName: #CONNECTDATA.	IEnum removeEnumeratorIID: IID_IEnumConnections.</body></methods><methods><class-id>External.COMStructure</class-id> <category>accessing-members</category><body package="Com- Automation">bstrMemberAt: aMemberName	" Answer a string containing the characters stored in external memory in the BSTR referenced by &lt;aMemberName&gt;. "	^self		withRefMemberPointer: aMemberName		do: [:pointer | (BSTR temporaryOn: (BSTRMemoryAddress fromPointer: pointer)) asString]		ifNil: [nil]</body><body package="Com- Automation">bstrMemberAt: aMemberName put: aString	" Set the BSTR member &lt;aMemberName&gt; to a newly allocated BSTR containing the characters of &lt;aString&gt;.  Ownership responsibility for releasing the BSTR goes with the structure. "	"make sure we release referenced memory before we overwrite the pointer"	| aBstr |	self releaseBstrMemberAt: aMemberName.	aString isNil		ifTrue: 			["#releaseBstrMemberAt: clears the pointer"			^self].	aBstr := BSTRMemoryAddress allocateString: aString.	[self memberAt: aMemberName put: aBstr asPointerParameter]		ensure: [aBstr enforceInvalidation]</body><body package="Com- Automation">refVariantMemberAt: aMemberName	" Answer the value of the variant at &lt;aMemberName&gt;. "	^ self		withRefMemberPointer: aMemberName		do: [:pointer | (COM_VARIANT temporaryOn: pointer) value]		ifNil: [nil]</body><body package="Com- Automation">refVariantMemberAt: aMemberName put: aValue	" set the value of the variant variant member at &lt;aMemberName&gt;. "	| var |	self releaseRefVariantMemberAt: aMemberName.	var := COM_VARIANT new value: aValue.	[self memberAt: aMemberName put: var asPointerParameter]		ensure: [var enforceInvalidation]</body></methods><methods><class-id>External.COMStructure</class-id> <category>releasing-members</category><body package="Com- Automation">releaseBstrMemberAt: aMemberName	" Private - release the BSTR at &lt;aMemberName&gt;. "	^self releaseRefMemberAt: aMemberName ofType: BSTR</body></methods><methods><class-id>External.COMStructure</class-id> <category>private</category><body package="Com- Automation">releaseRefMemberAt: aMemberName ofType: aType	" Private - release the Variant member referenced by &lt;aMemberName&gt;. "	| pointer |	pointer := self memberAt: aMemberName.	pointer isNull		ifFalse: 			[(aType temporaryOn: pointer) enforceRelease.			self memberAt: aMemberName put: NULL]</body></methods><methods><class-id>External.COMStructure</class-id> <category>releasing-members</category><body package="Com- Automation">releaseRefVariantMemberAt: aMemberName	" Private - release the Variant member referenced by &lt;aMemberName&gt;. "	^self releaseRefMemberAt: aMemberName ofType: COM_VARIANT</body><body package="Com- Automation">releaseSafeArrayMemberAt: aMemberName	^ self releaseRefMemberAt: aMemberName ofType: COM_SAFEARRAY</body><body package="Com- Automation">releaseVariantMemberAt: aMemberName	" Private - release the Variant member at &lt;aMemberName&gt;. "	(COM_VARIANTARG temporaryOn: (self structure refMemberAt: aMemberName))		clear</body></methods><methods><class-id>External.COMStructure</class-id> <category>accessing-members</category><body package="Com- Automation">safeArrayMemberAt: aMemberName	" Answer a string containing the characters stored in external memory in the BSTR referenced by &lt;aMemberName&gt;. "	^self		withRefMemberPointer: aMemberName		do: [:pointer | (COM_SAFEARRAY temporaryOn: pointer) asArray]		ifNil: [nil]</body><body package="Com- Automation">safeArrayMemberAt: aMemberName put: anArray	" Set the value of the safeArray referenced by &lt;aMemberName&gt; to &lt;anArray&gt;. "	| safeArray |	self releaseSafeArrayMemberAt: aMemberName.	safeArray := COMSafeArray fromCollection: anArray.	[self memberAt: aMemberName put: safeArray asPointerParameter]		ensure: [safeArray enforceInvalidation]</body><body package="Com- Automation">variantMemberAt: aMemberName	" Answer the value of the variant at &lt;aMemberName&gt;. "	^(COM_VARIANT temporaryOn: (structure refMemberAt: aMemberName)) value</body><body package="Com- Automation">variantMemberAt: aMemberName put: aValue	" set the value of the variant variant member at &lt;aMemberName&gt;. "	^(COM_VARIANT temporaryOn: (structure refMemberAt: aMemberName))		value: aValue</body></methods><methods><class-id>External.COMStructure</class-id> <category>private</category><body package="Com- Automation">withRefMemberPointer: aMemberName do: aBlock ifNil: aNilBlock	" Do something with a member pointer if it is valid"	| aPointer |	self isValid ifFalse: [^aNilBlock value].	aPointer := self memberAt: aMemberName.	^aPointer isNull ifTrue: aNilBlock ifFalse: [aBlock value: aPointer]</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^13  "VT_UNKNOWN"</body></methods><methods><class-id>Core.Double</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_R8</body></methods><methods><class-id>External.COMInterfaceValueReference</class-id> <category>accessing</category><body package="Com- Automation">comVariantType	"Return the receivers COM Variant type. I am a container for any kind of Interfaces. 	 So my variant type is VT_UNKNOWN | VT_BYREF"	^External.COMAutomationConstants.VT_UNKNOWN | self baseComVariantType</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>instance creation (licensing support)</category><body package="Com- Automation">createInstance: aClassId context: classExecutionContext licenseKey: aString	| options |	self		deprecated: #(#initial '8.1' #use 'createInstance:options:' #sunset '8.2').	options := (COMCreationOptions new)				clsid: aClassId;				iid: IID_IUnknown;				context: classExecutionContext;				licenseKey: aString;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createInstance: aClassId iid: anIIDOrSymbol controllingUnknown: controllingUnknown context: classExecutionContext licenseKey: aKey	| options |	self		deprecated: #(#initial '8.1' #use 'createInstance:options:' #sunset '8.2').	options := (COMCreationOptions new)				clsid: aClassId;				iid: anIIDOrSymbol;				controllingUnknown: controllingUnknown;				context: classExecutionContext;				licenseKey: aKey;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createInstance: aClassId iid: anIIDOrSymbol controllingUnknown: controllingUnknown context: classExecutionContext serverName: serverName licenseKey: aKey							| options |	self		deprecated: #(#initial '8.1' #use 'createInstance:options:' #sunset '8.2').	options := (COMCreationOptions new)				clsid: aClassId;				iid: anIIDOrSymbol;				controllingUnknown: controllingUnknown;				context: classExecutionContext;				serverName: serverName;				licenseKey: aKey;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createInstance: aClassId iid: anIID licenseKey: aString	| options |	options := (COMCreationOptions new)				clsid: aClassId;				iid: anIID;				licenseKey: aString;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Automation">createInstance: aClassId licenseKey: aString	| options |	options := (COMCreationOptions new)				clsid: aClassId;				licenseKey: aString;				yourself.	^self createInstanceWithOptions: options</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>licensing support</category><body package="Com- Automation">requestLicenseInfo: aClassID	^self requestLicenseInfo: aClassID context: CLSCTX_ALL serverName: nil</body><body package="Com- Automation">requestLicenseInfo: aClassID context: context serverName: serverName	| instance |	instance := IClassFactory2				forCLSID: aClassID				context: context				serverName: serverName.	^[instance getLicInfo] ensure: [instance enforceRelease]</body><body package="Com- Automation">requestLicenseKey: aClassID	^self requestLicenseKey: aClassID context: CLSCTX_ALL serverName: nil</body><body package="Com- Automation">requestLicenseKey: aClassID context: context serverName: serverName	| instance |	instance := IClassFactory2				forCLSID: aClassID				context: context				serverName: serverName.	^[instance requestLicKey] ensure: [instance enforceRelease]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="Com- Automation">marshalCOMEnumType: anEnumType	^ anEnumType marshalCollectionInParam: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>calling</category><body package="Com- Automation">setArgumentsInCOMCall: anAutomationCall	"invoke the automation call with indexed arguments"	^ anAutomationCall arguments: self</body></methods><methods><class-id>Core.Object class</class-id> <category>marshaling</category><body package="Com- Automation">defaultDispatchTypeClass	^ DispSimpleTypeSpec</body><body package="Com- Automation">fromUDTObject: aCOMObject ofType: aTypeDescription	^ aCOMObject setVariablesIn: self new usingType: aTypeDescription</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Com- Automation">asCOMRecordSpecifiedBy: aRecordInfo	^ aRecordInfo createRecordWith: self</body><body package="Com- Automation">asCOMVariant	" Answer the receiver as a COM VARIANT.  Answer nil if the receiver cannot be represented by a known VARIANT type. "	| aTypeCode |	( aTypeCode := self comVariantType ) isNil		ifTrue: [ ^nil ].	^( COMStructure classForStructureNamed: #VARIANT )		type: aTypeCode		value: self</body><body package="Com- Automation">baseComVariantType	" Answer the base com variant type. Normally this is the com variant type except for some special cases like value references and arrays."	^self comVariantType</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="Com- Automation">comTypeDescription	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Answer nil if the receiver cannot be represented as by a known variant type. "	^ DispTypeSpec fromVariantTypeCode: self comVariantType</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Answer nil if the receiver cannot be represented as by a known variant type. "	^ self error: #VariantTypeCodeNotDefinedForClass &lt;&lt; #com &gt;&gt; 'Variant Typecode not defined for class'</body></methods><methods><class-id>Core.Object</class-id> <category>marshaling</category><body package="Com- Automation">dispatchTypeClass	^self class defaultDispatchTypeClass</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="Com- Automation">equalToEnumConstant: anEnumConstant	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Com- Automation">isByteArray	"Was added for performance reasons."	^ false</body><body package="Com- Automation">isCollection	"Was added for performance reasons."	^ false</body><body package="Com- Automation">isNothing	"Answer whether I represent nothing"	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="Com- Automation">marshalCOMEnumType: anEnumType	self shouldNotImplement</body><body package="Com- Automation">marshalStructureType: aType cType: cType intoStruct: aDatum</body><body package="Com- Automation">marshalUnionType: aType cType: cType intoStruct: aDatum	self shouldNotImplement</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Com- Automation">putValuesIntoCOMRecord: record	"Put my values into the COMRecord. Provided this default implementation instead of	 'self subclassResponsibility' "	| value |	self class allInstVarNames keysAndValuesDo: [:anIndex :name |		value := self instVarAt: anIndex.		record memberAt: name asSymbol put: value].</body></methods><methods><class-id>Core.Object</class-id> <category>calling</category><body package="Com- Automation">setArgumentsInCOMCall: anAutomationCall	"When this point is reached the develop has made the mistake to pass a single parameter using multi parameter syntax"	^ self error: #PassedOneArgumentAsMany &lt;&lt;#com &gt;&gt; 'The automation member should be invoked using a many arguments syntax but only one parameter was provided'</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Com- Automation">setCOMRecordInVariant: aVariant	| record |	record := aVariant ownCOMRecord.	self putValuesIntoCOMRecord: record.	record enforceInvalidation.</body><body package="Com- Automation">setCOMVariant: aVariant	" Set the type and value of the COM VARIANT &lt;aVariant&gt; to describe the receiver.  Raise a COM exception if the receiver cannot be represented as a VARIANT value. "	self comVariantType isNil ifTrue: [^COMVariant errorNoVariant].	aVariant value: self</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="Com- Automation">setVariantRefValueIn: aVariant	aVariant commonSetRefValue: self.</body></methods><methods><class-id>Core.Date</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_DATE</body></methods><methods><class-id>Core.Timestamp</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_DATE</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>subclass-initializing</category><body package="Com- Automation">initializeInterfaces	" Private - Allocate any interfaces which are expected to be required  during the object's lifetime. "	super initializeInterfaces.	iClassFactory := IClassFactory2 directBindingOn: self.</body></methods><methods><class-id>External.COMInterface class</class-id> <category>subclass-testing</category><body package="Com- Automation">isDispatch	" Answer whether the receiver is a dispatch interface which supports IDispatch. "	^false</body></methods><methods><class-id>External.COMInterface</class-id> <category>testing</category><body package="Com- Automation">isDispatch	" Answer whether the receiver is a dispatch interface which supports IDispatch. "	^self class isDispatch</body></methods><methods><class-id>External.COMInterface</class-id> <category>subclass-error handling</category><body package="Com- Automation">signalDispatchError: hresult exceptionInfo: exceptionInfo argError: argError	" Private - signal an exception indicating dispatch invoke error. "	[	hresult = DISP_E_EXCEPTION		ifTrue: [			COMDispatchError hresult: hresult				description: exceptionInfo description 				info: exceptionInfo ].	hresult = DISP_E_TYPEMISMATCH		ifTrue: [			COMDispatchError hresult: hresult				description: (#ArgumentTypeMismatch &lt;&lt; #com &gt;&gt; 'Argument type mismatch') asString				info: argError ].	] ensure: [ 		exceptionInfo enforceRelease ].</body></methods><methods><class-id>External.COMInterfaceBinding class</class-id> <category>testing</category><body package="Com- Automation">isDispatch	" Answer whether the receiver is a dispatch interface which supports IDispatch. "	^false</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>testing</category><body package="Com- Automation">isDispatch	" Answer whether the receiver is a dispatch interface which supports IDispatch. "	^self class isDispatch</body></methods><methods><class-id>External.Win32KernelDLL</class-id> <category>API operations</category><body package="Com- Automation">getLocaleInfo: aLocale lcType: LCType 	| cchData lpLCData |	cchData := 255.	lpLCData := Win32ExternalInterface current WCHAR gcCalloc: 300.	self invokeGetLocaleInfo: aLocale lcType: LCType  lpLCData: lpLCData cchData: cchData.	^ lpLCData copyUnicodeStringFromHeap</body></methods><methods><class-id>Core.LargeNegativeInteger</class-id> <category>arithmetic</category><body package="Com- Automation">comVariantType	^self &lt;= -9223372036854775806		ifTrue: [External.COMAutomationConstants.VT_DECIMAL]		ifFalse: [External.COMAutomationConstants.VT_I8]</body></methods><methods><class-id>External.COMObject</class-id> <category>accessing</category><body package="Com- Automation">enumConstantNamed: aName	"Compatibility to COMDispatchDriver"	^ COMTypeLibrary enumConstantNamed: aName</body><body package="Com- Automation">enumConstantNamed: constant inTypeNamed: typeName	"Compatibility to COMDispatchDriver"	^ COMTypeLibrary enumConstantNamed: constant inTypeNamed: typeName</body></methods><methods><class-id>External.IUnknown class</class-id> <category>active object services</category><body package="Com- Automation">getActiveObject: aClassId	" Answer the IUnknown interface of the active object of the COM automation class specified by the specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID, which has been registered by a running COM automation server application. "	" Note: to get an interface other than IUnknown, use the #onActiveObject: message "	| aCLSID resultReference |	aCLSID := IClassFactory getCLSID: aClassId.	resultReference := self new asValueReference.	OLEAutomationDLL current GetActiveObject: aCLSID 		_: nil		_: resultReference.	^resultReference value</body><body package="Com- Automation">onActiveObject: aClassId 	" Answer a new instance of the receiver on the active object of the COM automation class specified by the specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  Raise a COMError if there is no active object.  Answer nil if if there is an active object but the requested interface is not supported.  Note: this is equivalent to VBA's GetObject(,ProgID) function."	| anIUnknown |	anIUnknown := IUnknown getActiveObject: aClassId.	anIUnknown isNil 		ifTrue: 			[COMError 				raiseSignal: (#ErrNamedNoActiveObj &lt;&lt; #com 						&gt;&gt; 'There is no active object of the class &lt;1p&gt;' expandMacrosWith: aClassId)].	self iid = IID_IUnknown ifTrue: [^anIUnknown].	^ anIUnknown basicQueryInterface: self iid</body></methods><methods><class-id>External.IUnknown</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^self interfaceBinding comVariantType</body></methods><methods><class-id>External.IUnknown</class-id> <category>private invoking</category><body package="Com- Automation">getMethodSpec: aCOMCall withArguments: arguments	| specification |	specification := aCOMCall specification member getSpecification.	^[specification performCallOn: self withParameters: arguments]		on: ExternalAccessFailed		do: [:ex | self handleCallError: ex]</body><body package="Com- Automation">getPropertySpec: aCOMCall	| specification |	specification := aCOMCall specification member propertyGetSpecification.	^[specification performCallOn: self withParameters: aCOMCall arguments]		on: ExternalAccessFailed		do: [:ex | self handleCallError: ex]</body></methods><methods><class-id>External.IUnknown</class-id> <category>accessing</category><body package="Com- Automation">getTypeInfo	| iDispatch dispTypeInfo typeLib |	^	[iDispatch := (self queryInterface: IID_IDispatch)				ifNil: [^self getTypeInfoUsingTypeLibraries].	dispTypeInfo := iDispatch getTypeInfo				ifNil: [^self getTypeInfoUsingTypeLibraries].	typeLib := dispTypeInfo getContainingTypeLib				ifNil: [^self getTypeInfoUsingTypeLibraries].	(typeLib getTypeInfoOfGuid: self iid) asVTableTypeInfo]			ensure: 				[iDispatch enforceRelease.				dispTypeInfo enforceRelease.				typeLib enforceRelease]</body><body package="Com- Automation">getTypeInfoUsingTypeLibraries	^COMTypeLibrary typeInfoForIID: self iid</body></methods><methods><class-id>External.IUnknown</class-id> <category>error handling</category><body package="Com- Automation">handleCallError: anExternalAccessFailed 		| error |	error := anExternalAccessFailed parameter ifNil: [ ^ anExternalAccessFailed pass ].	error isHRESULTError ifFalse: [ ^ anExternalAccessFailed pass ].	COMError hresult: error parameter.</body></methods><methods><class-id>External.IUnknown</class-id> <category>accessing</category><body package="Com- Automation">interfaceForIID: anIID	^ self iid = anIID 		ifTrue: [ self ]		ifFalse: [ self queryInterface: anIID ]</body></methods><methods><class-id>External.IUnknown</class-id> <category>private invoking</category><body package="Com- Automation">invokeMethodSpec: aCOMCall withArguments: arguments withNamedArguments: namedArgs	| specification |	(namedArgs notNil and: [namedArgs notEmpty])		ifTrue: 			[^self error: #NamedArgumentVTableCallsNotSupported &lt;&lt; #com						&gt;&gt; 'Calls to VTable methods using named arguments is not supported'].	specification := aCOMCall specification member getSpecification.	^[specification performCallOn: self withParameters: arguments]		on: ExternalAccessFailed		do: [:ex | self handleCallError: ex]</body><body package="Com- Automation">invokeProcedureSpec: aCOMCall withArguments: argValuesArray withNamedArguments: namedArgs	^ self invokeMethodSpec: aCOMCall withArguments: argValuesArray withNamedArguments: namedArgs</body></methods><methods><class-id>External.IUnknown</class-id> <category>accessing</category><body package="Com- Automation">iUnknown	^ self interfaceForIID: IID_IUnknown</body></methods><methods><class-id>External.IUnknown</class-id> <category>private invoking</category><body package="Com- Automation">setPropertySpec: aCOMCall withArguments: arguments	| spec |	spec := aCOMCall specification member				writePropertySpecificationForArguments: arguments.	^[spec performCallOn: self withParameters: arguments]		on: ExternalAccessFailed		do: [:ex | self handleCallError: ex]</body></methods><methods><class-id>External.IUnknown</class-id> <category>accessing</category><body package="Com- Automation">specificationTable	^ COMDispatchSpecificationTable newNamedTable</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_NULL</body></methods><methods><class-id>External.COMExternalInterface class</class-id> <category>argument conversion services</category><body package="Com- Automation">asCYParameter: aNumber	" Answer &lt;aNumber&gt; as a CY parameter. "	^( COM_CY fromNumber: aNumber ) asStructureParameter</body><body package="Com- Automation">asDATEParameter: aValue	"Answer &lt;aValue&gt; as a DATE parameter where &lt;aValue&gt; can be a Timestamp or a Date."	^( COMDate fromValue: aValue ) value</body><body package="Com- Automation">asVARIANT_BOOL: aBoolean	"Answer an integer mapping for &lt;aBoolean&gt;."	aBoolean isInteger		ifTrue: [ ^aBoolean ].  " in case any clients use the pool variable constants "	^aBoolean		ifTrue: [ -1 ]  " VARIANT_TRUE "		ifFalse: [ 0 ]  " VARIANT_FALSE "</body><body package="Com- Automation">booleanFromVARIANT_BOOL: aVARIANT_BOOL	"Answer a Boolean mapping for &lt;aVARIANT_BOOL&gt;."	^aVARIANT_BOOL == -1  " VARIANT_TRUE "		ifTrue: [ true ]		ifFalse: [ false ]</body></methods><methods><class-id>Core.LargePositiveInteger</class-id> <category>arithmetic</category><body package="Com- Automation">comVariantType	^self &gt; 9223372036854775807		ifTrue: [External.COMAutomationConstants.VT_DECIMAL]		ifFalse: [External.COMAutomationConstants.VT_UI8]</body></methods><methods><class-id>External.GUID class</class-id> <category>private-installation</category><body package="Com- Automation">installEnhancedIIDLookupFunctionality	Plugins installPluginNamed: Plugins enhancedIIDLookUpKey		block: [:aSymbol :clsIdBlock | GUID privateEnhancedIIDLookupFor: aSymbol clsidBlock: clsIdBlock]</body></methods><methods><class-id>External.GUID class</class-id> <category>private</category><body package="Com- Automation">privateEnhancedIIDLookupFor: aSymbolOrIID clsidBlock: aClsidRetrieveBlock	"return the IID for the given symbol or Interface id. 	If a class id of the implementing object is known, it can help to retrieve the iid for a symbol"	(COMTypeLibrary iidForSymbol: aSymbolOrIID) ifNotNil: [:iid | ^iid].	^aClsidRetrieveBlock value		ifNotNil: 			[:clsid |			(COMTypeLibrary typeLibraryContainingClassWithId: clsid)				ifNotNil: [:typeLib | (typeLib typeNamed: aSymbolOrIID) ifNotNil: [:type | type guid]]]</body></methods><methods><class-id>External.GUID class</class-id> <category>private-installation</category><body package="Com- Automation">removeEnhancedIIDLookupFunctionality	Plugins removePluginNamed: Plugins enhancedIIDLookUpKey</body></methods><methods><class-id>Core.WordArray</class-id> <category>accessing</category><body package="Com- Automation">sizeInBytes	"Provide my size in bytes."	^super size</body></methods><methods><class-id>Core.Integer</class-id> <category>converting</category><body package="Com- Automation">asCOMDecimalCompatibleValue	"return the fixedpoint which can be stored in a COM_DECIMAL	 Only used for storing numbers in VARIANTS as DECIMALS"	^ self asFixedPoint: 0</body></methods><methods><class-id>Core.Integer</class-id> <category>comparing</category><body package="Com- Automation">equalsCOMTypeSpec: aDispTypeSpec	"for typecode comparison"	^ aDispTypeSpec typecode = self</body><body package="Com- Automation">equalToEnumConstant: anEnumConstant	^ self = anEnumConstant value</body></methods><methods><class-id>Core.Integer</class-id> <category>accessing</category><body package="Com- Automation">marshalCOMEnumType: anEnumType	^ anEnumType marshalInteger: self</body></methods><methods><class-id>Core.Interval class</class-id> <category>instance creation</category><body package="Com- Automation">from: startInteger size: numElements	^ self from: startInteger to: startInteger + numElements - 1</body></methods><methods><class-id>Core.Interval</class-id> <category>printing</category><body package="Com- Automation">printVBBoundsOn: aStream 	start printOn: aStream.	aStream nextPutAll: '..'.	stop printOn: aStream.</body></methods><methods><class-id>Core.Symbol class</class-id> <category>marshaling</category><body package="Com- Automation">defaultDispatchTypeClass	^ DispEnumTypeSpec</body></methods><methods><class-id>Core.Symbol</class-id> <category>comparing</category><body package="Com- Automation">equalToEnumConstant: anEnumConstant	^anEnumConstant name asSymbol = self</body></methods><methods><class-id>Core.Symbol</class-id> <category>accessing</category><body package="Com- Automation">marshalCOMEnumType: anEnumType	^ anEnumType marshalSymbolInParam: self</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>type library information</category><body package="Com- Automation">allLibraryDescriptorsFor: typeLibraryIDString	| typeLibRegistry |	typeLibRegistry := self classesRegistry at: 'TypeLib'.	^self allLibraryDescriptorsFor: typeLibraryIDString in: typeLibRegistry</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>private</category><body package="Com- Automation">allLibraryDescriptorsFor: typeLibraryIDString in: typeLibRegistry	| guid aTypeLibEntry template collection |	aTypeLibEntry := typeLibRegistry at: typeLibraryIDString ifAbsent: [^#()].	guid := (GUID fromString: typeLibraryIDString) ifNil: [^#()].	template := TypeLibDescriptor new.	collection := OrderedCollection new.	template guid: guid.		[aTypeLibEntry keysAndValuesDo: 			[:aVersionString :aName |			template				version: aVersionString;				name: aName.			self				putTypeLibDescriptorsIn: (aTypeLibEntry at: aVersionString)				template: template				into: collection]]			on: Error			do: [:ex | ex return].	^collection</body><body package="Com- Automation">computeExtTypeLibraryIDMap	" COMRegistryInterface computeExtTypeLibraryIDMap "	| typeLibRegistry map |	Tools.Note ISSUE.	" Experimental, probably should be thrown out if not redesigned. "	map := IdentityDictionary new.	(HostInterface isWindows or: [HostInterface isWindowsNT]) ifFalse: [^map].	typeLibRegistry := self classesRegistry at: 'TypeLib'.	typeLibRegistry keysDo: 			[:typeLibraryIDString |			(self allLibraryDescriptorsFor: typeLibraryIDString in: typeLibRegistry)				do: [:each | map at: (self keyForTypeLibDescriptor: each) put: each]].	^map</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>type library experiments</category><body package="Com- Automation">extTypeLibraryIDMap	" Answer a dictionary describing all the registered type libraries		on the system, with the ID as the key and a list of all the		registered version/name pairs as the value. "	^ ExtTypeLibIDMap ifNil: [ ExtTypeLibIDMap := self computeExtTypeLibraryIDMap ]</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>session management</category><body package="Com- Automation">flushExternalLibraryCache	ExtTypeLibIDMap := nil.</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>initialize-release</category><body package="Com- Automation">initialize	COMSystem current when: #setUp send: #setUp to: self</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>private</category><body package="Com- Automation">keyForGuid: aGuid lcid: lcid platform: platform version: versionString		^(aGuid asString , '_' , lcid printString , '_',platform , '_' ,			versionString) asSymbol</body><body package="Com- Automation">keyForTypeLibDescriptor: tlibDescriptor	^self		keyForGuid: tlibDescriptor guid		lcid: tlibDescriptor lcid		platform: tlibDescriptor platform		version: tlibDescriptor version</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>initialize-release</category><body package="Com- Automation">obsolete	COMSystem removeAllActionsWithReceiver: self.	super obsolete.</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>session management</category><body package="Com- Automation">setUp	self flushExternalLibraryCache.</body></methods><methods><class-id>Core.Boolean</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_BOOL</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Com- Automation">baseComVariantType	"return the basic variant type. This method is required since superclass implementation returns VT_ARRAY"	^self comVariantType</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Since String is a subclass of Collection, override the default implementation. "    ^ External.COMAutomationConstants.VT_BSTR</body></methods><methods><class-id>External.IAnonymous</class-id> <category>private invoking</category><body package="Com- Automation">actualReceiverFor: aCOMCall	^ self</body></methods><methods><class-id>External.IAnonymous</class-id> <category>private</category><body package="Com- Automation">computeSpecificationTable	^specificationTable := COMVTableSpecificationTable forInterface: self</body></methods><methods><class-id>External.IAnonymous</class-id> <category>error handling</category><body package="Com- Automation">doesNotUnderstand: aMessage	| call |	call := COMCall forMessage: aMessage driver: self.	call memberExists ifFalse: [ ^ super doesNotUnderstand: aMessage ].	^ call invoke</body></methods><methods><class-id>External.IAnonymous</class-id> <category>private invoking</category><body package="Com- Automation">getMethod: aName withArguments: arguments	| spec |	spec := self specificationNamed: aName ifNone: [^self signalMemberNotFound].	^[spec performCallOn: self withParameters: arguments] on: ExternalAccessFailed		do: [:ex | self handleCallError: ex]</body><body package="Com- Automation">getProperty: aName withArguments: arguments	^ [(self specificationNamed: aName) propertyGetSpecification performCallOn: self withParameters: arguments  ] on: ExternalAccessFailed do: [:ex | 			self handleCallError: ex ]</body></methods><methods><class-id>External.IAnonymous</class-id> <category>private</category><body package="Com- Automation">matchArguments: args of: specArguments	^specArguments size = args size</body></methods><methods><class-id>External.IAnonymous</class-id> <category>accessing</category><body package="Com- Automation">name	^ self specificationTable name</body></methods><methods><class-id>External.IAnonymous</class-id> <category>printing</category><body package="Com- Automation">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt; "	| title |	title := self name ifNil: [ self class printString ] ifNotNil: [:name | name ]. 	aStream nextPutAll: ((title first) isVowel ifTrue: ['an '] ifFalse: ['a ']).	aStream nextPutAll: title.	interface notNil ifTrue: [aStream nextPutAll: ' on: ' , self interfaceBinding printString]</body></methods><methods><class-id>External.IAnonymous</class-id> <category>private invoking</category><body package="Com- Automation">setProperty: aName withArguments: arguments	^	[((self specificationNamed: aName) writePropertySpecificationForArguments: arguments)		performCallOn: self		withParameters: arguments]			on: ExternalAccessFailed			do: [:ex | self handleCallError: ex]</body></methods><methods><class-id>External.IAnonymous</class-id> <category>error handling</category><body package="Com- Automation">signalMemberNotFound	COMError raiseSignal: E_NOTIMPL</body></methods><methods><class-id>External.IAnonymous</class-id> <category>accessing</category><body package="Com- Automation">specificationFor: aSpecificationQuery ifAbsent: aBlock	^ self specificationTable at: aSpecificationQuery member types: aSpecificationQuery kinds  ifAbsent: aBlock.</body><body package="Com- Automation">specificationNamed: aName	^self specificationNamed: aName ifNone: [self signalMemberNotFound]</body><body package="Com- Automation">specificationNamed: aName ifNone: aBlock	^ self specificationTable at: aName asString ifAbsent: aBlock</body><body package="Com- Automation">specificationProvider	"Answer the object which can provide call specifications."	^self</body><body package="Com- Automation">specificationTable	^specificationTable ifNil: [self computeSpecificationTable ].</body><body package="Com- Automation">specificationTable: anObject	specificationTable := anObject</body><body package="Com- Automation">type	^COMTypeLibrary typeForIID: self iid</body><body package="Com- Automation">type: aType	aType isInterface		ifTrue: [^self specificationTable: aType vtableType specificationTable].	self error: #TryingToSetInvalidTypeInItf &lt;&lt; #com				&gt;&gt; 'Trying to set the type of an interface to something invalid'</body></methods><methods><class-id>External.IAnonymous</class-id> <category>error handling</category><body package="Com- Automation">wrapResult: result args: args namedArgs: namedArgs for: aSpec	^ result</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>marshaling</category><body package="Com- Automation">fromUDTObject: aCOMObject ofType: aTypeDescription	^ aCOMObject setDictEntriesIn: self new usingType: aTypeDescription</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="Com- Automation">marshalStructureType: aType cType: cType intoStruct: aDatum	self keysAndValuesDo: 			[:key :value |			aDatum memberAt: key put: ((aType elementNamed: key) type marshalInArgument: value)]</body><body package="Com- Automation">marshalUnionType: aType cType: cType intoStruct: aDatum	self keysAndValuesDo: 			[:key :value |			aDatum memberAt: key put: ((aType elementNamed: key) type marshalInArgument: value)]</body><body package="Com- Automation">putValuesIntoCOMRecord: aCOMRecord	self keysAndValuesDo: [:key :value |		aCOMRecord memberAt: key put: value ].</body></methods><methods><class-id>Core.Dictionary</class-id> <category>calling</category><body package="Com- Automation">setArgumentsInCOMCall: anAutomationCall	"invoke the automation call with indexed arguments"	^ anAutomationCall namedArguments: self</body></methods><methods><class-id>Core.FixedPoint</class-id> <category>converting</category><body package="Com- Automation">asCOMDecimalCompatibleValue	"return the fixedpoint which can be stored in a COM_DECIMAL	 Only used for storing numbers in VARIANTS as DECIMALS"	^ self</body><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_DECIMAL</body></methods><methods><class-id>External.IUnknownPointer</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value. "	^13  "VT_UNKNOWN"</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="Com- Automation">baseComVariantType	^External.COMAutomationConstants.VT_ARRAY</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Since Smalltalk Collections can contain anything use VT_VARIANT if the elements in the receiver match to more than one COM variant type or if the array is not reactangular and therefore nested arrays are needed. "	| elementClasses first |	first := nil.	elementClasses := Set new.	"[AA 2005/10/24] If the array is not like a matrix we have to set the type to variant to make sure it is capable of holding other nested	 safeArrays which can hold dimensions in which elements numbers do not match"	self isMatrixLike		ifFalse: [ ^8204 "VT_ARRAY | VT_VARIANT" ].	self do: [ : e | 		first isNil ifTrue: [ first := e ].		elementClasses add: e comVariantType ].	"More than one kind of object: map to a SAFEARRAY of VARIANTs"	elementClasses size &gt; 1		ifTrue: [ ^8204 "VT_ARRAY | VT_VARIANT" ].	"Empty array: map to a SAFEARRAY of VARIANTs since CreateSafeArray must take a legal type."	first isNil		ifTrue: [ ^8204 "VT_ARRAY | VT_VARIANT" ].	"Other cases: get the type of the element for the SAFEARRAY."	^first comVariantType |  self baseComVariantType "VT_ARRAY"</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="Com- Automation">isCollection	"Was added for performance reasons."	^ true</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="Com- Automation">isMatrixLike	"test wether the collection is (including all contained collections)	 square like, that means, the number of all elements in one dimension is equal	 in any subcollection"	^COM_SAFEARRAY isMatrixLike: self</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="Com- Automation">isMultidimensional	"answer whether the collection is multidimensional,	 which is not true for simple Collections."	^ false</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Since Smalltalk ByteArrays can contain only ushorts use VT_UI1 elements by default. "    ^ 8209 " VT_ARRAY | VT_UI1 "</body></methods><methods><class-id>Core.ByteArray</class-id> <category>testing</category><body package="Com- Automation">isByteArray	"Was added for performance reasons."	^ true</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_R8</body></methods><methods><class-id>Core.Float</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_R4</body></methods><methods><class-id>External.ExternalInterface</class-id> <category>As yet unclassified</category><body package="Com- Automation">typeLibDescFrom: anITypeInfo	| lib |	lib := anITypeInfo getContainingTypeLib.	TypeLibDescriptor fromITypeLib: lib</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>testing</category><body package="Com- Automation">hasTypeLibSearchPath	"Answer if the path used for searching absent type libraries is specified"	^ TypeLibSearchPaths notNil</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>accessing</category><body package="Com- Automation">typeLibSearchPaths	"Answer the path used for searching typelibraries if they are not found at the position which was specified 	 at creation or if no registry entry is found for the typelibrary. Scanning will include subdirectories,	 so the typelibraries may be positioned in subdirectories of the type-library search path. 	 If the path is not specified the COMDirectory is used for that purpose."	^ TypeLibSearchPaths ifNil: [ Array with: self absoluteCOMDirectoryName ]</body><body package="Com- Automation">typeLibSearchPaths: aCollectionOrNil 	"Set the paths used for searching typelibraries if they are not found at the position which was specified at creation.	 Raise an error if the paths do not exist."	aCollectionOrNil ifNotNil: 			[aCollectionOrNil do: 					[:path | 					| searchPath |					searchPath := path asLogicalFileSpecification asFilename.					searchPath definitelyExists 						ifFalse: 							[self 								error: (#TypeLibSearchPathDoesNotExist &lt;&lt; #com 										&gt;&gt; 'Type-library search path "&lt;1s&gt;" does not exist.' expandMacrosWith: path)].					searchPath isDirectory 						ifFalse: 							[self 								error: (#TypeLibSearchPathNotDirectory &lt;&lt; #com 										&gt;&gt; 'Type-library search path "&lt;1s&gt;" is not a directory.' 											expandMacrosWith: path)]]].	TypeLibSearchPaths := aCollectionOrNil</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^ External.COMAutomationConstants.VT_I4</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="Com- Automation">comVariantType	^External.COMAutomationConstants.VT_UI4</body></methods><methods><class-id>External.CPointer</class-id> <category>converting</category><body package="Com- Automation">asBSTRMemoryAddress	^ BSTRMemoryAddress fromPointer: self</body><body package="Com- Automation">setCOMRecordInVariant: aVariant	self halt: 'Recheck whether to create a copy - for nested structs'.	^ aVariant setRecordPointerTo: self</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-argument utilities</category><body package="Com- Automation">booleanFromVariantBool: aValue	"Private. Answer the value in the VARIANT_BOOL at &lt;aValue&gt;."	^COMExternalInterface booleanFromVARIANT_BOOL: aValue</body><body package="Com- Automation">bstrResultAtAddress: aBSTRPointer put: aString	"Private. Store the String output argument value &lt;aString&gt; into the caller-provided BSTR at &lt;anExternalAddress&gt;.This services is used for OUT arguments of the form 'BSTR *retval' "	| aBstr |	aString isNil ifTrue: [ ^self ].	aBstr := BSTR allocateString: aString.	aBSTRPointer contents: aBstr asPointerParameter.	aBstr enforceInvalidation.  " ownership of this BSTR transfers to the caller "</body><body package="Com- Automation">currencyResultAtAddress: pvarResult put: aValue	"Private. Store the result reference output argument value &lt;resultReference&gt; into the caller-provided memory location at &lt;pvarResult&gt;."	( ( COMStructure classForStructureNamed: #CY ) temporaryOn: pvarResult )		value: aValue</body><body package="Com- Automation">currencyValueAtAddress: aCompositeOrPointer	"Private. Answer the value in the CY at &lt;aPointer&gt;."	^( self structureFrom: aCompositeOrPointer ) value.</body><body package="Com- Automation">dateResultAtAddress: pvarResult put: aValue	"Private. Store the result reference output argument value &lt;resultReference&gt; into the caller-provided memory location at &lt;pvarResult&gt;."	| aCOMDate |	aCOMDate := COMDate fromValue: aValue.	self scalarResultAtAddress: pvarResult put: aCOMDate value</body><body package="Com- Automation">dateValueAtAddress: aCompositeOrPointer	"Private. Answer the value in the DATE at &lt;aPointer&gt; as a Timestamp."	^( COMDate fromValue: aCompositeOrPointer ) asTimestamp</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-exception handlers</category><body package="Com- Automation">exceptionHandlerForDispatchInvoke: callerType exceptionInfo: pexcepinfo	" Answer the error handler block to use when an exception occurs during a VTable function invocation by an external caller to IDispatch::Invoke.  An HRESULT value which describes the exception will be returned to the external caller as the return value of the function if an exception occurs. "	" For correct operation in COM, stack unwinding must not cross a function invocation boundary, which occurs at each external callin point.  The callin exception handler translates the error to an appropriate HRESULT status code and returns to the caller.  In addition, the error handler provides information to allow the error to be diagnosed. "	^[ :ex |		| hresult |		hresult := self handleDispatchInvokeException: ex 			callerType: callerType			exceptionInfo: pexcepinfo.		ex return: hresult ]</body><body package="Com- Automation">handleDispatchInvokeException: anException callerType: callerType exceptionInfo: pexcepinfo	" Private - handle &lt;anException&gt; which has occurred during IDispatch::Invoke processing.  Answer the HRESULT to return to the caller. "	self reportCallinError: anException.	pexcepinfo isValid		ifTrue: [			( self structureAtAddress: pexcepinfo "type: #EXCEPINFO" )				setInvocationExceptionDescription: anException description ].	^DISP_E_EXCEPTION</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-argument utilities</category><body package="Com- Automation">safeArrayResultPointerAtAddress: pvarResult put: aValue elementType: aTypeCode	"Private. Store the result reference output argument value &lt;aValue&gt; into the caller-provided memory location at &lt;pvarResult&gt;. Used for SAFEARRAY * * arguments.  We need to specify &lt;aTypeCode&gt; to enforce type."	| aComSA |	aComSA := COMSafeArray fromCollection: aValue elementType: aTypeCode.	pvarResult contents: aComSA asPointerParameter.	aComSA enforceInvalidation.</body><body package="Com- Automation">safeArrayValueAtAddress: aPointer typeCode: aTypeCode	"Private. Answer the value in the SAFEARRAY at &lt;aPointer&gt; of typeCode &lt;aTypeCode&gt;."	^( self structureAtAddress: aPointer )		typeCode: aTypeCode;		asArray</body><body package="Com- Automation">stringAtBSTRPointer: aBSTRPointer	"Private. Answer a String containing the characters at address &lt;aBSTRPointer&gt;. The string pointer references the Unicode byte BSTR encoding of the string."	aBSTRPointer isValid		ifFalse: [ ^nil ].	^BSTR stringAtPointer: aBSTRPointer.</body><body package="Com- Automation">variantBoolResultAtAddress: pvarResult put: aValue	"Private. Store the String output argument value &lt;aString&gt; into the caller-provided BSTR at &lt;anExternalAddress&gt;.This services is used for OUT arguments of the form 'BSTR *retval' "	self scalarResultAtAddress: pvarResult 		put: ( COMExternalInterface asVARIANT_BOOL: aValue )</body><body package="Com- Automation">variantResultAtAddress: pvarResult put: resultReference 	"Private. Store the result reference output argument value &lt;resultReference&gt; into the caller-provided memory location at &lt;pvarResult&gt;."	resultReference 		setCOMVariant: ((COMStructure classForStructureNamed: #VARIANT) 				temporaryOn: pvarResult).</body><body package="Com- Automation">variantValueFrom: aPointerOrComposite	"Private. Answer the value in the VARIANT at &lt;aPointerOrComposite&gt;."	^( self structureFrom: aPointerOrComposite ) value</body></methods><methods><class-id>UI.ValueHolder</class-id> <category>converting</category><body package="Com- Automation">baseComVariantType	^External.COMAutomationConstants.VT_BYREF</body><body package="Com- Automation">comVariantType	" Answer the type code which should be used to represent the receiver as a COM VARIANT value.  Answer nil if the receiver cannot be represented as by a known variant type. "	^COMVariant		filterTypeCode: self value comVariantType | self baseComVariantType</body></methods><methods><class-id>UI.ValueHolder</class-id> <category>accessing</category><body package="Com- Automation">setVariantRefValueIn: aVariant	aVariant commonSetRefValue: self value.</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>unwinding</category><body package="Com- Automation">withResultDoAndRelease: aBlock	"evaluate myself, do something with this value and release it afterwards again"	| result |	result := self value.	^ [ aBlock value: result ]	ensure: [ result enforceRelease ]</body></methods><methods><class-id>External.ValueReference class</class-id> <category>marshaling</category><body package="Com- Automation">defaultDispatchTypeClass	^ DispPtrTypeSpec</body></methods><methods><class-id>External.ValueReference</class-id> <category>accessing</category><body package="Com- Automation">baseComVariantType	"Return the receivers variant type. I am a generic container, so my variant type is my contents type, combined with VT_BYREF"	^External.COMAutomationConstants.VT_BYREF</body><body package="Com- Automation">comVariantType	"Return the receivers variant type. I am a generic container, so my variant type is my contents type, combined with VT_BYREF"	^COMVariant filterTypeCode: value comVariantType | self baseComVariantType</body><body package="Com- Automation">setVariantRefValueIn: aVariant	aVariant commonSetRefValue: self value.</body></methods><initialize><class-id>External.IConnectionPointContainerPointer</class-id></initialize><initialize><class-id>External.IConnectionPointPointer</class-id></initialize><initialize><class-id>External.IProvideClassInfoPointer</class-id></initialize><initialize><class-id>External.ITypeCompPointer</class-id></initialize><initialize><class-id>External.ITypeInfoPointer</class-id></initialize><initialize><class-id>External.ITypeLibPointer</class-id></initialize><initialize><class-id>External.COMDispatchInterfacePointer</class-id></initialize><initialize><class-id>External.IDispatchPointer</class-id></initialize><initialize><class-id>External.COMDispatchInterfaceImplementation</class-id></initialize><initialize><class-id>External.IDispatchImplementation</class-id></initialize><initialize><class-id>External.IConnectionPoint</class-id></initialize><initialize><class-id>External.IConnectionPointContainer</class-id></initialize><initialize><class-id>External.IProvideClassInfo</class-id></initialize><initialize><class-id>External.ITypeComp</class-id></initialize><initialize><class-id>External.COMTypeLibraryInterface</class-id></initialize><initialize><class-id>External.ITypeInfo</class-id></initialize><initialize><class-id>External.ITypeLib</class-id></initialize><initialize><class-id>External.COMDispatchInterface</class-id></initialize><initialize><class-id>External.IDispatch</class-id></initialize><initialize><class-id>External.COMVariantStructure</class-id></initialize><initialize><class-id>External.COMVariantValue</class-id></initialize><initialize><class-id>External.COM_VARIANT</class-id></initialize><initialize><class-id>External.COM_VARIANTARG</class-id></initialize><initialize><class-id>External.COM_ARRAYDESC</class-id></initialize><initialize><class-id>External.COM_BLOB</class-id></initialize><initialize><class-id>External.COM_CY</class-id></initialize><initialize><class-id>External.COM_DISPPARAMS</class-id></initialize><initialize><class-id>External.COM_ELEMDESC</class-id></initialize><initialize><class-id>External.COM_EXCEPINFO</class-id></initialize><initialize><class-id>External.COM_SAFEARRAY</class-id></initialize><initialize><class-id>External.COM_SAFEARRAYBOUND</class-id></initialize><initialize><class-id>External.COM_TYPEDESC</class-id></initialize><initialize><class-id>External.COM_DECIMAL</class-id></initialize><initialize><class-id>External.COM_FUNCDESC</class-id></initialize><initialize><class-id>External.COM_TLIBATTR</class-id></initialize><initialize><class-id>External.COM_TYPEATTR</class-id></initialize><initialize><class-id>External.DispSimpleTypeSpec</class-id></initialize><initialize><class-id>External.COMDispatchSpecificationTable</class-id></initialize><initialize><class-id>External.COMDualInterfaceObject</class-id></initialize><initialize><class-id>External.IClassFactory2</class-id></initialize><initialize><class-id>External.IClassFactory2Implementation</class-id></initialize><initialize><class-id>External.COM_VARDESC</class-id></initialize><initialize><class-id>External.BSTR</class-id></initialize><initialize><class-id>External.COMVariant</class-id></initialize><initialize><class-id>External.COMSpecificationPolicy</class-id></initialize><initialize><class-id>External.COMDispatchMethodSpecification</class-id></initialize><initialize><class-id>External.COMDispatchParameterizedPropertySpecification</class-id></initialize><initialize><class-id>External.SpecialVariantArg</class-id></initialize><initialize><class-id>External.COMLicenseManager</class-id></initialize><initialize><class-id>External.COMDispatchPropertySpecification</class-id></initialize><initialize><class-id>External.ILicenseManager</class-id></initialize><initialize><class-id>External.IRecordInfo</class-id></initialize><initialize><class-id>External.IRecordInfoPointer</class-id></initialize><initialize><class-id>External.IClassFactory2Pointer</class-id></initialize><initialize><class-id>External.COM_PARAMDESC</class-id></initialize><initialize><class-id>External.EMBEDDED_SAFEARRAY</class-id></initialize><initialize><class-id>External.ILicenseManagerPointer</class-id></initialize><initialize><class-id>External.COMTypeLibrary</class-id></initialize><initialize><class-id>External.ILicenseManagerImplementation</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>COMExternalInterface</name><environment>External</environment><super>External.Win32ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			private External.COMExternalInterfaceDictionary.*			</imports><category>COM-Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ValueReference</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><class><name>COMInterfaceValueReference</name><environment>External</environment><super>External.ValueReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>LargePositiveInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>ExternalStructure</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structure memberNames protocolMap </inst-vars><class-inst-vars>structureName </class-inst-vars><imports></imports><category>External-Data-Extensions</category><attributes><package>Com- External Data Enhancements</package></attributes></class><class><name>COMStructure</name><environment>External</environment><super>External.Win32Structure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.CConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceVTableSignatures</name><environment>External</environment><super>External.COMExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMInterfaceVTableSignaturesDictionary.*			</imports><category>COM-Development Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>CPointer</name><environment>External</environment><super>External.CDatum</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>COMError</name><environment>Core</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hresult </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceBinding</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>iid </class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface </inst-vars><class-inst-vars>iid </class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknown</name><environment>External</environment><super>External.COMInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceImplementation</name><environment>External</environment><super>External.COMInterfaceBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfacePointer implementor </inst-vars><class-inst-vars>vtableSignatureTypeName vtable vtableSelectors </class-inst-vars><imports>			External.CConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknownImplementation</name><environment>External</environment><super>External.COMInterfaceImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referenceCount </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>Win32KernelDLL</name><environment>External</environment><super>External.Win32DynamicLinkLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			External.CConstants.*			private External.Win32KernelDLLDictionary.*			</imports><category>OS-Win32 Host Bindings</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Win32</package></attributes></class><class><name>Win32ResultValueBuffer</name><environment>External</environment><super>External.Win32Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>LargeNegativeInteger</name><environment>Core</environment><super>Core.LargeInteger</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>WordArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>COMObject</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controllingUnknown innerUnknown referenceCount </inst-vars><class-inst-vars>clsid </class-inst-vars><imports>			External.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknownPointer</name><environment>External</environment><super>External.COMInterfacePointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>FixedPoint</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator scale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>COMClassFactoryObject</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectClass iClassFactory registrationToken registeredUnknown lockCount releaseIfNotInUse </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>IClassFactoryImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>Win32PointerResultValueBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Win32ArrayResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferElementType bufferElementCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><class><name>Date</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>day year </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>COMDynamicLinkLibrary</name><environment>External</environment><super>External.COMExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMDynamicLinkLibraryDictionary.*			</imports><category>COM-Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>IClassFactoryPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknownAdaptor</name><environment>External</environment><super>External.COMInterfaceFunctionAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>Win32MemoryAddress</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pointer </inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			</imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><class><name>Win32StructureResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structureType structureClass valueConstructionAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>IClassFactory</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clsid </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IAnonymous</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid specificationTable </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMStructureEnumerator</name><environment>External</environment><super>External.COMEnumeratorObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>