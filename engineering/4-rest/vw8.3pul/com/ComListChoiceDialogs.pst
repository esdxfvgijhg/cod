<?xml version="1.0"?><st-source><!-- Name: Com- List Choice DialogsNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Dialogs which provide different ways of allowing users to make choices from lists.DbIdentifier: bear73DbTrace: 447361DbUsername: aaugustinDbVersion: 8.0 - 3DialectVersion: VisualWorks 7.9PackageName: Com- List Choice DialogsParcel: #('ComListChoiceDialogs')ParcelName: Com- List Choice DialogsPrintStringCache: (8.0 - 3,aaugustin)Version: 8.0 - 3Date: 1:50:04 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:04</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ListDialog</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title textLines list minEntriesToShow maxEntriesToShow returnItems selection owner listModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>List Choice Dialogs</category><attributes><package>Com- List Choice Dialogs</package></attributes></class><comment><class-id>UI.ListDialog</class-id><body>The ListDialog class displays a dialog to the user which allows a single item to be selected from a list of choices.  The value selected by the user is returned; nil is returned if the dialog is cancelled.The dialog is configurable to allow a client-specified title and an optional set of one or more text labels with descriptive information to be displayed.  The minimum and maximum number of list entries to display is also configurable.  The dialog is automatically sized to correctly display the list elements and associated explanatory text.Standard configurations of the dialog are invokable using class messages:	ListDialog openOn: #( 'one' 'two' 'three' ) 		title: 'Choose a value'.	ListDialog openOn: #( 'one' 'two' 'three' ) 		title: 'Choose a value' 		selection: 'two'.More customized configurations are enabled by configuring the dialog instance:	ListDialog new		title: 'Choose One';		textLines: 'Please make a choice from this list.  ';		openOn: #( 'one' 'two' 'three' 'four' ).	ListDialog new		title: 'Choose One';		textLines: #(			'It is now your turn.'			'Please choose your action.  '			);		minEntriesToShow: 4;  " leave extra space in the list "		openOn: #( 'roll the dice' 'pass' 'go directly to jail' ).	ListDialog new		title: 'Choose One';		textLines: #( 'Choose one of the seven values.  ' );		maxEntriesToShow: 5;		openOn: #( 'one' 'two' 'three' 'four' 'five' 'six' 'seven' )			selection: 'four'.</body></comment><class><name>MultiSelectListDialog</name><environment>UI</environment><super>UI.ListDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>List Choice Dialogs</category><attributes><package>Com- List Choice Dialogs</package></attributes></class><comment><class-id>UI.MultiSelectListDialog</class-id><body>The MultiSelectListDialog class displays a dialog to the user which allows a one or more items to be selected from a list of choices.  The value(s) selected by the user are returned; nil is returned if the dialog is cancelled.The dialog is configurable to allow a client-specified title and an optional set of one or more text labels with descriptive information to be displayed.  The minimum and maximum number of list entries to display is also configurable.  The dialog is automatically sized to correctly display the list elements and associated explanatory text.Standard configurations of the dialog are invokable using class messages:	MultiSelectListDialog openOn: #( 'one' 'two' 'three' 'four' 'five' ) 		title: 'Choose a value'.	MultiSelectListDialog openOn: #( 'one' 'two' 'three' 'four' 'five' ) 		title: 'Choose a value' 		selection: #( 'two' 'four' ).More customized configurations are enabled by configuring the dialog instance:	MultiSelectListDialog new		title: 'Choose One';		textLines: 'Please make a choice from this list.  ';		openOn: #( 'one' 'two' 'three' 'four' ).	MultiSelectListDialog new		title: 'Choose One';		textLines: #(			'It is now your turn.'			'Please choose your action.  '			);		minEntriesToShow: 4;  " leave extra space in the list "		openOn: #( 'roll the dice' 'pass' 'go directly to jail' ).	MultiSelectListDialog new		title: 'Choose One';		textLines: #( 'Choose any of the seven values.  ' );		maxEntriesToShow: 5;		openOn: #( 'one' 'two' 'three' 'four' 'five' 'six' 'seven' )			selection: #( 'three' 'four' ).</body></comment><methods><class-id>UI.ListDialog</class-id> <category>subclass-operation</category><body package="Com- List Choice Dialogs">emptyListResponse	" Private - answer the result of trying to open the dialog on an empty list. "	"?? display a warning ??"	^nil</body><body package="Com- List Choice Dialogs">openDialog	" Private - open the dialog.  Answer the user's selection. "	| resultHolder |	self createView.	selection := nil.	resultHolder := ValueHolder new.  "??? why do we want to mess with this? ???"	builder openDialogWithExtent: builder window displayBox extent.	accept value		ifTrue: [ self saveSelection ]		ifFalse: [			"### Figure out what capability you're inheriting here and whether/how to exploit it... ###"			selection := ( cancel value 				ifTrue: [ "cancelBlock value" nil ] 				ifFalse: [ resultHolder value ] ) ].	^selection"VS implementation was:    topPane := self createView.    selection := nil.    topPane openModal: pmOwner.    ^selection"</body><body package="Com- List Choice Dialogs">saveSelection	" Private "	selection := ( returnItems		ifTrue: [ listModel selection ]		ifFalse: [ listModel selectionIndex ] ).	^selection</body></methods><methods><class-id>UI.ListDialog</class-id> <category>subclass-view creation</category><body package="Com- List Choice Dialogs">addActionButtonsToView	" Private - add optional action buttons to the view.  Answer their wrappers. "	^nil</body><body package="Com- List Choice Dialogs">addButtonRowWithLabels: labels actions: actions equalize: eqBoolean	" Private "	| num maxButtonWidth maxButtonHeight separation buttonWAs buttonWidth 	  window box layout left top actualColumns actualRows |	num := labels size.	maxButtonWidth := 0.	maxButtonHeight := 0.	separation := 20.	buttonWAs := OrderedCollection new.	window := builder window.	box := window displayBox.	actualColumns := "nColumns min:" labels size.	actualRows := num + actualColumns - 1 // actualColumns.	"We have to create and place the buttons before we can ask them their	preferred bounds and refine their spacing."	layout := LayoutFrame new.	layout leftFraction: 0.5; rightFraction: 0.5.	builder newComposite.	1 to: num do:		[:index |		| aLabel clickedSelector buttonSpec buttonW bExt |		aLabel := labels at: index.		clickedSelector := actions at: index.		buttonSpec := ActionButtonSpec				model: clickedSelector				label: aLabel				layout: (0@0 extent: 1@1).		buttonSpec			defaultable: true;			isDefault: false.		builder actionAt: clickedSelector put: [ self perform: clickedSelector ].  "?? Add hack... [DL 20-Oct-96] "		builder add: buttonSpec.		buttonW := builder wrapper.		"####Was this interesting??		(takeKeyboard and: [val == defaultValue])			ifTrue: [builder keyboardProcessor setActive: buttonW widget controller].		####"		maxButtonWidth := maxButtonWidth max: (bExt := buttonW preferredBounds extent) x.		maxButtonHeight := maxButtonHeight max: bExt y.		buttonWAs add: buttonW -&gt; bExt]. 	buttonWidth := eqBoolean		ifTrue: [actualColumns * maxButtonWidth + ((actualColumns - 1) * separation)]		ifFalse: [buttonWAs				inject: separation negated				into: [:x :assoc | x + assoc value x + separation]].	layout topOffset: box height; bottomOffset: box height+(actualRows * maxButtonHeight).	layout		leftOffset: 0 - ((buttonWidth + 1) // 2);		rightOffset: (buttonWidth + 1) // 2.	builder endCompositeLayout: layout.	left := 0.	top := 0.	1 to: num do:		[:index |		| bttnWA width |		bttnWA := buttonWAs at: index.		width := eqBoolean				ifTrue: [maxButtonWidth]				ifFalse: [bttnWA value x].		bttnWA key newLayout:			(Rectangle				left: left				right: left + width				top: top				bottom: top + maxButtonHeight) asLayout.		index \\ actualColumns = 0			ifTrue:				[left := 0.				top := top + maxButtonHeight]			ifFalse: [left := left + width + separation]].	self addGap: maxButtonHeight * actualRows.	buttonWidth := buttonWidth + separation.	self minWidth: buttonWidth.	^builder wrapper</body><body package="Com- List Choice Dialogs">addLabel: messageString	" Private - add a left-aligned text label to the view. "	| labelText layout box spec |	box := builder window displayBox.	labelText := ComposedText withText: messageString asText allBold		style: ( builder policy class systemWidgetTextStyle copy alignment: 0 ).	layout := AlignmentOrigin new		leftOffset: 16;		topOffset: box height.			"Centered layout:				leftFraction: 0.5;				topOffset: box height;				leftAlignmentFraction: 0.5.			"	spec := LabelSpec layout: layout.	spec 		hasCharacterOrientedLabel: false;		setLabel: labelText.	builder add: spec.	self addGap: labelText bounds height.	self minWidth: ( labelText bounds width + 20 ).	^builder wrapper</body><body package="Com- List Choice Dialogs">addList: model lines: maxLines validation: valid	| height layout field grid font scrollW max fullMax displaySelector |" Implementation note: This method refactors the superclass implementation to enable	subclassing (e.g., the enable the multi-select list dialog).  This refactoring should	really be pushed up into SimpleDialog itself so we don't have to do this here.""Bug fix  note: Observe that there is also a bug fix here so that the width computation	uses the display string, not the raw list element.  The dialog shouldn't	insist that only strings be allowed in the list. "	height := builder window displayBox height.	layout := LayoutFrame new.	layout leftOffset: 16.	layout rightFraction: 1 offset: -16.	layout topOffset: height."***refactored the following into a separate method to enable subclassing***"	field := self createSequenceViewSpecFor: listModel layout: layout.	builder add: field.	builder wrapper widget controller setDispatcher:		(UIDispatcher new doubleClick: [valid value ifTrue: [accept value: true]])."***refactored the following into a separate method to enable subclassing***"	builder wrapper widget setValidTargetIndex: ( self validTargetIndex: model ).	scrollW := builder wrapper decorator scrollerComponent.	scrollW preferredBoundsBlock:				[:sw | | rect |				rect := sw component preferredBounds						translatedBy: sw translation.				rect height: maxLines*sw scrollGrid y.				rect].	font := builder wrapper widget textStyle defaultFont.	font := Screen default defaultFontPolicy findFont: font."****Bug fix: allow non-string elements to be put in the list"	displaySelector := builder wrapper widget displayStringSelector.	displaySelector isNil		ifTrue: [ displaySelector := #displayString ].	max := model list inject: 0 into: [ :wMax :each | 		wMax max: ( each perform: displaySelector ) size].			"WAS: max := model list inject: 0 into: [:i :str | i max: str size]."		"Instead of exactly measuring every string, we		assume that $o will be a fairly representative		character.  Actually, $o will probably be wider		than the average, but this will usually be OK."	max := (font widthOf: $o) * max.		"Don't let the dialog get too wide."	fullMax := 350.	max &gt; fullMax		ifTrue:			[max := fullMax.			builder wrapper decorator useHorizontalScrollBar.			builder wrapper widget measureWidth: true].	grid := builder wrapper preferredBounds height.	layout bottomOffset: height+grid.	self addGap: grid.	self minWidth: max + 48.	^builder wrapper</body><body package="Com- List Choice Dialogs">addListToView	" Private - add the list component to the view.  Answer its wrapper. "	^self addList: listModel		lines: ( minEntriesToShow max: ( self computeMaxEntriesToShowFor: list ) )		validation: [ true ]  " all selections are valid "</body><body package="Com- List Choice Dialogs">addOkCancelButtonsToView	" Private - add the OK and Cancel buttons to the view.  Answer the wrapper. "	^self addOK: [ listModel selectionIndex ~= 0 ]  " value accept block "</body><body package="Com- List Choice Dialogs">addTextLinesToView	" Private - add components for the text info lines to the view. "	textLines do: [ :aString |		self addLabel: aString.			"addMessage: aString centered: false."		" self addSpaceBetweenElementsToView" ].</body><body package="Com- List Choice Dialogs">computeMaxEntriesToShowFor: aList	" Private - adjust maxEntriesToShow if necessary, to ensure that this guy fits on the screen. "	| availableLines |    maxEntriesToShow := maxEntriesToShow isNil        ifTrue: [ "self defaultMaxEntriesToShow" aList size ]        ifFalse: [ aList size min: maxEntriesToShow ].	availableLines :=		( Screen default bounds height // self lineHeight )		- 7 " borders, title bar, buttons, internal margins"		- textLines size.  " description text "	maxEntriesToShow := maxEntriesToShow min: availableLines.	^maxEntriesToShow</body><body package="Com- List Choice Dialogs">createListModel	" Private - create and initialize a model for the list pane in the receiver's view. "	| aListModel |	aListModel := SelectionInList new.	aListModel list: list "?? asList ??".	" always start with something selected "	selection isNil		ifTrue: [			selection := ( returnItems ifTrue: [ list first ] ifFalse: [ 1 ] ) ].	" install the initial selection "	selection isInteger		ifTrue: [ aListModel selectionIndex: selection ]		ifFalse: [ aListModel selection: selection ].	^aListModel</body><body package="Com- List Choice Dialogs">createSequenceViewSpecFor: aModel layout: layout	" Private - answer a specification for a sequence view on &lt;aModel&gt; with the given &lt;layout&gt; framing. "	^SequenceViewSpec model: aModel menu: nil layout: layout</body><body package="Com- List Choice Dialogs">createView	" Private - create a view with the desired attributes and contents. "	| aWindowSpec aListWrapper buttonWrappers aButtonSetWrapper |	aWindowSpec := ( self class interfaceSpecFor: #emptySpec ).	self initializeBuilderFor: owner.	builder 		add: aWindowSpec window;		add: aWindowSpec component.	self initializeWindowFor: owner.	self setInitialGap.	textLines size &gt; 0		ifTrue: [			self addTextLinesToView.			self addGap: 4 ].	listModel := self createListModel.	aListWrapper := self addListToView.	self addGap: 4.	buttonWrappers := OrderedCollection new.	aButtonSetWrapper := self addActionButtonsToView.	aButtonSetWrapper notNil		ifTrue: [			buttonWrappers add: aButtonSetWrapper.			self addGap: 6.			buttonWrappers add: self addDivider.			self addGap: 6 ].	buttonWrappers add: self addOkCancelButtonsToView.	self 		addGap: 6;		bottomAlignLowerEdge: aListWrapper;		bottomAlign: buttonWrappers.	self preOpen.</body><body package="Com- List Choice Dialogs">lineHeight	" Private - answer the line height for list items in the dialog. "	^self builder policy class systemWidgetTextStyle lineGrid</body><body package="Com- List Choice Dialogs">preOpen	"Do everything short of actually opening the window."	super preOpen.	title notNil		ifTrue: [ 	builder window label: title ].</body><body package="Com- List Choice Dialogs">validTargetIndex: model	"Private. Answer the argument for the setValidTargetIndex: method for &lt;model&gt;."	^model selectionIndex</body></methods><methods><class-id>UI.ListDialog</class-id> <category>subclass-initialization</category><body package="Com- List Choice Dialogs">defaultMaxEntriesToShow	" Private "	^10</body><body package="Com- List Choice Dialogs">defaultMinEntriesToShow	" Private "	^2   "Account for up and down arrow buttons."</body><body package="Com- List Choice Dialogs">initialize	" Private "	minEntriesToShow := self defaultMinEntriesToShow.	textLines := #( ).	returnItems := true.	super initialize.</body></methods><methods><class-id>UI.ListDialog</class-id> <category>configuring</category><body package="Com- List Choice Dialogs">initialSelection: aSelection	" Make &lt;aSelection&gt; be the initial selection when the dialog is opened. "	selection := aSelection.</body><body package="Com- List Choice Dialogs">maxEntriesToShow: anInteger	" Specify the maximum number of entries to show in the list at one time. "	maxEntriesToShow := anInteger.</body><body package="Com- List Choice Dialogs">minEntriesToShow: anInteger	" Specify the minumum number of entries to show in the list at one time. "	minEntriesToShow := anInteger.</body><body package="Com- List Choice Dialogs">owner: aView	" Set the owner of the dialog to &lt;aView&gt;, which may be either a VisualPart or a	ScheduledWindow.  It controls the look and feel and color choices	used by the dialog, and supplies the dialog's master window, which	is used by some window systems to create a visual connection between	the dialog and the window that created it."	owner := aView.</body><body package="Com- List Choice Dialogs">returnItems: aBoolean	" Specify whether to return selection as item or index. "	returnItems := aBoolean.</body><body package="Com- List Choice Dialogs">textLines: oneOrMoreStrings	" Specify one or more strings to be displayed at the top of the window. "	textLines := ( oneOrMoreStrings isString		ifTrue: [ Array with: oneOrMoreStrings ]		ifFalse: [ oneOrMoreStrings ] ).</body><body package="Com- List Choice Dialogs">title: aString	" Specify the title text of the dialog. "	title := aString.</body></methods><methods><class-id>UI.ListDialog</class-id> <category>opening</category><body package="Com- List Choice Dialogs">open	" Answer the user's choice in the list. "	list size = 0		ifTrue: [ ^self emptyListResponse ].	^self openDialog</body><body package="Com- List Choice Dialogs">openOn: aList        " Open a list dialog displaying &lt;aList&gt;.  Answer the selection. "	list := aList.	^self open</body><body package="Com- List Choice Dialogs">openOn: aList selection: initialSelection	" Open a list dialog displaying &lt;aList&gt;, with &lt;initialSelection&gt; as the initial selection. "	selection := initialSelection.	^self openOn: aList</body></methods><methods><class-id>UI.ListDialog class</class-id> <category>opening</category><body package="Com- List Choice Dialogs">openOn: aList title: aString	" Open a list choice dialog on &lt;aList&gt; with &lt;aString&gt; in the dialog window title.  Answer the selected item.  Answer nil if no choice was made or the dialog was cancelled by the user. "	" ListDialog openOn: #( 'one' 'two' 'three' ) title: 'Choose a value' "	^self new		title: aString;		openOn: aList</body><body package="Com- List Choice Dialogs">openOn: aList title: aString selection: aListItem	" Open a list choice dialog on &lt;aList&gt; with &lt;aString&gt; in the dialog window title and &lt;aListItem&gt; initially selected.  Answer the selected item.  Answer nil if no choice was made or the dialog was cancelled by the user. "	"	ListDialog openOn: #( 'one' 'two' 'three' ) 		title: 'Choose a value' 		selection: 'two'	"	^self new		title: aString;		openOn: aList selection: aListItem.</body></methods><methods><class-id>UI.MultiSelectListDialog</class-id> <category>subclass-view creation</category><body package="Com- List Choice Dialogs">addActionButtonsToView	" Private - add optional action buttons to the view.  Answer their wrappers. "	self addGap: 4.	^self addButtonRowWithLabels: (Array with: #selectAll &lt;&lt; #labels &gt;&gt;'Select all' with: #ClearAll &lt;&lt; #com &gt;&gt;'Clear all' )		actions: #( #selectAllInList #deselectAllInList )		equalize: false</body><body package="Com- List Choice Dialogs">addOkCancelButtonsToView	" Private - add the OK and Cancel buttons to the view.  Answer their wrappers. "	^self addOK: [ true ]   " value accept block "		"To insist that a selection be made: [ (  listModel selectionIndexes elementsEqual: listModel zeroIndex ) not ] "</body><body package="Com- List Choice Dialogs">createListModel	" Private - create and initialize a model for the list pane in the receiver's view. "	| aListModel |	aListModel := MultiSelectionInList new.	aListModel list: list "?? asList ??".	" install the initial selection (if any) "	selection size &gt; 0		ifTrue: [			selection asArray first isInteger				ifTrue: [ aListModel selectionIndexes: selection ]				ifFalse: [ aListModel selections: selection ] ].	^aListModel</body><body package="Com- List Choice Dialogs">createSequenceViewSpecFor: aModel layout: layout	" Private - answer a specification for a sequence view on &lt;aModel&gt; with the given &lt;layout&gt; framing. "	^( SequenceViewSpec model: aModel menu: nil layout: layout )		multipleSelections: true;		yourself</body><body package="Com- List Choice Dialogs">validTargetIndex: model	"Private. Answer the argument for the setValidTargetIndex: method for &lt;model&gt;."	"??^model selectionIndex asArray first??"	^0</body></methods><methods><class-id>UI.MultiSelectListDialog</class-id> <category>subclass-operation</category><body package="Com- List Choice Dialogs">deselectAllInList	" Private "	listModel clearAll.</body><body package="Com- List Choice Dialogs">saveSelection        " Private "	selection := ( returnItems		ifTrue: [ listModel selections ]		ifFalse: [ listModel selectionIndexes ] ).	^selection</body><body package="Com- List Choice Dialogs">selectAllInList	" Private "	listModel selectAll.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class></st-source>