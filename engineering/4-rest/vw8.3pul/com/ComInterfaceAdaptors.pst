<?xml version="1.0"?><st-source><!-- Name: Com- Interface AdaptorsNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Extensions to user interface facilities.  MessageBox provides a wrapper for host platform dialog boxes, with default emulation capabilities used where necessary.  TextWindow provides improvements to working with windows containing text which can be used as a workspace and has integrated backing file support.FileDialog is a native windows file finder dialog.DbIdentifier: bear73DbTrace: 497451DbUsername: alexDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Com- Event-Enabled Application Extensions' ''))DialectVersion: VisualWorks 7.9HideSource: falsePackageName: Com- Interface AdaptorsParcel: #('ComInterfaceAdaptors')ParcelName: Com- Interface AdaptorsPrerequisiteParcels: #(#('Com- Event-Enabled Application Extensions' ''))PrintStringCache: (8.3 - 1,alex)SaveSource: trueVersion: 8.3 - 1Date: 1:50:01 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:01</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TextWindow</name><environment>UI</environment><super>UI.EventEnabledApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filePathname windowLabel textCollector textEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Extensions</category><attributes><package>Com- Interface Adaptors</package></attributes></class><comment><class-id>UI.TextWindow</class-id><body>A TextWindow combines the capabilities of a workspace and a text view to enable text to be edited, evaluated, and saved to and from backing files in a uniform fashion.  In addition, a TextWindow will not arbitrarily limit its contents unless the client explicitly configures a buffer limit by sending the #characterLimit: message to bound the buffer contents.Various ways to open a text window:	TextWindow open.	TextWindow label: 'TextWindow Example'.	TextWindow openOn: 'This is some initial text'.	TextWindow openOn: 'This is some initial text'		label: 'TextWindow Example'	TextWindow openOnPathName: 'transcri.txt'.</body></comment><class><name>MessageBox</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private TextConstants.*			</imports><category>Interface-Extensions</category><attributes><package>Com- Interface Adaptors</package></attributes></class><comment><class-id>UI.MessageBox</class-id><body>The MessageBox class provides access to the host system's UI facilities for displaying notifications and getting confirmations from the user.  A platform-independent substitute is used if the services cannot be mapped to host services.Notifications:	MessageBox message: 'This is a message for you.'.	MessageBox warning: 'Consider yourself warned!'.	MessageBox notify: 'Title String' withText: 'Message text...'.Confirmations:	MessageBox confirm: 'Is this what you want?'.	MessageBox threeStateNotify: 'Title String' withText: 'Message text...'.</body></comment><class><name>SimpleTitledDialog</name><environment>UI</environment><super>UI.SimpleDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title allowsCancel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Extensions</category><attributes><package>Com- Interface Adaptors</package></attributes></class><comment><class-id>UI.SimpleTitledDialog</class-id><body>A SimpleTitledDialog extends the SimpleDialog facilities by enabling you to specify text for the title bar of the dialog.</body></comment><class><name>TextWindowTextCollector</name><environment>UI</environment><super>UI.TextCollector</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Extensions</category><attributes><package>Com- Interface Adaptors</package></attributes></class><comment><class-id>UI.TextWindowTextCollector</class-id><body>Class TextWindowTextCollector represents a ValueHolder into which text can be accumulated by using Stream protocol.  By default, there is no limit on the size of the text.  A buffer limit can be configured by setting the characterLimit attribute.The semantics of the operations for text appending operations, such as #nextPut: and #nextPutAll:, differ from the default text view behavior by immediately displaying the text (rather than waiting for the client to explicitly flush the new content into view).  This enables a client application to be written to append text to any flavor of stream (which may be a text pane, the Transcript, a file stream, a string-backed stream) and get reasonable behavior from #nextPut: and #nextPutAll: when it is mapped onto a text view.  In particular, the application should not have to use #show:, since that is specifically only a view-stream protocol and thus not polymorphic with other kinds of useful text sink streams.</body></comment><class><name>TextWindowTextCollectorView</name><environment>UI</environment><super>UI.TextCollectorView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Extensions</category><attributes><package>Com- Interface Adaptors</package></attributes></class><comment><class-id>UI.TextWindowTextCollectorView</class-id><body>A TextWindowTextCollectorView is an obsolete ComposedTextView subclass retained for compatibility.  All behavior is implemented by its superclass ComposedTextView.</body></comment><shared-variable><name>UseNativeDialogs</name><environment>UI.MessageBox</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>false</initializer><attributes><package>Com- Interface Adaptors</package></attributes></shared-variable><shared-variable><name>PlatformProviderMap</name><environment>UI.MessageBox</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Interface Adaptors</package></attributes></shared-variable><methods><class-id>UI.TextWindow</class-id> <category>private-edit menu</category><body package="Com- Interface Adaptors">editCopy	" Private - Perform the Edit menu Copy operation. "	textEditor copySelection.</body><body package="Com- Interface Adaptors">editCut	" Private - Perform the Edit menu Cut operation. "	textEditor cut.</body><body package="Com- Interface Adaptors">editFind	" Private - Perform the Edit menu Find... operation. "	textEditor find.</body><body package="Com- Interface Adaptors">editPaste	" Private - Perform the Edit menu Paste operation. "	textEditor paste.</body><body package="Com- Interface Adaptors">editReplace	" Private - Perform the Edit menu Replace... operation. "	textEditor replace.</body><body package="Com- Interface Adaptors">editRestore	" Private - Perform the Edit menu Restore operation. "	self isModified		ifFalse: [ ^self ].	self filePathname notNil		ifTrue: [ self openTextFile: self filePathname ]		ifFalse: [ self contents: '' ].</body><body package="Com- Interface Adaptors">editSelectAll	" Private - Perform the Edit menu Select All operation. "	textEditor selectFrom: 1 to: textEditor text size.</body><body package="Com- Interface Adaptors">editUndo	" Private - Perform the Edit menu Undo operation. "	textEditor undo.</body></methods><methods><class-id>UI.TextWindow</class-id> <category>private-Smalltalk menu</category><body package="Com- Interface Adaptors">evaluateDoIt	" Private - Perform the Smalltalk menu DoIt operation. "	textEditor doIt.</body><body package="Com- Interface Adaptors">evaluateFileItIn	" Private - Perform the Smalltalk menu File it in... operation. "	| selection |	selection := textEditor selection.	( ReadStream on: selection from: 1 to: selection size ) fileIn.</body><body package="Com- Interface Adaptors">evaluateInspectIt	" Private - Perform the Smalltalk menu InspectIt operation. "	textEditor inspectIt.</body><body package="Com- Interface Adaptors">evaluatePrintIt	" Private - Perform the Smalltalk menu PrintIt operation. "	textEditor printIt.</body></methods><methods><class-id>UI.TextWindow</class-id> <category>accessing</category><body package="Com- Interface Adaptors">characterLimit	" Answer the maximum size in characters of the text in the receiver.  nil indicates unbounded content. "	^textCollector characterLimit</body><body package="Com- Interface Adaptors">characterLimit: anInteger	" Specify the maximum size in characters of the text in the receiver.  Specify nil for unbounded content. "	textCollector characterLimit: anInteger.</body><body package="Com- Interface Adaptors">clearModified	" Mark the receiver as having unmodified contents. "	textEditor textHasChanged: false.</body><body package="Com- Interface Adaptors">contents	" Answer the contents of the text view. "	self isModified		ifTrue: [ ^textEditor text copy ].  " model isn't up to date with the view "	^self textCollector value</body><body package="Com- Interface Adaptors">contents: aString	" Set the contents of the text view to &lt;aString&gt;. "	self textCollector 		clear;		nextPutAll: aString.	self clearModified.</body><body package="Com- Interface Adaptors">setModified	" Mark the receiver as having modified contents. "	textEditor textHasChanged: true.</body><body package="Com- Interface Adaptors">setToTop	" Position the view to the top of the text. "	"( self componentNamed: #textView ) component setToTop."	textEditor selectAt: 1.</body><body package="Com- Interface Adaptors">textCollector	" Answer the text collector to which text can be appended. "	^textCollector</body><body package="Com- Interface Adaptors">windowLabel	" Answer the label of the receiver's view. "	^windowLabel</body><body package="Com- Interface Adaptors">windowLabel: aString	" Set the label of the receiver's view. "	windowLabel := aString.	self triggerEvent: #titleChanged: with: self windowTitle.</body></methods><methods><class-id>UI.TextWindow</class-id> <category>private-operation</category><body package="Com- Interface Adaptors">changesHandled	" Private - answer whether changes to the application state have been handled to the user's satisfaction.  Allow the user to save or discard if the document has been modified. "	| saveChangesResponse |	self isModified 		ifFalse: [ ^true ].  " no changes, life is grand "	" the document has been modified - find out what the user wants done "	saveChangesResponse := MessageBox threeStateNotify: (#PleaseConfirm1 &lt;&lt; #com &gt;&gt; 'Please confirm') asString		withText: (#SaveChangesToTextFile &lt;&lt; #com &gt;&gt; 'Save changes to text file?') asString.	saveChangesResponse isNil		ifTrue: [ ^false ].  " cancelled "	saveChangesResponse		ifFalse: [ 			^true ].	^self fileSave</body><body package="Com- Interface Adaptors">confirmTextChange	" Private - answer whether changes to the value can be accepted to a backing store. "	| aPathName |	self filePathname notNil		ifTrue: [ ^true ].	aPathName := FileDialog saveFile: self defaultFileName.	aPathName isNil		ifTrue: [ ^false ].   " user cancelled "	filePathname := aPathName.	^true</body><body package="Com- Interface Adaptors">openTextFile: aPathName	" Private - open the file named &lt;aPathName&gt; and display its contents in the receiver.  Answer whether successful. "	| aFilename |	aFilename := aPathName asFilename.	aFilename definitelyExists		ifFalse: [			MessageBox warning: ((#FileNotFoundC1s &lt;&lt; #com &gt;&gt; 'File not found: &lt;1s&gt;')			expandMacrosWith: aPathName printString).			^false ].	Cursor read showWhile: [		| fs |		fs := aFilename readStream.		self 			contents: fs contents;			setToTop.		fs close ].	^true</body><body package="Com- Interface Adaptors">saveTextChange	" Private - the view has accepted changes.  Save the text to the backing store.. "	"Assert isTrue: [ self isModified not ]."  " this got cleared underneath us by the text editor controlling this pane "	self saveTextFile: self filePathname.	self windowLabel: nil.  " reset the window label to reflect the file name "</body><body package="Com- Interface Adaptors">saveTextFile: aPathName	" Private - save the contents of the view to the file named &lt;aPathName&gt;.  Answer whether successful. "	Cursor read showWhile: [		| fs |		fs := aPathName asFilename newReadWriteStream.		fs nextPutAll: self contents asString. 		fs close ].	self clearModified.	^true</body></methods><methods><class-id>UI.TextWindow</class-id> <category>private-accessing</category><body package="Com- Interface Adaptors">defaultFileName	" Private - answer the default name for a new backing file. "	^((#Untitled1s &lt;&lt; #com &gt;&gt; 'Untitled.&lt;1s&gt;')			expandMacrosWith: self fileExtension)</body><body package="Com- Interface Adaptors">defaultFilePattern	" Private - answer the default file type in a file dialog for the receiver. "	^'*.', self fileExtension</body><body package="Com- Interface Adaptors">fileExtension	" Answer the backing storage file extension. "	^'txt'</body><body package="Com- Interface Adaptors">filePathname	" Answer the pathname of the file. "	^filePathname</body><body package="Com- Interface Adaptors">filePathname: aString	" Specify the pathname of the file. "	filePathname := aString.	self windowLabel: nil.  " reset the window label to reflect the file name "</body><body package="Com- Interface Adaptors">windowTitle        " Private - answer the window title. "	windowLabel notNil		ifTrue: [ ^windowLabel ].	^(self filePathname isNil		ifTrue: [ #TextWindowUntitled &lt;&lt; #com &gt;&gt; 'Text Window - (untitled)' ]		ifFalse: [#NamedTextWindowLabel &lt;&lt; #com &gt;&gt; 'Text Window on &lt;1s&gt;' expandMacrosWith: self filePathname] ) asString</body></methods><methods><class-id>UI.TextWindow</class-id> <category>testing</category><body package="Com- Interface Adaptors">isModified	" Answer whether the contents of the view have been modified since initially opened or last loaded. "	^textEditor textHasChanged</body></methods><methods><class-id>UI.TextWindow</class-id> <category>private-file menu</category><body package="Com- Interface Adaptors">fileClose	" Private - Perform the File menu Close operation.  Close the receiver's view. "	self closeRequest.</body><body package="Com- Interface Adaptors">fileNew	" Private - Perform the File menu New operation.  Open a new instance of the receiver's class. "	self class open.</body><body package="Com- Interface Adaptors">fileOpen	" Private - Perform the File menu Open... operation.  Prompt the user for the file name containing the data to be displayed in the receiver's view. "	| aPathName |	self changesHandled 		ifFalse: [ ^nil ].	aPathName := FileDialog openFile: self defaultFilePattern.	aPathName isNil 		ifTrue: [ ^self ].	Cursor execute showWhile: [		( self openTextFile: aPathName )			ifTrue: [ self filePathname: aPathName ].			"ifFalse: [ self filePathname: nil ]"		].</body><body package="Com- Interface Adaptors">fileSave	" Private - Perform the File menu Save operation.  Save the current contents of the window to its backing file.  Answer whether the save operation was completed successfully. "	| saveSucceeded |	self filePathname isNil		ifTrue: [ ^self fileSaveAs ].	Cursor execute showWhile: [ 		saveSucceeded := self saveTextFile: self filePathname ].	^saveSucceeded</body><body package="Com- Interface Adaptors">fileSaveAs        " Private - Perform the File menu Save As... operation.  Save the current contents of the window to a file specified by the user.  Answer whether the save operation was completed successfully. "	| aPathName saveSucceeded |	aPathName := FileDialog saveFile: ( self filePathname notNil		ifTrue: [ self filePathname ]		ifFalse: [ self defaultFileName ] ).	aPathName isNil		ifTrue: [ ^false ].   " user cancelled "	Cursor execute showWhile: [		( saveSucceeded := self saveTextFile: aPathName )			ifTrue: [ self filePathname: aPathName ].		].	^saveSucceeded</body></methods><methods><class-id>UI.TextWindow</class-id> <category>private-initialization</category><body package="Com- Interface Adaptors">initialState: aString	" Private - set the initial state of the receiver to &lt;aString&gt;. "	self textCollector nextPutAll: aString.</body><body package="Com- Interface Adaptors">initialize	" Private - initialize a new instance. "	textCollector := TextWindowTextCollector new.	windowLabel := (#TextWindowUntitled &lt;&lt; #com &gt;&gt; 'Text Window - (untitled)') asString.</body></methods><methods><class-id>UI.TextWindow</class-id> <category>subclass-menu operations</category><body package="Com- Interface Adaptors">menuBarName	" Answer the name of the menu bar component in the receiver's view. "	^#menuBarSpec</body></methods><methods><class-id>UI.TextWindow</class-id> <category>private-window events</category><body package="Com- Interface Adaptors">confirmCloseWindow	" Private - the window is about to close.  Make sure the user has a chance to save any changes. "	self changesHandled		ifFalse: [ self applicationWindow abortClose ].</body><body package="Com- Interface Adaptors">windowBuilt	" Private - the window has been constructed by the builder and is about to be opened. "	self applicationWindow label: self windowTitle.</body></methods><methods><class-id>UI.TextWindow</class-id> <category>private-view creation</category><body package="Com- Interface Adaptors">textView	"Construct a view for the text contents."	| aTextView aDispatcher |	aTextView := TextCollectorView new model: self textCollector.	textEditor := TextEditorController new.	textEditor 		menuHolder: ( ValueHolder with: self class textMenu );		performer: self.  " route popup menu operations back here to ensure menu bar/popup consistency "	aDispatcher := UIDispatcher new.	aDispatcher		receiver: self;		requestValueChangeSelector: #confirmTextChange ;		valueChangeSelector: #saveTextChange.	textEditor setDispatcher: aDispatcher.	aTextView controller: textEditor.	^aTextView</body></methods><methods><class-id>UI.TextWindow class</class-id> <category>interface specs</category><body package="Com- Interface Adaptors">eventHandlersSpec	" Answer the specifications for connecting components of the application using events "	^super eventHandlersSpec, #(		#( #applicationWindow			#( #built #windowBuilt )			"#( #opened #windowOpened )"			#( #confirmClose #confirmCloseWindow )			)		#( #application			#( #titleChanged: #label: #applicationWindow ) 			)		)</body></methods><methods><class-id>UI.TextWindow class</class-id> <category>opening</category><body package="Com- Interface Adaptors">label: titleString	" Create and open a new instance of the receiver with window label &lt;titleString&gt;.  Answer the text window. "	" TextWindow label: 'Text Window Test' "	^self openOn: String new label: titleString</body><body package="Com- Interface Adaptors">open	" Create and open a new instance of the receiver.  Answer the text window. "	" TextWindow open "	| aTextWindow |	aTextWindow := self new.	self openOn: aTextWindow withSpec: #windowSpec.	^aTextWindow</body><body package="Com- Interface Adaptors">openOn: aString	" Create and open a new instance of the receiver with  the contents initialized to &lt;aString&gt;.  Answer the text window. "	" TextWindow openOn: 'some text' "	| aTextWindow |	aTextWindow := self new.	self openOn: aTextWindow withSpec: #windowSpec.	aTextWindow 		contents: aString;		setToTop.	^aTextWindow</body><body package="Com- Interface Adaptors">openOn: aString label: titleString	" Create and open a new instance of the receiver with window label &lt;titleString&gt; and whose contents are initialized to &lt;aString&gt;.  Answer the text window. "	" TextWindow openOn: 'some text' label: 'A Text Window' "	| aTextWindow |	aTextWindow := self new.	aTextWindow windowLabel: titleString.	self openOn: aTextWindow withSpec: #windowSpec.	aTextWindow 		contents: aString;		setToTop.	^aTextWindow</body><body package="Com- Interface Adaptors">openOnPathName: aPathName 	" Open a new text window containing the contents of the file named &lt;aPathName&gt;. "	" TextWindow openOnPathName: 'readme.txt' "	| aTextWindow |	aPathName asFilename exists 		ifFalse: 			[self error: (#nosuchfile &lt;&lt; #com &gt;&gt; 'no such file: &lt;1s&gt;' 						expandMacrosWith: aPathName)].	aTextWindow := self new filePathname: aPathName.	self openOn: aTextWindow withSpec: #windowSpec.	Cursor read showWhile: 			[| fs |			fs := aPathName asFilename readStream.			aTextWindow				contents: fs contents;				setToTop.			fs close].	^aTextWindow</body><body package="Com- Interface Adaptors">openPrompted	"Prompt for a file name and open an editor on the named file."	" TextWindow openPrompted "	| aPathName aTextWindow |	aPathName := FileDialog openFile.	aPathName isNil		ifTrue: [ ^nil ].	aPathName asFilename exists		ifTrue: [ ^self openOnPathName: aPathName ].	aTextWindow := self new filePathname: aPathName.	self openOn: aTextWindow withSpec: #windowSpec.	aTextWindow 		contents: (#NewFileHeader &lt;&lt; #com &gt;&gt; '- new file -') asString;		setToTop.	^aTextWindow</body><body package="Com- Interface Adaptors">openWorkspace	"Open a workspace in which Smalltalk expressions can be evaluated."	" TextWindow openWorkspace "	self label: #Workspace &lt;&lt; #labels &gt;&gt; 'Workspace'.</body></methods><methods><class-id>UI.TextWindow class</class-id> <category>subclass-events</category><body package="Com- Interface Adaptors">constructEventsTriggered	" Answer the set of events which can be triggered by instances of the receiver. "	^super constructEventsTriggered		add: #titleChanged: ;		yourself</body></methods><methods><class-id>UI.MessageBox</class-id> <category>private-formatting</category><body package="Com- Interface Adaptors">formatMessageString: aString	" Private - format a long message string by inserting line breaks so it can be read when the VisualWorks Dialog emulation is used. "	| inStream outStream lineLength aWord nChars |	aString size &lt;= 100		ifTrue: [ ^aString ].	inStream := aString readStream.	outStream := String new newReadWriteStream.	lineLength := 0.	[ inStream atEnd ]		whileFalse: [			" observe that this simple line-breaking won't work with a string containing 				any pre-existing formatting, such as embedded tab's or CR's, so don't to that "			aWord := inStream upTo: Character space.			nChars := aWord size + 1.			( ( lineLength + nChars ) &gt;= 80			and: [ aWord ~= ' ' ] )				ifTrue: [ outStream cr.  lineLength := 0 ].			outStream nextPutAll: aWord; space.			lineLength := lineLength + nChars ].	^outStream contents</body></methods><methods><class-id>UI.MessageBox</class-id> <category>opening</category><body package="Com- Interface Adaptors">confirm: aString	" Display a message box with &lt;aString&gt; as the content and 'Yes' and 'No' for the choices.  Answer true if the selection is Yes, else false."	" MessageBox new confirm: 'Is this what you want?' "	^( SimpleTitledDialog titled: #PleaseConfirm &lt;&lt; #com &gt;&gt; 'Please Confirm' )		choose: ( self formatMessageString: aString ) 		labels: (Array with: #Yes &lt;&lt; #labels &gt;&gt; 'Yes' with: #No &lt;&lt; #labels &gt;&gt; 'No' )		values: #( true false )		default: true		for: nil</body><body package="Com- Interface Adaptors">confirm: titleString withText: aString defaultButton: aBoolean	"Display a message box with &lt;aString&gt; as the content and 'Yes' and 'No' for the choices.  	Answer true if the selection is Yes, else false.	Preset the default button as aBoolean defines	MessageBox new confirm: 'Please Confirm' withText: 'Is this what you want?' defaultButton: false	Returns: 		&lt;Boolean&gt;"	^( SimpleTitledDialog titled: titleString )		choose: ( self formatMessageString: aString ) 		labels: (Array with: #Yes &lt;&lt; #com &gt;&gt; 'Yes' with: #No &lt;&lt; #com &gt;&gt; 'No')		values: #( true false )		default: aBoolean		for: nil</body><body package="Com- Interface Adaptors">critical: aMessageString	"Display a critical message box with &lt;aString&gt; as the content.	 MessageBox new critical: 'Consider yourself warned!'	 Returns: 		"	^self critical: (#critical &lt;&lt; #com &gt;&gt; 'Critical Error') withText: aMessageString</body><body package="Com- Interface Adaptors">critical: aTitleString withText: aMessageString	"Display a critical message box with &lt;aString&gt; as the content and aTitleString as the title	 MessageBox new critical: 'Critical' withText: 'Consider yourself warned!'	 Returns: 		"	^( SimpleTitledDialog titled: aTitleString )		allowsCancel: true;		choose: ( self formatMessageString: aMessageString ) 			labels: #( 'OK' )			values: #( nil )			default: nil			for: nil</body><body package="Com- Interface Adaptors">message: aString	" Display a message box with &lt;aString&gt; as the content and 'OK' for the choices. "	" MessageBox new message: 'This is a message for you.' "	^( SimpleTitledDialog titled: #Information &lt;&lt; #com &gt;&gt; 'Information' )		allowsCancel: true;		choose: ( self formatMessageString: aString ) 			labels: ( Array with: #OK &lt;&lt; #labels &gt;&gt;'OK' )			values: #( nil )			default: nil			for: nil</body><body package="Com- Interface Adaptors">notify: titleString withText: messageString	"Display a message box with &lt;titleString&gt; as its title and &lt;messageString&gt; as the content and  'OK'  for the choices."	" MessageBox new notify: 'Title String' withText: 'Message text...' "	^( SimpleTitledDialog titled: titleString )		allowsCancel: true;		choose: ( self formatMessageString: messageString ) 			labels: (Array with: #OK &lt;&lt; #labels &gt;&gt;'OK' )			values: #( nil )			default: nil			for: nil</body><body package="Com- Interface Adaptors">threeStateNotify: titleString withText: messageString	" Display a message box with &lt;titleString&gt; as its title and &lt;messageString&gt; as the content.  Display buttons labeled 'Yes', 'No', and 'Cancel'.  Answer true, false, or nil.  Answer nil if the user cancels the dialog. "	" MessageBox new threeStateNotify: 'Title String' withText: 'Message text...' "	^( SimpleTitledDialog titled: titleString )		allowsCancel: true;		choose: ( self formatMessageString: messageString ) 			labels: ( Array with:#Yes &lt;&lt; #labels &gt;&gt; 'Yes' with: #No &lt;&lt; #labels &gt;&gt; 'No' with: #Cancel &lt;&lt; #labels &gt;&gt; 'Cancel' )			values: #( true false nil )			default: true			for: nil</body><body package="Com- Interface Adaptors">warning: aString	" Display a warning message box with &lt;aString&gt; as the content. "	" MessageBox new warning: 'Consider yourself warned!' "	^( SimpleTitledDialog titled: (#Warning &lt;&lt; #com &gt;&gt; 'Warning') asString )		allowsCancel: true;		choose: ( self formatMessageString: aString ) 			labels: ( Array with: #OK &lt;&lt; #labels &gt;&gt;'OK' )			values: #( nil )			default: nil			for: nil</body></methods><methods><class-id>UI.MessageBox class</class-id> <category>opening</category><body package="Com- Interface Adaptors">confirm: aString	" Display a message box with &lt;aString&gt; as the content and 'Yes' and 'No' for the choices.  Answer true if the selection is Yes, else false."	" MessageBox confirm: 'Is this what you want?' "	^self platformProvider confirm: aString</body><body package="Com- Interface Adaptors">confirm: titleString withText: aString defaultButton: aBoolean	"Display a message box with &lt;aString&gt; as the content and 'Yes' and 'No' for the choices. 	Answer true if the selection is Yes, else false	Preset the default button as aBoolean defines	MessageBox confirm: 'Please Confirm' withText: 'Is this what you want?' defaultButton: false	Returns: 		&lt;Boolean&gt;"	^self platformProvider confirm: titleString withText: aString defaultButton: aBoolean</body><body package="Com- Interface Adaptors">critical: aMessageString	"Display a critical message box with &lt;aString&gt; as the content.	 MessageBox critical: 'Consider yourself warned!'	 Returns: 		"	^self platformProvider critical: aMessageString</body><body package="Com- Interface Adaptors">critical: titleString withText: aMessageString	"Display a critical message box with &lt;aString&gt; as the content and aTitleString as the title	 MessageBox critical: 'Critical Error' withText: 'Consider yourself warned!' 	 Returns: 		"	^self platformProvider critical: titleString withText: aMessageString</body><body package="Com- Interface Adaptors">message: aString	" Display a message box with &lt;aString&gt; as the content and 'OK' for the choices. "	" MessageBox message: 'This is a message' "	^self platformProvider message: aString</body><body package="Com- Interface Adaptors">notify: titleString withText: messageString	"Display a message box with &lt;titleString&gt; as its title and &lt;messageString&gt; as the content and  'OK'  for the choices."	" MessageBox notify: 'Title String' withText: 'Message text...' "	^self platformProvider notify: titleString withText: messageString</body><body package="Com- Interface Adaptors">threeStateNotify: titleString withText: messageString	" Display a message box with &lt;titleString&gt; as its title and &lt;messageString&gt; as the content.  Display buttons labeled 'Yes', 'No', and 'Cancel'.  Answer true, false, or nil.  Answer nil if the user cancels the dialog. "	" MessageBox threeStateNotify: 'Title String' withText: 'Message text...' "	^self platformProvider threeStateNotify: titleString withText: messageString</body><body package="Com- Interface Adaptors">warning: aString	" Display a warning message box with &lt;aString&gt; as the content. "	" MessageBox warning: 'Consider yourself warned!' "	^self platformProvider warning: aString</body></methods><methods><class-id>UI.MessageBox class</class-id> <category>private-platform binding</category><body package="Com- Interface Adaptors">platformProvider	" Private - answer an object which provides MessageBox services on the current platform.  Emulate with an instance of the receiver if no provider is registered for the current host platform. "	self useNativeDialogs ifFalse: [^self new].	PlatformProviderMap isNil ifTrue: [^self new].	^PlatformProviderMap at: OSHandle currentOS ifAbsent: [self new]	"HostInterface"</body><body package="Com- Interface Adaptors">registerPlatformProvider: aClass for: aPlatform	" Register &lt;aClass&gt; as the MessageBox implementation for host platform &lt;aPlatform&gt;. "	| currentProvider |	PlatformProviderMap isNil		ifTrue: [ PlatformProviderMap := Dictionary new ].	currentProvider := PlatformProviderMap at: aPlatform		ifAbsent: [ nil ].	( currentProvider notNil	and: [ currentProvider ~= aClass ] )		ifTrue: [			( self confirm: ((#AboutToReplaceMessageBoxImplementor &lt;&lt; #com &gt;&gt; 'You are about to replace &lt;1s&gt; with &lt;2s&gt; as the MessageBox implementor for &lt;3s&gt;.  Proceed?')			expandMacrosWith: currentProvider printString			with: aClass printString			with: aPlatform printString) )					ifFalse: [ ^nil ].			].	PlatformProviderMap at: aPlatform put: aClass.</body><body package="Com- Interface Adaptors">unregisterPlatformProvider: aClass for: aPlatform	" Remove the registration &lt;aClass&gt; as the MessageBox implementation for host platform &lt;aPlatform&gt;. "	| currentProvider |	PlatformProviderMap isNil		ifTrue: [ 			self warning: ((#CantRemoveMessageBoxRegistration1 &lt;&lt; #com &gt;&gt; 'Can''t remove MessageBox registration of &lt;1s&gt; (nothing registered for any platform).')			expandMacrosWith: aClass printString).			^nil ].	currentProvider := PlatformProviderMap at: aPlatform		ifAbsent: [ nil ].	currentProvider isNil		ifTrue: [			self warning: ((#CantRemoveMessageBoxRegistration2 &lt;&lt; #com &gt;&gt; 'Can''t remove MessageBox registration of &lt;1s&gt; (nothing is registered for &lt;2s&gt;).')			expandMacrosWith: aClass printString			with: aPlatform printString).			^nil ].	currentProvider ~= aClass		ifTrue: [			self warning: ((#CantRemoveMessageBoxRegistration3 &lt;&lt; #com &gt;&gt; 'Can''t remove MessageBox registration of &lt;1s&gt; (&lt;2s&gt; is registered for &lt;3s&gt;).')			expandMacrosWith: aClass printString			with: currentProvider printString			with: aPlatform printString).			^nil ].	PlatformProviderMap removeKey: aPlatform.</body><body package="Com- Interface Adaptors">useNativeDialogs	^UseNativeDialogs</body><body package="Com- Interface Adaptors">useNativeDialogs: aBoolean	UseNativeDialogs := aBoolean</body></methods><methods><class-id>UI.SimpleTitledDialog</class-id> <category>private-view creation</category><body package="Com- Interface Adaptors">preOpen	"Do everything short of actually opening the window."	allowsCancel notNil		ifTrue: [ self escapeIsCancel: allowsCancel ].  " need to override hardwired decision in choice, too bad "	super preOpen.	title notNil		ifTrue: [ 	builder window label: title ].</body></methods><methods><class-id>UI.SimpleTitledDialog</class-id> <category>accessing</category><body package="Com- Interface Adaptors">allowsCancel: aBoolean	" Specify whether the user is allowed to cancel the dialog. "	allowsCancel := aBoolean.</body><body package="Com- Interface Adaptors">title: aString	" Specify the title text of the dialog. "	title := aString.</body></methods><methods><class-id>UI.SimpleTitledDialog class</class-id> <category>instance creation</category><body package="Com- Interface Adaptors">titled: aString	" Answer a new instance of the receiver which displays &lt;aString&gt; in the title bar of the dialog. "	^self new		title: aString;		yourself</body></methods><methods><class-id>UI.TextWindowTextCollector</class-id> <category>character writing</category><body package="Com- Interface Adaptors">cr	"Append a carriage return to the text."	super cr.	self endEntry.</body></methods><methods><class-id>UI.TextWindowTextCollector</class-id> <category>entry control</category><body package="Com- Interface Adaptors">appendEntry	"Append the text contents of the receiver's WriteStream to its text."	value := value , self nextEntry asText.	"value size &gt; self characterLimit"	( characterLimit notNil and: [ value size &gt; characterLimit ] )		ifTrue: [			value := value copyFrom: value size - ( characterLimit // 2 )				to: value size ].	self beginEntry</body></methods><methods><class-id>UI.TextWindowTextCollector</class-id> <category>accessing</category><body package="Com- Interface Adaptors">nextChunkPut: aString 	"Put aString onto the text stream, doubling embedded terminators."	entryStream nextChunkPut: aString.	self endEntry.</body><body package="Com- Interface Adaptors">nextPut: aCharacter 	"Append aCharacter to the text."	super nextPut: aCharacter.	self endEntry.</body><body package="Com- Interface Adaptors">nextPutAll: aCollection 	"Append all the characters in aCollection to the text."	super nextPutAll: aCollection.	self endEntry.</body></methods><methods><class-id>Tools.FileDialog class</class-id> <category>opening</category><body package="Com- Interface Adaptors">openFile	"Open a dialog to obtain the name of a file to open.  The title is set to 	'Open File' and fileSpec is set to '*.*'.  Answer the path name of the file selected 	by the user.  Answer nil if the user cancels the dialog. "	"FileDialog openFile"	^self 		openFileTitle: #OpenFile &lt;&lt; #com &gt;&gt; 'Open File' 		pattern: '*.*'</body><body package="Com- Interface Adaptors">openFile: patternString	"Open a dialog to obtain the name of a file to open.  The title is set to 	'Open File' and fileSpec is set to &lt;patternString&gt;.  Answer the path name 	of the file selected by the user.  Answer nil if the user cancels the dialog. "	"FileDialog openFile: '*.txt'"	^self 		openFileTitle: #OpenFile &lt;&lt; #com &gt;&gt; 'Open File' 		pattern: patternString</body><body package="Com- Interface Adaptors">openFileTitle: aTitleString pattern: patternString	"Open a dialog to obtain the name of a file to open.  The title is set to 	&lt;aTitleString&gt; and fileSpec is set to &lt;patternString&gt;.  Answer the path	name of the file selected by the user.  Answer nil if the user cancels the dialog."	"FileDialog openFileTitle: 'Open File' pattern: '*.txt'"		| dialog |	dialog := OpenFileDialog new.	dialog windowTitle: (self windowTitleFrom: aTitleString asString).	self massageDefault: patternString into: dialog.	dialog fileCondition: #mustBeOld.	^dialog open		ifTrue: [dialog selectionString]		ifFalse: [nil]</body><body package="Com- Interface Adaptors">saveFile: aString	"Open a dialog to obtain the name of a file to save with &lt;aString&gt; 	as the default name.  The title is set to 'Save File'.  Answer the path name 	of the file selected by the user.  Answer nil if the user cancels the dialog."	"FileDialog saveFile: 'Untitled.txt'"	^self 		saveTitle: #SaveFile &lt;&lt; #com &gt;&gt; 'Save File' 		fileName: aString</body><body package="Com- Interface Adaptors">saveTitle: aTitleString fileName: aString	"Open a dialog to obtain the name of a file to save with &lt;aTitleString&gt; as 	the title and &lt;aString&gt; as the default name.  Answer the path name of 	the file selected by the user.  Answer nil if the user cancels the dialog."	"FileDialog saveTitle: 'Save As' fileName: 'Untitled.txt'"		| dialog |	dialog := SaveFileDialog new.	dialog windowTitle: (self windowTitleFrom: aTitleString asString).	self massageDefault: aString into: dialog.	dialog fileCondition: #new.	^dialog open		ifTrue: [dialog selectionString]		ifFalse: [nil]</body></methods><methods><class-id>UI.TextWindow class</class-id> <category>interface specs</category><body package="Com- Interface Adaptors">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #TextWindowUntitled 				#defaultString: 'Text Window - (untitled)' 				#catalogID: #com ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1305 962 ) 			#flags: 4 			#menu: #menuBarSpec ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 4 0 -2 1 0 1 ) 					#name: #textView 					#flags: 9 					#component: #textView ) ) ) )</body></methods><methods><class-id>UI.TextWindow class</class-id> <category>resources</category><body package="Com- Interface Adaptors">menuBarSpec	"Tools.MenuEditor new openOnClass: self andSelector: #menuBarSpec"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_NewDot 								#defaultString: '&amp;New...' 								#catalogID: #menus ) 							#value: #fileNew ) 						#(#{UI.MenuItem} 							#rawLabel: #(#{Kernel.UserMessage} #key: #Open #defaultString: 'Open...' #catalogID: #com) 							#value: #fileOpen ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Save 								#defaultString: 'Save' 								#catalogID: #menus ) 							#value: #fileSave ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SaveAs 								#defaultString: 'Save As...' 								#catalogID: #menus ) 							#value: #fileSaveAs ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Close 								#defaultString: 'Close' 								#catalogID: #menus ) 							#value: #fileClose ) ) #(1 3 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Edit 					#defaultString: '&amp;Edit' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FindDot 								#defaultString: 'Find...' 								#catalogID: #menus ) 							#value: #editFind ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #ReplaceDot 								#defaultString: 'Replace...' 								#catalogID: #menus ) 							#value: #editReplace ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Undo 								#defaultString: 'Undo' 								#catalogID: #menus ) 							#value: #editUndo ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Cut 								#defaultString: 'Cut' 								#catalogID: #menus ) 							#value: #editCut ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Copy 								#defaultString: 'Copy' 								#catalogID: #menus ) 							#value: #editCopy ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Paste 								#defaultString: 'Paste' 								#catalogID: #menus ) 							#value: #editPaste ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Delete 								#defaultString: 'Delete' 								#catalogID: #labels ) 							#value: #editDelete ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #SelectAll 								#defaultString: 'Select All' 								#catalogID: #menus ) 							#value: #editSelectAll ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Restore 								#defaultString: 'Restore' 								#catalogID: #menus ) 							#value: #editRestore ) ) #(2 1 3 1 1 1 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_Smalltalk 					#defaultString: '&amp;Smalltalk' 					#catalogID: #menus) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DoIt 								#defaultString: 'Do it' 								#catalogID: #menus ) 							#value: #evaluateDoIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PrintIt 								#defaultString: 'Print it' 								#catalogID: #menus ) 							#value: #evaluatePrintIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #Inspect 								#defaultString: 'Inspect' 								#catalogID: #menus ) 							#value: #evaluateInspectIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #FileItIn 								#defaultString: 'File it In' 								#catalogID: #menus ) 							#value: #evaluateFileItIn ) ) #(3 1 ) nil ) ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Com- Interface Adaptors">smalltalkMenuSpec	"Tools.MenuEditor new openOnClass: self andSelector: #smalltalkMenuSpec"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #DoIt 					#defaultString: 'Do it' 					#catalogID: #menus ) 				#value: #evaluateDoIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #PrintIt 					#defaultString: 'Print it' 					#catalogID: #menus ) 				#value: #evaluatePrintIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#value: #evaluateInspectIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FileItIn 					#defaultString: 'File it In' 					#catalogID: #menus ) 				#value: #evaluateFileItIn ) ) #(3 1 ) nil ) "decodeAsLiteralArray"</body><body package="Com- Interface Adaptors">textMenu	"Tools.MenuEditor new openOnClass: self andSelector: #textMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) 				#value: #editCut ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#value: #editCopy ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) 				#value: #editPaste ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#value: #editFind ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ReplaceDot 					#defaultString: 'Replace...' 					#catalogID: #menus ) 				#value: #editReplace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #selectAll 					#defaultString: 'Select all' 					#catalogID: #com ) 				#value: #editSelectAll ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #doIt 					#defaultString: 'Do it' 					#catalogID: #com ) 				#value: #evaluateDoIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #printIt 					#defaultString: 'Print it' 					#catalogID: #com ) 				#value: #evaluatePrintIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Inspect 					#defaultString: 'Inspect' 					#catalogID: #menus ) 				#value: #evaluateInspectIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #fileItIn 					#defaultString: 'File it in' 					#catalogID: #com ) 				#value: #evaluateFileItIn ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #save 					#defaultString: 'Save' 					#catalogID: #com ) 				#value: #fileSave ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #restore 					#defaultString: 'Restore' 					#catalogID: #com ) 				#value: #editRestore ) ) #(3 2 1 3 1 2 ) nil ) decodeAsLiteralArray</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>EventEnabledApplicationModel</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><class><name>SimpleDialog</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>close accept cancel preBuildBlock postBuildBlock postOpenBlock escapeIsCancel parentView useParentColors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Dialogs</category><attributes><package>Interface-Dialogs</package></attributes></class><class><name>TextCollectorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>appendEntryMutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>TextCollector</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entryStream characterLimit writeSequencer nextEntry autoFlush </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class></st-source>