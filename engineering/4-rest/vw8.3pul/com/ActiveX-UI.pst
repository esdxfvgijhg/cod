<?xml version="1.0"?><st-source><!-- Name: ActiveX-UINotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package contains UI related code for ActiveX embeddingDbIdentifier: bear73DbTrace: 497462DbUsername: alexDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'Compression-ZLib' '') #(#any 'ActiveX-Container' '') #(#any 'ActiveX-AutomationExtensions' '') #(#any 'ActiveX-CInterfaces' '') #(#any 'ActiveX-Interfaces' '') #(#any 'Com- Ole Pools' '') #(#any 'Com- Ole' '') #(#any 'Com- System Configuration Services' '') #(#any 'Com- Win32' '') #(#any 'Com- Automation' '') #(#any 'Com- Win32 Pools' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #()PackageName: ActiveX-UIParcel: #('ActiveX-UI')ParcelName: ActiveX-UIPrerequisiteDescriptions: #(#(#name 'Compression-ZLib') #(#name 'ActiveX-Container') #(#name 'ActiveX-AutomationExtensions' #componentType #package) #(#name 'ActiveX-CInterfaces' #componentType #package) #(#name 'ActiveX-Interfaces' #componentType #package) #(#name 'Com- Ole Pools' #componentType #package) #(#name 'Com- Ole' #componentType #package) #(#name 'Com- System Configuration Services' #componentType #package) #(#name 'Com- Win32' #componentType #package) #(#name 'Com- Automation' #componentType #package) #(#name 'Com- Win32 Pools' #componentType #package))PrerequisiteParcels: #(#('Compression-ZLib' '') #('ActiveX-Container' '') #('ActiveX-AutomationExtensions' '') #('ActiveX-CInterfaces' '') #('ActiveX-Interfaces' '') #('Com- Ole Pools' '') #('Com- Ole' '') #('Com- System Configuration Services' '') #('Com- Win32' '') #('Com- Automation' '') #('Com- Win32 Pools' ''))PrintStringCache: (8.3 - 2,alex)Version: 8.3 - 2Post-Load Block: 	[:package | ]Pre-Unload Block: 	[:package | ActiveXSubsystem current uninstallKeyboardHook]Date: 3:07:37 PM April 21, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.2) of April 21, 2017 on April 21, 2017 at 3:07:37 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ActiveXSubsystem</name><environment>Core</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><comment><class-id>Core.ActiveXSubsystem</class-id><body>A subsystem used by ActiveX to be informed about events such as startup and shutdown.</body></comment><class><name>ActiveXSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>progId controlProperties controlBindings licenseKey eventBindings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><comment><class-id>UI.ActiveXSpec</class-id><body>ActiveXSpec is a UI Specification used to store the configuration of an ActiveX Control.Instance Variables	controlBindings		&lt;Collection of: ControlPropertyBinding&gt;		properties which are bound to application aspects	controlProperties	&lt;Array&gt;										contains defined property values of the control	progId				&lt;String&gt;									The progId of the ActiveX Control to embed	licenseKey			&lt;String&gt;									The key used to veryfy the license of a control.	eventBindings		&lt;Array&gt;										An Array of ControlEventBindings, describing what to do on the apearance 																	of which event	</body></comment><class><name>ControlEventBinding</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>event selector parameterNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><comment><class-id>UI.ControlEventBinding</class-id><body>ControlEventBinding has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables	event	&lt;Symbol&gt;	The name of the event which should be caught.	selector	&lt;Symbol&gt;	The selector of the method to be called	parameterNames &lt;Array of Symbols&gt; The names of the parameters of the event</body></comment><class><name>KillFocusEvent</name><environment>UI</environment><super>UI.WindowEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hostStruct hostData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><comment><class-id>UI.KillFocusEvent</class-id><body>Created and handled when a KILLFOCUS event appears for a window.Instance Variables	hostData	&lt;Object | ProtoObject&gt;	description of hostData	hostStruct	&lt;CComposite&gt;	description of hostStruct</body></comment><class><name>ActiveXControlView</name><environment>UI</environment><super>UI.SimpleView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>oleControlSite cachedBounds cachedClippingBounds </inst-vars><class-inst-vars></class-inst-vars><imports>			COMExternalInterfaceDictionary.*			External.COMConstants.*			Win32SystemSupportDictionary.*			</imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><comment><class-id>UI.ActiveXControlView</class-id><body>ActiveXControlView is the Widget View class used to embed ActiveX Controls.Instance Variables		cachedBounds		&lt;Rectangle&gt;			cached bounds		cachedClippingBounds &lt;Rectangle&gt;			cached Clipping bounds		oleControlSite		&lt;COleControlSite&gt;		the site object in which the control resides</body></comment><class><name>AcceleratorTable</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle entries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><comment><class-id>External.AcceleratorTable</class-id><body>AcceleratorTable is a C style Accelerator tableInstance Variables	entries	&lt;(Collection of: Accelerator)&gt;	entries	handle	&lt;CPointer&gt;							The handle of the accelerator table</body></comment><class><name>Accelerator</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fVirt key cmd </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.Win32Constants.*			</imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><comment><class-id>External.Accelerator</class-id><body>Accelerator is used to define keyboard shortcuts in OLE.Instance Variables	cmd	&lt;Integer&gt;		the command	fVirt	&lt;Integer&gt;		the  modifiers	key	&lt;Integer&gt;		the key code</body></comment><class><name>ActiveXControlController</name><environment>UI</environment><super>UI.SelectController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><comment><class-id>UI.ActiveXControlController</class-id><body>ActiveXControlController is the controller used by the ActiveX widget </body></comment><shared-variable><name>Drawing</name><environment>UI.ActiveXControlView</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ActiveX-UI</package></attributes></shared-variable><shared-variable><name>WindowProperties</name><environment>UI.ScheduledWindow</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>WeakKeyedRegistry new</initializer><attributes><package>ActiveX-UI</package></attributes></shared-variable><shared-variable><name>WH_GETMESSAGE</name><environment>External.Win32Constants</environment><private>false</private><constant>false</constant><category>Hook types</category><initializer>3</initializer><attributes><package>ActiveX-UI</package></attributes></shared-variable><shared-variable><name>WM_NULL</name><environment>External.Win32Constants</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>0</initializer><attributes><package>ActiveX-UI</package></attributes></shared-variable><shared-variable><name>WH_CALLWNDPROC</name><environment>External.Win32Constants</environment><private>false</private><constant>false</constant><category>Hook types</category><initializer>4</initializer><attributes><package>ActiveX-UI</package></attributes></shared-variable><shared-variable><name>WM_CREATE</name><environment>External.Win32Constants</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>1</initializer><attributes><package>ActiveX-UI</package></attributes></shared-variable><shared-variable><name>WM_SIZE</name><environment>External.Win32Constants</environment><private>false</private><constant>true</constant><category>Constants</category><initializer>5</initializer><attributes><package>ActiveX-UI</package></attributes></shared-variable><shared-variable><name>Modifiers</name><environment>External.Accelerator</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ActiveX-UI</package></attributes></shared-variable><methods><class-id>Core.ActiveXSubsystem</class-id> <category>initialize-release</category><body package="ActiveX-UI">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Core.ActiveXSubsystem</class-id> <category>default actions</category><body package="ActiveX-UI">pauseAction	"This is the pause hook. It will be called automatically when the system is paused, normally before an image save. 	Do Not Call This Directly.  If you want to manually pause or resume a subsystem call #pause or #resume."	ScheduledWindow scheduledWindows do: [:each | each pauseControls]</body><body package="ActiveX-UI">resumeAction	"This is the resume hook. It will be called automatically when the system is resumed (normally after returning from an image save, but continuing to run).	Do Not Call This Directly.  If you want to manually pause or resume a subsystem call #pause or #resume."	ScheduledWindow scheduledWindows do: [:each | each reactivateControls].</body><body package="ActiveX-UI">setUp	ScheduledWindow scheduledWindows do: [:each | each reactivateControls].</body><body package="ActiveX-UI">tearDown	"This is the deactivation hook. It will be called automatically when the system is deactivated, normally because the image is about to quit.	Do Not Call This Directly.  If you want to manually start up or shut down a subsystem call #activate or #deactivate."	ScheduledWindow scheduledWindows do: [:each | each pauseControls].</body></methods><methods><class-id>Core.ActiveXSubsystem</class-id> <category>prerequisites</category><body package="ActiveX-UI">prerequisiteSystems	"Delays are one of the first things we need available, so we initialize them depending only on the most basic functionality"	^Array with: WindowingSystem with: FinalizationSystem with: COMSystem.</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>accessing</category><body package="ActiveX-UI">controlBindings	^controlBindings</body><body package="ActiveX-UI">controlBindings: anObject	controlBindings := anObject</body><body package="ActiveX-UI">controlProperties	^ controlProperties</body><body package="ActiveX-UI">controlProperties: values	controlProperties := values</body><body package="ActiveX-UI">eventBindings	^eventBindings</body><body package="ActiveX-UI">eventBindings: anObject	eventBindings := anObject</body><body package="ActiveX-UI">licenseKey	^licenseKey</body><body package="ActiveX-UI">licenseKey: anObject	licenseKey := anObject</body><body package="ActiveX-UI">modelInBuilder: builder	| aModel |	aModel := super modelInBuilder: builder.	aModel value ifNotNil: [:m |		"copy the properties to ensure no values are transported back"		m storedProperties: self controlProperties copy.		builder isEditing ifFalse: [ m licenseKey: self licenseKey ].		m progId: self progId.		builder isEditing ifTrue: [			aModel value isLicenseKeyAvailable ifTrue: [				self licenseKey: aModel value requestLicKey ]]].	^ aModel</body><body package="ActiveX-UI">progId	^progId</body><body package="ActiveX-UI">progId: anObject		anObject = progId ifTrue: [ ^ self ].	progId := anObject.	self initializeControlSettings.</body><body package="ActiveX-UI">saveControlState: aControl properties: propertyValues	"Save the currentState of the control for restoring it later"	| props |	props := AbstractControlProperties newForControl: aControl propertieValues: propertyValues.	aControl storedProperties: props.	self controlProperties: props.</body><body package="ActiveX-UI">tabable	"Answer the value for tabable"	^tabable ifNil: [ true ]</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>private</category><body package="ActiveX-UI">decodeControlBindingsFromLiteralArray: anArray	^ anArray isNil 		ifTrue:  [ nil ]		ifFalse: [ anArray collect: [:each | each decodeAsLiteralArray]]</body><body package="ActiveX-UI">decodeControlPropertiesFromLiteralArray: anArray	^ AbstractControlProperties fromLiteralArray: anArray</body><body package="ActiveX-UI">decodeEventBindingsFromLiteralArray: anArray	^ anArray isNil 		ifTrue:  [ nil ]		ifFalse: [ anArray collect: [:each | each decodeAsLiteralArray]]</body><body package="ActiveX-UI">defaultModel	^  progId 		ifNil: [ nil ]		ifNotNil: [ (ControlProxy new) asValue ]</body><body package="ActiveX-UI">dispatchTo: policy with: builder	"Dispatch control to policy using builder."	policy activeXControl: self into: builder.</body><body package="ActiveX-UI">fromLiteralArrayEncoding: anArray	super fromLiteralArrayEncoding: anArray.	controlProperties := self decodeControlPropertiesFromLiteralArray: controlProperties.	controlBindings := self decodeControlBindingsFromLiteralArray: controlBindings.	eventBindings := self decodeEventBindingsFromLiteralArray: eventBindings .</body><body package="ActiveX-UI">literalArrayEncoding	| slots instanceVariableNames targetSlot targetClass literalArray instVars|		self checkForNeededSymbolicLabel.	targetClass := self class.	instanceVariableNames := targetClass allInstVarNames.	instVars := instanceVariableNames collect: [:aName | | index |		index := self class instVarIndexFor: aName.		aName -&gt; (self instVarAt: index) ].	instVars := instVars select: [:each | each value notNil ].	slots := instVars size.	literalArray := Array new: slots * 2 + 1.	literalArray at: 1 put: targetClass fullyQualifiedReference.	targetSlot := 2.	instVars do: [:association | 			literalArray at: targetSlot put: (association key , ':') asSymbol.			literalArray at: targetSlot + 1 put: association value literalArrayEncoding.			targetSlot := targetSlot + 2].	^literalArray</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>initialize-release</category><body package="ActiveX-UI">initialize	"Initialize the receiver."		self initializeControlSettings.	^ super initialize</body><body package="ActiveX-UI">initializeControlSettings		self controlProperties: ListControlProperties new.	self controlBindings: #().	self eventBindings: #().</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>aspect creation</category><body package="ActiveX-UI">installControlEventsIn: appModel For: aControl	self eventBindings do: [:each |		aControl when: each event do: [:args |  appModel controlEvent: each selector arguments: args ]].</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>testing</category><body package="ActiveX-UI">isDecorated	^self decorationType == #bordered		ifTrue: [true]		ifFalse: [false]</body></methods><methods><class-id>UI.ControlEventBinding</class-id> <category>accessing</category><body package="ActiveX-UI">event	^event</body><body package="ActiveX-UI">event: anObject	event := anObject</body><body package="ActiveX-UI">hasParameters	^ self parameterNames notEmpty</body><body package="ActiveX-UI">literalArrayEncoding		^Array		with: self class fullyQualifiedReference		with: self event literalArrayEncoding		with: self selector literalArrayEncoding		with: self parameterNames literalArrayEncoding</body><body package="ActiveX-UI">numberOfParameters	^ self parameterNames size</body><body package="ActiveX-UI">parameterNames	^parameterNames</body><body package="ActiveX-UI">parameterNames: anObject	parameterNames := anObject</body><body package="ActiveX-UI">selector	^selector</body><body package="ActiveX-UI">selector: anObject	selector := anObject</body></methods><methods><class-id>UI.ControlEventBinding</class-id> <category>private</category><body package="ActiveX-UI">proposedSelectorForModelName: modelName		| prefix aSelector |	prefix := modelName asString startingWithLowercaseLetter.	aSelector := prefix , self event startingWithUppercaseLetter.	self hasParameters		ifTrue:			[aSelector := aSelector , ':'.			2				to: self parameterNames size				do:					[:index | aSelector := aSelector , (self parameterNames at: index) startingWithLowercaseLetter , ':']].	^aSelector asSymbol</body></methods><methods><class-id>UI.ControlEventBinding</class-id> <category>initialize-release</category><body package="ActiveX-UI">takeValuesFrom: eventSpec modelName: modelName		eventSpec		ifNil:			[self				parameterNames: #();				selector: nil]		ifNotNil:			[self				parameterNames: eventSpec parameterNames;				selector: (self proposedSelectorForModelName: modelName)]</body></methods><methods><class-id>UI.ControlEventBinding class</class-id> <category>As yet unclassified</category><body package="ActiveX-UI">decodeFromLiteralArray: anArray		^self new		event: (anArray at: 2) decodeAsLiteralArray;		selector: (anArray at: 3) decodeAsLiteralArray;		parameterNames: (anArray at: 4);		yourself</body></methods><methods><class-id>UI.KillFocusEvent</class-id> <category>dispatching</category><body package="ActiveX-UI">dispatchTo: anObject	^anObject killFocusEvent: self</body></methods><methods><class-id>UI.KillFocusEvent</class-id> <category>private accessing</category><body package="ActiveX-UI">hostStruct		^hostStruct ifNil:			[hostStruct := CComposite newDatum: hostData ofType: Win32UserDLL current ST_EventRecord]</body></methods><methods><class-id>UI.KillFocusEvent</class-id> <category>initialize-release</category><body package="ActiveX-UI">loadFrom: anEventArray 	super loadFrom: anEventArray copy.		hostData := (anEventArray at: 10) copy.</body></methods><methods><class-id>UI.KillFocusEvent</class-id> <category>accessing</category><body package="ActiveX-UI">newFocusWindowHandle		^Win32Window		withHandle:			(CPointerType defaultPointer				newOfAddress: (self hostStruct memberAt: #wParam))</body></methods><methods><class-id>UI.ActiveXControlView</class-id> <category>accessing</category><body package="ActiveX-UI">basicOleControlSite		^ oleControlSite</body><body package="ActiveX-UI">clippingBounds	| gc |	^ cachedClippingBounds ifNil: [ 		gc := self graphicsContext.		cachedClippingBounds := gc clippingBounds translatedBy: gc translation.]</body><body package="ActiveX-UI">clsid	^ self model ifNotNil: [:m | m clsid]</body><body package="ActiveX-UI">clsid: aClsID	self oleControl ifNotNil: [:m | m clsidOrString: aClsID ]</body><body package="ActiveX-UI">doVerb: aVerb	| bounds |	bounds := self widgetBounds asTemporaryCStructure.	^ self oleControl iOleObject doVerb: aVerb with: nil  with: self oleControlSite iOleClientSite with: 0 with: self  windowHandle with: bounds</body><body package="ActiveX-UI">getPositionRect: posRectRef clipRect: clipRectRef	posRectRef value: self widgetBounds.	"outer rectangle containing the in-place object's position rectangle (PosRect). This rectangle is relative to the client area of the object's parent window."	clipRectRef value: self clippingBounds.</body><body package="ActiveX-UI">hasWindow	^ (self propertyAt: #hasWindow) ifNil: [ false ].</body><body package="ActiveX-UI">isEmbeddedInWindow: aBoolean	^ self propertyAt: #isEmbeddedInWindow put: aBoolean</body><body package="ActiveX-UI">isEnabled: aBoolean	state isEnabled == aBoolean ifTrue: [^self].	state isEnabled: aBoolean.	self oleControl ifNotNil: [:c | c isEnabled: aBoolean ].</body><body package="ActiveX-UI">isInDesignMode: aBoolean	self propertyAt: #editMode put: aBoolean.</body><body package="ActiveX-UI">oleContainer	^ self topComponent ifNil: [ nil ] ifNotNil: [:aWindow | aWindow oleContainer]</body><body package="ActiveX-UI">oleControl	^ self model ifNotNil: [:m | m value ]</body><body package="ActiveX-UI">oleControlSite		^ oleControlSite				ifNil:					[self oleControlSite: ControlSite new.					oleControlSite]</body><body package="ActiveX-UI">oleControlSite: aControlSite	oleControlSite ifNotNil: [ oleControlSite view: nil ].	oleControlSite := aControlSite.	oleControlSite ifNotNil: [ oleControlSite view: self ].</body><body package="ActiveX-UI">releaseDC: aDC	^ Win32UserDLL current ReleaseDC: self windowHandle _:aDC</body><body package="ActiveX-UI">widgetBounds	| gc |	^ cachedBounds ifNil: [ 		gc := self graphicsContext.		cachedBounds := self bounds translatedBy: gc translation.]</body><body package="ActiveX-UI">windowDC	^ OSSystemSupport concreteClass new GetDC: self windowHandle</body><body package="ActiveX-UI">windowHandle	^ self topComponent windowHandle</body></methods><methods><class-id>UI.ActiveXControlView</class-id> <category>private</category><body package="ActiveX-UI">activateOrView	self isInDesignMode ifFalse: [self basicActivateOrView ifFalse: [^false]].	self oleControl applyCachedProperties.	^true</body><body package="ActiveX-UI">basicActivateOrView	(self oleControl isNil or: [self oleControl isAllocated not])		ifTrue: [^false].	self oleControl isRunning ifFalse: [self oleControl run].	self oleControl miscStatus invisibleAtRuntime not		ifTrue: 			[self oleControl miscStatus activateWhenVisible				ifTrue: [^ self doActivationVerb]				ifFalse: [self error: 'don''t known whether to activate']].	^ true</body><body package="ActiveX-UI">changedParentage	"The receiver's container has changed.  Inform the receiver's controller."	self checkEmbedding.	^super changedParentage</body><body package="ActiveX-UI">continueDrawCallbackBlockType	^ OSSystemSupport concreteClass new siteContinueDrawCallbackType pointerType</body><body package="ActiveX-UI">doActivationVerb	[ self doVerb: self oleControl activationVerb ] on: Error do: [:ex | ^ false ].	^ true</body><body package="ActiveX-UI">embedControl	"Embed the control"	| aControl |	self oleControl ifNil: [^false].	aControl := self oleControl.	aControl isAllocated ifFalse: [^false].	self oleControlSite ifNotNil: [:site | site oleControl: aControl].	self activateOrView ifFalse: [^false].	self positionChanged: self widgetBounds clippingBounds: self clippingBounds.	"update the control's extents since setting the extent of the widget 			has already happened before the window was opened"	self invalidate.	^true</body><body package="ActiveX-UI">hideControl		self doVerb: OLEIVERB_HIDE</body><body package="ActiveX-UI">reEmbedControl	"Embed the control"		self oleControl		ifNotNil:			[:m | 			m reactivate.			self activateOrView.			self				positionChanged: self widgetBounds				clippingBounds: self clippingBounds]</body><body package="ActiveX-UI">revokeControlEmbedding		self model value ifNotNil: [:control | control isInPlaceActive ifTrue: [ self hideControl ]].	oleControlSite isNil ifFalse: [ oleControlSite revokeControlEmbedding]</body><body package="ActiveX-UI">setModel: aModel	"Set the receiver's model to be aModel."		aModel = model ifTrue: [^self].	model removeAllActionsWithReceiver: self.	super setModel: aModel.	model isNil		ifFalse:			[model when: #viewObjectViewChanged send: #viewObjectViewChanged:with: to:					self]</body></methods><methods><class-id>UI.ActiveXControlView</class-id> <category>events</category><body package="ActiveX-UI">embedInWindow	self embedControl ifTrue: [self isEmbeddedInWindow: true]</body><body package="ActiveX-UI">pause		self isEmbeddedInWindow: false.	self model value ifNotNil: [:control | control revokeEmbedding].	self model value releaseComInterfaces.</body><body package="ActiveX-UI">positionChanged: bounds clippingBounds: clippingBounds		self oleControl		ifNotNil:			[:aControl | 			(aControl isAllocated)				ifTrue:					[self oleControl isRunning 						ifTrue: [ self oleControl setExtent: bounds extent.]						ifFalse: [aControl miscStatus recomposeOnResize 										ifTrue: [ self model value run.					  							self oleControl setExtent: bounds extent.]].					[aControl iOleObject update.					 aControl 	iOleInPlaceObject setObjectRects: bounds with: cachedClippingBounds]						on: COMError , COMExternalAccessFailed						do: [:ex | ex return]]]</body><body package="ActiveX-UI">reactivate	self isEmbeddedInWindow: true.		self reEmbedControl.</body><body package="ActiveX-UI">removeFromWindow		self isEmbeddedInWindow: false.		self revokeControlEmbedding.	self model value enforceRelease.	self basicOleControlSite ifNotNil: [ self basicOleControlSite view: nil ].	self oleControlSite: nil.	self model: nil</body><body package="ActiveX-UI">viewObjectViewChanged: anAspect with:index 	self invalidate</body></methods><methods><class-id>UI.ActiveXControlView</class-id> <category>initialize-release</category><body package="ActiveX-UI">checkEmbedding	| window |	window := self topComponent.	self isEmbeddedInWindow 		ifTrue: [ (window isNil or: [ window isOpen not ]) ifTrue: [ self removeFromWindow ]]		ifFalse: [ (window notNil and: [ window isOpen  ]) ifTrue: [ self embedInWindow ]].</body><body package="ActiveX-UI">clearBounds	cachedBounds := nil.	cachedClippingBounds := nil.</body><body package="ActiveX-UI">release	"Release the receiver."	self removeFromWindow.	super release</body></methods><methods><class-id>UI.ActiveXControlView</class-id> <category>displaying</category><body package="ActiveX-UI">displayControlOn: aGraphicsContext in: bounds	| rect1 callback |	aGraphicsContext withDeviceContextDo: 			[:dc |			rect1 := bounds asTemporaryCStructure.			callback := CCallback do: [:p | false]						ofType: self continueDrawCallbackBlockType.						[self model value iViewObject2				drawAspect: DVASPECT_CONTENT				lIndex: 1				pvAspect: 0				ptd: nil				targetDevice: 0				hdcDraw: dc				lprcBounds: rect1				lprcWBounds: nil				pfnContinue: nil				dwContinue: 0]					on: Error					do: 						[:ex |						aGraphicsContext							displayRectangularBorder: (0 @ 0 extent: bounds extent - 1)]]</body><body package="ActiveX-UI">displayEmptyControlStateIn: bounds on: aGraphicsContext			aGraphicsContext paint: ColorValue black.		'Active-X' displayOn: aGraphicsContext at: 4@20.				^ aGraphicsContext displayRectangularBorder: (0 @ 0 extent: bounds extent - 1)</body><body package="ActiveX-UI">displayInvalidControlStateIn: bounds on: aGraphicsContext		self model value isNil ifTrue: [		aGraphicsContext paint: ColorValue black.		'Active-X' displayOn: aGraphicsContext at: 4@20.				^ aGraphicsContext displayRectangularBorder: (0 @ 0 extent: bounds extent - 1) ].		aGraphicsContext paint: ColorValue red.		aGraphicsContext displayRectangularBorder: (0 @ 0 extent: bounds extent - 1).		'Active-X Control not available' displayOn: aGraphicsContext at: 4@20.</body><body package="ActiveX-UI">displayOn: aGraphicsContext	"Display the receiver on aGraphicsContext. The receiver may alter	aGraphicsContext in any way it chooses."	"Subclasses will typically override this method to provide specific display	behavior.  Subclasses may send #displayOn: to super."	cachedBounds ifNil: [^self].	self model value		ifNil: [self displayEmptyControlStateIn: cachedBounds on: aGraphicsContext]		ifNotNil: 			[:aControl |			self isInDesignMode				ifTrue: 					[(aControl isAllocated and: [self isEmbeddedInWindow])						ifTrue: [self displayControlOn: aGraphicsContext in: cachedClippingBounds]						ifFalse: 							[self displayInvalidControlStateIn: cachedBounds on: aGraphicsContext]]				ifFalse: 					[(aControl isAllocated and: [self isEmbeddedInWindow])						ifFalse: 							[self displayInvalidControlStateIn: cachedBounds on: aGraphicsContext]]]</body></methods><methods><class-id>UI.ActiveXControlView</class-id> <category>bounds accessing</category><body package="ActiveX-UI">bounds: newBounds	"The receiver's bounds are being changed to newBounds."	"Inform the controller (if there is one) that any information it was retaining regarding bounds are invalid."		| bounds clippingBounds gc |	self isOpen ifFalse: [^ self ].	self checkEmbedding.	super bounds: newBounds.	bounds := self bounds translatedBy: self graphicsContext translation.	gc := container graphicsContext.	clippingBounds := (gc clippingBounds translatedBy: gc translation)		intersect: bounds.	(cachedBounds ~= bounds or: [clippingBounds ~= cachedClippingBounds])		ifTrue:			[cachedBounds := bounds.			cachedClippingBounds := clippingBounds.			self isEmbeddedInWindow				ifTrue:					[self positionChanged: bounds clippingBounds: cachedClippingBounds]]</body></methods><methods><class-id>UI.ActiveXControlView</class-id> <category>private testing</category><body package="ActiveX-UI">isEmbeddedInWindow	^ (self propertyAt: #isEmbeddedInWindow) ifNil: [ false ].</body><body package="ActiveX-UI">isInDesignMode	^ (self propertyAt: #editMode) ifNil: [ true ]</body></methods><methods><class-id>UI.ActiveXControlView</class-id> <category>testing</category><body package="ActiveX-UI">containsActiveXControl	^ true</body></methods><methods><class-id>UI.ActiveXControlView class</class-id> <category>private-events</category><body package="ActiveX-UI">ambivalentEventChecking	^ true</body></methods><methods><class-id>External.AcceleratorTable</class-id> <category>testing</category><body package="ActiveX-UI">includes: anAccelerator	^ self entries includes: anAccelerator</body></methods><methods><class-id>External.AcceleratorTable</class-id> <category>accessing</category><body package="ActiveX-UI">add: anAccelerator	self entries add: anAccelerator</body><body package="ActiveX-UI">entries	^entries</body><body package="ActiveX-UI">entries: anObject	entries := anObject</body><body package="ActiveX-UI">handle	^handle ifNil: [ self initializeAcceleratorHandle ]</body><body package="ActiveX-UI">handle: anObject	handle ifNotNil: [ self releaseHandle: handle .].	handle := anObject.</body><body package="ActiveX-UI">size	^ entries size</body></methods><methods><class-id>External.AcceleratorTable</class-id> <category>initialize-release</category><body package="ActiveX-UI">createCTable	| table ptr osSupport |	osSupport := OSSystemSupport concreteClass new. 	table := osSupport ACCEL calloc: self size.	ptr := osSupport LPACCEL baseType newOfAddress: table datum.	self entries do: [:each |		each setValuesInStructure: ptr.		ptr increment ].	^ table.</body><body package="ActiveX-UI">initialize	super initialize.	entries := OrderedCollection new.</body><body package="ActiveX-UI">initializeAcceleratorHandle	| ctable |	ctable := self createCTable.	self handle: (self createHandleFor: ctable size: self size).	^ handle "	ensure:  [ 		ctable free. 		ctable := nil]"</body><body package="ActiveX-UI">release	self handle: nil.	^ super release.</body></methods><methods><class-id>External.AcceleratorTable</class-id> <category>private</category><body package="ActiveX-UI">createHandleFor: ctable size: aSize	| osSupport result |	osSupport := OSSystemSupport concreteClass new. 	result := osSupport CreateAcceleratorTable: ctable entries: aSize."	result asInteger = 0 		ifTrue: [ Win32UserDLL current osWarning ]."	^ result</body><body package="ActiveX-UI">releaseHandle: aHandle	^ OSSystemSupport concreteClass new DestroyAcceleratorTable: aHandle.</body></methods><methods><class-id>External.AcceleratorTable class</class-id> <category>instance creation</category><body package="ActiveX-UI">fromControlStructure: lpControlInfo	| instance numElements lpAccel |	instance :=  self new.	lpControlInfo ifNil: [ ^ instance ].	numElements := lpControlInfo memberAt: #cAccel.	lpAccel := Win32SystemSupport concreteClass new copyAcceleratorTable: (lpControlInfo refMemberAt: #hAccel) entries: numElements.	numElements timesRepeat: [		instance add: (Accelerator fromPtr: lpAccel).		lpAccel increment].	^ instance</body><body package="ActiveX-UI">new	^ super new initialize</body></methods><methods><class-id>External.Accelerator</class-id> <category>accessing</category><body package="ActiveX-UI">cmd	^cmd</body><body package="ActiveX-UI">cmd: anObject	cmd := anObject</body><body package="ActiveX-UI">fVirt	^fVirt</body><body package="ActiveX-UI">fVirt: anObject	fVirt := anObject</body><body package="ActiveX-UI">key	^key</body><body package="ActiveX-UI">key: anObject	key := anObject</body><body package="ActiveX-UI">modifiers: modifiers		| res |	res := modifiers		inject: 0		into: [:sum :each | (self class modifierValueFor: each) + sum].	self fVirt:			(res = 0				ifTrue: 	[self error: #NoModifierSpecified &lt;&lt; #com &gt;&gt; 'No modifiers where specified']				ifFalse: 	[res])</body></methods><methods><class-id>External.Accelerator</class-id> <category>testing</category><body package="ActiveX-UI">hasVirtualKey	^ self fVirt bitAnd: FVIRTKEY</body><body package="ActiveX-UI">isAltFlagSet	^ fVirt bitAnd: FALT</body><body package="ActiveX-UI">isControlFlagSet	^ fVirt bitAnd: FCONTROL</body><body package="ActiveX-UI">isShiftFlagSet	^ fVirt bitAnd: FSHIFT</body></methods><methods><class-id>External.Accelerator</class-id> <category>C Type creation</category><body package="ActiveX-UI">setValuesInStructure: lpAccel	lpAccel 		memberAt: #fVirt put: self fVirt;		memberAt: #key put: self key;		memberAt: #cmd put: self cmd.</body></methods><methods><class-id>External.Accelerator</class-id> <category>printing</category><body package="ActiveX-UI">printOn: aStream	aStream nextPutAll: 'anAccelerator('.	(self modifierStrings copyWith: self keyName)			do: [:each | aStream nextPutAll: each ]			separatedBy: [ aStream nextPutAll: ' + ' ].	aStream nextPutAll: ')'.</body></methods><methods><class-id>External.Accelerator</class-id> <category>private</category><body package="ActiveX-UI">keyName	^ self key printString</body><body package="ActiveX-UI">modifierStrings	^ self class modifiers associations inject: OrderedCollection new into: [:sum :each |			(self fVirt bitAnd: each value) &gt; 0 ifTrue: [ sum add: each key ].			sum ].</body></methods><methods><class-id>External.Accelerator</class-id> <category>comparing</category><body package="ActiveX-UI">= anAccelerator	^ self key = anAccelerator key and: [ self fVirt = anAccelerator fVirt ]</body><body package="ActiveX-UI">hash	^ self key hash</body></methods><methods><class-id>External.Accelerator class</class-id> <category>private instance creation</category><body package="ActiveX-UI">altKey: key command: command	^ self fvirt: FALT key: key command: command</body><body package="ActiveX-UI">controlKey: key command: command	^ self fvirt:  FCONTROL key: key command: command</body><body package="ActiveX-UI">fvirt: modifiers key: key command: command	^ self new		fVirt: modifiers;		key: key;		cmd: command;		yourself</body><body package="ActiveX-UI">key: key command: command	^ self fvirt:  0 key: key command: command</body><body package="ActiveX-UI">modifiers: modifiers key: key command: command	^ self new		modifiers: modifiers;		key: key;		command: command;		yourself</body><body package="ActiveX-UI">shiftKey: key command: command	^ self fvirt: FSHIFT key: key command: command</body></methods><methods><class-id>External.Accelerator class</class-id> <category>constants</category><body package="ActiveX-UI">modifierValueFor: aSymbol	^ self modifiers at: aSymbol asLowercase asSymbol ifAbsent: [ self error: (#UnknownModifier &lt;&lt; #com &gt;&gt; 'Unknown modifier') ].</body><body package="ActiveX-UI">modifiers	^ Modifiers ifNil: [ self initializeModifiers ]</body></methods><methods><class-id>External.Accelerator class</class-id> <category>initialize-release</category><body package="ActiveX-UI">initializeModifiers	^Modifiers := Dictionary new		at: #alt put: 16r10;		at: #control put: 16r08;		at: #shift put: 16r4;		yourself</body></methods><methods><class-id>External.Accelerator class</class-id> <category>instance creation</category><body package="ActiveX-UI">forChar: aChar	"self forChar: Character tab"	^ self forChar: aChar modifierFlags: 0</body><body package="ActiveX-UI">forChar: aChar modifierFlags: additionalFlags	"self forChar: Character tab modifierFlags: FSHIFT"	| code keyCode flags modifiers |	code := Win32UserDLL current VkKeyScan: aChar.	keyCode := code bitAnd: 255.	flags := code bitShift: -8.	modifiers := FVIRTKEY bitOr: additionalFlags.	flags ~= 0 ifTrue: [		(flags bitAnd: 1) ~= 0 ifTrue: [ modifiers := modifiers | FSHIFT ].		(flags bitAnd: 2) ~= 0 ifTrue: [ modifiers := modifiers | FCONTROL ].		(flags bitAnd: 4) ~= 0 ifTrue: [ modifiers := modifiers | FALT ] ].	^ self fvirt: modifiers key: keyCode command: 0.</body><body package="ActiveX-UI">fromPtr: lpAccel	^self 		fvirt: (lpAccel memberAt: #fVirt) 		key: (lpAccel memberAt: #key)  		command: (lpAccel memberAt: #cmd).</body><body package="ActiveX-UI">fromShortcutEvent: anEvent	| flags |	anEvent keyValue isSymbol ifTrue: [^ nil ].	flags := 0.	anEvent metaState ~= 0 ifTrue: [		(anEvent metaState bitAnd: InputState ctrlMask) ~= 0			ifTrue:  [ flags := FCONTROL ].		(anEvent metaState bitAnd: InputState altMask) ~= 0			ifTrue: [ flags := flags | FALT ].		(anEvent metaState bitAnd: InputState shiftMask) ~= 0			ifTrue: [ flags := flags | FSHIFT ] ].	^ self forChar: anEvent keyCharacter modifierFlags: flags.</body></methods><methods><class-id>UI.ActiveXControlController</class-id> <category>accessing</category><body package="ActiveX-UI">activate	"Give keyboard focus to the receiver."	self model value getWindow ifNotNil: [:window | window setFocus ].	super activate</body><body package="ActiveX-UI">deactivate	"Take away keyboard focus from the receiver."	self focusOut.	self view topComponent ifNotNil: [:window |  		Win32UserDLL current SetFocus: window windowHandle.		window forceActive ].	super deactivate.</body><body package="ActiveX-UI">oleControlSite	^ self view oleControlSite</body></methods><methods><class-id>UI.ActiveXControlController</class-id> <category>As yet unclassified</category><body package="ActiveX-UI">activatedByActiveX	"The widget was activated by the activeX Control, e.g. by a click on it"	super activate</body></methods><methods><class-id>UI.ActiveXControlController</class-id> <category>building</category><body package="ActiveX-UI">hookEventsFor: aBuilder	| window |	window := aBuilder window.	window 		when: #mapped send: #windowOpened to: self;		when: #closing send: #windowClosed to: self.</body></methods><methods><class-id>UI.ActiveXControlController</class-id> <category>events</category><body package="ActiveX-UI">windowClosed	^ self view removeFromWindow.</body><body package="ActiveX-UI">windowOpened	self view embedInWindow.</body></methods><methods><class-id>UI.ActiveXControlController</class-id> <category>event driven</category><body package="ActiveX-UI">desiresFocus	"Default desiresFocus to false. Controllers that want keyboard focus have to redefine this method."	^ model value ifNil: [ false ]	   ifNotNil: [:m | 			m isAllocated ifFalse: [ false ] ifTrue: [ m miscStatus actsLikeLabel not ] ]</body></methods><methods><class-id>External.COMDispatchPropertySpecification</class-id> <category>accessing</category><body package="ActiveX-UI">type	^ returnValueDescription type</body></methods><methods><class-id>UI.Menu</class-id> <category>menu items</category><body package="ActiveX-UI">menuItemsDo: aBlock	^self menuItems do: [:each | each menuItemsDo: aBlock ]</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>building</category><body package="ActiveX-UI">activeXControl: spec into: builder	| component model |	model := spec modelInBuilder: builder.	component := spec isDecorated				ifTrue: [self activeXControlClass model: model]				ifFalse: [self undecoratedActiveXControlClass model: model].	component isInDesignMode: builder isEditing.	component controller: self activeXControlControlerClass new.	component controller hookEventsFor: builder.	self setDispatcherOf: component fromSpec: spec builder: builder.	builder isEditing		ifFalse: 			["Wanted to use ActsLikeLabel Flag here - but the Microsoft StatusBarControl ripped the focus			 although having this flag set. Always providing the controller with a keyboardprocessor although we try to avoid			 passing the focus to it using tab"			component widgetState				isTabStop: (model value isAllocated and: 							[model value miscStatus invisibleAtRuntime not								and: [model value miscStatus requiresFocus]])].	component isEnabled: spec initiallyEnabled.	builder isEditing		ifFalse: 			[component widgetState isVisible: spec initiallyVisible.			spec installControlEventsIn: builder source For: model value].	builder component: component.	builder wrapWith: (self simpleWrapperFor: spec).	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body><body package="ActiveX-UI">activeXControlClass	^ ActiveXControlView</body><body package="ActiveX-UI">activeXControlControlerClass 	^ ActiveXControlController</body><body package="ActiveX-UI">undecoratedActiveXControlClass		^ self activeXControlClass</body></methods><methods><class-id>UI.MenuBar</class-id> <category>accessing</category><body package="ActiveX-UI">menuItemsDo: aBlock	self menuButtons do: [:each | each menuItemsDo: aBlock ].</body></methods><methods><class-id>UI.Win32WindowMessage</class-id> <category>dispatching</category><body package="ActiveX-UI">dispatchTo: anObject	| support msg pos |	support := OSSystemSupport concreteClass new.	msg := support MSG gcCalloc.	pos := msg refMemberAt: #pt.	msg memberAt: #hwnd put: self windowHandle.	msg memberAt: #message put: self messageID.	msg memberAt: #wParam put: self parameterW.	msg memberAt: #lParam put: self parameterL.	msg memberAt: #time put: self time.	pos memberAt: #x put: self position x.	pos memberAt: #y put: self position y.	(self processControlAccelerator: msg)		ifFalse: 			[support TranslateMessage: msg.			support DispatchMessage: msg]</body></methods><methods><class-id>UI.Win32WindowMessage</class-id> <category>private</category><body package="ActiveX-UI">processControlAccelerator: pMsg	| site control aWindow |	aWindow := ScheduledWindow currentWindow ifNil: [^false].	site := aWindow getActiveObjectSite ifNil: [^false].	control := site oleControl ifNil: [^false].	(control translateAccelerator: pMsg)		= External.COMStatusCodeConstants.S_OK ifTrue: [^true].	^false</body></methods><methods><class-id>UI.MenuBarButtonView</class-id> <category>privileged</category><body package="ActiveX-UI">menuItemsDo: aBlock	^ self menu menuItemsDo: aBlock</body></methods><methods><class-id>Graphics.GraphicsContext</class-id> <category>drawing</category><body package="ActiveX-UI">withDeviceContextDo: aBlockClosure	^medium withDeviceContextDo: aBlockClosure</body></methods><methods><class-id>UI.ApplicationWindowSensor</class-id> <category>event processing</category><body package="ActiveX-UI">eventKillFocus: event	^window ifNotNil: [ window preprocessEventKillFocus: (KillFocusEvent withArray: event) ].</body></methods><methods><class-id>Graphics.Window</class-id> <category>events</category><body package="ActiveX-UI">getActiveObjectSite	^ nil</body></methods><methods><class-id>Graphics.Window</class-id> <category>event configuring</category><body package="ActiveX-UI">preprocessEventKillFocus: event	"Preprocess the given KillFocus Event - don't need to do anything here. 	 Subclasses may react differently on the event"		^ self</body></methods><methods><class-id>Graphics.Window</class-id> <category>drawing</category><body package="ActiveX-UI">withDeviceContextDo: aBlockClosure	"Get the window's device context and pass it to the block"	| winGfxLib dc hwnd |	winGfxLib := WindowsGraphicsSupport new.	hwnd := self windowHandle.	dc := winGfxLib GetDC: hwnd.	[aBlockClosure value: dc] ensure: [winGfxLib ReleaseDC: hwnd with: dc]</body></methods><methods><class-id>Graphics.VisualPart</class-id> <category>testing</category><body package="ActiveX-UI">containsActiveXControl	^ false</body></methods><methods><class-id>UI.ScheduledWindow class</class-id> <category>accessing</category><body package="ActiveX-UI">propertiesForWindow: aWindow	^ WindowProperties at: aWindow ifAbsentPut: [ Dictionary new ]</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>accessing</category><body package="ActiveX-UI">basicOleContainer		^self windowProperties at: #oleContainer ifAbsent: nil</body><body package="ActiveX-UI">basicOleContainer: aContainer		self windowProperties at: #oleContainer put: aContainer.</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>events</category><body package="ActiveX-UI">getActiveObjectSite	^ self keyboardProcessor focusedView ifNotNil: [:view |			view containsActiveXControl 				ifTrue: [ view basicOleControlSite ]				ifFalse: [ nil ]].</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>event driven events</category><body package="ActiveX-UI">killFocusEvent: anEvent	| aController |	self basicOleContainer ifNotNil: [:container | 		(container checkControlSetFocus: anEvent) ifNotNil: [:control |			control oleControlSite ifNotNil: [:site |				site view  isInDesignMode ifFalse: [				aController := control oleControlSite view controller. 				aController keyboardProcessor focusedView: aController view.			 	aController activatedByActiveX.]]]]</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>accessing</category><body package="ActiveX-UI">oleContainer		^ self basicOleContainer ifNil: [			self oleContainer: ControlContainer new.			self basicOleContainer]</body><body package="ActiveX-UI">oleContainer: aContainer	self basicOleContainer = aContainer ifTrue: [ ^ self ].	self basicOleContainer ifNotNil: [:container | 		self basicOleContainer: nil.		container window: nil ].	self basicOleContainer: aContainer.	aContainer ifNotNil: [ aContainer window: self ].</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>events</category><body package="ActiveX-UI">pauseControls	"This happens at system startup - controls have to be reactivated because at image 	 shutdown all interfaces are released"	self basicOleContainer ifNotNil: [:container | container pause ]</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>event configuring</category><body package="ActiveX-UI">preprocessEventKillFocus: event	"Add the event to the event queue as usual. This is currently only done 	 for this Window class as otherwise it would cause problems with menus"		^sensor addMetaInput: event</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>events</category><body package="ActiveX-UI">reactivateControls	"This happens at system startup - controls have to be reactivated because at image 	 shutdown all interfaces are released"	self basicOleContainer ifNotNil: [:container | container reactivate ]</body></methods><methods><class-id>UI.ScheduledWindow</class-id> <category>accessing</category><body package="ActiveX-UI">windowProperties 	^ self class propertiesForWindow: self.</body></methods><methods><class-id>UI.WindowSensor</class-id> <category>event processing</category><body package="ActiveX-UI">eventKillFocus: event</body></methods><methods><class-id>UI.ValueHolder class</class-id> <category>instance creation</category><body package="ActiveX-UI">decodeFromLiteralArray: anArray	^ self with: (anArray at: 3)</body></methods><methods><class-id>UI.ValueHolder</class-id> <category>accessing</category><body package="ActiveX-UI">literalArrayEncoding	^ Array with: self class fullyQualifiedReference		with: #value:		with: value literalArrayEncoding</body></methods><methods><class-id>External.ControlProxy</class-id> <category>accessing</category><body package="ActiveX-UI">activationVerb	^self miscStatus canActivateInsideOut		ifTrue: [OLEIVERB_INPLACEACTIVATE]		ifFalse: [OLEIVERB_UIACTIVATE]</body></methods><methods><class-id>External.ControlProxy</class-id> <category>private</category><body package="ActiveX-UI">initializeShortcuts	^ shortcuts := AcceleratorTable fromControlStructure: self iOleControl getControlInfo.</body></methods><methods><class-id>External.ControlProxy</class-id> <category>events</category><body package="ActiveX-UI">onFocus: aBoolean		self triggerEvent: #onFocus with: aBoolean</body><body package="ActiveX-UI">pause	"The system has started up - need to reactivate"		self saveStateToStorage</body><body package="ActiveX-UI">reactivate	"The system has started up - need to reactivate"		"There were situations in which interfaces were not empty at startup - remove later"	self interfaces: Dictionary new.	flags := Flags new.	self		iOleObject:			(licenseKey				ifNil: [self createInstanceWithoutLicense]				ifNotNil: [self createInstanceWithLicense]).	self miscStatus setClientSiteFirst		ifFalse:  [self loadFromStorageOrInitNew	].		"MSDN said this flag means the control should be run when it is created"	self miscStatus alwaysRun ifTrue: [self run].	self privateSetSite.</body></methods><methods><class-id>External.ControlProxy</class-id> <category>persistence</category><body package="ActiveX-UI">saveStateToStorage		self storedProperties: (AbstractControlProperties newForControl: self propertieValues: self storedProperties cachedPropertyValues)</body></methods><methods><class-id>External.ControlProxy</class-id> <category>private accessing</category><body package="ActiveX-UI">supportsTranslateAccelerator	^ self propertyAt: #supportsTranslateAccelerator ifAbsent: [ nil]</body><body package="ActiveX-UI">supportsTranslateAccelerator: aBoolean	^ self propertyAt: #supportsTranslateAccelerator put: aBoolean</body></methods><methods><class-id>External.ControlProxy</class-id> <category>keyboard handling</category><body package="ActiveX-UI">translateAccelerator: pMsg	"If the control is not inplace-active don't call TranslateAccelerator()"	| interface callBlock |	self isInPlaceActive ifFalse: [^S_FALSE].	interface := self iOleInPlaceActiveObject ifNil: [^S_FALSE].	interface isValid ifFalse: [^S_FALSE].	callBlock :=			[[interface translateAccelerator: pMsg] on: COMError				do: [:ex | ex return: ex hresult]].	^self supportsTranslateAccelerator		ifNil: 			[| result |			result := callBlock value.			self supportsTranslateAccelerator: result succeeded.			result]		ifNotNil: [:supportsCall | supportsCall ifTrue: callBlock ifFalse: [E_NOTIMPL]]</body></methods><methods><class-id>UI.ApplicationModel</class-id> <category>events</category><body package="ActiveX-UI">controlEvent: selector arguments: arguments	"It appeared the the number of arguments did not match the number of arguments which where specified in the typelibary. So the method may 	 expect more or less arguments than provided. For being able to call the method anyway we might need to correct the argument number"		| keywords newArgs |	selector last = $: ifFalse: [^self perform: selector].	keywords := selector keywords.	keywords size = arguments size		ifTrue: [^self perform: selector withArguments: arguments].	newArgs := keywords size &gt; arguments size		ifTrue: [arguments copyWith: (Array new: keywords size - arguments size)]		ifFalse:			[arguments				copyFrom: 1				to: keywords size].	^self perform: selector withArguments: newArgs</body><body package="ActiveX-UI">pauseControls</body></methods><methods><class-id>External.ControlSite</class-id> <category>widget events</category><body package="ActiveX-UI">enterEvent: anEvent	self view activateOrView</body></methods><methods><class-id>Core.Association class</class-id> <category>instance creation</category><body package="ActiveX-UI">decodeFromLiteralArray: anArray	^ self key: (anArray at: 2) decodeAsLiteralArray value: (anArray at: 3) decodeAsLiteralArray</body></methods><methods><class-id>Core.Association</class-id> <category>accessing</category><body package="ActiveX-UI">literalArrayEncoding	^ Array with: self class fullyQualifiedReference with: self key literalArrayEncoding with: self value literalArrayEncoding</body></methods><methods><class-id>Graphics.GraphicsMedium</class-id> <category>drawing</category><body package="ActiveX-UI">withDeviceContextDo: aBlockClosure	"Don't know how to get the medium's Device Context.	 Do nothing"</body></methods><methods><class-id>UI.MenuItem</class-id> <category>accessing</category><body package="ActiveX-UI">addAcceleratorTo: anAcceleratorTable 	| modifiers flags |	self shortcutKeyCharacter ifNotNil: [:char |		modifiers := adornment shortcutModifiers.		flags := 0.		(modifiers bitAnd: InputState ctrlMask) ~= 0 ifTrue: [ flags := flags | External.Win32Constants.FCONTROL ].		(modifiers bitAnd: InputState altMask) ~= 0 ifTrue: [ flags := flags | External.Win32Constants.FALT ].		(modifiers bitAnd: InputState shiftMask) ~= 0 ifTrue: [ flags := flags | External.Win32Constants.FSHIFT ].		anAcceleratorTable add: (Accelerator  forChar: char modifierFlags: flags) ].</body><body package="ActiveX-UI">menuItemsDo: aBlock		aBlock value: self.	adornment		ifNotNil:			[adornment submenu ifNotNil: [:menu | menu menuItemsDo: aBlock]]</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>converting</category><body package="ActiveX-UI">asTemporaryCStructure	| rect |	rect := OSSystemSupport concreteClass new RECT gcMalloc.	self setValuesInRECT: rect.	^ rect.</body></methods><methods><class-id>UI.InputState</class-id> <category>private dispatching</category><body package="ActiveX-UI">send: aWindow eventKillFocus: event	^ aWindow isNil		ifTrue: [ self ]		ifFalse: [aWindow sensor eventKillFocus: event]</body></methods><methods><class-id>External.ControlContainer</class-id> <category>initialize-release</category><body package="ActiveX-UI">initializeAcceleratorTable 	acceleratorTable := AcceleratorTable new.	self window keyboardProcessor menuBar ifNotNil: [:bar |		 bar menuItemsDo: [:each | 			each addAcceleratorTo: acceleratorTable] ].	^ acceleratorTable 		add: (Accelerator forChar: Character tab modifierFlags: 0);		add: (Accelerator forChar: Character tab modifierFlags: FSHIFT);				yourself</body></methods><methods><class-id>External.ControlContainer</class-id> <category>events</category><body package="ActiveX-UI">pause	self iActiveObject: nil.	self ambientFont: nil.	self ambientProperties: nil.	sites do: [:site | site pause ].	self basicAcceleratorTable ifNotNil: [:table | table release ].</body><body package="ActiveX-UI">reactivate	super reactivate.	sites do: [:site | site reactivate ]</body></methods><methods><class-id>Graphics.Pixmap</class-id> <category>drawing</category><body package="ActiveX-UI">withDeviceContextDo: aBlockClosure	"Creates memory context compatible with the Screen and connects it to the bitmap to draw on it.	 Pass the memory dc to the block and make sure everything is released properly"	| hBitmap memDC winGfxLib oldGdiObject screenDC |	winGfxLib := WindowsGraphicsSupport new.	hBitmap := self handle hBitmap.	screenDC := winGfxLib GetDC: 0.	memDC := winGfxLib CreateCompatibleDC: screenDC.	oldGdiObject := winGfxLib SelectObject: memDC with: hBitmap.	[aBlockClosure value: memDC] ensure: 			[winGfxLib SelectObject: memDC with: oldGdiObject.			winGfxLib DeleteDC: memDC.			winGfxLib ReleaseDC: 0 with: screenDC]</body></methods><methods><class-id>UI.Controller</class-id> <category>events</category><body package="ActiveX-UI">killFocusEvent: anEvent</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>VisualPart</name><environment>Graphics</environment><super>Graphics.VisualComponent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>container eventHandlers properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Visual Objects</category><attributes><package>Graphics-Visual Objects</package></attributes></class><class><name>SimpleView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>GraphicsContext</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>medium clipOriginX clipOriginY clipWidth clipHeight lineWidth capStyle joinStyle deviceFont devicePaint offsetX offsetY phaseX phaseY scaleX scaleY font paint paintPolicy fontPolicy clientData paintPreferences </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>ControlContainer</name><environment>External</environment><super>External.MultipleInterfaceDispatchObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window acceleratorTable iActiveObject sites ambientFont ambientProperties </inst-vars><class-inst-vars></class-inst-vars><imports>			OLEAutomationConstants.*			private External.Win32Constants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><class><name>GraphicsMedium</name><environment>Graphics</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Support</category><attributes><package>Graphics-Support</package></attributes></class><class><name>Pixmap</name><environment>Graphics</environment><super>Graphics.UnmappableSurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>Controller</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model view </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>Window</name><environment>Graphics</environment><super>Graphics.DisplaySurface</super><private>false</private><indexed-type>none</indexed-type><inst-vars>inputOrigin creationOrigin sensor iconic windowType effectiveWindowType statusLineHeight allowsStatusLine mapped eventHandlers windowManager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>Association</name><environment>Core</environment><super>Core.LookupKey</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Menu</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>items groupSizes adornment selectionMemory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>MenuBar</name><environment>UI</environment><super>Graphics.CompositePart</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuChannel performer menuButtons nextMenuButton artist menuActivation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>COMDispatchPropertySpecification</name><environment>External</environment><super>External.GeneralPropertySpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessMode memberID vtableIndex returnValueDescription flags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>Win32WindowMessage</name><environment>UI</environment><super>UI.WindowMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameterW parameterL position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Window Messages</package></attributes></class><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ControlProxy</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>progId clsid oleControlSite interfaces dispatchDriver miscStatus flags licenseKey shortcuts properties storedProperties </inst-vars><class-inst-vars></class-inst-vars><imports>			OLEAutomationConstants.*			private External.COMConstants.*			private External.COMAutomationConstants.*			private External.COMStatusCodeConstants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><class><name>SelectController</name><environment>UI</environment><super>UI.Controller</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardHook dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>InputState</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y bitState shiftState ctrlState commandKeyState metaState metaKeyState altKeyState lastClickTimestamp eventDispatcher lastDownPoint lastUpPoint lastUpButton lastWindow keyCaptureBlock isMouseHidden enforceNativeGrabbing </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>ControlSite</name><environment>External</environment><super>External.MultipleInterfaceDispatchObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>view oleContainer oleControl flags eventManager </inst-vars><class-inst-vars></class-inst-vars><imports>			OLEAutomationConstants.*			private External.COMConstants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>MenuBarButtonView</name><environment>UI</environment><super>UI.PushButtonView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessCharacterPosition flyingOver menuHolder menuBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class><class><name>WindowSensor</name><environment>UI</environment><super>UI.InputSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboard metaInput damage damageLock invalidationSuppressed skipNextDamage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Window System</category><attributes><package>OS-Window System</package></attributes></class><class><name>MenuItem</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabled visible label adornment nameKey value position helpText command </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Menus</category><attributes><package>Interface-Menus</package></attributes></class><class><name>ApplicationWindowSensor</name><environment>UI</environment><super>UI.WindowSensor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>WindowEvent</name><environment>UI</environment><super>UI.Event</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Events</category><attributes><package>Interface-Events</package></attributes></class><class><name>WidgetSpec</name><environment>UI</environment><super>UI.NamedSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>model callbacksSpec tabable helpText helpField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class></st-source>