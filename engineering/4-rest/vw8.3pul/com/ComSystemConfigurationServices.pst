<?xml version="1.0"?><st-source><!-- Name: Com- System Configuration ServicesNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This parcel contains image configuration code.DbIdentifier: bear73DbTrace: 432765DbUsername: aaugustinDbVersion: 8.0 - 5DevelopmentPrerequisites: #(#(#any 'Com- CodeAnnotations' ''))DialectVersion: VisualWorks 7.9IsFunctional: truePackageName: Com- System Configuration ServicesParcel: #('ComSystemConfigurationServices')ParcelName: Com- System Configuration ServicesPrerequisiteParcels: #(#('Com- CodeAnnotations' ''))PrintStringCache: (8.0 - 5,aaugustin)Version: 8.0 - 5Date: 1:50:01 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:01</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>WeakRegistry</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ephemerons action </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Configuration Services</category><attributes><package>Com- System Configuration Services</package></attributes></class><comment><class-id>Core.WeakRegistry</class-id><body>A WeakRegistry is a concrete class that is used to keep track of a collection of objects to be finalized (notified in some way when about to be garbage collected).</body></comment><class><name>WeakKeyedRegistry</name><environment>Core</environment><super>Core.WeakRegistry</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Configuration Services</category><attributes><package>Com- System Configuration Services</package></attributes></class><comment><class-id>Core.WeakKeyedRegistry</class-id><body>WeakKeyedRegistry is a dictionary containing collections of keys and values in which the key is a weak reference. The action for the collection is executed after the rescue of each weak key.  It provides a  mechanism to associate an extension with a particular object.</body></comment><class><name>WeakKeyedStrongValueRegistry</name><environment>Core</environment><super>Core.WeakKeyedRegistry</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- System Configuration Services</package></attributes></class><class><name>COMSystem</name><environment>External</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>deferredActions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- System Configuration Services</package></attributes></class><class><name>HostInterface</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>platform </class-inst-vars><imports></imports><category>System-Configuration Services</category><attributes><package>Com- System Configuration Services</package></attributes></class><comment><class-id>Kernel.HostInterface</class-id><body>The HostInterface class provides common protocol for accessing attributes of the host platform.</body></comment><class><name>SystemValue</name><environment>External</environment><super>UI.BlockValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>previousValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- System Configuration Services</package></attributes></class><class><name>EphemeronIdentityDictionary</name><environment>Core</environment><super>Core.EphemeronDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- System Configuration Services</package></attributes></class><class><name>ImageConfiguration</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Configuration Services</category><attributes><package>Com- System Configuration Services</package></attributes></class><comment><class-id>Kernel.ImageConfiguration</class-id><body>The ImageConfiguration class represents the configuration of the image, notably whether the image is a development configuration or a deployment image. The command line arguments for this invocation of the image are also part of the public protocol.By default, an image is considered to be a development image.  When you prepare a deployment image, you can install the runtime image configuration setting by evaluating the expression:	ImageConfiguration isDevelopment: false.To test whether the image is configured as a development image or a deployment image, evaluate the expression:	ImageConfiguration isDevelopment</body></comment><class><name>WeakKeyedDictionary</name><environment>Core</environment><super>Core.EphemeronDictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueProtectionArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- System Configuration Services</package></attributes></class><class><name>SystemExternalResourcesRegistry</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>registry allowImageSaveIfNotEmpty </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Configuration Services</category><attributes><package>Com- System Configuration Services</package></attributes></class><comment><class-id>External.SystemExternalResourcesRegistry</class-id><body>The SystemExternalResourcesRegistry provides a global registry for tracking external resources owned by the session.</body></comment><class><name>SystemValueRegistry</name><environment>OS</environment><super>OS.OSHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- System Configuration Services</package></attributes></class><comment><class-id>OS.SystemValueRegistry</class-id><body>This class manages system values which need to be reseted each startup to ensure they do not contain old values.Instead of leaving the responsibility to recompute these values to the diverse classes, we do this centralized.</body></comment><class><name>SystemGlobalRegistries</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Configuration Services</category><attributes><package>Com- System Configuration Services</package></attributes></class><comment><class-id>External.SystemGlobalRegistries</class-id><body>SystemGlobalRegistries is a global registry for registering objects that need to be finalized or notified, when another object is finalized. I added a new class and did not use SytemGlobalRegistries to 1. not every object may understand #aboutToSaveImage, #shutdownImage, #startupImage etc, which is send by SystemGlobalRegistries    except these methods are added to Object.2. avoid other possible sideeffects ... whatever these may be ... in case I did oversee somethingI don't expect registered objects to be valid after system restart - so they all will be finalized on shutdown and removed fromthe registry on startup since I will not be notified whether we will leave the image on #aboutToSnapShot.</body></comment><class><name>EarlyCOMSystem</name><environment>External</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- System Configuration Services</package></attributes></class><shared-variable><name>COMClassesToInform</name><environment>External.COMSystem</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><shared-variable><name>ErrorLogPath</name><environment>Kernel.ImageConfiguration</environment><private>false</private><constant>false</constant><category>COM image attributes</category><initializer>'error.log'</initializer><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><shared-variable><name>StartUpActionCache</name><environment>Kernel.ImageConfiguration</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><shared-variable><name>LogErrorsToFile</name><environment>Kernel.ImageConfiguration</environment><private>false</private><constant>false</constant><category>COM image attributes</category><initializer>true</initializer><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><shared-variable><name>ErrorNotifierClass</name><environment>Kernel.ImageConfiguration</environment><private>false</private><constant>false</constant><category>COM image attributes</category><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><shared-variable><name>Notifier</name><environment>External.SystemGlobalRegistries</environment><private>false</private><constant>false</constant><category>finalization</category><initializer></initializer><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><shared-variable><name>Finalizer</name><environment>External.SystemGlobalRegistries</environment><private>false</private><constant>false</constant><category>finalization</category><initializer></initializer><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><shared-variable><name>GCProtectionRegistry</name><environment>External.SystemGlobalRegistries</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><shared-variable><name>ImageManager</name><environment>Kernel</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>COMSystem current</initializer><attributes><package>Com- System Configuration Services</package></attributes></shared-variable><methods><class-id>Core.WeakRegistry</class-id> <category>registering</category><body package="Com- System Configuration Services">add: anObject    "Add &lt;anObject&gt; to the receiver."    [ self ephemerons at: anObject put: nil ]        "evaluateWithoutInterrupts" valueUninterruptably.	^anObject</body><body package="Com- System Configuration Services">remove: anObject    "Remove &lt;anObject&gt; from the registry."    ^self remove: anObject ifAbsent: []</body><body package="Com- System Configuration Services">remove: anObject ifAbsent: aBlock    "Remove &lt;anObject&gt; from the registry."    ^[ self ephemerons removeKey: anObject ifAbsent: aBlock ]        "evaluateWithoutInterrupts" valueUninterruptably.</body></methods><methods><class-id>Core.WeakRegistry</class-id> <category>private-accessing</category><body package="Com- System Configuration Services">actionArg: anEphemeron	"Private - Answer the argument to the receiver's action."		^anEphemeron key</body><body package="Com- System Configuration Services">ephemerons    "Private - answer the EphemeronDictionary."    ^ephemerons</body><body package="Com- System Configuration Services">mournKeyOf: anEphemeron	^ self rescue: anEphemeron</body><body package="Com- System Configuration Services">removeAll	(ephemerons isNil) ifFalse: [		ephemerons manager: ephemerons ]. "prevent it from informing us about demises"	(ephemerons := EphemeronIdentityDictionary new) manager: self.</body><body package="Com- System Configuration Services">rescueAll	self ephemerons associationsDo: [:anEphemeron |		self rescue: anEphemeron ].</body></methods><methods><class-id>Core.WeakRegistry</class-id> <category>accessing</category><body package="Com- System Configuration Services">action    "Answer the action that is evaluated when an object managed by the receiver is finalized."    ^action</body><body package="Com- System Configuration Services">action: anEvaluableAction    "Set the action that is evaluated when an object managed by the receiver is finalized.	The action takes one argument which for a WeakRegistry is the object being finalized	and for a WeakKeyedRegistry is an Association where the key is the object being	finalized."    action := anEvaluableAction</body><body package="Com- System Configuration Services">size        "Answer the number of elements contained in the receiver."    ^self ephemerons size</body><body package="Com- System Configuration Services">weakObjects	"Return the objects that are weakly referenced by this registry."	^self ephemerons keys</body></methods><methods><class-id>Core.WeakRegistry</class-id> <category>converting</category><body package="Com- System Configuration Services">asSet	" Answer a set containing the objects in the registry. "	^self ephemerons keys</body></methods><methods><class-id>Core.WeakRegistry</class-id> <category>testing</category><body package="Com- System Configuration Services">includes: anObject    "Answer true if the receiver includes &lt;anObject&gt;, else false."    ^self ephemerons includesKey: anObject</body><body package="Com- System Configuration Services">isEmpty        "Answer whether the receiver contains no elements."    ^self ephemerons isEmpty</body><body package="Com- System Configuration Services">notEmpty        "Answer whether the receiver contains one or more elements."    ^self ephemerons notEmpty</body></methods><methods><class-id>Core.WeakRegistry</class-id> <category>private-testing</category><body package="Com- System Configuration Services">mayBeFinalized: anObject    "Private - Answer true if &lt;anObject&gt; is finalizable."	"ISSUE: Following is porting patch which needs to be reviewed [DL 27-Dec-95] "    "anObject isSmallInteger" ( anObject isKindOf: SmallInteger )        ifTrue: [ ^false ].	"anObject isCharacter" ( anObject isKindOf: Character )		ifTrue: [^false].    ( nil == anObject or: [ true == anObject or: [ false == anObject ] ] )        ifTrue: [ ^false].    ^true</body></methods><methods><class-id>Core.WeakRegistry</class-id> <category>enumerating</category><body package="Com- System Configuration Services">do: aBlock    "Evaluate &lt;aBlock&gt; with each object of the receiver as its argument."    [ self ephemerons keysDo: aBlock ]        "evaluateWithoutInterrupts" valueUninterruptably.</body></methods><methods><class-id>Core.WeakRegistry</class-id> <category>private-initialization</category><body package="Com- System Configuration Services">initialize    "Private - Initialize the receiver."    "super initialize.""###ISSUE: What's the correct way to do this on VW? [DL 27-Dec-95] ###"    "(ephemerons := EphemeronIdentityDictionary new) manager: self"	(ephemerons := EphemeronIdentityDictionary new)  manager: self.</body><body package="Com- System Configuration Services">rescue: anEphemeron    "Private - The object that is the key of &lt;anEphemeron&gt; is no longer referenced.  Remove it from the registry and evaluate its action (which may cause it to be added again)."    | object evaluableAction args |    object := anEphemeron key.    args := Array with: ( self actionArg: anEphemeron ).    "extension := anEphemeron value."    self remove: object.    evaluableAction := self action.    evaluableAction == nil ifTrue: [^self].    evaluableAction evaluateWithArguments: args.    "evaluableAction isContext        ifTrue:            [args at: 1 put: nil.            evaluableAction evaluateWithArguments: args]."    args := nil</body></methods><methods><class-id>Core.WeakRegistry class</class-id> <category>instance creation</category><body package="Com- System Configuration Services">new    "Answer a new instance of the receiver."    ^super new initialize</body><body package="Com- System Configuration Services">newFinalizationRegistry    "Answer a new instance of the receiver which will send the #finalize message when an object in the registry is no longer referenced and is about to be destroyed."	Tools.Note ISSUE; needsWork.  "notYetImplemented..."  " I need some additional mechanism 		and perhaps an inst var to back this up with an actual implementation		on top of VW 2.5. [DL 09-May-97] "	^self new action: [ :object | object finalize ]</body></methods><methods><class-id>Core.WeakKeyedRegistry</class-id> <category>accessing</category><body package="Com- System Configuration Services">at: anObject ifAbsent: aBlock    "Answer the value associated with &lt;anObject&gt; if one exists, otherwise answer the value of &lt;aBlock&gt;."    ^[ self ephemerons at: anObject ifAbsent: aBlock ]        "evaluateWithoutInterrupts" valueUninterruptably.</body><body package="Com- System Configuration Services">at: anObject ifAbsentPut: aBlock    "Answer an value associated with &lt;anObject&gt;. If not found, add &lt;anObject&gt;	whose value is given by the result of evaluating &lt;aBlock&gt;."    ^ [ self ephemerons at: anObject ifAbsentPut: aBlock ]  valueUninterruptably.</body><body package="Com- System Configuration Services">at: anObject put: aValue    "Add &lt;anObject&gt; to the receiver."    ^[ self ephemerons at: anObject put: aValue ]        "evaluateWithoutInterrupts" valueUninterruptably.</body><body package="Com- System Configuration Services">keys	" Answer a set containing the receiver's keys.  This is the set of registered objects in the keyed registry. "	^self ephemerons keys</body><body package="Com- System Configuration Services">removeKey: anObject ifAbsent: aBlock    "Remove &lt;anObject&gt; from the registry if it exists, otherwise evaluate &lt;aBlock&gt;."    ^self remove: anObject ifAbsent: aBlock</body><body package="Com- System Configuration Services">values	" Answer a collection containing the values associated with the registered objects in the registry. "	^self ephemerons values</body></methods><methods><class-id>Core.WeakKeyedRegistry</class-id> <category>private-accessing</category><body package="Com- System Configuration Services">actionArg: anEphemeron	"Private - Answer the argument to the receiver's action."		^anEphemeron</body></methods><methods><class-id>Core.WeakKeyedRegistry</class-id> <category>enumerating</category><body package="Com- System Configuration Services">associationsDo: aBlock    "Evaluate &lt;aBlock&gt; with each association of the receiver as its argument."    [ self ephemerons associationsDo: aBlock ]        "evaluateWithoutInterrupts" valueUninterruptably.</body></methods><methods><class-id>Core.WeakKeyedRegistry</class-id> <category>converting</category><body package="Com- System Configuration Services">asSet	" Answer a set containing the objects in the registry. "	Tools.Note notYetImplemented.	Tools.Note ISSUE.  " Need to resolve the potentially different semantics		between VSE and the proposed Jigsaw Sep96.2 rework of		WeakKeyedRegistry, wherein the latter really wants to be		a dictionary but the former was more registry-ish		in its viewpoint.  [DL 23-Sep-96] "	"^self ephemerons keys"</body></methods><methods><class-id>External.COMSystem</class-id> <category>session management</category><body package="Com- System Configuration Services">earlySystemInstallation	" before window system installed "	(HostInterface isWindows or: [HostInterface isWindowsNT]) ifFalse: [ ^ self ].	self triggerEvent: #coreStartupCompleted.</body><body package="Com- System Configuration Services">pauseAction	super pauseAction.	"ImageManager"	" clients can veto the confirmation event if they do not want the save operation to proceed "	" the timing of the following isn't quite right, but it's the best we can do				without going into ObjectMemory and doing this hookup right "	self triggerEvent: #confirmSave.	" clients can veto the confirmation event if they do not want the save operation to proceed "	" the timing of the following isn't quite right, but it's the best we can do				without going into ObjectMemory and doing this hookup right "	self triggerEvent: #aboutToSave.	self triggerEvent: #pause.</body><body package="Com- System Configuration Services">resumeAction	super resumeAction.		"ImageManager"	self triggerEvent: #saveCompleted.	 Snapshot isAboutToQuit 		ifTrue: [ self triggerEvent: #quitAfterSnapShot ]		ifFalse: [ self triggerEvent: #resume ].</body><body package="Com- System Configuration Services">setUp	super setUp.	"ImageManager"	"no exact VW equivalent of the desired #startup event "	self performDeferredActions.	self triggerEvent: #startupCompleted.	ImageConfiguration isDevelopment		ifTrue: [self triggerEvent: #developmentStartup]		ifFalse: [self triggerEvent: #deploymentStartup].	self triggerEvent: #setUp.</body><body package="Com- System Configuration Services">shutdown	"Shutdown and exit the image."	"	[ self triggerEvent: #confirmShutdown ] 		on: VetoAction 		do: [ :ex | ^self error: 'Image shutdown aborted' ].	"	ObjectMemory quit.</body><body package="Com- System Configuration Services">tearDown	super tearDown.	"ImageManager"	self triggerEvent: #shutdown.	self triggerEvent: #tearDown.</body></methods><methods><class-id>External.COMSystem</class-id> <category>private accessing</category><body package="Com- System Configuration Services">deferredActions	^deferredActions ifNil: [ deferredActions := OrderedCollection new ].</body><body package="Com- System Configuration Services">deferredActions: anObject	deferredActions := anObject</body></methods><methods><class-id>External.COMSystem</class-id> <category>tools</category><body package="Com- System Configuration Services">performDeferredActions	[self deferredActions do: [:each | each value]]		ensure: [self deferredActions: nil]</body><body package="Com- System Configuration Services">whenActiveDo: aBlock	self isActive		ifTrue: [aBlock value]		ifFalse: [self deferredActions add: aBlock]</body></methods><methods><class-id>External.COMSystem</class-id> <category>prerequisites</category><body package="Com- System Configuration Services">prerequisiteSystems	^ Array with: InterestNotificationSystem with: EarlyCOMSystem</body></methods><methods><class-id>External.COMSystem class</class-id> <category>ImageManager</category><body package="Com- System Configuration Services">constructEventsTriggered	"Private - answer all the events which can be triggered by instances of the receiver. "	^super constructEventsTriggered 	" image startup "		add: #coreStartupCompleted ;		add: #startupCompleted ;		add: #developmentStartup ;		add: #deploymentStartup ;	" image save "		add: #confirmSave ;  " this is a vetoable confirmation event "		add: #aboutToSave ;		"Not supported on VW 2.5: add: #save:; "  " (no suitable way to hook into current ObjectMemory implementation) "		add: #saveCompleted ;	" image shutdown "		"add: #confirmShutdown ;"		add: #shutdown ;		add: #setUp;		add: #tearDown;		add: #pause;		add: #resume;		yourself</body></methods><methods><class-id>Kernel.HostInterface class</class-id> <category>platform identification</category><body package="Com- System Configuration Services">isAlphaNT	"Answer true if the current OS is WindowsNT on a DEC Alpha."	^self platform == #alpha_nt</body><body package="Com- System Configuration Services">isAlphaUNIX	"Answer true if the current OS is AlphaUnix."	^self platform == #alpha_unix</body><body package="Com- System Configuration Services">isOS2	"Answer true if the current OS is OS/2."	^self platform == #os2</body><body package="Com- System Configuration Services">isSolaris	"Answer true if the current OS is Solaris."	^self platform == #solaris</body><body package="Com- System Configuration Services">isWin32	"Answer true if the current OS is any kind of 32-bit Microsoft Windows."	"^OSHandle currentOS = #win32"	^self isWin32s or: [ self isWindows95 or: [ self isWindowsNT ] ]</body><body package="Com- System Configuration Services">isWin32s	"Answer true if the current OS is Win32s."	"^OSHandle currentPlatformID asArrayOfSubstrings last = 'win32s'"	^self platform == #win32s</body><body package="Com- System Configuration Services">isWindows	"Answer true if the current OS is Microsoft Windows (not NT)."	^self isWin32s or: [ self isWindows95 ]</body><body package="Com- System Configuration Services">isWindows95	"Answer true if the current OS is Windows95."	^self platform == #win95</body><body package="Com- System Configuration Services">isWindowsNT	"Answer true if the current OS is WindowsNT."	^self platform == #nt or: [ self isAlphaNT ]</body></methods><methods><class-id>Kernel.HostInterface class</class-id> <category>accessing</category><body package="Com- System Configuration Services">currentOS	"Answer a symbol identifying the current operating system"	" HostInterface currentOS "	^OSHandle currentOS</body><body package="Com- System Configuration Services">currentPlatformID	"Answer a string identifying the current operating system environment"	" HostInterface currentPlatformID "	^OSHandle currentPlatformID</body></methods><methods><class-id>Kernel.HostInterface class</class-id> <category>environment variables</category><body package="Com- System Configuration Services">getEnvironmentVariable: varName 	"Get an environment variable's value from the OS. This has different 	meanings on different platforms. On Windows NT and Windows 95, 	environment variables are in the registry. On Windows 3.1, they are 	in a VISWORKS.INI file. On Unix, the shell environment variables are 	used. 		If the variable does not exist in the environment, answer the empty 	string."	" HostInterface getEnvironmentVariable: 'PATH' "	^CEnvironment getenv: varName</body></methods><methods><class-id>Kernel.HostInterface class</class-id> <category>private-session management</category><body package="Com- System Configuration Services">determinePlatformType	"Private - Answer a symbol representing the current platform type."	| platformSymbol platformIDString stream peekChar |	platformIDString := OSHandle currentPlatformID.	platformSymbol := OSHandle currentOS.	#unix == platformSymbol ifTrue: [		stream := platformIDString readStream.		stream skipThrough: Character space.		('osf*' match: (stream through: Character space))			ifTrue: [^#alpha_unix ].		stream atEnd ifFalse: [			('hp*' match: (stream through: Character space))				ifTrue: [^#hppa ].			stream atEnd				ifFalse: [('solaris*' match: (stream through: Character space))				ifTrue: [^#solaris ]]].		^#unix].	#os2 == platformSymbol		ifTrue: [ ^#os2 ].	#win32 == platformSymbol ifTrue: [		stream := platformIDString readStream.		stream			skipThrough: Character space;			skipThrough: Character space.		(peekChar := stream peek ) == $w			ifTrue: [^#win32s ].		 (peekChar == $n) ifTrue: [			stream skipThrough: Character space.			stream atEnd ifFalse: [				('AXP*' match: (stream through: Character space))					ifTrue: [^#alpha_nt ]].			     ^#nt].		 (peekChar == $9)			ifTrue: [^#win95 ] ].	#mac == platformSymbol ifTrue: [		stream := platformIDString readStream.		stream			skipThrough: Character space;			skipThrough: Character space;			skipThrough: Character space.		^stream peek == $P			ifTrue: [ #powermac ]			ifFalse: [ #mac ] ].	^#unknown</body><body package="Com- System Configuration Services">platform	"Private - Answer a symbol which represents the current platform."	^platform value</body></methods><methods><class-id>Kernel.HostInterface class</class-id> <category>private-installation</category><body package="Com- System Configuration Services">initialize	" HostInterface initialize "	platform := SystemValue with: [ self determinePlatformType ].</body><body package="Com- System Configuration Services">obsolete	"The receiver was removed from the system and is now obsolete. Perform any necessary clean-up. Answer the receiver."	platform := nil.	^super obsolete</body></methods><methods><class-id>External.SystemValue</class-id> <category>initialize-release</category><body package="Com- System Configuration Services">initialize	"Initialize the receiver's instance variables."	super initialize.	eagerEvaluation := false.</body><body package="Com- System Configuration Services">startupSystem	previousValue := cachedValue.	self resetValue.</body></methods><methods><class-id>External.SystemValue</class-id> <category>accessing</category><body package="Com- System Configuration Services">eagerEvaluation: aBoolean 	"We don't allow this setting this here as system values may depend on others which have not been reseted.	 So their value should be computed when it is used not at system startup"	^ self shouldNotImplement</body><body package="Com- System Configuration Services">setValue: newValue	self shouldNotImplement</body></methods><methods><class-id>External.SystemValue</class-id> <category>testing</category><body package="Com- System Configuration Services">hasChanged	^ self value ~= previousValue</body></methods><methods><class-id>Core.EphemeronIdentityDictionary</class-id> <category>private</category><body package="Com- System Configuration Services">findKeyOrNil: key  	"Override to lookup by identity."	| index limit probe initialIndex |	limit := self basicSize.	index := initialIndex := self initialIndexFor: key identityHash boundedBy: limit.	[(probe := self basicAt: index) == nil or: [probe key == key]]		whileFalse: 			[(index := index + 1) &gt; limit ifTrue: 				[limit &lt; initialIndex ifTrue: [^self grow findKeyOrNil: key].				index := 1.				limit := initialIndex - 1]].	^index</body></methods><methods><class-id>Core.EphemeronIdentityDictionary</class-id> <category>accessing</category><body package="Com- System Configuration Services">keys	"Answer a set containing the receiver's keys."	| aSet |	aSet := IdentitySet new: self size * 3 // 2.	self keysDo: [:key | aSet add: key].	^aSet</body></methods><methods><class-id>Kernel.ImageConfiguration class</class-id> <category>command line</category><body package="Com- System Configuration Services">commandLine	"Answer the command that started up the system.	On the Mac, this answers the file names that were selected	in the finder at startup time."	" ImageConfiguration commandLine "	^CEnvironment commandLine</body></methods><methods><class-id>Kernel.ImageConfiguration class</class-id> <category>accessing</category><body package="Com- System Configuration Services">defaultErrorNotifierClass	^#{RuntimeManager} ifDefinedDo: [:manager | manager errorNotifierClass]				elseDo: #{COMErrorReporter}</body><body package="Com- System Configuration Services">errorLogPath	^ErrorLogPath</body><body package="Com- System Configuration Services">errorLogPath: aStringOrNil	ErrorLogPath := aStringOrNil.</body><body package="Com- System Configuration Services">errorNotifierClass	^ErrorNotifierClass ifNil: [self defaultErrorNotifierClass]</body><body package="Com- System Configuration Services">errorNotifierClass: aClassOrNil	ErrorNotifierClass := aClassOrNil</body><body package="Com- System Configuration Services">logToFile	"Answer the whether or not to write errors to a file."	^LogErrorsToFile = true</body><body package="Com- System Configuration Services">logToFile: aBoolean	"Set the whether or not to write errors to a file."	LogErrorsToFile := aBoolean</body></methods><methods><class-id>Kernel.ImageConfiguration class</class-id> <category>class initialization</category><body package="Com- System Configuration Services">initialize	"ImageConfiguration initialize"	self isDevelopment: #{NotifierView} isDefined</body></methods><methods><class-id>Kernel.ImageConfiguration class</class-id> <category>runtime packaging</category><body package="Com- System Configuration Services">installDeploymentStartupAction	"Restore the real startup handlers for the deployment image."	(ImageConfiguration isDevelopment not	and: [StartUpActionCache notNil]) ifTrue: 		[COMSystem current 			when: #deploymentStartup 			evaluate: StartUpActionCache.		StartUpActionCache := nil]</body><body package="Com- System Configuration Services">recordDeploymentStartupAction	"Stash the real startup handlers for the deployment image on the side.  This is used by the RuntimePackager to	 assist in creating a com server runtime image.  If you are creating a image that is not a com server, then you	 can just use the runtime package as is, i.e. without the comserver.rtp parameters file which configures the	 RuntimePackager to use this method."	ImageConfiguration isDevelopment ifFalse: 		[StartUpActionCache := COMSystem current actionForEvent: #deploymentStartup.		COMSystem current removeActionsForEvent: #deploymentStartup.			#{RuntimePackager.RuntimeManager} 			ifDefinedDo: [:runtimeManager | runtimeManager postStripBlock: [ImageConfiguration installDeploymentStartupAction]]			elseDo: [nil]].</body></methods><methods><class-id>Kernel.ImageConfiguration class</class-id> <category>configuring</category><body package="Com- System Configuration Services">isDevelopment: aBoolean	" Specify whether this is a development image. "	" ImageConfiguration isDevelopment: true "	" ImageConfiguration isDevelopment: false "	DeploymentOptionsSystem current 		isDevelopment: aBoolean;		startInRuntime: aBoolean not.</body></methods><methods><class-id>Kernel.ImageConfiguration class</class-id> <category>testing</category><body package="Com- System Configuration Services">isDevelopment	" Answer whether this is a development image. "	" ImageConfiguration isDevelopment "	^DeploymentOptionsSystem isDevelopment</body></methods><methods><class-id>Core.WeakKeyedDictionary</class-id> <category>accessing</category><body package="Com- System Configuration Services">at: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	^ self evaluateWithFullProtection: [ self privateAt: key put: anObject ].</body><body package="Com- System Configuration Services">basicAt: index put: value	super basicAt: index put: value.	valueProtectionArray at: index put: value value.</body><body package="Com- System Configuration Services">initValueProtectionArray	valueProtectionArray := Array new: self capacity.</body><body package="Com- System Configuration Services">privateAt: key put: anObject 	"Set the value at key to be anObject.  If key is not found, create a new	entry for key and set is value to anObject. Answer anObject."	| index element |	key == nil ifTrue: [^self subscriptBoundsErrorFor: #at:put: index: nil value: anObject].	index := self findKeyOrNil: key.	element := self basicAt: index.	element == nil		ifTrue: [self atNewIndex: index put: (self createKey: key value: anObject)]		ifFalse: [element value: anObject. valueProtectionArray at: index put: anObject].	^anObject</body></methods><methods><class-id>Core.WeakKeyedDictionary class</class-id> <category>instance creation</category><body package="Com- System Configuration Services">new: size	^ (super new: size)		initValueProtectionArray;		yourself.</body></methods><methods><class-id>External.SystemExternalResourcesRegistry</class-id> <category>private-session management</category><body package="Com- System Configuration Services">aboutToSaveImage	"Private - Process the externalResources registry.	This should be preceded by a gc compact."	self registry weakObjects do: [ :object | object aboutToSaveImage ]</body><body package="Com- System Configuration Services">confirmSaveImage	" Private - the image is about to be saved.  Veto the image save if it should not be allowed to proceed for any reason. "	ObjectMemory globalGarbageCollect.	(ImageConfiguration isDevelopment		and: [self allowImageSaveIfNotEmpty not and: [self registry notEmpty]])			ifTrue: 				[#{External.COMDevelopmentWarning} ifDefinedDo: 						[:logger |						logger log: #ExternalResourcesInUse &lt;&lt; #com									&gt;&gt; 'External resources are still in use by this session.  They will be released at image exit and cannot be restored when this saved image is restarted. ']]</body><body package="Com- System Configuration Services">shutdownImage	"Private - Process the externalResources registry.	This should be preceded by a gc compact."	self registry weakObjects do: [ :object | object shutdownImage ]</body><body package="Com- System Configuration Services">startupImage	"Private - Process the externalResources registry.	This should be preceded by a gc compact."	self registry weakObjects do: [ :object | object startupImage ].</body></methods><methods><class-id>External.SystemExternalResourcesRegistry</class-id> <category>accessing</category><body package="Com- System Configuration Services">allowImageSaveIfNotEmpty	" Answer whether image save should be allowed in a development configuration if the receiver contains resources. "	^allowImageSaveIfNotEmpty</body><body package="Com- System Configuration Services">allowImageSaveIfNotEmpty: aBoolean	" Specify whether image save should be allowed in a development configuration if the receiver contains resources.  This is useful to disallow when the external resources registry only contains 'unusual' resources whose presence at image save would indicate an application resource leak that should be reported to the developer. "	allowImageSaveIfNotEmpty := aBoolean.</body><body package="Com- System Configuration Services">registry	"Return the weak registry for external resources."	^registry</body></methods><methods><class-id>External.SystemExternalResourcesRegistry</class-id> <category>private-initialization</category><body package="Com- System Configuration Services">constructResourceRegistry	" Private - answer a new instance of a resource tracking registry. "	^ WeakRegistry newFinalizationRegistry</body><body package="Com- System Configuration Services">initialize	"Set up the registry and register for events."	allowImageSaveIfNotEmpty := false.	self initializeResourceRegistry.</body><body package="Com- System Configuration Services">initializeResourceRegistry	" Private - initialize the receiver's resource tracking registry. "	registry := self constructResourceRegistry.</body></methods><methods><class-id>External.SystemExternalResourcesRegistry class</class-id> <category>private-accessing</category><body package="Com- System Configuration Services">current: anExternalResourcesRegistry	"Set the current external resource instance."	current := anExternalResourcesRegistry.</body></methods><methods><class-id>External.SystemExternalResourcesRegistry class</class-id> <category>accessing</category><body package="Com- System Configuration Services">current	"Return the current external resource instance."	^current</body><body package="Com- System Configuration Services">currentRegistry	"Return the current external resource registry."	^self current registry</body></methods><methods><class-id>External.SystemExternalResourcesRegistry class</class-id> <category>private-installation</category><body package="Com- System Configuration Services">initialize	"Create a new registry and store it as the current registry."	current notNil		ifTrue: [ self  removeSessionEventHandlers ].	current := self new initialize.	self registerSessionEventHandlers.</body><body package="Com- System Configuration Services">obsolete	"This class is being removed from the system."	self removeSessionEventHandlers.	self current: nil.	^super obsolete.</body><body package="Com- System Configuration Services">registerSessionEventHandlers	" Private - register the image startup and shutdown event handlers. "	" SystemExternalResourcesRegistry registerSessionEventHandlers "	 COMSystem current		when: #coreStartupCompleted 			send: #startupImage to: self current;		when: #confirmSave 			send: #confirmSaveImage to: self current;		when: #aboutToSave 			send: #aboutToSaveImage to: self current;		when: #shutdown 			send: #shutdownImage to: self current.</body><body package="Com- System Configuration Services">removeSessionEventHandlers    " Private - remove the image startup and shutdown event handlers. "	" SystemExternalResourcesRegistry removeSessionEventHandlers "	COMSystem current removeAllActionsWithReceiver: self current.</body></methods><methods><class-id>External.SystemExternalResourcesRegistry class</class-id> <category>testing</category><body package="Com- System Configuration Services">sessionOwnsResources	" Answer whether the image session owns external resources. "	^self currentRegistry notEmpty</body></methods><methods><class-id>OS.SystemValueRegistry class</class-id> <category>class initialization</category><body package="Com- System Configuration Services">clearRegistry	SystemValue allInstancesDo: [:each | each startupSystem ].</body></methods><methods><class-id>External.SystemGlobalRegistries class</class-id> <category>events</category><body package="Com- System Configuration Services">invalidateRegisteredObjects	self finalizer removeAll.	self notifier removeAll.</body><body package="Com- System Configuration Services">performFinalizationActions	self finalizer rescueAll.	self notifier rescueAll.</body><body package="Com- System Configuration Services">quitAfterSnapShot		^ self performFinalizationActions.</body><body package="Com- System Configuration Services">setUp	^self invalidateRegisteredObjects</body></methods><methods><class-id>External.SystemGlobalRegistries class</class-id> <category>accessing</category><body package="Com- System Configuration Services">finalizer	^ Finalizer</body><body package="Com- System Configuration Services">notifier	^ Notifier</body></methods><methods><class-id>External.SystemGlobalRegistries class</class-id> <category>initialize-release</category><body package="Com- System Configuration Services">initialize	"self initialize"	"informClass: self about: #(setUp resume)."	COMSystem current		when: #setUp send: #setUp to: self;		when: #quitAfterSnapShot send: #quitAfterSnapShot to: self. 	Finalizer := WeakRegistry newFinalizationRegistry.	(Notifier := WeakKeyedRegistry new) action: 		[:anEphemeron | | object dependents |			object := anEphemeron key. 			(dependents := anEphemeron value) isNil ifFalse: [				dependents do: [:dependent | dependent finalize: object ]]].</body><body package="Com- System Configuration Services">obsolete	COMSystem current removeAllActionsWithReceiver: self.		super obsolete.</body></methods><methods><class-id>External.SystemGlobalRegistries class</class-id> <category>gc protection</category><body package="Com- System Configuration Services">gcProtectionRegistry	^ GCProtectionRegistry ifNil: [ GCProtectionRegistry := WeakKeyedDictionary new ].</body><body package="Com- System Configuration Services">safe: anObject forLifeTimeOf: anotherObject	| entries |	entries := self gcProtectionRegistry at: anotherObject ifAbsentPut: [ Set new ].	entries add: anObject.</body><body package="Com- System Configuration Services">unprotect: anObject referencedBy: anotherObject	| entries |	entries := self gcProtectionRegistry at: anotherObject ifAbsent: [ ^ self ].	entries remove: anObject ifAbsent: nil.</body></methods><methods><class-id>External.EarlyCOMSystem</class-id> <category>prerequisites</category><body package="Com- System Configuration Services">prerequisiteSystems	^ Array with: EarlyInstallationSystem</body></methods><methods><class-id>External.EarlyCOMSystem</class-id> <category>default actions</category><body package="Com- System Configuration Services">setUp	COMSystem current earlySystemInstallation</body></methods><methods><class-id>External.EarlyCOMSystem class</class-id> <category>options</category><body package="Com- System Configuration Services">activationEvent	"If this system reacts to system events, which system event should cause it to activate"	^#earlySystemInstallation.</body></methods><methods><class-id>Core.Object</class-id> <category>finalizing</category><body package="Com- System Configuration Services">doesNotNeedFinalization    "The receiver no loner needs to be sent the #finalize message when it is not referenced anymore."    self finalizationRegistry remove: self</body><body package="Com- System Configuration Services">finalizationRegistry    "Answer the WeakRegistry for finalizing the receiver.	Will be overridden by subclasses"    "VS 3.1: ^SystemWeakRegistries finalizer"	^ SystemGlobalRegistries finalizer</body><body package="Com- System Configuration Services">finalize: anObject    "The receiver has asked to be notified if &lt;anObject&gt; is finalized.  It has.  Default is do nothing."</body><body package="Com- System Configuration Services">hasFinalization    "Answer whether the receiver is registered for finalization."    ^self finalizationRegistry includes: self</body><body package="Com- System Configuration Services">needsFinalization    "The receiver needs to be sent the message #finalize when it is no loner referenced."    | finalizer |    finalizer := self finalizationRegistry.    ( finalizer mayBeFinalized: self )        ifFalse: [ ^self ].    finalizer add: self</body><body package="Com- System Configuration Services">notificationRegistry	"Answer the WeakKeyesRegistry used for notifying about finalization	May be overrriden by subclasses"	"VSE seemed to use a singleton (current) but there seems to be no reason to do so for now"	^ SystemGlobalRegistries notifier</body><body package="Com- System Configuration Services">notifyWhenFinalizable: anObject    "Mark &lt;anObject&gt; so that when it is no longer referenced the message #finalize: will be sent to the receiver with &lt;anObject&gt; as the argument."	"VS 3.1:    | notifier list |    notifier := SystemWeakRegistries current notifier.    (notifier mayBeFinalized: anObject)        ifFalse: [^self].    list := notifier at: anObject ifAbsentPut: [ Array new ].    list := list copyWith: self.    notifier at: anObject put: list.	"	"self subclassResponsibility"    | notifier list |	notifier := self notificationRegistry.    (notifier mayBeFinalized: anObject)        ifFalse: [^self].    list := notifier at: anObject ifAbsent: [ Array new ].    list := list copyWith: self.    notifier at: anObject put: list.</body></methods><initialize><class-id>Kernel.HostInterface</class-id></initialize><initialize><class-id>Kernel.ImageConfiguration</class-id></initialize><initialize><class-id>External.SystemExternalResourcesRegistry</class-id></initialize><initialize><class-id>External.SystemGlobalRegistries</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>EphemeronDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>accessLock manager </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Subsystem</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state canActivate prerequisites </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>System-Subsystems</category><attributes><package>System-Subsystems</package></attributes></class><class><name>BlockValue</name><environment>UI</environment><super>UI.ComputedValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block arguments numArgs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Models</category><attributes><package>Interface-Models</package></attributes></class><class><name>OSHandle</name><environment>OS</environment><super>OS.OSErrorHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Support</category><attributes><package>OS-Support</package></attributes></class></st-source>