<?xml version="1.0"?><st-source><!-- Name: Com- Ole ExamplesNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This parcel contains basic COM examplesDbIdentifier: bear73DbTrace: 497455DbUsername: alexDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Com- Event-Enabled Application Extensions' '') #(#any 'Com- Ole' '') #(#any 'Com- Ole Pools' '') #(#any 'Com- System Configuration Services' '') #(#any 'Com- CodeAnnotations' '') #(#any 'Com- ExtensionsToBase' '') #(#any 'Com- Interface Adaptors' '') #(#any 'Com- Win32' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #(#(#name 'Com- Ole Development' #componentType #package))PackageName: Com- Ole ExamplesParcel: #('ComOleExamples')ParcelName: Com- Ole ExamplesPrerequisiteDescriptions: #(#(#name 'Com- Event-Enabled Application Extensions') #(#name 'Com- Ole') #(#name 'Com- Ole Pools' #componentType #package) #(#name 'Com- System Configuration Services' #componentType #package) #(#name 'Com- CodeAnnotations' #componentType #package) #(#name 'Com- ExtensionsToBase' #componentType #package) #(#name 'Com- Interface Adaptors' #componentType #package) #(#name 'Com- Win32' #componentType #package))PrerequisiteParcels: #(#('Com- Event-Enabled Application Extensions' '') #('Com- Ole' '') #('Com- Ole Pools' '') #('Com- System Configuration Services' '') #('Com- CodeAnnotations' '') #('Com- ExtensionsToBase' '') #('Com- Interface Adaptors' '') #('Com- Win32' ''))PrintStringCache: (8.3 - 1,alex)Version: 8.3 - 1Post-Load Block: 	[:package | ]Date: 1:50:04 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:04</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>COMTestDriverFramework</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>logWindow log </inst-vars><class-inst-vars>displayTrace </class-inst-vars><imports></imports><category>COM-Object Test Framework</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.COMTestDriverFramework</class-id><body>COMTestDriverFramework is an abstract superclass which provides a basic framework for implementing test drivers for COM objects.</body></comment><class><name>COMObjectTestDriver</name><environment>Examples</environment><super>Examples.COMTestDriverFramework</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testObject testInterface bindingType </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Object Test Framework</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.COMObjectTestDriver</class-id><body>COMObjectTestDriver is an abstract superclass which provides a simple framework for implementing test drivers to exercise interfaces of a COMObject implementation.  COMObjectTestDriver provides a standard pattern for implementing interface test cases and provides test case services.</body></comment><class><name>COMPersistentDataObjectBrowser</name><environment>Examples</environment><super>UI.EventEnabledApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iClassFactoryPDO iUnkPDO descriptionHolder fileNameHolder backingStoreTypeHolder </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.COMPersistentDataObjectBrowser</class-id><body>COMPersistentDataObjectBrowser is an application which demonstrates using the simple COMPersistentDataObject sample COM object.  It allows you to create a COMPersistentDataObject (a PDO), save it to a file in one of several formats, and load saved objects from the file.To open the browser evaluate the expression:	COMPersistentDataObjectBrowser openPress the Create button to create a new PDO.  The Save and Save As buttons allow you to save the PDO in a file in any of several ways to exercise the various persistence mechanisms:	o using IPersistFile - creates a text file, in this case	o using IPersistStorage - saves the PDO in a substorage in a compound document file	o using IPersistStream - saves the PDO in a stream in a compound document filePress the Load button to load a PDO that you have previously saved.You may wish to use some of the COM development tools to explore while you run this sample:	COMResourceBrowser open.  " examine COM resource usage and exported objects "	COMTraceViewer open.  " watch COM interface function calls come in and out "</body></comment><class><name>IRandomNumberGeneratorPointer</name><environment>Examples</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.IRandomNumberGeneratorPointer</class-id><body>Instances of the receiver provide the host-level binding to the IRandomNumberGenerator interface./* INTERNAL COMMENT */// IRandomNumberGenerator interface definition</body></comment><class><name>COMPDOTestDriver</name><environment>Examples</environment><super>Examples.COMObjectTestDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.COMPDOTestDriver</class-id><body>COMPDOTestDriver defines test cases to exercise the interfaces implemented by the COM object implementation COMPersistentDataObject.  Please refer to the class method #checkListTestCases for expressions that you can evaluate to configure the test environment and execute various test cases." browse checklist expressions "	COMPDOTestDriver browseChecklistMethod: #checkListTestCases.</body></comment><class><name>COMPersistentDataObject</name><environment>Examples</environment><super>External.COMObjectWithInterfaceStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dateCreated systemDescription isDirty currentFileName backingStorage innerUnknownDO </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.COMPersistentDataObject</class-id><body>COMPersistentDataObject is a simple example of a COM object implementation.  The object has some simple state which it exposes to clients through the standard IDataObject interface and which can be persisted through standard COM persistence interfaces (IPersistFile, IPersistStorage, IPersistStream).This sample COM object implementation demonstrates a variety of techniques used when implementing COM objects:	- preallocation of interfaces expected to be used during the object's lifetime	- lazy allocation of interfaces which may not be requested	- direct interface binding for efficiency of supporting fully-implemented interfaces	- adaptor interface binding for flexibility (partial implementation or renaming of function selectors)	- aggregration to reuse capabilities of an existing COM objectCOMPersistentDataObject also demonstrates implementing the logic of an object server EXE application.  It demonstrates defining and registering a class factory for the serviced object, as well as the necessary EXE startup and shutdown logic for publishing this COM object class in a EXE which executes as a local process object server.To exercise this object, use the COMPersistentDataObjectBrowser sample application:	COMPersistentDataObjectBrowser openYou can also execute the various test cases provided by COMPDOTestDriver,  which exercise the interfaces supported by a persistent data object.</body></comment><class><name>IRandomNumberGeneratorImplementation</name><environment>Examples</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.IRandomNumberGeneratorImplementation</class-id><body>Instances of the receiver provide the binding to internal implementations of the IRandomNumberGenerator interface.</body></comment><class><name>COMRNGTestDriver</name><environment>Examples</environment><super>Examples.COMObjectTestDriver</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.COMRNGTestDriver</class-id><body>COMRNGTestDriver defines test cases to exercise the interfaces implemented by the COM object implementation COMRandomNumberGeneratorObject.  Please refer to the class method #checkListTestCases for expressions that you can evaluate to configure the test environment and execute various test cases." browse checklist expressions "	COMRNGTestDriver browseChecklistMethod: #checkListTestCases.</body></comment><class><name>COMRandomNumberGenerator</name><environment>Examples</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed lowerBound upperBound modulus ranList i j </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.COMRandomNumberGenerator</class-id><body>COMRandomNumberGenerator is a simple random number generator which is used for sample COM and automation object implementations.</body></comment><class><name>IRandomNumberGenerator</name><environment>Examples</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.IRandomNumberGenerator</class-id><body>The IRandomNumberGenerator interface provides access to the services of a random number generator.</body></comment><class><name>COMRandomNumberGeneratorObject</name><environment>Examples</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rng iRandomNumberGenerator iDataObject </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Samples</category><attributes><package>Com- Ole Examples</package></attributes></class><comment><class-id>Examples.COMRandomNumberGeneratorObject</class-id><body>COMRandomNumberGeneratorObject is a simple random number generator which exposes its services through the interface IRandomNumberGenerator.  It demonstrates implementing a COM object in Smalltalk, providing services to clients through an COM interface and implementing the interface function processing.For the purposes of demonstrating flexible configuration of interface function support, the RNG object also supports the standard IDataObject interface.  (It doesn't do much, but that's excactly the point in this case.)This sample COM object implementation demonstrates a variety of techniques used when implementing COM objects:	- preallocation of interfaces expected to be used during the object's lifetime	- lazy allocation of interfaces which may not be requested	- direct interface binding for efficiency of supporting fully-implemented interfaces	- adaptor interface binding for flexibility (partial implementation or renaming of function selectors)You can execute the various test cases provided by COMRNGTestDriver,  which exercise the interfaces supported by an RNG object.  (Note that the test driver enables you to exercise the external interface bindings by performing an external call which re-enters this image.  Cross-process invocation requires that the object be published through COM as an object server application with marshalling support for the IRandomNumberGenerator interface.  Publishing the RNG as a COM object server application is not currently supported.)</body></comment><methods><class-id>Examples.COMTestDriverFramework</class-id> <category>subclass-tracing</category><body package="Com- Ole Examples">isTraceEnabled	" Answer whether tracing is currently enabled for the receiver. "	^self class isTraceEnabled</body><body package="Com- Ole Examples">logCr	" Append an empty line to the COM trace log. The caller is responsible for ensuring that tracing is enabled. "	self class logCr.</body><body package="Com- Ole Examples">logIfTraceEnabled: traceEntry	" Append &lt;traceEntry&gt; to the COM trace log if tracing is currently enabled. "	self class logIfTraceEnabled: traceEntry.</body><body package="Com- Ole Examples">logTestCompletion	" Log a completion notice. "	self log cr; nextPutAll: '...done'; cr.	logWindow notNil		ifTrue: [ logWindow clearModified ].</body><body package="Com- Ole Examples">logTraceEntry: traceEntry	" Append the value of &lt;traceEntry&gt; to the COM trace log.  The &lt;traceEntry&gt; can be either a string or a block which returns a string.  The caller is responsible for ensuring that tracing is enabled. "	self class logTraceEntry: traceEntry.</body></methods><methods><class-id>Examples.COMTestDriverFramework</class-id> <category>accessing</category><body package="Com- Ole Examples">log	" Answer the test status log stream. "	log isNil		ifTrue: [ self createTestLogWindow ].	^log</body><body package="Com- Ole Examples">log: aStream	" Specify the test status log stream. "	log := aStream.</body><body package="Com- Ole Examples">logWindow	" Answer the window containing the test status log stream.  Answer nil the the log stream is not in a view.. "	^logWindow</body><body package="Com- Ole Examples">logWindow: aTextWindow	" Specify the view containing the test status log stream. "	logWindow := aTextWindow.	self log: aTextWindow textCollector.</body><body package="Com- Ole Examples">subjectClass    " Answer the COM class exercised by the receiver. "	^self class subjectClass</body></methods><methods><class-id>Examples.COMTestDriverFramework</class-id> <category>test services</category><body package="Com- Ole Examples">checkCOMResources	" Verify that there are no COM resources left lying around after running a test case. "	self class checkCOMResources.</body><body package="Com- Ole Examples">createTestLogWindow	" Create a log window for displaying test driver results.  Answer the stream for appending text. "	self logWindow: self class createTestLogWindow.</body></methods><methods><class-id>Examples.COMTestDriverFramework class</class-id> <category>subclass-tracing</category><body package="Com- Ole Examples">isTraceEnabled	" Answer whether tracing is currently enabled for instances of the receiver. "	^COMSessionManager isTraceEnabled</body><body package="Com- Ole Examples">logCr	" Append an empty line to the COM trace log. The caller is responsible for ensuring that tracing is enabled. "	COMSessionManager traceManager logCr.</body><body package="Com- Ole Examples">logIfTraceEnabled: traceEntry	" Append &lt;traceEntry&gt; to the COM trace log if tracing is currently enabled. "	self isTraceEnabled		ifTrue: [ self logTraceEntry: traceEntry ].</body><body package="Com- Ole Examples">logTraceEntry: traceEntry	" Append the value of &lt;traceEntry&gt; to the COM trace log.  The &lt;traceEntry&gt; can be either a string or a block which returns a string.  The caller is responsible for ensuring that tracing is enabled. "	| aString |	aString := ( traceEntry isStringOrUserMessage		ifTrue: [ traceEntry ]		ifFalse: [ traceEntry value ] ) asString.	COMSessionManager traceManager log: aString.</body></methods><methods><class-id>Examples.COMTestDriverFramework class</class-id> <category>test services</category><body package="Com- Ole Examples">browseChecklistMethod: aSelector	" Browse the checklist method named &lt;aSelector&gt; in the receiver. "	TextWindow openOn:  ( self class compiledMethodAt: aSelector ) getSource		label: self name, ' Test Execution Expressions'</body><body package="Com- Ole Examples">checkCOMResources	" Verify that there are no COM resources left lying around after running a test case. "	COMSessionManager sessionHasResources		ifTrue: [ 			#{External.COMResourceBrowser} ifDefinedDo: [:browser | browser open].			MessageBox warning: 				((#ComResourcesInUse &lt;&lt; #com &gt;&gt; 'COM resources are still in use - this may indicate a reference counting bug in the &lt;1s&gt; implementation.')			expandMacrosWith: ([self subjectClass name]					on: Error do: [:ex | ex return: ((#x1ssSubjectClass &lt;&lt; #com &gt;&gt; '&lt;1s&gt;''s subject class')			expandMacrosWith: self name)]))							].</body><body package="Com- Ole Examples">createTestLogWindow	" Create a log window for displaying test driver results.  Answer the text window "	^TextWindow openOn: String new		label: self name, ((#NamedLog &lt;&lt; #com &gt;&gt; '&lt;1s&gt; Log') expandMacrosWith: self name)</body><body package="Com- Ole Examples">openTraceViewer	" Open a trace viewer if tracing is currently enabled for the receiver's test cases. "	self displayTrace		ifTrue: [ COMTraceViewer open ].</body></methods><methods><class-id>Examples.COMTestDriverFramework class</class-id> <category>subclass-initializing</category><body package="Com- Ole Examples">initializeDisplayTrace	" Initialize the toggle controlling whether a trace log should be displayed during test case execution. "	displayTrace := self defaultDisplayTraceSetting.</body></methods><methods><class-id>Examples.COMTestDriverFramework class</class-id> <category>accessing</category><body package="Com- Ole Examples">defaultDisplayTraceSetting	" Answer the default setting for running tracing with test case execution. "	^false</body><body package="Com- Ole Examples">displayTrace	" Answer whether a trace log should be displayed during test case execution. "	displayTrace isNil		ifTrue: [ self initializeDisplayTrace ].	^displayTrace</body><body package="Com- Ole Examples">displayTrace: aBoolean	" Specify whether a trace log should be displayed during test case execution. "	displayTrace := aBoolean.</body><body package="Com- Ole Examples">subjectClass	" Answer the COM object implementation class exercised by the receiver. "	^self subclassResponsibility</body></methods><methods><class-id>Examples.COMObjectTestDriver</class-id> <category>subclass-configuring trace options</category><body package="Com- Ole Examples">openTraceViewerForIID: anIID bindingType: aBindingType testCase: testCaseSelector	" Open a trace viewer to watch function invocations of the interface identified by &lt;anIID&gt; through the connection type &lt;aBindingType&gt;.  May be overridden by subclasses which want to suppress tracing during test case execution.  "	self class openTraceViewer.</body><body package="Com- Ole Examples">setClassFactoryTestTraceOptions: aBindingType testCase: testCaseSelector	" Set the trace options to watch function invocations through IClassFactory through the connection type &lt;aBindingType&gt; for the test case &lt;testCaseSelector&gt;.  Answer an action which when evaluated will restore the original trace settings.  May be overridden by subclasses which want class factory tracting during test case execution. "	^self setTestTraceOptions: #( #none) 		forIID: IID_IClassFactory</body><body package="Com- Ole Examples">setGlobalTestTraceOptionsForIID: anIID bindingType: aBindingType testCase: testCaseSelector	" Set the global trace enabling flags to watch function invocations of an interface through the connection type &lt;aBindingType&gt; by test case &lt;testCaseSelector.  Answer an action which when evaluated will restore the system's tracing option settings to their current values.  May be overridden by subclasses which want different tracing options for a specific interface or test case. "	| globalSettingSelector originalSetting |	aBindingType = #internalLocal		ifTrue: [ globalSettingSelector := #traceInternalCalls ].	aBindingType = #externalLocal		ifTrue: [ globalSettingSelector := #traceCallin ].	aBindingType = #externalServer		ifTrue: [ globalSettingSelector := #traceCallin ].	originalSetting := COMTraceManager perform: globalSettingSelector.	globalSettingSelector := ( globalSettingSelector, ':' ) asSymbol.	COMTraceManager perform: globalSettingSelector		with: true.	^MessageSend receiver: COMTraceManager		selector: globalSettingSelector		argument: originalSetting</body><body package="Com- Ole Examples">setStandardTestTraceOptionsForIID: anIID bindingType: aBindingType	" Set the standard trace options to watch function invocations of the interface identified by &lt;anIID&gt; through the connection type &lt;aBindingType&gt;.  Answer an action which when evaluated will restore the original trace settings. "	^self setTestTraceOptions: ( self standardTestOptionsForBindingType: aBindingType ) 		forIID: anIID</body><body package="Com- Ole Examples">setTestTraceOptions: traceOptions forIID: anIID	" Set the  trace options for the interface identified by &lt;anIID&gt; to &lt;traceOptions&gt;.  Answer an action which when evaluated will restore the trace settings to their original values. "	| originalTraceOptions |	originalTraceOptions := COMTraceManager traceOptionsForIID: anIID.	COMTraceManager registerInterfaceTraceOptions: traceOptions 		forIID: anIID.	^MessageSend receiver: COMTraceManager		selector: #registerInterfaceTraceOptions:forIID:		arguments: ( Array with: originalTraceOptions with: anIID )</body><body package="Com- Ole Examples">setTestTraceOptionsForIID: anIID bindingType: aBindingType	" Set the trace options to watch function invocations of the interface identified by &lt;anIID&gt; through the connection type &lt;aBindingType&gt;.  Answer an action which when evaluated will restore the original trace settings.  May be overridden by subclasses which want different tracing options for a specific interface. "	^self setStandardTestTraceOptionsForIID: anIID 		bindingType: aBindingType</body><body package="Com- Ole Examples">setTestTraceOptionsForIID: anIID bindingType: aBindingType testCase: testCaseSelector	" Set the interface trace options to watch function invocations of the interface identified by &lt;anIID&gt; through the connection type &lt;aBindingType&gt; by test case &lt;testCaseSelector.  Answer an action which when evaluated will restore the system's tracing option settings to their current values.  May be overridden by subclasses which want different tracing options for a specific interface or test case. "	| restoreTraceStateActions |	self class displayTrace		ifFalse: [ ^nil ].	restoreTraceStateActions := OrderedCollection new.	restoreTraceStateActions 		add: ( self setGlobalTestTraceOptionsForIID: anIID bindingType: aBindingType testCase: testCaseSelector );		add: ( self setClassFactoryTestTraceOptions: aBindingType testCase: testCaseSelector );		add: ( self setTestTraceOptionsForIID: anIID bindingType: aBindingType ).	^ActionSequence withAll: 		( restoreTraceStateActions reject: [ :anAction | anAction isNil ] )</body><body package="Com- Ole Examples">standardTestOptionsForBindingType: aBindingType	" Answer the standard interface trace options for testing using a binding of type &lt;aBindingType&gt;. "	^Array with: ( aBindingType = #internalLocal		ifTrue: [ #internalCallin ]		ifFalse: [ #externalCallin ] )</body></methods><methods><class-id>Examples.COMObjectTestDriver</class-id> <category>accessing</category><body package="Com- Ole Examples">bindingType	" Answer the interface binding type in use for this test. "	^bindingType</body><body package="Com- Ole Examples">bindingType: aBindingType	" Specify the interface binding type in use for this test. "	bindingType := aBindingType.</body><body package="Com- Ole Examples">testInterface	" Answer the interface on the COM object being tested. "	^testInterface</body><body package="Com- Ole Examples">testInterface: anInterface	" Specify the interface on the COM object being tested. "	testInterface := anInterface.	testObject := anInterface implementingObject.  " nil if the test object is in a separate server process "</body><body package="Com- Ole Examples">testObject	" Answer (an interface on) the COM object being tested. "	^testObject</body></methods><methods><class-id>Examples.COMObjectTestDriver</class-id> <category>test execution</category><body package="Com- Ole Examples">createTestObject: aCLSID iid: anIID bindingType: aBindingType	" Create a new instance of the COM object class specified by &lt;aCLSID&gt; for use in testing and answer the interface identified by &lt;anIID&gt;.  Construct the test object so that the interface is excercised through an interface binding of type &lt;aBindingType&gt;. "	| anInterface |	anInterface := self class createTestObject: aCLSID 		iid: anIID 		bindingType: aBindingType.	self 		testInterface: anInterface;		bindingType: aBindingType.	^anInterface</body><body package="Com- Ole Examples">getInterfaceIID: anInterfaceSpecification	" Answer the IID of the interface specified by &lt;anInterfaceSpecification&gt;. "	^( anInterfaceSpecification class == GUID		ifTrue: [ anInterfaceSpecification ]   " IID "		ifFalse: [ anInterfaceSpecification iid ] )  " interface class "</body><body package="Com- Ole Examples">releaseTestInterface	testInterface notNil		ifTrue: [			testInterface enforceRelease.			testInterface := testObject := nil ].</body><body package="Com- Ole Examples">testCLSID: aCLSID iid: anInterfaceSpecification bindingType: aBindingType perform: testCaseSelector 	" Test the operations in the COM interface specified by &lt;anInterfaceSpecification&gt; with an interface binding of the specified type &lt;aBindingType&gt; on an test object of the COM object class &lt;aCLSID&gt;.  The interface can be specified by an interface class or an IID.  The binding type determines how the object is constructed to exercise internal or external connections. "	| anIID restoreTraceStateAction |	anIID := self getInterfaceIID: anInterfaceSpecification.	restoreTraceStateAction := self 				setTestTraceOptionsForIID: anIID				bindingType: aBindingType				testCase: testCaseSelector.	self 		openTraceViewerForIID: anIID		bindingType: aBindingType		testCase: testCaseSelector.	self 		createTestObject: aCLSID		iid: anIID		bindingType: aBindingType.	self testInterface isNil 		ifTrue: [self error: #ErrTestObjCreateFailed &lt;&lt; #com &gt;&gt; 'test object creation failed'].		[self createTestLogWindow.	(self log)		nextPutAll: ((#ExecutingTestCase &lt;&lt; #com &gt;&gt; 'Executing test case &lt;1s&gt;%&gt;%&gt;&lt;2s&gt;')			expandMacrosWith: self class name			with: testCaseSelector);		cr;		cr.	self perform: testCaseSelector] 			ensure: 				[self logWindow clearModified.				self releaseTestInterface.				restoreTraceStateAction evaluate.				" there should be no resources left lying around when the test terminates "				self checkCOMResources]</body></methods><methods><class-id>Examples.COMObjectTestDriver</class-id> <category>subclass-tracing</category><body package="Com- Ole Examples">logTestCaseDescription: descriptionString	" Log a description of the test case being executed. "	log 		nextPutAll: descriptionString; cr;		tab; nextPutAll: ((#InterfaceC1s &lt;&lt; #com &gt;&gt; 'Interface: &lt;1s&gt;')			expandMacrosWith: self testInterface printString); cr.	self testObject notNil		ifTrue: [ log tab; nextPutAll: ((#ObjectC1s &lt;&lt; #com &gt;&gt; 'Object: &lt;1s&gt;')			expandMacrosWith: self testObject printString); cr ].	log cr.</body></methods><methods><class-id>Examples.COMObjectTestDriver class</class-id> <category>test object creation</category><body package="Com- Ole Examples">createExternalLocalTestObject: aCLSID iid: anIID 	" Create a new instance of the COM object class identified by &lt;aCLSID&gt; for use in testing and answer the interface identified by &lt;anIID&gt;.  Construct the test object so that the interface is excercised through an internal interface binding. "	| aCOMObjectClass aClassFactory anInterface |	self isTraceEnabled 		ifTrue: 			[self				logCr;				logTraceEntry: #CreatingTestObj &lt;&lt; #com &gt;&gt;'Creating test object using COM class factory...'].	aCOMObjectClass := aCLSID = self subjectCLSID 				ifTrue: [self subjectClass]				ifFalse: [COMObject classForCLSID: aCLSID].	aCOMObjectClass isNil 		ifTrue: 			[MessageBox warning: (#NoClassFoundForCLSID1s &lt;&lt; #com &gt;&gt; 'No class found for CLSID &lt;1s&gt;' expandMacrosWith: aCLSID asString).			^nil].	aClassFactory := aCOMObjectClass registerClassFactory.	aClassFactory isNil 		ifTrue: [self error: #ErrFactoryRegFailed &lt;&lt; #com &gt;&gt; 'Class factory registration failed'].	[anInterface := IClassFactory createInstance: aCLSID iid: anIID] 		ensure: [aClassFactory revokeRegistration].	self isTraceEnabled 		ifTrue: 			[self				logTraceEntry: #DoneCreatingTestObj &lt;&lt; #com &gt;&gt;'... done creating test object';				logCr].	^anInterface</body><body package="Com- Ole Examples">createExternalServerTestObject: aCLSID iid: anIID	" Create a new instance of the COM object class specified by &lt;aCLSID&gt; for use in testing and answer the interface identified by &lt;anIID&gt;.  Construct the test object so that the interface is excercised through an internal interface binding. "	^IClassFactory createInstance: aCLSID iid: anIID</body><body package="Com- Ole Examples">createInternalLocalTestObject: aCLSID iid: anIID	" Create a new instance of the COM object class specified by &lt;anIID&gt; for use in testing and answer the interface identified by &lt;anIID&gt;.  Construct the test object so that the interface is excercised through an internal interface binding. "	| aCOMObjectClass |	aCOMObjectClass := ( aCLSID = self subjectCLSID		ifTrue: [ self subjectClass ]		ifFalse: [ COMObject classForCLSID: aCLSID ] ).	aCOMObjectClass isNil		ifTrue: [			MessageBox warning: ((#NoClassFoundForCLSID1s &lt;&lt; #com &gt;&gt; 'No class found for CLSID &lt;1s&gt;')			expandMacrosWith: aCLSID asString).			^nil ].	^aCOMObjectClass new queryInterface: anIID</body><body package="Com- Ole Examples">createTestObject: anIID bindingType: aBindingType	" Create a new instance of the receiver for use in testing and answer the interface identified by &lt;anIID&gt;.  Construct the test object so that the interface is excercised through an interface binding of type &lt;aBindingType&gt;. "	^self createTestObject: self subjectCLSID		iid: anIID 		bindingType: aBindingType</body><body package="Com- Ole Examples">createTestObject: aCLSID iid: anIID bindingType: aBindingType 	" Create a new instance of the COM object class specified by &lt;aCLSID&gt; for use in testing and answer the interface identified by &lt;anIID&gt;.  Construct the test object so that the interface is excercised through an interface binding of type &lt;aBindingType&gt;. "	aBindingType = #internalLocal 		ifTrue: [^self createInternalLocalTestObject: aCLSID iid: anIID].	aBindingType = #externalLocal 		ifTrue: [^self createExternalLocalTestObject: aCLSID iid: anIID].	aBindingType = #externalServer 		ifTrue: [^self createExternalServerTestObject: aCLSID iid: anIID].	self error: #ErrUnsupportedIntBindType &lt;&lt; #com &gt;&gt; 'unsupported interface binding type'</body><body package="Com- Ole Examples">manufactureTestObject: aCOMObjectClass	" Manufacture a new instance of the COM object class &lt;aCOMObjectClass&gt; for use in testing and answer its IUnknown interface.  The object class does not need to have a CLSID assigned for external publication.  Construct the test object so that the interface is excercised through an external interface binding to a local object. "	^self manufactureTestObject: aCOMObjectClass iid: IID_IUnknown</body><body package="Com- Ole Examples">manufactureTestObject: aCOMObjectClass iid: anIID	" Manufacture a new instance of the COM object class &lt;aCOMObjectClass&gt; for use in testing and answer the interface identified by &lt;anIID&gt;.  The object class does not need to have a CLSID assigned for external publication.  Construct the test object so that the interface is excercised through an external interface binding to a local object. "	| temporaryCLSID aClassFactory anInterface |	aCOMObjectClass clsid notNil		ifTrue: [ ^self createTestObject: aCOMObjectClass clsid iid: anIID bindingType: #externalLocal ].	" force external binding by using a temporary class factory "	temporaryCLSID := GUID new.	aClassFactory := COMClassFactoryObject new			objectClass: aCOMObjectClass;			objectCLSID: temporaryCLSID;			yourself.	aClassFactory registerAsMultipleUseLocalServer.	[ anInterface := IClassFactory createInstance: temporaryCLSID iid: anIID ]		ensure: [ aClassFactory revokeRegistration ].	Assert isTrue: [ anInterface isCOMInterfacePointer ].	Assert isEqual: anInterface implementingObject referenceCount to: 1.	^anInterface</body><body package="Com- Ole Examples">supportedBindingTypes	" Answer the types of interface binding connections that can be used to construct test objects. "	^#( #internalLocal #externalLocal #externalServer )</body></methods><methods><class-id>Examples.COMObjectTestDriver class</class-id> <category>subclass-tracing</category><body package="Com- Ole Examples">isTraceEnabled	" Answer whether tracing is currently enabled for incoming function calls. "	^COMSessionManager isTraceEnabled		and: [ ( ( COMSessionManager traceManager isTraceTypeEnabled: #externalCallin )				or: [ COMSessionManager traceManager isTraceTypeEnabled: #internalCallin ] ) ]</body></methods><methods><class-id>Examples.COMObjectTestDriver class</class-id> <category>test execution</category><body package="Com- Ole Examples">testCLSID: aCLSID iid: anInterfaceSpecification bindingType: aBindingType perform: testCaseSelector	" Test the operations in the COM interface specified by &lt;anInterfaceSpecification&gt; with an interface binding of the specified type &lt;aBindingType&gt; on an test object of the COM object class &lt;aCLSID&gt;.  The interface can be specified by an interface class or an IID.  The binding type determines how the object is constructed to exercise internal or external connections. "	^self new testCLSID: aCLSID 		iid: anInterfaceSpecification 		bindingType: aBindingType 		perform: testCaseSelector</body><body package="Com- Ole Examples">testInterface: anInterfaceSpecification bindingType: aBindingType perform: testCaseSelector	" Test the operations in the COM interface specified by &lt;anInterfaceSpecification&gt; with an interface binding of the specified type &lt;aBindingType&gt;.  The interface can be specified by an interface class or an IID.  The binding type determines how the object is constructed to exercise internal or external connections. "	^self new testCLSID: self subjectCLSID 		iid: anInterfaceSpecification 		bindingType: aBindingType 		perform: testCaseSelector</body></methods><methods><class-id>Examples.COMObjectTestDriver class</class-id> <category>subclass-accessing</category><body package="Com- Ole Examples">subjectCLSID	" Answer the CLSID of the COM object implementation class exercised by the receiver. "	^self subjectClass clsid</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser</class-id> <category>accessing</category><body package="Com- Ole Examples">backingStoreType	" Answer the current backing store type choice. "	^backingStoreTypeHolder value</body><body package="Com- Ole Examples">backingStoreType: aFormatChoice	" Set the current backing store type choice. "	( ( self supportedStorageTypes includes: aFormatChoice )	or: [ aFormatChoice = self backingStoreType ] )		ifFalse: [ ^self ].  " bogus or no change, leave it alone... "	backingStoreTypeHolder value: aFormatChoice.</body><body package="Com- Ole Examples">currentFileName	" Answer the current file name or nil. "	| aString |	aString := fileNameHolder value.	^aString size = 0		ifTrue: [ nil ]		ifFalse: [ aString ]</body><body package="Com- Ole Examples">currentFileName: aStringOrNil	" Set the current file name to &lt;aString&gt;. "	fileNameHolder value: ( aStringOrNil notNil		ifTrue: [ aStringOrNil ]		ifFalse: [ String new ] ).</body><body package="Com- Ole Examples">defaultBackingStoreType	" Private "	^'file'</body><body package="Com- Ole Examples">description: aStringOrNil	" Set the description to &lt;aString&gt;. "	descriptionHolder value: ( aStringOrNil notNil		ifTrue: [ aStringOrNil ]		ifFalse: [ String new ] ).</body><body package="Com- Ole Examples">supportedStorageTypes		^#( 'file' 'storage' 'stream' )</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser</class-id> <category>aspects</category><body package="Com- Ole Examples">backingStoreTypeHolder	" Answer the value holder for the backing store type choice. "	^backingStoreTypeHolder</body><body package="Com- Ole Examples">descriptionHolder	" Answer the value holder for the description. "	^descriptionHolder</body><body package="Com- Ole Examples">fileNameHolder	" Answer the value holder for the current file name. "	^fileNameHolder</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser</class-id> <category>private-user operations</category><body package="Com- Ole Examples">createPDO	" Private - create a PDO. "	self releasePersistentDataObject.	iUnkPDO := self createPersistentDataObject.	self updateView: nil.</body><body package="Com- Ole Examples">loadPDO	" Private - load a PDO. "	| aPathName |	aPathName := FileDialog openFile: '*.pdo'.	aPathName isNil		ifTrue: [ ^nil ].	self releasePersistentDataObject.	self loadFrom: aPathName.</body><body package="Com- Ole Examples">releasePDO	" Private - release the PDO. "	self releasePersistentDataObject.	self updateView: nil.</body><body package="Com- Ole Examples">saveAsPDO	" Private - save the PDO. "	| currentFileName aPathName |	currentFileName := self currentFileName.	aPathName := FileDialog saveFile: ( currentFileName notNil		ifTrue: [ currentFileName ]		ifFalse: [ (#Untitledpdo &lt;&lt; #com &gt;&gt; 'Untitled.pdo') asString ] ).	aPathName isNil		ifTrue: [ ^nil ].	self saveTo: aPathName.</body><body package="Com- Ole Examples">savePDO	" Private - save the PDO. "	| aPathName |	aPathName := self currentFileName.	aPathName isNil		ifTrue: [ ^self saveAsPDO ].	self saveTo: aPathName.</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser</class-id> <category>private-PDO operations</category><body package="Com- Ole Examples">createInternalPersistentDataObject	" Private - create a new PDO with strictly internal bindings and answer its IUnknown. "	^COMPersistentDataObject new innerUnknown</body><body package="Com- Ole Examples">createPersistentDataObject	" Private - create a new PDO and answer its IUnknown. "	^iClassFactoryPDO isNil		ifTrue: [ self createInternalPersistentDataObject ]  " internal testing configuration "		ifFalse: [ iClassFactoryPDO createInstance ]</body><body package="Com- Ole Examples">getDescription	" Private - answer the description of the PDO. "	| anIDataObject aDescriptionString |	anIDataObject := iUnkPDO queryInterface: IID_IDataObject.	aDescriptionString := anIDataObject renderFormat: 'String'.	^aDescriptionString</body><body package="Com- Ole Examples">loadFrom: aPathName	" Private - Load the PDO from the file named &lt;aPathName&gt;, according to the desired format. "	( COMCompoundFile isStorageFile: aPathName )		ifTrue: [ self loadFromCompoundDocFile: aPathName ]		ifFalse: [ self loadFromFile: aPathName ].</body><body package="Com- Ole Examples">loadFromCompoundDocFile: aPathName	" Private - load a PDO from the specified compound document file. "	| rootStorage storageType |		[iUnkPDO := self createPersistentDataObject.	rootStorage := COMCompoundFile pathName: aPathName.	storageType := self readStorageType: rootStorage.	storageType = 'storage' ifTrue: [self loadStateFromStorage: rootStorage].	storageType = 'stream' ifTrue: [self loadStateFromStream: rootStorage]]			on: COMError			do: 				[:ex |				self releasePersistentDataObject.				MessageBox notify: (#LoadFailed &lt;&lt; #com &gt;&gt; 'Load Failed') asString withText: ex description.				ex return].	(#('storage' 'stream') includes: storageType)		ifFalse: 			[self releasePersistentDataObject.			MessageBox notify: #LoadFailed &lt;&lt; #com &gt;&gt; 'Load Failed'				withText: (#UnexpectedFormatC1s &lt;&lt; #com &gt;&gt; 'Unexpected format: &lt;1s&gt;'						expandMacrosWith: (storageType isNil ifTrue: [#none &lt;&lt; #com &gt;&gt; '(none)'] ifFalse: [storageType]))].	self		backingStoreType: storageType;		updateView: aPathName</body><body package="Com- Ole Examples">loadFromFile: aPathName	" Private - load a PDO from the specified text file. "	| anIPersistFile |	iUnkPDO := self createPersistentDataObject.		[anIPersistFile := iUnkPDO queryInterface: IID_IPersistFile.	anIPersistFile load: aPathName storageMode: STGM_READ]			on: COMError			do: 				[:ex |				self releasePersistentDataObject.				MessageBox notify: (#LoadFailed &lt;&lt; #com &gt;&gt; 'Load Failed') asString withText: ex description.				ex return].	self		backingStoreType: 'file';		updateView: aPathName</body><body package="Com- Ole Examples">loadStateFromStorage: rootStorage	" Private - load the state of the PDO from a storage in the specified compound document file.  Error handling is provided by the caller. "	| aCLSID pdoStorage anIPersistStorage |	pdoStorage := rootStorage openStorage: self pdoDataStorageElementName.	aCLSID := pdoStorage readCLSID.	aCLSID = self pdoCLSID		ifFalse: 			[COMError raiseSignal: (#ErrNamedUnknownCLSID &lt;&lt; #com &gt;&gt; 'Invalid file: unknown CLSID &lt;1s&gt;'						expandMacrosWith: aCLSID asString)].	anIPersistStorage := iUnkPDO queryInterface: IID_IPersistStorage.	anIPersistStorage load: pdoStorage</body><body package="Com- Ole Examples">loadStateFromStream: rootStorage	" Private - load the state of the PDO from a stream in the specified compound document file.  Error handling is provided by the caller. "	| aCLSID pdoStream anIPersistStream |	pdoStream := rootStorage openStream: self pdoDataStorageElementName.	aCLSID := pdoStream readCLSID.	aCLSID = self pdoCLSID		ifFalse: 			[COMError raiseSignal: (#ErrNamedUnknownCLSID &lt;&lt; #com &gt;&gt; 'Invalid file: unknown CLSID &lt;1s&gt;'						expandMacrosWith: aCLSID asString)].	anIPersistStream := iUnkPDO queryInterface: IID_IPersistStream.	anIPersistStream load: pdoStream</body><body package="Com- Ole Examples">pdoCLSID	" Private - answer the CLSID of the PDO. "	^COMPersistentDataObject clsid</body><body package="Com- Ole Examples">pdoDataStorageElementName	" Private - answer the name of the stream in the compound file which contains the persisted data. "	^'PDOData'</body><body package="Com- Ole Examples">readStorageType: anIStorage	" Private - answer the persisted data format. "	| anIStream storageType |		[anIStream := anIStorage openStream: self storageTypeStreamName.	storageType := anIStream asCharacterStream contents]			on: COMError			do: 				[:ex |				storageType := nil.				ex return].	^storageType</body><body package="Com- Ole Examples">releasePersistentDataObject	" Private - release the current PDO. "	iUnkPDO := nil.</body><body package="Com- Ole Examples">saveTo: aPathName 	" Private - Save the PDO to the file named &lt;aPathName&gt; in the desired format. "	self backingStoreType = 'file' ifTrue: [^self saveToFile: aPathName].	self backingStoreType = 'storage' 		ifTrue: [^self saveToStorageFile: aPathName].	self backingStoreType = 'stream' 		ifTrue: [^self saveToStreamFile: aPathName].	self error: #ErrUnknownStorageType &lt;&lt; #com &gt;&gt; 'unknown storage type choice'</body><body package="Com- Ole Examples">saveToFile: aPathName	" Private - save the PDO to the specified file. "	| anIPersistFile |	anIPersistFile := iUnkPDO queryInterface: IID_IPersistFile.	[anIPersistFile save: aPathName makeFileCurrent: true] on: COMError		do: [:ex | MessageBox notify: (#SaveFailed &lt;&lt; #com &gt;&gt; 'Save Failed') asString withText: ex description].	anIPersistFile saveCompleted: aPathName.	self		description: self getDescription;		currentFileName: aPathName</body><body package="Com- Ole Examples">saveToStorageFile: aPathName	" Private - save the PDO to the specified file as a COM storage. "	| rootStorage pdoStorage anIPersistStorage |	[	rootStorage := COMCompoundFile newFile: aPathName.	[	self writeStorageType: rootStorage.	pdoStorage := rootStorage newStorage: self pdoDataStorageElementName.	pdoStorage writeCLSID: self pdoCLSID.	anIPersistStorage := iUnkPDO queryInterface: IID_IPersistStorage.	anIPersistStorage 		saveToAlternateStorage: pdoStorage;		saveCompleted: pdoStorage.	"?? pdoStorage commit. ??"  " don't need, right? "	rootStorage commit.	] ensure: [		anIPersistStorage notNil ifTrue: [ anIPersistStorage enforceRelease ].		pdoStorage notNil ifTrue: [ pdoStorage enforceRelease ].		rootStorage enforceRelease ].	] on: COMError		do: [ :ex |			MessageBox notify: (#SaveFailed &lt;&lt; #com &gt;&gt; 'Save Failed') asString				withText: ex description.			ex return ].	self		description: self getDescription;		currentFileName: aPathName.</body><body package="Com- Ole Examples">saveToStreamFile: aPathName	" Private - save the PDO to the specified file as a COM stream. "	| rootStorage pdoStream anIPersistStream |		[rootStorage := COMCompoundFile newFile: aPathName.	self writeStorageType: rootStorage.	pdoStream := rootStorage newStream: self pdoDataStorageElementName.	"###Use #saveToStream: API ?? If so, where is our corresponding load wrapper??###"	pdoStream writeCLSID: self pdoCLSID.	anIPersistStream := iUnkPDO queryInterface: IID_IPersistStream.	anIPersistStream save: pdoStream.	"?? pdoStream commit. ??"	" don't need, right? "	rootStorage commit]			on: COMError			do: 				[:ex |				MessageBox notify: (#SaveFailed &lt;&lt; #com &gt;&gt; 'Save Failed') asString withText: ex description.				ex return].	self		description: self getDescription;		currentFileName: aPathName</body><body package="Com- Ole Examples">storageTypeStreamName	" Private - answer the name of the stream in the compound file which defines the persisted format. "	^'PDOStorageType'</body><body package="Com- Ole Examples">writeStorageType: anIStorage	" Private - describe the persisted data format. "	| anIStream |	anIStream := anIStorage newStream: self storageTypeStreamName.	anIStream asCharacterStream nextPutAll: self backingStoreType</body><body package="Com- Ole Examples">zzOLDcreateLocalPersistentDataObject	" Private - create a new PDO in the local process with external bindings and answer its IUnknown. "	| aLocalClassFactory anIUnknown |	COMPersistentDataObject registerClassFactory isNil 		ifTrue: [self error: #ErrFactoryRegFailed &lt;&lt; #com &gt;&gt; 'Class factory registration failed'].	" this is cheating, really, but it works for the purposes of demonstration "	aLocalClassFactory := COMSessionManager 				classFactoryForCLSID: COMPersistentDataObject clsid.	[anIUnknown := IClassFactory createInstance: self pdoCLSID] 		ensure: [aLocalClassFactory revokeRegistration].	^anIUnknown</body><body package="Com- Ole Examples">zzOLDcreateServerPersistentDataObject	" Private - create a new PDO in a COM server process and answer its IUnknown. "	^IClassFactory createInstance: self pdoCLSID</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser</class-id> <category>private-operations</category><body package="Com- Ole Examples">enableDisableOperationButtons	| activePDOButtonNames |	activePDOButtonNames := #( 		#releasePDOButton 		#savePDOButton #saveAsPDOButton ).	iUnkPDO isNil		ifTrue: [			activePDOButtonNames do: [ :aButtonName |				self disableComponentNamed: aButtonName ] ]		ifFalse: [			activePDOButtonNames do: [ :aButtonName |				self enableComponentNamed: aButtonName ] ]</body><body package="Com- Ole Examples">updateView: aPathName	"  Private - update the view the reflect the current state of the PDO, if any. "	iUnkPDO isNil		ifTrue: [			self 				description: nil;				currentFileName: nil ]		ifFalse: [			self				description: self getDescription;				currentFileName: aPathName ].	self enableDisableOperationButtons.</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser</class-id> <category>private-class factory operations</category><body package="Com- Ole Examples">getClassFactory	" Private - get a class factory for creation PDO instances.  Answer whether successful. "	true ifTrue: [ self registerLocalClassFactory ].  " bypass a registered server to ensure we test ourselves "	" obtain a class factory for the PDO "	iClassFactoryPDO := [ IClassFactory forCLSID: self pdoCLSID ]		on: COMError		do: [ :ex | ex return: nil ].	iClassFactoryPDO notNil		ifTrue: [ Assert isEqual: iClassFactoryPDO clsid to: self pdoCLSID ] .	^iClassFactoryPDO notNil</body><body package="Com- Ole Examples">registerLocalClassFactory	" Private - register a PDO class factory from the local process. "	" this is cheating, really, but it works for the purposes of demonstration "	| aLocalClassFactory |	(aLocalClassFactory := COMPersistentDataObject registerClassFactory) isNil 		ifTrue: [self error: #ErrFactoryRegFailed &lt;&lt; #com &gt;&gt; 'Class factory registration failed'].	Assert isTrue: 			[aLocalClassFactory 				== (COMSessionManager classFactoryForCLSID: COMPersistentDataObject clsid)].	self applicationWindow 		when: #closed		send: #revokeRegistration		to: aLocalClassFactory</body><body package="Com- Ole Examples">releaseClassFactory	" Private - release the PDO class factory. "	iClassFactoryPDO := nil</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser</class-id> <category>private-initialization</category><body package="Com- Ole Examples">initialize	" Private - initialize a new instance "	super initialize.	descriptionHolder := String new asValue.	fileNameHolder := String new asValue.	backingStoreTypeHolder := self defaultBackingStoreType asValue.</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser</class-id> <category>private-window events</category><body package="Com- Ole Examples">windowBuilt	" Private - the window has been built and is about to be opened. "	^self enableDisableOperationButtons.</body><body package="Com- Ole Examples">windowClosed	" Private - the window has been closed. "	self 		releasePersistentDataObject;		releaseClassFactory.</body><body package="Com- Ole Examples">windowOpened	" Private - the window has been opened.  Obtain a class factory for the PDO. "	false ifTrue: [ ^self ].  " just punt out of here if you want to simply test internal connections "	Cursor execute showWhile: [ 		self getClassFactory ].	iClassFactoryPDO isNil		ifTrue: [ 			#( #createPDOButton #loadPDOButton ) do: [ :cn |				self disableComponentNamed: cn ].			MessageBox warning: (#CantObtainClassFactory &lt;&lt; #com &gt;&gt; 'Cannot obtain a class factory for the persistent data object sample.') asString ].</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser class</class-id> <category>interface specs</category><body package="Com- Ole Examples">eventHandlersSpec	" Answer the specifications for connecting components of the application using events "	^super eventHandlersSpec, #(		#( #applicationWindow			#( #built #windowBuilt )			#( #opened #windowOpened )			# (#closed #windowClosed ) 			)		)</body></methods><methods><class-id>Examples.IRandomNumberGeneratorPointer</class-id> <category>interface operations</category><body package="Com- Ole Examples">LowerBound: resultReference		" Invoke the IRandomNumberGenerator::LowerBound function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #LONG.	hresult := self invokeLowerBound: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole Examples">Next: resultReference		" Invoke the IRandomNumberGenerator::Next function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #LONG.	hresult := self invokeNext: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole Examples">Seed: resultReference		" Invoke the IRandomNumberGenerator::Seed function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #LONG.	hresult := self invokeSeed: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole Examples">UpperBound: resultReference		" Invoke the IRandomNumberGenerator::UpperBound function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #LONG.	hresult := self invokeUpperBound: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>Examples.IRandomNumberGeneratorPointer class</class-id> <category>class initialization</category><body package="Com- Ole Examples">initialize	self iid: (GUID				fromBytes: #[16rA0 16rA0 16rC 16r11 16rA0 16rDF 16r1C 16r10 16r90 16r29 4 2 16r24 0 16r78 2]).	" '{110CA0A0-DFA0-101C-9029-040224007802}' asGUID "	self updateAndRegister</body></methods><methods><class-id>Examples.COMPDOTestDriver</class-id> <category>subclass-configuring trace options</category><body package="Com- Ole Examples">setTestTraceOptionsForIID: anIID bindingType: aBindingType	" Set the trace options to watch function invocations of the interface identified by &lt;anIID&gt; through the connection type &lt;aBindingType&gt;.  Answer an action which when evaluated will restore the original trace settings. "	anIID = IID_IDataObject		ifTrue: [			^self setTestTraceOptions: COMTraceManager callinAndCalloutTraceOptions 				forIID: IID_IDataObject ].	^super setTestTraceOptionsForIID: anIID bindingType: aBindingType</body></methods><methods><class-id>Examples.COMPDOTestDriver</class-id> <category>test cases</category><body package="Com- Ole Examples">testIDataObjectCopyToClipboard	" This is a simple test case to demonstrate copying an object which supports IDataObject onto the clipboard.  In this case, we prove it worked by getting the String rendering back. "	| anIDataObject thePDO clipboardDataObject clipboardString |	self logTestCaseDescription: 'COM Persistent Data Object Clipboard Test (IDataObject)'.	anIDataObject := self testInterface.	thePDO := anIDataObject implementingObject controllingUnknown implementingObject.  " oh my "		" we have to work harder in this case because the PDO uses aggregation to expose its IDataObject "	log nextPutAll: 'Clipboard contents before starting test:'; cr.	Win32ClipboardInterface current 		clear;		setString: 'Clear clipboard contents at start of PDO test'.	log tab; nextPutAll: Win32ClipboardInterface current getString; cr; cr.	[	log		nextPutAll: '*** Copy a persistent data object to the clipboard ***'; cr; cr;		nextPutAll: thePDO descriptionString; cr.	anIDataObject copyToClipboard.	log nextPutAll: '...done'; cr; cr.	log nextPutAll: '*** Get String rendering of the clipboard contents ***'; cr; cr.	clipboardDataObject := IDataObject getClipboardObject.	[ clipboardString := clipboardDataObject renderFormat: 'String' ]		ensure: [ clipboardDataObject enforceRelease ].	log		nextPutAll: ( clipboardString isNil			ifTrue: [ '****ERROR: clipboard does not contain a string?! (nil was obtained)' ]			ifFalse: [ clipboardString ] ); cr.	] ensure: [  " make sure we clean out the clipboard to release the DTO when we're done "		log nextPutAll: 'Clipboard contents at end of test:'; cr.		Win32ClipboardInterface current 			clear;			setString: 'Reset clipboard contents at end of PDO test'.		log tab; nextPutAll: Win32ClipboardInterface current getString; cr; cr.		].	self logTestCompletion.</body></methods><methods><class-id>Examples.COMPDOTestDriver class</class-id> <category>subclass-accessing</category><body package="Com- Ole Examples">subjectClass	" Answer the COM object implementation class exercised by the receiver. "	^COMPersistentDataObject</body></methods><methods><class-id>Examples.COMPDOTestDriver class</class-id> <category>test cases</category><body package="Com- Ole Examples">testCopyToClipboard	" This is a simple test case to demonstrate copying an object which supports IDataObject onto the clipboard.  In this case, we prove it worked by getting the String rendering back. "	" COMPDOTestDriver testCopyToClipboard "	self testInterface: IDataObject 		bindingType: #externalLocal		perform: #testIDataObjectCopyToClipboard.</body></methods><methods><class-id>Examples.COMPDOTestDriver class</class-id> <category>checklists</category><body package="Com- Ole Examples">checkListTestCases	" enable/disable tracing during test execution "	COMPDOTestDriver displayTrace: true.	COMPDOTestDriver displayTrace: false.	" Verify that there are no COM resources left lying around after running test cases "	COMPDOTestDriver checkCOMResources.	COMPDOTestDriver testCopyToClipboard.</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>private-initializing</category><body package="Com- Ole Examples">allocateDataObject	" Private - allocate the aggregated data transfer object which supports IDataObject for the receiver. "	" IDataObject is exposed by aggregation of a data transfer object which itself uses an adaptor binding "	innerUnknownDO := self createDataObject.</body><body package="Com- Ole Examples">createDataObject		" Private - answer the inner IUnknown of a data transfer object		which will be contained within this aggregate object so that its		IDataObject interface can be exposed by the aggregate. "	" This method demonstrates how to create an inner object 		of an aggregate when the object is implemented locally		as a Smalltalk COM object.  If we were creating an existing		COM object from some other application as an inner object, 		this method would simply look like the following:	^IClassFactory createInstance: &lt;clsid&gt;		iid: IID_IUnknown		controllingUnknown: self controllingUnknown	"	| aDataObject |	aDataObject := ( COMDataTransferObject forControllingUnknown: self controllingUnknown )		addRendering: self descriptionString 			format: IDataObject cfStringName;		yourself.	" explicitly reference count the inner object which we reuse as an aggregate "		" Implementation note: we need to increment the aggregated object's		reference count here when directly instantiating a locally-implemented		object.  This is not necessary when the inner object is created		using its class factory, which by definition always returns a separately 		reference counted inner IUnknown to the creator. "	^aDataObject innerUnknown</body><body package="Com- Ole Examples">createIPersistStorage	" Private - answer a new IPersistStorage interface for the receiver.  Use an adaptor binding of the interface to handle name conflicts with IPersistFile operations. "	^IPersistStorage on: self		selectors: self standardIUnknownSelectors, #(			"-- IPersist -- "			#GetClassID: 			"-- IPersistStorage --"			#IsDirty  " map this onto the same implementation as IPersistFile::IsDirty "			#storageInitNew:			#storageLoad:			#storageSave:_:   " standard selector also used by IPersistFile, so we *must* remap it "			#storageSaveCompleted: 			#storageHandsOffStorage )</body><body package="Com- Ole Examples">createIPersistStream	" Private - answer a new IPersistStream interface for the receiver.  Use an adaptor binding of the interface to handle name conflicts with IPersistFile operations. "	^IPersistStream on: self		selectors: self standardIUnknownSelectors, #(			"-- IPersist -- "			#GetClassID: 			"-- IPersistStorage --"			#IsDirty  " map this onto the same implementation as IPersistFile::IsDirty "			#streamLoad:			#streamSave:_:   " standard selector also used by IPersistFile, so we *must* remap it "			#streamGetSizeMax: )</body><body package="Com- Ole Examples">updateRendering	" Private - update the rendering value when the receiver's state has been changed. "	" Note that this is unnecessarily inefficient when loading from persisted state, in		which case the following is more easily accomplished by simply deferring allocation		of the inner object for IDataObject until that interface is requested by a client, rather 		than aggressively pre-allocating the interface when the object is first created. "	self 		releaseDataObject;		allocateDataObject.</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>private-accessing</category><body package="Com- Ole Examples">backingStorage	^backingStorage</body><body package="Com- Ole Examples">currentFileName	^currentFileName</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>subclass-accessing</category><body package="Com- Ole Examples">createInterfaceForIID: iid	" Private - answer a new instance of the interface identified by the GUID &lt;iid&gt; on the receiver.  Answer nil if the interface is not supported.  This method should be reimplemented by subclasses. "	iid = IID_IPersistFile		ifTrue: [			" use the more efficient direct binding for IPersistFile because we will implement it completely "			^IPersistFile directBindingOn: self ].	" configurable interface bindings are used for these guys to handle name space collisions "	iid = IID_IPersistStorage		ifTrue: [ ^self createIPersistStorage ].	iid = IID_IPersistStream		ifTrue: [ ^self createIPersistStream ].	" because we support IDataObject by using aggregation to directly expose 		the interface of an inner object, we don't hook that up here.		See #getInnerObjectInterfaceForIID: for inner object QueryInterface hookup "	^super createInterfaceForIID: iid</body><body package="Com- Ole Examples">getInnerObjectInterfaceForIID: iid	" Private - answer a separate reference to the interface identified by the GUID &lt;iid&gt; of an inner object which is to be directly exposed to clients as an interface of the controlling object of an aggregate.  Answer nil there is no such interface. "    " Note that the controlling object of an aggregate which directly        exposes interfaces of an contained object must query the        inner IUnknown of the aggregated object by reimplementing        this method.  In contrast, recall that the usual implementation        of QueryInterface support for interfaces implemented directly        by the receiver is done by reimplementing #getInterfaceForIID:.        If aggregated objects are queried there, however, double        reference counting on the controlling object will result.        Consequently, the controlling object of an aggregate may        implement its QueryInterface support in two places:        - here in #innerQueryInterface:_: for any interfaces            of contained objects which are directly exposed to clients        - in the usual #getInterfaceForIID: for any interfaces            implemented directly by the controlling object		or which are cached references to interfaces obtained		from an inner object which are released with the inner object. "	iid = IID_IDataObject		ifTrue: [			| myOriginalReferenceCount anIDataObject |			innerUnknownDO isNil				ifTrue: [ self allocateDataObject ].			" observe that it is the containing object of the aggregate				which is reference counted, not the inner object. "			myOriginalReferenceCount := self referenceCount.			anIDataObject := innerUnknownDO queryInterface: IID_IDataObject.			Assert isEqual: self referenceCount to: ( myOriginalReferenceCount + 1 ).			Assert isEqual: innerUnknownDO implementingObject referenceCount to: 1.			^anIDataObject ].	^super getInnerObjectInterfaceForIID: iid</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>accessing</category><body package="Com- Ole Examples">dateCreated	" Answer the date and time on which the receiver was created. "	^dateCreated</body><body package="Com- Ole Examples">descriptionString	" Answer a string which describes the receiver. "	| aStream |	aStream := ReadWriteStream on: ( String new: 64 ).	super printOn: aStream.	aStream cr; tab; nextPutAll: 'Created on: '.	self dateCreated printOn: aStream.	aStream cr; tab; nextPutAll: 'Created by: '; nextPutAll: self systemDescription; cr.	aStream 		cr; 		nextPutAll: 'Saved State Attributes:'; cr;		tab; nextPutAll: 'IsDirty: '; nextPutAll: isDirty printString; cr;		tab; nextPutAll: 'CurFile: ', ( currentFileName isNil			ifTrue: [ '(none)' ]			ifFalse: [ currentFileName ] ); cr.	^aStream contents</body><body package="Com- Ole Examples">isDirty	" Answer the whether the receiver has changed since it was saved. "	^isDirty</body><body package="Com- Ole Examples">systemDescription	" Answer the description of the system on which the receiver was created. "	^systemDescription</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>private-persistence</category><body package="Com- Ole Examples">fileNewFile: aFileName	" Private - answer a stream on the file named &lt;aFileName&gt; or nil. "	^[ aFileName asFilename newReadWriteStream ]		on: Error		do: [ :ex | ex return: nil ]</body><body package="Com- Ole Examples">filePathNameReadOnly: aFileName storageMode: dwMode	" Private - answer a stream on the file named &lt;aFileName&gt; or nil. "	^[ aFileName asFilename readStream ]		on: Error		do: [ :ex | ex return: nil ]</body><body package="Com- Ole Examples">loadFromStorage: anIStorage	" Private - load the receiver's state from &lt;anIStorage&gt;.  Answer whether successful. "	| aCreationDate aCreatorDescription anIStream  |	" verify that this is really our stuff "	anIStorage readCLSID ~= self class clsid		ifTrue: [ ^false ].	[ anIStream := anIStorage openStreamReadOnly: 'CreateDate' ]		on: COMError		do: [ :ex | ex return: nil ].	anIStream isNil		ifTrue: [ ^false ].	aCreationDate := anIStream asCharacterStream contents.	aCreationDate := Timestamp readFrom: aCreationDate readStream.	[ anIStream := anIStorage openStreamReadOnly: 'Creator' ]		on: COMError		do: [ :ex | ex return: nil ].	anIStream isNil		ifTrue: [ ^false ].	aCreatorDescription := anIStream asCharacterStream contents.	anIStream enforceRelease.	dateCreated := aCreationDate.	systemDescription := aCreatorDescription.	^true</body><body package="Com- Ole Examples">loadFromStream: anIStream	" Private - load the receiver's state from &lt;anIStream&gt;.  Answer whether successful. "	| aStream |	aStream := anIStream asCharacterStream.	" doesn't seem like we should have to fiddle with position here, but there you have it "	"Assert isTrue: [ aStream position = GUID sizeInBytes ]."  " from CLSID, in this case "	aStream position: anIStream position.	^self loadStateAsTextFrom: aStream</body><body package="Com- Ole Examples">loadFromTextStream: aStream	" Private - load the receiver's state from &lt;aStream&gt;.  Answer whether successful. "	| aToken aCLSID |	aToken := aStream upTo: self tagTerminator.	aToken = 'CLSID'		ifFalse: [ ^false ].	"Assert isEqual:" aStream next "to: Character space".	aToken := aStream upTo: Character cr.	aCLSID := GUID fromString: aToken.	aCLSID = self class clsid		ifFalse: [ ^false ].	^self loadStateAsTextFrom: aStream</body><body package="Com- Ole Examples">loadStateAsTextFrom: aStream	" Private - load the receiver's state on &lt;aStream&gt;.  Answer whether successful. "	| aToken aCreationDate aCreatorDescription |	aToken := aStream upTo: self tagTerminator.	aToken = self tagCreated		ifFalse: [ ^false ].	"Assert isEqual: aStream next to: Character space."	aToken := aStream upTo: Character cr.	aCreationDate := Timestamp readFrom: aToken readStream. 	aToken := aStream upTo: self tagTerminator.	aToken = self tagCreator		ifFalse: [ ^false ].	"Assert isEqual: aStream next to: Character space."	aToken := aStream upTo: Character cr.	aCreatorDescription := aToken.	dateCreated := aCreationDate.	systemDescription := aCreatorDescription.	^true</body><body package="Com- Ole Examples">saveStateAsTextOn: aStream	" Private - save the receiver's state on &lt;aStream&gt;. "	aStream		nextPutAll: self tagCreated;		nextPut: self tagTerminator;		space;		nextPutAll: ((Locale named: #C) printAsTime: self dateCreated policyNamed: #short);		cr;		nextPutAll: self tagCreator;		nextPut: self tagTerminator;		space;		nextPutAll: self systemDescription;		cr</body><body package="Com- Ole Examples">saveToStorage: anIStorage	" Private - save the receiver's state in &lt;anIStorage&gt;. "	| anIStream |	" the CLSID is already stamped on this storage "	anIStream := anIStorage newStream: 'CreateDate'.	anIStream asCharacterStream		nextPutAll: self dateCreated printString.	anIStream := anIStorage newStream: 'Creator'.	anIStream asCharacterStream		nextPutAll: self systemDescription.</body><body package="Com- Ole Examples">saveToStream: anIStream	" Private - save the receiver's state on &lt;anIStream&gt;. "	| aStream |	aStream := anIStream asCharacterStream.	" doesn't seem like we should have to fiddle with position here, but there you have it "	"Assert isTrue: [ aStream position = GUID sizeInBytes ]."  " from CLSID, in this case "	aStream position: anIStream position.	self saveStateAsTextOn: aStream.</body><body package="Com- Ole Examples">saveToTextStream: aStream	" Private - save the receiver's state on &lt;aStream&gt;. "	aStream nextPutAll: 'CLSID: ', self class clsid asString; cr.	self saveStateAsTextOn: aStream.</body><body package="Com- Ole Examples">tagCreated	" Private "	^'Created'</body><body package="Com- Ole Examples">tagCreator	" Private "	^'Creator'</body><body package="Com- Ole Examples">tagTerminator	" Private - answer the character which terminates a tag mark in the stream. "	^$:</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>subclass-initializing</category><body package="Com- Ole Examples">initialize	" Private - initialize the receiver. "	dateCreated := Timestamp now.	systemDescription := Smalltalk version.	isDirty := true.	super initialize.</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>private-IPersist operations</category><body package="Com- Ole Examples">GetClassID: resultReference	" Private - Implement the IPersist::GetClassID operation.  Return the CLSID of the receiver's COM object class. "	resultReference value: self class clsid.	^S_OK</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>private-IPersistFile operations</category><body package="Com- Ole Examples">GetCurFile: resultReference	" Private - Implement the IPersistFile::GetCurFile function.  Return the currently associated file name or the default file save prompt. "	resultReference value:  ( currentFileName notNil		ifTrue: [ currentFileName ]		ifFalse: [  " default file save prompt "			Filename defaultDirectory construct: 'Untitled.pdo' ] ).	^S_OK</body><body package="Com- Ole Examples">IsDirty	" Private - Implement the IPersistFile::IsDirty operation.  Return a status code indicating whether the receiver has changed since it was last saved. "	^self isDirty		ifTrue: [ S_OK ]		ifFalse: [ S_FALSE ]</body><body package="Com- Ole Examples">Load: aFileName _: dwMode	" Private - Implement the IPersistFile::Load operation.  Load the receiver from the persisted state in the file specified by the absolute pathname &lt;aFileName&gt;.  Open the file in the storage mode requested by the caller if we deem this to be suitable. "	| aFileStream loadSucceeded |	"Assert isNil: backingStorage."	aFileStream := self filePathNameReadOnly: aFileName 		storageMode: dwMode.	aFileStream isNil		ifTrue: [ ^E_FAIL ].	loadSucceeded := self loadFromTextStream: aFileStream.	"?? aFileStream atEnd ifFalse: [ ^E_FAIL ]. ??"	aFileStream close.	loadSucceeded		ifFalse: [ ^E_FAIL ].	currentFileName := aFileName.	self updateRendering.	isDirty := false.	^S_OK</body><body package="Com- Ole Examples">Save: aPathName _: fRemember	" Private - Implement the IPersistFile::Save function. "	| filePathName aFileStream |	filePathName := ( aPathName isNil		ifTrue: [ currentFileName ]		ifFalse: [ aPathName ] ).	filePathName isNil		ifTrue: [ ^E_FAIL ].	aFileStream := self fileNewFile: filePathName.	aFileStream isNil		ifTrue: [ ^E_FAIL ].	self saveToTextStream: aFileStream.	aFileStream close.	isDirty := false.	( aPathName notNil and: [ fRemember ] )		ifTrue: [ currentFileName := aPathName ].	^S_OK</body><body package="Com- Ole Examples">SaveCompleted: aPathName	" Private - Implement the IPersistFile::SaveCompleted function. "	^S_OK</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>subclass-releasing</category><body package="Com- Ole Examples">releaseInnerObjects	" Private - release any inner objects owned by the receiver. "	self releaseDataObject.	super releaseInnerObjects.</body><body package="Com- Ole Examples">releaseResources	" Private - release resources associated with the receiver. "	self releaseBackingStorage.	super releaseResources.</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>private-IPersistStorage operations</category><body package="Com- Ole Examples">storageHandsOffStorage	" Private - Implement the IPersistFile::HandsOffStorage function. "	self releaseBackingStorage.	^S_OK</body><body package="Com- Ole Examples">storageInitNew: anIStorage	" Private - Implement the IStorage::InitNew function. "	"Assert isNil: currentFileName."	backingStorage notNil		ifTrue: [ ^CO_E_ALREADYINITIALIZED ].	" verify that we have a new, empty storage to work with "	anIStorage elementNames &gt; 0		ifTrue: [ ^E_FAIL ].	" we don't actually need to keep this guy around, but we demonstrate the approach for when you do "	backingStorage := anIStorage.	^S_OK</body><body package="Com- Ole Examples">storageLoad: anIStorage	" Private - Implement the IStorage::Load function. "	"Assert isNil: currentFileName."	backingStorage notNil		ifTrue: [ ^CO_E_ALREADYINITIALIZED ].	( self loadFromStorage: anIStorage )		ifFalse: [ ^E_FAIL ].	" we don't actually need to keep this guy around, but we demonstrate the approach for when you do "	backingStorage := anIStorage.	self updateRendering.	isDirty := false.	^S_OK</body><body package="Com- Ole Examples">storageSave: anIStorage _: sameAsLoad	" Private - Implement the IStorage::Save function.  Note that the receiver does not write its CLSID to the stream; that is the responsibility of the caller. "	self saveToStorage: anIStorage.	isDirty := false.	^S_OK</body><body package="Com- Ole Examples">storageSaveCompleted: anIStorage	" Private - Implement the IStorage::SaveCompleted function. "	anIStorage notNil		ifTrue: [			backingStorage := anIStorage ].	^S_OK</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>private-IPersistStream operations</category><body package="Com- Ole Examples">streamGetSizeMax: resultReference	" Private - Implement the IPersistStream:: GetSizeMax operation. "	| estCharCount |	estCharCount := 		self tagCreated size + 2 + self dateCreated printString size		+ self tagCreator size + 2 + self systemDescription size		+ 4.  " conservative estimate of CR/LF externalization "	resultReference value: estCharCount * 2.  " double for worst-case Unicode encoding "	^S_OK</body><body package="Com- Ole Examples">streamLoad: anIStream	" Private - Implement the IPersistStream::Load operation.  Load the receiver from the persisted state in &lt;anIStream&gt;.  "	"Assert isNil: currentFileName."	"Assert isNil: backingStorage."	( self loadFromStream: anIStream )		ifFalse: [ ^E_FAIL ].	self updateRendering.	isDirty := false.	^S_OK</body><body package="Com- Ole Examples">streamSave: anIStream _: fClearDirty	" Private - Implement the IPersistStream::Save operation.  Save the receiver onto &lt;anIStream&gt;.  Note that the receiver does not write its CLSID to the stream; that is the responsibility of the caller.  "	self saveToStream: anIStream.	fClearDirty		ifTrue: [ isDirty := false ].	^S_OK</body></methods><methods><class-id>Examples.COMPersistentDataObject</class-id> <category>private-releasing</category><body package="Com- Ole Examples">releaseBackingStorage	" Private - release the IStorage associated with an active instance of the receiver loaded through IPersistStorage. "	backingStorage := nil.</body><body package="Com- Ole Examples">releaseDataObject	" Private - release the data object which supports IDataObject for the receiver. "	innerUnknownDO notNil		ifTrue: [  " release the inner object carefully to avoid any release cycles "			innerUnknownDO := nil. ].</body></methods><methods><class-id>Examples.COMPersistentDataObject class</class-id> <category>session management</category><body package="Com- Ole Examples">startUpApplication        " Start up a COM object server application constructed to publish the COM persistent data object class.  Tracing support is included to demonstrate tracing and debugging of a runtime configuration.  Note that activation of this tracing capability requires that the COM trace support be included in the deployed configuration, which is not the standard deployment configuration; it is an optional technique, generally employed to facilitate debugging. "	" log application activity to a trace log if trace support is installed in a runtime configuration "	COMSessionManager activateRuntimeTracing.	"Initialize COM and verify that the application is being run as an object server."	COMSessionManager initializeObjectServer.	"Register the class factory for the object server application."	self registerServerClassFactory.	"Arrange for server application termination "	COMSessionManager exitIfNotInUse: true.</body></methods><methods><class-id>Examples.COMPersistentDataObject class</class-id> <category>installation</category><body package="Com- Ole Examples">installComponent	" Install the COM persistent data object "	COMSystem current when: #deploymentStartup		send: #startUpApplication to: self.</body><body package="Com- Ole Examples">removeComponent	" Remove the COM persistent data object "	COMSystem current removeAllActionsWithReceiver: self.</body></methods><methods><class-id>Examples.COMPersistentDataObject class</class-id> <category>class initialization</category><body package="Com- Ole Examples">initialize	self clsid: " '{9CB9A3A0-BBB9-11D0-843E-444553540000}' asGUID "	( GUID fromBytes: #[ 16rA0 16rA3 16rB9 16r9C 16rB9 16rBB 16rD0 16r11 16r84 16r3E 16r44 16r45 		16r53 16r54 0 0 ] ).</body></methods><methods><class-id>Examples.IRandomNumberGeneratorImplementation</class-id> <category>interface operations</category><body package="Com- Ole Examples">LowerBound: resultReference		" Invoke the IRandomNumberGenerator::LowerBound function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor LowerBound: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole Examples">Next: resultReference		" Invoke the IRandomNumberGenerator::Next operation.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Next: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole Examples">Seed: resultReference		" Invoke the IRandomNumberGenerator::Seed operation.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Seed: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole Examples">SetLowerBound: anInteger		" Invoke the IRandomNumberGenerator::SetLowerBound function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor SetLowerBound: anInteger		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole Examples">SetSeed: anInteger		" Invoke the IRandomNumberGenerator::SetSeed operation.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor SetSeed: anInteger		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole Examples">SetUpperBound: anInteger		" Invoke the IRandomNumberGenerator::SetUpperBound function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor SetUpperBound: anInteger		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole Examples">UpperBound: resultReference		" Invoke the IRandomNumberGenerator::UpperBound function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor UpperBound: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>Examples.IRandomNumberGeneratorImplementation</class-id> <category>private-invocation</category><body package="Com- Ole Examples">invokeLowerBound: this _: pLowerBound	" Private - invoke the IRandomNumberGenerator::LowerBound function for an external caller. "	" HRESULT LowerBound(            /* [out] */ LONG * pLowerBound); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pLowerBound isValid ifFalse: [^E_INVALIDARG].	self clearScalarResultValueAtAddress: pLowerBound.	resultReference := nil asValueReference.	hresult := implementor LowerBound: resultReference.	hresult succeeded		ifTrue: [self scalarResultAtAddress: pLowerBound put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole Examples">invokeNext: this _: pValue	" Private - invoke the IRandomNumberGenerator::Next function for an external caller. "	" HRESULT Next(            /* [out] */ LONG * pValue); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pValue isValid ifFalse: [^E_INVALIDARG].	self clearScalarResultValueAtAddress: pValue.	resultReference := nil asValueReference.	hresult := implementor Next: resultReference.	hresult succeeded		ifTrue: [self scalarResultAtAddress: pValue put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole Examples">invokeSeed: this _: pSeed	" Private - invoke the IRandomNumberGenerator::Seed function for an external caller. "	" HRESULT Seed(            /* [out] */ LONG * pSeed); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pSeed isValid ifFalse: [^E_INVALIDARG].	self clearScalarResultValueAtAddress: pSeed.	resultReference := nil asValueReference.	hresult := implementor Seed: resultReference.	hresult succeeded		ifTrue: [self scalarResultAtAddress: pSeed put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole Examples">invokeSetLowerBound: this _: lowerBound	" Private - invoke the IRandomNumberGenerator::SetLowerBound function for an external caller. "	" HRESULT SetLowerBound(            /* [in] */ LONG lowerBound); "	^[   " terminate exception stack unwind at external callin boundary "	implementor SetLowerBound: lowerBound.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole Examples">invokeSetSeed: this _: seed	" Private - invoke the IRandomNumberGenerator::SetSeed function for an external caller. "	" HRESULT SetSeed(            /* [in] */ LONG seed); "	^[   " terminate exception stack unwind at external callin boundary "	 implementor SetSeed: seed.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole Examples">invokeSetUpperBound: this _: upperBound	" Private - invoke the IRandomNumberGenerator::SetUpperBound function for an external caller. "	" HRESULT SetUpperBound(            /* [in] */ LONG upperBound); "	^[   " terminate exception stack unwind at external callin boundary "	implementor SetUpperBound: upperBound.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole Examples">invokeUpperBound: this _: pUpperBound	" Private - invoke the IRandomNumberGenerator::UpperBound function for an external caller. "	" HRESULT UpperBound(            /* [out] */ LONG * pUpperBound); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pUpperBound isValid ifFalse: [^E_INVALIDARG].	self clearScalarResultValueAtAddress: pUpperBound.	resultReference := nil asValueReference.	hresult := implementor UpperBound: resultReference.	hresult succeeded		ifTrue: [self scalarResultAtAddress: pUpperBound put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body></methods><methods><class-id>Examples.IRandomNumberGeneratorImplementation class</class-id> <category>parcel load/unload/save</category><body package="Com- Ole Examples">prerequisitesForLoading	^super prerequisitesForLoading		addLast: IRandomNumberGeneratorPointer;		yourself</body></methods><methods><class-id>Examples.IRandomNumberGeneratorImplementation class</class-id> <category>class initialization</category><body package="Com- Ole Examples">initialize	self iid: IRandomNumberGeneratorPointer iid.	"Assert notNil: self iid."	" verify that init order assumptions are correct "	self vtableSignatureTypeName: #__IRandomNumberGeneratorVtbl.	self updateAndRegister</body></methods><methods><class-id>Examples.COMRNGTestDriver</class-id> <category>private-test cases</category><body package="Com- Ole Examples">defaultTestCount	" Answer the number of random values to get in a test run. "	^10</body><body package="Com- Ole Examples">describeFormats: supportedFormats	" Private "	supportedFormats isNil		ifTrue: [			log nextPutAll: (#NotSupported &lt;&lt; #com &gt;&gt; '... not supported') asString; cr.			^self ].	log nextPutAll: ((#x1sFormatsSupportedC &lt;&lt; #com &gt;&gt; '&lt;1s&gt; formats supported:')			expandMacrosWith: supportedFormats size printString); cr.	supportedFormats do: [ :aFormatEtc |		log tab; nextPutAll: aFormatEtc printString ;cr ].	log nextPutAll: (#done &lt;&lt; #com &gt;&gt; '...done') asString; cr.</body><body package="Com- Ole Examples">exerciseRNG: anIRNG count: count	" Private - describe the current state of the RNG and exercise it "	log		nextPutAll: (#CurrentRNGSettingsC &lt;&lt; #com &gt;&gt; 'Current RNG settings:') asString; cr;		tab; nextPutAll: ((#lowerBoundC1s &lt;&lt; #com &gt;&gt; 'lowerBound: &lt;1s&gt;')			expandMacrosWith: anIRNG lowerBound printString); cr;		tab; nextPutAll: ((#upperBoundC1s &lt;&lt; #com &gt;&gt; 'upperBound: &lt;1s&gt;')			expandMacrosWith: anIRNG upperBound printString); cr;		tab; nextPutAll: ((#seedC1s &lt;&lt; #com &gt;&gt; 'seed: &lt;1s&gt;')			expandMacrosWith: anIRNG seed printString); cr.	log 		nextPutAll: ((#Next1sRandomNumbers &lt;&lt; #com &gt;&gt; 'Next &lt;1s&gt; random numbers generated are:')			expandMacrosWith: count printString); cr;		tab.	( ( 1 to: count ) collect: [ :i | anIRNG next ] ) 		do: [ :aNumber | log nextPutAll: aNumber printString ]		separatedBy: [ log space ].	log cr; cr.</body><body package="Com- Ole Examples">testAdviseConnection: anIDataObject	" Private - see if we can establish an advise connection for String formats.  This should fail. "	| aDataFormat anAdviseSink connectionToken |	log nextPutAll: (#EstablishingAdviseConnection &lt;&lt; #com &gt;&gt; 'Attempt to establish an advise connection...') asString; cr.	aDataFormat :=  ( COMStructure classForStructureNamed: #FORMATETC )		formatNamed: IDataObject cfStringName.	" this is utterly bogus, but we don't expect him to look at it anyway... "	anAdviseSink := IAdviseSinkPointer newTemporaryInterfacePointer.	" DAdvise isn't supported, so we expect this to fail "	connectionToken := [		anIDataObject registerAdviseSink: anAdviseSink 			format: aDataFormat 			adviseFlags: ADVF_ONLYONCE 		] on: COMError			do: [ :ex |				log 					nextPutAll: (#DAdviseFailed &lt;&lt; #com &gt;&gt; '***IDataObject::DAdvise failed***') asString; cr;					tab; nextPutAll: ex description; cr;					cr.				ex return: nil ].	connectionToken isNil		ifTrue: [ ^self ].	" good heavens, how did we get here?! "	log nextPutAll: ((#AdviseConnectionTokenC1s &lt;&lt; #com &gt;&gt; 'Advise connection token: &lt;1s&gt;')			expandMacrosWith: connectionToken printString); cr.	log nextPutAll: (#DisconnectingAdviseSink &lt;&lt; #com &gt;&gt; 'Now we''ll disconnect the advise sink') asString; cr.	[ anIDataObject unregisterAdviseSink: connectionToken ]		on: COMError		do: [ :ex |			log nextPutAll: ((#xErrorC1s &lt;&lt; #com &gt;&gt; '***Error: &lt;1s&gt;')			expandMacrosWith: ex description); cr.			ex return ].	log nextPutAll: (#done &lt;&lt; #com &gt;&gt; '...done'); cr; cr.</body><body package="Com- Ole Examples">testGetDataFormats: anIDataObject	" Private - enumerate the supported data formats "	| supportedFormats |	log nextPutAll: (#EnumerateFormatsForData &lt;&lt; #com &gt;&gt; 'Enumerate formats in which we can get data from this object...') asString; cr.	[ supportedFormats := anIDataObject getDataFormats ]		on: COMError		do: [ :ex | 			log nextPutAll: ((#xErrorC1s &lt;&lt; #com &gt;&gt; '***Error: &lt;1s&gt;')					expandMacrosWith: ex description); cr.			^self ].	self describeFormats: supportedFormats.	log cr.</body><body package="Com- Ole Examples">testQueryGetData: anIDataObject	" Private - try IDataObject::QueryGetData "	| aDataFormat supportsFormat |	log nextPutAll: (#TryQueryGetData &lt;&lt; #com &gt;&gt; 'Try IDataObject::QueryGetData (should be unimplemented)...') asString; cr.	aDataFormat := ( COMStructure classForStructureNamed: #FORMATETC )		format: IDataObject cfMetafilePict.	log nextPutAll: ((#Requesting1s &lt;&lt; #com &gt;&gt; '... requesting &lt;1s&gt;')			expandMacrosWith: aDataFormat formatDescription); cr.	supportsFormat := [ anIDataObject hasGetDataFormat: aDataFormat ]		on: COMError		do: [ :ex |			log nextPutAll: ((#xErrorC1s &lt;&lt; #com &gt;&gt; '***Error: &lt;1s&gt;')					expandMacrosWith: ex description); cr.			^nil ].	log tab; nextPutAll: '-&gt; ', supportsFormat printString; cr; cr.</body><body package="Com- Ole Examples">testRNG: count	" Private - exercise a COM RNG object through its IRandomNumberGenerator interface. "	| anIRNG initialLowerBound initialUpperBound |	anIRNG := self testInterface.	initialLowerBound := anIRNG lowerBound.	initialUpperBound := anIRNG upperBound.	log nextPutAll: (#TestWithInitialSettings &lt;&lt; #com &gt;&gt; 'Test with initial settings') asString; cr.	self exerciseRNG: anIRNG count: count.	log nextPutAll: (#TestWithModifiedBounds &lt;&lt; #com &gt;&gt; 'Test with modified bounds...') asString; cr.	anIRNG		setLowerBound: 10;		setUpperBound: 20.	self exerciseRNG: anIRNG count: count.	log nextPutAll: (#TestWithNegativeRange &lt;&lt; #com &gt;&gt; 'Test with negative range...') asString; cr.	anIRNG		setLowerBound: -100;		setUpperBound: -1.	self exerciseRNG: anIRNG count: count.	log nextPutAll: (#TestWithMixedRange &lt;&lt; #com &gt;&gt; 'Test with mixed positive/negative range...') asString; cr.	anIRNG		setLowerBound: -100;		setUpperBound: 100.	self exerciseRNG: anIRNG count: count.	log nextPutAll: (#TestBoundsAndSeedValue &lt;&lt; #com &gt;&gt; 'Test with initial bounds settings and modified seed value...') asString; cr.	anIRNG		setSeed: 20;		setLowerBound: initialLowerBound;		setUpperBound: initialUpperBound.	self exerciseRNG: anIRNG count: count.</body><body package="Com- Ole Examples">testSetDataFormats: anIDataObject	" Private - enumerate the supported data formats "	| supportedFormats |	log nextPutAll: (#EnumerateFormatsForObject &lt;&lt; #com &gt;&gt; 'Enumerate formats in which we can set data to this object...') asString; cr.	[ supportedFormats := anIDataObject setDataFormats ]		on: COMError		do: [ :ex | 			log nextPutAll: ((#xErrorC1s &lt;&lt; #com &gt;&gt; '***Error: &lt;1s&gt;')			expandMacrosWith: ex description); cr.			^self ].	self describeFormats: supportedFormats.	log cr.</body></methods><methods><class-id>Examples.COMRNGTestDriver</class-id> <category>test cases</category><body package="Com- Ole Examples">testIDataObject	" Test the IDataObject interface functions. "	| anIDataObject |	anIDataObject := self testInterface.	self logTestCaseDescription: (#GenKey21 &lt;&lt; #com &gt;&gt; 'Testing a COM Random Number Generator') asString.	log nextPutAll: (#GenKey18 &lt;&lt; #com &gt;&gt; 'Test IDataObject::DAdvise (not supported)') asString; cr.	self testAdviseConnection: anIDataObject.	log nextPutAll: (#GenKey17 &lt;&lt; #com &gt;&gt; 'Test IDataObject:: EnumFormatEtc (0 get, no set)') asString; cr.	self testGetDataFormats: anIDataObject.	self testSetDataFormats: anIDataObject.		self logTestCompletion."Test case development notes:	IDataObject describeInterfaceFunctions"</body><body package="Com- Ole Examples">testRNG	" Test the IRandomNumberGenerator interface functions. "	self logTestCaseDescription: (#GenKey21 &lt;&lt; #com &gt;&gt; 'Testing a COM Random Number Generator') asString.	self testRNG: self defaultTestCount.	self logTestCompletion.</body></methods><methods><class-id>Examples.COMRNGTestDriver class</class-id> <category>test cases</category><body package="Com- Ole Examples">testExternalLocalIDataObject	" Test case to exercise the COM random number generator's IDataObject interface through an external interface binding to a local object. "	" COMRNGTestDriver testExternalLocalIDataObject "	self testInterface: IDataObject 		bindingType: #externalLocal		perform: #testIDataObject.</body><body package="Com- Ole Examples">testExternalLocalRNG	" Test case to exercise the COM random number generator through an external interface binding to a local object. "	" COMRNGTestDriver testExternalLocalRNG "	self testInterface: IRandomNumberGenerator 		bindingType: #externalLocal		perform: #testRNG.</body><body package="Com- Ole Examples">testExternalServerRNG	" Test case to exercise the COM random number generator through an external interface binding to an object is a separate server process. "	" COMRNGTestDriver testExternalServerRNG "	" this test case configuration requires that you build and install 		an object server application for the RNG class, including		registering marshalling support for the IRandomNumberGenerator		interface to enable cross-process function invocation.  		This capability is not provided with this sample "	self error: #ErrNotSupported &lt;&lt; #com &gt;&gt; 'not supported'</body><body package="Com- Ole Examples">testInternalIDataObject	" Test case to exercise the COM random number generator's IDataObject interface through an internal interface binding to a local object. "	" COMRNGTestDriver testInternalIDataObject "	self testInterface: IDataObject 		bindingType: #internalLocal		perform: #testIDataObject.</body><body package="Com- Ole Examples">testInternalRNG	" Test case to exercise the COM random number generator through an internal interface binding to a local object. "	" COMRNGTestDriver testInternalRNG "	self testInterface: IRandomNumberGenerator 		bindingType: #internalLocal		perform: #testRNG.</body></methods><methods><class-id>Examples.COMRNGTestDriver class</class-id> <category>subclass-accessing</category><body package="Com- Ole Examples">subjectClass	" Answer the COM object implementation class exercised by the receiver. "	^COMRandomNumberGeneratorObject</body></methods><methods><class-id>Examples.COMRNGTestDriver class</class-id> <category>checklists</category><body package="Com- Ole Examples">checkListTestCases	" enable/disable tracing during test execution "	COMPDOTestDriver displayTrace: true.	COMPDOTestDriver displayTrace: false.	" Verify that there are no COM resources left lying around after running test cases "	COMRNGTestDriver checkCOMResources.	" test the IRandomNumberGenerator functions "	COMRNGTestDriver testInternalRNG.	COMRNGTestDriver testExternalLocalRNG.	" external server session  not supported (RNG not published as object server application) "	" test the IDataObject functions "	COMRNGTestDriver testInternalIDataObject.	COMRNGTestDriver testExternalLocalIDataObject.</body></methods><methods><class-id>Examples.COMRandomNumberGenerator</class-id> <category>accessing</category><body package="Com- Ole Examples">lowerBound		" Answer the receiver's lower bound value. "	^lowerBound</body><body package="Com- Ole Examples">lowerBound: aNumber		" Set the receiver's lower bound value. "	lowerBound := aNumber.</body><body package="Com- Ole Examples">next		" Answer the next random number in the sequence. "	^self computeNextValue</body><body package="Com- Ole Examples">seed		" Answer the receiver's seed value. "	^seed</body><body package="Com- Ole Examples">seed: anInteger		" Set the receiver's seed value. "	seed := anInteger.	self initializeRanList.</body><body package="Com- Ole Examples">upperBound		" Answer the receiver's upper bound value. "	^upperBound</body><body package="Com- Ole Examples">upperBound: aNumber		" Set the receiver's upper bound value. "	upperBound := aNumber.</body></methods><methods><class-id>Examples.COMRandomNumberGenerator</class-id> <category>private-operation</category><body package="Com- Ole Examples">computeNextValue		" Private - compute the next value in the sequence. "	| aNumber nextValue |	aNumber := ( ( ranList at: i ) + ( ranList at: j ) )		rem: self modulus.	aNumber &lt; 0		ifTrue: [ aNumber := aNumber + self modulus ].	ranList at: i put: aNumber.	i := i - 1.	( i = 0 ) ifTrue: [ i := ranList size ].	j := j - 1.	( j = 0 ) ifTrue: [ j := ranList size ].	aNumber := ( aNumber / self modulus ) asFloat.	nextValue := aNumber * ( self upperBound - self lowerBound )		+ self lowerBound.	( self lowerBound isInteger and: [ self upperBound isInteger ] )		ifTrue: [ nextValue := nextValue truncated ].	^nextValue</body></methods><methods><class-id>Examples.COMRandomNumberGenerator</class-id> <category>private-initializing</category><body package="Com- Ole Examples">initialize	" Private - initialize a new instance. "	self 		lowerBound: 1;  "0.0"		upperBound: 100;  "1.0"		modulus: 32767.	" install a random initial value for the seed "	self seed: Time now asSeconds.</body><body package="Com- Ole Examples">initializeRanList		" Private - initialize the ranList for the current RNG settings. "	| count aNumber allEven |	count := 17.	aNumber := self seed.	allEven := true.	ranList := Array new: count.	[ allEven ]		whileTrue: [			1 to: count do: [ :k |				aNumber := ( ( aNumber * 2743 ) + 5923 )					rem: self modulus.				aNumber &lt; 0					ifTrue: [ aNumber := aNumber + self modulus ].				( aNumber / 2 ) isInteger					ifTrue: [ allEven := false ].				ranList at: k put: aNumber ].			].	i := count.	j := 5.</body></methods><methods><class-id>Examples.COMRandomNumberGenerator</class-id> <category>private-accessing</category><body package="Com- Ole Examples">modulus		" Private - answer the modulus. "	^modulus</body><body package="Com- Ole Examples">modulus: anInteger		" Private - set the modulus. "	modulus := anInteger.</body></methods><methods><class-id>Examples.COMRandomNumberGenerator class</class-id> <category>instance creation</category><body package="Com- Ole Examples">new	" Answer a new instance of the receiver. "	^super new initialize</body></methods><methods><class-id>Examples.IRandomNumberGenerator</class-id> <category>civilized interface operations</category><body package="Com- Ole Examples">lowerBound		" Answer the lower bound value of the random number generator. "	| resultReference |	resultReference := nil asValueReference.	interface LowerBound: resultReference.	^resultReference value</body><body package="Com- Ole Examples">next		" Generate a random number in the range of the 		receiver's [lower..upper] bound and answer the value. "	| resultReference |	resultReference := nil asValueReference.	interface Next: resultReference.	^resultReference value</body><body package="Com- Ole Examples">seed		" Answer the seed value of the random number generator. "	| resultReference |	resultReference := nil asValueReference.	interface Seed: resultReference.	^resultReference value</body><body package="Com- Ole Examples">setLowerBound: anInteger		" Set the random number generator's lower bound. "	^interface SetLowerBound: anInteger</body><body package="Com- Ole Examples">setSeed: anInteger		" Set the random number generator's seed. "	^interface SetSeed: anInteger</body><body package="Com- Ole Examples">setUpperBound: anInteger		" Set the random number generator's upper bound. "	^interface SetUpperBound: anInteger</body><body package="Com- Ole Examples">upperBound		" Answer the upper bound value of the random number generator. "	| resultReference |	resultReference := nil asValueReference.	interface UpperBound: resultReference.	^resultReference value</body></methods><methods><class-id>Examples.IRandomNumberGenerator class</class-id> <category>parcel load/unload/save</category><body package="Com- Ole Examples">prerequisitesForLoading	^super prerequisitesForLoading		addLast: IRandomNumberGeneratorImplementation;		yourself</body></methods><methods><class-id>Examples.IRandomNumberGenerator class</class-id> <category>class initialization</category><body package="Com- Ole Examples">initialize	self iid: IRandomNumberGeneratorPointer iid.	self updateAndRegister</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject</class-id> <category>subclass-initializing</category><body package="Com- Ole Examples">initialize	" Private - initialize a new instance. "	rng := COMRandomNumberGenerator new.	super initialize.</body><body package="Com- Ole Examples">initializeInterfaces	" Private - Allocate any interfaces which are expected to be required during the object's lifetime.  Invoke the superclass method to ensure that the inner IUnknown is allocated. "	super initializeInterfaces.	" pre-allocation of supported interfaces at object creation time		is done by reimplementing this method.  Allocation		during initialization is a good strategy for interfaces which		are known to be required during the object's lifetime.		Interfaces which may not be requested can be supported		by a lazy allocation strategy, typically implemented 		in #getInterfaceForIID: "	iRandomNumberGenerator := IRandomNumberGenerator directBindingOn: self.</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject</class-id> <category>subclass-enumerating</category><body package="Com- Ole Examples">allocatedInterfacesDo: aOneArgBlock	" Private - enumerate the interfaces supported by the receiver which have been allocated during its lifetime and evaluate &lt;aOneArgBlock&gt; with each. "	super allocatedInterfacesDo: aOneArgBlock.	iRandomNumberGenerator notNil		ifTrue: [ aOneArgBlock value: iRandomNumberGenerator ].	iDataObject notNil		ifTrue: [ aOneArgBlock value: iDataObject ].</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject</class-id> <category>private-initializing</category><body package="Com- Ole Examples">createIDataObject	" Private - answer a new IDataObject interface on the receiver. "	" The IDataObject interface supported on an RNG demonstrates		configuring the interface binding when the receiver		only implements a few of the functions in the interface.		In fact, this object does not support any useful functionality		for IDataObject at all, but then this is just a example so we can		do silly things solely for pedagogical reasons. "	| anIDataObject |	anIDataObject := IDataObject on: self.	anIDataObject functionAdaptor		" configure messages sent to a different object "		installMinimumDispatchHandlers; 			" ( the function binding will simply answer E_NOTIMPL for everything ) "		" configure processing for functions that I really do implement "		when: #EnumFormatEtc			send: #EnumFormatEtc:_: to: self;		" configure processing for functions that don't need a whole method "		when: #DAdvise			evaluate: [ :aFormatEtc :advf :anAdviseSink :resultReference |				" DAdvise: aFormatEtc _: advf _: anAdviseSink _: resultReference "					" Create an advise connnection between the data transfer object					and an advise sink which is informated when the object's 					data changes.  Answer the result code. "				OLE_E_ADVISENOTSUPPORTED ];		yourself.	^anIDataObject</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject</class-id> <category>private-IDataObject operations</category><body package="Com- Ole Examples">EnumFormatEtc: dwDirection _: resultReference	" Private - implement the IDataObject::EnumFormatEtc function. "	" Create an enumerator to enumerate the formats supported by the receiver. "	| anEnumeratorObject anIEnum |	" this object doesn't allow its state to be set through IDataObject "	dwDirection = DATADIR_SET 		ifTrue: [ ^E_NOTIMPL ]. 	" answer an enumerator which is configured with the FORMATETC		specifications for the get-data formats in which the receiver		will provide data to a client "	" construct any empty enumerator, since this object doesn't		really support any formats at all "	anEnumeratorObject := COMStructureEnumerator forIID: IID_IEnumFORMATETC		elements: #( ).	anIEnum := anEnumeratorObject queryInterface: IID_IEnumFORMATETC.	resultReference value: anIEnum.	^S_OK</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject</class-id> <category>subclass-accessing</category><body package="Com- Ole Examples">getInterfaceForIID: iid	" Private - answer the interface identified by the GUID &lt;iid&gt;.  Answer nil if the requested interface is not supported by the receiver. "	" preallocated interfaces which are always constructed are simply returned "	iid = IRandomNumberGenerator iid		ifTrue: [ ^iRandomNumberGenerator ].	" lazy allocation constructs the supported interface on demand "	iid = IID_IDataObject		ifTrue: [   			iDataObject isNil				ifTrue: [ iDataObject := self createIDataObject ].			^iDataObject ].	^super getInterfaceForIID: iid</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject</class-id> <category>private-IRandomNumberGenerator operations</category><body package="Com- Ole Examples">LowerBound: resultReference	" Private - implement the IRandomNumberGenerator::LowerBound operation. "	resultReference value: rng lowerBound.	^S_OK</body><body package="Com- Ole Examples">Next: resultReference	" Private - implement the IRandomNumberGenerator::Next operation. "	resultReference value: rng next.	^S_OK</body><body package="Com- Ole Examples">Seed: resultReference	" Private - implement the IRandomNumberGenerator::Seed operation. "	resultReference value: rng seed.	^S_OK</body><body package="Com- Ole Examples">SetLowerBound: anInteger	" Private - implement the IRandomNumberGenerator::SetLowerBound operation. "	rng lowerBound: anInteger.	^S_OK</body><body package="Com- Ole Examples">SetSeed: anInteger	" Private - implement the IRandomNumberGenerator::SetSeed operation. "	rng seed: anInteger.	^S_OK</body><body package="Com- Ole Examples">SetUpperBound: anInteger	" Private - implement the IRandomNumberGenerator::SetUpperBound operation. "	rng upperBound: anInteger.	^S_OK</body><body package="Com- Ole Examples">UpperBound: resultReference	" Private - implement the IRandomNumberGenerator::UpperBound operation. "	resultReference value: rng upperBound.	^S_OK</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject</class-id> <category>subclass-releasing</category><body package="Com- Ole Examples">resetAllocatedInterfaces	" Private - reset the references to the interfaces supported by the receiver. "	super resetAllocatedInterfaces.	iRandomNumberGenerator := iDataObject := nil.</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject class</class-id> <category>installation</category><body package="Com- Ole Examples">installComponent	" Install the COM random number generator "	IRandomNumberGenerator registerIID.	IRandomNumberGeneratorPointer registerIID.	IRandomNumberGeneratorImplementation registerIID.</body><body package="Com- Ole Examples">removeComponent	" Remove the COM random number generator "	IRandomNumberGenerator removeIID.	IRandomNumberGeneratorPointer removeIID.	IRandomNumberGeneratorImplementation removeIID.</body></methods><methods><class-id>Examples.COMRandomNumberGeneratorObject class</class-id> <category>class initialization</category><body package="Com- Ole Examples">initialize	self clsid: (GUID				fromBytes: #[16r90 16r73 16r3A 16rE3 16rD3 16r96 16rCF 16r11 16rAB 16r44 0 16r20 16rAF 16r26 16r4C 16rC])	" '{E33A7390-96D3-11CF-AB44-0020AF264C0C}' asGUID "</body></methods><methods><class-id>Examples.IRandomNumberGeneratorPointer</class-id> <category>private-invocation</category><body package="Com- Ole Examples">invokeLowerBound: pLowerBound	" Private - invoke the IRandomNumberGenerator::LowerBound function. "	" HRESULT LowerBound(            /* [out] */ LONG * pLowerBound); "	&lt;COM: HRESULT __stdcall LowerBound(LONG * pLowerBound) =6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole Examples">invokeNext: pValue	" Private - invoke the IRandomNumberGenerator::Next function. "	" HRESULT Next(            /* [out] */ LONG * pValue); "	&lt;COM: HRESULT __stdcall Next(LONG * pValue) =3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole Examples">invokeSeed: pSeed	" Private - invoke the IRandomNumberGenerator::Seed function. "	" HRESULT Seed(            /* [out] */ LONG * pSeed); "	&lt;COM: HRESULT __stdcall Seed(LONG * pSeed) =4&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole Examples">invokeUpperBound: pUpperBound	" Private - invoke the IRandomNumberGenerator::UpperBound function. "	" HRESULT UpperBound(            /* [out] */ LONG * pUpperBound); "	&lt;COM: HRESULT __stdcall UpperBound(LONG * pUpperBound) =8&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Examples.IRandomNumberGeneratorPointer</class-id> <category>interface operations</category><body package="Com- Ole Examples">SetLowerBound: lowerBound		" Invoke the IRandomNumberGenerator::SetLowerBound function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT SetLowerBound(            /* [in] */ LONG lowerBound); "	&lt;COM: HRESULT __stdcall SetLowerBound(LONG lowerBound) =7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole Examples">SetSeed: seed		" Invoke the IRandomNumberGenerator::SetSeed function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT SetSeed(            /* [in] */ LONG seed); "	&lt;COM: HRESULT __stdcall SetSeed(LONG seed) =5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole Examples">SetUpperBound: upperBound		" Invoke the IRandomNumberGenerator::SetUpperBound function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT SetUpperBound(            /* [in] */ LONG upperBound); "	&lt;COM: HRESULT __stdcall SetUpperBound(LONG upperBound) =9&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>Examples.COMPersistentDataObjectBrowser class</class-id> <category>interface specs</category><body package="Com- Ole Examples">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #PDOBrowser 				#defaultString: 'COM Persistent Data Object Browser' 				#catalogID: #com ) 			#bounds: #(#{Graphics.Rectangle} 25 646 509 1057 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 74 0 -15 1 -150 1 ) 					#model: #descriptionHolder 					#isReadOnly: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 96 0 -40 1 -15 1 -15 1 ) 					#model: #fileNameHolder 					#isReadOnly: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 18 49 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #DescriptionColon 						#defaultString: 'Description:' 						#catalogID: #com ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 18 15 70 40 ) 					#name: #createPDOButton 					#model: #createPDO 					#label: 					#(#{Kernel.UserMessage} 						#key: #Create 						#defaultString: 'Create' 						#catalogID: #labels ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 80 15 132 40 ) 					#name: #loadPDOButton 					#model: #loadPDO 					#label: 					#(#{Kernel.UserMessage} 						#key: #LoadDot 						#defaultString: 'Load...' 						#catalogID: #menus ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 164 0 -140 1 210 0 -115 1 ) 					#name: #savePDOButton 					#model: #savePDO 					#label: 					#(#{Kernel.UserMessage} 						#key: #Save 						#defaultString: 'Save' 						#catalogID: #menus ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 214 0 -140 1 284 0 -115 1 ) 					#name: #saveAsPDOButton 					#model: #saveAsPDO 					#label: 					#(#{Kernel.UserMessage} 						#key: #SaveAs 						#defaultString: 'Save As...' 						#catalogID: #menus ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 15 0 -40 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #CurrentFileColon 						#defaultString: 'Current file:' 						#catalogID: #com ) ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 140 15 200 40 ) 					#name: #releasePDOButton 					#model: #releasePDO 					#label: 					#(#{Kernel.UserMessage} 						#key: #Release 						#defaultString: 'Release' 						#catalogID: #com ) 					#defaultable: true ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 -128 1 ) 					#model: #backingStoreTypeHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #File 						#defaultString: 'File' 						#catalogID: #labels ) 					#select: 'file' ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 -104 1 ) 					#model: #backingStoreTypeHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #StorageFile 						#defaultString: 'Storage File' 						#catalogID: #com ) 					#select: 'storage' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 15 0 -148 1 160 0 -50 1 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #BackingStoreType 						#defaultString: 'Backing Store Type' 						#catalogID: #com ) ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 -80 1 ) 					#model: #backingStoreTypeHolder 					#label: 					#(#{Kernel.UserMessage} 						#key: #StreamFile 						#defaultString: 'Stream File' 						#catalogID: #com ) 					#select: 'stream' ) ) ) )</body></methods><initialize><class-id>Examples.IRandomNumberGeneratorPointer</class-id></initialize><initialize><class-id>Examples.COMPersistentDataObject</class-id></initialize><initialize><class-id>Examples.IRandomNumberGeneratorImplementation</class-id></initialize><initialize><class-id>Examples.IRandomNumberGenerator</class-id></initialize><initialize><class-id>Examples.COMRandomNumberGeneratorObject</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>IUnknownImplementation</name><environment>External</environment><super>External.COMInterfaceImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referenceCount </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMObject</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controllingUnknown innerUnknown referenceCount </inst-vars><class-inst-vars>clsid </class-inst-vars><imports>			External.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMObjectWithInterfaceStorage</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknown</name><environment>External</environment><super>External.COMInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>EventEnabledApplicationModel</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><class><name>IUnknownPointer</name><environment>External</environment><super>External.COMInterfacePointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class></st-source>