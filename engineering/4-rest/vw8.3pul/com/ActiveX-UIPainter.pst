<?xml version="1.0"?><st-source><!-- Name: ActiveX-UIPainterNotice: Copyright 1999-2016 Cincom Systems, Inc.  All rights reserved.Comment: This package contains code required to create an Application containing an ActiveX control using the UIPainter.DbIdentifier: bear73DbTrace: 491807DbUsername: alexDbVersion: 8.2 - 3DevelopmentPrerequisites: #(#(#any 'Browser-BrowserUI' '') #(#any 'UIPainter' '') #(#any 'ActiveX-UI' '') #(#any 'ActiveX-AutomationExtensions' '') #(#any 'ActiveX-Container' '') #(#any 'Com- Automation' '') #(#any 'Com- Automation Pools' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #(#(#name 'Com- Automation Browser' #componentType #package))PackageName: ActiveX-UIPainterParcel: #('ActiveX-UIPainter')ParcelName: ActiveX-UIPainterPrerequisiteDescriptions: #(#(#name 'Browser-BrowserUI') #(#name 'UIPainter') #(#name 'ActiveX-UI') #(#name 'ActiveX-AutomationExtensions' #componentType #package) #(#name 'ActiveX-Container' #componentType #package) #(#name 'Com- Automation' #componentType #package) #(#name 'Com- Automation Pools' #componentType #package))PrerequisiteParcels: #(#('Browser-BrowserUI' '') #('UIPainter' '') #('ActiveX-UI' '') #('ActiveX-AutomationExtensions' '') #('ActiveX-Container' '') #('Com- Automation' '') #('Com- Automation Pools' ''))PrintStringCache: (8.2 - 3,alex)Version: 8.2 - 3Post-Load Block: 	[:package |  	UIPalette activeSpecsList add: #{UI.ActiveXSpec}]Pre-Unload Block: 	[:package | 	UIPalette activeSpecsList remove: #{UI.ActiveXSpec} ifAbsent: []]Date: 3:07:38 PM April 21, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.2) of April 21, 2017 on April 21, 2017 at 3:07:38 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ControlIntegratedSpecModel</name><environment>External</environment><super>Tools.IntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hasChanged </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UIPainter</package></attributes></class><comment><class-id>External.ControlIntegratedSpecModel</class-id><body>ControlIntegratedSpecModel is an abstract spec model class which is used for ActiveX related editors.Subclasses must implement the following messages:	private		updateListInstance Variables	hasChanged		&lt;Boolean&gt;	indicates whether data has changed</body></comment><class><name>ControlBindingEditor</name><environment>External</environment><super>External.ControlIntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectedBinding bindings plusButton minusButton listview </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UIPainter</package></attributes></class><comment><class-id>External.ControlBindingEditor</class-id><body>ControlBindingEditor is an editor for binding ActiveX control porperties to application aspects.Instance Variables	bindings	&lt;SelectionInList&gt;	a SelectionInList on the list of bindings.	selectedBinding	&lt;ValueModel&gt;	the currently selected binding</body></comment><class><name>ControlPropertyBinding</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>property aspect changeNotification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UIPainter</package></attributes></class><comment><class-id>UI.ControlPropertyBinding</class-id><body>ControlPropertyBinding is used to map control properties to application aspects.Instance Variables	property		&lt;String&gt;	the property name	aspect		&lt;aSymbol&gt;	the corresponding application aspect	changeNotification &lt;aSymbol&gt; an event which notifies us about the change of the property</body></comment><class><name>ControlPropertyBindingEditor</name><environment>External</environment><super>External.ControlBindingEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UIPainter</package></attributes></class><comment><class-id>External.ControlPropertyBindingEditor</class-id><body>ControlPropertyBindingEditor is an editor for binding Control properties to application aspects.</body></comment><class><name>GenericBindingSpec</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UIPainter</package></attributes></class><comment><class-id>UI.GenericBindingSpec</class-id><body>GenericBindingSpec is a generic class which can be used to generate accessor code. Instance Variables	block	&lt;BlockClosure &gt;	the two-argument-block which is executed when the code should be generated</body></comment><class><name>ControlEventEditor</name><environment>External</environment><super>External.ControlBindingEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>toolTipAssisten </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UIPainter</package></attributes></class><comment><class-id>External.ControlEventEditor</class-id><body>ControlEventEditor is a class for assigning Control events to application methods</body></comment><class><name>ControlPropertyEditor</name><environment>External</environment><super>External.ControlIntegratedSpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties selectedRow </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UIPainter</package></attributes></class><comment><class-id>External.ControlPropertyEditor</class-id><body>ControlPropertyEditor is an editor for Control Property values. The assigned values are used as a configuration for ActiveX Controls. Instance Variables	properties		&lt;SelectionInList&gt;	the SelectionInList on the list of properties	selectedRow	&lt;ValueModel&gt;		the currently selected assignment </body></comment><class><name>ControlPropertyAssignment</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>spec propertyValue editor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UIPainter</package></attributes></class><comment><class-id>External.ControlPropertyAssignment</class-id><body>ControlPropertyAssignment is used to represent control property values. It is possible to set their value in which case theysafe this information which is used to generate a configuration for the control.Instance Variables	control			&lt;COleControlProxy&gt;	the control which contains the property	propertyValue	&lt;Object&gt;				the assigned property value	spec			&lt;COMDispatchPropertySpecification&gt;	contains property information such as type and flags</body></comment><methods><class-id>External.ControlIntegratedSpecModel</class-id> <category>private</category><body package="ActiveX-UIPainter">hasChanged	^ hasChanged ifNil: [ false ]</body><body package="ActiveX-UIPainter">hasChanged: aBoolean	hasChanged := aBoolean</body><body package="ActiveX-UIPainter">updateList	self subclassResponsibility</body></methods><methods><class-id>External.ControlIntegratedSpecModel</class-id> <category>private accessing</category><body package="ActiveX-UIPainter">control		| widget |	propertiesTool ifNil: [^ nil ].	propertiesTool selection size = 1 ifFalse: [^ nil ].	widget := propertiesTool selection first widget. 	^ widget class = ActiveXControlView 		ifTrue: [ widget oleControl ]		ifFalse: [ nil ].</body><body package="ActiveX-UIPainter">controlProperties	| table |	^ self control 			ifNil: [ #() ]			ifNotNil: [:control | 				control isAllocated 					ifTrue: [						"filter double properties which may have different memberids"						table := control dispatchDriver specificationTable withSpecificationKey: #name.						table primaryValues ]					ifFalse: [ #() ]].</body><body package="ActiveX-UIPainter">reloadSelectionInformation	self updateList.</body><body package="ActiveX-UIPainter">spec	^ specChannel value</body></methods><methods><class-id>External.ControlIntegratedSpecModel</class-id> <category>actions</category><body package="ActiveX-UIPainter">markChanged		self hasChanged: true.	self enableApply</body><body package="ActiveX-UIPainter">precancel	^ false</body></methods><methods><class-id>External.ControlIntegratedSpecModel</class-id> <category>initialize-release</category><body package="ActiveX-UIPainter">propertiesTool: aTool	aTool == propertiesTool ifTrue: [ ^ self ].	super propertiesTool: aTool.	self updateList.</body><body package="ActiveX-UIPainter">specChannel: aChannel	super specChannel: aChannel.	self updateList.</body></methods><methods><class-id>External.ControlIntegratedSpecModel</class-id> <category>interface opening</category><body package="ActiveX-UIPainter">postBuildWith: aBuilder	super  postBuildWith: aBuilder.	(aBuilder componentAt: #Dataset1) widget gridLineColor: (ColorValue red: 0.8 green: 0.8 blue: 0.8).</body></methods><methods><class-id>External.ControlBindingEditor</class-id> <category>private</category><body package="ActiveX-UIPainter">bindableEntities		^ self subclassResponsibility</body><body package="ActiveX-UIPainter">bindingChoices	self subclassResponsibility</body><body package="ActiveX-UIPainter">controlEvents	^ self control ifNil: [ #() ] ifNotNil: [:control | control eventSpecificationTable specificationTable values ]</body><body package="ActiveX-UIPainter">eventNotificationChoices	^ (self controlEvents collect: [:each | each name asSymbol ]) asValue</body><body package="ActiveX-UIPainter">setFocusTo: newBinding	"Set the focus to the previously added binging representation in the listview"		self bindings selection: newBinding.	listview ifNotNil: ["		listview controller keyboardProcessor setActive: listview controller."		listview editAt: 1@self bindings selectionIndex ]</body><body package="ActiveX-UIPainter">updateButtonState		| control |	plusButton isNil ifTrue: [^self].	"Can't do anything"	control := self control.	plusButton isEnabled: (control notNil and: [control isAllocated]).</body><body package="ActiveX-UIPainter">updateList		self updateButtonState.</body><body package="ActiveX-UIPainter">updateMinusButtonState		minusButton isEnabled: self bindings list notEmpty</body></methods><methods><class-id>External.ControlBindingEditor</class-id> <category>aspects</category><body package="ActiveX-UIPainter">bindings	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^bindings isNil		ifTrue:			[bindings :=  SelectionInList new.			bindings list: OrderedCollection new.			bindings selectionIndexHolder compute:				[:v |				self selectedBinding value: bindings selection].			bindings]		ifFalse:			[bindings]</body><body package="ActiveX-UIPainter">selectedBinding	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectedBinding isNil		ifTrue:			[selectedBinding := nil asValue. 			selectedBinding onChangeSend: #selectionChanged to: self.]		ifFalse:			[selectedBinding]</body><body package="ActiveX-UIPainter">validBindings		^ (self bindings list select: [:each | self isValidBinding: each]) asArray</body></methods><methods><class-id>External.ControlBindingEditor</class-id> <category>private testing</category><body package="ActiveX-UIPainter">isValidBinding: anAssociation	self subclassResponsibility</body></methods><methods><class-id>External.ControlBindingEditor</class-id> <category>actions</category><body package="ActiveX-UIPainter">addBindingSlot	"This stub method was generated by UIDefiner"		| newBinding |	(self bindings list isEmpty or: [self isValidBinding: self bindings list last]) 		ifFalse: [^self].	newBinding := self newBinding.	self bindings list add: newBinding.	self bindings list: self bindings list.	self markChanged.	self setFocusTo: newBinding</body><body package="ActiveX-UIPainter">newBinding		self subclassResponsibility</body><body package="ActiveX-UIPainter">removeBinding	"This stub method was generated by UIDefiner"	self selectedBinding value ifNotNil: [:row|		self bindings list remove: row.		self bindings list: self bindings list. 		self markChanged ].</body><body package="ActiveX-UIPainter">selectedBindingKeyLabelPressed	"do nothing"</body><body package="ActiveX-UIPainter">selectedBindingValueLabelPressed	"Do nothing"</body></methods><methods><class-id>External.ControlBindingEditor</class-id> <category>events</category><body package="ActiveX-UIPainter">selectionChanged	minusButton ifNil: [^self ].	minusButton isEnabled: (self selectedBinding value notNil).</body></methods><methods><class-id>External.ControlBindingEditor</class-id> <category>interface opening</category><body package="ActiveX-UIPainter">postBuildWith: aBuilder	super postBuildWith: aBuilder.		plusButton := (aBuilder componentAt: #plusButton) widget.	minusButton := (aBuilder componentAt: #minusButton) widget.	listview := (aBuilder componentAt: #Dataset1) widget.	self updateButtonState.</body></methods><methods><class-id>External.ControlBindingEditor class</class-id> <category>interface specs</category><body package="ActiveX-UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	self subclassResponsibility</body></methods><methods><class-id>UI.ControlPropertyBinding</class-id> <category>accessing</category><body package="ActiveX-UIPainter">aspect	^aspect</body><body package="ActiveX-UIPainter">aspect: anObject	aspect := anObject</body><body package="ActiveX-UIPainter">changeNotification	^changeNotification</body><body package="ActiveX-UIPainter">changeNotification: anObject	changeNotification := anObject</body><body package="ActiveX-UIPainter">literalArrayEncoding	^ Array with: self class fullyQualifiedReference with: self property literalArrayEncoding with: self aspect literalArrayEncoding with: self changeNotification literalArrayEncoding</body><body package="ActiveX-UIPainter">property	^property</body><body package="ActiveX-UIPainter">property: anObject	property := anObject</body></methods><methods><class-id>UI.ControlPropertyBinding class</class-id> <category>As yet unclassified</category><body package="ActiveX-UIPainter">decodeFromLiteralArray: anArray		^self		newProperty: (anArray at: 2) decodeAsLiteralArray		aspect: (anArray at: 3) decodeAsLiteralArray		changeNotification:			(anArray size = 4				ifTrue: [(anArray at: 4) decodeAsLiteralArray]				ifFalse: [nil])</body></methods><methods><class-id>UI.ControlPropertyBinding class</class-id> <category>instance creation</category><body package="ActiveX-UIPainter">newProperty: aPropertyName aspect: anAspect changeNotification: anEventSymbol		^(self new)		property: aPropertyName;		aspect: anAspect;		changeNotification: anEventSymbol;		yourself</body></methods><methods><class-id>External.ControlPropertyBindingEditor</class-id> <category>events</category><body package="ActiveX-UIPainter">aspectChanged	self markChanged.</body><body package="ActiveX-UIPainter">notificationChanged	self markChanged.</body><body package="ActiveX-UIPainter">propertyChanged	"This appears when a value is set in the UI"	"	self selectedBinding value value ifNil: ["		self selectedBinding value aspect: self proposedAspectNameForSelectedRow.	self bindings listHolder value changed: #value.	self builder bindings		removeKey: #bindingChoices		ifAbsent: [].	self markChanged.	self bindings selectionIndexHolder changed: #value with: #reset</body></methods><methods><class-id>External.ControlPropertyBindingEditor</class-id> <category>private</category><body package="ActiveX-UIPainter">bindableEntities		^ self controlProperties select: [:each | self isBindableEntity: each]</body><body package="ActiveX-UIPainter">bindingChoices	^ (((self bindableEntities collect: [:each | each name asSymbol ]) "reject: [:each | 			self bindings list contains: [:binding | binding property = each ]]") 						asSortedCollection: [:a :b | a &lt; b ]) asValue</body><body package="ActiveX-UIPainter">proposedAspectNameForSelectedRow		| prefix |	prefix := self spec model 		ifNil: [ self control 				ifNil: [ 'control' ] 				ifNotNil: [:control | control controlName asLowercase ]] 		ifNotNil: [ self spec model asString asLowercase ].	^ (prefix, self selectedBinding value property startingWithUppercaseLetter) asSymbol</body><body package="ActiveX-UIPainter">updateList			super updateList.		self bindings list: specChannel value controlBindings asOrderedCollection.</body></methods><methods><class-id>External.ControlPropertyBindingEditor</class-id> <category>private testing</category><body package="ActiveX-UIPainter">isBindableEntity: aMemberSpecification	"Return whether the given property can be bound to a local variable"	^ aMemberSpecification isPropertySpecification and: [ 			aMemberSpecification propertyGetIsParameterless and: [ 				aMemberSpecification isHidden not and: [  						aMemberSpecification isRestricted not ]]]</body><body package="ActiveX-UIPainter">isValidBinding: anAssociation		^(self isValidPropertyName: anAssociation property)		and: [anAssociation aspect notNil].</body><body package="ActiveX-UIPainter">isValidPropertyName: aName	aName ifNil: [^false ].	^ self bindableEntities contains: [:each | each name asSymbol = aName ]</body></methods><methods><class-id>External.ControlPropertyBindingEditor</class-id> <category>actions</category><body package="ActiveX-UIPainter">newBinding		^ControlPropertyBinding newProperty: nil aspect: nil changeNotification:			nil</body></methods><methods><class-id>External.ControlPropertyBindingEditor</class-id> <category>accessing</category><body package="ActiveX-UIPainter">preapply	super preapply.	self spec controlBindings: self validBindings</body></methods><methods><class-id>UI.GenericBindingSpec</class-id> <category>accessing</category><body package="ActiveX-UIPainter">beForAction	type := #action.</body><body package="ActiveX-UIPainter">beForAspect	type := #aspect.</body><body package="ActiveX-UIPainter">block	^block</body><body package="ActiveX-UIPainter">block: anObject	block := anObject</body></methods><methods><class-id>UI.GenericBindingSpec</class-id> <category>evaluating</category><body package="ActiveX-UIPainter">generateCodeFor: key on: aStream	^ self block value: key value: aStream.</body></methods><methods><class-id>UI.GenericBindingSpec</class-id> <category>testing</category><body package="ActiveX-UIPainter">isForAction	^ type == #action.</body><body package="ActiveX-UIPainter">isForAspect	^ type == #aspect.</body></methods><methods><class-id>UI.GenericBindingSpec class</class-id> <category>instance creation</category><body package="ActiveX-UIPainter">withBlock: aBlock	^ self new		block: aBlock;		yourself</body></methods><methods><class-id>External.ControlEventEditor</class-id> <category>private</category><body package="ActiveX-UIPainter">bindableEntities		^ self controlEvents</body><body package="ActiveX-UIPainter">bindingChoices	| list |	list := self bindings list copyFrom: 1 to: self bindings selectionIndex - 1.	^ (((self bindableEntities collect: [:each | each name asSymbol ]) reject: [:each | 			list contains: [:binding | binding event = each ]]) 			asSortedCollection: [:a :b | a  &lt; b  ]) asValue</body><body package="ActiveX-UIPainter">eventSpecNamed: aName	^ self controlEvents 			detect: [:each | each name asSymbol = aName ]			ifNone: [ nil ]</body><body package="ActiveX-UIPainter">updateList		super updateList.	self bindings list: specChannel value eventBindings asOrderedCollection.</body></methods><methods><class-id>External.ControlEventEditor</class-id> <category>private testing</category><body package="ActiveX-UIPainter">isValidBinding: anAssociation	^ (self bindableEntities contains: [:each | each name asSymbol = anAssociation event ]) and: [ anAssociation selector notNil ]</body></methods><methods><class-id>External.ControlEventEditor</class-id> <category>actions</category><body package="ActiveX-UIPainter">newBinding		^ControlEventBinding new</body></methods><methods><class-id>External.ControlEventEditor</class-id> <category>accessing</category><body package="ActiveX-UIPainter">preapply	super preapply.	self spec eventBindings: self validBindings</body></methods><methods><class-id>External.ControlEventEditor</class-id> <category>events</category><body package="ActiveX-UIPainter">eventChanged		self selectedBinding value		takeValuesFrom: (self eventSpecNamed: self selectedBinding value event)		modelName: (self spec model ifNil: [self control ifNil: [ 'control' ] ifNotNil: [:c | c progId ]]).	self builder bindings		removeKey: #bindingChoices		ifAbsent: [].	self markChanged.	self bindings selectionIndexHolder changed: #value with: #reset</body><body package="ActiveX-UIPainter">selectorChanged	self markChanged.</body><body package="ActiveX-UIPainter">toolTipAssistent	^ toolTipAssisten ifNil: [ toolTipAssisten := TooltipAssistant new ]</body></methods><methods><class-id>External.ControlEventEditor</class-id> <category>As yet unclassified</category><body package="ActiveX-UIPainter">basicValidateEntry: aController	| aSymbol |	aSymbol := aController editValue.	^ (aSymbol isNil or: [ aSymbol isEmpty ]) 		ifTrue: [ true ]		ifFalse: [ aSymbol numArgs = self selectedBinding value numberOfParameters ]</body><body package="ActiveX-UIPainter">validateEntry: aController		| result |	result := self basicValidateEntry: aController.	result		ifTrue: [self toolTipAssistent release]		ifFalse:			[Screen default ringBell. 			(self toolTipAssistent)				initialize;				onView: aController view;				tooltip:						self selectedBinding value numberOfParameters printString ,									' argument selector expected';				openTooltip].	^result</body></methods><methods><class-id>External.ControlPropertyEditor</class-id> <category>private</category><body package="ActiveX-UIPainter">applyDesignTimeProperties: aList	| property assigned |	assigned := false.	aList do: [:aPropertyAssignment |		property := self properties list 			detect: [:each | each propertyName = aPropertyAssignment key ]			ifNone: [ nil ].		property ifNotNil: [ 			property propertyValue: aPropertyAssignment value. 			assigned := true. ]].	assigned ifTrue: [ self properties listHolder changed: #value ].</body><body package="ActiveX-UIPainter">availableProperties		| aPropertyList |	aPropertyList := (self controlProperties asSet		select: [:each | self isBrowsableProperty: each])		collect: [:each | ControlPropertyAssignment editor: self spec: each].	aPropertyList := aPropertyList asSet.	^aPropertyList asSortedCollection: self ascendingSortBlock</body><body package="ActiveX-UIPainter">isBrowsableProperty: aMemberSpecification	^ aMemberSpecification isPropertySpecification and: [ 		aMemberSpecification propertyGetIsParameterless and: [ 			aMemberSpecification isHidden not and: [  				aMemberSpecification isNonBrowsable not and: [  					aMemberSpecification isRestricted not and: [  						aMemberSpecification isReadOnlyFlagSet not and: [							aMemberSpecification getSpecificationForDisplay returnValueDescription type isInterface not ]]]]]]</body><body package="ActiveX-UIPainter">updateList		self properties list: self availableProperties.	specChannel value controlProperties assignPropertiesToEditor: self.</body></methods><methods><class-id>External.ControlPropertyEditor</class-id> <category>private sort blocks</category><body package="ActiveX-UIPainter">ascendingSortBlock		^[:a :b | a propertyName &lt; b propertyName]</body><body package="ActiveX-UIPainter">descendingSortBlock		^[:a :b | a propertyName &gt; b propertyName]</body></methods><methods><class-id>External.ControlPropertyEditor</class-id> <category>private accessing</category><body package="ActiveX-UIPainter">assignedProperties	^ self properties list select: [:each | each isAssigned ]</body><body package="ActiveX-UIPainter">assignedPropertyValues	^ self assignedProperties collect: [:each | 		each propertyName -&gt; each propertyValue ].</body><body package="ActiveX-UIPainter">propertyValueChoices	^ [ self selectedRow value ifNotNil: [:aPropertyAssignment |		aPropertyAssignment spec predefinedValues collect: 			[:each | aPropertyAssignment spec textRepresentationFor: each ]]]</body></methods><methods><class-id>External.ControlPropertyEditor</class-id> <category>aspects</category><body package="ActiveX-UIPainter">properties	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^properties isNil		ifTrue:			[properties :=  SelectionInList new.			 properties list: self availableProperties.			properties selectionIndexHolder compute:				[:v |				self selectedRow value: properties selection].			properties]		ifFalse:			[properties]</body><body package="ActiveX-UIPainter">selectedRow	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^selectedRow isNil		ifTrue:			[selectedRow := nil asValue]		ifFalse:			[selectedRow]</body></methods><methods><class-id>External.ControlPropertyEditor</class-id> <category>events</category><body package="ActiveX-UIPainter">selectedRowPropertyNameLabelPressed	self properties list sortBlock = self ascendingSortBlock 		ifTrue: [ self properties list sortBlock: self descendingSortBlock  ]		ifFalse: [ self properties list sortBlock: self ascendingSortBlock  ].	self properties listHolder changed: #value.</body><body package="ActiveX-UIPainter">selectedRowPropertyTypeStringLabelPressed</body><body package="ActiveX-UIPainter">selectedRowPropertyValueStringLabelPressed	"Do nothing"</body><body package="ActiveX-UIPainter">valueChanged	"This appears when a value is set in the UI"	self hasChanged: true.	self enableApply.</body></methods><methods><class-id>External.ControlPropertyEditor</class-id> <category>actions</category><body package="ActiveX-UIPainter">browseControlClass	"This stub method was generated by UIDefiner"	^self control		ifNotNil: 			[:aControl |			aControl isAllocated				ifTrue: 					[					[#{Refactory.Browser.AutomationBrowserEnvironment} ifDefinedDo: 							[:environmentClass |							Refactory.Browser.RefactoringBrowser								openOnEnvironment: environmentClass new								type: #Automation								state: aControl coclass createBrowserState]						elseDo: 							[self error: #RefactoringBrowserNotInImage &lt;&lt; #com										&gt;&gt; 'The RefactoringBrowser is not loaded in this image']]							on: Error							do: 								[:ex |								Dialog									warn: (#OpeningAutomationBrowserCouldNotBePerformed &lt;&lt; #com											&gt;&gt; 'Opening an Automation browser could not be performed for the following reason: &lt;1s&gt;'												expandMacrosWith: ex description)]]]</body><body package="ActiveX-UIPainter">precancel	propertiesTool rebuildSelection.	^ false</body></methods><methods><class-id>External.ControlPropertyEditor</class-id> <category>accessing</category><body package="ActiveX-UIPainter">preapply	super preapply.	self spec saveControlState: self control properties: self assignedPropertyValues.</body></methods><methods><class-id>External.ControlPropertyAssignment</class-id> <category>accessing</category><body package="ActiveX-UIPainter">control	^ editor control</body><body package="ActiveX-UIPainter">editor	^editor</body><body package="ActiveX-UIPainter">editor: anObject	editor := anObject</body><body package="ActiveX-UIPainter">propertyName	^ spec name</body><body package="ActiveX-UIPainter">propertyTypeString	^ spec propertyGetSpecificationForDisplay type uiPainterDisplayString</body><body package="ActiveX-UIPainter">propertyValue		^propertyValue ifNil: [ [ self control getProperty: spec name ] on: Error do: [:ex | ex return: nil ] ]</body><body package="ActiveX-UIPainter">propertyValue: anObject		[self control		basicSetProperty: spec name		value: anObject.	propertyValue := anObject]		on: Error		do: [:ex | ex return]</body><body package="ActiveX-UIPainter">propertyValueString		^ spec textRepresentationFor: self propertyValue</body><body package="ActiveX-UIPainter">propertyValueString: aString		^ self propertyValue: (spec valueFromTextRepresentation:aString)</body><body package="ActiveX-UIPainter">spec	^spec</body><body package="ActiveX-UIPainter">spec: anObject	spec := anObject</body></methods><methods><class-id>External.ControlPropertyAssignment</class-id> <category>testing</category><body package="ActiveX-UIPainter">isAssigned	^ propertyValue notNil</body></methods><methods><class-id>External.ControlPropertyAssignment</class-id> <category>printing</category><body package="ActiveX-UIPainter">printOn: aStream	aStream nextPutAll: self propertyName,' -&gt; ', self propertyValueString</body></methods><methods><class-id>External.ControlPropertyAssignment class</class-id> <category>instance creation</category><body package="ActiveX-UIPainter">editor: anEditor spec: spec	^ self new			editor: anEditor;			spec: spec;			yourself</body></methods><methods><class-id>UI.StreamControlProperties</class-id> <category>property assignment</category><body package="ActiveX-UIPainter">assignPropertiesToEditor: aPropertyEditor	aPropertyEditor applyDesignTimeProperties: data.</body></methods><methods><class-id>External.DispPtrTypeSpec</class-id> <category>printing</category><body package="ActiveX-UIPainter">stringRepresentationForParamValue: aValue	^ [ referentType ptrStringRepresentationForParamValue: aValue ] on: Error do: [:ex |		"There were cases in which a byref property returned a non-byref value"		referentType stringRepresentationForParamValue: aValue  ]</body><body package="ActiveX-UIPainter">valueFromTextRepresentation: aValue	^ referentType ptrValueFromTextRepresentation: aValue</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="ActiveX-UIPainter">startingWithLowercaseLetter	^ self asString startingWithLowercaseLetter asSymbol</body><body package="ActiveX-UIPainter">startingWithUppercaseLetter	^ self asString startingWithUppercaseLetter asSymbol</body></methods><methods><class-id>UI.UISpecEnumerator</class-id> <category>secondary dispatch</category><body package="ActiveX-UIPainter">doLeafActiveXSpec: aSpec	self doLeafWidgetSpec: aSpec.</body></methods><methods><class-id>UI.AspectEnumerator</class-id> <category>secondary dispatch</category><body package="ActiveX-UIPainter">doLeafActiveXSpec: aSpec	super doLeafActiveXSpec: aSpec.	aSpec addComponentBindingsTo: bindings.</body></methods><methods><class-id>External.GeneralPropertySpecification</class-id> <category>accessing</category><body package="ActiveX-UIPainter">predefinedValues		^ self propertyGetSpecificationForDisplay type predefinedValues</body><body package="ActiveX-UIPainter">textRepresentationFor: aValue	^ self propertyGetSpecificationForDisplay type stringRepresentationForParamValue: aValue.</body></methods><methods><class-id>Tools.UIPainterTool</class-id> <category>actions</category><body package="ActiveX-UIPainter">rebuildSelection	"Rebuild the selection. This is used to reload the ActiveX Control based on 	the information currently inside the spec after the editing has been canceled"		| selElem spec oldCanvasChanged |	selectionKind == #single ifFalse: [^self].	"replaceElement:etc. will cause change to be noted, and  select: will cause UIPainterWatchers to be alerted."	selElem := selection first.	spec := currentSpecCopy copy.	oldCanvasChanged := controller canvasHasChanged.	selElem := controller replaceElement: selElem basedOnSpec: spec.	controller select: selElem.	"			doInvalidate ifTrue: [currentView invalidate]"	controller canvasHasChanged: oldCanvasChanged.</body></methods><methods><class-id>External.DispUserDefTypeSpec</class-id> <category>printing</category><body package="ActiveX-UIPainter">uiPainterDisplayString	^ self name,'(',self kindname,')'</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>accessing</category><body package="ActiveX-UIPainter">predefinedValues	^ self constants values collect: [:each | each value ].</body></methods><methods><class-id>External.DispEnumTypeSpec</class-id> <category>printing</category><body package="ActiveX-UIPainter">stringRepresentationForParamValue: aValue	^ (self constantForValue: aValue ifNone: [ ^ aValue printString ]) name</body><body package="ActiveX-UIPainter">valueFromTextRepresentation: aString		^ (self constants at: aString asSymbol ifAbsent: [ ^ super valueFromTextRepresentation: aString ]) value</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>testing</category><body package="ActiveX-UIPainter">isInterface	^ actualType isInterface</body><body package="ActiveX-UIPainter">isInterfacePointer	^ actualType isInterfacePointer</body><body package="ActiveX-UIPainter">isOLE_COLOR	^ self guid = OLE_COLOR guid.</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>printing</category><body package="ActiveX-UIPainter">oleColorStringRepresentationForParamValue: aValue	^ aValue ifNil: [ '' ] ifNotNil: [ (OLE_COLOR withValue: aValue) stringRepresentation ]</body><body package="ActiveX-UIPainter">oleColorValueFromTextRepresentation:  aString	^ (OLE_COLOR fromString: aString) value</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>accessing</category><body package="ActiveX-UIPainter">predefinedValues	^ self isOLE_COLOR 		ifTrue: [ OLE_COLOR predefinedValues ]		ifFalse: [ super predefinedValues ]</body></methods><methods><class-id>External.DispAliasTypeSpec</class-id> <category>printing</category><body package="ActiveX-UIPainter">stringRepresentationForParamValue: aValue	self isOLE_COLOR ifTrue: [		^  self oleColorStringRepresentationForParamValue: aValue ].	^ aValue printString</body><body package="ActiveX-UIPainter">uiPainterDisplayString	^ self name,'(', actualType uiPainterDisplayString,')'</body><body package="ActiveX-UIPainter">valueFromTextRepresentation: aValue	self isOLE_COLOR ifTrue: [		^  self oleColorValueFromTextRepresentation: aValue ].	^ Compiler evaluate: aValue</body></methods><methods><class-id>UI.ListControlProperties</class-id> <category>property assignment</category><body package="ActiveX-UIPainter">assignPropertiesToEditor: aPropertyEditor	aPropertyEditor applyDesignTimeProperties: data.</body></methods><methods><class-id>External.COMDispatchSpecificationTable</class-id> <category>accessing-specifications</category><body package="ActiveX-UIPainter">primaryValues	"return all values which do not include an interface name in their key. 	 This is an indicator that for such members there is a superior implementation 	 in the subclass"	| result |	result := Set new.	self internalTables do: 			[:table |			table keysAndValuesDo: 					[:key :spec |					"The implementation currently is not really straightforward"					(key includes: $:) ifFalse: [result add: spec member]]].	^result</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>private-interface building</category><body package="ActiveX-UIPainter">addBindingsTo: env for: inst channel: aChannel	super addBindingsTo: env for: inst channel: aChannel.	env at: #progId put: (self adapt: inst forAspect: #progId channel: aChannel).	env at: #availableClassIdMenu put: self availableControlsMenu.</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>accessing</category><body package="ActiveX-UIPainter">availableControlsMenu		| values |	values := ControlProxy availableProgIds associations asSortedCollection: [:a :b|  a key &lt; b key].	^ self  createAvailableControlsMenuFor: values.</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>property slices</category><body package="ActiveX-UIPainter">bindingSlice	^#(21 #(#(#{Kernel.UserMessage} #key: #PropertyBindings #defaultString: 'Bindings' #catalogID: #com) #windowSpec ControlPropertyBindingEditor))</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>private-interface building</category><body package="ActiveX-UIPainter">componentName	"Identification of component"	^(#ActiveXComponent &lt;&lt; #UIPainter &gt;&gt; 'ActiveX Component') asString</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>private</category><body package="ActiveX-UIPainter">createAvailableControlsMenuFor: values	| twoGroups alphabethicGroup menu nonalphabeticGroups newGroups labels menuValues subMenu menuItem |	twoGroups := values groupedBy: [:each | each key first isAlphabetic ].	alphabethicGroup := twoGroups at: true.	alphabethicGroup :=  alphabethicGroup asSortedCollection: [:a :b | a key &lt; b key ].	nonalphabeticGroups := twoGroups at: false.	newGroups := alphabethicGroup inject: OrderedCollection new into: [:sum :each |		(sum isEmpty or: [ sum last size = 20 ])			ifTrue: [ sum add: OrderedCollection new ].			sum last add: each. 			sum].	menu := Menu new.	newGroups addFirst: nonalphabeticGroups.	newGroups do: [:eachGroup|		labels := eachGroup collect: [:each | each key ].		menuValues := eachGroup collect: [:each | each value ].		subMenu := Menu labelArray: labels values: menuValues.		menuItem := (MenuItem labeled: (self menuItemLabelFor: eachGroup)) submenu: subMenu.		menu addItem: menuItem].	^ menu"	twoGroups isEmpty ifTrue: [ ^ menu ].	alphabeticGroup := twoGroups at: true.	(twoGroups at: false) ifNotNil: [:groups |		generalGroup := OrderedCollection new.		groups do: [:each | generalGroup addAll: each value ].		alphabeticGroup add:  ($? -&gt; generalGroup)].	alphabeticGroup :=  alphabeticGroup asSortedCollection: [:a :b | a key &lt; b key ].	alphabeticGroup do: [:association |		associations := association value asArray.		labels := associations collect: [:each | each key ].		menuValues := associations collect: [:each | each value ].		subMenu := Menu labelArray: labels values: menuValues.		menuItem := (MenuItem labeled: (String with: association key)) submenu: subMenu.		menu addItem: menuItem].	^ menu"</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>property slices</category><body package="ActiveX-UIPainter">detailsSlice	^#(20 #(#(#{Kernel.UserMessage} #key: #ControlProperties #defaultString: 'Properties' #catalogID: #UIPainter) #windowSpec ControlPropertyEditor))</body><body package="ActiveX-UIPainter">eventSlice	^#(22 #(#(#{Kernel.UserMessage} #key: #EventBindings #defaultString: 'Events' #catalogID: #com) #windowSpec ControlEventEditor))</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>resources</category><body package="ActiveX-UIPainter">iconForWidgetTree	^ToolbarIconLibrary visualFor: #activeXWidget</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>accessing</category><body package="ActiveX-UIPainter">label	^ 'ActiveX'</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>private</category><body package="ActiveX-UIPainter">menuItemLabelFor: aCollection	| first last aString |	first := aCollection first key.	last := aCollection last key.	aString := first first isAlphabetic 			ifTrue: [ first copyFrom: 1 to: 2 ]			ifFalse: [ '?' ].	^ aString,' - ',(last first isAlphabetic 			ifTrue: [ last copyFrom: 1 to: 2 ]			ifFalse: [ '?' ])</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>aspect creation</category><body package="ActiveX-UIPainter">addComponentBindingsTo: bindings	self controlBindings do: [:each | 		bindings at: each aspect put: (self bindingSpecForPropertyBinding: each) ].	self eventBindings do: [:each | 		bindings at: each selector put: (self genericBindingSpecForEvent: each) ].</body><body package="ActiveX-UIPainter">bindingSpecForPropertyBinding: aBinding	^ (GenericBindingSpec withBlock: [:key :codeStream |  self writeAspectInstVarInitCodeForBinding: key on: codeStream ])		beForAspect;		yourself</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>private</category><body package="ActiveX-UIPainter">componentSpecDo: anEnumerator	^anEnumerator doLeafActiveXSpec: self</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>private accessing</category><body package="ActiveX-UIPainter">controlBindingForAspect: anAspectSymbol	^ self controlBindings 		detect: [:each | each aspect = anAspectSymbol ]		ifNone: nil</body><body package="ActiveX-UIPainter">eventBindingWithSelector: aSelector	^ self eventBindings 		detect: [:each | each selector = aSelector ]		ifNone: nil</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>aspect creation</category><body package="ActiveX-UIPainter">genericBindingSpecForEvent: aBinding	^ (GenericBindingSpec withBlock: [:key :codeStream |  self writeEventMethodsCodeForBinding: key on: codeStream ])		beForAction;		yourself</body></methods><methods><class-id>UI.ActiveXSpec</class-id> <category>private</category><body package="ActiveX-UIPainter">writeAspectInstVarInitCodeForBinding: aKey on: aStream		| binding |	binding := self controlBindingForAspect: aKey.	aStream		nextPutAll:			ControlPropertyValue fullName , ' controlHolder: self ' , self model ,					' propertyName: ' , binding property printString ,					' changeNotification: ' , binding changeNotification printString</body><body package="ActiveX-UIPainter">writeEventMethodsCodeForBinding: aKey on: aStream		| binding |	binding := self eventBindingWithSelector: aKey.	binding ifNil: [ self error: (#UnknownEventBinding &lt;&lt; #com &gt;&gt; 'Unknown Event binding' ) ].	aStream cr.	self writeSelectorForEventMethodBinding: binding on: aStream.	aStream		crtab;		nextPutAll:				'"This method was generated by UIDefiner for a Control Event.'.	aStream		crtab;		nextPutAll:				'Any edits made here may be lost whenever methods are automatically defined."'</body><body package="ActiveX-UIPainter">writeSelectorForEventMethodBinding: binding on: aStream	| keywords |	binding hasParameters 		ifFalse: [  ^ aStream nextPutAll: binding selector ].	keywords := binding selector keywords.	keywords with: binding parameterNames do: [:keyWord :aName |		aStream nextPutAll: keyWord,' ',aName startingWithLowercaseLetter,' ' ].</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>testing</category><body package="ActiveX-UIPainter">isBoolean	^ self typecode = VT_BOOL</body><body package="ActiveX-UIPainter">isDate	^ self typecode = VT_DATE</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>accessing</category><body package="ActiveX-UIPainter">predefinedValues	^ self isBoolean 		ifTrue: [ Array with: true with: false ]		ifFalse: [ super predefinedValues ]</body></methods><methods><class-id>External.DispSimpleTypeSpec</class-id> <category>printing</category><body package="ActiveX-UIPainter">stringRepresentationForParamValue: aValue 	^self isString 		ifTrue: [ aValue]		ifFalse: [ 			self isDate 				ifTrue: [ Locale current printAsTime: aValue policyNamed: #short ] 				ifFalse:[ super stringRepresentationForParamValue: aValue]]</body><body package="ActiveX-UIPainter">valueFromTextRepresentation: aString		^self isString		ifTrue: [aString]		ifFalse:			[self isDate				ifTrue: [ Locale current readTimestampFrom: aString readStream]				ifFalse: [super valueFromTextRepresentation: aString]]</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>accessing</category><body package="ActiveX-UIPainter">predefinedValues	^ #()</body></methods><methods><class-id>External.DispTypeSpec</class-id> <category>printing</category><body package="ActiveX-UIPainter">ptrStringRepresentationForParamValue: aValue	^ self stringRepresentationForParamValue: aValue value</body><body package="ActiveX-UIPainter">ptrValueFromTextRepresentation: aValue	^ (Compiler evaluate: aValue) asValue</body><body package="ActiveX-UIPainter">stringRepresentationForParamValue: aValue	^ aValue printString</body><body package="ActiveX-UIPainter">uiPainterDisplayString	^ self name</body><body package="ActiveX-UIPainter">valueFromTextRepresentation: aValue	^ Compiler evaluate: aValue</body></methods><methods><class-id>Tools.UIDefiner</class-id> <category>private</category><body package="ActiveX-UIPainter">initStringForGeneric: genericSlot on: codeStream	genericSlot value generateCodeFor: genericSlot key on: codeStream</body><body package="ActiveX-UIPainter">writeDefinitions: bindings for: aController	"bindings includes all required bindings in the selection set	that the user has not specifically disallowed.  Test to see whether	instance variables are already there.  Must check to see whether	action methods are already there, and do not redefine them if they	exist.  Always redefine aspect methods against the possibility that	the type of the model has changed.	NB: aspect methods incorporate lazy instVar initialization."	| genericSlots allnames actionSlots valueSlots listSlots tableSlots clientSlots dsvSlots dsvColSlots detailSlots ivNames detailVars codeStream allDetails treeViewSlots genericAspectSlots genericActionSlots |	allnames := aClass allInstVarNames asSet.	genericSlots := bindings select: [:e | e value isKindOf: GenericBindingSpec ].	genericAspectSlots := genericSlots select: [:e | e value isForAspect].	genericActionSlots := genericSlots select: [:e | e value isForAction].	actionSlots := bindings select: [:e | e value isKindOf: BlockClosure].	valueSlots := bindings select: [:e | e value isKindOf: ValueModel].	listSlots := bindings select: [:e | e value isKindOf: SelectionInList].	tableSlots := bindings select: [:e | e value isKindOf: TableInterface].	clientSlots := bindings select: [:e | (e value isKindOf: Symbol) or: [e value isBindingReference]].	dsvSlots := bindings select: [:e | e value isKindOf: DataSetSpec].	treeViewSlots := bindings select: [:each | each value isKindOf: TreeViewSpec].	dsvColSlots := bindings select: [:e | e value isKindOf: DataSetColumnSpec].	detailSlots := bindings select:		[:e | self isDataFormSpec: e value].	detailVars := self findDetailVars: detailSlots.	ivNames :=		(((genericAspectSlots, genericActionSlots, valueSlots, listSlots, tableSlots, clientSlots, dsvSlots) collect: [:e | e key ]), detailVars			select: [:e | (allnames includes: e asString) not]) asSet.	codeStream := String new writeStream.	self writeClassDefiningMessageForIVs: ivNames on: codeStream.	self writeAccessorsForClients: clientSlots andDetails: detailSlots on: codeStream.	self		writeGenericActions: genericActionSlots		simpleActions: actionSlots		andDetailActions: detailSlots		andDSVSortActions: dsvColSlots		on: codeStream.	self writeTreeViewActions: treeViewSlots on: codeStream.	self		writeGenericAspects: genericAspectSlots		anSimpleAspects: valueSlots		andListAspects: listSlots		andTableAspects: tableSlots		andDSVAspects: dsvSlots		on: codeStream.		allDetails := 		(self enumeratorClass new source: aController model builder source)			doSpec: aController model extractFullSpec; details.	(self does: aClass inheritFromClassNamed: #LensApplicationModel)		ifTrue:			[self				writeMixinQueryMethods: detailSlots on: codeStream.			"The private methods must be written to take into account all details			on the canvas, not just those currently selected."			self writePrivateMethods: allDetails for: aController on: codeStream]		ifFalse:			[allDetails isEmpty not				ifTrue:					[Dialog warn:(#GenKey60 &lt;&lt; #UIPainter &gt;&gt; 'A complete set of definitions could not be generatedto support the Data Form(s) being defined for, becausethis canvas is installed on a non-database class.  Youshould reinstall the canvas on a new class that is eithera Data Form or a Database Application, and try again.')]].			^codeStream contents</body><body package="ActiveX-UIPainter">writeGenericActions: genericActionSlots on: codeStream	genericActionSlots do: [:actn |			actn value generateCodeFor: actn key on: codeStream.			codeStream				nextPutAll: '!']</body><body package="ActiveX-UIPainter">writeGenericActions: genericActions simpleActions: actionSlots andDetailActions: detailSlots andDSVSortActions: dsvColSlots on: aStream	"Be careful never to rewrite simple actions that already exist,	however detail fetch and open actions must needs be rewritten	against the chance the user has changed these properties."		| codeStream emptyPos |	(genericActions isEmpty not		or:			[actionSlots isEmpty not				or: [detailSlots isEmpty not or: [dsvColSlots isEmpty not]]])		ifFalse: [^self].	codeStream := String new writeStream.	codeStream		cr;		cr;		nextPutAll: '!' , aClass fullName , ' methodsFor: ''actions''!'.	emptyPos := codeStream writePosition.	self writeGenericActions: genericActions on: codeStream.	self		writeSimpleActions:			(actionSlots select: [:assn | (aClass canUnderstand: assn key) not])		on: codeStream.	self		writeFetchActions:			(detailSlots select: [:assn | assn value fetchAction notNil])		on: codeStream.	self		writeOpenActions:			(detailSlots select: [:assn | assn value openAction notNil])		on: codeStream.	self writeSortActionsFor: dsvColSlots initGen: #initStringForDSV:on: on:			codeStream.	emptyPos = codeStream writePosition		ifFalse:			[aStream				nextPutAll: codeStream contents;				nextPutAll: ' !']</body><body package="ActiveX-UIPainter">writeGenericAspects: genericSlots anSimpleAspects: valueSlots andListAspects: listSlots andTableAspects: tableSlots andDSVAspects: dsvSlots on: aStream	"Always redefine the more accessor-like methods"		| codeStream emptyPos |	(genericSlots isEmpty not		or:			[valueSlots isEmpty not				or:					[listSlots isEmpty not						or: [tableSlots isEmpty not or: [dsvSlots isEmpty not]]]])		ifFalse: [^self].	codeStream := String new writeStream.	codeStream		cr;		cr;		nextPut: $!;		nextPutAll: aClass fullName;		nextPutAll: ' methodsFor: ''aspects''!'.	emptyPos := codeStream writePosition.	self writeAccessorsFor: valueSlots initGen: #initStringForValue:on: on:			codeStream.	self writeAccessorsFor: genericSlots initGen: #initStringForGeneric:on:		on: codeStream.	self writeAccessorsFor: listSlots initGen: #initStringForList:on: on:			codeStream.	self writeAccessorsFor: tableSlots initGen: #initStringForTable:on: on:			codeStream.	self writeAccessorsFor: dsvSlots initGen: #initStringForDSV:on: on:			codeStream.	emptyPos = codeStream writePosition		ifFalse:			[aStream				nextPutAll: codeStream contents;				nextPutAll: ' !']</body></methods><methods><class-id>External.ControlPropertyBindingEditor class</class-id> <category>interface specs</category><body package="ActiveX-UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 960 600 1408 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #rowLabelsAsButtons false #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 4 0 32 0 -4 1 -4 1 ) 					#name: #Dataset1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #bindings 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedBinding property' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #propertyChanged ) 							#label: 'Property' 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #ComboBox 							#choices: #bindingChoices 							#type: #symbol 							#noScroll: true 							#formatString: '' 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedBinding aspect' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #aspectChanged ) 							#label: 'Aspect' 							#labelIsImage: false 							#width: 80 							#editorType: #InputField 							#type: #symbol 							#noScroll: false 							#formatString: '' 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedBinding changeNotification' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #notificationChanged ) 							#label: 'Event' 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #ComboBox 							#choices: #eventNotificationChoices 							#type: #symbol 							#noScroll: false 							#formatString: '' 							#labelsAsButtons: true ) ) 					#labelsAsButtons: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 0 ) 					#name: #Label1 					#label: 'Property Bindings' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -59 1 4 0 -34 1 29 0 ) 					#name: #plusButton 					#model: #addBindingSlot 					#helpText: 'Add a Binding' 					#label: '+' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -29 1 4 0 -4 1 29 0 ) 					#name: #minusButton 					#flags: 40 					#model: #removeBinding 					#helpText: 'Remove a Binding' 					#label: '-' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>External.ControlEventEditor class</class-id> <category>interface specs</category><body package="ActiveX-UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 960 600 1408 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #rowLabelsAsButtons false #allowColumnReordering false ) 					#layout: #(#{Graphics.LayoutFrame} 4 0 32 0 -4 1 -4 1 ) 					#name: #Dataset1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #bindings 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedBinding event' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #eventChanged ) 							#label: 'Event' 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #ComboBox 							#choices: #bindingChoices 							#type: #symbol 							#noScroll: true 							#formatString: '' 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedBinding selector' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #selectorChanged 								#requestValueChangeSelector: 								#validateEntry: ) 							#label: 'Selector' 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #InputField 							#type: #symbol 							#noScroll: false 							#formatString: '' 							#labelsAsButtons: true ) ) 					#labelsAsButtons: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 0 ) 					#name: #Label1 					#label: 'Property Bindings' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -59 1 4 0 -34 1 29 0 ) 					#name: #plusButton 					#model: #addBindingSlot 					#helpText: 'Add a Binding' 					#label: '+' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -29 1 4 0 -4 1 29 0 ) 					#name: #minusButton 					#flags: 40 					#model: #removeBinding 					#helpText: 'Remove a Binding' 					#label: '-' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>External.ControlPropertyEditor class</class-id> <category>interface specs</category><body package="ActiveX-UIPainter">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Unlabeled Canvas' 			#bounds: #(#{Graphics.Rectangle} 960 600 1408 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DataSetSpec} 					#properties: #(#{UI.PropertyListDictionary} #showHorizontalLines true #allowColumnResizing true #showVerticalLines true #allowColumnReordering false #rowLabelsAsButtons false ) 					#layout: #(#{Graphics.LayoutFrame} 4 0 30 0 -4 1 -4 1 ) 					#name: #Dataset1 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} #white ) ) 					#model: #properties 					#columns: #(						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedRow propertyName' 							#label: 'Property' 							#labelIsImage: false 							#width: 100 							#rendererType: #Text 							#editorType: #None 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false #allowSorting true #allowResizing true ) 							#model: #'selectedRow propertyValueString' 							#callbacksSpec: 							#(#{UI.UIEventCallbackSubSpec} 								#valueChangeSelector: #valueChanged ) 							#label: 'Value' 							#labelIsImage: false 							#width: 120 							#rendererType: #Text 							#editorType: #ComboBox 							#choices: #propertyValueChoices 							#noScroll: false 							#labelsAsButtons: true ) 						#(#{UI.DataSetColumnSpec} 							#properties: #(#{UI.PropertyListDictionary} #allowSorting true #labelFromApplication false ) 							#model: #'selectedRow propertyTypeString' 							#label: 'type' 							#labelIsImage: false 							#width: 80 							#rendererType: #Text 							#editorType: #None 							#noScroll: false ) ) 					#verticalPolicy: #noWrap 					#labelsAsButtons: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -100 1 4 0 -4 1 27 0 ) 					#name: #ActionButton1 					#model: #browseControlClass 					#label: 'Browse Class' 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 4 11 ) 					#name: #Label2 					#label: 'Property Default Settings' ) ) ) )</body></methods><methods><class-id>Tools.ToolbarIconLibrary class</class-id> <category>resources</category><body package="ActiveX-UIPainter">activeXWidget20x20	"UIMaskEditor new openOnClass: self andSelector: #activeXWidget20x20"		&lt;resource: #image&gt;	| palette |	palette := Graphics.MappedPalette		withColors:			(#(#(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4401 4401 4401)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5814 5814 5814)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4240 4240 4240)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(546 546 546)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1959 1959 1959)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4947 4947 4947)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1253 1253 1253)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4079 4079 4079)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(6199 6199 6199)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(3919 3919 3919)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5332 5332 5332)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(225 225 225)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1638 1638 1638)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(6039 6039 6039)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(932 932 932)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4465 4465 4465)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(2184 2184 2184)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4304 4304 4304)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1317 1317 1317)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(2024 2024 2024)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4850 4850 4850)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(3276 3276 3276)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(2570 2570 2570)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(3983 3983 3983)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5396 5396 5396)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4690 4690 4690)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(6103 6103 6103)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5236 5236 5236)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(2249 2249 2249)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5075 5075 5075)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4369 4369 4369)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(6328 6328 6328)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1221 1221 1221)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4047 4047 4047)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5461 5461 5461)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1767 1767 1767)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(6713 6713 6713)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5139 5139 5139)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5846 5846 5846)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(739 739 739)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1445 1445 1445)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4272 4272 4272)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4979 4979 4979)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(578 578 578)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1124 1124 1124)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(2538 2538 2538)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5364 5364 5364)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(257 257 257)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4658 4658 4658)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(2377 2377 2377)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(2216 2216 2216)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(3309 3309 3309)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(4722 4722 4722)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1028 1028 1028)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5429 5429 5429)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(2441 2441 2441)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(1735 1735 1735)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(867 867 867)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(161 161 161)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(5975 5975 5975)) #(#{Graphics.ColorValue} 				#scaledRed:scaledGreen:scaledBlue: #(3694 3694 3694)))				collect:					[:each | 					(each at: 1) value						perform: (each at: 2)						withArguments: (each at: 3)]).	^CachedImage				on:					(Image						extent: 20 @ 20						depth: 6						bitsPerPixel: 8						palette: palette						usingBits:							(ByteArray fromPackedString:									'IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IPH IRT%IRT[M@,1IRT%IRT[F1,/O@\NF1,[J"0LG L%IRT%IQ,[F2&lt;@@@ [F1,VOAH[@2T%IRT%F1,[F3(@GQ,[G" 3F1,CIRT%IRT[F1,[K007F1(7EQ,[F0L%IRT%IQ,[F1,[NP@9HR&lt;[F1,[@2T%IRT%F1,[F1,6@C\BF1,[F1,CIRT%IRT[F1,[C"8@JA,[F1,[F0L%IRT%IQ,[F2\EI@4@EQ,[F1,[@2T%IRT%F1,/HQ4''D @.F1,[F1,CIRT%IRT[ER 5F1,[KP0/F1,[F0L%IRT%IS8DD!,[F1,R@AD[F1,[@2T%IRTQC18[F1,[F1,T@AT[F1,CIRT%@B$X@0LC@0LC@0(GH LC@0L%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IRT%IP@a'))</body><body package="ActiveX-UIPainter">activeXWidget20x20mask	"UIMaskEditor new openOnClass: self andSelector: #activeXWidget20x20mask"		&lt;resource: #image&gt;	^CachedImage		on:			(Image				extent: 20 @ 20				depth: 1				bitsPerPixel: 1				palette: CoveragePalette monoMaskPalette				usingBits:					#[0 0 0 0 0 0 0 0 0 0 0 0 1 131 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 31 255 192 0 63 255 192 0 127 255 192 0 0 0 0 0 0 0 0 0 0 0 0 0])</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>interface specs</category><body package="ActiveX-UIPainter">basicsEditSpec	"Tools.UIPainter new openOnClass: self andSelector: #basicsEditSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: ' ' 			#min: #(#{Core.Point} 298 187 ) 			#max: #(#{Core.Point} 298 187 ) 			#bounds: #(#{Graphics.Rectangle} 651 337 949 524 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.LabelSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{UI.AlignmentOrigin} 10 0 86 0 0 1 ) 					#label: 'ProgID' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 42 14 ) 					#name: #Label1 					#label: 'ActiveX' ) 				#(#{UI.MenuButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} 86 0 64 0 -10 1 87 0 ) 					#name: #clsidField 					#model: #progId 					#menu: #availableClassIdMenu ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 86 0 36 0 -10 1 58 0 ) 					#name: #InputField1 					#model: #model 					#type: #string ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 38 ) 					#name: #Label2 					#label: 'aspect' ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 86 107 ) 					#name: #CheckBox1 					#model: #initiallyDisabled 					#label: 'Initially Disabled' ) ) ) )</body></methods><methods><class-id>UI.ActiveXSpec class</class-id> <category>resources</category><body package="ActiveX-UIPainter">paletteIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteIcon"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 26@26 depth: 7 bitsPerPixel: 8 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(707 707 707)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6521 6521 6521)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4947 4947 4947)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6360 6360 6360)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1253 1253 1253)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2666 2666 2666)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4079 4079 4079)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4786 4786 4786)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1092 1092 1092)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5493 5493 5493)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3919 3919 3919)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5332 5332 5332)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1638 1638 1638)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6039 6039 6039)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6746 6746 6746)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(771 771 771)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6585 6585 6585)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5011 5011 5011)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6424 6424 6424)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1317 1317 1317)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(610 610 610)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2024 2024 2024)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3437 3437 3437)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5557 5557 5557)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1863 1863 1863)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3983 3983 3983)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5396 5396 5396)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6103 6103 6103)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(996 996 996)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2409 2409 2409)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3822 3822 3822)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6810 6810 6810)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(128 128 128)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6649 6649 6649)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1542 1542 1542)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2955 2955 2955)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5782 5782 5782)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2088 2088 2088)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6489 6489 6489)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2795 2795 2795)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5621 5621 5621)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6328 6328 6328)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5461 5461 5461)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6874 6874 6874)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1060 1060 1060)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3180 3180 3180)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3887 3887 3887)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6713 6713 6713)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2313 2313 2313)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3726 3726 3726)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5846 5846 5846)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1445 1445 1445)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6553 6553 6553)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3565 3565 3565)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6392 6392 6392)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5686 5686 5686)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(7099 7099 7099)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3405 3405 3405)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5525 5525 5525)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(418 418 418)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6232 6232 6232)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1670 1670 1670)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6071 6071 6071)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6778 6778 6778)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(964 964 964)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4497 4497 4497)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3790 3790 3790)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5204 5204 5204)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6617 6617 6617)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(96 96 96)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4336 4336 4336)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(642 642 642)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6456 6456 6456)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5750 5750 5750)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4882 4882 4882)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1188 1188 1188)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5589 5589 5589)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6296 6296 6296)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(2602 2602 2602)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(321 321 321)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1028 1028 1028)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6842 6842 6842)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1735 1735 1735)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5268 5268 5268)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6681 6681 6681)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5975 5975 5975)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(867 867 867)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1574 1574 1574)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(161 161 161)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3694 3694 3694)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ABP$IBP$IBP$IBP$IBP$IBP$IBP$IBP#(@@@@@P"5TUEQTUEQTUEQTUEQTUEQTUEQTUEP*@@@@@DH!HRD!HRD#H2L#H2L#H2L#H2L#H2L#J @@@@ABH2L#H2L#H2L#H2L#H2L#H2L#TBL#H2(@@@@@P"L#H2L#H2L#T@]PH2L#H2L]TQ\#H2LY@@@@@DIGQ4]GQ4]GQ3\^TT]GQ4\&lt;ATMDQ4]GO@@@@@ABDSX6M#X6M#X @PDLM#X6FPD3M#X6M 0@@@@@P# 8NC 8NC 8MA8AHC 8PC&lt; NC 8NC L@@@@@DH8NC 8NC 8NC RR!&lt;8J 5INC 8NC 8C@@@@@ABNC 8NC 8NC 8TA8AF0TCA@PDA@PDAEX@@@@@P",+J2,+J2,+J2,/OQ8LJ2,+J5APTEAF@@@@@DH]GQ4]GQ4]GQ4]IPAZGQ4]GQ4]GQ4]D0@@@@ABGQ4]GQ4]GQ5@A E[H"(]GQ4]GQ4]GQL@@@@@P!4]GQ4]GQ44UQ8LL @7GQ4]GQ4]GQ4S@@@@@DH]GQ4]GQ4LS%T&amp;GT4@G$@]GQ4]GQ4]D0@@@@ABGQ4]GQ4HE XNGQ4]CP@ GQ4]GQ4]GQL@@@@@P!4]GT@XT$T]GQ4]GQMHR"X]GQ4]GQ4S@@@@@DH]GR(MR  ]GQ4]GQ4]JP@;GQ4]GQ4]D0@@@@ABGQ45ID&lt;]GQ4]GQ4]GSPWQ!4]GQ4]GQL@@@@@P!4]D4@]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4S@@@@@DH]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]D0@@@@ABGQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQL@@@@@P!4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4]GQ4S@@@@@C(SD1LSD1LSD1LSD1LSD1LSD1LSD1LSD0@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@b')))</body><body package="ActiveX-UIPainter">paletteMonoIcon	"UIMaskEditor new openOnClass: self andSelector: #paletteMonoIcon"	&lt;resource: #image&gt;	^CachedImage on: ((Image extent: 26@26 depth: 1 bitsPerPixel: 1 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6681 6746 6649)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(1478 707 3951)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[255 255 255 192 128 0 0 64 128 0 0 64 128 0 0 64 128 0 0 64 128 16 24 64 128 56 48 64 128 24 48 64 128 24 64 64 128 12 128 64 128 13 0 64 128 14 0 64 128 14 0 64 128 30 0 64 128 54 0 64 128 99 0 64 128 195 0 64 129 1 128 64 134 1 128 64 140 0 128 64 128 0 0 64 128 0 0 64 128 0 0 64 128 0 0 64 128 0 0 64 255 255 255 192]))</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>COMDispatchSpecificationTable</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties specificationKey methodSpecifications propertySpecifications eventSpecifications </inst-vars><class-inst-vars>cachedSpecificationTables </class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Basics</category><attributes><package>Com- Automation</package></attributes></class><class><name>UISpecEnumerator</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>AspectEnumerator</name><environment>UI</environment><super>UI.UISpecEnumerator</super><private>false</private><indexed-type>none</indexed-type><inst-vars>source bindings actions clients incompletes details </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>ActiveXSpec</name><environment>UI</environment><super>UI.WidgetSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>progId controlProperties controlBindings licenseKey eventBindings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-UI</package></attributes></class><class><name>DispTypeSpec</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>DispUserDefTypeSpec</name><environment>External</environment><super>External.DispTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typelib docs typeFlags guid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>UIDefiner</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aClass initializeModels excludedBindings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Support</category><attributes><package>UIPainter</package></attributes></class><class><name>DispAliasTypeSpec</name><environment>External</environment><super>External.DispUserDefTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>actualType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>StreamControlProperties</name><environment>UI</environment><super>UI.BytelikeControlProperties</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><class><name>DispPtrTypeSpec</name><environment>External</environment><super>External.DispRefTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>IntegratedSpecModel</name><environment>Tools</environment><super>Tools.SpecModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertiesTool readMode interruptedRead </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class><class><name>DispSimpleTypeSpec</name><environment>External</environment><super>External.DispTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typecode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>GeneralPropertySpecification</name><environment>External</environment><super>External.COMAbstractMemberSpecification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>propertyGetSpecification propertySetSpecification isVTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Automation</package></attributes></class><class><name>DispEnumTypeSpec</name><environment>External</environment><super>External.DispComponentTypeSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Com- Automation</category><attributes><package>Com- Automation</package></attributes></class><class><name>ListControlProperties</name><environment>UI</environment><super>UI.AbstractControlProperties</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><class><name>UIPainterTool</name><environment>Tools</environment><super>Tools.UIPainterWatcher</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selection selectionKind controller currentSpecCopy currentSpecBindings specChannel subBuilder lock slice lastSlice slicesMenu sliceInfo client statusBarText list sliceChanging sliceTabChanging canvasTree menuBar currentView </inst-vars><class-inst-vars></class-inst-vars><imports>			private Smalltalk.TextConstants.*			</imports><category>UIPainter-Tools</category><attributes><package>UIPainter</package></attributes></class></st-source>