<?xml version="1.0"?><st-source><!-- Name: Com- External Data EnhancementsNotice: Copyright 1999-2015 Cincom Systems, Inc.  All rights reserved.Comment: Extensions to external data support runtime facilities.  The image-level mechanism for exporting objects for COM Server applications.DbIdentifier: bear73DbTrace: 464066DbUsername: aaugustinDbVersion: 8.0 - 11DevelopmentPrerequisites: #(#(#any 'Com- Interface Adaptors' '') #(#any 'Com- System Configuration Services' '') #(#any 'Com- CodeAnnotations' '') #(#any 'Com- ExtensionsToBase' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #()PackageName: Com- External Data EnhancementsParcel: #('ComExternalDataEnhancements')ParcelName: Com- External Data EnhancementsPrerequisiteDescriptions: #(#(#name 'Com- Interface Adaptors') #(#name 'Com- System Configuration Services') #(#name 'Com- CodeAnnotations') #(#name 'Com- ExtensionsToBase' #componentType #package))PrerequisiteParcels: #(#('Com- Interface Adaptors' '') #('Com- System Configuration Services' '') #('Com- CodeAnnotations' '') #('Com- ExtensionsToBase' ''))PrintStringCache: (8.0 - 11,aaugustin)Version: 8.0 - 11Date: 1:50:01 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:01</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ExportedObjectsTable</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objects lock exportedInterfaceCount accelerator </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>External-Data-Extensions</category><attributes><package>Com- External Data Enhancements</package></attributes></class><class><name>ExternalStructure</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structure memberNames protocolMap </inst-vars><class-inst-vars>structureName </class-inst-vars><imports></imports><category>External-Data-Extensions</category><attributes><package>Com- External Data Enhancements</package></attributes></class><shared-variable><name>AdaptorMapRegistry</name><environment>External.ExternalStructure</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- External Data Enhancements</package></attributes></shared-variable><methods><class-id>External.ExportedObjectsTable</class-id> <category>releasing</category><body package="Com- External Data Enhancements">invalidate	" Invalidate the contents of the receiver.  All registered objects will be lost. "	"	[ self triggerEvent: #confirmInvalidate ]		on: VetoAction		do: [ ^self ].	self triggerEvent: #invalidating.	"	self initialize.</body></methods><methods><class-id>External.ExportedObjectsTable</class-id> <category>private-accessing</category><body package="Com- External Data Enhancements">accelerator	^accelerator</body><body package="Com- External Data Enhancements">accelerator: anObject	accelerator := anObject</body><body package="Com- External Data Enhancements">exportTable	"Answer the table object that contains all the objects exported from Smalltalk's memory space into external memory space."	^objects</body><body package="Com- External Data Enhancements">exportTableLock	"Answer the recursion lock for the receiver's object export table. This lock is used for critcal section code accessing or modifying the export table."	^lock</body><body package="Com- External Data Enhancements">windowMessageClientName	^ #COM</body></methods><methods><class-id>External.ExportedObjectsTable</class-id> <category>accessing</category><body package="Com- External Data Enhancements">exportIndexFor: anObject	| index |	^self exportTableLock critical: 			[index := self accelerator at: anObject						ifAbsent: [self createNewEntryFor: anObject].			self incrementCounterAt: index + 1.			index]</body><body package="Com- External Data Enhancements">objectAt: anIndex	"Answer the object registered at &lt;anIndex&gt;."	^objects at: anIndex ifAbsent: [nil]</body><body package="Com- External Data Enhancements">registeredObjects	" Answer the objects which are registered in the receiver. "	^self accelerator keys</body><body package="Com- External Data Enhancements">releaseExportIndexFor: slot	"Remove the object registered at &lt;anIndex&gt; from the receiver.  The slot must have been obtained using the #exportIndexFor: protocol.  Releasing the wrong object will have undetermined results.  NOTE: The index is invalidated during image restart and is therefore not valid across snapshots."	| newCount |	^self exportTableLock critical: 			[newCount := self decrementCounterAt: (self refCountSlotForSlot: slot).			newCount = 0 ifTrue: [self removeObjectAt: slot]]</body></methods><methods><class-id>External.ExportedObjectsTable</class-id> <category>private</category><body package="Com- External Data Enhancements">createFreeEntry	| table oldSize |	table := self exportTable.	oldSize := table size.	table grow.	^ self findFreeEntry: oldSize + 1.</body><body package="Com- External Data Enhancements">createNewEntryFor: anObject	| freeEntry |	freeEntry := self findOrCreateFreeEntry.	self exportTable at: freeEntry put: anObject.	self exportTable at: (self refCountSlotForSlot: freeEntry) put: 0.	self accelerator at: anObject put: freeEntry.	anObject isCOMInterface ifTrue: [self incrementExportedInterfaceCount].	^freeEntry</body><body package="Com- External Data Enhancements">decrementCounterAt: slot	| oldValue newValue |	oldValue := self exportTable at: slot.	oldValue = 0		ifTrue: 			[self error: #InvalidReferenceCount &lt;&lt; #com &gt;&gt; 'Invalid Reference Count'].	newValue := oldValue - 1.	self exportTable at: slot put: newValue.	^newValue</body><body package="Com- External Data Enhancements">decrementExportedInterfaceCount	"Decrement the number of exported interfaces. If this is the last interface which was exported, disable window message processing on the main thread"	exportedInterfaceCount := exportedInterfaceCount - 1</body><body package="Com- External Data Enhancements">findFreeEntry: startIndex	| table |	table := self exportTable.	startIndex to: table size - 1		by: 2		do: [:index | (table at: index) isNil ifTrue: [^index]].	^ nil</body><body package="Com- External Data Enhancements">findOrCreateFreeEntry	^(self findFreeEntry: 1) ifNil: [self createFreeEntry]</body><body package="Com- External Data Enhancements">incrementCounterAt: slot	| newValue |	newValue := (self exportTable at: slot) + 1.	self exportTable at: slot put: newValue.	^ newValue</body><body package="Com- External Data Enhancements">incrementExportedInterfaceCount	"Increment the number of exported interfaces. If this is the first interface which is exported, enable window message processing on the main thread"	exportedInterfaceCount := exportedInterfaceCount + 1</body><body package="Com- External Data Enhancements">refCountSlotForSlot: slot	^ slot + 1</body><body package="Com- External Data Enhancements">removeObjectAt: slot	| table anObject |	table := self exportTable.	anObject := table at: slot.	table at: slot put: nil.	self accelerator removeKey: anObject.	anObject isCOMInterfaceImplementation		ifTrue: [self decrementExportedInterfaceCount].	self accelerator isEmpty ifTrue: [self initializeExportTable]</body></methods><methods><class-id>External.ExportedObjectsTable</class-id> <category>private-initialization</category><body package="Com- External Data Enhancements">initialize	" Private - initialize a newly created instance. "	self initializeExportTable.	lock := RecursionLock new.</body><body package="Com- External Data Enhancements">initializeExportTable	"Initialize the current export table. Sending this message results in all current exported objects to be flushed from the table and the index allocation to be reset. Send this only if you know what you are doing, otherwise run-time code that relies on currently exported objects will fail."	objects := Array new: 4.	exportedInterfaceCount := 0.	accelerator := IdentityDictionary new.</body></methods><methods><class-id>External.ExportedObjectsTable class</class-id> <category>accessing</category><body package="Com- External Data Enhancements">objectAt: anIndex	"Patch - implementation was wrong"	^self current objectAt: anIndex</body><body package="Com- External Data Enhancements">registerObject: anObject	" Register &lt;anObject&gt; in the system exported object table.  Answer the index under which it can be accessed. "	^self current exportIndexFor: anObject</body><body package="Com- External Data Enhancements">registeredObjects	" Answer the objects which are currently registered in the system exported objects table. "	" ExportedObjectsTable registeredObjects "	^self current registeredObjects</body><body package="Com- External Data Enhancements">removeObjectAt: anIndex	"Remove the object registered at &lt;anIndex&gt; in the system exported objects table. "	^self current releaseExportIndexFor: anIndex</body></methods><methods><class-id>External.ExportedObjectsTable class</class-id> <category>private-session management</category><body package="Com- External Data Enhancements">registerExternalObjectTable	" Private - register the exported objects table with the VM. "	" do nothing on VW - handling by initialize/invalidate "</body><body package="Com- External Data Enhancements">startupImage	" Private - the session is being started.  Reset the external object table. "	self current invalidate.</body></methods><methods><class-id>External.ExportedObjectsTable class</class-id> <category>testing</category><body package="Com- External Data Enhancements">isEmpty	" Answer whether there are any objects registered in the system exported objects table. "	^self notEmpty not</body><body package="Com- External Data Enhancements">notEmpty	" Answer whether there are any objects registered in the system exported objects table. "	^self registeredObjects notEmpty</body></methods><methods><class-id>External.ExportedObjectsTable class</class-id> <category>private-installation</category><body package="Com- External Data Enhancements">allocateExternalObjectTable	" Private - allocate the current EOT.  This is only done once when the EOT component is first installed. "	" don't reallocate if already installed "	self current class == self		ifTrue: [ ^self ].	self current: self new.</body><body package="Com- External Data Enhancements">obsolete	"The receiver was removed from the system and is now obsolete. Perform any necessary clean-up. 	Answer the receiver."	self removeSessionEventHandlers.	self current: nil.	^super obsolete</body><body package="Com- External Data Enhancements">registerSessionEventHandlers	" Register the image startup and shutdown event handlers. "	" ExportedObjectsTable registerSessionEventHandlers "	COMSystem current when: #coreStartupCompleted 		send: #startupImage to: self.</body><body package="Com- External Data Enhancements">removeSessionEventHandlers	" Remove the image startup and shutdown event handlers. "	" ExportedObjectsTable removeSessionEventHandlers "	COMSystem current removeAllActionsWithReceiver: self.</body></methods><methods><class-id>External.ExportedObjectsTable class</class-id> <category>private-events</category><body package="Com- External Data Enhancements">constructEventsTriggered        "Private - answer the set of events that instances of the        receiver can trigger."	^super constructEventsTriggered		"Not currently supported, needs further contemplation:		add: #confirmInvalidate ;		add: #invalidating ;		"		yourself</body></methods><methods><class-id>External.ExportedObjectsTable class</class-id> <category>private-instance creation</category><body package="Com- External Data Enhancements">new	"Answer an initialized and empty instance of the receiver."	^super new initialize</body></methods><methods><class-id>External.ExportedObjectsTable class</class-id> <category>private-accessing</category><body package="Com- External Data Enhancements">current	" Answer the current exported objects table.  There is one global instance in the system. "	^current</body><body package="Com- External Data Enhancements">current: anExternalObjectTable	" Private - set the current exported object table.  There is one global instance in the system. "	( anExternalObjectTable notNil and: [ current notNil ] )		ifTrue: [ 			MessageBox warning: (#ObjectTableAlreadyAllocated &lt;&lt; #com &gt;&gt; 'Exported object table already allocated') asString.			^self ].	current := anExternalObjectTable.</body></methods><methods><class-id>External.ExportedObjectsTable class</class-id> <category>class initialization</category><body package="Com- External Data Enhancements">initialize	self allocateExternalObjectTable.	self registerSessionEventHandlers.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>accessing-type information</category><body package="Com- External Data Enhancements">fundamentalType	" Answer the C data type of the structure accessed by the receiver. "	^self class getFundamentalTypeOf: ( self isValid		ifTrue: [ structure type ]		ifFalse: [ self class baseCType ] )</body><body package="Com- External Data Enhancements">memberNames	" Answer the names of the members in the structure accessed by the receiver. "	memberNames isNil		ifTrue: [ self initializeMemberNames ].	^memberNames</body><body package="Com- External Data Enhancements">sizeInBytes     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly.  Should be reimplemented by subclasses with variable-length data. "	| delegationAction |	" allow instance-specific overriding of this operation for structures which themselves hold this information "	( delegationAction := self delegationActionFor: #sizeInBytes ) notNil		ifTrue: [ ^delegationAction evaluate ].	^self structureType sizeof</body><body package="Com- External Data Enhancements">sizeof     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly. "	^self sizeInBytes</body><body package="Com- External Data Enhancements">structureType	" Answer the C data type of the structure accessed by the receiver. "	^self isValid		ifTrue: [ self class getFundamentalTypeOf: structure type ]		ifFalse: [ self class baseCType ]</body><body package="Com- External Data Enhancements">type	" Answer the C data type of the structure accessed by the receiver. "	^self isValid		ifTrue: [ structure type ]		ifFalse: [ self class type ]</body><body package="Com- External Data Enhancements">typeProvider	" Answer the object which can provide definitions from the type name space of the receiver. "	^self class typeProvider</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>private-testing</category><body package="Com- External Data Enhancements">isMemberGetSelector: aSelector	" Answer whether &lt;aSelector&gt; is a member get selector. "	^aSelector numArgs = 0 		and: [ memberNames includes: aSelector ]</body><body package="Com- External Data Enhancements">isMemberSetSelector: aSelector	" Answer whether &lt;aSelector&gt; is a member set selector. "	| maybeMemberName |	aSelector numArgs = 1		ifFalse: [ ^false ].	maybeMemberName := aSelector copyFrom: 1 to: aSelector size - 1.  " still a string here... "	^( memberNames detect: [ :mn | mn asString = maybeMemberName ]		ifNone: [ nil ] )			notNil</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>subclass-initializing</category><body package="Com- External Data Enhancements">constructDelegationActionFor: aSelector specification: delegationSpecification 	" Answer an action which implements the processing of the message &lt;aSelector&gt; for the receiver according to &lt;delegationSpecification&gt;. "	" the delegation specification can be a selector or an array containing the selector and one or more arguments to append to the incoming message "	| delegationSelector argumentMap numIncomingArgs remapsIncomingArgs arguments |	delegationSpecification isSymbol 		ifTrue: [^MessageSend forReceiver: self selector: delegationSpecification].	delegationSelector := delegationSpecification at: 1.	argumentMap := delegationSpecification at: 2.	arguments := Array new: delegationSelector numArgs.	argumentMap size = arguments size 		ifFalse: 			[self error: #ErrMixedArgMapSpec &lt;&lt; #com &gt;&gt; 'inconsistent argument map specification'].	numIncomingArgs := aSelector numArgs.	remapsIncomingArgs := false.	1 to: argumentMap size		do: 			[:i | 			| anArgSpec anArgValue |			anArgSpec := argumentMap at: i.			anArgSpec = '&lt;memberName&gt;' 				ifTrue: 					[" #memberGet or #memberSet "					"Assert isTrue: [ i = 1]."					" usually, anyway "					anArgValue := aSelector last = $: 								ifTrue: 									["Assert isTrue: [ aSelector numArgs = 1 ]."									(aSelector readStream upTo: $:) asSymbol]								ifFalse: [aSelector]]				ifFalse: 					[(anArgSpec isString and: [anArgSpec first = $&lt; and: [anArgSpec last = $&gt;]]) 						ifTrue: 							[" input argument remapping spec "							| inputIndex |							inputIndex := Integer 										readFrom: (anArgSpec copyFrom: 2 to: anArgSpec size - 1) readStream.							(inputIndex between: 1 and: numIncomingArgs) 								ifFalse: [self error: #ErrInvalidArgRemap &lt;&lt; #com &gt;&gt; 'invalid argument remapping'].							anArgValue := CollectionAccessor for: inputIndex.							remapsIncomingArgs := true]						ifFalse: 							[" the real argument value "							anArgValue := anArgSpec]].			arguments at: i put: anArgValue].	^(remapsIncomingArgs ifTrue: [LinkMessage] ifFalse: [MessageSend]) 		receiver: self		selector: delegationSelector		arguments: arguments</body><body package="Com- External Data Enhancements">initializeMemberNames	" Private - initialize the cached list of member names in the structure accessed by the receiver. "	self memberNames: ( self class memberNamesForType: self type ).</body><body package="Com- External Data Enhancements">initializeProtocolMap	" Private - initialize the protocol map of dynamic message selectors supported by the receiver. "	| adaptorSpecifications delegationAction |	protocolMap := nil.	structure isNil		ifTrue: [ ^self ].	adaptorSpecifications := self class adaptorSpecificationsForType: structure type.	adaptorSpecifications isNil		ifTrue: [ ^self ].	protocolMap := IdentityDictionary new.	adaptorSpecifications keysAndValuesDo: [  :aSelector :delegationSpecification |		delegationAction := self constructDelegationActionFor: aSelector 			specification: delegationSpecification.		protocolMap at: aSelector put: delegationAction ].</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>accessing-members</category><body package="Com- External Data Enhancements">bytesAtOffset: anInteger count: anInteger2	"Answer a ByteArray with &lt;anInteger2&gt; bytes copied from the receiver starting at &lt;anInteger&gt;.  Offsets are zero relative."	self isInExternalMemory		ifTrue: [			| bytes |			bytes := ByteArray new: anInteger2.			( CIntegerType unsignedShort pointerType cast: structure )				copyAt: anInteger				to: bytes				size: anInteger2				startingAt: 1.			^bytes ].    ^structure asByteArray copyFrom: (anInteger + 1) to: (anInteger + anInteger2)</body><body package="Com- External Data Enhancements">bytesAtOffset: anInteger put: aByteObject	" Store &lt;aByteObject&gt; starting at offset &lt;anInteger&gt; in the receiver.  Offsets are zero relative."	aByteObject == nil		ifTrue: [ ^self ].	self isInExternalMemory		ifTrue: [			( CIntegerType unsignedShort pointerType cast: structure )				copyAt: anInteger				from: aByteObject				size: aByteObject size				startingAt: 1 ]		ifFalse: [			structure datum replaceBytesFrom: anInteger + 1				to: anInteger + aByteObject size				with: aByteObject				startingAt: 1 ].</body><body package="Com- External Data Enhancements">memberAt: aMember	"Answer the value of the member named by the symbol &lt;aMember&gt;. "	^structure memberAt: aMember</body><body package="Com- External Data Enhancements">memberAt: aMember put: aValue	"Set the value of the member named by the symbol &lt;aMember&gt; to &lt;aValue&gt;. "	structure memberAt: aMember put: aValue.</body><body package="Com- External Data Enhancements">nestedMemberAt: aDotMember 	"Answer the value of the member named by the symbol &lt;aDotMember&gt;. "	| nestedMemberNames |	nestedMemberNames := self nestedMemberNames: aDotMember.	nestedMemberNames size = 2 		ifFalse: 			[self error: #ErrSingleDotNotation &lt;&lt; #com 						&gt;&gt; 'only single-level dot notation currently supported'].	^self isInExternalMemory 		ifTrue: 			[" this can be done a bit more efficiently because we can form a pointer "			(self structure refMemberAt: (nestedMemberNames at: 1)) 				memberAt: (nestedMemberNames at: 2)]		ifFalse: 			[(self memberAt: (nestedMemberNames at: 1)) 				memberAt: (nestedMemberNames at: 2)]</body><body package="Com- External Data Enhancements">nestedMemberAt: aDotMember put: aValue 	"Set the value of the member named by the symbol &lt;aDotMember&gt;. "	| nestedMemberNames |	nestedMemberNames := self nestedMemberNames: aDotMember.	nestedMemberNames size = 2 		ifFalse: 			[self error: #ErrSingleDotNotation &lt;&lt; #com 						&gt;&gt; 'only single-level dot notation currently supported'].	self isInExternalMemory 		ifTrue: 			[" this can be done a bit more efficiently because we can form a pointer "			| lpNestedMember |			lpNestedMember := self structure refMemberAt: (nestedMemberNames at: 1).			lpNestedMember memberAt: (nestedMemberNames at: 2) put: aValue]		ifFalse: 			[| nestedMemberValue |			nestedMemberValue := self memberAt: (nestedMemberNames at: 1).			nestedMemberValue memberAt: (nestedMemberNames at: 2) put: aValue.			self memberAt: (nestedMemberNames at: 1) put: nestedMemberValue]</body><body package="Com- External Data Enhancements">pointerMemberAt: aMemberName	" Answer the pointer member named &lt;aMemberName&gt;.  Answer nil if there is no address. "	| aPointer |	aPointer := structure memberAt: aMemberName.	^aPointer isNull		ifTrue: [ nil ]		ifFalse: [ aPointer ]</body><body package="Com- External Data Enhancements">pointerMemberAt: aMemberName put: anAddress	" Set the pointer member named &lt;aMemberName&gt; to &lt;anAddress&gt;. "	structure memberAt: aMemberName put: anAddress asPointerParameter.</body><body package="Com- External Data Enhancements">referenceToNestedMemberAt: aDotMember 	"Answer the value of the member named by the symbol &lt;aDotMember&gt;. "	| nestedMemberNames |	nestedMemberNames := self nestedMemberNames: aDotMember.	nestedMemberNames size = 2 		ifFalse: 			[self error: #ErrSingleDotNotation &lt;&lt; #com 						&gt;&gt; 'only single-level dot notation currently supported'].	^self isInExternalMemory 		ifTrue: 			[" this can be done a bit more efficiently because we can form a pointer "			(self structure refMemberAt: (nestedMemberNames at: 1)) 				refMemberAt: (nestedMemberNames at: 2)]		ifFalse: 			[(self memberAt: (nestedMemberNames at: 1)) 				memberAt: (nestedMemberNames at: 2)]</body><body package="Com- External Data Enhancements">stringAtOffset: anInteger 	" Private - answer the null-terminated string at offset &lt;anInteger&gt; from the start of the receiver. Offsets are zero relative."	self isInExternalMemory 		ifTrue: 			[| lpString |			lpString := CIntegerType char pointerType 						cast: structure asPointerParameter.			lpString += anInteger.			^lpString copyCStringFromHeap]		ifFalse: 			[self error: #ErrStringFromStrucBuf &lt;&lt; #com 						&gt;&gt; 'string extraction from internal structure buffer not supported'			"perhaps something along the lines of the following (inefficient) logic:			| bytes |			bytes := structure asByteArray.			^String fromBytes: ( bytes copyFrom: offset + 1 to: bytes sizeInBytes ) ]			"]</body><body package="Com- External Data Enhancements">stringPointerMemberAt: aMemberName	" Answer a string containing the characters stored in external memory in platform encoding at the address referenced by the pointer member named &lt;aMemberName&gt;.  Answer nil if the address is NULL. "	| lpString |	lpString := structure memberAt: aMemberName.	^lpString isNull		ifTrue: [ nil ]		ifFalse: [ lpString copyCStringFromHeap ]</body><body package="Com- External Data Enhancements">structureMemberAt: aMemberName	" Answer a structure wrapper on the structure member named &lt;aMemberName&gt; in the receiver. "	^self class temporaryOn: ( self memberAt: aMemberName )</body><body package="Com- External Data Enhancements">structureMemberAt: aMemberName put: aStructure	" Set the contents of the structure member named &lt;aMemberName&gt; in the receiver from &lt;aStructure&gt; "	self memberAt: aMemberName put: aStructure asStructureParameter.</body><body package="Com- External Data Enhancements">unicodePointerMemberAt: aMemberName	" Answer a string containing the characters stored in external memory in Unicode encoding at the address referenced by the pointer member named &lt;aMemberName&gt;.  Answer nil if the address is NULL. "	| lpString |	lpString := structure memberAt: aMemberName.	^lpString isNull		ifTrue: [ nil ]		ifFalse: [ lpString copyUnicodeStringFromHeap ]</body><body package="Com- External Data Enhancements">unionMemberAt: aDotMember	" Answer the value of the union member named by the symbol &lt;aDotMember. "	" This is primarily a placeholder for references to unnamed union members		in structures, which currently are forced to have a union name field		added in to work around an external declaration compilation problem.		Also use to track potential optimization of named unions. "	^self nestedMemberAt: aDotMember</body><body package="Com- External Data Enhancements">unionMemberAt: aDotMember put: aValue	" Set the value of the union member named by the symbol &lt;aDotMember. "	" This is primarily a placeholder for references to unnamed union members		in structures, which currently are forced to have a union name field		added in to work around an external declaration compilation problem.		Also use to track potential optimization of named unions. "	self nestedMemberAt: aDotMember put: aValue.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>external copying</category><body package="Com- External Data Enhancements">copyFromHeap	"Copy the structure accessed by the receiver from the external heap to an internal structure and release the heap memory.  Answer the receiver. "	| internalStructure |	self isInExternalMemory		ifTrue: [ 			internalStructure := self structure contents.			"Assert isTrue: [ internalStructure type pointerType = self structure type ]."			self structure free.			self structure: internalStructure ].	^self</body><body package="Com- External Data Enhancements">copyToHeap	"Copy the structure accessed by the receiver to the external heap.  Answer a pointer to the data."	self isInExternalMemory		ifFalse: [ self structure: self structure copyToHeap ].	^self</body><body package="Com- External Data Enhancements">gcCopyToHeap	"Copy the structure accessed by the receiver to the external heap.  Answer a pointer to the data that is registered for automatic garbage collection."	self copyToHeap.	self structure beGarbageCollectable.	^self</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>private-external copying</category><body package="Com- External Data Enhancements">copyToHeap: mallocSelector	"Copy the receiver to the external heap.  The argument is a method selector that accepts one argument and determines how to allocate data for the receiver -- it is typically one of #malloc: or #malloc16:.  The selector's argument is the number of objects of the receiver's baseCType to allocate.  Answer a pointer to the data.  If the allocation fails a primitive failed signal is raised."	self shouldNotImplement.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>printing</category><body package="Com- External Data Enhancements">printContentDescriptionOn: aStream	" Append a text description of the receiver's contents to &lt;aStream&gt; "	self isValid		ifFalse: [ 			aStream nextPutAll:  ' {invalid}'.			^self ].	aStream nextPutAll: ' {'.	self isInExternalMemory		ifTrue: [ structure asInteger printOn: aStream paddedWith: $0 to: 8 base: 16 ]		ifFalse: [ aStream nextPutAll: 'bytes' ].	aStream nextPut: $}.</body><body package="Com- External Data Enhancements">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt; "	| delegationAction |	" allow instance-specific overriding of this operation for structures which want to customize their representation "	( delegationAction := self delegationActionFor: #printOn: ) notNil		ifTrue: [ ^delegationAction evaluateWithArguments: ( Array with: aStream ) ].	self		printWrapperDescriptionOn: aStream;		printContentDescriptionOn: aStream.</body><body package="Com- External Data Enhancements">printWrapperDescriptionOn: aStream	" Append a text description of the receiver itself to &lt;aStream&gt; "	super printOn: aStream.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>private-accessing</category><body package="Com- External Data Enhancements">memberNames: memberNamesList	" Specify the names of the members in the structure accessed by the receiver. "	memberNames := memberNamesList.</body><body package="Com- External Data Enhancements">nestedMemberNames: aSymbol	" Private - answer an array containing the nested member referenced in a dot notation member name. "	| tempMemberNames aStream aMemberName |	Tools.Note ISSUEin72. "memberNames overrides instance variable - assuming this is intended -renamed it to tempMemberNames for code critic"	tempMemberNames := OrderedCollection new.	aStream := aSymbol readWriteStream.	[ aStream atEnd ] whileFalse: [		aMemberName := aStream upTo: $..		tempMemberNames add: aMemberName asSymbol ].	^tempMemberNames asArray"TESTING:	ExternalStructure basicNew nestedMemberNames: #'u.field'	ExternalStructure basicNew nestedMemberNames: #'struct.field'	ExternalStructure basicNew nestedMemberNames: #'struct.u.field'"</body><body package="Com- External Data Enhancements">protocolMap	" Private - answer the protocol map of &lt;dynamic selector&gt; -&gt; &lt;action&gt;. "	^protocolMap</body><body package="Com- External Data Enhancements">protocolMap: aDictionary	" Private - specify the protocol map of &lt;dynamic selector&gt; -&gt; &lt;action&gt;. "	protocolMap := aDictionary.</body><body package="Com- External Data Enhancements">setBytes: aByteObject	" Private - set the contents of the receiver to &lt;aByteObject&gt;. "	aByteObject size = self class sizeInBytes		ifFalse: [ self error: #ErrIncorrectSize &lt;&lt; #com &gt;&gt; 'incorrect size' ].	self bytesAtOffset: 0 put: aByteObject.</body><body package="Com- External Data Enhancements">structure	" Private - answer the structure "	^structure</body><body package="Com- External Data Enhancements">structure: aStructure	" Private - set the structure "	structure := aStructure.	self initializeProtocolMap.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>subclass-accessing</category><body package="Com- External Data Enhancements">delegationActionFor: aSelector	" Private - answer dynamic protocol delegation action for &lt;aSelector&gt;.  Answer nil if none defined. "	protocolMap isNil		ifTrue: [ ^nil ].	^protocolMap at: aSelector 		ifAbsent: [ nil ]</body><body package="Com- External Data Enhancements">memberNameFromGetSelector: aSelector	" Answer the member name if &lt;aSelector&gt; is a member get selector. "	^( aSelector numArgs = 0 	and: [ memberNames includes: aSelector ] )		ifTrue: [ aSelector ]		ifFalse: [ nil ]</body><body package="Com- External Data Enhancements">memberNameFromSetSelector: aSelector	" Answer the member name if &lt;aSelector&gt; is a member set selector. "	| maybeMemberName |	aSelector numArgs = 1		ifFalse: [ ^nil ].	maybeMemberName := aSelector copyFrom: 1 to: aSelector size - 1.  " still a string here... "	memberNames detect: [ :mn | mn asString = maybeMemberName ]		ifNone: [ ^nil ].	^maybeMemberName asSymbol</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>private-operation</category><body package="Com- External Data Enhancements">doesNotUnderstand: aMessage	" Private - support dynamic protocol for member accessing. "	| delegationAction memberName |	( delegationAction := self delegationActionFor: aMessage selector ) notNil		ifTrue: [ ^delegationAction evaluateWithArguments: aMessage arguments ].	self memberNames size = 0		ifTrue: [ ^super doesNotUnderstand: aMessage ].	" member getter: #foo -&gt; structure memberAt: #foo "	( memberName := self memberNameFromGetSelector: aMessage selector ) notNil		ifTrue: [ ^self perform: #memberAt: with: memberName ].	" member setter: #foo: aValue -&gt; structure memberAt: #foo put: aValue "	( memberName := self memberNameFromSetSelector: aMessage selector ) notNil		ifTrue: [ 			^self perform: #memberAt:put: with: memberName				with: aMessage arguments first ].	" hmm, must not be a member accessor after all "	^super doesNotUnderstand: aMessage</body><body package="Com- External Data Enhancements">startupImage	^ self privateInvalidate.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>accessing-datum</category><body package="Com- External Data Enhancements">clearContents	"Clear the contents of the receiver's structure."	"structure clearContents."	self isInExternalMemory		ifTrue: [  " CCompositePointer&gt;&gt;clearContents "			| nBytes |			nBytes := self sizeInBytes.			structure copyAt: 0				from: ( ByteArray new: nBytes )				size: nBytes 				startingAt: 1 ]		ifFalse: [   " CCompositePointer&gt;&gt;clearContents "			| nBytes newDatum |			nBytes := structure datum sizeInBytes.			newDatum := ( structure datum hasFixedData				ifTrue: [ structure datum class newInFixedSpace: nBytes ]				ifFalse: [ structure datum class new: nBytes ] ).			structure datum: newDatum ]</body><body package="Com- External Data Enhancements">contents	"Answer the contents of the receiver's structure."	^structure contents</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>testing</category><body package="Com- External Data Enhancements">isInExternalMemory	"Answer whether the receiver's contents stored in external memory."	^structure isExternalAddress and: [ structure isValid ]</body><body package="Com- External Data Enhancements">isSafeForExternalFunctionArgument	" Answer whether the receiver's structure buffer is allocated in fixed space or external memory so that it can be used as an external function call argument. "	^self isInExternalMemory		or: [ structure datum isFixedArgument ]</body><body package="Com- External Data Enhancements">isValid	"Answer whether the receiver is valid (accessible)."	^self isInExternalMemory or: [ structure class "isBits" == CComposite ]</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>converting</category><body package="Com- External Data Enhancements">asByteArray	" Answer the structure bytes. "	" Observe also that this would be easier if CDatum supported		polymorphic #contents protocol across local and external		structures.  This could use some work. "	^self isInExternalMemory		ifTrue: [ structure contents datum asByteArray ]		ifFalse: [ structure datum asByteArray ]</body><body package="Com- External Data Enhancements">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	| res |	self isSafeForExternalFunctionArgument ifFalse: [self gcCopyToHeap].	" ensure that any pointer parameter is in stable storage "	res := structure asPointerParameter.	"Don't protect fixedspace objects."	res isExternalAddress		ifTrue: 			["We need to copy the pointer to avoid creating a cyclic references in the gcprotection registry"			res := res copy.			SystemGlobalRegistries safe: self forLifeTimeOf: res].	^res</body><body package="Com- External Data Enhancements">asSeparateStructureParameter	"Answer the receiver in a form suitable for passing as a structure parameter to an external function call."	^structure asSeparateStructureParameter</body><body package="Com- External Data Enhancements">asStructureParameter	"Answer the receiver in a form suitable for passing as a structure parameter to an external function call."	^ structure asStructureParameter.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>subclass-releasing</category><body package="Com- External Data Enhancements">releaseResources		" Private - release resources owned by the receiver.		Default is to do nothing.  Should be reimplemented by 		subclasses whose fields reference external resources 		which must be released (e.g., external memory). "	| delegationAction |	" allow instance-specific overriding of this operation for structures which need to customize their release logic "	( delegationAction := self delegationActionFor: #releaseResources ) notNil		ifTrue: [ ^delegationAction evaluate ].	self releaseStructure.</body><body package="Com- External Data Enhancements">releaseStructure	" Private - release the structure itself. "	self isInExternalMemory 		ifTrue: [ self structure free ].	self structure: nil.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>releasing</category><body package="Com- External Data Enhancements">enforceInvalidation	"Set the receiver to be invalid."	^self privateInvalidate</body><body package="Com- External Data Enhancements">enforceRelease	" Immediately release any system resources associated with the receiver. "	^ self privateRelease</body><body package="Com- External Data Enhancements">invalidate	"Set the receiver to be invalid."	self callIndicatesChangeNeeded</body><body package="Com- External Data Enhancements">privateInvalidate	"Set the receiver to be invalid."	self doesNotNeedFinalization.	self isInExternalMemory ifTrue: [self structure enforceInvalidation].	self structure: nil</body><body package="Com- External Data Enhancements">release	"Explicite release of COM resources is not supported any more"	^self callIsDispensable</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>finalizing</category><body package="Com- External Data Enhancements">privateRelease	" Release any system resources associated with the receiver. "	self doesNotNeedFinalization.	self releaseResources.	^ super release.</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>type information utilities</category><body package="Com- External Data Enhancements">getFundamentalTypeOf: aType	" Dereference typedef's and pointers to get to the real type definition of &lt;aType&gt;. "	| fundamentalType |	fundamentalType := self getRealTypeOf: aType.	[ fundamentalType isPointer ]		whileTrue: [ fundamentalType := self getRealTypeOf: fundamentalType referentType ].	^fundamentalType</body><body package="Com- External Data Enhancements">getRealTypeOf: aType	" Dereference typedef's to get to the real type definition of &lt;aType&gt;. "	| realType |	realType := aType.	[ realType type == realType ]		whileFalse: [ realType := realType type ].	^realType</body><body package="Com- External Data Enhancements">memberNamesForType: aType	" Answer the names of the members of the structure &lt;aType&gt;. "	| aStructureType names |	aType isNil		ifTrue: [ ^#( ) ].	aStructureType := self getFundamentalTypeOf: aType.  " dereference pointers and typedefs "	"Assert isTrue: [ aStructureType isComposite ]."	names := SortedCollection new.	aStructureType keysAndValuesDo: [ :aName :anAssoc |		names add: aName ].	^names asArray</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>accessing-type information</category><body package="Com- External Data Enhancements">fixedDataSizeInBytes     " Answer the size in bytes of the fixed data layout portion of the structure represented by instances of the receiver.  For structures with variable-length array elements or other data appended to the end of the fixed data, the actual size in bytes may be larger than the minimum fixed-region.  Should be reimplemented by subclases with variable-length data. "	^self sizeInBytes</body><body package="Com- External Data Enhancements">memberNames	" Answer the names of the members of the structure represented by instance of the receiver. "	^self memberNamesForType: self type</body><body package="Com- External Data Enhancements">sizeInBytes     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly. "	| aStructureType |	^( aStructureType := self baseCType ) isNil		ifTrue: [ nil ]		ifFalse: [ aStructureType sizeof ]</body><body package="Com- External Data Enhancements">type	" Answer the C structure type accessed by instances of the receiver. "	^self baseCType</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>accessing-adaptor specifications</category><body package="Com- External Data Enhancements">adaptorSpecificationsForType: aType	" Answer the adaptor protocol specifications for &lt;aType&gt;. "	^self adaptorMapRegistry at: aType name		ifAbsent: [ ^nil ]</body><body package="Com- External Data Enhancements">registerTypeName: aStructureTypeName adaptorProtocol: aProtocolMapSpecification	" Register the specifications for constructing a structure protocol adaptor on the type named &lt;aStructureTypeName&gt;. "	self adaptorMapRegistry at: aStructureTypeName		put: aProtocolMapSpecification.</body><body package="Com- External Data Enhancements">unregisterTypeName: aStructureTypeName	" Remove the protocol adaptor map specifications for the type named &lt;aStructureTypeName&gt;. "	self adaptorMapRegistry removeKey: aStructureTypeName ifAbsent: [].</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>subclass-accessing</category><body package="Com- External Data Enhancements">structureName: aSymbol	" Private - set the name of the C data type accessed by of instances of the receiver. "	structureName := aSymbol.</body><body package="Com- External Data Enhancements">typeNamed: aStructureName	" Private - answer the C type definition of the structure named &lt;aStructureName&gt;. "	^self typeProvider typeNamed: aStructureName asSymbol</body><body package="Com- External Data Enhancements">typeProvider	" Answer the object which can provide definitions from the type name space of the receiver. "	self subclassResponsibility.</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>private-accessing</category><body package="Com- External Data Enhancements">adaptorMapRegistry	" Answer the registry of adaptor mappings (type name -&gt; protocol map specifications). "	^AdaptorMapRegistry</body><body package="Com- External Data Enhancements">adaptorMapRegistry: aDictionary	" Answer the registry of adaptor mappings (type name -&gt; protocol map specifications). "	AdaptorMapRegistry := aDictionary.</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>subclass-instance creation</category><body package="Com- External Data Enhancements">allocateStructure: aType	" Private - allocate a structure buffer of type &lt;aType&gt;. "	^self useFixedSpace		ifTrue: [ self allocateStructureInFixedSpace: aType ]		ifFalse: [ self allocateStructureInExternalMemory: aType ]</body><body package="Com- External Data Enhancements">allocateStructureInExternalMemory: aType	" Private - allocate a structure buffer of type &lt;aType&gt;. "	" need to retain zero-initialization semantics, which #malloc unfortunately does not provide "	"^aType gcMalloc"	^aType gcCalloc.</body><body package="Com- External Data Enhancements">allocateStructureInFixedSpace: aType	" Private - allocate a structure buffer of type &lt;aType&gt; in fixed space. "	^aType newInFixedSpace</body><body package="Com- External Data Enhancements">privateNew	" Private - answer a new instance of the receiver. "	^self basicNew</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>instance creation</category><body package="Com- External Data Enhancements">forType: aType	" Construct a new instance of the structure &lt;aType&gt;. "	^self onNew: ( self allocateStructure: aType )</body><body package="Com- External Data Enhancements">forTypeNamed: aStructureTypeName	" Construct a new instance of the structure named &lt;aTypeName&gt;. "	^self forType: ( self typeNamed: aStructureTypeName )</body><body package="Com- External Data Enhancements">new	" Answer a new instance of the receiver. "	" Fixed space or external heap memory is used to ensure that the structure 		is in stable memory and thus can be used as an external function argument. "	self type isNil		ifTrue: [ self error: (#NoTypeAvailToCreate &lt;&lt; #com &gt;&gt; 'no type available to create &lt;1s&gt;' expandMacrosWith: self name) ].	^self onNew: ( self allocateStructure: self type )</body><body package="Com- External Data Enhancements">newInExternalMemory	" Answer a new instance of the receiver with structure buffer allocated in external memory. "	self type isNil		ifTrue: [ self error: (#NoTypeAvailToCreate &lt;&lt; #com &gt;&gt; 'no type available to create &lt;1s&gt;' expandMacrosWith: self name) ].	^self onNew: ( self allocateStructureInExternalMemory: self type )</body><body package="Com- External Data Enhancements">newInFixedSpace	" Answer a new instance of the receiver with an internal byte buffer allocated in fixed space. "	" Fixed space is used to ensure that the structure can be used as an external function argument. "	self type isNil		ifTrue: [ self error: (#NoTypeAvailToCreate &lt;&lt; #com &gt;&gt; 'no type available to create &lt;1s&gt;' expandMacrosWith: self name) ].	^self onNew: ( self allocateStructureInFixedSpace: self type )</body><body package="Com- External Data Enhancements">on: aStructureOrPointer	" Answer a new instance of the receiver for the structure &lt;aStructureOrPointer&gt;. "	self deprecated: 'use temporaryOn:/onNew: instead'.	^self privateNew		structure: aStructureOrPointer;		yourself</body><body package="Com- External Data Enhancements">onNew: aStructure	^(self temporaryOn: aStructure)		needsFinalization;		yourself</body><body package="Com- External Data Enhancements">temporaryOn: aStructureOrPointer	"return a variant which represents a server temporary not-reference counted object"	^ self privateNew		structure: aStructureOrPointer;		yourself</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>external-transformations</category><body package="Com- External Data Enhancements">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery. "	self structureName == nil		ifTrue: [ ^nil ].	^self typeNamed: self structureName</body><body package="Com- External Data Enhancements">fromReturnValue: aStructureResult	" Private - answer a new instance of the receiver from the result value &lt;aStructureResult&gt;. "	"Assert isTrue: [ aStructureResult isExternalAddress or: [ aStructureResult class == CComposite ] ]."	^self onNew: aStructureResult</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>subclass-testing</category><body package="Com- External Data Enhancements">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" Fixed space is preferred, since it provides automatic zero-initialization, as expected by a Smalltalk programmer of their byte objects, and because the system automation garbage collects the object.  Allocating in external memory is more expensive, particularly because the more expensive #gcMalloc form must be used rather than #malloc in order to insulate clients from each having to participate in object management.  Wasn't that we like Smalltalk in the first place? "	^true</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>accessing</category><body package="Com- External Data Enhancements">structureName	" Answer the name of the C structure type accessed by instances of the receiver. "	^structureName</body></methods><methods><class-id>External.ExternalStructure class</class-id> <category>class initialization</category><body package="Com- External Data Enhancements">initialize	self adaptorMapRegistry: IdentityDictionary new.</body></methods><methods><class-id>Core.Integer</class-id> <category>converting</category><body package="Com- External Data Enhancements">asHandleParameter	"Answer the receiver in a form suitable for passing as a host handle parameter to an external function call."	^self</body><body package="Com- External Data Enhancements">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."    ^self</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Com- External Data Enhancements">asStringParameter	"Answer the receiver in a form suitable for passing as a null-terminated string in platform encoding to an external function call."	^self gcCopyToHeap</body><body package="Com- External Data Enhancements">asUnicodeParameter	"Answer the receiver in a form suitable for passing as a null-terminated string in Unicode encoding to an external function call."	^self gcCopyToHeapUnicode</body></methods><methods><class-id>External.CPointer</class-id> <category>converting</category><body package="Com- External Data Enhancements">asHandleParameter	"Answer the receiver in a form suitable for passing as a host handle parameter to an external function call."	^self</body></methods><methods><class-id>External.CPointer</class-id> <category>finalizing</category><body package="Com- External Data Enhancements">enforceInvalidation	self invalidate</body><body package="Com- External Data Enhancements">enforceRelease	^ self free</body></methods><methods><class-id>External.CPointer</class-id> <category>initialize-release</category><body package="Com- External Data Enhancements">invalidate	"Set the receiver to be invalid."	self referentAddress == nil		ifFalse: [ 			self beNonGarbageCollectable.			self referentAddress: nil ].</body></methods><methods><class-id>External.CPointer</class-id> <category>testing</category><body package="Com- External Data Enhancements">isExternalAddress        " Answer whether the receiver is an external memory address. "    ^true</body></methods><methods><class-id>External.CPointer</class-id> <category>initialize-release</category><body package="Com- External Data Enhancements">release	"Deallocate the external memory block pointed to by the receiver; answer the receiver.  After sending this message, the receiver's datum is invalidated. "	self free.	super release.</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Com- External Data Enhancements">isExternalAddress        " Answer whether the receiver is an external memory address. "    ^false</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Com- External Data Enhancements">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	self isFixedArgument 		ifFalse: [self error: #ErrCantCoerce &lt;&lt; #com &gt;&gt; 'can''t coerce'].	^self</body></methods><methods><class-id>Core.ByteEncodedString</class-id> <category>converting</category><body package="Com- External Data Enhancements">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	self isFixedArgument 		ifFalse: [self error: #ErrCantCoerce &lt;&lt; #com &gt;&gt; 'can''t coerce'].	^self</body></methods><methods><class-id>External.CIntegerType</class-id> <category>converting</category><body package="Com- External Data Enhancements">coerceForAssignment: anObject	"Coerce anObject to an instance of the receiver's type for the purpose of C assignment.  Answer the coerced object, otherwise raise an exception."	(self isBoolean and: [(anObject == true)  or: [(anObject == false) ]])		ifTrue: [^ anObject].	(anObject isKindOf: Integer) ifTrue: [^anObject].	^self class illegalAssignmentSignal raiseWith: anObject</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="Com- External Data Enhancements">asHandleParameter	"Answer the receiver in a form suitable for passing as a host handle parameter to an external function call."    "^self"    " VS returns nil because the VM generally handles nil		properly in API calls, notably when nil is passed		for a #struct argument.  The VW OE does not		seem to do the same for nil values passed for		pointer values.  Consequently, 0 seems like		a safer value to push through to the API call		mechanism when nil is used as an argument.		[DL/GG 16-Apr-06] "	^0</body><body package="Com- External Data Enhancements">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	"^0"  " a nil value should be treated as a NULL pointer by the external function call machinery "	^self</body><body package="Com- External Data Enhancements">asStringParameter	"Answer the receiver in a form suitable for passing as a null-terminated string in platform encoding to an external function call."	"^self"	^self asPointerParameter</body><body package="Com- External Data Enhancements">asUnicodeParameter	"Answer the receiver in a form suitable for passing as a null-terminated string in Unicode encoding to an external function call."	"^self"	^self asPointerParameter</body></methods><methods><class-id>External.CDatum</class-id> <category>converting</category><body package="Com- External Data Enhancements">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	(self isPointer or: 			["self"			theDatum isFixedArgument]) 		ifFalse: [self error: #ErrCantCoerce &lt;&lt; #com &gt;&gt; 'can''t coerce'].	^self</body></methods><methods><class-id>External.CCompoundType</class-id> <category>comparing</category><body package="Com- External Data Enhancements">= anObject	"Answer whether the receiver and the argument represent the same object.  We assume that all compound types in an interface are unique to an interface."	anObject == self ifTrue: [ ^ true ].	anObject class = self class ifFalse: [ ^ false ].	anObject size = self size ifFalse: [ ^ false ].	self membersDo: [:key :value |		(anObject memberNamed: key ifAbsent: nil) = value ifFalse: [ ^ false ]].	^ true</body></methods><methods><class-id>External.CCompoundType</class-id> <category>instance creation</category><body package="Com- External Data Enhancements">newInFixedSpace	"Answer a new data object for representing a value of this type.  The new object's memory is allocated in Smalltalk fixed memory space. "	^self defaultDatumClass newDatum: ( UninterpretedBytes newInFixedSpace: self dataSize ) 		ofType: self</body></methods><methods><class-id>External.CPointerType</class-id> <category>instance creation</category><body package="Com- External Data Enhancements">newInFixedSpace	"Answer a new data object for representing a value of this type.  The new object's memory is allocated in Smalltalk fixed memory space. "	^self defaultDatumClass newDatum: ( UninterpretedBytes newInFixedSpace: self dataSize ) 		ofType: self</body></methods><methods><class-id>External.CCompositePointer</class-id> <category>converting</category><body package="Com- External Data Enhancements">asSeparateStructureParameter	"Answer the receiver in a form suitable for passing as a structure parameter to an external function call."	^self asStructureParameter</body><body package="Com- External Data Enhancements">asStructureParameter	"Answer the receiver in a form suitable for passing as a structure parameter to an external function call."	^self contents</body></methods><methods><class-id>External.CCompositePointer</class-id> <category>As yet unclassified</category><body package="Com- External Data Enhancements">nestedMemberAt: aSymbol	| tokens nested |	tokens := aSymbol tokensBasedOn: $..	nested := (tokens allButLast: 1) inject: self				into: [:struct :each | struct refMemberAt: each asSymbol].	^nested memberAt: tokens last asSymbol</body><body package="Com- External Data Enhancements">nestedMemberAt: aSymbol put: aValue		| tokens nested |	tokens := aSymbol tokensBasedOn: $..	nested:= (tokens allButLast: 1) inject: self into: [:struct :each | struct refMemberAt: each asSymbol].	nested memberAt: tokens last asSymbol put: aValue</body></methods><methods><class-id>Kernel.UserMessage</class-id> <category>converting</category><body package="Com- External Data Enhancements">asStringParameter	"Answer the receiver in a form suitable for passing as a null-terminated string in platform encoding to an external function call."	^self asString asStringParameter</body><body package="Com- External Data Enhancements">asUnicodeParameter	"Answer the receiver in a form suitable for passing as a null-terminated string in Unicode encoding to an external function call."	^self asString asUnicodeParameter</body></methods><methods><class-id>External.CScalarType</class-id> <category>instance creation</category><body package="Com- External Data Enhancements">newInFixedSpace	"Answer a new data object for representing a value of this type.  The new object's memory is allocated in Smalltalk fixed memory space. "	^self defaultDatumClass newDatum: ( UninterpretedBytes newInFixedSpace: self dataSize ) 		ofType: self</body></methods><methods><class-id>External.CComposite</class-id> <category>converting</category><body package="Com- External Data Enhancements">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	"self"	theDatum isFixedArgument 		ifFalse: [self error: #ErrCantCoerce &lt;&lt; #com &gt;&gt; 'can''t coerce'].	^self</body><body package="Com- External Data Enhancements">asSeparateStructureParameter	"Answer the receiver in a form suitable for passing as a structure parameter to an external function call."	^self copy</body><body package="Com- External Data Enhancements">asStructureParameter	"Answer the receiver in a form suitable for passing as a structure parameter to an external function call."	^self</body></methods><methods><class-id>Core.TwoByteString</class-id> <category>converting</category><body package="Com- External Data Enhancements">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	self isFixedArgument 		ifFalse: [self error: #ErrCantCoerce &lt;&lt; #com &gt;&gt; 'can''t coerce'].	^self</body></methods><initialize><class-id>External.ExportedObjectsTable</class-id></initialize><initialize><class-id>External.ExternalStructure</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CDatum</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>theDatum type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>CComposite</name><environment>External</environment><super>External.CDatum</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ByteEncodedString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars>encoder </class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>CPointer</name><environment>External</environment><super>External.CDatum</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>TwoByteString</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>CScalarType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>kind numBits printName storeSelector atSelector atPutSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>CIntegerType</name><environment>External</environment><super>External.CScalarType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>CCompoundType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UserMessage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultString key catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>CCompositePointer</name><environment>External</environment><super>External.CPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Data</category><attributes><package>External-Data</package></attributes></class><class><name>CPointerType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class></st-source>