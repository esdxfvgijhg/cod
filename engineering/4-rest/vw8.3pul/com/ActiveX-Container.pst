<?xml version="1.0"?><st-source><!-- Name: ActiveX-ContainerNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This package contains the ActiveX Container related classesDbIdentifier: bear73DbTrace: 497461DbUsername: alexDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Com- Ole Development' '') #(#any 'Com- Automation Development' '') #(#any 'ActiveX-AutomationExtensions' '') #(#any 'ActiveX-CInterfaces' '') #(#any 'ActiveX-Interfaces' '') #(#any 'Com- Automation' '') #(#any 'Com- Automation Pools' '') #(#any 'Com- CodeAnnotations' '') #(#any 'Com- Win32' '') #(#any 'Com- Ole' '') #(#any 'Com- Ole Pools' '') #(#any 'Com- ExtensionsToBase' '') #(#any 'Com- System Configuration Services' '') #(#any 'Compression-ZLib' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #(#(#name 'URISupport' #componentType #package))IsFunctional: truePackageName: ActiveX-ContainerParcel: #('ActiveX-Container')ParcelName: ActiveX-ContainerPrerequisiteDescriptions: #(#(#name 'Com- Ole Development') #(#name 'Com- Automation Development') #(#name 'ActiveX-AutomationExtensions') #(#name 'ActiveX-CInterfaces' #componentType #package) #(#name 'ActiveX-Interfaces' #componentType #package) #(#name 'Com- Automation' #componentType #package) #(#name 'Com- Automation Pools' #componentType #package) #(#name 'Com- CodeAnnotations' #componentType #package) #(#name 'Com- Win32' #componentType #package) #(#name 'Com- Ole' #componentType #package) #(#name 'Com- Ole Pools' #componentType #package) #(#name 'Com- ExtensionsToBase' #componentType #package) #(#name 'Com- System Configuration Services' #componentType #package) #(#name 'Compression-ZLib' #componentType #package))PrerequisiteParcels: #(#('Com- Ole Development' '') #('Com- Automation Development' '') #('ActiveX-AutomationExtensions' '') #('ActiveX-CInterfaces' '') #('ActiveX-Interfaces' '') #('Com- Automation' '') #('Com- Automation Pools' '') #('Com- CodeAnnotations' '') #('Com- Win32' '') #('Com- Ole' '') #('Com- Ole Pools' '') #('Com- ExtensionsToBase' '') #('Com- System Configuration Services' '') #('Compression-ZLib' ''))PrintStringCache: (8.3 - 1,alex)Version: 8.3 - 1Date: 3:07:37 PM April 21, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.2) of April 21, 2017 on April 21, 2017 at 3:07:37 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AbstractControlProperties</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>data </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>UI.AbstractControlProperties</class-id><body>AbstractControlProperties is an abstract class for storing control properties. Control properties must be stored in Editor and when leaving the Image for being able to restore them later. This class hierarchy is implemented for this purpose. Subclasses implement different strategies to do this. One may use IStorages, others may store lists of properties and assign them to the Control. Subclasses must implement the following messages:	initialize-release		initFromArray:	literal array encoding		literalArrayEncoding	property assignment		assignPropertiesToEditor:		loadOrInit:Instance Variables	data	&lt;Collection&gt;	the data used to restore the properites of the control, whatever the data may be.</body></comment><class><name>ListControlProperties</name><environment>UI</environment><super>UI.AbstractControlProperties</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>UI.ListControlProperties</class-id><body>ControlProperties are stored as a list of key value bindings. It was the first supported way to store properties in this project andis now supported for two reasons: backwards compatibility and the case that the other two APIs aren't supported by the control.</body></comment><class><name>AmbientFont</name><environment>External</environment><super>External.COMDispatchObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>font </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.AmbientFont</class-id><body>AmbientFont is a dispatch wrapper for exposing smalltalk fonts via dispatchingInstance Variables	font	&lt;&gt;	the smalltalk font</body></comment><class><name>ControlPropertyValue</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controlHolder propertyName changeNotification control </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>UI.ControlPropertyValue</class-id><body>ControlPropertValue is a ValueModel which represents ActiveX control properties. They can be defined inside the UIPainter Control Property Bindings Editor and are used like common ValueModels inside the application.Instance Variables	changeNotification	&lt;Object&gt;					the notification sent by the control on change of the value	control				&lt;COleControlProxy&gt;	the control.	controlHolder		&lt;ValueHolder&gt;			The ValueModel inside the application holding the control	propertyName		&lt;String&gt;					The name of the bound control property</body></comment><class><name>AmbientProperties</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties designMode knownProperties </inst-vars><class-inst-vars></class-inst-vars><imports>			COMAutomationConstants.*			</imports><category>As yet unclassified</category><attributes><package>ActiveX-Container</package></attributes></class><class><name>Flags</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><class><name>MultipleInterfaceDispatchObject</name><environment>External</environment><super>External.COMDispatchObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfaces </inst-vars><class-inst-vars>specificationTable </class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.MultipleInterfaceDispatchObject</class-id><body>MultipleInterfaceDispatchObject is an abstract superclass for server objects which provide automation services as well as several other interfaces.Instance Variables	interfaces	&lt;(Collection of: (Object | ProtoObject))&gt;	description of interfaces</body></comment><class><name>ControlContainer</name><environment>External</environment><super>External.MultipleInterfaceDispatchObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>window acceleratorTable iActiveObject sites ambientFont ambientProperties </inst-vars><class-inst-vars></class-inst-vars><imports>			OLEAutomationConstants.*			private External.Win32Constants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.ControlContainer</class-id><body>This class is a COMServer class which server as the container object of Controls. E.g. the container may be an ApplicationWindow. Instance Variables	acceleratorTable	&lt;AcceleratorTable&gt;								The Accelerator table	iActiveObject			&lt;IOleInPlaceActiveObject&gt;					The currently active control	sites					&lt;(Collection of: (COleControlSite))&gt;			The sites contained in the Container 	window				&lt;ApplicationWindow&gt;							The window the container is attached to</body></comment><class><name>BytelikeControlProperties</name><environment>UI</environment><super>UI.AbstractControlProperties</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedPropertyValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>UI.BytelikeControlProperties</class-id><body>My subclasses uses Byte-oriented approach for storing properties.</body></comment><class><name>StreamControlProperties</name><environment>UI</environment><super>UI.BytelikeControlProperties</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>UI.StreamControlProperties</class-id><body>I use IPersistStreams to save and restore control properties</body></comment><class><name>OLEMiscStatus</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports>			OLEAutomationConstants.*			private External.COMConstants.*			private External.COMAutomationConstants.*			private External.COMStatusCodeConstants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.OLEMiscStatus</class-id><body>OLEMiscStatus represents flags of type OLEMISC.Instance Variables	value	&lt;Integer &gt;	The value containing the flag bits</body></comment><class><name>ControlProxy</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>progId clsid oleControlSite interfaces dispatchDriver miscStatus flags licenseKey shortcuts properties storedProperties </inst-vars><class-inst-vars></class-inst-vars><imports>			OLEAutomationConstants.*			private External.COMConstants.*			private External.COMAutomationConstants.*			private External.COMStatusCodeConstants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.ControlProxy</class-id><body>COleControlProxy represents the proxy of an ActiveX ControlInstance Variables	cachedProperties	&lt;OrderedCollection&gt;			a collection of property values set in the ui painter which need to be cached until the control is instantiated.	clsid				&lt;GUI&gt;						the classid of the control	controlInfo			&lt;Object&gt;					the controlinfo structure of the control	dispatchDriver		&lt;COMDispatchDriver&gt;		the dispatchDriver of the control for accessing control properties and methods	dispatchSpecificationTable	&lt;COMDispatchSpecificationTable&gt;		the Automation DispatchSpecificationTable which contains specs of automation 													properties and methods	flags				&lt;Flags&gt;					used to store several control status flags	interfaces			&lt;(Dictionary of: IUnknown) &gt;	the interfaces provided by the control	licenseKey			&lt;String&gt;					A String used for veryfying the UserLicense	miscStatus			&lt;Integer&gt;					miscStatus - ole status flags of the object	oleControlSite		&lt;COleControlSite&gt;			the site which embeds the control	pixelsToHimetricFactor	&lt;Object&gt;				pixelsToHimetric conversion factor	progId				&lt;string&gt;					a string containing the progid of the control	sinks				&lt;Dictionary&gt;				a collection eventsinks	shortcuts 			&lt;Array&gt;						a Collection of shortcuts used by the control</body></comment><class><name>ControlSite</name><environment>External</environment><super>External.MultipleInterfaceDispatchObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>view oleContainer oleControl flags eventManager </inst-vars><class-inst-vars></class-inst-vars><imports>			OLEAutomationConstants.*			private External.COMConstants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.ControlSite</class-id><body>COleControlSite is a server object which represents the site the control exists in.Instance Variables	ambientFont	&lt;Object&gt;						the AmbientFontProperty	flags			&lt;Flags&gt;						Flags of the Site	oleContainer	&lt;COleControlContainer&gt;	The Container (usually a placeholder for a window)	oleControl	&lt;COleControlProxy&gt;		the contained oleControl	view			&lt;OleControlView&gt;			The View used to manage the display area of the control.</body></comment><class><name>GenericCOMEventSink</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable configuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.GenericCOMEventSink</class-id><body>GenericCOMEventSink is a VTable Sink server object.Instance Variables	eventTable					&lt;Object&gt;					The table which stores event bindings	configuration					&lt;SinkConfiguration&gt;		An Object which stores data at runtime.</body></comment><class><name>StorageControlProperties</name><environment>UI</environment><super>UI.BytelikeControlProperties</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>UI.StorageControlProperties</class-id><body>I use an IStorage Interface to save and restore control properties.</body></comment><class><name>ControlEventManager</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>control sinks </inst-vars><class-inst-vars></class-inst-vars><imports>			OLEAutomationConstants.*			private External.COMConstants.*			private External.COMAutomationConstants.*			private External.COMStatusCodeConstants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.ControlEventManager</class-id><body>ControlEventManager is used for managing events sent by event sinks to activeX controls.Instance Variables	control	&lt;ControlProxy&gt;			the control which is notified on occurence of an event 	sinks		&lt;Dictionary&gt;				the sinks managed by this class</body></comment><class><name>OLE_COLOR</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			</imports><category></category><attributes><package>ActiveX-Container</package></attributes></class><comment><class-id>External.OLE_COLOR</class-id><body>OLE_COLOR is used for dealing with the OLE color system.Instance Variables	value	&lt;Integer&gt;	description of value</body></comment><shared-variable><name>EmbeddedControlCount</name><environment>External.ControlSite</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>0</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>FinalizationProtectionRegistry</name><environment>External.ControlProxy</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>IdentitySet new</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>PixelsToHimetricFactor</name><environment>External.ControlProxy</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>CustomColorDict</name><environment>External.OLE_COLOR</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>SysColorDict</name><environment>External.OLE_COLOR</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_ACTSLIKELABEL</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>8192</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_ALWAYSRUN</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>2048</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_SIMPLEFRAME</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>65536</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_ACTSLIKEBUTTON</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>4096</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_INVISIBLEATRUNTIME</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>1024</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_WANTSTOMENUMERGE</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>1048576</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_ALIGNABLE</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>32768</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_SETCLIENTSITEFIRST</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>131072</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_IGNOREACTIVATEWHENVISIBLE</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>524288</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_SUPPORTSMULTILEVELUNDO</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>2097152</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><shared-variable><name>OLEMISC_NOUIACTIVATE</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>interface IOleObject constants</category><initializer>16384</initializer><attributes><package>ActiveX-Container</package></attributes></shared-variable><methods><class-id>UI.AbstractControlProperties</class-id> <category>initialize-release</category><body package="ActiveX-Container">initFromArray: aLiteralArray	self subclassResponsibility</body></methods><methods><class-id>UI.AbstractControlProperties</class-id> <category>accessing</category><body package="ActiveX-Container">cachedPropertyValues	self subclassResponsibility</body><body package="ActiveX-Container">data	^data</body><body package="ActiveX-Container">data: anObject	data := anObject</body><body package="ActiveX-Container">getProperty: aKey	^ (self cachedPropertyValues detect: [:each | each key = aKey ] ifNone: [ nil ]) value</body><body package="ActiveX-Container">setProperty: aKey value: aValue	^self cachedPropertyValues add: aKey -&gt; aValue</body></methods><methods><class-id>UI.AbstractControlProperties</class-id> <category>literal array encoding</category><body package="ActiveX-Container">literalArrayEncoding	self subclassResponsibility</body></methods><methods><class-id>UI.AbstractControlProperties</class-id> <category>property assignment</category><body package="ActiveX-Container">applyCachedPropertiesTo: aControl		self cachedPropertyValues		do:			[:association | 			[aControl				basicSetProperty: association key				value: association value]				on: COMError				do: [:ex | ex return]]</body><body package="ActiveX-Container">assignPropertiesToEditor: aPropertyEditor	self subclassResponsibility</body><body package="ActiveX-Container">initNew: aControl		| tempStorage |	^[tempStorage := COMGlobalMemoryStorage newTemporaryBackingStore.	aControl iPersistStorage initNew: tempStorage]		ensure: [tempStorage enforceRelease]</body><body package="ActiveX-Container">loadOrInit: aControl	self subclassResponsibility</body></methods><methods><class-id>UI.AbstractControlProperties class</class-id> <category>private</category><body package="ActiveX-Container">basicNewForControl: aControl propertyValues: anObject		self subclassResponsibility</body><body package="ActiveX-Container">classForLiteralArray: anArray	^ self allSubclasses detect: [:class | class isResponsibleFor: anArray ] ifNone: nil</body><body package="ActiveX-Container">isSpecific	^ false</body><body package="ActiveX-Container">priority	^ 0</body><body package="ActiveX-Container">specificImplementations	^ self allSubclasses select: [:each | each isSpecific ]."	^ Array with: ListControlProperties"</body></methods><methods><class-id>UI.AbstractControlProperties class</class-id> <category>instance creation</category><body package="ActiveX-Container">fromLiteralArray: anArray	^ (self classForLiteralArray: anArray) new 		initFromArray: anArray;		yourself</body><body package="ActiveX-Container">newForControl: aControl 	^ self newForControl: aControl propertieValues: #()</body><body package="ActiveX-Container">newForControl: aControl propertieValues: propertyValues		| classes |	classes := self specificImplementations		asSortedCollection: [:a :b | a priority &gt; b priority].	classes		do:			[:each | 			(each basicNewForControl: aControl propertyValues: propertyValues)				ifNotNil: [:instance | ^instance]].	^nil</body></methods><methods><class-id>UI.AbstractControlProperties class</class-id> <category>private testing</category><body package="ActiveX-Container">isResponsibleFor: aLiteralArray	self subclassResponsibility</body></methods><methods><class-id>UI.ListControlProperties</class-id> <category>accessing</category><body package="ActiveX-Container">cachedPropertyValues	^ data</body><body package="ActiveX-Container">data: anObject		super data: anObject asOrderedCollection</body></methods><methods><class-id>UI.ListControlProperties</class-id> <category>property assignment</category><body package="ActiveX-Container">loadOrInit: aControl	self initNew: aControl.</body></methods><methods><class-id>UI.ListControlProperties</class-id> <category>copying</category><body package="ActiveX-Container">postCopy	super postCopy.	data := data copy.</body></methods><methods><class-id>UI.ListControlProperties</class-id> <category>literal array encoding</category><body package="ActiveX-Container">literalArrayEncoding	^self data asArray literalArrayEncoding</body></methods><methods><class-id>UI.ListControlProperties</class-id> <category>initialize-release</category><body package="ActiveX-Container">initFromArray: aLiteralArray	self data: (aLiteralArray collect: [:each | each decodeAsLiteralArray])</body></methods><methods><class-id>UI.ListControlProperties class</class-id> <category>private</category><body package="ActiveX-Container">basicNewForControl: aControl propertyValues: propertyValues		^self new		data: propertyValues;		yourself.</body><body package="ActiveX-Container">isSpecific	^ true</body><body package="ActiveX-Container">priority	^ 1</body></methods><methods><class-id>UI.ListControlProperties class</class-id> <category>instance creation</category><body package="ActiveX-Container">new	^ super new		data: #();		yourself.</body></methods><methods><class-id>UI.ListControlProperties class</class-id> <category>private testing</category><body package="ActiveX-Container">isResponsibleFor: aLiteralArray	^ aLiteralArray isEmpty or: [ aLiteralArray first class = Array ]</body></methods><methods><class-id>External.AmbientFont</class-id> <category>accessing</category><body package="ActiveX-Container">dispatchInterfaceIID	" *** This method was defined by COMDispatchObject as a subclass responsibility.	Replace its body with a proper implementation. *** "	^ IID_IFontDisp</body><body package="ActiveX-Container">font	^font</body><body package="ActiveX-Container">font: anObject	font := anObject</body><body package="ActiveX-Container">iFontDisp	^ self dispatchInterface</body><body package="ActiveX-Container">specificationTable	^ self class specificationTable</body><body package="ActiveX-Container">typeLibraries	^ nil</body></methods><methods><class-id>External.AmbientFont</class-id> <category>accessing properties</category><body package="ActiveX-Container">getBold	^ font bold</body><body package="ActiveX-Container">getCharset	^ font charset.	"^ DEFAULT_CHARSET"</body><body package="ActiveX-Container">getItalic	^ font italic</body><body package="ActiveX-Container">getName	^ font family</body><body package="ActiveX-Container">getSize	^ font pixelSize</body><body package="ActiveX-Container">getStrikethrough	^ false</body><body package="ActiveX-Container">getUnderline	^ font underline</body><body package="ActiveX-Container">getWeight	^ font bold ifTrue: [ 800 ] ifFalse: [ 400 ]</body></methods><methods><class-id>External.AmbientFont class</class-id> <category>instance creation</category><body package="ActiveX-Container">forFont: aFont	^ self new 		font: aFont;		yourself</body></methods><methods><class-id>External.AmbientFont class</class-id> <category>specificationTable</category><body package="ActiveX-Container">specificationTable	^ COMDispatchSpecificationTable new		specificationKey: #memberID;		clsid: IID_IFontDisp;		add: (COMDispatchPropertySpecification name: 'Name' memberID: DISPID_FONT_NAME type: VT_BSTR);		add: (COMDispatchPropertySpecification name: 'Size' memberID: DISPID_FONT_SIZE type: VT_CY);		add: (COMDispatchPropertySpecification name: 'Bold' memberID: DISPID_FONT_BOLD type: VT_BOOL);		add: (COMDispatchPropertySpecification name: 'Italic' memberID: DISPID_FONT_ITALIC type: VT_BOOL);		add: (COMDispatchPropertySpecification name: 'Underline' memberID: DISPID_FONT_UNDER type: VT_BOOL);		add: (COMDispatchPropertySpecification name: 'Strikethrough' memberID: DISPID_FONT_STRIKE type: VT_BOOL);		add: (COMDispatchPropertySpecification name: 'Weight' memberID: DISPID_FONT_WEIGHT type: VT_I2);		add: (COMDispatchPropertySpecification name: 'Charset' memberID: DISPID_FONT_CHARSET type: VT_I2);		yourself</body></methods><methods><class-id>UI.ControlPropertyValue</class-id> <category>private</category><body package="ActiveX-Container">control		^ control</body><body package="ActiveX-Container">control: aControl		self revokeEvents.	control := aControl.	self installEvents</body><body package="ActiveX-Container">installEvents		self control		ifNotNil:			[:aControl | 			aControl when: #propertyChanged send: #someControlPropertyChanged: to: self.			self changeNotification				ifNotNil:					[aControl when: changeNotification send: #observedPropertyChanged to: self].				aControl notifyOnLateUpdate: self	]</body><body package="ActiveX-Container">revokeEvents		self control		ifNotNil:			[:aControl | 			control removeAllActionsWithReceiver: self.			control removeUpdateNotificationFor: self]</body></methods><methods><class-id>UI.ControlPropertyValue</class-id> <category>accessing</category><body package="ActiveX-Container">changeNotification	^changeNotification</body><body package="ActiveX-Container">changeNotification: anObject	changeNotification := anObject</body><body package="ActiveX-Container">controlHolder	^controlHolder</body><body package="ActiveX-Container">controlHolder: anObject		controlHolder := anObject.	self control: anObject value.</body><body package="ActiveX-Container">flush</body><body package="ActiveX-Container">propertyName	^propertyName</body><body package="ActiveX-Container">propertyName: anObject	propertyName := anObject</body><body package="ActiveX-Container">setValue: newValue	self control setProperty: self propertyName value: newValue</body><body package="ActiveX-Container">value		^self control		ifNotNil:			[:aControl | 			[aControl getProperty: self propertyName asString]				on: COMError,ExternalAccessFailed				do: [:ex | ex return: nil]]</body></methods><methods><class-id>UI.ControlPropertyValue</class-id> <category>initialize-release</category><body package="ActiveX-Container">initialize	"Initialize a newly created instance. This method must answer the receiver."		super initialize.	controlHolder := nil.	propertyName := nil.	changeNotification := nil.	^self</body></methods><methods><class-id>UI.ControlPropertyValue</class-id> <category>events</category><body package="ActiveX-Container">mightBeChanged	"We don't know the original propery value - so assume it has changed"	self flush.	self changed: #value</body><body package="ActiveX-Container">observedPropertyChanged		self flush.	self changed: #value</body><body package="ActiveX-Container">someControlPropertyChanged: name	name  = self propertyName ifTrue: [ self observedPropertyChanged ].</body></methods><methods><class-id>UI.ControlPropertyValue</class-id> <category>updating</category><body package="ActiveX-Container">update: anAspect with: aParameter from: anObject	(anAspect = #value and: [anObject = self controlHolder ]) ifTrue: [		self control: anObject value ]</body></methods><methods><class-id>UI.ControlPropertyValue class</class-id> <category>instance creation</category><body package="ActiveX-Container">controlHolder: aValueModel propertyName: aSymbol changeNotification: aChangeSymbol	^ self new		propertyName: aSymbol;		changeNotification: aChangeSymbol;		controlHolder: aValueModel;		yourself</body></methods><methods><class-id>External.AmbientProperties</class-id> <category>private</category><body package="ActiveX-Container">checkKey: aKey	| property |	property := self knownProperties at: aKey				ifAbsent: 					[^self						error: #UnaccessibleProperty &lt;&lt; #com &gt;&gt; 'This property is not accessible'].	^self formatKey: property name</body><body package="ActiveX-Container">formatKey: name	^name asString</body><body package="ActiveX-Container">knownProperties	^knownProperties		ifNil: 			[knownProperties := (ControlSite specificationTable						withSpecificationKey: #name)							reject: [:each | self class nonAccessibleAmbientProperties includes: each name]]</body><body package="ActiveX-Container">nameForId: id	^(self knownProperties		getSpecificationWhere: #memberID		isEqualTo: id		ifAbsent: [^nil]) name</body><body package="ActiveX-Container">properties	^ properties</body></methods><methods><class-id>External.AmbientProperties</class-id> <category>acessing properties</category><body package="ActiveX-Container">getProperty: name	^self properties at: (self checkKey: name)</body><body package="ActiveX-Container">propertyNames	" Return an array of propertyNames "	^self properties keys</body><body package="ActiveX-Container">propertyTypeAt: aName	" Return the property type at aName "	| prop |	prop := self knownProperties at: (self checkKey: aName) ifAbsent: [^nil].	^prop typecode</body><body package="ActiveX-Container">propertyValueAt: aName	^self getProperty: aName</body><body package="ActiveX-Container">setDefaultProperty	self		setProperty: #AmbientAppearance		to: self class ambientAppearance3D		notify: false.	self setProperty: #ScaleUnits to: false notify: false.	self setProperty: #TextAlign to: 0 notify: false.	"self setProperty: #MessageReflect to: false notify: false.		self setProperty: #UserMode to: true notify: false.	self setProperty: #UIDead to: false notify: false."	self setProperty: #ShowGrabHandles to: false notify: false.	self setProperty: #ShowHatching to: false notify: false.	self setProperty: #SupportsMnemonics to: false notify: false.	self setProperty: #AutoClip to: true notify: false.	self setProperty: #LocaleID to: 0 notify: false.	self		setProperty: #Font		to: (AmbientFont forFont: Screen default defaultFontPolicy defaultFont)		notify: false.	self setProperty: #DisplayName to: '' notify: false.	self		setProperty: #ForeColor		to: (External.OLE_COLOR forSystemColor: COLOR_ACTIVECAPTION) value		notify: false.	self		setProperty: #BackgroundColor		to: (External.OLE_COLOR forSystemColor: COLOR_BACKGROUND) value		notify: false.	self		setProperty: #RightToLeft		to: false		notify: false.</body><body package="ActiveX-Container">setProperty: name to: val	^ self setProperty: name to: val notify: true.</body><body package="ActiveX-Container">setProperty: nameOrId to: val notify: bNotify	| id name |	nameOrId isInteger		ifTrue: 			[id := nameOrId.			name := self nameForId: id]		ifFalse: 			[name := self checkKey: nameOrId.			id := (self knownProperties at: name) getSpecification memberID].	self properties at: name put: val.	bNotify ifTrue: [self triggerEvent: #propertyChanged with: id]</body></methods><methods><class-id>External.AmbientProperties</class-id> <category>accessing</category><body package="ActiveX-Container">designMode	^ designMode</body><body package="ActiveX-Container">designMode: aBool	designMode := aBool.</body></methods><methods><class-id>External.AmbientProperties</class-id> <category>initialize-release</category><body package="ActiveX-Container">initialize	designMode := false.	properties := Dictionary new.	self setDefaultProperty.</body></methods><methods><class-id>External.AmbientProperties</class-id> <category>adding properties</category><body package="ActiveX-Container">addProperty: aName type: aType id: anId	self knownProperties add: (COMDispatchPropertySpecification				name: aName				memberID: anId				typeCode: aType)</body></methods><methods><class-id>External.AmbientProperties class</class-id> <category>instance creation</category><body package="ActiveX-Container">container: aContainer	"compatibility"	^ self new</body><body package="ActiveX-Container">new	^ super new initialize</body></methods><methods><class-id>External.AmbientProperties class</class-id> <category>private constants</category><body package="ActiveX-Container">ambientAppearance3D	^ 1</body><body package="ActiveX-Container">ambientAppearanceFlat	^ 0</body><body package="ActiveX-Container">nonAccessibleAmbientProperties	"Ambient properties which are not accessible since they are controlled by the system"	^#(UIDead UserMode MessageReflect DisplayAsDefault)</body></methods><methods><class-id>External.AmbientProperties class</class-id> <category>methods</category><body package="ActiveX-Container">typeConvert: aConst	aConst == OLE_COLOR ifTrue: [		^ VT_I4.	].	^ aConst.</body></methods><methods><class-id>Core.Flags</class-id> <category>accessing</category><body package="ActiveX-Container">&amp; aFlag	^ self testFlag: aFlag</body><body package="ActiveX-Container">clearFlag: aFlag	self remove: aFlag ifAbsent: [].</body><body package="ActiveX-Container">setFlag: aFlag	self add: aFlag.</body><body package="ActiveX-Container">setFlag: aFlag to: aBoolean	aBoolean		ifTrue: 	[ self setFlag: aFlag ]		ifFalse: 	[ self clearFlag: aFlag ].</body><body package="ActiveX-Container">testFlag: aFlag	^ self includes: aFlag</body><body package="ActiveX-Container">| aFlag	^ self setFlag: aFlag</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>accessing</category><body package="ActiveX-Container">dispatchInterfaceIID	"Answer the IID of the dispatch interface which is supported by the receiver. Must be reimplemented by a subclass"	^ IID_IDispatch</body><body package="ActiveX-Container">publishedObject	"Answer the object being published as a COM automation object by supporting IDispatch on it."	^ self</body><body package="ActiveX-Container">publishedObject: anObject	"Set the object being published as a COM automation object by supporting IDispatch on it."	self error: (#PublishingForeignObjectNotSupported &lt;&lt; #com &gt;&gt; 'Publishing a foreign object is not supported').</body><body package="ActiveX-Container">specificationTable 	^ self class specificationTable</body><body package="ActiveX-Container">typeLibraries	"Think we don't need typelibraries as the object is not registered in the outside world"	^ nil</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>subclass-accessing</category><body package="ActiveX-Container">getInterfaceForIID: iid		" Private - answer the interface identified by the GUID &lt;iid&gt;.		Answer nil if the requested interface is not supported by the receiver. "		^ self interfaces at: iid ifAbsent: [ super getInterfaceForIID: iid ]</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>initialize-release</category><body package="ActiveX-Container">initializeInterfaces	super initializeInterfaces.	interfaces :=  Dictionary new.</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>accessing interfaces</category><body package="ActiveX-Container">iAdviseSink	"For code critic"	self subclassResponsibility</body><body package="ActiveX-Container">interfaces	^ interfaces ifNil: [ self initializeInterfaces ]</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>events</category><body package="ActiveX-Container">pause	"For code critic"	self subclassResponsibility</body><body package="ActiveX-Container">reactivate	"For code critic"	self initializeInterfaces.</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>IOleWindow protocol</category><body package="ActiveX-Container">ContextSensitiveHelp: fEnterMode	"For code critic"	self subclassResponsibility</body><body package="ActiveX-Container">GetWindow: reference	"For code critic"	self subclassResponsibility</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>IOleInPlaceFrame protocol</category><body package="ActiveX-Container">TranslateAccelerator: lpmsg _: wID	"For code critic"	self subclassResponsibility</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>subclass-releasing</category><body package="ActiveX-Container">resetAllocatedInterfaces		" Private - reset the references to the interfaces supported by the receiver. "	super resetAllocatedInterfaces.	interfaces := nil.</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject</class-id> <category>subclass-enumerating</category><body package="ActiveX-Container">allocatedInterfacesDo: aOneArgBlock		" Private - enumerate the interfaces supported by the receiver		which have been allocated during its lifetime and		evaluate &lt;aOneArgBlock&gt; with each. "	super allocatedInterfacesDo: aOneArgBlock.	interfaces ifNotNil: [ interfaces do: [:each | aOneArgBlock value: each ]].</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject class</class-id> <category>private-initialization</category><body package="ActiveX-Container">commonClsId	^ nil</body><body package="ActiveX-Container">createSpecificationTable	self subclassResponsibility</body><body package="ActiveX-Container">initialize	"This method is run at COM Connect installation time. 	Public objects have a CLSID, private objects need not. 	Only objects with a CLSID can have a class factory registered for them."	"self initialize"		super initialize.	self commonClsId		ifNotNil:			[:aClsid | 			self				clsid: aClsid;				specificationTable: self createSpecificationTable;				yourself]</body></methods><methods><class-id>External.MultipleInterfaceDispatchObject class</class-id> <category>accessing</category><body package="ActiveX-Container">specificationTable	^ specificationTable ifNil: [ specificationTable := self createSpecificationTable ]</body><body package="ActiveX-Container">specificationTable: aTable	specificationTable := aTable.</body></methods><methods><class-id>External.ControlContainer</class-id> <category>accessing</category><body package="ActiveX-Container">acceleratorTable	^ acceleratorTable ifNil: [ self initializeAcceleratorTable ].</body><body package="ActiveX-Container">addSite: aSite	sites add: aSite.</body><body package="ActiveX-Container">ambientFont	^ambientFont		ifNil: 			[self ambientFont: self initializeAmbientFont.			ambientFont]</body><body package="ActiveX-Container">ambientFont: aFont	ambientFont := aFont</body><body package="ActiveX-Container">ambientProperties	^ambientProperties ifNil: [self initializeAmbientProperties]</body><body package="ActiveX-Container">ambientProperties: anAmbientProperties 	ambientProperties ifNotNil: [ ambientProperties removeAllActionsWithReceiver: self ].	ambientProperties  := anAmbientProperties.	ambientProperties ifNotNil: [ ambientProperties when: #propertyChanged send: #ambientChange: to: self. ].</body><body package="ActiveX-Container">controlsDo: aBlock	sites do: [:each | 		each oleControl ifNotNil: [:control |				aBlock value: control ]]</body><body package="ActiveX-Container">hostName	^ self window label</body><body package="ActiveX-Container">iActiveObject	^iActiveObject</body><body package="ActiveX-Container">iActiveObject: anObject	iActiveObject ifNotNil: [ iActiveObject enforceRelease ].	iActiveObject := anObject</body><body package="ActiveX-Container">removeSite: aSite	sites remove: aSite.	"The site hase been removed - nobody should use it any more. 	 Fix for problems with Spreadsheet controls"	aSite forceRelease.	sites isEmpty ifTrue: [		"Nobody should make a call any more - Force the release of all interfaces" 		self forceRelease].</body><body package="ActiveX-Container">sites	^ sites</body><body package="ActiveX-Container">window	^window</body><body package="ActiveX-Container">window: anObject	window = anObject ifTrue: [^self].	window		ifNotNil: 			[window				removeAllActionsWithReceiver: self;				oleContainer: nil].	window := anObject.	window ifNil: [^self].	window		when: #closed send: #releaseWindow to: self;		when: #bounds send: #windowsBoundsChanged to: self</body></methods><methods><class-id>External.ControlContainer</class-id> <category>methods - IOleContainer</category><body package="ActiveX-Container">setContainedControlEnumeratorInto: resultReference		| enumerator |	enumerator := COMInterfaceEnumerator		forIID: IID_IUnknown		elements:			(self containedControls				ifNil: [Array new]				ifNotNil: [Array with: self containedControls]).	resultReference value: enumerator</body></methods><methods><class-id>External.ControlContainer</class-id> <category>private</category><body package="ActiveX-Container">checkControlSetFocus: event		event newFocusWindowHandle		ifNotNil:			[:newFocusWindow | 			self				controlsDo:					[:each | 					| controlWindow |					controlWindow := each getWindow.					(self checkWhether: newFocusWindow isControlOrSub: controlWindow)						ifTrue: [^each]]].	^nil</body><body package="ActiveX-Container">checkWhether: newFocusHWND isControlOrSub: aControlHWND		| currentHWND |	aControlHWND ifNil: [ ^ false ].	currentHWND := newFocusHWND.	[currentHWND notNil] whileTrue: [		currentHWND = aControlHWND ifTrue: [^true].		currentHWND := currentHWND parentWindow].	^ false</body><body package="ActiveX-Container">containedControls	^ sites collect: [:each | each oleControl ]</body><body package="ActiveX-Container">hideOwnTools	Tools.Note remark: 'hiding Tools is not yet supported'.</body><body package="ActiveX-Container">setFrameInfo: lpFrameInfo	lpFrameInfo 		memberAt: #fMDIApp put: false;		memberAt: #hwndFrame put: self window windowHandle;		memberAt: #haccel put: self acceleratorTable handle;		memberAt: #cAccelEntries put: self acceleratorTable size.</body><body package="ActiveX-Container">showOwnTools	Tools.Note remark: 'hiding and showing Tools is not yet supported'.</body></methods><methods><class-id>External.ControlContainer</class-id> <category>IOleInPlaceUIWindow protocol</category><body package="ActiveX-Container">GetBorder: lprectBorder	Tools.Note remark: 'This code is untested'.	self window extent setValuesInStructure: lprectBorder.	^ S_OK</body><body package="ActiveX-Container">RequestBorderSpace: pborderwidths	^ S_OK</body><body package="ActiveX-Container">SetActiveObject: newActiveObject _: pszObjName	self iActiveObject: newActiveObject.	^ S_OK</body><body package="ActiveX-Container">SetBorderSpace: pborderwidths	pborderwidths isValid 		ifTrue: [ self hideOwnTools ]		ifFalse: [ self showOwnTools ].		^ S_OK</body></methods><methods><class-id>External.ControlContainer</class-id> <category>IOleInPlaceFrame protocol</category><body package="ActiveX-Container">EnableModeless: fEnable	^ S_OK</body><body package="ActiveX-Container">InsertMenus: hmenuShared _: lpMenuWidths	^ E_NOTIMPL</body><body package="ActiveX-Container">RemoveMenus: hmenuShared	^ E_NOTIMPL</body><body package="ActiveX-Container">SetMenu: hmenuShared _: holemenu _: hwndActiveObject	Tools.Note remark: 'Setting menu is currently not supported'.	^ S_OK</body><body package="ActiveX-Container">SetStatusText: pszStatusText	self triggerEvent: #statusTextChanged with: pszStatusText.	^ S_OK</body><body package="ActiveX-Container">TranslateAccelerator: lpmsg _: wID	^ E_NOTIMPL</body></methods><methods><class-id>External.ControlContainer</class-id> <category>IOleWindow protocol</category><body package="ActiveX-Container">ContextSensitiveHelp: fEnterMode	^ E_NOTIMPL</body><body package="ActiveX-Container">GetWindow: reference	reference value: self window windowHandle.	^ S_OK</body></methods><methods><class-id>External.ControlContainer</class-id> <category>private computing interfaces</category><body package="ActiveX-Container">computeIOleContainer	^ IOleContainer directBindingOn: self</body><body package="ActiveX-Container">computeIOleInPlaceFrame	^ IOleInPlaceFrame directBindingOn: self</body></methods><methods><class-id>External.ControlContainer</class-id> <category>IOleContainer protocol</category><body package="ActiveX-Container">EnumObjects: grfFlags _: resultReference		grfFlags = OLECONTF_EMBEDDINGS ifTrue: [			self setContainedControlEnumeratorInto: resultReference.			^S_OK].	^E_NOTIMPL</body><body package="ActiveX-Container">LockContainer: fLock	^ E_NOTIMPL</body></methods><methods><class-id>External.ControlContainer</class-id> <category>accessing interfaces</category><body package="ActiveX-Container">iAdviseSink	^ self interfaces at: IID_IAdviseSink</body><body package="ActiveX-Container">iOleContainer	^ self interfaces at: IID_IOleContainer</body><body package="ActiveX-Container">iOleInPlaceFrame		^ self interfaces at: IID_IOleInPlaceFrame.</body></methods><methods><class-id>External.ControlContainer</class-id> <category>initialize-release</category><body package="ActiveX-Container">basicAcceleratorTable 	^ acceleratorTable</body><body package="ActiveX-Container">initialize	super initialize.	sites := OrderedCollection new.</body><body package="ActiveX-Container">initializeAmbientProperties	self ambientProperties: AmbientProperties new.	^ambientProperties</body><body package="ActiveX-Container">initializeInterfaces	super initializeInterfaces.	interfaces		at: IID_IOleContainer put: self computeIOleContainer;		at: IID_IOleInPlaceFrame put: self computeIOleInPlaceFrame;		at: IID_IOleInPlaceUIWindow put: self computeIOleInPlaceFrame;		yourself.	^ interfaces</body><body package="ActiveX-Container">internalRelease	self iActiveObject: nil.	self ambientFont: nil.	self ambientProperties: nil.</body><body package="ActiveX-Container">releaseWindow	window ifNotNil: [window oleContainer: nil]</body></methods><methods><class-id>External.ControlContainer</class-id> <category>IErrorInfo protocol</category><body package="ActiveX-Container">GetDescription: resultReference	^ E_NOTIMPL</body><body package="ActiveX-Container">GetGUID: reference	^ E_NOTIMPL</body><body package="ActiveX-Container">GetHelpContext: resultReference	^ E_NOTIMPL</body><body package="ActiveX-Container">GetHelpFile: resultReference	^ E_NOTIMPL</body><body package="ActiveX-Container">GetSource: resultReference	^ E_NOTIMPL</body></methods><methods><class-id>External.ControlContainer</class-id> <category>IParseDisplayName protocol</category><body package="ActiveX-Container">ParseDisplayName: aBindContext 			_: aDisplayName 			_: nCharsConsumedReference 			_: resultReference	^ E_NOTIMPL</body></methods><methods><class-id>External.ControlContainer</class-id> <category>event handling</category><body package="ActiveX-Container">windowsBoundsChanged	(self iActiveObject notNil and: [ iActiveObject isValid]) ifTrue: [ 		self iActiveObject resizeBorder: self window component bounds with: self iOleInPlaceFrame with: true. ].</body></methods><methods><class-id>External.ControlContainer</class-id> <category>accessing Ambient properties</category><body package="ActiveX-Container">getAmbientAppearance	"Currently we do not autoclip the control"	^ self ambientProperties propertyValueAt: #AmbientAppearance</body><body package="ActiveX-Container">getAmbientAutoClip	"Currently we do not autoclip the control"	^ self ambientProperties propertyValueAt: #AutoClip</body><body package="ActiveX-Container">getAmbientBackgroundColor	^ self ambientProperties propertyValueAt: #BackgroundColor</body><body package="ActiveX-Container">getAmbientDisplayName	^ self ambientProperties propertyValueAt: #DisplayName</body><body package="ActiveX-Container">getAmbientFont	^ self ambientProperties propertyValueAt: #Font</body><body package="ActiveX-Container">getAmbientForeColor	^ self ambientProperties propertyValueAt: #ForeColor</body><body package="ActiveX-Container">getAmbientLocaleId	^ self ambientProperties propertyValueAt: #LocaleId</body><body package="ActiveX-Container">getAmbientMessageReflect	"Boolean value indicating whether the container wants to receive Windows messages such as $WM-CTLCOLOR, $WM-DRAWITEM, or $WM-PARENTNOTIFY. "	^ false</body><body package="ActiveX-Container">getAmbientRightToLeft	^ self ambientProperties propertyValueAt: #RightToLeft</body><body package="ActiveX-Container">getAmbientShowGrabHandles	^ self ambientProperties propertyValueAt: #ShowGrabHandles</body><body package="ActiveX-Container">getAmbientShowHatching	"Answer whether a hatched border should be displayed"	^ self ambientProperties propertyValueAt: #ShowHatching</body><body package="ActiveX-Container">getAmbientSupportsMnemonics	^ self ambientProperties propertyValueAt: #SupportsMnemonics</body><body package="ActiveX-Container">getForeColor	^ self ambientProperties propertyValueAt: #ForeColor</body><body package="ActiveX-Container">getLocaleId	^ self ambientProperties propertyValueAt: #LocaleId</body><body package="ActiveX-Container">getRightToLeft	^ self ambientProperties propertyValueAt: #RightToLeft</body><body package="ActiveX-Container">getShowGrabHandles	^ self ambientProperties propertyValueAt: #ShowGrabHandles</body><body package="ActiveX-Container">getShowHatching	"Answer whether a hatched border should be displayed"	^ self ambientProperties propertyValueAt: #ShowHatching</body><body package="ActiveX-Container">getSupportsMnemonics	^ self ambientProperties propertyValueAt: #SupportsMnemonics</body></methods><methods><class-id>External.ControlContainer</class-id> <category>private constants</category><body package="ActiveX-Container">ambientApplearance3D	^ 1</body><body package="ActiveX-Container">ambientApplearanceFlat	^ 0</body></methods><methods><class-id>External.ControlContainer</class-id> <category>events</category><body package="ActiveX-Container">ambientChange: dispid	self sites		do: [:each | each oleControl iOleControl onAmbientPropertyChange: dispid]</body></methods><methods><class-id>External.ControlContainer</class-id> <category>private computing</category><body package="ActiveX-Container">initializeAmbientFont	^AmbientFont forFont: self window graphicsContext font</body></methods><methods><class-id>External.ControlContainer</class-id> <category>subclass-releasing</category><body package="ActiveX-Container">releaseResources	" Private - release resources associated with the receiver. "	self internalRelease.	super releaseResources.</body></methods><methods><class-id>External.ControlContainer class</class-id> <category>private-initialization</category><body package="ActiveX-Container">commonClsId		^GUID fromString: '{ADF7988B-795E-4691-87CF-55794CA97409}'</body><body package="ActiveX-Container">createSpecificationTable	^ COMDispatchSpecificationTable new			specificationKey: #memberID;			clsid: self clsid;			yourself.</body></methods><methods><class-id>UI.BytelikeControlProperties</class-id> <category>literal array encoding</category><body package="ActiveX-Container">literalArrayEncoding	^ Array with: self class storageTypeName with: self compressedData literalArrayEncoding</body></methods><methods><class-id>UI.BytelikeControlProperties</class-id> <category>accessing</category><body package="ActiveX-Container">cachedPropertyValues	^ cachedPropertyValues ifNil: [ cachedPropertyValues := OrderedCollection new ]</body><body package="ActiveX-Container">compressedData	| writeStream gzStream |	writeStream := ByteArray new writeStream.	gzStream := OS.ZLib.GZipWriteStream bestCompressionOn: writeStream.	gzStream nextPutAll: self data.	gzStream close.	^ writeStream contents</body><body package="ActiveX-Container">compressedData: newData	| gzStream readStream |	readStream := newData readStream.	gzStream := OS.ZLib.GZipReadStream on: readStream.	self data: gzStream contents</body></methods><methods><class-id>UI.BytelikeControlProperties</class-id> <category>property assignment</category><body package="ActiveX-Container">assignPropertiesToEditor: aPropertyEditor	^ self</body></methods><methods><class-id>UI.BytelikeControlProperties</class-id> <category>initialize-release</category><body package="ActiveX-Container">initFromArray: aLiteralArray	self compressedData: (aLiteralArray at: 2)</body></methods><methods><class-id>UI.BytelikeControlProperties</class-id> <category>copying</category><body package="ActiveX-Container">postCopy	super postCopy.	cachedPropertyValues := cachedPropertyValues copy.</body></methods><methods><class-id>UI.BytelikeControlProperties class</class-id> <category>private testing</category><body package="ActiveX-Container">isResponsibleFor: aLiteralArray		^ self storageTypeName notNil and: [ aLiteralArray notEmpty and: [aLiteralArray first = self storageTypeName]]</body></methods><methods><class-id>UI.BytelikeControlProperties class</class-id> <category>private</category><body package="ActiveX-Container">storageTypeName		^ nil</body></methods><methods><class-id>UI.StreamControlProperties</class-id> <category>property assignment</category><body package="ActiveX-Container">loadOrInit: aControl		^aControl iPersistStream notNil		and:			[[self loadStream: aControl iPersistStream]				on: COMError				do: [:ex | self initNew: aControl]]</body></methods><methods><class-id>UI.StreamControlProperties</class-id> <category>private</category><body package="ActiveX-Container">loadStream: iPersistStream		| tempStorage |	tempStorage := COMGlobalMemoryStream on: self data.	^ iPersistStream load: tempStorage</body></methods><methods><class-id>UI.StreamControlProperties class</class-id> <category>private</category><body package="ActiveX-Container">basicNewForControl: aControl propertyValues: anObject	| tempStream |	aControl iPersistStream ifNil: [^nil].	^	[tempStream := COMGlobalMemoryStream newTemporaryBackingStore.	aControl iPersistStream save: tempStream.	(self new)		data: tempStream asByteArray;		yourself]			on: COMError			do: [:ex | ex return: nil]</body><body package="ActiveX-Container">isSpecific	^ true</body><body package="ActiveX-Container">priority	^ 2</body><body package="ActiveX-Container">storageTypeName		^#StreamProperties</body></methods><methods><class-id>External.OLEMiscStatus</class-id> <category>testing OLE status</category><body package="ActiveX-Container">activateWhenVisible	"Only possible if canActivateInsideOut is true. Indicates that this object prefers to be activated whenever it is visible. 	 Containers may always ignore this hint."	^ (self value bitAnd: OLEMISC_ACTIVATEWHENVISIBLE ) &gt; 0</body><body package="ActiveX-Container">actsLikeButton	"Test whether it cares for the container's DisplayAsDefault ambient property."	^ (self value bitAnd: OLEMISC_ACTSLIKEBUTTON ) &gt; 0</body><body package="ActiveX-Container">actsLikeLabel	"Test whether it acts like a label. A mnemonic key activates the control after it" 	^ (self value bitAnd: OLEMISC_ACTSLIKELABEL ) &gt; 0</body><body package="ActiveX-Container">alignable	"Tests whether the control can align itself in a rectangle"	^ (self value bitAnd: OLEMISC_ALIGNABLE ) &gt; 0</body><body package="ActiveX-Container">alwaysRun	"The control should run when created or loaded"	^ (self value bitAnd: OLEMISC_ALWAYSRUN ) &gt; 0</body><body package="ActiveX-Container">canActivateInsideOut	"Test whether this object is capable of activating in-place, without requiring installation of menus and toolbars to run."	^ (self value bitAnd: OLEMISC_INSIDEOUT ) &gt; 0</body><body package="ActiveX-Container">canLinkByOle1	"This object can be linked to by OLE 1 containers. "	^ (self value bitAnd: OLEMISC_CANLINKBYOLE1) &gt; 0</body><body package="ActiveX-Container">cantLinkInside	^ (self value bitAnd: OLEMISC_CANTLINKINSIDE) &gt; 0</body><body package="ActiveX-Container">iconicOnly	"The object has no useful content view other than its icon."	^ (self value bitAnd: OLEMISC_ONLYICONIC) &gt; 0</body><body package="ActiveX-Container">ignoreActivateWhenVisible	^ (self value bitAnd: OLEMISC_IGNOREACTIVATEWHENVISIBLE ) &gt; 0</body><body package="ActiveX-Container">insertNotReplace	"If set, the container should insert the object beside the current selection rather than replacing the current selection. 	 If this bit is not set, the object being inserted replaces the current selection."	^ (self value bitAnd: OLEMISC_INSERTNOTREPLACE) &gt; 0</body><body package="ActiveX-Container">invisibleAtRuntime	^ (self value bitAnd: OLEMISC_INVISIBLEATRUNTIME) &gt; 0</body><body package="ActiveX-Container">isLinkObject	"Test whether this object is a link object."	^ (self value bitAnd: OLEMISC_ISLINKOBJECT) &gt; 0</body><body package="ActiveX-Container">isStatic	"This object is a static object,  it contains no data."	^ (self value bitAnd: OLEMISC_STATIC) &gt; 0</body><body package="ActiveX-Container">noUIActivate	"It indicates that the control has no UI active state, no in-place tools, no shared menu, and no accelerators. 	 It also means that the control never needs the focus."	^ (self value bitAnd: OLEMISC_NOUIACTIVATE ) &gt; 0</body><body package="ActiveX-Container">recomposeOnResize	"If this bit is set, the container should force the object to the running state and call IOleObject::SetExtent with the new size."	^ (self value bitAnd: OLEMISC_RECOMPOSEONRESIZE) &gt; 0</body><body package="ActiveX-Container">renderingIsDeviceIndependent	"This object does not pay any attention to target devices."	^ (self value bitAnd: OLEMISC_RENDERINGISDEVICEINDEPENDENT ) &gt; 0</body><body package="ActiveX-Container">requiresFocus	^ self actsLikeLabel not and: [ self noUIActivate not ]</body><body package="ActiveX-Container">setClientSiteFirst	"Test whether the control wants to use IOleObject::SetClientSite as its initialization function"	^ (self value bitAnd: OLEMISC_SETCLIENTSITEFIRST ) &gt; 0</body><body package="ActiveX-Container">simpleFrame	".Test whether this is a grouping control. In this case the site needs to implement ISimpleFrameSite."	^ (self value bitAnd: OLEMISC_SIMPLEFRAME ) &gt; 0</body><body package="ActiveX-Container">supportsMultiLevelUndo	^ (self value bitAnd: OLEMISC_SUPPORTSMULTILEVELUNDO ) &gt; 0</body><body package="ActiveX-Container">wantsToMenuMerge	"Test whether the control can merge its menus with the containers"	^ (self value bitAnd: OLEMISC_WANTSTOMENUMERGE ) &gt; 0</body></methods><methods><class-id>External.OLEMiscStatus</class-id> <category>accessing</category><body package="ActiveX-Container">value	^value</body><body package="ActiveX-Container">value: anObject	value := anObject</body></methods><methods><class-id>External.OLEMiscStatus class</class-id> <category>instance creation</category><body package="ActiveX-Container">withValue: aValue	^ self new		value: aValue;		yourself</body></methods><methods><class-id>External.ControlProxy</class-id> <category>accessing</category><body package="ActiveX-Container">clsid	^clsid</body><body package="ActiveX-Container">clsid: anObject		anObject = clsid ifTrue: [^self].	clsid := anObject.	self privateRelease.	self createInstance</body><body package="ActiveX-Container">coclass	"Return the coclass specification of this control"	^ self withClassTypeInfoDo: [:typeInfo | External.DispUserDefTypeSpec fromTypeInfo: typeInfo ]</body><body package="ActiveX-Container">controlName	^ self withClassTypeInfoDo: [:typeInfo | typeInfo getDocumentationName ].</body><body package="ActiveX-Container">defaultDrawAspect		^self isAllocated		ifFalse: [DVASPECT_CONTENT]		ifTrue:			[self miscStatus iconicOnly				ifTrue: [DVASPECT_ICON]				ifFalse: [DVASPECT_CONTENT]]</body><body package="ActiveX-Container">dispatchSpecificationTable		^ self propertyAt: #specificationTable ifAbsentPut: [ self dispatchDriver specificationTable withSpecificationKey: #memberID ].</body><body package="ActiveX-Container">isInPlaceActive: aBoolean	flags setFlag: #isInPlaceActive to: aBoolean.	aBoolean		ifTrue: [WindowMessage concreteClass register: self]		ifFalse: [WindowMessage concreteClass unregister: self]</body><body package="ActiveX-Container">licenseKey: anObject	licenseKey := anObject</body><body package="ActiveX-Container">lockInPlaceActive: aBool	^ flags setFlag: #lockInPlaceActive to: aBool.</body><body package="ActiveX-Container">oleControlSite	^oleControlSite</body><body package="ActiveX-Container">oleControlSite: anObject	oleControlSite = anObject ifTrue: [^self].	oleControlSite ifNotNil: [self privateRemoveFromSite ].	oleControlSite := anObject.	oleControlSite ifNotNil: [ self privateSetSite ].</body><body package="ActiveX-Container">progId	^progId</body><body package="ActiveX-Container">progId: anObject	progId := anObject.	self clsid: (self formatClsIDString: progId).</body><body package="ActiveX-Container">shortCuts	^ shortcuts ifNil: [ self initializeShortcuts ].</body><body package="ActiveX-Container">storedProperties		^storedProperties		ifNil: [AbstractControlProperties newForControl: self propertieValues: OrderedCollection new]</body><body package="ActiveX-Container">storedProperties: anObject	storedProperties := anObject</body><body package="ActiveX-Container">updateControlStructure	shortcuts := nil.</body><body package="ActiveX-Container">windowHandle	^self getWindow ifNotNil: [:win | win handle asInteger]</body><body package="ActiveX-Container">windowVisible	^ flags testFlag: #windowVisible</body><body package="ActiveX-Container">windowVisible: aBoolean	^ flags setFlag: #windowVisible to: aBoolean</body></methods><methods><class-id>External.ControlProxy</class-id> <category>accessing interfaces</category><body package="ActiveX-Container">iConnectionPointContainer	^ self interfaceAt: IID_IConnectionPointContainer</body><body package="ActiveX-Container">iDataObject	^ self interfaceAt: IID_IDataObject</body><body package="ActiveX-Container">iDispatch	^ self interfaceAt: IID_IDispatch</body><body package="ActiveX-Container">iOleControl	^ self interfaceAt: IID_IOleControl</body><body package="ActiveX-Container">iOleInPlaceActiveObject	^ self interfaceAt: IID_IOleInPlaceActiveObject</body><body package="ActiveX-Container">iOleInPlaceObject	^ self interfaceAt: IID_IOleInPlaceObject</body><body package="ActiveX-Container">iOleObject	^ self interfaceAt: IID_IOleObject</body><body package="ActiveX-Container">iOleObject: anInterface	self interfaceAt: IID_IOleObject put: anInterface.</body><body package="ActiveX-Container">iPersist	^ self interfaceAt: IID_IPersist</body><body package="ActiveX-Container">iPersistStorage	^ self interfaceAt: IID_IPersistStorage</body><body package="ActiveX-Container">iPersistStream	^ self interfaceAt: IID_IPersistStream</body><body package="ActiveX-Container">iProvideClassInfo	^ self interfaceAt: IID_IProvideClassInfo</body><body package="ActiveX-Container">iUnknown	^ self interfaceAt: IID_IUnknown</body><body package="ActiveX-Container">iViewObject2	^ self interfaceAt: IID_IViewObject2</body></methods><methods><class-id>External.ControlProxy</class-id> <category>private</category><body package="ActiveX-Container">applyCachedProperties		self storedProperties applyCachedPropertiesTo: self.	self notifyOfPropertyChanges</body><body package="ActiveX-Container">beContained: aBoolean		^OLEDLL current OleSetContainedObject: self anyExistingInterface asPointerParameter _: aBoolean</body><body package="ActiveX-Container">clsidOrString: anObject		| newClsID |	newClsID := anObject class = GUID		ifTrue: [ anObject ]		ifFalse: [  self formatClsIDString: anObject ]. 	self clsid: newClsID.</body><body package="ActiveX-Container">formatClsIDString: aString		aString ifNil: [ ^ nil ].	(HostInterface isWindows not and: [ HostInterface isWindowsNT not ]) ifTrue: [ ^  nil ].	(aString occurrencesOf: $-) = 4 ifFalse: [^GUID clsidFromProgID: aString].	^GUID fromString: (self formatGuidString: aString)</body><body package="ActiveX-Container">formatGuidString: aString		aString size = 38 ifTrue: [^aString].	aString size = 36 ifTrue: [^'{' , aString , '}'].	^self error: #PossbleErrorInClassID &lt;&lt; #com &gt;&gt; 'Possible Error in ClassID'</body><body package="ActiveX-Container">inPlaceDeactivate	self isInPlaceActive ifFalse: [^self].	self isLockedInPlaceActive		ifTrue: 			[self error: #TheObjectIsLockedInPlaceActive &lt;&lt; #com						&gt;&gt; 'The Object is locked in-place active'].	^self iOleInPlaceObject inPlaceDeactivate</body><body package="ActiveX-Container">notifyOfPropertyChanges		self propertyBindings do: [:each | each mightBeChanged]</body><body package="ActiveX-Container">privateRelease		self releaseComInterfaces</body><body package="ActiveX-Container">privateRemoveFromSite		self isAllocated ifFalse: [^self].	self isInPlaceActive ifTrue: [self inPlaceDeactivate].	self iOleObject setClientSite: nil.		"Need to remove notifications here as they otherwise keep the object alive"	self beContained: false.	self interfaces: Dictionary new.</body><body package="ActiveX-Container">privateSetSite		self isAllocated ifFalse: [^self].	self iOleObject setClientSite: self oleControlSite iOleClientSite.	self beContained: true.	self miscStatus setClientSiteFirst ifTrue: [self loadFromStorageOrInitNew].</body><body package="ActiveX-Container">propertyBindings	^ self propertyAt: #propertyBindings ifAbsentPut: [ Set new]</body><body package="ActiveX-Container">queryInterface: anIID	^ self anyExistingInterface ifNil: [nil ] ifNotNil: [:interface |		interface queryInterface: anIID ]</body><body package="ActiveX-Container">revokeEmbedding		self isAllocated ifFalse: [^self].	self isInPlaceActive ifTrue: [self  inPlaceDeactivate].	self iOleObject setClientSite: nil.	"Need to remove notifications here as they otherwise keep the object alive"	self beContained: false</body><body package="ActiveX-Container">run	^ OLEDLL current oleRun: self.</body><body package="ActiveX-Container">withClassTypeInfoDo: aBlock	| classTypeInfo |	self iDispatch		ifNotNil: [:dispatch | classTypeInfo := COMDispatchSpecificationTable getClassTypeInfoOf: dispatch].	^aBlock value: classTypeInfo</body></methods><methods><class-id>External.ControlProxy</class-id> <category>printing</category><body package="ActiveX-Container">printOn: aStream		super printOn: aStream.	aStream nextPutAll: '(' , (self progId ifNil: ['unknown']) , ')'</body><body package="ActiveX-Container">storeOn: aStream		aStream		nextPutAll:			'(' , self class fullName				,					(self progId isNil						ifTrue: [' new)']						ifFalse: [' newProgId: ''' , self progId asString , ''')'])</body></methods><methods><class-id>External.ControlProxy</class-id> <category>testing</category><body package="ActiveX-Container">isAllocated	"return whether the control has been allocated"	^ self clsid notNil and: [ self anyExistingInterface notNil ]</body><body package="ActiveX-Container">isEnabled: aBool	^[self setProperty: #Enabled value: aBool] on: COMError		do: [:ex | ex return]</body><body package="ActiveX-Container">isInDesignMode	^ oleControlSite 		ifNil: [ true ]		ifNotNil: [ oleControlSite view 				ifNil: [ true]				ifNotNil: [:view | view isInDesignMode ]]</body><body package="ActiveX-Container">isInPlaceActive	^ flags testFlag: #isInPlaceActive</body><body package="ActiveX-Container">isLockedInPlaceActive	^ flags testFlag: #lockInPlaceActive</body><body package="ActiveX-Container">isRunning	^OLEDLL current OleIsRunning: self iOleObject</body><body package="ActiveX-Container">isUnboundWindow	^true</body><body package="ActiveX-Container">willNeverBeActivated		^self isInDesignMode		or:			[self miscStatus invisibleAtRuntime				or: [self miscStatus activateWhenVisible not]]</body></methods><methods><class-id>External.ControlProxy</class-id> <category>event handling</category><body package="ActiveX-Container">eventNotification: event arguments: args	"The COMEventSink sends the Selector as the Event Symbol. Simplifying the usage by just using the name	of the COM method for the event raised by the Control Object"	| eventName |	eventName := (event copyUpTo: $:) asSymbol.	self triggerEvent: #controlEvent with: event with: args.	^ self triggerEvent: eventName with: args.</body><body package="ActiveX-Container">oleObjectClosed	^ self triggerEvent: #OleObjectClosed.</body><body package="ActiveX-Container">oleObjectDataChanged: arg1 _: arg2	Tools.Note remark: 'oleObjectDataChanged:_: is untestet'.</body><body package="ActiveX-Container">oleObjectRenamed: anIMoniker	^ self triggerEvent: #oleObjectRenamed: with: anIMoniker</body><body package="ActiveX-Container">oleObjectSaved	^ self triggerEvent: #oleObjectSaved</body><body package="ActiveX-Container">propertyChangedID: dispID		| spec |	spec := self dispatchSpecificationTable		at: dispID		ifAbsent:			[ nil ].	self changed: #property with: (spec ifNotNil: [ spec name asSymbol ]).	self		triggerEvent: #propertyChanged		with: (spec ifNotNil: [ spec name asSymbol ]).	^S_OK</body><body package="ActiveX-Container">propertyEditRequested: dispID	"Currently we do not support vetoing property changes"	^ S_OK</body><body package="ActiveX-Container">viewObjectViewChanged: dwAspect with: lindex	self changed: #view with: (Array with: dwAspect with: lindex).	^ self triggerEvent: #viewObjectViewChanged with: dwAspect with: lindex</body></methods><methods><class-id>External.ControlProxy</class-id> <category>classFactory functionality</category><body package="ActiveX-Container">createInstance		self iOleObject: (licenseKey 		ifNil: [ self createInstanceWithoutLicense ]		ifNotNil: [ self createInstanceWithLicense ]).	self iOleObject ifNil: [^ self ].	self miscStatus setClientSiteFirst ifFalse: [ self loadFromStorageOrInitNew ].	"MSDN sayd this flag means the control should be run when it is created"	self miscStatus alwaysRun ifTrue: [ self run ].</body><body package="ActiveX-Container">createInstanceWithLicense		^self		withIClassFactory2Do:			[:factory | 			factory createInstanceLic: nil with: nil with: IID_IOleObject with:					licenseKey]		ifAbsent: [ self createInstanceWithoutLicense ]</body><body package="ActiveX-Container">createInstanceWithoutLicense	^self		withIClassFactoryDo: [:factory | factory createInstance: IID_IOleObject]		ifAbsent: [nil]</body><body package="ActiveX-Container">isLicenseKeyAvailable		^self withIClassFactory2Do: [:factory | factory getLicInfo runtimeKeyAvailable ] ifAbsent: [false ]</body><body package="ActiveX-Container">requestLicKey	^self withIClassFactory2Do: [:factory | factory requestLicKey]		ifAbsent: [nil]</body><body package="ActiveX-Container">withIClassFactory2Do: aBlock ifAbsent: anotherBlock		| classFactory |	self clsid ifNil: [^anotherBlock value].	classFactory := nil.	[classFactory := IClassFactory2		forCLSID: self clsid		context: CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER]		on: Error		do: [:ex | ex return].	classFactory ifNil: [^anotherBlock value].	^aBlock value: classFactory</body><body package="ActiveX-Container">withIClassFactoryDo: aBlock ifAbsent: anotherBlock	| classFactory |	classFactory := 			[IClassFactory forCLSID: self clsid				context: CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER ]					on: COMError					do: [:ex | ^ anotherBlock value].	^aBlock value: classFactory</body></methods><methods><class-id>External.ControlProxy</class-id> <category>IDispatch Protocol</category><body package="ActiveX-Container">basicSetProperty: key value: aValue	^ self dispatchDriver setProperty: key asString value: aValue</body><body package="ActiveX-Container">getProperty: aSymbol	^ (self isAllocated and: [ self isInPlaceActive or: [ self willNeverBeActivated ]])		ifTrue: [ self dispatchDriver getProperty: aSymbol asString ]		ifFalse: [ self storedProperties getProperty: aSymbol ]</body><body package="ActiveX-Container">invokeMethod: method 	^ self dispatchDriver invokeMethod: method asString</body><body package="ActiveX-Container">invokeMethod: method with: aValue	^ self dispatchDriver invokeMethod: method asString with: aValue</body><body package="ActiveX-Container">invokeMethod: method withArguments: arguments	^ self dispatchDriver invokeMethod: method asString withArguments: arguments</body><body package="ActiveX-Container">safeSetProperty: propertyName value: aValue	"set the property without the probability of causing exceptions"	^ [ self setProperty: propertyName asString value: aValue. true] on: COMError do: [:ex | ex return: false ].</body><body package="ActiveX-Container">setProperty: propertyName value: aValue	"Some controls could not set properties nethertheless the control site was set.	 As we do not activate controls in design mode, it can't be done at this point"	^oleControlSite notNil		ifTrue: [self basicSetProperty: propertyName asString value: aValue]		ifFalse: [self storedProperties setProperty: propertyName value: aValue]</body></methods><methods><class-id>External.ControlProxy</class-id> <category>private interface management</category><body package="ActiveX-Container">anyExistingInterface		^self interfaces		detect: [:each | each notNil]		ifNone: [nil]</body><body package="ActiveX-Container">basicInterfaceAt: anIID 	^ self interfaces at: anIID ifAbsent: [ nil ].</body><body package="ActiveX-Container">currentInterfacesDo: aBlock		interfaces ifNil: [ ^ self ].	interfaces values		do: [:each | (each notNil and: [ each isValid]) ifTrue:  [aBlock value: each]]</body><body package="ActiveX-Container">interfaceAt: anIID	| interface |	^ self interfaceAt: anIID ifAbsent: [ 		interface := (self queryInterface: anIID).		self interfaces at: anIID put: interface. 		interface]</body><body package="ActiveX-Container">interfaceAt: anIID ifAbsent: aBlock	^ self interfaces at: anIID ifAbsent: aBlock</body><body package="ActiveX-Container">interfaceAt: anIID put: anInterface	(self interfaces at: anIID ifAbsent: [ nil ]) ifNotNil: [:oldInterface |		oldInterface isValid ifTrue: [ oldInterface enforceRelease ]].	^ anInterface isNil 		ifTrue: [ self interfaces removeKey: anIID ifAbsent: [] ]		ifFalse: [ self interfaces at: anIID put: anInterface ]</body></methods><methods><class-id>External.ControlProxy</class-id> <category>private accessing</category><body package="ActiveX-Container">dispatchDriver	^dispatchDriver		ifNil: 			[dispatchDriver := COMDispatchDriver 								on: self iDispatch.					dispatchDriver				specificationPolicy: COMSpecificationPolicy newDefaultPolicy;				needsFinalization;				yourself]</body><body package="ActiveX-Container">eventSpecificationTable		self iDispatch ifNil: [^self newEmptySpecificationTable].	^([COMDispatchSpecificationTable getEventTypeInfoOf: self iDispatch]		on: Error		do: [:ex | ex return: nil])		ifNil: [self newEmptySpecificationTable]		ifNotNil:			[:eventTypeInfo | 			COMDispatchSpecificationTable specificationTableFor: eventTypeInfo				specificationKey: #memberID]</body><body package="ActiveX-Container">interfaces	^interfaces ifNil: [ 		self interfaces: Dictionary new.		interfaces ].</body><body package="ActiveX-Container">interfaces: anObject		self  currentInterfacesDo: [:each | [ each enforceRelease ] on: Error do: [:ex | ex return ]. ].	interfaces := anObject.</body><body package="ActiveX-Container">miscStatus	^ miscStatus ifNil: [ miscStatus := self iOleObject getMiscStatusObjectFor: self ].</body><body package="ActiveX-Container">newEmptySpecificationTable		^(COMDispatchSpecificationTable new)		specificationKey: #memberID;		yourself</body><body package="ActiveX-Container">properties	^ properties ifNil: [ properties := IdentityDictionary new ]</body></methods><methods><class-id>External.ControlProxy</class-id> <category>converting</category><body package="ActiveX-Container">himetricToPixels: psizel		^ psizel / self class pixelsToHimetricFactor</body><body package="ActiveX-Container">pixelsToHimetric: psizel		^ (self class pixelsToHimetricFactor * psizel) truncated</body></methods><methods><class-id>External.ControlProxy</class-id> <category>private property accessing</category><body package="ActiveX-Container">propertyAt: key 	^ self properties at: key ifAbsent: [ nil ]</body><body package="ActiveX-Container">propertyAt: key ifAbsent: aBlock	^ self properties at: key ifAbsent: aBlock</body><body package="ActiveX-Container">propertyAt: key ifAbsentPut: aBlock	^ self properties at: key ifAbsentPut: aBlock</body><body package="ActiveX-Container">propertyAt: key put: aValue	self properties at: key put: aValue</body></methods><methods><class-id>External.ControlProxy</class-id> <category>interface methods</category><body package="ActiveX-Container">getWindow	| res |	res :=  [ self iOleInPlaceObject getWindow ] on: Error do: [:ex | ex return: nil ].	^ res</body><body package="ActiveX-Container">setExtent: psizel		| himetricSize |	himetricSize := self pixelsToHimetric: psizel.	^ self setExtentInCFormat: himetricSize asTemporaryCStructure</body><body package="ActiveX-Container">setExtentInCFormat: psizel	"An error occured when setting the extent of CommonDialogs Controls, which 	is only iconic. Assuming this opertation is not supported for this kind of	objects"	self miscStatus iconicOnly		ifFalse: 			[^[self iOleObject setExtent: self defaultDrawAspect with: psizel]				on: COMError				do: [:ex | ex return: nil]]</body><body package="ActiveX-Container">setHostNames: szContainerApp	^ self setHostNames: szContainerApp with: szContainerApp</body><body package="ActiveX-Container">setHostNames: szContainerApp with: szContainerObj	^ self iOleObject setHostNames: szContainerApp with: szContainerObj</body></methods><methods><class-id>External.ControlProxy</class-id> <category>private computing</category><body package="ActiveX-Container">addSpecs: aSpecTable to: completeSpecTable assignments: assignments		aSpecTable specificationTable		do:			[:each | 			completeSpecTable				at: each memberID				put: each.			assignments				at: each memberID				put: aSpecTable]</body></methods><methods><class-id>External.ControlProxy</class-id> <category>initialize-release</category><body package="ActiveX-Container">initialize	self needsFinalization.	self interfaces: Dictionary new.	flags := Flags new.</body><body package="ActiveX-Container">release		^ self callIsDispensable</body><body package="ActiveX-Container">releaseComInterfaces		dispatchDriver enforceRelease.	dispatchDriver := nil.	self interfaces: nil.</body></methods><methods><class-id>External.ControlProxy</class-id> <category>persistence</category><body package="ActiveX-Container">loadFromStorageOrInitNew		self storedProperties loadOrInit: self.</body></methods><methods><class-id>External.ControlProxy</class-id> <category>notices</category><body package="ActiveX-Container">enforceRelease	^ self privateRelease</body></methods><methods><class-id>External.ControlProxy</class-id> <category>property update notification config</category><body package="ActiveX-Container">notifyOnLateUpdate: aPropertyBinding	self propertyBindings add: aPropertyBinding.</body><body package="ActiveX-Container">removeUpdateNotificationFor: aPropertyBinding	self propertyBindings remove: aPropertyBinding</body></methods><methods><class-id>External.ControlProxy</class-id> <category>finalization</category><body package="ActiveX-Container">finalize	^ self privateRelease.</body></methods><methods><class-id>External.ControlProxy class</class-id> <category>accessing</category><body package="ActiveX-Container">availableProgIds	^ COMRegistryInterface controlMap</body><body package="ActiveX-Container">pixelsToHimetricFactor	^ PixelsToHimetricFactor ifNil: [		PixelsToHimetricFactor  :=  (ATLDLL current atlPixelToHiMetric: 10000@10000 ) /10000.0].</body></methods><methods><class-id>External.ControlProxy class</class-id> <category>instance creation</category><body package="ActiveX-Container">new	^ super new initialize</body></methods><methods><class-id>External.ControlSite</class-id> <category>IOleClientSite protocol</category><body package="ActiveX-Container">GetContainer: aResultReference		aResultReference		value:			(self oleContainer				ifNil: [nil]				ifNotNil: [:container | container iOleContainer]).	^S_OK</body><body package="ActiveX-Container">GetMoniker: dwAssign _: dwWhichMoniker _: resultReference	"MSDN says this method is optional"	^ E_NOTIMPL</body><body package="ActiveX-Container">OnShowWindow: fShow	oleControl windowVisible: fShow.	^ S_OK</body><body package="ActiveX-Container">RequestNewObjectLayout	"Asks container to allocate more or less space for displaying an embedded object."	| posRectRef clipRectRef |"	sizeHimetric := self oleControl getExtent.	pixelSize := self oleControl himetricToPixels: sizeHimetric."	posRectRef := nil asValue.	clipRectRef := nil asValue.	self view getPositionRect: posRectRef clipRect: clipRectRef.	self oleControl isRunning ifFalse: [ self oleControl run ].	self oleControl iOleInPlaceObject setObjectRects: posRectRef value with: clipRectRef value.	^ S_OK</body><body package="ActiveX-Container">SaveObject	"Saves the object associated with the client site. This function is synchronous; 	 by the time it returns, the save will be completed."	^ E_NOTIMPL</body><body package="ActiveX-Container">ShowObject	"Tells the container to position the object so it is visible to the user. 	This method ensures that the container itself is visible and not minimized."	Tools.Note remark: 'found a note saying we should move the object into the visible area of the window, maybe it has becom active and expects some input'.	^ S_OK</body></methods><methods><class-id>External.ControlSite</class-id> <category>accessing</category><body package="ActiveX-Container">eventManager	^ eventManager ifNil: [ eventManager := ControlEventManager new ].</body><body package="ActiveX-Container">oleContainer	^ oleContainer ifNil: [ self addSelfToOleContainer ].</body><body package="ActiveX-Container">oleControl	^ oleControl</body><body package="ActiveX-Container">oleControl: aControl		aControl = oleControl ifTrue: [^self].	self eventManager control: nil.	oleControl ifNotNil: [oleControl oleControlSite: nil].	oleControl := aControl.	(oleControl notNil and: [oleControl isAllocated]) ifFalse: [^self].	aControl oleControlSite: self.	self eventManager control: aControl.	self registerEvents.	aControl		setHostNames:			(self oleContainer				ifNil: ['']				ifNotNil: [:container | container hostName])</body><body package="ActiveX-Container">uiActive	^ self flags testFlag: #uiActive</body><body package="ActiveX-Container">uiActive: aBoolean	self flags setFlag: #uiActive to: aBoolean</body><body package="ActiveX-Container">view	^view</body><body package="ActiveX-Container">view: aView		view ifNotNil: [self removeFromView: view ].	view := aView.	view notNil ifTrue: [ self addSelfToOleContainer ].</body></methods><methods><class-id>External.ControlSite</class-id> <category>IOleControlSite protocol</category><body package="ActiveX-Container">GetExtendedControl: resultReference	^ E_NOTIMPL</body><body package="ActiveX-Container"> LockInPlaceActive: fLock	self oleControl ifNotNil: [ oleControl lockInPlaceActive: fLock ].	^ S_OK</body><body package="ActiveX-Container">OnControlInfoChanged	oleControl updateControlStructure.	^ S_OK</body><body package="ActiveX-Container">OnFocus: fGotFocus	| controller |	controller := self view controller.	fGotFocus 		ifTrue: [	controller keyboardProcessor requestActivationFor: controller ]		ifFalse: [ "We should not do anything here as we might lose the focus to one of the control's tools "].	self oleControl onFocus: fGotFocus. 	^ S_OK</body><body package="ActiveX-Container">ShowPropertyFrame	Tools.Note remark: 'Show property frame is not supported by now'.	^ E_NOTIMPL</body><body package="ActiveX-Container">TransformCoords: pPtlHimetric _: pPtfContainer _: dwFlags	| result |	(dwFlags bitAnd: XFORMCOORDS_HIMETRICTOCONTAINER)		= XFORMCOORDS_HIMETRICTOCONTAINER			ifTrue: 				[result := self oleControl							himetricToPixels: (Point fromPOINTLStructure: pPtlHimetric).				result := self applyClippingFor: dwFlags on: result.				result setInCPoint: pPtfContainer.				^S_OK].	(dwFlags bitAnd: XFORMCOORDS_CONTAINERTOHIMETRIC)		= XFORMCOORDS_CONTAINERTOHIMETRIC			ifTrue: 				[result := self oleControl							pixelsToHimetric: (Point fromPOINTLStructure: pPtfContainer).				result := self applyClippingFor: dwFlags on: result.				result rounded setInCPoint: pPtlHimetric.				^ S_OK].	^E_INVALIDARG</body><body package="ActiveX-Container">TranslateAccelerator: pMsg _: grfModifiers	Tools.Note remark: 'TranslateAccelerator not supported'.	^ E_NOTIMPL.</body><body package="ActiveX-Container">applyClippingFor: dwFlags on: aPoint	(dwFlags bitAnd: XFORMCOORDS_SIZE) = XFORMCOORDS_SIZE		ifTrue: [ ^ aPoint abs ].	(dwFlags bitAnd: XFORMCOORDS_POSITION) = XFORMCOORDS_POSITION		ifTrue: [ ^ aPoint ].	^  COMError raiseSignal: E_INVALIDARG</body></methods><methods><class-id>External.ControlSite</class-id> <category>initialize-release</category><body package="ActiveX-Container">initialize	super initialize.	self needsFinalization.	flags := Flags new.</body></methods><methods><class-id>External.ControlSite</class-id> <category>IOleInPlaceSite protocol</category><body package="ActiveX-Container">CanInPlaceActivate	^ S_OK</body><body package="ActiveX-Container">DeactivateAndUndo		self oleControl iOleInPlaceObject uiDeactivate: self oleControl.	^S_OK</body><body package="ActiveX-Container">DiscardUndoState	"MSDN said may just return S_OK and do nothing"	^ S_OK</body><body package="ActiveX-Container">GetWindowContext: frameReference _: docReference _: lprcPosRect _: lprcClipRect _: lpFrameInfo	frameReference value: self oleContainer iOleInPlaceFrame.	docReference value: nil.	self view widgetBounds setValuesInRECT: lprcPosRect. 	self view clippingBounds setValuesInRECT: lprcClipRect. 	self oleContainer setFrameInfo: lpFrameInfo.	^ S_OK</body><body package="ActiveX-Container">OnInPlaceActivate	self class increaseEmbeddedControlCount.	oleControl isInPlaceActive: true.	^ S_OK</body><body package="ActiveX-Container">OnInPlaceDeactivate	self class decreaseEmbeddedControlCount.	oleControl isInPlaceActive: false.	^ S_OK</body><body package="ActiveX-Container">OnPosRectChange: lprcPosRect	| posRectRef clipRectRef |	posRectRef := nil asValue.	clipRectRef := nil asValue.	self view getPositionRect: posRectRef clipRect: clipRectRef.	self oleControl run.	self oleControl iOleInPlaceObject setObjectRects: posRectRef value with: clipRectRef value.	^ S_OK</body><body package="ActiveX-Container">OnUIActivate	self uiActive: true.	^ S_OK</body><body package="ActiveX-Container">OnUIDeactivate: fUndoable	self uiActive: false.	^ S_OK</body><body package="ActiveX-Container">Scroll: scrollExtent	"Currently we do not support controls which are larger than their view.	 Do nothing. MSDN says may just return S_FALSE"	^ S_FALSE</body></methods><methods><class-id>External.ControlSite</class-id> <category>accessing interfaces</category><body package="ActiveX-Container">iAdviseSink	^ self interfaces at: IID_IAdviseSink</body><body package="ActiveX-Container">iDispatch	^ self dispatchInterface</body><body package="ActiveX-Container">iOleClientSite	^ self interfaces at: IID_IOleClientSite</body><body package="ActiveX-Container">iOleControlSite	^ self interfaces at: IID_IOleControlSite</body><body package="ActiveX-Container">iOleInPlaceSite	^ self interfaces at: IID_IOleInPlaceSite</body></methods><methods><class-id>External.ControlSite</class-id> <category>private computing interfaces</category><body package="ActiveX-Container">computeIAdviseSink	^ IAdviseSink directBindingOn: self</body><body package="ActiveX-Container">computeIOleClientSite	^ IOleClientSite directBindingOn: self</body><body package="ActiveX-Container">computeIOleControlSite	^ IOleControlSite directBindingOn: self</body><body package="ActiveX-Container">computeIOleDocumentSite	^ IOleDocumentSite directBindingOn: self</body><body package="ActiveX-Container">computeIOleInPlaceSite	^ IOleInPlaceSite directBindingOn: self</body><body package="ActiveX-Container">computeIOleInPlaceSiteWindowless	^ IOleInPlaceSiteWindowless directBindingOn: self</body></methods><methods><class-id>External.ControlSite</class-id> <category>IOleInPlaceSiteWindowless protocol</category><body package="ActiveX-Container">CanWindowlessActivate	"Answer whether the object can activate without a window"		^ S_OK</body></methods><methods><class-id>External.ControlSite</class-id> <category>IAdviseSink protocol</category><body package="ActiveX-Container">viewChanged: dwAspect with: lIndex	| handle tempFlags |	tempFlags := Win32UserDLL RDW_INVALIDATE | Win32UserDLL  RDW_UPDATENOW | Win32UserDLL RDW_ALLCHILDREN.	handle := self  view windowHandle.	Win32UserDLL current 		InvalidateRect:handle _: nil _: true;		RedrawWindow: handle _: self view widgetBounds _: tempFlags.</body></methods><methods><class-id>External.ControlSite</class-id> <category>private computing</category><body package="ActiveX-Container">addSelfToOleContainer	"Add me to the OLE Container Object of the view's window so it is possible to manage focus 	 of the control"	^ oleContainer := self view oleContainer		addSite: self;		yourself</body></methods><methods><class-id>External.ControlSite</class-id> <category>accessing Ambient properties</category><body package="ActiveX-Container">getAmbientAppearance	"Currently we do not autoclip the control"	^ self oleContainer  getAmbientAppearance</body><body package="ActiveX-Container">getAutoClip	"Currently we do not autoclip the control"	^ self oleContainer getAmbientAutoClip</body><body package="ActiveX-Container">getBackgroundColor	^ self oleContainer getAmbientBackgroundColor</body><body package="ActiveX-Container">getDisplayAsDefault	^ self view isDefault</body><body package="ActiveX-Container">getDisplayName	^ self oleContainer getAmbientDisplayName</body><body package="ActiveX-Container">getFont	^ self oleContainer getAmbientFont iFontDisp</body><body package="ActiveX-Container">getForeColor	^ self oleContainer getAmbientForeColor</body><body package="ActiveX-Container">getLocaleId	^ self oleContainer getAmbientLocaleId</body><body package="ActiveX-Container">getMessageReflect	"Boolean value indicating whether the container wants to receive Windows messages such as $WM-CTLCOLOR, $WM-DRAWITEM, or $WM-PARENTNOTIFY. "	^ false</body><body package="ActiveX-Container">getRightToLeft	^ self oleContainer getAmbientRightToLeft</body><body package="ActiveX-Container">getShowGrabHandles	^ self oleContainer getAmbientShowGrabHandles</body><body package="ActiveX-Container">getShowHatching	"Answer whether a hatched border should be displayed"	^ self oleContainer getAmbientShowHatching</body><body package="ActiveX-Container">getSupportsMnemonics	^ self oleContainer getAmbientSupportsMnemonics</body><body package="ActiveX-Container">getUIDead	"True if user input should be ignored."	^ self view isInDesignMode</body><body package="ActiveX-Container">getUserMode	^ self view isInDesignMode not</body></methods><methods><class-id>External.ControlSite</class-id> <category>finalization</category><body package="ActiveX-Container">finalize	self objectRelease</body></methods><methods><class-id>External.ControlSite</class-id> <category>IOleWindow protocol</category><body package="ActiveX-Container">ContextSensitiveHelp: fEnterMode	"MSDN sayd it may return S_FALSE and do nothing"		^ S_FALSE</body><body package="ActiveX-Container">GetWindow: phwnd		^self view windowHandle		ifNil: [E_FAIL]		ifNotNil:			[:handle | 			phwnd value: handle.			S_OK]</body></methods><methods><class-id>External.ControlSite</class-id> <category>private accessing</category><body package="ActiveX-Container">flags	^ flags</body></methods><methods><class-id>External.ControlSite</class-id> <category>widget events</category><body package="ActiveX-Container">revokeControlEmbedding	self oleControl: nil.</body></methods><methods><class-id>External.ControlSite</class-id> <category>private</category><body package="ActiveX-Container">registerEvents	"currently do nothing"	self oleControl when: #viewObjectViewChanged send: #viewChanged:with: to: self.</body><body package="ActiveX-Container">removeFromContainer	oleContainer ifNotNil: [ oleContainer removeSite: self ].</body></methods><methods><class-id>External.ControlSite</class-id> <category>Controlling</category><body package="ActiveX-Container">removeFromView: aView	(view = aView) ifTrue: [ self removeFromContainer ].</body></methods><methods><class-id>External.ControlSite</class-id> <category>events</category><body package="ActiveX-Container">pause		self eventManager pause.	oleControl ifNotNil: [oleControl pause].	self view pause.</body><body package="ActiveX-Container">reactivate	"Reactivate the Site at system startup"	super reactivate.	oleControl ifNotNil: [ view reactivate ].	self eventManager reactivate.</body></methods><methods><class-id>External.ControlSite</class-id> <category>subclass-releasing</category><body package="ActiveX-Container">releaseAllocatedInterfaces	" Private - release the interfaces supported by the receiver which have been allocated during its lifetime. "	self allocatedInterfacesDo: [ :anInterface | 		anInterface interfaceBinding releaseResources ].</body></methods><methods><class-id>External.ControlSite</class-id> <category>subclass-initializing</category><body package="ActiveX-Container">initializeInterfaces	super initializeInterfaces.	^ interfaces := Dictionary new		at: IID_IOleControlSite put: self computeIOleControlSite;		at: IID_IOleInPlaceSite put: self computeIOleInPlaceSite;		at: IID_IOleClientSite put: self computeIOleClientSite;		yourself.</body></methods><methods><class-id>External.ControlSite class</class-id> <category>private-initialization</category><body package="ActiveX-Container">commonClsId		^GUID fromString: '{389F3AC1-164C-4E09-8004-D5FEE2553DE3}'</body><body package="ActiveX-Container">createSpecificationTable	^ COMDispatchSpecificationTable new			specificationKey: #memberID;			clsid: self clsid;			add: (COMDispatchPropertySpecification name: #AmbientAppearance memberID: 	DISPID_AMBIENT_APPEARANCE typeCode: VT_I4);			add: (COMDispatchPropertySpecification name: #AutoClip memberID: 			DISPID_AMBIENT_AUTOCLIP typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #BackgroundColor memberID: 	DISPID_AMBIENT_BACKCOLOR typeCode: VT_I4);			add: (COMDispatchPropertySpecification name: #DisplayAsDefault memberID: 	DISPID_AMBIENT_DISPLAYASDEFAULT typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #DisplayName memberID: 		DISPID_AMBIENT_DISPLAYNAME typeCode: VT_BSTR);			add: (COMDispatchPropertySpecification name: #Font memberID: 				DISPID_AMBIENT_FONT typeCode: VT_FONT);			add: (COMDispatchPropertySpecification name: #ForeColor memberID: 			DISPID_AMBIENT_FORECOLOR typeCode: VT_I4);			add: (COMDispatchPropertySpecification name: #LocaleId memberID: 				DISPID_AMBIENT_LOCALEID typeCode: VT_I4);					add: (COMDispatchPropertySpecification name: #MessageReflect memberID: 		DISPID_AMBIENT_MESSAGEREFLECT typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #ShowGrabHandles memberID: 	DISPID_AMBIENT_SHOWGRABHANDLES typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #SupportsMnemonics memberID: 	DISPID_AMBIENT_SUPPORTSMNEMONICS typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #ShowHatching memberID: 		DISPID_AMBIENT_SHOWHATCHING typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #UIDead memberID: 				DISPID_AMBIENT_UIDEAD typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #UserMode memberID: 			DISPID_AMBIENT_USERMODE typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #RightToLeft memberID: 			DISPID_AMBIENT_RIGHTTOLEFT typeCode: VT_BOOL);			add: (COMDispatchPropertySpecification name: #ScaleUnits memberID:			DISPID_AMBIENT_SCALEUNITS type: VT_BOOL);			add: (COMDispatchPropertySpecification name: #TextAlign memberID:			DISPID_AMBIENT_TEXTALIGN type: VT_I2);			yourself.</body></methods><methods><class-id>External.ControlSite class</class-id> <category>private</category><body package="ActiveX-Container">decreaseEmbeddedControlCount	EmbeddedControlCount := EmbeddedControlCount  - 1.	EmbeddedControlCount = 0 ifTrue: [ InputState default stopWindowMessageProcessingFor: #ActiveX ].</body><body package="ActiveX-Container">increaseEmbeddedControlCount	EmbeddedControlCount := EmbeddedControlCount  + 1.	EmbeddedControlCount = 1 ifTrue: [ InputState default startWindowMessageProcessingFor: #ActiveX ].</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>event accessing</category><body package="ActiveX-Container">canTriggerEvent: eventName	^  self hasEvent: eventName</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>private-accessing</category><body package="ActiveX-Container">myEventTable	"Private - answer a Dictionary mapping event names to actions	for the receiver, or nil if there is none."	^eventTable</body><body package="ActiveX-Container">myEventTable: newTable	"Private"	eventTable := newTable.</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>releasing</category><body package="ActiveX-Container">release	"Remove references to objects that may refer to the receiver. Answers self. "	" Note that we are careful not to invoke IUnknown::Release on the receiver, as is done by default for a COMObject as part of the convenience protocol of supporting the IUnknown operations directly on the object, which is strictly incorrect in the COM architecture because clients should never have direct access to anything but an interface but generally convenient for the Smalltalk COM developer who is actually creating a COMObject instance.  A COM event sink object is a Smalltalk object which happens to use COM services in its implementation.  It is used by a Smalltalk client who creates the event sink, connects it to some event source object, and then disconnects the event sink when they are done.  Although the creator should not ordinarily release the event sink itself, unless they have specifically acquired an interface reference themselves via #queryInterface: that they thus own and are responsible for releasiong, it would not be surprising for a Smalltalk programmer to (incorrectly) send #release to the sink object they created because they've gotten used to the COM rule 'always send #release when you're done using your COM resource', forgetting that this is not an interface that they have acquired but Just Another Smalltalk Object that they created.  Anyway, we want to be safe and protect against inadvertent reference counting bugs that would result from the inherited semantics of the COMObject convenience method.  Really bad things happen when you release an object you don't own out from underneath whoever really owns it and presumably is still trying to use it. "	self objectRelease.	self configuration releaseConnection.  " disconnect if the sink was still connected "</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>accessing</category><body package="ActiveX-Container">configuration	^configuration</body><body package="ActiveX-Container">connectionPointIID: anObject	self configuration connectionPointIID: anObject.	self configuration		specificationTable: (self specificationTableForIID: anObject).	self configuration		sinkInterface: ((COMInterface				classForIID: self configuration connectionPointIID) directBindingOn: self)</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>private</category><body package="ActiveX-Container">hasEvent: eventName	^self configuration specificationTable includesKey: eventName asSymbol</body><body package="ActiveX-Container">specificationTableForIID: anIID	| table |	table := Dictionary new.	((self vtableDescriptionFor: anIID) copyFrom: 4 to: 5) do: 			[:each |			table at: each name asSymbol put: each.			table at: each selector put: each].	^table</body><body package="ActiveX-Container">vtableDescriptionFor: anIID	^ (COMInterfaceImplementation classForIID: anIID) vtableDescription</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>class membership</category><body package="ActiveX-Container">respondsTo: aSymbol	"answer whether the receiver may respond to the given selector"	^(super respondsTo: aSymbol)		or: [self configuration specificationTable includesKey: aSymbol]</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>error handling</category><body package="ActiveX-Container">doesNotUnderstand: aMessage	| description |	description := self configuration specificationTable at: aMessage selector				ifAbsent: [^E_NOTIMPL].	^self triggerEvent: description name asSymbol		withArguments: aMessage arguments</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>subclass-releasing</category><body package="ActiveX-Container">releaseInnerObjects	" Private - release any inner objects owned by the receiver.  Should be reimplemented by subclasses which are controlling objects of an aggregate or which use containment to implement their services. "	self configuration releaseConnection.</body><body package="ActiveX-Container">releaseResources	" Private - release resources associated with the receiver. "	self configuration disconnect.	super releaseResources</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>private initialization</category><body package="ActiveX-Container">configureIID: anIID specificationTable: specificationTable	self connectionPointIID: anIID.	self configuration specificationTable: specificationTable</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>subclass-enumerating</category><body package="ActiveX-Container">allocatedInterfacesDo: aOneArgBlock	" Private - enumerate the interfaces supported by the receiver which have been allocated during its lifetime and evaluate &lt;aOneArgBlock&gt; with each.  Should be reimplemented by each subclass.  The subclass implementation should invoke the superclass method before enumerating the allocated interfaces managed in subclass storage. "	super allocatedInterfacesDo: aOneArgBlock.	self configuration sinkInterface notNil		ifTrue: [aOneArgBlock value: self configuration sinkInterface]</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>subclass-initializing</category><body package="ActiveX-Container">initialize	configuration := SinkConfiguration new.	SystemGlobalRegistries safe: configuration forLifeTimeOf: self.	^ super initialize.</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>connecting</category><body package="ActiveX-Container">disconnect	self configuration disconnect</body><body package="ActiveX-Container">establishConnectionTo: anInterface	" Establish an event connection to the event source object 		which supports &lt;anInterface&gt;. "	^configuration establishConnectionTo: anInterface</body><body package="ActiveX-Container">formatEventName: aName	^ aName asSymbol</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>subclass-accessing</category><body package="ActiveX-Container">getInterfaceForIID: iid	" Private - answer the interface identified by the GUID &lt;iid&gt;.  Answer nil if the requested interface is not supported by the receiver.  This method should be reimplemented by subclasses. "	iid = self configuration connectionPointIID		ifTrue: [ ^ self configuration sinkInterface ].	^ super getInterfaceForIID: iid</body></methods><methods><class-id>External.GenericCOMEventSink</class-id> <category>finalization</category><body package="ActiveX-Container">finalize	self configuration connectionPointInterface: nil.	self releaseResources.</body></methods><methods><class-id>External.GenericCOMEventSink class</class-id> <category>instance creation</category><body package="ActiveX-Container">iid: anIID		" Answer a new instance of the receiver which will receive event		notifications from the connection point specified by &lt;anIID&gt;"	^self new		connectionPointIID: anIID;		yourself</body><body package="ActiveX-Container">iid: anIID specificationTable: aSpecificationTable	" Answer a new instance of the receiver which will receive event		notifications from the connection point specified by &lt;anIID&gt;.		The incoming event notifications are described by the		specifications in &lt;aSpecificationTable&gt;.  "	^(self new)		configureIID: anIID specificationTable: aSpecificationTable;		yourself</body></methods><methods><class-id>UI.StorageControlProperties</class-id> <category>property assignment</category><body package="ActiveX-Container">loadOrInit: aControl		aControl iPersistStorage isNil		ifTrue: [self initNew: aControl]		ifFalse:			[[self loadStorage: aControl iPersistStorage]				on: COMError				do: [:ex | self initNew: aControl]]</body></methods><methods><class-id>UI.StorageControlProperties</class-id> <category>private</category><body package="ActiveX-Container">loadStorage: iPersistStorage	| tempStorage |	tempStorage := COMGlobalMemoryStorage on: self data.	^iPersistStorage load: tempStorage</body></methods><methods><class-id>UI.StorageControlProperties class</class-id> <category>private</category><body package="ActiveX-Container">basicNewForControl: aControl propertyValues: anObject		| tempStorage |	aControl iPersistStorage ifNil: [^nil].	tempStorage := COMGlobalMemoryStorage newTemporaryBackingStore.	^[aControl iPersistStorage saveTo: tempStorage sameAsLoad: false.	self new 		data: tempStorage asByteArray;		yourself]		on: Error		do: [:ex | ex return: nil]</body><body package="ActiveX-Container">isSpecific	^ true</body><body package="ActiveX-Container">priority	^ 3</body><body package="ActiveX-Container">storageTypeName		^#StorageProperties</body></methods><methods><class-id>External.ControlEventManager</class-id> <category>accessing sinks</category><body package="ActiveX-Container">basicEventSink		^ self sinks at: #EventSink ifAbsent: nil</body><body package="ActiveX-Container">basicOleObjectAdviseSink		^ self sinks at: #OleObjectAdviseSink ifAbsent: [ nil ]</body><body package="ActiveX-Container">basicPropertyNotifySink		^ self sinks at: #NotifySink ifAbsent: [ nil ]</body><body package="ActiveX-Container"> basicViewObjectAdviseSink		^ self sinks at: #ViewObjectAdviseSink ifAbsent: [ nil ]</body><body package="ActiveX-Container">eventSink		^ self sinks at: #EventSink ifAbsentPut: [ self computeEventSink ]</body><body package="ActiveX-Container">oleObjectAdviseSink		^ self sinks at: #OleObjectAdviseSink ifAbsentPut: [ self computeOleObjectAdviseSink ]</body><body package="ActiveX-Container">propertyNotifySink		^ self sinks at: #NotifySink ifAbsentPut: [ self computePropertyNotifySink ]</body><body package="ActiveX-Container">viewObjectAdviseSink		^ self sinks at: #ViewObjectAdviseSink ifAbsentPut: [ self computeViewObjectAdviseSink ]</body></methods><methods><class-id>External.ControlEventManager</class-id> <category>initialize-release</category><body package="ActiveX-Container">initialize	sinks := Dictionary new.	^ super initialize</body><body package="ActiveX-Container">releaseSinks	sinks do: [:each | each ifNotNil: [each disconnect]].	sinks := Dictionary new</body><body package="ActiveX-Container">removeNotifications	(control isNil or: [ control isInDesignMode ]) ifTrue: [^ self].	self basicViewObjectAdviseSink ifNotNil: [:sink | 		sink removeAllActionsWithReceiver: control. ].	self basicPropertyNotifySink ifNotNil: [:sink |		sink removeAllActionsWithReceiver: control ].	self basicOleObjectAdviseSink ifNotNil: [:sink |		sink removeAllActionsWithReceiver: control ].	self basicEventSink ifNotNil: [:sink |		sink removeAllActionsWithReceiver: control ].	self releaseSinks.</body></methods><methods><class-id>External.ControlEventManager</class-id> <category>accessing</category><body package="ActiveX-Container">control	^control</body><body package="ActiveX-Container">control: anObject	control ifNotNil: [ self removeNotifications ].	control := anObject.	control ifNotNil: [ self configureNotifications ].</body><body package="ActiveX-Container">sinks	^sinks</body><body package="ActiveX-Container">sinks: anObject	sinks := anObject</body></methods><methods><class-id>External.ControlEventManager</class-id> <category>private</category><body package="ActiveX-Container">configureNotifications	(control isNil or: [ control isInDesignMode ]) ifTrue: [^ self].	control miscStatus invisibleAtRuntime ifFalse: [ 		self viewObjectAdviseSink ifNotNil: [:sink |			sink when: #OnViewChange send: #viewObjectViewChanged:with: to: control. ]].	self propertyNotifySink ifNotNil: [:sink |		sink 			when: #OnChanged send: #propertyChangedID: to: control;			when: #OnRequestEdit send: #propertyEditRequested: to: control ].	self oleObjectAdviseSink ifNotNil: [:sink |		sink 			when: #OnClose send: #oleObjectClosed to: control;			when: #OnRename send: #oleObjectRenamed: to: control;			when: #OnSave send: #oleObjectSaved to: control;			when: #OnDataChange send: #oleObjectDataChanged:_: to: control ].	self eventSink ifNotNil: [:sink |		sink when: #eventNotification:arguments: send: #eventNotification:arguments: to: control ].</body></methods><methods><class-id>External.ControlEventManager</class-id> <category>events</category><body package="ActiveX-Container">pause	control ifNotNil: [ self removeNotifications ]</body><body package="ActiveX-Container">reactivate		control ifNotNil: [self configureNotifications]</body></methods><methods><class-id>External.ControlEventManager</class-id> <category>private computing</category><body package="ActiveX-Container">computeEventSink	| specTable sink |	^ control iDispatch ifNotNil: [ 		specTable := control eventSpecificationTable.		specTable isEmpty ifTrue: [^ nil ].		sink := COMEventSink iid: specTable iid specificationTable: specTable.		[sink establishConnectionTo: control iDispatch ] on: Error do: [:ex | sink := nil. ex return ].		^ sink ]</body><body package="ActiveX-Container">computeOleObjectAdviseSink	| sink |	sink := AdviseSink new.	sink establishConnectionTo: control iOleObject.	^sink</body><body package="ActiveX-Container">computePropertyNotifySink	| sink |	^control iDispatch		ifNotNil: 			[:dispatch |			sink := GenericCOMEventSink iid: IID_IPropertyNotifySink.			(sink establishConnectionTo: dispatch)				ifTrue: [sink]				ifFalse: 					[sink forceRelease.					sink := nil]]</body><body package="ActiveX-Container">computeViewObjectAdviseSink	| sink |	^control iViewObject2		ifNotNil: 			[sink := AdviseSink new.			sink establishConnectionTo: control iViewObject2.			sink]</body></methods><methods><class-id>External.ControlEventManager class</class-id> <category>instance creation</category><body package="ActiveX-Container">new	^ super new initialize</body></methods><methods><class-id>External.OLE_COLOR</class-id> <category>accessing</category><body package="ActiveX-Container">colorNameAt: translatedValue ifAbsent: aBlock	^ self class sysColorDict at: translatedValue ifAbsent: aBlock</body><body package="ActiveX-Container">stringRepresentation	^ self colorNameAt: self value ifAbsent: [ self value printStringRadix: 16 ].</body><body package="ActiveX-Container">sysColorValue	^ OLEAutomationDLL current oleTranslateColor: self value</body><body package="ActiveX-Container">value	^value</body><body package="ActiveX-Container">value: anObject	value := self maskValue: anObject</body></methods><methods><class-id>External.OLE_COLOR</class-id> <category>private</category><body package="ActiveX-Container">maskValue: aValue	"If the value is negative (the type definition seems to vary) convert it to a positive number"	^ CIntegerType int cast: aValue</body></methods><methods><class-id>External.OLE_COLOR class</class-id> <category>private constants</category><body package="ActiveX-Container">initSysColorDict 	^ SysColorDict := Dictionary new		at: (-2147483648 bitOr: COLOR_3DDKSHADOW) put: (#DarkShadowColor &lt;&lt; #com &gt;&gt; '3D Dark Shadow');		at: (-2147483648 bitOr: COLOR_3DLIGHT) put: (#LightColor &lt;&lt; #com &gt;&gt; '3D Light');		at: (-2147483648 bitOr: COLOR_ACTIVEBORDER) put: (#ActiveBorderColor &lt;&lt; #com &gt;&gt; 'Active Border Color');		at: (-2147483648 bitOr: COLOR_ACTIVECAPTION) put: (#ActiveCaptionColor &lt;&lt; #com &gt;&gt; 'Active Caption Color');		at: (-2147483648 bitOr: COLOR_APPWORKSPACE) put: (#AppWorkspaceColor &lt;&lt; #com &gt;&gt; 'Application Workspace Color');		at: (-2147483648 bitOr: COLOR_BACKGROUND) put: (#BackgroundColor &lt;&lt; #com &gt;&gt; 'Background Color');		at: (-2147483648 bitOr: COLOR_BTNFACE) put: (#ButtonfaceColor &lt;&lt; #com &gt;&gt; 'Buttonface Color');		at: (-2147483648 bitOr: COLOR_BTNHIGHLIGHT) put: (#ButtonHilightColor &lt;&lt; #com &gt;&gt; 'Button Hilight Color');		at: (-2147483648 bitOr: COLOR_BTNSHADOW) put: (#ButtonShadowColor &lt;&lt; #com &gt;&gt; 'Button Shadow Color');		at: (-2147483648 bitOr: COLOR_BTNTEXT) put: (#ButtonTextColor &lt;&lt; #com &gt;&gt; 'Button Text Color');		at: (-2147483648 bitOr: COLOR_CAPTIONTEXT) put: (#CaptionColor &lt;&lt; #com &gt;&gt; 'Caption Color');		at: (-2147483648 bitOr: COLOR_GRAYTEXT) put: (#GrayTextColor &lt;&lt; #com &gt;&gt; 'Gray Text Color');		at: (-2147483648 bitOr: COLOR_HIGHLIGHT) put: (#HilightColor &lt;&lt; #com &gt;&gt; 'Hilight Color');		at: (-2147483648 bitOr: COLOR_HIGHLIGHTTEXT) put: (#HilightTextColor &lt;&lt; #com &gt;&gt; 'Hilight Text Color');		at: (-2147483648 bitOr: COLOR_INACTIVEBORDER) put: (#InactiveBorderColor &lt;&lt; #com &gt;&gt; 'Inactive Border Color');		at: (-2147483648 bitOr: COLOR_INACTIVECAPTION) put: (#InactiveCaptionColor &lt;&lt; #com &gt;&gt; 'Inactive Caption Color');		at: (-2147483648 bitOr: COLOR_INACTIVECAPTIONTEXT) put: (#InactiveCaptionTextColor &lt;&lt; #com &gt;&gt; 'Inactive Caption Text Color');		at: (-2147483648 bitOr: COLOR_INFOBK)  put: (#InfoBKColor &lt;&lt; #com &gt;&gt; 'Info Background Color');		at: (-2147483648 bitOr: COLOR_INFOTEXT) put: (#InfoTextColor &lt;&lt; #com &gt;&gt; 'Info Text Color');		at: (-2147483648 bitOr: COLOR_MENU) put: (#MenuColor &lt;&lt; #com &gt;&gt; 'Menu Color');		at: (-2147483648 bitOr: COLOR_MENUTEXT) put: (#MenuTextColor &lt;&lt; #com &gt;&gt; 'Menu Text Color');		at: (-2147483648 bitOr: COLOR_SCROLLBAR) put: (#ScrollbarColor &lt;&lt; #com &gt;&gt; 'Scrollbar Color');		at: (-2147483648 bitOr: COLOR_WINDOW) put: (#WindowColor &lt;&lt; #com &gt;&gt; 'Window Color');		at: (-2147483648 bitOr: COLOR_WINDOWFRAME) put: (#WindowFrameColor &lt;&lt; #com &gt;&gt; 'Window Frame Color');		at: (-2147483648 bitOr: COLOR_WINDOWTEXT) put: (#WindowTextColor &lt;&lt; #com &gt;&gt; 'Window Text Color');		at: 0 put: (#Black &lt;&lt; #com &gt;&gt; 'Black');		at: -1 put: (#White &lt;&lt; #com &gt;&gt; 'White');		yourself</body><body package="ActiveX-Container">sysColorDict 	^ SysColorDict ifNil: [ self initSysColorDict ]</body></methods><methods><class-id>External.OLE_COLOR class</class-id> <category>instance creation</category><body package="ActiveX-Container">forSystemColor: aValue	^ self new		value: (aValue bitOr: 16r80000000);		yourself</body><body package="ActiveX-Container">fromString: aString		^self		withValue:			(self				oleSysColorValueNamed: aString				ifAbsent:					[self oleColorValueForRGB: (Integer readFromString: '16r' , aString)])</body><body package="ActiveX-Container">withValue: aValue	^ self new		value: aValue;		yourself</body></methods><methods><class-id>External.OLE_COLOR class</class-id> <category>private</category><body package="ActiveX-Container">oleColorValueForRGB: aValue	| b tempValue g r |	b := aValue bitAnd: 255.	tempValue := aValue bitShift: -8.	g := aValue bitAnd: 255.	tempValue := aValue bitShift: -8.	r := aValue bitAnd: 255.	tempValue := aValue bitShift: -8.	Tools.Assert isTrue: [ tempValue = 0 ].	^ (b bitShift: 16) +  (g bitShift: 8) + r</body><body package="ActiveX-Container">oleSysColorValueNamed: aString ifAbsent: aBlock		| tempString |	tempString := aString asString.	^ (self sysColorDict associations 		detect: [:each | each value asString = tempString ]		ifNone: [ ^ aBlock value ]) key</body></methods><methods><class-id>External.OLE_COLOR class</class-id> <category>accessing</category><body package="ActiveX-Container">guid	"The guid that identifies OLE_COLOR Type"	^ GUID fromString: '{66504301-BE0F-101A-8BBB-00AA00300CAB}'</body><body package="ActiveX-Container">predefinedValues		^self sysColorDict keys asArray</body></methods><methods><class-id>External.IOleControl</class-id> <category>IOleControl protocol</category><body package="ActiveX-Container">getControlInfo		| lpControlInfo |	lpControlInfo := COMExternalInterface current CONTROLINFO gcCalloc.	lpControlInfo		memberAt: #cb		put: lpControlInfo type referentType sizeof.	[ self getControlInfo: lpControlInfo ] on: COMError do: [:ex | ^ nil ].	^lpControlInfo</body></methods><methods><class-id>External.ITypeInfo</class-id> <category>enumerating</category><body package="ActiveX-Container">implementedDispatchInterfacesDo: aBlock	self dispatchInterfacesDo: [:each :flags | 		(each isImplementedItf: flags) ifTrue: [ aBlock value: each value: flags]].</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>private</category><body package="ActiveX-Container">computeControlMap        " Answer a dictionary describing all the registered OLE objects which can be inserted into a container, with the class name as the key and the string representation of the CLSID as the value. "	" COMRegistryInterface controlMap "    | ctrlMap clsidSection clsidEntries clsidEntryNames added progId |    ctrlMap := Dictionary new.    (HostInterface isWindows or: [ HostInterface isWindowsNT ]) ifFalse: [ ^  ctrlMap ].    clsidSection := self classesRegistry at: 'CLSID'.    clsidSection keys do: [:key |	  added := false.        clsidEntries := clsidSection at: key.        clsidEntryNames := clsidEntries keys.        ( clsidEntryNames includes: 'Control' )                    ifTrue: [ 				clsidEntries value ifNotNil: [:aName |				(clsidEntries includesKey: 'VersionIndependentProgID' ) ifTrue: 	[ 						ctrlMap at: aName put:  (clsidEntries at: 'VersionIndependentProgID') value. 						added := true.].				(clsidEntries includesKey: 'ProgId' ) ifTrue: 	[ | tokens versionedName|						progId := (clsidEntries at: 'ProgId') value. 						tokens := progId tokensBasedOn: $. .						versionedName := aName, ' V', (tokens size = 3 ifTrue: [ tokens last ] ifFalse: ['?']).						ctrlMap at: versionedName put: progId.						added := true.]].				added  ifFalse:	[ ctrlMap at: key put: key].        ]].    ^ctrlMap</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>accessing</category><body package="ActiveX-Container">controlMap        " Answer a dictionary describing all the registered OLE objects which can be inserted into a container, with the class name as the key and the string representation of the CLSID as the value. "	" COMRegistryInterface controlMap "    ^ ControlMap ifNil: [ ControlMap := self computeControlMap ]</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>updating</category><body package="ActiveX-Container">flushControlMap	ControlMap := nil.</body><body package="ActiveX-Container">update: anAspect with: aParameter from: anObject		(anObject = ObjectMemory and: [anAspect = #returnFromSnapshot]) ifFalse: [^self].	self flushExternalLibraryCache.	self flushControlMap</body></methods><methods><class-id>External.AdviseSink</class-id> <category>releasing</category><body package="ActiveX-Container">disconnect	^ self releaseConnection</body></methods><methods><class-id>External.IOleInPlaceObject</class-id> <category>IOleInPlaceObject protocol</category><body package="ActiveX-Container">uiDeactivate: proxy		proxy isInPlaceActive		ifFalse:			[COMDevelopmentWarning				raiseSignal:					#CantDeactivate &lt;&lt; #com &gt;&gt; 'Can not deactivate an inactive control'.			^proxy].	^self uIDeactivate</body></methods><methods><class-id>External.COMCompoundFile</class-id> <category>printing</category><body package="ActiveX-Container">printOn: aStream	^ aStream nextPutAll: 'a', self class name</body></methods><methods><class-id>External.IOleObject</class-id> <category>IOleObject protocol</category><body package="ActiveX-Container">getExtentFor: proxy		| psizel |	psizel := (0 @ 0) asTemporaryCStructure.	self		getExtent: proxy defaultDrawAspect		with: psizel.	^Point fromCSIZEStructure: psizel</body><body package="ActiveX-Container">getExtentInCFormatFor: proxy	| psizel |	psizel := (0 @ 0) asTemporaryCStructure.	[self getExtent: proxy defaultDrawAspect with: psizel] on: COMError		do: [:ex | ^nil].	^psizel</body><body package="ActiveX-Container">getMiscStatusObjectFor: aProxy		^OLEMiscStatus		withValue: (self getMiscStatus: DVASPECT_CONTENT)</body></methods><initialize><class-id>External.MultipleInterfaceDispatchObject</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>IOleInPlaceObject</name><environment>External</environment><super>External.IOleWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>ActiveX-Interfaces</package></attributes></class><class><name>COMObject</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controllingUnknown innerUnknown referenceCount </inst-vars><class-inst-vars>clsid </class-inst-vars><imports>			External.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>ValueModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>COMDispatchObject</name><environment>External</environment><super>External.COMAutomationObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>publishedObject registrationToken </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-COM Objects</category><attributes><package>Com- Automation</package></attributes></class><class><name>AdviseSink</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token iAdviseSink source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole</package></attributes></class><class><name>IOleControl</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>ActiveX-Interfaces</package></attributes></class><class><name>IOleObject</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.COMConstants.*			External.GUID.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>ActiveX-Interfaces</package></attributes></class><class><name>COMCompoundFile</name><environment>External</environment><super>External.IStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Storage Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>ITypeInfo</name><environment>External</environment><super>External.COMTypeLibraryInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMAutomationConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Automation-Interfaces</category><attributes><package>Com- Automation</package></attributes></class></st-source>