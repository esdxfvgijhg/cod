<?xml version="1.0"?><st-source><!-- Name: Com- CodeAnnotationsNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Classes which are useful for developers to annotate code with development notes and support correctness assertion checking.DbIdentifier: bear73DbTrace: 464068DbUsername: aaugustinDbVersion: 8.0 - 3DialectVersion: VisualWorks 7.9PackageName: Com- CodeAnnotationsParcel: #('ComCodeAnnotations')ParcelName: Com- CodeAnnotationsPrintStringCache: (8.0 - 3,aaugustin)Version: 8.0 - 3Date: 1:50:01 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:01</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Assert</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Code Annotations</category><attributes><package>Com- CodeAnnotations</package></attributes></class><comment><class-id>Tools.Assert</class-id><body>The Assert class is used to annotate client code with correctness assertions about the state of the system.  It is primarily intended for use during development; assertions should generally be turned off in a deployed application.Assertions are proceedable warnings.  Their primary purpose, in addition to the value they add as a means of expressing the programmer's intent in the program text, is to provide an explicit warning during development when the computation is in an unexpected state.  This is often of value as an early warning mechanism for program defects, which otherwise may not be surfaced until some subsequent point in the compuatation when the actual cause is more obscure.Assertions can be written in the form of expressions such as:	Assert isTrue: [ "a boolean expression of a condition which is expected to be satisified" ].	Assert isFalse: [ "a boolean expression of a condition which should be false" ].	Assert isNil: &lt;aValue&gt;.Blocks are generally wrapped around the assertion expression to avoid the cost of evaluation when assertion checking is disabled.  However, any expression which supports the #value message can also be used.To enable assertion checking, evaluate the expression:	Assert evaluateAssertions: true.To disable assertion checking, evaluate the expression:	Assert evaluateAssertions: false. </body></comment><class><name>Note</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Code Annotations</category><attributes><package>Com- CodeAnnotations</package></attributes></class><comment><class-id>Tools.Note</class-id><body>The Note class provides messages for annoting code to identify various points of interest.  It is primarily intended for use during development.Notes are used over the course of development to mark methods which need further attention, such as to resolve some implementation or philosphical issue or to complete a partial implementation of some facility.  The standard message-send cross referencing facilities of the development environment can be used to locate development notes.  Development notes should generally be resolved and removed as an application stabilizes.</body></comment><shared-variable><name>EvaluateAssertions</name><environment>Tools.Assert</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- CodeAnnotations</package></attributes></shared-variable><methods><class-id>Tools.Assert class</class-id> <category>private-assertions</category><body package="Com- CodeAnnotations">reportAssertionFailureIn: aContext reason: aString	" Private - report the failure of a correctness assertion during the execution of &lt;aContext&gt;. "	| failureMessage |	failureMessage := (#NamedAssertFail &lt;&lt; #com &gt;&gt; 'Correctness assertion failed (&lt;1s&gt;)' expandMacrosWith: aString) asString.	" We might at some point want to consider whether to support logging as well as notification. "	"	aContext == nil		ifTrue:			[OutputStreamProtect				critical: [self outputStream nextPutAll: failureReason, '.'; cr; flush]]		ifFalse:			[OutputStreamProtect critical: [				self outputStream					nextPutAll: failureMessage, ' in ';					nextPutAll: aContext mclass name;					nextPutAll: '&gt;&gt;';					nextPutAll: aContext selector; cr;					flush]].	"	self signalAssertionFailureIn: aContext description: failureMessage.</body><body package="Com- CodeAnnotations">signalAssertionFailureIn: aContext description: descriptionString	" Private - create a resumable walkback window warning that a correctness assertion failed. "	"Old: self assertFailedSignal raiseRequest."	"X3J20 style: AssertionFailureWarning signal: descriptionString "	Object haltSignal		raiseRequestWith: aContext		errorString: descriptionString.</body></methods><methods><class-id>Tools.Assert class</class-id> <category>configuring</category><body package="Com- CodeAnnotations">evaluateAssertions	" Answer whether assertion conditions are currently being evaluated. "	^EvaluateAssertions</body><body package="Com- CodeAnnotations">evaluateAssertions: aBoolean	" Specify whether assertion conditions should be evaluated. "	" Assert evaluateAssertions: true "	" Assert evaluateAssertions: false "	EvaluateAssertions := aBoolean.</body></methods><methods><class-id>Tools.Assert class</class-id> <category>private-initialization</category><body package="Com- CodeAnnotations">initialize	" Initialize the class state. "	self evaluateAssertions: false.  "Alt: self isDevelopmentSession"</body></methods><methods><class-id>Tools.Assert class</class-id> <category>assertions</category><body package="Com- CodeAnnotations">isEqual: aValue to: anotherValue	" Determine whether the condition that &lt;aValue&gt; is equal to &lt;anotherValue&gt; which is asserted to be the case is in fact true.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	" unlike other assertions, halt in this method rather than the caller to enable inspection of the values. "	aValue = anotherValue		ifFalse: [ self reportAssertionFailureIn: thisContext "sender" reason: #NotEqual &lt;&lt; #com &gt;&gt; 'not equal'  ].</body><body package="Com- CodeAnnotations">isFalse: aBooleanAction	" Determine whether some condition which is asserted to not be the case is in fact false.  The condition can be expressed as a Boolean value or as an evaluable action such as a block which evaluates to a Boolean.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	aBooleanAction value not		ifFalse: [ self reportAssertionFailureIn: thisContext sender reason: #NotFalse &lt;&lt; #com &gt;&gt; 'condition not false' ]."Footnote: A more aggressive implementation of the preceding could wrapped with something like:	( Signal noHandlerSignal		handle: [ :ex | ex returnWith: false ]		do: [ aBooleanAction value not ] )			ifTrue: [ ^true ]."</body><body package="Com- CodeAnnotations">isNil: aValue	" Verify whether the assertion that &lt;aValue&gt; is nil is in fact true.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	aValue == nil		ifFalse: [ self reportAssertionFailureIn: thisContext sender reason: #ShouldBeNil &lt;&lt; #com &gt;&gt;'value should have been nil' ].</body><body package="Com- CodeAnnotations">isTrue: aBooleanAction	" Determine whether some condition which is asserted to be the case is in fact true.  The condition can be expressed as a Boolean value or as an evaluable action such as a block which evaluates to a Boolean.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	aBooleanAction value		ifFalse: [ self reportAssertionFailureIn: thisContext sender reason: #NotTrue &lt;&lt; #com &gt;&gt; 'condition not true' ]."Footnote: A more aggressive implementation of the preceding could wrapped with something like:	( Signal noHandlerSignal		handle: [ :ex | ex returnWith: false ]		do: [ aBooleanAction value ] )			ifTrue: [ ^true ]."</body><body package="Com- CodeAnnotations">isValid: aValue	" Verify whether the assertion that &lt;aValue&gt; is valid is in fact true.  The value must respond to the #isValid predicate.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	aValue isValid		ifFalse: [ self reportAssertionFailureIn: thisContext sender reason: #NotValid &lt;&lt; #com &gt;&gt; 'value not valid' ]."Footnote: A more aggressive implementation of the preceding could wrapped with something like:	( Signal noHandlerSignal		handle: [ :ex | ex returnWith: false ]		do: [ aValue isValid ] )		ifTrue: [ ^true ]."</body><body package="Com- CodeAnnotations">isZero: aValue	" Verify whether the assertion that &lt;aValue&gt; is zero is in fact true.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	aValue = 0		ifFalse: [ self reportAssertionFailureIn: thisContext sender reason: #ShouldBeZero &lt;&lt; #com &gt;&gt; 'value should have been 0' ].</body><body package="Com- CodeAnnotations">notEqual: aValue to: anotherValue	" Determine whether the condition that &lt;aValue&gt; is not equal to &lt;anotherValue&gt; which is asserted to be the case is in fact true.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	" unlike other assertions, halt in this method rather than the caller to enable inspection of the values. "	aValue ~= anotherValue		ifFalse: [ self reportAssertionFailureIn: thisContext "sender" reason: #IsEqual &lt;&lt; #com &gt;&gt; 'is equal' ].</body><body package="Com- CodeAnnotations">notNil: aValue	" Verify whether the assertion that &lt;aValue&gt; is not nil is in fact true.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	aValue ~~ nil		ifFalse: [ self reportAssertionFailureIn: thisContext sender reason: #ShouldNotBeNil &lt;&lt; #com &gt;&gt; 'value should not be nil' ].</body><body package="Com- CodeAnnotations">notValid: aValue	" Verify whether the assertion that &lt;aValue&gt; is not valid is in fact true.  The value must respond to the #isValid predicate.  If the assertion is incorrect, report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	aValue isValid not		ifFalse: [ self reportAssertionFailureIn: thisContext sender reason: #ShouldNotBeValid &lt;&lt; #com &gt;&gt; 'value should not be valid' ]."Footnote: A more aggressive implementation of the preceding could wrapped with something like:	( Signal noHandlerSignal		handle: [ :ex | ex returnWith: false ]		do: [ aValue isValid not ] )			ifTrue: [ ^true ]."</body><body package="Com- CodeAnnotations">shouldNotBe	" Something which should not be possible has occurred.  Report the failure of the expected condition. "	self evaluateAssertions ifFalse: [ ^self ].	self reportAssertionFailureIn: thisContext sender reason: #ShouldNotHappen  &lt;&lt; #com &gt;&gt;'this should not be happening' .</body></methods><methods><class-id>Tools.Assert class</class-id> <category>testing</category><body package="Com- CodeAnnotations">isDevelopmentSession	" Answer whether this is a development session. "	^( #{ImageConfiguration} 		valueOrDo: [ ^( Smalltalk includesKey: #Debugger ) ] ) 			isDevelopment</body></methods><methods><class-id>Tools.Note class</class-id> <category>porting notes</category><body package="Com- CodeAnnotations">notYetPorted	" Mark a porting problem which requires an alternate implementation or some provision for compatibility support.  These are generally going to break, unless specifically disabled. "	Assert shouldNotBe.  " We shouldn't be at this point. "</body><body package="Com- CodeAnnotations">portingPatch	" Mark a temporary implementation which has been patched in while porting code between various platforms. "</body></methods><methods><class-id>Tools.Note class</class-id> <category>development notes</category><body package="Com- CodeAnnotations">ISSUE	" Mark a method which needs to be reviewed and possibly corrected to resolve a design or implementation issue.  Typically followed by a comment describing the issue. "</body><body package="Com- CodeAnnotations">ISSUEin72	" Mark a method which needs to be reviewed and possibly corrected to resolve a design or implementation issue.  Typically followed by a comment describing the issue. 	Alex: I used this mark to mark issues I found in COM 7.2"</body><body package="Com- CodeAnnotations">OBSOLETE		" Temporary development marker for methods which are about to be deleted but which we want to keep around briefly to help track down clients. "	"DEBUG" Screen default ringBell.	Assert shouldNotBe.  " there should no longer be any senders of this "</body><body package="Com- CodeAnnotations">experimental	" Mark a method which is an experiment and likely to change or go away again. "</body><body package="Com- CodeAnnotations">incomplete: aString	"The code is incomplete. The reason passed as a String"	self halt: (#IncompleteCode1s &lt;&lt; #com &gt;&gt; 'Code is incomplete: 1s' expandMacrosWith: aString).</body><body package="Com- CodeAnnotations">needsWork	" Mark a method which is only partially implemented or which needs other work before it is considered complete. "</body><body package="Com- CodeAnnotations">noLongerSupported	" Mark a method which is no longer supported and should no longer be in use. "	Assert shouldNotBe.</body><body package="Com- CodeAnnotations">notYetImplemented	" Mark a method which is not yet fully implemented. "	self error: #ErrNotImplemented &lt;&lt; #com &gt;&gt; 'not yet implemented'</body><body package="Com- CodeAnnotations">notYetSupported	" Mark a feature which is not yet supported on VW.  These should generally be disabled. "	"Assert isTrue: false."</body><body package="Com- CodeAnnotations">notYetTested	" Mark a method which is not yet tested. "</body><body package="Com- CodeAnnotations">pleaseReview: aBlock	"The code is incomplete. The reason passed as a String"	COMDevelopmentWarning raiseSignal: #PleaseReviewThisCodeBeforeRunning &lt;&lt; #com &gt;&gt; 'The following code should be reviewed before running'.	^ aBlock value.</body><body package="Com- CodeAnnotations">portingISSUE	" Mark a method which needs to be reviewed and possibly corrected to resolve a design or implementation issue.  Typically followed by a comment describing the issue. "</body><body package="Com- CodeAnnotations">probablyOBSOLETE		" Temporary development marker for methods which are about to be deleted but which we want to keep around briefly to help track down clients. "	"DEBUG" Screen default ringBell.	Assert shouldNotBe.  " there should probably no longer be any senders of this "</body><body package="Com- CodeAnnotations">temporarilyDisabled	" Mark something which is turned off temporarily. "</body><body package="Com- CodeAnnotations">testingISSUE	"1.1e testing problem mark"</body><body package="Com- CodeAnnotations">testingISSUE: aBlock restoreLater: originalBlock	"1.1e testing problem mark - change the sender back to the original code"	^ aBlock value</body></methods><methods><class-id>Tools.Note class</class-id> <category>implementation notes</category><body package="Com- CodeAnnotations">platformDependent	" Mark a method which is whose implementation is dependent on the host platform. "</body><body package="Com- CodeAnnotations">smalltalkDependent	" Mark a method which is whose implementation is dependent on the Smalltalk system. "</body></methods><methods><class-id>Tools.Note class</class-id> <category>instance creation</category><body package="Com- CodeAnnotations">new	"Instances of the receiver should not be created."	^self shouldNotImplement</body></methods><methods><class-id>Tools.Note class</class-id> <category>debugging</category><body package="Com- CodeAnnotations">bell	" Beeps are handy for debugging. "	Screen default ringBell.</body></methods><methods><class-id>Tools.Note class</class-id> <category>compatibility notes</category><body package="Com- CodeAnnotations">obsoleteMethod	" Mark a method which is obsolete.  Clients of an obsolete method should be converted to an appropriate alternative.  Obsolete methods are provided for backward compatibility and are typically phased out in the subsequent product release. "</body></methods><initialize><class-id>Tools.Assert</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>