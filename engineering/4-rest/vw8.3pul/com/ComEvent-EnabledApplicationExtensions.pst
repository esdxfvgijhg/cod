<?xml version="1.0"?><st-source><!-- Name: Com- Event-Enabled Application ExtensionsNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.DbIdentifier: bear73DbTrace: 428082DbUsername: aaugustinDbVersion: 8.0 - 2DialectVersion: VisualWorks 7.9PackageName: Com- Event-Enabled Application ExtensionsParcel: #('ComEvent-EnabledApplicationExtensions')ParcelName: Com- Event-Enabled Application ExtensionsPrintStringCache: (8.0 - 2,aaugustin)Version: 8.0 - 2Date: 1:50:01 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:01</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>EventEnabledValueHolder</name><environment>UI</environment><super>UI.ValueHolder</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><comment><class-id>UI.EventEnabledValueHolder</class-id><body>EventEnabledValueHolder is a very simple Model, no more than a value holder with updates.  The #changed: event is triggered whenever the value is changed using the #value: message.  The #valueChanged: event is triggered when the value is changed using the #value: message and the new value is different than the original value.Instance variables:	eventTable	&lt;Dictionary&gt; The event table which maps event names to actions.</body></comment><class><name>EventEnabledAppWindowStandardSystemController</name><environment>UI</environment><super>UI.ApplicationStandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><comment><class-id>UI.EventEnabledAppWindowStandardSystemController</class-id><body>An EventEnabledAppWindowStandardController is the standard controller for an event-enabled application window.</body></comment><class><name>EventEnabledApplicationModel</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><comment><class-id>UI.EventEnabledApplicationModel</class-id><body>EventEnabledApplicationModel provides some extensions to the basic ApplicationModel application framework to support an event-enabled application which has two-way event coupling between visual components in a view and the non-visual components of the application and its various domain models.  Other utility services are included as deemed convenient by the users of this framework.</body></comment><class><name>EventEnabledApplicationWindow</name><environment>UI</environment><super>UI.ScheduledWindow</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><comment><class-id>UI.EventEnabledApplicationWindow</class-id><body>An event-enabled application window is a top-level window which has been enhanced to trigger events reflecting the window's life cycle and to enable arbitrary properties to be attached to the main window of a view.</body></comment><class><name>EventEnabledSimpleView</name><environment>UI</environment><super>UI.SimpleView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><comment><class-id>UI.EventEnabledSimpleView</class-id><body>An event-enabled view is a SimpleView which has been enhanced to manage an event table to support triggering events and to enable arbitrary properties to be attached to the view.</body></comment><methods><class-id>UI.EventEnabledValueHolder</class-id> <category>accessing</category><body package="Com- Event-Enabled Application Extensions">value: newValue	"Set the currently stored value, and notify dependents."	| valueChangedAction isValueChanged |	valueChangedAction := self actionForEvent: #valueChanged: .	valueChangedAction notNil		ifTrue: [ isValueChanged := ( value ~= newValue ) ].	super value: newValue.	self triggerEvent: #changed: with: newValue.	( valueChangedAction notNil and: [ isValueChanged ] )		ifTrue: [ valueChangedAction evaluateWithArguments: ( Array with: newValue ) ].</body></methods><methods><class-id>UI.EventEnabledValueHolder</class-id> <category>private-accessing</category><body package="Com- Event-Enabled Application Extensions">myEventTable	"Private - answer a Dictionary mapping event names to actions	for the receiver, or nil if there is none."	^eventTable</body><body package="Com- Event-Enabled Application Extensions">myEventTable: newTable	"Private"	eventTable := newTable.</body></methods><methods><class-id>UI.EventEnabledValueHolder class</class-id> <category>private-events</category><body package="Com- Event-Enabled Application Extensions">constructEventsTriggered        "Private - Construct the set of events triggered by instances        of the receiver."	^super constructEventsTriggered asOrderedCollection		add: #changed: ;		add: #valueChanged: ;       	yourself</body></methods><methods><class-id>UI.EventEnabledAppWindowStandardSystemController</class-id> <category>private</category><body package="Com- Event-Enabled Application Extensions">requestForWindowClose	"Ask the receiver's application if it is ok to close the window"	^( self view hasActionForEvent: #confirmClose )		ifTrue: [ self view isOkToClose ]		ifFalse: [ super requestForWindowClose ]</body></methods><methods><class-id>UI.EventEnabledApplicationModel</class-id> <category>subclass-view creation</category><body package="Com- Event-Enabled Application Extensions">connectComponents	" The builder has completed construction of the view.  Establish the event-based connections between the visual and non-visual components of the application. "	self registerEventHandlers: #eventHandlersSpec.</body><body package="Com- Event-Enabled Application Extensions">postBuildWith: aBuilder	" The builder has completed work on the window. "	super postBuildWith: aBuilder.	self connectComponents.	self applicationWindow triggerEvent: #built.</body><body package="Com- Event-Enabled Application Extensions">registerEventHandlers: eventSpecSymbol	" Register all event handlers specified by the event handlers spec."	| eventSource eventHandlerSpecs |	( self class respondsTo: eventSpecSymbol ) 		ifFalse: [ ^self ].	( self class perform: eventSpecSymbol ) do: [ :entry |		eventSource := self componentNamed: ( entry at: 1 ).		eventHandlerSpecs := entry copyFrom: 2 to: entry size.		self registerEventHandlers: eventHandlerSpecs on: eventSource ].</body><body package="Com- Event-Enabled Application Extensions">registerEventHandlers: eventHandlerSpecs on: anEventGenerator 	" Register the event handlers defined in &lt;eventHandlerSpecs&gt; on &lt;anEventGenerator&gt;. "	| eventName selector receiver argumentValues argumentType argumentValueSpec |	eventHandlerSpecs do: 			[:eventHandlerSpec | 			eventName := eventHandlerSpec at: 1.			selector := eventHandlerSpec at: 2.			receiver := eventHandlerSpec size = 2 						ifTrue: [self]						ifFalse: [self componentNamed: (eventHandlerSpec at: 3)].			eventHandlerSpec size &lt; 4 				ifTrue: 					[" #( &lt;eventName&gt; &lt;selector&gt; [&lt;receiverName&gt;] ) "					anEventGenerator 						when: eventName						send: selector						to: receiver]				ifFalse: 					[" optional argument specifications "					argumentValues := OrderedCollection new.					4 to: eventHandlerSpec size						do: 							[:i | 							| anArgumentSpec |							anArgumentSpec := eventHandlerSpec at: i.							argumentType := anArgumentSpec at: 1.							argumentValueSpec := anArgumentSpec at: 2.							argumentValues add: (argumentType = #literal: 										ifTrue: [argumentValueSpec]										ifFalse: 											[argumentType = #componentNamed: 												ifTrue: [self componentNamed: argumentValueSpec]												ifFalse: [self error: #ErrUndefinedArgType &lt;&lt; #com &gt;&gt; 'undefined argument type']])].					anEventGenerator 						when: eventName						send: selector						to: receiver						withArguments: argumentValues asArray]]</body></methods><methods><class-id>UI.EventEnabledApplicationModel</class-id> <category>subclass-menu operations</category><body package="Com- Event-Enabled Application Extensions">disableMenu: aMenu	" Disable all items in &lt;aMenu&gt;. "	"aMenu disableAll."	aMenu menuItems do: [ :aMenuItem | aMenuItem disable ].</body><body package="Com- Event-Enabled Application Extensions">disableMenuItems: itemList in: aMenu	" Disable the specified items in &lt;aMenu&gt;. "	itemList do: [ :aMenuValue | 		( aMenu menuItemWithValue: aMenuValue ) disable ].</body><body package="Com- Event-Enabled Application Extensions">enableMenu: aMenu	" Enable all items in &lt;aMenu&gt;. "	"aMenu enableAll."	aMenu menuItems do: [ :aMenuItem | aMenuItem enable ].</body><body package="Com- Event-Enabled Application Extensions">enableMenuItems: itemList in: aMenu	" Enable the specified items in &lt;aMenu&gt;. "	itemList do: [ :aMenuValue | 		( aMenu menuItemWithValue: aMenuValue ) enable ].</body><body package="Com- Event-Enabled Application Extensions">menuBarComponent	" Answer the menu bar in the receiver's view.  Answer nil if the window does not have a menu bar. "	^self builder menuAt: self menuBarName   "??alt?? self menuFor: self menuBarName ??"</body><body package="Com- Event-Enabled Application Extensions">menuBarName	" Answer the name of the menu bar component in the receiver's view.  Should be reimplemented by subclasses which use a different name to identify the menu bar. "	^#menuSpec</body><body package="Com- Event-Enabled Application Extensions">menuNamed: aSymbol	" Answer the menu identified by aSymbol in the menu bar of receiver's view.  Answer nil if not found. "	^(self menuBarComponent atNameKey: aSymbol) ifNotNil:[:menu| menu submenu]</body><body package="Com- Event-Enabled Application Extensions">setEnabledStateOfMenuItems: itemList in: aMenu to: enableFlag	" Enable or disable the menu items in &lt;itemList&gt; in &lt;aMenu&gt; based on whether &lt;enableFlag&gt; is true or false. "	enableFlag 		ifTrue: [ self enableMenuItems: itemList in: aMenu ]		ifFalse: [ self disableMenuItems: itemList in: aMenu ].</body></methods><methods><class-id>UI.EventEnabledApplicationModel</class-id> <category>accessing</category><body package="Com- Event-Enabled Application Extensions">applicationWindow	" Answer the application window containing the current view on the receiver. "	^self builder window</body><body package="Com- Event-Enabled Application Extensions">componentNamed: aComponentName	" Answer the component in the application named &lt;aComponentName&gt;.  A component can be the application itself, a visual component in the receiver's view, or a nonvisual component which is a named aspect of the application.  Component names #application and #applicationWindow are reserved for the application model itself and its current view. "	| aComponent |	"Note that the following convention is required because the VisualWorks 		Canvas does not allow a name to be assigned to the window itself. "	aComponentName = #applicationWindow		ifTrue: [ ^self applicationWindow ].	aComponentName = #application		ifTrue: [ ^self ].	" answer the visual widget or the nonvisual component (aspect) "	aComponent := self builder componentAt: aComponentName.	aComponent notNil		ifTrue: [ ^aComponent widget ].	^self builder aspectAt: aComponentName</body><body package="Com- Event-Enabled Application Extensions">defaultWindowClassOrNil	"Answer the class of default Window to use for displaying the receiver's canvases. If the system default should be used, answer nil."	^EventEnabledApplicationWindow</body></methods><methods><class-id>UI.EventEnabledApplicationModel</class-id> <category>private-accessing</category><body package="Com- Event-Enabled Application Extensions">myEventTable	"Private - answer a Dictionary mapping event names to actions	for the receiver, or nil if there is none."	^eventTable</body><body package="Com- Event-Enabled Application Extensions">myEventTable: newTable	"Private"	eventTable := newTable.</body></methods><methods><class-id>UI.EventEnabledApplicationModel</class-id> <category>subclass-button operations</category><body package="Com- Event-Enabled Application Extensions">disableComponentNamed: aComponentName	" Disable the application widget named &lt;aComponentName&gt;. "	( self builder componentAt: aComponentName ) disable.  " needs the wrapper, not the widget... "</body><body package="Com- Event-Enabled Application Extensions">enableComponentNamed: aComponentName	" Eable the application widget named &lt;aComponentName&gt;. "	( self builder componentAt: aComponentName ) enable.  " needs the wrapper, not the widget... "</body></methods><methods><class-id>UI.EventEnabledApplicationModel class</class-id> <category>interface specs</category><body package="Com- Event-Enabled Application Extensions">eventHandlersSpec	" Answer the specifications for connecting components of the application using events "	" This is an experimental prototype of an extended		event specification notation which allows specification of event links		triggered by nonvisual components (aspects) of the application		or for which argument values are constructed at		registration time.  It may at some point be superseded by		a more permanent form of an event callback specification literal. "	" The event handlers specification answer a list of linkage specifications.  Each event linkage specification consists of the triggering component name followed by an array of one or more event handler specs:	#( &lt;componentName&gt; #( &lt;eventHandlerSpec&gt;... ) )	An event handler spec specifies a triggering event and one or more handler specifications definining the message to send and the receiver, i.e., it parallells to #when:send:to: event configuration prototocol.  The receiver defaults to the application if not specified.  Reserved names #application and #applicationWindow denote the application model and the application window, respectively.  (Note that the latter convention is imposed due to the current inability to specify an ID name for an application window component in the Canvas.)  Optional argument values (for #with: arguments ) can be specified as either component names or literal values. 	An &lt;eventHandlerSpec&gt; is defined by one of the following:		#( &lt;eventName&gt; &lt;selector&gt; [&lt;receiverName&gt;] )		#( &lt;eventName&gt; &lt;selector&gt; &lt;receiverName&gt; &lt;argumentSpecification&gt;... )	where &lt;argumentSpecification&gt; is one of the following		#( #componentNamed: &lt;aComponentName&gt; )		#( #literal: &lt;aLiteralValue&gt; )	"	^#( )</body></methods><methods><class-id>UI.EventEnabledApplicationWindow</class-id> <category>converting</category><body package="Com- Event-Enabled Application Extensions">asHandleParameter	"Answer the receiver in a form suitable for passing as a host handle parameter to an external function call."	^self windowHandle</body></methods><methods><class-id>UI.EventEnabledApplicationWindow</class-id> <category>accessing</category><body package="Com- Event-Enabled Application Extensions">controller	"Answer the receiver's controller."	controller == nil		ifTrue: [ self controller: EventEnabledAppWindowStandardSystemController new ].	^controller</body></methods><methods><class-id>UI.EventEnabledApplicationWindow</class-id> <category>private-accessing</category><body package="Com- Event-Enabled Application Extensions">myEventTable	"Private - answer a Dictionary mapping event names to actions	for the receiver, or nil if there is none."	^eventTable</body><body package="Com- Event-Enabled Application Extensions">myEventTable: newTable	"Private"	eventTable := newTable.</body><body package="Com- Event-Enabled Application Extensions">properties	"Private - Answer the properties Dictionary."	^properties</body><body package="Com- Event-Enabled Application Extensions">properties: aDictionary	"Private - Set the properties Dictionary."	properties := aDictionary.</body></methods><methods><class-id>UI.EventEnabledApplicationWindow</class-id> <category>properties</category><body package="Com- Event-Enabled Application Extensions">propertyAt: key          "Answer the value associated with         key in the properties dictionary."    properties isNil ifTrue: [ ^nil ].    ^properties at: key ifAbsent: [ nil ]</body><body package="Com- Event-Enabled Application Extensions">propertyAt: key ifAbsent: aBlock        "Answer the value associated with key        in the properties dictionary; if absent,         answer the result of evaluating aBlock."    properties isNil ifTrue: [ ^aBlock value ].    ^properties at: key ifAbsent: aBlock</body><body package="Com- Event-Enabled Application Extensions">propertyAt: key ifAbsentPut: aBlock        "Answer the value associated with key        in the properties dictionary; if absent, evaluate		aBlock, put the evaluation result at key, and        answer the result."    properties isNil ifTrue: [ properties := IdentityDictionary new ].    ^properties at: key ifAbsent: [ properties at: key put: aBlock value ]</body><body package="Com- Event-Enabled Application Extensions">propertyAt: key put: aValue        "Set the value associated with key        in the properties dictionary."    properties isNil ifTrue: [ properties := IdentityDictionary new ].    aValue isNil ifTrue: [ ^properties removeKey: key ifAbsent: [ ] ].    ^properties at: key put: aValue</body></methods><methods><class-id>UI.EventEnabledApplicationWindow</class-id> <category>private-window operations</category><body package="Com- Event-Enabled Application Extensions">finishOpening	" Notify the receiver's application that it has been opened. "	super finishOpening.	self triggerEvent: #opened.</body><body package="Com- Event-Enabled Application Extensions">isOkToClose        "Private - answer whether it is OK to close.        Triggers the veto-able #confirmClose event."	| isOkToClose |	isOkToClose := true.	[ self triggerEvent: #confirmClose ]		on: VetoAction		do: [ :ex | isOkToClose := false. ex resume ].	^isOkToClose</body><body package="Com- Event-Enabled Application Extensions">noticeOfWindowClose	" Notify the receiver's application that the view is being closed. "	self triggerEvent: #aboutToClose		ifNotHandled: [ super noticeOfWindowClose ].</body><body package="Com- Event-Enabled Application Extensions">privateOpenForced: forcePosition	"Open the receiver with the host window system."	| result |	result := super privateOpenForced: forcePosition.	self triggerEvent: #opened.	^result</body></methods><methods><class-id>UI.EventEnabledApplicationWindow</class-id> <category>window operations</category><body package="Com- Event-Enabled Application Extensions">abortClose        "Veto the window close which is about to occur."	VetoAction raiseSignal.</body><body package="Com- Event-Enabled Application Extensions">close	"Close the receiver."	super close.	self triggerEvent: #closed.</body></methods><methods><class-id>UI.EventEnabledApplicationWindow</class-id> <category>testing</category><body package="Com- Event-Enabled Application Extensions">isValid	" Answer whether the receiver is a valid (open) window. "	^self windowHandle isInteger</body></methods><methods><class-id>UI.EventEnabledApplicationWindow</class-id> <category>private-window events</category><body package="Com- Event-Enabled Application Extensions">activateEvent: anActivateEvent 	^[super activateEvent: anActivateEvent] 		ensure: [self triggerEvent: #activated]</body><body package="Com- Event-Enabled Application Extensions">deactivateEvent: aDeactivateEvent 	^[super deactivateEvent: aDeactivateEvent] 		ensure: [self triggerEvent: #deactivated]</body><body package="Com- Event-Enabled Application Extensions">resizeEvent: aResizeEvent 	^[super resizeEvent: aResizeEvent] ensure: [self triggerEvent: #resized]</body></methods><methods><class-id>UI.EventEnabledApplicationWindow class</class-id> <category>private-events</category><body package="Com- Event-Enabled Application Extensions">constructEventsTriggered        "Private - answer the set of events that instances of the        receiver can trigger."	^super constructEventsTriggered	"window opening"		add: #built ;		add: #opened ;	"window closing"		add: #confirmClose ;  " this is a vetoable confirmation event "		add: #aboutToClose ;		add: #closed ;	"window operation"		add: #activated ;		add: #deactivated ;		add: #resized ;		yourself</body></methods><methods><class-id>UI.EventEnabledSimpleView</class-id> <category>properties</category><body package="Com- Event-Enabled Application Extensions">propertyAt: key         "Answer the value associated with key        in the properties dictionary."    properties isNil ifTrue: [ ^nil ].    ^properties at: key ifAbsent: [ nil ]</body><body package="Com- Event-Enabled Application Extensions">propertyAt: key ifAbsent: aBlock        "Answer the value associated with key        in the properties dictionary; if absent,         answer the result of evaluating aBlock."    properties isNil ifTrue: [ ^aBlock value ].    ^properties at: key ifAbsent: aBlock</body><body package="Com- Event-Enabled Application Extensions">propertyAt: key ifAbsentPut: aBlock        "Answer the value associated with key        in the properties dictionary; if absent, evaluate		aBlock, put the evaluation result at key, and        answer the result."    properties isNil ifTrue: [ properties := IdentityDictionary new ].    ^properties at: key ifAbsent: [ properties at: key put: aBlock value ]</body><body package="Com- Event-Enabled Application Extensions">propertyAt: key put: aValue        "Set the value associated with key        in the properties dictionary."    properties isNil ifTrue: [ properties := IdentityDictionary new ].    aValue isNil ifTrue: [ ^properties removeKey: key ifAbsent: [ ] ].    ^properties at: key put: aValue</body></methods><methods><class-id>UI.EventEnabledSimpleView</class-id> <category>private-accessing</category><body package="Com- Event-Enabled Application Extensions">myEventTable	"Private - answer a Dictionary mapping event names to actions	for the receiver, or nil if there is none."	^eventTable</body><body package="Com- Event-Enabled Application Extensions">myEventTable: newTable	"Private"	eventTable := newTable.</body><body package="Com- Event-Enabled Application Extensions">properties        "Private - Answer the properties Dictionary."    ^properties</body><body package="Com- Event-Enabled Application Extensions">properties: aDictionary        "Private - Set the properties Dictionary."    properties := aDictionary.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ScheduledWindow</name><environment>UI</environment><super>Graphics.Window</super><private>false</private><indexed-type>none</indexed-type><inst-vars>label icon minimumSize maximumSize component lookPreferences paintPreferences edgeDecorationPolicy widgetPolicy controller model damageRepairPolicy masterWindow activationNotification application dragDropInProgress dragDropTracker dropTarget keyboardProcessor receiveWindowEvents sendWindowEvents toolbarVisible windowEventBlock layoutIsInvalid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Framework</category><attributes><package>Interface-Framework</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>SimpleView</name><environment>UI</environment><super>UI.View</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Support</category><attributes><package>UIBasics-Support</package></attributes></class><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>ApplicationStandardSystemController</name><environment>UI</environment><super>UI.StandardSystemController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventDispatcher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class></st-source>