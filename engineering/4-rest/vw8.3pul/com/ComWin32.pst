<?xml version="1.0"?><st-source><!-- Name: Com- Win32Notice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This object has not been commented.DbIdentifier: bear73DbTrace: 497466DbUsername: alexDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Com- ExtensionsToBase' '') #(#any 'Com- CodeAnnotations' '') #(#any 'Com- External Data Enhancements' '') #(#any 'Com- Interface Adaptors' '') #(#any 'Com- System Configuration Services' '') #(#any 'Com- Win32 Pools' '') #(#any 'BOSS' '') #(#any 'DLLCC' '') #(#package 'Com- Automation Pools' '') #(#any 'DLLCC-Decompiler' ''))DialectVersion: VisualWorks 7.9PackageName: Com- Win32Parcel: #('ComWin32')ParcelName: Com- Win32PrerequisiteDescriptions: #(#(#name 'Com- ExtensionsToBase') #(#name 'Com- CodeAnnotations') #(#name 'Com- External Data Enhancements') #(#name 'Com- Interface Adaptors') #(#name 'Com- System Configuration Services') #(#name 'Com- Win32 Pools') #(#name 'BOSS') #(#name 'DLLCC') #(#name 'Com- Automation Pools' #componentType #package #loadResolution #store) #(#name 'DLLCC-Decompiler' #componentType #package))PrerequisiteParcels: #(#('Com- ExtensionsToBase' '') #('Com- CodeAnnotations' '') #('Com- External Data Enhancements' '') #('Com- Interface Adaptors' '') #('Com- System Configuration Services' '') #('Com- Win32 Pools' '') #('BOSS' '') #('DLLCC' '') #('Com- Automation Pools' '') #('DLLCC-Decompiler' ''))PrintStringCache: (8.3 - 1,alex)Version: 8.3 - 1Pre-Load Block: 	[:package | ]Date: 1:50:01 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:01</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Win32ExternalInterface</name><environment>External</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports>			private External.Win32NLSConstants.*			private External.Win32ExternalInterfaceDictionary.*			</imports><category>OS-Win32 Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32ExternalInterface</class-id><body>The class Win32ExternalInterface defines external data types for the Microsoft Windows 32-bit programming interfaces (APIs) and provides and provides conversion services for working with host data.  This class contains the necessary type information for defining API functions in DLL binding classes.  It is primarily of interest to developers writing low-level host binding classes.  Please consult the Microsoft Win32 programming reference documentation for further information about Windows programming.Class services are provided to simplify and standardize handling for Win32 data types used as argument and return values in Win32 API's.  Win32 API's are defined by DLL-specific binding classes.  Clients should reference Win32 constants using the pool variables defined in Win32Constants.</body></comment><class><name>Win32DynamicLinkLibrary</name><environment>External</environment><super>External.Win32ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			External.CConstants.*			private External.Win32DynamicLinkLibraryDictionary.*			</imports><category>OS-Win32 Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32DynamicLinkLibrary</class-id><body>Win32DynamicLinkLibrary is the abstract superclass for implementing DLL host binding classes which provide external function call services to invoke API functions in Win32 dynamic link libraries.</body></comment><class><name>Win32CommonDialogDLL</name><environment>External</environment><super>External.Win32DynamicLinkLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			External.CConstants.*			External.Win32CommonDialogConstants.*			private External.Win32CommonDialogDLLDictionary.*			</imports><category>OS-Win32 Host Bindings</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>comdlg32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32CommonDialogDLL</class-id><body>Win32CommonDialogDLL implements the host binding DLL wrapper class to provide access to the Win32 common system dialog API functions.</body></comment><class><name>Win32Buffer</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buffer value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32Buffer</class-id><body>Win32Buffer is the abstract superclass for classes which implement buffers used for argument and return values of Win32 external functions.</body></comment><class><name>Win32ResultValueBuffer</name><environment>External</environment><super>External.Win32Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32ResultValueBuffer</class-id><body>Win32ResultValueBuffer is the abstract superclass for classes which implement buffers used for OUT arguments of Win32 external functions.  A result value buffer is constructed by a client, possibly with some initial state.  The client must send the message #asPointerParameter to the buffer when passing it as an argument to an external function.  On return, the message #contents is sent to the buffer to obtain the value returned by the called function.</body></comment><class><name>Win32ArrayResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferElementType bufferElementCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32ArrayResultBuffer</class-id><body>A Win32ArrayResultBuffer is used to obtain the value of an OUT argument of an external function which is an array of C data elements in memory that the caller allocates.  The buffer contents are returned as an array.</body></comment><class><name>Win32DialogBox</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>style properties parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32DialogBox</class-id><body>Win32DialogBox is an abstract superclass for implementing dialog wrapper classes which provide Smalltalk bindings to user dialogs provided by Win32 host platform components.</body></comment><class><name>Win32CommonSystemDialog</name><environment>External</environment><super>External.Win32DialogBox</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32CommonSystemDialog</class-id><body>Win32CommonSystemDialog is an abstract superclass for implementing dialog wrapper classes which provide Smalltalk bindings to the standard user dialogs provided by the Win32 host platform common system dialogs component.</body></comment><class><name>Win32ResourceHandle</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32ResourceHandle</class-id><body>Win32ResourceHandle is the abstract superclass for implementing wrapper classes which represent various Win32 host system resource handles.Instance variables:	handle		&lt;CPointer | nil&gt;	The Win32 resource handle.</body></comment><class><name>Win32WindowHandle</name><environment>External</environment><super>External.Win32ResourceHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			</imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32WindowHandle</class-id><body>The Win32WindowHandle class wraps a Win32 HWND resource handle and provides operations associated with manipulating the low-level window handle.</body></comment><class><name>Win32AdvApiDLL</name><environment>External</environment><super>External.Win32DynamicLinkLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			External.CConstants.*			private External.Win32AdvApiDLLDictionary.*			</imports><category>OS-Win32 Host Bindings</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>advapi32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32AdvApiDLL</class-id><body>AdvApiDLL implements the host binding DLL wrapper class to provide access to the Win32 registry API functions.</body></comment><class><name>Win32MemoryReadWriteStream</name><environment>External</environment><super>OS.ExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>address encoding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32MemoryReadWriteStream</class-id><body>Win32MemoryReadWriteStream supports the Smalltalk Stream protocol for accessing a buffer in external memory backed by Win32 global memory.  The memory is reallocated if necessary to grow the stream.</body></comment><class><name>Win32MemoryAddress</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pointer </inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			</imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32MemoryAddress</class-id><body>Win32MemoryAddress is the abstract superclass for implementing wrapper classes which provide memory allocation services through various Win32 platform memory allocation mechanisms.  Class messages are supported to provide a standard protocol for allocating external Win32 memory.A Win32MemoryAddress is an external memory address which references memory allocated outside Smalltalk object space using a Win32 memory allocator.  A Win32 memory address can be used interchangeably with a CPointer which references external memory allocated from the Smalltalk external memory heap.Instance variables:	pointer		&lt;CPointer | nil&gt;	The address of the referenced memory.</body></comment><class><name>Win32PlatformStringResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cb cbResult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32PlatformStringResultBuffer</class-id><body>A Win32PlatformStringResultBuffer is used to obtain the value of an OUT argument of an external function which is a platform string value in memory that the caller allocates.  The buffer value is returned as an internal Smalltalk string.</body></comment><class><name>Win32UnicodeStringResultBuffer</name><environment>External</environment><super>External.Win32PlatformStringResultBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32UnicodeStringResultBuffer</class-id><body>A Win32UnicodeStringResultBuffer is used to obtain the value of an OUT argument of an external function which is a Unicode string value in memory that the caller allocates.  The buffer value is returned as an internal Smalltalk string.</body></comment><class><name>Win32GenericHandle</name><environment>External</environment><super>External.Win32ResourceHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Win32</package></attributes></class><class><name>Win32ArgumentBuffer</name><environment>External</environment><super>External.Win32Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32ArgumentBuffer</class-id><body>Win32ArgumentBuffer is the abstract superclass for classes which implement buffers used for arguments of Win32 external functions.  An argument buffer is constructed by a client with some initial state.  The client must send the message #asPointerParameter to the buffer when passing it as an argument to an external function.  On return, the message #release is sent to the buffer to release any external resources acquired when the buffer was constructed.</body></comment><class><name>Win32StringPointerListBuffer</name><environment>External</environment><super>External.Win32ArgumentBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32StringPointerListBuffer</class-id><body>A Win32StringPointerListBuffer is used to construct an argument consisting of an array of string pointer values for a COM function call.</body></comment><class><name>ValueReference</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.ValueReference</class-id><body>A ValueReference is an object which holds a reference to a value and supports the #value and #value: protocol.  It is typically used to obtain an OUT value from an external function which expects the caller to provide a reference (pointer) argument which the callee sets to return a value.  Use of a value reference decouples Smalltalk clients from the low-level details of external function calls, allowing a low-level host binding wrapper class to encapsulate the direct external interface logic and provide argument marshalling services on behalf of Smalltalk callers of external functions.  Value reference parameters allow the platform-and-OE-specific details of external interactions to be encapsulated in low-level host binding classes and localize the gory details of crossing the system boundary to well-understand layers in the architecture.The caller typically obtains the OUT value reference by a pattern such as:	| resultReference |	resultReference := nil asValueReference.  "or: ValueReference new "	aDLLWrapper someFunction: 'foo' _: true _: resultReference.	^resultReference valueThe callee in the host binding class provides the value of an OUT value reference by an expression such as:    resultReference value: someValue.Note that the callee in this case is the object directly invokes the external function and is responsible for providing argument marshalling services which provide any necessary mapping between Smalltalk values and the corresponding external host data representations.Value references can also be used for IN/OUT parameters, where the caller provides an initial value and gets a possibly different value back.  E.g.	| inOutValueReference |	inOutValueReference := 20 asValueReference.  "or: ValueReference on: 20 "	aDLLWrapper someFunction: 'foo' _: true _: inOutValueReference.	^inOutValueReference valueInstance variables:	value		&lt;Object&gt;	The value being referenced.</body></comment><class><name>Win32UserDLL</name><environment>External</environment><super>External.Win32DynamicLinkLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			External.CConstants.*			private External.Win32UserDLLDictionary.*			</imports><category>OS-Win32 Host Bindings</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>user32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32UserDLL</class-id><body>Win32UserlDLL implements the host binding DLL wrapper class to provide access to the Win32 user interface and window system API functions.</body></comment><class><name>Win32FileDialog</name><environment>External</environment><super>External.Win32CommonSystemDialog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fileName filters pathName openFileNameStruct </inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32CommonDialogConstants.*			External.Win32Constants.*			</imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32FileDialog</class-id><body>The Win32FileDialog class provides a Smalltalk binding to the standard Win32 file dialog.  The Windows file dialog is generally used indirectly through the platform-independent FileDialog class.  However, clients which are willing to accept an explicit dependency on the Win32 platform in their applications may choose to use the Win32FileDialog class directly in order to exploit enhanced capabilities which are specific to the Windows dialog.</body></comment><class><name>Win32GlobalMemoryAddress</name><environment>External</environment><super>External.Win32MemoryAddress</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memorySize memoryHandle referentType </inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			</imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32GlobalMemoryAddress</class-id><body>A Win32GlobalMemoryAddress is an external memory address which references memory allocated outside Smalltalk object space using the Win32 global memory allocator.  Class messages are supported by Win32GlobalMemoryAddress to provide standard global memory allocation services.Win32 global memory is referenced by an HGLOBAL system resource handle obtained from the Win32 global memory allocator.  The global memory is addressable (i.e., has a valid pointer to the memory which can be used to reference its contents) only when the global memory block is locked by the client.  While the normal global memory allocation services provided to the Smalltalk programmer will lock the memory to make it addressable, a client which is only allocating the global memory block in order to give away the handle can optimize their implementation by bypassing the lock operation.  Global memory is unlocked when it is freed or invalidated; the latter typically occurs when a client gives away the memory to another application.Instance variables:	memorySize	&lt;Integer&gt; The size in bytes of the referenced memory.	memoryHandle	&lt;HGLOBAL&gt;  The global memory handle obtained from the Win32 global memory allocator.</body></comment><class><name>Win32KernelDLL</name><environment>External</environment><super>External.Win32DynamicLinkLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			External.CConstants.*			private External.Win32KernelDLLDictionary.*			</imports><category>OS-Win32 Host Bindings</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>kernel32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32KernelDLL</class-id><body>Win32KernelDLL implements the host binding DLL wrapper class to provide access to the Win32 kernel services API functions.</body></comment><class><name>Win32Structure</name><environment>External</environment><super>External.ExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32Structure</class-id><body>The Win32Structure class provides convenience services for creating and accessing Win32 data structures.  Dynamic protocol is supported for accessing each structure member, as well as transformation services for providing mappings between native host data types and Smalltalk wrapper classes.  Subclasses can be implemented to provide cusomized bindings for specific data structures.</body></comment><class><name>Win32ClipboardInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			</imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32ClipboardInterface</class-id><body>The Win32ClipboardInterface class provides services for accessing the system clipboard and clipboard format constants on a Win32 system.</body></comment><class><name>Win32UnicodePointerListBuffer</name><environment>External</environment><super>External.Win32StringPointerListBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32UnicodePointerListBuffer</class-id><body>A Win32UnicodePointerListBuffer is used to construct an argument consisting of an array of Unicode string pointer values for a COM function call.</body></comment><class><name>Win32HandleResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handleType handleClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32HandleResultBuffer</class-id><body>A Win32HandleResultBuffer is used to obtain the value of an OUT argument of an external function which is a Win32 resource handle.</body></comment><class><name>Win32RegKeyHandleResultBuffer</name><environment>External</environment><super>External.Win32HandleResultBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>securityAccess </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32RegKeyHandleResultBuffer</class-id><body>Win32RegKeyHandleResultBuffer is a buffer for Registry Key handles. In addition to it superclass it supports storing the requested security attributes.Instance Variables	securityAccess	&lt;Integer&gt;	the security attribute mask used to open the key.</body></comment><class><name>Win32RegKeyHandle</name><environment>External</environment><super>External.Win32ResourceHandle</super><private>false</private><indexed-type>none</indexed-type><inst-vars>securityAccess constant </inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			</imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32RegKeyHandle</class-id><body>The Win32RegKeyHandle class wraps a Win32 HKEY registration database key resource handle and provides operations associated with manipulating the low-level handle.Instance Variables	constant	&lt;Boolean&gt;		answer whether this key represents a constant like HKEY_LOCAL_MACHINE.	securityAccess	&lt;Integer&gt;	security access rights used for opening the key </body></comment><class><name>Win32PointerResultValueBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32PointerResultValueBuffer</class-id><body>Win32PointerResultValueBuffer is the abstract superclass for implementing result value buffers which obtain an OUT argument value which is a pointer to something.</body></comment><class><name>Win32BufferManager</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32BufferManager</class-id><body>Win32BufferManager provides the storage allocation policies and services which are used for allocating and managing external data buffers used to invoke external functions.</body></comment><class><name>Win32StructureResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structureType structureClass valueConstructionAction </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32StructureResultBuffer</class-id><body>A Win32StructureResultBuffer is used to obtain the value of an OUT argument of an external function which is a structure.  The buffer value is returned with the structure wrapped by an instance of an ExternalStructure (sub)class which operates on structures of this type.  Optionally, the creator of the buffer can specify an additional action to evaluate when the buffer contents are obtained in order the transform the structure into some suitable value.</body></comment><class><name>Win32MessageBox</name><environment>External</environment><super>External.Win32DialogBox</super><private>false</private><indexed-type>none</indexed-type><inst-vars>title message result resultSymbol </inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			</imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32MessageBox</class-id><body>The Win32Message class provides a Smalltalk binding to the standard Win32 message box dialog.  The Windows message dialog is generally used indirectly through the platform-independent MessageBox class.</body></comment><class><name>Win32_SYSTEMTIME</name><environment>External</environment><super>External.Win32Structure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32_SYSTEMTIME</class-id><body>Win32_SYSTEMTIME provides services for using and manipulating a time value represented as a Win32 SYSTEMTIME structure.Win32_SYSTEMTIME fromTimestamp: Win32_SYSTEMTIME now asTimestamp.---*** A note relating to COM Automation ***A variant time is stored as an 8-byte real value (double), representing a date between January 1, 1753 and December 31, 2078, inclusive. The value 2.0 represents January 1, 1900; 3.0 represents January 2, 1900, and so on. Adding 1 to the value increments the date by a day. The fractional part of the value represents the time of day. Therefore, 2.5 represents noon on January 1, 1900; 3.25 represents 6:00 a.m. on January 2, 1900, and so on. Negative numbers represent the dates prior to December 30, 1899.The SYSTEMTIME structure is useful for the following reasons: 1) It spans all time/date periods. MS-DOS date/time is limited to representing only those dates between 1/1/1980 and 12/31/2107. 2) The date/time elements are all easily accessible without needing to do any bit decoding. 3) The National Data Support data and time formatting functions GetDateFormat and GetTimeFormat take a SYSTEMTIME value as input. For more information, see the Win32 Programmer's Reference in the Win32 SDK. 4) It is the default Win32 time/date data format supported by Windows NT and Windows 95. ---Some basic tests:Win32_SYSTEMTIME fromTimestamp: ( Timestamp readFrom: 'January 1, 1000' readStream ).Win32_SYSTEMTIME fromTimestamp: ( Timestamp readFrom: 'January 1, 1753' readStream ).Win32_SYSTEMTIME fromTimestamp: ( Timestamp readFrom: 'December 31, 2078' readStream ).Win32_SYSTEMTIME fromTimestamp: ( Timestamp readFrom: 'December 31, 10000' readStream ).</body></comment><class><name>Win32StructurePointerResultBuffer</name><environment>External</environment><super>External.Win32PointerResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structureType structureClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32StructurePointerResultBuffer</class-id><body>A Win32StructurePointerBuffer is used to obtain the value of an OUT argument of an external function which is a pointer to a structure.  The buffer value is returned with the structure wrapped by an instance of an ExternalStructure (sub)class which operates on structures of this type.</body></comment><class><name>Win32UnicodeStringPointerResultBuffer</name><environment>External</environment><super>External.Win32PointerResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32UnicodeStringPointerResultBuffer</class-id><body>A Win32UnicodeStringPointerBuffer is used to obtain the value of an OUT argument of an external function which is a pointer to a Unicode string value.  The buffer value is returned as an internal Smalltalk string.</body></comment><class><name>Win32_FILETIME</name><environment>External</environment><super>External.Win32Structure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32_FILETIME</class-id><body>Win32_FILETIME provides services for using and manipulating a time value represented as a Win32 FILETIME structure.</body></comment><class><name>Win32LargeInteger</name><environment>External</environment><super>External.Win32Structure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32LargeInteger</class-id><body>Win32LargeInteger provides services for using the Win32 LARGE_INTEGER and ULARGEINTEGER data types.</body></comment><class><name>Win32ScalarResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scalarType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.Win32ScalarResultBuffer</class-id><body>A Win32ScalarResultBuffer is used to obtain the value of an OUT argument of an external function which is a scalar value.  The contents of the buffer are returned as the actual value.</body></comment><class><name>Win32RegistrationDatabase</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyName keyHandle rootHandle registryAccessMode </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><class><name>COMCompiler</name><environment>External</environment><super>Kernel.ExtendedCompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><comment><class-id>External.COMCompiler</class-id><body>The class COMCompiler is used in conjunction with COMParser.  Together they implement the extended syntax for external declarations ('&lt;COM: ...&gt;').  COMCompiler is responsible for constructing the proper CompiledMethod once the COMParser has parsed the declaration syntax.</body></comment><shared-variable><name>Win32UserDLLDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>Win32DynamicLinkLibraryDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>Win32ExternalInterfaceDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>Win32KernelDLLDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>Win32CommonDialogDLLDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>Win32AdvApiDLLDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>DynamicLinkLibraryBindingDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>UserFormats</name><environment>External.Win32ClipboardInterface</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>Current</name><environment>External.Win32ClipboardInterface</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>IsOpen</name><environment>External.Win32ClipboardInterface</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>DirName</name><environment>External.Win32FileDialog</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>UseGCHeapServices</name><environment>External.Win32BufferManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>UseFixedSpace</name><environment>External.Win32BufferManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>PointerRegistry</name><environment>External.Win32BufferManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Win32</package></attributes></shared-variable><shared-variable><name>ResultSymbols</name><environment>External.Win32MessageBox</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Win32</package></attributes></shared-variable><methods><class-id>External.Win32ExternalInterface</class-id> <category>releasing</category><body package="Com- Win32">close	" Close the library accessed by the receiver. "	self class current == self		ifTrue: [ self class current: nil ].</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>subclass-error handling</category><body package="Com- Win32">externalAccessFailed	"Raise the signal that indicates something went wrong with an external access.	 Use the receiver as the signal's parameter. Try to get the error code from the	 sending context."	" Note: This is really how the superclass method should be implemented.  This reimplementation should not be necessary. "	" Note also that use of this method is discouraged.  Clients should simply use #externalAccessFailedWith: in the first place. "	| errorCode |	"( thisContext sender method isKindOf: ExternalMethod )"	( thisContext sender method class == self externalMethodClass )		ifTrue: [ errorCode := thisContext sender top ].	^self externalAccessFailedWith: errorCode</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>type information utilities</category><body package="Com- Win32">getFundamentalTypeOf: aType	" Dereference typedef's and pointers to get to the real type definition of &lt;aType&gt;. "	| fundamentalType |	fundamentalType := self getRealTypeOf: aType.	[ fundamentalType isPointer ]		whileTrue: [ fundamentalType := self getRealTypeOf: fundamentalType referentType ].	^fundamentalType</body><body package="Com- Win32">getRealTypeOf: aType	" Dereference typedef's to get to the real type definition of &lt;aType&gt;. "	^aType baseType</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>accessing-types</category><body package="Com- Win32">platformCharacterType	" Answer the C data type of a platform string character. "	"^Win32TypeAccessor CHAR"	"?? ^CIntegerType unsignedChar ??"	^CIntegerType char</body><body package="Com- Win32">platformStringPointerType	" Answer the C data  type of a platform string pointer. "	"^CVoidType void pointerType"	^self platformCharacterType pointerType</body><body package="Com- Win32">typeNamed: aSymbol	" Answer the definition of the external data type named &lt;aSymbol&gt;.  Answer nil if it is not defined. "	^self typeNamed: aSymbol ifNone: [ nil ]</body><body package="Com- Win32">typeNamed: aSymbol ifNone: aBlock	" Answer the definition of the external data type named &lt;aSymbol&gt;.  Answer the result of evaluating &lt;aBlock&gt; if the definition does not exist. "	^self externals at: aSymbol ifAbsent: aBlock</body><body package="Com- Win32">unicodeCharacterType	" Answer the C data type of a Unicode character. "	"?? ^^CIntegerType unsignedShort ??"	^self current WCHAR</body><body package="Com- Win32">unicodeStringPointerType	" Answer the C data type of a Unicode string pointer. "	" A Unicode string is actually a WCHAR * pointer.  However, it is		sufficient for the purposes of what we with these buffers to simply		declare a more basic equivalent of the type. "	"?? ^CVoidType void pointerType ??"	^self unicodeCharacterType pointerType</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>argument conversion services</category><body package="Com- Win32">asPlatformStringBytes: aString	" Answer a byte object containing the native platform encoding of &lt;aString&gt;.  Note that no trailing null is appended. "	^aString asByteArrayEncoding: #default</body><body package="Com- Win32">asPointStructure: aPoint        " Answer &lt;aPoint&gt; as a Win32 POINT structure.  Note that this can also be used to construct any point-like structure with LONG x/y members (e.g., POINTL). "	aPoint == nil		ifTrue: [ ^self asPointStructure: 0 @ 0 ].	^self current POINT new		memberAt: #x put: aPoint x;		memberAt: #y put: aPoint y;		yourself</body><body package="Com- Win32">asRectangleParameter: aRectangle        " Answer &lt;aRectangle&gt; in form suitable for use as a Win32 RECT * structure argument.  Note that this can also be used to construct any point-like structure pointer argument with LONG cx/cy members (e.g., SIZEL). "	aRectangle == nil		ifTrue: [ ^self asRectangleParameter: ( 0 @ 0 extent: 0 @ 0 ) ].	^( Win32BufferManager allocateBuffer: self current RECT )		memberAt: #top put: aRectangle top;		memberAt: #bottom put: aRectangle bottom;		memberAt: #right put: aRectangle right;		memberAt: #left put: aRectangle left;		yourself</body><body package="Com- Win32">asSizeParameter: aPoint        " Answer &lt;aPoint&gt; in form suitable for use as a Win32 SIZE * structure argument.  Note that this can also be used to construct any point-like structure pointer argument with LONG cx/cy members (e.g., SIZEL). "	aPoint == nil		ifTrue: [ ^self asSizeParameter: 0 @ 0 ].	^( Win32BufferManager allocateBuffer: self current SIZE )		memberAt: #cx put: aPoint x;		memberAt: #cy put: aPoint y;		yourself</body><body package="Com- Win32">asSizeStructure: aPoint        " Answer &lt;aPoint&gt; as a Win32 SIZE structure.  Note that this can also be used to construct any point-like structure with LONG cx/cy members (e.g., SIZEL). "	aPoint == nil		ifTrue: [ ^self asSizeStructure: 0 @ 0 ].	^self current SIZE new		memberAt: #cx put: aPoint x;		memberAt: #cy put: aPoint y;		yourself</body><body package="Com- Win32">asUnicodeStringBytes: aString	" Answer a byte object containing the Unicode encoding of &lt;aString&gt;.  Note that no trailing null is appended. "	^aString asByteArrayEncoding: #UTF16</body><body package="Com- Win32">dateFromDosDate: anUnsignedShort	" Answer a Date from the MS-DOS formated date in &lt;anUnsignedShort&gt;. "	"The format is defined in OLE Auto PR p204 as:		0-4        Day of the month (1-31)		5-8        Month (1=Jan, 2=Febrary, etc)		9-15        Year offset from 1980 (add 1980 to get actual year."	| dayOfMonth month year |	anUnsignedShort isNil		ifTrue: [ ^nil ].	year := 1980 + ( anUnsignedShort bitShift: -9 ).	month := ( anUnsignedShort bitShift: -5 ) bitAnd: 2r0000000000001111.	dayOfMonth := anUnsignedShort bitAnd: 2r0000000000011111.	^Date newDay: dayOfMonth monthNumber: month year: year</body><body package="Com- Win32">dosDateFromDate: aDate 	"Answer the MS-DOS date format encoding of &lt;aDate&gt;."	"The format is defined in OLE Auto PR p204 as: 	0-4 Day of the month (1-31) 	5-8 Month (1=Jan, 2=Febrary, etc) 	9-15 Year offset from 1980 (add 1980 to get actual year)."	| day month year |	aDate isNil ifTrue: [^0].	day := aDate dayOfMonth.	month := aDate monthIndex bitShift: 5.	year := aDate year - 1980 bitShift: 9.	^day | month | year</body><body package="Com- Win32">dosTimeFromTime: aTime	" Answer the MS-DOS time format encoding of &lt;aTime&gt;. "    "The format is defined in OLE Auto PR p204 as:		0-4: Seconds divided by 2		5-10: Minutes (0-59)		11-15: Hour (0-23 on a 24-hour clock)."    | hours minutes seconds |    aTime isNil        ifTrue: [ ^0 ].    hours := aTime hours bitShift: 11.    minutes := aTime minutes bitShift: 5.    seconds := aTime seconds // 2.    ^hours | minutes | seconds</body><body package="Com- Win32">pointFromStruct: aStruct	" Answer the Win32 POINT structure &lt;aStruct&gt; as a Point. "	^( aStruct memberAt: #x ) @ ( aStruct memberAt: #y )</body><body package="Com- Win32">rectangleFromStruct: aStruct        " Answer the Win32 RECT structure &lt;aStruct&gt; as a Rectangle. "	| aRect | 	aRect := 0@0 extent: 0@0.	aRect 		top: ( aStruct memberAt: #top );		bottom: ( aStruct memberAt: #bottom );		right: ( aStruct memberAt: #right );		left: ( aStruct memberAt: #left ).	^aRect</body><body package="Com- Win32">stringFromPointer: lpString	" Answer the string containing the characters at address &lt;lpString&gt;.  The string pointer references the platform string encoding of the string. "	^lpString isNull		 ifTrue: [ nil ]		ifFalse: [ lpString copyCStringFromHeap ]</body><body package="Com- Win32">stringFromUnicodePointer: lpWstr	" Answer the string containing the characters at address &lt;lpWstr&gt;.  The string pointer references the Unicode byte encoding of the string. "	^lpWstr isNull		 ifTrue: [ nil ]		ifFalse: [ lpWstr copyUnicodeStringFromHeap ]</body><body package="Com- Win32">timeFromDosTime: anUnsignedShort	" Answer a Time from the MS-DOS formated time in &lt;anUnsignedShort&gt;. "    "The format is defined in OLE Auto PR p204 as:		0-4: Seconds divided by 2		5-10: Minutes (0-59)		11-15: Hour (0-23 on a 24-hour clock)."    | hours minutes seconds |    anUnsignedShort isNil        ifTrue: [ ^nil ].    hours := anUnsignedShort bitShift: -11.    minutes := ( anUnsignedShort bitShift: -5 ) bitAnd: 2r0000000000111111.    seconds := ( anUnsignedShort bitAnd: 2r0000000000011111 ) * 2.    ^Time new hours: hours minutes: minutes seconds: seconds</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>macros</category><body package="Com- Win32">HIWORD: l	"#define HIWORD(l) ((WORD)(((DWORD)(l )&gt;&gt;16)&amp;65535))"	^((DWORD cast: l) bitShift: -16) bitAnd: 65535</body><body package="Com- Win32">LOWORD: l	"#define LOWORD(l) ((WORD)(l ))"	^(WORD cast: l)</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>utilities</category><body package="Com- Win32">beep        "Beep the speaker"	" Win32ExternalInterface beep "	Win32UserDLL current MessageBeep: -1.</body><body package="Com- Win32">beep: frequency for: duration        "Beep the speaker"	" Win32ExternalInterface beep: 500 for: 300 "	Win32KernelDLL current Beep: frequency _: duration.</body><body package="Com- Win32">crString	" Answer the Win32 platform encoding of a hard line break. "	^String with: Character cr with: Character lf</body><body package="Com- Win32">findFileName: aFileName	" Answer the full path of the file named &lt;aFileName&gt;, searching on the system PATH directories.  Answer nil if the file is not found. "	" Win32ExternalInterface findFileName: 'kernel32.dll' "	^self findFileName: aFileName on: nil</body><body package="Com- Win32">findFileName: aFileName on: aDirectoryPathName	" Answer the full path of the file named &lt;aFileName&gt;, searching along the given path of &lt;aDirectoryPathName.  Answer nil if the file is not found. "	| resultReference |	resultReference := nil asValueReference.	Win32KernelDLL current SearchPath: aDirectoryPathName		_: aFileName		_: nil		_: nil		_: resultReference		_: nil.	^resultReference value</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>argument buffer services</category><body package="Com- Win32">arrayResultBufferFor: aTypeName count: nElements	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an array of &lt;nElements&gt; values of the type named &lt;aTypeName&gt;.  This service should generally only be used for scalar arguments (structure OUT argument buffers are usually constructed as an ExternalStructure instance).  Unlike other pointer arguments, it is not necessary in this case for the caller to send #asPointerParameter to the array value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer.  A subset of the element can be extracted by sending the message #copyFrom:to: to the buffer. "	| aType |	aType := self typeNamed: aTypeName asSymbol		ifNone: [ self error: ((#noSuchTypeC1s &lt;&lt; #com &gt;&gt; 'no such type: &lt;1s&gt;')			expandMacrosWith: aTypeName) ].	^self arrayResultBufferForType: aType count: nElements</body><body package="Com- Win32">arrayResultBufferForType: aType count: nElements	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an array of &lt;nElements&gt; values of the type &lt;aType&gt;.  This service should generally only be used for scalar arguments (structure OUT argument buffers are usually constructed as an ExternalStructure instance).  Unlike other pointer arguments, it is not necessary in this case for the caller to send #asPointerParameter to the array value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer.  A subset of the element can be extracted by sending the message #copyFrom:to: to the buffer. "	"Assert isTrue: [ aType isPointer or: [ aType is a scalar... ]."	aType isComposite		ifTrue: [ self error: ((#ArrayBufferNotSupported &lt;&lt; #com &gt;&gt; 'array buffer not supported for structures: &lt;1s&gt;')			expandMacrosWith: aType name) ].	^Win32ArrayResultBuffer type: aType count: nElements</body><body package="Com- Win32">createUnicodeArrayBuffer: stringList	"Allocate and answer an buffer containing pointers to the Unicode encoding of the strings in &lt;stringList&gt;.  The caller must send #asPointerParameter to the buffer when it is passed as a function argument and ensure that #release is sent to the buffer after the function call is made. "	^Win32UnicodePointerListBuffer for: stringList</body><body package="Com- Win32">handleResultBufferFor: aTypeName	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a Win32 HANDLE value of the type named &lt;aTypeName&gt;.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value of the handle must be extracted from the buffer after the function call by sending #contents to the buffer value. "	| aType  |	aType := self typeNamed: aTypeName asSymbol		ifNone: [ self error: ((#noSuchTypeC1s &lt;&lt; #com &gt;&gt; 'no such type: &lt;1s&gt;')			expandMacrosWith: aTypeName) ].	^Win32HandleResultBuffer forType: aType</body><body package="Com- Win32">platformStringBuffer: nBytes	" Answer an object which provides a buffer of &lt;nBytes&gt; bytes  for a character string in platform string encoding.  The message #asPointerParameter must be sent to the buffer when it is used as an argument of an external function.  The message #contents  is sent to the buffer to extract the value of an OUT string parameter after the function call. "	^Win32PlatformStringResultBuffer new: nBytes</body><body package="Com- Win32">scalarResultBufferFor: aTypeSpecification	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a value of the scalar type &lt;aTypeSpecification&gt;, which can be either a type name or a basic C type.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer. "	| aType |	aType := ( aTypeSpecification isSymbol		ifTrue: [ self typeNamed: aTypeSpecification asSymbol			ifNone: [ self error: ((#noSuchTypeC1s &lt;&lt; #com &gt;&gt; 'no such type: &lt;1s&gt;')			expandMacrosWith: aTypeSpecification) ] ]		ifFalse: [ aTypeSpecification ] ).	aType isComposite		ifTrue: [ self error: ((#notAScalarTypeC1s &lt;&lt; #com &gt;&gt; 'not a scalar type: &lt;1s&gt;')			expandMacrosWith: aType name) ].	^Win32ScalarResultBuffer for: aType</body><body package="Com- Win32">structureBufferFor: aStructureName	" Answer a buffer for the structure named &lt;aStructureName&gt; which can be used as an argument for an external function call.  The caller must send #asStructureParameter to the buffer when it is passed as the function argument.  The buffer should be released when the caller is done with it.  "	| aType |	aType := self typeNamed: aStructureName.	"Assert isTrue: [ aType isComposite ]."	^Win32BufferManager allocateBuffer: aType</body><body package="Com- Win32">structureResultBufferFor: aStructureName	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a value of the structure type named &lt;aStructureName&gt;.  The caller must send #asPointerParameter to the buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	| aType |	aType := self typeNamed: aStructureName asSymbol		ifNone: [ self error: ((#noSuchTypeC1s &lt;&lt; #com &gt;&gt; 'no such type: &lt;1s&gt;')			expandMacrosWith: aStructureName) ].	"Assert isTrue: [ aType isComposite ]."	^Win32StructureResultBuffer forType: aType</body><body package="Com- Win32">structureResultBufferFor: aStructureName valueAction: aOneArgAction	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a value of the structure type named &lt;aStructureName&gt;.  The caller must send #asPointerParameter to the buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value, which applies &lt;aOneArgAction&gt; to realize the value. "	| aType |	aType := self typeNamed: aStructureName asSymbol		ifNone: [ self error: ((#noSuchTypeC1s &lt;&lt; #com &gt;&gt; 'no such type: &lt;1s&gt;')			expandMacrosWith: aStructureName) ].	"Assert isTrue: [ aType isComposite ]."	^Win32StructureResultBuffer type: aType		action: aOneArgAction</body><body package="Com- Win32">unicodeResultBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a pointer to a Unicode string.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^Win32UnicodeStringPointerResultBuffer new</body><body package="Com- Win32">unicodeStringBuffer: nBytes	" Answer an object which provides a buffer of &lt;nBytes&gt; bytes  for a character string in Unicode string encoding.  The message #asPointerParameter must be sent to the buffer when it is used as an argument of an external function.  The message #contents  is sent to the buffer to extract the value of an OUT string parameter after the function call. "	^Win32UnicodeStringResultBuffer new: nBytes</body><body package="Com- Win32">unicodeStringBufferChars: nChars	" Answer an object which provides a buffer of &lt;nBytes&gt; bytes  for a character string in Unicode string encoding.  The message #asPointerParameter must be sent to the buffer when it is used as an argument of an external function.  The message #contents  is sent to the buffer to extract the value of an OUT string parameter after the function call. "	^Win32UnicodeStringResultBuffer newChars: nChars</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>locale services</category><body package="Com- Win32">LANGIDFROMLCID: lcid	"Answer a LANGID from the LCID &lt;lcid&gt;"	" Win32ExternalInterface LANGIDFROMLCID: Win32ExternalInterface lcidEnglish "	" Win32ExternalInterface LANGIDFROMLCID: Win32ExternalInterface lcidGerman "	"#define LANGIDFROMLCID(lcid)   ((WORD) (lcid))"	^lcid</body><body package="Com- Win32">MAKELANGID: usPrimaryLanguage _: usSubLanguage	"Create a language identifier from a primary language identifier and a secondary language identifier.usPrimaryLanguage Specifies the primary language identifier. This parameter can be one of the LANG_* predefined values. For a user-defined language, usPrimaryLanguage can be a value in the range 0x0200 to 0x03FF. All other values are reserved for system use. usSubLanguage Specifies the secondary language identifier. This parameter can be one of the SUBLANG_* values. For a user-defined secondary language, usSubLanguage can be a value in the range 0x20 to 0x3F. All other values are reserved for system use. The following three combinations of usPrimaryLanguage and usSubLanguage have special meaning: Primary language	ID Secondary language		ID Meaning LANG_NEUTRAL	SUBLANG_NEUTRAL 		Language neutral  LANG_NEUTRAL	SUBLANG_DEFAULT 		User default language  LANG_NEUTRAL	SUBLANG_SYS_DEFAULT 	System default language  "	" Win32ExternalInterface MAKELANGID: LANG_NEUTRAL _: SUBLANG_DEFAULT. "	" Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_DEFAULT. "	" Win32ExternalInterface MAKELANGID: LANG_GERMAN _: SUBLANG_DEFAULT. "	"#define MAKELANGID(p, s) ((((WORD) (s)) &lt;&lt; 10) | (WORD) (p))"	^( usSubLanguage bitShift: 10 ) | ( usPrimaryLanguage )</body><body package="Com- Win32">MAKELCID: langID _: sortID	" Answer the LCID corresponding to the given language and sort ID values.wLanguageID Specifies the language identifier. This parameter is a combination of a primary language identifier and a secondary language identifier and is usually created by using the MAKELANGID macro. wSortID Specifies the sort identifier. The following sort identifiers are defined: Value 							Meaning SORT_DEFAULT  				Specifies the default sort. SORT_JAPANESE_XJIS 		Specifies Japanese XJIS order. SORT_JAPANESE_UNICODE 	Specifies Japanese Unicode order. SORT_CHINESE_BIG5 			Specifies Chinese BIG5 order. SORT_CHINESE_UNICODE 	Specifies Chinese Unicode order. SORT_KOREAN_KSC 			Specifies Korean KSC order. SORT_KOREAN_UNICODE 	Specifies Korean Unicode order."	" Win32ExternalInterface 		MAKELCID: ( Win32ExternalInterface MAKELANGID: LANG_NEUTRAL _: SUBLANG_DEFAULT ) 		_: SORT_DEFAULT. "	" Win32ExternalInterface 		MAKELCID: ( Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_ENGLISH_UK ) 		_: SORT_DEFAULT. "	" Win32ExternalInterface 		MAKELCID: ( Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_ENGLISH_US ) 		_: SORT_DEFAULT. "	" Win32ExternalInterface 		MAKELCID: ( Win32ExternalInterface MAKELANGID: LANG_GERMAN _: SUBLANG_ENGLISH_US ) 		_: SORT_DEFAULT. "	"#define MAKELCID(lgid, srtid)  ((DWORD)((((DWORD)((WORD  )(srtid))) &lt;&lt; 16) |  \                                         ((DWORD)((WORD  )(lgid)))))"	"^CIntegerType unsignedLong cast: (...)"	^( sortID bitShift: 16 ) + langID"////  A locale ID is a 32 bit value which is the combination of a//  language ID, a sort ID, and a reserved area.  The bits are//  allocated as follows:////       +-------------+---------+-------------------------+//       |   Reserved  | Sort ID |      Language ID        |//       +-------------+---------+-------------------------+//        31         20 19     16 15                      0   bit//"</body><body package="Com- Win32">PRIMARYLANGID: lgid	"Extracts a primary language identifier from a language identifier."	" ( Win32ExternalInterface 		PRIMARYLANGID: ( Win32ExternalInterface MAKELANGID: LANG_NEUTRAL _: SUBLANG_DEFAULT ) ) 		= LANG_NEUTRAL"	" ( Win32ExternalInterface 		PRIMARYLANGID: ( Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_ENGLISH_UK ) ) 		= LANG_ENGLISH "	" ( Win32ExternalInterface 		PRIMARYLANGID: ( Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_ENGLISH_US ) )		= LANG_ENGLISH " 	" ( Win32ExternalInterface 		PRIMARYLANGID: ( Win32ExternalInterface MAKELANGID: LANG_GERMAN _: SUBLANG_GERMAN_SWISS ) )		= LANG_GERMAN "	"#define PRIMARYLANGID(lgid)    ((WORD  )(lgid) &amp; 0x3ff)"	^lgid bitAnd: 16r3FF</body><body package="Com- Win32">SUBLANGID: lgid	"Extracts a sublanguage identifier from a language identifier. "	" ( Win32ExternalInterface 		SUBLANGID: ( Win32ExternalInterface MAKELANGID: LANG_NEUTRAL _: SUBLANG_DEFAULT ) ) 		= SUBLANG_DEFAULT "	" ( Win32ExternalInterface 		SUBLANGID: ( Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_ENGLISH_UK ) ) 		= SUBLANG_ENGLISH_UK "	" ( Win32ExternalInterface 		SUBLANGID: ( Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_ENGLISH_US ) )		= SUBLANG_ENGLISH_US " 	" ( Win32ExternalInterface 		SUBLANGID: ( Win32ExternalInterface MAKELANGID: LANG_GERMAN _: SUBLANG_GERMAN_SWISS ) )		= SUBLANG_GERMAN_SWISS "	"#define SUBLANGID(lgid)        ((WORD  )(lgid) &gt;&gt; 10) "	^lgid bitShift: -10</body><body package="Com- Win32">defaultSystemLCID	" Answer the default locale ID of the system. "	^Win32KernelDLL current GetSystemDefaultLCID</body><body package="Com- Win32">defaultUserLCID	" Answer the default locale ID of the current user. "	^Win32KernelDLL current GetUserDefaultLCID</body><body package="Com- Win32">isLcidInstalled: anLCID	"Test whether the locale identifier is both supported and installed."	" Win32ExternalInterface isLcidInstalled: Win32ExternalInterface lcidEnglish "	" Win32ExternalInterface isLcidInstalled: Win32ExternalInterface lcidGerman "	" Win32ExternalInterface isLcidInstalled: 0 "	^Win32KernelDLL current IsValidLocale: anLCID asInteger _: LCID_INSTALLED</body><body package="Com- Win32">isLcidSupported: anLCID	"Test whether the locale identifier is supported."	" Win32ExternalInterface isLcidSupported: Win32ExternalInterface lcidEnglish "	" Win32ExternalInterface isLcidSupported: Win32ExternalInterface lcidGerman "	" Win32ExternalInterface isLcidSupported: 0 "	^Win32KernelDLL current IsValidLocale: anLCID asInteger _: LCID_SUPPORTED</body><body package="Com- Win32">lcidEnglish	"Answer a simple default LCID for the English language. The default sublanguage and sort order is used."	" Win32ExternalInterface lcidEnglish "	" ^Win32ExternalInterface makeLcidFromPrimaryLangid: LANG_ENGLISH "	^1033</body><body package="Com- Win32">lcidGerman	"Answer a simple default LCID for the German language. The default sublanguage and sort order is used."	" Win32ExternalInterface lcidGerman "	" ^Win32ExternalInterface makeLcidFromPrimaryLangid: LANG_GERMAN "	^1031</body><body package="Com- Win32">lcidNeutral	"Answer a simple default LCID for the neutral language."	^ 0</body><body package="Com- Win32">makeLcidFromLangid: wLanguageID	"Creates a locale identifier from language and default sort identifiers."	" Win32ExternalInterface 		makeLcidFromLangid: ( Win32ExternalInterface MAKELANGID: LANG_NEUTRAL _: SUBLANG_DEFAULT ) "	" Win32ExternalInterface 		makeLcidFromLangid: ( Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_ENGLISH_UK ) "	" Win32ExternalInterface 		makeLcidFromLangid: ( Win32ExternalInterface MAKELANGID: LANG_ENGLISH _: SUBLANG_ENGLISH_US ) "	" Win32ExternalInterface 		makeLcidFromLangid: ( Win32ExternalInterface MAKELANGID: LANG_GERMAN _: SUBLANG_ENGLISH_US ) "	^self MAKELCID: wLanguageID _: SORT_DEFAULT</body><body package="Com- Win32">makeLcidFromPrimaryLangid: primaryLanguageID	"Creates a locale identifier from language with the default sort and sublanguage identifiers."	" Win32ExternalInterface makeLcidFromPrimaryLangid: LANG_NEUTRAL "	" Win32ExternalInterface makeLcidFromPrimaryLangid: LANG_ENGLISH "	" Win32ExternalInterface makeLcidFromPrimaryLangid: LANG_GERMAN "	^self 		MAKELCID: (self MAKELANGID: primaryLanguageID _: SUBLANG_DEFAULT)		_: SORT_DEFAULT</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>private-accessing</category><body package="Com- Win32">clearCurrent	" Private - clear the current instance of the DLL if it has been opened. "	current notNil		ifTrue: [ self current: nil ].</body><body package="Com- Win32">current: aDLLBinding	"Private - specifiy the current instance for invoking API's in the DLL wrapped by the receiver."	current := aDLLBinding.</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>opening</category><body package="Com- Win32">open	" Answer a new instance of the receiver. "	^self new</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>subclass-initialization</category><body package="Com- Win32">getCurrent	"Private - get (open) an instance of the receiver."	^self open</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>subclass-code generation</category><body package="Com- Win32">typeDefinitionPools	" Answer a list of external type definition pools which are used in addition to the receiver's own privately defined external types to define the name space for compiling external declarations in the receiver. "	^#( )</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>accessing</category><body package="Com- Win32">closeCurrent	" Close the current instance of the DLL if it has been opened. "	current notNil		ifTrue: [			current close.			self current: nil ].</body><body package="Com- Win32">current	"Answer the current instance for invoking API's in the DLL wrapped by the receiver."	current isNil 		ifTrue: [ current := self getCurrent ].	^current</body><body package="Com- Win32">fileName	" Answer the name of the receiver's DLL file. "	| names |	names := self libraryFiles.	names size = 0 ifTrue: [^nil].	names size = 1 ifTrue: [^names first name].	self error: #ErrMultFilenames &lt;&lt; #com &gt;&gt; 'multiple file names'</body></methods><methods><class-id>External.Win32ExternalInterface class</class-id> <category>testing</category><body package="Com- Win32">isOpen	" Answer whether the DLL accessed by the receiver is open. "	^current notNil</body></methods><methods><class-id>External.Win32DynamicLinkLibrary</class-id> <category>testing</category><body package="Com- Win32">includesEntryPoint: anEntryPointName	" Answer whether the receiver contains an entry point named &lt;anEntryPointName&gt;. "	^self class libraryNamed: self class fileName 		includesEntryPoint: anEntryPointName</body></methods><methods><class-id>External.Win32DynamicLinkLibrary class</class-id> <category>testing</category><body package="Com- Win32">libraryNamed: aFileName includesEntryPoint: anEntryPointName	" Answer whether the DLL named &lt;aFileName&gt; contains an entry point named &lt;anEntryPointName&gt;. "	| dllHandle procAddress |	dllHandle := Win32KernelDLL current LoadLibrary: aFileName.	procAddress := Win32KernelDLL current GetProcAddress: dllHandle _: anEntryPointName.	^procAddress ~~ nil</body></methods><methods><class-id>External.Win32DynamicLinkLibrary class</class-id> <category>error reporting</category><body package="Com- Win32">osError: anInteger        "Create a walkback window describing an error condition        that was returned from the host operating system, as        indicated by anInteger"    ^"Error signal:" self error: ((#x1sOSError2s &lt;&lt; #com &gt;&gt; '&lt;1s&gt; ( OS error &lt;2s&gt; )')			expandMacrosWith: (self osErrorMessage: anInteger)			with: (anInteger printStringRadix: 16))</body><body package="Com- Win32">osErrorMessage: errorCode        " Answer the error message string corresponding to the host error code &lt;anInteger&gt;."	" In VS 3.1, this was provided by OperatingSystem, the unique instance		of OperatingSystemInformation. "	| resultReference |	[	resultReference := nil asValueReference.	Win32KernelDLL current FormatMessage: "FormatMessageFromSystem" 4096 		_: NULL  		_: errorCode 		 _: NULL  		_: resultReference 		_: 1024  " buffer size "		 _: NULL.	^resultReference value	] 		on: Error		do: [ :ex | ^(#unknownError &lt;&lt; #com &gt;&gt; '(unknown error)') asString ]</body></methods><methods><class-id>External.Win32CommonDialogDLL</class-id> <category>API operations</category><body package="Com- Win32">GetOpenFileName: lpOpenFileName	" Invoke the GetOpenFileName API to open the Windows file dialog.  Raise an exception if the function fails.  Answer whether the function succeeded. "		| succeeded parentWindow returnSemaphore |	parentWindow := Dialog defaultParentWindow.	returnSemaphore := Semaphore new.	[succeeded := self		invokeGetOpenFileName: lpOpenFileName asPointerParameter.	returnSemaphore signal] fork.	parentWindow		ifNil: [returnSemaphore wait]		ifNotNil:			[| windowManager |			windowManager := parentWindow windowManager.			[succeeded isNil]				whileTrue: [windowManager processNextNonCloseEventFor: parentWindow]].	succeeded ifFalse: [self reportDialogFailure: self CommDlgExtendedError].	^succeeded</body><body package="Com- Win32">GetSaveFileName: lpOpenFileName	" Invoke the GetSaveFileName API to open the Windows file dialog.  Raise an exception if the function fails.  Answer whether the function succeeded. "		| succeeded parentWindow returnSemaphore |	parentWindow := Dialog defaultParentWindow.	returnSemaphore := Semaphore new.	[succeeded := self		invokeGetSaveFileName: lpOpenFileName asPointerParameter.	returnSemaphore signal] fork.	parentWindow		ifNil: [returnSemaphore wait]		ifNotNil:			[| windowManager |			windowManager := parentWindow windowManager.			[succeeded isNil]				whileTrue: [windowManager processNextNonCloseEventFor: parentWindow]].	succeeded ifFalse: [self reportDialogFailure: self CommDlgExtendedError].	^succeeded</body></methods><methods><class-id>External.Win32CommonDialogDLL</class-id> <category>private-error handling</category><body package="Com- Win32">reportDialogFailure: errorCode	" Private - an error occurred trying to open the dialog "	errorCode ~= 0 		ifTrue: [ ^self class osError: errorCode ].</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>subclass-buffer management</category><body package="Com- Win32">allocateBuffer	" Private - allocate the buffer for obtaining the result value. "	self useFixedSpace		ifTrue: [ self allocateBufferInFixedSpace ]		ifFalse: [ self allocateBufferInExternalMemory ].</body><body package="Com- Win32">allocateBufferInExternalMemory	" Private - allocate the buffer for obtaining the result value in externalMemory. "	self needsFinalization.	buffer := Win32BufferManager allocateBuffer: self bufferElementType		count: self bufferElementCount.</body><body package="Com- Win32">allocateBufferInFixedSpace	" Private - allocate the buffer for obtaining the result value in Smalltalk fixed space object memory. "	self bufferElementCount &gt; 1		ifTrue: [ ^self allocateBufferInExternalMemory ].	buffer := self bufferElementType newInFixedSpace.  "newInFixedSpace: self bufferElementCount."</body><body package="Com- Win32">releaseBuffer	" Private - release the buffer if necessary. "	buffer notNil		ifTrue: [ 			self doesNotNeedFinalization.			self releaseBufferContents.			buffer isPointer				ifTrue: [ Win32BufferManager releaseBuffer: buffer ].			buffer := nil ].</body><body package="Com- Win32">releaseBufferContents	" Private - release the contents of the buffer if necessary.   Should be reimplemented by subclasses which manage buffers containing pointers to owned memory. "</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">buffer	" Private - answer the buffer. "	^buffer</body><body package="Com- Win32">bufferElementCount	" Private - answer the number of elements in the buffer.  Should be reimplemented by subclasses which allocate multi-element buffers. "	^1</body><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	self subclassResponsibility.</body><body package="Com- Win32">notEmpty	"for compatibility with ValueReference"	^ self value notNil</body><body package="Com- Win32">value	" Private - answer the value that corresponds to the contents of the buffer. "	^value</body><body package="Com- Win32">value: aValue	" Private - set the value that corresponds to the contents of the buffer. "	value := aValue.</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>converting</category><body package="Com- Win32">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	^buffer</body><body package="Com- Win32">isValueReference 	^ true</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>subclass-initialization</category><body package="Com- Win32">initialize	" Private - initialize a new instance. "	self allocateBuffer.</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>subclass-testing</category><body package="Com- Win32">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	^Win32BufferManager useFixedSpace</body><body package="Com- Win32">useGCHeapServices	" Private - answer whether the more-expensive but safer garbage-collection form of external heap allocation should be used for the receiver. "	^Win32BufferManager useGCHeapServices</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>releasing</category><body package="Com- Win32">enforceRelease	" Release any resources acquired to construct the buffer. "	^ self privateRelease.</body><body package="Com- Win32">release	self callIsDispensable</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>private</category><body package="Com- Win32">privateRelease	" Release any resources acquired to construct the buffer. "	self releaseBuffer.	super release.</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>finalization</category><body package="Com- Win32">finalize	^ self enforceRelease.</body></methods><methods><class-id>External.Win32Buffer</class-id> <category>notices</category><body package="Com- Win32">enforceInvalidation	self doesNotNeedFinalization.	buffer enforceInvalidation.	buffer := nil.</body></methods><methods><class-id>External.Win32ResultValueBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">checkResultValue	" Private - check whether there is a result value in the buffer which has not yet been brought into the appropriate Smalltalk value.  If so, bring it in and release any resources which are no longer needed. "	buffer isNil		ifTrue: [ ^self ].	" bring the value in "	self value: self getResultValue.	self releaseBuffer.</body><body package="Com- Win32">getResultValue	" Private - bring the buffer contents into a Smalltalk value.  Release any external resources which are no longer needed.  Answer the value. "	self subclassResponsibility.</body></methods><methods><class-id>External.Win32ResultValueBuffer</class-id> <category>accessing</category><body package="Com- Win32">contents	" Answer the contents of the buffer as a suitable Smalltalk value. "	self checkResultValue.	^value</body></methods><methods><class-id>External.Win32ResultValueBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">new	" Answer a new instance of the receiver. "	^super new initialize</body></methods><methods><class-id>External.Win32ArrayResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">checkResultValueFrom: startIndex to: stopIndex	" Private - check whether there is a result value in the buffer which has not yet been brought into the appropriate Smalltalk value.  If so, bring it in and release any resources which are no longer needed. "	buffer isNil		ifTrue: [ ^self ].	" bring the value in "	self value: ( self getResultValuesFrom: startIndex to: stopIndex ).	self releaseBuffer.</body><body package="Com- Win32">getResultValue	" Private - convert the contents into a array.  Answer the array. "	^self getResultValuesFrom: 1 to: self bufferElementCount</body><body package="Com- Win32">getResultValuesFrom: startIndex to: stopIndex 	" Private - convert the contents into a array.  Answer the array. "	| nValues anArray lpData |	buffer isPointer 		ifFalse: [self error: #ErrNotImplemented &lt;&lt; #com &gt;&gt; 'not yet implemented'].	" believe this is not gonna be polymorphic, sigh [DL 11-May-97] "	nValues := stopIndex - startIndex + 1.	anArray := Array new: nValues.	lpData := buffer copy.	startIndex &gt; 1 ifTrue: [lpData += (startIndex - 1)].	1 to: nValues		do: 			[:i | 			anArray at: i put: lpData contents.			lpData increment].	^anArray</body></methods><methods><class-id>External.Win32ArrayResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementCount	" Private - answer the number of elements in the buffer. "	^bufferElementCount</body><body package="Com- Win32">bufferElementCount: anInteger	" Private - specify the number of elements in the buffer. "	bufferElementCount := anInteger.</body><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^bufferElementType</body><body package="Com- Win32">bufferElementType: aType	" Private - specify the type of the elements in the buffer. "	bufferElementType := aType.</body></methods><methods><class-id>External.Win32ArrayResultBuffer</class-id> <category>accessing</category><body package="Com- Win32">atAllPut: aValue 	"Put &lt;aValue&gt; in every element of the receiver's buffer."	| lpData |	lpData := buffer copy.	self bufferElementCount timesRepeat: [		lpData contents: aValue.		lpData increment ].</body><body package="Com- Win32">copyFrom: startIndex to: stopIndex	" Answer the contents for the buffer for the elements in the rangs &lt;startIndex&gt; to &lt;stopIndex&gt;, inclusive.  Any other elements in the buffer are ignored and no longer accessible. "	self checkResultValueFrom: startIndex to: stopIndex.	^value</body></methods><methods><class-id>External.Win32ArrayResultBuffer</class-id> <category>subclass-testing</category><body package="Com- Win32">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" force to external memory, at least until you figure out how to work with fixed space "	^false</body></methods><methods><class-id>External.Win32ArrayResultBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">new	" Answer a new instance of the receiver. "	" insist on a buffer allocation size "	self shouldNotImplement.</body><body package="Com- Win32">type: aType count: nElements	" Answer a new instance of the receiver with a buffer for &lt;nElements&gt; of type &lt;aType&gt;. "	^self basicNew		bufferElementType: aType;		bufferElementCount: nElements;		initialize;		yourself</body></methods><methods><class-id>External.Win32DialogBox</class-id> <category>accessing</category><body package="Com- Win32">propertyAt: key         "Answer the value associated with key        in the properties dictionary."    properties isNil ifTrue: [ ^nil ].    ^properties at: key ifAbsent: [ nil ]</body><body package="Com- Win32">propertyAt: key ifAbsent: aBlock        "Answer the value associated with key        in the properties dictionary; if absent,         answer the result of evaluating aBlock."    properties isNil ifTrue: [ ^aBlock value ].    ^properties at: key ifAbsent: aBlock</body><body package="Com- Win32">propertyAt: key ifAbsentPut: aBlock        "Answer the value associated with key        in the properties dictionary; if absent, evaluate		aBlock, put the evaluation result at key, and        answer the result."    properties isNil ifTrue: [ properties := IdentityDictionary new ].    ^properties at: key ifAbsent: [ properties at: key put: aBlock value ]</body><body package="Com- Win32">propertyAt: key put: aValue        "Set the value associated with key        in the properties dictionary."    properties isNil ifTrue: [ properties := IdentityDictionary new ].    aValue isNil ifTrue: [ ^properties removeKey: key ifAbsent: [ ] ].    ^properties at: key put: aValue</body><body package="Com- Win32">title	"Answer the string to be placed in the title bar of the dialog."	^self propertyAt: #title</body><body package="Com- Win32">title: aString	"Specify the string to be placed in the title bar of the dialog."	self propertyAt: #title put: aString.</body></methods><methods><class-id>External.Win32DialogBox</class-id> <category>subclass-operation</category><body package="Com- Win32">getActiveWindow	" Private - answer the active window handle. "	| aWindowHandle |	aWindowHandle := self getActiveWindowHandle.	aWindowHandle == nil		ifTrue: [ ^nil ].	^Win32WindowHandle fromPointer: aWindowHandle</body><body package="Com- Win32">getActiveWindowHandle	" Private - answer the active window handle. "	" following is modelled after Dialog #warn: "	| parentWindow |	^(parentWindow := Dialog defaultParentWindow) isNil		ifTrue: [nil]		ifFalse: [CVoidType void pointerType cast: parentWindow windowHandle]" VS was:    hwndActive := WindowHandle queryActive.    ( Notifier findWindow: hwndActive ) isNil        ifTrue: [ hwndActive := nil ].	^hwndActive"</body><body package="Com- Win32">getOwnerWindowHandleForDialog	" Private - answer the owner window to be disabled when the dialog is opened. "	^( parent == nil		ifTrue: [ self getActiveWindowHandle ]		ifFalse: [ parent windowHandle ] )."***VS implementation was:    parent isWindow ifFalse: [        parent := Notifier findWindow: WindowHandle queryActive ].***"</body></methods><methods><class-id>External.Win32DialogBox</class-id> <category>subclass-accessing</category><body package="Com- Win32">addFlag: aFlag	" Private - add &lt;aFlag&gt; to the set of defined flags. "	style := ( style | aFlag ).</body><body package="Com- Win32">flags	" Private - answer the set of flags which are set for the receiver. "	^style</body><body package="Com- Win32">removeFlag: aFlag	" Private - remove &lt;aFlag&gt; from the set of defined flags. "	style := ( style bitXor: aFlag ).</body><body package="Com- Win32">setFlags: flagsValue	" Private - make &lt;flagsValue&gt; be the set of defined flags. "	style := flagsValue.</body><body package="Com- Win32">setOwner: aWindow	"Private -sets the owner of the Dialog box."	parent := aWindow "windowHandle".	^parent"VS implementation of ownership/disabling was:    owner isWindow        ifTrue: [ parent := owner ]        ifFalse: [ parent := owner mainView.                       parent isWindow ifFalse: [                            parent := Notifier findWindow: WindowHandle queryActive ]]."</body><body package="Com- Win32">style	" Answer the style option flags defined for the dialog. "	^style</body><body package="Com- Win32">style: anInteger	" Set the style option flags defined for the dialog. "	style := anInteger.</body></methods><methods><class-id>External.Win32DialogBox</class-id> <category>private-accessing</category><body package="Com- Win32">properties	"Private - Answer the properties Dictionary."	^properties</body><body package="Com- Win32">properties: aDictionary        "Private - Set the properties Dictionary."	properties := aDictionary.</body></methods><methods><class-id>External.Win32DialogBox</class-id> <category>subclass-initialization</category><body package="Com- Win32">initialize	" Private - initialize a new instance of the receiver. "</body></methods><methods><class-id>External.Win32DialogBox</class-id> <category>subclass-testing</category><body package="Com- Win32">hasFlag: aFlag	" Private - answer whether &lt;aFlag&gt; is in the set of defined flags. "	^( style bitAnd: aFlag ) &gt; 0</body></methods><methods><class-id>External.Win32DialogBox class</class-id> <category>instance creation</category><body package="Com- Win32">new	" Answer a new instance of the receiver. "	^super new initialize</body></methods><methods><class-id>External.Win32CommonSystemDialog</class-id> <category>configuring</category><body package="Com- Win32">owner: aWindow	"Sets the owner of the Dialog box."	self setOwner: aWindow.</body></methods><methods><class-id>External.Win32CommonSystemDialog</class-id> <category>testing</category><body package="Com- Win32">cancelled	" Answer whether the user cancelled the dialog without making a selection. "	self subclassResponsibility.</body></methods><methods><class-id>External.Win32ResourceHandle</class-id> <category>comparing</category><body package="Com- Win32">= aHandle        "Answer true if the receiver is the same as aHandle."    "&lt;primitive: 55&gt;"    (aHandle "isExternalHandle" isKindOf: Win32ResourceHandle )		ifFalse: [ ^false ].    ^self asInteger = aHandle asInteger</body><body package="Com- Win32">hash        "Private - Answer the integer hash of the receiver."    ^self asInteger</body></methods><methods><class-id>External.Win32ResourceHandle</class-id> <category>converting</category><body package="Com- Win32">asHandleParameter	"Answer the receiver in a form suitable for passing as a host handle parameter to an external function call."	^handle</body><body package="Com- Win32">asInteger        "Answer the receiver converted to an Integer."	handle == nil 		ifTrue: [ ^0 ].	"^self asUnsignedInteger"	" This seems unnecessarily heavy-handed - where did it come from?		Believe normal case is that the handle is simply an integer anyway.		[DL 04-Apr-96] "	^CIntegerType unsignedLong cast: self handle asInteger</body></methods><methods><class-id>External.Win32ResourceHandle</class-id> <category>printing</category><body package="Com- Win32">printHandleOn: aStream        "Private - Append an ASCII representation of the receiver's handle to &lt;aStream&gt;."	self asInteger printOn: aStream paddedWith: $0 to: 8 base: 16 .</body><body package="Com- Win32">printOn: aStream        "Private - Append the ASCII representation of         the receiver to aStream."	aStream nextPutAll: self class name, '{'.	self printHandleOn: aStream.	aStream nextPut: $}.</body></methods><methods><class-id>External.Win32ResourceHandle</class-id> <category>accessing</category><body package="Com- Win32">handle	" Answer the handle. "	^handle</body><body package="Com- Win32">handle: aHandle	" Set the handle to &lt;aHandle&gt;. "	handle := aHandle.</body></methods><methods><class-id>External.Win32ResourceHandle</class-id> <category>testing</category><body package="Com- Win32">isValid        "Answer whether the receiver is a valid (non-NULL)         handle."    "^self ~= self class nullValue"	^self asInteger ~= 0</body></methods><methods><class-id>External.Win32ResourceHandle class</class-id> <category>external-transformations</category><body package="Com- Win32">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery. "	self subclassResponsibility.</body><body package="Com- Win32">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an instance of the Win32 handle represented by the receiver.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^Win32RegKeyHandleResultBuffer for: self 		type: self baseCType</body></methods><methods><class-id>External.Win32ResourceHandle class</class-id> <category>instance attributes</category><body package="Com- Win32">sizeInBytes        "Private - answer the size in bytes of objects of       the receiver class."    ^4</body></methods><methods><class-id>External.Win32ResourceHandle class</class-id> <category>instance creation</category><body package="Com- Win32">fromHandle: aHandle	" Answer a new instance of the receiver for the host handle &lt;aHandle&gt;. "	( aHandle == nil  or: [ aHandle asInteger = 0 ] )		ifTrue: [ ^nil ].	^self new		handle: aHandle;		yourself</body></methods><methods><class-id>External.Win32WindowHandle</class-id> <category>operations</category><body package="Com- Win32">getClientRect	" Answer the rectangle describing the client area in the receiver. "	| resultReference |	resultReference := nil asValueReference.	Win32UserDLL current GetClientRect: self		_: resultReference.	^resultReference value</body><body package="Com- Win32">getDC	" Answer the receiver's device context "	"??? Wrap the raw DC handle in some suitable wrapper to encapsulate GUI operations, no??"	^Win32UserDLL current GetDC: self</body><body package="Com- Win32">releaseDC: aDeviceContext	" Release the device context from the receiver "	^Win32UserDLL current ReleaseDC: self _: aDeviceContext</body><body package="Com- Win32">sendMessage: aMsg	^Win32UserDLL current SendUnicodeMessage: self _: aMsg _: 0 _: 0</body><body package="Com- Win32">sendMessage: aMsg wParam: wParam lParam: lParam	^Win32UserDLL current SendUnicodeMessage: self _: aMsg _: wParam _: lParam</body><body package="Com- Win32">setFocus	Win32UserDLL current SetFocus: self</body></methods><methods><class-id>External.Win32WindowHandle</class-id> <category>testing</category><body package="Com- Win32">isValid        "Private - Answer true if the receiver is a valid window         handle."	^super isValid and: [ Win32UserDLL current IsWindow: self ]</body></methods><methods><class-id>External.Win32WindowHandle class</class-id> <category>instance creation</category><body package="Com- Win32">findWindow: aClassName windowName: aWindowName	" Win32WindowHandle findWindow: 'XLMAIN' windowName: nil "	^Win32WindowHandle fromHandle: ( Win32UserDLL current FindWindow: aClassName _:aWindowName )</body><body package="Com- Win32">getDesktopWindow        "Answer the handle of the desktop window."	" Win32WindowHandle getDesktopWindow "	^self fromHandle: Win32UserDLL current GetDesktopWindow</body><body package="Com- Win32">queryActive        "Answer the handle of the window that is currently active."	" Win32WindowHandle queryActive "	^self fromHandle: Win32UserDLL current GetActiveWindow</body><body package="Com- Win32">queryFocus        "Answer the handle of the window with the input focus."	" Win32WindowHandle queryFocus "	^self fromHandle: Win32UserDLL current GetFocus</body></methods><methods><class-id>External.Win32WindowHandle class</class-id> <category>external-transformations</category><body package="Com- Win32">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery. "	^Win32ExternalInterface current HWND</body></methods><methods><class-id>External.Win32AdvApiDLL</class-id> <category>API operations</category><body package="Com- Win32">RegCloseKey: hKey        "Close the RegDB key hKey"	| statusCode |	statusCode := self invokeRegCloseKey: ( self asKeyParameter: hKey asHandleParameter ).	^ statusCode = 0		ifTrue: [ 0 ]		ifFalse: [self error: ( self class osErrorMessage: statusCode)].</body><body package="Com- Win32">RegCreateKey: hKey _: aString _: resultReference        "Create or open the subkey named aString under hParentKey         in the RegDB"	| resultBuffer statusCode |	resultBuffer := Win32RegKeyHandle resultValueBuffer.	statusCode := self invokeRegCreateKey: ( self asKeyParameter: hKey asHandleParameter )		_: aString asUnicodeParameter		_: resultBuffer asPointerParameter.	statusCode = 0		ifTrue: [ resultReference value: resultBuffer contents ].	^statusCode</body><body package="Com- Win32">RegCreateKeyEx: hKey _: aString _: resultReference        "Create or open the subkey named aString under hParentKey         in the RegDB"	| resultBuffer statusCode dispositionBuffer |	resultBuffer := Win32RegKeyHandle resultValueBuffer.	dispositionBuffer := DWORD gcMalloc.	statusCode := self 			invokeRegCreateKeyEx: ( self asKeyParameter: hKey asHandleParameter ) 			_: aString asUnicodeParameter 			_: nil 			_: nil 			_: REG_OPTION_NON_VOLATILE 			_: KEY_ALL_ACCESS 			_: nil 			_: resultBuffer asPointerParameter 			_: dispositionBuffer.	statusCode = 0		ifTrue: [ resultReference value: resultBuffer contents ]		ifFalse: [self error: ( self class osErrorMessage: statusCode)]. 	^statusCode</body><body package="Com- Win32">RegCreateKeyEx: hKey _: aString _: samDesired _: resultReference	"Create or open the subkey named aString under hParentKey         in the RegDB"	| resultBuffer statusCode dispositionBuffer |	resultBuffer := Win32RegKeyHandle resultValueBuffer.	resultBuffer securityAccess: samDesired.	dispositionBuffer := DWORD gcMalloc.	statusCode := self				invokeRegCreateKeyEx: (self asKeyParameter: hKey asHandleParameter)				_: aString asUnicodeParameter				_: 0				_: nil				_: REG_OPTION_NON_VOLATILE				_: samDesired				_: nil				_: resultBuffer asPointerParameter				_: dispositionBuffer.	statusCode = 0		ifTrue: 			[resultReference value: resultBuffer contents]		ifFalse: [self error: (self class osErrorMessage: statusCode)].	^statusCode</body><body package="Com- Win32">RegDeleteKey: hParentKey _: aString        "Delete the subkey named aString under hParentKey in the RegDB"	^self invokeRegDeleteKey: ( self asKeyParameter: hParentKey asHandleParameter )		_: aString asUnicodeParameter</body><body package="Com- Win32">RegDeleteKeyEx: hParentKey _: aString _: samDesired        "Delete the subkey named aString under hParentKey in the RegDB"	^self invokeRegDeleteKeyEx: ( self asKeyParameter: hParentKey asHandleParameter )		_: aString asUnicodeParameter		_: samDesired		_: 0.</body><body package="Com- Win32">RegEnumKey: hKey _: anInteger _: resultReference _: ignored	"This function is provided for compatibility with Windows version 3.1. Win32-based applications should use the RegEnumKeyEx function."        "Copy the name of the (N-1)th subkey of hKey in the RegDB         into buffer"	| cbBuffer resultBuffer result |	cbBuffer := 512.	resultBuffer := Win32ExternalInterface unicodeStringBuffer: cbBuffer.	result := self invokeRegEnumKey: ( self asKeyParameter: hKey asHandleParameter )		_: anInteger 		_: resultBuffer asPointerParameter 		_: cbBuffer.	result = 0		ifTrue: [ resultReference value: resultBuffer contents ]		ifFalse: [ resultBuffer enforceRelease ].  " polite, although not perhaps strictly necessary "	^result</body><body package="Com- Win32">RegEnumValue: hKey    _: iValue    _: resultReferenceValue    _: ignoredCbValue    _: dwReserved    _: type    _: resultReferenceData    _: ingnoredCbData        "Enumerate the values of the specified key."	| result cbBuffer valueBuffer cbValueBuffer typeBuffer lpByteData cbDataBuffer |	cbBuffer := 512.	valueBuffer := Win32ExternalInterface unicodeStringBuffer: cbBuffer.	cbValueBuffer := Win32ExternalInterface scalarResultBufferFor: #LONG.	cbValueBuffer contents: cbBuffer.	typeBuffer := Win32ExternalInterface scalarResultBufferFor:  #LONG.	typeBuffer contents: type.	lpByteData := Win32ExternalInterface current BYTE malloc: cbBuffer.	cbDataBuffer := Win32ExternalInterface scalarResultBufferFor: #LONG.	cbDataBuffer contents: cbBuffer.	[        result := self invokeRegEnumValue: ( self asKeyParameter: hKey asHandleParameter )            _: iValue            _: valueBuffer asPointerParameter            _: cbValueBuffer asPointerParameter            _: dwReserved            _: typeBuffer asPointerParameter            _: lpByteData            _: cbDataBuffer asPointerParameter.	result = 0		ifTrue: [			resultReferenceValue value: valueBuffer contents.				"?? trimNullTerminator asNormalizedString ??"			"Assert isTrue: [ resultReferenceValue value size = cbValueBuffer contents ]." "right??"			resultReferenceData value: ( self class decodeBytes: lpByteData 				length: cbDataBuffer contents				type: typeBuffer contents ).			]		ifFalse: [ valueBuffer enforceRelease ].  " polite, although not perhaps strictly necessary "	] ensure: [		lpByteData freePointer ].	^result</body><body package="Com- Win32">RegOpenKey: hParentKey _: keyName _: resultReference	"This function is provided for compatibility with Windows version 3.1. Win32-based applications should use the RegOpenKeyEx function. "        "Open the subkey named keyName of hParentKey in the RegDB,         and answer the key handle in hKey"	| resultBuffer lpSubKey statusCode |	resultBuffer := Win32RegKeyHandle resultValueBuffer.	" subkey name can be either a string name or		an integer value identifying one of the 		predefined key values "	lpSubKey := ( keyName isString		ifTrue: [ keyName copyToHeapUnicode ]		ifFalse: [ CIntegerType unsignedLong malloc			contents: keyName "asInteger";			yourself ] ).	[	statusCode := self invokeRegOpenKey: ( self asKeyParameter: hParentKey asHandleParameter )		_: lpSubKey		_: resultBuffer asPointerParameter.	statusCode = 0		ifTrue: [ resultReference value: resultBuffer contents ].	] ensure: [		lpSubKey freePointer ].	^statusCode</body><body package="Com- Win32">RegOpenKeyEx: hKey _: keyName _: ulOptions _: samDesired _: resultReference        "Open the subkey named keyName of hParentKey in the RegDB, and answer the key handle in hKey. "	" &lt;ulOptions&gt; - Reserved; must be zero. "	| resultBuffer lpSubKey statusCode |	resultBuffer := Win32RegKeyHandle resultValueBuffer.	resultBuffer securityAccess: samDesired.	" subkey name can be either a string name or		an integer value identifying one of the 		predefined key values "	lpSubKey := ( keyName isString		ifTrue: [ keyName copyToHeapUnicode ]		ifFalse: [ CIntegerType unsignedLong malloc			contents: keyName;			yourself ] ).	[	statusCode := self invokeRegOpenKeyEx: ( self asKeyParameter: hKey asHandleParameter )		_: lpSubKey		_: ulOptions 		_: samDesired 		_: resultBuffer asPointerParameter.	statusCode = 0		ifTrue: [ resultReference value: resultBuffer contents ].	] ensure: [		lpSubKey freePointer ].	^statusCode</body><body package="Com- Win32">RegQueryValue: hKey _: nameString _: resultReference _: ignored	"This function is provided for compatibility with Windows version 3.1. Win32-based applications should use the RegQueryValueEx function."	"Copy the value of the subkey of hKey named nameString in the RegDB         into valueString; copy the length of the string (including NULL terminator)         into cbValue"	| resultReferenceType resultReferenceDataSize |	resultReferenceType := nil asValue.	resultReferenceDataSize := nil asValue.	^self		RegQueryValueEx: hKey		_: nameString		_: 0		_: resultReferenceType		_: resultReference		_: resultReferenceDataSize</body><body package="Com- Win32">RegQueryValueEx: hKey    _: nameString    _: lpReserved     _: resultReferenceType    _: resultReferenceData    _: resultReferenceDataSize        "Query the value of the specified hkey, and copy the value to         the buffer."	| result typeBuffer cbBuffer lpByteData cbDataBuffer |	typeBuffer := Win32ExternalInterface scalarResultBufferFor: #LONG.	cbBuffer := 512.	lpByteData := Win32ExternalInterface current BYTE malloc: cbBuffer.	cbDataBuffer := Win32ExternalInterface scalarResultBufferFor: #LONG.	cbDataBuffer contents: cbBuffer.	[	result := self invokeRegQueryValueEx: ( self asKeyParameter: hKey asHandleParameter )		_: nameString asUnicodeParameter		_: lpReserved 		_: typeBuffer  asPointerParameter		_: lpByteData		_: cbDataBuffer asPointerParameter.	result = 0		ifTrue: [			resultReferenceType value: typeBuffer contents.			resultReferenceDataSize value: cbDataBuffer contents.			resultReferenceData value: ( self class decodeBytes: lpByteData 				length: resultReferenceDataSize value				type: resultReferenceType value ) ]	] ensure: [		lpByteData freePointer ].	^result</body><body package="Com- Win32">RegSetValue: hKey _: nameString _: typeInteger _: valueString _: cbValue	"This function is provided for compatibility with Windows version 3.1. Win32-based applications should use the RegSetValueEx function, which allows an application to set any number of named values of any data type."        "Set the value of the subkey of hKey named nameString in the RegDB         to valueString; typeInteger is ignored, since the type is always a String"	Tools.Note notYetImplemented</body><body package="Com- Win32">RegSetValueEx: hKey _: valueName _: reservedMustBeZero _: typeInteger _: valueBytes  _: cbValue        "Set the value of the subkey of hKey named nameString in the RegDB         to valueString; typeInteger is ignored, since the type is always a String"	| result lpszName lpData |	lpszName := ( valueName == nil		ifTrue: [ nil ]		ifFalse: [ valueName copyToHeapUnicode ] ).	lpData := ( valueBytes == nil		ifTrue: [ nil ]		ifFalse: [ valueBytes copyToHeap ] ).	[	result := self invokeRegSetValueEx: ( self asKeyParameter: hKey asHandleParameter )		_: lpszName		_: reservedMustBeZero		_: typeInteger		_: lpData		_: cbValue.	] ensure: [		lpszName == nil ifFalse: [ lpszName freePointer ].		lpData == nil ifFalse: [ lpData freePointer ] ].	^result</body><body package="Com- Win32">regDeleteKey: keyName from: hKey flags: flags	"Try to use RegDeleteKey() first which is only available on Windows XP 64 bit, Windows Vista and later OSs.	On earlier 32bit systems  RegDeleteKey() is instead - in this case 32/64bit flags are ignored"	| result  |	result := (self includesEntryPoint: 'RegDeleteKeyExW')				ifTrue: 					[self 						RegDeleteKeyEx: hKey						_: keyName						_: flags]				ifFalse: [self RegDeleteKey: hKey _: keyName].	result ~= 0 ifTrue: [^nil]</body></methods><methods><class-id>External.Win32AdvApiDLL</class-id> <category>private-argument utilities</category><body package="Com- Win32">asKeyParameter: hKey	Tools.Note ISSUE.  " Is this really necessary?  Argument coercion		testing doesn't seem willing to hammer integers		into pointers for us, which is very sad.  [DL 24-Mar-96] "	hKey isInteger		ifTrue: [ ^Win32ExternalInterface current HKEY cast: hKey ].	^hKey</body></methods><methods><class-id>External.Win32AdvApiDLL class</class-id> <category>private-value decoding</category><body package="Com- Win32">conversions        "Private - answer a Dictionary mapping between         Registration Database type codes &amp; their         conversion selectors"    ^Dictionary new        at: REG_DWORD put: #decodeDword:length: ;        at: REG_SZ put: #decodeSz:length: ;	  at: REG_EXPAND_SZ put: #decodeSz:length: ;        at: REG_BINARY put: #decodeBinary:length: ;        yourself</body><body package="Com- Win32">decodeBinary: lpByteData length: anInteger        "Private - answer a Smalltalk ByteArray decoded from the given         arguments"	^(#BinaryDecodingNotSupported &lt;&lt; #com &gt;&gt; 'Binary decoding not supported') asString</body><body package="Com- Win32">decodeBytes: lpByteData length: length type: aTypeCode 	"Private - convert the data value specified by the parameters         into an equivalent Smalltalk object."	| selector |	selector := self conversions at: aTypeCode				ifAbsent: [self error: #ErrUnsupportedType &lt;&lt; #com &gt;&gt; 'Unsupported data type'].	^self 		perform: selector		with: lpByteData		with: length</body><body package="Com- Win32">decodeDword: lpByteData length: anInteger        "Private - answer a Smalltalk Integer decoded         from the given arguments"	"Assert isTrue: [ anInteger = CIntegerType long sizeof ]."	^( CIntegerType long pointerType cast: lpByteData ) contents</body><body package="Com- Win32">decodeSz: lpByteData length: anInteger        "Private - answer a Smalltalk string decoded from the given         arguments"	| aString |	aString := ( CIntegerType char pointerType cast: lpByteData ) copyUnicodeStringFromHeap.	"Assert isTrue: [ aString size = ( anInteger - 1 ) ]."	^aString</body></methods><methods><class-id>External.Win32MemoryReadWriteStream</class-id> <category>accessing</category><body package="Com- Win32">contents	"Answer with a copy of the receiver's collection from 1 to readLimit."	^self copyFrom: 1 to: self size</body><body package="Com- Win32">copyFrom: firstIndex to: lastIndex        "Answer the subcollection of the collection over         which the receiver is streaming, from firstIndex         to lastIndex."	| nBytes buffer |	nBytes := lastIndex - firstIndex + 1.	buffer := self bufferClass new: nBytes.	address asPointer 		copyAt: firstIndex - 1 " 0-based C pointer arithmetic "		to: buffer		size: nBytes		startingAt: 1.	^buffer</body><body package="Com- Win32">flush	"Write any unwritten information. For this class - do nothing."	Tools.Note ISSUEin72;notYetTested."implemented only in stream which sends       self subclassResponsibility"	^ self</body><body package="Com- Win32">next	"Answer the next object accessible by the receiver and advance the stream position."	| elements |	self atEnd		ifTrue: [			self pastEnd.			^nil ].	elements := self next: 1.	^elements isNil		ifTrue: [ nil ]		ifFalse: [ elements at: 1 ]</body><body package="Com- Win32">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next &lt;anInteger&gt; elements of the receiver into &lt;aSequenceableCollection&gt; 	starting at &lt;startIndex&gt; in &lt;aSequenceableCollection&gt;.  Answer &lt;aSequenceableCollection&gt;."	| nBytes stopIndex |	anInteger &lt; 1 ifTrue: [^aSequenceableCollection].	self atEnd ifTrue: [^Stream incompleteNextCountSignal raiseRequestWith: 0].	aSequenceableCollection class isBits 		ifFalse: [self error: #ErrBufferBeBytes &lt;&lt; #com &gt;&gt; 'buffer must be bytes'].	nBytes := anInteger * self bufferElementSizeInBytes.	stopIndex := position + nBytes.	stopIndex &gt; readLimit 		ifTrue: [^self error: #ErrReadEOS &lt;&lt; #com &gt;&gt; 'read beyond end of stream'].	address asPointer 		copyAt: position		to: aSequenceableCollection		size: nBytes		startingAt: startIndex.	" 0-based C pointer arithmetic works correctly because we haven't yet incremented position "	self position: stopIndex.	^aSequenceableCollection</body><body package="Com- Win32">next: anInteger putAll: aSequenceableCollection startingAt: startIndex 	"Store the &lt;anInteger&gt; elements of &lt;aSequenceableCollection&gt; starting	at &lt;startIndex&gt; into the next &lt;anInteger&gt; elements of the receiver.	Answer &lt;aSequenceableCollection&gt;"	| nBytes stopIndex buffer |	aSequenceableCollection isNil ifTrue: [^nil].	aSequenceableCollection class isBits 		ifFalse: [self error: #ErrBufferBeBytes &lt;&lt; #com &gt;&gt; 'buffer must be bytes'].	nBytes := anInteger * self bufferElementSizeInBytes.	stopIndex := position + nBytes.	[stopIndex &gt; writeLimit] whileTrue: [self grow].	buffer := self 				constructByteBufferOn: (anInteger = aSequenceableCollection size 						ifTrue: 							[aSequenceableCollection sizeInBytes &lt; nBytes 								ifTrue: [self error: #ErrSourceBufferTooSmall &lt;&lt; #com &gt;&gt; 'source buffer too small'].							aSequenceableCollection]						ifFalse: [aSequenceableCollection copyFrom: 1 to: anInteger]).	" not very efficient... "		[address asPointer 		copyAt: position		from: buffer		size: nBytes		startingAt: startIndex	" 0-based C pointer arithmetic works correctly because we haven't yet incremented position "] 			ensure: 				[buffer ~~ aSequenceableCollection ifTrue: [self releaseBuffer: buffer]].	position := stopIndex.	readLimit &lt; position ifTrue: [readLimit := position].	^aSequenceableCollection</body><body package="Com- Win32">nextPut: anObject        "Write &lt;anObject&gt; to the receiver stream.         Answer &lt;anObject&gt;."	^self nextPutAll: ( self bufferClass with: anObject )</body><body package="Com- Win32">size	"Answer the size of the collection the receiver streams over. "	^readLimit := readLimit max: position</body></methods><methods><class-id>External.Win32MemoryReadWriteStream</class-id> <category>private-accessing</category><body package="Com- Win32">address	"Private - answer the external address on which the receiver is operating on. "	^address</body><body package="Com- Win32">address: anExternalAddress	"Private - set the external address on which the receiver is operating on. "	address := anExternalAddress.</body><body package="Com- Win32">bufferClass	" Private - answer the class to use for allocating a read buffer. "	encoding = #binary ifTrue: [^ByteArray].	encoding = #default ifTrue: [^ByteString].	"?? ^String defaultPlatformClass ??"	"TBD: encoding = #UCS_2 ifTrue: [ ^TwoByteString ]. "	self error: #ErrUnknownEncoding &lt;&lt; #com &gt;&gt; 'unknown stream encoding'</body><body package="Com- Win32">bufferElementSizeInBytes	" Private - answer the size in bytes of an element in a transfer buffer. "	encoding = #binary ifTrue: [^1].	encoding = #default ifTrue: [^1].	"TBD: encoding = #UCS_2 ifTrue: [ ^2 ]. "	self error: #ErrUnknownEncoding &lt;&lt; #com &gt;&gt; 'unknown stream encoding'</body><body package="Com- Win32">contentsSpecies	^self bufferClass</body><body package="Com- Win32">encoding	" Private - answer the encoding type specifying the form in which data is transferred. "	^encoding</body></methods><methods><class-id>External.Win32MemoryReadWriteStream</class-id> <category>private-operation</category><body package="Com- Win32">constructByteBufferOn: aByteObject 	" Private - answer a stable buffer from which &lt;aByteObject&gt; can be written. "	aByteObject class == ByteArray ifTrue: [^aByteObject].	aByteObject isString 		ifTrue: [^aByteObject asByteArrayEncoding: self encoding].	self error: #ErrUnsupportedBufferCls &lt;&lt; #com &gt;&gt; 'unsupported buffer class'</body><body package="Com- Win32">grow	"Private - Answer the receiver expanded to accommodate more elements."	| newSize |	newSize := address memorySize * 2 + 10.	address reallocateMemory: newSize.	writeLimit := readLimit := newSize.</body><body package="Com- Win32">pastEnd	"The receiver has attempted to read past the end, answer nil."	^Signal noHandlerSignal		handle: [ :ex | ex parameter proceedWith: nil ]		do: [ self class endOfStreamSignal raiseRequestFrom: self ]</body><body package="Com- Win32">releaseBuffer: aBuffer	" Private - release the buffer storage. "	aBuffer "isPointer" isExternalAddress		ifTrue: [ aBuffer free ].</body></methods><methods><class-id>External.Win32MemoryReadWriteStream</class-id> <category>character/binary</category><body package="Com- Win32">binary	"Set the receiver's buffer to be binary." 	encoding := #binary.</body><body package="Com- Win32">isBinary	"Answer whether the receiver's data is byte or character."	^encoding = #binary</body><body package="Com- Win32">isText	"Answer true if the receiver's data is character."	^self isBinary not</body><body package="Com- Win32">text	"Set the receiver's buffer to be character using platform encoding." 	encoding := #default.</body></methods><methods><class-id>External.Win32MemoryReadWriteStream</class-id> <category>converting</category><body package="Com- Win32">asHandleParameter	"Answer the receiver in a form suitable for passing as a host handle parameter to an external function call."	^self address asHandleParameter</body><body package="Com- Win32">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	^self address asPointerParameter</body></methods><methods><class-id>External.Win32MemoryReadWriteStream</class-id> <category>private-initializing</category><body package="Com- Win32">on: anExternalAddress 	" Private - Initialize the stream size and position.  Answer the receiver. "	self address: anExternalAddress.	position := 0.	readLimit := writeLimit := anExternalAddress memorySize.</body></methods><methods><class-id>External.Win32MemoryReadWriteStream</class-id> <category>testing</category><body package="Com- Win32">isReadable	"Answer whether the stream implements #next."	^true</body><body package="Com- Win32">isWritable	"Answer whether the stream implements #nextPut:."	^true</body></methods><methods><class-id>External.Win32MemoryReadWriteStream</class-id> <category>releasing</category><body package="Com- Win32">release	" Release the receiver and the associated memory. "	self address isNil		ifTrue: [ ^self ].	self address enforceRelease.	self address: nil.	position := readLimit := writeLimit := 0.	super release.</body></methods><methods><class-id>External.Win32MemoryReadWriteStream class</class-id> <category>instance creation</category><body package="Com- Win32">byteStreamOn: anExternalAddress	"Answer a new instance of the receiver on &lt;anExternalAddress&gt; which treats its contents as a byte stream." 	^( super on: anExternalAddress )		binary;		yourself</body><body package="Com- Win32">characterStreamOn: anExternalAddress	"Answer a new instance of the receiver on &lt;anExternalAddress&gt; which treats its contents as a character stream." 	^( super on: anExternalAddress )		text;		yourself</body><body package="Com- Win32">on: anExternalAddress	"Answer a new instance of the receiver on &lt;anExternalAddress&gt;."	^self characterStreamOn: anExternalAddress</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>accessing</category><body package="Com- Win32">at: anInteger	" Answer the byte at the 1-based index position &lt;anInteger&gt; in the memory referenced by the receiver. "	^self atOffset: anInteger - 1</body><body package="Com- Win32">at: anInteger put: aByte	" Replace the byte at the 1-based index position &lt;anInteger&gt; in the memory referenced by the receiver with &lt;aByte&gt;. "	self atOffset: ( anInteger - 1 ) put: aByte.</body><body package="Com- Win32">contents	"Answer the referent of the receiver.  The answered datum depends on the receiver's type. "	^self pointer contents</body><body package="Com- Win32">contents: data	"Replace the referent of the receiver with the argument data.  The argument can be one of many classes depending on the receiver's referent type.  If the argument is an invalid object in regards to the receiver's referent type, a CType illegalAssignmentSignal is raised."	^self pointer contents: data</body><body package="Com- Win32">copyAt: offset from: byteData size: dataSize startingAt: startIndex	"Write dataSize bytes to the receiver's address + offset from byteData starting at startIndex.  byteData must be a byte-type object.  startIndex must be a positive Integer, and startIndex + dataSize must be less than or equal to the size of byteData."	self pointer copyAt: offset 		from: byteData 		size: dataSize 		startingAt: startIndex.</body><body package="Com- Win32">copyAt: offset to: aByteObject size: nBytes startingAt: startIndex	" Read &lt;nBytes&gt; bytes from the memory referenced by the receiver, starting at the 0-based offset from the beginning of the memory block and storing into &lt;aByteObject&gt; starting at the 1-based index &lt;startIndex&gt;.   The &lt;startIndex&gt; must be a positive Integer, and &lt;startIndex&gt; + &lt;nBytes&gt; must be less than or equal to the size of &lt;aByteObject&gt;.  Answer &lt;aByteObject&gt;. "	self pointer copyAt: offset		to: aByteObject		size: nBytes		startingAt: startIndex.	^aByteObject</body><body package="Com- Win32">copyCStringFromHeap	" Answer a String containing the characters referenced by the receiver, which are stored in platform encoding in external memory. "	^self asPointer copyCStringFromHeap</body><body package="Com- Win32">copyFrom: start to: stop        "Answer a new collection containing the elements         of the receiver indexed from &lt;start&gt; through &lt;stop&gt;."	| nBytes bytes |	nBytes := stop - start + 1.	bytes := ByteArray new: nBytes.	self copyAt: ( start - 1 )  " convert to 0-based index "		to: bytes		size: nBytes		startingAt: 1.	^bytes</body><body package="Com- Win32">copyUnicodeStringFromHeap	" Answer a String containing the characters referenced by the receiver, which are stored in Unicode encoding in external memory. "	^self asPointer copyUnicodeStringFromHeap</body><body package="Com- Win32">replaceBytes: count with: aByteObject	" Destructively replace &lt;count&gt; bytes in the memory referenced by the receiver with the contents of &lt;aByteObject&gt;. "	self replaceBytesFrom: 1 to: count with: aByteObject startingAt: 1</body><body package="Com- Win32">replaceBytesFrom: start to: stop with: aByteObject startingAt: repStart 	"This destructively replaces elements from the 1-based index positions &lt;start&gt; to &lt;stop&gt; in the 	memory referenced by the receiver receiver starting at index &lt;repStart&gt; 	in the &lt;aByteObject&gt;.  Answer the receiver."	| nBytes |	nBytes := stop - start + 1.	self pointer copyAt: ( start - 1)  " convert to 0-based indexing "		from: aByteObject 		size: nBytes		startingAt: repStart.</body><body package="Com- Win32">type	" Answer the C data type of the memory referenced by the receiver. "	pointer == nil		ifTrue: [ ^nil ].	^pointer type</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>converting</category><body package="Com- Win32">asInteger	" Answer the memory address represented by the receiver as an integer. "	^pointer == nil ifTrue: [ 0 ] ifFalse: [ pointer asInteger ]</body><body package="Com- Win32">asPointer	"Answer the receiver as a pointer object."	^pointer</body><body package="Com- Win32">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	^pointer</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>testing</category><body package="Com- Win32">isExternalAddress	" Answer whether the receiver is an external memory address. "	^true</body><body package="Com- Win32">isNull	"Answer whether the receiver is a null pointer, otherwise answer false."	^self asInteger = 0</body><body package="Com- Win32">isValid	" Answer whether the receiver is a valid (non-NULL) address. "	"VS: ^self ~= self class nullValue"	^self asInteger ~= 0</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>comparing</category><body package="Com- Win32">= anAddress    "Answer whether the receiver represents the same memory location as &lt;anAddress&gt;."    ^self class == anAddress class and: [ self asInteger = anAddress asInteger ]</body><body package="Com- Win32">hash	"Answer with a SmallInteger unique to the receiver."	^self asInteger hash</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>subclass-releasing</category><body package="Com- Win32">finalizationRegistry	"Private - Answer the WeakRegistry to be used for finalizing instances of the receiver."	^SystemExternalResourcesRegistry currentRegistry</body><body package="Com- Win32">finalize    "The receiver is no longer referenced by any object in the system and is about to be destroyed.  Free the external memory referenced by the receiver. "    ^self privateRelease</body><body package="Com- Win32">releaseMemory        "Private - Release the memory at the receiver's address, if appropriate.  For Win32MemoryAddress, do nothing.  Subclasses that can release memory will override this method"</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>subclass-accessing</category><body package="Com- Win32">atOffset: anInteger	"Private - answer the byte at the zero relative offset &lt;anInteger&gt; in the memory referenced by the receiver."	^( CIntegerType unsignedChar pointerType cast: pointer ) at: anInteger</body><body package="Com- Win32">atOffset: anInteger put: aByte        " Private - set the byte at the zero relative offset &lt;anInteger&gt; in the memory referenced by the receiver to &lt;aByte&gt;. "	( CIntegerType unsignedChar pointerType cast: pointer ) at: anInteger put: aByte.</body><body package="Com- Win32">pointer	" Private - answer the receiver's address pointer. "	^pointer</body><body package="Com- Win32">pointer: aPointer	" Private - set the receiver's address pointer. "	pointer := aPointer.</body><body package="Com- Win32">referentType	" Private - answer the type of the data referenced by the receiver. "	^pointer isNil		ifTrue: [ ^self class defaultReferentType ]		ifFalse: [ pointer type referentType ]</body><body package="Com- Win32">referentType: aType	" Private - specify the type of the data referenced by the receiver. "	pointer notNil		ifTrue: [ self setPointerReferentType: aType ].</body><body package="Com- Win32">setPointerReferentType: aType	" Private - modify the element type of the memory referenced by the receiver to be &lt;aType&gt; *. "	| pointerClass retypedPointer |	pointerClass := ( aType isComposite		ifTrue: [ CCompositePointer ]		ifFalse: [ CPointer ] ).	retypedPointer := pointerClass newDatum: pointer datum		ofType: aType pointerType.	pointer enforceInvalidation.	pointer := retypedPointer.</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>private-session management</category><body package="Com- Win32">aboutToSaveImage	"Private - About to save the image.  Do nothing at this point - we should only release external memory when the image really shuts down, so the pointers get saved in the image and must be invalidated when the saved image is restarted. "</body><body package="Com- Win32">shutdownImage	"Private - The image session is being shut down.  Release allocated external memory. "	self isValid		ifTrue: [ self privateRelease ].</body><body package="Com- Win32">startupImage	"Private - The image session is being started.  Invalidate the receiver, since any external memory referenced in a previous session is no longer valid."	self privateInvalidate.</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>printing</category><body package="Com- Win32">printHexAddressOn: aStream		" Append a text description of the receiver's COM external memory address to &lt;aStream&gt; "	aStream nextPut: ${.	self isValid		ifTrue: [ self asInteger printOn: aStream paddedWith: $0 to: 8 base: 16 ]		ifFalse: [ aStream nextPutAll: 'invalid' ].	aStream nextPut: $}.</body><body package="Com- Win32">printOn: aStream	"Append a string representation of the receiver to &lt;aStream&gt;."	super printOn: aStream.	aStream space.	self printHexAddressOn: aStream.</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>releasing</category><body package="Com- Win32">destroyReference	" Destroy this memory reference (without releasing it).  This service is used to relinquish ownership of the memory. "	self invalidate.</body><body package="Com- Win32">enforceInvalidation	"Set the receiver to be invalid."	^ self privateInvalidate.</body><body package="Com- Win32">enforceRelease	^ self privateRelease</body><body package="Com- Win32">free	"Free the memory referenced by the receiver."	self privateRelease.</body><body package="Com- Win32">invalidate	self callIndicatesChangeNeeded</body><body package="Com- Win32">privateInvalidate	"Set the receiver to be invalid."	self pointer: nil.	self doesNotNeedFinalization.</body><body package="Com- Win32">release	"Release the memory referenced by the receiver."	self callIsDispensable.	^ super release</body></methods><methods><class-id>External.Win32MemoryAddress</class-id> <category>private</category><body package="Com- Win32">privateRelease	"Release the memory referenced by the receiver."	self isValid		ifTrue: [ self releaseMemory ].	self privateInvalidate.	super release.</body></methods><methods><class-id>External.Win32MemoryAddress class</class-id> <category>subclass-allocation</category><body package="Com- Win32">allocateMemoryForExternalCopy: nBytes flags: allocFlags	" Private - allocate &lt;nBytes&gt; of external memory to which a byte object will be copied. "	^self allocateMemory: nBytes flags: allocFlags</body><body package="Com- Win32">allocationFlagsClearMemory: allocFlags	" Private - answer whether the memory allocated by the receiver with flags &lt;allocFlags&gt; is initialized to zero. "	^( allocFlags bitAnd: GMEM_ZEROINIT ) ~= 0</body><body package="Com- Win32">copyToExternalMemory: aByteObject flags: allocFlags nBytesExtra: nBytesExtra clearExtraBytes: clearExtraBytes 	" Private - Copy &lt;aByteObject&gt; to allocated host memory and answer the address of that memory. "	| nBytes anExternalAddress |	aByteObject isNil ifTrue: [^nil].	aByteObject class isBits 		ifFalse: [self error: #ErrBeByteObject &lt;&lt; #com &gt;&gt; 'must be a byte object'].	aByteObject isString 		ifTrue: [self error: #ErrNoStringsAllowed &lt;&lt; #com &gt;&gt; 'no strings allowed at this point'].	nBytes := aByteObject sizeInBytes.	anExternalAddress := self 				allocateMemoryForExternalCopy: nBytes + nBytesExtra				flags: allocFlags.	anExternalAddress replaceBytes: nBytes with: aByteObject.	(clearExtraBytes and: [nBytesExtra &gt; 0]) 		ifTrue: 			[anExternalAddress 				replaceBytesFrom: nBytes + 1				to: nBytes + nBytesExtra				with: (ByteArray new: nBytesExtra)				startingAt: 1].	^anExternalAddress</body><body package="Com- Win32">getAllocationReferentTypeFor: allocationSpecification	" Private - answer the referent type to allocate for &lt;allocationSpecification&gt;. "	^allocationSpecification isInteger		ifTrue: [ self defaultReferentType ]		ifFalse: [ allocationSpecification ]  " a C type "</body><body package="Com- Win32">getAllocationSizeFor: allocationSpecification	" Private - answer the size in bytes to allocate for &lt;allocationSpecification&gt;. "	^allocationSpecification isInteger		ifTrue: [ allocationSpecification ]		ifFalse: [ allocationSpecification sizeof ]  " a C type "</body></methods><methods><class-id>External.Win32MemoryAddress class</class-id> <category>instance creation</category><body package="Com- Win32">allocateMemory: allocationSpecification	" Allocate a block of external memory according to &lt;allocationSpecification&gt;, which can either be an integer specifying the size in bytes of an untyped block of memory or a C type describing the memory.  Answer a new instance of the receiver referencing the newly allocated memory. "	^self allocateMemory: allocationSpecification 		flags: self defaultAllocationFlags</body><body package="Com- Win32">allocateMemory: allocationSpecification flags: allocFlags	" Allocate a block of external memory according to &lt;allocationSpecification&gt;, which can either be an integer specifying the size in bytes of an untyped block of memory or a C type describing the memory.  The memory is allocated with the specified &lt;allocFlags&gt; of the memory allocator.   Answer a new instance of the receiver referencing the newly allocated memory. "	self subclassResponsibility.</body><body package="Com- Win32">copyStringToExternalMemory: aString	" Copy &lt;aString&gt; to external memory in platform string encoding with a trailing NULL character.  Answer a new instance of the receiver referencing the newly allocated memory. "	^self copyStringToExternalMemory: aString 		flags: self defaultAllocationFlags</body><body package="Com- Win32">copyStringToExternalMemory: aString flags: allocFlags	" Copy &lt;aString&gt; to external memory in platform string encoding with a trailing NULL character.  The memory is allocated with the specified &lt;allocFlags&gt; of the memory allocator.  Answer a new instance of the receiver referencing the newly allocated memory. "	| anAddress |	anAddress := self copyToExternalMemory: ( Win32ExternalInterface asPlatformStringBytes: aString )		flags: allocFlags		nBytesExtra: 1  " terminating NULL "		clearExtraBytes: true.	anAddress referentType: Win32ExternalInterface platformCharacterType.	^anAddress</body><body package="Com- Win32">copyToExternalMemory: aByteObject	" Copy &lt;aByteObject&gt; to allocated host memory and answer the address of that memory.  Strings are copied in default platform encoding with a trailing NULL character. "	^self copyToExternalMemory: aByteObject 		flags: self defaultAllocationFlags</body><body package="Com- Win32">copyToExternalMemory: aByteObject flags: allocFlags	" Copy &lt;aByteObject&gt; to allocated host memory and answer the address of that memory.  Strings are copied in default platform encoding with a trailing NULL character. "	^self copyToExternalMemory: aByteObject 		flags: allocFlags 		nBytesExtra: 0</body><body package="Com- Win32">copyToExternalMemory: aByteObject flags: allocFlags nBytesExtra: nBytesExtra	" Copy &lt;aByteObject&gt; to allocated host memory and answer the address of that memory.  Strings are copied in default platform encoding with a trailing NULL character.  Append &lt;nBytesExtra&gt; additional, which are zero-initialized if the allocation flags. "	aByteObject isString		ifTrue: [			^self copyToExternalMemory: ( Win32ExternalInterface asPlatformStringBytes: aByteObject ) 				flags: allocFlags 				nBytesExtra: nBytesExtra + 1  " ensure trailing NULL "				clearExtraBytes: true ].	^self copyToExternalMemory: aByteObject 		flags: allocFlags 		nBytesExtra: nBytesExtra 		clearExtraBytes: ( self allocationFlagsClearMemory: allocFlags )</body><body package="Com- Win32">copyUnicodeToExternalMemory: aString	" Copy &lt;aString&gt; to external memory in Unicode string encoding with a trailing NULL character.  Answer a new instance of the receiver referencing the newly allocated memory. "	^self copyUnicodeToExternalMemory: aString 		flags: self defaultAllocationFlags</body><body package="Com- Win32">copyUnicodeToExternalMemory: aString flags: allocFlags	" Copy &lt;aString&gt; to external memory in Unicode string encoding with a trailing NULL character.  The memory is allocated with the specified &lt;allocFlags&gt; of the memory allocator.  Answer a new instance of the receiver referencing the newly allocated memory. "	| anAddress |	anAddress := self copyToExternalMemory: ( Win32ExternalInterface asUnicodeStringBytes: aString )		flags: allocFlags		nBytesExtra: 2  " wide NULL "		clearExtraBytes: true.	anAddress referentType: Win32ExternalInterface unicodeCharacterType.	^anAddress</body><body package="Com- Win32">defaultAllocationFlags	" Answer the default allocation flags for instances of the receiver. "	^GMEM_MOVEABLE | GMEM_ZEROINIT</body><body package="Com- Win32">fromPointer: aPointer	"Answer a new instance of the receiver which references the external memory identified by &lt;aPointer&gt;. "	^self new pointer: aPointer</body></methods><methods><class-id>External.Win32MemoryAddress class</class-id> <category>subclass-accessing</category><body package="Com- Win32">defaultReferentType	"Answer the default type of the data referenced by instances of the receiver.  Unless otherwise specified, allocated memory is interpreted as a 'void *' reference. "	^CVoidType void</body></methods><methods><class-id>External.Win32MemoryAddress class</class-id> <category>accessing</category><body package="Com- Win32">sizeInBytes	" Answer the size in bytes of instance of the receiver. "	^CVoidType void pointerType dataSize</body></methods><methods><class-id>External.Win32PlatformStringResultBuffer</class-id> <category>accessing</category><body package="Com- Win32">cbResult: anInteger	" Specify the size in bytes of the result string to extract from the buffer.  This is typically obtained via a sibling OUT argument of the function call in which the receiver is being used. "	self checkCbResult: anInteger.	cbResult := anInteger.</body></methods><methods><class-id>External.Win32PlatformStringResultBuffer</class-id> <category>private-accessing</category><body package="Com- Win32">cb: nBytes	" Private - specify the size of the buffer to allocate. "	cb := nBytes.</body></methods><methods><class-id>External.Win32PlatformStringResultBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Win32">allocateBufferInExternalMemory	" Private - allocate the buffer for obtaining the result value in externalMemory. "	buffer := ( String new: cb ) copyToHeap.	Win32BufferManager registerPointer: buffer.</body></methods><methods><class-id>External.Win32PlatformStringResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^Win32ExternalInterface platformCharacterType</body></methods><methods><class-id>External.Win32PlatformStringResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">checkCbResult: anInteger 	" Private "	anInteger &gt; cb 		ifTrue: 			[self error: #ErrResultExceedBuffer &lt;&lt; #com &gt;&gt; 'result size cannot exceed buffer size']</body><body package="Com- Win32">getResultValue	" Private - convert the contents into a String.  Answer the string. "	self setTerminatingNullAtCbResult.	^buffer copyCStringFromHeap</body><body package="Com- Win32">setTerminatingNullAtCbResult	" Private "	cbResult notNil		ifTrue: [ 			| lpTerminatingNull |			lpTerminatingNull := buffer copy += cbResult.  " don't need to add 1, remember 0-based ptr arith "			lpTerminatingNull contents: 0 ].</body></methods><methods><class-id>External.Win32PlatformStringResultBuffer</class-id> <category>subclass-testing</category><body package="Com- Win32">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" force to external memory, at least until you figure out how to work with fixed space "	^false</body></methods><methods><class-id>External.Win32PlatformStringResultBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">new	" Answer a new instance of the receiver. "	" insist on a buffer allocation size "	self shouldNotImplement.</body><body package="Com- Win32">new: nBytes	" Answer a new instance of the receiver with a buffer of &lt;nBytes&gt;. "	^self basicNew		cb: nBytes;		initialize;		yourself</body></methods><methods><class-id>External.Win32UnicodeStringResultBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Win32">allocateBufferInExternalMemory	" Private - allocate the buffer for obtaining the result value in externalMemory. "	buffer := ( ByteArray new: cb ) copyToHeap.		"?? CIntegerType char malloc: cb ??"	Win32BufferManager registerPointer: buffer.</body></methods><methods><class-id>External.Win32UnicodeStringResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">checkCbResult: anInteger 	" Private "	anInteger = cb 		ifTrue: 			[self error: #ErrResultExceedBuffer &lt;&lt; #com &gt;&gt; 'result size cannot exceed buffer size']</body><body package="Com- Win32">getResultValue	" Private - convert the contents into a String.  Answer the string. "	self setTerminatingNullAtCbResult.	^Win32ExternalInterface stringFromUnicodePointer: buffer</body><body package="Com- Win32">setTerminatingNullAtCbResult	" Private "	cbResult notNil		ifTrue: [ 			| lpTerminatingNull |			lpTerminatingNull := ( CIntegerType char pointerType cast: buffer copy ) += cbResult.					 " don't need to add 1, remember 0-based ptr arith "			lpTerminatingNull contents: 0.			lpTerminatingNull increment.			lpTerminatingNull contents: 0 ].</body></methods><methods><class-id>External.Win32UnicodeStringResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^Win32ExternalInterface unicodeCharacterType</body></methods><methods><class-id>External.Win32UnicodeStringResultBuffer</class-id> <category>accessing</category><body package="Com- Win32">chars: anInteger	" Specify the size in bytes of the result string to extract from the buffer.  This is typically obtained via a sibling OUT argument of the function call in which the receiver is being used. "	self cb: anInteger * self bufferElementType sizeof</body><body package="Com- Win32">resultChars: anInteger	" Specify the size in bytes of the result string to extract from the buffer.  This is typically obtained via a sibling OUT argument of the function call in which the receiver is being used. "	self cbResult: anInteger * self bufferElementType sizeof</body></methods><methods><class-id>External.Win32UnicodeStringResultBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">newChars: nChars	^ self basicNew		chars: nChars;		initialize;		yourself</body></methods><methods><class-id>External.Win32GenericHandle</class-id> <category>notices</category><body package="Com- Win32">enforceInvalidation	handle := nil.</body><body package="Com- Win32">enforceRelease	self privateRelease</body></methods><methods><class-id>External.Win32GenericHandle</class-id> <category>marshaling</category><body package="Com- Win32">putBitmapIntoStgMedium: anStgMedium	anStgMedium unionMemberAt: #'u.hBitmap' put: handle.</body><body package="Com- Win32">putEnhancedMetaFileDataIntoStgMedium: anStgMedium	anStgMedium unionMemberAt: #'u.hEnhMetaFile' put: handle.</body><body package="Com- Win32">putMetaFileDataIntoStgMedium: anStgMedium	anStgMedium unionMemberAt: #'u.hMetaFilePict' put: handle.</body></methods><methods><class-id>External.Win32GenericHandle</class-id> <category>initialize-release</category><body package="Com- Win32">initialize	"Initialize a newly created instance. This method must answer the receiver."	self needsFinalization.</body></methods><methods><class-id>External.Win32GenericHandle</class-id> <category>finalization</category><body package="Com- Win32">finalize	self privateRelease</body><body package="Com- Win32">privateRelease	self isValid		ifTrue: [OSSystemSupport concreteClass new CloseHandle: handle]</body></methods><methods><class-id>External.Win32GenericHandle class</class-id> <category>external-transformations</category><body package="Com- Win32">baseCType	^Win32ExternalInterface current HANDLE</body></methods><methods><class-id>External.Win32GenericHandle class</class-id> <category>instance creation</category><body package="Com- Win32">fromEnhHandle: aHandle	^ self fromHandle: aHandle</body><body package="Com- Win32">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="Com- Win32">newFromHandle: aHandle	^ self fromHandle: aHandle</body></methods><methods><class-id>External.Win32ArgumentBuffer</class-id> <category>subclass-initializing</category><body package="Com- Win32">initialize	" Private - initialize a new instance. "	super initialize.	self initializeBuffer.</body><body package="Com- Win32">initializeBuffer	" Private - initialize the contents of the argument buffer to represent the argument value. "	self subclassResponsibility.</body></methods><methods><class-id>External.Win32ArgumentBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">for: aValue	" Allocate and initialize a new instance of the receiver for the argument value &lt;aValue&gt;. "	aValue size = 0  " nil or empty list "		ifTrue: [ ^nil ].  " satisfies #asPointerParameter and #release "	^self new		value: aValue;		initialize;		yourself</body></methods><methods><class-id>External.Win32StringPointerListBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Win32">releaseBufferContents	" Private - release the contents of the buffer if necessary. "	| lplpString lpString |	lplpString := buffer copy.	self bufferElementCount timesRepeat: [		lpString := lplpString contents.		lpString isNull 			ifFalse: [ lpString free ].		lplpString increment ].</body></methods><methods><class-id>External.Win32StringPointerListBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementCount	" Private - answer the number of elements in the buffer.  The value represented by a string pointer list buffer is a list of strings. "	^value size</body><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^Win32ExternalInterface platformStringPointerType</body></methods><methods><class-id>External.Win32StringPointerListBuffer</class-id> <category>subclass-initializing</category><body package="Com- Win32">copyStringToExternalMemory: aString	" Private - copy &lt;aString&gt; to external memory in a suitable encoding and answer the pointer. "	^aString copyToHeap</body><body package="Com- Win32">initializeBuffer	" Private - initialize the contents of the argument buffer with the list of string values. "	| lplpString lpString |	lplpString := buffer copy.	self value do: [ :aString |		lpString := self copyStringToExternalMemory: aString.		lplpString contents: lpString.		lplpString increment ].</body></methods><methods><class-id>External.Win32StringPointerListBuffer</class-id> <category>subclass-testing</category><body package="Com- Win32">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" force to external memory, at least until you figure out how to work with fixed space "	^false</body></methods><methods><class-id>External.ValueReference</class-id> <category>testing</category><body package="Com- Win32">isEmpty	" Answer whether the receiver references a value. "	^self value isNil</body><body package="Com- Win32">isValueReference	" Answer whether the receiver is a value reference which supports the #value and #value: accessing protocol. "	^true</body><body package="Com- Win32">notEmpty	" Answer whether the receiver references a value. "	^self isEmpty not</body></methods><methods><class-id>External.ValueReference</class-id> <category>printing</category><body package="Com- Win32">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt; "	super printOn: aStream.	aStream nextPutAll: ' on: '.	self printValueOn: aStream.</body><body package="Com- Win32">printValueOn: aStream	" Append a text description of value referenced by the receiver to &lt;aStream&gt; "	value printOn: aStream.</body></methods><methods><class-id>External.ValueReference</class-id> <category>accessing</category><body package="Com- Win32">value	" Answer the value referenced by the receiver. "	^value</body><body package="Com- Win32">value: aValue	" Set the value referenced by the receiver to &lt;aValue&gt;. "	value := aValue.</body></methods><methods><class-id>External.ValueReference class</class-id> <category>instance creation</category><body package="Com- Win32">on: aValue	" Answer a new instance of the receiver which references &lt;aValue&gt;. "	^self new value: aValue</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>API operations-utilities</category><body package="Com- Win32">CopyBitmap: bitmap 	^self invokeCopyImage: bitmap type: IMAGE_BITMAP cxDesired: 0 cyDesired: 0 flags: 0</body><body package="Com- Win32">MessageBeep: duration	" Make a beep. "	" UserDLL current MessageBeep: -1 "	self invokeMessageBeep: duration.	^true</body><body package="Com- Win32">MessageBoxEx: hWnd _: textString _: captionString _: style _: wLanguageId	" Open a Windows message box containing the message &lt;textString&gt; with &lt;caption&gt; as the title and suitable attributes per the type flags. "	| waitForResult parentWindow updateProcess error result |	parentWindow := Dialog defaultParentWindow.	waitForResult := Semaphore new.		[result := 			[self				invokeMessageBoxExW: hWnd asHandleParameter				_: textString asUnicodeParameter				_: captionString asUnicodeParameter				_: style				_: wLanguageId]					on: OsError					do: 						[:ex |						error := ex.						ex return: nil].	"hWnd asHandleParameter"	waitForResult signal]			fork.	updateProcess := 			[parentWindow				ifNotNil: [[parentWindow windowManager processNextEvent notNil] whileTrue]]					fork.	"endless loop"	waitForResult wait.	updateProcess terminate.	error		ifNotNil: 			[error				resetForReraise;				searchFrom: thisContext;				raise].	^result</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>API operations-clipboard</category><body package="Com- Win32">CloseClipboard	self invokeCloseClipboard.	^true</body><body package="Com- Win32">EmptyClipboard	self invokeEmptyClipboard.	^ true</body><body package="Com- Win32">GetClipboardData: uFormat	^HANDLE newOfAddress: (self invokeGetClipboardData: uFormat)</body><body package="Com- Win32">GetClipboardFormatName: uFormat _: resultReference _: ignored	| bufferSize resultBuffer nChars formatName |	bufferSize := 128.	resultBuffer := Win32ExternalInterface unicodeStringBufferChars: bufferSize.	nChars := self invokeGetClipboardFormatName: uFormat		_: resultBuffer asPointerParameter		_: bufferSize.	nChars &gt; 0		ifTrue: [			formatName := resultBuffer contents.			"Assert isTrue: [ formatName size = nChars ]."			resultReference value: formatName ]		ifFalse: [ resultBuffer enforceRelease ].  " polite, although not perhaps strictly necessary "	^nChars</body><body package="Com- Win32">GetClipboardOwner	| hWnd |	hWnd := self invokeGetClipboardOwner.	hWnd isNull		ifTrue: [ ^nil ].	^Win32WindowHandle fromHandle: hWnd</body><body package="Com- Win32">OpenClipboard: hWndNewOwner	^self invokeOpenClipboard: hWndNewOwner asHandleParameter</body><body package="Com- Win32">RegisterClipboardFormat: aString	" Register &lt;aString&gt; as the name of a user-defined clipboard format. "	^self invokeRegisterClipboardFormat: aString asUnicodeParameter</body><body package="Com- Win32">SetClipboardData: uFormat _: hMem	^HANDLE newOfAddress: (self invokeSetClipboardData: uFormat				_: hMem asHandleParameter)</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>API operations-windows</category><body package="Com- Win32">BringWindowToTop: aWindow		" Bring the window to the top of the display stack. "	^self invokeBringWindowToTop: aWindow asHandleParameter</body><body package="Com- Win32">FindWindow: lpClassName _: lpWindowName	| hWnd |	hWnd := self invokeFindWindowW: lpClassName asUnicodeParameter		_: lpWindowName asUnicodeParameter.	hWnd isNull		ifTrue: [	^nil ].	^hWnd</body><body package="Com- Win32">GetActiveWindow	| hWnd |	hWnd := self invokeGetActiveWindow.	hWnd isNull		ifTrue: [			"?? self osError ??"			^nil ].	^hWnd</body><body package="Com- Win32">GetClientRect: aWindow _: resultReference	| resultBuffer succeeded |	resultBuffer := Win32ExternalInterface structureResultBufferFor: #RECT		valueAction: [ :aStruct | Win32ExternalInterface rectangleFromStruct: aStruct ].	succeeded := self invokeGetClientRect: aWindow asHandleParameter		_: resultBuffer asPointerParameter.	succeeded		ifTrue: [ resultReference value: resultBuffer contents ].	^succeeded</body><body package="Com- Win32">GetDC: aWindow	^self invokeGetDC: aWindow asHandleParameter</body><body package="Com- Win32">GetDesktopWindow	^self invokeGetDesktopWindow</body><body package="Com- Win32">GetFocus	| hWnd |	hWnd := self invokeGetFocus.	hWnd isNull		ifTrue: [			"?? self osError ??"			^nil ].	^hWnd</body><body package="Com- Win32">IsWindow: aWindowHandle	^self invokeIsWindow: aWindowHandle asHandleParameter</body><body package="Com- Win32">IsWindowUnicode: aWindowHandle	^self invokeIsWindowUnicode: aWindowHandle asHandleParameter</body><body package="Com- Win32">ReleaseDC: aWindow _: aDeviceContext	^self invokeReleaseDC: aWindow asHandleParameter		_: aDeviceContext asHandleParameter</body><body package="Com- Win32">SendANSIMessage: aWindowHandle _: msg _: wParam _: lParam	" Send a message to an window. String parameters are expected/treated as ANSI.	Please see SendUnicodeMessage for more information."	^self		invokeSendMessageA: aWindowHandle asHandleParameter		_: msg		_: wParam asInteger		_: lParam asInteger</body><body package="Com- Win32">SendUnicodeMessage: aWindowHandle _: msg _: wParam _: lParam" 	Send a message to an window. 			Callers consciously have to decide whether they want to call the ANSI or the Unicode version of the function.	Depending on the called version, string (buffer) parameters are treated as Unicode/ANSI strings.		While Callers are strongly encuraged to use the Unicode version, the ANSI version of the method 	(which corresponds to the old implementation of SendMessage:) is kept to allow easy code adaptation.	"	^self		invokeSendMessageW: aWindowHandle asHandleParameter		_: msg		_: wParam asInteger		_: lParam asInteger</body><body package="Com- Win32">SetFocus: aWindow	| hwnd |	hwnd := self invokeSetFocus: aWindow asHandleParameter.	"?? hwnd isNull ifTrue: [ self osError ]. ??"	^hwnd</body><body package="Com- Win32">WindowFromPoint: aPoint	| hWnd |	hWnd := self invokeWindowFromPoint: 		( Win32ExternalInterface asPointStructure: aPoint ).	^hWnd isNull		ifTrue: [ nil ]		ifFalse: [ hWnd ]</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>examples API operations-windows</category><body package="Com- Win32">getWindowTextOf: aWindow	"The method uses SendMessageW (Unicode version) to retrieve the window text "	| bufferSize buffer |	bufferSize := 512.	buffer := self class unicodeStringBufferChars: bufferSize.	self		SendUnicodeMessage: aWindow		_: WM_GETTEXT		_: bufferSize		_: buffer asPointerParameter.	^buffer contents</body><body package="Com- Win32">setWindowTextOf: aWindow to: aString	"The method uses SendMessageW (Unicode version) to set the window text."	self SendUnicodeMessage: aWindow _: WM_SETTEXT _: nil _: aString asUnicodeParameter.</body></methods><methods><class-id>External.Win32FileDialog</class-id> <category>configuring</category><body package="Com- Win32">addAllFilesFilter	" Add the standard '*.*' all-files filter. "	self addFilter: '*.*' description: (#AllFiles &lt;&lt; #com &gt;&gt; 'All Files (*.*)') asString</body><body package="Com- Win32">addFilter: aFilter description: aDescription        "Add aFilter and aDescription to the list of File dialog        filters."    filters add: ( Association key: aFilter value: aDescription ).</body><body package="Com- Win32">addTextFilesFilter	" Add the standard '*.txt' text files filter. "	self addFilter: '*.txt' description: (#TextFilesTXT &lt;&lt; #com &gt;&gt; 'Text Files (*.TXT)') asString</body><body package="Com- Win32">allowMultiSelect	"Specifies that the File Name list box allows multiple selections"	self addFlag: OFN_ALLOWMULTISELECT.</body><body package="Com- Win32">defaultExtension: aString        "Specify the default file name extension.  If the user fails to enter an extension to the file name, this string will be appended to the file name. The string is the extension only, with no period separator (e.g. 'TXT'). "    self propertyAt: #defaultExtension put: aString.</body><body package="Com- Win32">defaultFilter: aString        "Specifies the string &lt;aString&gt; as the default filter of the File dialog."    self propertyAt: #defaultFilter put: aString.</body><body package="Com- Win32">fileMustExist	"Specifies that the user must enter correct path and file in the dialog box"	self addFlag: OFN_FILEMUSTEXIST.</body><body package="Com- Win32">fileSpec: aFileSpec        "Sets the initial fileName and directory of the edit control in the         File Dialog."	( ( aFileSpec includes: $: )	or: [ aFileSpec includes: $\ ] )		ifTrue: [ 			| aFilename aDirectory aFileName |			aFilename := aFileSpec asFilename.			aDirectory := aFilename head asFilename.			aDirectory definitelyExists				ifFalse: [ aDirectory := Filename defaultDirectory ].  " VSE was: Disk "			aFileName := aFilename tail.			self directory: aDirectory.			fileName := aFileName.			^self ].	" file name or simple pattern such as '*.*' or '*.txt' "	self directory: self class currentDirectory.	fileName := aFileSpec.</body><body package="Com- Win32">hideReadonly        "Hides the file dialog's Readonly check box. "	self addFlag: OFN_HIDEREADONLY.</body><body package="Com- Win32">noNetworkButton	"hides and disables the network button"	self addFlag: OFN_NONETWORKBUTTON.</body><body package="Com- Win32">overwritePrompt        "Prompt if the user attempts to overwrite a file"	self addFlag: OFN_OVERWRITEPROMPT.</body><body package="Com- Win32">owner: aWindow	"Sets the owner of the Dialog box."	super owner: aWindow.	"openFileNameStruct memberAt: #hwndOwner put: aWindow windowHandle."		" defer setting owner field until dialog opened "</body><body package="Com- Win32">setReadOnly	"causes the read only check box to be checked when the dialog box is created"	self addFlag: OFN_READONLY.</body><body package="Com- Win32">shareAware        "Allows a previously opened file to be opened         (e.g. change.log)"	self addFlag: OFN_SHAREAWARE.</body></methods><methods><class-id>External.Win32FileDialog</class-id> <category>subclass-accessing</category><body package="Com- Win32">dialogStructureFlags	" Private - answer the dialog box current flags. "	^openFileNameStruct memberAt: #Flags</body><body package="Com- Win32">dialogStructureFlags: flagsValue	" Private - set the dialog box current flags. "	flagsValue == nil		ifTrue: [ ^self ].	openFileNameStruct memberAt: #Flags put: flagsValue.</body></methods><methods><class-id>External.Win32FileDialog</class-id> <category>testing</category><body package="Com- Win32">cancelled	" Answer whether the user cancelled the dialog without making a selection. "	^pathName == nil</body><body package="Com- Win32">isReadOnlyChecked	" Answer whether the read only check box is selected by the user. "	^self hasFlag: OFN_READONLY</body></methods><methods><class-id>External.Win32FileDialog</class-id> <category>private-operation</category><body package="Com- Win32">includeSmalltalkFileFilters	"Private - Answer whether the standard Smalltalk development environment filters should be included in the dialog filters"	^( self propertyAt: #smalltalkFileFilters ) notNil</body><body package="Com- Win32">includeSmalltalkFileFilters: aBoolean	"Private - Specify whether to include the standard Smalltalk development environment filters in the dialog filters"	self propertyAt: #smalltalkFileFilters put: aBoolean.</body><body package="Com- Win32">installSmalltalkFileFilters	" Private - add the standard Smalltalk development environment filters and description "	self            addFilter: '*.st' description: (#SmalltalkFilesST &lt;&lt; #com &gt;&gt; 'Smalltalk Files (*.ST)') asString;		addFilter: '*.cls' description: (#ClassFilesCLS &lt;&lt; #com &gt;&gt; 'Class Files (*.CLS)') asString;		addFilter: '*.mth' description: (#MethodFilesMTH &lt;&lt; #com &gt;&gt; 'Method Files (*.MTH)') asString;            addFilter: '*.ini' description: (#InitializationFilesINI &lt;&lt; #com &gt;&gt; 'Initialization Files (*.INI)') asString;            addFilter: '*.log' description: (#LogFilesLOG &lt;&lt; #com &gt;&gt; 'Log Files (*.LOG)') asString;		yourself.</body></methods><methods><class-id>External.Win32FileDialog</class-id> <category>subclass-operation</category><body package="Com- Win32">allocateResources	" Private - allocate external resources needed to open the dialog. "	| fileNameBytes nMaxFile lpszFile aString |	" store a zero-terminated copy of the string in platform encoding in a stable string buffer "	fileNameBytes := Win32ExternalInterface asUnicodeStringBytes: 		( fileName, ( String with: ( Character value: 0 ) ) ).  " trailing NULL char "	"Assert isTrue: [ fileNameBytes size &gt;= ( fileName size + 1 ) ]."  " byte count vs. char count?? "	nMaxFile := fileNameBytes size max: 512.		"VS: Allocated 128-byte buffer to store 0-terminated fileName "	lpszFile := CIntegerType unsignedChar malloc: nMaxFile.	lpszFile copyAt: 0		from: fileNameBytes		size: fileNameBytes size		startingAt: 1.    openFileNameStruct        memberAt: #lpstrFile put: lpszFile;        memberAt: #nMaxFile put: nMaxFile;        memberAt: #lpstrFilter 		put: (self constructFilterString copyToHeapUnicode);        memberAt: #nFilterIndex		put: ( self propertyAt: #defaultFilterIndex );    "set by constructFilterString"        memberAt: #lpstrInitialDir 		put: (self directory asString copyToHeapUnicode).			"?? does trailing backslash on directory name matter ??"			"VS was: self directory drivePathName copyToHeap "    ( aString := self propertyAt: #defaultExtension ) notNil         ifTrue: [            openFileNameStruct memberAt: #lpstrDefExt put: (aString copyToHeapUnicode) ].    ( aString := self title ) notNil         ifTrue: [            openFileNameStruct memberAt: #lpstrTitle put: (aString asString copyToHeapUnicode)].	" put the structure in stable storage "	openFileNameStruct := openFileNameStruct copyToHeap.</body><body package="Com- Win32">cleanUp        "Private - Free resources allocated for the dialog."	self setFlags: self dialogStructureFlags.	self releaseResources.</body><body package="Com- Win32">clearDialogResults	" Private - clear the dialog return values. "	pathName := fileName := nil.</body><body package="Com- Win32">constructFilterString	" Private - construct a string containing all the filters in the form needed to pass to the dialog.  Set the #defFilterIndex property for the number of filters and answer the parameter string. "    | filterString filterIndex defaultFilterIndex defaultFilter |    self includeSmalltalkFileFilters        ifTrue: [ self installSmalltalkFileFilters ].    filterString := String new.    filterIndex := 0.    defaultFilterIndex := 0.    defaultFilter := self propertyAt: #defaultFilter.    filters do: [ :assoc |        filterIndex := filterIndex + 1.        assoc key = defaultFilter             ifTrue: [ defaultFilterIndex := filterIndex ].        "filterString := filterString, assoc value asAsciiZ, assoc key asAsciiZ."         "*** alternate implementation cobbled together from VW/OLE prototype              (seems to be working too hard here, but whatever)  [DL 10-Apr-96] ***"        filterString := filterString, assoc value, ' '.        filterString byteAt: filterString size put: 0.        filterString := filterString, assoc key, ' '.        filterString byteAt: filterString size put: 0.        ].    "*** VW: make sure the string ends with two NULL chars ***"    filterString := filterString, ' '.    filterString byteAt: filterString size put: 0.    self propertyAt: #defaultFilterIndex put: defaultFilterIndex.    ^filterString</body><body package="Com- Win32">getDialogResults	" Private - record the information specified by the user in the dialog. "	| directoryName nFileOffset |	self setFlags: self dialogStructureFlags.	pathName := ( openFileNameStruct memberAt: #lpstrFile) 		copyUnicodeStringFromHeap.	nFileOffset := openFileNameStruct memberAt: #nFileOffset.	directoryName := pathName copyFrom: 1 to: nFileOffset.	fileName := pathName copyFrom: nFileOffset + 1 to: pathName size.	"	Assert isTrue: [ ( pathName asFilename directory asString, '\' ) sameAs: directoryName ].	Assert isTrue: [ 		( ( pathName asFilename head ) sameAs: directoryName )		or: [ ( pathName asFilename head, '\' ) sameAs: directoryName ] ].	Assert isTrue: [ pathName asFilename tail sameAs: fileName ].	"	" set DirName to the directory selected by the user "	"DirName := Directory pathName: temp."	self class currentDirectory: directoryName asFilename.</body><body package="Com- Win32">openOpenDialog	" Private - open the Open File dialog "	self dialogStructureFlags: self flags.	self allocateResources.	openFileNameStruct memberAt: #hwndOwner		put: self getOwnerWindowHandleForDialog.	self clearDialogResults.	[	( Win32CommonDialogDLL current GetOpenFileName: openFileNameStruct )  " this can of course fail "		ifTrue: [ self getDialogResults ].  " false means user cancelled "	] ensure: [		self cleanUp ].</body><body package="Com- Win32">openSaveDialog	" Private - open the Save File dialog. "	self dialogStructureFlags: self flags.	self allocateResources.	openFileNameStruct memberAt: #hwndOwner		put: self getOwnerWindowHandleForDialog.	self clearDialogResults.	[	( Win32CommonDialogDLL current GetSaveFileName: openFileNameStruct )  " this can of course fail "		ifTrue: [ self getDialogResults ].  " false means user cancelled "	] ensure: [		self cleanUp ].</body><body package="Com- Win32">releaseResources	" Private - release the external resources allocated to open the dialog. "	( openFileNameStruct memberAt: #lpstrFile ) free.	( openFileNameStruct memberAt: #lpstrFilter ) free.	( openFileNameStruct memberAt: #lpstrInitialDir ) free.    ( self propertyAt: #defaultExtension ) notNil 		ifTrue: [  ( openFileNameStruct memberAt: #lpstrDefExt ) free ].    self title notNil         ifTrue: [ ( openFileNameStruct memberAt: #lpstrTitle ) free ].    openFileNameStruct free.    openFileNameStruct := nil.</body></methods><methods><class-id>External.Win32FileDialog</class-id> <category>accessing</category><body package="Com- Win32">defaultFilter        "Answers the default filter of the File dialog."    ^self propertyAt: #defaultFilter</body><body package="Com- Win32">directory        "Answer the selected directory."    ^self class currentDirectory</body><body package="Com- Win32">directory: aDirectory	"Set the initial directory.  Check if the directory exists first,	because otherwise isDirectory may fail when the path cannot	be found, e.g.: after unmounting a removable device"	(aDirectory definitelyExists and: [aDirectory isDirectory])		ifTrue: [self class currentDirectory: aDirectory]</body><body package="Com- Win32">fileName        "Answer the name of the selected file."    ^fileName</body><body package="Com- Win32">pathName        "Answer the path name of the selected file."    ^pathName</body></methods><methods><class-id>External.Win32FileDialog</class-id> <category>opening</category><body package="Com- Win32">open        "Brings up the open file dialog."	self openOpenDialog.</body><body package="Com- Win32">openFile        "Brings up the default open file dialog.  The title is set to 'Open File'        and fileSpec is set to '*.*'. "    self openFile: '*.*'.</body><body package="Com- Win32">openFile: patternString        "Brings up the default open file dialog.  The title is set to 'Open File'        and fileSpec is set to patternString. "	self openFileTitle: (#OpenFile &lt;&lt; #com &gt;&gt; 'Open File') asString pattern: patternString</body><body package="Com- Win32">openFileTitle: aTitleString pattern: patternString        "Brings up the default open file dialog.  The title is set to &lt;aTitleString&gt;        and fileSpec is set to &lt;patternString&gt;. "    self title: aTitleString.    patternString notNil 		ifTrue: [ self fileSpec: patternString ].    self        hideReadonly;        shareAware;        addAllFilesFilter;        addTextFilesFilter.    ImageConfiguration isDevelopment        ifTrue: [ self includeSmalltalkFileFilters: true ].    ( self propertyAt: #defFilter ) isNil         ifTrue: [ self defaultFilter: '*.*' ].    self openOpenDialog.</body><body package="Com- Win32">openTitle: aTitle fileSpec: aFileSpec showFileInButton: showFileIn        "Private - Kept for backward compatibility.         Create an Open... dialog box titled aTitle initialized to         aFileSpec file specification"	self title: aTitle;		fileSpec: aFileSpec;            hideReadonly;            shareAware;		addAllFilesFilter;		addTextFilesFilter.    ( self propertyAt: #defaultFilter ) isNil 		ifTrue: [ self defaultFilter: '*.*' ].    self openOpenDialog.</body><body package="Com- Win32">save        "Brings up the save file dialog."	self openSaveDialog.</body><body package="Com- Win32">saveFile: aString        "Brings up the save file dialog with aString as the         default name.  The title is set to 'Save File'. "    self saveTitle: (#SaveFile &lt;&lt; #com &gt;&gt; 'Save File') asString fileName: aString.</body><body package="Com- Win32">saveTitle: aTitle fileName: aFileSpec        "Brings up the file save dialog with aTitle and aString         as the default name."    self title: aTitle;            fileSpec: aFileSpec;            hideReadonly;            overwritePrompt;		addAllFilesFilter;		addTextFilesFilter.    self openSaveDialog.</body></methods><methods><class-id>External.Win32FileDialog</class-id> <category>subclass-initialization</category><body package="Com- Win32">initialize        "Private - Initialize openFileNameStruct"	super initialize.	openFileNameStruct := Win32ExternalInterface current OPENFILENAMEW new.	openFileNameStruct memberAt: #lStructSize		put: openFileNameStruct sizeof.	fileName := String new.	filters := OrderedCollection new.	self setFlags: OFN_NOCHANGEDIR.</body></methods><methods><class-id>External.Win32FileDialog class</class-id> <category>opening</category><body package="Com- Win32">openFile        " Brings up the default open file dialog.  The title is set to 'Open File' and fileSpec is set to '*.*'.  Answer the path name of the file selected by the user. "	" Win32FileDialog openFile "	^self new		openFile;		pathName</body><body package="Com- Win32">openFile: patternString        "Brings up the default open file dialog.  The title is set to 'Open File' and fileSpec is set to patternString.  Answer the path name of the file selected by the user. "	" Win32FileDialog openFile: '*.txt' "	^self new		openFile: patternString;		pathName</body><body package="Com- Win32">openFileTitle: aTitleString pattern: patternString        "Brings up the default open file dialog.  The title is set to 'Open File' and fileSpec is set to patternString.  Answer the path name of the file selected by the user. "	" Win32FileDialog openFileTitle: 'Open File' pattern: '*.txt' "	^self new		openFileTitle: aTitleString pattern: patternString;		pathName</body><body package="Com- Win32">saveFile: aString        "Brings up the save file dialog with &lt;aString&gt; as the default name.  The title is set to 'Save File'.  Answer the path name of the file selected by the user. "	" Win32FileDialog saveFile: 'Untitled.txt' "	^self new		saveFile: aString;		pathName</body><body package="Com- Win32">saveTitle: aTitle fileName: aString        "Brings up the file save dialog with &lt;aTitle&gt; as the title and &lt;aString&gt; as the default name.  Answer the path name of the file selected by the user. "	" Win32FileDialog saveTitle: 'Save As' fileName: 'Untitled.txt' "	^self new		saveTitle: aTitle fileName: aString;		pathName</body></methods><methods><class-id>External.Win32FileDialog class</class-id> <category>accessing</category><body package="Com- Win32">currentDirectory	" Answer the current directory for file dialogs. "	^DirName</body></methods><methods><class-id>External.Win32FileDialog class</class-id> <category>private-session management</category><body package="Com- Win32">startupImage	"Private - Initialize the class variables.  This is called during startup."	"DirName := Directory pathName: Disk drivePathName."	self currentDirectory: Filename defaultDirectory.</body></methods><methods><class-id>External.Win32FileDialog class</class-id> <category>private-accessing</category><body package="Com- Win32">currentDirectory: aDirectory	" Private "	DirName := aDirectory.</body></methods><methods><class-id>External.Win32FileDialog class</class-id> <category>private-installation</category><body package="Com- Win32">obsolete	"This class is being removed from the system."	COMSystem current removeAllActionsWithReceiver: self.	^super obsolete</body></methods><methods><class-id>External.Win32FileDialog class</class-id> <category>class initialization</category><body package="Com- Win32">initialize	self startupImage.	COMSystem current when: #startupCompleted send: #startupImage to: self.</body></methods><methods><class-id>External.Win32GlobalMemoryAddress</class-id> <category>accessing</category><body package="Com- Win32">memberAt: aMember	"Answer the value of the structure member named by the symbol &lt;aMember&gt;. "	^pointer memberAt: aMember</body><body package="Com- Win32">memberAt: aMember put: aValue	"Set the value of the structure member named by the symbol &lt;aMember&gt; to &lt;aValue&gt;. "	^pointer memberAt: aMember put: aValue</body><body package="Com- Win32">memoryHandle	" Answer the memory handle of the memory block that the receiver references. "	 ^memoryHandle</body><body package="Com- Win32">memorySize        " Answer the size of the memory block referenced by the receiver.. "	( memorySize isNil and: [ self isValid ] )		ifTrue: [			memorySize := Win32KernelDLL current GlobalSize: memoryHandle ].	^memorySize</body><body package="Com- Win32">reallocateMemory: newSize	" Reallocate the memory block referenced by the receiver to &lt;newSize&gt; bytes. "	| hGlobal |	hGlobal := Win32KernelDLL current GlobalReAlloc: self memoryHandle 		_: newSize 		_: GMEM_MOVEABLE.	self		memoryHandle: hGlobal;		memorySize: newSize;		pointer: ( Win32KernelDLL current GlobalLock: hGlobal ).</body><body package="Com- Win32">refMemberAt: aMember	"Answer a pointer to the structure member named by the symbol &lt;aMember&gt;. "	^pointer refMemberAt: aMember</body></methods><methods><class-id>External.Win32GlobalMemoryAddress</class-id> <category>converting</category><body package="Com- Win32">asHandleParameter	"Answer the receiver in a form suitable for passing as a host handle parameter to an external function call."	memoryHandle isNil		ifTrue: [ ^nil asHandleParameter ].  "excessively defensive, OE should handle this "	^memoryHandle</body></methods><methods><class-id>External.Win32GlobalMemoryAddress</class-id> <category>subclass-accessing</category><body package="Com- Win32">pointer: aPointer	" Private - set the receiver's address pointer. "	super pointer: aPointer.	aPointer notNil		ifTrue: [ self setPointerReferentType: self referentType ].</body><body package="Com- Win32">referentType	" Private - answer the type of the data referenced by the receiver. "	^referentType</body><body package="Com- Win32">referentType: aType	" Private - specify the type of the data referenced by the receiver. "	referentType := aType.	super referentType: aType.</body></methods><methods><class-id>External.Win32GlobalMemoryAddress</class-id> <category>private-accessing</category><body package="Com- Win32">memoryHandle: hGlobal        "Private - set the handle of the memory object for the        receiver to hGlobal"    memoryHandle := hGlobal.</body><body package="Com- Win32">memorySize: anInteger        "Private - set the size of the receiver's memory block."    memorySize := anInteger.</body></methods><methods><class-id>External.Win32GlobalMemoryAddress</class-id> <category>locking</category><body package="Com- Win32">lock	" Lock the global memory referenced by the receiver so that the memory is addressable. "	pointer notNil 		ifTrue: [ ^self ].   " already locked "	self pointer: ( Win32KernelDLL current GlobalLock: memoryHandle ).</body><body package="Com- Win32">unlock        "Unlock the memory referenced by the receiver.  It is no longer addressable. "	pointer notNil		ifTrue: [			Win32KernelDLL current GlobalUnlock: memoryHandle.			pointer := nil ].</body></methods><methods><class-id>External.Win32GlobalMemoryAddress</class-id> <category>subclass-releasing</category><body package="Com- Win32">releaseMemory        "Private - Release the memory at the receiver's address."	self unlock.	Win32KernelDLL current GlobalFree: memoryHandle.	memoryHandle := memorySize := nil.</body></methods><methods><class-id>External.Win32GlobalMemoryAddress</class-id> <category>testing</category><body package="Com- Win32">isValid	" Answer whether the receiver is a valid (non-NULL) address. "	^self memoryHandle ~~ nil and: [ memoryHandle isNull not ]</body></methods><methods><class-id>External.Win32GlobalMemoryAddress</class-id> <category>releasing</category><body package="Com- Win32">privateInvalidate	"Set the receiver to be invalid."	memoryHandle := memorySize := nil.	super privateInvalidate.</body><body package="Com- Win32">revokeOwnership	" The memory  referenced by the receiver is being given away. "	self doesNotNeedFinalization.	self 		unlock;		privateInvalidate.</body></methods><methods><class-id>External.Win32GlobalMemoryAddress class</class-id> <category>constants</category><body package="Com- Win32">zeroInitializationFlag	" Answer the global memory allocation flag specifying zero-initialization of the allocated memory. "	^GMEM_ZEROINIT</body></methods><methods><class-id>External.Win32GlobalMemoryAddress class</class-id> <category>instance creation</category><body package="Com- Win32">allocateMemory: allocationSpecification flags: allocFlags	" Allocate a block of external memory according to &lt;&gt;, which can either be an integer specifying the size in bytes of an untyped block of memory or a C type describing the memory.  The memory is allocated with the specified &lt;allocFlags&gt; of the Win32 global memory allocator.   Answer a new instance of the receiver referencing the newly allocated memory. "	| nBytes hGlobal anExternalGlobalAddress |	nBytes := self getAllocationSizeFor: allocationSpecification.	hGlobal := Win32KernelDLL current GlobalAlloc: allocFlags 		_: nBytes.	anExternalGlobalAddress := self fromHandle: hGlobal.	anExternalGlobalAddress		memorySize: nBytes;		referentType: ( self getAllocationReferentTypeFor: allocationSpecification );		lock.   " make the memory addressable "	anExternalGlobalAddress needsFinalization.	^anExternalGlobalAddress</body><body package="Com- Win32">fromHandle: hGlobal	"Answer a new instance of the receiver which references the external memory identified by &lt;hGlobal&gt;.  The memory is not addressable until the handle is locked. "	^self new		memoryHandle: hGlobal;		referentType: self defaultReferentType; " untyped unless otherwise specified "		yourself.</body><body package="Com- Win32">fromPointer: aPointer	"Answer a new instance of the receiver which references the external memory identified by &lt;aPointer&gt;. "	self shouldNotImplement.</body></methods><methods><class-id>External.Win32GlobalMemoryAddress class</class-id> <category>external-transformations</category><body package="Com- Win32">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery. "	^Win32ExternalInterface current HGLOBAL</body><body package="Com- Win32">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a Win32 global memory address.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^Win32HandleResultBuffer for: self 		type: self baseCType</body></methods><methods><class-id>External.Win32KernelDLL</class-id> <category>API operations</category><body package="Com- Win32">Beep: dwFreq _: dwDuration	self invokeBeep: dwFreq _: dwDuration.	^true</body><body package="Com- Win32">FileTimeToSystemTime: aFileTime _: resultReference	| resultBuffer |	resultBuffer := Win32_SYSTEMTIME resultValueBuffer.	self invokeFileTimeToSystemTime: aFileTime asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^true</body><body package="Com- Win32">FormatMessage: flags _: source _: messageId _: languageId _: resultReference _: cbSize _: arguments 	| resultBuffer cbResult aString |	resultBuffer := Win32ExternalInterface unicodeStringBuffer: cbSize.	cbResult := self 				invokeFormatMessage: flags				_: source				_: messageId				_: languageId				_: resultBuffer asPointerParameter				_: cbSize				_: arguments.	"??asPointerParameter??"	"??asPointerParameter??"	cbResult = 0 		ifTrue: 			[resultBuffer enforceRelease.			self error: #ErrNoString &lt;&lt; #com &gt;&gt; 'no string'].	resultBuffer resultChars: cbResult - 2.	"chop off trailing CR/LF"	aString := resultBuffer contents.	"Assert isEqual: aString size to: ( cbResult - 2 )."	aString := aString copyReplaceAll: Win32ExternalInterface crString				with: ' '.	"replace hard linefeeds"	resultReference value: aString.	^cbResult</body><body package="Com- Win32">FreeLibrary: hLibModule	^self invokeFreeLibrary: hLibModule</body><body package="Com- Win32">GetCommandLine	" Answer the command line string which started this process. "	| lpString |	lpString := self  invokeGetCommandLine.	lpString isNull		ifTrue: [ 			"?? self osError ??"			^nil ].	^lpString copyUnicodeStringFromHeap</body><body package="Com- Win32">GetLastError	"Calling GetLastError from Smalltalk is pointless as too much happened between the original C call 	and this method. Please use __wincall in your C declaration instead. 	Please see Win32SystemSupport&gt;GetLastError for more details"	self deprecated: #(#version '8.0').	^ self shouldNotImplement</body><body package="Com- Win32">GetLocalTime: resultReference	| resultBuffer |	resultBuffer := Win32_SYSTEMTIME resultValueBuffer.	self invokeGetLocalTime: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.</body><body package="Com- Win32">GetProcAddress: hModule _: lpProcName	| procAddr |	procAddr := self invokeGetProcAddress: hModule 		_: lpProcName asStringParameter.	^procAddr isNull		ifTrue: [ nil ]		ifFalse: [ procAddr ]</body><body package="Com- Win32">GetSystemDefaultLCID	^self invokeGetSystemDefaultLCID</body><body package="Com- Win32">GetSystemDefaultLangID	^ self invokeGetSystemDefaultLangID.	"MSDN doesn't say GetLastError can be used here"</body><body package="Com- Win32">GetSystemTime: resultReference	| resultBuffer |	resultBuffer := Win32_SYSTEMTIME resultValueBuffer.	self invokeGetSystemTime: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.</body><body package="Com- Win32">GetUserDefaultLCID	^self invokeGetUserDefaultLCID</body><body package="Com- Win32">GetUserDefaultLangID	^self invokeGetUserDefaultLangID</body><body package="Com- Win32">GlobalAlloc: uFlags _: dwBytes	^HGLOBAL newOfAddress: (self invokeGlobalAlloc: uFlags _: dwBytes)</body><body package="Com- Win32">GlobalFree: hMem	| hGlobal |	hGlobal := self invokeGlobalFree: hMem.	hGlobal isNull ifFalse: [ 		"Calling GetLastError() is pointless as too many things may have appeared 		between the C call and the next line. Raising a generic error instead."		^self error: #GlobalFreeFailed &lt;&lt; #com &gt;&gt; 'GlobalFree() failed.' ].	^hGlobal</body><body package="Com- Win32">GlobalLock: hMem	^LPVOID newOfAddress: (self invokeGlobalLock: hMem)</body><body package="Com- Win32">GlobalReAlloc: hMem _: dwBytes _: uFlags	^HGLOBAL		newOfAddress: (self invokeGlobalReAlloc: hMem _: dwBytes _: uFlags)</body><body package="Com- Win32">GlobalSize: hMem	^self invokeGlobalSize: hMem asHandleParameter</body><body package="Com- Win32">GlobalUnlock: hMem	^self invokeGlobalUnlock: hMem "asHandleParameter"</body><body package="Com- Win32">LoadLibrary: aFileName	" Load the library named &lt;aFileName&gt; and answer its module handle. "	^HMODULE		newOfAddress: (self invokeLoadLibrary: aFileName asUnicodeParameter)</body><body package="Com- Win32">SearchPath: aPathName _: aFileName _: aFileExtension _: cbBuffer _: resultReference _: ignored2	| bufferSize resultBuffer lpFilePart cbResult |	bufferSize := ( cbBuffer notNil		ifTrue: [ cbBuffer ]		ifFalse: [ 255 ] ).	resultBuffer := Win32ExternalInterface unicodeStringBuffer: bufferSize * 2.	lpFilePart := Win32ExternalInterface current LPWSTR malloc.	lpFilePart contents: NULL.	[	cbResult := self invokeSearchPath: aPathName asStringParameter		_: aFileName asUnicodeParameter		_: aFileExtension asUnicodeParameter		_: bufferSize		_: resultBuffer asPointerParameter		_: lpFilePart.	cbResult &gt; 0		ifTrue: [			| aString |			resultBuffer resultChars: cbResult.  "necessary??"			aString := resultBuffer contents.			"Assert isTrue: [ aString size = cbResult ]."			resultReference value: aString ]		ifFalse: [ resultBuffer enforceRelease ].  " polite, although not perhaps strictly necessary "	] ensure: [		lpFilePart freePointer ].	^cbResult</body><body package="Com- Win32">SystemTimeToFileTime: aSystemTime _: resultReference	| resultBuffer |	resultBuffer := Win32_FILETIME resultValueBuffer.	self invokeSystemTimeToFileTime: aSystemTime asPointerParameter 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^ true</body></methods><methods><class-id>External.Win32Structure</class-id> <category>accessing-members</category><body package="Com- Win32">handleMemberAt: aMemberName	"Answer the host handle at member &lt;aMemberName&gt; in the receiver.  Answer nil if the handle is NULL. "	| aHandle |	aHandle := self memberAt: aMemberName.	aHandle isNull 		ifTrue: [ ^nil ].	^aHandle</body><body package="Com- Win32">handleMemberAt: aMemberName put: aHandle	"Set the host handle at member &lt;aMemberName&gt; in the receiver. "	self memberAt: aMemberName put: aHandle asHandleParameter.</body><body package="Com- Win32">largeIntegerMemberAt: aMemberName        "Answer the 8-byte signed integer at member &lt;aMemberName&gt; in the receiver.        If the high bit is on a negative number is returned. "	^( Win32LargeInteger temporaryOn: ( self memberAt: aMemberName ) ) 		asSignedInteger</body><body package="Com- Win32">largeIntegerMemberAt: aMemberName put: anIntegerValue        "Set the 8-byte signed integer at member &lt;aMemberName&gt; in the receiver to &lt;anIntegerValue&gt;. "	^self memberAt: aMemberName		put: ( Win32LargeInteger fromSignedInteger: anIntegerValue ) structure</body><body package="Com- Win32">uLargeIntegerMemberAt: aMemberName        "Answer the 8-byte unsigned integer at member &lt;aMemberName&gt; in the receiver. "	^( Win32LargeInteger temporaryOn: ( self memberAt: aMemberName ) ) 		asUnsignedInteger</body><body package="Com- Win32">uLargeIntegerMemberAt: aMemberName put: anIntegerValue        "Set the 8-byte unsigned integer at member &lt;aMemberName&gt; in the receiver to &lt;anIntegerValue&gt;. "	^self memberAt: aMemberName		put: ( Win32LargeInteger fromUnsignedInteger: anIntegerValue ) structure</body><body package="Com- Win32">unicodePointerMemberAt: aMemberName	" Answer a string containing the characters stored in external memory in Unicode encoding at the address referenced by the pointer member named &lt;aMemberName&gt;.  Answer nil if the address is NULL. "	^Win32ExternalInterface stringFromUnicodePointer: ( structure memberAt: aMemberName )</body></methods><methods><class-id>External.Win32Structure class</class-id> <category>accessing-adaptor specifications</category><body package="Com- Win32">adaptorSpecificationsForType: aType	" Answer the adaptor protocol specifications for &lt;aType&gt;. "	^super adaptorSpecificationsForType: ( self getFundamentalTypeOf: aType )</body><body package="Com- Win32">registerTypeName: aStructureTypeName adaptorProtocol: aProtocolMapSpecification	" Register the specifications for constructing a structure protocol adaptor on the type named &lt;aStructureTypeName&gt;. "	| aType |	aType := self typeNamed: aStructureTypeName.	super registerTypeName: ( self getFundamentalTypeOf: aType ) name 		adaptorProtocol: aProtocolMapSpecification.</body><body package="Com- Win32">unregisterTypeName: aStructureTypeName	" Remove the protocol adaptor map specifications for the type named &lt;aStructureTypeName&gt;. "	| aType |	aType := self typeNamed: aStructureTypeName.	super unregisterTypeName: ( self getFundamentalTypeOf: aType ) name.</body></methods><methods><class-id>External.Win32Structure class</class-id> <category>subclass-accessing</category><body package="Com- Win32">typeProvider	" Answer the object which can provide definitions from the type name space of the receiver. "	^Win32ExternalInterface</body></methods><methods><class-id>External.Win32Structure class</class-id> <category>external-transformations</category><body package="Com- Win32">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an instance of the data structure represented by the receiver.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^Win32StructureResultBuffer for: self 		type: self baseCType</body><body package="Com- Win32">resultValuePointerBufferFor: aStructureName	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a pointer to the structure named &lt;aStructureName&gt;.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^Win32StructurePointerResultBuffer for: self 		type: ( self typeNamed: aStructureName )</body></methods><methods><class-id>External.Win32Structure class</class-id> <category>subclass-testing</category><body package="Com- Win32">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	^Win32BufferManager useFixedSpace</body></methods><methods><class-id>External.Win32ClipboardInterface</class-id> <category>private-accessing</category><body package="Com- Win32">empty        " Private - empty the clipboard. Note: it must be opened first. "	^Win32UserDLL current EmptyClipboard</body><body package="Com- Win32">getClipboardData: cfFormat        " Private - get the current contents of the clipboard. Note: it must be opened first. "	^Win32UserDLL current GetClipboardData: cfFormat</body><body package="Com- Win32">setClipboardData: cfFormat hGlobal: hGlobal	" Private - set the contents of the clipboard to the data in global memory at &lt;hGlobal&gt;.  Note: it must be opened first. "	Win32UserDLL current SetClipboardData: cfFormat _: hGlobal.</body></methods><methods><class-id>External.Win32ClipboardInterface</class-id> <category>testing</category><body package="Com- Win32">containsFormat: aCfConstant        "Answer whether the clipboard contains data in the format described by the clipboard format constant &lt;aCfConstant&gt;.  The clipboard format can be an operating system defined constant or a user-defined clipboard format. "    ^Win32UserDLL current IsClipboardFormatAvailable: aCfConstant</body><body package="Com- Win32">containsFormatNamed: aFormatName	"Answer whether the clipboard contains data in the user-defined format named &lt;aFormatName&gt;. "	^self containsFormat: ( self formatNamed: aFormatName )</body><body package="Com- Win32">containsSmalltalkObject        "Answer whether the clipboard contains a Smalltalk object."    ^self containsFormat: self class cfSmalltalkObject</body><body package="Com- Win32">containsText        "Answer whether the clipboard contains text."    ^self containsFormat: CF_TEXT</body><body package="Com- Win32">containsUnicodeText        "Answer whether the clipboard contains Unicode text."    ^self containsFormat: CF_UNICODETEXT</body></methods><methods><class-id>External.Win32ClipboardInterface</class-id> <category>accessing</category><body package="Com- Win32">clear        "Clear the contents of the clipboard."	| succeeded |	self open ifFalse: [ self close. ^false ].	[ succeeded := self empty ]		ensure: [ self close ].	^succeeded</body><body package="Com- Win32">close        "Close the clipboard, if opened."    IsOpen ifFalse: [ ^nil ].    Win32UserDLL current CloseClipboard.    IsOpen := false.</body><body package="Com- Win32">getByteString        "Answer the contents of the clipboard as a String, or an empty         string if the clipboard is empty or cannot render a string."    | aString |    ( aString := self getByteStringOrNil ) isNil        ifTrue: [ ^String new ]        ifFalse: [ ^aString ]</body><body package="Com- Win32">getByteStringOrNil        "Answer the contents of the clipboard as a String, or nil         if the clipboard is empty or cannot render a string."	| hGlobal aString |	self containsText ifFalse: [ ^nil ].	self open ifFalse: [ ^nil ].	[	hGlobal := self getClipboardData: CF_TEXT.	hGlobal notNil		ifTrue: [ aString := self class getStringFromGlobalMemory: hGlobal ].	] ensure: [		self close ].	^aString</body><body package="Com- Win32">getObject        "Answer the contents of the clipboard as an object,        or nil if the clipboard is empty or cannot render an object."    ^self getObject: self class cfSmalltalkObject</body><body package="Com- Win32">getObject: cfFormat        "Private - Answer the contents of the clipboard as an object,        or nil if the clipboard is empty or cannot render an object         in format &lt;cfFormat&gt;. "	| hGlobal anObject |	self open ifFalse: [ self close. ^nil ].	( self containsFormat: cfFormat )		ifFalse: [ self close. ^nil ].	[	hGlobal := self getClipboardData: cfFormat.	hGlobal notNil		ifTrue: [ anObject := self class getSmalltalkObjectFromGlobalMemory: hGlobal ].	] ensure: [		self close ].	^anObject</body><body package="Com- Win32">getString	^ self getStringOrNil ifNil: [ String new ].</body><body package="Com- Win32">getStringOrNil	^ self getUnicodeStringOrNil ifNil: [ self getByteStringOrNil ]</body><body package="Com- Win32">getUnicodeStringOrNil        "Answer the contents of the clipboard as a String, or nil         if the clipboard is empty or cannot render a string."	| hGlobal aString |	self containsUnicodeText ifFalse: [ ^nil ].	self open ifFalse: [ ^nil ].	[	hGlobal := self getClipboardData: CF_UNICODETEXT.	hGlobal notNil		ifTrue: [ aString := self class getUnicodeStringFromGlobalMemory: hGlobal ].	] ensure: [		self close ].	^aString</body><body package="Com- Win32">open        "Open the clipboard."    ^IsOpen := ( Win32UserDLL current OpenClipboard: Win32WindowHandle getDesktopWindow ).</body><body package="Com- Win32">setByteString: aString        "Set the contents of the clipboard to &lt;aString&gt;."	aString isNil ifTrue: [ ^nil ].	self open ifFalse: [ ^nil ].	[	self setClipboardData: CF_TEXT		hGlobal: ( self class copyStringToGlobalMemory: aString ).	] ensure: [		self close ].	^aString</body><body package="Com- Win32">setObject: anObject        "Set the contents of the clipboard to anObject."    self setObject: anObject format: self class cfSmalltalkObject.</body><body package="Com- Win32">setObject: anObject format: cfFormat	" Set the contents of the clipboard to an externalized representation of &lt;anObject&gt; as format &lt;cfFormat&gt;. "	| description |	anObject isNil ifTrue: [ ^nil ].	self open ifFalse: [ ^nil ].	description :=		( UserFormats keyAtValueEqual: cfFormat ),		' (', anObject printString, ')'.	[	self empty.	self setClipboardData: cfFormat		hGlobal: ( self class copySmalltalkObjectToGlobalMemory: anObject ).	self setClipboardData: CF_DSPTEXT		hGlobal: ( self class copyStringToGlobalMemory: description ).	] ensure: [		self close ].	^anObject</body><body package="Com- Win32">setString: aString	^ self setUnicodeString: aString.</body><body package="Com- Win32">setUnicodeString: aString        "Set the contents of the clipboard to &lt;aString&gt;."	aString isNil ifTrue: [ ^nil ].	self open ifFalse: [ ^nil ].	[	self setClipboardData: CF_UNICODETEXT		hGlobal: ( self class copyUnicodeStringToGlobalMemory: aString ).	] ensure: [		self close ].	^aString</body></methods><methods><class-id>External.Win32ClipboardInterface</class-id> <category>user formats</category><body package="Com- Win32">formatNamed: aString        "Answer the clipboard format named aString.        Register the format if not previously defined."	^self class userFormats at: aString 		ifAbsent: [ self registerFormat: aString ]</body><body package="Com- Win32">getFormatName: aCfFormat        "Answer the name of the registered clipboard format &lt;aCfFormat&gt;        or nil if the format is not registered. "	| resultReference |	resultReference := nil asValueReference.	Win32UserDLL current GetClipboardFormatName: aCfFormat		_: resultReference		_: nil.	^resultReference value</body><body package="Com- Win32">registerFormat: aString        "Register aString as a user-defined clipboard format.        Answer the format."    | aFormat |    aFormat := Win32UserDLL current RegisterClipboardFormat: aString.    self class userFormats at: aString put: aFormat.    ^aFormat</body></methods><methods><class-id>External.Win32ClipboardInterface class</class-id> <category>private-session management</category><body package="Com- Win32">startupImage	" Private - initialize the state of the receiver. "	HostInterface isWin32		ifFalse: [ ^self initialize ].	IsOpen := false.	UserFormats := Dictionary new.  " reset the list of known user formats "</body></methods><methods><class-id>External.Win32ClipboardInterface class</class-id> <category>private-accessing</category><body package="Com- Win32">current: aClipboardInterface	" Private - install the Win32 clipboard interface. "	Current := aClipboardInterface.</body><body package="Com- Win32">objectFilerClass	^#{BinaryObjectStorage} valueOrDo: [self error: #ErrNoBOSSSupport &lt;&lt; #com &gt;&gt; 'BOSS support not installed']</body><body package="Com- Win32">userFormats        "Private - answer the list of known user-defined clipboard         formats."    "UserFormats isNil ifTrue: [ UserFormats := Dictionary new ]."    ^UserFormats</body><body package="Com- Win32">userFormats: aDictionary        "Private - set the list of known user-defined clipboard         formats to aDictionary."    UserFormats := aDictionary.</body></methods><methods><class-id>External.Win32ClipboardInterface class</class-id> <category>data transfer services</category><body package="Com- Win32">copySmalltalkObjectToGlobalMemory: anObject	" Make a persistent copy of &lt;anObject&gt; in global memory in a form from which an equivalent object can subsequently be recreated.  Answer the handle of the global memory which was allocated to contain the persistent representation of the object's state. "	| objectFilerClass anExternalAddress aStream nBytes |	objectFilerClass := self objectFilerClass.true ifTrue: [  "###Hack in a temporary implementation until Win32MemoryReadWriteStream fixed###"	| byteStream |	byteStream := ReadWriteStream on: ( ByteArray new: 1024 ).	( objectFilerClass onNew: byteStream ) nextPut: anObject.	nBytes := byteStream position.	anExternalAddress := Win32GlobalMemoryAddress allocateMemory: nBytes "+ 4".	anExternalAddress doesNotNeedFinalization.	"Punt: anExternalAddress nextLongPut: nBytes."	anExternalAddress replaceBytes: nBytes		with: byteStream contents.] ifFalse: [ Tools.Note ISSUE; needsWork.  " temporarily punt on the 'real' implementation [DL 23-Apr-97] "	anExternalAddress := Win32GlobalMemoryAddress allocateMemory: 1024.	anExternalAddress doesNotNeedFinalization.	aStream := Win32MemoryReadWriteStream byteStreamOn: anExternalAddress.	aStream nextLongPut: 0.    " size place holder "  "VSE was: #nextULongPut: "	"Assert isEqual: aStream position to: 4."	( objectFilerClass onNew: aStream ) nextPut: anObject.		"VSE was: objectFiler dump: anObject on: stream "	nBytes := aStream position.	aStream reset; nextLongPut: ( nBytes - 4 ).  "VSE was: #nextULongPut: "	" observe that we do not close/release the stream because we now give the memory away "].	"Assert isTrue: [ anExternalAddress asPointer notNil ]."	anExternalAddress unlock.	"Assert isTrue: [ anExternalAddress asPointer isNil ]."	^anExternalAddress memoryHandle</body><body package="Com- Win32">copyStringToGlobalMemory: aString	" Copy &lt;aString&gt; to global memory in native platform string format.  Answer the address of the memory which was allocated to hold the string. "	| anExternalAddress hGlobal |	anExternalAddress := Win32GlobalMemoryAddress copyToExternalMemory: aString		flags: GMEM_MOVEABLE | GMEM_ZEROINIT.   "?? GMEM_SHARE ??"	hGlobal := anExternalAddress memoryHandle.	anExternalAddress 		unlock;		doesNotNeedFinalization.  " ownership is given away when we put things on the clipboard "	^hGlobal</body><body package="Com- Win32">copyUnicodeStringToGlobalMemory: aString	" Copy &lt;aString&gt; to global memory in native platform string format.  Answer the address of the memory which was allocated to hold the string. "	| anExternalAddress hGlobal |	anExternalAddress := Win32GlobalMemoryAddress copyUnicodeToExternalMemory: aString		flags: GMEM_MOVEABLE | GMEM_ZEROINIT.   "?? GMEM_SHARE ??"	hGlobal := anExternalAddress memoryHandle.	anExternalAddress 		unlock;		doesNotNeedFinalization.  " ownership is given away when we put things on the clipboard "	^hGlobal</body><body package="Com- Win32">getSmalltalkObjectFromGlobalMemory: hGlobal 	" Answer the object which is recreated from the persistent representation of object state in global memory at &lt;hGlobal&gt;. "	| objectFilerClass anExternalAddress aStream nBytes anObject |	objectFilerClass := self objectFilerClass.	anExternalAddress := Win32GlobalMemoryAddress fromHandle: hGlobal.	anExternalAddress doesNotNeedFinalization.	" 'cause we don't own this guy in the first place "	anExternalAddress memorySize &gt; 4 		ifFalse: [self error: #ErrInvalidGlobalMem &lt;&lt; #com &gt;&gt; 'invalid global memory'].	" min size is at least our ULONG length field "	anExternalAddress lock.	"Assert isTrue: [ anExternalAddress asPointer notNil ]."	" otherwise we'da gotten an exception... "		[true 		ifTrue: 			["###Hack in a temporary implementation until Win32MemoryReadWriteStream fixed###"			aStream := ReadStream 						on: (anExternalAddress copyFrom: 1 to: anExternalAddress memorySize).			"we punted the length field"			anObject := (objectFilerClass onOldNoScan: aStream) next]		ifFalse: 			[aStream := Win32MemoryReadWriteStream byteStreamOn: anExternalAddress.			nBytes := aStream nextLong.	"VSE was: #nextULong "			"Assert isTrue: [ nBytes &lt;= anExternalAddress memorySize ]."			anObject := (objectFilerClass onOldNoScan: aStream) next			"VSE was: objectFiler loadFrom: stream."]] 			ensure: [anExternalAddress unlock].	^anObject</body><body package="Com- Win32">getStringFromGlobalMemory: hGlobal	" Answer the string contained in the global memory referenced by &lt;hGlobal&gt;.  The string is assumed to be in native platform format. "	| aGlobalMemoryAddress aString |	aGlobalMemoryAddress := Win32GlobalMemoryAddress fromHandle: hGlobal.	"Assert isFalse: [ aGlobalMemoryAddress hasFinalization ]."  " otherwise must invalidate when done... "	aGlobalMemoryAddress lock.	aString := aGlobalMemoryAddress asPointer copyCStringFromHeap.	aGlobalMemoryAddress unlock.	^aString"Slightly more efficient, but less clear/safe:	| lpString aString |	lpString := Win32KernelDLL current GlobalLock: hGlobal.	aString := lpString copyCStringFromHeap.	Win32KernelDLL current GlobalUnlock: hGlobal.	^aString"</body><body package="Com- Win32">getUnicodeStringFromGlobalMemory: hGlobal	" Answer the string contained in the global memory referenced by &lt;hGlobal&gt;.  The string is assumed to be in native platform format. "	| aGlobalMemoryAddress aString |	aGlobalMemoryAddress := Win32GlobalMemoryAddress fromHandle: hGlobal.	"Assert isFalse: [ aGlobalMemoryAddress hasFinalization ]."  " otherwise must invalidate when done... "	aGlobalMemoryAddress lock.	aString := aGlobalMemoryAddress asPointer copyUnicodeStringFromHeap.	aGlobalMemoryAddress unlock.	^aString"Slightly more efficient, but less clear/safe:	| lpString aString |	lpString := Win32KernelDLL current GlobalLock: hGlobal.	aString := lpString copyCStringFromHeap.	Win32KernelDLL current GlobalUnlock: hGlobal.	^aString"</body></methods><methods><class-id>External.Win32ClipboardInterface class</class-id> <category>clipboard formats</category><body package="Com- Win32">cfSmalltalkObject	" Answer the clipboard format for a Smalltalk object in a persistent representation from which the object can be recreated. "	^self current formatNamed: self cfSmalltalkObjectName</body><body package="Com- Win32">cfSmalltalkObjectName	" Answer the user name of the clipboard format for a Smalltalk object in a persistent representation from which the object can be recreated. "	^'Visual Works Object'</body></methods><methods><class-id>External.Win32ClipboardInterface class</class-id> <category>accessing</category><body package="Com- Win32">current	" Answer the Win32 clipboard interface. "	^Current</body></methods><methods><class-id>External.Win32ClipboardInterface class</class-id> <category>private-installation</category><body package="Com- Win32">initialize	" Private - initialize the state of the receiver. "	IsOpen := false.	UserFormats := Dictionary new.	Current := self new.	" We could be clever about registering the startup handler,		only installing it when 'OSHandle currentOS = #win32'		and there are actually UserFormat entries.  But that's		a little too clever for the first pass.  Get ambitous later		if it seems worthwhile. "	COMSystem current when: #startupCompleted		send: #startupImage to: self.</body><body package="Com- Win32">obsolete	"This class is being removed from the system."	COMSystem current removeAllActionsWithReceiver: self.	self current close.	self current: nil.	^super obsolete</body></methods><methods><class-id>External.Win32UnicodePointerListBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^Win32ExternalInterface unicodeStringPointerType</body></methods><methods><class-id>External.Win32UnicodePointerListBuffer</class-id> <category>subclass-initializing</category><body package="Com- Win32">copyStringToExternalMemory: aString	" Private - copy &lt;aString&gt; to external memory in a suitable encoding and answer the pointer. "	^aString copyToHeapUnicode</body></methods><methods><class-id>External.Win32HandleResultBuffer</class-id> <category>private-accessing</category><body package="Com- Win32">handleClass: aHandleClass	" Private - specify the handle wrapper class to instantiate on the buffer contents. "	handleClass := aHandleClass.</body><body package="Com- Win32">handleType: aHandleType	" Private - specify the handle type which we are getting back in the result buffer. "	handleType := aHandleType.</body></methods><methods><class-id>External.Win32HandleResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^handleType</body></methods><methods><class-id>External.Win32HandleResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">getResultValue	" Private - convert the buffer contents into a suitable handle value.  Answer the value. "	| aValue |	" we start with the raw handle value "	aValue := ( buffer isPointer		ifTrue: [ buffer contents ]  " bring the bits back in at this point "		ifFalse: [ buffer ] ).	aValue isNull		ifTrue: [ ^nil ].	" it turns out that both fixed-space and heap allocation		lose the HANDLE typedef, so it would be nice fiddle it back in at this point.   		Not strictly necessary, but kinda nice if these guys are gonna 		float around the system "	false ifTrue: [  " Not yet enabled, this is tricky and not yet sure how to do safely "	| lpVoidType |	lpVoidType := CVoidType void pointerType.	"Assert isTrue: [ handleType isPointer ]."	"Assert isTrue: [ handleType class = CTypedefType and: [ handleType type = lpVoidType ] ]." 	aValue type: handleType.	].	" optionally wrap the raw bits with a handle accessor class "	handleClass notNil		ifTrue: [ aValue := handleClass fromHandle: aValue ].	^aValue</body></methods><methods><class-id>External.Win32HandleResultBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">for: aHandleClass type: aHandleType	" Answer a new instance of the receiver which is used for bringing a handle value into the system via a buffer in which &lt;aHandleType&gt; is obtained.  The structure is returned with &lt;aHandleClass&gt; instance as the wrapper. "	^self basicNew		handleType: aHandleType;		handleClass: aHandleClass;		initialize;		yourself</body><body package="Com- Win32">forType: aHandleType	" Answer a new instance of the receiver which is used for bringing a handle value into the system via a buffer in which &lt;aHandleType&gt; is obtained. "	^self basicNew		handleType: aHandleType;		initialize;		yourself</body></methods><methods><class-id>External.Win32RegKeyHandleResultBuffer</class-id> <category>accessing</category><body package="Com- Win32">securityAccess	^securityAccess</body><body package="Com- Win32">securityAccess: anObject	securityAccess := anObject</body></methods><methods><class-id>External.Win32RegKeyHandleResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">getResultValue	" Private - convert the buffer contents into a suitable handle value.  Answer the value. "	^super getResultValue ifNotNil: 			[:result |			result				securityAccess: self securityAccess;				yourself]</body></methods><methods><class-id>External.Win32RegKeyHandle</class-id> <category>operations</category><body package="Com- Win32">close	"Private - close the receiver's key"	"On 64 bit Windows, closeing a Root handle does not work ... since we didn't open it"	self isConstant ifTrue: [ ^ self ].	(Win32AdvApiDLL current RegCloseKey: self) ~= 0 		ifTrue: [self error: #ErrClosingKey &lt;&lt; #com &gt;&gt; 'error closing key']</body><body package="Com- Win32">create32Bit: keyName        "Private - add a new subkey of the receiver         with the specified name"    ^self class create32Bit: keyName in: self</body><body package="Com- Win32">create64Bit: keyName        "Private - add a new subkey of the receiver         with the specified name"    ^self class create64Bit: keyName in: self</body><body package="Com- Win32">create: keyName        "Private - add a new subkey of the receiver         with the specified name"    ^self class create: keyName in: self</body><body package="Com- Win32">delete32Bit: subKeyName        "Private - delete the specified subkey name         from the receiver"    ^self class delete32Bit: subKeyName from: self</body><body package="Com- Win32">delete64Bit: subKeyName        "Private - delete the specified subkey name         from the receiver"    ^self class delete64Bit: subKeyName from: self</body><body package="Com- Win32">delete: subKeyName        "Private - delete the specified subkey name         from the receiver"    ^self class delete: subKeyName from: self</body><body package="Com- Win32">enumKeys	" Answer a collection of containing all the subkeys of the receiver. "	| subKeys index resultReference |	subKeys := OrderedCollection new.	index := 0.	resultReference := nil asValueReference.	[ ( Win32AdvApiDLL current RegEnumKey: self			_: index 			_: resultReference			_: nil ) = 0 ]		whileTrue: [			subKeys add: resultReference value.			resultReference value: nil.			index := index + 1 ].	^subKeys</body><body package="Com- Win32">enumValues        "Private - enumerate the values of the receiver, and         answer a collection of Smalltalk objects which are         equivalent to the RegDB values."	| values index resultReferenceValue resultReferenceData |	values := OrderedCollection new.	index := 0.	resultReferenceValue := nil asValueReference.	resultReferenceData := nil asValueReference.	[ ( Win32AdvApiDLL current RegEnumValue: self			_: index 			_: resultReferenceValue			_: nil 			_: 0			_: REG_SZ   "??? what should this be??? "			_: resultReferenceData			_: nil ) = 0 ]		whileTrue: [			values add: ( Array				with: resultReferenceValue value				with: resultReferenceData value ).			resultReferenceValue value: nil.			resultReferenceData value: nil.			index := index + 1 ].	^values</body><body package="Com- Win32">open32Bit: subKeyName        "Private - open the specified subkey of the receiver,         and answer an instance of the receiver class which corresponds         to the opened subkey"    ^self class open32Bit: subKeyName in: self</body><body package="Com- Win32">open64Bit: subKeyName        "Private - open the specified subkey of the receiver,         and answer an instance of the receiver class which corresponds         to the opened subkey"    ^self class open64Bit: subKeyName in: self</body><body package="Com- Win32">open: subKeyName        "Private - open the specified subkey of the receiver,         and answer an instance of the receiver class which corresponds         to the opened subkey"    ^self class open: subKeyName in: self</body><body package="Com- Win32">openAlternate: subKeyName	"Private - open the specified alternate subkey of the receiver,         and answer an instance of the receiver class which corresponds         to the opened subkey. Alternate means, on a 32 bit vm, answer the 64 bit 	   registry handly and the other way around."	^ObjectMemory is64Bit		ifTrue: [self open32Bit: subKeyName]		ifFalse: [self open64Bit: subKeyName]</body><body package="Com- Win32">openAlternateReadOnly: subKeyName	"Private - open the specified alternate subkey of the receiver in Read-only mode,         and answer an instance of the receiver class which corresponds         to the opened subkey. Alternate means, on a 32 bit vm, answer the 64 bit 	   registry handly and the other way around."	^ObjectMemory is64Bit		ifTrue: [self openReadOnly32Bit: subKeyName]		ifFalse: [self openReadOnly64Bit: subKeyName]</body><body package="Com- Win32">openReadOnly32Bit: subKeyName        "Private - open the specified 32bit subkey of the receiver,         and answer an instance of the receiver class which corresponds         to the opened subkey"    ^self class open32Bit: subKeyName in: self securityAccess: KEY_READ</body><body package="Com- Win32">openReadOnly64Bit: subKeyName        "Private - open the specified 64bit subkey of the receiver,         and answer an instance of the receiver class which corresponds         to the opened subkey"    ^self class open64Bit: subKeyName in: self securityAccess: KEY_READ</body><body package="Com- Win32">openReadOnly: subKeyName        "Private - open the specified subkey of the receiver,         and answer an instance of the receiver class which corresponds         to the opened subkey"    ^self class open: subKeyName in: self securityAccess: KEY_READ</body><body package="Com- Win32">value        "Private - answer the receiver's default value."    ^self valueNamed: nil</body><body package="Com- Win32">value: aValue        "Private - answer the value of the receiver key."    | result bytes |	bytes := aValue isString 			ifTrue: [ Win32ExternalInterface asUnicodeStringBytes: (aValue copyWith: (Character value: 0)) ]			ifFalse: [ aValue ].   result := Win32AdvApiDLL current RegSetValueEx: self        _: nil        _: 0        _: REG_SZ        _: bytes        _: bytes size.    result &gt; 0 ifTrue: [ ^nil ]</body><body package="Com- Win32">valueNamed: aString        "Private - answer the value of the receiver with the given named value key." 	| typeResultReference resultReference sizeResultReference |	resultReference := nil asValueReference.	typeResultReference := nil asValueReference.	sizeResultReference := nil asValueReference.	Win32AdvApiDLL current RegQueryValueEx: self		_: aString		_: 0		_: typeResultReference		_: resultReference		_: sizeResultReference.	^resultReference value</body><body package="Com- Win32">valueNamed: aString put: aValue	"Private - answer the value at aString - 	added for Win32RegistrationDatabase&gt;&gt;namedValueAt:put:"    | result bytes | 	bytes := aValue isString 			ifTrue: [ Win32ExternalInterface asUnicodeStringBytes: (aValue copyWith: (Character value: 0)) ]			ifFalse: [ aValue ].    result := Win32AdvApiDLL current RegSetValueEx: self         _: aString        _: 0        _: REG_SZ        _: bytes        _: bytes size.    result &gt; 0 ifTrue: [ ^nil ]</body></methods><methods><class-id>External.Win32RegKeyHandle</class-id> <category>converting</category><body package="Com- Win32">asHandleParameter	"Answer the receiver in a form suitable for passing as a host handle parameter to an external function call."	" This seems unnecessarily heavy-handed - is it really necessary?		Argument coercion testing doesn't seem willing to hammer integers		into pointers for us, which is very sad, so for now at least we 		leave this here on the grounds of better safe than sorry.  [DL 24-Mar-96] "	handle isInteger		ifTrue: [ ^Win32ExternalInterface current HKEY cast: handle ].	^handle</body></methods><methods><class-id>External.Win32RegKeyHandle</class-id> <category>printing</category><body package="Com- Win32">printHandleOn: aStream        "Private - Append an ASCII representation of the receiver's handle to &lt;aStream&gt;."	aStream nextPutAll: ( self asInteger printStringRadix: 16 ).</body></methods><methods><class-id>External.Win32RegKeyHandle</class-id> <category>private</category><body package="Com- Win32">securityAccess	^securityAccess ifNil: [KEY_ALL_ACCESS]</body><body package="Com- Win32">securityAccess: anObject	securityAccess := anObject</body></methods><methods><class-id>External.Win32RegKeyHandle</class-id> <category>testing</category><body package="Com- Win32">is32Bit	self securityAccess ifNil: [^ false ].	^ (self securityAccess bitAnd: self class modifierFor32Bit) = self class modifierFor32Bit</body><body package="Com- Win32">is64Bit	^(self securityAccess bitAnd: self class modifierFor64Bit)		= self class modifierFor64Bit</body></methods><methods><class-id>External.Win32RegKeyHandle</class-id> <category>accessing</category><body package="Com- Win32">beConstant	constant := true.</body><body package="Com- Win32">isConstant	^constant ifNil: [false]</body></methods><methods><class-id>External.Win32RegKeyHandle class</class-id> <category>external-transformations</category><body package="Com- Win32">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery. "	^Win32ExternalInterface current HKEY</body></methods><methods><class-id>External.Win32RegKeyHandle class</class-id> <category>private-operations</category><body package="Com- Win32">create32Bit: keyName in: hKey        "Private - create the specified 32bit Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle."	| resultReference |	resultReference := nil asValueReference.	Win32AdvApiDLL current RegCreateKeyEx: hKey 		_: keyName 		_: (self markFor32Bit: (self securityAccessFor: hKey))		_: resultReference.	^resultReference value</body><body package="Com- Win32">create64Bit: keyName in: hKey        "Private - create the specified 64bit Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle."	| resultReference |	resultReference := nil asValueReference.	Win32AdvApiDLL current RegCreateKeyEx: hKey 		_: keyName 		_: (self markFor64Bit: (self securityAccessFor: hKey))		_: resultReference.	^resultReference value</body><body package="Com- Win32">create: keyName        "Private - create the specified key name of HKEY_CLASSES_ROOT,         and answer an instance of the receiver class which corresponds         to the created key"    ^self create: keyName in: HKEY_CLASSES_ROOT</body><body package="Com- Win32">create: keyName in: hKey        "Private - create the specified Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle."	| resultReference |	resultReference := nil asValueReference.	Win32AdvApiDLL current RegCreateKeyEx: hKey 		_: keyName 		_: (self securityAccessFor: hKey)		_: resultReference.	^resultReference value</body><body package="Com- Win32">delete32Bit: keyName from: hKey	"Private - delete the specified 32 bit keyName from its parent."	| result |	result := Win32AdvApiDLL current				regDeleteKey: keyName				from: hKey				flags: (self mergeAccessRightsOf: hKey with: self modifierFor32Bit).	result ~= 0 ifTrue: [^nil]</body><body package="Com- Win32">delete64Bit: keyName from: hKey	"Private - delete the specified 64 bit keyName from its parent."	| result |	result := Win32AdvApiDLL current				regDeleteKey: keyName				from: hKey				flags: (self mergeAccessRightsOf: hKey with: self modifierFor64Bit).	result ~= 0 ifTrue: [^nil]</body><body package="Com- Win32">delete: keyName        "Private - delete the specified keyName from the         HKEY_CLASSES_ROOT predefined handle."    ^self delete: keyName from: HKEY_CLASSES_ROOT</body><body package="Com- Win32">delete: keyName from: hKey	"Private - delete the specified keyName from its parent."	| result |	result := Win32AdvApiDLL current				regDeleteKey: keyName				from: hKey				flags: (self bitModifierFor: (self securityAccessFor: hKey)).	result ~= 0 ifTrue: [^nil]</body><body package="Com- Win32">open32Bit: keyName in: hKey	"Private - open the specified Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle.         keyName may be either a String, or an Integer value         specifying one of the predefined key values."	^self		open32Bit: keyName		in: hKey		securityAccess: (self securityAccessFor: hKey)</body><body package="Com- Win32">open32Bit: keyName in: hKey securityAccess: samDesired	"Private - open the specified Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle.         keyName may be either a String, or an Integer value         specifying one of the predefined key values.	&lt;samDesired&gt; Security Access Mode Desired. Specifies an access mask that describes the desired security access for the new key. This parameter can be a combination of the following values: KEY_ALL_ACCESS		Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, and KEY_SET_VALUE access.KEY_CREATE_LINK	Permission to create a symbolic link.KEY_CREATE_SUB_KEY	Permission to create subkeys.KEY_ENUMERATE_SUB_KEYS	Permission to enumerate subkeys.KEY_EXECUTE	Permission for read access.KEY_NOTIFY	Permission for change notification.KEY_QUERY_VALUE	Permission to query subkey data.KEY_READ	Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access.KEY_SET_VALUE	Permission to set subkey data.KEY_WRITE	Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access."	| resultReference |	resultReference := nil asValueReference.	Win32AdvApiDLL current		RegOpenKeyEx: hKey		_: keyName		_: 0		_: (self mergeAccessRightsOf: hKey with: (self markFor32Bit: samDesired))		_: resultReference.	^resultReference value</body><body package="Com- Win32">open64Bit: keyName in: hKey	"Private - open the specified Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle.         keyName may be either a String, or an Integer value         specifying one of the predefined key values."	^self		open64Bit: keyName		in: hKey		securityAccess: (self securityAccessFor: hKey)</body><body package="Com- Win32">open64Bit: keyName in: hKey securityAccess: samDesired	"Private - open the specified Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle.         keyName may be either a String, or an Integer value         specifying one of the predefined key values.	&lt;samDesired&gt; Security Access Mode Desired. Specifies an access mask that describes the desired security access for the new key. This parameter can be a combination of the following values: KEY_ALL_ACCESS		Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, and KEY_SET_VALUE access.KEY_CREATE_LINK	Permission to create a symbolic link.KEY_CREATE_SUB_KEY	Permission to create subkeys.KEY_ENUMERATE_SUB_KEYS	Permission to enumerate subkeys.KEY_EXECUTE	Permission for read access.KEY_NOTIFY	Permission for change notification.KEY_QUERY_VALUE	Permission to query subkey data.KEY_READ	Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access.KEY_SET_VALUE	Permission to set subkey data.KEY_WRITE	Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access."	| resultReference |	resultReference := nil asValueReference.	Win32AdvApiDLL current		RegOpenKeyEx: hKey		_: keyName		_: 0		_: (self mergeAccessRightsOf: hKey with: (self markFor64Bit: samDesired))		_: resultReference.	^resultReference value</body><body package="Com- Win32">open: keyName        "Private - open the specified key name of HKEY_CLASSES_ROOT,         and answer an instance of the receiver class which corresponds         to the opened key"    ^self open: keyName in: HKEY_CLASSES_ROOT</body><body package="Com- Win32">open: keyName in: hKey	"Private - open the specified Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle.         keyName may be either a String, or an Integer value         specifying one of the predefined key values."	^self		open: keyName		in: hKey		securityAccess: (self securityAccessFor: hKey)</body><body package="Com- Win32">open: keyName in: hKey securityAccess: samDesired	"Private - open the specified Registration Database         key name in the specified open key handle, and         answer a corresponding instance of RegKeyHandle.         keyName may be either a String, or an Integer value         specifying one of the predefined key values.	&lt;samDesired&gt; Security Access Mode Desired. Specifies an access mask that describes the desired security access for the new key. This parameter can be a combination of the following values: KEY_ALL_ACCESS		Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, and KEY_SET_VALUE access.KEY_CREATE_LINK	Permission to create a symbolic link.KEY_CREATE_SUB_KEY	Permission to create subkeys.KEY_ENUMERATE_SUB_KEYS	Permission to enumerate subkeys.KEY_EXECUTE	Permission for read access.KEY_NOTIFY	Permission for change notification.KEY_QUERY_VALUE	Permission to query subkey data.KEY_READ	Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access.KEY_SET_VALUE	Permission to set subkey data.KEY_WRITE	Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access."	| resultReference |	resultReference := nil asValueReference.	Win32AdvApiDLL current		RegOpenKeyEx: hKey		_: keyName		_: 0		_: (self mergeAccessRightsOf: hKey with: samDesired)		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.Win32RegKeyHandle class</class-id> <category>predefined keys</category><body package="Com- Win32">classesRoot        "Private - answer an instance of the receiver class         which corresponds to the HKEY_CLASSES_ROOT         predefined key"    ^self fromInteger: HKEY_CLASSES_ROOT</body><body package="Com- Win32">classesRootId        "Private - answer the HKEY_CLASSES_ROOT         predefined key"    ^HKEY_CLASSES_ROOT</body><body package="Com- Win32">currentConfigId        "Private - answer the HKEY_CURRENT_CONFIG         predefined key"    ^HKEY_CURRENT_CONFIG</body><body package="Com- Win32">currentUser        "Private - answer an instance of the receiver class         which corresponds to the HKEY_CURRENT_USER         predefined key"    ^self fromInteger: HKEY_CURRENT_USER</body><body package="Com- Win32">currentUserId        "Private - answer the HKEY_CURRENT_USER         predefined key"    ^HKEY_CURRENT_USER</body><body package="Com- Win32">dynDataId        "Private - answer the HKEY_DYN_DATA         predefined key"    ^HKEY_DYN_DATA</body><body package="Com- Win32">localMachine        "Private - answer an instance of the receiver class         which corresponds to the HKEY_LOCAL_MACHINE         predefined key"    ^self fromInteger: HKEY_LOCAL_MACHINE</body><body package="Com- Win32">localMachineId        "Private - answer the HKEY_LOCAL_MACHINE         predefined key"    ^HKEY_LOCAL_MACHINE</body><body package="Com- Win32">performanceData        "Private - answer an instance of the receiver class         which corresponds to the HKEY_PERFORMANCE_DATA         predefined key"    ^self fromInteger: HKEY_PERFORMANCE_DATA</body><body package="Com- Win32">performanceDataId        "Private - answer the HKEY_PERFORMANCE_DATA         predefined key"    ^HKEY_PERFORMANCE_DATA</body><body package="Com- Win32">users        "Private - answer an instance of the receiver class         which corresponds to the HKEY_USERS         predefined key"    ^self fromInteger: HKEY_USERS</body><body package="Com- Win32">usersId        "Private - answer the HKEY_USERS         predefined key"    ^HKEY_USERS</body></methods><methods><class-id>External.Win32RegKeyHandle class</class-id> <category>private</category><body package="Com- Win32">alternateSamModifier	^ObjectMemory is64Bit		ifTrue: [self modifierFor32Bit]		ifFalse: [self modifierFor64Bit]</body><body package="Com- Win32">bitModifierFor: accessRights	^accessRights bitAnd: (self modifierFor64Bit bitOr: self modifierFor32Bit)</body><body package="Com- Win32">errorBitModeSwitchingNotPossible	self error: #Switching32_64BitNotPossible &lt;&lt; #com				&gt;&gt; 'Switchting between 32 and 64 access not possible'</body><body package="Com- Win32">markFor32Bit: samValue	"mark the security access for 32 bit access. Make sure it has not been marked for 64 bit access before"	(samValue bitAnd: self modifierFor64Bit) = self modifierFor64Bit		ifTrue: [self errorBitModeSwitchingNotPossible].	^samValue bitOr: self modifierFor32Bit</body><body package="Com- Win32">markFor64Bit: samValue	"mark the security access for 64 bit access. Make sure it has not been marked for 32 bit access before"	(samValue bitAnd: self modifierFor32Bit) = self modifierFor32Bit		ifTrue: [self errorBitModeSwitchingNotPossible].	^samValue bitOr: self modifierFor64Bit</body><body package="Com- Win32">mergeAccessRightsOf: aWin32RegKeyHandle with: aSmallInteger	"Merge the Access rights of the keyhandle with the given integer, taking care that	 no invalid combination of 32/64 bit access modes are specified."	| bitModifier1 bitModifier2 bitModifier |	"Extract the 32/64 bit modifiers from the security access rights mask and combine it"	bitModifier1 := self				bitModifierFor: (self securityAccessFor: aWin32RegKeyHandle).	bitModifier2 := self bitModifierFor: aSmallInteger.	bitModifier := bitModifier1 bitOr: bitModifier2.	"Check if 32 and 64 bit modifier is set. In this case, raise an error"	((bitModifier bitAnd: self modifierFor32Bit) ~= 0		and: [(bitModifier bitAnd: self modifierFor64Bit) ~= 0])			ifTrue: [self errorBitModeSwitchingNotPossible].	^bitModifier		bitOr: ((self securityAccessFor: aWin32RegKeyHandle) bitAnd: aSmallInteger)</body><body package="Com- Win32">modifierFor32Bit	^KEY_WOW64_32KEY</body><body package="Com- Win32">modifierFor64Bit	^KEY_WOW64_64KEY</body><body package="Com- Win32">securityAccessFor: hKey	^hKey class == Win32RegKeyHandle		ifTrue: [hKey securityAccess]		ifFalse: 			["Usually an Integer"			KEY_ALL_ACCESS]</body></methods><methods><class-id>External.Win32RegKeyHandle class</class-id> <category>instance creation</category><body package="Com- Win32">fromInteger32Bits: anInteger	"Answer the registry handle for the platform handle specified as &lt;anInteger&gt;,	 assuming that it is an 32 bit registry key handle"	^(self fromInteger: anInteger)		securityAccess: (self markFor32Bit: KEY_ALL_ACCESS);		yourself</body><body package="Com- Win32">fromInteger64Bits: anInteger	"Answer the registry handle for the platform handle specified as &lt;anInteger&gt;,	 assuming that it is an 64 bit registry key handle"	^(self fromInteger: anInteger)		securityAccess: (self markFor64Bit: KEY_ALL_ACCESS);		yourself</body><body package="Com- Win32">fromInteger: anInteger	"^self fromHandle: anInteger"	"?? Do we need the heavy but correct version?? "	| instance |	instance := self fromHandle: ((CPointer new)						datum: anInteger;						type: Win32ExternalInterface current HKEY).	instance beConstant.	^instance</body></methods><methods><class-id>External.Win32BufferManager class</class-id> <category>private-accessing</category><body package="Com- Win32">pointerRegistry	" Private - answer the registry containing pointers allocated from the external heap which need to be released. "	^PointerRegistry</body><body package="Com- Win32">pointerRegistry: aRegistry	" Private - set the registry containing pointers allocated from the external heap which need to be released. "	PointerRegistry := aRegistry.</body><body package="Com- Win32">registerPointer: aPointer	" Private - register the malloc'd pointer &lt;aPointer&gt; as something we want to make sure gets cleaned up. "	self useGCHeapServices		ifTrue: [ aPointer beGarbageCollectable ]		ifFalse: [ self pointerRegistry add: aPointer ].</body><body package="Com- Win32">registeredPointers	" Private - answer all valid pointers in the registry. "	" Win32BufferManager registeredPointers "	^self pointerRegistry select: [ :lpDatum | lpDatum isValid ]</body><body package="Com- Win32">unregisterPointer: aPointer	" Private - unregister the malloc'd pointer &lt;aPointer&gt; as something we want to make sure gets cleaned up. "	self pointerRegistry remove: aPointer ifAbsent: [].</body></methods><methods><class-id>External.Win32BufferManager class</class-id> <category>buffer services</category><body package="Com- Win32">clearExternalBuffer: lpDatum type: aType count: count	" Clear the contents of a buffer allocated in external memory which contains &lt;count&gt; instances of the C datum &lt;aType&gt;. "	| nBytesToClear |	nBytesToClear := aType sizeof * count.	lpDatum copyAt: 0		from: ( ByteArray new: nBytesToClear )		size: nBytesToClear		startingAt: 1.</body></methods><methods><class-id>External.Win32BufferManager class</class-id> <category>allocation services</category><body package="Com- Win32">allocateBuffer: aType	" Allocate and return a buffer to contain the C datum &lt;aType&gt;. "	^self useFixedSpace		ifTrue: [ aType newInFixedSpace ]		ifFalse: [ self allocateHeapBuffer: aType ]</body><body package="Com- Win32">allocateBuffer: aType count: count	" Allocate and return a buffer to contain &lt;count&gt; instances of the C datum &lt;aType&gt;. "	" fixed space not supported for arrays of things, not polymorphic with pointer protocol "	^self allocateHeapBuffer: aType count: count</body><body package="Com- Win32">allocateHeapBuffer: aType	" Allocate and return a buffer from the external heap to contain the C datum &lt;aType&gt;. "	| lpDatum |	lpDatum := ( aType isComposite		ifTrue: [ aType new copyToHeap ]		ifFalse: [ aType malloc contents: 0; yourself ] ).	self registerPointer: lpDatum.	^lpDatum</body><body package="Com- Win32">allocateHeapBuffer: aType count: count	" Allocate and return a buffer from the external heap to contain &lt;count&gt; instances of the C datum &lt;aType&gt;. "	| lpDatum |	lpDatum := aType calloc: count.	self registerPointer: lpDatum.	^lpDatum</body><body package="Com- Win32">releaseBuffer: aDatum	" Release a previously allocated buffer containing the C datum &lt;aDatum&gt;. "	aDatum isPointer		ifTrue: [ 			self useGCHeapServices 				ifFalse: [ self unregisterPointer: aDatum ].			aDatum free ].</body></methods><methods><class-id>External.Win32BufferManager class</class-id> <category>private-installation</category><body package="Com- Win32">obsolete	"This class is being removed from the system."	self removeSessionEventHandlers.	^super obsolete.</body><body package="Com- Win32">registerSessionEventHandlers	" Private - register the image startup and shutdown event handlers. "	" Win32BufferManager registerSessionEventHandlers "	 COMSystem current		when: #coreStartupCompleted 			send: #startupImage to: self;		when: #shutdown 			send: #shutdownImage to: self.</body><body package="Com- Win32">removeSessionEventHandlers	" Private - remove the image startup and shutdown event handlers. "	" Win32BufferManager removeSessionEventHandlers "	COMSystem current removeAllActionsWithReceiver: self.</body></methods><methods><class-id>External.Win32BufferManager class</class-id> <category>allocation policies</category><body package="Com- Win32">useFixedSpace	" Answer whether to use fixed space rather than exterrnal heap allocations when possible. "	^UseFixedSpace</body><body package="Com- Win32">useFixedSpace: aBoolean 	" Specify whether to use fixed space rather than exterrnal heap allocations when possible. "	" Win32BufferManager useFixedSpace: false "	" Win32BufferManager useFixedSpace: true "	self registeredPointers size &gt; 0 		ifTrue: [self error: #ErrPointerRegNotEmpty &lt;&lt; #com &gt;&gt; 'pointer registry not empty'].	UseFixedSpace := aBoolean</body><body package="Com- Win32">useGCHeapServices	" Answer whether the more-expensive garbage-collected form of external heap allocation services for allocating buffers from the external heap. "	^UseGCHeapServices</body><body package="Com- Win32">useGCHeapServices: aBoolean 	" Specify whether the more-expensive garbage-collected form of external heap allocation services for allocating buffers from the external heap. "	self registeredPointers size &gt; 0 		ifTrue: [self error: #ErrPointerRegNotEmpty &lt;&lt; #com &gt;&gt; 'pointer registry not empty'].	UseGCHeapServices := aBoolean</body></methods><methods><class-id>External.Win32BufferManager class</class-id> <category>private-session management</category><body package="Com- Win32">shutdownImage	"Private - Process the malloc'd pointers registry.	This should be preceded by a gc compact."	self registeredPointers do: [ :aPointer | aPointer free ].</body><body package="Com- Win32">startupImage	"Private - Process the malloc'd pointers registry.	This should be preceded by a gc compact."	self registeredPointers do: [ :aPointer | aPointer enforceInvalidation ].  " just in case someone's still hanging on them "	self resetPointerRegistry.</body></methods><methods><class-id>External.Win32BufferManager class</class-id> <category>private-initialization</category><body package="Com- Win32">initializePointerRegistry	" Private- initialize the pointer registry. "	(self pointerRegistry notNil and: [self registeredPointers size &gt; 0]) 		ifTrue: [self error: #ErrPointerRegNotEmpty &lt;&lt; #com &gt;&gt; 'pointer registry not empty'].	self resetPointerRegistry</body><body package="Com- Win32">resetPointerRegistry	" Private- reset the pointer registry. "	self pointerRegistry: IdentitySet new.</body></methods><methods><class-id>External.Win32BufferManager class</class-id> <category>class initialization</category><body package="Com- Win32">initialize	self initializePointerRegistry.	self 		useFixedSpace: false;		useGCHeapServices: true.	self registerSessionEventHandlers.</body></methods><methods><class-id>External.Win32StructureResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">applyValueConstructionActionTo: aValue	" Private "	" in some cases we also want to apply a realization action and be done with it at this point "	^valueConstructionAction isNil		ifTrue: [ aValue ]		ifFalse: [ valueConstructionAction value: aValue ]</body><body package="Com- Win32">getResultValue	" Private - convert the buffer contents into a suitable structure value.  Answer the value. "	| aValue |	" we start with the raw structure data "	aValue := ( buffer isPointer		ifTrue: [ buffer contents ]  " bring the bits back in at this point "		ifFalse: [ buffer ] ).	" in most cases we wrap the raw bits with a structure accessor class "	structureClass notNil		ifTrue: [ aValue := structureClass fromReturnValue: aValue ].	" in some cases we also want to apply a realization action and be done with it at this point "	^self applyValueConstructionActionTo: aValue</body></methods><methods><class-id>External.Win32StructureResultBuffer</class-id> <category>private-accessing</category><body package="Com- Win32">structureClass: aStructureClass	" Private - specify the structure wrapper class to instantiate on the buffer contents. "	structureClass := aStructureClass.</body><body package="Com- Win32">structureType: aStructureType	" Private - specify the structure type to which we are getting a pointer back in the result buffer. "	structureType := aStructureType.</body><body package="Com- Win32">valueConstructionAction: aOneArgAction	" Private - specify the action to evaluate to realize the contents of the buffer as a useful action. "	valueConstructionAction := aOneArgAction.</body></methods><methods><class-id>External.Win32StructureResultBuffer</class-id> <category>printing</category><body package="Com- Win32">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	structureType notNil		ifTrue: [ 			aStream nextPutAll: ' ('.			buffer isNil  " already brought result value back in "				ifTrue: [ value printOn: aStream ]				ifFalse: [ aStream nextPutAll: 'for ', structureType name printString ].			aStream nextPutAll: ')' ].</body></methods><methods><class-id>External.Win32StructureResultBuffer</class-id> <category>accessing</category><body package="Com- Win32">memberAt: aMemberName put: aValue	" Initialize a member of the structure. "	buffer memberAt: aMemberName put: aValue.</body></methods><methods><class-id>External.Win32StructureResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^structureType</body></methods><methods><class-id>External.Win32StructureResultBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">for: aStructureClass type: aStructureType 	" Answer a new instance of the receiver which is used for bringing a structure value into the system via a buffer in which a structure of type &lt;aStructureType&gt; is obtained.  The structure is returned with &lt;aStructureClass&gt; instance as the wrapper. "	aStructureType isComposite 		ifFalse: [self error: #ErrNotStrucType &lt;&lt; #com &gt;&gt; 'not a structure type'].	^(self basicNew)		structureType: aStructureType;		structureClass: aStructureClass;		initialize;		yourself</body><body package="Com- Win32">for: aStructureClass type: aStructureType action: aOneArgAction 	" Answer a new instance of the receiver which is used for bringing a structure value into the system via a buffer in which a structure of type &lt;aStructureType&gt; is obtained.  The value obtained from the buffer is realized by wrapping it in an instance of &lt;aStructureClass&gt; and evaluating &lt;aOneArgAction&gt; on the structure. "	aStructureType isComposite 		ifFalse: [self error: #ErrNotStrucType &lt;&lt; #com &gt;&gt; 'not a structure type'].	^(self basicNew)		structureType: aStructureType;		structureClass: aStructureClass;		valueConstructionAction: aOneArgAction;		initialize;		yourself</body><body package="Com- Win32">forType: aStructureType 	" Answer a new instance of the receiver which is used for bringing a structure value into the system via a buffer in which a structure of type &lt;aStructureType&gt; is obtained. "	aStructureType isComposite 		ifFalse: [self error: #ErrNotStrucType &lt;&lt; #com &gt;&gt; 'not a structure type'].	^(self basicNew)		structureType: aStructureType;		initialize;		yourself</body><body package="Com- Win32">type: aStructureType action: aOneArgAction 	" Answer a new instance of the receiver which is used for bringing a structure value into the system via a buffer in which a structure of type &lt;aStructureType&gt; is obtained.  The value obtained from the buffer is realized by evaluating &lt;aOneArgAction&gt; on the structure. "	aStructureType isComposite 		ifFalse: [self error: #ErrNotStrucType &lt;&lt; #com &gt;&gt; 'not a structure type'].	^(self basicNew)		structureType: aStructureType;		valueConstructionAction: aOneArgAction;		initialize;		yourself</body></methods><methods><class-id>External.Win32MessageBox</class-id> <category>configuring</category><body package="Com- Win32">abortRetryIgnore        "Specify Abort, Retry, Ignore buttons."    style := style | MB_ABORTRETRYIGNORE.</body><body package="Com- Win32">applicationModal        "Make the receiver application modal."    style := style | MB_APPLMODAL.</body><body package="Com- Win32">defaultButton: anInteger        "Set the initially selected (default) pushbutton to        button # anInteger."    | flags |    anInteger = 1 ifTrue: [ flags := MB_DEFBUTTON1 ].    anInteger = 2 ifTrue: [ flags := MB_DEFBUTTON2 ].    anInteger = 3 ifTrue: [ flags := MB_DEFBUTTON3 ].    style := style | flags.</body><body package="Com- Win32">iconAsterisk        "Specify an asterisk icon; same as iconInformation."    style := style | MB_ICONASTERISK.</body><body package="Com- Win32">iconExclamation        "Specify an exclamation mark icon."    style := style | MB_ICONEXCLAMATION.</body><body package="Com- Win32">iconHand        "Specify a hand icon; same as iconStop"    style := style | MB_ICONHAND.</body><body package="Com- Win32">iconInformation        "Specify an information icon."    style := style | MB_ICONINFORMATION.</body><body package="Com- Win32">iconQuestion        "Specify a question mark icon."    style := style | MB_ICONQUESTION.</body><body package="Com- Win32">iconStop        "Specify a stop sign icon."    style := style | MB_ICONSTOP.</body><body package="Com- Win32">message: aString        "Set the message string to display to aString."    message := aString.</body><body package="Com- Win32">ok        "Specify OK button."    style := style | MB_OK.</body><body package="Com- Win32">okCancel        "Specify OK, Cancel buttons."    style := style | MB_OKCANCEL.</body><body package="Com- Win32">retryCancel        "Specify Retry, Cancel buttons."    style := style | MB_RETRYCANCEL.</body><body package="Com- Win32">systemModal        "Make the receiver system modal."    style := style | MB_SYSTEMMODAL.</body><body package="Com- Win32">taskModal        "Make the receiver task modal."    style := style | MB_TASKMODAL.</body><body package="Com- Win32">title: aString        "Set the title of the receiver to aString."    title := aString.</body><body package="Com- Win32">yesNo        "Specify Yes, No buttons."    style := style | MB_YESNO.</body><body package="Com- Win32">yesNoCancel        "Specify Yes, No, Cancel buttons."    style := style | MB_YESNOCANCEL.</body></methods><methods><class-id>External.Win32MessageBox</class-id> <category>accessing</category><body package="Com- Win32">result        "Answer the result for the selection made by the user; true        is the result when the first pushbutton is selected, false        is the result when the second pushbutton is selected, and        nil is the result when the third pushbutton is selected."    ^result</body><body package="Com- Win32">resultSymbol        "Answer a symbol corresponding to the user selection;        may be one of the following: #ok, #cancel, #yes, #no,        #retry, #ignore, #abort."    ^resultSymbol</body></methods><methods><class-id>External.Win32MessageBox</class-id> <category>operation</category><body package="Com- Win32">open        "Display the receiver, and answer the result corresponding        to the user selection."    | resultCode |    resultCode := self openDialog.    self getResult: resultCode.    ^result</body></methods><methods><class-id>External.Win32MessageBox</class-id> <category>subclass-initialization</category><body package="Com- Win32">initialize	"Private - initialize the receiver's state to default values."	title := ''.  "?? some standard WindowLabelPrefix ??"	style := 0.</body></methods><methods><class-id>External.Win32MessageBox</class-id> <category>private-operation</category><body package="Com- Win32">getResult: hostResult 	"Private - convert the host-specific result value to        normalized result; save this result &amp; symbolic result        for later access."	resultSymbol := ResultSymbols at: hostResult				ifAbsent: [self error: #ErrUnexpectedMBox &lt;&lt; #com &gt;&gt; 'Unexpected MessageBox result'].	hostResult = ID_OK ifTrue: [^result := true].	hostResult = ID_YES ifTrue: [^result := true].	hostResult = ID_NO ifTrue: [^result := false].	hostResult = ID_ABORT ifTrue: [^result := true].	hostResult = ID_IGNORE ifTrue: [^result := nil].	hostResult = ID_CANCEL 		ifTrue: 			[(style bitAnd: MB_TYPEMASK) = MB_OKCANCEL 				ifTrue: [^result := false]				ifFalse: [^result := nil]].	hostResult = ID_RETRY 		ifTrue: 			[(style bitAnd: MB_TYPEMASK) = MB_RETRYCANCEL 				ifTrue: [^result := true]				ifFalse: [^result := false]]</body><body package="Com- Win32">openDialog        "Display the receiver, and answer the result corresponding        to the user selection."	| hwndActive |	hwndActive := self getActiveWindowHandle.	^Win32UserDLL current MessageBoxEx: hwndActive		_: ( message isNil 			ifTrue: [ String new ] 			ifFalse: [ message ] )		_: title		_: style		_: 0</body></methods><methods><class-id>External.Win32MessageBox class</class-id> <category>opening</category><body package="Com- Win32">confirm: aString        "Display a message box with aString as the title and        'Yes' and 'No' for the choices.  Answer true if the         selection is Yes, else false."	" Win32MessageBox confirm: 'Is this what you want?' "    ^self new        title: (#confirm &lt;&lt; #labels &gt;&gt; 'Please Confirm');        message: aString;        iconQuestion;        yesNo;        open</body><body package="Com- Win32">confirm: titleString withText: aString defaultButton: aBoolean 	"Display a message box with aString as the title and 'Yes' and 'No' for the choices.  	Answer true if the selection is Yes, else false.	Preset the default button as aBoolean defines	Win32MessageBox confirm: 'Please Confirm' withText: 'Is this what you want?' defaultButton: true	Returns: 		&lt;Boolean&gt;"	^(self new)		title: titleString;		message: aString;		iconQuestion;		yesNo;		defaultButton: (aBoolean ifTrue: [1] ifFalse: [2]);		open</body><body package="Com- Win32">critical: aMessageString 	"Display a message box with messageString as the content and	 'OK' for the choices and a stop icon.	 Win32MessageBox critical: 'Title String' 	 Returns: 		"	^self critical: (#critical &lt;&lt; #com &gt;&gt; 'Critical Error') withText: aMessageString</body><body package="Com- Win32">critical: titleString withText: messageString 	"Display a message box with titleString as its title and messageString as the content and	 'OK' for the choices and a stop icon.	 Win32MessageBox critical: 'Title String' withText: 'Message text...' 	 Returns: 		"   ^self new        title: titleString;        message: messageString;        iconStop;        ok;        open</body><body package="Com- Win32">deferredNotify: titleString withText: messageString        " Post a deferred notifier. "	" Win32MessageBox deferredNotify: 'Title String' withText: 'Message text...' "	[ ( MessageSend        receiver: self        selector: #notify:withText:        arguments: ( Array with: titleString with: messageString ) )            "performDeferred"		value ] fork.</body><body package="Com- Win32">message: aString        "Display a message box with aString as the content and        'OK' for the choices."	" Win32MessageBox message: 'This is a message for you.' "    ^self new        title: (#information &lt;&lt; #labels &gt;&gt; 'Information');        message: aString;        iconInformation;        ok;        open</body><body package="Com- Win32">notify: titleString withText: messageString        "Display a message box with titleString as its        title and messageString as the content and        'OK' for the choices."	" Win32MessageBox notify: 'Title String' withText: 'Message text...' "    ^self new        title: titleString;        message: messageString;        iconExclamation;        ok;        open</body><body package="Com- Win32">threeStateNotify: titleString withText: messageString        "Display a message box with titleString as its         title and messageString as the content.  Display         buttons labeled 'Yes', 'No', and 'Cancel'.         Answer true, false, or nil.        Answer nil if the user cancels the dialog."	" Win32MessageBox threeStateNotify: 'Title String' withText: 'Message text...' "    ^self new        title: titleString;        message: messageString;        iconQuestion;        yesNoCancel;        open</body><body package="Com- Win32">warning: aString        "Display a warning message box with aString as the text."	" Win32MessageBox warning: 'Consider yourself warned!' "    self notify: (#warning &lt;&lt; #labels &gt;&gt; 'Warning') withText: aString</body></methods><methods><class-id>External.Win32MessageBox class</class-id> <category>private-opening</category><body package="Com- Win32">titled: aString withText: aString2 style: mbConstants        "Private - Open a message box with title aString and text aString2         and style mbConstants (from OperatingSystemConstants).         Answer an OperatingSystemConstant indicating the selection."    ^self new        title: aString;        message: aString2;        style: mbConstants;        openDialog</body></methods><methods><class-id>External.Win32MessageBox class</class-id> <category>private-installation</category><body package="Com- Win32">initialize	"Private - initialize a Dictionary mapping host-specific results        to result symbols."	ResultSymbols := (Dictionary new)				at: ID_OK put: #ok;				at: ID_CANCEL put: #cancel;				at: ID_YES put: #yes;				at: ID_NO put: #no;				at: ID_ABORT put: #abort;				at: ID_RETRY put: #retry;				at: ID_IGNORE put: #ignore;				yourself.	((BindingReference simpleName: #MessageBox) valueOrDo: [^nil])		registerPlatformProvider: self		for: #win32</body><body package="Com- Win32">obsolete	"The receiver was removed from the system and is now obsolete. 	 Perform any necessary clean-up. Answer the receiver."	#{MessageBox} ifDefinedDo: 		[:mb | mb unregisterPlatformProvider: self for: #win32].	^super obsolete</body></methods><methods><class-id>External.Win32_SYSTEMTIME</class-id> <category>converting</category><body package="Com- Win32">asDate        "Private - answer a Date object which contains the        same date as the receiver."    ^Date newDay: ( self memberAt: #wDay )        monthNumber: ( self memberAt: #wMonth )        year: ( self memberAt: #wYear )</body><body package="Com- Win32">asFileTime        "Private - answer the receiver converted to a Win32 FILETIME structure."	| resultReference succeeded |	resultReference := nil asValueReference.	succeeded := Win32KernelDLL current SystemTimeToFileTime: self 		_: resultReference.	^succeeded		ifTrue: [ resultReference value ]		ifFalse: [ nil ]</body><body package="Com- Win32">asTime        "Private - answer a Time object which contains the        same time as the receiver."    ^Time new        hours: ( self memberAt: #wHour )        minutes: ( self memberAt: # wMinute )        seconds: ( self memberAt: # wSecond )</body><body package="Com- Win32">asTimestamp	"Answer the receiver converted to a Timestamp object."	^Timestamp new		year: ( self memberAt: #wYear );		month: ( self memberAt: #wMonth  );		day: ( self memberAt: #wDay );		hour: ( self memberAt: #wHour );		minute: ( self memberAt: #wMinute );		second: ( self memberAt: #wSecond );		millisecond: ( self memberAt: #wMilliseconds );		yourself</body></methods><methods><class-id>External.Win32_SYSTEMTIME</class-id> <category>printing</category><body package="Com- Win32">printOn: aStream    aStream nextPutAll: self class name, ' { ', self asTimestamp printString, ' }'.</body></methods><methods><class-id>External.Win32_SYSTEMTIME class</class-id> <category>private-instance creation</category><body package="Com- Win32">fromDate: aDate time: aTime        "Private - answer a WinSystemTime based on the       specified date and time."    ^self new        memberAt: #wMonth put: aDate monthIndex;        memberAt: #wDay put: aDate dayOfMonth;        memberAt: #wYear put: aDate year;        memberAt: #wHour put: aTime hours;        memberAt: #wMinute put: aTime minutes;        memberAt: #wSecond put: aTime seconds;        memberAt: #wMilliseconds put: 0;   " unnecessary in fixed space, but safe "        yourself</body></methods><methods><class-id>External.Win32_SYSTEMTIME class</class-id> <category>instance creation</category><body package="Com- Win32">fromTimestamp: aTimestamp        "Private - answer a WinSystemTime based on the specified &lt;aTimestamp&gt;."    ^self new        memberAt: #wMonth put: aTimestamp month;        memberAt: #wDay put: aTimestamp day;        memberAt: #wYear put: aTimestamp year;        memberAt: #wHour put: aTimestamp hour;        memberAt: #wMinute put: aTimestamp minute;        memberAt: #wSecond put: aTimestamp second;        memberAt: #wMilliseconds put: aTimestamp millisecond;        yourself</body><body package="Com- Win32">getLocalTime	" Answer the current local date and time."	" Win32_SYSTEMTIME getLocalTime "	| resultReference |	resultReference := nil asValueReference.	Win32KernelDLL current GetLocalTime: resultReference.	^resultReference value</body><body package="Com- Win32">getSystemTime	" Answer the current system time. The system time is expressed in Coordinated Universal Time (UTC is the standard international time used internally by Windows NT). "	" Win32_SYSTEMTIME getSystemTime "	| resultReference |	resultReference := nil asValueReference.	Win32KernelDLL current GetSystemTime: resultReference.	^resultReference value</body><body package="Com- Win32">now	" Answer the current time."	" Win32_SYSTEMTIME now "	^self getLocalTime</body></methods><methods><class-id>External.Win32_SYSTEMTIME class</class-id> <category>class initialization</category><body package="Com- Win32">initialize	self structureName: #SYSTEMTIME.</body></methods><methods><class-id>External.Win32StructurePointerResultBuffer</class-id> <category>private-accessing</category><body package="Com- Win32">structureClass: aStructureClass	" Private - specify the structure wrapper class to instantiate on the buffer contents. "	structureClass := aStructureClass.</body><body package="Com- Win32">structureType: aStructureType	" Private - specify the structure type to which we are getting a pointer back in the result buffer. "	structureType := aStructureType.</body></methods><methods><class-id>External.Win32StructurePointerResultBuffer</class-id> <category>printing</category><body package="Com- Win32">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	structureType notNil		ifTrue: [ 			aStream nextPutAll: ' ('.			buffer isNil  " already brought result value back in "				ifTrue: [ value printOn: aStream ]				ifFalse: [ aStream nextPutAll: 'for ', structureType name printString ].			aStream nextPutAll: ')' ].</body></methods><methods><class-id>External.Win32StructurePointerResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^structureType pointerType</body></methods><methods><class-id>External.Win32StructurePointerResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">getResultValue	" Private - convert the buffer contents into a suitable value for the structure.  Answer the value. "	| lpStruct |	lpStruct := buffer contents.	lpStruct isNull		ifTrue: [ ^nil ].	^structureClass fromReturnValue: lpStruct.</body></methods><methods><class-id>External.Win32StructurePointerResultBuffer</class-id> <category>subclass-testing</category><body package="Com- Win32">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	^structureClass notNil		ifTrue: [ structureClass useFixedSpace ]		ifFalse: [ super useFixedSpace ]</body></methods><methods><class-id>External.Win32StructurePointerResultBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">for: aStructureClass type: aStructureType 	" Answer a new instance of the receiver which is used for bringing a structure value into the system via a buffer in which a pointer to a structure of type &lt;aStructureType&gt; is obtained.  The structure is returned with &lt;aStructureClass&gt; instance as the wrapper. "	aStructureType isComposite 		ifFalse: [self error: #ErrNotStrucType &lt;&lt; #com &gt;&gt; 'not a structure type'].	^(self basicNew)		structureType: aStructureType;		structureClass: aStructureClass;		initialize;		yourself</body><body package="Com- Win32">new	" Answer a new instance of the receiver. "	" a structure pointer buffer should only be constructed for obtaining the value of a specific structure "	self shouldNotImplement.</body></methods><methods><class-id>External.Win32UnicodeStringPointerResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^Win32ExternalInterface unicodeStringPointerType</body></methods><methods><class-id>External.Win32UnicodeStringPointerResultBuffer</class-id> <category>subclass-testing</category><body package="Com- Win32">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" force to external memory, at least until you figure out how to work with fixed space "	^false</body></methods><methods><class-id>External.Win32UnicodeStringPointerResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">getResultValue	" Private - convert the contents into a String.   Answer the string. "	| lpString |	( lpString := buffer contents ) isNull		 ifTrue: [ ^nil ].	^Win32ExternalInterface stringFromUnicodePointer: lpString</body></methods><methods><class-id>External.Win32_FILETIME</class-id> <category>printing</category><body package="Com- Win32">printOn: aStream    aStream nextPutAll: self class name, ' { ', self asTimestamp printString, ' }'.</body></methods><methods><class-id>External.Win32_FILETIME</class-id> <category>converting</category><body package="Com- Win32">asDate        "Answer the Date of the last write to the file        corresponding to the receiver."    ^self asSystemTime asDate</body><body package="Com- Win32">asSystemTime        "Private - answer the receiver converted to a Win32 SYSTEMTIME structure."	| resultReference succeeded |	resultReference := nil asValueReference.	succeeded := Win32KernelDLL current FileTimeToSystemTime: self 		_: resultReference.	^succeeded		ifTrue: [ resultReference value ]		ifFalse: [ nil ]</body><body package="Com- Win32">asTime        "Answer the Time of the last write to the file        corresponding to the receiver."    ^self asSystemTime asTime</body><body package="Com- Win32">asTimestamp	"Answer the receiver converted to a Timestamp object."	^Timestamp fromDate: self asDate andTime: self asTime</body></methods><methods><class-id>External.Win32_FILETIME class</class-id> <category>private-instance creation</category><body package="Com- Win32">fromDate: aDate time: aTime        "Private - answer a Win32 FILETIME structure based on the       specified date and time."	" Win32_FILETIME fromDate: Date today time: Time now "	^( Win32_SYSTEMTIME fromDate: aDate time: aTime ) asFileTime</body></methods><methods><class-id>External.Win32_FILETIME class</class-id> <category>class initialization</category><body package="Com- Win32">initialize	self structureName: #FILETIME.</body></methods><methods><class-id>External.Win32LargeInteger</class-id> <category>converting</category><body package="Com- Win32">asSignedInteger	" Answer the signed value in the receiver as an Integer. "	^self decodeLargeInteger</body><body package="Com- Win32">asUnsignedInteger	" Answer the unsigned value in the receiver as an Integer. "	^self decodeULargeInteger</body></methods><methods><class-id>External.Win32LargeInteger</class-id> <category>accessing-type information</category><body package="Com- Win32">type	" Answer the C data type of the structure accessed by the receiver. "	^self structure type</body></methods><methods><class-id>External.Win32LargeInteger</class-id> <category>private-converting</category><body package="Com- Win32">decodeLargeInteger	" Private - decode the 8-byte signed integer and answer the corresponding Integer value. "	" Implementation note: This low-level byte-twiddling implementation is probably working too hard.  This should be rewritten at some point to make more appropriate use of the underlying C type definitions. "    | off total bytes |    off := 1.    total := 0.    bytes := ( self isInExternalMemory        ifTrue: [ self structure contents ]        ifFalse: [ self structure ] )            datum.    ( bytes byteAt: off + 7 ) &gt;= 16r80        ifTrue: [   "negative"            7 to: 0 by: -1 do: [ :i |                total := ( total bitShift: 8 ) + ( ( bytes byteAt: off + i ) bitXor: 16rFF ) ].            total := ( total + 1 ) negated ]        ifFalse: [            7 to: 0 by: -1 do: [ :i |            total := ( total bitShift: 8 ) + ( bytes byteAt: off + i ) ] ].    ^total</body><body package="Com- Win32">decodeULargeInteger	" Private - answer the 8-byte unsigned integer encoded in the receiver as an Integer. "	"^( ( self uLongAtOffset: anInteger + 4 ) bitShift: 32 ) + ( self uLongAtOffset: anInteger )"	| fields |	fields := self structure memberAt: #u.	^( ( fields memberAt: #HighPart) bitShift: 32 )		+ ( fields memberAt: #LowPart )</body><body package="Com- Win32">encodeLargeIntegerFrom: anIntegerValue 	" Private - encode &lt;anIntegerValue&gt; in the receiver as an 8-byte signed value. "	" Implementation note: This low-level byte-twiddling implementation is probably working too hard.  This should be rewritten at some point to make more appropriate use of the underlying C type definitions. "	| off value low high aLargeInteger bytes |	(anIntegerValue between: -9223372036854775808 and: 9223372036854775807) 		ifFalse: 			[^self error: #ErrLargeIntRange &lt;&lt; #com 						&gt;&gt; 'LARGE_INTEGER value must be between -9223372036854775808  and +9223372036854775807'].	value := anIntegerValue positive 				ifTrue: [anIntegerValue]				ifFalse: [anIntegerValue negated - 1].	low := value bitAnd: 16rFFFFFFFF.	high := value bitShift: -32.	aLargeInteger := self isInExternalMemory 				ifTrue: [self class newSignedInteger]				ifFalse: [self].	" create a scratch local buffer for byte stuffing "	bytes := aLargeInteger structure datum.	off := 1.	bytes byteAt: off put: (low bitAnd: 16rFF).	bytes byteAt: off + 1 put: ((low bitShift: -8) bitAnd: 16rFF).	bytes byteAt: off + 2 put: ((low bitShift: -16) bitAnd: 16rFF).	bytes byteAt: off + 3 put: (low bitShift: -24).	bytes byteAt: off + 4 put: (high bitAnd: 16rFF).	bytes byteAt: off + 5 put: ((high bitShift: -8) bitAnd: 16rFF).	bytes byteAt: off + 6 put: ((high bitShift: -16) bitAnd: 16rFF).	bytes byteAt: off + 7 put: ((high bitShift: -24) bitAnd: 16rFF).	anIntegerValue negative 		ifTrue: 			[0 to: 7				do: [:i | bytes byteAt: off + i put: ((bytes byteAt: off + i) bitXor: 16rFF)]].	aLargeInteger == self 		ifFalse: 			[self structure 				copyAt: 0				from: bytes				size: bytes sizeInBytes				startingAt: 1].	^anIntegerValue</body><body package="Com- Win32">encodeULargeIntegerFrom: anIntegerValue 	" Private - encode &lt;anIntegerValue&gt; in the receiver as an 8-byte unsigned value. "	| aULargeInteger fields |	(anIntegerValue between: 0 and: 16rFFFFFFFFFFFFFFFF) 		ifFalse: 			[^self error: #ErrULargeIntRange &lt;&lt; #com 						&gt;&gt; 'ULARGE_INTEGER value must be between 0  and +18446744073709551615'].	"self		uLongAtOffset: anInteger put: ( anIntegerValue bitAnd: 16rFFFFFFFF );		uLongAtOffset: anInteger + 4 put: ( ( anIntegerValue bitShift: -32 ) bitAnd: 16rFFFFFFFF )."	aULargeInteger := self isInExternalMemory 				ifTrue: [self class newUnsignedInteger]				ifFalse: [self].	" create a scratch local buffer for byte stuffing "	fields := aULargeInteger memberAt: #u.	fields		memberAt: #LowPart put: (anIntegerValue bitAnd: 16rFFFFFFFF);		memberAt: #HighPart			put: ((anIntegerValue bitShift: -32) bitAnd: 16rFFFFFFFF).	aULargeInteger memberAt: #u put: fields.	aULargeInteger == self 		ifFalse: 			[self structure 				copyAt: 0				from: aULargeInteger structure datum				size: self class sizeInBytes				startingAt: 1].	^anIntegerValue</body></methods><methods><class-id>External.Win32LargeInteger class</class-id> <category>instance creation</category><body package="Com- Win32">forSignedReturnValue	" Answer a new instance of the receiver which is to be used to obtain a signed OUT parameter return value.  Since in general the ownership responsibility of an OUT parameter is transferred to the caller, mark the structure as needing finalization to ensure cleanup (if relevant).  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument. "	| aStructure |	aStructure := self onNew: ( self allocateStructure: Win32ExternalInterface current LARGE_INTEGER ).	"Assert isTrue: [ aStructure isSafeForExternalFunctionArgument ]."	^aStructure</body><body package="Com- Win32">forUnsignedReturnValue	" Answer a new instance of the receiver which is to be used to obtain an unsigned OUT parameter return value.  Since in general the ownership responsibility of an OUT parameter is transferred to the caller, mark the structure as needing finalization to ensure cleanup (if relevant).  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument. "	| aStructure |	aStructure := self onNew: ( self allocateStructure: Win32ExternalInterface current ULARGE_INTEGER ).	"Assert isTrue: [ aStructure isSafeForExternalFunctionArgument ]."	^aStructure</body><body package="Com- Win32">fromSignedInteger: anInteger        " Answer a new instance of the receiver with value &lt;anInteger&gt;        in LARGE_INTEGER format of an 8-byte signed integer. "	^self newSignedInteger		encodeLargeIntegerFrom: anInteger;		yourself</body><body package="Com- Win32">fromUnsignedInteger: anInteger        " Answer a new instance of the receiver with value &lt;anInteger&gt;        in ULARGE_INTEGER format of an 8-byte unsigned integer. "	^self newUnsignedInteger		encodeULargeIntegerFrom: anInteger;		yourself</body><body package="Com- Win32">maxValueSigned        " Answer a LARGE_INTEGER containing the maximum value that it can represent. "    ^self fromSignedInteger: 16r7FFFFFFFFFFFFFFF</body><body package="Com- Win32">maxValueUnsigned        " Answer a ULARGE_INTEGER containing the maximum value that it can represent. "    ^self fromUnsignedInteger: 16rFFFFFFFFFFFFFFFF</body><body package="Com- Win32">newSignedInteger	" Answer a new instance of the receiver for a LARGE_INTEGER with an internal byte buffer "	^self onNew: ( self allocateStructure: Win32ExternalInterface current LARGE_INTEGER )</body><body package="Com- Win32">newUnsignedInteger	" Answer a new instance of the receiver for a ULARGE_INTEGER with an internal byte buffer "	^self onNew: ( self allocateStructure: Win32ExternalInterface current ULARGE_INTEGER )</body></methods><methods><class-id>External.Win32LargeInteger class</class-id> <category>external-transformations</category><body package="Com- Win32">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery. "	" there are two types that map onto this class, so this is an ambiguous request "	self shouldNotImplement.</body></methods><methods><class-id>External.Win32LargeInteger class</class-id> <category>accessing-type information</category><body package="Com- Win32">sizeInBytes     " Answer the size in bytes of the structure represented by instances of the receiver. "	"^( self typeProvider typeNamed: #LARGE_INTEGER ) sizeof "	"^( self typeProvider typeNamed: #ULARGE_INTEGER ) sizeof "	^8</body></methods><methods><class-id>External.Win32LargeInteger class</class-id> <category>subclass-testing</category><body package="Com- Win32">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	^true</body></methods><methods><class-id>External.Win32ScalarResultBuffer</class-id> <category>private-accessing</category><body package="Com- Win32">scalarType: aType	" Private - specify the scalar type to which we are getting a pointer back in the result buffer. "	scalarType := aType.</body></methods><methods><class-id>External.Win32ScalarResultBuffer</class-id> <category>printing</category><body package="Com- Win32">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	scalarType notNil		ifTrue: [ 			aStream nextPutAll: ' ('.			buffer isNil  " already brought result value back in "				ifTrue: [ value printOn: aStream ]				ifFalse: [ aStream nextPutAll: 'for ', scalarType name printString ].			aStream nextPutAll: ')' ].</body></methods><methods><class-id>External.Win32ScalarResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Win32">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^scalarType</body></methods><methods><class-id>External.Win32ScalarResultBuffer</class-id> <category>accessing</category><body package="Com- Win32">contents: aValue	" Set the initial vaue of the buffer. "	buffer contents: aValue.</body></methods><methods><class-id>External.Win32ScalarResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Win32">getResultValue	" Private - convert the result buffer contents into a normal Smalltalk value.  Answer the value. "	^buffer contents</body></methods><methods><class-id>External.Win32ScalarResultBuffer class</class-id> <category>instance creation</category><body package="Com- Win32">for: aScalarType 	" Answer a new instance of the receiver which is used for bringing a scalar value into the system via a buffer in which a pointer to an element of type &lt;aScalarType&gt; is obtained. "	aScalarType isComposite 		ifTrue: [self error: #ErrNotForStrucType &lt;&lt; #com &gt;&gt; 'should not use for a structure type'].	^(self basicNew)		scalarType: aScalarType;		initialize;		yourself</body><body package="Com- Win32">new	" Answer a new instance of the receiver. "	" a scalar result buffer should only be constructed for obtaining the value of a specific type "	self shouldNotImplement.</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>converting</category><body package="Com- Win32">species        "Answer the class which closely approximates the receiver class,         for use in select:, reject:, etc."    ^Dictionary</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>private-accessing</category><body package="Com- Win32">isOpen	^ keyHandle notNil</body><body package="Com- Win32">keyHandle        "Private - answer the key handle."    ^keyHandle</body><body package="Com- Win32">keyHandle: aRegKeyHandle        "Private - set the key handle to aHandle."    keyHandle := aRegKeyHandle.</body><body package="Com- Win32">keyName        "Answer the hierarchical specification of the receiver"    ^keyName</body><body package="Com- Win32">keyName: aString        "Set the hierarchical specification of the receiver to aString"    keyName := aString.</body><body package="Com- Win32">registryAccessMode	"answer whether we want to access 32 or 64 bit keys specifically (#'32Bit' #'64Bit') 	or if we leave the decision to the API (nil)"	^registryAccessMode</body><body package="Com- Win32">registryAccessMode: aSymbol	(registryAccessMode notNil and: [registryAccessMode ~= aSymbol])		ifTrue: [self class regKeyHandleClass errorBitModeSwitchingNotPossible].	registryAccessMode := aSymbol.</body><body package="Com- Win32">rootHandle        "Private - answer the root handle of the receiver."    ^rootHandle</body><body package="Com- Win32">rootHandle: aRegKeyHandle        "Private - set the root handle of the receiver to aRegKeyHandle."    rootHandle := aRegKeyHandle.</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>accessing</category><body package="Com- Win32">add: anAssociation        "Add anAssociation to the receiver"    self at: anAssociation key put: anAssociation value.    ^anAssociation</body><body package="Com- Win32">at: aString        "Answer a new instance of the receiver class which spans         out from the node named aString; make sure the key exists         by trying to open the key"    ^self at: aString ifAbsent: [ self errorAbsentKey ]</body><body package="Com- Win32">at: aString ifAbsent: aBlock        "Answer a new instance of the receiver class which spans         out from the node named aString; if the key does not exist,         evaluate aBlock"    | subKeyName |    subKeyName := self keyName isInteger        ifTrue: [ aString ]        ifFalse: [ self keyName, '\', aString ].    ( self includesKey: aString ) ifFalse: [ ^aBlock value ].    ^self class new: subKeyName in: self rootHandle accessMode: self registryAccessMode</body><body package="Com- Win32">at: key put: value        "Set the value of the node named key to value"    self open.    ( self keyHandle create: key )        value: value;        close.    self close.    ^value</body><body package="Com- Win32">keys        "Answer a collection of keys of the receiver."    | array |    self openReadOnly.    array := self keyHandle enumKeys.    self close.    ^array</body><body package="Com- Win32">name	" Answer the key under which the receiver is defined. "    self keyName isInteger ifTrue: [        | regKeyHandleClass |        regKeyHandleClass := self class regKeyHandleClass.        self keyName = regKeyHandleClass classesRootId            ifTrue: [ ^'HKEY_CLASSES_ROOT' ].        self keyName = regKeyHandleClass currentUserId            ifTrue: [ ^'HKEY_CURRENT_USER' ].        self keyName = regKeyHandleClass localMachineId            ifTrue: [ ^'HKEY_LOCAL_MACHINE' ].        self keyName = regKeyHandleClass usersId            ifTrue: [ ^'HKEY_USERS' ].        self keyName = regKeyHandleClass currentConfigId            ifTrue: [ ^'HKEY_CURRENT_CONFIG' ].        self keyName = regKeyHandleClass dynDataId            ifTrue: [ ^'HKEY_DYN_DATA' ].        self keyName = regKeyHandleClass performanceDataId            ifTrue: [ ^'HKEY_PERFORMANCE_DATA' ].        ^'** UNRECOGNIZED ROOT KEY **' ].    ^( self keyName reverse readStream upTo: $\ ) reverse</body><body package="Com- Win32">namedValueAssociations        "Answer a collection of all named value key/value pairs, as Associations."    | associations values association |    associations := OrderedCollection new.    self openReadOnly.    values := self keyHandle enumValues.    self close.    values do: [ :value |        association := Association key: ( value at: 1 ) value: ( value at: 2 ).        associations add: association ].    ^associations</body><body package="Com- Win32">namedValueAt: namedValueKey        "Answer the value of the named value with key namedValueKey."    ^self namedValueAt: namedValueKey ifAbsent: [ self errorAbsentKey ]</body><body package="Com- Win32">namedValueAt: namedValueKey ifAbsent: aBlock        "Answer the value of the named value with key namedValueKey."    | value |    self openReadOnly.    value := self keyHandle valueNamed: namedValueKey.    self close.    ^value</body><body package="Com- Win32">namedValueAt: namedValueKey put: anObject        "Set the value of the named value with key namedValueKey to anObject."    self open.    self keyHandle valueNamed: namedValueKey put: anObject.    self close</body><body package="Com- Win32">namedValueKeys        "Answer a collection of named value keys of the receiver."    | array |    self openReadOnly.    array := self keyHandle enumValues.    self close.    ^array collect: [ :a | a at: 1 ]</body><body package="Com- Win32">publicKeys        "Answer an Array of the subkeys of the receiver; Windows reserved         keys are not included - use #keys if you want to include them"    ^self keys reject: [:s | s first = $.]</body><body package="Com- Win32">removeKey: aString        "Remove the subkey named aString starting at the         current node (named keyName)"    self open.    self keyHandle delete: aString.    self close.</body><body package="Com- Win32">value        "Answer the value of the current node; in Windows 3.1,         this value is always a String."    | value |    self openReadOnly.    value := self keyHandle value.    self close.    ^value</body><body package="Com- Win32">value: aString        "Set the value of the receiver node to aString; in         Windows 3.1, the values are always Strings."    self open.    self keyHandle value: aString.    self close.</body><body package="Com- Win32">valueProtected        "Answer the value of the current node; in Windows 3.1,         this value is always a String."    | value wasOpen |    wasOpen := self isOpen.    wasOpen ifFalse: [ self openReadOnly ].    value := self keyHandle value.    wasOpen ifFalse: [self close ].    ^value</body><body package="Com- Win32">values        "Answer a collection of the values corresponding to all the         keys of the receiver"    ^self keys collect: [:k | ( self at: k ) ]</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>enumerating</category><body package="Com- Win32">associations        "Answer a collection of all key/value pairs, as Associations."    | associations |    associations := OrderedCollection new.    self associationsDo: [ :assoc | associations add: assoc ].    ^associations</body><body package="Com- Win32">associationsDo: aBlock        "Answer the receiver.  For each key/value pair in the receiver,         evaluate aBlock with that association as an argument"    self keysDo: [ :key |        aBlock value: ( Association key: key value: ( self at: key ) ) ]</body><body package="Com- Win32">associationsSelect: aBlock        "For each key/value pair in the receiver, evaluate         aBlock with the association as the argument.         Answer a new object containing those key/value pairs         for which aBlock evaluates to true."    | answer |    answer := self species new.    self associationsDo: [ :each |        (aBlock value: each)            ifTrue: [answer add: each]].    ^answer</body><body package="Com- Win32">keysAndValuesDo: aBlock 	"Evaluate aBlock with each of the receiver's key/value pairs as the 	arguments."    self keysDo: [ :key |        aBlock value: key value: ( self at: key ) value ]</body><body package="Com- Win32">keysDo: aBlock        "Evaluate aBlock (a OneArgumentBlock) for each key in the receiver"    self keys do: [ :aKey | aBlock value: aKey ]</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>operations</category><body package="Com- Win32">close        "Close the receiver's key handle."    self keyName isInteger 		ifFalse: [ self keyHandle close ].</body><body package="Com- Win32">open	"Open the receiver's key handle."	self keyName isInteger		ifTrue: 			[self rootHandle: self keyName.			self keyHandle: self openRegKeyFromInteger]		ifFalse: [self keyHandle: self openRegKeyHandle]</body><body package="Com- Win32">openReadOnly	"Open the receiver's key handle."	self keyName isInteger		ifTrue: 			[self rootHandle: self keyName.			self keyHandle: self openRegKeyFromInteger]		ifFalse: [self keyHandle: self openReadOnlyRegKeyHandle]</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>printing</category><body package="Com- Win32">printHierarchyOn: aStream        "Append a hierarchical representation of the receiver to aStream"    self printHierarchyOn: aStream indent: ''</body><body package="Com- Win32">printHierarchyOn: aStream indent: aString 	"Append a hierarchical representation of the receiver to aStream,         using aString as the initial indentation - each subsequent level will         indent 3 more spaces"	self keysDo: 			[:key | 			| sub |			aStream nextPutAll: aString , key.			sub := self at: key.			sub value ifNotNil: 					[:value | 					aStream nextPutAll: ' = '.					value isString 						ifTrue: [aStream nextPutAll: value]						ifFalse: [aStream print: value]].			aStream cr.			sub printHierarchyOn: aStream indent: aString , '   ']</body><body package="Com- Win32">printOn: aStream        "Answer a human readable String which is used to represent         the receiver"    aStream nextPutAll: self valueProtected printString.</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>private-error handling</category><body package="Com- Win32">errorAbsentKey	"Private - Report an error message indicating that the         key was not found"	self error: #ErrKeyMissing &lt;&lt; #com &gt;&gt; 'Key is missing'</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>testing</category><body package="Com- Win32">alternateRegistrationDatabase	"For 64 Systems. Answer the alternate registration database. On a 32bit vm, this will answer 		 the 64bit database, on a 64 vm, it will answer the 32bit registratation database version.	 Please note that this will not work if the receiver is already configured for one type of access."	| alternate |	alternate := self copy.	ObjectMemory is64Bit ifTrue: [  alternate be32Bit ] ifFalse: [ alternate be64Bit ].	^ alternate</body><body package="Com- Win32">includesAlternateKey: aString	"Answer true if the receiver contains a alternate subkey named aString,         otherwise answer false. Alternate means the 64 bit key on 32 bit vms and the other way around"	^ self alternateRegistrationDatabase includesKey: aString</body><body package="Com- Win32">includesKey: aString        "Answer true if the receiver contains a subkey named aString,         otherwise answer false"    | exists handle |    self openReadOnly.    ( exists := ( handle := self keyHandle openReadOnly: aString ) notNil )        ifTrue: [ handle close ].    self close.    ^exists</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>private operation</category><body package="Com- Win32">openReadOnlyRegKeyHandle	^ self openRegKeyHandleAccess: External.Win32Constants.KEY_READ</body><body package="Com- Win32">openRegKeyFromInteger	self is32Bit		ifTrue: [^self class regKeyHandleClass fromInteger32Bits: self keyName].	self is64Bit		ifTrue: [^self class regKeyHandleClass fromInteger64Bits: self keyName].	^self class regKeyHandleClass fromInteger: self keyName</body><body package="Com- Win32">openRegKeyHandle	^ self openRegKeyHandleAccess: External.Win32Constants.KEY_ALL_ACCESS</body><body package="Com- Win32">openRegKeyHandleAccess: securityAccess	self is32Bit		ifTrue: 			[^self class regKeyHandleClass				open32Bit: self keyName				in: self rootHandle				securityAccess: securityAccess].	self is64Bit		ifTrue: 			[^self class regKeyHandleClass				open64Bit: self keyName				in: self rootHandle				securityAccess: securityAccess].	^self class regKeyHandleClass		open: self keyName		in: self rootHandle		securityAccess: securityAccess</body></methods><methods><class-id>External.Win32RegistrationDatabase</class-id> <category>32/64 bit Registry Access</category><body package="Com- Win32">be32Bit	"If registry keys are redirected, force the API to access 32 bit keys"	self registryAccessMode: #'32Bit'.</body><body package="Com- Win32">be64Bit	"If registry keys are redirected, force the API to access 64 bit keys"	^ self registryAccessMode: #'64Bit'</body><body package="Com- Win32">is32Bit	"return whether a 32 bit access mode has been specified for this registration database"	^ self registryAccessMode = #'32Bit'</body><body package="Com- Win32">is64Bit	"return whether a 64 bit access mode has been specified for this registration database"	^ self registryAccessMode = #'64Bit'</body></methods><methods><class-id>External.Win32RegistrationDatabase class</class-id> <category>instance creation</category><body package="Com- Win32">classesRoot        "Answer a new instance of the receiver         corresponding to the HKEY_CLASSES_ROOT         predefined key."    ^super new        keyName: self regKeyHandleClass classesRootId</body><body package="Com- Win32">currentConfig        "Answer a new instance of the receiver         corresponding to the HKEY_CURRENT_CONFIG         predefined key."    ^super new        keyName: self regKeyHandleClass currentConfigId</body><body package="Com- Win32">currentUser        "Answer a new instance of the receiver         corresponding to the HKEY_CURRENT_USER         predefined key."    ^super new        keyName: self regKeyHandleClass currentUserId</body><body package="Com- Win32">dynData        "Answer a new instance of the receiver         corresponding to the HKEY_DYN_DATA         predefined key."    ^super new        keyName: self regKeyHandleClass dynDataId</body><body package="Com- Win32">localMachine        "Answer a new instance of the receiver         corresponding to the HKEY_LOCAL_MACHINE         predefined key."    ^super new        keyName: self regKeyHandleClass localMachineId</body><body package="Com- Win32">new        "Answer a new instance of the receiver         corresponding to the HKEY_CLASSES_ROOT         predefined key."    ^self classesRoot</body><body package="Com- Win32">new: aString        "Answer a new instance of the receiver which spans out from         the hierarchy node named aString, in the CLASSES_ROOT         subtree; aString can be a full hierarchical specification,         such as:            ( RegistrationDatabase new: 'Package\protocol\StdFileEditing\verb\0' ) value "    ^self new        at: aString</body><body package="Com- Win32">new: aString in: aRootKey        "Answer a new instance of the receiver which spans out from         the hierarchy node named aString, from the specified root         key; aString can be a full hierarchical specification."    ^self new        rootHandle: aRootKey;        keyName: aString</body><body package="Com- Win32">new: aString in: aRootKey accessMode: accessMode	"Answer a new instance of the receiver which spans out from         the hierarchy node named aString, from the specified root         key; aString can be a full hierarchical specification."	^(self new)		rootHandle: aRootKey;		keyName: aString;		registryAccessMode: accessMode;		yourself</body><body package="Com- Win32">performanceData        "Answer a new instance of the receiver         corresponding to the HKEY_PERFORMANCE_DATA         predefined key."    ^super new        keyName: self regKeyHandleClass performanceDataId</body><body package="Com- Win32">users        "Answer a new instance of the receiver         corresponding to the HKEY_USERS         predefined key."    ^super new        keyName: self regKeyHandleClass usersId</body></methods><methods><class-id>External.Win32RegistrationDatabase class</class-id> <category>printing</category><body package="Com- Win32">printHierarchyOn: aStream        "Append a hierarchical representation of the complete         RegDB hierarchy to aStream"    self new printHierarchyOn: aStream</body><body package="Com- Win32">printRegistrationHierarchy        "Answer a String containing a hierarchical representation of         the complete RegDB hierarchy"	" Win32RegistrationDatabase printRegistrationHierarchy "    | stream |    stream := ReadWriteStream on: String new.    self printHierarchyOn: stream.    ^stream contents</body></methods><methods><class-id>External.Win32RegistrationDatabase class</class-id> <category>private-accessing</category><body package="Com- Win32">regKeyHandleClass 		"Answer the key handle class."	^Win32RegKeyHandle</body></methods><methods><class-id>External.COMCompiler</class-id> <category>public access</category><body package="Com- Win32">getExternalFor: textOrStream in: aClass notifying: aRequestor ifFail: failBlock 	"Answer the external which describes the COM method defined by &lt;textOrStream&gt;."	self from: textOrStream		class: aClass		context: nil		notifying: aRequestor.	^self translateToExternal: sourceStream		ifFail: failBlock		handlerClass:			(requestor isNil				ifTrue: [self nonInteractiveCompilerErrorHandlerClass]				ifFalse: [self interactiveCompilerErrorHandlerClass])</body></methods><methods><class-id>External.COMCompiler</class-id> <category>private</category><body package="Com- Win32">translate: aStream noPattern: noPattern ifFail: failBlock needSourceMap: mapFlag handler: handler	"noPattern is true for evaluation, false for compilation"	Tools.Note ISSUE; needsWork.  " Add error-checking in this guy to enforce the 		requirement that COM method declarations include a valid VTable index		and that implicit DLLCC types are not alllowed, i.e., you gotta do the data		type declarations properly.  [DL 15-Apr-97] "	^super translate: aStream noPattern: noPattern ifFail: failBlock needSourceMap: mapFlag handler: handler</body><body package="Com- Win32">translateToExternal: aStream ifFail: failBlock handler: handler	| methodNode holder codeStream method parser strongPointers |	"Make special provisions for compiling methods in classes that still use the old parser."	parser := class parserClass new.	methodNode := parser parseExternalDeclaration: aStream			class: class			context: context			notifying: handler			builder: ProgramNodeBuilder new			ifFail: [^failBlock value].true ifTrue: [	^parser external]."Note ISSUE.   Browse for interesting stuff and delete "	handler selector: methodNode selector.  "save selector in case of error"	codeStream := self newCodeStream.	strongPointers := OrderedCollection new.	self external: parser external.	parser externals notNil ifTrue:		[| targetClassExternals |		targetClassExternals := self targetClass externals.		Object errorSignal			handle: [:ex |				Dialog warn: ex errorString.				failBlock value]			do: [parser externals ownKeysAndValuesDo: [:key :anExternal |					targetClassExternals installAt: key put: anExternal.					strongPointers add: (targetClassExternals associationAt: key).				targetClassExternals weakenAt: key]]].	"Assuming restartRequest is meant here"	RestartRequest		handle: [:ex |				codeStream := self newCodeStream.				ex restart]		do: [codeStream				class: targetClass outerScope: (self scopeForMethod: methodNode);				requestor: handler.			false ifTrue: [codeStream saveSourceMap].			false				ifTrue: [methodNode emitValue: codeStream inContext: context]				ifFalse: [methodNode emitEffect: codeStream].			method := codeStream makeMethod: methodNode].	"The following seems like a hack but there doesn't seem to be a clean way	to initialize the new method given the current external unless CompiledMethod	is taught about externals which doesn't seem right either."	Object messageNotUnderstoodSignal		handle: [:ex | ex return]		do: [method				for: (self targetClass externals associationAt: self external name)				selector: methodNode selector].	"Generate methods for implicit externals, such as for 'bar' in 'typedef struct bar {..} foo' "	"strongPointers do: [:assoc |		assoc key ~~ self external name			ifTrue: [self targetClass generateMethodsForExternal: assoc value]]."	"If the method contains an attribute, reset the method to be an AnnotatedMethod.	Note that AnnotatedMethods are mutually exclusive with ExternalMethods -- one	can't have both yet."	method := method withAdditionalPropertiesFrom: methodNode.	holder := self newMethodHolder.	holder node: methodNode.	holder method: method.	false ifTrue: [holder sourceInfo: codeStream sourceInfo].	^holder</body><body package="Com- Win32">translateToExternal: aStream ifFail: failBlock handlerClass: handlerClass	"The handler class must be chosen appropriately	for interactive vs. non-interactive mode."	| handler |	handler := handlerClass new.	^handler		forClass: targetClass		on: sourceStream		for: requestor		onFailDo: failBlock		do: [:src |			self translateToExternal: src				ifFail: failBlock				handler: handler]</body></methods><methods><class-id>External.COMCompiler class</class-id> <category>parsing</category><body package="Com- Win32">preferredParserClass	^COMParser</body></methods><methods><class-id>External.COMCompiler class</class-id> <category>public access</category><body package="Com- Win32">getProcedureFor: aSelector class: aClass 	" Answer the ExternalProcedure which describes the COM method named &lt;aSelector&gt; in &lt;aClass&gt;. "	"alex: Moved this method to 'Com- OLE' package since it is only referenced in this one and it references	COMExternalMethod, which is defined in COM- OLE"	" COMCompiler getProcedureFor: #invokeQueryInterface:_: class: IUnknownPointer "	" COMCompiler getProcedureFor: #invokeAddRef class: IUnknownPointer "	| aMethod anExternalProcedure |	aMethod := aClass compiledMethodAt: aSelector.	(aMethod isKindOf: COMExternalMethod) 		ifFalse: [self error: #ErrNotCOMMethod &lt;&lt; #com &gt;&gt; 'not a COM method'].	aMethod external isNil 		ifFalse: [^aMethod external owner: aClass; yourself].	anExternalProcedure := self new 				getExternalFor: (aMethod getSourceIfAbsent: [aMethod decompiledSource])				in: aClass				notifying: nil				ifFail: [^nil].	^anExternalProcedure</body></methods><methods><class-id>UI.ValueHolder</class-id> <category>converting</category><body package="Com- Win32">isValueReference 	^ true</body><body package="Com- Win32">notEmpty	"for compatibility with ValueReference"	^ self value notNil</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Com- Win32">asValueReference	" Answer a reference to the receiver which allows it to be manipulated using the standard #value and #value: accessing protocol. "	^ValueReference on: self</body><body package="Com- Win32">isValueReference	" Answer whether the receiver is a value reference which supports the #value and #value: accessing protocol. "	^false</body></methods><methods><class-id>Core.Exception</class-id> <category>accessing</category><body package="Com- Win32">resetForReraise	"This is to get the exception instance ready for transport to the client side and reraise it in the calling thread.  The method 'copyForReraise' doesn't seem to be good enough to support user defined exception parameters.  Moreover, it seems to make sense to make the exception nonresumable, when raised in the client thread."	"This small method was copied from Protocols-Common for not having to add it as prerequisite."	messageText := self description.	initialContext := nil.	firstUnwindContext := nil.	handlerContext := nil.	proceedBlock := nil.	isResumable := false.	signal := nil.	searchContext := nil</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>constants-basic</category><body package="Com- Win32">CCHDEVICENAME	"/* size of a device name string */"	&lt;C: #define CCHDEVICENAME 32	&gt;</body><body package="Com- Win32">CCHFORMNAME	"/* size of a form name string */"	&lt;C: #define CCHFORMNAME 32	&gt;</body><body package="Com- Win32">MAX_PATH	&lt;C: #define MAX_PATH          260	&gt;</body><body package="Com- Win32">WINVER	" Win32 SDK for Windows 95 and Windows NT 3.5.1 (MS VC++ 4.0) "	&lt;C: #define WINVER 0x0400	&gt;</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>types-basic</category><body package="Com- Win32">ACCESS_MASK"From WinNT.h (types from NT exposed through Win32 API)//////////////////////////////////////////////////////////////////////////                                                                    ////                             ACCESS MASK                            ////                                                                    //////////////////////////////////////////////////////////////////////////////  Define the access mask as a longword sized structure divided up as//  follows:////       3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1//       1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0//      +---------------+---------------+-------------------------------+//      |G|G|G|G|Res'd|A| StandardRights|         SpecificRights        |//      |R|W|E|A|     |S|               |                               |//      +-+-------------+---------------+-------------------------------+////      typedef struct _ACCESS_MASK {//          WORD   SpecificRights;//          BYTE  StandardRights;//          BYTE  AccessSystemAcl : 1;//          BYTE  Reserved : 3;//          BYTE  GenericAll : 1;//          BYTE  GenericExecute : 1;//          BYTE  GenericWrite : 1;//          BYTE  GenericRead : 1;//      } ACCESS_MASK;//      typedef ACCESS_MASK *PACCESS_MASK;////  but to make life simple for programmer's we'll allow them to specify//  a desired access mask by simply OR'ing together mulitple single rights//  and treat an access mask as a DWORD.  For example////      DesiredAccess = DELETE | READ_CONTROL////  So we'll declare ACCESS_MASK as DWORD//// begin_ntddk begin_nthal begin_ntifs"	&lt;C: typedef DWORD ACCESS_MASK&gt;</body><body package="Com- Win32">ATOM	&lt;C: typedef WORD ATOM&gt;</body><body package="Com- Win32">BOOL	&lt;C: typedef __bool int BOOL&gt;</body><body package="Com- Win32">BYTE	&lt;C: typedef unsigned char BYTE&gt;</body><body package="Com- Win32">CHAR	&lt;C: typedef char CHAR&gt;</body><body package="Com- Win32">CLIPFORMAT	&lt;C: typedef WORD CLIPFORMAT&gt;</body><body package="Com- Win32">DATE	&lt;C: typedef double DATE&gt;</body><body package="Com- Win32">DECIMAL	&lt;C: typedef struct tagDEC DECIMAL&gt;</body><body package="Com- Win32">DEVMODEA	&lt;C: typedef struct _devicemodeA DEVMODEA&gt;</body><body package="Com- Win32">DOUBLE	&lt;C: typedef double DOUBLE&gt;</body><body package="Com- Win32">DWORD	&lt;C: typedef unsigned long DWORD&gt;</body><body package="Com- Win32">DWORDLONG	&lt;C: typedef unsigned int DWORDLONG&gt;</body><body package="Com- Win32">FARPROC	"&lt;C: typedef int (FAR WINAPI *FARPROC)()&gt;"	&lt;C: typedef int ( _stdcall *FARPROC)()&gt;</body><body package="Com- Win32">FILETIME	&lt;C: typedef struct _FILETIME FILETIME&gt;</body><body package="Com- Win32">FLOAT	&lt;C: typedef float FLOAT&gt;</body><body package="Com- Win32">HANDLE	"&lt;C: typedef PVOID HANDLE&gt;"	&lt;C: typedef void * HANDLE&gt;</body><body package="Com- Win32">HBITMAP	"&lt;C: typedef HANDLE HBITMAP&gt;"	&lt;C: typedef void * HBITMAP&gt;</body><body package="Com- Win32">HDC	"&lt;C: typedef HANDLE HDC&gt;"	&lt;C: typedef void * HDC&gt;</body><body package="Com- Win32">HEMF	"&lt;C: typedef HANDLE HEMF&gt;"	&lt;C: typedef void * HEMF&gt;</body><body package="Com- Win32">HENHMETAFILE	"&lt;C: typedef HANDLE HENHMETAFILE&gt;"	&lt;C: typedef void * HENHMETAFILE&gt;</body><body package="Com- Win32">HGLOBAL	"&lt;C: typedef HANDLE HGLOBAL&gt;"	&lt;C: typedef void * HGLOBAL&gt;</body><body package="Com- Win32">HICON	"&lt;C: typedef HANDLE HICON&gt;"	&lt;C: typedef void * HICON&gt;</body><body package="Com- Win32">HINSTANCE	&lt;C: typedef void * HINSTANCE&gt;</body><body package="Com- Win32">HMETAFILE	"&lt;C: typedef HANDLE HMETAFILE&gt;"	&lt;C: typedef void * HMETAFILE&gt;</body><body package="Com- Win32">HMETAFILEPICT	&lt;C: typedef void * HMETAFILEPICT&gt;</body><body package="Com- Win32">HMF	"&lt;C: typedef HANDLE HMF&gt;"	&lt;C: typedef void * HMF&gt;</body><body package="Com- Win32">HMODULE	&lt;C: typedef void * HMODULE&gt;</body><body package="Com- Win32">HRSRC	"&lt;C: typedef HANDLE HRSRC&gt;"	&lt;C: typedef void * HRSRC&gt;</body><body package="Com- Win32">HTASK	"&lt;C: typedef HANDLE HTASK&gt;"	&lt;C: typedef void * HTASK&gt;</body><body package="Com- Win32">HWND	"&lt;C: typedef HANDLE HWND&gt;"	&lt;C: typedef void * HWND&gt;</body><body package="Com- Win32">INT	&lt;C: typedef int INT&gt;</body><body package="Com- Win32">LANGID	&lt;C: typedef WORD LANGID&gt;</body><body package="Com- Win32">LARGE_INTEGER	&lt;C: typedef union _LARGE_INTEGER LARGE_INTEGER&gt;</body><body package="Com- Win32">LCID	&lt;C: typedef DWORD LCID&gt;</body><body package="Com- Win32">LONG	&lt;C: typedef long LONG&gt;</body><body package="Com- Win32">LONGLONG	&lt;C: typedef hyper LONGLONG&gt;</body><body package="Com- Win32">LPARAM	&lt;C: typedef LONG LPARAM&gt;</body><body package="Com- Win32">LPBYTE	&lt;C: typedef BYTE * LPBYTE&gt;</body><body package="Com- Win32">LPCRECT	&lt;C: typedef const RECT * LPCRECT&gt;</body><body package="Com- Win32">LPCRECTL	&lt;C: typedef const RECTL * LPCRECTL&gt;</body><body package="Com- Win32">LPCSTR	&lt;C: typedef const CHAR * LPCSTR&gt;</body><body package="Com- Win32">LPCTSTR	&lt;C: typedef /* [string] */ const TCHAR *LPCTSTR&gt;</body><body package="Com- Win32">LPCWSTR	&lt;C: typedef const WCHAR * LPCWSTR&gt;</body><body package="Com- Win32">LPDEVMODEA	&lt;C: typedef DEVMODEA * LPDEVMODEA&gt;</body><body package="Com- Win32">LPDWORD	&lt;C: typedef DWORD * LPDWORD&gt;</body><body package="Com- Win32">LPFILETIME	&lt;C: typedef struct _FILETIME * LPFILETIME&gt;</body><body package="Com- Win32">LPMSG	&lt;C: typedef struct tagMSG * LPMSG&gt;</body><body package="Com- Win32">LPRECT	&lt;C: typedef struct tagRECT * LPRECT&gt;</body><body package="Com- Win32">LPSIZEL	&lt;C: typedef SIZEL * LPSIZEL&gt;</body><body package="Com- Win32">LPSTR	&lt;C: typedef char * LPSTR&gt;</body><body package="Com- Win32">LPSYSTEMTIME	&lt;C: typedef struct _SYSTEMTIME * LPSYSTEMTIME&gt;</body><body package="Com- Win32">LPTSTR	&lt;C: typedef /* [string] */ TCHAR *LPTSTR&gt;</body><body package="Com- Win32">LPVOID	&lt;C: typedef void * LPVOID&gt;</body><body package="Com- Win32">LPWORD	&lt;C: typedef WORD * LPWORD&gt;</body><body package="Com- Win32">LPWSTR	&lt;C: typedef WCHAR * LPWSTR&gt;</body><body package="Com- Win32">LRESULT	&lt;C: typedef LONG LRESULT&gt;</body><body package="Com- Win32">METAFILEPICT	&lt;C: typedef struct tagMETAFILEPICT METAFILEPICT&gt;</body><body package="Com- Win32">MSG	&lt;C: typedef struct tagMSG MSG&gt;</body><body package="Com- Win32">PFILETIME	&lt;C: typedef struct _FILETIME *PFILETIME&gt;</body><body package="Com- Win32">PLONG	&lt;C: typedef LONG * PLONG&gt;</body><body package="Com- Win32">POINT	&lt;C: typedef struct tagPOINT POINT&gt;</body><body package="Com- Win32">POINTF	&lt;C: typedef struct tagPOINTF POINTF&gt;</body><body package="Com- Win32">POINTL	&lt;C: typedef struct _POINTL POINTL&gt;</body><body package="Com- Win32">PVOID	&lt;C: typedef void * PVOID&gt;</body><body package="Com- Win32">RECT	&lt;C: typedef struct tagRECT RECT&gt;</body><body package="Com- Win32">RECTL	&lt;C: typedef struct _RECTL RECTL&gt;</body><body package="Com- Win32">SHORT	&lt;C: typedef short SHORT&gt;</body><body package="Com- Win32">SIZE	&lt;C: typedef struct tagSIZE SIZE&gt;</body><body package="Com- Win32">SIZEL	&lt;C: typedef SIZE SIZEL&gt;</body><body package="Com- Win32">SYSTEMTIME	&lt;C: typedef struct _SYSTEMTIME SYSTEMTIME&gt;</body><body package="Com- Win32">TCHAR	&lt;C: typedef WCHAR TCHAR&gt;</body><body package="Com- Win32">UINT	&lt;C: typedef unsigned int UINT&gt;</body><body package="Com- Win32">ULARGE_INTEGER	&lt;C: typedef union _ULARGE_INTEGER ULARGE_INTEGER&gt;</body><body package="Com- Win32">ULONG	&lt;C: typedef DWORD ULONG&gt;</body><body package="Com- Win32">ULONGLONG	&lt;C: typedef unsigned __int64 ULONGLONG&gt;</body><body package="Com- Win32">USHORT	&lt;C: typedef unsigned short USHORT&gt;</body><body package="Com- Win32">WCHAR	&lt;C: typedef wchar_t WCHAR&gt;</body><body package="Com- Win32">WORD	&lt;C: typedef unsigned short WORD&gt;</body><body package="Com- Win32">WPARAM	&lt;C: typedef UINT WPARAM&gt;</body><body package="Com- Win32">hyper	&lt;C: typedef __int64 hyper&gt;</body><body package="Com- Win32">wchar_t	&lt;C: typedef unsigned short wchar_t&gt;</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>structs-basic</category><body package="Com- Win32">_FILETIME	&lt;C: struct _FILETIME {		DWORD dwLowDateTime;		DWORD dwHighDateTime;		}&gt;</body><body package="Com- Win32">_POINTL	&lt;C: struct _POINTL {			LONG x, y;		}&gt;</body><body package="Com- Win32">_RECTL	&lt;C: struct _RECTL {			LONG left, top, right, bottom;		}&gt;</body><body package="Com- Win32">_SYSTEMTIME	&lt;C: struct _SYSTEMTIME {		WORD wYear;		WORD wMonth;		WORD wDayOfWeek;		WORD wDay;		WORD wHour;		WORD wMinute;		WORD wSecond;		WORD wMilliseconds;		}&gt;"MemberswYear Specifies the current year. wMonth Specifies the current month; January = 1, February = 2, and so on. wDayOfWeek Specifies the current day of the week; Sunday = 0, Monday = 1, and so on. wDay Specifies the current day of the month. wHour Specifies the current hour. wMinute Specifies the current minute. wSecond Specifies the current second. wMilliseconds Specifies the current millisecond. RemarksIt is not recommended that you add and subtract values from the SYSTEMTIME structure to obtain relative times. Instead, you should: Convert the SYSTEMTIME structure to a FILETIME structure. Copy the resulting FILETIME structure to a LARGE_INTEGER structure. Use normal 64-bit arithmetic on the LARGE_INTEGER value."</body><body package="Com- Win32">_devicemodeA	&lt;C: struct _devicemodeA {     BYTE   dmDeviceName[CCHDEVICENAME];    WORD dmSpecVersion;    WORD dmDriverVersion;    WORD dmSize;    WORD dmDriverExtra;    DWORD dmFields;    short dmOrientation;    short dmPaperSize;    short dmPaperLength;    short dmPaperWidth;    short dmScale;    short dmCopies;    short dmDefaultSource;    short dmPrintQuality;    short dmColor;    short dmDuplex;    short dmYResolution;    short dmTTOption;    short dmCollate;    BYTE   dmFormName[CCHFORMNAME];    WORD   dmLogPixels;    DWORD  dmBitsPerPel;    DWORD  dmPelsWidth;    DWORD  dmPelsHeight;    DWORD  dmDisplayFlags;    DWORD  dmDisplayFrequency;//#if (WINVER &gt;= 0x0400)    DWORD  dmICMMethod;    DWORD  dmICMIntent;    DWORD  dmMediaType;    DWORD  dmDitherType;    DWORD  dmReserved1;    DWORD  dmReserved2;//#endif /* WINVER */	}&gt;</body><body package="Com- Win32">tagDEC	&lt;C: struct tagDEC {		USHORT wReserved;		union {			struct {				BYTE scale;				BYTE sign;			} s1;		USHORT signscale;		} u1;		ULONG Hi32;		union {			struct {				ULONG Lo32;				ULONG Mid32;			} s2;		ULONGLONG Lo64;		} u2;	}&gt;"Note: I had to add names to structures and unions. [GG 3-May-1997]""From wtypes.h: Note the #ifdef for the Mactypedef struct tagDEC {    USHORT wReserved;    union {        struct {            BYTE scale;            BYTE sign;        };        USHORT signscale;    };    ULONG Hi32;    union {        struct {#ifdef _MAC            ULONG Mid32;            ULONG Lo32;#else            ULONG Lo32;            ULONG Mid32;#endif        };        ULONGLONG Lo64;    };} DECIMAL;"</body><body package="Com- Win32">tagMETAFILEPICT	&lt;C: struct tagMETAFILEPICT {		    LONG        mm;		    LONG        xExt;		    LONG        yExt;		    HMETAFILE   hMF;		}&gt;</body><body package="Com- Win32">tagMSG	&lt;C: struct tagMSG {			HWND hwnd;			UINT message;			WPARAM wParam;			LPARAM lParam;			DWORD time;			POINT pt;		}&gt;</body><body package="Com- Win32">tagPOINT	&lt;C: struct tagPOINT {			LONG x, y;		}&gt;</body><body package="Com- Win32">tagPOINTF	&lt;C: struct tagPOINTF {			float x, y;		}&gt;</body><body package="Com- Win32">tagRECT	&lt;C: struct tagRECT {			LONG left, top, right, bottom;		}&gt;</body><body package="Com- Win32">tagSIZE	&lt;C: struct tagSIZE {			LONG cx, cy;		}&gt;</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>structs-common dialogs</category><body package="Com- Win32">tagOFNA	&lt;C: struct tagOFNA {   DWORD        lStructSize;   HWND         hwndOwner;   HINSTANCE    hInstance;   LPCSTR       lpstrFilter;   LPSTR        lpstrCustomFilter;   DWORD        nMaxCustFilter;   DWORD        nFilterIndex;   LPSTR        lpstrFile;   DWORD        nMaxFile;   LPSTR        lpstrFileTitle;   DWORD        nMaxFileTitle;   LPCSTR       lpstrInitialDir;   LPCSTR       lpstrTitle;   DWORD        Flags;   WORD         nFileOffset;   WORD         nFileExtension;   LPCSTR       lpstrDefExt;   LPARAM       lCustData;   LPOFNHOOKPROC lpfnHook;   LPCSTR       lpTemplateName;}&gt;</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>structs</category><body package="Com- Win32">tagOFNW	&lt;C: struct tagOFNW {			DWORD lStructSize;			HWND hwndOwner;			HINSTANCE hInstance;			LPCWSTR lpstrFilter;			LPWSTR lpstrCustomFilter;			DWORD nMaxCustFilter, nFilterIndex;			LPWSTR lpstrFile;			DWORD nMaxFile;			LPWSTR lpstrFileTitle;			DWORD nMaxFileTitle;			LPCWSTR lpstrInitialDir, lpstrTitle;			DWORD Flags;			WORD nFileOffset, nFileExtension;			LPCWSTR lpstrDefExt;			LPARAM lCustData;			LPOFNHOOKPROC lpfnHook;			LPCWSTR lpTemplateName;			void * pvReserved;			DWORD dwReserved, FlagsEx;		}&gt;</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>types-common dialogs</category><body package="Com- Win32">LPOFNHOOKPROC	&lt;C: typedef UINT (_stdcall *LPOFNHOOKPROC) (HWND, UINT, WPARAM, LPARAM)&gt;</body><body package="Com- Win32">LPOPENFILENAMEA	&lt;C: typedef struct tagOFNA * LPOPENFILENAMEA&gt;</body><body package="Com- Win32">LPOPENFILENAMEW	&lt;C: typedef OPENFILENAMEW * LPOPENFILENAMEW&gt;</body><body package="Com- Win32">OPENFILENAMEW	&lt;C: typedef struct tagOFNW { 			DWORD         lStructSize; 			HWND          hwndOwner; 			HINSTANCE     hInstance; 			LPCWSTR       lpstrFilter; 			LPWSTR        lpstrCustomFilter; 			DWORD         nMaxCustFilter; 			DWORD         nFilterIndex; 			LPWSTR        lpstrFile; 			DWORD         nMaxFile; 			LPWSTR        lpstrFileTitle; 			DWORD         nMaxFileTitle; 			LPCWSTR       lpstrInitialDir; 			LPCWSTR       lpstrTitle; 			DWORD         Flags; 			WORD          nFileOffset; 			WORD          nFileExtension; 			LPCWSTR       lpstrDefExt; 			LPARAM        lCustData; 			LPOFNHOOKPROC lpfnHook; 			LPCWSTR       lpTemplateName; 			/* #if (_WIN32_WINNT &gt;= 0x0500) */  				void *        pvReserved;  				DWORD         dwReserved;  				DWORD         FlagsEx;			/* #endif (_WIN32_WINNT &gt;= 0x0500) */		} OPENFILENAMEW&gt;</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>types-registry</category><body package="Com- Win32">HKEY	"&lt;C: typedef HANDLE HKEY&gt;"	&lt;C: typedef void * HKEY&gt;</body><body package="Com- Win32">PHKEY	&lt;C: typedef HKEY *PHKEY&gt;</body><body package="Com- Win32">REGSAM"// Requested Key access mask type."	&lt;C: typedef ACCESS_MASK REGSAM&gt;</body></methods><methods><class-id>External.Win32ExternalInterface</class-id> <category>unions-basic</category><body package="Com- Win32">_LARGE_INTEGER	&lt;C: union _LARGE_INTEGER {			struct {				DWORD LowPart;				LONG HighPart;			} u;			LONGLONG QuadPart;		}&gt;</body><body package="Com- Win32">_ULARGE_INTEGER	&lt;C: union _ULARGE_INTEGER {			struct {				DWORD LowPart, HighPart;			} u;			ULONGLONG QuadPart;		}&gt;</body></methods><methods><class-id>External.Win32CommonDialogDLL</class-id> <category>types</category><body package="Com- Win32">LPOPENFILENAMEW	&lt;C: typedef void * LPOPENFILENAMEW&gt;</body></methods><methods><class-id>External.Win32CommonDialogDLL</class-id> <category>API operations</category><body package="Com- Win32">CommDlgExtendedError	"return the last error that occurred when trying to launch a system common dialog box"	&lt;C: DWORD CommDlgExtendedError(void)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32CommonDialogDLL</class-id> <category>private-invocation</category><body package="Com- Win32">invokeGetOpenFileName: lpOpenFileName	&lt;C: BOOL _threaded GetOpenFileNameW(LPOPENFILENAMEW lpOpenFileName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetSaveFileName: lpOpenFileName	&lt;C: BOOL _threaded GetSaveFileNameW(LPOPENFILENAMEW lpOpenFileName)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32AdvApiDLL</class-id> <category>private-invocation</category><body package="Com- Win32">invokeRegCloseKey: hKey	&lt;C: LONG RegCloseKey (HKEY hKey)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegCreateKey: hKey _: lpSubKey _: phkResult	&lt;C: LONG RegCreateKeyW (			HKEY hKey,			LPCWSTR lpSubKey,			PHKEY phkResult			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegCreateKeyEx: hKey _: lpSubKey _: Reserved _: lpClass _: dwOptions _: samDesired _: lpSecurityAttributes _: phkResult _: lpdwDisposition 	&lt;C: LONG __stdcall RegCreateKeyExW(  			/*__in*/        HKEY hKey,  			/*__in*/        LPCTSTR lpSubKey,    			/*__reserved*/  DWORD Reserved,    			/*__in_opt*/    LPTSTR lpClass,    			/*__in*/       DWORD dwOptions,    			/*__in*/        REGSAM samDesired,    			/*__in_opt*/    LPSECURITY_ATTRIBUTES lpSecurityAttributes,    			/*__out*/       PHKEY phkResult,    			/*__out_opt*/   LPDWORD lpdwDisposition)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegDeleteKey: hKey _: lpSubKey	&lt;C: LONG RegDeleteKeyW (			HKEY hKey,			LPWSTR lpSubKey			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegDeleteKeyEx: hKey _: lpSubKey _: samDesired _: Reserved	&lt;C: LONG __stdcall RegDeleteKeyExW(  	/*__in*/        HKEY hKey,  	/*__in*/        LPCTSTR lpSubKey,  	/*__in*/        REGSAM samDesired,  	/*__reserved*/  DWORD Reserved)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegEnumKey: hKey _: dwIndex _: lpName _: cbName	&lt;C: LONG RegEnumKeyW (			HKEY hKey,			DWORD dwIndex,			LPWSTR lpName,			DWORD cbName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegEnumKeyEx: hKey _: dwIndex _: lpName _: lpcbName _: lpReserved _: lpClass _: lpcbClass _:lpftLastWriteTime	"The RegEnumKeyEx function enumerates subkeys of the specified open registry key. The function retrieves information about one subkey each time it is called. Unlike the RegEnumKey function, RegEnumKeyEx retrieves the class name of the subkey and the time it was last modified. Copy the name of the (N-1)th subkey of hKey in the RegDB into buffer"	&lt;C: LONG RegEnumKeyExW (			HKEY hKey,				DWORD dwIndex,				LPWSTR lpName,				LPDWORD lpcbName,				LPDWORD lpReserved,				LPWSTR lpClass,				LPDWORD lpcbClass,				PFILETIME lpftLastWriteTime)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegEnumValue: hKey _: dwIndex _: lpValueName _: lpcbValueName _: lpReserved _: lpType _: lpData _: lpcbData	&lt;C: LONG RegEnumValueW (			HKEY hKey,			DWORD dwIndex,			LPWSTR lpValueName,			LPDWORD lpcbValueName,			LPDWORD lpReserved,			LPDWORD lpType,			LPBYTE lpData,			LPDWORD lpcbData			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegOpenKey: hKey _: lpSubKey _: phkResult	&lt;C: LONG RegOpenKeyW (			HKEY hKey,			LPCWSTR lpSubKey,			PHKEY phkResult			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegOpenKeyEx: hKey _: lpSubKey _: ulOptions _: samDesired _: phkResult"LONG RegOpenKeyEx(    HKEY hKey,				// handle of open key     LPCTSTR lpSubKey,		// address of name of subkey to open     DWORD ulOptions,		// reserved     REGSAM samDesired,	// security access mask     PHKEY phkResult 		// address of handle of open key    );"	&lt;C: LONG RegOpenKeyExW (			HKEY hKey,			LPCWSTR lpSubKey,    			DWORD ulOptions,		    		REGSAM samDesired,				PHKEY phkResult			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegQueryValue: hKey _: lpSubKey _: lpValue _: lpcbValue	&lt;C: LONG RegQueryValueW (			HKEY hKey,			LPCWSTR lpSubKey,			LPWSTR lpValue,			PLONG   lpcbValue			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegQueryValueEx: hKey _: lpValueName _: lpReserved _: lpType _: lpData _: lpcbData	&lt;C: LONG RegQueryValueExW(			HKEY hKey,			LPCWSTR lpValueName,			LPDWORD lpReserved,			LPDWORD lpType,			LPBYTE lpData,			LPDWORD lpcbData)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegSetValue: hKey _: lpSubKey _: dwType _: lpData _: cbData	&lt;C: LONG RegSetValueW (			HKEY hKey,			LPCWSTR lpSubKey,			DWORD dwType,			LPCWSTR lpData,			DWORD cbData			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegSetValueEx: hKey _: lpValueName _: reserved _: dwType _: lpData _: cbData	&lt;C: LONG RegSetValueExW (			HKEY hKey,			LPCWSTR lpValueName,			DWORD reserved,			DWORD dwType,			const BYTE* lpData,			DWORD cbData			)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>private-invocation-windows</category><body package="Com- Win32">invokeBringWindowToTop: hWnd	&lt;C: BOOL BringWindowToTop(HWND hWnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeCopyImage: hImage type: uType cxDesired: cxDesired cyDesired: cyDesired flags: fuFlags	&lt;C: HANDLE __stdcall CopyImage( 		/* _In_ */ HANDLE hImage, 		/*_In_ */ UINT uType, 		/*_In_*/  int cxDesired,  		/*_In_*/  int cyDesired,  		/*_In_*/  UINT fuFlags)&gt;		^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeFindWindowW: lpClassName _: lpWindowName	&lt;C: HWND FindWindowW (LPCWSTR lpClassName, LPCWSTR lpWindowName )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetActiveWindow	&lt;C: HWND GetActiveWindow (void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetClientRect: hWnd _: lpRect	&lt;C: BOOL GetClientRect(HWND hWnd, LPRECT lpRect)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetDC: hWnd	&lt;C: HDC GetDC(HWND hWnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetDesktopWindow	&lt;C: HWND GetDesktopWindow(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetFocus	&lt;C: HWND GetFocus (void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeIsWindow: hWnd	&lt;C: BOOL IsWindow (HWND hWnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeIsWindowUnicode: hWnd	&lt;C: BOOL IsWindowUnicode(HWND hWnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeReleaseDC: hWnd _: hDC	&lt;C: int ReleaseDC(HWND hWnd, HDC hDC)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeSendMessageA: hWnd _: Msg _: wParam _: lParam	&lt;C: LRESULT SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeSendMessageW: hWnd _: Msg _: wParam _: lParam	&lt;C: LRESULT SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeSetFocus: hWnd	&lt;C: HWND SetFocus (HWND hWnd)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeWindowFromPoint: point	&lt;C: HWND WindowFromPoint (POINT point)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>private-invocation-clipboard</category><body package="Com- Win32">invokeCloseClipboard	&lt;C: BOOL _wincall CloseClipboard(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeEmptyClipboard	&lt;C: BOOL _wincall EmptyClipboard(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetClipboardData: uFormat	&lt;C: HANDLE _wincall GetClipboardData (UINT uFormat)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetClipboardFormatName: format _: lpszFormatName _: cchMaxCount	&lt;C: int GetClipboardFormatNameW (UINT format, LPWSTR lpszFormatName, int cchMaxCount)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetClipboardOwner	&lt;C: HWND GetClipboardOwner(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeOpenClipboard: hWndNewOwner	&lt;C: BOOL OpenClipboard( HWND hWndNewOwner)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeRegisterClipboardFormat: lpszFormat	&lt;C: UINT _wincall RegisterClipboardFormatW (LPCWSTR lpszFormat)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeSetClipboardData: uFormat _: hMem	&lt;C: HANDLE _wincall SetClipboardData (UINT uFormat, HANDLE hMem)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>API operations-utilities</category><body package="Com- Win32">GetSysColor: nIndex	&lt;C: DWORD GetSysColor(int nIndex)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>API operations-clipboard</category><body package="Com- Win32">IsClipboardFormatAvailable: format	&lt;C: BOOL IsClipboardFormatAvailable (UINT format)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32UserDLL</class-id> <category>private-invocation-utilities</category><body package="Com- Win32">invokeMessageBeep: duration	&lt;C: BOOL _wincall MessageBeep(int duration)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeMessageBoxExW: hWnd _: lpText _: lpCaption _: uType _: wLanguageId	&lt;C: int _threaded _wincall MessageBoxExW(			HWND hWnd ,			LPCWSTR lpText,			LPCWSTR lpCaption,			UINT uType,			WORD wLanguageId)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32KernelDLL</class-id> <category>private-invocation</category><body package="Com- Win32">invokeBeep: dwFreq _: dwDuration	&lt;C:  BOOL __wincall Beep (DWORD dwFreq, DWORD dwDuration )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeFileTimeToSystemTime: lpFileTime _: lpSystemTime	&lt;C: BOOL _wincall FileTimeToSystemTime(			const FILETIME *lpFileTime,			LPSYSTEMTIME lpSystemTime			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeFormatMessage: dwFlags _: source  _: dwMessageId  _: dwLanguageId  _: lpBuffer _: nSize  _: arguments    &lt;C: DWORD __stdcall FormatMessageW(DWORD dwFlags, unsigned int source, DWORD dwMessageId, DWORD dwLanguageId, LPWSTR lpBuffer, DWORD nSize, /*va_list*/ void *arguments)&gt;	^self externalAccessFailedWith: _errorCode"Jigsaw automatic port of VSE bindings to internal buffers changed OUT arg type to use internal String buffer:    &lt;C: unsigned int __stdcall FormatMessageA(unsigned int flags, unsigned int source, unsigned int messageId, unsigned int languageId, char _oopref * buffer, unsigned int size, unsigned int arguments)&gt;"</body><body package="Com- Win32">invokeFreeLibrary: hLibModule	&lt;C: BOOL FreeLibrary(HMODULE hLibModule)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetCommandLine	&lt;C: LPWSTR GetCommandLineW (void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetLocalTime: lpSystemTime	&lt;C: void GetLocalTime (LPSYSTEMTIME lpSystemTime)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetProcAddress: hModule _: lpProcName	&lt;C: FARPROC GetProcAddress(			HMODULE hModule,			LPCSTR lpProcName			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetSystemDefaultLCID	&lt;C: LCID GetSystemDefaultLCID (void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetSystemDefaultLangID	&lt;C: LANGID GetSystemDefaultLangID (void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetSystemTime: lpSystemTime	&lt;C: void GetSystemTime (LPSYSTEMTIME lpSystemTime)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetUserDefaultLCID	&lt;C: LCID GetUserDefaultLCID (void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGetUserDefaultLangID	&lt;C: LANGID GetUserDefaultLangID (void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGlobalAlloc: uFlags _: dwBytes	&lt;C: HGLOBAL _wincall GlobalAlloc(UINT uFlags, DWORD dwBytes)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGlobalFree: hMem	&lt;C: HGLOBAL GlobalFree(HGLOBAL hMem)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGlobalLock: hMem	&lt;C: LPVOID _wincall GlobalLock(HGLOBAL hMem)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGlobalReAlloc: hMem _: dwBytes _: uFlags	&lt;C: HGLOBAL _wincall GlobalReAlloc ( HGLOBAL hMem, DWORD dwBytes, UINT uFlags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGlobalSize: hMem	&lt;C: DWORD GlobalSize(HGLOBAL hMem)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeGlobalUnlock: hMem	&lt;C: BOOL GlobalUnlock(HGLOBAL hMem)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeLoadLibrary: lpLibFileName	&lt;C: HMODULE _wincall LoadLibraryW(LPCWSTR lpLibFileName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeSearchPath: lpPath _: lpFileName _: lpExtension _: nBufferLength _: lpBuffer _: lpFilePart	&lt;C: DWORD SearchPathW(			LPCWSTR lpPath,			LPCWSTR lpFileName,			LPCWSTR lpExtension,			DWORD nBufferLength,			LPWSTR lpBuffer,			LPWSTR *lpFilePart			)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Win32">invokeSystemTimeToFileTime: lpSystemTime _: lpFileTime	&lt;C: BOOL _wincall SystemTimeToFileTime (			const SYSTEMTIME *lpSystemTime,			LPFILETIME lpFileTime			)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.Win32KernelDLL</class-id> <category>API operations</category><body package="Com- Win32">IsValidLocale: aLocale _: dwFlags	"BOOL IsValidLocale(  		LCID Locale,    // locale identifier to validate		DWORD dwFlags   // specifies validity test);"	&lt;C: BOOL IsValidLocale(LCID aLocale, DWORD dwFlags) &gt;	^self externalAccessFailedWith: _errorCode</body></methods><initialize><class-id>External.Win32FileDialog</class-id></initialize><initialize><class-id>External.Win32ClipboardInterface</class-id></initialize><initialize><class-id>External.Win32BufferManager</class-id></initialize><initialize><class-id>External.Win32MessageBox</class-id></initialize><initialize><class-id>External.Win32_SYSTEMTIME</class-id></initialize><initialize><class-id>External.Win32_FILETIME</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalStructure</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structure memberNames protocolMap </inst-vars><class-inst-vars>structureName </class-inst-vars><imports></imports><category>External-Data-Extensions</category><attributes><package>Com- External Data Enhancements</package></attributes></class><class><name>ValueHolder</name><environment>UI</environment><super>UI.ValueModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Support</category><attributes><package>Interface-Support</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ExternalInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>includeFiles includeDirectories libraryFiles libraryDirectories virtual optimizationLevel </class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>ExtendedCompiler</name><environment>Kernel</environment><super>Kernel.Compiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>external </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Parsing</category><attributes><package>DLLCC</package></attributes></class><class><name>ExternalStream</name><environment>OS</environment><super>Core.PositionableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class></st-source>