<?xml version="1.0"?><st-source><!-- Name: Com- Automation DevelopmentNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: This parcel contains development-time code for COM AutomationDbIdentifier: bear73DbTrace: 497457DbUsername: alexDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'Com- Automation' '') #(#any 'Com- Event-Enabled Application Extensions' '') #(#any 'Com- Ole Development' '') #(#any 'UIPainter' '') #(#any 'Tools-Settings' '') #(#any 'Tools-Settings-VW' '') #(#any 'Browser-Environments' '') #(#any 'Com- Automation Pools' '') #(#any 'Com- CodeAnnotations' '') #(#any 'Com- List Choice Dialogs' '') #(#any 'Com- Ole' '') #(#any 'Com- Ole Pools' '') #(#any 'Com- Interface Adaptors' ''))DialectVersion: VisualWorks 7.9PackageName: Com- Automation DevelopmentParcel: #('ComAutomationDevelopment')ParcelName: Com- Automation DevelopmentPrerequisiteDescriptions: #(#(#name 'Com- Automation') #(#name 'Com- Event-Enabled Application Extensions') #(#name 'Com- Ole Development') #(#name 'UIPainter') #(#name 'Tools-Settings' #componentType #package) #(#name 'Tools-Settings-VW' #componentType #package) #(#name 'Browser-Environments' #componentType #package) #(#name 'Com- Automation Pools' #componentType #package) #(#name 'Com- CodeAnnotations' #componentType #package) #(#name 'Com- List Choice Dialogs' #componentType #package) #(#name 'Com- Ole' #componentType #package) #(#name 'Com- Ole Pools' #componentType #package) #(#name 'Com- Interface Adaptors' #componentType #package))PrerequisiteParcels: #(#('Com- Automation' '') #('Com- Event-Enabled Application Extensions' '') #('Com- Ole Development' '') #('UIPainter' '') #('Tools-Settings' '') #('Tools-Settings-VW' '') #('Browser-Environments' '') #('Com- Automation Pools' '') #('Com- CodeAnnotations' '') #('Com- List Choice Dialogs' '') #('Com- Ole' '') #('Com- Ole Pools' '') #('Com- Interface Adaptors' ''))PrintStringCache: (8.3 - 1,alex)Version: 8.3 - 1Date: 1:50:06 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:06</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>IDLTypeLibraryDefinition</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comClasses classDefinitions creator companyName fileName libraryHolder libraryName interfaceName lcid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>IDLParametersDefinition</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>paramDefs </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>IDLMethodsDefinition</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodDefinitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>IDLPropertiesDefinition</name><environment>Tools</environment><super>Tools.IDLMethodsDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>ComAutomationWizardDeployPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>Tools.ComAutomationWizardDeployPage</class-id><body>ComAutomationWizardDeployPage interface page to the COM Automation Wizard names the image and type library deployed and prepares the image for deployments.</body></comment><class><name>COMAutomationEditor</name><environment>External</environment><super>UI.EventEnabledApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispatcherName dispatcher evaluationTextModel textEditor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Development Support</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>External.COMAutomationEditor</class-id><body>The class COMAutomationEditor is an simple COM Automation controller application which provides an editor window for evaluating expressions to invoke methods and properties of an automation object through an dispatch driver.  The text view is used to type Smalltalk expressions that can be selected and evaluated using the Evaluation menu commands.The Smalltalk code fragments that you evaluate in the text pane have available to it a variable, usually named 'dispatcher', which is the COM dispatch driver on the dispatch interface of the automation object being manipulated.  You send messages to the dispatcher to invoke methods and to get or set properties.  These messages are dispatched to the automation object via its IDispatch interface. The COMAutomationEditor is useful for interactive experimenting with a live automation object, but of course you must first understand the services provided by the object through its dispatch interface in order to know what methods and properties can be manipulated.  You must obtain information about the capabilities of the automation object from suitable sources, usually provided in some form by the publisher of the object.The Developer menu provides access to utility services for inspecting the dispatcher and generating reports about the dispatch interface members in the specification table of the dispatch driver.  The contents of the reports that are generated describing the dispatch specification table vary according to the automation object being manipulated and how you have configured the dispatch driver with specfiications and policies.  Please consult the COM Connect user documentation for more information about COMDispatchDriver and the various options that are available for configuring its specification and lookup policies.Instance Variables	dispatcherName	&lt;String&gt;	The name of the dispatcher variable for expression evaluation.	dispatcher	&lt;COMDispatchDriver&gt; - The dispatch driver on the automation object.	evaluationTextModel	&lt;ValueModel | nil&gt; The ValueModel for the text pane - contains a String.</body></comment><class><name>IDispatchTraceAdaptor</name><environment>External</environment><super>External.IUnknownTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dispidMap </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			External.COMAutomationConstants.*			</imports><category>COM-Automation-Trace Support</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>External.IDispatchTraceAdaptor</class-id><body>IDispatchTraceAdaptor provides interface function tracing for operations in the IDispatch interface.</body></comment><class><name>ComAutomationWizardGUIDGenPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className classMethodList instanceMethodList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id><body>ComAutomationWizardGUIDGenPage nterface page to the COM Automation Wizard supports GUID stub method creation and compilation for a COM classInstance Variables:	classMethodList	&lt;MultiSelectionInList&gt;	selections for interface class methods to install.	className	&lt;ValueModel&gt;		COM class name.	instanceMethodList	&lt;MultiSelectionInList&gt;	selections for instance stub methods to install.</body></comment><class><name>EmptyCOMServerClass</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Development</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>External.EmptyCOMServerClass</class-id><body>This class only exists for suppressing CodeCritics errors in "Com- Automation Development".</body></comment><class><name>IDLParameterDefinition</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type returnType flags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>IDLMethodDefinition</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodName parameters parameterTypes returnTypes helpString parameterDefs stSelector optionalParameterCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>IDLPropertyDefinition</name><environment>Tools</environment><super>Tools.IDLMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>ComAutomationWizardClassesPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classFinder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>Tools.ComAutomationWizardClassesPage</class-id><body>ComAutomationWizardClassesPage interface page to the COM Automation Wizard is used to select the COM interface classes to export in a server image. Instance Variables:	classFinder	&lt;ClassFinder&gt;	class selection tool</body></comment><class><name>COMAutomationTypeAnalyzer</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stockPropertyActions stream methodSpecifications propertySpecifications eventSpecifications role </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			External.COMAutomationConstants.*			</imports><category>COM-Automation-Development Support</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>External.COMAutomationTypeAnalyzer</class-id><body>COMAutomationTypeAnalyzer provides utilities for describing the members of a dispatch interface and generating the specification table literals.  It can be used at development time to construct dispatch specification table definitions for COM automation controllers.</body></comment><class><name>ComAutomationWizardRegFilePage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>className classRegistrationHolder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>Tools.ComAutomationWizardRegFilePage</class-id><body>ComAutomationWizardRegFilePage  interface page to the COM Automation Wizard supports registration file creation and registration of a COM class.Instance Variables:	className	&lt;ValueModel on: Behavior&gt;	COM class to register.	regConfigurations	&lt;Dictionary&gt;	entries to be registered by attribute symbol.</body></comment><class><name>ComAutomationWizardSettings</name><environment>Tools</environment><super>Tools.SettingsDomain</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectClassList typeLibraryClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>Tools.ComAutomationWizardSettings</class-id><body>ComAutomationWizardSettings is the group of settings and setting pages defining the interface and data for the COM Automation Wizard.Instance Variables:	objectClassList	&lt;MultiSelectionInList&gt;	class selections to export	typeLibraryClass	&lt;ValueModel on: Behavior&gt;	current class to export</body></comment><class><name>IDLClassDefinition</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methodsDefinitions propertiesDefinitions comClass externalName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>ComAutomationWizardIDLGenPage</name><environment>Tools</environment><super>Tools.SettingsManagerPage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comClassList libraryDefinition typelibraryLCID bitsForStubCode lcid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>Tools.ComAutomationWizardIDLGenPage</class-id><body>ComAutomationWizardIDLGenPage interface page to the COM Automation Wizard supports type library creation and compilation.Instance Variables:	comClassList	&lt;MultiSelectionInList&gt;	selections for class interfaces to export	libraryDefinition	&lt;IDLTypeLibraryDefinition&gt;	type library definitions are installed here	typelibraryLCID	&lt;ValueModel on: Symbol&gt;	LCID for type library.</body></comment><class><name>ComAutomationWizard</name><environment>Tools</environment><super>Tools.SettingsManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>Tools.ComAutomationWizard</class-id><body>ComAutomationWizard is a COM application tool for assigning, registering, and creating a server image exporting a VisualWorks COM interface.</body></comment><class><name>IDLSetPropertyDefinition</name><environment>Tools</environment><super>Tools.IDLMethodDefinition</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>ComAutomationWizardRegFileSettings</name><environment>Tools</environment><super>Tools.SettingsDomain</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><class><name>COMEventTraceViewer</name><environment>Tools</environment><super>UI.EventEnabledApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventNotificationMap eventSink enableTracing traceLog </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Automation-Development Support</category><attributes><package>Com- Automation Development</package></attributes></class><comment><class-id>Tools.COMEventTraceViewer</class-id><body>The COMEventTraceViewer class demonstrates using a COMEventSink to receive COM event notifications in Smalltalk. The application is a simple event trace logger which reports every event triggered by the event source object in a log window.  The example demonstrates two styles of notification: all events from the event sink are reported to a single message or interest in individual events is registered, with a separate message sent for each.  The lattter is probably a more common style, where a client would register handlers only for the events of interest, although in the case we blindly register handlers for everything.In order to use an event sink, you must first have a COM object which generates events.  Given that you have an event source object, class messages are provided to open a COMEventTraceViewer in which event occurrences are reported.  For some interface on an event source object which can dynamically provide type information describing the event interface supported by the class, the event trace viewer can be opened by an expression of the form:	COMEventTraceViewer openOn: anInterfaceIf the event source does not provide its class type information, you must construct the event specifications for the event sink from another source, such as the type library, using services provided by COMDispatchSpecificationTable or the development utility COMAutomationTypeAnalyzer.Note that you are responsible for ensuring that the COMEventTraceViewer is closed (thus disconnecting the event sink) before the event source object is released.</body></comment><class><name>ComAutomationWizardRegConf</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>settingsGroup interfaceClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Automation-Tools</category><attributes><package>Com- Automation Development</package></attributes></class><shared-variable><name>LeaveConsoleUp</name><environment>Tools.ComAutomationWizard</environment><private>false</private><constant>false</constant><category>local globals</category><initializer>false</initializer><attributes><package>Com- Automation Development</package></attributes></shared-variable><shared-variable><name>BatchFileNeeded</name><environment>Tools.ComAutomationWizard</environment><private>false</private><constant>false</constant><category>local globals</category><initializer>false</initializer><attributes><package>Com- Automation Development</package></attributes></shared-variable><shared-variable><name>VCVARS32File</name><environment>Tools.ComAutomationWizard</environment><private>false</private><constant>false</constant><category>local globals</category><initializer>false</initializer><attributes><package>Com- Automation Development</package></attributes></shared-variable><shared-variable><name>RelayEventNotifications</name><environment>Tools.COMEventTraceViewer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation Development</package></attributes></shared-variable><shared-variable><name>DisplayFeedback</name><environment>External.COMAutomationTypeAnalyzer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Automation Development</package></attributes></shared-variable><methods><class-id>Tools.IDLTypeLibraryDefinition</class-id> <category>printing</category><body package="Com- Automation Development">classDefinitionsCommentOn: aStream 	classDefinitions		do: 			[:def | 			aStream nextPutAll: '//'; cr.			aStream nextPutAll: '// CLSID_'; nextPutAll: def classDescription , ':'.			aStream tab.			aStream nextPutAll: def classID; cr.			aStream nextPutAll: '// Interface:'; tab.			aStream nextPutAll: def interfaceDescription.			aStream tab; nextPutAll: '{' , def interfaceID , '}'; cr]</body><body package="Com- Automation Development">classDefinitionsOn: aStream 	classDefinitions do: [:def | def printOn: aStream]</body><body package="Com- Automation Development">componentDescriptionsOn: aStream 	aStream nextPutAll: 'library ' , libraryName; cr.	aStream nextPutAll: '{'; cr.	aStream tab; nextPutAll: 'importlib("stdole32.tlb");'; cr.	aStream tab; nextPutAll: 'importlib("stdole2.tlb");'; cr.	classDefinitions		do: 			[:def | 			| str |			aStream tab; nextPutAll: '// Class information for ' , def comClassName; cr.			aStream tab; nextPutAll: '[uuid('.			str := def classID.			aStream nextPutAll: (str copyFrom: 2 to: str size - 1).			aStream nextPutAll: '),'; cr.			aStream tab; nextPutAll: 'helpstring("' , def comClassName , ' class")]'; cr.			str := def externalName.			aStream tab; nextPutAll: 'coclass ' , str; cr.			aStream tab; nextPut: ${; cr.			aStream tab; nextPutAll: ' //'; cr.			aStream tab; nextPutAll: ' // This next line surfaces the dispinterface from the class.'; cr.			aStream tab; nextPutAll: ' //'; cr.			aStream tab; nextPutAll: ' [default] dispinterface ' , def interfaceDescription , 'Disp;'; cr.			aStream tab; nextPutAll: '};'; cr].	aStream nextPutAll: '};'; cr.	aStream nextPutAll: '// eof'; cr</body><body package="Com- Automation Development">cpp_quotesOn: aStream 	aStream cr; nextPutAll: 'cpp_quote("//+-------------------------------------------------------------------------")cpp_quote("//")'.	aStream cr; nextPutAll: 'cpp_quote("//  Created by ',  creator, '")'.	aStream cr; nextPutAll: 'cpp_quote("//  Copyright (C) ',  companyName, ', ', Date today year printString, '.")'.	aStream cr; nextPutAll: 'cpp_quote("//")cpp_quote("//--------------------------------------------------------------------------")'.	aStream cr</body><body package="Com- Automation Development">headerCommentOn: aStream	aStream nextPutAll: '//'; cr.	aStream nextPutAll: '// This file will be processed by the MIDL compiler to// produce the type library ('.	aStream nextPutAll: fileName, '.tlb'.	aStream nextPutAll: ') and marshalling code.//'; cr.</body><body package="Com- Automation Development">importFileNamesOn: aStream 	self importedFiles		do: 			[:fn | 			aStream nextPutAll: 'import "' , fn , '";'.			aStream cr]</body><body package="Com- Automation Development">printOn: aStream 		[self headerCommentOn: aStream.	self typeLibraryCommentOn: aStream.	self classDefinitionsCommentOn: aStream.	self referenceCommentOn: aStream.	self importFileNamesOn: aStream.	self cpp_quotesOn: aStream.	aStream flush.	self classDefinitionsOn: aStream.	self typeLibraryDefinitionsOn: aStream]		ensure: [aStream close]</body><body package="Com- Automation Development">referenceCommentOn: aStream 	aStream nextPutAll: '//'; cr.	aStream nextPutAll: '// For the legal data types permited on an [oleautomation] interface see// Microsoft Developer Network Library -- Visual Studio 97 CD:// mk:@ivt:pdapp/native/sdk/rpc/src/mi-laref_100.htm//// -------------------------------------------------------------------------------------------'</body><body package="Com- Automation Development">typeLibraryCommentOn: aStream 	aStream nextPutAll: '//'; cr.	aStream nextPutAll: '// Type library: '.	aStream nextPutAll: fileName , '.tlb'.	aStream tab.	aStream nextPutAll: (classDefinitions at: 1) typeLibraryID asString; cr</body><body package="Com- Automation Development">typeLibraryDefinitionsOn: aStream	self typeLibraryHeaderOn: aStream.	self typeLibraries do: 			[:lib |			| str |			str := lib libraryID asString.			aStream				nextPutAll: '[uuid(' , (str copyFrom: 2 to: str size - 1) , '),';				cr.	"hardcode this for now"			self lcid				ifNotNil: 					[aStream						nextPutAll: (' lcid(0x0&lt;1s&gt;),'									expandMacrosWith: (self lcid printStringRadix: 16));						cr].			aStream				nextPutAll: ' version(' , lib majorVersion printString , '.'							, lib minorVersion printString , '),';				cr.			aStream nextPutAll: ' helpstring("'.			aStream				nextPutAll: interfaceName , ' Interface")]';				cr].	self componentDescriptionsOn: aStream</body><body package="Com- Automation Development">typeLibraryHeaderOn: aStream 	aStream nextPutAll: '//'; cr.	aStream nextPutAll: '// Component and type library descriptions'; cr.	aStream nextPutAll: '//'; cr</body></methods><methods><class-id>Tools.IDLTypeLibraryDefinition</class-id> <category>accessing</category><body package="Com- Automation Development">addClassDefinition: def 	classDefinitions add: def</body><body package="Com- Automation Development">companyName: aString 	companyName := aString</body><body package="Com- Automation Development">creator: aString 	creator := aString</body><body package="Com- Automation Development">definitionOfClass: aClass 	^classDefinitions detect: [:def | def comClassName == aClass name]		ifNone: [nil]</body><body package="Com- Automation Development">fileName: aString 	fileName := aString</body><body package="Com- Automation Development">importedFiles	"the imported library files in the idl file"	^#('oaidl.idl' 'ocidl.idl')</body><body package="Com- Automation Development">interfaceName: aString 	interfaceName := aString</body><body package="Com- Automation Development">libraryHolder: aClass 	libraryHolder := aClass</body><body package="Com- Automation Development">libraryName: aString 	libraryName := aString</body><body package="Com- Automation Development">typeLibraries	^libraryHolder typeLibraries values</body><body package="Com- Automation Development">typeLibraryID	^libraryHolder typeLibraryID</body><body package="Com- Automation Development">typeLibraryIDString	| str |	str := self typeLibraryID asString.	^str copyFrom: 2 to: str size - 1</body></methods><methods><class-id>Tools.IDLTypeLibraryDefinition</class-id> <category>initialize-release</category><body package="Com- Automation Development">initialize	comClasses := OrderedCollection new.	classDefinitions := OrderedCollection new.	creator := (#NoCreatorNameYet &lt;&lt; #com &gt;&gt; 'No Creator Name Yet') asString.	companyName := (#NoCompanyNameYet &lt;&lt; #com &gt;&gt; 'No Company Name Yet') asString</body></methods><methods><class-id>Tools.IDLTypeLibraryDefinition</class-id> <category>As yet unclassified</category><body package="Com- Automation Development">lcid	^ lcid</body><body package="Com- Automation Development">lcid: aSmallInteger 		lcid := aSmallInteger</body></methods><methods><class-id>Tools.IDLTypeLibraryDefinition class</class-id> <category>instance creation</category><body package="Com- Automation Development">new	^super new initialize</body></methods><methods><class-id>Tools.IDLParametersDefinition</class-id> <category>accessing</category><body package="Com- Automation Development">paramDef: aDef 	paramDefs add: aDef</body></methods><methods><class-id>Tools.IDLParametersDefinition</class-id> <category>initialize-release</category><body package="Com- Automation Development">initialize	paramDefs := OrderedCollection new</body></methods><methods><class-id>Tools.IDLParametersDefinition</class-id> <category>printing</category><body package="Com- Automation Development">printOn: aStream 	aStream nextPutAll: '(  '.	paramDefs		do: [:def | def printOn: aStream]		separatedBy: [aStream nextPutAll: ', '].	aStream nextPutAll: ' )'</body></methods><methods><class-id>Tools.IDLParametersDefinition class</class-id> <category>instance creation</category><body package="Com- Automation Development">new	^super new initialize</body></methods><methods><class-id>Tools.IDLMethodsDefinition</class-id> <category>printing</category><body package="Com- Automation Development">definitionsOn: aStream 	aStream nextPutAll: '//'; cr.	aStream nextPutAll: '// Methods.'; cr; nextPutAll: '//'; cr.	methodDefinitions		do: 			[:def | 			aStream tab.			def printOn: aStream.			aStream cr]</body><body package="Com- Automation Development">emptyDefinitionsOn: aStream 	aStream nextPutAll: '//// No Methods//';cr</body><body package="Com- Automation Development">printOn: aStream 	self definitions isEmpty		ifTrue: [self emptyDefinitionsOn: aStream]		ifFalse: [self definitionsOn: aStream]</body></methods><methods><class-id>Tools.IDLMethodsDefinition</class-id> <category>initialize-release</category><body package="Com- Automation Development">add: aDef 	methodDefinitions add: aDef</body><body package="Com- Automation Development">initialize	methodDefinitions := OrderedCollection new</body><body package="Com- Automation Development">methodDefinitions: colOfDefs 	methodDefinitions addAll: colOfDefs</body></methods><methods><class-id>Tools.IDLMethodsDefinition</class-id> <category>accessing</category><body package="Com- Automation Development">definitions	^methodDefinitions</body></methods><methods><class-id>Tools.IDLMethodsDefinition</class-id> <category>testing</category><body package="Com- Automation Development">includesSameDefinitionAs: anIDLMethodDefinition	"Answer true if the receiver already has a definition that defines the same as &lt;anIDLMethodDefinition&gt;."	^self definitions contains: [:each | each definesSameAs: anIDLMethodDefinition]</body></methods><methods><class-id>Tools.IDLMethodsDefinition class</class-id> <category>instance creations</category><body package="Com- Automation Development">methodDefinitions: colOfDefs 	^self new methodDefinitions: colOfDefs</body><body package="Com- Automation Development">new	^super new initialize</body></methods><methods><class-id>Tools.IDLPropertiesDefinition</class-id> <category>printing</category><body package="Com- Automation Development">definitionsOn: aStream 	aStream nextPutAll: '//'; cr.	aStream nextPutAll: '// Properties.'; cr; nextPutAll: '//'; cr.	methodDefinitions		do: 			[:def | 			aStream tab.			def printOn: aStream.			aStream cr]</body><body package="Com- Automation Development">emptyDefinitionsOn: aStream 	aStream nextPutAll: '//// No Properties//'</body><body package="Com- Automation Development">printOn: aStream 	aStream nextPutAll: '// Properties.'; cr; nextPutAll: '//'; cr.	methodDefinitions		do: 			[:def | 			aStream tab.			def printOn: aStream.			aStream cr]</body></methods><methods><class-id>Tools.ComAutomationWizardDeployPage</class-id> <category>accessing</category><body package="Com- Automation Development">deployImagePath	^manager domain deployImagePath</body><body package="Com- Automation Development">helpText	^#wizardDeployPageHelp &lt;&lt; #com &gt;&gt; 'The Deploy page will help you prepare the deployment image. The fields reflect the both the type library directory and the image file as you''ve defined during the setup.'</body><body package="Com- Automation Development">libraryDirectory	^manager domain libraryDirectory</body><body package="Com- Automation Development">localServerImage	^manager domain localServerImage</body><body package="Com- Automation Development">publishedClasses	^manager domain targetClassList value</body><body package="Com- Automation Development">startUpClasses	^Array with: manager domain typeLibraryClass value</body><body package="Com- Automation Development">warningText	^(#WarnSaveImage &lt;&lt; #com 		&gt;&gt; 'Be sure to save the image before you run the deployment image setup.') 			asText allBold 		asComposedText asValue</body></methods><methods><class-id>Tools.ComAutomationWizardDeployPage</class-id> <category>actions</category><body package="Com- Automation Development">addRegistrationSupport	"Add self registration support for the published COM classes"	self publishedClasses do: [:cl | 		COMSessionManager addRegistrationSupportForClass: cl]</body><body package="Com- Automation Development">openTraceViewer	COMTraceViewer open</body><body package="Com- Automation Development">registerDispatchIIDs	self publishedClasses do: [:cl | IDispatch registerDispatchIID: cl iidInterfaceDisp]</body><body package="Com- Automation Development">runSetup	self unregisterExampleLibraries.	self registerDispatchIIDs.	COMSessionManager installRuntime.	self addRegistrationSupport.	self startUpClasses		do: 			[:cl | 			cl installRuntime.			cl registerSessionEventHandlers].	Dialog warn: ((#SaveDeployImageAs &lt;&lt; #com &gt;&gt; 'You can now save the deployment image as&lt;n&gt;&lt;1s&gt;.') expandMacrosWith: self localServerImage value )</body><body package="Com- Automation Development">unregisterExampleLibraries	| exampleClassNames |	exampleClassNames := #(#{COMDualInterfaceObject} #{Examples.SmalltalkCommanderCOMObject} #{Examples.AllDataTypesCOMObject} #{Examples.AutomationAllDataTypes} #{Examples.AutomationOnlySmalltalkCommander}).	exampleClassNames do: [:bnd | bnd ifDefinedDo: [:b | b unregister; removeSessionEventHandlers]]</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-accessing</category><body package="Com- Automation Development">dispatchSpecificationTable	" Private "	" allow an automation controller as well as a dispatch driver to be used "	^self dispatcher asDispatchDriver specificationTable</body><body package="Com- Automation Development">dispatcher	^ dispatcher</body><body package="Com- Automation Development">dispatcher: aDispatchDriver	" Set the dispatch driver "	dispatcher := aDispatchDriver.</body><body package="Com- Automation Development">dispatcherName: aString	" Private - specify the name of the dispatcher object. "	dispatcherName := aString.</body><body package="Com- Automation Development">evaluationTextModel	" Answer the model for the evaluation text. "	^evaluationTextModel</body><body package="Com- Automation Development">evaluationTextPane	" Private "	^self componentNamed: #evaluationTextPane</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-edit menu</category><body package="Com- Automation Development">editCopy	" Private - Perform the Edit menu Copy operation. "	textEditor copySelection.</body><body package="Com- Automation Development">editCut	" Private - Perform the Edit menu Cut operation. "	textEditor cut.</body><body package="Com- Automation Development">editFind	" Private - Perform the Edit menu Find... operation. "	textEditor find.</body><body package="Com- Automation Development">editPaste	" Private - Perform the Edit menu Paste operation. "	textEditor paste.</body><body package="Com- Automation Development">editReplace	" Private - Perform the Edit menu Replace... operation. "	textEditor replace.</body><body package="Com- Automation Development">editUndo	" Private - Perform the Edit menu Undo operation. "	textEditor undo.</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-evaluate menu</category><body package="Com- Automation Development">evaluateDoIt	" Evaluate the expression.  Answer the value of the expression "	self evaluateSelection.</body><body package="Com- Automation Development">evaluateInspectIt	" Evaluate the expression.  Open an inspector on the value of the expression "	self evaluateSelection inspect.</body><body package="Com- Automation Development">evaluateMenu	" Answer the Evaluate menu in the receiver's view. "	^self menuNamed: (#Evaluate &lt;&lt; #com &gt;&gt; 'Evaluate') asString</body><body package="Com- Automation Development">evaluatePrintIt	" Evaluate the expression.  Display the result. "	textEditor insertAndSelect: (' ' , self evaluateSelection printString)		at: textEditor selectionStopIndex</body><body package="Com- Automation Development">updateEvaluateMenu	" Private - enable/disable the Evaluate operations to reflect the current state of the application. "	self updateEvaluateMenu: self evaluateMenu.</body><body package="Com- Automation Development">updateEvaluateMenu: aMenu	" Private - enable/disable the Evaluate operations to reflect the current state of the application. "	dispatcher isNil		ifTrue: [			self disableMenu: aMenu.			#( #doItButton #inspectItButton #printItButton ) do: [ :aComponentName |				"( self componentNamed: aComponentName ) disable."				self disableComponentNamed: aComponentName ]			]		ifFalse: [			self enableMenu: aMenu.			].</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-operation</category><body package="Com- Automation Development">evaluateSelection	" Private - Evaluate the currently selected text..  Answer the value of the expression "	| anExpression aStream | 	anExpression := self getTextToEvaluate.	anExpression size = 0		ifTrue: [			MessageBox notify: #NothingSelected &lt;&lt; #com &gt;&gt;'Nothing Selected'				withText: #SelectExpToEval &lt;&lt; #com &gt;&gt; 'You must select the expression that you want to evaluate.'.			^nil ].	aStream := WriteStream on: ( String new: 20 ).	aStream nextPutAll: 		'[ :', dispatcherName, ' | ';		nextPutAll: anExpression;		nextPut: $].	^( Compiler evaluate: aStream contents ) value: dispatcher</body><body package="Com- Automation Development">getTextToEvaluate	" Private - answer the text to be evaluated. "	^textEditor selection asString</body><body package="Com- Automation Development">setAutomationObjectDescription: aString	" Describe the automation object dispatch driver "	"Alt: self triggerEvent: #automationObjectDescription: with: aString "	( self componentNamed: #automationObjectDescription ) 		labelString: aString.</body><body package="Com- Automation Development">setAutomationSpecificationPolicyDescription: aString	" Describe the automation object dispatch driver's Specification Policy "	"Alt: self triggerEvent: #specificationPolicyDescription: with: aString "	( self componentNamed: #automationSpecificationPolicyDescription )		labelString: aString.</body><body package="Com- Automation Development">setEvaluationText: aString	" Set the contents of the evaluation text pane to &lt;aString&gt;. "	self evaluationTextModel value: aString.</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-initialization</category><body package="Com- Automation Development">initialEvaluationText	" Private "	^(#EditorDefaultText &lt;&lt; #com &gt;&gt; '" Invoke methods and properties of the automation object by sending messages to the dispatcher, e.g.,	dispatcher invokeMethod: ''AboutBox''	dispatcher getProperty: ''Value''"') asString</body><body package="Com- Automation Development">initialize	" Private - initialize a new instance "	super initialize.	evaluationTextModel := String new asValue.</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-developer menu</category><body package="Com- Automation Development">describeAll	" Describe the methods and properties supported by the automation object. "	| methodSpecifications propertySpecifications aStream |	methodSpecifications := self getMethodSpecifications.	propertySpecifications := self getPropertySpecifications.	aStream := ReadWriteStream on: String new.	COMAutomationTypeAnalyzer new		clsid: methodSpecifications clsid;		lcid: methodSpecifications lcid;		methodSpecifications: methodSpecifications;		propertySpecifications: propertySpecifications;		stream: aStream;		describeMethods;		describeProperties.	TextWindow openOn: aStream contents		label: #AutoObjMethodsNProps &lt;&lt; #com &gt;&gt; 'Automation Object Methods and Properties'.</body><body package="Com- Automation Development">describeMethods	" Describe the methods supported by the automation object. "	| methodSpecifications aStream |	methodSpecifications := self getMethodSpecifications.	aStream := ReadWriteStream on: String new.	COMAutomationTypeAnalyzer new		clsid: methodSpecifications clsid;		lcid: methodSpecifications lcid;		methodSpecifications: methodSpecifications;		stream: aStream;		describeMethods.	TextWindow openOn: aStream contents		label: #AutoObjMethods&lt;&lt; #com &gt;&gt;'Automation Object Methods'.</body><body package="Com- Automation Development">describeProperties	" Describe the properties supported by the automation object. "	| propertySpecifications aStream |	propertySpecifications := self getPropertySpecifications.	aStream := ReadWriteStream on: String new.	COMAutomationTypeAnalyzer new		clsid: propertySpecifications clsid;		lcid: propertySpecifications lcid;		propertySpecifications: propertySpecifications;		stream: aStream;		describeProperties.	TextWindow openOn: aStream contents		label: #AutoObjProps &lt;&lt; #com &gt;&gt; 'Automation Object Properties'.</body><body package="Com- Automation Development">developerMenu	" Answer the Developer menu in the receiver's menu bar. "	^self menuNamed: (#Developer &lt;&lt; #com &gt;&gt; 'Developer') asString</body><body package="Com- Automation Development">inspectDispatcher	dispatcher inspect.</body><body package="Com- Automation Development">inspectSpecifications	self dispatchSpecificationTable inspect.</body><body package="Com- Automation Development">updateDeveloperMenu	" Private - enable/disable the operations in the Developer menu to reflect the capabilities of the dispatcher. "	self updateDeveloperMenu: self developerMenu.</body><body package="Com- Automation Development">updateDeveloperMenu: aMenu	" Private - enable/disable the operations in the Developer menu to reflect the capabilities of the dispatcher. "	dispatcher isNil		ifTrue: [			self disableMenu: aMenu.			^self ].	Tools.Note ISSUE.  " Disable these guys if the spec table is empty?  If untyped?? "	"	self enableDisableMenuItems: #( #describeMethods #describeProperties #describeAll  )		in: aMenu		enableFlag: dispatcher notNil.	"</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-help menu</category><body package="Com- Automation Development">explainWhatToDo	" A low-rent Help facility. "	| helpString |	helpString := (#AutoEditorHelp &lt;&lt; #com &gt;&gt;'COMAutomationEditor is a simple tool that lets you invoke the methods and properties of a COM automation object.  The automation editor window is associated with a COMDispatchDriver which you use to invoke the methods and properties supported by an automation object through a dispatch interface.  You can type Smalltalk code in this window which sends messages via the dispatcher to the automation object when you invoke the Execute menu command.  The dispatcher can be referenced in your expressions as an object named ''dispatcher''.&lt;nn&gt;Methods and properties are accessed using the COMDispatchDriver protocol.  For example, the object you are playing with supports an #AboutBox method, you would invoke it by entering the following expression in the text pane:&lt;nnt&gt;dispatcher invokeMethod: ''AboutBox''&lt;nn&gt;and invoking the DoIt command.&lt;nn&gt;Similarly, you could set the value of a property be evaluating an expression such as:&lt;nnt&gt;dispatcher setProperty: ''Value'' value: 1.  " or whatever is suitable... "&lt;nn&gt;Refer to the documentation provided by the supplier of the automation object which you are exploring for information about the methods and properties which are supported and what arguments, if any, must be provided.') expandMacros.	TextWindow openOn: helpString		label: #HowToUseAutoEditor &lt;&lt; #com &gt;&gt; 'How to use the COM Automation Editor'.</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-describing</category><body package="Com- Automation Development">copySpecificationTable: aSpecificationTable satisfying: aBlock	" Private - answer a copy of &lt;aSpecificationTable&gt; containing only those specifications for which &lt;aBlock&gt; evaluates to true. "	| specTableCopy |	specTableCopy := aSpecificationTable copyEmpty.	aSpecificationTable do: [ :aDispatchSpec |		( aBlock value: aDispatchSpec )			ifTrue: [ specTableCopy add: aDispatchSpec ] ].	^specTableCopy</body><body package="Com- Automation Development">getMethodSpecifications	" Private - answer a specification table for the methods supported by the automation object. "	^self copySpecificationTable: self dispatchSpecificationTable		satisfying: [ :aDispatchSpec | aDispatchSpec isMethodSpecification ].</body><body package="Com- Automation Development">getPropertySpecifications	" Private - answer a specification table for the methods supported by the automation object. "	^self copySpecificationTable: self dispatchSpecificationTable		satisfying: [ :aDispatchSpec | aDispatchSpec isPropertySpecification ].</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>private-window events</category><body package="Com- Automation Development">windowBuilt	" Private - the window has been constructed by the builder and is about to be opened.  Initialize menu item states. "	textEditor := self evaluationTextPane controller.  " cache this for evaluation operations "	self 		updateEvaluateMenu;		updateDeveloperMenu.	dispatcher isNil		ifTrue: [			self setEvaluationText: 'Not connected to an automation object.'.			self disableComponentNamed: #evaluationTextPane ].</body><body package="Com- Automation Development">windowClosed	" Private - the window has been closed. "	dispatcher := nil.</body></methods><methods><class-id>External.COMAutomationEditor</class-id> <category>controlling</category><body package="Com- Automation Development">slaveToApplication: anApplicationModel window: aWindow	" Make the receiver's window be slaved to &lt;aWindow&gt; owned by &lt;anApplicationModel&gt;. "	" slave the automation editor to the control browser which spawned it "	Tools.Note ISSUE.  " Well, this is a nice idea but it doesn't work yet.		The user documentation is clearly not telling us the whole story		about what needs to be done to make this happen.		[DL 29-May-96] "	aWindow		application: anApplicationModel;		beMaster.	self applicationWindow		application: anApplicationModel;		beSlave.</body></methods><methods><class-id>External.COMAutomationEditor class</class-id> <category>accessing</category><body package="Com- Automation Development">defaultDispatcherClass	" Answer the default dispatcher class used by instances of the receiver. "	^COMDispatchDriver</body></methods><methods><class-id>External.COMAutomationEditor class</class-id> <category>defaults</category><body package="Com- Automation Development">defaultDispatcherName		" Answer the default name of the automation dispatcher variable used for evaluating expressions. "	^'dispatcher'</body><body package="Com- Automation Development">defaultInitialText	" Answer the text which is initially displayed in an automation editor. "	^self defaultInitialText: self defaultDispatcherName</body><body package="Com- Automation Development">defaultInitialText: dispatcherName	" Answer the text which is initially displayed in an automation editor. "	| defaultText |	defaultText := (#DefaultTextForEditor &lt;&lt; #com &gt;&gt; '" Invoke methods and properties of the automation object by sending messages to the dispatcher, e.g.,&lt;n&gt;&lt;t&gt;&lt;1s&gt; invokeMethod: ''AboutBox''&lt;n&gt;&lt;t&gt;&lt;1s&gt; getProperty: ''Value''"&lt;n&gt;').	^defaultText expandMacrosWith: dispatcherName</body></methods><methods><class-id>External.COMAutomationEditor class</class-id> <category>interface specs</category><body package="Com- Automation Development">eventHandlersSpec	" Answer the specifications for connecting components of the application using events "	^super eventHandlersSpec, #(		#( #applicationWindow			#( #built #windowBuilt )			# (#closed #windowClosed ) 			)		)</body></methods><methods><class-id>External.COMAutomationEditor class</class-id> <category>opening</category><body package="Com- Automation Development">openOnDispatcher: aDispatchDriver	" Open an automation editor on the object supporting &lt;aDispatchDriver&gt;.  Answer the editor. "	^self openOnDispatcher: aDispatchDriver description: nil</body><body package="Com- Automation Development">openOnDispatcher: aDispatchDriver description: descriptionString	" Open an automation editor on the object supporting &lt;aDispatchDriver&gt;, which is described by &lt;descriptionString.  Answer the editor. "	^self openOnDispatcher: aDispatchDriver 		description: descriptionString 		dispatcherName: self defaultDispatcherName 		initialText: self defaultInitialText</body><body package="Com- Automation Development">openOnDispatcher: aDispatchDriver description: descriptionString dispatcherName: dispatcherName initialText: initialText	" Open an automation editor on the object supporting &lt;aDispatchDriver&gt;, which is described by &lt;descriptionString.  Answer the editor. "	| anAutomationEditor |    "Assert isTrue: [ aDispatchDriver is a COMDispatchDriver or an automation controller ]."	anAutomationEditor := self new		dispatcherName: dispatcherName;		dispatcher: aDispatchDriver;		yourself.	anAutomationEditor evaluationTextModel value: initialText.	self openOn: anAutomationEditor.  	anAutomationEditor		setAutomationObjectDescription: ( descriptionString isNil			ifTrue: [ 'Dispatcher: ', aDispatchDriver printString ]			ifFalse: [ 'Dispatcher on ', descriptionString ] );		setAutomationSpecificationPolicyDescription: 			'Specification policy: ',  aDispatchDriver asDispatchDriver specificationPolicy description.	^anAutomationEditor</body></methods><methods><class-id>External.IDispatchTraceAdaptor</class-id> <category>subclass-exception handlers</category><body package="Com- Automation Development">exceptionHandlerForDispatchInvoke: traceContext exceptionInfo: exceptionInfoReference	" Answer the error handler block to use when an exception occurs during a VTable function invocation of IDispatch::Invoke.  The exception is reported and passed on. "	^[ :ex |		traceContext isTraceEnabled ifTrue: [ 			self logString: ex description tag: '***Exception'.			exceptionInfoReference notNil				ifTrue: [ self logValue: exceptionInfoReference value tag: '***Exception info' ].			self isIncomingInterface				ifTrue: [ self logErrorExitHRESULT: DISP_E_EXCEPTION ].			].		ex pass ]</body></methods><methods><class-id>External.IDispatchTraceAdaptor</class-id> <category>subclass-tracing</category><body package="Com- Automation Development">getDISPIDDescription: aDISPID	" Answer a description of &lt;aDISPID&gt;. "	| knownDISPIDMap dispidName |	knownDISPIDMap := Dictionary new		at: DISPID_COLLECT put: 'DISPID_COLLECT';		at: DISPID_CONSTRUCTOR put: 'DISPID_CONSTRUCTOR';		at: DISPID_DESTRUCTOR put: 'DISPID_DESTRUCTOR';		at: DISPID_EVALUATE put: 'DISPID_EVALUATE';		at: DISPID_NEWENUM put: 'DISPID_NEWENUM';		at: DISPID_PROPERTYPUT put: 'DISPID_PROPERTYPUT';		at: DISPID_UNKNOWN put: 'DISPID_UNKNOWN';		at: DISPID_VALUE put: 'DISPID_VALUE';		yourself.	dispidName := knownDISPIDMap at: aDISPID		ifAbsent: [ nil ].	dispidName notNil		ifTrue: [ ^dispidName, ' ( ', aDISPID printString, ' )' ].	dispidName := dispidMap at: aDISPID		ifAbsent: [ nil ].	dispidName notNil		ifTrue: [ ^dispidName, ' ( ', aDISPID printString, ' )' ].	^aDISPID printString"| dispidPrefix |dispidPrefix := 'DISPID_'.Transcript cr.COMAutomationConstants  keys asSortedCollection do: [ :k |	( k copyFrom: 1 to: ( dispidPrefix size min: k size ) ) = dispidPrefix		ifTrue: [ 			| dispidName |			dispidName := k asString.			Transcript tab; tab; show: 'at: ', dispidName asString, ' put: ', dispidName printString, ';'; cr ] ].Transcript flush."</body><body package="Com- Automation Development">logDISPID: aDISPID	" Log a DISPID to the COM trace log. "	self logString: ( self getDISPIDDescription: aDISPID )		tag: 'DISPID'</body><body package="Com- Automation Development">logInvokeFlags: wFlags	" Log a description of the dispatch invoke flags to the COM trace log. "	| flagNames |	flagNames := OrderedCollection new.	( wFlags bitAnd: DISPATCH_METHOD ) ~= 0		ifTrue: [ flagNames add: 'DISPATCH_METHOD' ].	( wFlags bitAnd: DISPATCH_PROPERTYGET ) ~= 0		ifTrue: [ flagNames add: 'DISPATCH_PROPERTYGET' ].	( wFlags bitAnd: DISPATCH_PROPERTYPUT ) ~= 0		ifTrue: [ flagNames add: 'DISPATCH_PROPERTYPUT' ].	( wFlags bitAnd: DISPATCH_PROPERTYPUTREF ) ~= 0		ifTrue: [ flagNames add: 'DISPATCH_PROPERTYPUTREF' ].	self logFlags: wFlags 		nameList: flagNames 		tag: 'wFlags'."COMAutomationConstants keys asSortedCollection asArray	select: [ :k | ( k readStream upTo: $_ ) = 'DISPATCH' ]"</body><body package="Com- Automation Development">logParameters: dispParams	" Log the parameters of a dispatch operation to the COM trace log. "	| arguments anArg anArgName |	arguments := ( dispParams isCOMStructure		ifTrue: [			"Assert isEqual: dispParams structureType name to: #tagDISPPARAMS."			dispParams arguments ]		ifFalse: [			"Assert isTrue: [ dispParams isNil or: [ dispParams isArray ] ]."  "?? right ??"			dispParams ] ).	arguments size = 0		ifTrue: [ ^self ].	self log: self logIndent, 'Parameters:'.	1 to: arguments size do: [ :i |		anArg := arguments at: i.		anArgName := self logIndent, 'arg', i printString.		" hacky stuff for incoming args from outside, oh well "		( anArg isKindOf: COMVariantStructure )			ifTrue: [				self logString:anArg valueDescription					tag: anArgName, ' (', anArg typeCodeDescription, ')' ]			ifFalse: [ self logValue: anArg tag: anArgName ].		].</body></methods><methods><class-id>External.IDispatchTraceAdaptor</class-id> <category>private-initialization</category><body package="Com- Automation Development">initialize	" Private - initialize a new instance. "	dispidMap := Dictionary new.</body></methods><methods><class-id>External.IDispatchTraceAdaptor</class-id> <category>interface operations</category><body package="Com- Automation Development">GetIDsOfNames: riid _: names _: cNames _: lcid _: resultReference	" Invoke the IDispatch::GetIDsOfNames function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self				logIID: riid;				logValue: names tag: 'names';				logValue: cNames tag: 'cNames';				logValue: lcid tag: 'LCID'].		[hresult := implementor				GetIDsOfNames: riid				_: names				_: cNames				_: lcid				_: resultReference]			on: Error			do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: 					[self logValue: resultReference value tag: 'DISPID''s'.					" cache DISPID's of members that we happen to learn about "					dispidMap at: resultReference value first put: names first].			self logHRESULT: hresult].	^hresult</body><body package="Com- Automation Development">GetTypeInfo: itinfo _: lcid _: resultReference	" Invoke the IDispatch::GetTypeInfo function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			(itinfo isInteger not or: [itinfo ~= 0])				ifTrue: 					[self logString: itinfo printString , ' ( *** EXPECTED 0 *** )'						tag: 'itinfo'].			self logValue: lcid tag: 'LCID'].	[hresult := implementor GetTypeInfo: itinfo _: lcid _: resultReference]		on: Error		do: (self exceptionHandlerForHRESULTReturnValue: traceContext).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: [self logInterfaceResultValue: resultReference value tag: 'ITypeInfo'].			self logHRESULT: hresult].	^hresult</body><body package="Com- Automation Development">Invoke: dispidMember _: anIID _: lcid _: wFlags _: dispParams _: resultReference _: exceptionInfoReference _: argErrorReference	"Invoke the IDispatch::Invoke function. "	| traceContext hresult |	traceContext := self constructFunctionTraceContextForContext: thisContext.	traceContext isTraceEnabled		ifTrue: 			[self logFunctionHeader: traceContext.			self logDISPID: dispidMember.			anIID ~= IID_NULL				ifTrue: 					[self						logString: (self getIIDDescription: anIID) , ' (*** EXPECTED IID_NULL ***)'						tag: 'IID'].			self				logValue: lcid tag: 'LCID';				logInvokeFlags: wFlags;				logParameters: dispParams].		[hresult := implementor				Invoke: dispidMember				_: anIID				_: lcid				_: wFlags				_: dispParams				_: resultReference				_: exceptionInfoReference				_: argErrorReference]			on: Error			do: (self exceptionHandlerForDispatchInvoke: traceContext					exceptionInfo: exceptionInfoReference).	traceContext isTraceEnabled		ifTrue: 			[hresult succeeded				ifTrue: 					[resultReference notNil						ifTrue: [self logValue: resultReference value tag: 'Result value']]				ifFalse: 					[(hresult = DISP_E_EXCEPTION and: [exceptionInfoReference notNil])						ifTrue: [self logValue: exceptionInfoReference value tag: '***Exception info'].					((hresult = DISP_E_TYPEMISMATCH or: [hresult = DISP_E_PARAMNOTFOUND])						and: [argErrorReference notNil])							ifTrue: [self logValue: argErrorReference value tag: '***Arg error']].			self logHRESULT: hresult].	^hresult</body></methods><methods><class-id>External.IDispatchTraceAdaptor class</class-id> <category>instance creation</category><body package="Com- Automation Development">new	" Answer a new instance of the receiver. "	^super new initialize</body></methods><methods><class-id>External.IDispatchTraceAdaptor class</class-id> <category>class initialization</category><body package="Com- Automation Development">initialize	COMTraceManager registerAdaptorClass: self forIID: IID_IDispatch.	" register default interface trace options "	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IDispatch.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IConnectionPoint.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IConnectionPointContainer.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager callinAndCalloutTraceOptions		forIID: IID_IProvideClassInfo.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager calloutOnlyTraceOptions		forIID: IID_ITypeLib.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager calloutOnlyTraceOptions		forIID: IID_ITypeInfo.	COMTraceManager		registerInterfaceTraceOptions: COMTraceManager calloutOnlyTraceOptions		forIID: IID_ITypeComp.</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id> <category>class methods generation</category><body package="Com- Automation Development">classPragmasText	^'&lt;pragmas: #class&gt;	^ #(typeLibrary)'</body><body package="Com- Automation Development">clsidText	| clsid |	clsid := GUID new storeString.	^'^' , clsid</body><body package="Com- Automation Development">constructDispatchSpecificationsWithKeyText	^'"answer the dispatch specification table describing the methods and properties supported through COM automation by the receiver."	^self newDispatchSpecificationTable		specificationKey: aSymbol;		decodeSpecificationsFromLiteralArray: self methodSpecificationsLiteral;		decodeSpecificationsFromLiteralArray: self propertySpecificationsLiteral;		yourself'</body><body package="Com- Automation Development">dispatchSpecificationsForServerText	^'"answer the dispatch specification table for publishing instances of the receiver though a COM automation controller dispatch driver."	"self dispatchSpecificationsForServer."	^(self constructDispatchSpecificationsWithKey: #memberID) clsid: self clsid; yourself'</body><body package="Com- Automation Development">externalNameText	^'	"Return the name known outside of VisualWorks"	^', self externalName value printString</body><body package="Com- Automation Development">generateClassMethod: methodName textSelector: methodTextSelector protocol: theProtocol  	| strm   theClass  methodComment |	theClass := self targetClass.	theClass notNil 		ifTrue: [theClass := theClass class] 		ifFalse: [^nil].	(theClass findSelector:  methodName)  notNil 		ifTrue: 			[self class warnNotGenerating: methodName inClass: theClass.			^nil].	strm  := String new writeStream.	methodComment := (#MethodWarnAutoGen &lt;&lt; #com &gt;&gt; '"This method was generated by COM Automation Tool. Do not change unless you know what you are doing."') asString.	"now do the code"	strm nextPutAll: methodName; cr.	strm tab; nextPutAll: methodComment; cr; cr.	strm tab; nextPutAll: (self perform: methodTextSelector).	theClass compile: strm contents classified: theProtocol</body><body package="Com- Automation Development">generateClassMethod: methodName textSelector: methodTextSelector protocol: theProtocol  onlyIfNotExists: aBoolean	| strm   theClass  methodComment |	theClass := self targetClass.	theClass notNil 		ifTrue: [theClass := theClass class] 		ifFalse: [^nil].	aBoolean ifTrue: [(theClass findSelector:  methodName)  notNil 		ifTrue: [self class warnNotGenerating: methodName inClass: theClass.			^nil]].	strm  := String new writeStream.	methodComment := (#MethodWarnAutoGen &lt;&lt; #com &gt;&gt; '"This method was generated by COM Automation Tool. Do not change unless you know what you are doing."') asString.	"now do the code"	strm nextPutAll: methodName; cr.	strm tab; nextPutAll: methodComment; cr; cr.	strm tab; nextPutAll: (self perform: methodTextSelector).	theClass compile: strm contents classified: theProtocol</body><body package="Com- Automation Development">generateClass_classPragmas	self		generateClassMethod: #classPragmas		textSelector: #classPragmasText		protocol: #'compiler support'</body><body package="Com- Automation Development">generateClass_clsid	self		generateClassMethod: #clsid		textSelector: #clsidText		protocol: #identity</body><body package="Com- Automation Development">generateClass_constructDispatchSpecificationsWithKey	| strm theClass theProtocol  methodName methodComment |	theClass := self targetClass.	theClass notNil 		ifTrue: [theClass := theClass class] 		ifFalse: [^nil].	methodName := #'constructDispatchSpecificationsWithKey:'.	(theClass findSelector:  methodName)  notNil 				ifTrue: 			[self class warnNotGenerating: methodName inClass: theClass.			^nil].	theProtocol := #'private-specifications'.	strm  := String new writeStream.	methodComment := (#GenKey95 &lt;&lt; #com &gt;&gt; '"This method was generated by COM AutomationTool. 	Do not change unless you know what you are doing."') asString.	"now do the code"	strm nextPutAll: methodName, ' aSymbol'; cr.	strm tab; nextPutAll: methodComment; cr; cr.	strm tab; nextPutAll: self constructDispatchSpecificationsWithKeyText.	theClass compile: strm contents classified: theProtocol</body><body package="Com- Automation Development">generateClass_dispatchSpecificationsForServer	self		generateClassMethod: #dispatchSpecificationsForServer		textSelector: #dispatchSpecificationsForServerText		protocol: #'private-specifications'</body><body package="Com- Automation Development">generateClass_externalName	self		generateClassMethod: #externalName		textSelector: #externalNameText		protocol: #identity</body><body package="Com- Automation Development">generateClass_iidInterfaceDisp	self		generateClassMethod: #iidInterfaceDisp		textSelector: #iidInterfaceDispText		protocol: #'identity'</body><body package="Com- Automation Development">generateClass_iidVtableInterface	self		generateClassMethod: #iidVtableInterface		textSelector: #iidInterfaceDispText		protocol: #'identity'</body><body package="Com- Automation Development">generateClass_initialize	self		generateClassMethod: #initialize		textSelector: #initializeText		protocol: #'private-installation'		onlyIfNotExists: false</body><body package="Com- Automation Development">generateClass_installRuntime	self		generateClassMethod: #installRuntime		textSelector: #installRuntimeText		protocol: #'private-installation'</body><body package="Com- Automation Development">generateClass_interfaceName	self		generateClassMethod: #interfaceName		textSelector: #interfaceNameText		protocol: #'identity'</body><body package="Com- Automation Development">generateClass_newDispatchSpecificationTable	self		generateClassMethod: #newDispatchSpecificationTable		textSelector: #newDispatchSpecificationTableText		protocol: #'private-specifications'</body><body package="Com- Automation Development">generateClass_registerSessionEventHandlers	self		generateClassMethod: #registerSessionEventHandlers		textSelector: #registerSessionEventHandlersText		protocol: #'private-installation'</body><body package="Com- Automation Development">generateClass_registerTypeLibraries	self		generateClassMethod: #registerTypeLibraries		textSelector: #registerTypeLibrariesText		protocol: #'type libraries'</body><body package="Com- Automation Development">generateClass_releaseTypeLibraries	self		generateClassMethod: #releaseTypeLibraries		textSelector: #releaseTypeLibrariesText		protocol: #'type libraries'</body><body package="Com- Automation Development">generateClass_removeSessionEventHandlers	self		generateClassMethod: #removeSessionEventHandlers		textSelector: #removeSessionEventHandlersText		protocol: #'private-installation'</body><body package="Com- Automation Development">generateClass_specificationTable	self		generateClassMethod: #specificationTable		textSelector: #specificationTableText		protocol: #'private-specifications'</body><body package="Com- Automation Development">generateClass_startUpApplication	self		generateClassMethod: #startUpApplication		textSelector: #startUpApplicationText		protocol: #'session management'</body><body package="Com- Automation Development">generateClass_typeLibraries	| theClass |	theClass := self targetClass.	theClass notNil ifTrue: [(theClass class allInstVarNames includes: 'typeLibraries')			ifFalse: [theClass class addInstVarName: 'typeLibraries']].	self		generateClassMethod: #typeLibraries		textSelector: #typeLibrariesText		protocol: #'type libraries'</body><body package="Com- Automation Development">generateClass_typeLibraryID	self		generateClassMethod: #typeLibraryID		textSelector: #typeLibraryIDText		protocol: #'type libraries'</body><body package="Com- Automation Development">generateClass_unregisterTypeLibraries	self		generateClassMethod: #unregisterTypeLibraries		textSelector: #unregisterTypeLibrariesText		protocol: #'type libraries'</body><body package="Com- Automation Development">generateClass_updateTypeLibraries	self		generateClassMethod: #updateTypeLibraries		textSelector: #updateTypeLibrariesText		protocol: #'type libraries'</body><body package="Com- Automation Development">iidInterfaceDispText	| iid |	iid := GUID new storeString.	^'^' , iid</body><body package="Com- Automation Development">initializeText	^'	"This method is run at COM Connect installation time. It takes the place of ClassInitalizer."	IDispatch registerDispatchIID: self iidInterfaceDisp'</body><body package="Com- Automation Development">installRuntimeText	^'	"prepare the receiver for deployment in a runtime image configuration.  You can extend this method and place other installation code in it."	"all we are doing is making sure the type library is registered."	"this is probably not necessary for this application.  but, this method makes a nice placeholder for essential tasks when they are identified."	"self installRuntime."	self registerSessionEventHandlers.	self releaseTypeLibraries.	self registerTypeLibraries'</body><body package="Com- Automation Development">interfaceNameText	"interfaceName method text"	^'"Answer a description of the the dispatch interface with which a Smalltalk object is published as a COM automation object."	^', self interfaceDescription value printString</body><body package="Com- Automation Development">newDispatchSpecificationTableText	^'"answer a new empty dispatch specification table for publishing or exposing the receiver''s methods and properties."	^COMDispatchSpecificationTable new		iid: self iidInterfaceDisp;		name: self interfaceName;		yourself'</body><body package="Com- Automation Development">registerSessionEventHandlersText	^'	"install the event handlers for the receiver."	"the only being used is #startUpApplication.  the others could be used for any cleanup needed by the application."	"note.  the event  #developmentStartup can be used as well.  see ImageConfiguration&gt;&gt;isDevelopment:."	self removeSessionEventHandlers.	COMSessionManager 		when: #shutdownImage		send: #releaseTypeLibraries to: self.	COMSessionManager 		when: #confirmSaveImage		send: #releaseTypeLibraries to: self.	ImageManager 		when: #deploymentStartup		send: #startUpApplication to: self'</body><body package="Com- Automation Development">registerTypeLibrariesText	^'"register the type libraries.  must be run before COMAutomationTypeAnalyzer class &gt;&gt;generateTypeLibrarySpecifications: can be executed."	"note.  this places type library information into the system registry."	"self registerTypeLibraries."	self typeLibraries do: [ : aTypeLibrary | aTypeLibrary createRegistration ]'</body><body package="Com- Automation Development">releaseTypeLibrariesText	^'	"release the type libraries.  this does not remove the receiver from the system registry table."	| toBeReleased |	"This test does not use self to avoid loading."	self typeLibraries isNil ifTrue: [ ^self ].	toBeReleased := self typeLibraries.	typeLibraries := nil.	toBeReleased do: [ : aTypeLibrary | aTypeLibrary release ].'</body><body package="Com- Automation Development">removeSessionEventHandlersText	^'	"remove the registration of any session event handlers for the receiver."	ImageManager removeAllActionsWithReceiver: self.	COMSessionManager removeAllActionsWithReceiver: self.'</body><body package="Com- Automation Development">specificationTableText	^'"answer the specification table for the receiver."	^self dispatchSpecificationsForServer'</body><body package="Com- Automation Development">startUpApplicationText	^'	"start up the Automation object server."	"this method is ran at image startup and is invoked through the VW event registration event services."	"log application activity to a trace log if trace support is installed in a runtime configuration.  remove from production version."	COMSessionManager activateRuntimeTracing.	"make sure the type libraries are ok.  not essential."	self updateTypeLibraries.	"initialize COM and verify that the application is being run as an object server."	COMSessionManager initializeAutomationServer.	"register the class factory for the object server application."	COMAutomationServer registerServerClassFactoryForClass: self.	"arrange for server application termination.  set to true if you want the image to shut down when all outstanding references are zero."	COMSessionManager exitIfNotInUse: false.'</body><body package="Com- Automation Development">typeLibrariesText	"typeLibraries method text"	^'typeLibraries isNil		ifTrue: [ | pragmas |				pragmas := Pragma allNamed: #typeLibrary in: self class.				typeLibraries := Dictionary new.				pragmas do: [:each  |  | aTypeLibrary |					aTypeLibrary := self perform: each selector.					typeLibraries at: aTypeLibrary lcid put: aTypeLibrary ]].			^typeLibraries'</body><body package="Com- Automation Development">typeLibraryIDText	| clsid |	clsid := GUID new storeString.	^'^' , clsid</body><body package="Com- Automation Development">unregisterTypeLibrariesText	^'	"unregister the type libraries.  this removes the receiver from the system registry." 	self typeLibraries do: [ : aTypeLibrary | aTypeLibrary removeRegistration ]'</body><body package="Com- Automation Development">updateTypeLibrariesText	^'	"update the registry for each type library defined by the application.  see also COMTypeLibrary&gt;&gt;updateRegistration."	self typeLibraries do: [ : aTypeLibrary | aTypeLibrary updateRegistration ]'</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id> <category>instance methods generation</category><body package="Com- Automation Development">automationServerText	| theClass |	theClass := self targetClass.	theClass := self targetClass.	theClass notNil ifTrue: [(theClass allInstVarNames includes: 'automationServer')			ifFalse: [theClass addInstVarName: 'automationServer']].	^'automationServer == nil 		ifTrue: [automationServer := COMAutomationServer on: self								clsid: self class clsid								specificationTable: self class dispatchSpecificationsForServer								typeLibraries: self class typeLibraries].	^automationServer'</body><body package="Com- Automation Development">dispatchInterfaceText		^'"answer the receiver''s dispatch interface.  this method or its implementation below should always be used when returning an IDispatch interface pointer to the receiver.  this protocol insures that a separately referenced interface is returned. Not answering a separately referenced interface causes major errors."	^self automationServer queryInterface: self class iidInterfaceDisp'</body><body package="Com- Automation Development">generateInstanceMethod: methodName textSelector: methodTextSelector protocol: theProtocol  	| strm   theClass  methodComment |	theClass := self targetClass.	(theClass findSelector:  methodName)  notNil 		ifTrue: 			[self class warnNotGenerating: methodName inClass: theClass.			^nil].	strm  := String new writeStream.	methodComment := (#GenKey96 &lt;&lt; #com &gt;&gt; '"This method was generated by COM Automation Tool. 	Do not change unless you know what you are doing."') asString.	"now do the code"	strm nextPutAll: methodName; cr.	strm tab; nextPutAll: methodComment; cr; cr.	strm tab; nextPutAll: (self perform: methodTextSelector).	theClass compile: strm contents classified: theProtocol</body><body package="Com- Automation Development">generateInstance_automationServer	self		generateInstanceMethod: #automationServer		textSelector: #automationServerText		protocol: #'private-accessing'</body><body package="Com- Automation Development">generateInstance_dispatchInterface	self		generateInstanceMethod: #dispatchInterface		textSelector: #dispatchInterfaceText		protocol: #'private-accessing'</body><body package="Com- Automation Development">generateInstance_releaseAutomationServer	self		generateInstanceMethod: #releaseAutomationServer		textSelector: #releaseAutomationServerText		protocol: #'private-releasing'</body><body package="Com- Automation Development">releaseAutomationServerText	^'	"release the automation server object which publishes the receiver."	automationServer notNil		ifTrue: [| innerObject |				innerObject := automationServer.				automationServer := nil.				Assert isTrue: [innerObject implementingObject referenceCount = 1].				innerObject release]'</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id> <category>accessing</category><body package="Com- Automation Development">helpText	^#wizardGUIDPageHelp &lt;&lt; #com &gt;&gt; 'The GUID page will create the class identifier, support instance, and class methods for the class you have selected in the Classes page. There will be default values in the various widgets and those values do not need normally to be modified.Class: A combo box with the classes that you have added to the wizard.Interface name: The name of the dispatch interface with which a Smalltalk object is published as a COM automation object.External name: The name of the COM object as it is known outside of VisualWorks (must be different than Interface name).Type Library	Local: The selected class that holds the type library support code.	Class: Specify another class to hold the type library support code.Instance methods: The instance side methods to be auto-generated for the selected class. The Generate button below this list will install the methods.Class methods: The class side support methods to be auto-generated for the selected class. The Generate button below this list will install the methods.'</body><body package="Com- Automation Development">interfaceName	^self interfaceDescription value</body><body package="Com- Automation Development">whereIsTypeLibrary	^manager domain whereIsTypeLibrary</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id> <category>private</category><body package="Com- Automation Development">changeLibraryLocation	self initializeMethodLists</body><body package="Com- Automation Development">changedClass	(self targetClass respondsTo: #externalName)		ifTrue: [self externalName value: self targetClass externalName]		ifFalse: [self externalName value: 'IA' , self className value name].	(self targetClass respondsTo: #interfaceName)		ifTrue: [self interfaceDescription value: self targetClass interfaceName]		ifFalse: [self interfaceDescription value: 'I' , self className value name].	self externalName changed.	self interfaceDescription changed.</body><body package="Com- Automation Development">classToString: aClass	^aClass unambiguousName</body><body package="Com- Automation Development">stringToClass: aString	^(BindingReference pathString: aString) value</body><body package="Com- Automation Development">targetClass	^self className value</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id> <category>actions</category><body package="Com- Automation Development">generateClassMethods	| sels |	sels := self classMethodList selections.	sels do: [:sel | self perform: ('generateClass_' , sel) asSymbol]</body><body package="Com- Automation Development">generateInstanceMethods	| sels |	sels := self instanceMethodList selections.	sels do: [:sel | self perform: ('generateInstance_' , sel) asSymbol]</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id> <category>aspects</category><body package="Com- Automation Development">classMethodList	^classMethodList isNil		ifTrue: [classMethodList := MultiSelectionInList new]		ifFalse: [classMethodList]</body><body package="Com- Automation Development">className	"This method was generated by UIDefiner. Any edits made here	may be lost whenever methods are automatically defined. The	initialization provided below may have been preempted by an	initialize method."	^className isNil		ifTrue: [className := nil asValue]		ifFalse: [className]</body><body package="Com- Automation Development">externalName	^manager domain externalName</body><body package="Com- Automation Development">instanceMethodList	^instanceMethodList isNil		ifTrue: [instanceMethodList := MultiSelectionInList new]		ifFalse: [instanceMethodList]</body><body package="Com- Automation Development">interfaceDescription	^manager domain interfaceDescription</body><body package="Com- Automation Development">targetClassList	^manager domain targetClassList</body><body package="Com- Automation Development">typeLibraryClass	^manager domain typeLibraryClass</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id> <category>interface opening</category><body package="Com- Automation Development">postBuildWith: aBuilder 	super postBuildWith: aBuilder.	self initializeMethodLists.	self className value ifNil: 			[| targetClasses |			(targetClasses := self targetClassList value) notEmpty 				ifTrue: 					[self className value: targetClasses first.					self changedClass]]</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage</class-id> <category>initialize-release</category><body package="Com- Automation Development">initializeMethodLists	| l sels |	l := List new.	sels := #(#initialize #interfaceName #iidInterfaceDisp #iidVtableInterface #clsid #specificationTable #constructDispatchSpecificationsWithKey #dispatchSpecificationsForServer #newDispatchSpecificationTable #externalName) asSortedCollection.	l addAll: sels.	self whereIsTypeLibrary value == #local		ifTrue: 			[sels := #(#typeLibraryID #classPragmas #typeLibraries #registerTypeLibraries #unregisterTypeLibraries #releaseTypeLibraries #updateTypeLibraries #installRuntime #registerSessionEventHandlers #removeSessionEventHandlers #startUpApplication) asSortedCollection.			l addAll: sels].	self classMethodList list: l.	self classMethodList selectAll.	sels := #(#automationServer #dispatchInterface #releaseAutomationServer) asSortedCollection.	self instanceMethodList list: sels.	self instanceMethodList selectAll</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage class</class-id> <category>utils</category><body package="Com- Automation Development">warnNotGenerating: aMethod inClass: aClass	"Warn the user that aMethod for aClass is not being generated"	|msg|	msg := (#WarnNotGenerate &lt;&lt; #com &gt;&gt; 'COM Automation Wizard will not generate &lt;1s&gt; for &lt;2s&gt;.  &lt;2s&gt; already understands &lt;1s&gt;.') 		expandMacrosWith: aMethod printString		with: aClass unambiguousName.	Transcript 		show: msg ;		cr.	"MessageBox warn: msg"</body></methods><methods><class-id>External.EmptyCOMServerClass class</class-id> <category>accessing</category><body package="Com- Automation Development">iidInterfaceDisp	^ nil</body><body package="Com- Automation Development">iidVtableInterface	^ nil</body><body package="Com- Automation Development">newTypeLibraryNeutral	^ nil</body></methods><methods><class-id>Tools.IDLParameterDefinition</class-id> <category>printing</category><body package="Com- Automation Development">printFlagsOn: aStream	"clients must use out,retval"	flags do: [:each | aStream nextPutAll: each] separatedBy: [aStream nextPutAll: ', ']</body><body package="Com- Automation Development">printOn: aStream 	aStream nextPut: $[.	self printFlagsOn: aStream.	aStream nextPut: $]; nextPut: Character space; nextPutAll: type.	(flags contains: [:each | #(#out #retval) includes: each ])		ifTrue: [aStream nextPut: $*].	aStream nextPut: Character space; nextPutAll: name</body></methods><methods><class-id>Tools.IDLParameterDefinition</class-id> <category>accessing</category><body package="Com- Automation Development">name: aString type: newType flags: newFlags 	name := aString.	((newFlags includes: #optional) and: [('VARIANT*' match: newType) not ]) ifTrue: [ 		^ self error: (#OnlyVariantsParametersCanBeOptional &lt;&lt; #com &gt;&gt;'only VARIANT parameters can be optional')].	type := newType.	flags := newFlags.</body></methods><methods><class-id>Tools.IDLParameterDefinition class</class-id> <category>instance creation</category><body package="Com- Automation Development">name: aString type: aTypeString flags: aFlagsString	^self new		name: aString		type: aTypeString		flags: aFlagsString</body><body package="Com- Automation Development">name: aString type: typeString returnType: aString3 	^self new		name: aString		type: typeString		flags: (self flagsFor: aString3)</body><body package="Com- Automation Development">name: aString type: aString2 returnType: returnType optional: aBoolean	| flags |	flags := self flagsFor: returnType.	aBoolean ifTrue: [flags := flags copyWith: #optional].	^self name: aString type: aString2 flags: flags</body></methods><methods><class-id>Tools.IDLParameterDefinition class</class-id> <category>private</category><body package="Com- Automation Development">flagsFor: returnType	^((returnType tokensBasedOn: $,) collect: [:each | each trimBlanks asSymbol ]) asArray</body></methods><methods><class-id>Tools.IDLMethodDefinition</class-id> <category>accessing</category><body package="Com- Automation Development">helpString	^helpString</body><body package="Com- Automation Development">helpString: aValue 	helpString := aValue</body><body package="Com- Automation Development">methodName	^methodName</body><body package="Com- Automation Development">methodName: aValue 	methodName := aValue</body><body package="Com- Automation Development">optionalParameterCount	^optionalParameterCount ifNil: [0]</body><body package="Com- Automation Development">optionalParameterCount: anObject	optionalParameterCount := anObject</body><body package="Com- Automation Development">parameterTypes	^parameterTypes</body><body package="Com- Automation Development">parameterTypes: aValue 	parameterTypes := aValue</body><body package="Com- Automation Development">parameters	^parameters</body><body package="Com- Automation Development">parameters: aValue 	parameters := aValue</body><body package="Com- Automation Development">returnTypes	^returnTypes</body><body package="Com- Automation Development">returnTypes: aValue 	returnTypes := aValue.</body><body package="Com- Automation Development">stSelector	"return the smalltalk selector that this method maps to"	^stSelector</body><body package="Com- Automation Development">stSelector: aString 	"set the smalltalk selector that this method maps to"	stSelector := aString</body></methods><methods><class-id>Tools.IDLMethodDefinition</class-id> <category>printing</category><body package="Com- Automation Development">helpStringOn: aStream 	aStream nextPutAll: '[helpstring("'; nextPutAll: self helpString; nextPutAll: '")]'; nextPut: Character space</body><body package="Com- Automation Development">initializeParameterDefs	| defs paramCount lastRequiredParameter |	defs := IDLParametersDefinition new.	paramCount := self returnTypes size.	lastRequiredParameter := paramCount - self optionalParameterCount.	1 to: paramCount		do: 			[:i |			defs paramDef: (IDLParameterDefinition						name: (self parameters at: i)						type: (self parameterTypes at: i)						returnType: (self returnTypes at: i)						optional: i &gt; lastRequiredParameter)].	^defs</body><body package="Com- Automation Development">methodEndOn: aStream 	aStream nextPutAll: ';'</body><body package="Com- Automation Development">methodNameOn: aStream 	aStream nextPutAll: self methodName; nextPut: Character space</body><body package="Com- Automation Development">parameterDefs	^ parameterDefs ifNil: [ parameterDefs :=  self initializeParameterDefs ]</body><body package="Com- Automation Development">parameterDefs: newDefs	^parameterDefs := newDefs</body><body package="Com- Automation Development">parametersOn: aStream 	self parameterDefs printOn: aStream</body><body package="Com- Automation Development">printOn: aStream		[self helpStringOn: aStream.	self resultOn: aStream.	self methodNameOn: aStream.	self parametersOn: aStream.	self methodEndOn: aStream]			on: Error			do: 				[:ex |				^Error raiseWith: self					errorString: (#ErrorWhenGeneratingIDL &lt;&lt; #com							&gt;&gt; 'Error when generating IDL code for &lt;1p&gt;. Reason: &lt;2s&gt;'								expandMacrosWith: self methodName								with: ex description) asString]</body><body package="Com- Automation Development">resultOn: aStream 	aStream nextPutAll: 'HRESULT'; nextPut: Character space</body></methods><methods><class-id>Tools.IDLMethodDefinition</class-id> <category>testing</category><body package="Com- Automation Development">definesSameAs: anIDLMethodDefinition	"Answer true if this definition defines the same thing as the argument."	^self class == anIDLMethodDefinition class		and: [self methodName = anIDLMethodDefinition methodName]</body><body package="Com- Automation Development">isMethodDef	^true</body></methods><methods><class-id>Tools.IDLMethodDefinition</class-id> <category>ui support</category><body package="Com- Automation Development">browseDefiningMethod: classes	| environment |	environment := Refactory.Browser.SelectorEnvironment implementorsOf: self stSelector in: (Refactory.Browser.BrowserEnvironment new forClasses: classes).	environment openEditor	"	methodCollector := MethodCollector new.	methodCollector		browseSelect: (methodCollector implementorsOf: self stSelector)"	"results := Refactory.Browser.BrowserEnvironment new implementorsOf: self stSelector.	results notEmpty		ifTrue: [results openEditor]"</body></methods><methods><class-id>Tools.IDLMethodDefinition</class-id> <category>initialize-release</category><body package="Com- Automation Development">initialize	methodName := parameters := parameterTypes := returnTypes := helpString := String new.</body></methods><methods><class-id>Tools.IDLMethodDefinition class</class-id> <category>instance creation</category><body package="Com- Automation Development">getProperty: mName type: type helpString: hString 	^IDLPropertyDefinition new		name: mName		type: type		helpString: hString</body><body package="Com- Automation Development">methodName: mName helpString: aString	| none |	^self		methodName: mName		parameters: (none := Array new)		parameterTypes: none		returnTypes: none		helpString: aString</body><body package="Com- Automation Development">methodName: mName parameters: params parameterTypes: paramTypes optionalParameterCount: optParamCount returnTypes: retTypes	^self		methodName: mName		parameters: params		parameterTypes: paramTypes		optionalParameterCount: optParamCount		returnTypes: retTypes		helpString: String new</body><body package="Com- Automation Development">methodName: mName parameters: params parameterTypes: paramTypes optionalParameterCount: optParamCount returnTypes: retTypes helpString: aString	^self new methodName: mName;				parameters: params;				optionalParameterCount: optParamCount;				parameterTypes: paramTypes;				returnTypes: retTypes;				helpString: aString;				yourself</body><body package="Com- Automation Development">methodName: mName parameters: params parameterTypes: paramTypes returnTypes: retTypes	^self		methodName: mName		parameters: params		parameterTypes: paramTypes		optionalParameterCount: nil		returnTypes: retTypes</body><body package="Com- Automation Development">methodName: mName parameters: params parameterTypes: paramTypes returnTypes: retTypes helpString: aString	^self		methodName: mName		parameters: params		parameterTypes: paramTypes		optionalParameterCount: nil		returnTypes: retTypes		helpString: aString</body><body package="Com- Automation Development">new	^super new initialize</body><body package="Com- Automation Development">setProperty: mName type: type helpString: hString 	^IDLSetPropertyDefinition new		name: mName		type: type		helpString: hString</body></methods><methods><class-id>Tools.IDLPropertyDefinition</class-id> <category>testing</category><body package="Com- Automation Development">isMethodDef	^false</body><body package="Com- Automation Development">isSetProperty	^false</body></methods><methods><class-id>Tools.IDLPropertyDefinition</class-id> <category>printing</category><body package="Com- Automation Development">helpStringOn: aStream 	aStream nextPutAll: '[propget, helpstring("'; nextPutAll: self helpString; nextPutAll: '")]'; nextPut: Character space</body></methods><methods><class-id>Tools.IDLPropertyDefinition</class-id> <category>accessing</category><body package="Com- Automation Development">name: pName type: type helpString: hString 	self methodName: pName.	self parameterDefs: (IDLParametersDefinition new				 paramDef: (IDLParameterDefinition			name: 'Value'			type: type			returnType: 'out, retval');				yourself).	self helpString: hString</body></methods><methods><class-id>Tools.IDLPropertyDefinition class</class-id> <category>instance creation</category><body package="Com- Automation Development">name: pName type: type helpString: hString 	^(self new) name: pName; type: type; helpString: hString</body></methods><methods><class-id>Tools.ComAutomationWizardClassesPage</class-id> <category>accessing</category><body package="Com- Automation Development">classFinder	^classFinder isNil		ifTrue:			[classFinder := ClassFinder new.			classFinder allowUndefinedClass: false.			classFinder disallowCreation]		ifFalse:			[classFinder]</body><body package="Com- Automation Development">helpText	^#wizardClassPageHelp &lt;&lt; #com &gt;&gt; 'The Classes page is where you select the classes that you want to publish. You can use the ClassFinder (by clicking on the magnifying glass button) to find the classes that you want. After you have found a class, select OK from the ClassFinder and click on the Add button to add the class into the selected classes list. Next, select the class(es) that youwant to publish.'</body></methods><methods><class-id>Tools.ComAutomationWizardClassesPage</class-id> <category>aspects</category><body package="Com- Automation Development">objectClassList	^manager domain objectClassList</body></methods><methods><class-id>Tools.ComAutomationWizardClassesPage</class-id> <category>actions</category><body package="Com- Automation Development">addNewClass		IncrementalSearchDialog selectClass		ifNotNil: [:newClass | self objectClassList list add: newClass]</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>private-utilities</category><body package="Com- Automation Development">asLiteralString: aValue		" Private - temporary patch to provide #asLiteralString service "	aValue class == ByteArray  " GUID bytes "		ifTrue: [ ^( GUID fromBytes: aValue ) hexByteString ].	aValue class == Array		ifTrue: [ 			| aStream |			aStream := ReadWriteStream on: String new.			aStream nextPutAll: '#( '.			aValue do: [ :each | aStream nextPutAll: ( self asLiteralString: each ), ' ' ].			aStream nextPutAll: ')'.			^aStream contents ].	^aValue storeString    " String, Symbol, Number... "</body><body package="Com- Automation Development">checkConsistencyOf: specTable1 and: specTable2		" Private - verify that the two specification tables have consistent stock properties "	( specTable1 specificationKey = specTable2 specificationKey	and: [ specTable1 clsid = specTable2 clsid	and: [ specTable1 name = specTable2 name	and: [ specTable1 iid = specTable2 iid ] ] ] )		ifFalse: [			COMDevelopmentWarning raiseSignal: #ErrInconsistentSpecHeader &lt;&lt; #com &gt;&gt;'Inconsistent spec table header properties' ].</body><body package="Com- Automation Development">indent		" Private - answer the indent in description reports. "	^self class indent</body><body package="Com- Automation Development">indexOfFirstMemberIn: aLiteralArray		" Private - answer the index of the first member 		specification literal in the dispatch specification		literal &lt;aLiteralArray&gt; following the named		stock properties of the table. "	| index |	index := 2.  " first element is the spec table type "	[ index &lt;= aLiteralArray size ]		whileTrue: [			( aLiteralArray at: index ) isSymbol				ifFalse: [ ^index ].			index := index + 2.			].	Assert isTrue: [ index = ( aLiteralArray size + 1 ) ].  " empty table "	^index</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>accessing</category><body package="Com- Automation Development">clsid: aCLSID		" Record &lt;aCLSID&gt; as the CLSID associated with		specification tables constructed by the receiver. "	aCLSID isNil ifTrue: [ ^self ].	stockPropertyActions add: [ :aDispatchSpecificationTable |		aDispatchSpecificationTable clsid: aCLSID ].</body><body package="Com- Automation Development">eventSpecifications		" Answer the event specifications. "	^eventSpecifications</body><body package="Com- Automation Development">eventSpecifications: aDispatchSpecificationTable		" Set the event specifications. "	self installStockProperties: aDispatchSpecificationTable.	eventSpecifications := aDispatchSpecificationTable.</body><body package="Com- Automation Development">lcid: anLCID		" Record &lt;anLCID&gt; as the locale ID associated with		specification tables constructed by the receiver. "	anLCID isNil ifTrue: [ ^self ].	stockPropertyActions add: [ :aDispatchSpecificationTable |		aDispatchSpecificationTable lcid: anLCID ].</body><body package="Com- Automation Development">methodSpecifications		" Answer the method specifications. "	^methodSpecifications</body><body package="Com- Automation Development">methodSpecifications: aDispatchSpecificationTable		" Set the method specifications. "	self installStockProperties: aDispatchSpecificationTable.	methodSpecifications := aDispatchSpecificationTable.</body><body package="Com- Automation Development">propertySpecifications		" Answer the property specifications. "	^propertySpecifications</body><body package="Com- Automation Development">propertySpecifications: aDispatchSpecificationTable		" Set the property specifications. "	self installStockProperties: aDispatchSpecificationTable.	propertySpecifications := aDispatchSpecificationTable.</body><body package="Com- Automation Development">role	"Answer the role for which we are generating, #client or #server. If no role has been set, default to #client."	role isNil ifTrue: [ ^#client ].	^role</body><body package="Com- Automation Development">role: aSymbol	"Answer the role for which we are generating, #client or #server."	( self class checkRole: aSymbol ) ifFalse: [ ^self ].	role := aSymbol.</body><body package="Com- Automation Development">stream		" Private - answer the report stream. "	^stream</body><body package="Com- Automation Development">stream: aStream		" Private - set the report stream. "	stream := aStream.</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>description</category><body package="Com- Automation Development">describeDispatchInterface: anIDispatch		" Describe the methods, properties, and events supported by &lt;anIDispatch&gt;. "	self getDispatchInterfaceSpecifications: anIDispatch.	self		describeMethods;		describeProperties;		describeEvents.</body><body package="Com- Automation Development">describeEnumerationConstants: anITypeInfo		" Describe the enumeration constants described by &lt;anITypeInfo&gt;. "    | indent indent2 constants |    indent := self indent.    indent2 := indent, indent.	stream nextPutAll: indent, anITypeInfo getDocumentationName,		' Enumeration:'; cr.    "Print out the dictionary in alphabetical order."	constants := self class getEnumerationConstants: anITypeInfo.    constants keys asSortedCollection do: [ : aKey |        " &lt;name&gt; &lt;value&gt; "        stream            nextPutAll: indent2, aKey, ': ';            nextPutAll: ( constants at: aKey ) printString;            cr.    ].	stream cr.</body><body package="Com- Automation Development">describeEventSpecifications: aSpecificationTable	" Describe the events defined by &lt;aSpecificationTable&gt;. "	self		eventSpecifications: aSpecificationTable;		describeEvents.</body><body package="Com- Automation Development">describeEventTypeInfo: anITypeInfo		" Describe the events defined by &lt;anITypeInfo&gt;. "	self getEventTypeInfoSpecifications: anITypeInfo.	self describeEvents.</body><body package="Com- Automation Development">describeMethodSpecifications: aSpecificationTable	" Describe the methods defined by &lt;aSpecificationTable&gt;. "	self        methodSpecifications: aSpecificationTable;        describeMethods.</body><body package="Com- Automation Development">describePropertySpecifications: aSpecificationTable	" Describe the properties defined by &lt;aSpecificationTable&gt;. "	self        propertySpecifications: aSpecificationTable;        describeProperties.</body><body package="Com- Automation Development">describeTypeInfo: anITypeInfo		" Describe the methods and properties supported by &lt;anITypeInfo&gt;. "	self getTypeInfoSpecifications: anITypeInfo.	self		describeMethods;		describeProperties.</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>private-description</category><body package="Com- Automation Development">describeDISPID: aDISPID	"Answer a string with a hexadecimal and decimal description of the dispatch ID &lt;aDISPID&gt;."	^'DISPID: 16r', ( aDISPID printStringRadix: 16 ), ' (', aDISPID printString, ')'</body><body package="Com- Automation Development">describeEvents	" Describe the contents of the event specification table. "    | aSpecificationTable indent indent2 	  aDispatchSpecification selector specificSpecification |	indent := self indent.	indent2 := indent, indent.	"indent3 := indent, indent, indent."    stream nextPutAll: 'Events:'; cr.    eventSpecifications size = 0        ifTrue: [            stream nextPutAll: indent, '(none)'; cr; cr.            ^self ].	self describePropertiesOf: eventSpecifications.	aSpecificationTable := eventSpecifications specificationTable.	aSpecificationTable keys asSortedCollection do: [ :key |		aDispatchSpecification := aSpecificationTable at: key.		specificSpecification := aDispatchSpecification getSpecification.		stream 			cr;			nextPutAll: indent, specificSpecification name; cr;			nextPutAll: indent2, ( self describeDISPID: specificSpecification memberID ); cr.		selector := specificSpecification selectorAttribute.		selector isNil			ifTrue: [ selector := specificSpecification defaultSelector ].		stream nextPutAll: indent2, 'Event name: ', selector storeString; cr.		self describeParameters: specificSpecification parameterNames 			types: specificSpecification parameterTypeCodes.		specificSpecification optionalParameterCount ~= 0			ifTrue: [				stream nextPutAll: indent2, 'Optional parameter count: ';					nextPutAll: specificSpecification optionalParameterCount printString; cr ].		stream nextPutAll: indent2, 'Return type: ', 			( self typeCodeDescriptionOf: specificSpecification typeCode ); cr.		].	stream		cr;		nextPutAll: '    ( ', aSpecificationTable size printString, ' events )'; cr;		cr.</body><body package="Com- Automation Development">describeGetParameters: getParameters  setParameters: setParameters        " Private - describe the parameters supported by a specification. "	| indent2 indent3 param |	indent2 := self indent, self indent.	indent3 := indent2, self indent.	stream nextPutAll: indent2, 'Arguments:'; cr.	1 to: setParameters size do: [ :i |		param := ( setParameters at: i ).		stream 			nextPutAll: indent3, param name, ' '.		(getParameters includes: param) ifFalse: [ 			stream nextPutAll: (#SetPropertyOnly &lt;&lt; #com &gt;&gt; '(setproperty only)') asString ].		stream nextPutAll:  ' : ';			nextPutAll: ( self typeCodeDescriptionOf: param typecode );			cr ].</body><body package="Com- Automation Development">describeMethods	" Describe the methods. "	| aSpecificationTable indent indent2 aDispatchSpecification selector specificSpecification |	indent := self indent.	indent2 := indent , indent.	"indent3 := indent, indent, indent."	stream		nextPutAll: 'Methods:';		cr.	methodSpecifications size = 0		ifTrue: 			[stream				nextPutAll: indent , '(none)';				cr;				cr.			^self].	self describePropertiesOf: methodSpecifications.	aSpecificationTable := methodSpecifications allSpecifications				sorted: #key ascending.	aSpecificationTable do: 			[:association |			aDispatchSpecification := association value.			specificSpecification := aDispatchSpecification getSpecification.			stream				cr;				nextPutAll: indent , specificSpecification name;				cr;				nextPutAll: indent2 , (self describeDISPID: specificSpecification memberID);				cr.			selector := specificSpecification selectorAttribute.			selector isNil ifTrue: [selector := specificSpecification defaultSelector].			stream				nextPutAll: indent2 , 'Selector: ' , selector storeString;				cr.			self describeParameters: specificSpecification parameterNames				types: specificSpecification parameterTypeCodes.			specificSpecification optionalParameterCount ~= 0				ifTrue: 					[stream						nextPutAll: indent2 , 'Optional parameter count: ';						nextPutAll: specificSpecification optionalParameterCount printString;						cr].			stream				nextPutAll: indent2 , 'Return type: '							, (self typeCodeDescriptionOf: specificSpecification typeCode);				cr].	stream		cr;		nextPutAll: '( ' , aSpecificationTable size printString , ' methods )';		cr;		cr</body><body package="Com- Automation Development">describeParameters: parameterNames types: parameterTypes        " Private - describe the parameters supported by a specification. "	| nParameters indent2 indent3 |	nParameters := parameterTypes size.	nParameters = 0		ifTrue: [			Assert isZero: parameterNames size.			^self ].	indent2 := self indent, self indent.	indent3 := indent2, self indent.	parameterNames size ~= nParameters		ifTrue: [			"Assert shouldNotBe."			parameterNames size &gt; 0				ifTrue: [					stream nextPutAll: indent2, 'Parameter names: ',						parameterNames printString; cr ].				parameterTypes size &gt; 0					ifTrue: [						stream nextPutAll: indent2, 'Argument types:'; cr.						parameterTypes do: [ :aTypeCode |							stream nextPutAll: indent3, 								( self typeCodeDescriptionOf: aTypeCode ); cr ] ].			^self ].	stream nextPutAll: indent2, 'Arguments:'; cr.	1 to: nParameters do: [ :i |		stream 			nextPutAll: indent3, ( parameterNames at: i ), ': ';			nextPutAll: ( self typeCodeDescriptionOf: ( parameterTypes at: i ) );			cr ].</body><body package="Com- Automation Development">describeProperties	" Describe the properties. "	| aSpecificationTable indent indent2 aDispatchSpecification selectorDescription setSpecification getSpecification |	indent := self indent.	indent2 := indent , indent.	"indent3 := indent, indent, indent."	stream		nextPutAll: (#PropertiesColon &lt;&lt; #com &gt;&gt; 'Properties:') asString;		cr.	propertySpecifications size = 0		ifTrue: 			[stream				nextPutAll: indent , (#none &lt;&lt; #com &gt;&gt; '(none)') asString;				cr;				cr.			^self].	self describePropertiesOf: propertySpecifications.	aSpecificationTable := propertySpecifications allSpecifications				sorted: #key ascending.	aSpecificationTable do: 			[:association |			aDispatchSpecification := association value.			stream				cr;				nextPutAll: indent , aDispatchSpecification name;				cr;				nextPutAll: indent2							, (self describeDISPID: aDispatchSpecification memberID);				cr.			selectorDescription := aDispatchSpecification isWriteOnly						ifTrue: 							[(#NoneWriteOnlyShh &lt;&lt; #com &gt;&gt; '(none - writeOnly property)') asString]						ifFalse: 							[(aDispatchSpecification getSpecification selectorAttribute notNil								ifTrue: [aDispatchSpecification getSpecification selectorAttribute]								ifFalse: [aDispatchSpecification getSpecification defaultSelector])									storeString].			stream				nextPutAll: indent2							, (#NamedGetSelectorColon &lt;&lt; #com &gt;&gt; 'Get selector: &lt;1s&gt;'									expandMacrosWith: selectorDescription);				cr.			selectorDescription := aDispatchSpecification isReadOnly						ifTrue: [(#NoneReadOnlyShh &lt;&lt; #com &gt;&gt; '(none - readOnly property)') asString]						ifFalse: 							[(aDispatchSpecification setSpecification selectorAttribute notNil								ifTrue: [aDispatchSpecification setSpecification selector]								ifFalse: [aDispatchSpecification setSpecification defaultSelector])									storeString].			stream				nextPutAll: indent2							, (#NamedSetSelectorColon &lt;&lt; #com &gt;&gt; 'Set selector: &lt;1s&gt;'									expandMacrosWith: selectorDescription);				cr.			setSpecification := aDispatchSpecification setSpecification.			getSpecification := aDispatchSpecification getSpecificationForDisplay.			aDispatchSpecification isParameterized				ifTrue: 					[self describePropertyParameters: aDispatchSpecification.					getSpecification optionalParameterCount ~= 0						ifTrue: 							[stream								nextPutAll: indent2											, (#NamedOptionalParamCount &lt;&lt; #com &gt;&gt; 'Optional parameter count: &lt;1p&gt;'													expandMacrosWith: getSpecification optionalParameterCount);								cr]].			stream				nextPutAll: indent2 , (#NamedValueColon &lt;&lt; #com &gt;&gt; 'Value: &lt;1s&gt;'									expandMacrosWith: (self typeCodeDescriptionOf: getSpecification typeCode));				cr.			(aDispatchSpecification isParameterized				and: [aDispatchSpecification isReadOnly not])					ifTrue: 						[stream							nextPutAll: indent2										, (#NamedPutResultTypeColon &lt;&lt; #com &gt;&gt; 'Put result type: &lt;1s&gt;'												expandMacrosWith: (self typeCodeDescriptionOf: setSpecification typeCode));							cr]].	stream		cr;		nextPutAll: (#NamedPropertiesShh &lt;&lt; #com &gt;&gt; '( &lt;1p&gt; properties )'					expandMacrosWith: aSpecificationTable size);		cr;		cr</body><body package="Com- Automation Development">describePropertiesOf: aSpecificationTable	" Private - describe the properties of &lt;aSpecificationTable&gt;. "	| clsid name iid lcid indent |	clsid := aSpecificationTable clsid.	name := aSpecificationTable name.	iid := aSpecificationTable iid.	lcid := aSpecificationTable lcid.	indent := self indent.	clsid notNil		ifTrue: [ stream nextPutAll: indent, 'CLSID: ', clsid printString; cr ].	name notNil		ifTrue: [ stream nextPutAll: indent, 'Interface name: ', name; cr ].	iid notNil		ifTrue: [ stream nextPutAll: indent, 'IID: ', iid printString; cr ].	lcid notNil		ifTrue: [ stream nextPutAll: indent, 'Locale ID: ', lcid printString; cr ].</body><body package="Com- Automation Development">describePropertyParameters: aPropertySpec	| getParameters setParameters |	getParameters := aPropertySpec getSpecificationForDisplay ifNil: [#()] ifNotNil: [:spec | spec parameters].	setParameters := aPropertySpec setSpecification ifNil: [getParameters] ifNotNil: [:spec | spec parameters].	self describeGetParameters: getParameters setParameters: setParameters</body><body package="Com- Automation Development">typeCodeDescriptionOf: aTypeCode		" Private - answer a string description of &lt;aTypeCode&gt;. "	aTypeCode isInteger		ifFalse: [ ^aTypeCode printString ].  " GUID can be in here... "	^COMVariant typeCodeDescriptionOf: aTypeCode</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>generation</category><body package="Com- Automation Development">generateAppendix	| indent2 |	indent2 := self indent , self indent.	stream		cr;		nextPutAll: indent2 , ').';		cr;		cr.	stream		nextPutAll: self indent , '" End of specification "';		cr</body><body package="Com- Automation Development">generateDispatchInterfaceSpecifications: anIDispatch		" Generate the specification literals for the methods, properties, and events supported by &lt;anIDispatch&gt;. "	self getDispatchInterfaceSpecifications: anIDispatch.	self		generateMethodPropertyAndEventSpecifications.</body><body package="Com- Automation Development">generateEnumerationConstants: anITypeInfo		" Generate a literal defining the enumeration constants described by &lt;aDictionary&gt;. "    | indent indent2 indent3 constants |    indent := self indent.    indent2 := indent, indent.    indent3 := indent, indent, indent.	stream nextPutAll: indent, '" ', anITypeInfo getDocumentationName,		' Enumeration "'; cr.   stream        nextPutAll: indent2, '#( ';        cr.    "Print out the dictionary in alphabetical order."	constants := self class getEnumerationConstants: anITypeInfo.    constants keys asSortedCollection do: [ : aKey |        " &lt;name&gt; &lt;value&gt; "        stream            nextPutAll: indent3, '#( ';            nextPutAll: aKey storeString, ' ';            nextPutAll: ( constants at: aKey ) storeString, ' )';            cr.    ].   stream        nextPutAll: indent2, ').'; cr;        cr.</body><body package="Com- Automation Development">generateEventTypeInfoSpecifications: anITypeInfo		" Generate the specification literals for the events defined by &lt;anITypeInfo&gt;. "	self getEventTypeInfoSpecifications: anITypeInfo.	self generateEventSpecifications.</body><body package="Com- Automation Development">generateMethodAndPropertySpecifications	" Generate the method and property specifications literal "	(self methodSpecifications size = 0		and: [self propertySpecifications size = 0])			ifTrue: 				[stream					nextPutAll: self indent								, '" No method or properties exist, no specification table was generated. "';					cr.				^self].	self generateSpecificationHeader.	self generateMethodSpecificationsOnly.	self generatePropertySpecificationsOnly.	self generateAppendix.</body><body package="Com- Automation Development">generateMethodPropertyAndEventSpecifications	(self methodSpecifications size = 0		and: [self propertySpecifications size = 0])			ifTrue: 				[stream					nextPutAll: self indent								, '" No method or properties exist, no specification table was generated. "';					cr.				^self].	self generateSpecificationHeader.	self generateMethodSpecificationsOnly.	self generatePropertySpecificationsOnly.	self generateEventSpecificationsOnly.	self generateAppendix</body><body package="Com- Automation Development">generateSpecificationHeader	self checkConsistencyOf: self methodSpecifications		and: self propertySpecifications.	stream		nextPutAll: self indent					, '" This is the specification table literal for the dispatch Interface: ';		cr;		nextPutAll: self indent , '		Name:		' , self methodSpecifications name;		cr;		nextPutAll: self indent , '		Locale ID:	'					, self methodSpecifications lcid printString;		cr;		nextPutAll: self indent , '		IID:			'					, self methodSpecifications iid asString;		cr;		nextPutAll: self indent , '		Methods:	'					, self methodSpecifications size printString;		cr;		nextPutAll: self indent , '		Properties:	'					, self propertySpecifications size printString;		cr;		nextPutAll: self indent , ' This interface is indexed for use by a '					, self role asString , '. "';		cr;		cr.	stream		nextPutAll: self indent , '" Specification Table Header "';		cr.	self generateTableHeader: methodSpecifications</body><body package="Com- Automation Development">generateSpecifications: aDispatchSpecificationTable	" Generate the specification literal for &lt;aDispatchSpecificationTable&gt;. "	| indent indent2 |	indent := self indent.	indent2 := self indent , self indent.	aDispatchSpecificationTable size = 0		ifTrue: 			[stream				nextPutAll: indent , '" (none) "';				cr.			^self].	self generateTableHeader: aDispatchSpecificationTable.	aDispatchSpecificationTable		do: [:each | self generateMemberSpecification: each].	stream		nextPutAll: indent2 , ').';		cr;		cr</body><body package="Com- Automation Development">generateTypeInfoSpecifications: anITypeInfo		" Generate the specification literals for the methods and properties defined by &lt;anITypeInfo&gt;. "	self getTypeInfoSpecifications: anITypeInfo.	self generateMethodAndPropertySpecifications.</body><body package="Com- Automation Development">privateGenerateSpecifications: aDispatchSpecificationTable	" Generate the specification literal entries for &lt;aDispatchSpecificationTable&gt;. "	| indent  |	indent := self indent.	aDispatchSpecificationTable size = 0		ifTrue: 			[stream				nextPutAll: indent , '" (none) "';				cr.			^self].	aDispatchSpecificationTable		do: [:each | self generateMemberSpecification: each].</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>private-generation</category><body package="Com- Automation Development">generateEventSpecifications		" Generate the event specifications literal "	stream nextPutAll: self indent, '" Events "'; cr.	self generateSpecifications: self eventSpecifications.	stream cr.</body><body package="Com- Automation Development">generateEventSpecificationsOnly		" Generate the event specifications literal "	stream nextPutAll: self indent, '" Events "'; cr.	self privateGenerateSpecifications: self eventSpecifications.	stream cr.</body><body package="Com- Automation Development">generateMemberSpecification: aMember	" Generate the specification literal for the dispatch specification literal &lt;anArray&gt;. "	"stream nextPutAll: indent2, ( self asLiteralString: aDispatchSpecificationLiteral ); cr."	| anArray |	anArray := aMember literalArrayEncoding.	stream cr.	self prettyPrintSpecArray: anArray on: stream indent: 2.</body><body package="Com- Automation Development">generateMethodSpecifications		" Generate the method specifications literal "	stream nextPutAll: self indent, '" Methods "'; cr.	self generateSpecifications: self methodSpecifications.	stream cr.</body><body package="Com- Automation Development">generateMethodSpecificationsOnly	" Generate the method and property specifications literal "	| indent2 |	indent2 := self indent , self indent.	stream		cr;		nextPutAll: indent2 , '" Methods ('					, self methodSpecifications size printString , ') "';		cr;		cr;		nextPutAll: indent2					, '" The selector sent to the published object is by default the method name itself. "';		cr;		nextPutAll: indent2					, '" The keyword for method arguments is by default #with: "';		cr;		nextPutAll: indent2					, '" The selector can be set manually in each method specification by using the pattern: "';		cr;		nextPutAll: indent2 , '" 	#selector: #mySelector "';		cr;		cr.	methodSpecifications isEmpty		ifTrue: 			[stream				nextPutAll: indent2 , '" (none) "';				cr]		ifFalse: 			[methodSpecifications do: [:each | self generateMemberSpecification: each]]</body><body package="Com- Automation Development">generatePropertySpecifications		" Generate the property specifications literal "	stream nextPutAll: self indent, '" Properties "'; cr.	self generateSpecifications: self propertySpecifications.	stream cr.</body><body package="Com- Automation Development">generatePropertySpecificationsOnly	" Generate the method and property specifications literal "	| indent2 |	indent2 := self indent , self indent.	stream		cr;		nextPutAll: indent2 , '"  Properties ('					, self propertySpecifications size printString , ')  "';		cr;		cr;		nextPutAll: indent2					, '" The selector sent to the published object to set a property is by default set&lt;PropertyName&gt;: "';		cr;		nextPutAll: indent2					, '" The selector sent to the published object to get a property is by default get&lt;PropertyName&gt;: "';		cr;		nextPutAll: indent2					, '" The selector can be set manually in each property specification by using the pattern: "';		cr;		nextPutAll: indent2 , '" 	#setSelector: #mySelector: "';		cr;		nextPutAll: indent2 , '" 	#getSelector: #mySelector "';		cr;		cr.	self propertySpecifications isEmpty		ifTrue: 			[stream				nextPutAll: indent2 , '" (none) "';				cr]		ifFalse: 			[self propertySpecifications				do: [:each | self generateMemberSpecification: each]].</body><body package="Com- Automation Development">generateTableHeader: aSpecificiationTable	" Private - generate the specification table header.        The first member literal is at &lt;stopIndex&gt;. "	| indent indent2 stopIndex aLiteralArray|	aLiteralArray := aSpecificiationTable literalArrayEncodingForStockAttributes.	indent := self indent.	indent2 := self indent , self indent.	stopIndex := aLiteralArray size.	stream		nextPutAll: indent , '^#( ' , (aLiteralArray at: 1) storeString;		cr.	" describe the stock properties, notably the key "	2 to: stopIndex - 1		by: 2		do: 			[:index |			Assert isTrue: [(aLiteralArray at: index) isSymbol].			stream				nextPutAll: indent2 , (aLiteralArray at: index) storeString , ' '							, (self asLiteralString: (aLiteralArray at: index + 1));				cr].	stopIndex &lt;= aLiteralArray size		ifTrue: [Assert isFalse: [(aLiteralArray at: stopIndex) isSymbol]]</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>private-initialization</category><body package="Com- Automation Development">getDispatchInterfaceSpecifications: anIDispatch	" Get the specifications of the methods, properties, and events supported by &lt;anIDispatch&gt;. "	| anITypeInfo |	anITypeInfo := anIDispatch getTypeInfo.	anITypeInfo isNil ifTrue: [^self].	self		methodSpecifications: (self getMethodSpecifications: anITypeInfo);		propertySpecifications: (self getPropertySpecifications: anITypeInfo).	anITypeInfo := COMDispatchSpecificationTable getEventTypeInfoOf: anIDispatch.	self eventSpecifications: (self getEventSpecifications: anITypeInfo)</body><body package="Com- Automation Development">getEventSpecifications: anITypeInfo		" Private - construct an specification table with the event name as key. "	anITypeInfo isNil		ifTrue: [ ^nil ].	^COMDispatchSpecificationTable constructEventSpecificationTable: anITypeInfo		specificationKey: #name</body><body package="Com- Automation Development">getEventTypeInfoSpecifications: anITypeInfo		" Get the specifications of the events defined by &lt;anITypeInfo&gt;. "	self eventSpecifications: ( self getEventSpecifications: anITypeInfo ).</body><body package="Com- Automation Development">getMethodSpecifications: anITypeInfo		" Private - construct a method specification table with the function name as key. "	^COMDispatchSpecificationTable constructMethodSpecificationTable: anITypeInfo		specificationKey: self specificationKey</body><body package="Com- Automation Development">getPropertySpecifications: anITypeInfo		" Private - construct a property specification table with the property name as key. "	^COMDispatchSpecificationTable constructPropertySpecificationTable: anITypeInfo		specificationKey: self specificationKey</body><body package="Com- Automation Development">getTypeInfoSpecifications: anITypeInfo		" Get the specifications of the methods and properties defined by &lt;anITypeInfo&gt;. "	self 		methodSpecifications: ( self getMethodSpecifications: anITypeInfo );		propertySpecifications: ( self getPropertySpecifications: anITypeInfo ).</body><body package="Com- Automation Development">initialize		" Private - initialize a new instance of the receiver. "	stockPropertyActions := OrderedCollection new.</body><body package="Com- Automation Development">installStockProperties: aDispatchSpecificationTable		" Private - install the predefined stock properties on &lt;aDispatchSpecificationTable&gt;. "	aDispatchSpecificationTable isNil		ifTrue: [ ^self ].	self stockPropertyActions do: [ :anAction |		anAction value: aDispatchSpecificationTable ].</body><body package="Com- Automation Development">specificationKey	"Private. Answer the specfication key based on the role."	self role = #client ifTrue: [^#name].	self role = #server ifTrue: [^#memberID].	self error: #ErrNoRoleSpecified &lt;&lt; #com &gt;&gt; 'No role specified.'</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>private-accessing</category><body package="Com- Automation Development">stockPropertyActions		" Private - answer the list of actions which are evaluated		to install stock property values on a specification table. "	^stockPropertyActions</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer</class-id> <category>private printing</category><body package="Com- Automation Development">prettyPrintArrayElement: each at: index on: aStream indent: indent elementsInLine: elementsInLine	"print an array type element on the given text line. The index is the index of the element in the collection,	the indent is the number of tabs. ElementsInLine contains the current number of elements in 	one text line (where 2 is the maximum). The method returns the new numer of elements in the current text line"	| tabs |	tabs := index = 1				ifTrue: 					[aStream cr.					indent + 1]				ifFalse: 					[elementsInLine value &gt; 0						ifTrue: 							[aStream cr.							indent + 2]						ifFalse: [indent + 1]].	self prettyPrintSpecArray: each on: aStream indent: tabs.	aStream cr.	^ 0</body><body package="Com- Automation Development">prettyPrintSpecArray: anArray on: aStream indent: indent	"prettyprint a specification table represented as a literal array"	| elementsInLine |	aStream		tab: indent;		nextPutAll: '#('.	elementsInLine := 0.	anArray doWithIndex: 			[:each :index |			each isSpecArray				ifTrue: 					[elementsInLine := self								prettyPrintArrayElement: each								at: index								on: aStream								indent: indent								elementsInLine: elementsInLine]				ifFalse: 					[elementsInLine := self								printBasicElement: each								at: index								on: aStream								indent: indent								elementsInLine: elementsInLine]].	elementsInLine &gt; 0 ifTrue: [aStream cr].	aStream tab: indent + 1.	aStream nextPut: $)</body><body package="Com- Automation Development">prettyPrintSpecValue: anArray on: aStream indent: indent	"prettyprint a specification table entry represented as a literal array"	^anArray isSpecArray		ifTrue: [self prettyPrintSpecArray: anArray on: aStream indent: indent]		ifFalse: 			[aStream				tab: indent;				print: anArray]</body><body package="Com- Automation Development">printBasicElement: each at: index on: aStream indent: indent elementsInLine: elementsInLine	"print an basic element on the given line. The index is the index of the element in the collection,	the indent is the number of tabs. ElementsInLine contains the current number of elements in 	one text line (where 2 is the maximum). The method returns the new numer of elements in the current text line"	| newElements |	index = 1		ifTrue: [aStream tab]		ifFalse: 			[elementsInLine  = 0				ifTrue: [aStream tab: indent + 1]				ifFalse: [aStream tab]].	each storeOn: aStream.	newElements := elementsInLine + 1.	(newElements = 2 or: [index = 1])		ifTrue: 			[newElements := 0.			aStream cr].	^ newElements</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>private-utilities</category><body package="Com- Automation Development">checkRole: aSymbol	"Raise an error is &lt;aSymbol&gt; is not #client or #server. Answer whether &lt;aSymbol&gt; is OK."	( aSymbol ~~ #client and: [ aSymbol ~~ #server ] )		ifTrue: [ 			MessageBox warning:((#IllegalRoleSymbol &lt;&lt; #com &gt;&gt; 'You must specify the Symbol #client or #server. &lt;1s&gt; is illegal.') expandMacrosWith: aSymbol).			^false ]		ifFalse: [ ^true ]</body><body package="Com- Automation Development">classNameOf: aCLSID	" Answer the user name of the class identified by &lt;aCLSID&gt;. "	| fullName |	[	( fullName := COMRegistryInterface getUserTypeFull: aCLSID ) isNil		ifTrue: [ ^((#NoNameRegistered &lt;&lt; #com &gt;&gt; 'No name registred for CLSID &lt;1s&gt;')			expandMacrosWith: aCLSID asString) ]		ifFalse: [ ^fullName ]	] on: COMError        do: [ :ex |  		^((#ErrorLookingForName &lt;&lt; #com &gt;&gt; 'Error looking for the name of CLSID &lt;1s&gt;')			expandMacrosWith: aCLSID asString) ]</body><body package="Com- Automation Development">createAutomationObject: aCLSID		" Create an instance of the automation object identified by &lt;aCLSID&gt;.		Answer its dispatch interface. "	| anIDispatch |	anIDispatch := [ IClassFactory createInstance: aCLSID		iid: IID_IDispatch		] on: COMError		do: [ :ex |			( ex hresult = CO_E_OBJNOTCONNECTED 			or: [ ex hresult = E_NOINTERFACE ] )				ifTrue: [ ex return: nil ].			ex pass ].	anIDispatch notNil		ifTrue: [ ^anIDispatch ].	" try insisting on running a separate server process "	^IClassFactory createInstance: aCLSID		iid: IID_IDispatch		context: CLSCTX_SERVER</body><body package="Com- Automation Development">displayFeedback	"Answer whether or not to display dialog boxes to inform the user when interesting things happen. Make this a toggle in order to use this class for testing without user interaction."	^DisplayFeedback</body><body package="Com- Automation Development">displayFeedback: aBoolean	"Set whether or not to display dialog boxes to inform the user when interesting things happen. Make this a toggle in order to use this class for testing without user interaction."	DisplayFeedback := aBoolean</body><body package="Com- Automation Development">generationInfo	"Answer an information String."	^((#GeneratedBy1sOn2s &lt;&lt; #com &gt;&gt; 'Generated by &lt;1s&gt; on &lt;2s&gt;')			expandMacrosWith: self name			with: Timestamp now printString)</body><body package="Com- Automation Development">getEnumerationConstants: anITypeInfo        " Answer the specifications of the enumeration constants defined by &lt;anITypeInfo&gt;,		where the element names are mapped to the constant value. "	^self getEnumerationConstants: anITypeInfo putIn: Dictionary new</body><body package="Com- Automation Development">getEnumerationConstants: anITypeInfo putIn: aDictionary	"Answer the specifications of the enumeration constants defined by &lt;anITypeInfo&gt;, where the element names are mapped to the constant value. Add the elements to &lt;aDictionary&gt;, which can be any object that follows the dictionary protocol."    | aTypeAttr count aVarDesc constantName |    aTypeAttr := anITypeInfo getTypeAttr.    [	count := aTypeAttr variableCount.    ] ensure: [ 		aTypeAttr enforceRelease ].    0 to: count - 1 do: [ : index |		aVarDesc := anITypeInfo getVarDesc: index.		[		aVarDesc isConstant			ifTrue: [				constantName := aVarDesc getName.				aDictionary at: constantName 					put: aVarDesc constantValue ].        ] ensure: [ 			aVarDesc enforceRelease ].    ].    ^aDictionary</body><body package="Com- Automation Development">getIDispatchFromID: anID	"Get the dispatch interface for the object class identified by &lt;anID&gt;. &lt;anID&gt; can be a ProgID or GUID."	| anIDispatch aCLSID |	anID isNil ifTrue: [^self noID: anID].	(aCLSID := anID asGUID) isNil ifTrue: [^self noID: anID].	anIDispatch := self createAutomationObject: aCLSID.	anIDispatch getTypeInfo isNil		ifTrue: 			[self noTypeInfo: anID asProgID asString , ', ' , aCLSID printString.			^nil].	^anIDispatch</body><body package="Com- Automation Development">indent		" Private - answer the indent in description reports. "	^'	'	"This is a TAB character."</body><body package="Com- Automation Development">promptForTypeLibrary	"Prompt the user for a type library filename. Answer a COMTypeLibrary or nil. The library answer must be released."	| filename |	( filename := FileDialog openFileTitle: #OpenTypeLibrary &lt;&lt; #com &gt;&gt; 'Open Type Library' pattern: '*.tlb; *.olb' ) isNil		ifTrue: [ ^nil ].	^COMTypeLibrary pathName: filename.</body><body package="Com- Automation Development">systemInfo	" Private "	^Smalltalk version"VSE COMC:	^'Visual Smalltalk ', Smalltalk versionNumberString"</body><body package="Com- Automation Development">targetClass	"Return A Class or nil"	"self targetClass"	| classFinder |	classFinder := ClassFinder new.	classFinder allowUndefinedClass: false.	classFinder disallowCreation.	classFinder findClass.	^classFinder selectedClass</body><body package="Com- Automation Development">targetNameSpace	"Return either a NameSpace of a NameSpace of a class, or nil if none"	"self targetNameSpace"	| choice someNameSpace |	choice := Dialog				choose: #SupplyOwnerOfNewPool &lt;&lt; #com &gt;&gt; 'You must Supply who will own the new Pool'				labels: (Array						with: #AClass &lt;&lt; #com &gt;&gt; 'A Class'						with: #ANamespace &lt;&lt; #com &gt;&gt; 'A Namespace'						with: #Abort &lt;&lt; #com &gt;&gt; 'Abort')				values: #(#class #namespace nil)				default: #class.	choice == #namespace		ifTrue: 			[someNameSpace := IncrementalSearchDialog						selectNamespace: #ChooseNameSpaceOwner &lt;&lt; #com &gt;&gt; 'Which NameSpace will own this pool?'].	choice == #class		ifTrue: 			[| classFinder |			classFinder := ClassFinder new.			classFinder allowUndefinedClass: false.			classFinder disallowCreation.			classFinder findClass.			classFinder selectedClass isNil ifTrue: [^nil].			someNameSpace := classFinder selectedClass asNameSpace].	^someNameSpace</body><body package="Com- Automation Development">version	"Answer a String describing the version of this component."	| parcelList parcel |	parcelList := Parcel parcelsForClass: self.	parcelList size = 0 ifTrue: [^'Filed-in class (not from parcel)'].	parcel := parcelList asArray first.	^'Parcel ', parcel name, ' ', parcel version.</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>specification description</category><body package="Com- Automation Development">describeDispatchInterface: anIDispatch	"Generate a description of the dispatch interface members supported by &lt;anIDispatch&gt;."	| aStream |	aStream := ReadWriteStream on: String new.	self describeDispatchInterface: anIDispatch on: aStream.	TextWindow openOn: aStream contents		label: #DispInterfaceDesc &lt;&lt; #com &gt;&gt; 'Dispatch Interface Description'.</body><body package="Com- Automation Development">describeDispatchInterfaceNamed: aMemberName typeLibrary: aCOMTypeLibrary		" Describe the dispatch interface member named &lt;aMemberName&gt;		 in &lt;anITypeLib&gt;. "	| anITypeInfo anITypeLib |	anITypeLib := aCOMTypeLibrary asInterfaceReference.	anITypeInfo := self getTypeInfoOfDispatchInterfaceNamed: aMemberName 		typeLibrary: anITypeLib.	anITypeInfo isNil		ifTrue: [ 			^self noInterfaceFound: aMemberName in: aCOMTypeLibrary ].	self describeTypeInfo: anITypeInfo</body><body package="Com- Automation Development">describeDispatchInterfaces	"Describe all the dispatch interfaces in a type library file picked by the user from a file dialog. "	| typeLib |	( typeLib := self promptForTypeLibrary ) isNil		ifTrue: [ ^self ].	[ self describeDispatchInterfaces: typeLib ]		ensure: [ typeLib enforceRelease ]</body><body package="Com- Automation Development">describeDispatchInterfaces: aCOMTypeLibrary	"Describe all the dispatch interfaces in &lt;aCOMTypeLibrary&gt;. "	| dispatchInterfaces anITypeLib |	anITypeLib := aCOMTypeLibrary asInterfaceReference.	dispatchInterfaces := self typeLibraryDispatchInterfaces: anITypeLib.	dispatchInterfaces isNil ifTrue: [^self noDispatchInterfacedIn: aCOMTypeLibrary].	self describeTypeLibrarySpecifications: anITypeLib dispatchInterfaces: dispatchInterfaces</body><body package="Com- Automation Development">describeEventTypeInfo: anITypeInfo		" Generate a description of the events defined by &lt;anITypeInfo&gt;. "	| aStream |	aStream := ReadWriteStream on: String new.	aStream 		nextPutAll: (#ITypeInfoEvents &lt;&lt; #com &gt;&gt; 'ITypeInfo Events') asString; cr;		cr.	self new		stream: aStream;		describeEventTypeInfo: anITypeInfo.	TextWindow openOn: aStream contents		label: #ITypeInfoEvents &lt;&lt; #com &gt;&gt; 'ITypeInfo Events'.</body><body package="Com- Automation Development">describeID: anID	"Generate a description of the dispatch interface members supported by the object class identified by &lt;anID&gt;, a ProgID or GUID. The object is instantiated in order to get to it's type information."	| anIDispatch className aStream aCLSID |	(aCLSID := anID asGUID) isNil ifTrue: [^self noID: anID].	(anIDispatch := self getIDispatchFromID: aCLSID) isNil ifTrue: [^self].	className := self classNameOf: aCLSID.	aStream := ReadWriteStream on: String new.	aStream		nextPutAll: (#DispIntDescriptionOf &lt;&lt; #com &gt;&gt; 'Dispatch interface description of &lt;1s&gt; (&lt;2p&gt;)'					expandMacrosWith: className					with: aCLSID);		cr;		cr.	(self new)		stream: aStream;		clsid: aCLSID;		describeDispatchInterface: anIDispatch.	TextWindow openOn: aStream contents		label: (#NameDescription &lt;&lt; #com &gt;&gt; '&lt;1s&gt; Description' expandMacrosWith: className)</body><body package="Com- Automation Development">describeSpecificationTable: aDispatchSpecificationTable	" Display a report describing specifications in &lt;aDispatchSpecificationTable&gt;. "	| methodSpecifications propertySpecifications aStream |	methodSpecifications := COMDispatchSpecificationTable new		specificationKey: aDispatchSpecificationTable specificationKey;		yourself.	propertySpecifications := COMDispatchSpecificationTable new		specificationKey: aDispatchSpecificationTable specificationKey;		yourself.	aDispatchSpecificationTable properties keys do: [ :aPropertyName |		methodSpecifications propertyAt: aPropertyName			put: ( aDispatchSpecificationTable propertyAt: aPropertyName ).		propertySpecifications propertyAt: aPropertyName			put: ( aDispatchSpecificationTable propertyAt: aPropertyName ) ].	aDispatchSpecificationTable do: [ :aDispatchSpec |		aDispatchSpec isMethodSpecification			ifTrue: [ methodSpecifications add: aDispatchSpec ]			ifFalse: [ propertySpecifications add: aDispatchSpec ] ].	aStream := ReadWriteStream on: String new.	aStream nextPutAll: (#DispTableMethodsNProps &lt;&lt; #com &gt;&gt; 'Dispatch Table Methods and Properties') asString; cr; cr.	self new		clsid: aDispatchSpecificationTable clsid;		lcid: aDispatchSpecificationTable lcid;		methodSpecifications: methodSpecifications;		propertySpecifications: propertySpecifications;		stream: aStream;		describeMethods;		describeProperties.	TextWindow openOn: aStream contents		label: #DispTableMethodsNProps &lt;&lt; #com &gt;&gt; 'Dispatch Table Methods and Properties'.</body><body package="Com- Automation Development">describeTypeInfo: anITypeInfo		" Generate a description of the methods and properties defined by &lt;anITypeInfo&gt;. "	self describeTypeInfo: anITypeInfo clsid: nil.</body><body package="Com- Automation Development">describeTypeInfo: anITypeInfo clsid: aCLSID		" Generate a description of the methods and properties defined by &lt;anITypeInfo&gt;. "	| aStream |	aStream := ReadWriteStream on: String new.	self describeTypeInfo: anITypeInfo clsid: aCLSID on: aStream.	TextWindow openOn: aStream contents		label: #ITypeInfoDescription &lt;&lt; #com &gt;&gt;'ITypeInfo Description'.</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>private-description</category><body package="Com- Automation Development">describeDispatchInterface: anIDispatch on: aStream	"Generate a description of the dispatch interface members supported by &lt;anIDispatch&gt; on &lt;aStream&gt;."	anIDispatch hasTypeInfo		ifFalse: [ 			aStream nextPutAll: ((#NoTypeInfoAvailable &lt;&lt; #com &gt;&gt; '&lt;1s&gt;: has no type information available.')			expandMacrosWith: anIDispatch printString) ].	aStream 		nextPutAll: (#DispatchInterfaceDescription &lt;&lt; #com &gt;&gt; 'Dispatch interface description') asString; cr;		cr.	self new		stream: aStream;		describeDispatchInterface: anIDispatch.</body><body package="Com- Automation Development">describeTypeInfo: anITypeInfo clsid: aCLSID on: aStream	"Generate a description of the methods and properties defined by &lt;anITypeInfo&gt; on &lt;aStream&gt;."	aStream 		nextPutAll: 'ITypeInfo Members'; cr;		cr.	self new		stream: aStream;		clsid: aCLSID;		describeTypeInfo: anITypeInfo</body><body package="Com- Automation Development">describeTypeLibrarySpecifications: anITypeLib dispatchInterfaces: dispatchInterfaces		" Generate the literal specifications for the dispatch interfaces whose		type info interfaces are contained in &lt;dispatchInterfaces&gt; which are		defined in the type library &lt;anITypeLib&gt;. "	| typeLibName aStream "nInterfaces" index "progressDialog"	  dispatchInterfaceName |	typeLibName := anITypeLib getDocumentationName.	aStream := ReadWriteStream on: String new.	aStream 		nextPutAll: ((#TypeLibNamedDisp &lt;&lt; #com &gt;&gt; '" Type Library &lt;1s&gt; Dispatch Interfaces "') expandMacrosWith: typeLibName) asString; cr; 		cr.	"nInterfaces := dispatchInterfaces size."	index := 0.	Tools.Note temporarilyDisabled.  " Don't know if VW has a facility		equivalent to the Win32 progress indicator dialog.		Disable UI niceness for now.  [DL 24-Mar-96] "	"TEMP DISABLE:	progressDialog := ProgressIndicatorDialog new        backColor: Color dialogBackground;		open: 'Describing Type Library Specifications'			message: ''.	[	"	dispatchInterfaces do: [ :anITypeInfo |		dispatchInterfaceName := anITypeInfo getDocumentationName.		aStream			nextPutAll:((#DispInterfaceNamed &lt;&lt; #com &gt;&gt; '" Dispatch Interface &lt;1s&gt; "') expandMacrosWith: dispatchInterfaceName) asString; cr;			cr.		"TEMP DISABLE:		progressDialog 			percent:  ( index / nInterfaces * 100 ) truncated;			message: 'Interface ', dispatchInterfaceName, '...'.		"		self describeTypeInfo: anITypeInfo clsid: nil on: aStream.		"self new			stream: aStream;			describeDispatchInterface: anITypeInfo."		index := index + 1.		aStream cr.		"TEMP DISABLE:		progressDialog canceled			ifTrue: [				""aStream cr; nextPutAll: 'Generation canceled by user request.'.""			^self ].		"		].	"TEMP DISABLE:	] ensure: [		progressDialog close ].	"    TextWindow openOn: aStream contents        label: #TypeLibSpecs &lt;&lt; #com &gt;&gt; 'Type Library Specifications'.</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>specification generation</category><body package="Com- Automation Development">generateDispatchInterfaceNamed: aMemberName typeLibrary: aCOMTypeLibrary	" Generate a literal specification of the dispatch interface members 		in the dispatch interface named &lt;aMemberName&gt; in &lt;aCOMTypeLibrary&gt;. "	| anITypeInfo anITypeLib |	anITypeLib := aCOMTypeLibrary asInterfaceReference.	anITypeInfo := self getTypeInfoOfDispatchInterfaceNamed: aMemberName typeLibrary: anITypeLib.	anITypeInfo isNil ifTrue: [^nil].	self generateTypeInfoSpecification: anITypeInfo</body><body package="Com- Automation Development">generateEventTypeInfoSpecification: anITypeInfo		" Generate a literal specification of the events defined by &lt;anITypeInfo&gt;. "	| aStream |	aStream := ReadWriteStream on: String new.	aStream 		nextPutAll: '" ',(#ITypeInfoEvents &lt;&lt; #com &gt;&gt; 'ITypeInfo Events') asString,' "'; cr;		cr.	self new		stream: aStream;		generateEventTypeInfoSpecifications: anITypeInfo.	TextWindow openOn: aStream contents		label: #ITypeInfoEvents &lt;&lt; #com &gt;&gt; 'ITypeInfo Events'.</body><body package="Com- Automation Development">generateForID: anID	" Generate a literal specification of the dispatch interface members supported by the object class identified by &lt;anID&gt;. &lt;anID&gt; can be a ProgID or GUID."	| anIDispatch className aStream aCLSID |	(aCLSID := anID asGUID) isNil ifTrue: [^self noID: anID].	(anIDispatch := self getIDispatchFromID: aCLSID) isNil ifTrue: [^self].	className := self classNameOf: aCLSID.	aStream := ReadWriteStream on: String new.	aStream		nextPutAll: '" ' , (#DispIntMembersOf &lt;&lt; #com &gt;&gt; 'Dispatch interface members of &lt;1s&gt; (&lt;2p&gt;)'							expandMacrosWith: className							with: aCLSID printString)					, ' "';		cr;		cr.	(self new)		stream: aStream;		clsid: aCLSID;		generateDispatchInterfaceSpecifications: anIDispatch.	TextWindow openOn: aStream contents		label: (#NamedSpecifications &lt;&lt; #com &gt;&gt; '&lt;1s&gt; Specifications' expandMacrosWith: className)</body><body package="Com- Automation Development">generateSpecificationLiteral: aDispatchSpecificationTable		" Generate a literal specification of &lt;aDispatchSpecificationTable&gt;. "	| aStream |	aStream := ReadWriteStream on: String new.	aStream 		nextPutAll: '" ',(#DispSpecifications &lt;&lt; #com &gt;&gt; 'Dispatch Specifications') asString,' "'; cr;		cr.	self new		stream: aStream;		generateSpecifications: aDispatchSpecificationTable.	TextWindow openOn: aStream contents		label:#DispSpecifications &lt;&lt; #com &gt;&gt; 'Dispatch Specifications'.</body><body package="Com- Automation Development">generateTypeInfoSpecification: anITypeInfo		" Generate a literal specification of the methods and properties defined by &lt;anITypeInfo&gt;. "	self generateTypeInfoSpecification: anITypeInfo clsid: nil.</body><body package="Com- Automation Development">generateTypeInfoSpecification: anITypeInfo clsid: aCLSID		" Generate a literal specification of the methods and properties defined by &lt;anITypeInfo&gt;. "	| aStream |	aStream := ReadWriteStream on: String new.	aStream 		nextPutAll: (#ITypeInfoMembers &lt;&lt; #com &gt;&gt;'" ITypeInfo interface members "') asString; cr;		cr.	self new		stream: aStream;		clsid: aCLSID;		generateTypeInfoSpecifications: anITypeInfo.    TextWindow openOn: aStream contents		label: #ITypeInfoSpecifications &lt;&lt; #com &gt;&gt; 'ITypeInfo Specifications'.</body><body package="Com- Automation Development">generateTypeLibrarySpecifications	"Generate the literal specifications for the dispatch interfaces (selected by the user) defined in a type library selected by the user."	| aCOMTypeLibrary |	( aCOMTypeLibrary := self promptForTypeLibrary ) isNil		ifTrue: [ ^self ].	[	self generateTypeLibrarySpecificationsFromUser: aCOMTypeLibrary.	] ensure: [		aCOMTypeLibrary enforceRelease ].</body><body package="Com- Automation Development">generateTypeLibrarySpecifications: aCOMTypeLibrary	"Generate the literal specifications for all the dispatch interfaces defined in the type library &lt;aCOMTypeLibrary&gt;."	^self generateTypeLibrarySpecifications: aCOMTypeLibrary forRole: #client</body><body package="Com- Automation Development">generateTypeLibrarySpecifications: aCOMTypeLibrary forRole: aSymbol	"Generate the literal specifications for all the dispatch interfaces defined in the type library &lt;aCOMTypeLibrary&gt;. If &lt;aSymbol&gt; is #client, the generated type library is to be used for a client controller. If &lt;aSymbol&gt; is #server, the specification is for a VW server."	| dispatchInterfaces anITypeLib |	(self checkRole: aSymbol) ifFalse: [^self].	anITypeLib := aCOMTypeLibrary asInterfaceReference.	dispatchInterfaces := self typeLibraryDispatchInterfaces: anITypeLib.	self		generateTypeLibrarySpecifications: anITypeLib		dispatchInterfaces: dispatchInterfaces		forRole: aSymbol</body><body package="Com- Automation Development">generateTypeLibrarySpecificationsFromUser: aCOMTypeLibrary	"Generate the literal specifications for the dispatch interfaces defined in the type library &lt;aCOMTypeLibrary&gt; selected by the user. aCOMTypeLibrary may be an instance of ITypeLib. The generated type library is to be used for a client controller."	^self generateTypeLibrarySpecificationsFromUser: aCOMTypeLibrary forRole: #client</body><body package="Com- Automation Development">generateTypeLibrarySpecificationsFromUser: aCOMTypeLibrary forRole: aSymbol	"Generate the literal specifications for the dispatch interfaces defined in the type library &lt;aCOMTypeLibrary&gt; selected by the user. aCOMTypeLibrary may be an instance of ITypeLib."	| dispatchInterfaces anITypeLib |	anITypeLib := aCOMTypeLibrary asInterfaceReference.	dispatchInterfaces := self typeLibraryDispatchInterfacesFromUser: anITypeLib.	dispatchInterfaces isNil ifTrue: [^nil].	self		generateTypeLibrarySpecifications: anITypeLib		dispatchInterfaces: dispatchInterfaces		forRole: aSymbol</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>type library utilities</category><body package="Com- Automation Development">getTypeInfoOfDispatchInterfaceNamed: aMemberName typeLibrary: anITypeLib		" Answer the ITypeInfo interface of the dispatch interface named &lt;aMemberName&gt;		defined in the type library &lt;anITypeLib&gt;. "	^anITypeLib detect: [ :anITypeInfo | 			anITypeInfo typekind = TKIND_DISPATCH			and: [ ( anITypeInfo getDocumentationName ) = aMemberName ]  ]		ifNone: [ nil ]</body><body package="Com- Automation Development">typeLibraryDispatchInterfaceFromUser: anITypeLib	" Answer the dispatch interface type info defined in the type library &lt;anITypeLib&gt;		selected by the user from the list of all dispatch interfaces. "	| dispatchInterfaceMap selectedName |	dispatchInterfaceMap := self typeLibraryDispatchInterfaceMap: anITypeLib.	selectedName := (ListDialog new)				title: #SelectADispatchInterface &lt;&lt; #com &gt;&gt; 'Select a Dispatch Interface';				textLines: (Array							with: (#DispInterfacesInTypeLib &lt;&lt; #com &gt;&gt; 'Dispatch interfaces in type library &lt;1s&gt;'									expandMacrosWith: anITypeLib getDocumentationName));				openOn: dispatchInterfaceMap keys asSortedCollection asArray.	selectedName isNil		ifTrue: 			[" user cancelled "			^nil].	" return the selected interface type info's "	^ dispatchInterfaceMap at: selectedName.</body><body package="Com- Automation Development">typeLibraryDispatchInterfaceMap: anITypeLib		" Answer the ITypeInfo interfaces of the dispatch interfaces		defined in the type library &lt;anITypeLib&gt;. "	| dispatchInterfaces |	dispatchInterfaces := Dictionary new.	( anITypeLib select: [ :anITypeInfo |		anITypeInfo typekind = TKIND_DISPATCH ] )			do: [ :anITypeInfo | 				dispatchInterfaces at: anITypeInfo getDocumentationName					put: anITypeInfo ].	^dispatchInterfaces</body><body package="Com- Automation Development">typeLibraryDispatchInterfaces: anITypeLib		" Answer the ITypeInfo interfaces of the dispatch interfaces		defined in the type library &lt;anITypeLib&gt;. "	^anITypeLib select: [ :anITypeInfo | anITypeInfo isDispatch ]</body><body package="Com- Automation Development">typeLibraryDispatchInterfacesFromUser: anITypeLib	" Answer the dispatch interface type info interfaces defined in the type library &lt;anITypeLib&gt;		selected by the user from the list of all dispatch interfaces. "	| dispatchInterfaceMap selectedNames selectedInterfaces |	dispatchInterfaceMap := self typeLibraryDispatchInterfaceMap: anITypeLib.	selectedNames := dispatchInterfaceMap keys asSortedCollection asArray.	selectedNames := (MultiSelectListDialog new)				title: #SelectDispatchInterfaces &lt;&lt; #com &gt;&gt; 'Select Dispatch Interfaces';				textLines: (Array							with: (#DispInterfacesInTypeLib &lt;&lt; #com &gt;&gt; 'Dispatch interfaces in type library &lt;1s&gt;'									expandMacrosWith: anITypeLib getDocumentationName)							with: #SelectOneOrMoreInt &lt;&lt; #com &gt;&gt; 'Select one or more interfaces:');				openOn: selectedNames selection: selectedNames.	selectedNames isNil		ifTrue: 			[" user cancelled "			^nil].	" return the selected interface type info's"	selectedInterfaces := OrderedCollection new.	selectedNames		do: [:anInterfaceName | selectedInterfaces add: (dispatchInterfaceMap at: anInterfaceName)].	^selectedInterfaces</body><body package="Com- Automation Development">typeLibraryEnumerations: anITypeLib		" Answer the ITypeInfo interfaces of the enumerations		defined in the type library &lt;anITypeLib&gt;. "	^anITypeLib select: [ :anITypeInfo |		anITypeInfo typekind = TKIND_ENUM ]</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>constants and dictionary statics</category><body package="Com- Automation Development">addDictionaries: names typeLibrary: aCOMTypeLibrary promptUser: promptUser forClass: aClass	"Add to aClass a new IdentityDictionary static for each enumeration constants defined in the type library &lt;aCOMTypeLibrary&gt;. Each dictionary name in &lt;names&gt; is the concatenation of the library name and an enumeration name. If &lt;promptUser&gt; is true and an entry already exists as a static in aClass for a given identity dictionary name, ask the user if he or she wants to overwrite the entry. If &lt;promptUser&gt; is false, the identity dictionary is always added to aClass. NOTE:  pre 5i we used to use PoolDictionary -- now we use a static and imports"	| dictionaries |	names isNil ifTrue: [ ^nil ].	dictionaries := self makeDictionaries: names typeLibrary: aCOMTypeLibrary.	names do: [ : newStaticName |		| addPool theStatic|		addPool := true.		( promptUser and: [ aClass asNameSpace includesKey: newStaticName asSymbol ] )			ifTrue: [ addPool := MessageBox confirm: ((#DictionaryAsStaticExists &lt;&lt; #com &gt;&gt; 'The Dictionary &lt;1s&gt; already exists as a Shared Variable in &lt;1s&gt;. Do you want to update this entry?') expandMacrosWith: newStaticName with: aClass shortName).					 theStatic := aClass asNameSpace bindingFor: newStaticName asSymbol].		addPool ifTrue: [			| newGuy |			theStatic isNil 				ifTrue: 					["Create the static on the class and initialize it"					theStatic := aClass asNameSpace						defineStatic: newStaticName asSymbol 						private: true 						constant: false 						category: NameSpaceOrganizer  defaultProtocol 						initializer: 'Core.IdentityDictionary new'.					theStatic initialize].					theStatic value isNil ifTrue: 				["For some reason this fella's value is nil force it to be a new IdentityDictionary"				theStatic value: IdentityDictionary new].			"*** Do not throw away the old reference, just update it. ***"			newGuy := dictionaries at: newStaticName.			theStatic value keys do: [ : k | 				( newGuy includesKey: k ) 					ifFalse: [ theStatic value removeKey: k ] ].			theStatic value addAll: newGuy associations ]	].	^dictionaries</body><body package="Com- Automation Development">defineDictionaries: aCOMTypeLibrary promptUser: promptUser	"Add to the image an IdentityDictionary as a static for each enumeration constants defined in the type library &lt;aCOMTypeLibrary&gt;. Each dictionary name is the concatenation of the library name and an enumeration name. If &lt;promptUser&gt; is true and an entry already exists in the Smalltalk dictionary for a given pool dictionary name, ask the user if he or she wants to overwrite the entry. If &lt;promptUser&gt; is false, the pool dictionary is always added to Smalltalk."	| names theTarget |	names := self getDictionaryNames: aCOMTypeLibrary.	(MessageBox confirm: #MustDecideClass &lt;&lt; #com &gt;&gt;'You must first decide what class will own any new Dictionaries that are created.')		ifFalse: [^ MessageBox warning: #OperationAbortedCreation &lt;&lt; #com &gt;&gt; 'Operation Aborted.  No owner given for new Dictionaries that might be created.'].	(theTarget := self targetClass) isNil		ifTrue: [^ MessageBox warning: #OperationAbortedCreation &lt;&lt; #com &gt;&gt; 'Operation Aborted.  No owner given for new Dictionaries that might be created.' ].	^self addDictionaries: names 		typeLibrary: aCOMTypeLibrary 		promptUser: promptUser		forClass: theTarget</body><body package="Com- Automation Development">describeTypeLibraryConstants: aCOMTypeLibrary	"Describe all the enumeration constants defined in the type library &lt;aCOMTypeLibrary&gt;."	| typeLibName aStream anITypeLib |	anITypeLib := aCOMTypeLibrary asInterfaceReference.	typeLibName := anITypeLib getDocumentationName.	aStream := ReadWriteStream on: String new.	aStream		nextPutAll: (#TypeLibEnumHeading &lt;&lt; #com &gt;&gt; '" Type Library &lt;1s&gt; Enumeration Constants "'					expandMacrosWith: typeLibName);		cr;		cr.	(self typeLibraryEnumerations: anITypeLib) do: 			[:anITypeInfo |			(self new)				stream: aStream;				describeEnumerationConstants: anITypeInfo].	TextWindow openOn: aStream contents		label: (#TypeLibEnumConstants &lt;&lt; #com &gt;&gt; '&lt;1s&gt; Enumeration Constants'				expandMacrosWith: typeLibName)</body><body package="Com- Automation Development">getDictionaryNames: aCOMTypeLibrary	"Answer an Array of Strings for the names that is to be used as Indentity Dictionaries for each enumeration constants defined in the type library &lt;aCOMTypeLibrary&gt;. A pool name is the library Name concatenated with a constant enumeration name. This method is used with #makeDictionaries:typeLibrary:  NOTE:  pre 5i we used to use PoolDictionary -- now we use a static and imports"	| anITypeLib names libraryName |	names := OrderedCollection new.	anITypeLib := aCOMTypeLibrary typeLib.	libraryName := anITypeLib getDocumentationName.	(self typeLibraryEnumerations: anITypeLib)		do: [:anITypeInfo | names add: libraryName , anITypeInfo getDocumentationName].	^names</body><body package="Com- Automation Development">makeDictionaries: aCOMTypeLibrary	"Make an IdentityDictionary for each enumeration constants defined in the type library &lt;aCOMTypeLibrary&gt;. Answer a dictionary where each key is the concatenation of the library name and an enumeration name and each value is an IdentityDictionary.  Note: pre 5.i we used to use PoolDictionaries, now we use a static and imports on classes"	| names |	names := self getDictionaryNames: aCOMTypeLibrary.	^self makeDictionaries: names typeLibrary: aCOMTypeLibrary.</body><body package="Com- Automation Development">makeDictionaries: names typeLibrary: aCOMTypeLibrary	"Make an IdentityDictionary for each enumeration constants defined in the type library &lt;aCOMTypeLibrary&gt;. Answer a dictionary where each key is the concatenation of the library name and an enumeration name and each value is a IdentityDictionary. The &lt;names&gt; argument is generated by #getPoolDictionaryNames: and specifies which pools to generate.  NOTE:  pre 5i we used to use PoolDictionary -- now we use a static and imports"	| anITypeLib answer key value libraryName |	answer := Dictionary new.	anITypeLib := aCOMTypeLibrary typeLib.	libraryName := anITypeLib getDocumentationName.	(self typeLibraryEnumerations: anITypeLib) do: 			[:anITypeInfo |			key := libraryName , anITypeInfo getDocumentationName.			(names includes: key)				ifTrue: 					[value := self getEnumerationConstants: anITypeInfo putIn: IdentityDictionary new.					answer at: key put: value]].	^answer</body><body package="Com- Automation Development">promptAndDefineDictionaries: aCOMTypeLibrary 	"Show the user a multiple selection list box for all of the pool dictionary names that can be made from the library &lt;aCOMTypeLibrary&gt;. Each pool dictionary name is the concatenation of the library name and an enumeration name. The user then chooses which Pool Dictionaries to generate. Add to the target a static that is a IdentityDictionary for each enumeration constants the user asked. If an entry already exists in theTarget as a static of the given identity dictionary name, ask the user if he or she wants to overwrite the entry."	| theTarget listChoices choices |	choices := self getDictionaryNames: aCOMTypeLibrary.	(MessageBox confirm: #MustDecideClass &lt;&lt; #com 				&gt;&gt; 'You must first decide what class will own any new Dictionaries that are created.') 		ifFalse: 			[^MessageBox warning: #OperationAbortedCreation &lt;&lt; #com 						&gt;&gt; 'Operation Aborted.  No owner given for new Dictionaries that might be created.'].	(theTarget := self targetClass) isNil 		ifTrue: 			[^MessageBox warning: #OperationAbortedCreation &lt;&lt; #com 						&gt;&gt; 'Operation Aborted.  No owner given for new Dictionaries that might be created.'].	listChoices := (MultiSelectListDialog new)				title: #AddDictionaries &lt;&lt; #com &gt;&gt; 'Add Dictionaries';				textLines: (#AddDictionariesQuery &lt;&lt; #com 							&gt;&gt; 'Add the following Dictionaries to &lt;1s&gt; as a Shared Variable?' 								expandMacrosWith: theTarget shortName);				initialSelection: choices;				openOn: choices.	^self 		addDictionaries: listChoices		typeLibrary: aCOMTypeLibrary		promptUser: true		forClass: theTarget</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>instance creation</category><body package="Com- Automation Development">new	" Answer a new instance of the receiver. "	^super new initialize</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>private-user feedback</category><body package="Com- Automation Development">noDispatchInterfacedIn: aSource	"If feedback is on, display a message box telling the user that no dispatch interfaces where found."	self displayFeedback ifFalse: [ ^self ].	MessageBox message: ((#NoDispInterfacesIn &lt;&lt; #com &gt;&gt;'There are no dispatch interfaces in &lt;n&gt;&lt;1p&gt;.') expandMacrosWith: aSource)</body><body package="Com- Automation Development">noID: aSource	"If feedback is on, display a message box telling the user that no dispatch interfaces where found."	self displayFeedback ifFalse: [ ^self ].	MessageBox message:((#NotACLSID &lt;&lt; #com &gt;&gt; 'The ID &lt;1p&gt; does not correspond to a CLSID.') expandMacrosWith: aSource)</body><body package="Com- Automation Development">noInterfaceFound: aName in: aSource	"If feedback is on, display a message box telling the user that the interface named &lt;aName&gt; was not found."	self displayFeedback ifFalse: [ ^self ].	MessageBox message:((#InterfaceNotFoundIn &lt;&lt; #com &gt;&gt; 'The interface named &lt;1s&gt;  was not found in &lt;n&gt;&lt;2p&gt;.') expandMacrosWith: aName with: aSource)</body><body package="Com- Automation Development">noTypeInfo: aSource	"If feedback is on, display a message box telling the user that no type information."	self displayFeedback ifFalse: [ ^self ].	MessageBox message:((#NoTypeInfo &lt;&lt; #com &gt;&gt; 'The ID &lt;1s&gt; does not have any type information.') expandMacrosWith: aSource asString)</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>private-generation</category><body package="Com- Automation Development">generateTypeLibrarySpecifications: anITypeLib dispatchInterfaces: dispatchInterfaces forRole: aSymbol		" Generate the literal specifications for the dispatch interfaces whose		type info interfaces are contained in &lt;dispatchInterfaces&gt; which are		defined in the type library &lt;anITypeLib&gt;. "	| typeLibName aStream nInterfaces index "progressDialog"	  dispatchInterfaceName |	( self checkRole: aSymbol ) ifFalse: [ ^self ].	typeLibName := anITypeLib getDocumentationName.	aStream := ReadWriteStream on: String new.	aStream 		nextPutAll: self indent, ((#TypeLibNamedDisp &lt;&lt; #com &gt;&gt; '" Type Library &lt;1s&gt; Dispatch Interfaces "') expandMacrosWith: typeLibName)  ; cr; 		nextPutAll: self indent, '" ', self generationInfo, ' "'; cr;		nextPutAll: self indent, (#QuoteFrom &lt;&lt; #com &gt;&gt; '" From ') asString, self systemInfo, ' "'; cr;		cr.	nInterfaces := dispatchInterfaces size.	nInterfaces = 0		ifTrue: [ aStream nextPutAll: self indent, (#NoDispIntInTypeLib &lt;&lt; #com &gt;&gt; 'No dispatch interfaces in this type library.') asString ].	index := 0.	Tools.Note temporarilyDisabled.  " Don't know if VW has a facility		equivalent to the Win32 progress indicator dialog.		Disable UI niceness for now.  [DL 24-Mar-96] "	"TEMP DISABLE:	progressDialog := ProgressIndicatorDialog new        backColor: Color dialogBackground;		open: 'Generating Type Library Specifications'			message: ''.	[	"	dispatchInterfaces do: [ :anITypeInfo |		dispatchInterfaceName := anITypeInfo getDocumentationName.		"TEMP DISABLE:		progressDialog 			percent:  ( index / nInterfaces * 100 ) truncated;			message: 'Interface ', dispatchInterfaceName, '...'.		"		self new			stream: aStream;			role: aSymbol;			generateTypeInfoSpecifications: anITypeInfo.		index := index + 1.		aStream cr.		"TEMP DISABLE:		progressDialog canceled			ifTrue: [				""aStream cr; nextPutAll: 'Generation canceled by user request.'.""			^self ].		"		].	"TEMP DISABLE:	] ensure: [		progressDialog close ].	"	TextWindow openOn: aStream contents		label: #ITypeLibSpecs &lt;&lt; #com &gt;&gt; 'ITypeLib Specifications'.</body></methods><methods><class-id>External.COMAutomationTypeAnalyzer class</class-id> <category>class initialization</category><body package="Com- Automation Development">initialize	self displayFeedback: true</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage</class-id> <category>accessing</category><body package="Com- Automation Development">fullPath	"Answer the Filename for the library path."	^manager domain libraryDirectory value asFilename</body><body package="Com- Automation Development">helpText	^#wizardRegFilePageHelp &lt;&lt; #com &gt;&gt; 'This page will create and register the registration file with the Windows operating system.For Class: The class for which you are generating the registration file.Reg. File: The name of the registration file (must end with .reg).Description: Short text to identify the purpose of the COM interface to users.ProgID: Program ID (PROGID) string identifying the application in the registry.Version: Defaults to 1.0 (supply a different version if you prefer).LocalServer:  Use the buttons beside the entry fields to optionally select the server path for 	Engine:	The VisualWorks object engine file path (i.e. for visual.exe or vwnt.exe).	Image:	The COM server image pathAutomation Switch: Check this if you want the server image to start up with the \AUTOMATION flag.ActiveX Control: Check this if you want the server image to start up with the \PROGRAMMABLE flag.There are three buttons:Self Registration: Will create a class method enabling the image to register/unregister the object with the Windows registry.  When enabled, use the command line option -RegServer &lt;class&gt; to register &lt;class&gt; and -UnRegServer &lt;class&gt; to unregister &lt;class&gt;.Generate File: Will generate the file that you can use to register the object in the Windows registry.Register: Will merge the .reg file with the Windows registry and register the object.'</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage</class-id> <category>aspects</category><body package="Com- Automation Development">className	^className isNil		ifTrue: [className := nil asValue]		ifFalse: [className]</body><body package="Com- Automation Development">classRegistrationHolder	^classRegistrationHolder ifNil: [classRegistrationHolder := self currentClassRegistration asValue]</body><body package="Com- Automation Development">creator	^manager domain creator</body><body package="Com- Automation Development">libraryFile	^manager domain libraryFile</body><body package="Com- Automation Development">localServerEngine	^manager domain localServerEngine</body><body package="Com- Automation Development">localServerImage	^manager domain localServerImage</body><body package="Com- Automation Development">regFileName	^manager domain regFileName</body><body package="Com- Automation Development">targetClassList	^manager domain targetClassList</body><body package="Com- Automation Development">typeLibraryID	^manager domain typeLibraryID</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage</class-id> <category>private</category><body package="Com- Automation Development">classToString: aClass	^aClass unambiguousName</body><body package="Com- Automation Development">currentClassRegistration	^ComAutomationWizardRegConf domain: manager domain class: self className value</body><body package="Com- Automation Development">okayToChangeClass	^self className value notNil</body><body package="Com- Automation Development">regConfigurations	^self targetClassList value collect: [:each | ComAutomationWizardRegConf domain: manager domain class: each]</body><body package="Com- Automation Development">stringToClass: aString	^(BindingReference pathString: aString) value</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage</class-id> <category>interface opening</category><body package="Com- Automation Development">preBuildWith: aBuilder 	| targetClasses |	super preBuildWith: aBuilder.	self className value ifNil: 			[(targetClasses := self targetClassList value) notEmpty 				ifTrue: [self className value: targetClasses first]]</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage</class-id> <category>actions</category><body package="Com- Automation Development">generateClassSpec	"Generate registration specification methods inside selected COM classes to enable self registration of the server"	self okayToChangeClass ifFalse: [^self].	self regConfigurations do: 			[:conf | 			self 				generateClassMethod: #comRegistrationSpec				do: 					[:stream | 					(COMAutomationRegistration new)						versionIndependentProgID: conf progID;						versionIndependentDescription: conf objectDescription;						version: conf versionNumber;						activeXOn: conf activeXOn;						automationOption: conf automationOn;						installOn: stream]				protocol: #registration				forClass: conf interfaceClass]</body><body package="Com- Automation Development">generateFile	| fname fStream |	"save the configuration of the last class"	self okayToChangeClass ifFalse:[^self].	fname := self fullPath \ self regFileName value.	fStream := fname writeStream.	[self regHeaderOn: fStream.	self regConfigurations 		do: [:conf| 				(COMAutomationRegistration new)						enginePath: self localServerEngine value;						imagePath:  self localServerImage value;						versionIndependentProgID: conf progID;						versionIndependentDescription: conf objectDescription;						clsid: conf interfaceClass clsid;						version: conf versionNumber;						typeLibraries: conf interfaceClass typeLibraries;						activeXOn: conf activeXOn;						automationOption: conf automationOn;						storeRegistrationOn: fStream].	fStream nextPutAll: '; eof'; cr]		ensure: [fStream close].	fname edit</body><body package="Com- Automation Development">register	"If you want to debug this use /k instead of /c to get the command shell to stay open"	| debug cmdOptions command |	debug := ComAutomationWizard debugBatchFiles.	cmdOptions := debug ifTrue: ['/K'] ifFalse: ['/c'].	command := 'cmd &lt;1s&gt; cd "&lt;2s&gt;" &amp; &lt;3s&gt;'				expandMacrosWith: cmdOptions				with: self fullPath asString				with: self regFileName value.	debug		ifTrue: 			[Transcript				show: (#TryingToExecuteColon &lt;&lt; #com &gt;&gt; 'Trying to execute: &lt;1p&gt;' 							expandMacrosWith: command);				cr].	OSSystemSupport concreteClass CreateProcess: nil arguments: command</body><body package="Com- Automation Development">setLocalEngine	| pathString |	(pathString := Dialog requestFileName: #LocalServerEnginePath &lt;&lt; #com 						&gt;&gt; 'Local Server Engine Path') 		notEmpty 			ifTrue: 				[(self localServerEngine)					value: pathString;					changed]</body><body package="Com- Automation Development">setLocalImage	| pathString |	(pathString := Dialog 				requestFileName: #LocalServerImagePath &lt;&lt; #com &gt;&gt; 'Local Server Image Path') 			notEmpty 			ifTrue: 				[(self localServerImage)					value: pathString;					changed]</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage</class-id> <category>private-generations</category><body package="Com- Automation Development">regHeaderOn: fStream 	fStream		nextPutAll: 'REGEDIT';		cr;		cr.	fStream		nextPutAll: '/***********************************************************************';		cr.	fStream		nextPutAll: '/*';		cr.	fStream		nextPutAll: '/*';		cr.	fStream		nextPutAll: '/* Summary of GUIDs:';		cr.	self targetClassList value do: 			[:cl | 			fStream				nextPutAll: '/*';				cr.			fStream				nextPutAll: '/*  ' , cl name;				cr.			fStream				nextPutAll: '/*  CLSID:';				tab;				nextPutAll: cl clsid asString;				cr].	fStream		nextPutAll: '/* Type Library: ' , self libraryFile value , '.tlb';		tab;		nextPutAll: self typeLibraryID asString;		cr.	fStream		nextPutAll: '/*';		cr.	fStream		nextPutAll: '/*  Created by ' , self creator value;		cr.	fStream		nextPutAll: '/*';		cr.	fStream		nextPutAll: '/***********************************************************************';		cr;		cr</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage</class-id> <category>notifications</category><body package="Com- Automation Development">selectRegistrationGroup	self classRegistrationHolder value: self currentClassRegistration.</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage class</class-id> <category>resources</category><body package="Com- Automation Development">fileOpen	^ToolbarIconLibrary visualFor: #fileOpen</body></methods><methods><class-id>Tools.ComAutomationWizardSettings</class-id> <category>accessing</category><body package="Com- Automation Development">bitsForStubCode	^self settingWithId: #(idlGen bitsForStubCode)</body><body package="Com- Automation Development">classList	^(self settingWithId: #(classSelect classList)) target model</body><body package="Com- Automation Development">classListSelection	^(self settingWithId: #(#classSelect #classListSelection)) target</body><body package="Com- Automation Development">company	^self settingWithId: #(idlGen company)</body><body package="Com- Automation Development">creator	^self settingWithId: #(idlGen creator)</body><body package="Com- Automation Development">deployImagePath	^self settingWithId: #(deploy deployImagePath)</body><body package="Com- Automation Development">domainRoot	^self</body><body package="Com- Automation Development">externalName	^self settingWithId: #(guidGen externalName)</body><body package="Com- Automation Development">interfaceDescription	^self settingWithId: #(guidGen interfaceDescription)</body><body package="Com- Automation Development">libraryDirectory	^self settingWithId: #(#idlGen #libraryDirectory)</body><body package="Com- Automation Development">libraryFile	^self settingWithId: #(idlGen libraryFile)</body><body package="Com- Automation Development">libraryName	^self settingWithId: #(idlGen libraryName)</body><body package="Com- Automation Development">localServerEngine	^self settingWithId: #(regFile localServerEngine)</body><body package="Com- Automation Development">localServerImage	^self settingWithId: #(regFile localServerImage)</body><body package="Com- Automation Development">objectClassList	^objectClassList isNil 		ifTrue: 			[objectClassList := (MultiSelectionInList new)						listHolder: self classList;						selectionIndexHolder: self classListSelection]		ifFalse: [objectClassList]</body><body package="Com- Automation Development">regConfigurations	^self settingWithId: #(#regFile #regConfiguration)</body><body package="Com- Automation Development">regFileName	^self settingWithId: #(regFile regFileName)</body><body package="Com- Automation Development">regFileSettingGroupFor: aClass 	^aClass ifNil: [ComAutomationWizardRegFileSettings classGroup]		ifNotNil: 			[| settingGroup settingKey |			settingKey := aClass unambiguousName asSymbol.			settingGroup := self settingWithId: #(#regFile #regGroup).			settingGroup settingNamed: settingKey				ifAbsent: 					[ComAutomationWizardRegFileSettings addGroupTo: settingGroup						named: settingKey]]</body><body package="Com- Automation Development">settings	^cachedSettings ifNil:[cachedSettings := self class collectSettings]</body><body package="Com- Automation Development">targetClassList	^self objectClassList selectionHolder</body><body package="Com- Automation Development">typeLibraryClass	^typeLibraryClass isNil		ifTrue: [typeLibraryClass := nil asValue]		ifFalse: [typeLibraryClass]</body><body package="Com- Automation Development">typeLibraryID	^self typeLibraryClass value typeLibraryID</body><body package="Com- Automation Development">version	^self settingWithId: #(idlGen version)</body><body package="Com- Automation Development">whereIsTypeLibrary	^self settingWithId: #(guidGen whereIsTypeLibrary)</body><body package="Com- Automation Development">withSettingsCachedDo: aBlock	self settings.		aBlock value</body></methods><methods><class-id>Tools.ComAutomationWizardSettings</class-id> <category>reading/writing</category><body package="Com- Automation Development">readFrom: aStream 	| group |	group := self settingWithId: #(#regFile #regGroup).	group preApplyBlock: 			[self objectClassList selections do: 					[:each | 					ComAutomationWizardRegFileSettings addGroupTo: group						named: each unambiguousName]].	super readFrom: aStream</body></methods><methods><class-id>Tools.ComAutomationWizardSettings</class-id> <category>initialize-release</category><body package="Com- Automation Development">release	super release.	cachedSettings := nil.</body></methods><methods><class-id>Tools.ComAutomationWizardSettings class</class-id> <category>accessing</category><body package="Com- Automation Development">current		current := nil.	^self new</body></methods><methods><class-id>Tools.ComAutomationWizardSettings class</class-id> <category>private</category><body package="Com- Automation Development">classToStringAdaptor	^(PluggableAdaptor on: List new asValue) 		getBlock: [:m | m value collect: [:each | each unambiguousName]]		putBlock: 			[:m :v | 			| list |			list := List new.			v do: 					[:each | 					(BindingReference pathString: each) 						ifDefinedDo: [:value | list add: value]						elseDo: 							[Transcript								show: (#warnClassMissing &lt;&lt; #com 											&gt;&gt; 'Warning: &lt;1s&gt; class missing from image' expandMacrosWith: each);								cr]].			m value: list]		updateBlock: [:m :a :p | true]</body></methods><methods><class-id>Tools.IDLClassDefinition</class-id> <category>accessing</category><body package="Com- Automation Development">classDescription	| str |	str := comClass interfaceName.	^str copyFrom: 2 to: str size</body><body package="Com- Automation Development">classID	^comClass clsid asString</body><body package="Com- Automation Development">comClassName	^comClass name</body><body package="Com- Automation Development">externalName	^externalName</body><body package="Com- Automation Development">externalName: aString 	externalName := aString</body><body package="Com- Automation Development">interfaceDescription	^comClass interfaceName</body><body package="Com- Automation Development">interfaceID	| str |	str := comClass iidInterfaceDisp asString.	^str copyFrom: 2 to: str size - 1</body><body package="Com- Automation Development">methodDefinitionOfName: aString 	^methodsDefinitions definitions detect: [:mDef | mDef methodName asString = aString]		ifNone: [nil]</body><body package="Com- Automation Development">methodsDefinitions: aIDLMethodsDefinition 	methodsDefinitions := aIDLMethodsDefinition</body><body package="Com- Automation Development">oleInterfaceID	| str |	str := comClass iidVtableInterface asString.	^str copyFrom: 2 to: str size - 1</body><body package="Com- Automation Development">propertiesDefinitions: aIDLPropertiesDefinition 	propertiesDefinitions := aIDLPropertiesDefinition</body><body package="Com- Automation Development">propertyDefinitionsOfName: aString 	^propertiesDefinitions definitions select: [:mDef | mDef methodName asString = aString]</body><body package="Com- Automation Development">typeLibraryID	^comClass typeLibraryID</body><body package="Com- Automation Development">typelibraryIDString	| str |	str := self typeLibraryID asString.	^str copyFrom: 2 to: str size</body></methods><methods><class-id>Tools.IDLClassDefinition</class-id> <category>printing</category><body package="Com- Automation Development">declarationBodyOn: aStream 	aStream nextPut: ${; cr.	propertiesDefinitions printOn: aStream.	methodsDefinitions printOn: aStream.	aStream nextPutAll: '};'; cr</body><body package="Com- Automation Development">dispatchInterfaceMapOn: aStream 	aStream cr; nextPutAll: '//'; cr.	aStream nextPutAll: (#VWMapComment &lt;&lt; #com &gt;&gt; '// Map the interface to VW dispatch') asString; cr.	aStream nextPutAll: '//'; cr.	aStream nextPutAll: '[uuid(' , self interfaceID.	aStream nextPutAll: ')] dispinterface ' , self interfaceDescription , 'Disp'; cr.	aStream nextPut: ${; cr.	aStream tab; nextPutAll: 'interface ' , self interfaceDescription.	aStream nextPut: $;; cr.	aStream nextPutAll: '};'; cr</body><body package="Com- Automation Development">headerOn: aStream 	aStream nextPutAll: '//'; cr.	aStream nextPutAll: ((#CreateInterfaceComment &lt;&lt; #com &gt;&gt; '// Create an interface called &lt;1s&gt;')			expandMacrosWith: self interfaceDescription); cr.	aStream nextPutAll: '//'; cr</body><body package="Com- Automation Development">interfaceHeaderOn: aStream 	aStream nextPutAll: '[object,uuid('.	aStream nextPutAll: self oleInterfaceID.	aStream nextPutAll: '),oleautomation] interface '.	aStream nextPutAll: self interfaceDescription.	aStream nextPutAll: ' : IDispatch'; cr</body><body package="Com- Automation Development">printOn: aStream 	self headerOn: aStream.	self interfaceHeaderOn: aStream.	self declarationBodyOn: aStream.	self dispatchInterfaceMapOn: aStream</body></methods><methods><class-id>Tools.IDLClassDefinition</class-id> <category>initialize-release</category><body package="Com- Automation Development">on: aClass 	comClass := aClass</body></methods><methods><class-id>Tools.IDLClassDefinition class</class-id> <category>instance creation</category><body package="Com- Automation Development">onClass: aComClass 	^self new on: aComClass</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage</class-id> <category>interface opening</category><body package="Com- Automation Development">postBuildWith: aBuilder 	| targetClasses |	super postBuildWith: aBuilder.	self comClassList selectAll.	self typeLibraryClass value ifNil: 			[(targetClasses := self targetClassList value) notEmpty 				ifTrue: [self typeLibraryClass value: targetClasses first]]</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage</class-id> <category>private</category><body package="Com- Automation Development">canBrowse: anObject	^ anObject isKindOf: IDLMethodDefinition</body><body package="Com- Automation Development">classToString: aClass	^aClass unambiguousName</body><body package="Com- Automation Development">compileMethodSpecificationsLiteral: aCOMDispatchSpecificationTable for: aClass 	| protocol method stream classDef |	protocol := #'private-specifications'.	method := #methodSpecificationsLiteral.	classDef := self definitionForClass: aClass.	stream := String new writeStream.	stream nextPutAll: method; cr.	stream tab; nextPutAll: '^#('; cr.	aCOMDispatchSpecificationTable values		do: 			[:methodSpec | 			| methodDef |			methodDef := classDef methodDefinitionOfName: methodSpec name.			methodSpec selector: methodDef stSelector.			stream tab; tab; nextPutAll: methodSpec literalArrayEncoding printString.			stream cr].	stream tab; nextPutAll: ')'.	aClass class compile: stream contents classified: protocol</body><body package="Com- Automation Development">compilePropertySpecificationsLiteral: aCOMDispatchSpecificationTable for: aClass	| protocol method stream classDef |	protocol := #'private-specifications'.	method := #propertySpecificationsLiteral.	classDef := self definitionForClass: aClass.	stream := String new writeStream.	stream		nextPutAll: method;		cr.	stream		tab;		nextPutAll: '^#(';		cr.	aCOMDispatchSpecificationTable values do: 			[:methodSpec |			(classDef propertyDefinitionsOfName: methodSpec name) do: 					[:methodDef |					methodDef isSetProperty						ifTrue: [methodSpec setSpecification selector: methodDef stSelector]						ifFalse: [methodSpec getSpecification selector: methodDef stSelector]].			stream				tab;				tab;				nextPutAll: methodSpec literalArrayEncoding printString.			stream cr].	stream		tab;		nextPutAll: ')'.	aClass class compile: stream contents classified: protocol</body><body package="Com- Automation Development">createLibraryDirectory: aFilename 	^(MessageBox confirm: #COMLibDirCreate &lt;&lt; #com 				&gt;&gt; 'Library directory does not exist. Should it be created?') 		ifTrue: [self privateCreateLibDir: aFilename]		ifFalse: [false]</body><body package="Com- Automation Development">definitionForClass: aClass 	^libraryDefinition ifNotNil: [libraryDefinition definitionOfClass: aClass]</body><body package="Com- Automation Development">generate64BitStubCode	^self bitsForStubCode value = #'64Bit'</body><body package="Com- Automation Development">generateClassMethod: methodName text: methodText protocol: theProtocol forClass: aClass	| strm theClass methodComment |	aClass notNil ifTrue: [theClass := aClass class] ifFalse: [^nil].	(theClass findSelector: methodName) notNil		ifTrue: 			[self class warnNotGenerating: methodName inClass: theClass.			^nil].	strm := String new writeStream.	methodComment := (#MethodWarnAutoGen &lt;&lt; #com				&gt;&gt; '"This method was generated by COM Automation Tool. Do not change unless you know what you are doing."')					asString.	"now do the code"	strm		nextPutAll: methodName;		cr.	strm		tab;		nextPutAll: methodComment;		cr;		cr.	strm		tab;		nextPutAll: methodText.	theClass compile: strm contents classified: theProtocol</body><body package="Com- Automation Development">handleLibraryGenerationError: anException	| result labels values |	labels := Array with: #Ok &lt;&lt; #com &gt;&gt; 'Ok'.	values := #(#ok).	(self canBrowse: anException parameter)		ifTrue: 			[labels := labels copyWith: #Browse &lt;&lt; #com &gt;&gt; 'Browse'.			values := values copyWith: #browse].	result := Dialog				choose: anException description				labels: labels				values: values				default: #browse				for: nil.	result = #ok ifTrue: [^self].	anException parameter browseDefiningMethod: (self comClassList selections)</body><body package="Com- Automation Development">nameForLCID: anLCID	"self new nameForLCID: 1024"	"self new nameForLCID: 0"	| locale |	anLCID = 0 ifTrue: [^'Neutral'].	locale := WindowsLocale withID: anLCID.	^locale englishLanguageName capitalized		, locale englishCountryName capitalized</body><body package="Com- Automation Development">newTypeLibraryMethodName	^'newTypeLibrary' , (self nameForLCID: self lcid)</body><body package="Com- Automation Development">privateCreateLibDir: aFilename 	| parentDirectory |	aFilename definitelyExists 		ifTrue: [^true]		ifFalse: 			[parentDirectory := aFilename directory.			parentDirectory = aFilename ifTrue: [^false].			(self privateCreateLibDir: parentDirectory) ifFalse: [^false].			aFilename makeDirectory.			aFilename definitelyExists ifTrue: [^true] ifFalse: [^false]]</body><body package="Com- Automation Development">selectedClasses	^self comClassList selections</body><body package="Com- Automation Development">stringToClass: aString	^(BindingReference pathString: aString) value</body><body package="Com- Automation Development">textForNewTypleLibrary	| aStream v i majorVersion minorVersion |	aStream := String new writeStream.	aStream nextPutAll: (#TypeLibraryMethodComment &lt;&lt; #com &gt;&gt; '"answer a type library for the selected language for the application."	"the type library ID is its GUID.  the type library file is the output from the MIDL compiler and must already exist."	"note.  the absolute directory name must be set so that the TypeLibrary directory can be found."') asString.	aStream cr; cr.	aStream nextPutAll: ('	%&lt;typeLibrary%&gt;		^COMTypeLibrary new		libraryID: self typeLibraryID;		lcid: 16r&lt;1s&gt;;		directoryName: ' expandMacrosWith:  (self lcid printStringRadix: 16)).	aStream nextPutAll: self libraryDirectory value printString, ';'; cr.	aStream nextPutAll: 'fileName: '.	aStream nextPutAll: (self libraryFile value, '.tlb') printString, ';'; cr.	v := self version value.	i := v findString: '.' startingAt: 1.	i = 0 		ifTrue: [majorVersion := v. minorVersion := '0']		ifFalse: [majorVersion := v copyFrom: 1 to: i-1. 					minorVersion := v copyFrom: i+1 to: v size].	aStream tab; tab; nextPutAll: 'majorVersion: ', majorVersion, ';'; cr.	aStream tab; tab; nextPutAll: 'minorVersion: ', minorVersion; cr.	^aStream contents</body><body package="Com- Automation Development">typeDescriptionFor: aClass	| methodDefs propDefs classDef |	methodDefs := IDLMethodsDefinition new.	propDefs := IDLPropertiesDefinition new.	ComAutomationWizardGUIDGenPage pragmas do: 			[:selector |			(Pragma allNamed: selector from: aClass to: Object) do: 					[:pragma |					| def container |					def := IDLMethodDefinition perform: pragma keyword								withArguments: pragma arguments.					def stSelector: pragma selector.					container := def isMethodDef ifTrue: [methodDefs] ifFalse: [propDefs].					(container includesSameDefinitionAs: def)						ifTrue: 							["superclasses may not overwrite what subclasses define"							| msg |							msg := #DefinitionOverriddenInSubclass &lt;&lt; #com										&gt;&gt; '&lt;1s&gt;  "&lt;2s&gt;" is overridden in a subclass. Please check if this is intended&lt;n&gt;'											expandMacrosWith: def class name											with: def methodName.							Transcript show: msg]						ifFalse: [container add: def]]].	classDef := IDLClassDefinition onClass: aClass.	classDef		methodsDefinitions: methodDefs;		propertiesDefinitions: propDefs;		externalName: aClass externalName.	^classDef</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage</class-id> <category>aspects</category><body package="Com- Automation Development">bitsForStubChoices	| items |	items := manager domain bitsForStubCode type choices.	^Menu labelArray: items values: items</body><body package="Com- Automation Development">bitsForStubCode	^bitsForStubCode		ifNil: 			[bitsForStubCode := (AspectAdaptor subject: manager domain bitsForStubCode)						forAspect: #value]</body><body package="Com- Automation Development">comClassList	^comClassList isNil 		ifTrue: 			[comClassList := MultiSelectionInList new listHolder: self targetClassList]		ifFalse: [comClassList]</body><body package="Com- Automation Development">creator	^manager domain creator</body><body package="Com- Automation Development">interfaceDescription	^manager domain interfaceDescription</body><body package="Com- Automation Development">libraryDirectory	^manager domain libraryDirectory</body><body package="Com- Automation Development">libraryFile	^manager domain libraryFile</body><body package="Com- Automation Development">targetClassList	^manager domain targetClassList</body><body package="Com- Automation Development">typeLibraryClass	^manager domain typeLibraryClass</body><body package="Com- Automation Development">typeLibraryLCID	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^typelibraryLCID isNil		ifTrue:			[typelibraryLCID := nil asValue]		ifFalse:			[typelibraryLCID]</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage</class-id> <category>actions</category><body package="Com- Automation Development">compileLibraryFile	| libDirectory batchFilename commandString cmdStart finalCommand debug |	self generateRspFile.	libDirectory := self libraryDirectoryFileName.	batchFilename := 'Make' , self libraryFile value , '.bat'.	self generateMakeLibraryFile: libDirectory \ batchFilename.	commandString := ' cd ' , libDirectory asString , ' &amp; ' , batchFilename.	ComAutomationWizard useBatchFile		ifTrue: [commandString := ComAutomationWizard cmdEnvironmentBatchFileName, ' &amp; ', commandString].	debug := ComAutomationWizard debugBatchFiles.	cmdStart := debug		ifTrue: ['cmd /K  ']		ifFalse: ['cmd /c  '].	finalCommand := cmdStart , commandString.	debug 		ifTrue: [Transcript show: ((#TryingToExecuteColon &lt;&lt; #com &gt;&gt; 'Trying to execute: &lt;1p&gt;') expandMacrosWith: finalCommand); cr].	OSSystemSupport concreteClass CreateProcess: nil arguments: finalCommand</body><body package="Com- Automation Development">generateLibraryFile	| fn strm lib |	(	[| fname |	fname := self libraryDirectory value asFilename.	fname definitelyExists		ifTrue: [true]		ifFalse: [self createLibraryDirectory: fname]]			on: Error			do: [:ex | false])			ifFalse: 				[MessageBox					warning: (#WarnNotValidIDLDir &lt;&lt; #com							&gt;&gt; '&lt;1s&gt; is not a valid directory.  Please supply a valid directory before generating the idl file.'								expandMacrosWith: self libraryDirectory value).				^self].	COMSessionManager absolutePathName: self libraryDirectory value.	self generateNewTypeLibraryMethod.	fn := self fullLibraryFileName constructWithExtension: '.idl'.	fn asFilename exists ifTrue: [fn asFilename delete].	strm := fn asFilename readWriteStream.		[lib := IDLTypeLibraryDefinition new.	lib libraryHolder: self typeLibraryClass value.	lib creator: self creator value.	lib fileName: self libraryFile value.	lib lcid: self lcid.	lib companyName: self company value.	lib libraryName: self libraryName value.	lib interfaceName: self interfaceDescription value.	self comClassList selections		do: [:cn | lib addClassDefinition: (self typeDescriptionFor: cn)].	[lib printOn: strm] on: Error		do: [:ex | ^self handleLibraryGenerationError: ex]]			ensure: [strm close].	FileBrowser openOnFileNamed: fn asString.	libraryDefinition := lib</body><body package="Com- Automation Development">generateMakeLibraryFile: batFn 	| fn fStream |	fn := self libraryFile value.	fStream := batFn writeStream.		[fStream nextPutAll: 'REM Build the type library for ' , fn; cr.	fStream nextPutAll: 'del ' , fn , '.log'; cr.	fStream nextPutAll: 'MIDL ' , fn , '.idl' , ' @' , fn , '.rsp'; cr.	fStream nextPutAll: 'start notepad ' , fn , '.log']		ensure: [fStream close]</body><body package="Com- Automation Development">generateNewTypeLibraryMethod	| libClass |	libClass := self typeLibraryClass value.	self		generateClassMethod: self newTypeLibraryMethodName		text: self textForNewTypleLibrary		protocol: #'type libraries'		forClass: libClass</body><body package="Com- Automation Development">generateRspFile	| fn fStream rspFile |	fn := self libraryFile value.	rspFile := self fullLibraryFileName constructWithExtension: '.rsp'.	rspFile exists ifTrue: [rspFile delete].	fStream := rspFile writeStream.		["Assume we are in the server image"	fStream nextPutAll: (self generate64BitStubCode				ifTrue: ['/amd64']				ifFalse: ['/win32']).	fStream		cr;		nextPutAll: '/tlb ' , fn , '.tlb';		cr.	fStream		nextPutAll: '/iid iid_' , fn , '.cpp';		cr.	fStream		nextPutAll: '/h midl_' , fn , '.h';		cr.	fStream		nextPutAll: '/o ' , fn , '.log';		cr.	fStream		nextPutAll: '/proxy ' , fn , '_p.c';		cr]			ensure: [fStream close]</body><body package="Com- Automation Development">generateTypeSpecificationLiteralMethods	| analyzer libClass comLib anITypeLib dispatchInterfaces dispatchInterfaceName |	analyzer := COMAutomationTypeAnalyzer new.	libClass := self typeLibraryClass value.	comLib := libClass newTypeLibraryNeutral.	anITypeLib := comLib asInterfaceReference.	dispatchInterfaces := COMAutomationTypeAnalyzer typeLibraryDispatchInterfaces: anITypeLib.	dispatchInterfaces		do: 			[:anITypeInfo | 			| aClass |			dispatchInterfaceName := anITypeInfo getDocumentationName.			aClass := self selectedClasses detect: [:cl | cl interfaceName , 'Disp' = dispatchInterfaceName].			analyzer getTypeInfoSpecifications: anITypeInfo.			self compileMethodSpecificationsLiteral: analyzer methodSpecifications for: aClass.			self compilePropertySpecificationsLiteral: analyzer propertySpecifications for: aClass].</body><body package="Com- Automation Development">lcid	^self typeLibraryLCID value ifNil: [0]</body><body package="Com- Automation Development">registerLibrary	| libClass |	libClass := self typeLibraryClass value.	"If the process is repeated, we need to update the typeLibs with	 new paths etc."	libClass releaseTypeLibraries.	libClass registerTypeLibraries.	self generateTypeSpecificationLiteralMethods</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage</class-id> <category>accessing</category><body package="Com- Automation Development">company	^manager domain company</body><body package="Com- Automation Development">fullLibraryFileName	^self libraryDirectoryFileName \ self libraryFile value</body><body package="Com- Automation Development">helpText	^#wizardIDLPageHelp &lt;&lt; #com &gt;&gt; 'The Type Library page will auto-generate the type library based on the pragmas that you used in the class to be published.Library Holder Class: The selected class that will hold the Type Library information.LibraryName: The name you want to give the library.Version: Defaults to 1.0 (supply a different version if you prefer).Library Dir: The full path name to where the library file will be stored.LibraryFile: The name of the library file that will be generated.Author: Your name.Company: Your company name.There are three buttons:Generate IDL: This button will generate the IDL file that will be used by the MIDL compiler. After it is generated, a TextWindow will open on the file so you can review it for any errors.Compile IDL: This button will invoke the MIDL compiler to create the library file. A console window will be displayed while the compilation occurs. Then notepad will open to display the log file that was generated by the compilation processes. This log file would contain information on anyerrors encountered during compilation. Register Library: This button will register the library with the operating system.'</body><body package="Com- Automation Development">libraryDirectoryFileName	"Answer the Filename for the user specified value."	^self libraryDirectory value asFilename</body><body package="Com- Automation Development">libraryName	^manager domain libraryName</body><body package="Com- Automation Development">version	^manager domain version</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage</class-id> <category>notification</category><body package="Com- Automation Development">changedLibraryDir	self libraryDirectory value ifNotNil: 			[:aString | 			aString notEmpty 				ifTrue: 					[aString last ~= $\ ifTrue: [self libraryDirectory value: aString , '\']]]</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage</class-id> <category>testing</category><body package="Com- Automation Development">isValidDirectoryInputFrom: anInputBoxController	"This is the validation callback from the input field for the library directory name.	Answer whether the input is valid or not and warn if it's invalid."	| valid |	(valid := self isValidDirectoryName: anInputBoxController stringValue)		ifFalse: [Dialog warn: 'The library directory input is not a valid name.'].	^valid</body><body package="Com- Automation Development">isValidDirectoryName: aString	"Check whether the given String is valid as directory name.	Compare the (canonicalized) Filename path with the simple components scan which preserves bad characters. "	| aFilename bad |	aFilename := [aString asFilename] on: OsError do: [:ex | ^false].	bad := (aFilename class badCharacterList copyWithout: $:)				copyWithout: aFilename separator.	^aString allSatisfy: [:ch | (bad includes: ch) not]</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage class</class-id> <category>utils</category><body package="Com- Automation Development">warnNotGenerating: aMethod inClass: aClass 	ComAutomationWizardGUIDGenPage warnNotGenerating: aMethod inClass: aClass</body></methods><methods><class-id>Tools.ComAutomationWizard</class-id> <category>actions</category><body package="Com- Automation Development">nextPage	| numberOfPages nextPageIndex |	numberOfPages := self pageListHolder list size.	nextPageIndex := self pageListHolder selectionIndex + 1 min: numberOfPages.	self pageListHolder selectionIndex: nextPageIndex.	self updateButtons</body><body package="Com- Automation Development">prevPage	| prevPageIndex |	prevPageIndex := self pageListHolder selectionIndex - 1 max: 1.	self pageListHolder selectionIndex: prevPageIndex.	self updateButtons</body></methods><methods><class-id>Tools.ComAutomationWizard</class-id> <category>private</category><body package="Com- Automation Development">updateButtons	| pageIndex |	pageIndex := self pageListHolder selectionIndex.	(self builder componentAt: #backButton) isEnabled: pageIndex &gt; 1.	(self builder componentAt: #nextButton) 		isEnabled: pageIndex ~= self pageListHolder list size</body></methods><methods><class-id>Tools.ComAutomationWizard</class-id> <category>interface opening</category><body package="Com- Automation Development">postBuildWith: aBuilder	super postBuildWith: aBuilder.	(aBuilder componentAt: #backButton) disable.</body></methods><methods><class-id>Tools.ComAutomationWizard class</class-id> <category>accessing</category><body package="Com- Automation Development">cmdEnvironmentBatchFileName	^(VCVARS32File trimBlanks includes: Character space) 		ifTrue: ['"' , VCVARS32File , '"']		ifFalse: [VCVARS32File]</body><body package="Com- Automation Development">debugBatchFiles	^LeaveConsoleUp isNil		ifTrue: [LeaveConsoleUp := false]		ifFalse: [LeaveConsoleUp]</body><body package="Com- Automation Development">debugBatchFiles: aBoolean 	"self debugBatchFiles: false"	"self debugBatchFiles: true"	LeaveConsoleUp := aBoolean</body><body package="Com- Automation Development">environmentBatchFile	^VCVARS32File</body><body package="Com- Automation Development">environmentBatchFile: aFilename	VCVARS32File := aFilename</body><body package="Com- Automation Development">useBatchFile	"Note -- this can only return true if the batch file is a valid filename and this static is true"	|partOne|	partOne := BatchFileNeeded isNil		ifTrue: [BatchFileNeeded := false]		ifFalse: [BatchFileNeeded].	^partOne and: [self isBatchFileLegit]</body><body package="Com- Automation Development">useBatchFile: aBoolean 	BatchFileNeeded := aBoolean</body></methods><methods><class-id>Tools.ComAutomationWizard class</class-id> <category>testing</category><body package="Com- Automation Development">isBatchFileLegit	^[self environmentBatchFile asFilename definitelyExists]		on: Error do: [:ex | false]</body></methods><methods><class-id>Tools.ComAutomationWizard class</class-id> <category>interface opening</category><body package="Com- Automation Development">open	self environmentSet ifTrue: [self open: ComAutomationWizardSettings new]</body></methods><methods><class-id>Tools.ComAutomationWizard class</class-id> <category>private</category><body package="Com- Automation Development">environmentSet	|userKnows |		(self useBatchFile and: [self isBatchFileLegit])		ifTrue: [^true].	(CEnvironment userEnvironment at: #MsDevDir ifAbsent: nil) isNil 		ifFalse: [^true].	userKnows := MessageBox confirm: self noEnvironmentVariablesWarningString.	userKnows not		ifTrue: 			[^(MessageBox confirm: self warnUserAboutProceedingString)].	"The user has an idea where this file is -- let them look for it"	self environmentBatchFile: (FileDialog openFileTitle: #FindVCVARSBat &lt;&lt; #com &gt;&gt; 'Find the vcvars32.bat File' pattern: '*.bat').	self isBatchFileLegit		ifFalse: 			[self environmentBatchFile: nil.			self useBatchFile: false.			^MessageBox confirm: self warnUserAboutProceedingString].	self useBatchFile: true.	^true</body><body package="Com- Automation Development">noEnvironmentVariablesWarningString	^(#noEnvVarWarning &lt;&lt; #com &gt;&gt; 'It does not appear that you have your the proper environment variables setup for the IAAutomationWizard to work properly.  This means that the batch files that the IAAutomationWizard creates and then executes will fail.&lt;nn&gt;Typically these environment variables are setup on a global scale when Visual C++ is first installed.  However, you can also set up the environment variables on a shell (cmd) by shell basis by executing the vcvars32.bat file that comes with Visual C++.   If you know where vcvars32.bat is then the wizard will automatically execute that batch file before it runs any batch files it creates.  This should allow the batch file execution to work.  vcvars32.bat usally lives in the bin directory of Visual C++.&lt;nn&gt;Do you happen to know where that file is?') expandMacros.</body><body package="Com- Automation Development">warnUserAboutProceedingString	^(#warnUserAboutProceed &lt;&lt; #com &gt;&gt; 'Not knowing where the vcvars32.bat file is is OK!  The IAAutomationWizard will still work.  The caveat is that the batch files it creates will not be executed so your TypeLibraries will not be published.&lt;nn&gt;The IAAutomationWizard can still generate new methods on the classes that you specify.&lt;nn&gt;Do you still want to use the IAAutomationWizard?') expandMacros</body></methods><methods><class-id>Tools.IDLSetPropertyDefinition</class-id> <category>printing</category><body package="Com- Automation Development">helpStringOn: aStream 	aStream nextPutAll: '[propput, helpstring("'; nextPutAll: self helpString; nextPutAll: '")]'; nextPut: Character space</body></methods><methods><class-id>Tools.IDLSetPropertyDefinition</class-id> <category>testing</category><body package="Com- Automation Development">isMethodDef	^false</body><body package="Com- Automation Development">isSetProperty	^true</body></methods><methods><class-id>Tools.IDLSetPropertyDefinition</class-id> <category>accessing</category><body package="Com- Automation Development">name: pName type: type helpString: hString	self methodName: pName.	self parameterDefs: ((IDLParametersDefinition new)				paramDef: (IDLParameterDefinition name: 'Value' type: type returnType: 'in');				yourself).	self helpString: hString</body></methods><methods><class-id>Tools.ComAutomationWizardRegFileSettings class</class-id> <category>accessing</category><body package="Com- Automation Development">current	current := nil.	^self new</body></methods><methods><class-id>Tools.ComAutomationWizardRegFileSettings class</class-id> <category>groups</category><body package="Com- Automation Development">addGroupTo: aSettingsGroup named: aStringOrSymbol 	| newGroup nameSymbol |	nameSymbol := aStringOrSymbol asSymbol.	newGroup := self classGroup id: (Array with: nameSymbol).	aSettingsGroup addSetting: newGroup named: nameSymbol.	^newGroup</body><body package="Com- Automation Development">classGroup	| group |	group := SettingsGroup new.	(self settingsWithPrefix: #(#regSetting)) 		do: [:each | group addSetting: each named: each localId].	^group</body></methods><methods><class-id>Tools.COMEventTraceViewer</class-id> <category>private-window events</category><body package="Com- Automation Development">aboutToCloseWindow	" Private - the window being closed. "	self releaseEventSink.</body><body package="Com- Automation Development">windowOpened	" Private - the window has been opened. "	"self displayInitialText."	( eventSink isNil or: [ eventSink specificationTable isEmpty ] )		ifTrue: [			self disableComponentNamed: #enableTracingCheckBox.			"self disableComponentNamed: #describeEventsButton."  " aargh, also defer - wierd painting occurs from here"			"self disableComponentNamed: #traceLogPane."  " must defer until initial text displayed "			].</body></methods><methods><class-id>Tools.COMEventTraceViewer</class-id> <category>private-operation</category><body package="Com- Automation Development">describeEvents    " Describe the events supported by the source object to which the receiver's sink is connnected. "    | eventSpecifications aStream |	eventSpecifications := self getEventSpecifications.    aStream := ReadWriteStream on: String new.    COMAutomationTypeAnalyzer new        stream: aStream;        describeEventSpecifications: eventSpecifications.    TextWindow openOn: aStream contents        label: 'COM Events'.</body><body package="Com- Automation Development">displayInitialText	" Private - display some initial information in the trace view when it is first opened. "	( eventSink isNil or: [ eventSink specificationTable isEmpty ] )		ifTrue: [			self disableComponentNamed: #describeEventsButton.  " bogus here, but avoids initial display problems "			traceLog nextPutAll: (#NotConnectedToEventSourceObject &lt;&lt; #com &gt;&gt; 'Not connected to an event source object.') asString; cr.			self disableComponentNamed: #traceLogPane ]		ifFalse: [			traceLog 				nextPutAll: ( self class relayEventNotifications					ifTrue: [ (#EventsBySingleMessage &lt;&lt; #com &gt;&gt; 'Event notifications are being relayed through a single notification message') asString ]					ifFalse: [ (#EventsByMultipleMessages &lt;&lt; #com &gt;&gt; 'Event notifications are being sent by individual messages') asString ] ); cr;				cr ].</body><body package="Com- Automation Development">doesNotUnderstand: aMessage	" Private - detect event notifications sent directly to the receiver "	| anEventSpecification |	eventNotificationMap isNil		ifTrue: [ ^super doesNotUnderstand: aMessage ].	anEventSpecification := eventNotificationMap at: aMessage selector		ifAbsent: [ ^super doesNotUnderstand: aMessage ].	"Assert isFalse: [ self class relayEventNotifications ]."	self reportEvent: anEventSpecification 		arguments: aMessage arguments.</body><body package="Com- Automation Development">eventTriggered: anEventSelector arguments: arguments	" Private - an event notification is being relayed to the receiver by the event sink. "	"Assert isTrue: [ self class relayEventNotifications ]."	self reportEvent: ( eventNotificationMap at: anEventSelector )		arguments: arguments</body><body package="Com- Automation Development">getEventSpecifications    " Private - answer a specification table for the events supported by the event source object. "	| sinkSpecTable eventSpecifications |	sinkSpecTable := self eventSink specificationTable.	eventSpecifications := sinkSpecTable copyEmpty.	eventSpecifications specificationKey: #name.	sinkSpecTable do: [ :aDispatchSpec |		eventSpecifications add: aDispatchSpec ].	^eventSpecifications</body><body package="Com- Automation Development">registerEventHandlers	" Private - register a handler for every event supported by the object. "	self class relayEventNotifications		ifTrue: [   " report all events through a single port "			eventSink when: #eventNotification:arguments:				send: #eventTriggered:arguments: to: self ]		ifFalse: [  " report each event via an individual message "			eventNotificationMap keysDo: [ :anEventSelector |				eventSink when: anEventSelector					send: anEventSelector to: self ] ].</body><body package="Com- Automation Development">releaseEventSink	" Private "	eventSink notNil		ifTrue: [			eventSink releaseConnection.			eventSink := nil ].</body><body package="Com- Automation Development">reportEvent: anEventSpecification arguments: arguments	" Private - an event notification has been received. "	| nArgs parameterNames |	enableTracing value		ifFalse: [ ^self ].	nArgs := arguments size.	parameterNames := anEventSpecification parameterNames.	Assert isEqual: nArgs to: parameterNames size.	traceLog nextPutAll: (#NamedEvent &lt;&lt; #com &gt;&gt; 'Event &lt;1s&gt;' expandMacrosWith: anEventSpecification name).	nArgs = 0		ifTrue: [ traceLog cr ]		ifFalse: [            		traceLog nextPutAll: ':'; cr.			1 to: nArgs do: [ :i |				traceLog 					"tab;" nextPutAll: ( String with: Character tab );  " sigh "					nextPutAll: ( parameterNames at: i ), ': ';					nextPutAll: ( arguments at: i ) printString; cr ].			].	traceLog cr.</body></methods><methods><class-id>Tools.COMEventTraceViewer</class-id> <category>aspects</category><body package="Com- Automation Development">enableTracing	" Answer the value holder for the flag indicating whether tracing is currently enabled. "	^enableTracing</body><body package="Com- Automation Development">traceLog	" Answer the model for the trace log text. "	^traceLog</body></methods><methods><class-id>Tools.COMEventTraceViewer</class-id> <category>private-accessing</category><body package="Com- Automation Development">eventSink	" Private "	^eventSink</body><body package="Com- Automation Development">eventSink: anEventSink	" Private "	eventSink := anEventSink.	self initializeEventNotificationMap.</body></methods><methods><class-id>Tools.COMEventTraceViewer</class-id> <category>private-initialization</category><body package="Com- Automation Development">initialize		" Private - initialize a new instance. "	enableTracing := false asValue.	traceLog := TextWindowTextCollector new.</body><body package="Com- Automation Development">initializeEventNotificationMap	" Private - construct the event notification map used for processing event notifications reported by separate messages. "	| nArgs parameterNames |	eventNotificationMap := IdentityDictionary new.	eventSink specificationTable do: [ :anEventSpecification |		nArgs := anEventSpecification parameterCount.		parameterNames := anEventSpecification parameterNames.		" synthesize argument names if not available "		( nArgs &gt; 0 and: [ parameterNames size = 0 ] )			ifTrue: [				parameterNames := Array new: nArgs.				1 to: nArgs do: [ :i |					parameterNames at: i put: 'arg', i printString ].				anEventSpecification parameterNames: parameterNames].		eventNotificationMap at: anEventSpecification selector			put: anEventSpecification.		].</body></methods><methods><class-id>Tools.COMEventTraceViewer</class-id> <category>private-view creation</category><body package="Com- Automation Development">textMenu	"Answer a Menu of operations on the source code that is to 	be displayed when the operate menu button is pressed."	^ParagraphEditor editGroup</body><body package="Com- Automation Development">traceLogComponent	"Construct a view for the trace log text."	| aTextView textEditor |	aTextView := TextCollectorView new model: self traceLog.	textEditor := TextEditorController new.	textEditor menuHolder: ( ValueHolder with: self textMenu ).	aTextView controller: textEditor.	^aTextView</body></methods><methods><class-id>Tools.COMEventTraceViewer class</class-id> <category>interface specs</category><body package="Com- Automation Development">eventHandlersSpec	" Answer the specifications for connecting components of the application using events "	^super eventHandlersSpec, #(		#( #applicationWindow			#( #opened #windowOpened ) 			#( #aboutToClose #aboutToCloseWindow )			)		)</body></methods><methods><class-id>Tools.COMEventTraceViewer class</class-id> <category>opening</category><body package="Com- Automation Development">open	" Open a event trace viewer which is not connected to anything.. "	" COMEventTracer open "	| anEventViewer |	anEventViewer := self new.	self openOn: anEventViewer withSpec: #windowSpec.	anEventViewer displayInitialText.	^anEventViewer</body><body package="Com- Automation Development">openOn: anInterface	" Open a event trace viewer window which establishes an event sink on the COM object represented by &lt;anInterface&gt; and  reports each event triggered by the event source object.  Answer the trace viewer. "	" get the event interface type information "	| anITypeInfo eventSpecificationTable |	anITypeInfo := COMDispatchSpecificationTable getEventTypeInfoOf: anInterface.	anITypeInfo isNil		ifTrue: 			[MessageBox notify: #NoEventInfo &lt;&lt; #com &gt;&gt; 'No Event Info'				withText: #NoEventInfoLong &lt;&lt; #com						&gt;&gt; 'No event information available.  The object either does not support events or you must provide the dispatch specifications from another source (e.g., from a type library).'.			^nil].	" construct an event specification table for this event interface "	eventSpecificationTable := COMDispatchSpecificationTable				constructEventSinkSpecificationTable: anITypeInfo.	eventSpecificationTable size = 0		ifTrue: 			[MessageBox notify: #NoEventsDefined &lt;&lt; #com &gt;&gt; 'No Events Defined'				withText: #NoEventsDefinedLong &lt;&lt; #com						&gt;&gt; 'No event definitions were defined in the event interface.  (This is pretty bogus and probably should not be.)'.			^nil].	^self openOn: anInterface specificationTable: eventSpecificationTable</body><body package="Com- Automation Development">openOn: anInterface specificationTable: anEventSpecificationTable	" Open a event trace viewer window which establishes an event sink on the COM object represented by &lt;anInterface&gt; and  reports each event triggered by the event source object.  The event specifications and the connection point IID of the event interface are defined in &lt;anEventSpecificationTable&gt;.  Answer the trace viewer. "	| anEventViewer anEventSink |	" configure the event sink with the event interface specifications "	anEventSink := COMEventSink iid: anEventSpecificationTable iid		specificationTable: anEventSpecificationTable.	" register event handlers on the event sink so the viewer is notified of events "	anEventViewer := self new.	anEventViewer 		eventSink: anEventSink;		registerEventHandlers.	" establish the notification connection to the event source object "	anEventSink establishConnectionTo: anInterface. 		" Note: the notification connection is torn down when the viewer is closed "	" open the trace log view which allows us to view event reporting "	self openOn: anEventViewer withSpec: #windowSpec.	anEventViewer displayInitialText.	^anEventViewer</body></methods><methods><class-id>Tools.COMEventTraceViewer class</class-id> <category>configuring</category><body package="Com- Automation Development">relayEventNotifications	" Answer whether event notifications are relayed to instances of the receiver through a standard notification message.  Otherwise, event notifications are sent directly to instances of the receiver as a message whose selector conforms to the event selector (and picked up in this case by doesNotUnderstand). "	RelayEventNotifications isNil		ifTrue: [ RelayEventNotifications := true ].	^RelayEventNotifications</body><body package="Com- Automation Development">relayEventNotifications: aBoolean	" Specify whether event notifications are relayed to instances of the receiver through a standard notification message.  Otherwise, event notifications are sent directly to instances of the receiver as a message whose selector conforms to the event selector (and picked up in this case by doesNotUnderstand). "	"To send all event notifications to single notification port:		COMEventTraceViewer relayEventNotifications: true.	To send all event notifications via individual messages:		COMEventTraceViewer relayEventNotifications: false.	"	RelayEventNotifications := aBoolean.</body></methods><methods><class-id>Tools.ComAutomationWizardRegConf</class-id> <category>accessing</category><body package="Com- Automation Development">activeXOn	^(self settingsGroup settingNamed: #activeXOn) value</body><body package="Com- Automation Development">activeXOn: aString		(self settingsGroup settingNamed: #activeXOn) value: aString</body><body package="Com- Automation Development">automationOn		^(self settingsGroup settingNamed: #automationOn) value</body><body package="Com- Automation Development">automationOn: aString		(self settingsGroup settingNamed: #automationOn) value: aString</body><body package="Com- Automation Development">objectDescription		^(self settingsGroup settingNamed: #objectDescription) value</body><body package="Com- Automation Development">objectDescription: aString		(self settingsGroup settingNamed: #objectDescription) value: aString</body><body package="Com- Automation Development">progID		^(self settingsGroup settingNamed: #progID) value</body><body package="Com- Automation Development">progID: aString		(self settingsGroup settingNamed: #progID) value: aString</body><body package="Com- Automation Development">settingsGroup	^settingsGroup</body><body package="Com- Automation Development">versionNumber		^(self settingsGroup settingNamed: #versionNumber) value</body><body package="Com- Automation Development">versionNumber: aNumber		(self settingsGroup settingNamed: #versionNumber) value: aNumber</body></methods><methods><class-id>Tools.ComAutomationWizardRegConf</class-id> <category>aspects</category><body package="Com- Automation Development">interfaceClass	^interfaceClass</body><body package="Com- Automation Development">interfaceClass: aBehavior	interfaceClass := aBehavior</body><body package="Com- Automation Development">settingsGroup: aSettingsGroup	settingsGroup := aSettingsGroup</body></methods><methods><class-id>Tools.ComAutomationWizardRegConf class</class-id> <category>instance creation</category><body package="Com- Automation Development">domain: aSettingsDomain class: aClass 	^(self new)		settingsGroup: (aSettingsDomain regFileSettingGroupFor: aClass);		interfaceClass: aClass;		yourself</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-com</category><body package="Com- Automation Development">policySettingType	"Return the EnumerationSetting type for the valid specification policies.  This 	 assumes that the choices are of newFooPolicy, and we can strip that stuff off	 to make readable labels."	| policyDescriptions policyValues |	policyValues := COMSpecificationPolicy validDefaultPolicies asArray.	policyDescriptions := policyValues 				collect: [:each | each copyFrom: 'new' size + 1 to: each size - 'Policy' size].	^EnumerationSetting 				keys: policyValues				choices: policyValues				labels: policyDescriptions.</body></methods><methods><class-id>Core.Array</class-id> <category>testing</category><body package="Com- Automation Development">isSpecArray	self isEmpty ifTrue: [^false].	^(self first isSymbol and: [self size &gt; 1])		or: [self anySatisfy: #isSpecArray]</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Com- Automation Development">isSpecArray	^false</body></methods><methods><class-id>Tools.SettingsManagerPage class</class-id> <category>utils</category><body package="Com- Automation Development">warnNotGenerating: aSymbol inClass: aClass 	"Warn the user that aMethod for aClass is not being generated"	| msg |	msg := #WarnNotGenerate &lt;&lt; #com 				&gt;&gt; 'COM Automation Wizard will not generate &lt;1s&gt; for &lt;2s&gt;.  &lt;2s&gt; already understands &lt;1s&gt;.' 					expandMacrosWith: aSymbol					with: aClass instanceBehavior unambiguousName.	Transcript		show: msg;		cr	"MessageBox warn: msg"</body></methods><methods><class-id>Tools.SettingsManagerPage</class-id> <category>private-generations</category><body package="Com- Automation Development">generateClassMethod: methodName do: aBlock protocol: theProtocol forClass: aClass 	| strm theClass methodComment |	aClass ifNotNil: [theClass := aClass class] ifNil: [^nil].	(theClass findSelector: methodName) ifNotNil: 			[self class warnNotGenerating: methodName inClass: theClass.			^nil].	strm := String new writeStream.	methodComment := (#MethodWarnAutoGen &lt;&lt; #com 				&gt;&gt; '"This method was generated by COM Automation Tool. Do not change unless you know what you are doing."') 					asString.	"now do the code"	strm		nextPutAll: methodName;		cr.	strm		tab;		nextPutAll: methodComment;		cr;		cr;		nextPut: $^.	aBlock value: strm.	theClass compile: strm contents classified: theProtocol</body><body package="Com- Automation Development">generateClassMethod: methodName textSelector: methodTextSelector protocol: theProtocol 	| strm theClass methodComment |	theClass := self targetClass.	theClass notNil ifTrue: [theClass := theClass class] ifFalse: [^nil].	(theClass findSelector: methodName)  ifNotNil: 			[self class warnNotGenerating: methodName inClass: theClass.			^nil].	strm := String new writeStream.	methodComment := (#MethodWarnAutoGen &lt;&lt; #com 				&gt;&gt; '"This method was generated by COM Automation Tool. Do not change unless you know what you are doing."') 					asString.	"now do the code"	strm		nextPutAll: methodName;		cr.	strm		tab;		nextPutAll: methodComment;		cr;		cr.	strm		tab;		nextPutAll: (self perform: methodTextSelector).	theClass compile: strm contents classified: theProtocol</body><body package="Com- Automation Development">generateClassMethod: methodName textSelector: methodTextSelector protocol: theProtocol onlyIfNotExists: aBoolean 	| strm theClass methodComment |	theClass := self targetClass.	theClass notNil ifTrue: [theClass := theClass class] ifFalse: [^nil].	aBoolean 		ifTrue: 			[(theClass findSelector: methodName)  ifNotNil: 					[self class warnNotGenerating: methodName inClass: theClass.					^nil]].	strm := String new writeStream.	methodComment := (#MethodWarnAutoGen &lt;&lt; #com 				&gt;&gt; '"This method was generated by COM Automation Tool. Do not change unless you know what you are doing."') 					asString.	"now do the code"	strm		nextPutAll: methodName;		cr.	strm		tab;		nextPutAll: methodComment;		cr;		cr.	strm		tab;		nextPutAll: (self perform: methodTextSelector).	theClass compile: strm contents classified: theProtocol</body></methods><methods><class-id>Tools.SettingsManagerPage</class-id> <category>accessing</category><body package="Com- Automation Development">targetClass	"Convenience method. Not all subclasses need to implement this - therefore returning nil"	^ nil</body></methods><methods><class-id>Tools.ComAutomationWizardDeployPage class</class-id> <category>interface specs</category><body package="Com- Automation Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #DeploymentSetup 				#defaultString: 'Deployment Setup' 				#catalogID: #com ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1060 705 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 90 0 -10 1 -10 0.8 ) 					#flags: 4 					#model: #warningText 					#tabRequiresControl: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 120 0 10 0 -10 1 35 0 ) 					#model: #libraryDirectory 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 120 0 45 0 -10 1 70 0 ) 					#model: #localServerImage 					#tabable: true 					#style: #default 					#isReadOnly: false ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 -10 1 0 1 ) 					#model: #openTraceViewer 					#label: 					#(#{Kernel.UserMessage} 						#key: #OpenComTracer 						#defaultString: 'Open Com Trace Viewer' 						#catalogID: #com ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{UI.AlignmentOrigin} -10 1 -10 1 1 1 ) 					#model: #runSetup 					#label: 					#(#{Kernel.UserMessage} 						#key: #RunSetup 						#defaultString: 'Run Setup' 						#catalogID: #com ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 10 0 0 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #TypeLibraryDirColon 						#defaultString: 'Type Library Dir:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 45 0 0 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ImageFileColon 						#defaultString: 'Image File:' 						#catalogID: #com ) 					#style: #default ) ) ) )</body></methods><methods><class-id>External.COMAutomationEditor class</class-id> <category>interface specs</category><body package="Com- Automation Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #AutomationEditor 				#defaultString: 'COM Automation Editor' 				#catalogID: #com ) 			#min: #(#{Core.Point} 40 20 ) 			#bounds: #(#{Graphics.Rectangle} 52 535 567 1008 ) 			#flags: 4 			#menu: #menuSpec ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 96 0 -5 1 -5 1 ) 					#name: #evaluationTextPane 					#model: #evaluationTextModel 					#menu: #textMenu 					#tabRequiresControl: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 5 63 84 90 ) 					#name: #doItButton 					#model: #evaluateDoIt 					#label: 					#(#{Kernel.UserMessage} 						#key: #DoIt 						#defaultString: 'Do it' 						#catalogID: #menus ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 93 63 172 90 ) 					#name: #printItButton 					#model: #evaluatePrintIt 					#label: 					#(#{Kernel.UserMessage} 						#key: #PrintIt 						#defaultString: 'Print it' 						#catalogID: #menus ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.Rectangle} 180 63 259 90 ) 					#name: #inspectItButton 					#model: #evaluateInspectIt 					#label: 					#(#{Kernel.UserMessage} 						#key: #InspectIt 						#defaultString: 'Inspect it' 						#catalogID: #com ) 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 8 ) 					#name: #automationObjectDescription 					#label: 					#(#{Kernel.UserMessage} 						#key: #DispatcherNoneShh 						#defaultString: 'Dispatcher: (none)' 						#catalogID: #com ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 5 35 ) 					#name: #automationSpecificationPolicyDescription 					#label: 					#(#{Kernel.UserMessage} 						#key: #SpecPolicyNoneShh 						#defaultString: 'Specification policy: (none)' 						#catalogID: #com ) ) ) ) )</body></methods><methods><class-id>External.COMAutomationEditor class</class-id> <category>resources</category><body package="Com- Automation Development">menuSpec	"Tools.MenuEditor new openOnClass: self andSelector: #menuSpec"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Evaluate 					#defaultString: 'Evaluate' 					#catalogID: #com ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DoIt 								#defaultString: 'Do it' 								#catalogID: #menus ) 							#value: #evaluateDoIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #PrintIt 								#defaultString: 'Print it' 								#catalogID: #menus ) 							#value: #evaluatePrintIt ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #InspectIt 								#defaultString: 'Inspect it' 								#catalogID: #menus ) 							#value: #evaluateInspectIt ) ) #(3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Developer 					#defaultString: 'Developer' 					#catalogID: #com ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #InspectDispatch 								#defaultString: 'Inspect Dispatcher' 								#catalogID: #com ) 							#value: #inspectDispatcher ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #InspectSpecs 								#defaultString: 'Inspect Specifications' 								#catalogID: #com ) 							#value: #inspectSpecifications ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DescribeMethods 								#defaultString: 'Describe Methods' 								#catalogID: #com ) 							#value: #describeMethods ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DescribeProps 								#defaultString: 'Describe Properties' 								#catalogID: #com ) 							#value: #describeProperties ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #DescribeAll 								#defaultString: 'Describe All' 								#catalogID: #com ) 							#value: #describeAll ) ) #(2 3 ) nil ) ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Help 					#defaultString: 'Help' 					#catalogID: #labels ) 				#value: #explainWhatToDo ) ) #(3 ) nil ) decodeAsLiteralArray</body><body package="Com- Automation Development">textMenu	"Tools.MenuEditor new openOnClass: self andSelector: #textMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Cut 					#defaultString: 'Cut' 					#catalogID: #menus ) 				#value: #editCut ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Copy 					#defaultString: 'Copy' 					#catalogID: #menus ) 				#value: #editCopy ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Paste 					#defaultString: 'Paste' 					#catalogID: #menus ) 				#value: #editPaste ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #FindDot 					#defaultString: 'Find...' 					#catalogID: #menus ) 				#value: #editFind ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #ReplaceDot 					#defaultString: 'Replace...' 					#catalogID: #menus ) 				#value: #editReplace ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #doIt 					#defaultString: 'Do it' 					#catalogID: #com ) 				#value: #evaluateDoIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #printIt 					#defaultString: 'Print it' 					#catalogID: #com ) 				#value: #evaluatePrintIt ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #InspectIt 					#defaultString: 'Inspect it' 					#catalogID: #com ) 				#value: #evaluateInspectIt ) ) #(3 2 3 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage class</class-id> <category>interface specs</category><body package="Com- Automation Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #SupportGenerator 				#defaultString: 'COM Support Generator' 				#catalogID: #com ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1191 932 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 6 0 -10 1 30 0 ) 					#model: #className 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changedClass ) 					#style: #default 					#type: #object 					#comboList: #targetClassList 					#readSelector: 					#stringToClass: 					#printSelector: 					#classToString: ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 44 0 -10 1 69 0 ) 					#model: #interfaceDescription 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 110 0 81 0 -10 1 106 0 ) 					#model: #externalName 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 168 0 138 0 -10 1 163 0 ) 					#flags: 40 					#model: #typeLibraryClass 					#type: #symbol ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 210 0 -5 0.5 -35 1 ) 					#model: #instanceMethodList 					#multipleSelections: true 					#selectionType: #checkMark ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.5 210 0 -10 1 -35 1 ) 					#model: #classMethodList 					#multipleSelections: true 					#selectionType: #checkMark ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 6 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClassColon 						#defaultString: 'Class:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 110 0 -5 1 180 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #TypeLibrary 						#defaultString: 'Type library' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0.5 185 0 431 0 212 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ClassMethodsColon 						#defaultString: 'Class methods:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 185 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #InstanceMethodsColon 						#defaultString: 'Instance methods:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.Rectangle} 20 138 89 162 ) 					#model: #whereIsTypeLibrary 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changeLibraryLocation ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Local 						#defaultString: 'Local' 						#catalogID: #com ) 					#style: #default 					#select: #local ) 				#(#{UI.RadioButtonSpec} 					#layout: #(#{Graphics.Rectangle} 101 139 160 162 ) 					#flags: 32 					#model: #whereIsTypeLibrary 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #changeLibraryLocation ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #Class 						#defaultString: 'Class' 						#catalogID: #labels ) 					#style: #default 					#select: #anotherClass ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0 -30 1 -30 0.5 -5 1 ) 					#model: #generateInstanceMethods 					#label: 					#(#{Kernel.UserMessage} 						#key: #Generate 						#defaultString: 'Generate' 						#catalogID: #com ) 					#style: #default 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 30 0.5 -30 1 -30 1 -5 1 ) 					#model: #generateClassMethods 					#label: 					#(#{Kernel.UserMessage} 						#key: #Generate 						#defaultString: 'Generate' 						#catalogID: #com ) 					#style: #default 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 41 0 0 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #InterfaceNameColon 						#defaultString: 'Interface name:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 80 0 0 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #ExternalNameColon 						#defaultString: 'External name:' 						#catalogID: #com ) 					#style: #default ) ) ) )</body></methods><methods><class-id>Tools.ComAutomationWizardGUIDGenPage class</class-id> <category>compiler support</category><body package="Com- Automation Development">pragmas	&lt;pragmas: #instance&gt;	&lt;pragmas: #class&gt;	^#(	#methodName:parameters:parameterTypes:returnTypes: 		#methodName:parameters:parameterTypes:returnTypes:helpString: 		#getProperty:type:helpString: #setProperty:type:helpString:		#methodName:parameters:parameterTypes:optionalParameterCount:returnTypes:		#methodName:parameters:parameterTypes:optionalParameterCount:returnTypes:helpString:)</body></methods><methods><class-id>Tools.ComAutomationWizardClassesPage class</class-id> <category>interface specs</category><body package="Com- Automation Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #SelectObjectClasses 				#defaultString: 'Select object classes' 				#catalogID: #com ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1083 883 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 35 0 -10 1 -85 1 ) 					#model: #objectClassList 					#multipleSelections: true 					#selectionType: #checkMark ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 10 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #SelectAppClasses 						#defaultString: 'Select classes belonging to this application:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -70 1 -80 1 -10 1 -55 1 ) 					#model: #addNewClass 					#label: 					#(#{Kernel.UserMessage} 						#key: #Add 						#defaultString: 'Add' 						#catalogID: #labels ) 					#style: #default 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.ComAutomationWizardRegFilePage class</class-id> <category>interface specs</category><body package="Com- Automation Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #RegistryFileGen 				#defaultString: 'Registry File Generator' 				#catalogID: #com ) 			#bounds: #(#{Graphics.Rectangle} 640 512 1079 896 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 137 0 -5 1 325 0 ) 					#name: #Gruppenfeld1 					#label: 					#(#{Kernel.UserMessage} 						#key: #ForClassColon 						#defaultString: 'For Class:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 10 0 -10 1 35 0 ) 					#name: #InputField1 					#model: #regFileName 					#style: #default ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -229 1 -35 1 -124 1 -10 1 ) 					#name: #ActionButton1 					#model: #generateFile 					#label: 					#(#{Kernel.UserMessage} 						#key: #GenerateFile 						#defaultString: 'Generate File' 						#catalogID: #com ) 					#style: #default 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -109 1 -35 1 -10 1 -10 1 ) 					#name: #ActionButton2 					#model: #register 					#label: 					#(#{Kernel.UserMessage} 						#key: #Register 						#defaultString: 'Register' 						#catalogID: #com ) 					#style: #default 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 10 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #RegFileColon 						#defaultString: 'Reg. File:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 171 ) 					#name: #Label2 					#label: 					#(#{Kernel.UserMessage} 						#key: #DescriptionColon 						#defaultString: 'Description:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 206 ) 					#name: #Label3 					#label: 					#(#{Kernel.UserMessage} 						#key: #ProgIDColon 						#defaultString: 'ProgID: ' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 15 241 ) 					#name: #Label4 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionColon 						#defaultString: 'Version:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 53 0 -48 1 78 0 ) 					#name: #InputField2 					#model: #localServerEngine 					#style: #default ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutSizedOrigin} -43 1 53 0 22 25 ) 					#name: #ActionButton3 					#model: #setLocalEngine 					#label: #fileOpen 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 88 0 -48 1 113 0 ) 					#name: #InputField3 					#model: #localServerImage 					#style: #default ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication true ) 					#layout: #(#{Graphics.LayoutSizedOrigin} -43 1 88 0 22 25 ) 					#name: #ActionButton4 					#model: #setLocalImage 					#label: #fileOpen 					#hasCharacterOrientedLabel: false 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 206 0 -20 1 231 0 ) 					#name: #InputField4 					#model: #'classRegistrationHolder progID' 					#style: #default 					#numChars: 39 ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 241 0 -20 1 266 0 ) 					#name: #InputField5 					#model: #'classRegistrationHolder versionNumber' 					#style: #default 					#type: #number ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 38 0 -5 1 123 0 ) 					#name: #GroupBox1 					#label: 					#(#{Kernel.UserMessage} 						#key: #LocalServer 						#defaultString: 'Local Server' 						#catalogID: #com ) ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 53 ) 					#name: #Label5 					#label: 					#(#{Kernel.UserMessage} 						#key: #LocalServerEngine 						#defaultString: 'Engine:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 17 85 ) 					#name: #Label6 					#label: 					#(#{Kernel.UserMessage} 						#key: #LocalServerImage 						#defaultString: 'Image:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 270 ) 					#name: #CheckBox1 					#model: #'classRegistrationHolder automationOn' 					#label: 					#(#{Kernel.UserMessage} 						#key: #AutomationSwitch 						#defaultString: 'Automation Switch' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 20 295 ) 					#name: #CheckBox2 					#model: #'classRegistrationHolder activeXOn' 					#label: 					#(#{Kernel.UserMessage} 						#key: #ActiveXControl 						#defaultString: 'ActiveX Control' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 171 0 -20 1 196 0 ) 					#name: #InputField6 					#model: #'classRegistrationHolder objectDescription' 					#style: #default 					#numChars: 40 ) 				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 90 0 136 0 -20 1 161 0 ) 					#name: #ComboBox1 					#model: #className 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #selectRegistrationGroup 						#requestValueChangeSelector: #okayToChangeClass ) 					#style: #default 					#type: #object 					#comboList: #targetClassList 					#readSelector: 					#stringToClass: 					#printSelector: 					#classToString: ) 				#(#{UI.ActionButtonSpec} 					#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 					#layout: #(#{Graphics.LayoutFrame} -345 1 -35 1 -242 1 -10 1 ) 					#name: #ActionButton5 					#model: #generateClassSpec 					#helpText: 'This button will add self registration features to the class.' 					#label: 'Self Registration' 					#style: #default 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.ComAutomationWizardSettings class</class-id> <category>settings-classes</category><body package="Com- Automation Development">classesList	&lt;setting: #(classSelect classList)&gt; 	^((SequenceSetting of: StringSetting) on: self classToStringAdaptor)</body><body package="Com- Automation Development">classesListSelection	&lt;setting: #(classSelect classListSelection)&gt; 	^((SequenceSetting of: NumberSetting) on: List new asValue)</body></methods><methods><class-id>Tools.ComAutomationWizardSettings class</class-id> <category>settings-GUID Generator</category><body package="Com- Automation Development">guidExternalName	&lt;setting: #(guidGen externalName)&gt;	^StringSetting on: String new asValue</body><body package="Com- Automation Development">guidInterfaceDescription	&lt;setting: #(guidGen interfaceDescription)&gt;	^StringSetting on: String new asValue</body><body package="Com- Automation Development">guidWhereIsTypeLibrary	&lt;setting: #(guidGen whereIsTypeLibrary)&gt;	^((EnumerationSetting choices: #(#local #anotherClass)		labels: (Array with: #Local &lt;&lt; #com &gt;&gt; 'Local'				with: #Class &lt;&lt; #labels &gt;&gt; 'Class')) 			on: #local asValue) default: #local</body></methods><methods><class-id>Tools.ComAutomationWizardSettings class</class-id> <category>settings-Reg file page</category><body package="Com- Automation Development">regFileName	&lt;setting: #(regFile regFileName)&gt;	| defaultMessage |	defaultMessage := (#regFileName &lt;&lt; #com &gt;&gt; 'Specify A Reg File.reg') asString.	^(StringSetting forNameOfFile on: defaultMessage asValue) 		default: defaultMessage</body><body package="Com- Automation Development">regGroup	&lt;setting: #(regFile regGroup)&gt;	^SettingsGroup new</body><body package="Com- Automation Development">regLocalServerEngine	&lt;setting: #(regFile localServerEngine)&gt;	| defaultMessage |	defaultMessage := (#SupplyAServerEnginePath &lt;&lt; #com &gt;&gt; 'Supply a Server Engine Path') asString.	^(StringSetting forNameOfFile on: defaultMessage asValue) 		default: defaultMessage</body><body package="Com- Automation Development">regLocalServerImage	&lt;setting: #(regFile localServerImage)&gt;	| defaultMessage |	defaultMessage := (#SupplyAServerImagePath &lt;&lt; #com &gt;&gt; 'Supply a Server Image Path') asString.	^(StringSetting forNameOfFile on: defaultMessage asValue) 		default: defaultMessage</body></methods><methods><class-id>Tools.ComAutomationWizardSettings class</class-id> <category>settings-IDL Generator</category><body package="Com- Automation Development">bitsForStubCode	&lt;setting: #(idlGen bitsForStubCode)&gt;	^((EnumerationSetting choices: #(#'32Bit' #'64Bit')		labels: #('32 Bit' '64 Bit')) 			on: #'32Bit' asValue) default: #'32Bit'</body><body package="Com- Automation Development">idlCompany	&lt;setting: #(idlGen company)&gt;	| defaultMessage |	defaultMessage := (#noCompanyYet &lt;&lt; #com &gt;&gt; 'no company yet') asString.	^(StringSetting on: defaultMessage asValue) default: defaultMessage</body><body package="Com- Automation Development">idlCreator	&lt;setting: #(idlGen creator)&gt;	| defaultMessage |	defaultMessage := (#noCreatorYet &lt;&lt; #com &gt;&gt; 'no creator yet') asString.	^(StringSetting on: defaultMessage asValue) default: defaultMessage</body><body package="Com- Automation Development">idlLibraryDirectory	&lt;setting: #(idlGen libraryDirectory)&gt;	| defaultDirectory |	defaultDirectory := (Filename defaultDirectory construct: '\TypeLibrary') 				asString , '\'.	^(StringSetting forNameOfDirectory on: defaultDirectory asValue) 		default: defaultDirectory</body><body package="Com- Automation Development">idlLibraryFile	&lt;setting: #(idlGen libraryFile)&gt;	| defaultMessage |	defaultMessage := (#noLibFileYet &lt;&lt; #com &gt;&gt; 'no library file yet') 				asString.	^(StringSetting forNameOfFile on: defaultMessage asValue) 		default: defaultMessage</body><body package="Com- Automation Development">idlLibraryName	&lt;setting: #(idlGen libraryName)&gt;	| defaultMessage |	defaultMessage := (#noLibNameYet &lt;&lt; #com &gt;&gt; 'no library name yet') 				asString asString.	^(StringSetting forNameOfFile on: defaultMessage asValue) 		default: defaultMessage</body><body package="Com- Automation Development">idlVersion	&lt;setting: #(idlGen version)&gt;	^(StringSetting on: '1.0' asValue) default: '1.0'</body></methods><methods><class-id>Tools.ComAutomationWizardSettings class</class-id> <category>settings-Deploy page</category><body package="Com- Automation Development">deployImagePath	&lt;setting: #(deploy deployImagePath)&gt;	| defaultMessage |	defaultMessage := (#deployImagePath &lt;&lt; #com &gt;&gt; 'Specify an image path') asString.	^(StringSetting forNameOfFile on: defaultMessage asValue) 		default: defaultMessage</body></methods><methods><class-id>Tools.ComAutomationWizardSettings class</class-id> <category>pages</category><body package="Com- Automation Development">classesPage	&lt;settingsPage: #(classSelect)&gt;		^ComAutomationWizardClassesPage new		label: #Classes &lt;&lt; #labels &gt;&gt; 'Classes'</body><body package="Com- Automation Development">deployPage	&lt;settingsPage: #(deploy) position: 40&gt;		^ComAutomationWizardDeployPage new		label: #Deploy &lt;&lt; #labels &gt;&gt; 'Deploy'</body><body package="Com- Automation Development">guidGenPage	&lt;settingsPage: #(guidGen) position: 10&gt;		^ComAutomationWizardGUIDGenPage new		label: #GUID &lt;&lt; #labels &gt;&gt; 'GUID'</body><body package="Com- Automation Development">idlGenPage	&lt;settingsPage: #(idlGen) position: 20&gt;		^ComAutomationWizardIDLGenPage new		label: #TypeLibrary &lt;&lt; #labels &gt;&gt; 'Type Library'</body><body package="Com- Automation Development">regFilePage	&lt;settingsPage: #(regFile) position: 30&gt;		^ComAutomationWizardRegFilePage new		label: #RegFile &lt;&lt; #labels &gt;&gt; 'Reg File'</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage class</class-id> <category>interface specs</category><body package="Com- Automation Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #TypeLibGenerator 				#defaultString: 'Type Library Generator' 				#catalogID: #com ) 			#bounds: #(#{Graphics.Rectangle} 673 321 1248 732 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ComboBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 10 0 -10 1 35 0 ) 					#model: #typeLibraryClass 					#style: #default 					#type: #object 					#comboList: #targetClassList 					#readSelector: 					#stringToClass: 					#printSelector: 					#classToString: ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 43 0 -10 1 68 0 ) 					#model: #libraryName 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 77 0 -10 1 102 0 ) 					#model: #version 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 111 0 -10 1 136 0 ) 					#model: #libraryDirectory 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#requestValueChangeSelector: 						#isValidDirectoryInputFrom: ) 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 144 0 -10 1 169 0 ) 					#model: #libraryFile 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 177 0 -10 1 202 0 ) 					#model: #creator 					#style: #default ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 211 0 -10 1 236 0 ) 					#model: #company 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 40 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #LibraryNameColon 						#defaultString: 'Library Name:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 74 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #VersionColon 						#defaultString: 'Version:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 141 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #LibraryFileColon 						#defaultString: 'Library File:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 176 75 202 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #AuthorColon 						#defaultString: 'Author:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 108 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #LibraryDirColon 						#defaultString: 'Library Dir:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 39 0 -30 1 143 0 -5 1 ) 					#model: #generateLibraryFile 					#label: 					#(#{Kernel.UserMessage} 						#key: #GenerateIDL 						#defaultString: 'Generate IDL' 						#catalogID: #com ) 					#style: #default 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 166 0 -30 1 279 0 -5 1 ) 					#model: #compileLibraryFile 					#label: 					#(#{Kernel.UserMessage} 						#key: #CompileIDL 						#defaultString: 'Compile IDL' 						#catalogID: #com ) 					#style: #default 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 292 0 -30 1 420 0 -5 1 ) 					#model: #registerLibrary 					#label: 					#(#{Kernel.UserMessage} 						#key: #RegisterLibrary 						#defaultString: 'Register Library' 						#catalogID: #com ) 					#style: #default 					#isDefault: true 					#defaultable: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 240 0 0 0 ) 					#name: #Label1 					#label: 					#(#{Kernel.UserMessage} 						#key: #LanguageLCIDC 						#defaultString: 'Language (LCID):' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 12 0 310 0 -10 1 -40 1 ) 					#model: #comClassList 					#multipleSelections: true 					#selectionType: #checkMark ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 243 0 -10 1 268 0 ) 					#model: #typeLibraryLCID 					#menu: #typelibraryLCIDMenu ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.Rectangle} 10 210 93 236 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #CompanyColon 						#defaultString: 'Company:' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{UI.AlignmentOrigin} 10 0 9 0 0 0 ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #LibraryHolderColon 						#defaultString: 'Library Holder Class: ' 						#catalogID: #com ) 					#style: #default ) 				#(#{UI.LabelSpec} 					#layout: #(#{Core.Point} 10 272 ) 					#name: #Label2 					#label: 'Generate C Stubs' 					#style: #default ) 				#(#{UI.MenuButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 275 0 -10 1 300 0 ) 					#name: #MenuButton1 					#model: #bitsForStubCode 					#menu: #bitsForStubChoices ) ) ) )</body></methods><methods><class-id>Tools.ComAutomationWizardIDLGenPage class</class-id> <category>resources</category><body package="Com- Automation Development">typelibraryLCIDMenu	"Tools.MenuEditor new openOnClass: self andSelector: #typelibraryLCIDMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #USEnglish 					#defaultString: 'US English' 					#catalogID: #com ) 				#value: 1033 ) 			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #Neutral 					#defaultString: 'Neutral' 					#catalogID: #com ) 				#value: 0 ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ComAutomationWizard class</class-id> <category>resources</category><body package="Com- Automation Development">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 				#(#{Kernel.UserMessage} 					#key: #_File 					#defaultString: '&amp;File' 					#catalogID: #menus ) 				#submenu: #(#{UI.Menu} #(						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_LoadDot 								#defaultString: '&amp;Load...' 								#catalogID: #menus ) 							#value: #importAllSettings 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #fileOpen ) ) 						#(#{UI.MenuItem} 							#rawLabel: 							#(#{Kernel.UserMessage} 								#key: #_SaveDot 								#defaultString: '&amp;Save...' 								#catalogID: #menus ) 							#value: #exportSettings 							#labelImage: #(#{UI.ResourceRetriever} #{Tools.ToolbarIconLibrary} #fileSave ) ) ) #(2 ) nil ) ) ) #(1 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.ComAutomationWizard class</class-id> <category>interface specs</category><body package="Com- Automation Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #comAutomationWizard 				#defaultString: 'COM Automation Wizard' 				#catalogID: #com ) 			#min: #(#{Core.Point} 450 330 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 640 500 1240 990 ) 			#flags: 4 			#menu: #menuBar ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.TreeViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 10 0 130 0 -45 1 ) 					#name: #TreeView 					#flags: 15 					#model: #pageListHolder 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#valueChangeSelector: #updateButtons ) 					#menu: #pageTreeMenu 					#useModifierKeys: true 					#selectionType: #highlight 					#displayStringSelector: #label 					#useIcons: #other 					#iconSelectors: #(#listIcon ) 					#rootExpander: true ) 				#(#{UI.ResizingSplitterSpec} 					#layout: #(#{Graphics.LayoutFrame} 132 0 5 0 138 0 -45 1 ) 					#name: #ResizingSplitter1 					#horizontal: false 					#minAboveSize: 30 					#minBelowSize: 30 					#aboveWidgets: 'TreeView' 					#belowWidgets: 'Subcanvas GroupBox' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 140 0 10 0 -10 1 -45 1 ) 					#name: #GroupBox ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -330 1 -35 1 -250 1 -10 1 ) 					#name: #backButton 					#model: #prevPage 					#label: 					#(#{Kernel.UserMessage} 						#key: #back 						#defaultString: '&lt;&lt; Back' 						#catalogID: #com ) 					#isDefault: false 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -245 1 -35 1 -165 1 -10 1 ) 					#name: #nextButton 					#model: #nextPage 					#label: 					#(#{Kernel.UserMessage} 						#key: #next 						#defaultString: 'Next &gt;&gt;' 						#catalogID: #com ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -160 1 -35 1 -90 1 -10 1 ) 					#name: #applyButton 					#flags: 56 					#model: #applyPressed 					#helpText: 					#(#{Kernel.UserMessage} 						#key: #SettingsManagerApplyButton 						#defaultString: 'Apply the yet unapplied settings without closing this window.' 						#catalogID: #labels ) 					#label: 					#(#{Kernel.UserMessage} 						#key: #_Apply 						#defaultString: '&amp;Apply' 						#catalogID: #labels ) 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -80 1 -35 1 -10 1 -10 1 ) 					#name: #helpButton 					#model: #helpPressed 					#helpText: '' 					#label: 					#(#{Kernel.UserMessage} 						#key: #AmpHelp 						#defaultString: '&amp;Help' 						#catalogID: #labels ) 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 160 0 35 0 -20 1 -55 1 ) 					#name: #Subcanvas 					#flags: 1 ) ) ) )</body></methods><methods><class-id>Tools.ComAutomationWizardRegFileSettings class</class-id> <category>settings</category><body package="Com- Automation Development">activeXOn	&lt;setting: #(#regSetting #activeXOn)&gt;	^(BooleanSetting on: true asValue)		default: true</body><body package="Com- Automation Development">automationOn	&lt;setting: #(#regSetting #automationOn)&gt;	^(BooleanSetting on: true asValue)		default: true</body><body package="Com- Automation Development">objectDescription	&lt;setting: #(#regSetting #objectDescription)&gt;	| defaultMessage |	defaultMessage := (#SpecifyADescriptor &lt;&lt; #com &gt;&gt; 'Specify a Descriptor') asString.	^(StringSetting on: defaultMessage asValue)		default: defaultMessage</body><body package="Com- Automation Development">progID	&lt;setting: #(#regSetting #progID)&gt;	| defaultMessage |	defaultMessage := (#SetAnApplicationApplication &lt;&lt; #com &gt;&gt; 'SetAnApplication.Application') asString.	^(StringSetting on: defaultMessage asValue)		default: defaultMessage</body><body package="Com- Automation Development">versionNumber	&lt;setting: #(#regSetting #versionNumber)&gt;	^(NumberSetting on: 1.0 asValue)		default: 1.0</body></methods><methods><class-id>Tools.COMEventTraceViewer class</class-id> <category>interface specs</category><body package="Com- Automation Development">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 			#(#{Kernel.UserMessage} 				#key: #EventTraceViewer 				#defaultString: 'COM Event Trace Viewer' 				#catalogID: #com ) 			#bounds: #(#{Graphics.Rectangle} 800 600 1241 1004 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ArbitraryComponentSpec} 					#layout: #(#{Graphics.LayoutFrame} 8 0 32 0 -8 1 -8 1 ) 					#name: #traceLogPane 					#flags: 9 					#component: #traceLogComponent ) 				#(#{UI.CheckBoxSpec} 					#layout: #(#{Core.Point} 10 7 ) 					#name: #enableTracingCheckBox 					#model: #enableTracing 					#label: 					#(#{Kernel.UserMessage} 						#key: #enabletracing 						#defaultString: 'enable tracing' 						#catalogID: #com ) )				#(#ActionButtonSpec 					#layout: #(#LayoutOrigin -126 1 3 0 ) 					#name: #describeEventsButton 					#model: #describeEvents 					#label: 					#(#{Kernel.UserMessage} 						#key: #DescribeEvents 						#defaultString:  'Describe Events' 						#catalogID: #com )					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualWorksSettings class</class-id> <category>settings-com</category><body package="Com- Automation Development">com03SpecificationPolicy	&lt;setting: #(com specificationPolicy)&gt;	^(self policySettingType on: COMSpecificationPolicy aspect: #defaultPolicy)		default: #newVariantPolicy;		label: #DefaultSpecificationPolicy &lt;&lt; #com &gt;&gt; 'Default Specification Policy';		helpText: #DefaultSpecificationPolicyHelp &lt;&lt; #com &gt;&gt; 'The dispatch driver uses the specification policy instance to dynamically create specifications for methods and properties the dispatch driver''s specification table does not know about.  The Default Policy is set to the Variant policy by the system.'</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Com- Automation Development">comOpenAutomationWizard	"Open the Automation Publishing Wizard. "	&lt;menuItem: #(#OpenTheAutomationWizardDot #com 'Open the Automation Wizard...')		nameKey: nil		menu: #(#menuBar #tools #comc)		position: 10.05&gt;	self applicationForClassNamed: #{ComAutomationWizard} do: [:class| class open]</body></methods><initialize><class-id>External.IDispatchTraceAdaptor</class-id></initialize><initialize><class-id>External.COMAutomationTypeAnalyzer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SettingsDomain</name><environment>Tools</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cachedSettings cachedPages unappliedSnapshots </inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>Tools-Settings</category><attributes><package>Tools-Settings</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>SettingsManagerPage</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>manager id position label icon children definingMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>SettingsManager</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>triggerChannel pageListHolder domainHolder rootPage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Settings-UI</category><attributes><package>Tools-Settings</package></attributes></class><class><name>EventEnabledApplicationModel</name><environment>UI</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Interface-Event Extensions</category><attributes><package>Com- Event-Enabled Application Extensions</package></attributes></class><class><name>IUnknownTraceAdaptor</name><environment>External</environment><super>External.COMInterfaceTraceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>assumeHRESULTReturnValues </inst-vars><class-inst-vars></class-inst-vars><imports>			External.GUID.*			</imports><category>COM-Trace Support</category><attributes><package>Com- Ole Development</package></attributes></class></st-source>