<?xml version="1.0"?><st-source><!-- Name: Com- OleNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.DbIdentifier: bear73DbTrace: 500171DbUsername: alexDbVersion: 8.3 - 4DevelopmentPrerequisites: #(#(#any 'Com- CodeAnnotations' '') #(#any 'Com- External Data Enhancements' '') #(#any 'Com- Interface Adaptors' '') #(#any 'Com- Ole Pools' '') #(#any 'Com- System Configuration Services' '') #(#any 'Com- Win32' '') #(#any 'DLLCC' '') #(#any 'Com- ExtensionsToBase' '') #(#any 'Com- Win32 Pools' '') #(#any 'DLLCC-Decompiler' ''))DialectVersion: VisualWorks 7.9DisregardedPrerequisites: #()PackageName: Com- OleParcel: #('ComOle')ParcelName: Com- OlePrerequisiteDescriptions: #(#(#name 'Com- CodeAnnotations') #(#name 'Com- External Data Enhancements') #(#name 'Com- Interface Adaptors') #(#name 'Com- Ole Pools') #(#name 'Com- System Configuration Services') #(#name 'Com- Win32') #(#name 'DLLCC' #applicability #store) #(#name 'Com- ExtensionsToBase' #componentType #package) #(#name 'Com- Win32 Pools' #componentType #package) #(#name 'DLLCC-Decompiler' #componentType #package))PrerequisiteParcels: #(#('Com- CodeAnnotations' '') #('Com- External Data Enhancements' '') #('Com- Interface Adaptors' '') #('Com- Ole Pools' '') #('Com- System Configuration Services' '') #('Com- Win32' '') #('Com- ExtensionsToBase' '') #('Com- Win32 Pools' '') #('DLLCC-Decompiler' ''))PrintStringCache: (8.3 - 4,alex)Version: 8.3 - 4Post-Load Block: 	[:package | 	COMExternalMethod installExternalPlugin]Pre-Unload Block: 	[:package | 	COMExternalMethod removeExternalPlugin]Date: 1:50:03 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:03</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AdviseInfo</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>formatEtc flags sink key </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMWarning</name><environment>External</environment><super>Core.UserNotification</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMDevelopmentWarning</name><environment>External</environment><super>External.COMWarning</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceBinding</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>iid </class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMExternalInterface</name><environment>External</environment><super>External.Win32ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			private External.COMExternalInterfaceDictionary.*			</imports><category>COM-Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>COMInterfacePointer</name><environment>External</environment><super>External.COMInterfaceBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfaceAddress isMTAObject </inst-vars><class-inst-vars>vtableDescription </class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknownPointer</name><environment>External</environment><super>External.COMInterfacePointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IRunningObjectTablePointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMResultNotification</name><environment>External</environment><super>Core.Notification</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hresult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interface </inst-vars><class-inst-vars>iid </class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknown</name><environment>External</environment><super>External.COMInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMStorageElementInterface</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name container </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IStream</name><environment>External</environment><super>External.COMStorageElementInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMStructure</name><environment>External</environment><super>External.Win32Structure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.CConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COM_FILETIME</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersist</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistStream</name><environment>External</environment><super>External.IPersist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IMoniker</name><environment>External</environment><super>External.IPersistStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COM_OLEVERB</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IGlobalInterfaceTable</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			COMExternalInterfaceDictionary.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.IGlobalInterfaceTable</class-id><body>### Provide a brief explanation of the IGlobalInterfaceTable interface ####</body></comment><class><name>COMObject</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>controllingUnknown innerUnknown referenceCount </inst-vars><class-inst-vars>clsid </class-inst-vars><imports>			External.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMEnumeratorObject</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enumeratorIID elements bufferElementType currentIndex iEnum </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMStringEnumerator</name><environment>External</environment><super>External.COMEnumeratorObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>IAdviseSink</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IAdviseSink2</name><environment>External</environment><super>External.IAdviseSink</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMReadWriteStream</name><environment>OS</environment><super>OS.ExternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream encoding </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Storage Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COM_STATDATA</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceImplementation</name><environment>External</environment><super>External.COMInterfaceBinding</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfacePointer implementor </inst-vars><class-inst-vars>vtableSignatureTypeName vtable vtableSelectors </class-inst-vars><imports>			External.CConstants.*			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknownImplementation</name><environment>External</environment><super>External.COMInterfaceImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referenceCount </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IRunnableObjectImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.IRunnableObjectImplementation</class-id><body>Instances of the receiver provide the host-level external callback binding for the IRunnableObject interface.</body></comment><class><name>COMLicenseInfo</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>runtimeKeyAvailable licenseVerified </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistFile</name><environment>External</environment><super>External.IPersist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistStreamImplementation</name><environment>External</environment><super>External.IPersistImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COM_DVTARGETDEVICE</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IRootStorage</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IClassFactory</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars>clsid </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfacePointerResultBuffer</name><environment>External</environment><super>External.Win32PointerResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfacePointerClass iid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IDataObjectPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>GlobalInterfaceTable</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>staInstance mtaInstance </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.GlobalInterfaceTable</class-id><body>GlobalInterfaceTable is an interface for accessing Microsoft's GlobalIntefaceTable implementation. It is used for marshaling interfaces between apartmentsin a simple way.Instance Variables	mtaInstance	&lt;IGlobalInterfaceTable&gt;	the IGlobalInteface tagle interface living in the MTA	staInstance	&lt;IGlobalInterfaceTable&gt;	the IGlobalInteface tagle interface living in the STA (main thread)</body></comment><class><name>COM_FORMATETC</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			External.Win32Constants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IAnonymousPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMWorkerProcess</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>workerProcess startSemaphore endSemaphore resultValue workBlock myException </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.COMWorkerProcess</class-id><body>COMWorkerProcess is a class which manages a process which is used to channel calls to specific COM apartments. Instance Variables	endSemaphore	&lt;Semaphore&gt;			Semaphore signaled by the worker process to signal that it finished its work.	myException	&lt;GenericException&gt;		the exception which appeared during work	resultValue		&lt;Object&gt;				the result value of the evaluation	startSemaphore	&lt;Semaphore&gt;			Semaphore signaled to inform the process that he should start working	workBlock		&lt;BlockClosure&gt;			a block of work to be done in the process	workerProcess	&lt;Process&gt;				the process that does the work</body></comment><class><name>COMExternalAccessFailed</name><environment>External</environment><super>External.ExternalAccessFailed</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>Com- Ole</package></attributes></class><class><name>IStreamPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMDataRendering</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>formatEtc value valueBlock </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMGlobalMemoryStream</name><environment>External</environment><super>External.IStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.Win32Constants.*			</imports><category>COM-Storage Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceAdaptor</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>implementor vtableSelectors </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceFunctionAdaptor</name><environment>External</environment><super>External.COMInterfaceAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>eventTable </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>ILockBytes</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IDataObject</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			External.Win32Constants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IDataObjectImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMMultiQIResultBuffer</name><environment>External</environment><super>External.Win32ArrayResultBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iidList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IMallocPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>AdviseSink</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token iAdviseSink source </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.AdviseSink</class-id><body>AdviseSink is a Serverobject which receives notifications from the COM object in Certain situations. Instance Variables	iAdviseSink	&lt;IAdviseSink&gt;	the IAdviseSink interface	token			&lt;Object&gt;			the token got from the serverobject needed to unregister </body></comment><class><name>IStoragePointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMSessionManager</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>traceManager </class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>IClassFactoryImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IRootStoragePointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMMemoryAddressResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IStorage</name><environment>External</environment><super>External.COMStorageElementInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMGlobalMemoryStorage</name><environment>External</environment><super>External.IStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iLockBytes </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.Win32Constants.*			</imports><category>COM-Storage Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COM_OBJECTDESCRIPTOR</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IAnonymous</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid specificationTable </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.IAnonymous</class-id><body>IAnonymous is a generic placeholder for any com interface for which no specific implementation exists in the image. It will try to lookup the interface definitions from typelibraries to be able to perform calls.Instance Variables	iid					&lt;GUID&gt;								my interface id	specificationTable	&lt;COMVTableSpecificationTable&gt;		a description of my entrypoints</body></comment><class><name>IDataAdviseHolder</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMRegistryInterface</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMDynamicLinkLibrary</name><environment>External</environment><super>External.COMExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMDynamicLinkLibraryDictionary.*			</imports><category>COM-Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>COMPlatformProvider</name><environment>External</environment><super>External.COMDynamicLinkLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pendingCallouts pendingCallins </inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMDynamicLinkLibraryDictionary.*			ArgKinds.*			private External.COMPlatformProviderDictionary.*			</imports><category>COM-Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>X64COMInterface</name><environment>External</environment><super>External.COMPlatformProvider</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private External.X64COMInterfaceDictionary.*			</imports><category></category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>MultiThreadedCOMLib.dll</item></libraryFiles><libraryDirectories><item>C:\Projekte\COM ARs\63193\20070327 full\MultiThreadedCOMLib_2007_03_27-2\MultiThreadedCOMLib\Debug</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>IAdviseSinkImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMError</name><environment>Core</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hresult </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>IBindCtxPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IEnumPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMErrorReporter</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>exception context errorFilePath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistStorageImplementation</name><environment>External</environment><super>External.IPersistImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMClassFactoryObject</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectClass iClassFactory registrationToken registeredUnknown lockCount releaseIfNotInUse </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>IEnum</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid elementSpecification elementClass bufferElementType elementUnpackingSelector </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>GUIDResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknownInnerImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceVTableSignatures</name><environment>External</environment><super>External.COMExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private External.COMInterfaceVTableSignaturesDictionary.*			</imports><category>COM-Development Support</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>IBindCtx</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IClassFactoryPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IAdviseSinkPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceValueReference</name><environment>External</environment><super>External.ValueReference</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>IAdviseSink2Pointer</name><environment>External</environment><super>External.IAdviseSinkPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COM_STATSTG</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistFileImplementation</name><environment>External</environment><super>External.IPersistImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IUnknownAdaptor</name><environment>External</environment><super>External.COMInterfaceFunctionAdaptor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMStructurePointerResultBuffer</name><environment>External</environment><super>External.Win32StructurePointerResultBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IGlobalInterfaceTableImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.IGlobalInterfaceTableImplementation</class-id><body>Instances of the receiver provide the host-level external callback binding for the IGlobalInterfaceTable interface.</body></comment><class><name>COMMemoryAddress</name><environment>External</environment><super>External.Win32MemoryAddress</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>IParseDisplayNamePointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IGlobalInterfaceTablePointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.IGlobalInterfaceTablePointer</class-id><body>Instances of the receiver provide the host-level external callout binding for the IGlobalInterfaceTable interface.</body></comment><class><name>COMExternalVTable</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>vtableDescription callbackSelectors interfaceClass callbacks vTablePointer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMDecompiler</name><environment>Kernel</environment><super>Kernel.ExternalDecompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>Kernel.COMDecompiler</class-id><body>COMDecompiler is a decompiler for COMExternalMethods.</body></comment><class><name>IParseDisplayNameImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMSharedMemoryAddress</name><environment>External</environment><super>External.COMMemoryAddress</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMCompoundFile</name><environment>External</environment><super>External.IStorage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Storage Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMDataTransferObject</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iDataObject formats advises </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMStructureEnumerator</name><environment>External</environment><super>External.COMEnumeratorObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMEntryPointDescription</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name selector vtableIndex signatureType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><class><name>IRunnableObjectPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.IRunnableObjectPointer</class-id><body>Instances of the receiver provide the host-level external callout binding for the IRunnableObject interface.</body></comment><class><name>IParseDisplayName</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMCOSERVERINFOBuffer</name><environment>External</environment><super>External.Win32ArgumentBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IEnumImplementation</name><environment>External</environment><super>External.IUnknownImplementation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMCallOutError</name><environment>External</environment><super>Core.COMError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfaceEnumerator</name><environment>External</environment><super>External.COMEnumeratorObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-COM Objects</category><attributes><package>Com- Ole</package></attributes></class><class><name>GITCookie</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>iid handle </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-Host Binding Framework</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.GITCookie</class-id><body>GITCookie is a cookie used with glable interface tables. It is required since storage and retrieval of interfaces requires to know two values,the handle and the iid of the stored interface.Instance Variables	handle	&lt;Integer&gt;	The handle used to retrieve the stored interface again.	iid	&lt;GUID&gt;			The IID of the interface stored</body></comment><class><name>GUIDPointerResultBuffer</name><environment>External</environment><super>External.Win32PointerResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.GUIDPointerResultBuffer</class-id><body>GUIDPointerResultBuffer is a buffer class which is used for returning GUID pointers, that is parameters of type GUID **.</body></comment><class><name>IDataAdviseHolderPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistStreamInitPointer</name><environment>External</environment><super>External.IPersistPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COM_STGMEDIUM</name><environment>External</environment><super>External.COMStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars>backingStoreInterface iUnknown </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			External.Win32Constants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistStorage</name><environment>External</environment><super>External.IPersist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>IRunningObjectTable</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMGUIDArrayBuffer</name><environment>External</environment><super>External.Win32ArgumentBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistFilePointer</name><environment>External</environment><super>External.IPersistPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IMalloc</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>sharedMemoryAllocator taskMemoryAllocator </class-inst-vars><imports>			External.COMConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>OLEDLL</name><environment>External</environment><super>External.COMDynamicLinkLibrary</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mode </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			private External.OLEDLLDictionary.*			</imports><category>COM-Host Bindings</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>ole32.dll</item></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><class><name>COMUnicodeStringPointerResultBuffer</name><environment>External</environment><super>External.Win32UnicodeStringPointerResultBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMInterfacePointerArrayResultBuffer</name><environment>External</environment><super>External.Win32ArrayResultBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfacePointerClass iid </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>ILockBytesPointer</name><environment>External</environment><super>External.IUnknownPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMSNBBuffer</name><environment>External</environment><super>External.Win32UnicodePointerListBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistStreamPointer</name><environment>External</environment><super>External.IPersistPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IMonikerPointer</name><environment>External</environment><super>External.IPersistStreamPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMObjectWithInterfaceStorage</name><environment>External</environment><super>External.COMObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>interfaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- Ole</package></attributes></class><class><name>IPersistStreamInit</name><environment>External</environment><super>External.IPersist</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interfaces</category><attributes><package>Com- Ole</package></attributes></class><class><name>COMThreadManager</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.COMThreadManager</class-id><body>COMThreadManager manages the pool of threads used to perform threaded COM calls.</body></comment><class><name>IPersistStoragePointer</name><environment>External</environment><super>External.IPersistPointer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Host Bindings</category><attributes><package>Com- Ole</package></attributes></class><class><name>IRunnableObject</name><environment>External</environment><super>External.IUnknown</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			External.COMStatusCodeConstants.*			</imports><category>COM-Interface Binding Prototypes</category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.IRunnableObject</class-id><body>### Provide a brief explanation of the IRunnableObject interface ####</body></comment><class><name>COMCreationOptions</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>threaded controllingUnknown licenseKey iid iids specification clsid platform serverName context </inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMConstants.*			</imports><category></category><attributes><package>Com- Ole</package></attributes></class><comment><class-id>External.COMCreationOptions</class-id><body>COMCreationOptions contains all possible options for creating a com object. It can be passed to IClassFactory&gt;CreateInstanceWithOptions:, COMClient and COMDispatchDriver createInstanceWithOptions: calls, ILicenseManager instance creation methods as well as Class factory creation methods (e.g. IClassFactory class&gt;forClsID:).Instance Variables:	clsid					&lt;GUID | String&gt;		clsid or progid of object to create	context				&lt;Integer&gt;			class creation context	controllingUnknown		&lt;IUnknown&gt;			controlling IUnknown interface in case of aggregation	iid					&lt;GUID&gt;				requested interface Id	iids					&lt;Array of GUID&gt;		requested interface IDs if several interfaces are requested	licenseKey			&lt;String&gt;				licenseKey for creating the object (if required)	platform				&lt;Symbol&gt;			Determine whether 32 or 64 bit server is created	serverName			&lt;String&gt;				description of serverName	specification			&lt;COMDispatchSpecificationTable | COMSpecificaiontPolicy&gt;												(automation instance creation only) specification table or policy for dispatch drivers	threaded				&lt;Boolean&gt;			Determines whether a threaded Object shall be created.We can group the options in three categories, which are used in certain situationsFactory options ------------------------... are only used when creating class factories (or when internally creating a class factory to be able to create an instance).- factory options are: clsid, licenseKey, threadedServer options ------------------------... affect the place, where com objects or class factories are created. They are only used as long with methods which allow to specify this.These options are usually used for class side methods which create class factories explicitely or internally. They are ignored by references to objectswhich already run on a specific server, e.g. ILicenseManager and IClassFactory instances (when creating com object instances).- server options are:			context, platform, serverNameInstance options------------------------... are passed to factorys to create com object instances. They may determine the Interface IID to be returned, whether we want a threaded object or if you want to use aggregation. Factory objects are instances of IClassFactory and ILicenseManager.- instance options are:		controllingUnknown, iid | iids, licenseKey, (specification), threadedSpecial options ------------------------- The "specification" attribute is only used when creating dispatch drivers.- The "threaded" attribute can be used when creating class factories as well as when creating instances. Threaded interfaces do not have to be marshaled  in threaded calls (in MTA) but in normal ones. Marshaling is done automatically but affects the performance. Here is a list of attributes which are supported by the respective class and methodIClassFactory, class factory creation:			server and factory optionsIClassFactory, class side object creation:			all options; server, factory and instance options (excl. specification)IClassFactory, instance side object creation:		instance optionsILicenseManager instance creation methods:		factory and instance optionsILicenseManager COMClient creation				factory and instance optionsILicenseManager DispatchDriver creation			factory and instance options (incl. specification)COMDispatchDriver instance creation				all options; server, factory and instance options (incl. specification)COMClient instance creation					all options; server, factory and instance options (excl. specification)</body></comment><class><name>X86COMInterface</name><environment>External</environment><super>External.COMPlatformProvider</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.ThreadedCOMLibDictionary.*			private External.X86COMInterfaceDictionary.*			</imports><category>COM-Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles><item>MultiThreadedCOMLib.dll</item></libraryFiles><libraryDirectories><item>$(COM)</item></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Ole</package></attributes></class><shared-variable><name>ExitIfNotInUse</name><environment>External.COMClassFactoryObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>ActiveObjectsRegistry</name><environment>External.COMClassFactoryObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>LockCount</name><environment>External.COMClassFactoryObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>ClassFactoryRegistry</name><environment>External.COMClassFactoryObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>ElementTypeMap</name><environment>External.IEnum</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>CLSCTX_ACTIVATE_64_BIT_SERVER</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>constants</category><initializer>16r80000</initializer><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>CLSCTX_ACTIVATE_32_BIT_SERVER</name><environment>External.COMConstants</environment><private>false</private><constant>true</constant><category>constants</category><initializer>16r40000</initializer><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>DesiredMode</name><environment>External.COMSystem</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>FactoryClassWithLicensingSupport</name><environment>External.IClassFactory</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>WriteErrorsToFile</name><environment>External.COMErrorReporter</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>DescriptionDepth</name><environment>External.COMErrorReporter</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>IIDMap</name><environment>External.COMInterfacePointer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>COMExternalInterfaceDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>COMPlatformProviderDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>OLEDLLDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>X86COMInterfaceDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>COMDynamicLinkLibraryDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>COMInterfaceVTableSignaturesDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>X64COMInterfaceDictionary</name><environment>External</environment><private>false</private><constant>false</constant><category>external dictionaries</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>SpecialSessionResources</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>SavedResources</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>RegistrationCandidates</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>Set new</initializer><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>DefaultLCIDInitializer</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>nil</initializer><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>OwnedMemoryRegistry</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>DefaultCOMDirectory</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>OwnedInterfacesRegistry</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>AllocatedInterfacesRegistry</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>DefaultLocaleID</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>IsCOMAvailable</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>IsDCOMEnabled</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>IsFreeThreadingAvailable</name><environment>External.COMSessionManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>DefaultMetaFileClass</name><environment>External.IDataObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>RenderingActionMap</name><environment>External.IDataObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>DefaultBitmapClass</name><environment>External.IDataObject</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>CallbackCreationTable</name><environment>External.COMExternalVTable</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>ErrorNames</name><environment>Kernel.SystemError</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>TypeNames</name><environment>External.IMoniker</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>AccessLock</name><environment>External.COMThreadManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>RunningProcesses</name><environment>External.COMThreadManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>ReservedSTAProcesses</name><environment>External.COMThreadManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>ReservedMTAProcesses</name><environment>External.COMThreadManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>MTAFinalizationSemaphore</name><environment>External.COMThreadManager</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>AlreadyRaised</name><environment>External.COMDevelopmentWarning</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>RenderingActionMap</name><environment>External.COMDataRendering</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>RenderingMediumMap</name><environment>External.COMDataRendering</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>RenderingNameMap</name><environment>External.COMDataRendering</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>UserFormatNames</name><environment>External.COMDataRendering</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>VTableSignaturesPool</name><environment>External.COMInterfaceImplementation</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>Current</name><environment>External.GlobalInterfaceTable</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>PlatformProvider</name><environment>External.COMPlatformProvider</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>ForceDLLUsage</name><environment>External.COMPlatformProvider</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>false</initializer><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>ThreadedCallback</name><environment>External.COMPlatformProvider</environment><private>false</private><constant>false</constant><category>Threaded Callback</category><initializer></initializer><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>StructureNameSynonyms</name><environment>External.COMStructure</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><shared-variable><name>StructureNameMap</name><environment>External.COMStructure</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- Ole</package></attributes></shared-variable><methods><class-id>External.IUnknownPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeAddRef	"Invoke the IUnknown::AddRef function. "	" ULONG AddRef( void); "	&lt;COM: ULONG __stdcall  AddRef(void) = 1&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeQueryInterface: riid _: ppvObject	" Private - invoke the IUnknown::QueryInterface function. "	" HRESULT QueryInterface(		/* [in] */ REFIID riid,		/* [out] */ void **ppvObject); "	&lt;COM: HRESULT __stdcall  QueryInterface(const IID * const riid, void * * ppvObject) = 0&gt;   ^self externalAccessFailedWith: _errorCode		allowHRESULT: E_NOINTERFACE.</body><body package="Com- Ole">invokeRelease	"Private - invoke the IUnknown::Release function. "	" ULONG Release( void); "	&lt;COM: ULONG __stdcall  Release(void) = 2&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetClassID: pClassID	" Private - invoke the IPersist::GetClassID function. "	" HRESULT GetClassID(            /* [out] */ CLSID *pClassID); "	&lt;COM: HRESULT __stdcall  GetClassID(CLSID * pClassID) = 3&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IRunningObjectTablePointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeEnumRunning: ppenumMoniker	" Private - invoke the IRunningObjectTable::EnumRunning function. "	" HRESULT EnumRunning(            /* [out] */ IEnumMoniker **ppenumMoniker); "	&lt;COM: HRESULT __stdcall  EnumRunning(IEnumMoniker * * ppenumMoniker) = 9&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetObject: pmkObjectName _: ppunkObject	" Private - invoke the IRunningObjectTable::GetObject function. "	" HRESULT GetObject(            /* [unique][in] */ IMoniker *pmkObjectName,            /* [out] */ IUnknown **ppunkObject); "	&lt;COM: HRESULT __stdcall  GetObject(IMoniker * pmkObjectName, IUnknown * * ppunkObject) = 6&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: MK_E_UNAVAILABLE  " object is not registered as running "</body><body package="Com- Ole">invokeGetTimeOfLastChange: pmkObjectName _: pfiletime	" Private - invoke the IRunningObjectTable::GetTimeOfLastChange function. "	" HRESULT GetTimeOfLastChange(            /* [unique][in] */ IMoniker *pmkObjectName,            /* [out] */ FILETIME *pfiletime); "	&lt;COM: HRESULT __stdcall  GetTimeOfLastChange(IMoniker * pmkObjectName, FILETIME * pfiletime) = 8&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: MK_E_UNAVAILABLE  " object is not registered as running "</body><body package="Com- Ole">invokeIsRunning: pmkObjectName	" Private - invoke the IRunningObjectTable::IsRunning function. "	" HRESULT IsRunning(            /* [unique][in] */ IMoniker *pmkObjectName); "	&lt;COM: HRESULT __stdcall  IsRunning(IMoniker * pmkObjectName) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeNoteChangeTime: dwRegister _: pfiletime	" Private - invoke the IRunningObjectTable::NoteChangeTime function. "	" HRESULT NoteChangeTime(            /* [in] */ DWORD dwRegister,            /* [in] */ FILETIME *pfiletime); "	&lt;COM: HRESULT __stdcall  NoteChangeTime(DWORD dwRegister, FILETIME * pfiletime) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeRegister: grfFlags _: punkObject _: pmkObjectName _: pdwRegister	" Private - invoke the IRunningObjectTable::Register function. "	" HRESULT Register(            /* [in] */ DWORD grfFlags,            /* [unique][in] */ IUnknown *punkObject,            /* [unique][in] */ IMoniker *pmkObjectName,            /* [out] */ DWORD *pdwRegister); "	&lt;COM: HRESULT __stdcall  Register(DWORD grfFlags, IUnknown * punkObject, IMoniker * pmkObjectName, DWORD * pdwRegister) = 3&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IRunningObjectTablePointer</class-id> <category>interface operations</category><body package="Com- Ole">Revoke: dwRegister		" Invoke the IRunningObjectTable::Revoke function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Revoke(            /* [in] */ DWORD dwRegister); "	&lt;COM: HRESULT __stdcall  Revoke(DWORD dwRegister) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IDataObjectPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeDAdvise: pformatetc _: advf _: pAdvSink _: pdwConnection	" Private - invoke the IDataObject::DAdvise function. "	" HRESULT DAdvise(            /* [in] */ FORMATETC *pformatetc,            /* [in] */ DWORD advf,            /* [unique][in] */ IAdviseSink *pAdvSink,            /* [out] */ DWORD *pdwConnection); "	&lt;COM: HRESULT __stdcall  DAdvise(FORMATETC * pformatetc, DWORD advf, IAdviseSink * pAdvSink, DWORD * pdwConnection) = 9&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeEnumDAdvise: ppenumAdvise	" Private - invoke the IDataObject::EnumDAdvise function. "	" HRESULT EnumDAdvise(            /* [out] */ IEnumSTATDATA **ppenumAdvise); "	&lt;COM: HRESULT __stdcall  EnumDAdvise(IEnumSTATDATA * * ppenumAdvise) = 11&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeEnumFormatEtc: dwDirection _: ppenumFormatEtc	" Private - invoke the IDataObject::EnumFormatEtc function. " 	" HRESULT EnumFormatEtc(            /* [in] */ DWORD dwDirection,            /* [out] */ IEnumFORMATETC **ppenumFormatEtc); "	&lt;COM: HRESULT __stdcall  EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC * * ppenumFormatEtc) = 8&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetCanonicalFormatEtc: pformatectIn _: pformatetcOut	" Private - invoke the IDataObject::GetCanonicalFormatEtc function. "	" HRESULT GetCanonicalFormatEtc(            /* [unique][in] */ FORMATETC *pformatectIn,            /* [out] */ FORMATETC *pformatetcOut); "	&lt;COM: HRESULT __stdcall  GetCanonicalFormatEtc(FORMATETC * pformatectIn, FORMATETC * pformatetcOut) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetData: pformatetcIn _: pmedium	" Private - invoke the IDataObject::GetData function. "	" HRESULT GetData(            /* [unique][in] */ FORMATETC *pformatetcIn,            /* [out] */ STGMEDIUM *pmedium); "	&lt;COM: HRESULT __stdcall  GetData(FORMATETC * pformatetcIn, STGMEDIUM * pmedium) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetDataHere: pformatetc _: pmedium	" Private - Invoke the IDataObject::GetDataHere function. "	" HRESULT GetDataHere(            /* [unique][in] */ FORMATETC *pformatetc,            /* [out][in] */ STGMEDIUM *pmedium); "	&lt;COM: HRESULT __stdcall  GetDataHere(FORMATETC * pformatetc, STGMEDIUM * pmedium) = 4&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeQueryGetData: pformatetc	" Private - Invoke the IDataObject::QueryGetData function. "	" HRESULT QueryGetData(            /* [unique][in] */ FORMATETC *pformatetc); "	&lt;COM: HRESULT __stdcall  QueryGetData(FORMATETC * pformatetc) = 5&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: DATA_E_FORMATETC</body><body package="Com- Ole">invokeSetData: pformatetc _: pmedium _: fRelease	" Private - Invoke the IDataObject::SetData function. "	" HRESULT SetData(            /* [unique][in] */ FORMATETC *pformatetc,            /* [unique][in] */ STGMEDIUM *pmedium,            /* [in] */ BOOL fRelease); "	&lt;COM: HRESULT __stdcall  SetData(FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease) = 7&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IDataObjectPointer</class-id> <category>interface operations</category><body package="Com- Ole">DUnadvise: dwConnection		" Invoke the IDataObject::DUnadvise function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT DUnadvise(            /* [in] */ DWORD dwConnection); "	&lt;COM: HRESULT __stdcall  DUnadvise(DWORD dwConnection) = 10&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IStreamPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeClone: ppstm	" Private - invoke the IStream::Clone function. "	" HRESULT Clone(            /* [out] */ IStream **ppstm); "	&lt;COM: HRESULT __stdcall  Clone(IStream * * ppstm) = 13&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCopyTo: pstm _: cb _: pcbRead _: pcbWritten	" Private - invoke the IStream::CopyTo function. "	" HRESULT CopyTo(            /* [unique][in] */ IStream *pstm,            /* [in] */ ULARGE_INTEGER cb,            /* [out] */ ULARGE_INTEGER *pcbRead,            /* [out] */ ULARGE_INTEGER *pcbWritten); "	&lt;COM: HRESULT __stdcall  CopyTo(IStream * pstm, ULARGE_INTEGER cb, ULARGE_INTEGER * pcbRead, ULARGE_INTEGER * pcbWritten) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeLockRegion: libOffset _: cb _: dwLockType	" Private - invoke the IStream::LockRegion function. "	" HRESULT LockRegion(            /* [in] */ ULARGE_INTEGER libOffset,            /* [in] */ ULARGE_INTEGER cb,            /* [in] */ DWORD dwLockType); "	&lt;COM: HRESULT __stdcall  LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) = 10&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeRead: pv _: cb _: pcbRead	" Private - invoke the IStream::Read function. "	" HRESULT Read(            /* [out] */ void *pv,            /* [in] */ ULONG cb,            /* [out] */ ULONG *pcbRead); "	&lt;COM: HRESULT __stdcall  Read(void * pv, ULONG cb, ULONG * pcbRead) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSeek: dlibMove _: dwOrigin _: plibNewPosition	" Private - invoke the IStream::Seek function. "	" HRESULT Seek(            /* [in] */ LARGE_INTEGER dlibMove,            /* [in] */ DWORD dwOrigin,            /* [out] */ ULARGE_INTEGER *plibNewPosition); "	&lt;COM: HRESULT __stdcall  Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * plibNewPosition) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSetSize: libNewSize	" Private - invoke the IStream::SetSize function. "	" HRESULT SetSize(            /* [in] */ ULARGE_INTEGER libNewSize); "	&lt;COM: HRESULT __stdcall  SetSize(ULARGE_INTEGER libNewSize) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStat: pstatstg _: grfStatFlag	" Private - invoke the IStream::Stat function. "	" HRESULT Stat(            /* [out] */ STATSTG *pstatstg,            /* [in] */ DWORD grfStatFlag); "	&lt;COM: HRESULT __stdcall  Stat(STATSTG * pstatstg, DWORD grfStatFlag) = 12&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeUnlockRegion: libOffset _: cb _: dwLockType	" Private - invoke the IStream::UnlockRegion function. "	" HRESULT UnlockRegion(            /* [in] */ ULARGE_INTEGER libOffset,            /* [in] */ ULARGE_INTEGER cb,            /* [in] */ DWORD dwLockType); "	&lt;COM: HRESULT __stdcall  UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) = 11&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeWrite: pv _: cb _: pcbWritten	" Private - invoke the IStream::Write function. "	" HRESULT Write(            /* [size_is][in] */ const void *pv,            /* [in] */ ULONG cb,            /* [out] */ ULONG *pcbWritten); "	&lt;COM: HRESULT __stdcall  Write(const void * pv, ULONG cb, ULONG * pcbWritten) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IStreamPointer</class-id> <category>interface operations</category><body package="Com- Ole">Commit: grfCommitFlags		" Invoke the IStream::Commit function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Commit(            /* [in] */ DWORD grfCommitFlags); "	&lt;COM: HRESULT __stdcall  Commit(DWORD grfCommitFlags) = 8&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">Revert		" Invoke the IStream::Revert function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Revert( void); "	&lt;COM: HRESULT __stdcall  Revert(void) = 9&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IMallocPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeAlloc: cb	" Private -  Invoke the IMalloc::Alloc function "	" void *Alloc(            /* [in] */ ULONG cb); "	&lt;COM: void *  __stdcall  Alloc(ULONG cb) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeDidAlloc: pv	" Private - invoke the IMalloc::DidAlloc function. "	" int DidAlloc(            void *pv); "	&lt;COM: int __stdcall  DidAlloc(void * pv) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeFree: pv	" Private - invoke the IMalloc::Free function. "	" void Free(            /* [in] */ void *pv); "	&lt;COM: void __stdcall  Free(void * pv) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetSize: pv	" Private - invoke the IMalloc::GetSize function. "	" ULONG GetSize(            /* [in] */ void *pv); "	&lt;COM: ULONG __stdcall  GetSize(void * pv) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeRealloc: pv _: cb	" Private - invoke the IMalloc::Realloc function. "	" void *Realloc(            /* [in] */ void *pv,            /* [in] */ ULONG cb); "	&lt;COM: void *  __stdcall  Realloc(void * pv, ULONG cb) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IMallocPointer</class-id> <category>interface operations</category><body package="Com- Ole">HeapMinimize	" Invoke the IMalloc::HeapMinimize function. "	" void HeapMinimize( void)"	&lt;COM: void __stdcall  HeapMinimize(void) = 8&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IStoragePointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeCopyTo: ciidExclude _: rgiidExclude _: snbExclude _: pstgDest	" Private - invoke the IStorage::CopyTo function. "	" HRESULT CopyTo(            /* [in] */ DWORD ciidExclude,            /* [size_is][unique][in] */ const IID *rgiidExclude,            /* [unique][in] */ SNB snbExclude,            /* [unique][in] */ IStorage *pstgDest); "	&lt;COM: HRESULT __stdcall  CopyTo(DWORD ciidExclude, const IID * rgiidExclude, SNB snbExclude, IStorage * pstgDest) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateStorage: pwcsName _: grfMode _: dwStgFmt _: reserved2 _: ppstg	" Private - invoke the IStorage::CreateStorage function. "	" HRESULT CreateStorage(            /* [string][in] */ const OLECHAR *pwcsName,            /* [in] */ DWORD grfMode,            /* [in] */ DWORD dwStgFmt,            /* [in] */ DWORD reserved2,            /* [out] */ IStorage **ppstg); "	&lt;COM: HRESULT __stdcall  CreateStorage(const OLECHAR * pwcsName, DWORD grfMode, DWORD dwStgFmt, DWORD reserved2, IStorage * * ppstg) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateStream: pwcsName _: grfMode _: reserved1 _: reserved2 _: ppstm	" Private - invoke the IStorage::CreateStream function. "	" HRESULT CreateStream(            /* [string][in] */ const OLECHAR *pwcsName,            /* [in] */ DWORD grfMode,            /* [in] */ DWORD reserved1,            /* [in] */ DWORD reserved2,            /* [out] */ IStream **ppstm); "	&lt;COM: HRESULT __stdcall  CreateStream(const OLECHAR * pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream * * ppstm) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeDestroyElement: pwcsName	" Private - invoke the IStorage::DestroyElement function. "	" HRESULT DestroyElement(            /* [string][in] */ const OLECHAR *pwcsName); "	&lt;COM: HRESULT __stdcall  DestroyElement(const OLECHAR * pwcsName) = 12&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeEnumElements: reserved1 _: reserved2 _: reserved3 _: ppenum	" Private - invoke the IStorage::EnumElements function. "	" HRESULT EnumElements(            /* [in] */ DWORD reserved1,            /* [size_is][unique][in] */ void *reserved2,            /* [in] */ DWORD reserved3,            /* [out] */ IEnumSTATSTG **ppenum); "	&lt;COM: HRESULT __stdcall  EnumElements(DWORD reserved1, void * reserved2, DWORD reserved3, IEnumSTATSTG * * ppenum) = 11&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeMoveElementTo: pwcsName _: pstgDest _: pwcsNewName _: grfFlags	" Private - invoke the IStorage::MoveElementTo function. "	" HRESULT MoveElementTo(            /* [string][in] */ const OLECHAR *pwcsName,            /* [unique][in] */ IStorage *pstgDest,            /* [string][in] */ const OLECHAR *pwcsNewName,            /* [in] */ DWORD grfFlags); "	&lt;COM: HRESULT __stdcall  MoveElementTo(const OLECHAR * pwcsName, IStorage * pstgDest, const OLECHAR * pwcsNewName, DWORD grfFlags) = 8&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOpenStorage: pwcsName _: pstgPriority _: grfMode _: snbExclude _: reserved _: ppstg	" Private - invoke the IStorage::OpenStorage function. "	" HRESULT OpenStorage(            /* [string][unique][in] */ const OLECHAR *pwcsName,            /* [unique][in] */ IStorage *pstgPriority,            /* [in] */ DWORD grfMode,            /* [unique][in] */ SNB snbExclude,            /* [in] */ DWORD reserved,            /* [out] */ IStorage **ppstg); "	&lt;COM: HRESULT __stdcall  OpenStorage(const OLECHAR * pwcsName, IStorage * pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage * * ppstg) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOpenStream: pwcsName _: reserved1 _: grfMode  _: reserved2 _: ppstm	" Private - invoke the IStorage::OpenStream function. "	" HRESULT OpenStream(            /* [string][in] */ const OLECHAR *pwcsName,            /* [unique][in] */ void *reserved1,            /* [in] */ DWORD grfMode,            /* [in] */ DWORD reserved2,            /* [out] */ IStream **ppstm); "	&lt;COM: HRESULT __stdcall  OpenStream(const OLECHAR * pwcsName, void * reserved1, DWORD grfMode, DWORD reserved2, IStream * * ppstm) = 4&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeRenameElement: pwcsOldName _: pwcsNewName	" Private - invoke the IStorage::RenameElement function. "	" HRESULT RenameElement(            /* [string][in] */ const OLECHAR *pwcsOldName,            /* [string][in] */ const OLECHAR *pwcsNewName); "	&lt;COM: HRESULT __stdcall  RenameElement(const OLECHAR * pwcsOldName, const OLECHAR * pwcsNewName) = 13&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSetElementTimes: pwcsName _: pctime _: patime _: pmtime	" Private - invoke the IStorage::SetElementTimes function. "	" HRESULT SetElementTimes(            /* [string][in] */ const OLECHAR *pwcsName,            /* [in] */ const FILETIME *pctime,            /* [in] */ const FILETIME *patime,            /* [in] */ const FILETIME *pmtime); "	&lt;COM: HRESULT __stdcall  SetElementTimes(const OLECHAR * pwcsName, const FILETIME * pctime, const FILETIME * patime, const FILETIME * pmtime) = 14&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStat: pstatstg _: grfStatFlag	" Private - invoke the IStorage::Stat function. "	" HRESULT Stat(            /* [out] */ STATSTG *pstatstg,            /* [in] */ DWORD grfStatFlag); "	&lt;COM: HRESULT __stdcall  Stat(STATSTG * pstatstg, DWORD grfStatFlag) = 17&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IStoragePointer</class-id> <category>interface operations</category><body package="Com- Ole">Commit: grfCommitFlags		" Invoke the IStorage::Commit function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Commit(            /* [in] */ DWORD grfCommitFlags); "	&lt;COM: HRESULT __stdcall  Commit(DWORD grfCommitFlags) = 9&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">Revert		" Invoke the IStorage::Revert function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Revert( void); "	&lt;COM: HRESULT __stdcall  Revert(void) = 10&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">SetClass: clsid		" Invoke the IStorage::SetClass function.		Raise an exception if an error occurs.  Answer the result code. "	"HRESULT SetClass(            /* [in] */ REFCLSID clsid); "	&lt;COM: HRESULT __stdcall  SetClass(const CLSID * const clsid) = 15&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">SetStateBits: grfStateBits _: grfMask		" Invoke the IStorage::SetStateBits function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT SetStateBits(            /* [in] */ DWORD grfStateBits,            /* [in] */ DWORD grfMask); "	&lt;COM: HRESULT __stdcall  SetStateBits(DWORD grfStateBits, DWORD grfMask) = 16&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IRootStoragePointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeSwitchToFile: pszFile	" Private - invoke the IRootStorage::SwitchToFile function. "	" HRESULT SwitchToFile(            /* [string][in] */ LPOLESTR pszFile); "	&lt;COM: HRESULT __stdcall  SwitchToFile(LPOLESTR pszFile) = 3&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IEnumPointer</class-id> <category>interface operations</category><body package="Com- Ole">Reset	" Invoke the IEnum::Reset function.  Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Reset( void);"	&lt;COM: HRESULT __stdcall  Reset(void) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">Skip: celt	" Invoke the IEnum::Skip function.  Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Skip(            /* [in] */ ULONG celt);"	&lt;COM: HRESULT __stdcall  Skip(ULONG celt) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IEnumPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeClone: ppenum	" Private - invoke the IEnum::Clone function. "	" HRESULT Clone(            /* [out] */ IEnum **ppenum); "	&lt;COM: HRESULT __stdcall  Clone(IEnum * * ppenum) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeNext: celt _: rgelt _: pceltFetched	" Private - invoke the IEnum::Next function. "	" HRESULT Next(            /* [in] */ ULONG celt,            /* [out] */ void *rgelt,            /* [out] */ ULONG *pceltFetched); "	&lt;COM: HRESULT __stdcall  Next(ULONG celt, void * rgelt, ULONG * pceltFetched) = 3&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IClassFactoryPointer</class-id> <category>interface operations</category><body package="Com- Ole">LockServer: fLock		" Invoke the IClassFactory::LockServer function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT LockServer(            /* [in] */ BOOL fLock); "	&lt;COM: HRESULT __stdcall  LockServer(BOOL fLock) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IClassFactoryPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeCreateInstance: pUnkOuter _: riid _: ppvObject	" Private - invoke the IClassFactory::CreateInstance function. "	" HRESULT CreateInstance(            /* [unique][in] */ IUnknown *pUnkOuter,            /* [in] */ REFIID riid,            /* [out] */ void **ppvObject); "	&lt;COM: HRESULT __stdcall  CreateInstance(IUnknown * pUnkOuter, const IID * const riid, void * * ppvObject) = 3&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IAdviseSinkPointer</class-id> <category>interface operations</category><body package="Com- Ole">OnClose	" Invoke the IAdviseSink::OnClose function. "	" void OnClose( void); "	&lt;COM: void __stdcall  OnClose(void) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">OnSave	" Invoke the IAdviseSink::OnSave function. "	" void OnSave( void); "	&lt;COM: void __stdcall  OnSave(void) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">OnViewChange: dwAspect _: lindex	" Invoke the IAdviseSink::OnViewChange function. "	" void OnViewChange(            /* [in] */ DWORD dwAspect,            /* [in] */ LONG lindex);"	&lt;COM: void __stdcall  OnViewChange(DWORD dwAspect, LONG lindex) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IAdviseSinkPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeOnDataChange: pFormatetc _: pStgmed	" Private - Invoke the IAdviseSink::OnDataChange function. "	" void OnDataChange(            /* [unique][in] */ FORMATETC *pFormatetc,            /* [unique][in] */ STGMEDIUM *pStgmed); "	&lt;COM: void __stdcall  OnDataChange(FORMATETC * pFormatetc, STGMEDIUM * pStgmed) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOnRename: pmk	" Private - invoke the IAdviseSink::OnRename function. "	" void OnRename(            /* [in] */ IMoniker *pmk); "	&lt;COM: void __stdcall  OnRename(IMoniker * pmk) = 5&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IAdviseSink2Pointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeOnLinkSrcChange: pmk	" Private - invoke the IAdviseSink2::OnLinkSrcChange function. "	" void OnLinkSrcChange(            /* [unique][in] */ IMoniker *pmk); "	&lt;COM: void __stdcall  OnLinkSrcChange(IMoniker * pmk) = 8&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IParseDisplayNamePointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeParseDisplayName: pbc _: pszDisplayName _: pchEaten _: ppmkOut	" Private - invoke the IParseDisplayName::ParseDisplayName function. "	" HRESULT ParseDisplayName(            /* [unique][in] */ IBindCtx *pbc,            /* [in] */ LPOLESTR pszDisplayName,            /* [out] */ ULONG *pchEaten,            /* [out] */ IMoniker **ppmkOut); "	&lt;COM: HRESULT __stdcall  ParseDisplayName(IBindCtx * pbc, LPOLESTR pszDisplayName, ULONG * pchEaten, IMoniker * * ppmkOut) = 3&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IGlobalInterfaceTablePointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetInterfaceFromGlobal: dwCookie _: riid _: ppU	" Private - invoke the IGlobalInterfaceTable::GetInterfaceFromGlobal function. "	&lt;COM: HRESULT __stdcall  GetInterfaceFromGlobal(DWORD dwCookie, REFIID const riid, IUnknown * * ppU) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeRegisterInterfaceInGlobal: pUnk _: riid _: dwCookie	" Private - invoke the IGlobalInterfaceTable::RegisterInterfaceInGlobal function. "	&lt;COM: HRESULT __stdcall  RegisterInterfaceInGlobal(IUnknown * pUnk, REFIID riid, DWORD * dwCookie) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeRevokeInterfaceFromGlobal: dwCookie	" Private - invoke the IGlobalInterfaceTable::RevokeInterfaceFromGlobal function. "	&lt;COM: HRESULT __stdcall  RevokeInterfaceFromGlobal(DWORD dwCookie) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IRunnableObjectPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetRunningClass: lpClsid	" Private - invoke the IRunnableObject::GetRunningClass function. "	&lt;COM: HRESULT __stdcall  GetRunningClass(LPCLSID lpClsid) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeIsRunning	" Private - invoke the IRunnableObject::IsRunning function. "	&lt;COM: BOOL __stdcall  IsRunning(void) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeLockRunning: fLock _: fLastUnlockCloses	" Private - invoke the IRunnableObject::LockRunning function. "	&lt;COM: HRESULT __stdcall  LockRunning(BOOL fLock, BOOL fLastUnlockCloses) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeRun: pbc	" Private - invoke the IRunnableObject::Run function. "	&lt;COM: HRESULT __stdcall  Run(LPBINDCTX pbc) = 4&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSetContainedObject: fContained	" Private - invoke the IRunnableObject::SetContainedObject function. "	&lt;COM: HRESULT __stdcall  SetContainedObject(BOOL fContained) = 7&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IDataAdviseHolderPointer</class-id> <category>interface operations</category><body package="Com- Ole">Unadvise: dwConnection		" Invoke the IDataAdviseHolder::Unadvise function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Unadvise(            /* [in] */ DWORD dwConnection);"	&lt;COM: HRESULT __stdcall  Unadvise(DWORD dwConnection) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IDataAdviseHolderPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeAdvise: pDataObject _: pFetc _: advf _: pAdvise _: pdwConnection	" Private - invoke the IDataAdviseHolder::Advise function. "	" HRESULT Advise(            /* [unique][in] */ IDataObject *pDataObject,            /* [unique][in] */ FORMATETC *pFetc,            /* [in] */ DWORD advf,            /* [unique][in] */ IAdviseSink *pAdvise,            /* [out] */ DWORD *pdwConnection); "	&lt;COM: HRESULT __stdcall  Advise(IDataObject * pDataObject, FORMATETC * pFetc, DWORD advf, IAdviseSink * pAdvise, DWORD * pdwConnection) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeEnumAdvise: ppenumAdvise	" Private - invoke the IDataAdviseHolder::EnumAdvise function. "	" HRESULT EnumAdvise(            /* [out] */ IEnumSTATDATA **ppenumAdvise); "	&lt;COM: HRESULT __stdcall  EnumAdvise(IEnumSTATDATA * * ppenumAdvise) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSendOnDataChange: pDataObject _: dwReserved _: advf	" Private - invoke the IDataAdviseHolder::Advise function. "	" HRESULT SendOnDataChange(            /* [unique][in] */ IDataObject *pDataObject,            /* [in] */ DWORD dwReserved,            /* [in] */ DWORD advf); "	&lt;COM: HRESULT __stdcall  SendOnDataChange(IDataObject * pDataObject, DWORD dwReserved, DWORD advf) = 6&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistStreamInitPointer</class-id> <category>interface operations</category><body package="Com- Ole">InitNew		" Invoke the IPersistStreamInit::InitNew function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT InitNew( void);"	&lt;COM: HRESULT __stdcall  InitNew(void) = 8&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">IsDirty		" Invoke the IPersistStreamInit::IsDirty function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT IsDirty( void);"	&lt;COM: HRESULT __stdcall  IsDirty(void) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistStreamInitPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetSizeMax: pcbSize	" Private - invoke the IPersistStreamInit::GetSizeMax function. "	" HRESULT GetSizeMax(            /* [out] */ ULARGE_INTEGER *pcbSize); "	&lt;COM: HRESULT __stdcall  GetSizeMax(ULARGE_INTEGER * pcbSize) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeLoad: pStm	" Private - invoke the IPersistStreamInit::Load function. "	" HRESULT Load(            /* [unique][in] */ IStream *pStm); "	&lt;COM: HRESULT __stdcall  Load(LPSTREAM pStm) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSave: pStm _: fClearDirty	" Private - invoke the IPersistStreamInit::Save function. "	" HRESULT Save(            /* [unique][in] */ IStream *pStm,            /* [in] */ BOOL fClearDirty); "	&lt;COM: HRESULT __stdcall  Save(LPSTREAM pStm, BOOL fClearDirty) = 6&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistFilePointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetCurFile: ppszFileName	" Private - invoke the IPersistFile::GetCurFile function. "	" HRESULT GetCurFile(            /* [out] */ LPOLESTR *ppszFileName); "	&lt;COM: HRESULT __stdcall  GetCurFile(LPOLESTR * ppszFileName) = 8&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeLoad: pszFileName _: dwMode	" Private - invoke the IPersistFile::Load function. "	" HRESULT Load(            /* [in] */ LPCOLESTR pszFileName,            /* [in] */ DWORD dwMode); "	&lt;COM: HRESULT __stdcall  Load(LPCOLESTR pszFileName, DWORD dwMode) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSave: pszFileName _: fRemember	" Private - invoke the IPersistFile::Save function. "	" HRESULT Save(            /* [unique][in] */ LPCOLESTR pszFileName,            /* [in] */ BOOL fRemember); "	&lt;COM: HRESULT __stdcall  Save(LPCOLESTR pszFileName, BOOL fRemember) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSaveCompleted: pszFileName	" Private - invoke the IPersistFile::SaveCompleted function. "	" HRESULT SaveCompleted(            /* [unique][in] */ LPCOLESTR pszFileName); "	&lt;COM: HRESULT __stdcall  SaveCompleted(LPCOLESTR pszFileName) = 7&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistFilePointer</class-id> <category>interface operations</category><body package="Com- Ole">IsDirty		" Invoke the IPersistFile::IsDirty function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT IsDirty( void); "	&lt;COM: HRESULT __stdcall  IsDirty(void) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.ILockBytesPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeLockRegion: libOffset _: cb _: dwLockType	" Private - invoke the ILockBytes::LockRegion function. "	" HRESULT LockRegion(            /* [in] */ ULARGE_INTEGER libOffset,            /* [in] */ ULARGE_INTEGER cb,            /* [in] */ DWORD dwLockType); "	&lt;COM: HRESULT __stdcall  LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeReadAt: ulOffset _: pv _: cb _: pcbRead	" Private - invoke the ILockBytes::ReadAt function. "	" HRESULT ReadAt(            /* [in] */ ULARGE_INTEGER ulOffset,            /* [in] */ void *pv,            /* [in] */ ULONG cb,            /* [out] */ ULONG *pcbRead); "	&lt;COM: HRESULT __stdcall  ReadAt(ULARGE_INTEGER ulOffset, void * pv, ULONG cb, ULONG * pcbRead) = 3&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSetSize: cb	" Private - invoke the ILockBytes::SetSize function. "	" HRESULT SetSize(            /* [in] */ ULARGE_INTEGER cb);  "	&lt;COM: HRESULT __stdcall  SetSize(ULARGE_INTEGER cb) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStat: pstatstg _: grfStatFlag	" Private - invoke the ILockBytes::Stat function. "	" HRESULT Stat(            /* [out] */ STATSTG *pstatstg,            /* [in] */ DWORD grfStatFlag); "	&lt;COM: HRESULT __stdcall  Stat(STATSTG * pstatstg, DWORD grfStatFlag) = 9&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeUnlockRegion: libOffset _: cb _: dwLockType	" Private - invoke the ILockBytes::UnlockRegion function. "	" HRESULT UnlockRegion(            /* [in] */ ULARGE_INTEGER libOffset,            /* [in] */ ULARGE_INTEGER cb,            /* [in] */ DWORD dwLockType); "	&lt;COM: HRESULT __stdcall  UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) = 8&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeWriteAt: ulOffset _: pv _: cb _: pcbWritten	" Private - invoke the ILockBytes::WriteAt function. "	" HRESULT WriteAt(            /* [in] */ ULARGE_INTEGER ulOffset,            /* [in] */ const void *pv,            /* [in] */ ULONG cb,            /* [out] */ ULONG *pcbWritten); "	&lt;COM: HRESULT __stdcall  WriteAt(ULARGE_INTEGER ulOffset, const void * pv, ULONG cb, ULONG * pcbWritten) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.ILockBytesPointer</class-id> <category>interface operations</category><body package="Com- Ole">Flush		" Invoke the ILockBytes::Flush function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT Flush( void); "	&lt;COM: HRESULT __stdcall  Flush(void) = 5&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistStreamPointer</class-id> <category>interface operations</category><body package="Com- Ole">IsDirty		" Invoke the IPersistStream::IsDirty function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT IsDirty( void);"	&lt;COM: HRESULT __stdcall  IsDirty(void) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistStreamPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetSizeMax: pcbSize	" Private - invoke the IPersistStream::GetSizeMax function. "	" HRESULT GetSizeMax(            /* [out] */ ULARGE_INTEGER *pcbSize); "	&lt;COM: HRESULT __stdcall  GetSizeMax(ULARGE_INTEGER * pcbSize) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeLoad: pStm	" Private - invoke the IPersistStream::Load function. "	" HRESULT Load(            /* [unique][in] */ IStream *pStm); "	&lt;COM: HRESULT __stdcall  Load(IStream * pStm) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSave: pStm _: fClearDirty	" Private - invoke the IPersistStream::Save function. "	" HRESULT Save(            /* [unique][in] */ IStream *pStm,            /* [in] */ BOOL fClearDirty); "	&lt;COM: HRESULT __stdcall  Save(IStream * pStm, BOOL fClearDirty) = 6&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IMonikerPointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeBindToObject: pbc _: pmkToLeft _: riidResult _: ppvResult	" Private - invoke the IMoniker::BindToObject function. "	" HRESULT BindToObject(            /* [unique][in] */ IBindCtx *pbc,            /* [unique][in] */ IMoniker *pmkToLeft,            /* [in] */ REFIID riidResult,            /* [out] */ void **ppvResult); "	&lt;COM: HRESULT __stdcall  BindToObject(IBindCtx * pbc, IMoniker * pmkToLeft, const IID * const riidResult, void * * ppvResult) = 8&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeBindToStorage: pbc _: pmkToLeft _: riid _: ppvObj	" Private - invoke the IMoniker::BindToStorage function. "	" HRESULT BindToStorage(            /* [unique][in] */ IBindCtx *pbc,            /* [unique][in] */ IMoniker *pmkToLeft,            /* [in] */ REFIID riid,            /* [out] */ void **ppvObj); "	&lt;COM: HRESULT __stdcall  BindToStorage(IBindCtx * pbc, IMoniker * pmkToLeft, const IID * const riid, void * * ppvObj) = 9&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCommonPrefixWith: pmkOther _: ppmkPrefix	" Private - invoke the IMoniker::CommonPrefixWith function. "	" HRESULT CommonPrefixWith(            /* [unique][in] */ IMoniker *pmkOther,            /* [out] */ IMoniker **ppmkPrefix); "	&lt;COM: HRESULT __stdcall  CommonPrefixWith(IMoniker * pmkOther, IMoniker * * ppmkPrefix) = 18&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: MK_E_NOPREFIX</body><body package="Com- Ole">invokeComposeWith: pmkRight _: fOnlyIfNotGeneric _: ppmkComposite	" Private - invoke the IMoniker::ComposeWith function. "	" HRESULT ComposeWith(            /* [unique][in] */ IMoniker *pmkRight,            /* [in] */ BOOL fOnlyIfNotGeneric,            /* [out] */ IMoniker **ppmkComposite); "	&lt;COM: HRESULT __stdcall  ComposeWith(IMoniker * pmkRight, BOOL fOnlyIfNotGeneric, IMoniker * * ppmkComposite) = 11&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeEnum: fForward _: ppenumMoniker	" Private - invoke the IMoniker::Enum function. "	" HRESULT Enum(            /* [in] */ BOOL fForward,            /* [out] */ IEnumMoniker **ppenumMoniker); "	&lt;COM: HRESULT __stdcall  Enum(BOOL fForward, IEnumMoniker * * ppenumMoniker) = 12&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetDisplayName: pbc _: pmkToLeft _: ppszDisplayName	" Private - invoke the IMoniker::GetDisplayName function. "	" HRESULT GetDisplayName(            /* [unique][in] */ IBindCtx *pbc,            /* [unique][in] */ IMoniker *pmkToLeft,            /* [out] */ LPOLESTR *ppszDisplayName); "	&lt;COM: HRESULT __stdcall  GetDisplayName(IBindCtx * pbc, IMoniker * pmkToLeft, LPOLESTR * ppszDisplayName) = 20&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetTimeOfLastChange: pbc _:  pmkToLeft _: pFileTime	" Private - invoke the IMoniker::GetTimeOfLastChange function. "	" HRESULT GetTimeOfLastChange(            /* [unique][in] */ IBindCtx *pbc,            /* [unique][in] */ IMoniker *pmkToLeft,            /* [out] */ FILETIME *pFileTime); "	&lt;COM: HRESULT __stdcall  GetTimeOfLastChange(IBindCtx * pbc, IMoniker * pmkToLeft, FILETIME * pFileTime) = 16&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeHash: pdwHash	" Private - invoke the IMoniker::Hash function. "	" HRESULT Hash(            /* [out] */ DWORD *pdwHash); "	&lt;COM: HRESULT __stdcall  Hash(DWORD * pdwHash) = 14&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeInverse: ppmk	" Private - invoke the IMoniker::Inverse function. "	" HRESULT Inverse(            /* [out] */ IMoniker **ppmk); "	&lt;COM: HRESULT __stdcall  Inverse(IMoniker * * ppmk) = 17&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: MK_E_NOINVERSE</body><body package="Com- Ole">invokeIsEqual: pmkOtherMoniker	" Private - invoke the IMoniker::IsEqual function. "	" HRESULT IsEqual(            /* [unique][in] */ IMoniker *pmkOtherMoniker); "	&lt;COM: HRESULT __stdcall  IsEqual(IMoniker * pmkOtherMoniker) = 13&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeIsRunning: pbc _:  pmkToLeft _: pmkNewlyRunning	" Private - invoke the IMoniker::IsRunning function. "	" HRESULT IsRunning(            /* [unique][in] */ IBindCtx *pbc,            /* [unique][in] */ IMoniker *pmkToLeft,            /* [unique][in] */ IMoniker *pmkNewlyRunning); "	&lt;COM: HRESULT __stdcall  IsRunning(IBindCtx * pbc, IMoniker * pmkToLeft, IMoniker * pmkNewlyRunning) = 15&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeIsSystemMoniker: pdwMksys	" Private - invoke the IMoniker::IsSystemMoniker function. "	" HRESULT IsSystemMoniker(            /* [out] */ DWORD *pdwMksys); "	&lt;COM: HRESULT __stdcall  IsSystemMoniker(DWORD * pdwMksys) = 22&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeParseDisplayName: pbc _: pmkToLeft _: pszDisplayName _: pchEaten _: ppmkOut	" Private - invoke the IMoniker::ParseDisplayName function. "	" HRESULT ParseDisplayName(            /* [unique][in] */ IBindCtx *pbc,            /* [unique][in] */ IMoniker *pmkToLeft,            /* [in] */ LPOLESTR pszDisplayName,            /* [out] */ ULONG *pchEaten,            /* [out] */ IMoniker **ppmkOut); "	&lt;COM: HRESULT __stdcall  ParseDisplayName(IBindCtx * pbc, IMoniker * pmkToLeft, LPOLESTR pszDisplayName, ULONG * pchEaten, IMoniker * * ppmkOut) = 21&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeReduce: pbc _: dwReduceHowFar _: ppmkToLeft _: ppmkReduced	"Private - invoke the IMoniker::Reduce function. "	" HRESULT Reduce(            /* [unique][in] */ IBindCtx *pbc,            /* [in] */ DWORD dwReduceHowFar,            /* [unique][out][in] */ IMoniker **ppmkToLeft,            /* [out] */ IMoniker **ppmkReduced); "	&lt;COM: HRESULT __stdcall  Reduce(IBindCtx * pbc, DWORD dwReduceHowFar, IMoniker * * ppmkToLeft, IMoniker * * ppmkReduced) = 10&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeRelativePathTo: pmkOther _: ppmkRelPath	" Private - invoke the IMoniker::RelativePathTo function. "	" HRESULT RelativePathTo(            /* [unique][in] */ IMoniker *pmkOther,            /* [out] */ IMoniker **ppmkRelPath); "	&lt;COM: HRESULT __stdcall  RelativePathTo(IMoniker * pmkOther, IMoniker * * ppmkRelPath) = 19&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistStoragePointer</class-id> <category>interface operations</category><body package="Com- Ole">HandsOffStorage		" Invoke the IPersistStorage::HandsOffStorage function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT HandsOffStorage( void); "	&lt;COM: HRESULT __stdcall  HandsOffStorage(void) = 9&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">IsDirty	    " Invoke the IPersistStorage::IsDirty function.		Raise an exception if an error occurs.  Answer the result code. "	" HRESULT IsDirty( void);"	&lt;COM: HRESULT __stdcall  IsDirty(void) = 4&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.IPersistStoragePointer</class-id> <category>private-invocation</category><body package="Com- Ole">invokeInitNew: pStg	" Private - invoke the IPersistStorage::InitNew function. "	" HRESULT InitNew(            /* [unique][in] */ IStorage *pStg); "	&lt;COM: HRESULT __stdcall  InitNew(IStorage * pStg) = 5&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeLoad: pStg	" Private - invoke the IPersistStorage::Load function. "	"  HRESULT Load(            /* [unique][in] */ IStorage *pStg); "	&lt;COM: HRESULT __stdcall  Load(IStorage * pStg) = 6&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSave: pStgSave _: fSameAsLoad	" Private - invoke the IPersistStorage::Save function. "	" HRESULT Save(            /* [unique][in] */ IStorage *pStgSave,            /* [in] */ BOOL fSameAsLoad); "	&lt;COM: HRESULT __stdcall  Save(IStorage * pStgSave, BOOL fSameAsLoad) = 7&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSaveCompleted: pStgNew	" Private - invoke the IPersistStorage::SaveCompleted function. "	" HRESULT SaveCompleted(            /* [unique][in] */ IStorage *pStgNew); "	&lt;COM: HRESULT __stdcall  SaveCompleted(IStorage * pStgNew) = 8&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-data object operations</category><body package="Com- Ole">invokeCreateDataAdviseHolder: ppDAHolder		"Private - WINOLEAPI CreateDataAdviseHolder(			LPDATAADVISEHOLDER FAR* ppDAHolder);"	&lt;C: HRESULT __stdcall  CreateDataAdviseHolder(LPDATAADVISEHOLDER * ppDAHolder)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateDataCache: pUnkOuter _: rclsid _: iid _: ppv		"Private - WINOLEAPI CreateDataCache(			LPUNKNOWN pUnkOuter, REFCLSID rclsid,			REFIID iid, LPVOID FAR* ppv);"	&lt;C: HRESULT __stdcall  CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid, REFIID iid, LPVOID * ppv)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleDraw: pUnknown _: dwAspect _: hdcDraw _: lprcBounds        "Private - WINOLEAPI          OleDraw (			LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw,			LPCRECT lprcBounds);"	&lt;C: HRESULT __stdcall  OleDraw(LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, LPCRECT lprcBounds)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleDuplicateData: hSrc _: cfFormat _: uiFlags		"Private - WINOLEAPI_(HANDLE) OleDuplicateData (                        HANDLE hSrc, CLIPFORMAT cfFormat,                        UINT uiFlags); "	&lt;C: HANDLE __stdcall  OleDuplicateData(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeReleaseStgMedium: aStgMedium		" Private - WINOLEAPI_(void)   ReleaseStgMedium(LPSTGMEDIUM); "	&lt;C: void __stdcall  ReleaseStgMedium(LPSTGMEDIUM)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-clipboard</category><body package="Com- Ole">invokeOleGetClipboard: ppDataObj        "Private - WINOLEAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj);"	&lt;C: HRESULT __stdcall  OleGetClipboard(LPDATAOBJECT * ppDataObj)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: CLIPBRD_E_BAD_DATA</body><body package="Com- Ole">invokeOleIsCurrentClipboard: pDataObj        "Private - WWINOLEAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj);"	&lt;C: HRESULT __stdcall  OleIsCurrentClipboard(LPDATAOBJECT pDataObj)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleSetClipboard: pDataObj        "Private - WINOLEAPI  OleSetClipboard(LPDATAOBJECT pDataObj);"	&lt;C: HRESULT __stdcall  OleSetClipboard(LPDATAOBJECT pDataObj)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-FILETIME services</category><body package="Com- Ole">invokeCoDosDateTimeToFileTime: nDosDate _: nDosTime _: lpFileTime        "Private - WINOLEAPI_(BOOL) CoDosDateTimeToFileTime(                       WORD nDosDate, WORD nDosTime, FILETIME FAR* lpFileTime); "	&lt;C: BOOL __stdcall CoDosDateTimeToFileTime (WORD nDosDate, WORD nDosTime, FILETIME * lpFileTime)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoFileTimeNow: lpFileTime        "Private - WINOLEAPI  CoFileTimeNow( FILETIME FAR* lpFileTime ); "	&lt;C: HRESULT __stdcall CoFileTimeNow( FILETIME * lpFileTime )&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoFileTimeToDosDateTime: lpFileTime _: lpDosDate _: lpDosTime        "Private - WINOLEAPI_(BOOL) CoFileTimeToDosDateTime(                 FILETIME FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime); "	&lt;C: BOOL __stdcall CoFileTimeToDosDateTime(FILETIME * lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-monikers</category><body package="Com- Ole">invokeBindMoniker: pmk _: grfOpt _:iidResult _: ppvResult        "Private - WINOLEAPI  BindMoniker(			LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);"	&lt;C: HRESULT __stdcall  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID * ppvResult)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateAntiMoniker: ppmk        "Private - WINOLEAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk); "	&lt;C: HRESULT __stdcall  CreateAntiMoniker(LPMONIKER * ppmk)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateBindCtx: reserved _: ppbc        "Private - WINOLEAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);"	&lt;C: HRESULT __stdcall  CreateBindCtx(DWORD reserved, LPBC * ppbc)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateFileMoniker: lpszPathName _: ppmk        "Private - WINOLEAPI  CreateFileMoniker(			LPCOLESTR lpszPathName, LPMONIKER FAR* ppmk);"	&lt;C: HRESULT __stdcall  CreateFileMoniker(LPCOLESTR lpszPathName, LPMONIKER * ppmk)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateGenericComposite: pmkFirst _: pmkRest _: ppmkComposite        "Private - WINOLEAPI  CreateGenericComposite(			LPMONIKER pmkFirst, LPMONIKER pmkRest,			LPMONIKER FAR* ppmkComposite);"	&lt;C: HRESULT __stdcall  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest, LPMONIKER * ppmkComposite)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateItemMoniker: lpszDelim _: lpszItem _: ppmk        "Private -WINOLEAPI  CreateItemMoniker(			LPCOLESTR lpszDelim, LPCOLESTR lpszItem,			LPMONIKER FAR* ppmk);"	&lt;C: HRESULT __stdcall  CreateItemMoniker(LPCOLESTR lpszDelim, LPCOLESTR lpszItem, LPMONIKER * ppmk)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreatePointerMoniker: punk _: ppmk        "Private - WINOLEAPI  CreatePointerMoniker(                LPUNKNOWN punk, LPMONIKER FAR* ppmk); "	&lt;C: HRESULT __stdcall  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER * ppmk)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetRunningObjectTable: reserved _: pprot        "Private - WINOLEAPI  GetRunningObjectTable(               DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot); "	&lt;C: HRESULT __stdcall  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE * pprot)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeMkParseDisplayName: pbc _: szUserName _: pchEaten _: ppmk        "Private - WINOLEAPI  MkParseDisplayName(				LPBC pbc, LPCOLESTR szUserName,				ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);"	&lt;C: HRESULT __stdcall  MkParseDisplayName(LPBC pbc, LPCOLESTR szUserName, ULONG * pchEaten, LPMONIKER * ppmk)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeMonikerCommonPrefixWith: pmkThis _: pmkOther _: ppmkCommon        "Private - WINOLEAPI  MonikerCommonPrefixWith(                LPMONIKER pmkThis, LPMONIKER pmkOther,                LPMONIKER FAR* ppmkCommon) "	&lt;C: HRESULT __stdcall  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther, LPMONIKER * ppmkCommon)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: MK_E_NOPREFIX</body><body package="Com- Ole">invokeMonikerRelativePathTo: pmkSrc _: pmkDest _: ppmkRelPath _: dwReserved        "Private - WINOLEAPI  MonikerRelativePathTo(                LPMONIKER pmkSrc, LPMONIKER pmkDest,                 LPMONIKER FAR* ppmkRelPath, BOOL dwReserved); "	&lt;C: HRESULT __stdcall  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER * ppmkRelPath, BOOL dwReserved)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-icon extraction</category><body package="Com- Ole">invokeOleGetIconOfClass: rclsid _: lpszLabel _: fUseTypeAsLabel	" Private - WINOLEAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid,		     LPOLESTR lpszLabel,			BOOL fUseTypeAsLabel) "	&lt;C: HGLOBAL __stdcall  OleGetIconOfClass(const CLSID * const rclsid, LPOLESTR lpszLabel, BOOL fUseTypeAsLabel)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleGetIconOfFile: lpszPath _: fUseFileAsLabel	" Private - WINOLEAPI_(HGLOBAL) OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel)"	&lt;C: HGLOBAL __stdcall  OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleMetafilePictFromIconAndLabel: hIcon _: lpszLabel _: lpszSourceFile _: iIconIndex	" Private - WINOLEAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(			HICON hIcon, LPOLESTR lpszLabel,			LPOLESTR lpszSourceFile, UINT iIconIndex)"	&lt;C: HGLOBAL __stdcall  OleMetafilePictFromIconAndLabel(HICON hIcon, LPOLESTR lpszLabel, LPOLESTR lpszSourceFile, UINT iIconIndex)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-class factory</category><body package="Com- Ole">invokeCoCreateInstance: rclsid	_: pUnkOuter	_: dwClsContext	_: riid	_: ppv		"Private - WINOLEAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);"	&lt;C: HRESULT __stdcall  CoCreateInstance(const CLSID * const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID * const riid, LPVOID * ppv)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoCreateInstanceEx: rclsid	_: pUnkOuter	_: dwClsContext	_: pServerInfo	_: dwCount	_: pResults		"Private - 	WINOLEAPI CoCreateInstanceEx(	    REFCLSID                    Clsid,	    IUnknown    *               punkOuter, // only relevant locally	    DWORD                       dwClsCtx,	    COSERVERINFO *              pServerInfo,	    DWORD                       dwCount,	    MULTI_QI        *           pResults );"	&lt;C: HRESULT __stdcall  CoCreateInstanceEx(const CLSID * const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, COSERVERINFO * pServerInfo, DWORD dwCount, MULTI_QI * pResults)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoGetClassObject: rclsid    _: dwClsContext    _: pServerInfo    _: riid    _: ppv        "Private - WINOLEAPI  CoGetClassObject(                  REFCLSID rclsid, DWORD dwClsContext, COSERVERINFO * pServerInfo,                    REFIID riid, LPVOID * ppv); "	&lt;C: HRESULT __stdcall  CoGetClassObject(const CLSID * const rclsid, DWORD dwClsContext, COSERVERINFO * pServerInfo, const IID * const riid, LPVOID * ppv)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: E_NOINTERFACE</body><body package="Com- Ole">invokeCoRegisterClassObject: rclsid _: pUnk _: dwClsContext _: flags _: lpdwRegister        "Private - WINOLEAPI  CoRegisterClassObject(                    REFCLSID rclsid, LPUNKNOWN pUnk,                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister); "	&lt;C: HRESULT __stdcall  CoRegisterClassObject(const CLSID * const rclsid, LPUNKNOWN pUnk, DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoRevokeClassObject: dwRegister		" Notify COM that a class object previously registered with 		CoRegisterClassObject is no longer available.		Raise an exception if an error occurs.  Answer the result code. "	"WINOLEAPI  CoRevokeClassObject(DWORD dwRegister); "	&lt;C: HRESULT __stdcall  CoRevokeClassObject(DWORD dwRegister)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">threadedInvokeCoCreateInstance: rclsid	_: pUnkOuter	_: dwClsContext	_: riid	_: ppv		"Private - WINOLEAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);"	&lt;C: HRESULT __stdcall  __threaded CoCreateInstance(const CLSID * const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID * const riid, LPVOID * ppv)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">threadedInvokeCoCreateInstanceEx: rclsid	_: pUnkOuter	_: dwClsContext	_: pServerInfo	_: dwCount	_: pResults		"Private - 	WINOLEAPI CoCreateInstanceEx(	    REFCLSID                    Clsid,	    IUnknown    *               punkOuter, // only relevant locally	    DWORD                       dwClsCtx,	    COSERVERINFO *              pServerInfo,	    DWORD                       dwCount,	    MULTI_QI        *           pResults );"	&lt;C: HRESULT __stdcall  __threaded CoCreateInstanceEx(const CLSID * const rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, COSERVERINFO * pServerInfo, DWORD dwCount, MULTI_QI * pResults)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">threadedInvokeCoGetClassObject: rclsid    _: dwClsContext    _: pServerInfo    _: riid    _: ppv        "Private - WINOLEAPI  CoGetClassObject(                  REFCLSID rclsid, DWORD dwClsContext, COSERVERINFO * pServerInfo,                    REFIID riid, LPVOID * ppv); "	&lt;C: HRESULT __stdcall  __threaded CoGetClassObject(const CLSID * const rclsid, DWORD dwClsContext, COSERVERINFO * pServerInfo, const IID * const riid, LPVOID * ppv)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: E_NOINTERFACE</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-DLL operations</category><body package="Com- Ole">CoFreeAllLibraries		" Free all DLL's previously loaded by CoLoadLibrary , whether or		not they are currently in use. " 	" WINOLEAPI_(void) CoFreeAllLibraries(void); "	&lt;C: void __stdcall  CoFreeAllLibraries(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">CoFreeUnusedLibraries		" Notify the OLE implementation layer that it can free any DLL's 		previously loaded by CoLoadLibrary which are no longer used. " 	" WINOLEAPI_(void) CoFreeUnusedLibraries(void); "	&lt;C: void __stdcall  CoFreeUnusedLibraries(void)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-storage</category><body package="Com- Ole">invokeCreateILockBytesOnHGlobal: hGlobal _: fDeleteOnRelease _: pplkbyt		"Private - WINOLEAPI CreateILockBytesOnHGlobal (					HGLOBAL hGlobal, BOOL fDeleteOnRelease,					LPLOCKBYTES * pplkbyt);"	&lt;C: HRESULT __stdcall CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPLOCKBYTES * pplkbyt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCreateStreamOnHGlobal: hGlobal _: fDeleteOnRelease _: ppstm		"Private - WINOLEAPI CreateStreamOnHGlobal (					HGLOBAL hGlobal, BOOL fDeleteOnRelease,					LPSTREAM * ppstm);"	&lt;C: HRESULT __stdcall CreateStreamOnHGlobal(HGLOBAL, BOOL, IStream *)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetClassFile: szFilename _: pclsid		"Private - WINOLEAPI  GetClassFile (LPCOLESTR szFilename, CLSID FAR* pclsid);"	&lt;C: HRESULT __stdcall GetClassFile (LPCOLESTR szFilename, CLSID * pclsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetHGlobalFromILockBytes: plkbyt _: phglobal		"Private - WINOLEAPI GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL * phglobal);"	&lt;C: HRESULT __stdcall GetHGlobalFromILockBytes(LPLOCKBYTES plkbyt, HGLOBAL * phglobal)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeGetHGlobalFromStream: pstm _: phglobal		"Private - WINOLEAPI GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL * phglobal);"	&lt;C: HRESULT __stdcall GetHGlobalFromStream(LPSTREAM pstm, HGLOBAL * phglobal)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleSave: pPS _: pStg _: fSameAsLoad        "Private - WWINOLEAPI  OleSave(			LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);"    &lt;C: HRESULT __stdcall OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad)&gt;    ^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleSaveToStream: pPStm _: pStm        "Private - WINOLEAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm)"    &lt;C: HRESULT __stdcall OleSaveToStream(LPPERSISTSTREAM pPStm, LPSTREAM pStm)&gt;    ^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeReadClassStg: pStg _: pclsid		"Private - WINOLEAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid); "	&lt;C: HRESULT __stdcall  ReadClassStg(LPSTORAGE pStg, CLSID * pclsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeReadClassStm: pStm _: pclsid		"Private - WINOLEAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid); "	&lt;C: HRESULT __stdcall  ReadClassStm(LPSTREAM pStm, CLSID * pclsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeReadFmtUserTypeStg: pstg _: pcf _: lplpszUserType		"Private - WINOLEAPI ReadFmtUserTypeStg (                LPSTORAGE pstg, CLIPFORMAT FAR* pcf, LPOLESTR FAR* lplpszUserType); "	&lt;C: HRESULT __stdcall  ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT * pcf, LPOLESTR * lplpszUserType)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStgCreateDocfile: pwcsName _: grfMode _: reserved _: ppstgOpen		"Private - WINOLEAPI StgCreateDocfile(			const OLECHAR * pwcsName,			DWORD grfMode,			DWORD reserved,			IStorage * *ppstgOpen);"	&lt;C: HRESULT __stdcall  StgCreateDocfile(const OLECHAR * pwcsName,			DWORD grfMode,			DWORD reserved,			IStorage  * * ppstgOpen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStgCreateDocfileOnILockBytes: plkbyt _: grfMode _: reserved _: ppstgOpen		"Private - WINOLEAPI StgCreateDocfileOnILockBytes(						ILockBytes *plkbyt,                    DWORD grfMode,                    DWORD reserved,                    IStorage * *ppstgOpen);"	&lt;C: HRESULT __stdcall  StgCreateDocfileOnILockBytes(ILockBytes * plkbyt, DWORD grfMode, DWORD reserved, IStorage * * ppstgOpen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStgIsStorageFile: pwcsName		"Private - WINOLEAPI StgIsStorageFile(const OLECHAR * pwcsName);"	&lt;C: HRESULT __stdcall  StgIsStorageFile(const OLECHAR * pwcsName)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStgIsStorageILockBytes: plkbyt		"Private - WINOLEAPI StgIsStorageILockBytes(ILockBytes * plkbyt);"	&lt;C: HRESULT __stdcall  StgIsStorageILockBytes(ILockBytes * plkbyt)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStgOpenStorage: pwcsName _: pstgPriority _: grfMode _: snbExclude _: reserved _: ppstgOpen		"Private - WINOLEAPI StgOpenStorage(              const OLECHAR * pwcsName,              IStorage  *pstgPriority,              DWORD grfMode,              SNB snbExclude,              DWORD reserved,              IStorage  * *ppstgOpen);"	&lt;C: HRESULT __stdcall  StgOpenStorage(const OLECHAR * pwcsName,              IStorage *pstgPriority,              DWORD grfMode,              SNB snbExclude,              DWORD reserved,              IStorage * *ppstgOpen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStgOpenStorageOnILockBytes: plkbyt _: pstgPriority _: grfMode _: snbExclude _: reserved _: ppstgOpen		"Private - WINOLEAPI StgOpenStorageOnILockBytes(ILockBytes *plkbyt,                  IStorage *pstgPriority,                  DWORD grfMode,                  SNB snbExclude,                  DWORD reserved,                  IStorage * *ppstgOpen);"	&lt;C: HRESULT __stdcall  StgOpenStorageOnILockBytes(ILockBytes * plkbyt, IStorage * pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage * * ppstgOpen)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStgSetTimes: lpszName _: pctime _: patime _: pmtime		"Private - WINOLEAPI StgSetTimes(                   OLECHAR const * lpszName,                   FILETIME const * pctime,                   FILETIME const * patime,                   FILETIME const * pmtime);"	&lt;C: HRESULT __stdcall  StgSetTimes(OLECHAR const * lpszName,                   FILETIME const * pctime,                   FILETIME const * patime,                   FILETIME const * pmtime)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeWriteClassStg: pStg _: rclsid		"Private - WINOLEAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid); "	&lt;C: HRESULT __stdcall  WriteClassStg(LPSTORAGE pStg, const CLSID * const rclsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeWriteClassStm: pStm _: rclsid		"Private - WINOLEAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid); "	&lt;C: HRESULT __stdcall  WriteClassStm(LPSTREAM pStm, const CLSID * const rclsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeWriteFmtUserTypeStg: pstg _: cf _: lpszUserType		"Private - WINOLEAPI WriteFmtUserTypeStg (                  LPSTORAGE pstg, CLIPFORMAT cf, LPOLESTR lpszUserType); "	&lt;C: HRESULT __stdcall  WriteFmtUserTypeStg(LPSTORAGE pstg, CLIPFORMAT cf, LPOLESTR lpszUserType)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-registration database</category><body package="Com- Ole">invokeOleRegEnumFormatEtc: clsid _: dwDirection _: ppenum        "Private - WINOLEAPI OleRegEnumFormatEtc (                                REFCLSID clsid, DWORD dwDirection,                                LPENUMFORMATETC FAR* ppenum); "	&lt;C: HRESULT __stdcall  OleRegEnumFormatEtc(const CLSID * const clsid, DWORD dwDirection, LPENUMFORMATETC * ppenum)&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: REGDB_E_CLASSNOTREG 		or: REGDB_E_KEYMISSING.</body><body package="Com- Ole">invokeOleRegEnumVerbs: clsid _: ppenum        "Private - WINOLEAPI OleRegEnumVerbs (                                REFCLSID clsid, LPENUMOLEVERB FAR* ppenum); "	&lt;C: HRESULT __stdcall  OleRegEnumVerbs(const CLSID * const clsid, LPENUMOLEVERB * ppenum)&gt;	^self externalAccessFailedWith: _errorCode		allowAnyHRESULTOf: ( Array			with: REGDB_E_CLASSNOTREG 			with: REGDB_E_KEYMISSING			with: OLEOBJ_E_NOVERBS )</body><body package="Com- Ole">invokeOleRegGetMiscStatus: clsid _: dwAspect _: pdwStatus        "Private - WINOLEAPI OleRegGetMiscStatus (                               REFCLSID clsid, DWORD dwAspect,                               DWORD FAR* pdwStatus); "	&lt;C: HRESULT __stdcall  OleRegGetMiscStatus(const CLSID * const clsid, DWORD dwAspect, DWORD * pdwStatus)&gt;	^self externalAccessFailedWith: _errorCode		allowHRESULT: REGDB_E_CLASSNOTREG 		or: REGDB_E_KEYMISSING.</body><body package="Com- Ole">invokeOleRegGetUserType: clsid _: dwFormOfType _: pszUserType        "Private - WINOLEAPI OleRegGetUserType (                             REFCLSID clsid, DWORD dwFormOfType,                             LPOLESTR * pszUserType);"	&lt;C: HRESULT __stdcall  OleRegGetUserType(const CLSID * const clsid, DWORD dwFormOfType, LPOLESTR * pszUserType)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: REGDB_E_CLASSNOTREG		"?? or: REGDB_E_REGDB_KEY ??"</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-object conversion</category><body package="Com- Ole">invokeGetConvertStg: pStg        "Private - WINOLEAPI GetConvertStg(            LPSTORAGE pStg);"	&lt;C: HRESULT __stdcall  GetConvertStg(LPSTORAGE pStg)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleDoAutoConvert: pStg _: pClsidNew        "Private - WINOLEAPI OleDoAutoConvert(            LPSTORAGE pStg, LPCLSID pClsidNew);"	&lt;C: HRESULT __stdcall  OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: REGDB_E_KEYMISSING</body><body package="Com- Ole">invokeOleGetAutoConvert: clsidOld _: pClsidNew        "Private - WINOLEAPI OleGetAutoConvert(            REFCLSID clsidOld, LPCLSID pClsidNew);"	&lt;C: HRESULT __stdcall  OleGetAutoConvert(const CLSID * const clsidOld, LPCLSID pClsidNew)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeSetConvertStg: pStg _: fConvert        "Private - WINOLEAPI SetConvertStg(            LPSTORAGE pStg, BOOL fConvert);"	&lt;C: HRESULT __stdcall  SetConvertStg(LPSTORAGE pStg, BOOL fConvert)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-GUID services</category><body package="Com- Ole">invokeCLSIDFromProgID: lpszProgID _: lpclsid        "Private - WINOLEAPI CLSIDFromProgID (LPCOLESTR lpszProgID, LPCLSID lpclsid);"	&lt;C: HRESULT __stdcall  CLSIDFromProgID (LPCOLESTR lpszProgID, LPCLSID lpclsid)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: CO_E_CLASSSTRING</body><body package="Com- Ole">invokeCLSIDFromString: lpsz _: pclsid        "Private - WINOLEAPI CLSIDFromString(LPOLESTR lpsz, LPCLSID pclsid);"	&lt;C: HRESULT __stdcall  CLSIDFromString(LPOLESTR lpsz, LPCLSID pclsid)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: CO_E_CLASSSTRING</body><body package="Com- Ole">invokeCoCreateGuid: pguid        "Private - WINOLEAPI CoCreateGuid(GUID FAR *pguid);"	&lt;C: HRESULT __stdcall  CoCreateGuid(GUID *pguid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeIIDFromString: lpsz _: lpiid        "Private - WINOLEAPI IIDFromString(LPOLESTR lpsz, LPIID lpiid);"	&lt;C: HRESULT __stdcall  IIDFromString(LPOLESTR lpsz, LPIID lpiid)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: CO_E_IIDSTRING</body><body package="Com- Ole">invokeProgIDFromCLSID: clsid _: lplpszProgID        "Private - WINOLEAPI ProgIDFromCLSID (REFCLSID clsid, LPOLESTR * lplpszProgID);"	&lt;C: HRESULT __stdcall  ProgIDFromCLSID(const CLSID * const clsid, LPOLESTR * lplpszProgID)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStringFromCLSID: rclsid _: lplpsz        "Private - WINOLEAPI StringFromCLSID(REFCLSID rclsid, LPOLESTR FAR* lplpsz);"	&lt;C: HRESULT __stdcall StringFromCLSID(REFCLSID rclsid, LPOLESTR * lplpsz)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStringFromGUID2: rguid _: lpsz _: cbMax        "Private - WINOLEAPI_(int) StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cbMax); "	&lt;C: int __stdcall StringFromGUID2(REFGUID rguid, LPOLESTR lpsz, int cbMax)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeStringFromIID: riid _: lplpsz        "Private - WINOLEAPI StringFromIID(REFIID rclsid, LPOLESTR FAR* lplpsz);"	&lt;C: HRESULT __stdcall StringFromIID(REFIID riid, LPOLESTR * lplpsz)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-conversion services</category><body package="Com- Ole">CoIsOle1Class: rclsid		" Determine whether the CLSID specified by the GUID &lt;clsid&gt; 		represents an OLE 1 object. "	&lt;C: BOOL __stdcall CoIsOle1Class(REFCLSID rclsid)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoTreatAsClass: clsidOld _: clsidNew        " Establishes or removes an emulation from one object class to another.        The &lt;clsidNew&gt; specifies the CLSID of the object class that should emulate        &lt;clsidOld&gt; replacing any existing emulation. It can be CLSID_NULL, in which        case any existing emulation for &lt;clsidOld&gt; is removed. "	&lt;C: HRESULT __stdcall CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew)&gt;	^self externalAccessFailedWith: _errorCode		allowAnyHRESULTOf: ( Array 			with: REGDB_E_CLASSNOTREG			with: REGDB_E_WRITEREGDB			with: REGDB_E_READREGDB )</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-initialization</category><body package="Com- Ole">invokeCoBuildVersion        "Private - WINOLEAPI_(DWORD) CoBuildVersion( VOID );"	&lt;C: DWORD __stdcall  CoBuildVersion(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoInitialize: pvReserved        "Private - WINOLEAPI  CoInitialize(LPVOID pvReserved);"	&lt;C: HRESULT __stdcall  CoInitialize(LPVOID pvReserved)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoInitializeEx: pvReserved coInit: dwCoInit	&lt;C: HRESULT CoInitializeEx(void * pvReserved,  DWORD dwCoInit) &gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoInitializeExThreaded: pvReserved coInit: dwCoInit	&lt;C: HRESULT __threaded CoInitializeEx(void * pvReserved,  DWORD dwCoInit) &gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleBuildVersion        "Private - WINOLEAPI_(DWORD) OleBuildVersion( VOID );"	&lt;C: DWORD __stdcall  OleBuildVersion(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeOleInitialize: pvReserved        "Private - WINOLEAPI OleInitialize(LPVOID pvReserved);"	&lt;C: HRESULT __stdcall  OleInitialize(LPVOID pvReserved)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-terminating</category><body package="Com- Ole">CoUninitialize		" Close the COM implementation library. This function is unnecessary if the		OleUninitialize function is used. "	" WINOLEAPI_(void)  CoUninitialize(void); "	&lt;C: void __stdcall  CoUninitialize(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">CoUninitializeThreaded		" Close the COM implementation library. This function is unnecessary if the		OleUninitialize function is used. "	" WINOLEAPI_(void)  CoUninitialize(void); "	&lt;C: void __stdcall __threaded CoUninitialize(void)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">OleUninitialize		" Close the OLE implementation library.  "	" WINOLEAPI_(void) OleUninitialize(void); "	&lt;C: void __stdcall  OleUninitialize(void)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-object management</category><body package="Com- Ole">invokeCoHasStrongExternalConnections: pUnk        "Private - WINOLEAPI_(BOOL) CoHasStrongExternalConnections(LPUNKNOWN pUnk);"	&lt;C: BOOL __stdcall CoHasStrongExternalConnections(LPUNKNOWN pUnk)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoIsHandlerConnected: pUnk		"Private - WINOLEAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);"	&lt;C: BOOL __stdcall CoIsHandlerConnected(LPUNKNOWN pUnk)&gt;	^self externalAccessFailedWith: _errorCode</body><body package="Com- Ole">invokeCoLockObjectExternal: pUnk _: fLock _: fLastUnlockReleases        "Private - WINOLEAPI CoLockObjectExternal(			LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);"	&lt;C: HRESULT __stdcall CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invocation-memory management</category><body package="Com- Ole">invokeCoGetMalloc: dwMemContext _: ppMalloc		"Private - WINOLEAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);"	&lt;C: HRESULT __stdcall  CoGetMalloc(DWORD dwMemContext, LPMALLOC * ppMalloc)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: E_INVALIDARG</body><body package="Com- Ole">threadedInvokeCoGetMalloc: dwMemContext _: ppMalloc		"Private - WINOLEAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);"	&lt;C: HRESULT __stdcall  __threaded CoGetMalloc(DWORD dwMemContext, LPMALLOC * ppMalloc)&gt;	^self externalAccessFailedWith: _errorCode 		allowHRESULT: E_INVALIDARG</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-object conversion</category><body package="Com- Ole">invokeOleSetAutoConvert: clsidOld _: clsidNew        " Tag an object of class &lt;clsidOld&gt; for automatic conversion to a        different class &lt;clsidNew&gt; on being loaded."    "WINOLEAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew);"	&lt;C: HRESULT __stdcall  OleSetAutoConvert(const CLSID * const clsidOld, const CLSID * const clsidNew)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private-invokation-ole</category><body package="Com- Ole">invokeOleFlushClipboard		" Empty the clipboard, removing the IDataObject instance.		Raise an exception if an error occurs.  Answer the result code. "	" WINOLEAPI  OleFlushClipboard(void); "	&lt;C: HRESULT __stdcall  OleFlushClipboard(void)&gt;	^self externalAccessFailedWith: _errorCode</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>defines</category><body package="Com- Ole">STDMETHODCALLTYPE	&lt;C: #define STDMETHODCALLTYPE __stdcall	&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>structs-automation</category><body package="Com- Ole">tagARRAYDESC	&lt;C: struct tagARRAYDESC {			TYPEDESC tdescElem;			USHORT cDims;			SAFEARRAYBOUND rgbounds[1];		}&gt;</body><body package="Com- Ole">tagBLOB	&lt;C: struct tagBLOB {			ULONG cbSize;			BYTE * pBlobData;		}&gt;</body><body package="Com- Ole">tagCONNECTDATA	&lt;C: struct tagCONNECTDATA {			LPUNKNOWN pUnk;			DWORD dwCookie;		}&gt;</body><body package="Com- Ole">tagCY	"A currency number stored as an 8-byte, two's complement integer, scaled by 10,000 to give a fixed-point number with 15 digits to the left of the decimal point and 4 digits to the right. This representation provides a range of Â±922337203685477.5807. The CURRENCY data type is useful for calculations involving money, or for any fixed-point calculation where accuracy is particularly important."	&lt;C: union tagCY {		struct {			unsigned long Lo;			long      Hi;		} s;		LONGLONG int64;	}&gt;"Size is 8""Note: manual addition of #s name to nested structure to make DLLCC happy"</body><body package="Com- Ole">tagDISPPARAMS	&lt;C: struct tagDISPPARAMS {			VARIANTARG * rgvarg;			DISPID * rgdispidNamedArgs;			UINT cArgs, cNamedArgs;		}&gt;</body><body package="Com- Ole">tagELEMDESC	&lt;C: struct tagELEMDESC{		   	TYPEDESC tdesc;                  // Type of the element.			union {		      	IDLDESC idldesc;        //Info for remoting the element                                   				//(backward compatibility)	            	PARAMDESC paramdesc;    //info about the parameter  	 		 } u;			} &gt;</body><body package="Com- Ole">tagEXCEPINFO	&lt;C: struct tagEXCEPINFO {			WORD wCode, wReserved;			BSTR bstrSource, bstrDescription, bstrHelpFile;			DWORD dwHelpContext;			void * pvReserved;			HRESULT ( __stdcall * pfnDeferredFillIn)(struct tagEXCEPINFO * );			SCODE scode;		}&gt;</body><body package="Com- Ole">tagFUNCDESC	&lt;C: struct tagFUNCDESC {			MEMBERID memid;			SCODE * lprgscode;			ELEMDESC * lprgelemdescParam;			FUNCKIND funckind;			INVOKEKIND invkind;			CALLCONV callconv;			SHORT cParams, cParamsOpt, oVft, cScodes;			ELEMDESC elemdescFunc;			WORD wFuncFlags;		}&gt;</body><body package="Com- Ole">tagIDLDESC	&lt;C: struct tagIDLDESC {			unsigned long dwReserved;			unsigned short wIDLFlags;		}&gt;</body><body package="Com- Ole">tagSAFEARRAY	&lt;C: struct tagSAFEARRAY {			unsigned short cDims, fFeatures;			unsigned long cbElements, cLocks;			void * pvData;			SAFEARRAYBOUND rgsabound[1];		}&gt;</body><body package="Com- Ole">tagSAFEARRAYBOUND	&lt;C: struct tagSAFEARRAYBOUND {			ULONG cElements;			LONG lLbound;		}&gt;</body><body package="Com- Ole">tagTLIBATTR	&lt;C: struct tagTLIBATTR {			GUID guid;			LCID lcid;			SYSKIND syskind;			WORD wMajorVerNum, wMinorVerNum, wLibFlags;		}&gt;</body><body package="Com- Ole">tagTYPEATTR	&lt;C: struct tagTYPEATTR {			GUID guid;			LCID lcid;			DWORD dwReserved;			MEMBERID memidConstructor, memidDestructor;			LPOLESTR lpstrSchema;			ULONG cbSizeInstance;			TYPEKIND typekind;			WORD cFuncs, cVars, cImplTypes, cbSizeVft, cbAlignment, wTypeFlags, wMajorVerNum, wMinorVerNum;			TYPEDESC tdescAlias;			IDLDESC idldescType;		}&gt;</body><body package="Com- Ole">tagTYPEDESC	" NOTE: This type definition has been manually modified.		The definition in the header file uses an unnamed union,		which does not compile correctly in DLLCC (the unnamed		union fields get quietly dropped out of the definition).		For correct operation, a name field has been added		to the union field. "	&lt;C: struct  tagTYPEDESC		{		/* [switch_is][switch_type] */ union 			{			/* [case] */ struct tagTYPEDESC *lptdesc;			/* [case] */ struct tagARRAYDESC *lpadesc;			/* [case] */ HREFTYPE hreftype;			}	u;		VARTYPE vt;		}&gt;</body><body package="Com- Ole">tagVARDESC	" NOTE: This type definition has been manually modified.		The definition in the header file uses an unnamed union,		which does not compile correctly in DLLCC (the unnamed		union fields get quietly dropped out of the definition).		For correct operation, a name field has been added		to the union field. "	&lt;C: struct  tagVARDESC {		MEMBERID memid;		LPOLESTR lpstrSchema;		/* [switch_is][switch_type] */ union 			{			/* [case] */ ULONG oInst;			/* [case] */ VARIANT * lpvarValue;			}	u;		ELEMDESC elemdescVar;		WORD wVarFlags;		VARKIND varkind;		}&gt;</body><body package="Com- Ole">tagVARIANT	&lt;C: struct tagVARIANT {            VARTYPE vt;            WORD wReserved1;            WORD wReserved2;            WORD wReserved3;            union                 {                LONGLONG llVal;                LONG lVal;		      	                BYTE bVal;				                SHORT iVal;				                FLOAT fltVal;				                DOUBLE dblVal;			                VARIANT_BOOL boolVal; /*new, same as bool?*/                _VARIANT_BOOL bool;	                SCODE scode;			                CY cyVal;				                DATE date;				                BSTR bstrVal;			                IUnknown *punkVal;		                IDispatch *pdispVal;		                SAFEARRAY *parray;	                BYTE *pbVal;			                SHORT *piVal;			                LONG *plVal;				                LONGLONG *pllVal;                FLOAT *pfltVal;			                DOUBLE *pdblVal;		                VARIANT_BOOL *pboolVal;                _VARIANT_BOOL *pbool;	                SCODE *pscode;			                CY *pcyVal;				                DATE *pdate;				                BSTR *pbstrVal;			                IUnknown **ppunkVal;	                IDispatch **ppdispVal;	                SAFEARRAY **pparray;	                VARIANT *pvarVal;                PVOID byref;                CHAR cVal;                USHORT uiVal;							                ULONG ulVal;							                ULONGLONG ullVal;                INT intVal;                UINT uintVal;                DECIMAL *pdecVal;                CHAR *pcVal;                USHORT *puiVal;	                ULONG *pulVal;                ULONGLONG *pullVal;                INT *pintVal;                UINT *puintVal;                struct __tagBRECORD {				                    PVOID pvRecord;                    IRecordInfo *pRecInfo;                    } recordData ;                } u;		}&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>types-automation</category><body package="Com- Ole">ARRAYDESC	&lt;C: typedef struct tagARRAYDESC ARRAYDESC&gt;</body><body package="Com- Ole">BINDPTR	&lt;C: typedef union tagBINDPTR BINDPTR&gt;</body><body package="Com- Ole">BSTR	&lt;C: typedef OLECHAR * BSTR&gt;</body><body package="Com- Ole">CALLCONV	&lt;C: typedef enum tagCALLCONV CALLCONV&gt;</body><body package="Com- Ole">CURRENCY	&lt;C: typedef CY CURRENCY&gt;	"oaidl.h"</body><body package="Com- Ole">CY	&lt;C: typedef struct tagCY CY&gt;</body><body package="Com- Ole">DESCKIND	&lt;C: typedef enum tagDESCKIND DESCKIND&gt;</body><body package="Com- Ole">DISPID	&lt;C: typedef LONG DISPID&gt;</body><body package="Com- Ole">DISPPARAMS	&lt;C: typedef struct tagDISPPARAMS DISPPARAMS&gt;</body><body package="Com- Ole">ELEMDESC	&lt;C: typedef struct tagELEMDESC ELEMDESC&gt;</body><body package="Com- Ole">EXCEPINFO	&lt;C: typedef struct tagEXCEPINFO EXCEPINFO&gt;</body><body package="Com- Ole">FIXEDSIZESAFEARRAY	&lt;C: typedef SAFEARRAY FIXEDSIZESAFEARRAY&gt;</body><body package="Com- Ole">FUNCDESC	&lt;C: typedef struct tagFUNCDESC FUNCDESC&gt;</body><body package="Com- Ole">FUNCKIND	&lt;C: typedef enum tagFUNCKIND FUNCKIND&gt;</body><body package="Com- Ole">HREFTYPE	&lt;C: typedef DWORD HREFTYPE&gt;</body><body package="Com- Ole">IConnectionPoint	"&lt;C: typedef struct __IConnectionPoint IConnectionPoint&gt;"	&lt;C: typedef struct __IAnonymous IConnectionPoint&gt;</body><body package="Com- Ole">IConnectionPointContainer	"&lt;C: typedef struct __IConnectionPointContainer IConnectionPointContainer&gt;"	&lt;C: typedef struct __IAnonymous IConnectionPointContainer&gt;</body><body package="Com- Ole">IDLDESC	&lt;C: typedef struct tagIDLDESC IDLDESC&gt;</body><body package="Com- Ole">IDispatch	"&lt;C: typedef struct __IDispatch IDispatch&gt;"	&lt;C: typedef struct __IAnonymous IDispatch&gt;</body><body package="Com- Ole">IEnumConnectionPoints	"&lt;C: typedef struct __IEnumConnectionPoints IEnumConnectionPoints&gt;"	&lt;C: typedef struct __IAnonymous IEnumConnectionPoints&gt;</body><body package="Com- Ole">IEnumConnections	"&lt;C: typedef struct __IEnumConnections IEnumConnections&gt;"	&lt;C: typedef struct __IAnonymous IEnumConnections&gt;</body><body package="Com- Ole">INVOKEKIND	&lt;C: typedef enum tagINVOKEKIND INVOKEKIND&gt;</body><body package="Com- Ole">IProvideClassInfo	"&lt;C: typedef struct __IProvideClassInfo IProvideClassInfo&gt;"	&lt;C: typedef struct __IAnonymous IProvideClassInfo&gt;</body><body package="Com- Ole">ITypeComp	"&lt;C: typedef struct __ITypeComp ITypeComp&gt;"	&lt;C: typedef struct __IAnonymous ITypeComp&gt;</body><body package="Com- Ole">ITypeInfo	"&lt;C: typedef struct __ITypeInfo ITypeInfo&gt;"	&lt;C: typedef struct __IAnonymous ITypeInfo&gt;</body><body package="Com- Ole">ITypeLib	"&lt;C: typedef struct __ITypeLib ITypeLib&gt;"	&lt;C: typedef struct __IAnonymous ITypeLib&gt;</body><body package="Com- Ole">LPCONNECTIONPOINT	&lt;C: typedef IConnectionPoint * LPCONNECTIONPOINT&gt;</body><body package="Com- Ole">LPENUMCONNECTIONPOINTS	&lt;C: typedef IEnumConnectionPoints * LPENUMCONNECTIONPOINTS&gt;</body><body package="Com- Ole">LPENUMCONNECTIONS	&lt;C: typedef IEnumConnections * LPENUMCONNECTIONS&gt;</body><body package="Com- Ole">LPPARAMDESCEX	&lt;C: typedef PARAMDESCEX * LPPARAMDESCEX &gt;</body><body package="Com- Ole">LPTYPEINFO	&lt;C: typedef ITypeInfo * LPTYPEINFO&gt;</body><body package="Com- Ole">MEMBERID	&lt;C: typedef DISPID MEMBERID&gt;</body><body package="Com- Ole">PARAMDESC	&lt;C: typedef struct tagPARAMDESC {			LPPARAMDESCEX pparamdescex;         //valid if PARAMFLAG_FHASDEFAULT			USHORT wParamFlags;         // IN, OUT, etc			}  PARAMDESC&gt;</body><body package="Com- Ole">PARAMDESCEX	&lt;C: typedef struct tagPARAMDESCEX {			VARIANT *cByte;                     // size of this struct			VARIANTARG varDefaultValue;         // default value of this parameter		} PARAMDESCEX&gt;</body><body package="Com- Ole">REGKIND	&lt;C: typedef enum tagREGKIND REGKIND&gt;</body><body package="Com- Ole">SAFEARRAY	&lt;C: typedef struct tagSAFEARRAY SAFEARRAY&gt;</body><body package="Com- Ole">SAFEARRAYBOUND	&lt;C: typedef struct tagSAFEARRAYBOUND SAFEARRAYBOUND&gt;</body><body package="Com- Ole">SYSKIND	&lt;C: typedef enum tagSYSKIND SYSKIND&gt;</body><body package="Com- Ole">TLIBATTR	&lt;C: typedef struct tagTLIBATTR TLIBATTR&gt;</body><body package="Com- Ole">TYPEATTR	&lt;C: typedef struct tagTYPEATTR TYPEATTR&gt;</body><body package="Com- Ole">TYPEDESC	&lt;C: typedef struct tagTYPEDESC TYPEDESC&gt;</body><body package="Com- Ole">TYPEKIND	&lt;C: typedef enum tagTYPEKIND TYPEKIND&gt;</body><body package="Com- Ole">VARDESC	&lt;C: typedef struct tagVARDESC VARDESC&gt;</body><body package="Com- Ole">VARIANT	&lt;C: typedef struct tagVARIANT VARIANT&gt;</body><body package="Com- Ole">VARIANTARG	&lt;C: typedef struct tagVARIANT VARIANTARG&gt;</body><body package="Com- Ole">VARIANT_BOOL	&lt;C: typedef short VARIANT_BOOL&gt;</body><body package="Com- Ole">VARKIND	&lt;C: typedef enum tagVARKIND VARKIND&gt;</body><body package="Com- Ole">VARTYPE	&lt;C: typedef unsigned short VARTYPE&gt;</body><body package="Com- Ole">_VARIANT_BOOL	&lt;C: typedef VARIANT_BOOL _VARIANT_BOOL &gt;</body><body package="Com- Ole">specialVARIANTARG	&lt;C: typedef struct tagVARIANT specialVARIANTARG&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>types-COM</category><body package="Com- Ole">BIND_OPTS	&lt;C: typedef struct tagBIND_OPTS BIND_OPTS&gt;</body><body package="Com- Ole">CLSID	&lt;C: typedef GUID CLSID&gt;</body><body package="Com- Ole">COAUTHIDENTITY	&lt;C: typedef struct _COAUTHIDENTITY COAUTHIDENTITY&gt;</body><body package="Com- Ole">COAUTHINFO	&lt;C: typedef struct _COAUTHINFO COAUTHINFO&gt;</body><body package="Com- Ole">COSERVERINFO	&lt;C: typedef struct _COSERVERINFO COSERVERINFO&gt;</body><body package="Com- Ole">DVTARGETDEVICE	&lt;C: typedef struct tagDVTARGETDEVICE DVTARGETDEVICE&gt;</body><body package="Com- Ole">FORMATETC	&lt;C: typedef struct tagFORMATETC FORMATETC&gt;</body><body package="Com- Ole">GUID	&lt;C: typedef struct _GUID GUID&gt;</body><body package="Com- Ole">HRESULT	" add __hresult modifier to specify that HRESULT failure returns should generate function call failure exception "	"&lt;C: typedef LONG HRESULT&gt;"	&lt;C: typedef __hresult long HRESULT&gt;</body><body package="Com- Ole">IAdviseSink	"&lt;C: typedef struct __IAdviseSink IAdviseSink&gt;"	&lt;C: typedef struct __IAnonymous IAdviseSink&gt;</body><body package="Com- Ole">IAdviseSink2	"&lt;C: typedef struct __IAdviseSink2 IAdviseSink2&gt;"	&lt;C: typedef struct __IAnonymous IAdviseSink2&gt;</body><body package="Com- Ole">IAnonymous	&lt;C: typedef struct __IAnonymous IAnonymous&gt;</body><body package="Com- Ole">IBindCtx	"&lt;C: typedef struct __IBindCtx IBindCtx&gt;"	&lt;C: typedef struct __IAnonymous IBindCtx&gt;</body><body package="Com- Ole">IClassFactory	"&lt;C: typedef struct __IClassFactory IClassFactory&gt;"	&lt;C: typedef struct __IAnonymous IClassFactory&gt;</body><body package="Com- Ole">IDataAdviseHolder	"&lt;C: typedef struct __IDataAdviseHolder IDataAdviseHolder&gt;"	&lt;C: typedef struct __IAnonymous IDataAdviseHolder&gt;</body><body package="Com- Ole">IDataObject	"&lt;C: typedef struct __IDataObject IDataObject&gt;"	&lt;C: typedef struct __IAnonymous IDataObject&gt;</body><body package="Com- Ole">IDropSource	"&lt;C: typedef struct __IDropSource IDropSource&gt;"	&lt;C: typedef struct __IAnonymous IDropSource&gt;</body><body package="Com- Ole">IDropTarget	"&lt;C: typedef struct __IDropTarget IDropTarget&gt;"	&lt;C: typedef struct __IAnonymous IDropTarget&gt;</body><body package="Com- Ole">IEnum	"&lt;C: typedef struct __IEnum IEnum&gt;"	&lt;C: typedef struct __IAnonymous IEnum&gt;</body><body package="Com- Ole">IEnumFORMATETC	"&lt;C: typedef struct __IEnumFORMATETC IEnumFORMATETC&gt;"	&lt;C: typedef struct __IAnonymous IEnumFORMATETC&gt;</body><body package="Com- Ole">IEnumMoniker	"&lt;C: typedef struct __IEnumMoniker IEnumMoniker&gt;"	&lt;C: typedef struct __IAnonymous IEnumMoniker&gt;</body><body package="Com- Ole">IEnumOLEVERB	"&lt;C: typedef struct __IEnumOLEVERB IEnumOLEVERB&gt;"	&lt;C: typedef struct __IAnonymous IEnumOLEVERB&gt;</body><body package="Com- Ole">IEnumSTATDATA	"&lt;C: typedef struct __IEnumSTATDATA IEnumSTATDATA&gt;"	&lt;C: typedef struct __IAnonymous IEnumSTATDATA&gt;</body><body package="Com- Ole">IEnumSTATSTG	"&lt;C: typedef struct __IEnumSTATSTG IEnumSTATSTG&gt;"	&lt;C: typedef struct __IAnonymous IEnumSTATSTG&gt;</body><body package="Com- Ole">IEnumString	"&lt;C: typedef struct __IEnumString IEnumString&gt;"	&lt;C: typedef struct __IAnonymous IEnumString&gt;</body><body package="Com- Ole">IEnumUnknown	"&lt;C: typedef struct __IEnumUnknown IEnumUnknown&gt;"	&lt;C: typedef struct __IAnonymous IEnumUnknown&gt;</body><body package="Com- Ole">IID	&lt;C: typedef GUID IID&gt;</body><body package="Com- Ole">ILicenseManager	&lt;C: typedef struct __IAnonymous ILicenseManager&gt;</body><body package="Com- Ole">ILockBytes	"&lt;C: typedef struct __ILockBytes ILockBytes&gt;"	&lt;C: typedef struct __IAnonymous ILockBytes&gt;</body><body package="Com- Ole">IMalloc	"&lt;C: typedef struct __IMalloc IMalloc&gt;"	&lt;C: typedef struct __IAnonymous IMalloc&gt;</body><body package="Com- Ole">IMoniker	"&lt;C: typedef struct __IMoniker IMoniker&gt;"	&lt;C: typedef struct __IAnonymous IMoniker&gt;</body><body package="Com- Ole">IParseDisplayName	"&lt;C: typedef struct __IParseDisplayName IParseDisplayName&gt;"	&lt;C: typedef struct __IAnonymous IParseDisplayName&gt;</body><body package="Com- Ole">IPersist	"&lt;C: typedef struct __IPersist IPersist&gt;"	&lt;C: typedef struct __IAnonymous IPersist&gt;</body><body package="Com- Ole">IPersistFile	"&lt;C: typedef struct __IPersistFile IPersistFile&gt;"	&lt;C: typedef struct __IAnonymous IPersistFile&gt;</body><body package="Com- Ole">IPersistStorage	"&lt;C: typedef struct __IPersistStorage IPersistStorage&gt;"	&lt;C: typedef struct __IAnonymous IPersistStorage&gt;</body><body package="Com- Ole">IPersistStream	"&lt;C: typedef struct __IPersistStream IPersistStream&gt;"	&lt;C: typedef struct __IAnonymous IPersistStream&gt;</body><body package="Com- Ole">IPersistStreamInit	"&lt;C: typedef struct __IPersistStreamInit IPersistStreamInit&gt;"	&lt;C: typedef struct __IAnonymous IPersistStreamInit&gt;</body><body package="Com- Ole">IRootStorage	"&lt;C: typedef struct __IRootStorage IRootStorage&gt;"	&lt;C: typedef struct __IAnonymous IRootStorage&gt;</body><body package="Com- Ole">IRunningObjectTable	"&lt;C: typedef struct __IRunningObjectTable IRunningObjectTable&gt;"	&lt;C: typedef struct __IAnonymous IRunningObjectTable&gt;</body><body package="Com- Ole">IStorage	"&lt;C: typedef struct __IStorage IStorage&gt;"	&lt;C: typedef struct __IAnonymous IStorage&gt;</body><body package="Com- Ole">IStream	"&lt;C: typedef struct __IStream IStream&gt;"	&lt;C: typedef struct __IAnonymous IStream&gt;</body><body package="Com- Ole">IUnknown	"&lt;C: typedef struct __IUnknown IUnknown&gt;"	&lt;C: typedef struct __IAnonymous IUnknown&gt;</body><body package="Com- Ole">LINKSRCDESCRIPTOR	&lt;C: typedef struct tagOBJECTDESCRIPTOR LINKSRCDESCRIPTOR&gt;</body><body package="Com- Ole">LPBC	&lt;C: typedef IBindCtx * LPBC&gt;</body><body package="Com- Ole">LPBINDCTX	&lt;C: typedef IBindCtx * LPBINDCTX&gt;</body><body package="Com- Ole">LPCLASSFACTORY	&lt;C: typedef IClassFactory * LPCLASSFACTORY&gt;</body><body package="Com- Ole">LPCLSID	&lt;C: typedef CLSID * LPCLSID&gt;</body><body package="Com- Ole">LPCOLESTR	&lt;C: typedef const OLECHAR * LPCOLESTR&gt;</body><body package="Com- Ole">LPDATAADVISEHOLDER	&lt;C: typedef IDataAdviseHolder * LPDATAADVISEHOLDER&gt;</body><body package="Com- Ole">LPDATAOBJECT	&lt;C: typedef IDataObject * LPDATAOBJECT&gt;</body><body package="Com- Ole">LPDROPSOURCE	&lt;C: typedef IDropSource * LPDROPSOURCE&gt;</body><body package="Com- Ole">LPDROPTARGET	&lt;C: typedef IDropTarget * LPDROPTARGET&gt;</body><body package="Com- Ole">LPENUMFORMATETC	&lt;C: typedef IEnumFORMATETC * LPENUMFORMATETC&gt;</body><body package="Com- Ole">LPENUMOLEVERB	&lt;C: typedef IEnumOLEVERB * LPENUMOLEVERB&gt;</body><body package="Com- Ole">LPFORMATETC	&lt;C: typedef struct tagFORMATETC * LPFORMATETC&gt;</body><body package="Com- Ole">LPIID	&lt;C: typedef IID * LPIID&gt;</body><body package="Com- Ole">LPLINKSRCDESCRIPTOR	&lt;C: typedef struct tagOBJECTDESCRIPTOR *LPLINKSRCDESCRIPTOR&gt;</body><body package="Com- Ole">LPLOCKBYTES	&lt;C: typedef ILockBytes * LPLOCKBYTES&gt;</body><body package="Com- Ole">LPMALLOC	&lt;C: typedef IMalloc * LPMALLOC&gt;</body><body package="Com- Ole">LPMONIKER	&lt;C: typedef IMoniker * LPMONIKER&gt;</body><body package="Com- Ole">LPOBJECTDESCRIPTOR	&lt;C: typedef struct tagOBJECTDESCRIPTOR * LPOBJECTDESCRIPTOR&gt;</body><body package="Com- Ole">LPOLESTR	&lt;C: typedef OLECHAR * LPOLESTR&gt;</body><body package="Com- Ole">LPOLEVERB	&lt;C: typedef struct tagOLEVERB * LPOLEVERB&gt;</body><body package="Com- Ole">LPPERSISTSTORAGE	&lt;C: typedef IPersistStorage * LPPERSISTSTORAGE&gt;</body><body package="Com- Ole">LPPERSISTSTREAM	&lt;C: typedef IPersistStream * LPPERSISTSTREAM&gt;</body><body package="Com- Ole">LPRUNNINGOBJECTTABLE	&lt;C: typedef IRunningObjectTable * LPRUNNINGOBJECTTABLE&gt;</body><body package="Com- Ole">LPSTGMEDIUM	&lt;C: typedef STGMEDIUM * LPSTGMEDIUM&gt;</body><body package="Com- Ole">LPSTORAGE	&lt;C: typedef IStorage * LPSTORAGE&gt;</body><body package="Com- Ole">LPSTREAM	&lt;C: typedef IStream * LPSTREAM&gt;</body><body package="Com- Ole">LPUNKNOWN	&lt;C: typedef IUnknown * LPUNKNOWN&gt;</body><body package="Com- Ole">MULTI_QI	&lt;C: typedef struct tagMULTI_QI MULTI_QI&gt;</body><body package="Com- Ole">OBJECTDESCRIPTOR	&lt;C: typedef struct  tagOBJECTDESCRIPTOR	OBJECTDESCRIPTOR&gt;</body><body package="Com- Ole">OLECHAR	&lt;C: typedef WCHAR OLECHAR&gt;</body><body package="Com- Ole">OLEVERB	&lt;C: typedef struct tagOLEVERB OLEVERB&gt;</body><body package="Com- Ole">REFCLSID	&lt;C: typedef CLSID * REFCLSID&gt;</body><body package="Com- Ole">REFGUID	&lt;C: typedef GUID * REFGUID&gt;</body><body package="Com- Ole">REFIID	&lt;C: typedef IID * REFIID&gt;</body><body package="Com- Ole">SCODE	"&lt;C: typedef LONG SCODE&gt;"	&lt;C: typedef unsigned long SCODE&gt;</body><body package="Com- Ole">SNB	&lt;C: typedef OLECHAR * * SNB&gt;</body><body package="Com- Ole">STATDATA	&lt;C: typedef struct tagSTATDATA STATDATA&gt;</body><body package="Com- Ole">STATSTG	&lt;C: typedef struct tagSTATSTG STATSTG&gt;</body><body package="Com- Ole">STGMEDIUM	&lt;C: typedef struct tagSTGMEDIUM STGMEDIUM&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>structs-COM</category><body package="Com- Ole">Interface	&lt;C: typedef struct __IAnonymous Interface&gt;</body><body package="Com- Ole">_COAUTHIDENTITY 	&lt;C: struct _COAUTHIDENTITY {		USHORT *User; 		ULONG UserLength; 		USHORT *Domain; 		ULONG DomainLength; 		USHORT *Password; 		ULONG PasswordLength; 		ULONG Flags; 	}&gt;</body><body package="Com- Ole">_COAUTHINFO	&lt;C: struct _COAUTHINFO { 		DWORD dwAuthnSvc; 		DWORD dwAuthzSvc; 		LPWSTR pwszServerPrincName; 		DWORD dwAuthnLevel;		DWORD dwImpersonationLevel; 		COAUTHIDENTITY *pAuthIdentityData; 		DWORD dwCapabilities;  	}&gt;</body><body package="Com- Ole">_COSERVERINFO	&lt;C: struct _COSERVERINFO {		DWORD dwReserved1; 		LPWSTR pwszName; 		COAUTHINFO *pAuthInfo; 		DWORD dwReserved2; 		}&gt;</body><body package="Com- Ole">_GUID	&lt;C: struct _GUID {			unsigned long Data1;			unsigned short Data2, Data3;			unsigned char Data4[8];		}&gt;</body><body package="Com- Ole">__IAnonymous	&lt;C: struct __IAnonymous {			struct __IAnonymousVtbl * lpVtbl;		}&gt;</body><body package="Com- Ole">__IAnonymousVtbl	" The anonymous interface VTable is a generic placeholder for a structure containing a sequence of function pointers, i.e., the pure virtual function table comprising an interface. "	"&lt;C: struct __IAnonymousVtbl {			HRESULT ( __stdcall * QueryInterface)(IUnknown * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IUnknown * This);			ULONG ( __stdcall * Release)(IUnknown * This);		}&gt;"	&lt;C: struct __IAnonymousVtbl &gt;</body><body package="Com- Ole">tagBIND_OPTS	&lt;C: struct tagBIND_OPTS {			DWORD cbStruct, grfFlags, grfMode, dwTickCountDeadline;		}&gt;</body><body package="Com- Ole">tagDVTARGETDEVICE	&lt;C: struct tagDVTARGETDEVICE {			DWORD tdSize;			WORD tdDriverNameOffset, tdDeviceNameOffset, tdPortNameOffset, tdExtDevmodeOffset;			BYTE tdData[1];		}&gt;</body><body package="Com- Ole">tagFORMATETC	&lt;C: struct tagFORMATETC {			CLIPFORMAT cfFormat;			DVTARGETDEVICE * ptd;			DWORD dwAspect;			LONG lindex;			DWORD tymed;		}&gt;</body><body package="Com- Ole">tagMULTI_QI	&lt;C: struct tagMULTI_QI {			IID * pIID;			IUnknown * pItf;			HRESULT hr;		}&gt;</body><body package="Com- Ole">tagOBJECTDESCRIPTOR	&lt;C: struct tagOBJECTDESCRIPTOR {			ULONG cbSize;			CLSID clsid;			DWORD dwDrawAspect;			SIZEL sizel;			POINTL pointl;			DWORD dwStatus, dwFullUserTypeName, dwSrcOfCopy;		}&gt;</body><body package="Com- Ole">tagOLEVERB	&lt;C: struct tagOLEVERB {			LONG lVerb;			LPOLESTR lpszVerbName;			DWORD fuFlags, grfAttribs;		}&gt;</body><body package="Com- Ole">tagSTATDATA	&lt;C: struct tagSTATDATA {			FORMATETC formatetc;			DWORD advf;			IAdviseSink * pAdvSink;			DWORD dwConnection;		}&gt;</body><body package="Com- Ole">tagSTATSTG	&lt;C: struct tagSTATSTG {			LPOLESTR pwcsName;			DWORD type;			ULARGE_INTEGER cbSize;			FILETIME mtime, ctime, atime;			DWORD grfMode, grfLocksSupported;			CLSID clsid;			DWORD grfStateBits, reserved;		}&gt;</body><body package="Com- Ole">tagSTGMEDIUM	&lt;C: struct tagSTGMEDIUM {			DWORD tymed;			union {				HBITMAP hBitmap;				HMETAFILEPICT hMetaFilePict;				HENHMETAFILE hEnhMetaFile;				HGLOBAL hGlobal;				LPOLESTR lpszFileName;				IStream * pstm;				IStorage * pstg;			} u;			IUnknown * pUnkForRelease;		}&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>enums-automation</category><body package="Com- Ole">tagCALLCONV	&lt;C: enum tagCALLCONV {			CC_CDECL = 1, 			CC_MSCPASCAL = 1, 			CC_PASCAL = 0, 			CC_MACPASCAL, 			CC_STDCALL = 1, 			CC_RESERVED = 1, 			CC_SYSCALL = 1, 			CC_MPWCDECL = 1, 			CC_MPWPASCAL = 1, 			CC_MAX = 1		}&gt;</body><body package="Com- Ole">tagDESCKIND	&lt;C: enum tagDESCKIND {			DESCKIND_NONE, 			DESCKIND_FUNCDESC, 			DESCKIND_VARDESC = 1, 			DESCKIND_TYPECOMP = 1, 			DESCKIND_IMPLICITAPPOBJ = 1, 			DESCKIND_MAX = 1		}&gt;</body><body package="Com- Ole">tagFUNCKIND	&lt;C: enum tagFUNCKIND {			FUNC_VIRTUAL, 			FUNC_PUREVIRTUAL, 			FUNC_NONVIRTUAL = 1, 			FUNC_STATIC = 1, 			FUNC_DISPATCH = 1		}&gt;</body><body package="Com- Ole">tagINVOKEKIND	&lt;C: enum tagINVOKEKIND {			INVOKE_FUNC = 1, 			INVOKE_PROPERTYGET, 			INVOKE_PROPERTYPUT = 4, 			INVOKE_PROPERTYPUTREF = 8		}&gt;</body><body package="Com- Ole">tagREGKIND	&lt;C: enum tagREGKIND {		REGKIND_DEFAULT,    		REGKIND_REGISTER,		REGKIND_NONE	}&gt;</body><body package="Com- Ole">tagSYSKIND	&lt;C: enum tagSYSKIND {			SYS_WIN16, 			SYS_WIN32, 			SYS_MAC = 1		}&gt;</body><body package="Com- Ole">tagTYPEKIND	&lt;C: enum tagTYPEKIND {			TKIND_ENUM, 			TKIND_RECORD, 			TKIND_MODULE = 1, 			TKIND_INTERFACE = 1, 			TKIND_DISPATCH = 1, 			TKIND_COCLASS = 1, 			TKIND_ALIAS = 1, 			TKIND_UNION = 1, 			TKIND_MAX = 1		}&gt;</body><body package="Com- Ole">tagVARKIND	&lt;C: enum tagVARKIND {			VAR_PERINSTANCE, 			VAR_STATIC, 			VAR_CONST = 1, 			VAR_DISPATCH = 1		}&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>structs</category><body package="Com- Ole">__tagBRECORD	"part of tagVariant"	&lt;C: struct __tagBRECORD {			PVOID pvRecord;			IRecordInfo * pRecInfo;		}&gt;</body><body package="Com- Ole">recordData	&lt;C: struct recordData {			PVOID pvRecord;			IRecordInfo * pRecInfo;		}&gt;</body><body package="Com- Ole">tagLICINFO	&lt;C: struct tagLICINFO {			LONG cbLicInfo;			BOOL fRuntimeKeyAvail, fLicVerified;		}&gt;</body><body package="Com- Ole">tagPARAMDESC	&lt;C: struct tagPARAMDESC {			LPPARAMDESCEX pparamdescex;			USHORT wParamFlags;		}&gt;</body><body package="Com- Ole">tagPARAMDESCEX	&lt;C: struct tagPARAMDESCEX {			VARIANT * cByte;			VARIANTARG varDefaultValue;		}&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>types</category><body package="Com- Ole">IRecordInfo	"the interface used to describe structs alias records in COM"	&lt;C: typedef void * IRecordInfo&gt;</body><body package="Com- Ole">LICINFO	&lt;C: typedef struct tagLICINFO {    				LONG cbLicInfo;    				BOOL fRuntimeKeyAvail;    				BOOL fLicVerified;    			} 	LICINFO&gt;</body><body package="Com- Ole">PVOID	&lt;C: typedef void * PVOID&gt;</body><body package="Com- Ole">PVOIS	&lt;C: typedef void * PVOIS&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>types-automation samples</category><body package="Com- Ole">IAllDataTypesDisp	&lt;C: typedef void * IAllDataTypesDisp&gt;</body><body package="Com- Ole">ISmalltalkCommanderDisp	"Define the interface data type. Using __IAnonymous instead of __ISmalltalkCommanderDisp is a space optimization that avoids defining extraneous data types that are not needed by the COM Connect runtime."	"&lt;C: typedef struct __ISmalltalkCommanderDisp ISmalltalkCommanderDisp&gt;"	&lt;C: typedef struct __IAnonymous ISmalltalkCommanderDisp&gt;</body></methods><methods><class-id>External.COMExternalInterface</class-id> <category>unions-automation</category><body package="Com- Ole">tagBINDPTR	&lt;C: union tagBINDPTR {			FUNCDESC * lpfuncdesc;			VARDESC * lpvardesc;			ITypeComp * lptcomp;		}&gt;</body></methods><methods><class-id>External.COMPlatformProvider</class-id> <category>types</category><body package="Com- Ole">entryPointType	&lt;C: typedef void * entryPointType&gt;</body><body package="Com- Ole">interfaceType	&lt;C: typedef struct _interfaceType {		void ** vtablePointer;		long entry; } interfaceType&gt;</body></methods><methods><class-id>External.X64COMInterface</class-id> <category>types</category><body package="Com- Ole">vtableType	&lt;C: typedef struct _vtableType {		unsigned long long size;		entryPointType *entries; 		} vtableType&gt;</body></methods><methods><class-id>External.COMInterfaceVTableSignatures</class-id> <category>vtables-COM</category><body package="Com- Ole">__IAdviseSink2Vtbl	"	&lt;C: struct __IAdviseSink2 {			struct __IAdviseSink2Vtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IAdviseSink2 IAdviseSink2&gt;	"	&lt;C: struct __IAdviseSink2Vtbl {			HRESULT ( __stdcall * QueryInterface)(IAdviseSink2 * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IAdviseSink2 * This);			ULONG ( __stdcall * Release)(IAdviseSink2 * This);			void ( __stdcall * OnDataChange)(IAdviseSink2 * This, FORMATETC * pFormatetc, STGMEDIUM * pStgmed);			void ( __stdcall * OnViewChange)(IAdviseSink2 * This, DWORD dwAspect, LONG lindex);			void ( __stdcall * OnRename)(IAdviseSink2 * This, IMoniker * pmk);			void ( __stdcall * OnSave)(IAdviseSink2 * This);			void ( __stdcall * OnClose)(IAdviseSink2 * This);			void ( __stdcall * OnLinkSrcChange)(IAdviseSink2 * This, IMoniker * pmk);		}&gt;</body><body package="Com- Ole">__IAdviseSinkVtbl	"	&lt;C: struct __IAdviseSink {			struct __IAdviseSinkVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IAdviseSink IAdviseSink&gt;	"	&lt;C: struct __IAdviseSinkVtbl {			HRESULT ( __stdcall * QueryInterface)(IAdviseSink * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IAdviseSink * This);			ULONG ( __stdcall * Release)(IAdviseSink * This);			void ( __stdcall * OnDataChange)(IAdviseSink * This, FORMATETC * pFormatetc, STGMEDIUM * pStgmed);			void ( __stdcall * OnViewChange)(IAdviseSink * This, DWORD dwAspect, LONG lindex);			void ( __stdcall * OnRename)(IAdviseSink * This, IMoniker * pmk);			void ( __stdcall * OnSave)(IAdviseSink * This);			void ( __stdcall * OnClose)(IAdviseSink * This);		}&gt;</body><body package="Com- Ole">__IBindCtxVtbl	"	&lt;C: struct __IBindCtx {			struct __IBindCtxVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IBindCtx IBindCtx&gt;	"	&lt;C: struct __IBindCtxVtbl {			HRESULT ( __stdcall * QueryInterface)(IBindCtx * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IBindCtx * This);			ULONG ( __stdcall * Release)(IBindCtx * This);			HRESULT ( __stdcall * RegisterObjectBound)(IBindCtx * This, IUnknown * punk);			HRESULT ( __stdcall * RevokeObjectBound)(IBindCtx * This, IUnknown * punk);			HRESULT ( __stdcall * ReleaseBoundObjects)(IBindCtx * This);			HRESULT ( __stdcall * SetBindOptions)(IBindCtx * This, BIND_OPTS * pbindopts);			HRESULT ( __stdcall * GetBindOptions)(IBindCtx * This, BIND_OPTS * pbindopts);			HRESULT ( __stdcall * GetRunningObjectTable)(IBindCtx * This, IRunningObjectTable * * pprot);			HRESULT ( __stdcall * RegisterObjectParam)(IBindCtx * This, LPOLESTR pszKey, IUnknown * punk);			HRESULT ( __stdcall * GetObjectParam)(IBindCtx * This, LPOLESTR pszKey, IUnknown * * ppunk);			HRESULT ( __stdcall * EnumObjectParam)(IBindCtx * This, IEnumString * * ppenum);			HRESULT ( __stdcall * RevokeObjectParam)(IBindCtx * This, LPOLESTR pszKey);		}&gt;</body><body package="Com- Ole">__IClassFactory2Vtbl	"IClassFactory VTable"	&lt;C:  struct __IClassFactory2Vtbl {               HRESULT ( __stdcall *QueryInterface )(             IClassFactory2 * This,            /* [in] */ REFIID riid,            /* [iid_is][out] */ void **ppvObject);                ULONG ( __stdcall *AddRef )(             IClassFactory2 * This);                ULONG ( __stdcall *Release )(             IClassFactory2 * This);                /* [local] */ HRESULT ( __stdcall *CreateInstance )(             IClassFactory2 * This,            /* [unique][in] */ IUnknown *pUnkOuter,            /* [in] */ REFIID riid,            /* [iid_is][out] */ void **ppvObject);                /* [local] */ HRESULT ( __stdcall *LockServer )(             IClassFactory2 * This,            /* [in] */ BOOL fLock);                HRESULT ( __stdcall *GetLicInfo )(             IClassFactory2 * This,            /* [out] */ LICINFO *pLicInfo);                HRESULT ( __stdcall *RequestLicKey )(             IClassFactory2 * This,            /* [in] */ DWORD dwReserved,            /* [out] */ BSTR *pBstrKey);                /* [local] */ HRESULT ( __stdcall *CreateInstanceLic )(             IClassFactory2 * This,            /* [in] */ IUnknown *pUnkOuter,            /* [in] */ IUnknown *pUnkReserved,            /* [in] */ REFIID riid,            /* [in] */ BSTR bstrKey,            /* [iid_is][out] */ PVOID *ppvObj);        	    } &gt;</body><body package="Com- Ole">__IClassFactoryVtbl	"	&lt;C: struct __IClassFactory {			struct __IClassFactoryVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IClassFactory IClassFactory&gt;	"	&lt;C: struct __IClassFactoryVtbl {			HRESULT ( __stdcall * QueryInterface)(IClassFactory * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IClassFactory * This);			ULONG ( __stdcall * Release)(IClassFactory * This);			HRESULT ( __stdcall * CreateInstance)(IClassFactory * This, IUnknown * pUnkOuter, const IID * const riid, void * * ppvObject);			HRESULT ( __stdcall * LockServer)(IClassFactory * This, BOOL fLock);		}&gt;</body><body package="Com- Ole">__IDataAdviseHolderVtbl	"	&lt;C: struct __IDataAdviseHolder {			struct __IDataAdviseHolderVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IDataAdviseHolder IDataAdviseHolder&gt;	"	&lt;C: struct __IDataAdviseHolderVtbl {			HRESULT ( __stdcall * QueryInterface)(IDataAdviseHolder * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IDataAdviseHolder * This);			ULONG ( __stdcall * Release)(IDataAdviseHolder * This);			HRESULT ( __stdcall * Advise)(IDataAdviseHolder * This, IDataObject * pDataObject, FORMATETC * pFetc, DWORD advf, IAdviseSink * pAdvise, DWORD * pdwConnection);			HRESULT ( __stdcall * Unadvise)(IDataAdviseHolder * This, DWORD dwConnection);			HRESULT ( __stdcall * EnumAdvise)(IDataAdviseHolder * This, IEnumSTATDATA * * ppenumAdvise);			HRESULT ( __stdcall * SendOnDataChange)(IDataAdviseHolder * This, IDataObject * pDataObject, DWORD dwReserved, DWORD advf);		}&gt;</body><body package="Com- Ole">__IDataObjectVtbl	"	&lt;C: struct __IDataObject {			struct __IDataObjectVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IDataObject IDataObject&gt;	"	&lt;C: struct __IDataObjectVtbl {			HRESULT ( __stdcall * QueryInterface)(IDataObject * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IDataObject * This);			ULONG ( __stdcall * Release)(IDataObject * This);			HRESULT ( __stdcall * GetData)(IDataObject * This, FORMATETC * pformatetcIn, STGMEDIUM * pmedium);			HRESULT ( __stdcall * GetDataHere)(IDataObject * This, FORMATETC * pformatetc, STGMEDIUM * pmedium);			HRESULT ( __stdcall * QueryGetData)(IDataObject * This, FORMATETC * pformatetc);			HRESULT ( __stdcall * GetCanonicalFormatEtc)(IDataObject * This, FORMATETC * pformatectIn, FORMATETC * pformatetcOut);			HRESULT ( __stdcall * SetData)(IDataObject * This, FORMATETC * pformatetc, STGMEDIUM * pmedium, BOOL fRelease);			HRESULT ( __stdcall * EnumFormatEtc)(IDataObject * This, DWORD dwDirection, IEnumFORMATETC * * ppenumFormatEtc);			HRESULT ( __stdcall * DAdvise)(IDataObject * This, FORMATETC * pformatetc, DWORD advf, IAdviseSink * pAdvSink, DWORD * pdwConnection);			HRESULT ( __stdcall * DUnadvise)(IDataObject * This, DWORD dwConnection);			HRESULT ( __stdcall * EnumDAdvise)(IDataObject * This, IEnumSTATDATA * * ppenumAdvise);		}&gt;</body><body package="Com- Ole">__IDropSourceVtbl	"	&lt;C: struct __IDropSource {			struct __IDropSourceVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IDropSource IDropSource&gt;	"	&lt;C: struct __IDropSourceVtbl {			HRESULT ( __stdcall * QueryInterface)(IDropSource * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IDropSource * This);			ULONG ( __stdcall * Release)(IDropSource * This);			HRESULT ( __stdcall * QueryContinueDrag)(IDropSource * This, BOOL fEscapePressed, DWORD grfKeyState);			HRESULT ( __stdcall * GiveFeedback)(IDropSource * This, DWORD dwEffect);		}&gt;</body><body package="Com- Ole">__IDropTargetVtbl	"	&lt;C: struct __IDropTarget {			struct __IDropTargetVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IDropTarget IDropTarget&gt;	"	&lt;C: struct __IDropTargetVtbl {			HRESULT ( __stdcall * QueryInterface)(IDropTarget * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IDropTarget * This);			ULONG ( __stdcall * Release)(IDropTarget * This);			HRESULT ( __stdcall * DragEnter)(IDropTarget * This, IDataObject * pDataObj, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);			HRESULT ( __stdcall * DragOver)(IDropTarget * This, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);			HRESULT ( __stdcall * DragLeave)(IDropTarget * This);			HRESULT ( __stdcall * Drop)(IDropTarget * This, IDataObject * pDataObj, DWORD grfKeyState, POINTL pt, DWORD * pdwEffect);		}&gt;</body><body package="Com- Ole">__IEnumVtbl	"IEnum is an untyped represention of the IEnumXXX family of enumerators.  The only difference among the typed variations of the untyped template is the type declaration of the element argument of the IEnum::Next operation."	"	&lt;C: struct __IEnum {			struct __IEnumVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IEnumVtbl IEnum&gt;	"	&lt;C: struct __IEnumVtbl {			HRESULT ( __stdcall * QueryInterface)(IEnum * This, const IID * const riid, LPVOID * ppvObj);			ULONG ( __stdcall * AddRef)(IEnum * This);			ULONG ( __stdcall * Release)(IEnum * This);			HRESULT ( __stdcall * Next)(IEnum * This, ULONG celt, void * * rgelt, ULONG * pceltFetched);			HRESULT ( __stdcall * Skip)(IEnum * This, ULONG celt);			HRESULT ( __stdcall * Reset)(IEnum * This);			HRESULT ( __stdcall * Clone)(IEnum * This, IEnum  ** ppenum);		}&gt;</body><body package="Com- Ole">__IGlobalInterfaceTableVtbl	&lt;C: struct __IGlobalInterfaceTableVtbl {			HRESULT ( __stdcall * QueryInterface)(IGlobalInterfaceTable * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IGlobalInterfaceTable * This);			ULONG ( __stdcall * Release)(IGlobalInterfaceTable * This);			HRESULT (__stdcall *RegisterInterfaceInGlobal)(IGlobalInterfaceTable* This, IUnknown * pUnk, REFIID riid, dword *dwCookie);			HRESULT (__stdcall *RevokeInterfaceFromGlobal) (IGlobalInterfaceTable* This, DWORD dwCookie);			HRESULT (__stdcall *GetInterfaceFromGlobal) (IGlobalInterfaceTable * This, DWORD dwCookie, const  REFIID riid, IUnknown** ppU);		}&gt;</body><body package="Com- Ole">__ILicenseManagerVtbl	&lt;C: struct __ILicenseManagerVtbl {			HRESULT ( __stdcall * QueryInterface)(ILicenseManager * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(ILicenseManager * This);			ULONG ( __stdcall * Release)(ILicenseManager * This);       		HRESULT ( __stdcall *IsDevelopment )(ILicenseManager * This, CLSID* class , BOOL *result);       		HRESULT ( __stdcall *CreateInstance)(ILicenseManager * This, CLSID* class , IUnknown *pUnkOuter, REFIID riid, BSTR license,  void **ppvObject);       		HRESULT ( __stdcall *QueryLicenseKey)(ILicenseManager * This, CLSID* class, BSTR * result);		}&gt;</body><body package="Com- Ole">__ILockBytesVtbl	"	&lt;C: struct __ILockBytes {			struct __ILockBytesVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __ILockBytes ILockBytes&gt;	"	&lt;C: struct __ILockBytesVtbl {			HRESULT ( __stdcall * QueryInterface)(ILockBytes * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(ILockBytes * This);			ULONG ( __stdcall * Release)(ILockBytes * This);			HRESULT ( __stdcall * ReadAt)(ILockBytes * This, ULARGE_INTEGER ulOffset, void * pv, ULONG cb, ULONG * pcbRead);			HRESULT ( __stdcall * WriteAt)(ILockBytes * This, ULARGE_INTEGER ulOffset, const void * pv, ULONG cb, ULONG * pcbWritten);			HRESULT ( __stdcall * Flush)(ILockBytes * This);			HRESULT ( __stdcall * SetSize)(ILockBytes * This, ULARGE_INTEGER cb);			HRESULT ( __stdcall * LockRegion)(ILockBytes * This, ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);			HRESULT ( __stdcall * UnlockRegion)(ILockBytes * This, ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);			HRESULT ( __stdcall * Stat)(ILockBytes * This, STATSTG * pstatstg, DWORD grfStatFlag);		}&gt;</body><body package="Com- Ole">__IMallocVtbl	"	&lt;C: struct __IMalloc {			struct __IMallocVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IMalloc IMalloc&gt;	"	&lt;C: struct __IMallocVtbl {			HRESULT ( __stdcall * QueryInterface)(IMalloc * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IMalloc * This);			ULONG ( __stdcall * Release)(IMalloc * This);			void *  ( __stdcall * Alloc)(IMalloc * This, ULONG cb);			void *  ( __stdcall * Realloc)(IMalloc * This, void * pv, ULONG cb);			void ( __stdcall * Free)(IMalloc * This, void * pv);			ULONG ( __stdcall * GetSize)(IMalloc * This, void * pv);			int ( __stdcall * DidAlloc)(IMalloc * This, void * pv);			void ( __stdcall * HeapMinimize)(IMalloc * This);		}&gt;</body><body package="Com- Ole">__IMonikerVtbl	"	&lt;C: struct __IMoniker {			struct __IMonikerVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IMoniker IMoniker&gt;	"	&lt;C: struct __IMonikerVtbl {			HRESULT ( __stdcall * QueryInterface)(IMoniker * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IMoniker * This);			ULONG ( __stdcall * Release)(IMoniker * This);			HRESULT ( __stdcall * GetClassID)(IMoniker * This, CLSID * pClassID);			HRESULT ( __stdcall * IsDirty)(IMoniker * This);			HRESULT ( __stdcall * Load)(IMoniker * This, IStream * pStm);			HRESULT ( __stdcall * Save)(IMoniker * This, IStream * pStm, BOOL fClearDirty);			HRESULT ( __stdcall * GetSizeMax)(IMoniker * This, ULARGE_INTEGER * pcbSize);			HRESULT ( __stdcall * BindToObject)(IMoniker * This, IBindCtx * pbc, IMoniker * pmkToLeft, const IID * const riidResult, void * * ppvResult);			HRESULT ( __stdcall * BindToStorage)(IMoniker * This, IBindCtx * pbc, IMoniker * pmkToLeft, const IID * const riid, void * * ppvObj);			HRESULT ( __stdcall * Reduce)(IMoniker * This, IBindCtx * pbc, DWORD dwReduceHowFar, IMoniker * * ppmkToLeft, IMoniker * * ppmkReduced);			HRESULT ( __stdcall * ComposeWith)(IMoniker * This, IMoniker * pmkRight, BOOL fOnlyIfNotGeneric, IMoniker * * ppmkComposite);			HRESULT ( __stdcall * Enum)(IMoniker * This, BOOL fForward, IEnumMoniker * * ppenumMoniker);			HRESULT ( __stdcall * IsEqual)(IMoniker * This, IMoniker * pmkOtherMoniker);			HRESULT ( __stdcall * Hash)(IMoniker * This, DWORD * pdwHash);			HRESULT ( __stdcall * IsRunning)(IMoniker * This, IBindCtx * pbc, IMoniker * pmkToLeft, IMoniker * pmkNewlyRunning);			HRESULT ( __stdcall * GetTimeOfLastChange)(IMoniker * This, IBindCtx * pbc, IMoniker * pmkToLeft, FILETIME * pFileTime);			HRESULT ( __stdcall * Inverse)(IMoniker * This, IMoniker * * ppmk);			HRESULT ( __stdcall * CommonPrefixWith)(IMoniker * This, IMoniker * pmkOther, IMoniker * * ppmkPrefix);			HRESULT ( __stdcall * RelativePathTo)(IMoniker * This, IMoniker * pmkOther, IMoniker * * ppmkRelPath);			HRESULT ( __stdcall * GetDisplayName)(IMoniker * This, IBindCtx * pbc, IMoniker * pmkToLeft, LPOLESTR * ppszDisplayName);			HRESULT ( __stdcall * ParseDisplayName)(IMoniker * This, IBindCtx * pbc, IMoniker * pmkToLeft, LPOLESTR pszDisplayName, ULONG * pchEaten, IMoniker * * ppmkOut);			HRESULT ( __stdcall * IsSystemMoniker)(IMoniker * This, DWORD * pdwMksys);		}&gt;</body><body package="Com- Ole">__IParseDisplayNameVtbl	"	&lt;C: struct __IParseDisplayName {			struct __IParseDisplayNameVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IParseDisplayName IParseDisplayName&gt;	"	&lt;C: struct __IParseDisplayNameVtbl {			HRESULT ( __stdcall * QueryInterface)(IParseDisplayName * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IParseDisplayName * This);			ULONG ( __stdcall * Release)(IParseDisplayName * This);			HRESULT ( __stdcall * ParseDisplayName)(IParseDisplayName * This, IBindCtx * pbc, LPOLESTR pszDisplayName, ULONG * pchEaten, IMoniker * * ppmkOut);		}&gt;</body><body package="Com- Ole">__IPersistFileVtbl	"	&lt;C: struct __IPersistFile {			struct __IPersistFileVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IPersistFile IPersistFile&gt;	"	&lt;C: struct __IPersistFileVtbl {			HRESULT ( __stdcall * QueryInterface)(IPersistFile * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IPersistFile * This);			ULONG ( __stdcall * Release)(IPersistFile * This);			HRESULT ( __stdcall * GetClassID)(IPersistFile * This, CLSID * pClassID);			HRESULT ( __stdcall * IsDirty)(IPersistFile * This);			HRESULT ( __stdcall * Load)(IPersistFile * This, LPCOLESTR pszFileName, DWORD dwMode);			HRESULT ( __stdcall * Save)(IPersistFile * This, LPCOLESTR pszFileName, BOOL fRemember);			HRESULT ( __stdcall * SaveCompleted)(IPersistFile * This, LPCOLESTR pszFileName);			HRESULT ( __stdcall * GetCurFile)(IPersistFile * This, LPOLESTR * ppszFileName);		}&gt;</body><body package="Com- Ole">__IPersistStorageVtbl	"	&lt;C: struct __IPersistStorage {			struct __IPersistStorageVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IPersistStorage IPersistStorage&gt;	"	&lt;C: struct __IPersistStorageVtbl {			HRESULT ( __stdcall * QueryInterface)(IPersistStorage * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IPersistStorage * This);			ULONG ( __stdcall * Release)(IPersistStorage * This);			HRESULT ( __stdcall * GetClassID)(IPersistStorage * This, CLSID * pClassID);			HRESULT ( __stdcall * IsDirty)(IPersistStorage * This);			HRESULT ( __stdcall * InitNew)(IPersistStorage * This, IStorage * pStg);			HRESULT ( __stdcall * Load)(IPersistStorage * This, IStorage * pStg);			HRESULT ( __stdcall * Save)(IPersistStorage * This, IStorage * pStgSave, BOOL fSameAsLoad);			HRESULT ( __stdcall * SaveCompleted)(IPersistStorage * This, IStorage * pStgNew);			HRESULT ( __stdcall * HandsOffStorage)(IPersistStorage * This);		}&gt;</body><body package="Com- Ole">__IPersistStreamInitVtbl	"	&lt;C: struct __IPersistStreamInit {			struct __IPersistStreamInitVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IPersistStreamInit IPersistStreamInit&gt;	"	&lt;C: struct __IPersistStreamInitVtbl {			HRESULT ( __stdcall * QueryInterface)(IPersistStreamInit * This, const IID * const riid, LPVOID * ppvObj);			ULONG ( __stdcall * AddRef)(IPersistStreamInit * This);			ULONG ( __stdcall * Release)(IPersistStreamInit * This);			HRESULT ( __stdcall * GetClassID)(IPersistStreamInit * This, LPCLSID lpClassID);			HRESULT ( __stdcall * IsDirty)(IPersistStreamInit * This);			HRESULT ( __stdcall * Load)(IPersistStreamInit * This, LPSTREAM pStm);			HRESULT ( __stdcall * Save)(IPersistStreamInit * This, LPSTREAM pStm, BOOL fClearDirty);			HRESULT ( __stdcall * GetSizeMax)(IPersistStreamInit * This, ULARGE_INTEGER * pcbSize);			HRESULT ( __stdcall * InitNew)(IPersistStreamInit * This);		}&gt;</body><body package="Com- Ole">__IPersistStreamVtbl	"	&lt;C: struct __IPersistStream {			struct __IPersistStreamVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IPersistStream IPersistStream&gt;	"	&lt;C: struct __IPersistStreamVtbl {			HRESULT ( __stdcall * QueryInterface)(IPersistStream * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IPersistStream * This);			ULONG ( __stdcall * Release)(IPersistStream * This);			HRESULT ( __stdcall * GetClassID)(IPersistStream * This, CLSID * pClassID);			HRESULT ( __stdcall * IsDirty)(IPersistStream * This);			HRESULT ( __stdcall * Load)(IPersistStream * This, IStream * pStm);			HRESULT ( __stdcall * Save)(IPersistStream * This, IStream * pStm, BOOL fClearDirty);			HRESULT ( __stdcall * GetSizeMax)(IPersistStream * This, ULARGE_INTEGER * pcbSize);		}&gt;</body><body package="Com- Ole">__IPersistVtbl	"	&lt;C: struct __IPersist {			struct __IPersistVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IPersist IPersist&gt;	"	&lt;C: struct __IPersistVtbl {			HRESULT ( __stdcall * QueryInterface)(IPersist * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IPersist * This);			ULONG ( __stdcall * Release)(IPersist * This);			HRESULT ( __stdcall * GetClassID)(IPersist * This, CLSID * pClassID);		}&gt;</body><body package="Com- Ole">__IRootStorageVtbl	"	&lt;C: struct __IRootStorage {			struct __IRootStorageVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IRootStorage IRootStorage&gt;	"	&lt;C: struct __IRootStorageVtbl {			HRESULT ( __stdcall * QueryInterface)(IRootStorage * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IRootStorage * This);			ULONG ( __stdcall * Release)(IRootStorage * This);			HRESULT ( __stdcall * SwitchToFile)(IRootStorage * This, LPOLESTR pszFile);		}&gt;</body><body package="Com- Ole">__IRunningObjectTableVtbl	"	&lt;C: struct __IRunningObjectTable {			struct __IRunningObjectTableVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IRunningObjectTable IRunningObjectTable&gt;	"	&lt;C: struct __IRunningObjectTableVtbl {			HRESULT ( __stdcall * QueryInterface)(IRunningObjectTable * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IRunningObjectTable * This);			ULONG ( __stdcall * Release)(IRunningObjectTable * This);			HRESULT ( __stdcall * Register)(IRunningObjectTable * This, DWORD grfFlags, IUnknown * punkObject, IMoniker * pmkObjectName, DWORD * pdwRegister);			HRESULT ( __stdcall * Revoke)(IRunningObjectTable * This, DWORD dwRegister);			HRESULT ( __stdcall * IsRunning)(IRunningObjectTable * This, IMoniker * pmkObjectName);			HRESULT ( __stdcall * GetObject)(IRunningObjectTable * This, IMoniker * pmkObjectName, IUnknown * * ppunkObject);			HRESULT ( __stdcall * NoteChangeTime)(IRunningObjectTable * This, DWORD dwRegister, FILETIME * pfiletime);			HRESULT ( __stdcall * GetTimeOfLastChange)(IRunningObjectTable * This, IMoniker * pmkObjectName, FILETIME * pfiletime);			HRESULT ( __stdcall * EnumRunning)(IRunningObjectTable * This, IEnumMoniker * * ppenumMoniker);		}&gt;</body><body package="Com- Ole">__IStorageVtbl	"	&lt;C: struct __IStorage {			struct __IStorageVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IStorage IStorage&gt;	"	&lt;C: struct __IStorageVtbl {			HRESULT ( __stdcall * QueryInterface)(IStorage * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IStorage * This);			ULONG ( __stdcall * Release)(IStorage * This);			HRESULT ( __stdcall * CreateStream)(IStorage * This, const OLECHAR * pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream * * ppstm);			HRESULT ( __stdcall * OpenStream)(IStorage * This, const OLECHAR * pwcsName, void * reserved1, DWORD grfMode, DWORD reserved2, IStream * * ppstm);			HRESULT ( __stdcall * CreateStorage)(IStorage * This, const OLECHAR * pwcsName, DWORD grfMode, DWORD dwStgFmt, DWORD reserved2, IStorage * * ppstg);			HRESULT ( __stdcall * OpenStorage)(IStorage * This, const OLECHAR * pwcsName, IStorage * pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage * * ppstg);			HRESULT ( __stdcall * CopyTo)(IStorage * This, DWORD ciidExclude, const IID * rgiidExclude, SNB snbExclude, IStorage * pstgDest);			HRESULT ( __stdcall * MoveElementTo)(IStorage * This, const OLECHAR * pwcsName, IStorage * pstgDest, const OLECHAR * pwcsNewName, DWORD grfFlags);			HRESULT ( __stdcall * Commit)(IStorage * This, DWORD grfCommitFlags);			HRESULT ( __stdcall * Revert)(IStorage * This);			HRESULT ( __stdcall * EnumElements)(IStorage * This, DWORD reserved1, void * reserved2, DWORD reserved3, IEnumSTATSTG * * ppenum);			HRESULT ( __stdcall * DestroyElement)(IStorage * This, const OLECHAR * pwcsName);			HRESULT ( __stdcall * RenameElement)(IStorage * This, const OLECHAR * pwcsOldName, const OLECHAR * pwcsNewName);			HRESULT ( __stdcall * SetElementTimes)(IStorage * This, const OLECHAR * pwcsName, const FILETIME * pctime, const FILETIME * patime, const FILETIME * pmtime);			HRESULT ( __stdcall * SetClass)(IStorage * This, const CLSID * const clsid);			HRESULT ( __stdcall * SetStateBits)(IStorage * This, DWORD grfStateBits, DWORD grfMask);			HRESULT ( __stdcall * Stat)(IStorage * This, STATSTG * pstatstg, DWORD grfStatFlag);		}&gt;</body><body package="Com- Ole">__IStreamVtbl	"	&lt;C: struct __IStream {			struct __IStreamVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IStream IStream&gt;	"	&lt;C: struct __IStreamVtbl {			HRESULT ( __stdcall * QueryInterface)(IStream * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IStream * This);			ULONG ( __stdcall * Release)(IStream * This);			HRESULT ( __stdcall * Read)(IStream * This, void * pv, ULONG cb, ULONG * pcbRead);			HRESULT ( __stdcall * Write)(IStream * This, const void * pv, ULONG cb, ULONG * pcbWritten);			HRESULT ( __stdcall * Seek)(IStream * This, LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER * plibNewPosition);			HRESULT ( __stdcall * SetSize)(IStream * This, ULARGE_INTEGER libNewSize);			HRESULT ( __stdcall * CopyTo)(IStream * This, IStream * pstm, ULARGE_INTEGER cb, ULARGE_INTEGER * pcbRead, ULARGE_INTEGER * pcbWritten);			HRESULT ( __stdcall * Commit)(IStream * This, DWORD grfCommitFlags);			HRESULT ( __stdcall * Revert)(IStream * This);			HRESULT ( __stdcall * LockRegion)(IStream * This, ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);			HRESULT ( __stdcall * UnlockRegion)(IStream * This, ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);			HRESULT ( __stdcall * Stat)(IStream * This, STATSTG * pstatstg, DWORD grfStatFlag);			HRESULT ( __stdcall * Clone)(IStream * This, IStream * * ppstm);		}&gt;</body><body package="Com- Ole">__IUnknownVtbl	"	&lt;C: struct __IUnknown{			struct __IUnknownVtbl * lpVtbl;		}&gt;	&lt;C: typedef struct __IUnknown IUnknown&gt;	"	&lt;C: struct __IUnknownVtbl {			HRESULT ( __stdcall * QueryInterface)(IUnknown * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IUnknown * This);			ULONG ( __stdcall * Release)(IUnknown * This);		}&gt;</body></methods><methods><class-id>External.COMInterfaceVTableSignatures</class-id> <category>vtables-automation samples</category><body package="Com- Ole">__IRunnableObjectVtbl	&lt;C: struct __IRunnableObjectVtbl { 			HRESULT ( __stdcall * QueryInterface)(IRunnableObject * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IRunnableObject * This);			ULONG ( __stdcall * Release)(IRunnableObject * This);       	HRESULT ( __stdcall *GetRunningClass )(             IRunnableObject * This,            /* [out] */ LPCLSID lpClsid);                HRESULT ( __stdcall *Run )(             IRunnableObject  * This,            /* [in] */ LPBINDCTX pbc);                /* [local] */ BOOL ( __stdcall *IsRunning )(             IRunnableObject  * This);                HRESULT ( __stdcall *LockRunning )(             IRunnableObject  * This,            /* [in] */ BOOL fLock,            /* [in] */ BOOL fLastUnlockCloses);                HRESULT ( __stdcall  *SetContainedObject )(             IRunnableObject  * This,            /* [in] */ BOOL fContained);            } &gt;</body></methods><methods><class-id>External.COMInterfaceVTableSignatures</class-id> <category>vtables-COM samples</category><body package="Com- Ole">__IRandomNumberGeneratorVtbl	&lt;C: struct __IRandomNumberGeneratorVtbl {			HRESULT ( __stdcall * QueryInterface)(IUnknown * This, const IID * const riid, void * * ppvObject);			ULONG ( __stdcall * AddRef)(IUnknown * This);			ULONG ( __stdcall * Release)(IUnknown * This);			HRESULT ( __stdcall * Next)(IUnknown * This, LONG * pValue);			HRESULT ( __stdcall * Seed)(IUnknown * This, LONG * pSeed);			HRESULT ( __stdcall * SetSeed)(IUnknown * This, LONG seed);			HRESULT ( __stdcall * LowerBound)(IUnknown * This, LONG * pLowerBound);			HRESULT ( __stdcall * SetLowerBound)(IUnknown * This, LONG lowerBound);			HRESULT ( __stdcall * UpperBound)(IUnknown * This, LONG * pUpperBound);			HRESULT ( __stdcall * SetUpperBound)(IUnknown * This, LONG upperBound);		}&gt;</body></methods><methods><class-id>External.COMInterfaceVTableSignatures</class-id> <category>vtables-automation</category><body package="Com- Ole">__IRecordInfoVtbl	&lt;C: struct __IRecordInfoVtbl {         HRESULT ( __stdcall *QueryInterface )(             IRecordInfo * This,            /* [in] */ REFIID riid,            /* [iid_is][out] */ void **ppvObject);                ULONG ( __stdcall *AddRef )(             IRecordInfo * This);                ULONG ( __stdcall *Release )(             IRecordInfo * This);                HRESULT ( __stdcall *RecordInit )(             IRecordInfo * This,            /* [out] */ PVOID pvNew);                HRESULT ( __stdcall *RecordClear )(             IRecordInfo * This,            /* [in] */ PVOID pvExisting);                HRESULT ( __stdcall *RecordCopy )(             IRecordInfo * This,            /* [in] */ PVOID pvExisting,            /* [out] */ PVOID pvNew);                HRESULT ( __stdcall *GetGuid )(             IRecordInfo * This,            /* [out] */ GUID *pguid);                HRESULT ( __stdcall *GetName )(             IRecordInfo * This,            /* [out] */ BSTR *pbstrName);                HRESULT ( __stdcall *GetSize )(             IRecordInfo * This,            /* [out] */ ULONG *pcbSize);                HRESULT ( __stdcall *GetTypeInfo )(             IRecordInfo * This,            /* [out] */ ITypeInfo **ppTypeInfo);                HRESULT ( __stdcall *GetField )(             IRecordInfo * This,            /* [in] */ PVOID pvData,            /* [in] */ LPCOLESTR szFieldName,            /* [out] */ VARIANT *pvarField);                HRESULT ( __stdcall *GetFieldNoCopy )(             IRecordInfo * This,            /* [in] */ PVOID pvData,            /* [in] */ LPCOLESTR szFieldName,            /* [out] */ VARIANT *pvarField,            /* [out] */ PVOID *ppvDataCArray);                HRESULT ( __stdcall *PutField )(             IRecordInfo * This,            /* [in] */ ULONG wFlags,            /* [out][in] */ PVOID pvData,            /* [in] */ LPCOLESTR szFieldName,            /* [in] */ VARIANT *pvarField);                HRESULT ( __stdcall *PutFieldNoCopy )(             IRecordInfo * This,            /* [in] */ ULONG wFlags,            /* [out][in] */ PVOID pvData,            /* [in] */ LPCOLESTR szFieldName,            /* [in] */ VARIANT *pvarField);                HRESULT ( __stdcall *GetFieldNames )(             IRecordInfo * This,            /* [out][in] */ ULONG *pcNames,            /* [length_is][size_is][out] */ BSTR *rgBstrNames);                BOOL ( __stdcall *IsMatchingType )(             IRecordInfo * This,            /* [in] */ IRecordInfo *pRecordInfo);                PVOID ( __stdcall *RecordCreate )(             IRecordInfo * This);                HRESULT ( __stdcall *RecordCreateCopy )(             IRecordInfo * This,            /* [in] */ PVOID pvSource,            /* [out] */ PVOID *ppvDest);                HRESULT ( __stdcall *RecordDestroy )(             IRecordInfo * This,            /* [in] */ PVOID pvRecord);    }&gt;</body></methods><methods><class-id>External.X86COMInterface</class-id> <category>types</category><body package="Com- Ole">vtableType	&lt;C: typedef struct _vtableType {		unsigned long size;		entryPointType *entries; 		} vtableType&gt;</body></methods><methods><class-id>Core.CommandLineInterest class</class-id> <category>dependencies-pragma</category><body package="Com- Ole">registerCOMServers: tokenReadStream	&lt;triggerAtSystemEvent: #returnFromSnapshot option: '-RegServer' sequence: 20&gt;	| classes reportStream |	classes := self registrationClassesFrom: tokenReadStream.	COMSystem current whenActiveDo: 			[reportStream := WindowingSystem isHeadless						ifTrue: [Transcript]						ifFalse: [String new writeStream].			classes isEmpty				ifTrue: 					[reportStream						nextPutAll: (#registryUnaltered &lt;&lt; #com &gt;&gt; 'No changes to Windows registry') asString]				ifFalse: 					[classes do: 							[:each |							each comRegistrationSpec register								ifTrue: 									[reportStream										nextPutAll: each unambiguousName;										cr]].					reportStream						nextPutAll: (#classRegistrationAdded &lt;&lt; #com &gt;&gt; 'Successfully added to Windows registry')								asString].			WindowingSystem isHeadless ifFalse: [Dialog warn: reportStream contents].			"A COM Server should quit after registering the COM classes as there is normally no user"			ObjectMemory quit]</body><body package="Com- Ole">unregisterCOMServers: tokenReadStream 	&lt;triggerAtSystemEvent: #returnFromSnapshot option: '-UnregServer' sequence: 20&gt;	| classes reportStream |	classes := self registrationClassesFrom: tokenReadStream.	COMSystem current whenActiveDo: [	reportStream := WindowingSystem isHeadless 				ifTrue: [Transcript]				ifFalse: [String new writeStream].	classes isEmpty 		ifTrue: 			[reportStream 				nextPutAll: (#registryUnaltered &lt;&lt; #com &gt;&gt; 'No changes to Windows registry') 						asString]		ifFalse: 			[classes do: 					[:each | 					each comRegistrationSpec unregister 						ifTrue: 							[reportStream								nextPutAll: each unambiguousName;								cr]].			reportStream 				nextPutAll: (#classRegistrationRemoved &lt;&lt; #com 						&gt;&gt; 'Successfully removed from Windows registry') asString].	WindowingSystem isHeadless ifFalse: [Dialog warn: reportStream contents].	"A COM Server should quit after registering the COM classes as there is normally no user"	ObjectMemory quit ].</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>actions</category><body package="Com- Ole">comSubMenu	"Stub for genering COM menu"	&lt;submenu: #(#COM #com 'COM')		nameKey: #comc		menu: #(#menuBar tools)		position: 20.50&gt;</body></methods><methods><class-id>External.AdviseInfo</class-id> <category>testing</category><body package="Com- Ole">provideNoData	^(flags bitAnd: ADVF_NODATA) = ADVF_NODATA</body><body package="Com- Ole">triggerBeforeDemise	^(flags bitAnd: ADVF_DATAONSTOP) = ADVF_DATAONSTOP</body><body package="Com- Ole">triggerOnInstallation	^(flags bitAnd: ADVF_PRIMEFIRST) = ADVF_PRIMEFIRST</body><body package="Com- Ole">triggerOnlyOnce	^(flags bitAnd: ADVF_ONLYONCE) = ADVF_ONLYONCE</body></methods><methods><class-id>External.AdviseInfo</class-id> <category>accessing</category><body package="Com- Ole">flags	^flags</body><body package="Com- Ole">flags: anObject	flags := anObject</body><body package="Com- Ole">formatEtc	^formatEtc</body><body package="Com- Ole">formatEtc: anObject	formatEtc := anObject</body><body package="Com- Ole">key	^key</body><body package="Com- Ole">key: anObject	key := anObject</body><body package="Com- Ole">sink	^sink</body><body package="Com- Ole">sink: anObject	sink := anObject</body></methods><methods><class-id>External.AdviseInfo</class-id> <category>As yet unclassified</category><body package="Com- Ole">asStatData	| iAdvSink |	iAdvSink := sink asSeparateInterfacePointer.	^	[(COM_STATDATA new)		memberAt: #pAdvSink put: iAdvSink asPointerParameter;		memberAt: #formatetc put: formatEtc asStructureParameter;		memberAt: #advf put: flags;		memberAt: #dwConnection put: key;		yourself]			ensure: [iAdvSink enforceInvalidation]</body></methods><methods><class-id>External.AdviseInfo class</class-id> <category>instance creation</category><body package="Com- Ole">formatEtc: aFormatEtc flags: advf sink: anAdviseSink key: key	^(self new)		formatEtc: aFormatEtc;		flags: advf;		sink: anAdviseSink;		key: key;		yourself</body></methods><methods><class-id>External.COMWarning</class-id> <category>private-testing</category><body package="Com- Ole">displayWarningMessages		" Private - answer whether to display warning messages in the current session. "	^self class displayWarningMessages</body></methods><methods><class-id>External.COMWarning</class-id> <category>private-defaults</category><body package="Com- Ole">defaultAction	"Display a notifier and then continue."	self class displayWarningMessages		ifFalse: [ ^self ].	^MessageBox notify: (#COMConnectWarning &lt;&lt; #com &gt;&gt; 'COM Connect Warning') asString		withText: self description</body></methods><methods><class-id>External.COMWarning class</class-id> <category>private-testing</category><body package="Com- Ole">displayWarningMessages		" Private - answer whether to display warning messages in the current session. "	" Suppress warnings in the product build; enable in internal dev system. "	^true	" was: ^self isInLibrary not "</body><body package="Com- Ole">log: aString	 Transcript show: aString;cr.</body></methods><methods><class-id>External.COMDevelopmentWarning</class-id> <category>private-testing</category><body package="Com- Ole">displayWarningMessages		" Private - answer whether to display developer-only warning messages in the current session. "	" COMDevelopmentWarning displayWarningMessages "	^ImageConfiguration isDevelopment</body></methods><methods><class-id>External.COMDevelopmentWarning</class-id> <category>private-defaults</category><body package="Com- Ole">defaultAction        "Display a notifier and then continue."	self class displayWarningMessages		ifFalse: [ ^self ].	MessageBox notify: (#GenKey3 &lt;&lt; #com &gt;&gt; 'COM Connect Development Warning') asString		withText: self description.</body></methods><methods><class-id>External.COMDevelopmentWarning class</class-id> <category>private-testing</category><body package="Com- Ole">displayWarningMessages		" Private - answer whether to display developer-only warning messages in the current session. "	" COMDevelopmentWarning displayWarningMessages "	^ImageConfiguration isDevelopment</body></methods><methods><class-id>External.COMDevelopmentWarning class</class-id> <category>session  startup</category><body package="Com- Ole">resetMessages	AlreadyRaised := nil</body></methods><methods><class-id>External.COMDevelopmentWarning class</class-id> <category>As yet unclassified</category><body package="Com- Ole">alreadyRaised	^AlreadyRaised ifNil: [AlreadyRaised := Set new]</body><body package="Com- Ole">raiseSignalOnce: aUserMessage 	| aString |	aString := aUserMessage asString.	(self alreadyRaised includes: aString)  ifTrue: [ ^self].	self alreadyRaised add: aString .	^ self raiseSignal: aString .</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>testing</category><body package="Com- Ole">isCOMInterface	" Answer whether the receiver is a COM interface. "	^true</body><body package="Com- Ole">isCOMInterfaceAdaptor	" Answer whether the receiver is an adaptor on a COM interface. "	^false</body><body package="Com- Ole">isCOMInterfaceBinding	" Answer whether the receiver is a COM interface binding which provides direct access to the raw interface functions of a COM interface. "	^true</body><body package="Com- Ole">isMTAObject	^ self subclassResponsibility</body><body package="Com- Ole">isSTAObject	^ self subclassResponsibility</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>accessing</category><body package="Com- Ole">implementingObject	" Answer the COM object in the current process which supports the receiver.  Answer nil if the interface is not supported by a Smalltalk object in the current session. "	self subclassResponsibility.</body><body package="Com- Ole">interfaceBinding	" Answer the interface binding which provides function invocation services for the receiver. "	^self</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>subclass-accessing</category><body package="Com- Ole">interfaceReferenceClass	" Private - answer the COM interface class that references the receiver. "	^self class interfaceReferenceClass</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>subclass-tracing</category><body package="Com- Ole">isTraceTypeEnabled: callerType	" Private - answer whether tracing of the specified type is currently enabled for the receiver. "	^self isTraceTypeEnabled: callerType forIID: self iid</body><body package="Com- Ole">isTraceTypeEnabled: callerType forIID: anIID	" Private - answer whether tracing of the specified type is currently enabled for the receiver. "	^COMSessionManager isTraceEnabled		and: [ COMSessionManager traceManager isTraceTypeEnabled: callerType forIID: anIID ]</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>identity</category><body package="Com- Ole">iid	" Answer the interface ID GUID which uniquely identifies the receiver. "	^self class iid</body><body package="Com- Ole">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;.  The default is to do nothing - the IID is known by the class.  This method is reimplemented by subclasses whose instances can represent more than one interface. "	"Assert isTrue: [ self class supportsIID: anIID ]."</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>converting</category><body package="Com- Ole">asInterfaceReference	" Answer a civilized interface reference on the receiver. "	^self interfaceReferenceClass forBinding: self</body><body package="Com- Ole">asSeparateInterfacePointer	self subclassResponsibility</body><body package="Com- Ole">storeSelfInPointer: aPointer 	self subclassResponsibility</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>releasing</category><body package="Com- Ole">enforceInvalidation	"Enforce invalidation of the receiver. Only call this method if you know this is required. 	 The object will be unusable afterwards"	^ self privateInvalidate</body><body package="Com- Ole">enforceRelease	^ self</body><body package="Com- Ole">privateInvalidate	self subclassResponsibility</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>private interface operations</category><body package="Com- Ole">privateRelease	self subclassResponsibility</body></methods><methods><class-id>External.COMInterfaceBinding</class-id> <category>subclass-error handling</category><body package="Com- Ole">hresultSucceeded: hresult	" Answer whether &lt;hresult&gt; is a success return code. "	" This service is only necessary if a subclass chooses to include		the COM external type definition pool in its compilation		context, which results in the HRESULT CType definition		overriding the HRESULT class in the name space. "	^hresult asHRESULT succeeded</body></methods><methods><class-id>External.COMInterfaceBinding class</class-id> <category>subclass-accessing</category><body package="Com- Ole">iid: anIID 	" Private - set the the interface ID which uniquely identifies instances  of the receiver to the GUID &lt;anIID&gt;. "	(iid notNil and: [anIID notNil and: [iid ~= anIID]]) 		ifTrue: 			[" might be an initialization bug that developer should know about "			COMDevelopmentWarning 				raiseSignal: (#ErrNamedIIDChange &lt;&lt; #com 						&gt;&gt; 'Changing the IID of &lt;1s&gt; from &lt;2p&gt; to &lt;3p&gt;.' 							expandMacrosWith: self name							with: iid							with: anIID)].	iid := anIID</body><body package="Com- Ole">interfaceReferenceClass	" Private - answer the COM interface class that references instance of the receiver. "	^COMInterface classForIID: self iid</body></methods><methods><class-id>External.COMInterfaceBinding class</class-id> <category>identity</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid		ifNil: 			[self initializeIfImplemented.			iid]</body><body package="Com- Ole">supportsIID: anIID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^self iid = anIID</body></methods><methods><class-id>External.COMInterfaceBinding class</class-id> <category>private-VTable utilities</category><body package="Com- Ole">compareCalloutEPT: aCalloutEPT toCallinEPT: aCallinEPT	" Private - compare the callout and callin entry point descriptions and answer whether they are the same. "	( aCallinEPT name = aCalloutEPT name	and: [ aCallinEPT vtableIndex = aCalloutEPT vtableIndex	and: [ aCallinEPT numberOfArguments = ( aCalloutEPT numberOfArguments + 1 )  " asymmetry of This "	and: [ aCallinEPT resultType baseType = aCalloutEPT resultType baseType] ] ] )		ifFalse: [ ^false ].	Tools.Note ISSUE.  " Add checking on arg types when callout EPT's reworked [DL 12-Apr-97] "	^true</body></methods><methods><class-id>External.COMExternalInterface class</class-id> <category>argument buffer services</category><body package="Com- Ole">createCOSERVERINFOBuffer: serverName	"Allocate and answer a COSERVERINFO structure for a &lt;serverName&gt;.  The caller must send #asPointerParameter to the buffer when it is passed as a function argument and ensure that #release is sent to the buffer after the function call is made. "	^COMCOSERVERINFOBuffer for: serverName</body><body package="Com- Ole">createSNBBuffer: stringList	"Allocate and answer an SNB structure for the strings in &lt;stringList&gt;.  The caller must send #asPointerParameter to the buffer when it is passed as a function argument and ensure that #release is sent to the buffer after the function call is made. "	^COMSNBBuffer for: stringList</body><body package="Com- Ole">multiQIResultBuffer: anIIDList	" Answer an object which can be used to as the buffer to obtain a list of interface pointers corresponding to the interfaces specified by the interface ID's in &lt;anIIDList&gt;.  The caller must send #asPointerParameter to the buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^COMMultiQIResultBuffer for: anIIDList</body><body package="Com- Ole">unicodeReadOnlyResultBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a Unicode string allocated by the callee in COM task memory.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value.  The COM memory of the string is not released. "	^Win32UnicodeStringPointerResultBuffer new</body><body package="Com- Ole">unicodeResultBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a Unicode string allocated by the callee in COM task memory.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^COMUnicodeStringPointerResultBuffer new</body></methods><methods><class-id>External.COMExternalInterface class</class-id> <category>argument validation</category><body package="Com- Ole">checkInOutStructureParameter: aStructure	" Ensure that an IN/OUT structure parameter is in stable memory. "	( aStructure isCOMStructure   " stabilized if necessary by #asPointerParameter "	or: [ aStructure isExternalAddress ] )		ifFalse: [ COMError raiseSignal: #ErrIOStrucNotInExtMem &lt;&lt; #com &gt;&gt; '[in][out] structure not in external memory' ].</body></methods><methods><class-id>External.COMExternalInterface class</class-id> <category>argument conversion services</category><body package="Com- Ole">asClassContextParameter: aCLSCTX	"Answer &lt;aCLSCTX&gt; enabled for DCOM if the system is running on DCOM."	COMSessionManager isDCOMAvailable		ifFalse: [ ^aCLSCTX ].	aCLSCTX = CLSCTX_ALL		ifTrue: [ ^CLSCTX_ALL | CLSCTX_REMOTE_SERVER ].	aCLSCTX = CLSCTX_SERVER		ifTrue: [ ^CLSCTX_SERVER | CLSCTX_REMOTE_SERVER ].	^aCLSCTX</body><body package="Com- Ole">asFileTimeParameter: aFileTimeOrTimeStamp	" Answer &lt;aFileTimeOrTimeStamp&gt; as a FILETIME * parameter. "	Tools.Note ISSUEin72. "no implementor of isTimeStamp - changed implementation" 	^ aFileTimeOrTimeStamp asFileTime asPointerParameter</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>converting</category><body package="Com- Ole">actualImplementor 	^ self</body><body package="Com- Ole">asInteger	" Answer the integer value which is the address of the receiver's VTable pointer in external memory. "	^interfaceAddress isNil		ifTrue: [ 0 ]		ifFalse: [ interfaceAddress ]</body><body package="Com- Ole">asInterfacePointer	" Answer an interface pointer for the receiver's VTable in external memory. "	^self</body><body package="Com- Ole">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	"???? ^self asInteger ???"	| cPointer |	self matchesProcessApartment ifFalse: [ ^ self marshalToOtherApartment asPointerParameter ].	cPointer := CVoidType void pointerType cast: interfaceAddress.	SystemGlobalRegistries safe: self forLifeTimeOf: cPointer.	^ cPointer.</body><body package="Com- Ole">storeSelfInPointer: aPointer	"Put myself into the given pointer buffer. Ensure reference counting is correct."	| otherApartmentPointer |	self matchesProcessApartment		ifTrue: 			["If I exist in the apartment of the current process, we don't need to do any marshaling.			  In this case, just call AddRef on myself and store my interface address in the pointer buffer"			self invokeAddRef.			aPointer contents: self interfaceAddress]		ifFalse: 			[ "If we are in the wrong apartment, we need to marshal the pointer. This will automatically cause 			  AddRef to be called on the Interface. Afterwards ther marshaled interface is invalidated to avoid finalization since the 			  reference has been transferred to the pointer buffer."			otherApartmentPointer := self marshalToOtherApartment.			aPointer contents: otherApartmentPointer interfaceAddress.			otherApartmentPointer enforceInvalidation	]</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>subclass-error handling</category><body package="Com- Ole">externalAccessFailed	 "Raise an exception that indicates something went wrong with an external access. Try to get the error code from the sending context. "	" Note that use of this method is discouraged.  Clients should simply use #externalAccessFailedWith: in the first place.  It is provided only for consistency with ExternalInterface. "	| errorCode |	"( thisContext sender method isKindOf: ExternalMethod )"	( thisContext sender method class == self externalMethodClass )		ifTrue: [ errorCode := thisContext sender top ].	^self externalAccessFailedWith: errorCode</body><body package="Com- Ole">externalAccessFailedWith: errorCode	" Raise an exception that indicates something went wrong with an external access. "	( errorCode isError 	and: [ errorCode name = #'hresult error'  ] )		ifTrue: [ ^self signalExceptionForHRESULT: errorCode parameter asHRESULT ].	^self signalExceptionForErrorCode: errorCode</body><body package="Com- Ole">externalAccessFailedWith: errorCode allowAnyHRESULTOf: listOfAcceptableValues	" An external function call has failed.  If it is an HRESULT failure and the value is one of the error codes in &lt;listOfAcceptableValues&gt;, return the HRESULT value.  Otherwise raise an exception that indicates something went wrong with an external access. "	( errorCode isError	and: [ errorCode name = #'hresult error' ] )		ifTrue: [ 			"^self checkHresult: hresult allowAny: acceptableValue"			| hresult |			hresult := errorCode parameter asHRESULT.			( listOfAcceptableValues includes: hresult )				ifTrue: [ ^hresult ].			^self signalExceptionForHRESULT: hresult ].	^self signalExceptionForErrorCode: errorCode</body><body package="Com- Ole">externalAccessFailedWith: errorCode allowHRESULT: acceptableValue	" An external function call has failed.  If it is an HRESULT failure and the value is &lt;acceptableValue&gt;, return the HRESULT value.  Otherwise raise an exception that indicates something went wrong with an external access. "	( errorCode isError	and: [ errorCode name = #'hresult error' ] )		ifTrue: [ 			"^self checkHresult: hresult allow: acceptableValue"			| hresult |			hresult := errorCode parameter asHRESULT.			hresult = acceptableValue				ifTrue: [ ^hresult ].			^self signalExceptionForHRESULT: hresult ].	^self signalExceptionForErrorCode: errorCode</body><body package="Com- Ole">externalAccessFailedWith: errorCode allowHRESULT: acceptableValue or: anotherAcceptableValue	" An external function call has failed.  If it is an HRESULT failure and the value is &lt;acceptableValue&gt; or &lt;anotherAcceptableValue, return the HRESULT value.  Otherwise raise an exception that indicates something went wrong with an external access. "	( errorCode isError	and: [ errorCode name = #'hresult error' ] )		ifTrue: [ 			"^self checkHresult: hresult allow: acceptableValue or: anotherAcceptableValue"			| hresult |			hresult := errorCode parameter asHRESULT.			( hresult = acceptableValue or: [ hresult = anotherAcceptableValue ] )				ifTrue: [ ^hresult ].			^self signalExceptionForHRESULT: hresult ].	^self signalExceptionForErrorCode: errorCode</body><body package="Com- Ole">signalExceptionForErrorCode: errorCode	" Private - an external function call has failed for a reason other than an HRESULT failure.  Raise an exception. "	^ExternalInterface externalAccessFailedSignal		raiseWith: self		errorString: (errorCode isError ifTrue:						[nil == errorCode parameter							ifTrue: [errorCode name]							ifFalse: [errorCode errorMessageString]])</body><body package="Com- Ole">signalExceptionForHRESULT: hresult	" Private - raise an exception for the HRESULT error code &lt;hresult&gt;. "	( hresult succeeded)		ifTrue: [    " VM problem, should not ever be here in the first place "			^self error:				(#ErrNamedHRESULTfail &lt;&lt; #com 						&gt;&gt; 'Unexpected HRESULT external function call failure ( &lt;1s&gt; )' 							expandMacrosWith: (hresult value printStringRadix: 16)) ].	^COMCallOutError hresult: hresult</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>private-accessing</category><body package="Com- Ole">externalAccessFailedSignal	^ self class externalAccessFailedSignal</body><body package="Com- Ole">externalMethodClass	"Answer the class that should be used when compiling optimized forms of the receiver's methods."	^self class externalMethodClass</body><body package="Com- Ole">interfaceAddress	" Private - answer the address in external memory of the receiver's interface data structures (ptr-ptr-VTable). "	^interfaceAddress</body><body package="Com- Ole">interfaceAddress: anAddress	" Private - set the reference to the receiver's interface function table in external memory. "	"Assert isTrue: [ anAddress isNil or: [ anAddress isInteger ] ]."	interfaceAddress := ( anAddress = 0		ifTrue: [ nil ]		ifFalse: [ anAddress ] ).</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>printing</category><body package="Com- Ole">printHexAddressOn: aStream		" Append a text description of the receiver's COM external memory address to &lt;aStream&gt; "	aStream nextPutAll: ' {'.	self isValid		ifTrue: [ self asInteger printOn: aStream paddedWith: $0 to: 8 base: 16 ]		ifFalse: [ aStream nextPutAll: 'invalid' ].	aStream nextPut: $}.</body><body package="Com- Ole">printOn: aStream		" Append a text description of the receiver to &lt;aStream&gt; "	super printOn: aStream.	aStream space.	self printHexAddressOn: aStream.</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>comparing</category><body package="Com- Ole">= anObject	" Answer whether the receiver and &lt;anObject&gt; represent the same interface. "	^anObject isCOMInterface 		and: [ self iid = anObject iid		and: [ anObject interfaceBinding interfaceEqual: self ] ]</body><body package="Com- Ole">hash	"Answer the integer hash of the receiver."	^self iid hash bitXor: self asInteger hash</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>testing</category><body package="Com- Ole">isCOMInterfacePointer	" Answer whether the receiver is a COM interface referencing a VTable in external memory. "	^true</body><body package="Com- Ole">isSTAObject	^ self isMTAObject not</body><body package="Com- Ole">isValid	"Answer whether the receiver is a valid (non-NULL) interface pointer."	^self asInteger ~= 0</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>private-finalizing</category><body package="Com- Ole">finalizationRegistry	"Private - Answer the registry to be used for finalizing instances of the receiver."	^COMSessionManager ownedInterfacesRegistry</body><body package="Com- Ole">finalize	"The receiver is no longer referenced by any object in the system and is about to be destroyed.  Release the interface reference. "	self doesNotNeedFinalization.	self isValid ifFalse: [^self].	"Some COM servers terminate immediately after quit commands. 	 So ignore errors which may appear on finalization of interface pointers."	self privateFinalizeInCorrectApartment: 			[[self privateRelease] on: Error do: [:ex | ex return]].</body><body package="Com- Ole">privateFinalizeInCorrectApartment: aBlock	"private - finalize myself in the correct apartment."	^self isMTAObject		ifTrue: [COMThreadManager performMTAFinalizationDo: aBlock]		ifFalse: [aBlock value]</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>private-comparing</category><body package="Com- Ole">interfaceEqual: anInterface	" Private - answer whether the receiver and &lt;anInterface&gt; are the same interface.  The IID's are assumed to be equal. "	"Assert isTrue: [ anInterface isOLEInterfaceReference not ]."	"Assert isTrue: [ anInterface isOLEInterfacePointer ]."	^self asInteger = anInterface asInterfacePointer asInteger</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>accessing</category><body package="Com- Ole">functionAdaptor	" Answer the interface function adaptor which is configured for the receiver.  Answer nil if this is a direct binding of the interface to the real implementor. "	^nil</body><body package="Com- Ole">implementingObject	" Answer the COM object in the current process which supports the receiver.  Answer nil if the interface is not supported by a local Smalltalk COM object. "	| anInterfaceImpl |	anInterfaceImpl := COMInterfaceImplementation localImplementorOf: self.	^anInterfaceImpl ifNotNil: [anInterfaceImpl implementingObject]</body><body package="Com- Ole">isAppartmentDefined	^isMTAObject notNil</body><body package="Com- Ole">isMTAObject	^isMTAObject</body><body package="Com- Ole">isMTAObject: anObject	isMTAObject := anObject</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>private-session management</category><body package="Com- Ole">shutdownImage	"Private - The image session is being shut down.  All allocated interfaces should have already been released at this point; cannot release now because memory allocators and OLEDLL are closed. "	self isValid 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#ErrNamedUnreleasedIntExit &lt;&lt; #com 						&gt;&gt; 'Unreleased COM interface impl found at image exit: &lt;1p&gt;' 							expandMacrosWith: self)]</body><body package="Com- Ole">startupImage	"Private - The image session is being started.  Invalidate the receiver, since any external memory referenced in a previous session is no longer valid."	self privateInvalidate.</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>private-copying</category><body package="Com- Ole">copyInterfaceBinding	" Private - answer a copy of the receiver interface binding.  This is used carefully when copying an interface reference. "	^ self</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>obsolete</category><body package="Com- Ole">Release	self callIsDispensable.</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>releasing</category><body package="Com- Ole">invalidate		self callIndicatesChangeNeeded.</body><body package="Com- Ole">privateInvalidate	"Invalidate the receiver and remove from finalization (if not already done).  Subclasses will typically augment this method (via super) to release or free any associated system or COM resources or references."	self doesNotNeedFinalization.	self interfaceAddress: nil.  " ?? use zero?  have to handle nil anyway, so this is fine "</body><body package="Com- Ole">release	self callIsDispensable.	^ super release.</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>private interface operations</category><body package="Com- Ole">invokeAddRef	" AddRef, implemented in IUnknownPointer"</body><body package="Com- Ole">performInCorrespondingAppartment: aBlock	"Perform the block in the appartment in which the com object lives.	This obviates marshaling the interface between appartments. 	This is extremely important for addRef/release calls where we definitely don't want  this to happen.	This method allows performing calls based on the appartment of the object, not on the process the 	call is performed in"	^self isMTAObject		ifTrue: [COMThreadManager performInMTA: aBlock]		ifFalse: [COMThreadManager performInSTA: aBlock]</body><body package="Com- Ole">privateRelease	^ self doesNotNeedFinalization.</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>subclass-initialization</category><body package="Com- Ole">initialize	"Private - Initialize any private state within the receiver.  Subclasses that reimplement this method should ensure they send 'super initialize'.  Answer the receiver."	self isMTAObject: COMThreadManager isActiveProcessAnMTAProcess.	self interfaceAddress: nil	"?? use zero?  have to handle nil anyway, so this is fine "</body></methods><methods><class-id>External.COMInterfacePointer</class-id> <category>marshaling</category><body package="Com- Ole">marshalToOtherApartment	^ self isMTAObject 		ifTrue: [ COMThreadManager marshalToSTA: self ]		ifFalse: [ COMThreadManager marshalToMTA: self ]</body><body package="Com- Ole">matchesProcessApartment	^self isMTAObject = COMThreadManager isActiveProcessAnMTAProcess</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>external-transformations</category><body package="Com- Ole">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery."	"TBD: consider alternate import format: ^CIntegerType unsignedLong"	^CVoidType void pointerType</body><body package="Com- Ole">fromReturnValue: aPointerOrInteger	" Answer a new instance of the receiver for the interface pointer represented by the CPointer or Integer value &lt;aPointerOrInteger&gt; which has been obtained as an OUT parameter return value from an external function call.  Since in general the ownership responsibility of an OUT parameter is transferred to the caller, mark the interface as needing finalization to ensure that it is released by the caller.  Answer nil if the pointer is not valid. "	| anInterfaceAddress |	anInterfaceAddress := self getAddressValueFrom: aPointerOrInteger.	anInterfaceAddress == nil		ifTrue: [ ^nil ].	^self newResultInterfacePointerAtAddress: anInterfaceAddress</body><body package="Com- Ole">fromReturnValue: aPointerOrInteger iid: anIID	" Answer a new instance of the COM interface identified by the GUID &lt;anIID&gt; for the interface pointer represented by the CPointer or Integer value &lt;aPointerOrInteger&gt; which has been obtained as an OUT parameter return value from an external function call.  Since in general the ownership responsibility of an OUT parameter is transferred to the caller, mark the interface as needing finalization to ensure that it is released by the caller.  Answer nil if the pointer is not valid. "	| anInterfaceAddress |	anInterfaceAddress := self getAddressValueFrom: aPointerOrInteger.	anInterfaceAddress == nil		ifTrue: [ ^nil ].	^( self classForIID: anIID ifNone: [ IAnonymousPointer ] ) new		iid: anIID; 		interfaceAddress: anInterfaceAddress;		yourself</body><body package="Com- Ole">newParameterAtAddress: anExternalAddress	" Answer a new instance of the receiver for an interface whose pointer value is in external memory referenced by &lt;anExternalAddress&gt;.  The new interface pointer is not separately reference counted and should not be released by the caller.  The interface pointer does not use finalization. "	| anInterfaceAddress |	anInterfaceAddress := self getAddressValueFrom: anExternalAddress.	anInterfaceAddress == nil		ifTrue: [ ^nil ].	^self new		interfaceAddress: anInterfaceAddress;		enforceAddRef;		yourself</body><body package="Com- Ole">newResultInterfacePointerAtAddress: anExternalAddress	" Answer a new instance of the receiver for an interface whose pointer value is in external memory referenced by &lt;anExternalAddress&gt;.  The new interface pointer is not separately reference counted and should not be released by the caller.  The interface pointer does not use finalization. "	| anInterfaceAddress |	anInterfaceAddress := self getAddressValueFrom: anExternalAddress.	anInterfaceAddress == nil		ifTrue: [ ^nil ].	^self new		interfaceAddress: anInterfaceAddress;		yourself</body><body package="Com- Ole">newTemporaryInterfacePointerAtAddress: anExternalAddress	" Answer a new instance of the receiver for an interface whose pointer value is in external memory referenced by &lt;anExternalAddress&gt;. In earlier versions of COM connect, this interface pointer was not referencecounted. From 7.9 on,	it is at it may be kept by the server object."	| anInterfaceAddress |	anInterfaceAddress := self getAddressValueFrom: anExternalAddress.	anInterfaceAddress == nil		ifTrue: [ ^nil ].	^self new		interfaceAddress: anInterfaceAddress;		enforceAddRef;		yourself</body><body package="Com- Ole">newUncountedInterfacePointerAtAddress: anExternalAddress	" Answer a new instance of the receiver for an interface whose pointer value is in external memory referenced by &lt;anExternalAddress&gt;. 	 Please note that the returned interface is not reference counted and not managed by COM Connect."	| anInterfaceAddress |	anInterfaceAddress := self getAddressValueFrom: anExternalAddress.	anInterfaceAddress == nil ifTrue: [^nil].	^(self privateNew)		interfaceAddress: anInterfaceAddress;		yourself</body><body package="Com- Ole">releaseInterfaceAtAddress: aPointer	(IUnknownPointer newUncountedInterfacePointerAtAddress: aPointer) enforceRelease.</body><body package="Com- Ole">resultValueArrayBuffer: count	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an array of &lt;count&gt; instances of the receiver.  The caller must send #asPointerParameter to the buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value.  The returned interface pointers become the responsibility of the caller, who must release them when done, in the usual fashion. "	^COMInterfacePointerArrayResultBuffer type: self count: count</body><body package="Com- Ole">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an instance of the receiver.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^COMInterfacePointerResultBuffer for: self</body><body package="Com- Ole">resultValueBufferForIID: anIID	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an interface pointer instance of the interface identified by the GUID &lt;anIID&gt;.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	| anInterfacePointerClass |	anInterfacePointerClass := self classForIID: anIID		ifNone: [ ^COMInterfacePointerResultBuffer for: IAnonymousPointer iid: anIID ].	^COMInterfacePointerResultBuffer for: anInterfacePointerClass</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>private-IID class map</category><body package="Com- Ole">initializeIIDMap	" Private - initialize the IID-to-class map. "	self iidMap: Dictionary new.</body><body package="Com- Ole">interfaceImplementationClassForIID: anIID	" Private - answer the interface callin binding class for the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry |	iidEntry := self iidMap at: anIID " ptr, reference, impl "		ifAbsent: [ ^nil ].	^iidEntry at: 3</body><body package="Com- Ole">interfacePointerClassForIID: anIID	" Private - answer the interface pointer binding class for the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry |	iidEntry := self iidMap at: anIID " ptr, reference, impl "		ifAbsent: [ ^nil ].	^iidEntry at: 1</body><body package="Com- Ole">interfaceReferenceClassForIID: anIID	" Private - answer the interface reference class for the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry |	iidEntry := self iidMap at: anIID " ptr, reference, impl "		ifAbsent: [ ^nil ].	^iidEntry at: 2</body><body package="Com- Ole">registerInterfaceImplementationClass: aClass forIID: anIID	" Private - register &lt;aClass&gt; as the interface callin binding class for the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry |	( anIID isNil or: [ anIID = IID_NULL ] )		ifTrue: [ ^nil ].  " ignore null IID's of abstract interface classes "	self iidMap isNil		ifTrue: [ self initializeIIDMap ].	iidEntry := self iidMap at: anIID 		ifAbsentPut: [ Array new: 3 ].  " ptr, reference, impl "	iidEntry at: 3 put: aClass.	^aClass</body><body package="Com- Ole">registerInterfacePointerClass: aClass forIID: anIID	 " Private - register &lt;aClass&gt; as the interface pointer binding class for the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry registeredClass |	( anIID isNil or: [ anIID = IID_NULL ] )		ifTrue: [ ^nil ].  " ignore null IID's of abstract interface classes "	self iidMap isNil		ifTrue: [ self initializeIIDMap ].	iidEntry := self iidMap at: anIID 		ifAbsentPut: [ Array new: 3 ].  " ptr, reference, impl "	registeredClass := iidEntry at: 1.	" pointer registrations must be unique; changing may be a programmer error "	( registeredClass notNil and: [ registeredClass ~~ aClass ] )		ifTrue: [			( MessageBox confirm: 				((#AboutToReplaceRegistrationForID &lt;&lt; #com &gt;&gt; 'You are about to replace the interface pointer registration for IID &lt;1s&gt; of &lt;2s&gt; with &lt;3s&gt; - this may be an error.  Do you wish to proceed?')					expandMacrosWith: anIID printString					with: registeredClass name					with: aClass name) )				ifFalse: [ Screen default ringBell. ^nil ] ].	iidEntry at: 1 put: aClass.	^aClass</body><body package="Com- Ole">registerInterfaceReferenceClass: aClass forIID: anIID	" Private - register &lt;aClass&gt; as the interface class representing the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry |	( anIID isNil or: [ anIID = IID_NULL ] )		ifTrue: [ ^nil ].  " ignore null IID's of abstract interface classes "	self iidMap isNil		ifTrue: [ self initializeIIDMap ].	iidEntry := self iidMap at: anIID 		ifAbsentPut: [ Array new: 3 ].  " ptr, reference, impl "	iidEntry at: 2 put: aClass.	^aClass</body><body package="Com- Ole">removeInterfaceImplementationClassForIID: anIID	" Private - unregister &lt;aClass&gt; as the interface callin binding class for the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry |	iidEntry := self iidMap at: anIID  " ptr, reference, impl "		 ifAbsent: [ ^nil ].	iidEntry at: 3 put: nil.	iidEntry = #( nil nil nil )		ifTrue: [ self iidMap removeKey: anIID ].</body><body package="Com- Ole">removeInterfacePointerClassForIID: anIID	" Private - unregister &lt;aClass&gt; as the interface pointer binding class for the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry |	iidEntry := self iidMap at: anIID  " ptr, reference, impl "		ifAbsent: [ ^nil ].	iidEntry at: 1 put: nil.	iidEntry = #( nil nil nil )		ifTrue: [ self iidMap removeKey: anIID ].</body><body package="Com- Ole">removeInterfaceReferenceClassForIID: anIID	" Private - unregister &lt;aClass&gt; as the interface reference class for the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| iidEntry |	iidEntry := self iidMap at: anIID  " ptr, reference, impl "		 ifAbsent: [ ^nil ].	iidEntry at: 2 put: nil.	iidEntry = #( nil nil nil )		ifTrue: [ self iidMap removeKey: anIID ].</body><body package="Com- Ole">subclassForIID: anIID	" Private - answer the interface pointer class which supports the interface identified by the GUID &lt;anIID&gt;. "	^COMInterfacePointer allSubclasses		detect: [ :aClass | aClass supportsIID: anIID ]		ifNone: [ nil ]</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>private-installation</category><body package="Com- Ole">ClassFinalizer    " COMInterfacePointer ClassFinalizer "	"NOTE: This is a special finalizer.  While the fundamental intent of ClassInitializer 	and ClassFinalizer methods is to be class-specific and *not* used via inheritance 	by subclasses, for this particular branch of the hierarchy with its registry of subclass 	mapping information it is convenient to write this removal support once with the intention 	that it indeed be inherited. "	self removeIID.	self vtableDescription: nil.</body><body package="Com- Ole">obsolete	"The receiver was removed from the system and is now obsolete. Perform any 	necessary clean-up. Answer the receiver."	self ClassFinalizer.	^super obsolete</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>accessing</category><body package="Com- Ole">vtableDescription	" Answer an array of entry point descriptions, in VTable order, of the receiver's interface VTable functions. "	^vtableDescription</body><body package="Com- Ole">vtableSelectors	" Answer an array of message selectors, in VTable order, of the receiver's interface functions. "	^self vtableDescription collect: [ :eptDescription | eptDescription selector ]</body><body package="Com- Ole">vtableSize	" Answer the number of interface function entry points defined in the receiver's interface function VTable. "	^self vtableDescription size</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>private-instance creation</category><body package="Com- Ole">getAddressValueFrom: anExternalAddress 	" Private - answer the address as an integer value.  The source may be either an (untyped) pointer, the usual case, or a raw integer value representing the address, obtained in some presumably appropriate fashion by the client.  Answer nil if the address does not constitute a valid address on which an instance of the receiver should be constructed. "	| anAddress |	anExternalAddress == nil ifTrue: [^nil].	anExternalAddress isInteger 		ifTrue: [anAddress := anExternalAddress]		ifFalse: 			[anExternalAddress isPointer 				ifTrue: [anAddress := anExternalAddress referentAddress]].	anAddress == nil 		ifTrue: [self error: #ErrUnknownIntPointer &lt;&lt; #com &gt;&gt; 'unknown interface pointer source'].	"Assert isTrue: [ anAddress isInteger ]."	"Assert isEqual: anExternalAddress asInteger to: anAddress."	^anAddress = 0 ifTrue: [nil] ifFalse: [anAddress]</body><body package="Com- Ole">privateNew	" Private - answer a new instance of the reciever..  The caller determines whether finalization is to be applied. "      ^super new initialize</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>subclass-accessing</category><body package="Com- Ole">externalAccessFailedSignal	"Answer the signal that is raised when any external access fails."	^ExternalInterface externalAccessFailedSignal</body><body package="Com- Ole">vtableDescription: anArrayOfEntryPointDescriptions	" Set the VTable description in the form of a list of COM entry point descriptions, ordered by VTable slot index. "	vtableDescription := anArrayOfEntryPointDescriptions.</body><body package="Com- Ole">vtableSignatureType	" Private - answer the structure definition for the receiver's interface VTable. "	^COMInterfaceImplementation vtableSignatureTypeNamed: self vtableSignatureTypeName</body><body package="Com- Ole">vtableSignatureTypeName	" Private - answer the name of the structure definition for the receiver's interface VTable. "	| interfaceName |	self name first = $I		ifFalse: [ ^nil ].	interfaceName := self name copyFrom: 1		to: ( self name indexOfSubCollection: 'Pointer' startingAt: 2 ) - 1.	^( '__', interfaceName, 'Vtbl' ) asSymbol</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerIID	" Private - register the receiver as the interface pointer binding class for its IID. "	self registerIID: self iid forClass: self.</body><body package="Com- Ole">registerIID: anIID forClass: aClass	" Private - register &lt;aClass&gt; as the interface pointer binding class representing the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	COMInterfacePointer registerInterfacePointerClass: aClass forIID: anIID.</body><body package="Com- Ole">removeIID	" Private - remove the registration of the receiver as the interface pointer binding class for its IID. "	self removeInterfacePointerClassForIID: self iid.</body><body package="Com- Ole">removeIID: anIID	" Private - remove the interface pointer binding class registration of the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	COMInterfacePointer removeInterfacePointerClassForIID: anIID.</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>IID class map</category><body package="Com- Ole">classForIID: anIID	" Answer the interface pointer class which represents the interface specified by the interface ID GUID &lt;anIID&gt;.  Answer nil if the interface is not supported. "	^self classForIID: anIID ifNone: [ nil ]</body><body package="Com- Ole">classForIID: anIID ifNone: aBlock	" Answer the interface pointer class which represents the interface specified by the interface ID GUID &lt;anIID&gt;.   Answer the result of evaluating &lt;aBlock&gt; if no class is available. "	| aClass |	( anIID isNil or: [ anIID = IID_NULL ] )		ifTrue: [ ^aBlock value ].	aClass := COMInterfacePointer interfacePointerClassForIID: anIID.	aClass notNil		ifTrue: [ ^aClass ].	aClass := self subclassForIID: anIID.	aClass notNil		ifTrue: [  " self-registration backstop "			self registerIID: anIID forClass: aClass.			^aClass ].	^aBlock value</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>private-accessing</category><body package="Com- Ole">iidMap	" Private - answer the dictionary which maps IID's to interface classes. "	^IIDMap</body><body package="Com- Ole">iidMap: aDictionary	" Private - set the dictionary which maps IID's to interface classes. "	IIDMap := aDictionary.</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>private-vtable construction</category><body package="Com- Ole">entryPointNameFromSelector: entryPointSelector	" Private - answer the entry point name corresponding to the interface function method selector &lt;entryPointSelector&gt;. "	^( ReadStream on: entryPointSelector ) upTo: $:</body><body package="Com- Ole">entryPointSelectorFromPrimitiveSelector: primitiveSelector 	" Private - answer the entry point name corresponding to the primitive dispatch method selector &lt;primitiveSelector&gt;. "	| entryPointProposal interfaceClasses entryPointSelector |	#('invoke' 'primitive') do: 			[:aPrefix | 			(primitiveSelector size &gt; aPrefix size 				and: [(primitiveSelector copyFrom: 1 to: aPrefix size) = aPrefix]) 					ifTrue: 						[entryPointProposal := primitiveSelector copyFrom: aPrefix size + 1									to: primitiveSelector size.						interfaceClasses := self allSuperclasses reverse , (Array with: self).						interfaceClasses := interfaceClasses 									copyFrom: (interfaceClasses indexOf: IUnknownPointer)									to: interfaceClasses size.						(#('AddRef' 'Release') includes: entryPointProposal) ifTrue: [ entryPointProposal := 'enforce',entryPointProposal.].						interfaceClasses reverseDo: 								[:anInterfaceClass | 								entryPointSelector := anInterfaceClass selectors 											detect: [:aSelector | aSelector asString sameAs: entryPointProposal]											ifNone: [nil].								entryPointSelector notNil ifTrue: [^entryPointSelector]].						"self error: 'unknown entry point'"						COMDevelopmentWarning 							raiseSignal: (#ErrNamedNoMethFuncEntry &lt;&lt; #com 									&gt;&gt; 'No implementing method found for probable function entry point name &lt;1p&gt; (proceeding with this as hypothesis anyway).' 										expandMacrosWith: entryPointProposal).						^entryPointProposal]].	^primitiveSelector</body><body package="Com- Ole">getSelectorOf: aCompiledMethod	" Answer the message selector of &lt;aCompiledMethod&gt;.  This is necessary because a VW compiled method does not carry its own message selector with it. "	"^aCompiledMethod selector"	^aCompiledMethod mclass selectorAtMethod: aCompiledMethod		ifAbsent: [ nil ]</body><body package="Com- Ole">vtableMethods	" Private - answer the VTable dispatch methods of the receiver, in an array ordered by VTable slot index. "	| interfaceClasses localVTables mergedVTable cm |	self == COMInterfacePointer		ifTrue: [ ^#( ) ].	interfaceClasses := self withAllSuperclasses reverse.	interfaceClasses := interfaceClasses 		copyFrom: ( interfaceClasses indexOf: COMInterfacePointer ) + 1 		to: interfaceClasses size.	localVTables := interfaceClasses collect: [ :aClass | aClass vtableMethodsLocal ].	mergedVTable := Array new: ( localVTables		inject: 0 into: [ :maxSize :aVTable | maxSize max: aVTable size ] ).	localVTables do: [ :aVTable |		1 to: aVTable size do: [ :i | 			( cm := aVTable at: i ) notNil				ifTrue: [ mergedVTable at: i put: cm ] ].		].	^mergedVTable</body><body package="Com- Ole">vtableMethodsLocal	" Private - answer the VTable dispatch methods which are implemented by the receiver, in an array ordered by VTable slot index. "    | methods entryPointDict slotIndex maxIndex entry methodList |    methods := self getMethodDictionary values        select: [ :cm | cm class == self externalMethodClass and: [ cm handle isInteger ] ].    methods isEmpty        ifTrue: [ ^#() ].    entryPointDict := Dictionary new.    maxIndex := 0.    methods do: [ :cm |        slotIndex := cm handle.        ( entry := entryPointDict at: slotIndex ifAbsent: [nil ] ) notNil            ifTrue: [ (entry matchesVTableEntry: cm) ifFalse: [				MessageBox warning:            	    ((#DuplicateFunctionDefinitions &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable problem: duplicate function definitions for slot &lt;2s&gt; ( &lt;3s&gt;, &lt;4s&gt; )')					expandMacrosWith: self name					with: slotIndex printString					with: (self getSelectorOf: entry)					with: (self getSelectorOf: cm)) ]].        entryPointDict at: slotIndex put: cm.        maxIndex := maxIndex max: slotIndex ].    methodList := Array new: maxIndex + 1.    entryPointDict keysAndValuesDo: [ :key :value |        methodList at: key + 1 put: value ].    ^methodList</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>private-code generation</category><body package="Com- Ole">errorCodeVariableName	"Answer a string that represents the name of the error code variable used when generating interface methods."	^'_errorCode'</body><body package="Com- Ole">tempExternals	"Answer a temporary ExternalDictionary that is used when compiling external methods within the receiver. This dictionary is used by the parser and discarded after method compilation."	| tempExternals |	tempExternals := ExternalDictionary new.	tempExternals addBackup: self externalInterfaceClass externals.	^tempExternals</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>instance creation</category><body package="Com- Ole">new	" Answer a new instance of the receiver.  Finalization is used to ensure that the COM interface reference counting rules are followed, in the event that the explicit reference counting implemented by the application is erroneous. "      ^self privateNew needsFinalization</body><body package="Com- Ole">newTemporaryInterfacePointer	" Answer a new instance of the receiver for an external interface pointer which the client asserts is a temporary copy and does not need to be reference counted. "	self callIndicatesChangeNeeded.	^self privateNew</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>subclass-initialization</category><body package="Com- Ole">checkVTableValidity	" Check the receiver's VTable for internal and external consistency. "	( self vtableDescription notNil	and: [ self respondsTo: #validateVTable ] )   " can't check validity during runtime component loading; need Dev methods "		ifTrue: [			self validateVTable.    " check internal consistency "			self validateVTableConsistency.  " check consistency with VTable structure definition "			].</body><body package="Com- Ole">constructVTableDescription	" Private - construct a description of the receiver's VTable.  Answer an array of entry point descriptions, in VTable order, of the receiver's VTable functions. "	| vtableMethods vtableEntryPoints 	  cm primitiveSelector anExternalProcedure anEntryPointSelector anEntryPoint |	vtableMethods := self vtableMethods.	vtableMethods size = 0		ifTrue: [ ^nil ].	vtableEntryPoints := Array new: vtableMethods size.	1 to: vtableEntryPoints size do: [ :i |		cm := vtableMethods at: i.		primitiveSelector := self getSelectorOf: cm.		anExternalProcedure := self compilerClass getProcedureFor: primitiveSelector			class: cm mclass.		anEntryPointSelector := self entryPointSelectorFromPrimitiveSelector: primitiveSelector.		Assert isEqual: anExternalProcedure name asString			to: ( self entryPointNameFromSelector: anEntryPointSelector ).		Assert isEqual: anExternalProcedure referentAddress first			to: cm handle.		anEntryPoint := COMEntryPointDescription name: anExternalProcedure name asString			type: anExternalProcedure type			vtableIndex: cm handle			selector: anEntryPointSelector.		vtableEntryPoints at: i put: anEntryPoint ].	^vtableEntryPoints</body><body package="Com- Ole">initializeVTableDescription	" Private - initialize the receiver's VTable description with a list of entry point descriptions and function selectors for the functions of the interface represented by the receiver.  The entry points must be in the order of the slots in the VTable. "	self vtableDescription: self constructVTableDescription.</body><body package="Com- Ole">updateAndRegister	self		registerIID;		initializeVTableDescription.	self checkVTableValidity</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>compilation</category><body package="Com- Ole">classCompilerClass	"Answer a compiler class appropriate for source methods of this class' metaclass."	 ^#{COMCompiler} valueOrDo: [super classCompilerClass]</body><body package="Com- Ole">compilerClass	"Answer a compiler class appropriate for source methods of this class."	 ^#{COMCompiler} valueOrDo: [super compilerClass]</body><body package="Com- Ole">decompilerClass	"Answer a decompiler class appropriate for methods of this class."	^COMDecompiler</body><body package="Com- Ole">externalInterfaceClass	"Answer the class used to hold all external objects defined in the receiver.  The receiver, and all subclasses, typically share the same external interface class with a shared space of external type definitions.  Subclasses may override this method to answer their unique interface class if they wish their COM interface class to use a different set of externals."	^COMExternalInterface</body><body package="Com- Ole">externalMethodClass	"Answer the class that should be used when compiling optimized forms of the receiver's methods."	^COMExternalMethod</body><body package="Com- Ole">externals	"Answer the external dictionary used to hold all external objects defined in the receiver. The receiver, and all subclasses, typically do not have their own external dictionary--each shares the external dictionary answered by the method #externalInterfaceClass. Subclasses should override #externalInterfaceClass to answer their unique interface class if they wish their COM interface class to use a different set of externals."	^self externalInterfaceClass externals</body><body package="Com- Ole">isVirtual	"Answer true if the receiver's external method calls support virtual look-up. Subclasses of the receiver do not perform external method look-up in the same manner as ExternalInterface classes, so answer false."	^false</body><body package="Com- Ole">recompileMethods	"Recompile all methods in the receiver.  Answer the receiver."	self selectors do: [:aSelector | self recompile: aSelector].	self class selectors do: [:aSelector | self class recompile: aSelector].	Tools.Note ISSUE.  " ExternalInterface does the following... [DL 15-Mar-96]	self externals ownDo: [:ext | self externals weakenAt: ext name]	"</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>generating methods</category><body package="Com- Ole">generateMethodsForExternal: anExternal	"Regenerate the methods for the external object indicated by the argument.  Answer the receiver."	anExternal methods do: [:methodCodeString |		COMExternalInterface compile: methodCodeString classified: anExternal category]</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>fileIn/Out</category><body package="Com- Ole">prerequisitesForLoading	"COMInterfacePointer classes require their external interface class since it defines the types used,	 and their compiler class since it compiles their methods."	^super prerequisitesForLoading		addLast: COMExternalInterface;		addLast: COMCompiler;		addLast: COMExternalMethod;		yourself</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>VTable utilities</category><body package="Com- Ole">validateVTable	" Verify that a complete and consistent set of VTable dispatch methods is defined in the receiver.  Notify the user of any problems. "    | interfaceClasses localVTables mergedVTable emptySlots dummyGuy |	Tools.Note ISSUE; needsWork.  " clean this up... [DL 10-May-97] "    self == COMInterfacePointer        ifTrue: [ ^#( ) ].	Tools.Note ISSUE.  " Since the VTable description is now constructed and cached in a CIV,		you should be able to strip this construction logic and just verify what we've got.		Verify that #constructVTableDescription is exactly this and then		simplify this implementation to avoid to duplicate effort.  [DL 10-May-97] "    interfaceClasses := self withAllSuperclasses reverse.    interfaceClasses := interfaceClasses        copyFrom: ( interfaceClasses indexOf: COMInterfacePointer ) + 1        to: interfaceClasses size.    localVTables := interfaceClasses collect: [ :aClass | aClass vtableMethodsLocal ].    mergedVTable := Array new: ( localVTables        inject: 0 into: [ :maxSize :aVTable | maxSize max: aVTable size ] ).    emptySlots := Set new.    localVTables do: [ :aVTable |         | index firstMethod cm |        " verify that interface methods compose a complete block of entries "        firstMethod := aVTable detect: [ :element | element notNil ] ifNone: [ nil ].        index := ( firstMethod isNil            ifTrue: [ aVTable size + 1 ]            ifFalse: [ aVTable indexOf: firstMethod ] ).        index to: aVTable size do: [ :i |            ( aVTable at: i ) isNil                ifTrue: [                    MessageBox warning: 					((#VTableNoLovalFunction &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable problem: no local function definition for slot &lt;2s&gt;')						expandMacrosWith: self name						with: (i - 1) printString).                    emptySlots add: i - 1 ] ].        " construct the merged VTable "        1 to: aVTable size do: [ :i |            ( cm := aVTable at: i ) notNil                ifTrue: [ 			"### ( mergedVTable at: i ) notNil ifTrue: [ complain about duplicate definition ###"			mergedVTable at: i put: cm ] ].        ]."##OK, here's where we actually get into the validation logic ###"	" verify that the complete VTable is fully defined "	1 to: mergedVTable size do: [ :i |		( ( mergedVTable at: i ) isNil		and: [ ( emptySlots includes: i - 1 ) not ] )			ifTrue: [ 				MessageBox warning: 					((#NoFunctionDefined &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable problem: no function definition for slot &lt;2s&gt;')						expandMacrosWith: self name						with: (i - 1) printString) ] ].	" verify that the receiver properly exposes the interface protocol "	self vtableDescription isNil		ifTrue: [			Assert shouldNotBe.  " right?  Or is this reasonable? [DL 10-May-97] "			^mergedVTable ].	dummyGuy := self basicNew.	self vtableDescription do: [ :eptDescription |		| aSelector |		aSelector := eptDescription selector.		( dummyGuy respondsTo: aSelector )			ifFalse: [				MessageBox warning: 					((#UnimplementedSelector &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable problem: unimplemented selector #&lt;2s&gt; for &lt;3s&gt;')						expandMacrosWith: self name						with: aSelector						with: eptDescription name) ].		].	^mergedVTable</body><body package="Com- Ole">validateVTableConsistency	" Verify that the VTable functions defined in the receiver are consistent with the interface VTable structure definition.  Notify the user of any problems. "	| calloutEntryPoints vtableStructureType rawEntryPoints nEntryPoints aCalloutEPT aRawEPT |	calloutEntryPoints := self vtableDescription.	(vtableStructureType := self vtableSignatureType) isNil ifTrue: [^calloutEntryPoints].	(nEntryPoints := (rawEntryPoints := COMInterfaceImplementation constructVTableDescriptionOf: vtableStructureType) size) ~= calloutEntryPoints size		ifTrue: 			[Transcript				show: (#WarnVTableCalloutErr &lt;&lt; #com						&gt;&gt; '&lt;1s&gt; VTable consistency problem: callout binding of &lt;1s&gt; has &lt;2p&gt; entry points, but VTable is defined to have &lt;3p&gt; functions.'							expandMacrosWith: self name							with: calloutEntryPoints size							with: rawEntryPoints size).			nEntryPoints := nEntryPoints min: calloutEntryPoints size].	1 to: nEntryPoints		do: 			[:i |			aCalloutEPT := calloutEntryPoints at: i.			Assert isEqual: aCalloutEPT vtableIndex to: i - 1.			aRawEPT := rawEntryPoints at: i.			(self compareCalloutEPT: aCalloutEPT toCallinEPT: aRawEPT)				ifFalse: 					[Transcript show: (#WarnVTableCalloutShortErr &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable consistency problem: entry point &lt;2s&gt; not consistent with callout function definition.'								expandMacrosWith: self name								with: aCalloutEPT name)]].	^calloutEntryPoints</body></methods><methods><class-id>External.COMInterfacePointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: nil.							" abstract superclass does not have an IID "	"self updateAndRegister"			"subclasses should do this"</body></methods><methods><class-id>External.IUnknownPointer</class-id> <category>civilized operations</category><body package="Com- Ole">asSeparateInterfacePointer	^self matchesProcessApartment		ifTrue: 			[(self copy)				enforceAddRef;				needsFinalization;				yourself]		ifFalse: [self marshalToOtherApartment]</body><body package="Com- Ole">basicQueryInterface: iid        "Query the receiver for the interface specified by the GUID &lt;iid&gt;.		Answer the interface if it is supported, else trigger an exception. "	| resultReference |	resultReference := COMInterfaceValueReference forIID: iid.	self basicQueryInterface: iid _: resultReference.	^resultReference value</body><body package="Com- Ole">queryInterface: iid        "Query the receiver for the interface specified by the GUID &lt;iid&gt;.		Answer the interface if it is supported, else answer nil. "	| resultReference |	resultReference := COMInterfaceValueReference forIID: iid.	self QueryInterface: iid _: resultReference.	^resultReference value</body><body package="Com- Ole">referenceCount	^self		enforceAddRef;		enforceDecRef</body></methods><methods><class-id>External.IUnknownPointer</class-id> <category>private interface operations</category><body package="Com- Ole">privateAddRef	" Invoke the IUnknown::AddRef function. "	^self performInCorrespondingAppartment: [self invokeAddRef]</body><body package="Com- Ole">privateDecrementReferenceCount		" Decrement the reference count of the interface referenced by the receiver.		Do not destroy the reference, allowing the client to continue using the interface.		Answer the value of the reference count (for diagnostic use only; may not be stable). "	^self internalRelease</body></methods><methods><class-id>External.IUnknownPointer</class-id> <category>interface operations</category><body package="Com- Ole">QueryInterface: iid _: resultReference	" Invoke the IUnknown::QueryInterface function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := self invokeQueryInterface: iid				_: resultBuffer asPointerParameter.	hresult succeeded		ifTrue: [resultReference value: resultBuffer contents asInterfaceReference].	^hresult</body><body package="Com- Ole">basicQueryInterface: iid _: resultReference	" Invoke the IUnknown::QueryInterface function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := self invokeQueryInterface: iid				_: resultBuffer asPointerParameter.	hresult = E_NOINTERFACE		ifTrue: 			[COMError				raiseSignal: (#ErrNamedNoSupport &lt;&lt; #com						&gt;&gt; 'This object does not support &lt;1p&gt;'							expandMacrosWith: resultReference interfaceReference class)].	hresult succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult</body><body package="Com- Ole">enforceAddRef	" Invoke the IUnknown::AddRef function. "	^self privateAddRef</body><body package="Com- Ole">enforceDecRef	" Invoke the IUnknown::AddRef function. "	^self privateDecrementReferenceCount</body></methods><methods><class-id>External.IUnknownPointer</class-id> <category>private-interface operations</category><body package="Com- Ole">internalRelease	" Private - safely invoke the IUnknown::Release operation. "	^self isValid		ifTrue: [self performInCorrespondingAppartment: [self invokeRelease]]		ifFalse: [-1]</body><body package="Com- Ole">privateRelease	" Invoke the IUnknown::Release function. "	| remainingReferenceCount |	super privateRelease.	remainingReferenceCount := self internalRelease.	interfaceAddress := nil.	^remainingReferenceCount</body></methods><methods><class-id>External.IUnknownPointer</class-id> <category>releasing</category><body package="Com- Ole">enforceRelease	^self privateRelease</body></methods><methods><class-id>External.IUnknownPointer</class-id> <category>obsolete</category><body package="Com- Ole">AddRef	" Invoke the IUnknown::AddRef function. "	self callIsDispensable.</body><body package="Com- Ole">Release	self callIsDispensable.</body><body package="Com- Ole">decrementReferenceCount	"obsolete - it is not required any more to modify the reference counting."	self callIsDispensable.	^0</body></methods><methods><class-id>External.IUnknownPointer class</class-id> <category>private-vtable construction</category><body package="Com- Ole">entryPointNameFromSelector: entryPointSelector	" Private - answer the entry point name corresponding to the interface function method selector &lt;entryPointSelector&gt;. "	| string |	string := super entryPointNameFromSelector: entryPointSelector.	^(#('enforceAddRef' 'enforceRelease') includes: string)		ifTrue: [string allButFirst: 'enforce' size]		ifFalse: [string]</body></methods><methods><class-id>External.IUnknownPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IUnknown.	self updateAndRegister</body></methods><methods><class-id>External.IPersistPointer</class-id> <category>interface operations</category><body package="Com- Ole">GetClassID: resultReference		" Invoke the IPersist::GetClassID function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := GUID resultValueBuffer.	hresult := self invokeGetClassID: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.IPersistPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersist.	self updateAndRegister</body></methods><methods><class-id>External.IRunningObjectTablePointer</class-id> <category>interface operations</category><body package="Com- Ole">EnumRunning: resultReference		" Invoke the IRunningObjectTable::EnumRunning function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumMoniker.	hresult := self invokeEnumRunning: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">GetObject: anIMoniker _: resultReference	" Invoke the IRunningObjectTable::GetObject function. 		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IUnknownPointer resultValueBuffer.	hresult := self invokeGetObject: anIMoniker asPointerParameter				_: resultBuffer asPointerParameter.	hresult succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult</body><body package="Com- Ole">GetTimeOfLastChange: anIMoniker _: resultReference	" Invoke the IRunningObjectTable::GetTimeOfLastChange function.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMStructure resultValueBufferFor: #FILETIME.	hresult := self invokeGetTimeOfLastChange: anIMoniker asPointerParameter				_: resultBuffer asPointerParameter.	hresult succeeded		ifTrue: [resultReference value: resultBuffer contents asTimestamp].	^hresult</body><body package="Com- Ole">IsRunning: anIMoniker		" Invoke the IRunningObjectTable::IsRunning function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeIsRunning: anIMoniker asPointerParameter</body><body package="Com- Ole">NoteChangeTime: registrationToken _: aTimeStamp		" Invoke the IRunningObjectTable::NoteChangeTime function. 		Raise an exception if an error occurs.  Answer the result code. "	^self invokeNoteChangeTime: registrationToken		_: ( COMExternalInterface asFileTimeParameter: aTimeStamp )</body><body package="Com- Ole">Register: grfFlags _: anIUnknown _: anIMoniker _: resultReference		" Invoke the IRunningObjectTable::Register function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #DWORD.	hresult := self invokeRegister: grfFlags 		_: anIUnknown asPointerParameter 		_: anIMoniker asPointerParameter 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.IRunningObjectTablePointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IRunningObjectTable.	self updateAndRegister</body></methods><methods><class-id>External.COMResultNotification</class-id> <category>private-accessing</category><body package="Com- Ole">ensureMessageTextInstalled	" Private - ensure that the receiver has some suitable message. "	messageText == nil ifTrue: [self messageText: self hresult description]</body><body package="Com- Ole">hresultAttribute: anInteger	" Private - set the receiver's hresult attribute.  This has to be done carefully in the VW 2.5 NGException facility due to a collision between the VW 4.0 inst var setter and the class signalling protocol which must be simulated via an instance method in VW 2.5. "	hresult := anInteger.</body></methods><methods><class-id>External.COMResultNotification</class-id> <category>accessing</category><body package="Com- Ole">hresult        "Answer the COM result code which caused the notification. "    ^hresult</body><body package="Com- Ole">hresult: anInteger        "Set the result code set to &lt;anInteger&gt;."	self hresultAttribute: anInteger.	self ensureMessageTextInstalled.</body></methods><methods><class-id>External.COMResultNotification class</class-id> <category>signalling</category><body package="Com- Ole">hresult: anInteger 	^( self new hresult: anInteger ) raiseSignal</body></methods><methods><class-id>External.COMInterface</class-id> <category>converting</category><body package="Com- Ole">asInterfacePointer	" Answer an interface pointer for the receiver's VTable in external memory. "	^interface == nil		ifTrue: [ nil ]		ifFalse: [ self interfaceBinding asInterfacePointer ]</body><body package="Com- Ole">asInterfaceReference	" Answer a civilized interface reference on the receiver. "	^self</body><body package="Com- Ole">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	^interface == nil		ifTrue: [ nil ]		ifFalse: [ self interfaceBinding asPointerParameter ]</body><body package="Com- Ole">asSeparateInterfacePointer	^ self interfaceBinding asSeparateInterfacePointer asInterfaceReference</body><body package="Com- Ole">asValueReference	" Answer a reference to the receiver which allows it to be manipulated using the standard #value and #value: accessing protocol. "	^COMInterfaceValueReference on: self</body></methods><methods><class-id>External.COMInterface</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt; "	super printOn: aStream.	interface notNil		ifTrue: [ aStream nextPutAll: ' on: ', self interfaceBinding printString ].</body></methods><methods><class-id>External.COMInterface</class-id> <category>private-accessing</category><body package="Com- Ole">actualImplementor	" Private - answer the immediate implementor of the interface. "	^interface actualImplementor</body><body package="Com- Ole">implementor	" Private - answer the immediate implementor of the interface. "	^interface</body><body package="Com- Ole">implementor: anInterfaceImplementor	" Private - set the immediate implementor of the interface. "	" do not install tracing (this is the backdoor we use to get install/ermove the trace adaptor) "	interface := anInterfaceImplementor.</body><body package="Com- Ole">interfaceBinding: anInterfaceBinding 	" Private - set the interface binding which provides function invocation services for the receiver to &lt;anInterfaceBinding&gt;. "	| newBinding |	self checkInterfaceBinding: anInterfaceBinding.	newBinding := (anInterfaceBinding isNil 				or: [anInterfaceBinding isValid not]) 					ifTrue: [nil]					ifFalse: [anInterfaceBinding].	"Assert isTrue: [		( newBinding isNil 		or: [ newBinding isCOMInterfacePointer		or: [ newBinding isCOMInterfaceImplementation ] ] ) ]."	interface notNil 		ifTrue: 			[newBinding notNil 				ifTrue: [self error: #ErrCantSwapPointers &lt;&lt; #com &gt;&gt; 'cannot swap interface pointers']].	interface := newBinding.	interface notNil ifTrue: [self installTracing]</body></methods><methods><class-id>External.COMInterface</class-id> <category>testing</category><body package="Com- Ole">isCOMInterface	" Answer whether the receiver is a COM interface. "	^true</body><body package="Com- Ole">isCOMInterfaceImplementation	" Answer whether the receiver is a COM interface implemented in this Smalltalk image. "	^self  interfaceBinding isCOMInterfaceImplementation</body><body package="Com- Ole">isCOMInterfacePointer	" Answer whether the receiver is a COM interface referencing a VTable in external memory. "	^self interfaceBinding isCOMInterfacePointer</body><body package="Com- Ole">isCOMInterfaceReference	" Answer whether the receiver is a COM interface reference which provides civilized protocol to invoke the interface functions of a COM interface. "	^true</body><body package="Com- Ole">isMTAObject	^ interface isMTAObject</body><body package="Com- Ole">isSTAObject	^ interface isSTAObject</body><body package="Com- Ole">isValid	"Answer whether the receiver has a valid (non-NULL) interface. "	^interface notNil and: [ interface isValid ]</body></methods><methods><class-id>External.COMInterface</class-id> <category>comparing</category><body package="Com- Ole">= anObject	" Answer whether the receiver and &lt;anObject&gt; represent the same interface. "	^anObject isCOMInterface 		and: [ self iid = anObject iid		and: [ self sameBindingAs: anObject ] ]</body><body package="Com- Ole">hash	"Answer the integer hash value of the receiver."	^self interfaceBinding hash</body><body package="Com- Ole">storeSelfInPointer: aPointer	^ self interfaceBinding storeSelfInPointer: aPointer.</body></methods><methods><class-id>External.COMInterface</class-id> <category>copying</category><body package="Com- Ole">copy	" Answer a copy of the receiver.  The copy is not separately reference counted and should not be released by the caller.  (Note: The #seperateReference message should be sent to the receiver to obtain a separately reference counted copy.) "	^self class forBinding: self copyInterfaceBinding</body><body package="Com- Ole">separateReference	" Answer a new interface reference on the same interface.  The copy is reference counted and must be released by the caller. "	self callIsDispensable.	^self asSeparateInterfacePointer</body></methods><methods><class-id>External.COMInterface</class-id> <category>private-copying</category><body package="Com- Ole">copyInterfaceBinding	" Private - answer a copy of the receiver's interface binding. "	^interface isNil		ifTrue: [ nil ]		ifFalse: [ self interfaceBinding copyInterfaceBinding ]</body></methods><methods><class-id>External.COMInterface</class-id> <category>subclass-comparing</category><body package="Com- Ole">sameBindingAs: anInterface	" Private - answer whether the receiver and &lt;anInterface&gt; have the same binding. "	" let binding control comparison (allows optimization) "	^self isCOMInterfaceImplementation		ifTrue: [ self interfaceBinding interfaceEqual: anInterface interfaceBinding ]		ifFalse: [ anInterface interfaceBinding interfaceEqual: self interfaceBinding ]</body></methods><methods><class-id>External.COMInterface</class-id> <category>identity</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^self class iid</body><body package="Com- Ole">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;.  The default is to do nothing - the IID is known by the class.  This method is reimplemented by subclasses whose instances can represent more than one interface. "	"Assert isTrue: [ self class supportsIID: anIID ]."</body></methods><methods><class-id>External.COMInterface</class-id> <category>accessing</category><body package="Com- Ole">functionAdaptor	" Answer the interface function adaptor which is configured for the receiver.  Answer nil if this is a direct binding of the interface to the real implementor. "	^interface notNil		ifTrue: [ interface functionAdaptor ]		ifFalse: [ nil ]</body><body package="Com- Ole">implementingObject	" Answer the COM object in the current process which supports the receiver.  Answer nil if the interface is not supported by a local Smalltalk COM object. "	^self isValid		ifTrue: [ self interfaceBinding implementingObject ]		ifFalse: [ nil ]</body><body package="Com- Ole">interfaceBinding	" Answer the interface binding which provides function invocation services for the receiver. "	^interface notNil		ifTrue: [ interface interfaceBinding ]		ifFalse: [ nil ]</body></methods><methods><class-id>External.COMInterface</class-id> <category>private-tracing</category><body package="Com- Ole">installTracing	" Private - install a trace adaptor on the receiver if appropriate. "	^Plugins		performPluginNamed: Plugins installTracingKey		with: self		ifAbsent: []</body><body package="Com- Ole">traceAdaptor	" Private - answer the trace adaptor configured on the receiver.  Answer nil if none. "	self isCOMInterfacePointer		ifTrue: [			^( interface isCOMInterfaceAdaptor and: [ interface isCOMTraceAdaptor ] )				ifTrue: [ interface ]				ifFalse: [ nil ] ].	self isCOMInterfaceImplementation		ifTrue: [ ^self interfaceBinding traceAdaptor ].	^nil</body></methods><methods><class-id>External.COMInterface</class-id> <category>private-error handling</category><body package="Com- Ole">checkInterfaceBinding: anInterfaceBinding 	" Private - verify that &lt;anInterfaceBinding&gt; is suitable to install in the receiver. "	anInterfaceBinding isNil ifTrue: [^self].	anInterfaceBinding iid isNil 		ifTrue: [self error: #ErrInvalidIntBinding &lt;&lt; #com &gt;&gt; 'invalid interface binding (no iid)'].	self checkInterfaceBindingIID: anInterfaceBinding</body><body package="Com- Ole">checkInterfaceBindingIID: anInterfaceBinding 	" Private - verify that a consistent binding is being installed in the receiver. "	(self class supportsIID: anInterfaceBinding iid) 		ifFalse: [self error: #ErrIIDMismatch &lt;&lt; #com &gt;&gt; 'IID mismatch']</body></methods><methods><class-id>External.COMInterface</class-id> <category>private-coercing</category><body package="Com- Ole">coerceToPointer	" Private - force the receiver to invoke its functions through an external VTable. "	interface notNil		ifTrue: [ 			interface := self interfaceBinding asInterfacePointer.			interface iid: self iid.			self installTracing ].</body><body package="Com- Ole">optimizeBinding	" Private - force the receiver to invoke its functions through an interface implementation connected directly to a local implementing object, if possible. "	| anInterfaceImpl |	self isCOMInterfacePointer		ifTrue: [			| myInterfaceBinding |			myInterfaceBinding := self interfaceBinding.			anInterfaceImpl := COMInterfaceImplementation localImplementorOf: myInterfaceBinding.			anInterfaceImpl notNil				ifTrue: [ 					myInterfaceBinding doesNotNeedFinalization.  " throw away this pointer instance "					interface := anInterfaceImpl. 					self installTracing.  " should already be installed, but this is certainly safe "					].			].</body></methods><methods><class-id>External.COMInterface</class-id> <category>releasing</category><body package="Com- Ole">enforceInvalidation	" Invalidate the receiver. "	^self privateInvalidate</body><body package="Com- Ole">enforceRelease	^ self privateRelease.</body><body package="Com- Ole">invalidate		self callIndicatesChangeNeeded</body><body package="Com- Ole">privateInvalidate	" Invalidate the receiver. "	self isCOMInterfacePointer		ifTrue: [ self interfaceBinding enforceInvalidation ].	interface := nil.</body></methods><methods><class-id>External.COMInterface</class-id> <category>referencing</category><body package="Com- Ole">destroyReference		self callIndicatesChangeNeeded.</body></methods><methods><class-id>External.COMInterface</class-id> <category>private interface operations</category><body package="Com- Ole">privateRelease	self subclassResponsibility</body></methods><methods><class-id>External.COMInterface</class-id> <category>error handling</category><body package="Com- Ole">doesNotUnderstand: aMessage	^(self selectorFromThreaded: aMessage selector)		ifNil: [super doesNotUnderstand: aMessage]		ifNotNil: [:selector | COMThreadManager performInMTA: [ self perform: selector withArguments: aMessage arguments]]</body><body package="Com- Ole">selectorFromThreaded: selector	| newSelector |	(selector first: 8) = 'threaded' ifFalse: [^nil].	newSelector := selector allButFirst: 8.	newSelector isEmpty ifTrue: [^nil].	(self respondsTo: newSelector asSymbol) ifTrue: [^newSelector asSymbol].	newSelector first isUppercase		ifTrue: [newSelector at: 1 put: newSelector first asLowercase].	(self respondsTo: newSelector asSymbol) ifTrue: [^newSelector asSymbol].	^nil</body></methods><methods><class-id>External.COMInterface class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerIID	" Private - register the receiver as the interface class for its IID. "	self registerIID: self iid forClass: self.</body><body package="Com- Ole">registerIID: anIID forClass: aClass	" Private - register &lt;aClass&gt; as the interface class representing the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	COMInterfacePointer registerInterfaceReferenceClass: aClass forIID: anIID.</body><body package="Com- Ole">removeIID	" Private - remove the registration of the receiver as the interface class for its IID. "	self removeIID: self iid.</body><body package="Com- Ole">removeIID: anIID	" Private - remove the interface class registration of the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	COMInterfacePointer removeInterfaceReferenceClassForIID: anIID.</body></methods><methods><class-id>External.COMInterface class</class-id> <category>subclass-tracing</category><body package="Com- Ole">allowsTracing	" Answer whether tracing is allowed on instances of the receiver. "	^true</body><body package="Com- Ole">canTraceAdaptorAssumeHRESULT	" Answer whether a trace adaptor configured on an instance of the receiver can assume that the functions in the interface represented by the receiver follow the standard COM convention of returning an HRESULT as the function return value, with OUT values returned via parameter values. "	^false</body><body package="Com- Ole">traceAdaptorClass	" Answer the trace adaptor class which services instances of the receiver. "	^nil</body></methods><methods><class-id>External.COMInterface class</class-id> <category>subclass-accessing</category><body package="Com- Ole">iid: anIID 	" Private - set the the interface ID which uniquely identifies instances of the receiver to the GUID &lt;anIID&gt;. "	(iid notNil and: [anIID notNil and: [iid ~= anIID]]) 		ifTrue: 			[" maybe initialization bug that developer should know about "			COMDevelopmentWarning 				raiseSignal: (#ErrNamedIIDChange &lt;&lt; #com 						&gt;&gt; 'Changing the IID of &lt;1s&gt; from &lt;2p&gt; to &lt;3p&gt;.' 							expandMacrosWith: self name							with: iid							with: anIID)].	iid := anIID</body><body package="Com- Ole">interfaceCallinBindingClass	" Answer the callin binding class for the receiver.  Complain if not defined, this is a development/installation problem. "	| interfaceCallinBindingClass |	interfaceCallinBindingClass :=  self interfaceImplementationClass.	interfaceCallinBindingClass isNil		ifTrue: [ self error: ((#NoCallInBindingClass &lt;&lt; #com &gt;&gt; 'no COMInterfaceImplementation callin binding class for &lt;1s&gt;')			expandMacrosWith: self name) ].	^interfaceCallinBindingClass</body><body package="Com- Ole">interfaceImplementationClass	" Private - answer the interface implementation class which is referenced by instances of the receiver. "	^COMInterfaceImplementation classForIID: self iid</body><body package="Com- Ole">interfacePointerClass	" Private - answer the interface pointer class which is referenced by instances of the receiver. "	^COMInterfacePointer classForIID: self iid</body></methods><methods><class-id>External.COMInterface class</class-id> <category>IID class map</category><body package="Com- Ole">classForIID: anIID	" Answer the interface class which represents the interface specified by the interface ID GUID &lt;anIID&gt;.  Answer nil if the interface is not supported. "	^self classForIID: anIID ifNone: [ nil ]</body><body package="Com- Ole">classForIID: anIID ifNone: aBlock	" Answer the interface class which represents the interface specified by the interface ID GUID &lt;anIID&gt;.   Answer the result of evaluating &lt;aBlock&gt; if no class is available. "	| aClass |	( anIID isNil or: [ anIID = IID_NULL ] )		ifTrue: [ ^aBlock value ].	aClass := COMInterfacePointer interfaceReferenceClassForIID: anIID.	aClass notNil		ifTrue: [ ^aClass ].	aClass := self subclassForIID: anIID.	aClass notNil		ifTrue: [  " self-registration backstop "			self registerIID: anIID forClass: aClass.			^aClass ].	^aBlock value</body></methods><methods><class-id>External.COMInterface class</class-id> <category>external-transformations</category><body package="Com- Ole">forTemporaryInterfacePointerAtAddress: anExternalAddress	"Answer a new instance of the receiver for an external interface pointer whose pointer value is in external memory referenced by &lt;anExternalAddress&gt;.  This creation service is used to instantiate interfaces which are temporarily owned - the interface instance is not separately reference counted and should not be released by the caller.  E.g., this is always used by the callee during interface function invocation to access an interface argument provided by an external caller.  The caller must explicitly make a copy of the interface and increment its reference count if it holds on to this interface reference. "	^self forBinding: 		( self interfacePointerClass newTemporaryInterfacePointerAtAddress: anExternalAddress )</body><body package="Com- Ole">uncountedInterfacePointerAtAddress: anExternalAddress	^self forBinding: 		( self interfacePointerClass newUncountedInterfacePointerAtAddress: anExternalAddress )</body></methods><methods><class-id>External.COMInterface class</class-id> <category>subclass-instance creation</category><body package="Com- Ole">forBinding: anInterfaceBinding	" Answer a new instance of the receiver which uses the interface callin/callout binding &lt;anInterfaceBinding&gt; to perform the interface function processing. "	^self new		interfaceBinding: anInterfaceBinding;			yourself</body></methods><methods><class-id>External.COMInterface class</class-id> <category>instance creation</category><body package="Com- Ole">adaptorBindingOn: anObject	"Answer a new instance of the receiver which supports its interface indirectly on &lt;anObject&gt;, through a configurable adaptor which maps the standard message selectors for the interface functions to the desired protocol supported by the implementing object. "	^self forBinding: ( self interfaceCallinBindingClass adaptorBindingOn: anObject )</body><body package="Com- Ole">directBindingOn: anObject	"Answer a new instance of the receiver which supports its interface directly on &lt;anObject&gt;, using the standard message selectors for the interface functions. "	^self forBinding: ( self interfaceCallinBindingClass directBindingOn: anObject )</body><body package="Com- Ole">on: anObject 	" Answer a new instance of the receiver which supports its interface on &lt;anObject&gt;. "	anObject isCOMInterfaceBinding 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#ErrNamedOnInt &lt;&lt; #com 						&gt;&gt; 'The &lt;1s&gt; #on: instantiation message should only be used on objects, not interface bindings.' 							expandMacrosWith: self name).			^self forBinding: anObject].	^self adaptorBindingOn: anObject</body><body package="Com- Ole">on: anObject selectors: selectors 	" Answer a new instance of the receiver which supports its interface on &lt;anObject&gt; using &lt;selectors&gt; as the interface function handlers to delegate processing responsibility to the implementing object.  The &lt;selectors&gt; list must be exact match in size, order, and argument count to the interface VTable function layout. "	anObject isCOMInterfaceBinding 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#ErrNamedOnSelInt &lt;&lt; #com 						&gt;&gt; 'The &lt;1s&gt; #on:selectors: instantiation message should only be used on objects, not interface bindings.' 							expandMacrosWith: self name).			^nil].	^self 		forBinding: (self interfaceCallinBindingClass adaptorBindingOn: anObject				selectors: selectors)</body></methods><methods><class-id>External.COMInterface class</class-id> <category>private-installation</category><body package="Com- Ole">obsolete	"The receiver was removed from the system and is now obsolete. 	Perform any necessary clean-up. Answer the receiver."	self removeIID.	^super obsolete</body></methods><methods><class-id>External.COMInterface class</class-id> <category>parcel load/unload/save</category><body package="Com- Ole">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMInterfacePointer;		yourself</body></methods><methods><class-id>External.COMInterface class</class-id> <category>identity</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid		ifNil: 			[self initializeIfImplemented.			iid]</body><body package="Com- Ole">supportsIID: anIID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^self iid = anIID</body></methods><methods><class-id>External.COMInterface class</class-id> <category>private-IID class map</category><body package="Com- Ole">subclassForIID: anIID	" Private - answer the interface class which supports the interface identified by the GUID &lt;anIID&gt;. "	^COMInterface allSubclasses		detect: [ :aClass | aClass supportsIID: anIID ]		ifNone: [ nil ]</body></methods><methods><class-id>External.COMInterface class</class-id> <category>subclass-initialization</category><body package="Com- Ole">updateAndRegister	" Private - initialize the class state.  NOTE: The IID must be initialized separately before evaluating this initialization. "	self registerIID.</body></methods><methods><class-id>External.COMInterface class</class-id> <category>error raising</category><body package="Com- Ole">couldNotDetermineInterfaceFor: something	self		error: (#CouldNotDetermineIIDFor1p &lt;&lt; #com				&gt;&gt; 'Could not determine IID for &lt;1p&gt;' expandMacrosWith: something)</body></methods><methods><class-id>External.COMInterface class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: nil.					" abstract superclass does not have an IID "	"self updateAndRegister" 	"subclasses should do this"</body></methods><methods><class-id>External.COMInterface class</class-id> <category>utilities</category><body package="Com- Ole">decodeIIdsFromOptions: options clsidBlock: aBlock	| iids temp |	iids := options iid				ifNil: 					[options iids ifNil: [Array with: IID_IUnknown] ifNotNil: [options iids]]				ifNotNil: [Array with: options iid].	^iids collect: 			[:each |			temp := GUID iidFor: each clsidBlock: aBlock.			temp ifNil: [COMInterface couldNotDetermineInterfaceFor: each].			temp]</body></methods><methods><class-id>External.IUnknown</class-id> <category>object management</category><body package="Com- Ole">hasStrongExternalConnections		"Answer whether the receiver's object has strong external connections. "	^OLEDLL current CoHasStrongExternalConnections: self</body><body package="Com- Ole">isHandlerConnected		" Answer whether the in-process server or handler 		is connected to the receiver's object. "    self isValid        ifFalse: [ COMError hresult: E_INVALIDARG ].	^OLEDLL current CoIsHandlerConnected: self</body><body package="Com- Ole">lockObject		" Lock the receiver's object so that its reference count		cannot decrement to zero. "	OLEDLL current CoLockObjectExternal: self _: true _: false.</body><body package="Com- Ole">unlockObject		" Unlock the receiver's object.  This lock is the last reference to the object		that is supposed to keep it alive. "	self unlockObject: true.</body><body package="Com- Ole">unlockObject: lastLockReleases		" Unlock the receiver's object.  The &lt;lastLockReleases&gt; flag		 specifies whether the lock is the last reference to the object		that is supposed to keep it alive. "	OLEDLL current CoLockObjectExternal: self _: false _: lastLockReleases.</body></methods><methods><class-id>External.IUnknown</class-id> <category>interface operations</category><body package="Com- Ole">basicQueryInterface: iid 	" Query the receiver for the interface specified by the GUID &lt;iid&gt;.  Answer the interface if it is supported, else answer nil. "	| resultReference |	interface isNil 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#WarnNamedNoIntQuery &lt;&lt; #com 						&gt;&gt; 'No interface to query in &lt;1p&gt;' expandMacrosWith: self).			^nil].	resultReference := COMInterfaceValueReference forIID: iid.	interface basicQueryInterface: iid _: resultReference.	^resultReference value</body><body package="Com- Ole">enforceAddRef	^ self privateAddRef</body><body package="Com- Ole">enforceDecRef	" Decrement the reference count of the interface referenced by the receiver.  Do not destroy the reference, allowing the client to continue using the interface.  This service must be used when artificial reference counting on an interface is desired.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	^ self privateDecrementReferenceCount</body><body package="Com- Ole">incrementReferenceCount</body><body package="Com- Ole">queryInterface: iidOrSymbol	" Query the receiver for the interface specified by the GUID &lt;iid&gt;.  Answer the interface if it is supported, else answer nil. "	^(GUID iidFor: iidOrSymbol clsidBlock: [self clsid])		ifNil: [COMInterface couldNotDetermineInterfaceFor: iidOrSymbol]		ifNotNil: [:anIID | self queryInterfaceIID: anIID]</body><body package="Com- Ole">queryInterfaceIID: iid 	" Query the receiver for the interface specified by the GUID &lt;iid&gt;.  Answer the interface if it is supported, else answer nil. "	| resultReference |	interface isNil 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#WarnNamedNoIntQuery &lt;&lt; #com 						&gt;&gt; 'No interface to query in &lt;1p&gt;' expandMacrosWith: self).			^nil].	resultReference := COMInterfaceValueReference forIID: iid.	interface QueryInterface: iid _: resultReference.	^resultReference value</body><body package="Com- Ole">referenceCount	^self		privateAddRef;		privateDecrementReferenceCount</body><body package="Com- Ole">release	" Decrement the reference count of the interface referenced by the receiver and destroy the reference to it.  Release any resources associated with the receiver.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	interface := nil.	super release.	^ 0</body></methods><methods><class-id>External.IUnknown</class-id> <category>private interface operations</category><body package="Com- Ole">privateAddRef	" Increment the reference count of the interface referenced by the receiver.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	^interface enforceAddRef</body><body package="Com- Ole">privateDecrementReferenceCount	" Decrement the reference count of the interface referenced by the receiver.  Do not destroy the reference, allowing the client to continue using the interface.  This service must be used when artificial reference counting on an interface is desired.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	^ interface privateDecrementReferenceCount</body><body package="Com- Ole">privateRelease	" Decrement the reference count of the interface referenced by the receiver and destroy the reference to it.  Release any resources associated with the receiver.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	| myInterfaceBinding refCount |	interface isNil 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#WarnNamedTooManyRel1p &lt;&lt; #com &gt;&gt; 'Too many releases of &lt;1p&gt;' 						expandMacrosWith: self).			refCount := nil]		ifFalse: 			[" release carefully to ensure that we can never get this far twice "			myInterfaceBinding := interface.			interface := nil.			refCount := myInterfaceBinding enforceRelease].	super release.	^refCount</body></methods><methods><class-id>External.IUnknown</class-id> <category>obsolete</category><body package="Com- Ole">Release	self callIsDispensable.</body><body package="Com- Ole">addRef	" Increment the reference count of the interface referenced by the receiver.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	"Don't allow direct calls to AddRef"	^ self callIsDispensable</body><body package="Com- Ole">decrementReferenceCount</body></methods><methods><class-id>External.IUnknown</class-id> <category>accessing</category><body package="Com- Ole">clsid	"try to retrieve the clsid"	^(self queryInterfaceIID: IID_IPersist) ifNotNil: [:itf | itf getClassID]</body><body package="Com- Ole">implementingObject	" Answer the COM object in the current process which supports the receiver.  Answer nil if the interface is not supported by a local Smalltalk COM object. "	| iUnknown |	self isValid ifFalse: [^nil].	super implementingObject ifNotNil: [:obj | ^obj].	"In case the interface was casted to a different interface, we can not find the implementor.	 Query the IUnknown interface even if we think that we already are it and perform the test again."	iUnknown := COMThreadManager				performInSTA: [self queryInterface: IID_IUnknown].	"To avoid an endless recursion, call the implementation of the interface binding directly"	^[iUnknown interfaceBinding implementingObject]		ensure: [iUnknown enforceRelease]</body></methods><methods><class-id>External.IUnknown</class-id> <category>converting</category><body package="Com- Ole">castToIID: anIID	"create a new interface pointer to the given interface address but using the interface type	 specifed by anIID. E.g. this may be used for converting an IAnonymous to an IDispatch.	 The method will return a new, separatly counted interface reference"	| class |	class := COMInterfacePointer  classForIID: anIID ifNone: [ IAnonymous ].	^ (class fromReturnValue: self implementor asInterfacePointer interfaceAddress)		enforceAddRef;		asInterfaceReference</body></methods><methods><class-id>External.IUnknown class</class-id> <category>private-tracing</category><body package="Com- Ole">canTraceAdaptorAssumeHRESULT	" Answer whether a trace adaptor configured on an instance of the receiver can assume that the functions in the interface represented by the receiver follow the standard COM convention of returning an HRESULT as the function return value, with OUT values returned via parameter values.  Although IUknown::AddRef and IUnknown::Release do not return an HRESULT, they are explicitly handled by the standard trace adaptor, so it is acceptable to stretch the truth in our response. "	^true</body></methods><methods><class-id>External.IUnknown class</class-id> <category>instance creation</category><body package="Com- Ole">innerBindingOn: anObject	"Answer a new instance of the receiver which supports the inner unknown binding of interface on &lt;anObject&gt;. "	^self forBinding: ( IUnknownInnerImplementation directBindingOn: anObject )</body><body package="Com- Ole">pathName: aPathName	" Answer a new instance of the receiver on the COM object in the file named &lt;aPathName&gt;. 	Note: this is equivalent to VBA's GetObject(FileName) function."	| bindContext anIMoniker anInterface |	bindContext := IBindCtx newBindContext.	anIMoniker := IMoniker fromDisplayName: aPathName bindContext: bindContext.	anInterface := anIMoniker bind: self iid.	^anInterface</body><body package="Com- Ole">pathName: aFileName progID: aProgIDOrCLSID	"Create an new Automation object of the class named &lt;aProgIDOrCLSID&gt; and	load &lt;aFileName&gt; into it. Answer an instance of the reciever on the automation	object. The automation class &lt;aProgIDOrCLSID&gt; must support IPersistFile.	Note: this is equivalent to VBA's GetObject(FileName,ProgID) function."	| anIPF anIUnknown anInterface |	anIUnknown := IClassFactory createInstance: aProgIDOrCLSID		context: CLSCTX_SERVER.	[ anIPF := anIUnknown basicQueryInterface: IID_IPersistFile ]		ensure: [ anIUnknown enforceRelease ].	[ anIPF loadReadOnly: aFileName.	anInterface := anIPF basicQueryInterface: self iid ]		ensure: [ anIPF enforceRelease ].	^anInterface</body></methods><methods><class-id>External.IUnknown class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IUnknown.	self updateAndRegister</body></methods><methods><class-id>External.COMStorageElementInterface</class-id> <category>accessing</category><body package="Com- Ole">close		" Close the storage element.  Commit any changes. "	interface isNil		ifTrue: [ ^self ].	self isEditable		ifTrue: [ self commit ].	self enforceRelease.</body><body package="Com- Ole">container		" Answer the structured storage entity which contains the receiver. "	^container</body><body package="Com- Ole">container: anOleStorageEntity		" Set the structured storage entity which contains the receiver to &lt;anOleStorageEntity&gt;. "	container := anOleStorageEntity.</body><body package="Com- Ole">name		" Answer the name of the receiver. "	name isNil		ifTrue: [ name := self getName ].	^name</body><body package="Com- Ole">name: aString		" Set the name of the receiver to &lt;aString&gt;. "	name := aString.</body></methods><methods><class-id>External.COMStorageElementInterface</class-id> <category>interface operations-operations</category><body package="Com- Ole">commit		" Commit any changes to the contents of the storage since it was last opened		or committed to persistent storage, but only if no one else has made		changes to the storage since the receiver was last opened or committed.		This prevents overwriting changes made by another user of the storage.		Answer whether the commit succeeded. "	[ interface Commit: STGC_ONLYIFCURRENT ]		on: COMError		do: [ :ex |			ex hresult = STG_E_NOTCURRENT				ifTrue: [ ^false ].			ex pass ].	^true</body><body package="Com- Ole">commit: grfCommitFlags		" Commit any changes to the contents of the storage element 		since it was last opened or committed to persistent storage, 		according to the STGC flags in &lt;grfCommitFlags&gt;.		Raise an exception if an error occurs.  Answer the result code. "	^interface Commit: grfCommitFlags</body><body package="Com- Ole">flush        "Force all data written to the receiver to be         recorded on disk."	self commit.</body><body package="Com- Ole">revert		" Discard any changes made to the contents of the storage element		since it was last opened or committed to persistent storage. 		Raise an exception if an error occurs.  Answer the result code. "	^interface Revert</body></methods><methods><class-id>External.COMStorageElementInterface</class-id> <category>testing</category><body package="Com- Ole">isDirectStorage		" Answer whether the element is direct storage "	^self statisticsWithoutName isDirectStorage</body><body package="Com- Ole">isEditable		" Answer whether the element is editable "	^self statisticsWithoutName isEditable</body><body package="Com- Ole">isLocked		" Answer whether the element has any access locks. "	^self statisticsWithoutName isLocked</body><body package="Com- Ole">isLockedExclusive		" Answer whether the element has an exclusive access lock. "	^self statisticsWithoutName isLockedExclusive</body><body package="Com- Ole">isReadOnly		" Answer whether the element is readOnly. "	^self statisticsWithoutName isReadOnly</body><body package="Com- Ole">isStorage		" Answer whether the receiver is an IStorage. "	^false</body><body package="Com- Ole">isStream		" Answer whether the receiver is an IStream. "	^false</body><body package="Com- Ole">isTransactedStorage		" Answer whether the element is transacted storage "	^self statisticsWithoutName isTransactedStorage</body></methods><methods><class-id>External.COMStorageElementInterface</class-id> <category>interface operations-accessing</category><body package="Com- Ole">statistics		" Answer the storage statistics about this storage element.		Include the storage name (which must be deallocated). "	| resultReference |	resultReference := nil asValueReference.	interface Stat: resultReference _: STATFLAG_DEFAULT.	"self ASSERT: resultReference value hasFinalization."	^resultReference value</body><body package="Com- Ole">statisticsWithoutName		" Snswer the storage statistics about this storage element.		Omit the storage name so that deallocation is not necessary. "	| resultReference |	resultReference := nil asValueReference.	interface Stat: resultReference _: STATFLAG_NONAME.	"self ASSERT: ( resultReference value hasName not )."	resultReference value doesNotNeedFinalization.	^resultReference value</body></methods><methods><class-id>External.COMStorageElementInterface</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream        "Append the ASCII representation         of the receiver to &lt;aStream&gt;."    super printOn: aStream.    ( self isValid and: [ self name notNil ] )        ifTrue: [            aStream nextPutAll: ' on: '; nextPutAll: self name ].</body></methods><methods><class-id>External.COMStorageElementInterface</class-id> <category>private-accessing</category><body package="Com- Ole">getName		" Private - get the receiver's name from its interface statistics. "	| stat elementName |	stat := self statistics.	elementName := stat name.	stat enforceRelease.	^elementName</body></methods><methods><class-id>External.COMStorageElementInterface class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: nil.	" this is an abstract class which does not correspond to any real interface. "</body></methods><methods><class-id>External.IStream</class-id> <category>interface operations-operations</category><body package="Com- Ole">clone		" Answer a clone of the receiver whose seek pointer is initialized		to the current position. "	| resultReference |	resultReference := IStream new asValueReference.	interface Clone: resultReference.	^resultReference value</body><body package="Com- Ole">copyTo: destStream		" Copy the contents of the stream to &lt;destStream&gt;, 		starting at the current seek pointer in each stream. "	interface CopyTo: destStream _: nil _: nil _: nil.</body><body package="Com- Ole">read: buffer count: count		" Read &lt;count&gt; bytes from the stream starting at the current seek pointer		into the &lt;buffer&gt; provided by the caller.		Update the seek pointer to the new position after the read is complete.		Answer the number of bytes actually read. "	| resultReference |	resultReference := nil asValueReference.	interface Read: buffer 		_: count 		_: resultReference.	^resultReference value</body><body package="Com- Ole">setSize: newSize		" Change the size of the stream to &lt;newSize&gt;. "	^interface SetSize: newSize</body><body package="Com- Ole">write: buffer count: count		" Write &lt;count&gt; bytes from the client's &lt;buffer&gt; into the stream		starting at the current seek pointer.  Update the seek pointer to the 		new position after the write is complete.  Answer the number of bytes 		actually written. "	| resultReference |	resultReference := nil asValueReference.	interface Write: buffer _: count _: resultReference.	^resultReference value</body></methods><methods><class-id>External.IStream</class-id> <category>converting</category><body package="Com- Ole">asByteStream	" Answer a read write stream connected to the receiver which treats its contents as bytes."	^COMReadWriteStream byteStreamOn: self</body><body package="Com- Ole">asCharacterStream	" Answer a read write stream connected to the receiver which treats its contents as characters."	^COMReadWriteStream characterStreamOn: self</body><body package="Com- Ole">readWriteStream	"Answer a read write stream connected to the receiver."	^self asCharacterStream</body></methods><methods><class-id>External.IStream</class-id> <category>utility operations</category><body package="Com- Ole">readCLSID		" Answer the CLSID associated with the receiver. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current ReadClassStm: self 		_: resultReference.	^resultReference value</body><body package="Com- Ole">writeCLSID: clsid		" Set the CLSID associated with the receiver to the GUID &lt;clsid&gt;. "	^OLEDLL current WriteClassStm: self _: clsid</body></methods><methods><class-id>External.IStream</class-id> <category>interface operations-positioning</category><body package="Com- Ole">position        " Answer the current position in the stream. "    | resultReference |    resultReference := nil asValueReference.    interface Seek: 0 _: STREAM_SEEK_CUR _: resultReference.    ^resultReference value</body><body package="Com- Ole">position: anInteger        " Set the position of the stream to offset &lt;anInteger&gt;. "	interface Seek: anInteger _: STREAM_SEEK_SET _: nil.</body><body package="Com- Ole">reset        " Set the position of the stream to the beginning. "	interface Seek: 0 _: STREAM_SEEK_SET _: nil</body><body package="Com- Ole">setToEnd        " Set the position of the stream to the end. "	interface Seek: 0 _: STREAM_SEEK_END _: nil.</body><body package="Com- Ole">skip: anInteger        " Increment the position of the stream by &lt;anInteger&gt;. "	interface Seek: anInteger _: STREAM_SEEK_CUR _: nil.</body></methods><methods><class-id>External.IStream</class-id> <category>accessing</category><body package="Com- Ole">size	"Answer the size of the receiver stream element. "	^self statisticsWithoutName cbSize</body></methods><methods><class-id>External.IStream</class-id> <category>interface operations-locking</category><body package="Com- Ole">lockRegion: offset count: count mode: lockType		" Lock the &lt;count&gt; bytes in the stream starting at position &lt;offset&gt; 		using locking mode &lt;lockType&gt;. "	^interface LockRegion: offset _: count _: lockType</body><body package="Com- Ole">unlockRegion: offset count: count mode: lockType		" Unlock the &lt;count&gt; bytes in the stream starting at position &lt;offset&gt; 		that was previously locked in locking mode &lt;lockType&gt;. "	^interface UnlockRegion: offset _: count _: lockType</body></methods><methods><class-id>External.IStream</class-id> <category>testing</category><body package="Com- Ole">isStream		" Answer whether the receiver is an IStream. "	^true</body></methods><methods><class-id>External.IStream class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IStream.	self updateAndRegister</body></methods><methods><class-id>External.COMStructure</class-id> <category>printing</category><body package="Com- Ole">printWrapperDescriptionOn: aStream	" Append a text description of the receiver itself to &lt;aStream&gt; "	super printWrapperDescriptionOn: aStream.	self class == COMStructure		ifTrue: [ aStream nextPutAll: ' on ', self structureType  name ].</body></methods><methods><class-id>External.COMStructure</class-id> <category>subclass-accessing</category><body package="Com- Ole">stringAtAddress: anExternalAddress	" Private - answer a String containing the characters at address &lt;anExternalAddress&gt;.   The string pointer references the Unicode byte encoding of the string. "	( anExternalAddress isNil or: [ anExternalAddress isValid not ] )		ifTrue: [ ^nil ].	^COMExternalInterface stringFromUnicodePointer: anExternalAddress asPointer</body></methods><methods><class-id>External.COMStructure</class-id> <category>testing</category><body package="Com- Ole">isCOMStructure	"Answer &lt;true&gt; if the receiver supports the COMStructure protocol."	^true</body><body package="Com- Ole">isVARIANT	"Answer &lt;true&gt; if the receiver supports the VARIANT protocol."	^false</body></methods><methods><class-id>External.COMStructure</class-id> <category>accessing-members</category><body package="Com- Ole">comAddressMemberAt: aMemberName	" Answer the structure member named &lt;aMemberName&gt; as a COMMemoryAddress.  No assumption of memory ownership is made here (i.e., the address does not have finalization).  Answer nil if the address is NULL. "	| aPointer |	aPointer := self structure memberAt: aMemberName.	^aPointer isNull		ifTrue: [ nil ]		ifFalse: [ COMMemoryAddress fromPointer: aPointer ]</body><body package="Com- Ole">fileTimeMemberAt: aMemberName	" Answer the FILETIME timestamp at &lt;aMemberName&gt; in the receiver. "	| aFileTime |	aFileTime := self structureMemberAt: aMemberName.	aFileTime asByteArray detect: [ :aByte | aByte ~= 0 ]		ifNone: [ ^nil ].	^aFileTime asTimestamp</body><body package="Com- Ole">guidMemberAt: aMemberName	" Answer the 16-byte GUID at member &lt;aMemberName&gt; in the receiver. "	| guidBytes |	guidBytes := ( self memberAt: aMemberName ) datum asByteArray.	guidBytes detect: [ :aByte | aByte ~= 0 ]		ifNone: [ ^nil ].    ^GUID fromBytes: guidBytes</body><body package="Com- Ole">guidMemberAt: aMemberName put: aGUID	" Set the 16-byte GUID at member &lt;aMemberName&gt; in the receiver. "	aGUID size = GUID sizeInBytes		ifFalse: [ COMError raiseSignal: #ErrIncorrectGUIDSize &lt;&lt; #com &gt;&gt; 'incorrect size for GUID' ].	" a structure member won't take any arbitrary byte object, it seems,		so we do some sneaky stuff here to slam our GUID bytes into the field. "	self memberAt: aMemberName put: 		( CComposite newDatum: aGUID   "strictly correct version would be: ( UninterpretedBytes from: aGUID ) "			ofType: ( COMExternalInterface getRealTypeOf: GUID baseCType ) ).</body><body package="Com- Ole">interfaceMemberAt: aMemberName put: anInterface	" Set the interface pointer at &lt;aMemberName&gt; to &lt;anInterface&gt;. "	| separateReference |	self releaseInterfaceMemberAt: aMemberName.	anInterface isNil		ifTrue: 			["#releaseInterfaceMemberAt: clears the pointer"			^self].	separateReference := anInterface asSeparateInterfacePointer.	[self memberAt: aMemberName put: separateReference asPointerParameter]		ensure: [separateReference enforceInvalidation]</body><body package="Com- Ole">interfaceMemberAt: aMemberName type: anInterfaceClass	" Answer the interface pointer of type &lt;interfaceClass&gt; at &lt;aMemberName&gt;.  The interface is a temporary copy and is not separately reference counted.  The caller should copy the interface if they want to retain an independent copy.  Answer the interface or nil if not valid. "	^self		withRefMemberPointer: aMemberName		do: [:pointer | anInterfaceClass forTemporaryInterfacePointerAtAddress: pointer]		ifNil: [nil]</body><body package="Com- Ole">internalInterfaceMemberAt: aMemberName type: anInterfaceClass	" Answer the interface pointer of type &lt;interfaceClass&gt; at &lt;aMemberName&gt;.  The interface represents the interface which is stored in the structure.	  It is not separately reference counted and will not be released by finalization. The interface reference may stop working after the structure has been released.	  For keeping a copy of the interface reference, please use #interfaceMemberAt:type: instead."	^self		withRefMemberPointer: aMemberName		do: [:pointer | anInterfaceClass uncountedInterfacePointerAtAddress: pointer]		ifNil: [nil]</body><body package="Com- Ole">structureMemberAt: aMemberName	" Answer a structure wrapper on the structure member named &lt;aMemberName&gt; in the receiver. "	| aStructure |	aStructure := self memberAt: aMemberName.	^( COMStructure classForStructureNamed: aStructure type name )		temporaryOn: aStructure</body></methods><methods><class-id>External.COMStructure</class-id> <category>subclass-releasing</category><body package="Com- Ole">finalize	"The receiver is no longer referenced by any object in the system and is about to be destroyed.  Free the external resources owned by the receiver. "	self isValid ifFalse: [ ^ self ].	^self privateRelease</body></methods><methods><class-id>External.COMStructure</class-id> <category>releasing-members</category><body package="Com- Ole">releaseInterfaceMemberAt: aMemberName	" Private - release the Interface at &lt;aMemberName&gt;. "	(self internalInterfaceMemberAt: aMemberName type: IUnknown)		ifNotNil: 			[:itf |			itf enforceRelease.			self memberAt: aMemberName put: NULL]</body></methods><methods><class-id>External.COMStructure class</class-id> <category>private-accessing</category><body package="Com- Ole">structureNameMap	" Private - answer the dictionary which maps host structure names to data structure definition classes. "	^StructureNameMap</body><body package="Com- Ole">structureNameMap: aDictionary	" Private - set the dictionary which maps host structure names to data structure definition classes. "	StructureNameMap := aDictionary.</body><body package="Com- Ole">structureNameSynonyms	" Private - answer the dictionary which records typedef synonym names for registered structures. "	^StructureNameSynonyms</body><body package="Com- Ole">structureNameSynonyms: aDictionary	" Private - answer the dictionary which records typedef synonym names for registered structures. "	StructureNameSynonyms := aDictionary.</body></methods><methods><class-id>External.COMStructure class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerStructureName	" Private - register the host data structure name accessed by instance of the receiver. "	self registerStructureName: self structureName for: self.</body><body package="Com- Ole">removeStructureName	" Private - remove the registration of the name of the host data structure accessed by instances of the receiver. "	self removeStructureName: self structureName.</body></methods><methods><class-id>External.COMStructure class</class-id> <category>subclass-accessing</category><body package="Com- Ole">typeProvider	" Answer the object which can provide definitions from the type name space of the receiver. "	^COMExternalInterface</body></methods><methods><class-id>External.COMStructure class</class-id> <category>instance creation</category><body package="Com- Ole">createExternalStructureNamed: aStructureName	" Answer a new data structure instance for the host structure named &lt;aStructureName&gt;.  The structure is allocated in external COM memory. "	| aStructureClass |	( aStructureClass := self classForStructureNamed: aStructureName ifNone: [ nil ] ) notNil		ifTrue: [ ^aStructureClass newExternalStructure ].	^self onNew: ( self allocateStructureInCOMMemory: ( self typeNamed: aStructureName ) )		" possibly with dynamic protocol adaptor specifications applied "</body><body package="Com- Ole">createOwnedStructureNamed: aStructureName atAddress: anAddress	" Answer a new data structure instance for the host structure named &lt;aStructureName&gt; whose bytes are in external memory at &lt;anAddress&gt;. "	^( self classForStructureNamed: aStructureName ifNone: [ self ] )		 onNew: anAddress</body><body package="Com- Ole">createStructureNamed: aStructureName	" Answer a new data structure instance for the host structure named &lt;aStructureName&gt;.  The structure is allocated in Smalltalk memory. "	| aStructureClass |	( aStructureClass := self classForStructureNamed: aStructureName ifNone: [ nil ] ) notNil		ifTrue: [ ^aStructureClass new ].	^self forTypeNamed: aStructureName   " possibly with dynamic protocol adaptor specifications applied "</body><body package="Com- Ole">createStructureNamed: aStructureName atAddress: anAddress	" Answer a new data structure instance for the host structure named &lt;aStructureName&gt; whose bytes are in external memory at &lt;anAddress&gt;. "	^( self classForStructureNamed: aStructureName ifNone: [ self ] )		 temporaryOn: anAddress</body><body package="Com- Ole">newExternalStructure	" Answer a new instance of the receiver whose structure bytes are allocated in external memory using the COM task allocator. "	^self onNew: ( self allocateStructureInCOMMemory: self type )</body></methods><methods><class-id>External.COMStructure class</class-id> <category>external-transformations</category><body package="Com- Ole">resultValueBufferFor: aStructureName	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an instance of the data structure named &lt;aStructureName&gt;.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	| aStructureClass |	aStructureClass := self classForStructureNamed: aStructureName		ifNone: [ ^Win32StructureResultBuffer for: self type: ( self typeNamed: aStructureName ) ].	^aStructureClass resultValueBuffer</body><body package="Com- Ole">resultValuePointerBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a pointer to the COM structure named &lt;aStructureName&gt; allocated by the called function in COM task memory.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^COMStructurePointerResultBuffer for: self 		type: self baseCType</body><body package="Com- Ole">resultValuePointerBufferFor: aStructureName	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a pointer to the COM structure named &lt;aStructureName&gt; allocated by the called function in COM task memory.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	| aStructureClass |	aStructureClass := self classForStructureNamed: aStructureName		ifNone: [ ^COMStructurePointerResultBuffer for: self type: ( self typeNamed: aStructureName ) ].	^aStructureClass resultValuePointerBuffer</body></methods><methods><class-id>External.COMStructure class</class-id> <category>class map</category><body package="Com- Ole">classForStructureNamed: aStructureName	" Answer the COM structure definition class which represents the host data structure named &lt;structureName&gt;.  Answer a generic wrapper class if the structure is not supported by a customized wrapper class. "	^self classForStructureNamed: aStructureName 		ifNone: [ COMStructure ]</body><body package="Com- Ole">classForStructureNamed: aStructureName ifNone: aBlock	" Answer the COM structure definition class which represents the host data structure named &lt;structureName&gt;.   Answer the result of evaluating &lt;aBlock&gt; if no customized wrapper class is available. "	aStructureName isNil		ifTrue: [ ^aBlock value ].	^self structureNameMap at: ( self registeredStructureNameOf: aStructureName asSymbol )		ifAbsent: aBlock</body></methods><methods><class-id>External.COMStructure class</class-id> <category>private-registration</category><body package="Com- Ole">initializeStructureNameMap	" Private - initialize the map from a host data structure name to the COM structure definition class which represents that type. "	self structureNameMap: Dictionary new.</body><body package="Com- Ole">initializeSynonymNameMap	" Private - initialize the synonym map of host structure names. "	self structureNameSynonyms: Dictionary new.</body><body package="Com- Ole">registerStructureNameSynonyms: aStructureName	" Private - register any underlying type names for which &lt;aStructureName&gt; is a synonym. "	| aType registeredTypeName realType |	self structureNameSynonyms isNil		ifTrue: [ self initializeSynonymNameMap ].	aType := self typeNamed: aStructureName.	aType isNil 		ifTrue: [ ^self ].  " punt if the structure definition isn't actually loaded yet "	registeredTypeName := aType name.	[ ( realType := aType type ) ~~ aType ]		whileTrue: [			| aSynonymName |			aSynonymName := realType name.			aSynonymName ifNil: [ ^ self ].			( self structureNameMap includesKey: aSynonymName )				ifTrue: [ ^self ].  " bail if this is a registration on top of an already-known type "			self structureNameSynonyms at: aSynonymName put: registeredTypeName.			aType := realType ].</body><body package="Com- Ole">registeredStructureNameOf: aStructureTypeName	" Answer the name under which we registered any mapping information for &lt;aStructureTypeName&gt;. "	self structureNameSynonyms isNil		ifTrue: [ ^aStructureTypeName ].	^self structureNameSynonyms at: aStructureTypeName		ifAbsent: [ aStructureTypeName ]  " original name or not registered "</body><body package="Com- Ole">removeStructureNameSynonyms: aStructureName	" Private - remove the registration of any underlying type names for which &lt;aStructureName&gt; is a synonym. "	| aType realType |	self structureNameSynonyms isNil		ifTrue: [ ^self ].	aType := self typeNamed: aStructureName.	aType notNil ifTrue: [	[ ( realType := aType type ) ~~ aType ]		whileTrue: [			self structureNameSynonyms removeKey: realType name ifAbsent: [].			aType := realType ]]</body></methods><methods><class-id>External.COMStructure class</class-id> <category>subclass-instance creation</category><body package="Com- Ole">allocateStructureInCOMMemory: aType	" Private - allocate a structure buffer of type &lt;aType&gt; in COM task memory. "	" need to retain zero-initialization semantics, which #malloc unfortunately does not provide "	^COMMemoryAddress allocateStructure: aType</body></methods><methods><class-id>External.COMStructure class</class-id> <category>private-installation</category><body package="Com- Ole">obsolete	"The receiver was removed from the system and is now obsolete. Perform any necessary clean-up. Answer the receiver."	self removeStructureName.	^super obsolete</body><body package="Com- Ole">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMExternalInterface;		yourself</body><body package="Com- Ole">updateAndRegister		" Private - initialize class state. "	self structureNameMap isNil		ifTrue: [ self initializeStructureNameMap ].	self structureNameSynonyms isNil		ifTrue: [ self initializeSynonymNameMap ].	self registerStructureName.</body></methods><methods><class-id>External.COMStructure class</class-id> <category>registration</category><body package="Com- Ole">registerStructureName: aStructureName for: aClass 	" Register &lt;structureName&gt; as the host structure name of the data structure definition class &lt;aClass&gt;. "	| registeredClass |	aStructureName isNil ifTrue: [^self].	aStructureName isSymbol 		ifFalse: 			[COMDevelopmentWarning 				raiseSignal: (#WarnStrucRegSymbol &lt;&lt; #com 						&gt;&gt; 'COMStructure name must be registered as a symbol - ignoring registration of &lt;1p&gt; for class &lt;2s&gt;.  You need to fix the registration logic.' 							expandMacrosWith: aStructureName							with: aClass name).			Screen default ringBell.			^nil].	self structureNameMap isNil ifTrue: [self initializeStructureNameMap].	registeredClass := self structureNameMap at: aStructureName ifAbsent: [nil].	" structure registrations should be unique;  changing may be a programmer error "	(registeredClass notNil and: [registeredClass ~~ aClass]) 		ifTrue: 			[(MessageBox 				confirm: (#NamedReplateStrucReg &lt;&lt; #com 						&gt;&gt; 'You are about to replace the registration for structure &lt;1s&gt; of &lt;2s&gt; with &lt;3s&gt; - this may be an error.  Do you wish to proceed?' 							expandMacrosWith: aStructureName							with: registeredClass name							with: aClass name)) 					ifFalse: 						[Screen default ringBell.						^nil]].	self structureNameMap at: aStructureName put: aClass.	" the system is sensitive to typedefs, unfortunately, so we have to watch out for them "	self registerStructureNameSynonyms: aStructureName</body><body package="Com- Ole">removeStructureName: aStructureName	" Remove the registration of &lt;aStructureName&gt; as the host structure name of the data structure definition class &lt;aClass&gt;. "	aStructureName isNil		ifTrue: [ ^self ].	self structureNameMap removeKey: aStructureName "asSymbol" ifAbsent: [ ].	" the system is sensitive to typedefs, unfortunately, so we have to watch out for them "	self removeStructureNameSynonyms: aStructureName.</body></methods><methods><class-id>External.COMStructure class</class-id> <category>type information utilities</category><body package="Com- Ole">sizeOfStructureNamed: aStructureName	" Answer the size in bytes of the host structure named &lt;structureName&gt;. "	^( self classForStructureNamed: aStructureName 		ifNone: [ ^ ( self typeNamed: aStructureName ) sizeof ]		) sizeInBytes</body></methods><methods><class-id>External.COM_FILETIME</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream	super printOn: aStream.	self isValid		ifTrue: [ aStream nextPutAll: ' { ', self asTimestamp printString, ' }' ].</body></methods><methods><class-id>External.COM_FILETIME</class-id> <category>converting</category><body package="Com- Ole">asDosDateTime	" Answer the receiver as a DOS date/time pair. "	| resultReferenceDosDate resultReferenceDosTime |	resultReferenceDosDate := nil asValueReference.	resultReferenceDosTime := nil asValueReference.	( OLEDLL current CoFileTimeToDosDateTime: self		_: resultReferenceDosDate 		_: resultReferenceDosTime )			ifFalse: [ ^nil ].	^Array with: resultReferenceDosDate value with: resultReferenceDosTime value</body><body package="Com- Ole">asFileTime	" Answer the receiver as a Timestamp. "	^ self</body><body package="Com- Ole">asTimestamp	" Answer the receiver as a Timestamp. "	^( Win32_FILETIME temporaryOn: self structure ) asTimestamp</body></methods><methods><class-id>External.COM_FILETIME class</class-id> <category>instance creation</category><body package="Com- Ole">fromDosDate: dosDate time: dosTime	" Answer a new instance of the receiver corresponding to the given DOS date/time. "	| resultReference |	resultReference := nil asValueReference.	( OLEDLL current CoDosDateTimeToFileTime: dosDate _: dosTime _: resultReference )		ifFalse: [ ^nil ].	^resultReference value</body><body package="Com- Ole">fromTimeStamp: aTimeStamp	" Answer a new instance of the receiver with &lt;aTimeStamp&gt; as its value. "	| fileTime |	aTimeStamp isNil ifTrue: [^nil].	fileTime := Win32_FILETIME fromDate: aTimeStamp asDate				time: aTimeStamp asTime.	^[self onNew: fileTime structure] ensure: [fileTime enforceInvalidation]</body><body package="Com- Ole">now	" Answer a new instance of the receiver with the current time. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current CoFileTimeNow: resultReference.	^resultReference value</body></methods><methods><class-id>External.COM_FILETIME class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self structureName: #FILETIME.	self updateAndRegister</body></methods><methods><class-id>External.IPersist</class-id> <category>testing</category><body package="Com- Ole">usesStorage		" Answer whether the receiver operates on an IStorage. "	^false</body><body package="Com- Ole">usesStream		" Answer whether the receiver operates on an IStream. "	^false</body></methods><methods><class-id>External.IPersist</class-id> <category>interface operations</category><body package="Com- Ole">getClassID		" Answer the CLSID of the document object. "	| resultReference |	resultReference := nil asValueReference.	interface GetClassID: resultReference.	^resultReference value</body></methods><methods><class-id>External.IPersist class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersist.	self updateAndRegister</body></methods><methods><class-id>External.IPersistStream</class-id> <category>interface operations</category><body package="Com- Ole">getSizeMax		" Answer the maximum size of the stream needed to save the object. "	| resultReference |	resultReference := nil asValueReference.	interface GetSizeMax: resultReference.	^resultReference value</body><body package="Com- Ole">isDirty		" Answer whether the object has been changed since it was last saved. "	^( interface IsDirty ) = S_OK</body><body package="Com- Ole">load: aStream		" Initialize an object previously stored with the Save operation		from the stream &lt;aStream&gt;.		Raise an exception if an error occurs.  Answer the result code. "	^interface Load: aStream</body><body package="Com- Ole">save: aStream		" Save a copy of the object to the stream &lt;aStream&gt; and clear its dirty flag. "	interface Save: aStream _: true.</body><body package="Com- Ole">saveAndLeaveDirty: aStream		" Save a copy of the object to the stream &lt;aStream&gt;.  Do not clear its dirty flag. "	interface Save: aStream _: false.</body></methods><methods><class-id>External.IPersistStream</class-id> <category>storing</category><body package="Com- Ole">saveToStream: anIStream        " Save the the receiver to the stream object &lt;anIStream&gt;.         The CLSID and the object's persistent state are stored. "	OLEDLL current OleSaveToStream: self _: anIStream.</body></methods><methods><class-id>External.IPersistStream</class-id> <category>testing</category><body package="Com- Ole">usesStream		" Answer whether the receiver operates on an IStream. "	^true</body></methods><methods><class-id>External.IPersistStream class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistStream.	self updateAndRegister</body></methods><methods><class-id>External.IMoniker</class-id> <category>interface operations-testing</category><body package="Com- Ole">isAntiMoniker		" Answer whether the receiver is an anti-moniker "	^self systemMonikerType = MKSYS_ANTIMONIKER</body><body package="Com- Ole">isCompositeMoniker		" Answer whether the receiver is a composite moniker "	^self systemMonikerType = MKSYS_GENERICCOMPOSITE</body><body package="Com- Ole">isFileMoniker		" Answer whether the receiver is a file moniker "	^self systemMonikerType = MKSYS_FILEMONIKER</body><body package="Com- Ole">isItemMoniker		" Answer whether the receiver is an item moniker "	^self systemMonikerType = MKSYS_ITEMMONIKER</body><body package="Com- Ole">isPointerMoniker		" Answer whether the receiver is a pointer moniker "	^self systemMonikerType = MKSYS_POINTERMONIKER</body><body package="Com- Ole">isRunning: aBindContext 	monikerToLeft:  monikerToLeft 	monikerNewlyRunning: monikerNewlyRunning		" Answer whether this moniker is running. "	^( interface IsRunning: aBindContext _:  monikerToLeft _: monikerNewlyRunning ) = S_OK</body><body package="Com- Ole">isSystemMoniker		" Answer whether the receiver is a type of moniker whose		implementation semantics are conceptually important to the binding process. "	^( interface IsSystemMoniker: nil asValueReference ) = S_OK</body></methods><methods><class-id>External.IMoniker</class-id> <category>interface operations-accessing</category><body package="Com- Ole">getDisplayName	" Answer the display name of this moniker. "	| resultReference aBindContext |	resultReference := nil asValueReference.	aBindContext := IBindCtx newBindContext.	interface GetDisplayName: aBindContext _: nil _: resultReference.	^resultReference value</body><body package="Com- Ole">getDisplayName: aBindContext monikerToLeft: monikerToLeft		" Answer the display name of this moniker. "	| resultReference |	resultReference := nil asValueReference.	interface GetDisplayName: aBindContext _: monikerToLeft _: resultReference.	^resultReference value</body><body package="Com- Ole">getHash		" Answer the hash of this moniker. "	| resultReference |	resultReference := nil asValueReference.	interface Hash: resultReference.	^resultReference value</body><body package="Com- Ole">getTimeOfLastChange: aBindContext monikerToLeft:  monikerToLeft		" Answer the timestamp of when the object referenced by this moniker		was last changed. "	| resultReference |	resultReference := nil asValueReference.	interface GetTimeOfLastChange: aBindContext _:  monikerToLeft _: resultReference.	^resultReference value</body><body package="Com- Ole">name	" Answer the display name of this moniker. "	| resultReference aBindContext |	resultReference := nil asValueReference.	aBindContext := IBindCtx newBindContext.	interface GetDisplayName: aBindContext _: nil _: resultReference.	^resultReference value</body><body package="Com- Ole">systemMonikerType		" Answer the type of the receiver if it is a type of moniker whose		implementation semantics are conceptually important to the binding process. "	| resultReference |	resultReference := nil asValueReference.	^( interface IsSystemMoniker: resultReference ) = S_OK		ifTrue: [ resultReference value ]		ifFalse: [ nil ]</body></methods><methods><class-id>External.IMoniker</class-id> <category>binding</category><body package="Com- Ole">bind: iid		" Bind the receiver to the object which it references.		Answer the interface specified by the GUID &lt;iid&gt; on the object. "			| resultReference |	resultReference := COMInterfaceValueReference forIID: iid.	OLEDLL current BindMoniker: self 		_: 0 		_: iid 		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.IMoniker</class-id> <category>interface operations-composing</category><body package="Com- Ole">composeGenericCompositeWith: monikerToRight		" Answer a new composite moniker formed from the receiver and &lt;monikerToRight&gt;. 		The receiver must be a generic composite moniker. "	| resultReference |	resultReference := IMoniker new asValueReference.	interface ComposeWith: monikerToRight _: true _: resultReference.	^resultReference value</body><body package="Com- Ole">composeWith: monikerToRight		" Answer a new composite moniker formed from the receiver and &lt;monikerToRight&gt;. "	| resultReference |	resultReference := IMoniker new asValueReference.	interface ComposeWith: monikerToRight _: false _: resultReference.	^resultReference value</body></methods><methods><class-id>External.IMoniker</class-id> <category>interface operations-comparing</category><body package="Com- Ole">isEqual: aMoniker		" Answer whether the receiver is equal to &lt;aMoniker&gt;. "	^( interface IsEqual: aMoniker ) = S_OK</body></methods><methods><class-id>External.IMoniker</class-id> <category>interface operations-parsing</category><body package="Com- Ole">commonPrefixWith: aMoniker		" Answer the longest common prefix shared by the receiver and &lt;aMoniker&gt;. "	| resultReference hresult |	resultReference := IMoniker new asValueReference.	hresult := interface CommonPrefixWith: aMoniker _: resultReference.	hresult = S_OK  " MK_E_NOPREFIX, MK_S_ME, MK_S_HIM, MK_S_US "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">elementsEnumerator		" Answer an enumerator on the elements of a composite moniker		which will operate in the forward direction.		Answer nil if there is nothing to enumerate. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumMoniker ) asValueReference.	interface Enum: true _: resultReference.	^resultReference value</body><body package="Com- Ole">elementsReversedEnumerator		" Answer an enumerator on the elements of a composite moniker		which will operate in the reverse direction.		Answer nil if there is nothing to enumerate. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumMoniker ) asValueReference.	interface Enum: false _: resultReference.	^resultReference value</body><body package="Com- Ole">inverse		" Answer the inverse of this moniker. "	| resultReference hresult |	resultReference := IMoniker new asValueReference.	hresult := interface Inverse: resultReference.	hresult = S_OK   " MK_E_NOINVERSE "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">parseDisplayName: aBindContext 	monikerToLeft: monikerToLeft 	displayName: displayName		" Parse the display name &lt;displayName&gt; into a moniker 		for the object that it refers to.  Answer the interface pointer. "	| resultReference nCharsConsumedReference |	resultReference := IMoniker new asValueReference.	nCharsConsumedReference := nil asValueReference.	interface ParseDisplayName: aBindContext 		_: monikerToLeft 		_: displayName 		_: nCharsConsumedReference 		_: resultReference.	^resultReference value</body><body package="Com- Ole">reduce: aBindContext howFar: dwReduceHowFar monikerToLeft: monikerToLeft		" Reduce this moniker to a more or equally efficient moniker		referring to the same object, according the the MKREDUCE flags.		Answer the resulting reduced moniker. "	| resultReference hresult |	resultReference := IMoniker new asValueReference.	hresult := interface Reduce: aBindContext 		_: dwReduceHowFar 		_: monikerToLeft 		_: resultReference.	hresult = S_OK   " MK_S_REDUCED_TO_SELF "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">relativePathTo: aMoniker		" Answer the relative path which when composed to the end of the receiver 		will yield &lt;aMoniker&gt;. "	| resultReference hresult |	resultReference := IMoniker new asValueReference.	hresult := interface RelativePathTo: aMoniker _: resultReference.	hresult = S_OK   " MK_S_HIM "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body></methods><methods><class-id>External.IMoniker</class-id> <category>interface operations-binding</category><body package="Com- Ole">bindToObject: aBindContext monikerToLeft: monikerToLeft iid: iid		" Locate and load the object referenced by this moniker.		Answer the interface identified by &lt;iid&gt; on the referenced object. "	| resultReference |	resultReference := COMInterfaceValueReference forIID: iid.	interface BindToObject: aBindContext _: monikerToLeft _: iid _: resultReference.	^resultReference value</body><body package="Com- Ole">bindToStorage: aBindContext monikerToLeft: monikerToLeft iid: iid		" Obtain access to the persistent storage of the object referenced by this moniker.		Answer the interface identified by &lt;iid&gt; on the referenced object's storage. "	| resultReference |	resultReference := COMInterfaceValueReference forIID: iid.	interface BindToStorage: aBindContext _: monikerToLeft _: iid _: resultReference.	^resultReference value</body></methods><methods><class-id>External.IMoniker</class-id> <category>accessing</category><body package="Com- Ole">description		" Answer a description of the receiver. "	| type |	type := self type.	type isNil		ifTrue: [ type := (#unknownMonikerType &lt;&lt; #com &gt;&gt; 'unknown moniker type') asString ].	^type, ': ', self name</body><body package="Com- Ole">elementDescriptions		" Answer the descriptions of the elements of a composite moniker. "	| elements descriptions |	elements := self elements.	descriptions := elements collect: [ :aMoniker |		aMoniker description ].	elements do: [ :aMoniker | aMoniker enforceRelease ].	^descriptions</body><body package="Com- Ole">elementNames		" Answer the display names of the elements of a composite moniker. "	| elements names |	elements := self elements.	names := elements collect: [ :aMoniker |		aMoniker name ].	elements do: [ :aMoniker | aMoniker enforceRelease ].	^names</body><body package="Com- Ole">elements		" Answer the elements of a composite moniker. "	| anEnumerator contents |	anEnumerator := self elementsEnumerator.	anEnumerator isNil		ifTrue: [ ^ #() ].	contents := anEnumerator contents.	^contents</body><body package="Com- Ole">elementsReversed		" Answer the elements of a composite moniker in reverse order. "	| anEnumerator contents |	anEnumerator := self elementsReversedEnumerator.	anEnumerator isNil		ifTrue: [ ^ #() ].	contents := anEnumerator contents.	^contents</body><body package="Com- Ole">type		" Answer the type of the receiver if it is a type of moniker whose		implementation semantics are conceptually important to the binding process. "	^self class typeNameOf: self systemMonikerType</body></methods><methods><class-id>External.IMoniker</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream        "Append the ASCII representation         of the receiver to &lt;aStream&gt;."    super printOn: aStream.    self isValid        ifTrue: [            | name |            name := [ self name ]                on: COMError                do: [ :ex |                    ex hresult = E_NOTIMPL                        ifTrue: [ ex return: (#noName &lt;&lt; #com &gt;&gt; '&lt;no name&gt;') asString ]                        ifFalse: [ ex pass ] ].            aStream nextPutAll: ' (''', self type, ': ', name, ''')' ].</body></methods><methods><class-id>External.IMoniker class</class-id> <category>private-installation</category><body package="Com- Ole">constructTypeNames	" Private - answer a mapping from system moniker types to descriptive names. "	^Dictionary new		at: MKSYS_ANTIMONIKER put: 'anti-moniker';		at: MKSYS_FILEMONIKER put: 'file moniker';		at: MKSYS_GENERICCOMPOSITE put: 'composite moniker';		at: MKSYS_ITEMMONIKER put: 'item moniker';		at: MKSYS_POINTERMONIKER put: 'pointer moniker';		yourself</body><body package="Com- Ole">initializeTypeNames	" Private - initialize the mapping from system moniker types to descriptive names. "	self typeNames: self constructTypeNames.</body></methods><methods><class-id>External.IMoniker class</class-id> <category>instance creation</category><body package="Com- Ole">createAntiMoniker	" Answer a new instance of the receiver for a new anti moniker. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current CreateAntiMoniker: resultReference.	^resultReference value</body><body package="Com- Ole">createFileMoniker: aPathName	" Create a new moniker for the file named &lt;aPathName&gt;.  The file name can be either an absolute or relative path name.   Answer a new instance of the receiver for the new file moniker. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current CreateFileMoniker: aPathName 		_: resultReference.	^resultReference value</body><body package="Com- Ole">createGenericCompositeMoniker: firstMoniker with: nextMoniker	" Create a new generic composite moniker which is formed by concatentating &lt;firstMoniker&gt; with &lt;nextMoniker&gt;.  Answer a new instance of the receiver for the new composite moniker. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current CreateGenericComposite: firstMoniker		_: nextMoniker		_: resultReference.	^resultReference value</body><body package="Com- Ole">createItemMoniker: itemName	" Create a new moniker for the item named &lt;itemName&gt; using the default delimiter.  Answer a new instance of the receiver for the new item moniker. "	^self createItemMoniker: itemName 		delimiterString: self defaultDelimiterString</body><body package="Com- Ole">createItemMoniker: itemName delimiterString: delimiterString	" Create a new moniker for the item named &lt;itemName&gt; using the given &lt;delimiterString&gt;.   Answer a new instance of the receiver on the item moniker. "	| resultReference |	resultReference := self new asValueReference .	OLEDLL current CreateItemMoniker: delimiterString		_: itemName		_: resultReference.	^resultReference value</body><body package="Com- Ole">createPointerMoniker: anIUnknown	" Create a new pointer moniker for the object &lt;anIUnknown&gt;.  Answer a new instance of the receiver for the new moniker. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current CreatePointerMoniker: anIUnknown 		_: resultReference.	^resultReference value</body><body package="Com- Ole">defaultDelimiterString	" Answer the default delimiter string for an item moniker. "	^'!'</body><body package="Com- Ole">fromDisplayName: displayName	" Answer a new instance of the receiver for the object referenced by &lt;displayName&gt;. "	^self fromDisplayName: displayName 		bindContext: nil		charsConsumed: nil asValueReference</body><body package="Com- Ole">fromDisplayName: displayName bindContext: aBindContext	" Answer a new instance of the receiver for the object referenced by &lt;displayName&gt;. "	^self fromDisplayName: displayName 		bindContext: aBindContext		charsConsumed: nil asValueReference</body><body package="Com- Ole">fromDisplayName: displayName bindContext: aBindContext charsConsumed: nCharsConsumedReference	" Answer a new instance of the receiver for the object referenced by &lt;displayName&gt;.   Set the value of the caller's reference object &lt;nCharsConsumedReference&gt; to the number of characters consumed from the display name. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current MkParseDisplayName: aBindContext		_: displayName		_: nCharsConsumedReference		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.IMoniker class</class-id> <category>parsing utilities</category><body package="Com- Ole">commonPrefixOf: aMoniker with: anotherMoniker	" Answer a new moniker specifying the longest common prefix between &lt;aMoniker&gt; and &lt;anotherMoniker&gt;. "	" Used in the implementation of a moniker class. "	| resultReference hresult |	resultReference := self new asValueReference.	hresult := OLEDLL current MonikerCommonPrefixWith: aMoniker 		_: anotherMoniker 		_: resultReference.	hresult = S_OK  " MK_E_NOPREFIX, MK_S_ME, MK_S_HIM, MK_S_US "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">relativePathTo: sourceMoniker from: destMoniker	" Answer a new moniker specifying the relative path from the &lt;sourceMoniker&gt; to &lt;destMoniker&gt;. "	" Used in the implementation of a moniker class. "	| resultReference hresult |	resultReference := self new asValueReference.	hresult := OLEDLL current MonikerRelativePathTo: sourceMoniker 		_: destMoniker 		_: resultReference 		_: false.	hresult = S_OK   " MK_S_HIM "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body></methods><methods><class-id>External.IMoniker class</class-id> <category>private-accessing</category><body package="Com- Ole">typeNames	" Private - answer the mapping from system moniker types to descriptive names. "	^TypeNames</body><body package="Com- Ole">typeNames: aDictionary	" Private - set the mapping from system moniker types to descriptive names. "	TypeNames := aDictionary.</body></methods><methods><class-id>External.IMoniker class</class-id> <category>description utilities</category><body package="Com- Ole">typeNameOf: aMonikerType	" Answer the name of the moniker type &lt;aMonikerType&gt;.   Answer the result of evaluating &lt;aBlock&gt; if the moniker type is not known (e.g., is not a system moniker). "	^self typeNameOf: aMonikerType ifAbsent: [ nil ]</body><body package="Com- Ole">typeNameOf: aMonikerType ifAbsent: aBlock	" Answer the name of the moniker type &lt;aMonikerType&gt;.   Answer the result of evaluating &lt;aBlock&gt; if the moniker type is not known (e.g., is not a system moniker). "	^self typeNames at: aMonikerType ifAbsent: [ aBlock value ]</body></methods><methods><class-id>External.IMoniker class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IMoniker.	self initializeTypeNames.	self updateAndRegister</body></methods><methods><class-id>External.COM_OLEVERB</class-id> <category>subclass-releasing</category><body package="Com- Ole">releaseResources	" Private - release resources owned by the receiver. "	self releaseVerbName.	super releaseResources.</body><body package="Com- Ole">releaseVerbName		" Private - release the verb name in the receiver. "	| aPointer |	( aPointer := self memberAt: #lpszVerbName ) isNull		ifFalse: [			( COMMemoryAddress fromPointer: aPointer ) free.			self memberAt: #lpszVerbName put: nil ].</body></methods><methods><class-id>External.COM_OLEVERB</class-id> <category>accessing</category><body package="Com- Ole">verbName	" Answer the name of the verb. "	^self unicodePointerMemberAt: #lpszVerbName</body></methods><methods><class-id>External.COM_OLEVERB class</class-id> <category>accessing</category><body package="Com- Ole">enumeratorIID	" Answer the IID of the interface which enumerates collections containing instances of the receiver. "	^IID_IEnumOLEVERB</body></methods><methods><class-id>External.COM_OLEVERB class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self structureName: #OLEVERB.	self updateAndRegister</body></methods><methods><class-id>External.IGlobalInterfaceTable</class-id> <category>interface operations</category><body package="Com- Ole">getInterfaceFromGlobal: dwCookie with: riid	" Invoke the IGlobalInterfaceTable::GetInterfaceFromGlobal function. ""**** NOTE: Automatically generated method, requires manual review ****"	| resultReference |	resultReference := COMInterfaceValueReference forIID: riid.	interface GetInterfaceFromGlobal: dwCookie _: riid _: resultReference.	^resultReference value</body><body package="Com- Ole">registerInterfaceInGlobal: anInterface	| dwCookie res |	dwCookie := DWORD calloc.	res := self				registerInterfaceInGlobal: anInterface asPointerParameter				with: anInterface iid				with: dwCookie.	^(External.HRESULT succeeded: res)		ifTrue: [dwCookie contents]		ifFalse: [nil]</body><body package="Com- Ole">registerInterfaceInGlobal: pUnk with: riid with: dwCookie	" Invoke the IGlobalInterfaceTable::RegisterInterfaceInGlobal function. ""**** NOTE: Automatically generated method, requires manual review ****"	^interface RegisterInterfaceInGlobal: pUnk _: riid _: dwCookie</body><body package="Com- Ole">revokeInterfaceFromGlobal: dwCookie	" Invoke the IGlobalInterfaceTable::RevokeInterfaceFromGlobal function. "	^interface RevokeInterfaceFromGlobal: dwCookie</body></methods><methods><class-id>External.IGlobalInterfaceTable class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IGlobalInterfaceTable.	self updateAndRegister</body></methods><methods><class-id>External.COMObject</class-id> <category>accessing</category><body package="Com- Ole">classFactoryClass	" Answer the class factory object class which would have created the receiver. "	^self class classFactoryClass</body><body package="Com- Ole">clsid	" Answer the CLSID of the COM object class of the receiver. "	^self class clsid</body><body package="Com- Ole">controllingUnknown	" Answer the controlling IUnknown of the receiver.  If the receiver is not a contained object, this will be its inner IUnknown. "	^controllingUnknown</body><body package="Com- Ole">innerUnknown	" Answer the non-delegating inner IUnknown of the receiver.  If the receiver is contained within a controlling object, this is different than the controlling unknown of the outer object. "	^innerUnknown</body><body package="Com- Ole">vtableSelectorFor: aSelector	aSelector = #AddRef ifTrue: [^ #enforceAddRef ].	aSelector = #Release ifTrue: [^ #enforceRelease ].	^ aSelector</body></methods><methods><class-id>External.COMObject</class-id> <category>subclass-tracing</category><body package="Com- Ole">isTraceEnabled	" Answer whether tracing is currently enabled for incoming function calls. "	^self class isTraceEnabled</body><body package="Com- Ole">isTraceEnabledForIID: anIID	" Answer whether tracing is currently enabled for incoming function calls on the interface identified by &lt;anIID&gt;. "	^self class isTraceEnabledForIID: anIID</body><body package="Com- Ole">logCr	" Append an empty line to the COM trace log. The caller is responsible for ensuring that tracing is enabled. "	self class logCr.</body><body package="Com- Ole">logIfTraceEnabled: traceEntry	" Append &lt;traceEntry&gt; to the COM trace log if tracing is currently enabled. "	self class logIfTraceEnabled: traceEntry.</body><body package="Com- Ole">logIfTraceEnabled: traceEntry forIID: anIID	" Append &lt;traceEntry&gt; to the COM trace log if tracing is currently enabled for the interface identified by &lt;anIID&gt;. "	self class logIfTraceEnabled: traceEntry forIID: anIID.</body><body package="Com- Ole">logTraceEntry: traceEntry	" Append the value of &lt;traceEntry&gt; to the COM trace log.  The &lt;traceEntry&gt; can be either a string or a block which returns a string.  The caller is responsible for ensuring that tracing is enabled. "	self class logTraceEntry: traceEntry.</body></methods><methods><class-id>External.COMObject</class-id> <category>subclass-accessing</category><body package="Com- Ole">allocatedInterfaces	" Private - answer the interfaces supported by the receiver which have been allocated during its lifetime. "	| allocatedInterfaces |	allocatedInterfaces := Set new.	self allocatedInterfacesDo: [ :anInterface |		allocatedInterfaces add: anInterface ].	^allocatedInterfaces</body><body package="Com- Ole">getInnerObjectInterfaceForIID: iid	" Private - answer a separate reference to the interface identified by the GUID &lt;iid&gt; of an inner object which is to be directly exposed to clients as an interface of the controlling object of an aggregate.  Answer nil there is no such interface.  This method should be reimplemented by subclasses which expose interfaces of inner objects through aggregation. "	^nil</body><body package="Com- Ole">getInterfaceForIID: iid	" Private - answer the interface identified by the GUID &lt;iid&gt;.  Answer nil if the requested interface is not supported by the receiver.  This method should be reimplemented by subclasses. "	^nil</body><body package="Com- Ole">interfaceForIID: iid	" Private - answer the interface supported by the receiver which is identified by the GUID &lt;iid&gt;.  Answer nil if the requested interface is not supported by the receiver. "	^self interfaceForIID: iid ifNone: [ nil ]</body><body package="Com- Ole">interfaceForIID: iid ifNone: aBlock	" Private - answer the interface supported by the receiver which is identified by the GUID &lt;iid&gt;.  Answer the result of evaluating a block if the requested interface is not supported. "	| anInterface |	iid = IID_IUnknown		ifTrue: [ ^self innerUnknown ].	^( anInterface := self getInterfaceForIID: iid ) isNil		ifTrue: [ aBlock value ]		ifFalse: [ anInterface ]</body><body package="Com- Ole">referenceCount	" Private - answer the receiver's reference count. This is the sum of the outstanding reference counts on all of its interfaces. "	^referenceCount</body></methods><methods><class-id>External.COMObject</class-id> <category>copying</category><body package="Com- Ole">postCopy	super postCopy.	self releaseEventTable</body></methods><methods><class-id>External.COMObject</class-id> <category>printing</category><body package="Com- Ole">printCLSIDOn: aStream	" Append a text representation of the receiver's CLSID to &lt;aStream&gt;. "	self clsid notNil		ifTrue: [ aStream nextPutAll: ' (CLSID ', self clsid asString, ')' ].</body><body package="Com- Ole">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	self printCLSIDOn: aStream.</body></methods><methods><class-id>External.COMObject</class-id> <category>testing</category><body package="Com- Ole">isCOMInterfaceAdaptor	" Answer whether the receiver is an adaptor on a COM interface. "	^false</body><body package="Com- Ole">isClassFactory	" Answer whether the receiver is a class factory which manufactures COM objects. "	^false</body><body package="Com- Ole">isControllingObject	" Answer whether the receiver is a controlling object which handles its own IUnknown operations. "	^self controllingUnknown == self innerUnknown</body><body package="Com- Ole">isInnerObject	" Answer whether the receiver is an inner object contained within an aggregate which delegates its IUnknown operations to a controlling object. "	^self controllingUnknown ~~ self innerUnknown</body></methods><methods><class-id>External.COMObject</class-id> <category>subclass-releasing</category><body package="Com- Ole">forceRelease	" Private - attempt to forcibly release the receiver.  Answer whether successful.  This is a dangerous thing to do and is primarily a developer debugging facility. 	I added code which checks if the image owns references to the object and tries to	get rid of them in this case. If this step fails it will not proceed releasing itself."	self invalidateSessionSelfReferences.	self releaseResources.	referenceCount := 0.	^true</body><body package="Com- Ole">objectRelease	" Private - invoke the Object #release method. "	^super release</body><body package="Com- Ole">releaseAllocatedInterfaces	" Private - release the interfaces supported by the receiver which have been allocated during its lifetime. "	self allocatedInterfacesDo: [ :anInterface | 		anInterface interfaceBinding ifNotNil: [:binding | binding enforceRelease ]].</body><body package="Com- Ole">releaseInnerObjects	" Private - release any inner objects owned by the receiver.  Should be reimplemented by subclasses which are controlling objects of an aggregate or which use containment to implement their services. "</body><body package="Com- Ole">releaseResources	" Private - release resources associated with the receiver.  Should be reimplemented by subclasses if resources other than allocated interfaces or contained objects are owned by the receiver.  Subclasses should release their own resources and then invoke 'super releaseResources'. "	self doesNotNeedFinalization.	self		releaseInnerObjects;		releaseAllocatedInterfaces;		resetAllocatedInterfaces.	self triggerReleasedEvent</body><body package="Com- Ole">resetAllocatedInterfaces	" Private - reset the references to the interfaces supported by the receiver.  May be reimplemented by subclasses.  Subclass implementations should invoke the superclass method. "	"Assert isTrue: [ self innerUnknown interfaceBinding hasExternalResources not ]."	self innerUnknown: nil.	" the inner object of an aggregate does not reference count its controlling unknown,		so we need to destroy the reference here rather than release it. "	self isInnerObject		ifTrue: 			[self controllingUnknown enforceInvalidation.			self controllingUnknown: nil]</body><body package="Com- Ole">triggerReleasedEvent	" Private - trigger the #released event when the last client reference on the receiver has been released and all resources acquired by the object have been released. "	self triggerEvent: #released.	" we don't allocate event table storage for all COM objects because		in the general case we only use it for objects manufactured 		by a class factory.  So we don't care about the minor inefficiency		of routing through the Object event table storage for this 		once-in-a-lifetime event, but we do want to be careful		to clean up afterwards so we don't leave dangling references		to otherwise unreference objects.  (Note that this concern		goes away if the Object event table storage uses a weak registry.) "	self releaseEventTable.    " less aggressive technique: self releaseAllActionsForEvent: #released "</body></methods><methods><class-id>External.COMObject</class-id> <category>subclass-enumerating</category><body package="Com- Ole">allocatedInterfacesDo: aOneArgBlock	" Private - enumerate the interfaces supported by the receiver which have been allocated during its lifetime and evaluate &lt;aOneArgBlock&gt; with each.  Should be reimplemented by each subclass.  The subclass implementation should invoke the superclass method before enumerating the allocated interfaces managed in subclass storage. "	self innerUnknown notNil		ifTrue: [ aOneArgBlock value: self innerUnknown ].</body></methods><methods><class-id>External.COMObject</class-id> <category>private-IUnknown operations</category><body package="Com- Ole">AddRef	" Private - perform the IUnknown::AddRef function.  Delegate to the controlling unknown to allow reuse if the receiver is a contained object.  The controlling unknown is the receiver's own inner unknown if it is not aggregrated or is the controlling object. "	self callIsDispensable.</body><body package="Com- Ole">QueryInterface: iid _: resultReference	" Private - implement the IUnknown::QueryInterface function.  Query the receiver for the interface identified by the GUID &lt;iid&gt;.  If the requested interface is supported by the receiver, store  a new reference counted copy of the interface into &lt;resultReference&gt;. Answer the result code. "	self isControllingObject		ifTrue: [ ^self innerQueryInterface: iid _: resultReference ].	^[ self controllingUnknown interfaceBinding QueryInterface: iid _: resultReference ]		on: COMError		do: [ :ex | ^ex hresult ]</body><body package="Com- Ole">innerAddRef	" Private - implement the non-delegating IUnknown::AddRef function.  Increment the reference count of the interface referenced by the receiver.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	^self incrementReferenceCount</body><body package="Com- Ole">innerQueryInterface: iid _: resultReference	" Private - implement the non-delegating IUnknown::QueryInterface function.  Query the receiver for the interface identified by the GUID &lt;iid&gt;.  If the requested interface is supported by the receiver, store a new reference counted copy of the interface into &lt;resultReference&gt;. Answer the result code. "	| anInterface |	anInterface := self getInnerObjectInterfaceForIID: iid.	anInterface isNil		ifTrue: [anInterface := self interfaceForIID: iid ifNone: [^E_NOINTERFACE]].	resultReference value: anInterface.	^S_OK</body><body package="Com- Ole">innerRelease	" Private - implement the non-delegating IUnknown::Release function.  Decrement the reference count of the interface referenced by the receiver and destroy the reference to it.  Release any resources associated with the receiver.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	^self enforceDecRef</body><body package="Com- Ole">privateAddRef	" Private - perform the IUnknown::AddRef function.  Delegate to the controlling unknown to allow reuse if the receiver is a contained object.  The controlling unknown is the receiver's own inner unknown if it is not aggregrated or is the controlling object. "	^self isControllingObject		ifTrue: [ self innerAddRef ]		ifFalse: [   			" return value is not an HRESULT, so don't need exception handler "			self controllingUnknown enforceAddRef ]</body></methods><methods><class-id>External.COMObject</class-id> <category>subclass-initializing</category><body package="Com- Ole">initialize	" Private - initialize the receiver. "	referenceCount := 0.	self initializeInterfaces.	self needsFinalization.</body><body package="Com- Ole">initializeInterfaces	" Private - Allocate any interfaces which are expected to be required during the object's lifetime.  The inner IUnknown is always allocated.  May be reimplemented by subclasses.  Subclass implementations must invoke the superclass method. "	self innerUnknown: self createInnerUnknown.	" outer object uses its own inner unknown as its controlling unknown "	self controllingUnknown isNil		ifTrue: [ self controllingUnknown: self innerUnknown ].</body></methods><methods><class-id>External.COMObject</class-id> <category>subclass-interface operations</category><body package="Com- Ole">unimplementedFunction	" Private - default handler for an unimplemented interface function. "	^E_NOTIMPL</body></methods><methods><class-id>External.COMObject</class-id> <category>subclass-reference counting</category><body package="Com- Ole">enforceDecRef	" Private - decrement the receiver's reference count.  This is the sum of the outstanding reference counts on all of its interfaces.  Release resources owned by the receiver if its reference count goes to 0. "	^ self privateDecrementReferenceCount</body><body package="Com- Ole">incrementReferenceCount	" Private - increment the receiver's reference count.  This is the sum of the outstanding reference counts on all of its interfaces. "	^referenceCount := referenceCount + 1</body></methods><methods><class-id>External.COMObject</class-id> <category>subclass-dispatch configuring</category><body package="Com- Ole">standardIUnknownSelectors	" Private - answer the selectors for the standard implementations of the IUnknown operations. "	^#( #QueryInterface:_: #AddRef  #Release )</body></methods><methods><class-id>External.COMObject</class-id> <category>IUnknown operations</category><body package="Com- Ole">queryInterface: iid	"Query the receiver for the interface specified by the GUID &lt;iid&gt;.  Answer the interface if it is supported, else answer nil. "	^self controllingUnknown queryInterface: iid</body><body package="Com- Ole">release	" Decrement the reference count of the interface referenced by the receiver.  Release any resources associated with the receiver.  Answer the value of the reference count (for diagnostic use only; may not be stable). "	self callIsDispensable.	self objectRelease.</body></methods><methods><class-id>External.COMObject</class-id> <category>private-accessing</category><body package="Com- Ole">controllingUnknown: anIUnknown	" Private - set the controlling unknown of the receiver to &lt;anIUnknown&gt;.  This is different from the local unknown when the receiver is part of an aggregation. "	anIUnknown isNil 		ifTrue: [ controllingUnknown := nil. ^self ].	"Assert isTrue: [ 		innerUnknown isNil  "" when I'm being created as an inner object of an aggregate ""		or: [ anIUnknown == innerUnknown ] ]."  " when I am in control of my own destiny "	" The inner object of an aggregate must keep a copy of its controlling object's IUnknown,		but is not allowed to reference count it, since that would create a reference		counting cycle between the inner and outer objects. "	controllingUnknown := ( innerUnknown isNil		ifTrue: [ anIUnknown copy ]  " the controlling object to which I must now delegate "		ifFalse: [ anIUnknown ] ).</body><body package="Com- Ole">innerUnknown: anIUnknown	" Private - set the non-delegating inner IUnknown of the receiver to &lt;anIUnknown&gt;.  This is different from the controlling unknown when the receiver is part of an aggregation. "	innerUnknown := anIUnknown.</body><body package="Com- Ole">sessionSelfReferences	| myInterfaces |	myInterfaces := self allocatedInterfaces.	^COMSessionManager allOwnedInterfaces select: 			[:each |			myInterfaces				contains: [:my | my isValid and: [my interfaceBinding isReferencedBy: each ]]]</body></methods><methods><class-id>External.COMObject</class-id> <category>private-initializing</category><body package="Com- Ole">createInnerUnknown	" Private - answer a new non-delegating IUnknown for the receiver. "	^IUnknown innerBindingOn: self</body></methods><methods><class-id>External.COMObject</class-id> <category>finalization</category><body package="Com- Ole">finalize	self releaseResources.</body></methods><methods><class-id>External.COMObject</class-id> <category>obsolete</category><body package="Com- Ole">Release	self callIsDispensable.</body><body package="Com- Ole">addRef	"Don't allow direct calls to AddRef"	^self callIsDispensable</body><body package="Com- Ole">decrementReferenceCount	" Private - decrement the receiver's reference count.  This is the sum of the outstanding reference counts on all of its interfaces.  Release resources owned by the receiver if its reference count goes to 0. "	^ self privateDecrementReferenceCount</body><body package="Com- Ole">freeSessionSelfReferences	"Try to get rid of references to the server object"	^ self invalidateSessionSelfReferences</body></methods><methods><class-id>External.COMObject</class-id> <category>notices</category><body package="Com- Ole">enforceAddRef	^ self privateAddRef</body><body package="Com- Ole">enforceRelease	^ self privateRelease</body></methods><methods><class-id>External.COMObject</class-id> <category>private interface operations</category><body package="Com- Ole">privateRelease	" Private - perform the IUnknown::Release function.  Delegate to the controlling unknown to allow reuse if the receiver is a contained object.  The controlling unknown is the receiver's own inner unknown if it is not aggregrated or is the controlling object. "	^self isControllingObject		ifTrue: [ self innerRelease ]		ifFalse: [   			" return value is not an HRESULT, so don't need exception handler "			" [AA 2005/11/07] fix for AR49895. 			  Inner unknown loses reference to the controlling unknown when #Release is called.			  We therefore call decrementReferenceCount instead."			self controllingUnknown privateDecrementReferenceCount  ]</body></methods><methods><class-id>External.COMObject</class-id> <category>private</category><body package="Com- Ole">privateDecrementReferenceCount	" Private - decrement the receiver's reference count.  This is the sum of the outstanding reference counts on all of its interfaces.  Release resources owned by the receiver if its reference count goes to 0. "	referenceCount := referenceCount - 1.	referenceCount &lt; 0 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#WarnNamedTooManyRel1p2p &lt;&lt; #com 						&gt;&gt; 'Too many releases of &lt;1p&gt; (&lt;2p&gt;)' expandMacrosWith: self							with: referenceCount)].	^referenceCount</body></methods><methods><class-id>External.COMObject</class-id> <category>tools</category><body package="Com- Ole">invalidateSessionSelfReferences	"Try to get rid of references to the server object"	self sessionSelfReferences do: [:each | each enforceInvalidation]</body></methods><methods><class-id>External.COMObject class</class-id> <category>CLSID class map</category><body package="Com- Ole">classForCLSID: aGUID	" Answer the COMObject subclass which represents the class specified by the CLSID &lt;aGUID&gt;.  Answer nil if the CLSID is not supported. "	^self classForCLSID: aGUID ifNone: [ nil ]</body><body package="Com- Ole">classForCLSID: aGUID ifNone: aBlock	" Answer the COMObject subclass which represents the class specified by the CLSID &lt;aGUID&gt;.  Answer the result of  evaluating &lt;aBlock&gt; if the CLSID is not known. "	^COMObject allSubclasses 		detect: [ :aCOMObjectClass | aCOMObjectClass clsid = aGUID ]		ifNone: aBlock</body></methods><methods><class-id>External.COMObject class</class-id> <category>class factory services</category><body package="Com- Ole">classFactoryClass	" Answer the class factory object class which creates instances of the receiver. "	^COMClassFactoryObject</body><body package="Com- Ole">newClassFactory	" Answer a new class factory which creates instances of the receiver. "	^self classFactoryClass forClass: self</body><body package="Com- Ole">registerClassFactory	" Register a class factory to create instances of the receiver.  Answer the class factory.  Answer nil if class factory registration failed. "	" while ordinarily we prefer not to clutter object implementatations with tracing support,		which in general is better handling through the non-intrusive interface tracing		facilities, class factory registration is such a fundamental operation that		in this case we add tracing to facilitate debugging application problems. "	| aCLSID aClassFactory |	self logIfTraceEnabled: 			[#NamedRegClassFactory &lt;&lt; #com 				&gt;&gt; 'Registering class factory for &lt;1s&gt; ( CLSID &lt;2p&gt; ) ...' 					expandMacrosWith: self name					with: self clsid].	(aCLSID := self clsid) isNil 		ifTrue: 			[| message |			message := (#WarnNamedCantRegFactory &lt;&lt; #com 						&gt;&gt; 'Cannot register a class factory for class &lt;1s&gt; (no CLSID is defined).' 							expandMacrosWith: self name).			self logIfTraceEnabled: message.			COMDevelopmentWarning raiseSignal: message.			^nil].	aClassFactory := COMSessionManager classFactoryForCLSID: aCLSID.	aClassFactory notNil 		ifTrue: 			[| message |			message := (#ErrNamedRegUnnecessary &lt;&lt; #com 						&gt;&gt; 'Registration is unnecessary: a class factory is already registered for class &lt;1s&gt; ( CLSID &lt;2s&gt; ).' 							expandMacrosWith: self name							with: aCLSID asString).			self logIfTraceEnabled: message.			COMDevelopmentWarning raiseSignal: message.			^aClassFactory].	aClassFactory := self newClassFactory.	[aClassFactory registerAsMultipleUseLocalServer] on: COMError		do: 			[:ex | 			self isTraceEnabled 				ifTrue: 					[self						logTraceEntry: #ClassFactoryRegFailed &lt;&lt; #com 									&gt;&gt; '***ERROR: class factory registration failed:';						logTraceEntry: '    ' , ex description;						logCr].			^nil].	self logIfTraceEnabled: 			[#DoneRegisteringFactory &lt;&lt; #com &gt;&gt; '...done registering class factory'].	^aClassFactory</body><body package="Com- Ole">registerServerClassFactory	" Register a class factory for an object server to create instances of the receiver.  Terminate the object server application if registration fails.  Answer the class factory if registration succeeds. "	| aClassFactory |	aClassFactory := self registerClassFactory.	aClassFactory isNil		ifTrue: [			COMSessionManager terminateServer:				((#FactoryRegistrationFailed &lt;&lt; #com &gt;&gt; 'Class factory registration for &lt;1s&gt; failed')						expandMacrosWith: self name) ].	^aClassFactory</body><body package="Com- Ole">revokeClassFactory	" Revoke the registration of the class factory which has been registered with COM to create instances of the receiver. "	" while ordinarily we prefer not to clutter object implementatations with tracing support,		which in general is better handling through the non-intrusive interface tracing		facilities, class factory registration is such a fundamental operation that		in this case we add tracing to facilitate debugging application problems. "	| aCLSID aClassFactory |	self logIfTraceEnabled: 			[#NamedRegRevokeFactory &lt;&lt; #com 				&gt;&gt; 'Revoking registration of class factory for &lt;1s&gt; ( CLSID &lt;2p&gt; ) ...' 					expandMacrosWith: self name					with: self clsid].	(aCLSID := self clsid) isNil 		ifTrue: 			[| message |			message := #WarnNamedCantRegFactory &lt;&lt; #com 						&gt;&gt; 'Cannot register a class factory for class &lt;1s&gt; (no CLSID is defined).' 							expandMacrosWith: self name.			self logIfTraceEnabled: message.			COMDevelopmentWarning raiseSignal: message.			^self].	aClassFactory := COMSessionManager classFactoryForCLSID: aCLSID.	aClassFactory isNil 		ifTrue: 			[| message |			message := #NamedNoFactoryReg &lt;&lt; #com 						&gt;&gt; 'No class factory is currently registered for class &lt;1s&gt; ( CLSID &lt;2s&gt; ).' 							expandMacrosWith: self name							with: aCLSID asString.			self logIfTraceEnabled: message.			COMDevelopmentWarning raiseSignal: message.			^self].	aClassFactory revokeRegistration.	self logIfTraceEnabled: 			[#DoneRevokeRegFactory &lt;&lt; #com 				&gt;&gt; '...done revoking class factory registration']</body></methods><methods><class-id>External.COMObject class</class-id> <category>subclass-tracing</category><body package="Com- Ole">isRuntimeTraceEnabled	" Answer whether this is a runtime configuration with tracing enabled. "	^ImageConfiguration isDevelopment not and: [ self isTraceEnabled ]</body><body package="Com- Ole">isTraceEnabled	" Answer whether tracing is currently enabled for incoming function calls. "	^COMSessionManager isTraceEnabled		and: [ ( ( COMSessionManager traceManager isTraceTypeEnabled: #externalCallin )				or: [ COMSessionManager traceManager isTraceTypeEnabled: #internalCallin ] ) ]</body><body package="Com- Ole">isTraceEnabledForIID: anIID	" Answer whether tracing is currently enabled for incoming function calls on the interface identified by &lt;anIID&gt;. "	^COMSessionManager isTraceEnabled		and: [ ( ( COMSessionManager traceManager isTraceTypeEnabled: #externalCallin forIID: anIID )				or: [ COMSessionManager traceManager isTraceTypeEnabled: #internalCallin forIID: anIID ] ) ]</body><body package="Com- Ole">logCr	" Append an empty line to the COM trace log. The caller is responsible for ensuring that tracing is enabled. "	COMSessionManager traceManager logCr.</body><body package="Com- Ole">logIfTraceEnabled: traceEntry	" Append &lt;traceEntry&gt; to the COM trace log if tracing is currently enabled. "	self isTraceEnabled		ifTrue: [ self logTraceEntry: traceEntry ].</body><body package="Com- Ole">logIfTraceEnabled: traceEntry forIID: anIID	" Append &lt;traceEntry&gt; to the COM trace log if tracing is currently enabled for the interface identified by &lt;anIID&gt;. "	( self isTraceEnabledForIID: anIID )		ifTrue: [ self logTraceEntry: traceEntry ].</body><body package="Com- Ole">logTraceEntry: traceEntry	" Append the value of &lt;traceEntry&gt; to the COM trace log.  The &lt;traceEntry&gt; can be either a string or a block which returns a string.  The caller is responsible for ensuring that tracing is enabled. "	| aString |	aString := ( traceEntry isStringOrUserMessage		ifTrue: [ traceEntry ]		ifFalse: [ traceEntry value ] ) asString.	COMSessionManager traceManager log: aString.</body></methods><methods><class-id>External.COMObject class</class-id> <category>subclass-events</category><body package="Com- Ole">constructEventsTriggered	"Private - answer the collection of events that instances of the	receiver can trigger."	^super constructEventsTriggered		add: #released ;  " used by manufacturing class factory and to support server application termination policies "		yourself</body></methods><methods><class-id>External.COMObject class</class-id> <category>identity</category><body package="Com- Ole">clsid	" Answer the CLSID of the COM object class of instances of the receiver. "	^clsid</body><body package="Com- Ole">clsid: aGUID	" Set the CLSID of the COM object class of instances of the receiver to &lt;aGUID&gt;. "	clsid := aGUID.</body></methods><methods><class-id>External.COMObject class</class-id> <category>instance creation</category><body package="Com- Ole">forControllingUnknown: aControllingUnknown 	" Answer a new instance of the receiver for the aggregate object controlled by the IUnknown &lt;aControllingUnknown&gt;.  Answer nil if instances of the receiver do not support aggregation. "	self supportsAggregration ifFalse: [^nil].	" not a cooperative kind of guy "	aControllingUnknown iid = IID_IUnknown 		ifFalse: 			[" somewhat zealous check to detect programming errors "			COMDevelopmentWarning 				raiseSignal: (#WarnNamedAggNotIUnk &lt;&lt; #com 						&gt;&gt; 'Controlling unknown of aggregate is not an IUnknown: &lt;1p&gt;' 							expandMacrosWith: aControllingUnknown)].	^(super new)		controllingUnknown: aControllingUnknown;		initialize;		yourself</body><body package="Com- Ole">new	" Answer a new instance of the receiver. "	^super new initialize</body><body package="Com- Ole">newServerObject	" Answer a new instance of the receiver. "	^self new</body></methods><methods><class-id>External.COMObject class</class-id> <category>testing</category><body package="Com- Ole">supportsAggregration	" Answer whether instances of the receiver will participate as non-control objects in an aggregate by cooperating with the controlling unknown of the aggregate. "	^true</body></methods><methods><class-id>External.COMObject class</class-id> <category>registering</category><body package="Com- Ole">comRegistrationSpec	^ nil</body></methods><methods><class-id>External.COMObject class</class-id> <category>licensing support</category><body package="Com- Ole">canCreateWithoutLicense	"We can create instances without using a license if we are not in runtime but in development mode"	^ true</body><body package="Com- Ole">checkLicenseKey: aKey	COMError hresult: E_NOTIMPL</body><body package="Com- Ole">requestLicenseKey	COMError raiseSignal: E_NOTIMPL</body></methods><methods><class-id>External.COMEnumeratorObject</class-id> <category>subclass-accessing</category><body package="Com- Ole">bufferElementType	" Private - answer the C data type of the elements on which the receiver operates. "	^bufferElementType</body><body package="Com- Ole">bufferElementType: aCType	" Private - set the C data type of the elements on which the receiver operates. "	bufferElementType := aCType.</body><body package="Com- Ole">elements: aCollection	" Set the collection of elements being enumerated to &lt;aCollection&gt;. "	aCollection isNil		ifTrue: [ 			elements := nil.			^self ].	elements := aCollection asArray.	self initializePosition.</body><body package="Com- Ole">enumeratorIID: iid	" Private - set the IID of the enumerator interface for the receiver's element class. "	enumeratorIID := iid.</body><body package="Com- Ole">enumeratorInterface	" Answer the enumeration interface supported by the receiver.  Note that this is not a separately reference counted copy of the interface. "	iEnum isNil		ifTrue: [ iEnum := self createIEnum ].	^iEnum</body><body package="Com- Ole">getInterfaceForIID: iid	" Private - answer the interface identified by the GUID &lt;iid&gt;.   Answer nil if the requested interface is not supported by the receiver. "	iid = self enumeratorIID		ifTrue: [ ^self enumeratorInterface ].	^super getInterfaceForIID: iid</body><body package="Com- Ole">position	" Private - answer the current position of the receiver in its element collection. "	^currentIndex</body><body package="Com- Ole">position: anInteger	" Private - set the current position of the receiver in its element collection to &lt;anInteger&gt;. "	currentIndex := anInteger.</body></methods><methods><class-id>External.COMEnumeratorObject</class-id> <category>subclass-initializing</category><body package="Com- Ole">createIEnum	" Private - create an IEnum interface on the receiver. "	| anIEnum |	anIEnum := IEnum directBindingOn: self.	"Assert isEqual: anIEnum iid to: self enumeratorIID."	"Assert isEqual: anIEnum bufferElementType to: self bufferElementType."	^anIEnum</body><body package="Com- Ole">initializePosition	" Private - set the enumerator's position to the start of the collection. "	self position: 1.</body></methods><methods><class-id>External.COMEnumeratorObject</class-id> <category>accessing</category><body package="Com- Ole">elements	" Answer the collection of elements being enumerated. "	^elements</body><body package="Com- Ole">enumeratorIID	" Answer the IID of the enumerator interface for the receiver's element class. "	^enumeratorIID</body></methods><methods><class-id>External.COMEnumeratorObject</class-id> <category>subclass-operation</category><body package="Com- Ole">incrementPosition: count	" Private - increment the receiver's position by &lt;count&gt;. "	currentIndex := currentIndex + count.</body><body package="Com- Ole">packCurrentElementInto: lpElement	" Private - pack the element at the current index into the receiver into the element buffer at &lt;lpElement&gt;.  Answer whether successful. "	self subclassResponsibility.</body><body package="Com- Ole">packElementBuffer: elementBuffer count: count	" Private - pack the next &lt;count&gt; elements of the receiver's collection into the caller's &lt;elementBuffer&gt;.  Answer the number of elements supplied.  Answer nil if an expected error occurred and the operation has failed. "	| nElementsReturned lpBuffer lpElement |	"Assert isTrue: [ elementBuffer isPointer ]."	"Assert isTrue: [ elementBuffer type = CVoidType void pointerType pointerType ]."	lpBuffer := bufferElementType pointerType cast: elementBuffer asPointerParameter.	nElementsReturned := 0.	lpElement := lpBuffer copy.	count timesRepeat: [		self atEnd			ifTrue: [ ^nElementsReturned ].		( self packCurrentElementInto: lpElement )			ifFalse: [ ^nil ].  " perhaps somewhat obstinate, but hey, it's really a bug in the guy who constructed me "		nElementsReturned := nElementsReturned + 1.		self incrementPosition: 1 ].	^nElementsReturned</body></methods><methods><class-id>External.COMEnumeratorObject</class-id> <category>subclass-enumerating</category><body package="Com- Ole">allocatedInterfacesDo: aOneArgBlock	" Private - enumerate the interfaces supported by the receiver which have been allocated during its lifetime and evaluate &lt;aOneArgBlock&gt; with each. "	super allocatedInterfacesDo: aOneArgBlock.	iEnum notNil		ifTrue: [ aOneArgBlock value: iEnum ].</body></methods><methods><class-id>External.COMEnumeratorObject</class-id> <category>private-IEnum operations</category><body package="Com- Ole">Clone: resultReference	" Private - implement the IEnum::Clone function.  Answer the result code. "	" Create another enumerator that contains the same enumeration state as the current one. "	| anEnumerator |	anEnumerator := self class forIID: self enumeratorIID 		elements: self elements		bufferElementType: self bufferElementType.	anEnumerator position: self position.	resultReference value: anEnumerator enumeratorInterface.		"( anEnumerator queryInterface: anEnumerator enumeratorIID )."	^S_OK</body><body package="Com- Ole">Next: elementCount _: elementBuffer _: countReference	" Private - implement the IEnum::Next function.  Answer the result code. "	" Retrieve the next &lt;elementCount&gt; items in the enumeration sequence.		Store the retrieved elements into the &lt;elementBuffer&gt; array.		Store the number of elements actually retrieved into &lt;countReference&gt;.		Note the &lt;countReference&gt; can be nil if &lt;elementCount&gt; is 1. "	| nElementsReturned |	elementBuffer isNil		ifTrue: [ ^E_FAIL ].	currentIndex &gt; elements size		ifTrue: [			countReference notNil				ifTrue: [ countReference value: 0 ].			^S_FALSE ].	nElementsReturned := self packElementBuffer: elementBuffer count: elementCount.	nElementsReturned isNil		ifTrue: [ ^E_FAIL ].	countReference notNil		ifTrue: [ countReference value: nElementsReturned ].	^nElementsReturned = elementCount		ifTrue: [ S_OK ]		ifFalse: [ S_FALSE ]</body><body package="Com- Ole">Reset	" Private - implement the IEnum::Reset function.   Answer the result code. "	" Reset the enumeration sequence to the beginning. "	self initializePosition.	^S_OK</body><body package="Com- Ole">Skip: elementCount	" Private - implement the IEnum::Reset function.   Answer the result code. "	" Skip over the next specified number of elements in the enumeration sequence. "	self incrementPosition: elementCount.	^currentIndex &gt; elements size		ifTrue: [ S_FALSE ]  " skipped fewer than &lt;elementCount&gt; "		ifFalse: [ S_OK ]</body></methods><methods><class-id>External.COMEnumeratorObject</class-id> <category>subclass-releasing</category><body package="Com- Ole">resetAllocatedInterfaces	" Private - reset the references to the interfaces supported by the receiver. "	super resetAllocatedInterfaces.	iEnum := nil.</body></methods><methods><class-id>External.COMEnumeratorObject</class-id> <category>testing</category><body package="Com- Ole">atEnd	"Answer whether the position is greater than or equal to the limit."	^currentIndex &gt; elements size</body></methods><methods><class-id>External.COMEnumeratorObject class</class-id> <category>instance creation</category><body package="Com- Ole">forIID: anIID elements: anOrderedCollection	" Answer a new instance of the receiver which enumerates the homogeneous collection of interfaces or data structures specified by &lt;anIID&gt;. "	self subclassResponsibility</body><body package="Com- Ole">on: anOrderedCollection	" Answer a new instance of the receiver which enumerates the homogeneous collection of interfaces or data structures in &lt;anOrderedCollection&gt;. "	| anElement anIID |	anOrderedCollection size = 0		ifTrue: [ COMError raiseSignal: #ErrCantGetIIDFromEmpty &lt;&lt; #com &gt;&gt; 'cannot determine IID from empty collection' ].	anElement := anOrderedCollection first.	anIID := self getIIDForElement: anElement.	anIID isNil		ifTrue: [ COMError raiseSignal:  (#ErrNamedUnknownEnum &lt;&lt; #com &gt;&gt; 'unknown enumerator interface: &lt;1s&gt;' expandMacrosWith: (#nil &lt;&lt; #com &gt;&gt; 'nil')) ].	^self forIID: anIID elements: anOrderedCollection</body></methods><methods><class-id>External.COMEnumeratorObject class</class-id> <category>subclass-instance creation</category><body package="Com- Ole">checkElementValidity: elements	" Private - verify that the collection is a collection of valid elements, per COM enumeration model. "	elements do: [ :anElement |		anElement isNil			ifTrue: [ COMError raiseSignal: #ErrNoNilEnumElements &lt;&lt; #com &gt;&gt; 'nil enumeration elements not supported' ] ].</body><body package="Com- Ole">checkEnumeratorIID: anIID	" Private - verify that the IID is a supported enumeration interface. "	( IEnum supportsIID: anIID )		ifFalse: [ COMError raiseSignal: (#ErrNamedUnknownEnum &lt;&lt; #com &gt;&gt; 'unknown enumerator interface: &lt;1s&gt;' expandMacrosWith:  anIID asString) ].</body><body package="Com- Ole">forIID: anIID elements: anOrderedCollection bufferElementType: aCType	"Answer a new instance of the receiver which enumerates the homogeneous collection &lt;anOrderedCollection&gt; of elements into a buffer containing instances of the C data type &lt;aCType&gt;.  The enumerator interface IID is specified by the GUID &lt;anIID&gt;. "	self checkEnumeratorIID: anIID.	self checkElementValidity: anOrderedCollection.	^self new		enumeratorIID: anIID;		bufferElementType: aCType;		elements: anOrderedCollection;		yourself</body><body package="Com- Ole">getIIDForElement: anElement	" Private - answer the IID of the enumerator interface for a homogeneous collection of elements represented by &lt;anElement&gt;. "	self subclassResponsibility.</body></methods><methods><class-id>External.COMStringEnumerator</class-id> <category>subclass-operation</category><body package="Com- Ole">packCurrentElementInto: lpString	" Private - pack the element at the current index into the receiver into the element buffer at &lt;lpStruct&gt;.  Answer whether successful. "	| anElement aCOMAddress |	anElement := self elements at: currentIndex.	anElement isNil		ifTrue: [ ^false ].  " perhaps somewhat obstinate, but hey, it's really a bug in the guy who constructed me "	aCOMAddress := COMMemoryAddress copyUnicodeToExternalMemory: anElement.	lpString contents: aCOMAddress asPointerParameter.	aCOMAddress enforceInvalidation.  " relinquish ownership of the memory to the caller "	^true</body></methods><methods><class-id>External.COMStringEnumerator class</class-id> <category>instance creation</category><body package="Com- Ole">forIID: anIID elements: anOrderedCollection	" Answer a new instance of the receiver which enumerates a collection of strings. "	self checkEnumeratorIID: anIID.	^self forIID: IID_IEnumString		elements: anOrderedCollection		bufferElementType: COMExternalInterface unicodeStringPointerType		yourself</body><body package="Com- Ole">on: anOrderedCollection	" Answer a new instance of the receiver which enumerates the strings in &lt;anOrderedCollection&gt;. "	^self forIID: IID_IEnumString elements: anOrderedCollection</body></methods><methods><class-id>External.COMStringEnumerator class</class-id> <category>subclass-instance creation</category><body package="Com- Ole">checkElementValidity: elements	" Private - verify that the collection is a collection of homogeneous elements, per COM enumeration model. "	elements do: [ :anElement |		anElement isString			ifFalse: [ COMError raiseSignal: #ErrStringEnumItems &lt;&lt; #com &gt;&gt; 'enumeration elements must be strings'] ].</body><body package="Com- Ole">checkEnumeratorIID: anIID	" Private - verify that the IID is a supported enumeration interface. "	anIID = IID_IEnumString		ifFalse: [ COMError raiseSignal: (#ErrNamedEnumIIDStrings &lt;&lt; #com &gt;&gt;'incorrect enumerator IID for strings: &lt;1s&gt;' expandMacrosWith: anIID asString)].</body><body package="Com- Ole">getIIDForElement: anElement	" Private - answer the IID of the enumerator interface for a homogeneous collection of elements represented by &lt;anElement&gt;. "	^IEnum enumeratorIIDFor: String</body></methods><methods><class-id>External.IAdviseSink</class-id> <category>interface operations</category><body package="Com- Ole">onClose		" Notify the receiver that the calling object has closed (transitioned from		the running to the loaded state) and is shutting down.  		The notification is asynchronous. "	interface OnClose</body><body package="Com- Ole">onContentViewChange		" Notifier the receiver that the content view of the calling object has changed. "	self onViewChange: DVASPECT_CONTENT.</body><body package="Com- Ole">onDataChange: aFormatEtc storageMedium: aStgMedium		" Notify the receiver that the data in the calling object has changed.		The FORMATETC format information that the receiver provided		when this data advise was established via IDataObject::DAdvise is		provided in &lt;aFormatEtc&gt;. The changed data in the specified format		is provided in &lt;aStgMedium&gt;.  The notification is asynchronous.		The arguments belong to the caller and are valid only for the duration of this call. "	interface OnDataChange: aFormatEtc _: aStgMedium.</body><body package="Com- Ole">onIconViewChange		" Notifier the receiver that the icon view of the calling object has changed. "	self onViewChange: DVASPECT_ICON.</body><body package="Com- Ole">onRename: aMoniker		" Notify the receiver that the name of the calling object has changed to &lt;aMoniker&gt;.		The notification is asynchronous and the arguments belong to the caller. "	interface OnRename: aMoniker</body><body package="Com- Ole">onSave		" Notify the receiver that the calling object has been saved to persistent storage.		The notification is asynchronous. "	interface OnSave.</body><body package="Com- Ole">onViewChange: dwAspect		" Notify the receiver that the view of the calling object described by 		the DVASPECT value in &lt;dwAspect&gt; has changed.		The notification is asynchronous and the arguments belong to the caller. "	" In OLE 2.0.1, &lt;dwAspect&gt; must be a single value and &lt;lindex&gt; must be -1. "	interface OnViewChange: dwAspect _: -1.</body></methods><methods><class-id>External.IAdviseSink class</class-id> <category>subclass-tracing</category><body package="Com- Ole">canTraceAdaptorAssumeHRESULT	" Answer whether a trace adaptor configured on an instance of the receiver can assume that the functions in the interface represented by the receiver follow the standard COM convention of returning an HRESULT as the function return value, with OUT values returned via parameter values. "	^false</body></methods><methods><class-id>External.IAdviseSink class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IAdviseSink.	self updateAndRegister</body></methods><methods><class-id>External.IAdviseSink2</class-id> <category>interface operations</category><body package="Com- Ole">onLinkSourceChange: aMoniker		" Notify the receiver that the moniker of the calling link object 		has changed to &lt;aMoniker&gt;.  Used by an OLE link object to		notify its container of a moniker change when the link object		has received an OnRename notification from its link source object. 		The notification is asynchronous and the arguments belong to the caller."	interface OnLinkSrcChange: aMoniker.</body></methods><methods><class-id>External.IAdviseSink2 class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IAdviseSink2.	self updateAndRegister</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>private-initializing</category><body package="Com- Ole">on: anIStream 	" Private - Initialize the stream size and position.  Answer the receiver. "	self stream: anIStream.	position := 0.	self updateLimits.</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>character/binary</category><body package="Com- Ole">binary	"Set the receiver's buffer to be binary." 	encoding := #binary.</body><body package="Com- Ole">isBinary	"Answer whether the receiver's data is byte or character."	^encoding = #binary</body><body package="Com- Ole">isText	"Answer true if the receiver's data is character."	^self isBinary not</body><body package="Com- Ole">text	"Set the receiver's buffer to be character using platform encoding." 	encoding := #default.</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>accessing</category><body package="Com- Ole">contents	"Answer the contents of the COM stream over which the receiver is streaming."	| originalPosition contents |	originalPosition := self position.	self reset.	[	contents := self next: self size.	] ensure: [		self position: originalPosition ].	^contents</body><body package="Com- Ole">copyFrom: firstIndex to: lastIndex        "Answer the subcollection of the collection over         which the receiver is streaming, from firstIndex         to lastIndex."	| originalPosition count value |	originalPosition := self position.	self position: firstIndex - 1.	count := lastIndex - firstIndex + 1.	[ value := self next: count ]		ensure: [ self position: originalPosition ].	^value</body><body package="Com- Ole">next	"Answer the next object accessible by the receiver and advance the stream position. "	| elements |	elements := self next: 1.	^elements isNil		ifTrue: [ nil ]		ifFalse: [ elements at: 1 ]</body><body package="Com- Ole">next: anInteger	" Answer the next &lt;anInteger&gt; elements from the receiver. "	| nBytes buffer nBytesRead elements |	nBytes := anInteger * self bufferElementSizeInBytes.	buffer := self allocateBuffer: nBytes class: self bufferClass.	[	nBytesRead := self stream read: buffer count: nBytes.	elements := self getBufferContents: buffer		count: anInteger		nBytesRead: nBytesRead.	] ensure: [		self releaseBuffer: buffer ].	^elements</body><body package="Com- Ole">next: anInteger into: aSequenceableCollection startingAt: startIndex 	"Store the next &lt;anInteger&gt; elements of the receiver into &lt;aSequenceableCollection&gt; 	starting at &lt;startIndex&gt; in &lt;aSequenceableCollection&gt;.  Answer &lt;aSequenceableCollection&gt;."	| nBytes buffer nBytesRead |	anInteger &lt; 1		ifTrue: [ ^aSequenceableCollection ].	self atEnd		ifTrue: [			^Stream incompleteNextCountSignal raiseRequestWith: 0 ].	"future: support reading string encodings into non-byte character collections "	aSequenceableCollection class isBits		ifFalse: [ COMError raiseSignal: #ErrBeByte &lt;&lt; #com &gt;&gt;  'not a byte object'].	nBytes := anInteger * self bufferElementSizeInBytes.	buffer := ( aSequenceableCollection isFixedArgument		ifTrue: [ 			aSequenceableCollection sizeInBytes &lt; nBytes				ifTrue: [ COMError raiseSignal: #ErrDestBufferTooSmall &lt;&lt; #com &gt;&gt; 'destination buffer too small' ].			aSequenceableCollection ]		ifFalse: [ self allocateBuffer: nBytes class: self bufferClass ] ).	[	nBytesRead := self stream read: buffer count: nBytes.	nBytesRead ~= nBytes		ifTrue: [ COMError raiseSignal: #ErrReadPastStreamEnd &lt;&lt; #com &gt;&gt; 'Read beyond end of stream' ].	buffer ~~ aSequenceableCollection		ifTrue: [			buffer isExternalAddress				ifTrue: [    " have to special-case the pointer buffer handling, protocol not consistent "					buffer copyAt: 0						to: aSequenceableCollection						size: nBytes						startingAt: startIndex ]				ifFalse: [					self isBinary						ifTrue: [ 							aSequenceableCollection replaceBytesFrom: startIndex								to: ( startIndex + nBytes - 1 )								with: buffer								startingAt: 1 ]						ifFalse: [							aSequenceableCollection replaceFrom: startIndex								to: ( startIndex + anInteger - 1 )								with: buffer ] ].			].	] ensure: [		buffer ~~ aSequenceableCollection ifTrue: [ self releaseBuffer: buffer ] ].	^aSequenceableCollection</body><body package="Com- Ole">next: anInteger putAll: aSequenceableCollection startingAt: startIndex 	"Store the &lt;anInteger&gt; elements of &lt;aSequenceableCollection&gt; starting	at &lt;startIndex&gt; into the next &lt;anInteger&gt; elements of the receiver.	Answer &lt;aSequenceableCollection&gt;"	| nBytes buffer nBytesWritten |	"future: support storing string encodings from non-byte character collections "	aSequenceableCollection class isBits		ifFalse: [ COMError raiseSignal: #ErrBeByte &lt;&lt; #com &gt;&gt;  'not a byte object' ].	nBytes := anInteger * self bufferElementSizeInBytes.	buffer := self constructByteBufferOn: ( anInteger = aSequenceableCollection size		ifTrue: [  			aSequenceableCollection sizeInBytes &lt; nBytes				ifTrue: [ COMError raiseSignal: #ErrSourceBufferTooSmall &lt;&lt; #com &gt;&gt; 'source buffer too small' ].			aSequenceableCollection ]		ifFalse: [ aSequenceableCollection copyFrom: 1 to: anInteger ] ).  " not very efficient... "	[	nBytesWritten := self stream		write: buffer 		count: nBytes.	] ensure: [		buffer ~~ aSequenceableCollection ifTrue: [ self releaseBuffer: buffer ] ].	self updateLimits.	nBytesWritten = nBytes		ifFalse: [ COMError raiseSignal: #ErrWriteNotCompleted &lt;&lt; #com &gt;&gt; 'Write not completed' ].	^aSequenceableCollection</body><body package="Com- Ole">nextPut: anObject        "Write &lt;anObject&gt; to the receiver stream.         Answer &lt;anObject&gt;."	^self nextPutAll: ( self bufferClass with: anObject )</body><body package="Com- Ole">size	"Answer the size of the collection the receiver streams over. "	^readLimit</body><body package="Com- Ole">stream	" Answer the COM stream on which the receiver is operating. "	^stream</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>operations</category><body package="Com- Ole">commit	" Commit any changes to the contents of the storage element since it was last opened or committed to persistent storage. "	self stream commit.</body><body package="Com- Ole">flush	"Force all data written to the receiver to be recorded on disk."	self commit.</body><body package="Com- Ole">revert	" Discard any changes made to the contents of the storage element since it was last opened or committed to persistent storage. "	self stream revert.</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>positioning</category><body package="Com- Ole">position	"Answer the current receiver stream position."	^self stream position</body><body package="Com- Ole">position: anInteger	"Set the receiver stream position to &lt;anInteger&gt;. "	self stream position: anInteger.</body><body package="Com- Ole">reset	"Position the receiver stream to the beginning."	self stream reset.</body><body package="Com- Ole">setToEnd	"Set the position of the receiver stream to the end."	self stream setToEnd.</body><body package="Com- Ole">skip: anInteger	"Increment the position of the receiver by &lt;anInteger&gt;."	self stream skip: anInteger.</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>testing</category><body package="Com- Ole">atEnd	"Answer whether the position is greater than or equal to the limit."	^self position = self size</body><body package="Com- Ole">isEmpty	"Answer whether the receiver contains any elements."	^self size = 0</body><body package="Com- Ole">isReadable	"Answer whether the stream implements #next."	^true</body><body package="Com- Ole">isWritable	"Answer whether the stream implements #nextPut:."	^true</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>private-operation</category><body package="Com- Ole">allocateBuffer: count class: aBufferClass 	" Private - allocate a buffer to read the next &lt;count&gt; elements for a buffer of type &lt;aBufferClass&gt;.  Answer the buffer. "	aBufferClass == ByteArray 		ifTrue: 			[^self useFixedSpace 				ifTrue: [aBufferClass newInFixedSpace: count]				ifFalse: [(aBufferClass new: count) copyToHeap]].	aBufferClass == ByteString 		ifTrue: 			[^self useFixedSpace 				ifTrue: [ByteArray newInFixedSpace: count]				ifFalse: [(aBufferClass new: count) copyToHeap]].	"TBD: aBufferClass == TwoByteString ifTrue: [ ... allocate a Unicode transfer buffer ... ]. "	self error: #ErrUnsupportedBufferCls &lt;&lt; #com &gt;&gt; 'unsupported buffer class'</body><body package="Com- Ole">constructByteBufferOn: aByteObject 	" Private - answer a stable buffer from which &lt;aByteObject&gt; can be written. "	aByteObject class == ByteArray 		ifTrue: 			[^aByteObject isFixedArgument 				ifTrue: [aByteObject]				ifFalse: [^aByteObject copyToHeap]].	aByteObject isString 		ifTrue: [^aByteObject copyToHeapEncoding: self encoding].	self error: #ErrUnsupportedBufferCls &lt;&lt; #com &gt;&gt; 'unsupported buffer class'</body><body package="Com- Ole">getBufferContents: aBuffer count: count nBytesRead: nBytesRead 	" Private - answer the contents of &lt;aBuffer&gt;.   We wanted &lt;count&gt; elements, there were actually &lt;nBytesRead&gt; bytes brought back into the system. "	count = 0 ifTrue: [^nil].	self bufferClass == ByteArray 		ifTrue: 			["Assert isTrue: [ nBytesRead &lt;= count ]."			^aBuffer isPointer 				ifTrue: 					[| aByteArray |					aByteArray := ByteArray new: count.					aBuffer 						copyAt: 0						to: aByteArray						size: count						startingAt: 1.					aByteArray]				ifFalse: 					[count = nBytesRead 						ifTrue: [aBuffer]						ifFalse: [aBuffer copyFrom: 1 to: nBytesRead]]].	self bufferClass == ByteString 		ifTrue: 			[| aString |			aString := aBuffer isPointer 						ifTrue: [aBuffer copyCStringFromHeap]						ifFalse: [aBuffer asStringEncoding: #default].			^aString size = count 				ifTrue: [aString]				ifFalse: [aString copyFrom: 1 to: (count min: aString size)	"???"]].	"TBD: aBufferClass == TwoByteString ifTrue: [ ... extract from a Unicode transfer buffer ... ]. "	self error: #ErrUnsupportedBufferCls &lt;&lt; #com &gt;&gt; 'unsupported buffer class'</body><body package="Com- Ole">releaseBuffer: aBuffer	" Private - release the buffer storage. "	aBuffer "isPointer" isExternalAddress		ifTrue: [ aBuffer free ].</body><body package="Com- Ole">updateLimits	" Update the state information after the stream has been modified. "	readLimit := self stream size.</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>private-accessing</category><body package="Com- Ole">bufferClass	" Private - answer the class to use for allocating a read buffer. "	encoding = #binary ifTrue: [^ByteArray].	encoding = #default ifTrue: [^ByteString].	"?? ^String defaultPlatformClass ??"	"TBD: encoding = #UCS_2 ifTrue: [ ^TwoByteString ]. "	self error: #ErrUnknownEncoding &lt;&lt; #com &gt;&gt; 'unknown stream encoding'</body><body package="Com- Ole">bufferElementSizeInBytes	" Private - answer the size in bytes of an element in a transfer buffer. "	encoding = #binary ifTrue: [^1].	encoding = #default ifTrue: [^1].	"TBD: encoding = #UCS_2 ifTrue: [ ^2 ]. "	self error: #ErrUnknownEncoding &lt;&lt; #com &gt;&gt; 'unknown stream encoding'</body><body package="Com- Ole">contentsSpecies	^self bufferClass</body><body package="Com- Ole">encoding	" Private - answer the encoding type specifying the form in which data is transferred. "	^encoding</body><body package="Com- Ole">stream: anIStream	" Set the COM stream element on which the receiver is operating to &lt;anIStream&gt;. "	stream := anIStream.</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>private-testing</category><body package="Com- Ole">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	"^Win32BufferManager useFixedSpace"	^false</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>converting</category><body package="Com- Ole">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."    ^self stream asPointerParameter</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>private interface operations</category><body package="Com- Ole">privateRelease	" Release the receiver and the underlying COM stream. "	self stream isNil		ifTrue: [ ^self ].	self stream enforceRelease.	position := readLimit := writeLimit := 0.	super release.</body></methods><methods><class-id>OS.COMReadWriteStream</class-id> <category>releasing</category><body package="Com- Ole">release	" Release the receiver and the underlying COM stream. "	self stream isNil		ifTrue: [ ^self ].	self stream: nil.	position := readLimit := writeLimit := 0.	super release.</body></methods><methods><class-id>OS.COMReadWriteStream class</class-id> <category>instance creation</category><body package="Com- Ole">byteStreamOn: anIStream	"Answer a new instance of the receiver on &lt;anIStream&gt; which treats its contents as a byte stream."	^( super on: anIStream )		binary;		yourself</body><body package="Com- Ole">characterStreamOn: anIStream	"Answer a new instance of the receiver on &lt;anIStream&gt; which treats its contents as a character stream."	^( super on: anIStream )		text;		yourself</body><body package="Com- Ole">on: anIStream	"Answer a new instance of the receiver on &lt;anIStream&gt;."	^self characterStreamOn: anIStream</body></methods><methods><class-id>External.COM_STATDATA</class-id> <category>accessing</category><body package="Com- Ole">adviseSink	" Answer the IAdviseSink interface. "	 ^ self interfaceMemberAt: #pAdvSink type: IAdviseSink.</body><body package="Com- Ole">formatEtc	" Answer the FORMATETC structure. "	^self structureMemberAt: #formatetc</body></methods><methods><class-id>External.COM_STATDATA</class-id> <category>subclass-releasing</category><body package="Com- Ole">releaseAdviseSink	" Private - release the advise sink pointer, if any. "	self internalAdviseSink ifNotNil: [:itf | itf enforceRelease]</body><body package="Com- Ole">releaseResources	" Private - release resources owned by the receiver. "	self releaseAdviseSink.	super releaseResources</body></methods><methods><class-id>External.COM_STATDATA</class-id> <category>private</category><body package="Com- Ole">internalAdviseSink	" Answer the IAdviseSink interface. "	 ^ self internalInterfaceMemberAt: #pAdvSink type: IAdviseSink.</body></methods><methods><class-id>External.COM_STATDATA</class-id> <category>converting</category><body package="Com- Ole">asSeparateStructureParameter	"Answer the receiver in a form suitable for passing as a structure parameter to an external function call."	self internalAdviseSink enforceAddRef.	^super asSeparateStructureParameter</body></methods><methods><class-id>External.COM_STATDATA class</class-id> <category>accessing</category><body package="Com- Ole">enumeratorIID	" Answer the IID of the interface which enumerates collections containing instances of the receiver. "	^IID_IEnumSTATDATA</body></methods><methods><class-id>External.COM_STATDATA class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self structureName: #STATDATA.	self updateAndRegister</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>private-accessing</category><body package="Com- Ole">adaptorBinding	" Private - answer the real adaptor binding for the receiver.  Ignore other guys, such as any trace adaptors which are interposed in the callin chain. "	| anAdaptor |	anAdaptor := self implementor.	[ anAdaptor isCOMInterfaceAdaptor and: [ anAdaptor isCOMTraceAdaptor ] ]		whileTrue: [ anAdaptor := anAdaptor implementor ].	^anAdaptor isCOMInterfaceAdaptor		ifTrue: [ anAdaptor ]		ifFalse: [ nil ]</body><body package="Com- Ole">callinInterfaceIndex	" Private - answer the index in the external object table of the receiver (the interface implementation itself).  This value is stored in the receiver's object state in external memory to allow the virtual machine callin processing to send a function callin invocation message to the receiver. "	^self interfacePointer ifNotNil: [:pointer | pointer memberAt: #entry]</body><body package="Com- Ole">entryPointIndexOfName: anEntryPointName	" Private - answer the index in the VTable of the entry point named &lt;anEntryPointName&gt;. "	 ^( self vtableDescription collect: [ :eptDescr | eptDescr name ] )		indexOf: anEntryPointName asString ifAbsent: [ nil ]</body><body package="Com- Ole">entryPointNamed: anEntryPointName	" Private - answer the entry point description of the entry point named &lt;anEntryPointName&gt;. "	^self vtableDescription detect: [ :eptDescr | eptDescr name = anEntryPointName asString ]		ifNone: [ nil ]</body><body package="Com- Ole">externalAddress	" Private - answer the address in external memory of the receiver's interface data structures (ptr-ptr-VTable).   Allocate the interface structures if not already created. "	self interfaceAddress == nil 		ifTrue: [ self allocateExternalResources ].	^self interfaceAddress</body><body package="Com- Ole">externalDataPointer	" Private - answer a pointer which references the receiver's interface data structures (ptr-ptr-VTable) in external memory. "	^self interfacePointer memberAt: #vtablePointer</body><body package="Com- Ole">implementor: anObject	" Private - set the immediate implementor of the interface to &lt;anObject&gt;. "	implementor == self 		ifTrue: [ COMError raiseSignal: #ErrCantDelegateSelf &lt;&lt; #com &gt;&gt; 'cannot delegate to self'  ].	implementor := anObject.</body><body package="Com- Ole">interfaceAddress	" Private - answer the address in external memory of the receiver's interface data structures (ptr-ptr-VTable). "	^self interfacePointer ifNotNil: [:pointer | pointer asInteger]</body><body package="Com- Ole">interfaceAddress: anAddress	" Private - set the address in external memory of the receiver's interface data structures (ptr-ptr-VTable). "	"Assert isTrue: [ anAddress isNil or: [ anAddress isInteger ] ]."	^self interfacePointer: (anAddress				ifNotNil: 					[COMPlatformProvider current interfaceType pointerType						newOfAddress: anAddress])</body><body package="Com- Ole">traceAdaptor	" Private - answer the trace adaptor configured on the receiver.  Answer nil if none. "	^( implementor isCOMInterfaceAdaptor and: [ implementor isCOMTraceAdaptor ] )		ifTrue: [ implementor ]		ifFalse: [ nil ]</body><body package="Com- Ole">vtable	"Private - answer the VTable that is shared by all instances of the receiver's class.  This message is added solely as an aid in using inspectors."	^self class vtable</body><body package="Com- Ole">vtableAddress	"Private - Answer the address in external memory at which the function dispatch VTable referenced by the receiver is stored."	^self interfacePointer		ifNotNil: [:pointer | pointer memberAt: #vtablePointer]</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-error handling</category><body package="Com- Ole">checkHresult: hresult	" Signal an error if &lt;hresult&gt; is an error code. "	(hresult failed)		ifTrue: [ COMError hresult: hresult ].	^hresult</body><body package="Com- Ole">checkHresult: hresult allow: acceptableValue	" Signal an error if &lt;hresult&gt; is an error code other than &lt;acceptableValue&gt;. "	^hresult = acceptableValue		ifTrue: [ hresult ]		ifFalse: [ self checkHresult: hresult ]</body><body package="Com- Ole">checkHresult: hresult allow: acceptableValue or: anotherAcceptableValue	" Signal an error if &lt;hresult&gt; is an error code other than &lt;acceptableValue&gt;. "	^( hresult = acceptableValue or: [ hresult = anotherAcceptableValue ] )		ifTrue: [ hresult ]		ifFalse: [ self checkHresult: hresult ]</body><body package="Com- Ole">checkHresult: hresult allowAny: listOfAcceptableValues	" Signal an error if &lt;hresult&gt; is an error code other than &lt;acceptableValue&gt;. "	^( listOfAcceptableValues includes: hresult )		ifTrue: [ hresult ]		ifFalse: [ self checkHresult: hresult ]</body><body package="Com- Ole">hresultForException: anException	" Private - answer the HRESULT to return when &lt;anException&gt; has been raised 	during an interface function callin invocation. "	" ^( ex isKindOf: COMError ) ""	^( anException isNGException and: [ anException originator isKindOf: COMError ] ) "	^( COMError handles: anException )		ifTrue: [ anException hresult ]		ifFalse: [ E_UNEXPECTED ]</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-argument utilities</category><body package="Com- Ole">addressResultAtAddress: aPointer put: anAddress	" Private - store the address output argument value &lt;anAddress&gt; into the caller-provided memory location at &lt;aPointer&gt;. The callee is responsible for providing an address which has been allocated using the COM task memory allocator for return to a caller. "	anAddress isNil ifTrue: [ ^self ].	aPointer contents: anAddress asPointerParameter.	anAddress enforceInvalidation.  " ownership of this memory transfers to the caller "</body><body package="Com- Ole">clearPointerResultValueAtAddress: aPointer	" Private - store a NULL pointer into the address buffer at &lt;aPointer&gt;. "	aPointer isValid		ifFalse: [ ^self ].   " NOP if client didn't provide result buffer "	aPointer contents: NULL.</body><body package="Com- Ole">clearResultBufferAtAddress: aPointer	" Private - clear the contents of the OUT value buffer provided by the caller at &lt;aPointer&gt;. "	| bufferElementType nBytes |	aPointer isValid ifFalse: [^self].	" NOP if client didn't provida result buffer "	bufferElementType := COMExternalInterface				getRealTypeOf: aPointer type referentType.	bufferElementType isPointer		ifTrue: 			[aPointer contents: NULL.			^self].	bufferElementType isBasic		ifTrue: 			[" scalar "			bufferElementType isBoolean				ifTrue: [aPointer contents: false]				ifFalse: [aPointer contents: 0]].	" bufferElementType isComposite or unknown "	nBytes := bufferElementType sizeof.	aPointer		copyAt: 0		from: (ByteArray new: nBytes)		size: nBytes		startingAt: 1</body><body package="Com- Ole">clearScalarResultValueAtAddress: aPointer	" Private - store zero into the scalar output argument at &lt;aPointer&gt;. "	aPointer isValid		ifFalse: [ ^self ].   " NOP if client didn't provide result buffer "	aPointer contents: 0.</body><body package="Com- Ole">clearStructureResultAtAddress: lpStruct	" Private - clear the contents of the host structure identified by &lt;aStructureSpecification&gt; at &lt;anExternalAddress&gt;. "	| nBytes |	lpStruct isValid		ifFalse: [ ^self ].   " NOP if client didn't provide result buffer "	nBytes := lpStruct type referentType sizeof.	lpStruct copyAt: 0		from: ( ByteArray new: nBytes )		size: nBytes		startingAt: 1.</body><body package="Com- Ole">getArrayOfStrings: count fromUnicodeArray: lplpWSTR	" Private - answer an Array of size &lt;count&gt; filled with Strings extracted from the Unicode string array &lt;lplpWstr&gt;. "	| lpUnicodeString nameList |	nameList := Array new: count.	lpUnicodeString := lplpWSTR copy.	1 to: count do:		[ :index |		nameList at: index 			put: ( COMExternalInterface stringFromUnicodePointer: lpUnicodeString contents ).		lpUnicodeString increment ].	^nameList</body><body package="Com- Ole">guidAtAddress: aPointer	" Private - answer the GUID at address &lt;aPointer&gt;. "	aPointer isValid		ifFalse: [ ^nil ].	^GUID fromPointer: aPointer</body><body package="Com- Ole">guidFromStack: aCComposite	"Return a GUID which is passed as byval argument on stack"	^GUID fromBytes: aCComposite datum asByteArray</body><body package="Com- Ole">guidPointerResultAtAddress: aPointer put: aValue	"Put a GUID into the GUID ** buffer at aPointer.	 Since GUIDs exist in fixed space but memory needs to be transferred, we need to make sure it is 	 copied to heap"	aPointer isValid ifFalse: [^nil].	aPointer contents: (aValue ifNotNil: [aValue asByteArray copyToHeap])</body><body package="Com- Ole">interfaceAtAddress: aPointer type: anInterfaceSpecification	" Private - answer the interface argument at address &lt;aPointer&gt; "	| anInterfaceClass |	aPointer isValid		ifFalse: [ ^nil ].	anInterfaceClass := ( ( anInterfaceSpecification "isClass" isKindOf: Class )		ifTrue: [ anInterfaceSpecification ]		ifFalse: [ COMInterface classForIID: anInterfaceSpecification ] ).    ^ (anInterfaceClass interfacePointerClass newParameterAtAddress: aPointer) asInterfaceReference</body><body package="Com- Ole">interfaceResultAtAddress: aPointer put: anInterface	" Private - store the interface output argument value &lt;anInterface&gt; into the caller-provided memory location at &lt;aPointer&gt;.	  The implementation will AddRef() on the Interface"	anInterface isNil ifTrue: [ ^self ].	anInterface storeSelfInPointer: aPointer.</body><body package="Com- Ole">rectangleResultAtAddress: lpRect put: aRectangle        " Private - store the Rectangle output argument value &lt;aRectangle&gt;        into the caller-provided memory location at &lt;aPointer&gt;. "	aRectangle isNil ifTrue: [ ^self ].	lpRect		memberAt: #left put: aRectangle left;		memberAt: #top put: aRectangle top;		memberAt: #right put: aRectangle right;		memberAt: #bottom put: aRectangle bottom.</body><body package="Com- Ole">scalarResultAtAddress: aPointer put: aValue	" Private - store the scalar output argument value &lt;aValue&gt; into the caller-provided memory location addressed at &lt;aPointer&gt;. "	aValue isNil ifTrue: [ ^self ].  " assume NULL stored at function callback entry to clear the buffer "	aPointer contents: aValue.</body><body package="Com- Ole">stringAtAddress: anExternalAddress		" Private - answer a String containing the characters at address &lt;anExternalAddress&gt;. 		The string pointer references the Unicode byte encoding of the string. "	anExternalAddress isValid		ifFalse: [ ^nil ].	^COMExternalInterface stringFromUnicodePointer: anExternalAddress asPointer</body><body package="Com- Ole">stringResultAtAddress: ppszResult put: aString	" Private - store the String output argument value &lt;aString&gt; in memory obtained from the COM task allocator, in Unicode byte encoding, and store the address of the returned string into the caller-provided memory location at &lt;ppszResult&gt;. "	" This service is used for OUT arguments of the form 'LPOLESTR *ppszFoo' "	| aCOMMemoryAddress |	aString isNil		ifTrue: [ ^self ].	aCOMMemoryAddress := COMMemoryAddress copyUnicodeToExternalMemory: aString.	ppszResult contents: aCOMMemoryAddress asPointerParameter.	aCOMMemoryAddress enforceInvalidation.</body><body package="Com- Ole">structureAtAddress: aPointer	" Private - answer the structure argument value at &lt;aPointer&gt;. "	| structureName |	aPointer isValid		ifFalse: [ ^nil ].	structureName := aPointer type referentType name.	structureName = #VARIANT ifTrue: [ structureName := #VARIANTARG ].	^COMStructure createStructureNamed: structureName 		atAddress: aPointer</body><body package="Com- Ole">structureFrom: aPointerOrComposite	" Private - answer the structure argument value at &lt;aPointer&gt;. "	aPointerOrComposite type isPointer		ifTrue: [^self structureAtAddress: aPointerOrComposite].	"Code generated with resolution 106104 will require this code to be present. 	 COM 8.3+ will generate different code"	aPointerOrComposite type baseType = COMExternalInterface current _GUID		ifTrue: [^GUID fromBytes: aPointerOrComposite datum asByteArray].	^(COMStructure classForStructureNamed: aPointerOrComposite type name)		temporaryOn: aPointerOrComposite</body><body package="Com- Ole">structureResultAtAddress: lpStruct put: aStructure 	" Private - store the structure output argument value &lt;aStructure&gt; into the caller-provided memory location at &lt;lpStruct&gt;. "	| rawStructure structureBytes nBytes |	aStructure isNil ifTrue: [^self].	rawStructure := aStructure asStructureParameter.	"Assert isTrue: [ rawStructure type isComposite ]."	structureBytes := rawStructure isPointer 				ifTrue: [rawStructure contents datum]				ifFalse: [rawStructure datum].	structureBytes class isBits 		ifFalse: 			[self error: #ErrUnknownStrucSize &lt;&lt; #com &gt;&gt; 'unknown structure size'].	nBytes := structureBytes sizeInBytes.	nBytes = lpStruct type referentType sizeof 		ifFalse: 			[COMDevelopmentWarning 				raiseSignal: (#ErrNamedMixedStruct &lt;&lt; #com 						&gt;&gt; 'Structure result size mismatch in &lt;1p&gt; (result value &lt;2p&gt; has different size than caller''s structure buffer &lt;3p&gt;). Result value not stored!!' 							expandMacrosWith: self							with: aStructure							with: lpStruct).			^nil].	lpStruct 		copyAt: 0		from: structureBytes		size: nBytes		startingAt: 1.	"Release the structure for safety reasons - referenced resources has been transferred to the result address. #Structure&gt;release would try 	 to release resources although it does not own them any more"	(aStructure isKindOf: ExternalStructure) ifTrue: [ aStructure releaseStructure ].</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-exception handlers</category><body package="Com- Ole">exceptionHandlerForHRESULTReturnValue: callerType	" Answer the error handler block to use when an exception occurs during a function invocation.  An HRESULT value which describes the exception will be returned if an exception occurs. "	" For correct operation in COM, stack unwinding must not cross a function invocation boundary, which occurs at each external callin point.  The callin exception handler translates the error to an appropriate HRESULT status code and returns to the caller.  In addition, the error handler provides information to allow the error to be diagnosed. "	^[ :ex |		self reportCallinError: ex.		ex return: ( self hresultForException: ex ) ]</body><body package="Com- Ole">exceptionHandlerForNilReturnValue: callerType	" Answer the error handler block to use when an exception occurs during a function invocation.  The value nil will be returned if an exception occurs. "	^self exceptionHandlerForUnspecifiedReturnValue: callerType callerErrorValue: nil</body><body package="Com- Ole">exceptionHandlerForUnspecifiedReturnValue: callerType callerErrorValue: errorReturnValue	" Answer the error handler block to use when an exception occurs during a function invocation.  The &lt;errorReturnValue&gt; will be returned if an exception occurs. "	" For correct operation in COM, stack unwinding must not cross a function invocation boundary, which occurs at each external callin point.  The callin exception handler translates the error to an appropriate HRESULT status code and returns to the caller.  In addition, the error handler provides information to allow the error to be diagnosed. "	^[ :ex |		self reportCallinError: ex.		ex return: errorReturnValue ]</body><body package="Com- Ole">exceptionHandlerForZeroReturnValue: callerType    " Answer the error handler block to use when an exception occurs during a function invocation.  The value 0 will be returned if an exception occurs. "    ^self exceptionHandlerForUnspecifiedReturnValue: callerType callerErrorValue: 0</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>private-copying</category><body package="Com- Ole">copyInterfaceBinding	" Private - answer a copy of the receiver interface binding.  This is used carefully when copying an interface reference. "	^self</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>accessing</category><body package="Com- Ole">actualImplementor	" Private - answer the immediate implementor of the interface. "	^implementor actualImplementor</body><body package="Com- Ole">dispatchSelectors	" Answer the message selectors of the receiver's interface function dispatch bindings which are used to dispatch the corresponding VTable interface function selector to the implementing object. "	| myAdaptor |	( myAdaptor := self functionAdaptor ) notNil		ifTrue: [ myAdaptor dispatchSelectors ].  " configurable binding using an adaptor "	^self class vtableSelectors   " standard binding directly on the object "</body><body package="Com- Ole">functionAdaptor	" Answer the interface function adaptor which is configured for the receiver.  Answer nil if this is a direct binding of the interface to the real implementor. "	^implementor notNil		ifTrue: [ self adaptorBinding ]		ifFalse: [ nil ]</body><body package="Com- Ole">implementingObject	" Answer the object that implements the interface.  Ignore any adaptors which have been configured to customize the interface binding. "	| anObject |	anObject := self implementor ifNil: [ ^ nil ].	[ anObject isCOMInterfaceAdaptor ]		whileTrue: [ anObject := anObject implementor ].	^anObject</body><body package="Com- Ole">implementor	" Answer the object that implements the interface functions.  This is the immediate implementor and may be an adaptor configured to customize the interface binding on behalf of the object which really implements the interface functions. "	^implementor</body><body package="Com- Ole">interfacePointer	^interfacePointer</body><body package="Com- Ole">interfacePointer: anObject	interfacePointer := anObject.	interfacePointer isNil		ifTrue: [self doesNotNeedFinalization]		ifFalse: [self needsFinalization]</body><body package="Com- Ole">reportCallinError: anException 	" Private - an exception has occurred during the callin invocation of a VTable function.  Report the error so that the problem can be diagnosed. "	"Don't report terminate exceptions - this may open another debugger, which might be terminated, which again raises this exception, 	 which may open another debugger, which may be terminated to raise this exception ..."	| ex |	(TerminateException handles: anException) ifTrue: [anException return].	ex := anException copy 				messageText: (#comCallIn &lt;&lt; #com &gt;&gt; 'COM Call In:') asString , ' ' 						, anException description.	ImageConfiguration errorNotifierClass notify: ex		context: anException initialContext</body><body package="Com- Ole">rootExceptions	" Answer the exceptions which should be handled by a function invocation. "	^Error, TerminateException</body><body package="Com- Ole">vtableDescription		" Answer an array of entry point descriptions, in VTable order,		of the receiver's callin VTable functions. "	^self class vtableDescription</body><body package="Com- Ole">vtableSize		" Answer the number of interface function entry points		defined in the receiver's callin VTable functions. "	^self class vtable size</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-tracing</category><body package="Com- Ole">isExternalCallinTracingEnabled	" Answer whether external function invocation tracing is currently enabled for the receiver. "	^self traceAdaptor notNil		and: [ self isTraceTypeEnabled: #externalCallin ]</body><body package="Com- Ole">isInterfaceFunctionSelector: functionSelector	" Private - answer whether &lt;aSelector&gt; is an interface function selector of the receiver. "	^self class vtableSelectors includes: functionSelector</body><body package="Com- Ole">reportExternalFunctionEntry	" Report entry from an external caller to the interface function . "	^Plugins		performPluginNamed: Plugins reportExternalFunctionEntryKey		with: self		ifAbsent: []</body><body package="Com- Ole">reportExternalFunctionInvalidArgExit	" Private - report an invalid argument value to the COM trace log if &lt;aValue&gt; is not valid.  The caller is responsible for ensuring that tracing is enabled. "	Plugins		performPluginNamed: Plugins reportExternalFunctionInvalidArgExitKey		with: self		ifAbsent: []</body><body package="Com- Ole">reportIfInvalidExternalArg: aValue name: argName	" Private - report an invalid argument value to the COM trace log if &lt;aValue&gt; is not valid.  The caller is responsible for ensuring that tracing is enabled. "	aValue isValid		ifFalse: [self reportInvalidExternalArg: aValue name: argName]</body><body package="Com- Ole">reportInvalidExternalArg: aValue name: argName	^Plugins		performPluginNamed: Plugins reportInvalidExternalArgKey		with: self		with: aValue		with: argName		ifAbsent: []</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>converting</category><body package="Com- Ole">asInteger	" Answer the integer value which is the address of the receiver's VTable pointer in external memory. "	^self interfacePointer isNil		ifTrue: [0]		ifFalse: [self interfacePointer asInteger]</body><body package="Com- Ole">asInterfacePointer	" Answer an interface pointer for the receiver's VTable in external memory. "	| ifPtrClass |	ifPtrClass := self class interfacePointerClass ifNil: [IAnonymousPointer].	"Call AddRef directly on self instead on the interface pointer. The result will be the same. 	 We don't need to go through the COM API"	self dispatchAddRef.	^(ifPtrClass newResultInterfacePointerAtAddress: self externalAddress)		iid: self iid;		yourself</body><body package="Com- Ole">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	^self asInterfacePointer asPointerParameter</body><body package="Com- Ole">asSeparateInterfacePointer	^ self asInterfacePointer</body><body package="Com- Ole">dispatchAddRef	"this method is implemented by the only subclass IUnknownImplementation. Do nothing here"</body><body package="Com- Ole">storeSelfInPointer: aPointer 	aPointer contents: self externalAddress.	self dispatchAddRef.</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>testing</category><body package="Com- Ole">hasExternalResources	" Answer whether the receiver has valid external memory associated with it. "	^self interfaceAddress notNil</body><body package="Com- Ole">isAdaptorBinding	" Answer whether the receiver is an adaptor binding which allows the interface function bindings on the implementing object to be configured to non-standard protocol mappings. "	^self functionAdaptor notNil</body><body package="Com- Ole">isCOMInterfaceImplementation	" Answer whether the receiver is a COM interface implemented in this Smalltalk image. "	^true</body><body package="Com- Ole">isMTAObject	"MTA Servers not supported"	^ false</body><body package="Com- Ole">isReferencedBy: anInterfacePointer	"answer whether the parameter is a reference to the receiver"	^self interfaceAddress = anInterfacePointer asInteger</body><body package="Com- Ole">isSTAObject	^ true</body><body package="Com- Ole">isValid	"Answer whether the receiver is a valid interface."	^implementor notNil</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>private-session management</category><body package="Com- Ole">shutdownImage	"Private - The image session is being shut down.  All allocated interfaces should have already been released at this point; cannot release now because memory allocators and OLEDLL are closed. "	self hasExternalResources 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#ErrNamedUnreleasedIntExit &lt;&lt; #com 						&gt;&gt; 'Unreleased COM interface impl found at image exit: &lt;1p&gt;' 							expandMacrosWith: self)]</body><body package="Com- Ole">startupImage	"Private - The image session is being started.  Invalidate the receiver, since any external memory referenced in a previous session is no longer valid."	self resetResources.</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>private-stack accessing</category><body package="Com- Ole">functionSelectorFromContext: aMethodContext	" Private - answer the interface function selector for the invocation represented by &lt;aMethodContext&gt;. "	| callBackSelector |	callBackSelector := aMethodContext selector.	"Assert isTrue: [ ( callBackSelector copyFrom: 1 to: ( 'invoke' size min: callBackSelector size ) ) = 'invoke' ]."	"Assert isTrue: [ callBackSelector numArgs &gt; 0 ]."  " there's always a This argument from the OE callback "	^( callBackSelector copyFrom: 'invoke' size + 1		to: ( callBackSelector numArgs = 1			ifTrue: [ callBackSelector size - 1 ]  " unary interface function "			ifFalse: [ callBackSelector size - 2 ] )		) asSymbol</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>comparing</category><body package="Com- Ole">= anObject	" Answer whether the receiver and &lt;anObject&gt; represent the same interface. "	^anObject isCOMInterface 		and: [ self iid = anObject iid		and: [ self interfaceEqual: anObject interfaceBinding ] ]</body><body package="Com- Ole">hash	"Answer the integer hash value of the receiver."Tools.Note ISSUE.  " This is undoubtedly wrong, review vs. #= and fix [DL 24-Apr-97] "	^self iid hash bitXor: self implementingObject hash</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>private-finalizing</category><body package="Com- Ole">finalizationRegistry	"Private - Answer the registry to be used for finalizing instances of the receiver."	^COMSessionManager allocatedInterfacesRegistry</body><body package="Com- Ole">finalize	"The receiver is no longer referenced by any object in the system and is about to be destroyed.  Free any external resources owned by the receiver. "	self releaseResources</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>validating</category><body package="Com- Ole">validateDispatchHandlers	" Validate the registered interface function dispatch handlers.  Ensure as far as can be determined that the handlers are consistent with the function for which they are registered.  Display a warning message for any problems that are found. "	| myAdaptor aSelector aHandler |	implementor isNil 		ifTrue: [self error: #ErrNotLiveInterface &lt;&lt; #com &gt;&gt; 'not a live interface'].	myAdaptor := self functionAdaptor.	self vtableDescription do: 			[:eptDescription | 			aSelector := eptDescription selector.			aHandler := myAdaptor notNil 						ifTrue: [myAdaptor actionForFunctionSelector: aSelector]						ifFalse: [MessageSend forReceiver: self implementor selector: aSelector].			aHandler isNil 				ifTrue: 					[MessageBox 						warning: ((#x1sHasNoHandler &lt;&lt; #com &gt;&gt; '&lt;1s&gt; has no handler registered for the &lt;2s&gt; function.')							expandMacrosWith: self class name							with: eptDescription name)]				ifFalse: 					[(aHandler isKindOf: MessageSend) 						ifTrue: 							[self class 								validateSupportFor: aHandler selector								by: aHandler receiver								for: eptDescription]	"isMessage"]]</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>printing</category><body package="Com- Ole">printHexAddressOn: aStream	" Append a text description of the receiver's COM external memory address to &lt;aStream&gt; "	aStream nextPut: ${.	self hasExternalResources		ifTrue: 			[self interfaceAddress				printOn: aStream				paddedWith: $0				to: 8				base: 16]		ifFalse: [aStream nextPutAll: 'unallocated'].	aStream nextPut: $}</body><body package="Com- Ole">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	aStream space.	self printHexAddressOn: aStream.</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>initialize-release</category><body package="Com- Ole">initialize</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>releasing</category><body package="Com- Ole">invalidate	" Set the receiver to be invalid. "	self callIndicatesChangeNeeded.</body><body package="Com- Ole">privateInvalidate	" Set the receiver to be invalid. "	self resetResources.</body><body package="Com- Ole">releaseResources	"Private - Release all external resources owned by the receiver. 	 This method should not be called by third-party-code as it interfers with COM finalization."	| index |	self interfacePointer		ifNil: [self resetResources]		ifNotNil: 			[:pointer |			index := self callinInterfaceIndex.			self resetResources.			pointer free.			"must be done before ExportedObjectsTable operation - otherwise garbage collection may re-invoke this code before resources have been released"			ExportedObjectsTable removeObjectAt: index]</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>subclass-releasing</category><body package="Com- Ole">resetResources	" Private - reset the external resources associated with the receiver to an initial state. "	self interfacePointer ifNotNil: [:p | p enforceInvalidation].	self interfacePointer: nil</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>private-resource management</category><body package="Com- Ole">allocateExternalResources	"Private - Allocate and initialize the external memory for the receiver. "	" A COM interface in external memory is a pointer to a pointer to a VTable of function addresses.  Appended to the pointer which references the VTable can be private data of the object supporting the interface.  (This structure conveniently corresponds to the memory layout of a C++ object body, which consists of a VTable pointer followed by the object private state.)  "	"Instances of the receiver allocate an 8 byte external memory area for their object body as follows:			offset 0 - 4 byte address of the VTable for the interface.			offset 4 - 4 byte external object table index of the supporting object.	The second field is used by the OE callback mechanism for VTables to dispatch the external function invocation to a Smalltalk object, which we define to be this interface implementation instance, for reentry into the image.  The argument marshalling for the callback and and external invocation selector used to dispatch the callback to the receiver is defined by the VTable specifications of the receiver's class. 	"	| vtableAddress callinInterfaceIndex lpObjectBody |	vtableAddress := self class vtable asPointerParameter.	vtableAddress == nil		ifTrue: 			[^COMError raiseSignal: #ErrCantAllocCallbakVTable &lt;&lt; #com						&gt;&gt; 'unable to allocate interface callback VTable'].	"Assert isTrue: [ self hasExternalResources not ]."	" register the receiver in the exported object table to make it known to the OE callback mechanism "	callinInterfaceIndex := ExportedObjectsTable registerObject: self.	" allocate and initialize the 8-byte object body of the interface in external memory "	lpObjectBody := COMMemoryAddress				allocateMemory: COMPlatformProvider current interfaceType.	"The memory is now managed by myself and should not be shown to users in the COM resource browser"	lpObjectBody doesNotNeedFinalization.	lpObjectBody		memberAt: #vtablePointer put: vtableAddress;		memberAt: #entry put: callinInterfaceIndex.	self interfacePointer: lpObjectBody</body></methods><methods><class-id>External.COMInterfaceImplementation</class-id> <category>private-comparing</category><body package="Com- Ole">interfaceEqual: anInterface	" Private - answer whether the receiver and &lt;anInterface&gt; are the same interface.  The IID's are assumed to be equal. "	"Assert isTrue: [ anInterface isOLEInterfaceReference not ]."	" compare carefully to avoid unnecessary external resource allocation by an impl "	^anInterface isCOMInterfacePointer		ifTrue: 			[self interfacePointer notNil				and: [self interfacePointer interfaceEqual: anInterface]]		ifFalse: 			[" there is only one impl binding per object per IID "			self == anInterface]</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>VTable utilities</category><body package="Com- Ole">invalidateExternalVTable	" Invalidate the address of the receiver's VTable in external memory. "	self vtable isNil ifTrue: [ ^self ].	self vtable invalidate.</body><body package="Com- Ole">releaseExternalVTable	" Release the receiver's VTable in external memory. "	self vtable isNil ifTrue: [ ^self ].	self vtable release.</body><body package="Com- Ole">validateVTable	" Verify that a complete and consistent set of VTable invocation methods is defined in the receiver.  Notify the user of any problems. "	| eptDescriptions callbackSelectors dummyGuy ept aSelector |	vtable isNil 		ifTrue: [ ^self ].  " abstract classes in the hierarchy don't have a vtable "	eptDescriptions := vtable vtableDescription.	callbackSelectors := vtable callbackSelectors.	dummyGuy := self basicNew.	1 to: vtable size do: [ :i |		ept := eptDescriptions at: i.		aSelector := callbackSelectors at: i.		ept vtableIndex = ( i - 1 )			ifFalse: [ 				MessageBox warning: 					((#VTableSlotIndexProblem &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable problem: slot index problem in &lt;2s&gt;')						expandMacrosWith: self name						with: ept name) ].		ept numberOfArguments = ( aSelector occurrencesOf: $: )			ifFalse: [ 				MessageBox warning: 					((#ArgumentCountMismatch &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable problem: argument count mismatch in &lt;2s&gt;')						expandMacrosWith: self name						with: ept name) ].		( dummyGuy respondsTo: aSelector )			ifFalse: [ 				MessageBox warning: 					((#UnimplementedSelector &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable problem: unimplemented selector #&lt;2s&gt; for &lt;3s&gt;')						expandMacrosWith: self name						with: aSelector						with: ept name) ].		].	^eptDescriptions</body><body package="Com- Ole">validateVTableConsistency	" Verify that the VTable functions defined in the receiver are consistent with the interface callout binding.  Notify the user of any problems. "	| anInterfacePointerClass callbackSelectors callinEntryPoints calloutEntryPoints nEntryPoints aCallinEPT aCalloutEPT |	vtable isNil ifTrue: [^self].	" abstract classes in the hierarchy don't have a vtable "	(anInterfacePointerClass := self interfacePointerClass) isNil 		ifTrue: [^nil].	callbackSelectors := vtable callbackSelectors.	callinEntryPoints := vtable vtableDescription.	calloutEntryPoints := anInterfacePointerClass vtableDescription.	nEntryPoints := callinEntryPoints size.	nEntryPoints ~= calloutEntryPoints size 		ifTrue: 			[MessageBox 				warning: (#WarnVTableCallinErr &lt;&lt; #com 						&gt;&gt; ' &lt;1s&gt; VTable consistency problem: callin binding has &lt;2p&gt; entry points, but callout binding of &lt;3s&gt;  has &lt;4p&gt; functions.' 							expandMacrosWith: self name							with: callinEntryPoints size							with: anInterfacePointerClass name							with: calloutEntryPoints size).			" um, it may not actually make sense to try to press on at this point, but give it a try... "			nEntryPoints := nEntryPoints min: calloutEntryPoints size].	1 to: nEntryPoints		do: 			[:i | 			aCallinEPT := callinEntryPoints at: i.			Assert isEqual: aCallinEPT selector numArgs				to: (callbackSelectors at: i) numArgs - 1.	" callback from OE includes leading This arg "			Assert isEqual: aCallinEPT vtableIndex to: i - 1.			aCalloutEPT := calloutEntryPoints at: i.			(self compareCalloutEPT: aCalloutEPT toCallinEPT: aCallinEPT) 				ifFalse: 					[COMDevelopmentWarning raiseSignal: 						(#WarnVTableCalloutShortErr &lt;&lt; #com 								&gt;&gt; '&lt;1s&gt; VTable consistency problem: entry point &lt;2s&gt; not consistent with callout function definition.' 									expandMacrosWith: self name									with: aCallinEPT name)]].	^callinEntryPoints</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerIID	" Private - register the receiver as the interface implementation binding class for its IID. "	self registerIID: self iid forClass: self.</body><body package="Com- Ole">registerIID: anIID forClass: aClass	" Private - register &lt;aClass&gt; as the interface implementation binding class representing the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	COMInterfacePointer registerInterfaceImplementationClass: aClass forIID: anIID.</body><body package="Com- Ole">removeIID	" Private - remove the registration of the receiver as the interface implementation binding class for its IID. "	self removeIID: self iid.</body><body package="Com- Ole">removeIID: anIID	" Private - remove the interface implementation binding class registration of the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	COMInterfacePointer removeInterfaceImplementationClassForIID: anIID.</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>accessing</category><body package="Com- Ole">vtableDescription	" Answer an array of entry point descriptions, in VTable order, of the receiver's interface VTable functions. "	^self vtable vtableDescription</body><body package="Com- Ole">vtableSelectors	" Answer an array of message selectors, in VTable order, of the receiver's interface functions. "	^vtableSelectors</body><body package="Com- Ole">vtableSize	" Answer the number of interface function entry points defined in the receiver's interface function VTable. "	^self vtable size</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>subclass-initialization</category><body package="Com- Ole">callbackSelectorFor: anEntryPointDescription	" Private - answer the selector which is sent to instances of the receiver when the entry point described by &lt;anEntryPointDescription&gt; is invoked by an external caller.  By default, the callin selector is the entry point name prefixed by 'invoke' and a suitable number of argument keywords, e.g., #invokeQueryInterface:_:_: "	" Note that in Visual Smalltalk, the callin binding has the same argument list as the callout binding, while in Visual Works an additional 'this' argument is always prepended by the OE callback mechanism. "	^self constructSelectorFor: anEntryPointDescription name 		prefix: self callbackSelectorPrefix 		nArgs: anEntryPointDescription numberOfArguments  " include leading This arg from VW callback "</body><body package="Com- Ole">checkVTableValidity	" Check the receiver's VTable for internal and external consistency. "	self vtable notNil		ifTrue: [			self validateVTable.    " check internal consistency "			self validateVTableConsistency.  " check consistency with VTable structure definition "			].</body><body package="Com- Ole">constructCallbackSelectorsFor: vtableDescription	" Private - construct the list of callback selectors to send to instances of the receiver when the corresponding entry point in the &lt;vtableDescription&gt; is invoked by callin from an external client. "	^vtableDescription collect: [ :eptDescription |		self callbackSelectorFor: eptDescription ].</body><body package="Com- Ole">constructSelectorFor: functionName prefix: functionPrefix nArgs: nArgs	" Private - construct the selector to use with entry point named &lt;functionName&gt; with &lt;nArgs&gt;.  A prefix is optionally prepended to the function name. "	| aStream |	aStream := ReadWriteStream on: ( String new: functionPrefix size + functionName size + ( nArgs * 2 ) ).	functionPrefix notNil		ifTrue: [ aStream nextPutAll: functionPrefix ].	aStream nextPutAll: functionName.	nArgs &gt; 0		ifTrue: [			aStream nextPut: $:.			( nArgs - 1 ) timesRepeat: [ aStream nextPutAll: '_:' ] ].	^aStream contents asSymbol</body><body package="Com- Ole">constructVTable	" Private - construct the VTable which is shared by all instances of the receiver. "	| vtableDescription |	vtableDescription := self constructVTableDescription.	vtableDescription isNil ifTrue: [^nil].	^COMExternalVTable		forEntryPoints: vtableDescription		callbackSelectors: (self constructCallbackSelectorsFor: vtableDescription)		interfaceClass: self</body><body package="Com- Ole">constructVTableDescription	" Private - construct a description of the receiver's VTable.  Answer an array of entry point descriptions, in VTable order, of the receiver's VTable functions.  The argument types describe the value to be constructed by the virtual machine when a callback to the entry point is invoked by an external caller. "	| vtableDescription vtableType |	vtableType := self vtableSignatureType.	vtableType isNil		ifTrue: [ ^nil ].  " abstract classes in the hierarchy don't have a VTable "	vtableDescription := self constructVTableDescriptionOf: vtableType.	vtableDescription do: [ :eptDescriptor |		eptDescriptor selector: ( self defaultForwardingSelectorFor: eptDescriptor ) ].	^vtableDescription asArray</body><body package="Com- Ole">constructVTableDescriptionOf: aVTableStructureType 	" Private - construct a description of the VTable defined by &lt;aVTableStructureType&gt;.  Answer an array of entry point descriptions, in VTable order, of the VTable functions.  The argument types describe the value to be constructed by the virtual machine when a callback to the entry point is invoked by an external caller. "	| vtableDescription vtableIndex |	aVTableStructureType isComposite 		ifFalse: [self error: #ErrBadVTableSig &lt;&lt; #com &gt;&gt; 'bad VTable signature type'].	vtableDescription := OrderedCollection new.	vtableIndex := 0.	aVTableStructureType keysAndValuesDo: 			[:methodName :offsetAndTypeAssoc | 			| aType eptDescriptor |			aType := offsetAndTypeAssoc value.			aType isProcedurePointer 				ifFalse: [self error: #ErrBadVTableSig &lt;&lt; #com &gt;&gt; 'bad VTable signature type'].			aType := aType referentType.			eptDescriptor := COMEntryPointDescription 						name: methodName asString						type: aType						vtableIndex: vtableIndex.			vtableDescription add: eptDescriptor.			vtableIndex := vtableIndex + 1].	^vtableDescription asArray</body><body package="Com- Ole">defaultForwardingSelectorFor: anEntryPointDescription	" Private - answer the default selector to use when forwarding a callback for &lt;anEntryPointDescription&gt; to the implementing object which supports the interface. "	" Note that in Visual Smalltalk, the callin binding has the same argument list as the callout binding, while in Visual Works an additional 'this' argument is always prepended by the OE callback mechanism. "	^self constructSelectorFor: anEntryPointDescription name 		prefix: nil 		nArgs: anEntryPointDescription numberOfArguments - 1  " strip leading This arg from VW callback when forwarding "</body><body package="Com- Ole">initializeVTable	" Private - initialize the receiver's VTable with a list of entry point descriptions and dispatch selectors for processing callins from external clients to the functions implemented by the receiver.  The entry points must be in the order of the slots in the VTable. "	self vtable: self constructVTable.	self initializeVTableSelectors.</body><body package="Com- Ole">initializeVTableSelectors	" Private - initialize the array of message selectors, in VTable order, of the receiver's interface functions. "	self vtable notNil		ifTrue: [ self vtableSelectors: ( self vtableDescription collect: [ :eptDescription | eptDescription selector ] ) ].</body><body package="Com- Ole">vtableSignatureType	" Private - answer the structure definition for the receiver's interface VTable. "	^self vtableSignatureTypeNamed: self vtableSignatureTypeName</body><body package="Com- Ole">vtableSignatureTypeNamed: aVTableStructureTypeName	" Private - answer the structure definition for the interface VTable defined by the structure type named&lt;aVTableStructureTypeName&gt;.  "	self vtableSignaturesPool isNil		ifTrue: [ ^nil ].	^self vtableSignaturesPool at: aVTableStructureTypeName		ifAbsent: [ nil ]</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>subclass-accessing</category><body package="Com- Ole">callbackSelectorPrefix	" Private - answer the prefix used to construct a callback selector from the entry point selector. "	^'invoke'</body><body package="Com- Ole">interfacePointerClass	" Private - answer the interface pointer class which represents the same COM interface as the receiver. "	^COMInterfacePointer classForIID: self iid</body><body package="Com- Ole">internalCallbackSelectorPrefix	" Private - answer the prefix used to construct a callback selector from the entry point selector. "	^'private'</body><body package="Com- Ole">vtable	"Private - answer the VTable shared by all instances of the receiver."	^vtable</body><body package="Com- Ole">vtable: aVTable	" Private - set the VTable shared by all instances of the receiver to &lt;aVTable&gt;. "	vtable notNil		ifTrue: [ vtable release ].	vtable := aVTable.</body><body package="Com- Ole">vtableSelectors: selectors	" Specify the list of message selectors, in VTable order, of the receiver's interface functions. "	vtableSelectors := selectors.</body><body package="Com- Ole">vtableSignatureTypeName	" Answer the name of the structure type which defines the function table layout and function signatures of the receiver's interface VTable. "	^vtableSignatureTypeName</body><body package="Com- Ole">vtableSignatureTypeName: aTypeName	" Specify the name of the structure type which defines the function table layout and function signatures of the receiver's interface VTable. "	vtableSignatureTypeName := aTypeName.</body><body package="Com- Ole">vtableSignaturesPool	" Private - answer the data types pool containing interface VTable function table signatures. "	^VTableSignaturesPool</body><body package="Com- Ole">vtableSignaturesPool: aDictionary	" Private - specify the data types pool containing interface VTable function table signatures.	 When this changes all subclasses must rebuild their vtables to get the right type objects."	VTableSignaturesPool := aDictionary.	self allSubclasses do:		[:interfaceClass|		interfaceClass rebindAllMethods; initializeVTable]	"self vtableSignaturesPool: VTableSignaturesPool"</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>IID class map</category><body package="Com- Ole">classForIID: anIID	" Answer the interface implementation class which represents the interface specified by the interface ID GUID &lt;anIID&gt;.  Answer nil if the interface is not supported. "	^self classForIID: anIID ifNone: [ nil ]</body><body package="Com- Ole">classForIID: anIID ifNone: aBlock	" Answer the interface implementation class which represents the interface specified by the interface ID GUID &lt;anIID&gt;.   Answer the result of evaluating &lt;aBlock&gt; if no class is available. "	| aClass |	( anIID isNil or: [ anIID = IID_NULL ] )		ifTrue: [ ^aBlock value ].	aClass := COMInterfacePointer interfaceImplementationClassForIID: anIID.	aClass notNil		ifTrue: [ ^aClass ].	aClass := self subclassForIID: anIID.	aClass notNil		ifTrue: [  " self-registration backstop "			self registerIID: anIID forClass: aClass.			^aClass ].	^aBlock value</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>subclass-instance creation</category><body package="Com- Ole">adaptorClass	" Private - answer the interface binding adaptor class for the receiver. "	^COMInterfaceFunctionAdaptor</body><body package="Com- Ole">createAdaptorOn: anObject	" Private - answer an interface adaptor which supports the interface functions of the receiver and allows the mapping onto the protocol of &lt;anObject&gt; to be configured. "	^self adaptorClass on: anObject		selectors: self vtableSelectors</body><body package="Com- Ole">validateDispatchSelectors: dispatchSelectors for: anObject	" Private - validate the interface function dispatch selectors in the &lt;dispatchSelectors&gt; array.  Ensure that a complete set is provided and that as far as can be determined that the handlers are consistent with the function for which they are registered.  The dispatchSelectors is an Array in VTable order. "	| eptDescriptions aSelector eptDescription |	eptDescriptions := self vtableDescription.	dispatchSelectors size ~= eptDescriptions size		ifTrue: [ 			MessageBox warning: 				((#VTableSizeMismatch &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable adaptor handlers problems: size mismatch')					expandMacrosWith: self name) ].	1 to: ( dispatchSelectors size min: eptDescriptions size ) do: [ :i |		aSelector := dispatchSelectors at: i.		eptDescription := eptDescriptions at: i.		aSelector isNil			ifTrue: [				MessageBox warning: 					((#VTableNoHandler &lt;&lt; #com &gt;&gt; '&lt;1s&gt; VTable handlers problems: no handler for &lt;2s&gt;')						expandMacrosWith: self name						with: eptDescription name) ]			ifFalse: [				self validateSelector: aSelector for: eptDescription.  " is this perhaps overzealous? "				self validateSupportFor: aSelector					by: anObject					for: eptDescription ].		].</body><body package="Com- Ole">validateMinimumBindingSupportOf: anObject	" Private - validate that &lt;anObject&gt; supports the minimum interface function selectors needed to minimally support the receiver's interface.  Should be reimplemented by subclasses with stronger constraints than doing nothing. "</body><body package="Com- Ole">validateSelector: aSelector for: eptDescription	" Private - validate the dispatch selector &lt;aSelector&gt; for the interface function described by &lt;eptDescription&gt;. "	( MessageSend numberOfArgumentsFor: aSelector ) 			~= ( eptDescription numberOfArguments - 1 )  " ignore implicit receiver arg of callback "		ifTrue: [			| interfaceName |			interfaceName := self interfaceReferenceClass name asString.			MessageBox warning: 				((#FunctionArgumentCountMismatch &lt;&lt; #com &gt;&gt; '&lt;1s&gt; interface function binding problem: argument count mismatch for &lt;2s&gt;::&lt;3s&gt; ( &lt;4s&gt; is registered).')					expandMacrosWith: self name					with: interfaceName					with: eptDescription name					with: aSelector printString) ].</body><body package="Com- Ole">validateStandardBindingSupportOf: anObject	" Private - validate that &lt;anObject&gt; supports the standard interface function selectors needed to fully support the receiver's interface. "	self vtableDescription do: [ :eptDescription |		self validateSupportFor: eptDescription selector 			by: anObject 			for: eptDescription ].</body><body package="Com- Ole">validateSupportFor: aSelector by: anObject for: anEntryPointDescription	" Private - validate that &lt;anObject&gt; supports the &lt;aSelector&gt;. "	( anObject respondsTo: aSelector )		ifFalse: [			| interfaceName |			interfaceName := self interfaceReferenceClass name asString.			MessageBox warning: ((#BindingProblem &lt;&lt; #com &gt;&gt; '&lt;1s&gt; binding problem: &lt;2s&gt; does not support &lt;3s&gt; for &lt;4s&gt;::&lt;5s&gt;.')					expandMacrosWithArguments: (OrderedCollection new 						add: interfaceName;						add: anObject printString;						add: aSelector printString;						add: interfaceName;						add: anEntryPointDescription name; asArray)) ].</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>instance creation</category><body package="Com- Ole">adaptorBindingOn: anObject	" Answer an initialized instance of the receiver that is an interface for &lt;anObject&gt;.  The object can configure the interface binding to map the standard function selectors of this interface to any desired protocol.  By default, the adaptor installs the standard IUnknown function selectors and maps all other interface functions such that they return the E_NOTIMPL status code. "	| anInterfaceAdaptor |	ImageConfiguration isDevelopment		ifTrue: [ self validateMinimumBindingSupportOf: anObject ].	anInterfaceAdaptor := self createAdaptorOn: anObject.	anInterfaceAdaptor installStandardDispatchHandlers.	^self new		implementor: anInterfaceAdaptor;		yourself</body><body package="Com- Ole">adaptorBindingOn: anObject selectors: selectors 	" Answer an initialized instance of the receiver that is an interface for &lt;anObject&gt;.  The interface binding adaptor is configured to map the standard function selectors of the interface to the corresponding entries in &lt;selectors&gt; as the interface function handlers to delegate processing responsibility to the implmenting object.  The &lt;selectors&gt; list must be exact match in size, order, and argument count to the interface VTable function layout. "	| anInterfaceAdaptor |	selectors size ~= self vtableSize 		ifTrue: [self error: #ErrIncorrectSelNumber &lt;&lt; #com &gt;&gt; 'incorrect number of selectors'].	ImageConfiguration isDevelopment 		ifTrue: [self validateDispatchSelectors: selectors for: anObject].	anInterfaceAdaptor := self createAdaptorOn: anObject.	anInterfaceAdaptor installDispatchSelectors: selectors.	^(self new)		implementor: anInterfaceAdaptor;		yourself</body><body package="Com- Ole">directBindingOn: anObject	" Answer an initialized instance of the receiver that is an interface for &lt;anObject&gt;.  The object must support the standard function selectors of this interface. "	ImageConfiguration isDevelopment		ifTrue: [ self validateStandardBindingSupportOf: anObject ].	^self new		implementor: anObject;		yourself</body><body package="Com- Ole">new	^ super new initialize</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>private-installation</category><body package="Com- Ole">ClassFinalizer	" COMInterfaceImplementation ClassFinalizer "	"NOTE: This is a special finalizer.  While the fundamental intent of ClassInitializer 	and ClassFinalizer methods is to be class-specific and *not* used via inheritance 	by subclasses, for this particular branch of the hierarchy with its registry of 	subclass mapping information it is convenient to write this removal support once 	with the intention that it indeed be inherited. "	(COMSessionManager allExportedInterfaces 		detect: [:anInterfaceImpl | anInterfaceImpl class == self]		ifNone: [nil]) notNil 		ifTrue: 			[self error: #ErrCantRemoveLiveClass &lt;&lt; #com 						&gt;&gt; 'cannot remove class while instances are exported'].	self releaseExternalVTable.	self removeIID.	self vtable: nil</body><body package="Com- Ole">initialize	self iid: nil.  							" abstract superclass does not have an IID "	self vtableSignatureTypeName: nil.  	" nor does it have an VTable "	"self updateAndRegister"			"subclasses should do this"</body><body package="Com- Ole">obsolete	self ClassFinalizer.	^super obsolete</body><body package="Com- Ole">prerequisitesForLoading	^super prerequisitesForLoading		addLast: COMInterfacePointer;		yourself</body><body package="Com- Ole">updateAndRegister	self		registerIID;		initializeVTable.	self checkVTableValidity</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>private-IID class map</category><body package="Com- Ole">subclassForIID: anIID	" Private - answer the interface implementation class which supports the interface identified by the GUID &lt;anIID&gt;. "	^COMInterfaceImplementation allSubclasses		detect: [ :aClass | aClass supportsIID: anIID ]		ifNone: [ nil ]</body></methods><methods><class-id>External.COMInterfaceImplementation class</class-id> <category>utilities</category><body package="Com- Ole">localImplementorOf: anInterfacePointer	" Answer the interface implementation binding supported by a COM object in the current session which corresponds to the interface pointer &lt;anInterfacePointer&gt;.  Answer nil if the interface was not exported by this session. "	| pointerAddress localPointer |	anInterfacePointer isCOMInterfacePointer		ifFalse: 			[self error: #ErrMustBeIntPointer &lt;&lt; #com &gt;&gt; 'must be an interface pointer'].	localPointer := COMThreadManager marshalToSTA: anInterfacePointer.	pointerAddress := localPointer asInterfacePointer asInteger.	^COMSessionManager allExportedInterfaces detect: 			[:anInterfaceImpl |			" first test here is fast heuristic which hints at equality "			anInterfaceImpl asInteger = pointerAddress				and: [anInterfaceImpl = localPointer]]		ifNone: [nil]</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>civilized operations</category><body package="Com- Ole">enforceDecRef		" Decrement the reference count of the interface referenced by the receiver.		Do not destroy the reference, allowing the client to continue using the interface.		Answer the value of the reference count (for diagnostic use only; may not be stable). "	^self privateDecrementReferenceCount</body><body package="Com- Ole">queryInterface: iid        "Query the receiver for the interface specified by the GUID &lt;iid&gt;.		Answer the interface if it is supported, else answer nil. "	| resultReference |	resultReference := COMInterfaceValueReference forIID: iid.	self QueryInterface: iid _: resultReference.	^resultReference value</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>private-dispatch</category><body package="Com- Ole">dispatchAddRef	" Private - dispatch the IUnknown::AddRef function. "	 referenceCount := referenceCount + 1.	^implementor enforceAddRef</body><body package="Com- Ole">dispatchQueryInterface:  iid _: resultReference	" Private - dispatch the IUnknown::QueryInterface function. "	^implementor QueryInterface:  iid 		_: resultReference</body><body package="Com- Ole">dispatchRelease	" Private - dispatch the IUnknown::Release function. "	referenceCount := referenceCount - 1.	referenceCount = 0 ifTrue: [ self releaseResources ].	^implementor enforceRelease</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeAddRef: this		"Private - invoke the IUnknown::AddRef function for an external caller. "	" ULONG AddRef( void); "	^[   " terminate exception stack unwind at external callin boundary "	 self dispatchAddRef .	] on: self rootExceptions   		do: ( self exceptionHandlerForZeroReturnValue: #externalCallin )</body><body package="Com- Ole">invokeQueryInterface: this _: riid _: ppvObject		" Private - invoke the IUnknown::QueryInterface function for an external caller. "	" HRESULT QueryInterface(            /* [in] */ REFIID riid,            /* [out] */ void **ppvObject); "	^[   " terminate exception stack unwind at external callin boundary "	| hresult iid resultReference |	self reportExternalFunctionEntry.	( riid isValid	and: [ ppvObject isValid ] )		ifFalse: [ ^E_INVALIDARG ].	iid := self guidAtAddress: riid.	self clearScalarResultValueAtAddress: ppvObject.	resultReference := nil asValueReference.	hresult := self dispatchQueryInterface: iid 		_: resultReference.	(hresult succeeded)		ifTrue: [ self interfaceResultAtAddress: ppvObject put: resultReference value ].	hresult	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeRelease: this		"Private - invoke the IUnknown::Release function for an external caller. "	" ULONG Release( void); "	^[   " terminate exception stack unwind at external callin boundary "	self dispatchRelease.	] on: self rootExceptions   		do: ( self exceptionHandlerForZeroReturnValue: #externalCallin )</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>interface operations</category><body package="Com- Ole">QueryInterface: iid _: resultReference	" Invoke the IUnknown::QueryInterface function.	Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		self dispatchQueryInterface: iid _: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult allow: E_NOINTERFACE.	^hresult</body><body package="Com- Ole">basicQueryInterface: iid _: resultReference 	" Invoke the IUnknown::QueryInterface function.	Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := 			[" terminate exception stack unwind at function invocation boundary "			self dispatchQueryInterface: iid _: resultReference] 					on: self rootExceptions					do: (self exceptionHandlerForHRESULTReturnValue: #internalCallin).	hresult = E_NOINTERFACE 		ifTrue: 			[COMError 				raiseSignal: (#ErrNamedNoSupport &lt;&lt; #com 						&gt;&gt; 'This object does not support &lt;1p&gt;' 							expandMacrosWith: resultReference interfaceReference class)]		ifFalse: [self checkHresult: hresult].	^hresult</body><body package="Com- Ole">enforceAddRef	" Invoke the IUnknown::AddRef function. "	^ self privateAddRef</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>accessing</category><body package="Com- Ole">referenceCount	^referenceCount</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>initialize-release</category><body package="Com- Ole">initialize	referenceCount := 0.	^ super initialize</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>private interface operations</category><body package="Com- Ole">privateAddRef	" Invoke the IUnknown::AddRef function. "	^[  " terminate exception stack unwind at function invocation boundary "	self dispatchAddRef	] on: self rootExceptions   		do: ( self exceptionHandlerForZeroReturnValue: #internalCallin )</body><body package="Com- Ole">privateDecrementReferenceCount		" Decrement the reference count of the interface referenced by the receiver.		Do not destroy the reference, allowing the client to continue using the interface.		Answer the value of the reference count (for diagnostic use only; may not be stable). "	^self privateRelease</body><body package="Com- Ole">privateRelease	" Invoke the IUnknown::Release function. "	^[  " terminate exception stack unwind at function invocation boundary "	self dispatchRelease	] on: self rootExceptions   		do: ( self exceptionHandlerForZeroReturnValue: #internalCallin )</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>obsolete</category><body package="Com- Ole">AddRef	self callIsDispensable.</body><body package="Com- Ole">Release	" Invoke the IUnknown::Release function. "	self callIsDispensable.</body><body package="Com- Ole">decrementReferenceCount	self callIsDispensable.</body></methods><methods><class-id>External.IUnknownImplementation</class-id> <category>releasing</category><body package="Com- Ole">enforceRelease	| count |	count := self referenceCount.	count &gt; 0		ifTrue: [[self referenceCount &gt; 0] whileTrue: [self privateRelease]]		ifFalse: [self releaseResources].	^implementor referenceCount</body></methods><methods><class-id>External.IUnknownImplementation class</class-id> <category>subclass-instance creation</category><body package="Com- Ole">adaptorClass	" Private - answer the interface binding adaptor class for the receiver. "	^IUnknownAdaptor</body><body package="Com- Ole">validateMinimumBindingSupportOf: anObject	" Private - validate that &lt;anObject&gt; supports the minimum interface function selectors needed to minimally support the receiver's interface. "	IUnknownImplementation vtableDescription do: [ :eptDescription |		self validateSupportFor: eptDescription selector 			by: anObject 			for: eptDescription ].</body></methods><methods><class-id>External.IUnknownImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IUnknown.	self vtableSignatureTypeName: #__IUnknownVtbl.	self updateAndRegister</body></methods><methods><class-id>External.IRunnableObjectImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetRunningClass: this _: lpClsid	" Private - invoke the IRunnableObject::GetRunningClass function for an external caller. "	" HRESULT __stdcall  GetRunningClass(LPCLSID lpClsid) = 3 ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^[  " terminate exception stack unwind at function invocation boundary "	"### optional - add checking for NULL argument pointers:	self reportExternalFunctionEntry.	lpClsid isNull ifTrue: [ ^E_INVALIDARG ].	###"	implementor GetRunningClass: ( self guidAtAddress: lpClsid )	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeIsRunning: this	" Private - invoke the IRunnableObject::IsRunning function for an external caller. "	" BOOL __stdcall  IsRunning(void) = 5 "	^[  " terminate exception stack unwind at function invocation boundary "	implementor IsRunning	] on: self rootExceptions		do: ( self exceptionHandlerForNilReturnValue: #externalCallin )</body><body package="Com- Ole">invokeLockRunning: this _: fLock _: fLastUnlockCloses	" Private - invoke the IRunnableObject::LockRunning function for an external caller. "	" HRESULT __stdcall  LockRunning(BOOL fLock, BOOL fLastUnlockCloses) = 6 "	^[  " terminate exception stack unwind at function invocation boundary "	implementor LockRunning: fLock _: fLastUnlockCloses	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeRun: this _: pbc	" Private - invoke the IRunnableObject::Run function for an external caller. "	" HRESULT __stdcall  Run(LPBINDCTX pbc) = 4 ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^[  " terminate exception stack unwind at function invocation boundary "	"### optional - add checking for NULL argument pointers:	self reportExternalFunctionEntry.	pbc isNull ifTrue: [ ^E_INVALIDARG ].	###"	implementor Run: ( "self interfaceAtAddress: "pbc "### type: IFoo ##" )	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeSetContainedObject: this _: fContained	" Private - invoke the IRunnableObject::SetContainedObject function for an external caller. "	" HRESULT __stdcall  SetContainedObject(BOOL fContained) = 7 "	^[  " terminate exception stack unwind at function invocation boundary "	implementor SetContainedObject: fContained	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IRunnableObjectImplementation</class-id> <category>interface operations</category><body package="Com- Ole">GetRunningClass: lpClsid	" Invoke the IRunnableObject::GetRunningClass function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetRunningClass: lpClsid		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">IsRunning	" Invoke the IRunnableObject::IsRunning function. "	^[  " terminate exception stack unwind at function invocation boundary "	implementor IsRunning	] on: self rootExceptions		do: ( self exceptionHandlerForNilReturnValue: #internalCallin )</body><body package="Com- Ole">LockRunning: fLock _: fLastUnlockCloses	" Invoke the IRunnableObject::LockRunning function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor LockRunning: fLock _: fLastUnlockCloses		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Run: pbc	" Invoke the IRunnableObject::Run function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Run: pbc		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">SetContainedObject: fContained	" Invoke the IRunnableObject::SetContainedObject function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor SetContainedObject: fContained		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IRunnableObjectImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IRunnableObject.	self vtableSignatureTypeName: #__IRunnableObjectVtbl.	self updateAndRegister</body></methods><methods><class-id>External.COMLicenseInfo</class-id> <category>accessing</category><body package="Com- Ole">licenseVerified	^licenseVerified</body><body package="Com- Ole">licenseVerified: anObject	licenseVerified := anObject</body><body package="Com- Ole">runtimeKeyAvailable	^runtimeKeyAvailable</body><body package="Com- Ole">runtimeKeyAvailable: anObject	runtimeKeyAvailable := anObject</body></methods><methods><class-id>External.COMLicenseInfo</class-id> <category>initialize-release</category><body package="Com- Ole">fromLicInfo: aPLicInfo	self licenseVerified: (aPLicInfo memberAt: #fLicVerified).	self runtimeKeyAvailable:	 (aPLicInfo memberAt: #fRuntimeKeyAvail).</body></methods><methods><class-id>External.COMLicenseInfo class</class-id> <category>instance creation</category><body package="Com- Ole">fromLicInfo: aPLicInfo	^ self new		fromLicInfo: aPLicInfo;		yourself</body></methods><methods><class-id>External.IPersistFile</class-id> <category>interface operations</category><body package="Com- Ole">currentPathName		" Answer the absolute path name of the document's file.		Answer nil if there is no file currently associated with the receiver. "	| resultReference |	resultReference := nil asValueReference.	^( interface GetCurFile: resultReference ) = S_OK		ifTrue: [ resultReference value ]		ifFalse: [ nil ]</body><body package="Com- Ole">getCurFile		" Answer the absolute path name of the document's currently associated file.		Answer the default filename prompt if there is no currently associated file. "	| resultReference |	resultReference := nil asValueReference.	interface GetCurFile: resultReference.	^resultReference value</body><body package="Com- Ole">isDirty		" Answer whether the object has been changed since it was last saved. "	^( interface IsDirty ) = S_OK</body><body package="Com- Ole">load: aPathName		" Load the document object contained in the file specified		by the absolute pathname &lt;aPathName&gt; with read/write access. "	interface Load: aPathName _: STGM_READWRITE.</body><body package="Com- Ole">load: aPathName storageMode: storageModeFlags		" Load the document object contained in the file specified		by the absolute pathname &lt;aPathName&gt; with the access		modes specified by &lt;storageModeFlags&gt;. "	interface Load: aPathName _: storageModeFlags.</body><body package="Com- Ole">loadReadOnly: aPathName		" Load the document object contained in the file specified		by the absolute pathname &lt;aPathName&gt; with readOnly access. "	interface Load: aPathName _: STGM_READ.</body><body package="Com- Ole">save		" Save a copy of the object to the current working file. "	interface Save: nil _: true.</body><body package="Com- Ole">save: aPathName makeFileCurrent: fRemember		" Save a copy of the object to the file specified		by the absolute pathname &lt;aPathName&gt;.		Make the specified file the current working copy of the		document if &lt;fRemember&gt; is true.		Save the object to the current file if the path name is null.		Raise an exception if an error occurs.  Answer the result code. "	^interface Save: aPathName _: fRemember</body><body package="Com- Ole">saveAs: aPathName		" Save a copy of the object to the file specified by the absolute		pathname &lt;aPathName&gt; and make it the current working file. "	interface Save: aPathName _: true.</body><body package="Com- Ole">saveCompleted		" The object has been saved to its backing storage 		and the caller is finished working with it. "	^interface SaveCompleted: nil</body><body package="Com- Ole">saveCompleted: aPathName		" The object has been saved to the file specified		by the absolute pathname &lt;aPathName&gt; 		and the caller is finished working with it. 		Answer the result code, which is always S_OK. "	^interface SaveCompleted: aPathName</body><body package="Com- Ole">saveCopyAs: aPathName		" Save a copy of the object to the file specified by the absolute		pathname &lt;aPathName&gt;.  Do not change the current working file. "	interface Save: aPathName _: false.</body></methods><methods><class-id>External.IPersistFile class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistFile.	self updateAndRegister</body></methods><methods><class-id>External.IPersistImplementation</class-id> <category>interface operations</category><body package="Com- Ole">GetClassID: resultReference		" Invoke the IPersist::GetClassID function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetClassID: resultReference 		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IPersistImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetClassID: this _: pClassID	" Private - invoke the IPersist::GetClassID function for an external caller. "	" HRESULT GetClassID(            /* [out] */ CLSID *pClassID); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pClassID isValid ifFalse: [^E_INVALIDARG].	self clearStructureResultAtAddress: pClassID.	resultReference := nil asValueReference.	hresult := implementor GetClassID: resultReference.	hresult succeeded		ifTrue: [self structureResultAtAddress: pClassID put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body></methods><methods><class-id>External.IPersistImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersist.	self vtableSignatureTypeName: #__IPersistVtbl.	self updateAndRegister</body></methods><methods><class-id>External.IPersistStreamImplementation</class-id> <category>interface operations</category><body package="Com- Ole">GetSizeMax: resultReference		" Invoke the IPersistStream::GetSizeMax function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetSizeMax: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">IsDirty		" Invoke the IPersistStream::IsDirty function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor IsDirty		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Load: anIStream		" Invoke the IPersistStream::Load function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Load: anIStream		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Save: anIStream _: fClearDirty		" Invoke the IPersistStream::Save function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Save: anIStream _: fClearDirty		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IPersistStreamImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetSizeMax: this _: pcbSize	" Private - invoke the IPersistStream::GetSizeMax function for an external caller. "	" HRESULT GetSizeMax(            /* [out] */ ULARGE_INTEGER *pcbSize); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pcbSize isValid ifFalse: [^E_INVALIDARG].	self clearStructureResultAtAddress: pcbSize.	resultReference := nil asValueReference.	hresult := implementor GetSizeMax: resultReference.	hresult succeeded		ifTrue: 			[| resultValue |			resultValue := resultReference value.			resultValue isInteger				ifTrue: [resultValue := Win32LargeInteger fromUnsignedInteger: resultValue].			self structureResultAtAddress: pcbSize put: resultValue].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeIsDirty: this	" Private - invoke the IPersistStream::IsDirty function for an external caller. "	" HRESULT IsDirty( void);"	^[   " terminate exception stack unwind at external callin boundary "	 implementor IsDirty.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeLoad: this _: pStm	" Private - invoke the IPersistStream::Load function for an external caller. "	" HRESULT Load(            /* [unique][in] */ IStream *pStm); "	^[   " terminate exception stack unwind at external callin boundary "	| anIStream |	self reportExternalFunctionEntry.	pStm isValid		ifFalse: [ ^E_INVALIDARG ].	anIStream := self interfaceAtAddress: pStm		type: IStream.	implementor Load: anIStream.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeSave: this _: pStm _: fClearDirty	" Private - invoke the IPersistStream::Save function for an external caller. "	" HRESULT Save(            /* [unique][in] */ IStream *pStm,        	/* [in] */ BOOL fClearDirty); "	^[   " terminate exception stack unwind at external callin boundary "	| anIStream |	self reportExternalFunctionEntry.	pStm isValid		ifFalse: [ ^E_INVALIDARG ].	anIStream := self interfaceAtAddress: pStm		type: IStream.	implementor Save: anIStream 		_: fClearDirty.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IPersistStreamImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistStream.	self vtableSignatureTypeName: #__IPersistStreamVtbl.	self updateAndRegister</body></methods><methods><class-id>External.COM_DVTARGETDEVICE</class-id> <category>accessing</category><body package="Com- Ole">deviceName		" Answer the device name. "	^self stringAtOffset: ( self memberAt: #tdDeviceNameOffset )</body><body package="Com- Ole">driverName		" Answer the driver name. "	^self stringAtOffset: ( self memberAt: #tdDriverNameOffset )</body><body package="Com- Ole">extDevMode		" Answer the DEVMODE. "	^self stringAtOffset: ( self memberAt: #tdExtDevmodeOffset )</body><body package="Com- Ole">portName		" Answer the port name. "	^self stringAtOffset: ( self memberAt: #tdPortNameOffset )</body></methods><methods><class-id>External.COM_DVTARGETDEVICE</class-id> <category>accessing-type information</category><body package="Com- Ole">sizeInBytes     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly. "	^self memberAt: #tdSize</body></methods><methods><class-id>External.COM_DVTARGETDEVICE class</class-id> <category>accessing-type information</category><body package="Com- Ole">fixedDataSizeInBytes     " Answer the size in bytes of the fixed data layout portion of the structure represented by instances of the receiver.   A DVTARGETDEVICE structure has a variable-length BYTE array data buffer as the last member of the structure. "	"^self baseCType sizeof - CIntegerType unsignedLong sizeof"	^12</body><body package="Com- Ole">sizeInBytes     " Answer the size in bytes of the structure represented by the receiver, including any padding required to make the structure tile correctly. "	self shouldNotImplement.  " depends on the size of the variable-length trailing data buffer "</body></methods><methods><class-id>External.COM_DVTARGETDEVICE class</class-id> <category>subclass-testing</category><body package="Com- Ole">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" a DVTARGETDEVICE structure cannot be allocated in fixed space because the DLLCC		compilation technology for the trailing array of BYTE data		appears to rest on the assumption that a pointer can be formed relative to the		base of the structure in order to access the array, which is only true when		the structure is itself a pointer into external memory "	^false</body></methods><methods><class-id>External.COM_DVTARGETDEVICE class</class-id> <category>instance creation</category><body package="Com- Ole">driverName: driverNameString 	deviceName: deviceNameString 	portName: portNameString	extDevMode: extDevMode		" Answer a new instance of the receiver with the specified values. "	Tools.Note notYetImplemented.</body></methods><methods><class-id>External.COM_DVTARGETDEVICE class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self structureName: #DVTARGETDEVICE.	self updateAndRegister</body></methods><methods><class-id>External.IRootStorage</class-id> <category>interface operations</category><body package="Com- Ole">switchToFile: aPathName		" Make a copy of the file underlying the IStorage in the file named &lt;aPathName&gt;.		Raise an exception if an error occurs.  Answer the result code. "	^interface SwitchToFile: aPathName</body></methods><methods><class-id>External.IRootStorage class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IRootStorage.	self updateAndRegister</body></methods><methods><class-id>External.IClassFactory</class-id> <category>accessing</category><body package="Com- Ole">clsid	" Answer the CLSID of the COM object class for which the receiver constructs object instances. "	^clsid</body><body package="Com- Ole">clsid: aCLSID	" Specify the CLSID of the COM object class for which the receiver constructs object instances. "	clsid := aCLSID.</body></methods><methods><class-id>External.IClassFactory</class-id> <category>interface operations</category><body package="Com- Ole">createInstance	" Create an uninitialized instance of the class manufactured by the receiver and answer its IUnknown interface. "	^self createInstance: IID_IUnknown controllingUnknown: nil</body><body package="Com- Ole">createInstance: anIID	" Create an uninitialized instance of the class manufactured by the receiver and answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	^self createInstance: anIID controllingUnknown: nil</body><body package="Com- Ole">createInstance: anIID controllingUnknown: controllingUnknown	" Create an uninitialized instance of the class manufactured by the receiver.  The object is created as an inner object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "    | resultReference |    resultReference := COMInterfaceValueReference forIID: anIID.    interface CreateInstance: controllingUnknown        _: anIID        _: resultReference.    ^resultReference value</body><body package="Com- Ole">lockServer	" Lock the object server application which supports the receiver. "	interface LockServer: true.</body><body package="Com- Ole">threadedCreateInstance: anIID	" Create an uninitialized instance of the class manufactured by the receiver and answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	self		deprecated: #(#initial '8.1' #use 'createInstance:options:' #sunset '8.2').	^self createInstanceWithOptions: ((COMCreationOptions new)				iid: anIID;				threaded: true;				yourself)</body><body package="Com- Ole">threadedCreateInstance: anIID controllingUnknown: controllingUnknown	" Create an uninitialized instance of the class manufactured by the receiver.  The object is created as an inner object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	self		deprecated: #(#initial '8.1' #use 'createInstance:options:' #sunset '8.2').	^self createInstanceWithOptions: ((COMCreationOptions new)				iid: anIID;				threaded: true;				controllingUnknown: controllingUnknown;				yourself)</body><body package="Com- Ole">unlockServer	" Unlock the object server application which supports the receiver. "	interface LockServer: false.</body></methods><methods><class-id>External.IClassFactory</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream	" Append a text description of the receiver to &lt;aStream&gt; "	super printOn: aStream.	clsid notNil		ifTrue: [ aStream nextPutAll: ' - CLSID ', clsid asString ].</body></methods><methods><class-id>External.IClassFactory</class-id> <category>private instance creation</category><body package="Com- Ole">privateCreateInstanceIID: anIID options: options result: resultReference	interface		CreateInstance: options controllingUnknown		_: anIID		_: resultReference</body></methods><methods><class-id>External.IClassFactory</class-id> <category>instance creation</category><body package="Com- Ole">createInstanceWithOptions: options	" Create an uninitialized instance of the class manufactured by the receiver.  The object is created as an inner object within an aggregate if the IUnknown of a controlling object is specified in &lt;options controllingUnknown&gt;.  Answer a single interface specified by the GUID &lt;options iid&gt; or an array of interfaces specified by&lt;options iids&gt;. The interface can be created threaded by setting &lt;options threaded&gt;. For IClassFactory2 instances it is possible to specify &lt;options licenseKey&gt;."	| iids firstInterface otherInterfaces resultReference creationBlock |	iids := self class decodeIIdsFromOptions: options clsidBlock: [self clsid].	resultReference := COMInterfaceValueReference forIID: iids first.	creationBlock :=			[self				privateCreateInstanceIID: iids first				options: options				result: resultReference].	options performInCorrectApartment: creationBlock.	firstInterface := resultReference value.	options hasMultipleIIDs ifFalse: [^firstInterface].	otherInterfaces := (iids allButFirst: 1) collect: 					[:iid |					options performInCorrectApartment: [firstInterface queryInterface: iid]].	^(Array with: firstInterface) , otherInterfaces</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>registration</category><body package="Com- Ole">registerClassObject: aCLSID unknown: anIUnknown classContext: classContext flags: flags	" Register the object identified by &lt;anIUnknown&gt; as the class factory for the CLSID specified by the GUID &lt;aCLSID&gt;.  The CLSCTX value &lt;classContext&gt; specifies the context in which the executable code is to be run.  The REGCLS value &lt;flags&gt; controls how connections are made to the class object.  Answer the registration token for the registered class factory. "	| resultReference |	resultReference := nil asValueReference.	COMThreadManager isActiveProcessAnMTAProcess		ifTrue: 			[COMDevelopmentWarning				raiseSignal: #RegisteringAClassFactoryInMTAMayFreezeImage &lt;&lt; #com						&gt;&gt; 'Registering a class factory in the MTA (multithreaded appartment) is assumed harmful and unnecessary.Com Call-Ins will not block the system. I will register the class factory in the STA instead.'].	COMThreadManager performInSTA: 			[OLEDLL current				CoRegisterClassObject: aCLSID				_: anIUnknown				_: classContext				_: flags				_: resultReference].	^resultReference value</body><body package="Com- Ole">revokeClassObject: registrationToken	" Notify COM that a class object previously registered with CoRegisterClassObject is no longer available. "	OLEDLL current CoRevokeClassObject: registrationToken.</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>utilities</category><body package="Com- Ole">getCLSID: aClassId	" Answer the CLSID of the COM object class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  Raise a COMError if &lt;aClassId&gt; is an invalid ProgID. "	| aCLSID |	aCLSID := aClassId asGUID.	" note that this can succeeds for GUID values which are not registered CLSID's... "	aCLSID isNil ifTrue: [COMError hresult: CO_E_CLASSSTRING].	^aCLSID</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IClassFactory.	self updateAndRegister</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>deprecated-object creation</category><body package="Com- Ole">createInstance: aClassId context: classExecutionContext	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	^self createInstanceWithOptions: (COMCreationOptions				clsid: aClassId				iid: IID_IUnknown				context: classExecutionContext)</body><body package="Com- Ole">createInstance: aClassId iid: anIID	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	^self createInstanceWithOptions: (COMCreationOptions				clsid: aClassId				iid: anIID				context: CLSCTX_ALL)</body><body package="Com- Ole">createInstance: aClassId iid: anIID context: classExecutionContext	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	^self createInstanceWithOptions: (COMCreationOptions				clsid: aClassId				iid: anIID				context: classExecutionContext)</body><body package="Com- Ole">createInstance: aClassId iid: anIID controllingUnknown: controllingUnknown	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	| options |	self		deprecated: #(#version '8.1' #sunset '8.2' #use #createInstanceWithOptions:).	options := (COMCreationOptions new)				clsid: aClassId;				iid: anIID;				context: CLSCTX_ALL;				controllingUnknown: controllingUnknown;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Ole">createInstance: aClassId iid: anIIDOrSymbol controllingUnknown: controllingUnknown context: classExecutionContext	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	| options |	self		deprecated: #(#version '8.1' #sunset '8.2' #use #createInstanceWithOptions:).	options := (COMCreationOptions new)				clsid: aClassId;				iid: anIIDOrSymbol;				context: classExecutionContext;				controllingUnknown: controllingUnknown;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Ole">createInstance: aClassId iids: anIIDArray controllingUnknown: controllingUnknown context: classExecutionContext serverName: serverName	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID, on the remote server machine named &lt;serverName&gt;.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	| options |	self		deprecated: #(#version '8.1' #sunset '8.2' #use #createInstanceWithOptions:).	options := (COMCreationOptions new)				clsid: aClassId;				iids: anIIDArray;				context: classExecutionContext;				controllingUnknown: controllingUnknown;				serverName: serverName;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Ole">threadedCreateInstance: aClassId	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  Answer the IUnknown interface of the new object. "	| options |	self		deprecated: #(#version '8.1' #sunset '8.2' #use #createInstanceWithOptions:).	options := (COMCreationOptions new)				clsid: aClassId;				iid: IID_IUnknown;				context: CLSCTX_ALL;				threaded: true;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Ole">threadedCreateInstance: aClassId iid: anIID	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	| options |	self		deprecated: #(#version '8.1' #sunset '8.2' #use #createInstanceWithOptions:).	options := (COMCreationOptions new)				clsid: aClassId;				iid: anIID;				context: CLSCTX_ALL;				threaded: true;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Ole">threadedCreateInstance: aClassId iid: anIID context: classExecutionContext	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	| options |	self		deprecated: #(#version '8.1' #sunset '8.2' #use #createInstanceWithOptions:).	options := (COMCreationOptions new)				clsid: aClassId;				iid: anIID;				context: classExecutionContext;				threaded: true;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Ole">threadedCreateInstance: aClassId iid: anIID controllingUnknown: controllingUnknown context: classExecutionContext	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	| options |	self		deprecated: #(#version '8.1' #sunset '8.2' #use #createInstanceWithOptions:).	options := (COMCreationOptions new)				clsid: aClassId;				iid: anIID;				context: classExecutionContext;				controllingUnknown: controllingUnknown;				threaded: true;				yourself.	^self createInstanceWithOptions: options</body><body package="Com- Ole">threadedCreateInstance: aClassId iids: anIIDArray controllingUnknown: controllingUnknown context: classExecutionContext serverName: serverName	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID, on the remote server machine named &lt;serverName&gt;.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;controllingUnknown&gt;.  Answer the interface specified by the GUID &lt;anIID&gt; of the new object. "	| options |	self		deprecated: #(#version '8.1' #sunset '8.2' #use #createInstanceWithOptions:).	options := (COMCreationOptions new)				clsid: aClassId;				iids: anIIDArray;				context: classExecutionContext;				controllingUnknown: controllingUnknown;				threaded: true;				yourself.	^self createInstanceWithOptions: options</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>instance creation</category><body package="Com- Ole">forCLSID: aClassId	"Answer a new instance of the receiver for the class factory object of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID. "	^self forOptions: ((COMCreationOptions newForVTable)				clsid: aClassId;				context: CLSCTX_ALL;				yourself)</body><body package="Com- Ole">forCLSID: aClassId context: aContext	"Answer a new instance of the receiver for the class factory object of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID. "	^self forOptions: ((COMCreationOptions newForVTable)				clsid: aClassId;				context: aContext;				yourself)</body><body package="Com- Ole">forCLSID: aClassId context: aContext serverName: serverName	"Answer a new instance of the receiver for the class factory object of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID, on the remote server machine named &lt;serverName&gt;. "	^self forOptions: (COMCreationOptions new				clsid: aClassId;				context: aContext;				serverName: serverName;				yourself)</body><body package="Com- Ole">forCLSID: aClassId serverName: serverName	"Answer a new instance of the receiver for the class factory object of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID, on the remote server machine named &lt;serverName&gt;. "	^self forOptions: ((COMCreationOptions newForVTable)				clsid: aClassId;				context: CLSCTX_ALL;				serverName: serverName;				yourself)</body><body package="Com- Ole">forOptions: options	"Answer a new instance of the receiver for the class factory object of the COM class specified by &lt;options clsid&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID, on the remote server machine named &lt;options serverName&gt;. &lt;options context&gt;, &lt;options platform&gt; and &lt;options threaded&gt; specify the kind of classfactory and where it is created. "	| aCLSID resultReference context creationBlock result |	aCLSID := self getCLSID: options clsid.	resultReference := self new asValueReference.	context := options context ifNil: [CLSCTX_ALL].	context := context bitOr: options platformContextFlags.	context := COMExternalInterface asClassContextParameter: context.	creationBlock :=			[OLEDLL current				CoGetClassObject: aCLSID				_: context				_: options serverName				_: self iid				_: resultReference].	options threaded		ifTrue: [COMThreadManager performInMTA: creationBlock]		ifFalse: [creationBlock value].	result := resultReference value.	result ifNotNil: [result clsid: aCLSID].	^result</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>private</category><body package="Com- Ole">contextFlagsForPlatform:  platform	platform ifNil: [ ^ 0 ].	platform = #win32 ifTrue: [^ CLSCTX_ACTIVATE_32_BIT_SERVER].	platform = #win64 ifTrue: [^ CLSCTX_ACTIVATE_64_BIT_SERVER].	^ self error: #UnknownPlatform &lt;&lt; #com &gt;&gt; 'Unknown platform'.</body><body package="Com- Ole">factoryClassWithLicensingSupport	^ FactoryClassWithLicensingSupport</body><body package="Com- Ole">factoryClassWithLicensingSupport: aClass	FactoryClassWithLicensingSupport := aClass.</body></methods><methods><class-id>External.IClassFactory class</class-id> <category>object creation</category><body package="Com- Ole">createInstance: aClassId	" Create a new instance of the COM class specified by &lt;aClassId&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID.  Answer the IUnknown interface of the new object. "	^self createInstanceWithOptions: (COMCreationOptions				clsid: aClassId				iid: IID_IUnknown				context: CLSCTX_ALL)</body><body package="Com- Ole">createInstanceWithOptions: options	" Create a new instance of the COM class specified by &lt;options clsid&gt;, which can be a CLSID GUID, a ProgID string, or the display string reprentation of a CLSID, on the remote server machine named &lt;options serverName&gt;.  The object is created as a non-control object within an aggregate if the IUnknown of a controlling object is specified in &lt;options controllingUnknown&gt;.  Answer the interface(s) specified by either one GUID in &lt;options iid&gt; or an Array of GUIDs in &lt;options iids&gt;. Set &lt;options threaded&gt; to specify that the object shall be created in the Mulit Threaded Apartment (MTA). Use &lt;option platform&gt; to force the creation of an object on a 32/64 bit server."	| factory |	factory := self factoryForOptions: options.	^ [ factory createInstanceWithOptions: options ] ensure: [ factory enforceRelease]</body><body package="Com- Ole">factoryForOptions: creationOptions	| factoryClass |	factoryClass := creationOptions containsLicenseKey				ifTrue: [self factoryClassWithLicensingSupport]				ifFalse: [IClassFactory].	^factoryClass forOptions: creationOptions</body></methods><methods><class-id>External.COMInterfacePointerResultBuffer</class-id> <category>private-accessing</category><body package="Com- Ole">iid: anIID	" Private - specify the IID to apply to the interface pointer which is instantiated from the buffer contents. "	iid := anIID.</body><body package="Com- Ole">interfaceDescription	" Private "	^iid isNil		ifTrue: [ interfacePointerClass name ]		ifFalse: [ interfacePointerClass name, ' ', iid asString ]</body><body package="Com- Ole">interfacePointerClass: anInterfacePointerClass	" Private - specify the interface pointer class to instantiate from the buffer contents. "	interfacePointerClass := anInterfacePointerClass.</body></methods><methods><class-id>External.COMInterfacePointerResultBuffer</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	interfacePointerClass notNil		ifTrue: [ 			aStream nextPutAll: ' ('.			buffer isNil  " already brought result value back in "				ifTrue: [ value printOn: aStream ]				ifFalse: [ aStream nextPutAll: 'for ', self interfaceDescription ].			aStream nextPutAll: ')' ].</body></methods><methods><class-id>External.COMInterfacePointerResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Ole">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^COMInterfacePointer baseCType</body></methods><methods><class-id>External.COMInterfacePointerResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Ole">getResultValue	" Private - convert the interface buffer contents into a real interface pointer.  Answer the value. "	| lpInterfacePointer anInterfacePointer |	lpInterfacePointer := buffer contents.	lpInterfacePointer isNull		ifTrue: [ ^nil ].	anInterfacePointer := ( iid isNil		ifTrue: [ interfacePointerClass fromReturnValue: lpInterfacePointer ]		ifFalse: [ interfacePointerClass fromReturnValue: lpInterfacePointer iid: iid ] ).	"Assert isTrue: [ anInterfacePointer hasFinalization ]."  " we acquire ownership as resources enter the system here "	^anInterfacePointer</body></methods><methods><class-id>External.COMInterfacePointerResultBuffer class</class-id> <category>instance creation</category><body package="Com- Ole">for: anInterfacePointerClass	" Answer a new instance of the receiver which is used for bringing an interface pointer value into the system in order to construct an instance of &lt;anInterfacePointerClass&gt;. "	^self basicNew		interfacePointerClass: anInterfacePointerClass;		initialize;		yourself</body><body package="Com- Ole">for: anInterfacePointerClass iid: anIID	" Answer a new instance of the receiver which is used for bringing an interface pointer value into the system in order to construct an instance of &lt;anInterfacePointerClass&gt; with its IID value set to the GUID &lt;anIID&gt;. "	^self basicNew		interfacePointerClass: anInterfacePointerClass;		iid: anIID;		initialize;		yourself</body><body package="Com- Ole">new	" Answer a new instance of the receiver. "	" an interface buffer should only be constructed for obtaining the value of a specific interface pointer. "	self shouldNotImplement.</body></methods><methods><class-id>External.IDataObjectPointer</class-id> <category>interface operations</category><body package="Com- Ole">DAdvise: aFormatEtc _: advf _: anAdviseSink _: resultReference		" Invoke the IDataObject::DAdvise function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer dwConnection |	resultBuffer := COMExternalInterface scalarResultBufferFor: #DWORD.	hresult := self invokeDAdvise: aFormatEtc asPointerParameter		_: advf 		_: anAdviseSink asPointerParameter 		_: resultBuffer asPointerParameter.	( dwConnection := resultBuffer contents ) ~= 0		ifTrue: [ resultReference value: dwConnection ].	^hresult</body><body package="Com- Ole">EnumDAdvise: resultReference		" Invoke the IDataObject::EnumDAdvise function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumSTATDATA.	hresult := self invokeEnumDAdvise: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">EnumFormatEtc: aDataDirection _: resultReference		" Invoke the IDataObject::EnumFormatEtc function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumFORMATETC.	hresult := self invokeEnumFormatEtc: aDataDirection		 _: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">GetCanonicalFormatEtc: aFormatEtc _: resultReference        " Invoke the IDataObject::GetCanonicalFormatEtc function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult outFormat |	outFormat := COM_FORMATETC newExternalStructure.	hresult := self invokeGetCanonicalFormatEtc: aFormatEtc asPointerParameter		_: outFormat asPointerParameter.	resultReference value: ( hresult = DATA_S_SAMEFORMATETC		ifTrue: [ aFormatEtc ]		ifFalse: [ outFormat ] ).	^hresult</body><body package="Com- Ole">GetData: aFormatEtc _: resultReference        " Invoke the IDataObject::GetData function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMStructure resultValueBufferFor: #STGMEDIUM.	hresult := self invokeGetData: aFormatEtc asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">GetDataHere: aFormatEtc _: aStgMedium		" Invoke the IDataObject::GetDataHere function.		Raise an exception if an error occurs.  Answer the result code. "	COMExternalInterface checkInOutStructureParameter: aStgMedium.	^self invokeGetDataHere: aFormatEtc asPointerParameter		_: aStgMedium asPointerParameter</body><body package="Com- Ole">QueryGetData: aFormatEtc		" Invoke the IDataObject::QueryGetData function.		Raise an exception if an error occurs.  Answer the result code. "    ^self invokeQueryGetData: aFormatEtc asPointerParameter</body><body package="Com- Ole">SetData: aFormatEtc _: aStgMedium _: fRelease		" Invoke the IDataObject::SetData function.		Raise an exception if an error occurs.  Answer the result code. "    ^self invokeSetData: aFormatEtc asPointerParameter        _: aStgMedium asPointerParameter        _: fRelease</body></methods><methods><class-id>External.IDataObjectPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IDataObject.	self updateAndRegister</body></methods><methods><class-id>External.GlobalInterfaceTable</class-id> <category>private</category><body package="Com- Ole">releaseCookie: aCookie	^COMThreadManager		performInSTA: [self staInstance revokeInterfaceFromGlobal: aCookie handle]</body><body package="Com- Ole">retrieveInterface: cookie from: tableInterface	^tableInterface getInterfaceFromGlobal: cookie handle with: cookie iid</body><body package="Com- Ole">storeInterface: anInterface on: tableInterface	^(tableInterface registerInterfaceInGlobal: anInterface)		ifNotNil: [:handle | GITCookie iid: anInterface iid handle: handle]</body></methods><methods><class-id>External.GlobalInterfaceTable</class-id> <category>initialize-release</category><body package="Com- Ole">initializeMtaInstance	mtaInstance := IClassFactory				threadedCreateInstance: CLSID_StdGlobalInterfaceTable				iid: IID_IGlobalInterfaceTable.	"Hide the interface from users"	mtaInstance interfaceBinding doesNotNeedFinalization.	^mtaInstance</body><body package="Com- Ole">initializeStaInstance	staInstance := COMThreadManager performInSTA: 					[IClassFactory createInstance: CLSID_StdGlobalInterfaceTable						iid: IID_IGlobalInterfaceTable].	"Hide the interface from users"	staInstance interfaceBinding doesNotNeedFinalization.	^ staInstance</body><body package="Com- Ole">release	staInstance		ifNotNil: 			[staInstance enforceRelease.			staInstance := nil].	mtaInstance		ifNotNil: 			[mtaInstance enforceRelease.			mtaInstance := nil]</body></methods><methods><class-id>External.GlobalInterfaceTable</class-id> <category>accessing</category><body package="Com- Ole">mtaInstance	^mtaInstance ifNil: [self initializeMtaInstance]</body><body package="Com- Ole">staInstance	^staInstance ifNil: [self initializeStaInstance]</body></methods><methods><class-id>External.GlobalInterfaceTable</class-id> <category>marshaling</category><body package="Com- Ole">marshalToMTA: anInterface	| cookie |	anInterface isMTAObject ifTrue: [^anInterface].	cookie := COMThreadManager				performInSTA: [self storeInterface: anInterface on: self staInstance].	^	[COMThreadManager		performInMTA: [self retrieveInterface: cookie from: self mtaInstance]]			ensure: [self releaseCookie: cookie]</body><body package="Com- Ole">marshalToSTA: anInterface	| cookie |	anInterface isSTAObject ifTrue: [^anInterface].	cookie := COMThreadManager				performInMTA: [self storeInterface: anInterface on: self mtaInstance].	^	[COMThreadManager		performInSTA: [self retrieveInterface: cookie from: self staInstance]]			ensure: [self releaseCookie: cookie]</body></methods><methods><class-id>External.GlobalInterfaceTable class</class-id> <category>accessing</category><body package="Com- Ole">current	^Current ifNil: [Current := self new]</body></methods><methods><class-id>External.GlobalInterfaceTable class</class-id> <category>initialize-release</category><body package="Com- Ole">release	Current		ifNotNil: 			[Current release.			Current := nil]</body></methods><methods><class-id>External.GlobalInterfaceTable class</class-id> <category>binary storage</category><body package="Com- Ole">reset	Current := nil.</body></methods><methods><class-id>External.GlobalInterfaceTable class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	COMSystem current when: #coreStartupCompleted send: #reset to: self.	COMSystem current when: #aboutToSave send: #release to: self.</body></methods><methods><class-id>External.COM_FORMATETC</class-id> <category>printing</category><body package="Com- Ole">formatDescription	" Answer a string description of the transfer format. "	^self class formatDescriptionOf: ( self structure memberAt: #cfFormat )</body><body package="Com- Ole">mediumDescription	" Answer a string description of the transfer medium. "	^COM_STGMEDIUM mediumDescriptionOf: ( self memberAt: #tymed )</body><body package="Com- Ole">printOn: aStream        "Append the ASCII representation of the receiver         to aStream. "	super printOn: aStream.	self isValid		ifFalse: [ ^self ].	aStream 		nextPutAll: ' ( '; 		nextPutAll: self formatDescription;		nextPutAll: ', medium: ';		nextPutAll: self mediumDescription;		nextPutAll: ' )'.</body></methods><methods><class-id>External.COM_FORMATETC</class-id> <category>accessing</category><body package="Com- Ole">dvTargetDevice	" Answer the DVTARGETDEVICE. "	| aPointer |	( aPointer := self memberAt: # ptd ) isNull		ifTrue: [ ^nil ].	^COMStructure createStructureNamed: #DVTARGETDEVICE		atAddress: aPointer</body></methods><methods><class-id>External.COM_FORMATETC</class-id> <category>copying</category><body package="Com- Ole">deepCopy        "Answer a copy of the receiver with shallow           copies of each instance variable."  	Tools.Note portingPatch.  " Bring in VS protocol temporarily.  Need to look		at copying more generally and probably do something		in OLEStructure itself.  [DL 19-May-96] "	"VS was: ^self objectDeepCopy"	Assert isTrue: [ self isInExternalMemory not ].	^self class temporaryOn: self structure shallowCopy</body></methods><methods><class-id>External.COM_FORMATETC</class-id> <category>comparing</category><body package="Com- Ole">sameAs: aFormatEtc	" Answer whether the receiver and &lt;aFormatEtc&gt; have the same transfer format and aspect. "	^(self sameFormatAs: aFormatEtc) and: 			[(self memberAt: #dwAspect) = (aFormatEtc memberAt: #dwAspect)				and: [(self memberAt: #lindex) = (aFormatEtc memberAt: #lindex)]]</body><body package="Com- Ole">sameFormatAs: aFormatEtc	" Answer whether the receiver and &lt;aFormatEtc&gt; have the same transfer format. "	^(self memberAt: #cfFormat) = (aFormatEtc memberAt: #cfFormat)		and: [((self memberAt: #tymed) bitAnd: (aFormatEtc memberAt: #tymed)) ~= 0]</body></methods><methods><class-id>External.COM_FORMATETC class</class-id> <category>instance creation</category><body package="Com- Ole">format: cfFormat 	" Answer a default FORMATETC with the specified clipboard format and medium. "	| tymed |	tymed := COMDataRendering defaultMediumFor: cfFormat.	(tymed isNil) ifTrue: [			COMError raiseSignal: (#ErrNamedNoMedium &lt;&lt; #com 						&gt;&gt; 'no medium for format named &lt;1p&gt;' 							expandMacrosWith: (COMDataRendering getFormatName: cfFormat))].	^self format: cfFormat medium: tymed</body><body package="Com- Ole">format: cfFormat medium: tymed	" Answer a default FORMATETC with the specified clipboard format and medium. "	^self new		memberAt: #cfFormat put: cfFormat;		memberAt: #ptd put: nil;  " added per VW/OLE alpha #setDefFormatEtc: "		memberAt: #dwAspect put: DVASPECT_CONTENT;		memberAt: #tymed put: tymed;		memberAt: #lindex put: -1;		yourself</body><body package="Com- Ole">formatNULL	" Answer a new default FORMATETC with NULL format and medium "	^self format: CF_NULL medium: TYMED_NULL</body><body package="Com- Ole">formatNamed: aFormatName	" Answer a default FORMATETC with the format whose String name is &lt;aFormatName&gt; "	| cfFormat tymed |	cfFormat := COMDataRendering formatNamed: aFormatName.	cfFormat isNil		ifTrue: [ COMError raiseSignal: (#ErrNamedNoFormat &lt;&lt; #com &gt;&gt;  'unsupported format named &lt;1p&gt;' expandMacrosWith: aFormatName)].	tymed := COMDataRendering defaultMediumFor: cfFormat.	tymed isNil		ifTrue: [ COMError raiseSignal: (#ErrNamedNoMedium &lt;&lt; #com &gt;&gt; 'no medium for format named &lt;1p&gt;' expandMacrosWith: aFormatName)].	^self format: cfFormat medium: tymed</body></methods><methods><class-id>External.COM_FORMATETC class</class-id> <category>accessing</category><body package="Com- Ole">enumeratorIID	" Answer the IID of the interface which enumerates collections containing instances of the receiver. "	^IID_IEnumFORMATETC</body></methods><methods><class-id>External.COM_FORMATETC class</class-id> <category>subclass-testing</category><body package="Com- Ole">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	Tools.Note ISSUE.  " Various things start to break when this guy is allocated off the heap		(enumerator, probably just a bug/oversight that needs to be fixed).		Anyway, insist on an internal byte buffer for these guys,		at least for a while anyway.  [DL 14-May-97] "	^true</body></methods><methods><class-id>External.COM_FORMATETC class</class-id> <category>description services</category><body package="Com- Ole">formatDescriptionOf: cfFormat	" Answer a string description of the transfer format &lt;cfFormat&gt;. "	| descriptions userFormatName |	descriptions := Dictionary new		at: CF_BITMAP put: 'bitmap';		at: CF_DIB put: 'DIB';	"Maybe add additional descriptions someday:		at: CfDif put: 'XXX';		at: CfDspbitmap put: 'XXX';		at: CfDspmetafilepict put: 'XXX';		at: CfDsptext put: 'XXX';		at: CfGdiobjfirst put: 'XXX';		at: CfGdiobjlast put: 'XXX';	"		at: CF_METAFILEPICT put: 'Metafile';		at: CF_OEMTEXT put: 'OEM text';		at: CF_OWNERDISPLAY put: 'ownerDisplay';	"Maybe add additional descriptions someday:		at: CfPalette put: 'XXX';		at: CfSylk put: 'XXX';	"		at: CF_TEXT put: 'string';		at: CF_TIFF put: 'TIFF';		yourself.	^descriptions at: cfFormat 		ifAbsent: [ 			( userFormatName := Win32ClipboardInterface current getFormatName: cfFormat ) == nil				ifTrue: [ '( unknown format ', cfFormat printString, ' )' ]				ifFalse: [ userFormatName ] ]</body></methods><methods><class-id>External.COM_FORMATETC class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self structureName: #FORMATETC.	self updateAndRegister</body></methods><methods><class-id>External.IAnonymousPointer</class-id> <category>identity</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid</body><body package="Com- Ole">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;. "	"Assert isTrue: [ self iid isNil or: [ self iid = anIID ] ]."	iid := anIID.</body></methods><methods><class-id>External.IAnonymousPointer class</class-id> <category>instance creation</category><body package="Com- Ole">forIID: anIID	" Answer a new instance of the receiver for the interface specified by &lt;anIID&gt;. "	^self new		iid: anIID;		yourself</body></methods><methods><class-id>External.IAnonymousPointer class</class-id> <category>subclass-accessing</category><body package="Com- Ole">interfaceReferenceClass	" Private - answer the COM interface class that references instance of the receiver. "	^IAnonymous</body><body package="Com- Ole">vtableSignatureType	" Private - answer the structure definition for the receiver's interface VTable. "	^IUnknownPointer vtableSignatureType</body></methods><methods><class-id>External.IAnonymousPointer class</class-id> <category>external-transformations</category><body package="Com- Ole">resultValueArrayBuffer: count	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an array of &lt;count&gt; instances of the receiver.  The caller must send #asPointerParameter to the buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value.  The returned interface pointers become the responsibility of the caller, who must release them when done, in the usual fashion. "	self shouldNotImplement.  " you need to specify IID in order to instantiate an anonymous interface pointer "</body></methods><methods><class-id>External.IAnonymousPointer class</class-id> <category>identity</category><body package="Com- Ole">supportsIID: aGUID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^false</body></methods><methods><class-id>External.IAnonymousPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IAnonymous.	" private internal IID for cross-referencing.		IAnonymous does not represent any specific interface "	self updateAndRegister</body></methods><methods><class-id>External.COMWorkerProcess</class-id> <category>initialize-release</category><body package="Com- Ole">initialize	startSemaphore := Semaphore new.	endSemaphore := Semaphore new.	workerProcess := 			[[			[startSemaphore wait.			self doWork.			endSemaphore signal] repeat]				on: Process terminateSignal				do: 					[:ex |					myException := ex.					endSemaphore signal]]					fork</body><body package="Com- Ole">initializeMta	self initialize.	[workerProcess attachToThread] on: Error		do: 			[:ex |			^self				error: #CouldNotAttachToThread &lt;&lt; #com &gt;&gt; 'Could not attach to thread'].	workerProcess beComMtaProcess.	[self evaluate: [OLEDLL current CoInitializeWorkerThread]] on: Error		do: 			[:ex |			^self error: #CouldNotInitializeWorkerProcess &lt;&lt; #com						&gt;&gt; 'Could not initialize worker process'].	^self</body><body package="Com- Ole">reset	| isMTAProcess |	isMTAProcess := self isComMtaProcess.	self kill.	isMTAProcess ifTrue: [self initializeMta] ifFalse: [self initialize].	self resetExecutionVariables</body><body package="Com- Ole">resetExecutionVariables	resultValue := nil.	myException := nil.	workBlock := nil</body></methods><methods><class-id>External.COMWorkerProcess</class-id> <category>private</category><body package="Com- Ole">analyseResult	| result exception |	exception := myException ifNotNil: [:ex | ex copyForReraise].	result := resultValue.	self releaseTemporaries.	^exception		ifNil: [result]		ifNotNil: 			[exception				searchFrom: thisContext;				raise]</body><body package="Com- Ole">attachToThread	workerProcess attachToThread.</body><body package="Com- Ole">detachFromThread	workerProcess detachFromThread.</body><body package="Com- Ole">doWork	resultValue := [workBlock value] on: Error				do: 					[:ex |					myException := ex.					ex return: nil]</body><body package="Com- Ole">kill	self isComMtaProcess		ifTrue: 			[[workerProcess interruptWith: [OLEDLL current CoUninitializeThreaded]]				on: Error				do: [:ex | ].			[workerProcess detachFromThread] on: Error do: [:ex | ]].	[workerProcess terminate] on: Error do: [:ex | ]</body><body package="Com- Ole">release	self isComMtaProcess ifTrue: [ 		self evaluate: [ OLEDLL current CoUninitializeThreaded ]. 		workerProcess detachFromThread ].	workerProcess terminate.</body><body package="Com- Ole">releaseTemporaries	workBlock := nil.	resultValue := nil.	myException := nil.</body></methods><methods><class-id>External.COMWorkerProcess</class-id> <category>testing</category><body package="Com- Ole">isComMtaProcess 	^ workerProcess isComMtaProcess</body></methods><methods><class-id>External.COMWorkerProcess</class-id> <category>performing</category><body package="Com- Ole">evaluate: aBlock	^ self evaluate: aBlock atPriority: Processor activeProcess priority</body><body package="Com- Ole">evaluate: aBlock atPriority: aPriority	self resetExecutionVariables.	workBlock := aBlock.	workerProcess priority: aPriority.	"signal the semaphore wich starts the processing"		[startSemaphore signal.	"wait for the processing to be finished"	endSemaphore wait]			ifCurtailed: [self reset].	^self analyseResult</body></methods><methods><class-id>External.COMWorkerProcess class</class-id> <category>instance creation</category><body package="Com- Ole">new	^super new initialize</body><body package="Com- Ole">newMtaProcess	^super new initializeMta</body><body package="Com- Ole">newStaProcess	^ self new</body></methods><methods><class-id>External.COMExternalAccessFailed</class-id> <category>private-defaults</category><body package="Com- Ole">defaultAction	ImageConfiguration errorNotifierClass notify: self context: thisContext sender</body></methods><methods><class-id>External.IStreamPointer</class-id> <category>interface operations</category><body package="Com- Ole">Clone: resultReference		" Invoke the IStream::Clone function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IStreamPointer resultValueBuffer.	hresult := self invokeClone: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">CopyTo: destStream _: cb _: cbReadReference _: cbWrittenReference		" Invoke the IStream::CopyTo function.		Raise an exception if an error occurs.  Answer the result code. "	| cbBuffer cbReadBuffer cbWrittenBuffer hresult |	cbBuffer := ( cb isNil		ifTrue: [ Win32LargeInteger maxValueUnsigned ]		ifFalse: [ Win32LargeInteger fromUnsignedInteger: cb ] ).	cbReadReference notNil		ifTrue: [ cbReadBuffer := Win32LargeInteger forUnsignedReturnValue ].	cbWrittenReference notNil		ifTrue: [ cbWrittenBuffer := Win32LargeInteger forUnsignedReturnValue ].	hresult := self invokeCopyTo: destStream asPointerParameter		_: cbBuffer asStructureParameter		_: cbReadBuffer asPointerParameter		_: cbWrittenBuffer asPointerParameter.	cbReadReference notNil		ifTrue: [ cbReadReference value: cbReadBuffer asUnsignedInteger ].	cbWrittenReference notNil		ifTrue: [ cbWrittenReference value: cbWrittenBuffer asUnsignedInteger ].	^hresult</body><body package="Com- Ole">LockRegion: offset _: count _: lockType		" Invoke the IStream::LockRegion function.		Raise an exception if an error occurs.  Answer the result code. "	| libOffset cb |	libOffset := Win32LargeInteger fromUnsignedInteger: offset.	cb := Win32LargeInteger fromUnsignedInteger: count.	^self invokeLockRegion: libOffset asStructureParameter		_: cb asStructureParameter		_: lockType</body><body package="Com- Ole">Read: buffer _: cbBuffer _: resultReference 	" Invoke the IStream::Read function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult readBuffer cbReadBuffer cbRead |	buffer isExternalAddress 		ifTrue: [readBuffer := buffer]		ifFalse: 			[buffer class isBits 				ifFalse: 					[COMError 						raiseSignal: (#ErrNamedIStreamNotByte &lt;&lt; #com 								&gt;&gt; 'IStream buffer not a byte object: &lt;1s&gt;' 									expandMacrosWith: buffer class name)].			"Assert isTrue: [ buffer sizeInBytes = count ]."			buffer isFixedArgument 				ifTrue: [readBuffer := buffer]				ifFalse: 					["Maybe do:					readBuffer := ( Win32ExternalInterface allocateBuffersInFixedSpace						ifTrue: [ buffer class newInFixedSpace: cbBuffer ]						ifFalse: [ buffer class referentType gcMalloc: cbBuffer ].					"					COMError 						raiseSignal: (#ErrNamedIStreamMem &lt;&lt; #com 								&gt;&gt; 'IStream buffer not in stable memory: &lt;1s&gt;' 									expandMacrosWith: buffer class name)]].	cbReadBuffer := COMExternalInterface scalarResultBufferFor: #ULONG.	hresult := self 				invokeRead: readBuffer asPointerParameter				_: cbBuffer				_: cbReadBuffer asPointerParameter.	cbRead := cbReadBuffer contents.	"Assert isTrue: [ cbRead &lt;= cbBuffer ]."	"future:	readBuffer ~~ buffer		ifTrue: [ 			readBuffer copyAt: 0				to: buffer				size: cbRead				startingAt: 1 ].	"	resultReference notNil ifTrue: [resultReference value: cbRead].	"future: ] ensure: [ readBuffer ~~ buffer ifTrue: [ readBuffer free ] ]."	^hresult</body><body package="Com- Ole">Seek: displacement _: dwOrigin _: resultReference		" Invoke the IStream::Seek function.		Raise an exception if an error occurs.  Answer the result code. "	| dlibMove resultBuffer hresult |	dlibMove := Win32LargeInteger fromSignedInteger: displacement.	resultReference notNil 		ifTrue: [ resultBuffer := Win32LargeInteger forUnsignedReturnValue ].	hresult := self invokeSeek: dlibMove asStructureParameter		_: dwOrigin		_: resultBuffer asPointerParameter.	resultReference notNil		ifTrue: [ 	resultReference value: resultBuffer asUnsignedInteger ].	^hresult</body><body package="Com- Ole">SetSize: newSize		" Invoke the IStream::SetSize function.		Raise an exception if an error occurs.  Answer the result code. "	| cb |	cb := Win32LargeInteger fromUnsignedInteger: newSize.	^self invokeSetSize: cb asStructureParameter</body><body package="Com- Ole">Stat: resultReference _: grfStatFlag		" Invoke the IStream::Stat function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMStructure resultValueBufferFor: #STATSTG.	hresult :=  self invokeStat: resultBuffer asPointerParameter		_: grfStatFlag.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">UnlockRegion: offset _: count _: lockType		" Invoke the IStream::UnlockRegion function.		Raise an exception if an error occurs.  Answer the result code. "	| libOffset cb |	libOffset := Win32LargeInteger fromUnsignedInteger: offset.	cb := Win32LargeInteger fromUnsignedInteger: count.	^self  invokeUnlockRegion: libOffset asStructureParameter		_: cb asStructureParameter		_: lockType</body><body package="Com- Ole">Write: buffer _: count _: resultReference 	" Invoke the IStream::Write function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult writeBuffer cbWrittenBuffer |	buffer isExternalAddress 		ifTrue: [writeBuffer := buffer]		ifFalse: 			[buffer class isBits 				ifFalse: 					[COMError 						raiseSignal: (#ErrNamedIStreamNotByte &lt;&lt; #com 								&gt;&gt; 'IStream buffer not a byte object: &lt;1s&gt;' 									expandMacrosWith: buffer class name)].			"Assert isTrue: [ buffer sizeInBytes = count ]."			buffer isFixedArgument 				ifTrue: [writeBuffer := buffer]				ifFalse: 					["Maybe do:					writeBuffer := ( Win32ExternalInterface allocateBuffersInFixedSpace						ifTrue: [ buffer class newInFixedSpace: cbBuffer ]						ifFalse: [ buffer class referentType gcMalloc: cbBuffer ].					... and set the contents of the write buffer suitably ...					"					COMError 						raiseSignal: (#ErrNamedIStreamMem &lt;&lt; #com 								&gt;&gt; 'IStream buffer not in stable memory: &lt;1s&gt;' 									expandMacrosWith: buffer class name)]].	resultReference notNil 		ifTrue: 			[cbWrittenBuffer := COMExternalInterface scalarResultBufferFor: #ULONG].	hresult := self 				invokeWrite: writeBuffer asPointerParameter				_: count				_: cbWrittenBuffer asPointerParameter.	resultReference notNil 		ifTrue: [resultReference value: cbWrittenBuffer contents].	"future: ] ensure: [ writeBuffer ~~ buffer ifTrue: [ writeBuffer free ] ]."	^hresult</body></methods><methods><class-id>External.IStreamPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IStream.	self updateAndRegister</body></methods><methods><class-id>External.COMDataRendering</class-id> <category>accessing</category><body package="Com- Ole">formatEtc		" Answer the format of the rendering. "    ^formatEtc</body><body package="Com- Ole">formatEtc: anOLEFormatEtc		" Set the format of the rendering. "    formatEtc := anOLEFormatEtc</body><body package="Com- Ole">value	" Answer the value being rendering."	^value ifNil: [valueBlock value]</body><body package="Com- Ole">value: aValue	"Set the value to be rendered to &lt;aValue&gt;."	value := aValue.</body><body package="Com- Ole">valueBlock	^valueBlock</body><body package="Com- Ole">valueBlock: anObject	valueBlock := anObject</body></methods><methods><class-id>External.COMDataRendering</class-id> <category>comparing</category><body package="Com- Ole">sameFormatEtc: aFormatEtc	"Answer true if the receiver's FormatEtc has the same cfFormat, tymed, and dwAspect as aFormatEtc."	^formatEtc sameAs: aFormatEtc</body></methods><methods><class-id>External.COMDataRendering</class-id> <category>rendering</category><body package="Com- Ole">renderValueOntoMedium: aStgMedium        " Render the object onto &lt;aStgMedium&gt;. This is used by GetData:          and GetDataHere: to render data in object onto the specified 		 storage medium. "	| cfFormat aSelector |	cfFormat := formatEtc memberAt: #cfFormat.	aSelector := self class getRenderingOperationFor: cfFormat.	aSelector isNil		ifTrue: [ 			Tools.Note ISSUE.  "?? COMError hresult: DV_E_CLIPFORMAT ??"			^COMError raiseSignal: (#ErrNamedUnsupportFormat &lt;&lt; #com &gt;&gt; 'unsupported rendering format: &lt;1p&gt;' expandMacrosWith: cfFormat) ].	self perform: aSelector with: aStgMedium.	^aStgMedium</body></methods><methods><class-id>External.COMDataRendering</class-id> <category>private-rendering</category><body package="Com- Ole">renderBitmap: aStgMedium	" Private - render a string value onto &lt;aStgMedium&gt;. "	aStgMedium tymed: formatEtc tymed.	self value putBitmapIntoStgMedium: aStgMedium.</body><body package="Com- Ole">renderEnhancedMetafile: aStgMedium	" Private - render a string value onto &lt;aStgMedium&gt;. "	aStgMedium tymed: formatEtc tymed.	self value putEnhancedMetaFileDataIntoStgMedium: aStgMedium.</body><body package="Com- Ole">renderMetafile: aStgMedium	" Private - render a string value onto &lt;aStgMedium&gt;. "	aStgMedium tymed: formatEtc tymed.	self value putMetaFileDataIntoStgMedium: aStgMedium.</body><body package="Com- Ole">renderSmalltalkObject: aStgMedium	" Private - render an arbitrary Smalltalk object onto &lt;aStgMedium&gt;. "	| hGlobal |	hGlobal := Win32ClipboardInterface copySmalltalkObjectToGlobalMemory: self value.	Assert isEqual: formatEtc tymed to: TYMED_HGLOBAL.	aStgMedium tymed: formatEtc tymed.	aStgMedium hGlobal: hGlobal.</body><body package="Com- Ole">renderString: aStgMedium	" Private - render a string value onto &lt;aStgMedium&gt;. "	| hGlobal aValue |	aValue := self value.	aValue class isBits 		ifFalse: [ ^COMError raiseSignal: #ErrValueBeByte &lt;&lt; #com &gt;&gt; 'value must be a byte object' ].	Tools.Note ISSUE.  " Why the implementation descrepancy in the handling		of a FileName between OLERendering&gt;&gt;renderObject: 		and STGMEDIUM #format:data:?  [DL 11-Apr-96] "	hGlobal := Win32ClipboardInterface copyStringToGlobalMemory: aValue.	Assert isEqual: formatEtc tymed to: TYMED_HGLOBAL.	aStgMedium tymed: formatEtc tymed.	aStgMedium hGlobal: hGlobal.</body><body package="Com- Ole">renderUnicodeString: aStgMedium	" Private - render a string value onto &lt;aStgMedium&gt;. "	| hGlobal aValue |	aValue := self value.	aValue class isBits 		ifFalse: [ ^COMError raiseSignal: #ErrValueBeByte &lt;&lt; #com &gt;&gt; 'value must be a byte object' ].	Tools.Note ISSUE.  " Why the implementation descrepancy in the handling		of a FileName between OLERendering&gt;&gt;renderObject: 		and STGMEDIUM #format:data:?  [DL 11-Apr-96] "	hGlobal := Win32ClipboardInterface copyUnicodeStringToGlobalMemory: aValue.	Assert isEqual: formatEtc tymed to: TYMED_HGLOBAL.	aStgMedium tymed: formatEtc tymed.	aStgMedium hGlobal: hGlobal.</body></methods><methods><class-id>External.COMDataRendering</class-id> <category>releasing</category><body package="Com- Ole">release	"Release any resources associated with the receiver."	value := nil.	valueBlock := nil.	super release.</body></methods><methods><class-id>External.COMDataRendering class</class-id> <category>private-rendering</category><body package="Com- Ole">getFormatName: aCfFormat        "Answer the name of the clipboard format &lt;aCfFormat&gt;. "	^RenderingNameMap keyAtValue: aCfFormat ifAbsent: [nil ]</body><body package="Com- Ole">getRenderingOperationFor: aFormat	" Answer the operation to invoke when an object is to be rendering in &lt;aFormat&gt;. "	^RenderingActionMap at: ( self getFormatName: aFormat )		ifAbsent: [ nil ]</body><body package="Com- Ole">registerRenderingOperation: aOneArgSelector for: aFormatName format: aFormat medium: defaultMedium	" Register the operation to invoke when an object is to be rendered as &lt;aFormat&gt;. "	RenderingNameMap at: aFormatName		put: aFormat.	( Win32ClipboardInterface userFormats includesKey: aFormatName )		ifTrue: [ UserFormatNames add: aFormatName ].	RenderingActionMap at: aFormatName		put: aOneArgSelector.	RenderingMediumMap at: aFormatName		put: defaultMedium.</body></methods><methods><class-id>External.COMDataRendering class</class-id> <category>private-accessing</category><body package="Com- Ole">renderingActionMap	^RenderingActionMap</body><body package="Com- Ole">renderingMediumMap	^RenderingMediumMap</body><body package="Com- Ole">renderingNameMap	^RenderingNameMap</body></methods><methods><class-id>External.COMDataRendering class</class-id> <category>private-installation</category><body package="Com- Ole">ensureSmalltalkObjectRenderFormatIsRegistered		([self getRenderingOperationFor: IDataObject cfSmalltalkObject]		on: Error		do: [:ex | ex return: nil])		ifNil: [self registerSmalltalkObjectRenderFormat]</body><body package="Com- Ole">initializeRenderingMaps	" Private "		RenderingNameMap := Dictionary new.	UserFormatNames := Set new.	RenderingActionMap := Dictionary new.	RenderingMediumMap := Dictionary new.	self		registerRenderingOperation: #renderString:		for: IDataObject cfStringName		format: IDataObject cfString		medium: TYMED_HGLOBAL.	self		registerRenderingOperation: #renderUnicodeString:		for: IDataObject cfUnicodeStringName		format: IDataObject cfUnicodeString		medium: TYMED_HGLOBAL.	Tools.Note ISSUEin72.	"Operation not defined for Metafilepict"	self		registerRenderingOperation: #renderMetafile:		for: IDataObject cfMetafilePictName		format: IDataObject cfMetafilePict		medium: TYMED_MFPICT.	self registerRenderingOperation: #renderEnhancedMetafile:		for: IDataObject cfEnhancedMetafilePictName		format: IDataObject cfEnhMetafilePict		medium:TYMED_ENHMF.	self registerRenderingOperation: #renderBitmap:		for: IDataObject cfBitmapName		format: IDataObject cfBitmap		medium:TYMED_GDI.	self registerRenderingOperation: #renderFilename:		for: IDataObject cfFilename		format: IDataObject cfFilename		medium: IDataObject cfFilenameNameMedium.	(HostInterface isWindows or: [HostInterface isWindowsNT]) ifTrue: [		self registerSmalltalkObjectRenderFormat ].</body><body package="Com- Ole">obsolete	"The receiver was removed from the system and is now obsolete. 	Perform any necessary clean-up. Answer the receiver."	self removeSessionEventHandlers.	^super obsolete</body><body package="Com- Ole">registerSessionEventHandlers	" Private - register the image startup and shutdown event handlers. "	" COMDataRendering registerSessionEventHandlers "	COMSystem current when: #startupCompleted 		send: #startupImage to: self.</body><body package="Com- Ole">registerSmalltalkObjectRenderFormat		^self		registerRenderingOperation: #renderSmalltalkObject:		for: IDataObject cfSmalltalkObjectName		format: IDataObject cfSmalltalkObject		medium: TYMED_HGLOBAL</body><body package="Com- Ole">removeSessionEventHandlers	" Remove the image startup and shutdown event handlers. "	" COMDataRendering removeSessionEventHandlers "	COMSystem current removeAllActionsWithReceiver: self.</body></methods><methods><class-id>External.COMDataRendering class</class-id> <category>accessing</category><body package="Com- Ole">defaultMediumFor: aFormat        "Answer the default rendering medium for &lt;aFormat&gt;.  Answer nil if not supported. "	^RenderingMediumMap at: ( self getFormatName: aFormat )		ifAbsent: [ nil ].</body><body package="Com- Ole">formatNamed: aFormatName        "Answer the clipboard format named &lt;aFormatName&gt;.  Answer nil if not supported. "	| aFormat |	aFormat := RenderingNameMap at: aFormatName		ifAbsent: [ nil ].	aFormat isNil		ifTrue: [			| sameAsKey |			sameAsKey := RenderingNameMap keys detect: [ :fn | fn sameAs: aFormatName ]				ifNone: [ nil ].			sameAsKey notNil				ifTrue: [ aFormat := RenderingNameMap at: sameAsKey ] ].	^aFormat</body></methods><methods><class-id>External.COMDataRendering class</class-id> <category>instance creation</category><body package="Com- Ole">for: aValue formatEtc: aFormatEtc	" Create a new instance of the receiver for rendering &lt;aValue&gt; in the format specified by &lt;aFormatEtc&gt;. "    ^self new        formatEtc: aFormatEtc;        value: aValue;        yourself</body><body package="Com- Ole">forBlock: aValue formatEtc: aFormatEtc	" Create a new instance of the receiver for rendering &lt;aValue&gt; in the format specified by &lt;aFormatEtc&gt;. "    ^self new        formatEtc: aFormatEtc;        valueBlock: aValue;        yourself</body></methods><methods><class-id>External.COMDataRendering class</class-id> <category>private-session management</category><body package="Com- Ole">startupImage	" Private - the session is being started.  Reset the user-defined clipboard formats. "	(HostInterface isWindows or: [HostInterface isWindowsNT]) ifFalse: [^self].	self ensureSmalltalkObjectRenderFormatIsRegistered.	UserFormatNames do: [ :aFormatName |		| aFormat |		aFormat := Win32ClipboardInterface current formatNamed: aFormatName.		RenderingNameMap at: aFormatName put: aFormat ].</body></methods><methods><class-id>External.COMDataRendering class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self initializeRenderingMaps.	self registerSessionEventHandlers.</body></methods><methods><class-id>External.COMGlobalMemoryStream</class-id> <category>accessing</category><body package="Com- Ole">memoryAddress	" Answer the global memory address of the receiver. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current GetHGlobalFromStream: self 		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.COMGlobalMemoryStream</class-id> <category>converting</category><body package="Com- Ole">asByteArray	"Answer a ByteArray whose contents are the bytes of the receiver."	^( Win32MemoryReadWriteStream byteStreamOn: self memoryAddress )		contents"Implementation note:  The obvious implementation of this method is:    ^self asByteStream contentsThis implementation utilizes the existing facilities for obtaining the contents of a COM IStream, which indeed is used elsewhere on file-backed streams.  However, we encounter problems which we have not been able to track down whenreading large backing store contents from global memoryusing the COM-implemented IStream::Read operation.Extracting the bytes seems to work properly whenwe use our own memory stream accessing logic,however, so the alternate implementation using MemoryReadWriteStream is used in this method. "</body></methods><methods><class-id>External.COMGlobalMemoryStream class</class-id> <category>creating</category><body package="Com- Ole">createOnAddress: aGlobalMemoryAddress deleteOnRelease: deleteOnRelease	" Answer a new instance of the receiver which is an IStream  on &lt;aGlobalMemoryAddress&gt;.  If &lt;deleteOnRelease&gt; is set the memory will be released by COM when the stream is released. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current CreateStreamOnHGlobal: aGlobalMemoryAddress 		_: deleteOnRelease 		_: resultReference.	( deleteOnRelease 	and: [ aGlobalMemoryAddress isExternalAddress ] )		ifTrue: [ aGlobalMemoryAddress doesNotNeedFinalization ].	^resultReference value</body><body package="Com- Ole">newTemporaryBackingStore	" Create a temporary stream in global memory.  Answer a new instance of the receiver on the storage object.  The memory will be released when the stream is released. "	^self createOnAddress: nil deleteOnRelease: true</body></methods><methods><class-id>External.COMGlobalMemoryStream class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerIID	" Private - register the receiver as the interface class for its IID.  Do nothing for the receiver - its superclass IStream is correctly registered as the class for the (shared) IID. "</body><body package="Com- Ole">removeIID	" Private - remove the registration of the receiver as the interface class for its IID.  Do nothing for the receiver - its superclass IStream manages the registration for the (shared) IID. "</body></methods><methods><class-id>External.COMGlobalMemoryStream class</class-id> <category>opening</category><body package="Com- Ole">on: aByteObject	" Answer a new instance of the receiver which is an IStream on a newly allocated block of global memory whose contents are initialized with the data in &lt;aByteObject&gt;.  The memory will be released when the stream is released. "	| nBytes aGlobalAddress |	aByteObject class isBits		ifFalse: [ COMError raiseSignal: #ErrSourceBeByte &lt;&lt; #com &gt;&gt; 'source must be a byte object'  ].	aByteObject isString		ifTrue: [   " strings not yet supported (trailing null philosophy not yet specified) "			COMError raiseSignal: #ErrMustBeByteArray &lt;&lt; #com &gt;&gt; 'must be a ByteArray' ].	nBytes := aByteObject size.	Tools.Note ISSUE.  " Gary - please review the flags here, vs. what you did in storage.		This particular implementation was picked up from the VW/OLE prototype.		[Deb 08-Aug-96] "	aGlobalAddress := Win32GlobalMemoryAddress allocateMemory: nBytes		flags: ( GMEM_SHARE | GMEM_MOVEABLE | GMEM_DISCARDABLE ).			"?? or just do: Win32GlobalAddress copyToNonSmalltalkMemory: aByteObject ??"	aGlobalAddress replaceBytes: nBytes with: aByteObject.	aGlobalAddress unlock.  " we're going to give it away - is this necessary?? "	^self createOnAddress: aGlobalAddress deleteOnRelease: true"VS/OLE implementation was:    | nBytes anIStream |    nBytes := aByteObject size.    anIStream := self newTemporaryBackingStore.    ""Assert isTrue: [ anIStream size = 0 ].""    anIStream asByteStream        putBytesFrom: aByteObject            from: 1 to: nBytes;        reset.	""Assert isTrue: [ anIStream position = 0 and: [ anIStream size = nBytes ] ].""    ^anIStream"</body></methods><methods><class-id>External.COMGlobalMemoryStream class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IStream.	self updateAndRegister</body></methods><methods><class-id>External.COMInterfaceAdaptor</class-id> <category>accessing</category><body package="Com- Ole">actualImplementor	" Answer the real implementor of the interface whose functions are supported by the receiver. "	^implementor actualImplementor</body><body package="Com- Ole">implementingObject	" Answer the COM object in the current process which supports the receiver.  Answer nil if the interface is not supported by a local Smalltalk COM object. "	self subclassResponsibility.</body><body package="Com- Ole">implementor	" Answer the real implementor of the interface whose functions are supported by the receiver. "	^implementor</body><body package="Com- Ole">implementor: anInterface	" Specify the real implementor of the interface whose functions are supported by the receiver. "	implementor := anInterface.</body><body package="Com- Ole">referenceCount 	^ implementor referenceCount</body><body package="Com- Ole">vtableSelectors	"Answer the message selectors of the interface functions, in VTable order."	^vtableSelectors</body><body package="Com- Ole">vtableSelectors: selectorList	"Specifiy the message selectors of the interface functions, in VTable order."	vtableSelectors := selectorList.</body></methods><methods><class-id>External.COMInterfaceAdaptor</class-id> <category>testing</category><body package="Com- Ole">isCOMInterfaceAdaptor	" Answer whether the receiver is an adaptor on a COM interface. "	^true</body></methods><methods><class-id>External.COMInterfaceAdaptor</class-id> <category>private interface operations</category><body package="Com- Ole">privateAddRef	"implemented by subclasses"	^self</body><body package="Com- Ole">privateRelease	" Release the receiver. "	^ super release</body></methods><methods><class-id>External.COMInterfaceAdaptor</class-id> <category>releasing</category><body package="Com- Ole">privateInvalidate	"Set the receiver to be invalid."	^ self</body></methods><methods><class-id>External.COMInterfaceAdaptor</class-id> <category>notices</category><body package="Com- Ole">enforceRelease	^ self privateRelease</body></methods><methods><class-id>External.COMInterfaceAdaptor</class-id> <category>interface operations</category><body package="Com- Ole">enforceAddRef	^ self privateAddRef</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor</class-id> <category>dispatch configuring</category><body package="Com- Ole">implementedFunctions	" Answer the message selectors of the interface functions for which the receiver's object has registered a handler. "	^self dispatchSelectors reject: [ :selector | selector = #unimplementedFunction ]</body><body package="Com- Ole">installDispatchSelectors: dispatchSelectors 	" Configure the receiver to map the interface function selectors of its public protocol to the &lt;dispatchSelectors&gt; supported by the implementing object. "	dispatchSelectors size ~= vtableSelectors size 		ifTrue: 			[self error: #ErrIntFunctionMapMix &lt;&lt; #com 						&gt;&gt; 'interface function selector mapping size mismatch'].	1 to: vtableSelectors size		do: 			[:i | 			self 				when: (vtableSelectors at: i)				send: (dispatchSelectors at: i)				to: implementor]</body><body package="Com- Ole">installMinimumDispatchHandlers	" Configure the receiver's interface function dispatch bindings to dispatch the minimal functions beeded to support the interface to the implementing object using the standard function selectors, with unimplemented-function semantics for all other operations.  By default, we know nothing.  This method should be reimplemented by subclasses with stronger requirements. "	self installUnimplementedDispatchHandlers.</body><body package="Com- Ole">installStandardDispatchHandlers	" Configure the receiver to map the interface function &lt;selectors&gt; of its public protocol directly onto the implementing object. "	vtableSelectors do: [ :aSelector |		self when: aSelector			send: (implementor vtableSelectorFor: aSelector) to: implementor ].</body><body package="Com- Ole">installUnimplementedDispatchHandlers	" Configure the receiver's interface function dispatch bindings with a default set of VTable function handlers which provide unimplemented-function semantics. "	vtableSelectors do: [ :aSelector |		self when: aSelector			send: #unimplementedFunction to: self ].</body><body package="Com- Ole">standardIUnknownSelectors	" Answer the selectors for the standard implementations of the IUnknown operations. "	^#( #QueryInterface:_: #AddRef  #Release )</body><body package="Com- Ole">unimplementedFunction	" Answer the HRESULT value for an unimplemented function. "	^E_NOTIMPL</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor</class-id> <category>accessing</category><body package="Com- Ole">dispatchSelectors	" Answer the message selectors of the receiver's interface function dispatch bindings which are used to dispatch the corresponding VTable interface function selector to the implementing object. "	^vtableSelectors collect: [ :aFunctionSelector |		| anAction |		( ( anAction := self actionForEvent: aFunctionSelector ) "isMessage" isKindOf: MessageSend )			ifTrue: [ anAction selector ]			ifFalse: [ nil ] ]</body><body package="Com- Ole">functionAdaptor	" Answer the interface function adaptor which is configured for the receiver.  Answer nil if this is a direct binding of the interface to the real implementor. "	^self</body><body package="Com- Ole">implementingObject	" Answer the object that implements the interface.  Ignore any adaptors which have been configured to customize the interface binding. "	"?? ^implementor ??"	| anObject |	anObject := self implementor.	[ anObject isCOMInterfaceAdaptor ]		whileTrue: [ anObject := anObject implementor ].	^anObject</body><body package="Com- Ole">implementor: anObject	" Set the implementor of the interface to &lt;anObject&gt;."	implementor == self 		ifTrue: [ COMError raiseSignal: #ErrCantDelegateSelf &lt;&lt; #com &gt;&gt; 'cannot delegate to self' ].	super implementor: anObject.</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor</class-id> <category>event configuring</category><body package="Com- Ole">when: eventName evaluate: anAction	"Append &lt;anAction&gt; to the list of actions to evaluate when the receiver triggers the event named &lt;eventName&gt;.  For interface function events, we use replacement semantics rather than the standard append semantics, so that each interface function maps onto a single handler."	| functionSelector |	( functionSelector  := self interfaceFunctionSelectorForEventName: eventName ) notNil		ifTrue: [			self removeActionsForEvent: functionSelector.			^super when: functionSelector evaluate: anAction ].	^super when: eventName evaluate: anAction</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor</class-id> <category>private-operation</category><body package="Com- Ole">doesNotUnderstand: aMessage	" Private - sent to the receiver by the virtual machine when the message &lt;aMessage&gt; sent to the receiver was not implemented by the receiver.  Dispatch the message to the implementing object if &lt;aMessage&gt; represents an interface function. "	^self triggerEvent: aMessage selector		withArguments: aMessage arguments		ifNotHandled: [ super doesNotUnderstand: aMessage ]</body><body package="Com- Ole">functionNameFromSelector: aSelector	" Private "	^aSelector readStream upTo: $:</body><body package="Com- Ole">interfaceFunctionSelectorForEventName: eventName	" Private - answer the interface function selector corresponding to &lt;eventName&gt;.  Answer nil if not an interface function. "	vtableSelectors isNil		ifTrue: [ ^nil ].	( vtableSelectors includes: eventName )		ifTrue: [ ^eventName ].	vtableSelectors do: [ :functionSelector |		( self functionNameFromSelector: functionSelector ) = eventName asString			ifTrue: [ ^functionSelector ] ].	^nil</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor</class-id> <category>private-accessing</category><body package="Com- Ole">actionForFunctionSelector: functionSelector	" Private "	^self actionForEvent: functionSelector</body><body package="Com- Ole">myEventTable	"Private - answer a Dictionary mapping event names to actions	for the receiver, or nil if there is none."	^eventTable</body><body package="Com- Ole">myEventTable: newTable	"Private"	eventTable := newTable.</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor</class-id> <category>copying</category><body package="Com- Ole">postCopy	super postCopy.	self releaseEventTable</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor</class-id> <category>event accessing</category><body package="Com- Ole">canTriggerEvent: eventName	"Answer &lt;true&gt; if the receiver can trigger an event named &lt;eventName&gt;."	^( self interfaceFunctionSelectorForEventName: eventName ) notNil		or: [ super canTriggerEvent: eventName ]</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor</class-id> <category>testing</category><body package="Com- Ole">isCOMTraceAdaptor	" Answer whether the receiver is a trace adaptor on a COM interface. "	^false</body></methods><methods><class-id>External.COMInterfaceFunctionAdaptor class</class-id> <category>instance creation</category><body package="Com- Ole">on: anObject selectors: selectors	"Answer an initialized instance of the receiver that supports the COM interface functions specified in the &lt;selectors&gt; list by mapping them onto protocol specified by the implementing object &lt;anObject&gt;. "	^self new		implementor: anObject;		vtableSelectors: selectors;		installUnimplementedDispatchHandlers;		yourself</body></methods><methods><class-id>External.ILockBytes</class-id> <category>interface operations-locking</category><body package="Com- Ole">lockRegion: offset count: count mode: lockType		" Lock the &lt;count&gt; bytes in the byte array starting at position &lt;offset&gt; 		using locking mode &lt;lockType&gt;. "	^interface LockRegion: offset _: count _: lockType</body><body package="Com- Ole">unlockRegion: offset count: count mode: lockType		" Unlock the &lt;count&gt; bytes in the byte array starting at position &lt;offset&gt; 		that was previously locked in locking mode &lt;lockType&gt;. "	^interface UnlockRegion: offset _: count _: lockType</body></methods><methods><class-id>External.ILockBytes</class-id> <category>interface operations-accessing</category><body package="Com- Ole">statistics		" Answer the storage statistics about this storage element.		Include the storage name (which must be deallocated), if known. "	| resultReference |	resultReference := nil asValueReference.	interface Stat: resultReference _: STATFLAG_DEFAULT.    resultReference value hasName        "ifTrue: [ self ASSERT: resultReference value hasFinalization ]"        ifFalse: [ resultReference value doesNotNeedFinalization ].	^resultReference value</body><body package="Com- Ole">statisticsWithoutName		" Snswer the storage statistics about this storage element.		Omit the storage name so that deallocation is not necessary. "	| resultReference |	resultReference := nil asValueReference.	interface Stat: resultReference _: STATFLAG_NONAME.	"self ASSERT: ( resultReference value hasName not )."	resultReference value doesNotNeedFinalization.	^resultReference value</body></methods><methods><class-id>External.ILockBytes</class-id> <category>interface operations-operations</category><body package="Com- Ole">flush		" Ensure that any internal buffers maintained by the implementor		are written out to the backing store. "	interface Flush.</body><body package="Com- Ole">readAt: offset buffer: buffer count: count		" Read the &lt;count&gt; bytes from the byte array starting at position &lt;offset&gt;		into the &lt;buffer&gt; provided by the caller.		Answer the number of bytes actually read into the &lt;resultReference&gt;. "	| resultReference |	resultReference := nil asValueReference.	interface ReadAt: offset        _:  buffer 		_: count 		_: resultReference.	^resultReference value</body><body package="Com- Ole">setSize: newSize		" Change the size of the byte array to &lt;newSize&gt;. "	^interface SetSize: newSize</body><body package="Com- Ole">writeAt: offset buffer: buffer count: count		" Write &lt;count&gt; bytes from the client's &lt;buffer&gt; into the byte array		starting at position &lt;offset&gt;.   Answer the number of bytes 		actually written. "	| resultReference |	resultReference := nil asValueReference.	interface WriteAt: offset 		_: buffer 		_: count 		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.ILockBytes</class-id> <category>accessing</category><body package="Com- Ole">size        "Answer the size of the receiver's byte array. "    ^self statisticsWithoutName cbSize</body></methods><methods><class-id>External.ILockBytes</class-id> <category>testing</category><body package="Com- Ole">isStorageBytes		" Answer whether the receiver's byte array contains an IStorage. "	^( OLEDLL current StgIsStorageILockBytes: self ) = S_OK</body></methods><methods><class-id>External.ILockBytes class</class-id> <category>instance creation</category><body package="Com- Ole">createOnAddress: aGlobalMemoryAddress deleteOnRelease: deleteOnRelease	" Create a new ILockBytes on &lt;aGlobalMemoryAddress&gt;.  If &lt;deleteOnRelease&gt; is set the memory will be released by COM when the lock bytes is released. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current CreateILockBytesOnHGlobal: aGlobalMemoryAddress 		_: deleteOnRelease 		_: resultReference.	( deleteOnRelease 	and: [ aGlobalMemoryAddress isExternalAddress ] )		ifTrue: [ aGlobalMemoryAddress doesNotNeedFinalization ].	^resultReference value</body></methods><methods><class-id>External.ILockBytes class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_ILockBytes.	self updateAndRegister</body></methods><methods><class-id>External.IDataObject</class-id> <category>interface operations</category><body package="Com- Ole">dataAdviseConnectionsEnumerator	" Answer an enumerator on the collection of STATDATA structures which describe the data advise connections currently established on the data object. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumSTATDATA ) asValueReference.	interface EnumDAdvise: resultReference.	^resultReference value</body><body package="Com- Ole">getCanonicalFormatEtc: aFormatEtc	" Answer the canonical FORMATETC which will be supplied for &lt;aFormatEtc&gt;. "	| resultReference hresult |	resultReference := nil asValueReference.	hresult := interface GetCanonicalFormatEtc: aFormatEtc		_: resultReference.	hresult = S_OK   " DATA_S_SAMEFORMATETC "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">getData: aFormatEtc	" Retrieve data in the format specified by &lt;aFormatEtc&gt;.  Answer the storage medium which the data object allocated and filled in.  The caller is responsible for releasing the storage. "    | resultReference |    resultReference := nil asValueReference.    interface GetData: aFormatEtc _: resultReference.    ^resultReference value</body><body package="Com- Ole">getDataFormatsEnumerator	" Answer an enumerator that can be used to enumerate the formats that can be used to obtain data with IDataObject::GetData. "    | resultReference |    resultReference := ( IEnum forIID: IID_IEnumFORMATETC ) asValueReference.    interface EnumFormatEtc: DATADIR_GET _: resultReference.    ^resultReference value</body><body package="Com- Ole">getDataHere: aFormatEtc storageMedium: aStgMedium	" Retrieve data in the format specified by &lt;aFormatEtc&gt;.  The caller allocates the storage medium &lt;aStgMedium&gt;. "	interface GetDataHere: aFormatEtc _: aStgMedium.</body><body package="Com- Ole">hasGetDataFormat: aFormatEtc	" Answer whether a call to IDataObject::GetData would succeed if it were passed &lt;aFormatEtc&gt; as the requested data format. "	^( interface QueryGetData: aFormatEtc ) = S_OK</body><body package="Com- Ole">queryGetDataFormat: cfFormat	| format |	format := self privateGetDefaultFormatEtc: cfFormat.	^interface QueryGetData: format</body><body package="Com- Ole">registerAdviseSink: anAdviseSink format: aFormatEtc adviseFlags: advFlags	" Register a data advise sink on the data object.  Answer the token which identifies the connection (nil if not established). "	| resultReference |	resultReference := nil asValueReference.	interface DAdvise: aFormatEtc _: advFlags _: anAdviseSink _: resultReference.	^resultReference value</body><body package="Com- Ole">setData: aFormatEtc storageMedium: aStgMedium release: fRelease	" Set the receiver's data in the format specified by &lt;aFormatEtc&gt; from the storage medium &lt;aStgMedium&gt;.  The receiver must release the storage if &lt;fRelease&gt; is true; otherwise the caller retains ownership of the storage. "    ^interface SetData: aFormatEtc _: aStgMedium _: fRelease</body><body package="Com- Ole">setDataFormatsEnumerator	" Answer an enumerator that can be used to enumerate the formats that can be used to store data with IDataObject::SetData. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumFORMATETC ) asValueReference.	interface EnumFormatEtc: DATADIR_SET _: resultReference.	^resultReference value</body><body package="Com- Ole">unregisterAdviseSink: connectionToken	" Delete a data advise connection between the data transfer object and an advisory sink, identified by the &lt;connectionToken&gt; returned when the connection was established through IDataObject::DAdvise. "	interface DUnadvise: connectionToken.</body></methods><methods><class-id>External.IDataObject</class-id> <category>testing</category><body package="Com- Ole">containsFormat: formatName	"Answer whether data can be obtained from the receiver in the specified format."	| aFormatEtc |	aFormatEtc := ( COMStructure classForStructureNamed: #FORMATETC )		formatNamed: formatName.	[ self hasGetDataFormat: aFormatEtc ] 		on: COMError 		do: [ :ex | ^false ].	^true</body></methods><methods><class-id>External.IDataObject</class-id> <category>clipboard services</category><body package="Com- Ole">copyToClipboard	" Copy the receiver to the system clipboard. "	OLEDLL current OleSetClipboard: self.</body><body package="Com- Ole">isClipboardObject	" Answer whether the receiver is on the system clipboard. "	^( OLEDLL current OleIsCurrentClipboard: self ) = S_OK</body></methods><methods><class-id>External.IDataObject</class-id> <category>accessing</category><body package="Com- Ole">dataAdviseConnections	" Answer a collection of STATDATA structures which describe the data advise connections currently established on the data object.   Answer nil if advise connections are not supported. "	| anEnumerator contents |	anEnumerator := [ self dataAdviseConnectionsEnumerator ]		on: COMError		do: [ :ex | 			( ex hresult = E_NOTIMPL 			or: [ ex hresult = OLE_E_ADVISENOTSUPPORTED ] )				ifTrue: [ ^nil ].			ex pass ].	contents := anEnumerator contents.	^contents</body><body package="Com- Ole">getDataFormats	" Answer the data formats which can be obtained from the receiver.  Answer nil if the data object does not support getting its data. "	| anEnumerator contents |	anEnumerator := [ self getDataFormatsEnumerator ]		on: COMError		do: [ :ex | 			ex hresult = E_NOTIMPL				ifTrue: [ ^nil ].			ex pass ].	contents := anEnumerator contents.	^contents</body><body package="Com- Ole">setDataFormats	" Answer the data formats which can be sent to the receiver.  Answer nil if the data object does not allow its state to be set. "	| anEnumerator contents |	anEnumerator := [ self setDataFormatsEnumerator ]		on: COMError		do: [ :ex | 			( ex hresult = E_NOTIMPL			or: [ ex hresult = E_INVALIDARG ] )  " kinda wierd, but it does seem to indicate not-supported "				ifTrue: [ ^nil ].			ex pass ].	contents := anEnumerator contents.	^contents</body></methods><methods><class-id>External.IDataObject</class-id> <category>data transfer services</category><body package="Com- Ole">privateGetData: aFormatEtc	"Render the data obtained from the receiver for the specified format."	| aStgMedium aSelector theData formatName |	formatName := COMDataRendering				getFormatName: (aFormatEtc memberAt: #cfFormat).	[self hasGetDataFormat: aFormatEtc] on: COMError do: [:ex | ^nil].	aStgMedium := self getData: aFormatEtc.	aStgMedium isNil ifTrue: [^nil].		[aSelector := self class getRenderingOperationFor: formatName.	aSelector isNil		ifTrue: 			[^COMError				raiseSignal: (#ErrNamedUnsuppFormat &lt;&lt; #com						&gt;&gt; 'unsupported data format: &lt;1s&gt;' expandMacrosWith: formatName)].	theData := self				perform: aSelector				with: aFormatEtc				with: aStgMedium]			ensure: [aStgMedium enforceRelease].	^theData</body><body package="Com- Ole">renderFormat: formatName	"Render the data obtained from the receiver for the specified format."	| aFormatEtc |	aFormatEtc := (COMStructure classForStructureNamed: #FORMATETC)				formatNamed: formatName.	^self privateGetData: aFormatEtc</body></methods><methods><class-id>External.IDataObject</class-id> <category>private-unmarshaling</category><body package="Com- Ole">unmarshalBitmapFormatEtc: aFormatEtc medium: aStgMedium	" Private - answer a string "	| tempBitmap  |	tempBitmap := self class defaultBitmapClass		fromHandle: (aStgMedium unionMemberAt: #'u.hBitmap').	^ [tempBitmap copy ] ensure: [ tempBitmap enforceInvalidation ]</body><body package="Com- Ole">unmarshalEnhancedMetafileFormatEtc: aFormatEtc medium: aStgMedium	" Private - answer a string "	^self class defaultMetaFileClass		fromEnhHandle: (aStgMedium unionMemberAt: #'u.hEnhMetaFile')</body><body package="Com- Ole">unmarshalMetafileFormatEtc: aFormatEtc medium: aStgMedium	" Private - answer a string "	^self class defaultMetaFileClass		fromHandle: (aStgMedium unionMemberAt: #'u.hMetaFilePict')</body><body package="Com- Ole">unmarshalSmalltalkObjectFormatEtc: aFormatEtc medium: aStgMedium	" Private - answer a Smalltalk object "	^Win32ClipboardInterface		getSmalltalkObjectFromGlobalMemory: aStgMedium hGlobal</body><body package="Com- Ole">unmarshalStringFormatEtc: aFormatEtc medium: aStgMedium	" Private - answer a string "	^Win32ClipboardInterface getStringFromGlobalMemory: aStgMedium hGlobal</body><body package="Com- Ole">unmarshalUnicodeStringFormatEtc: aFormatEtc medium: aStgMedium	" Private - answer a string "	^Win32ClipboardInterface		getUnicodeStringFromGlobalMemory: aStgMedium hGlobal</body></methods><methods><class-id>External.IDataObject</class-id> <category>private-rendering</category><body package="Com- Ole">getDataFormat: cfFormat	| format |	format := COM_FORMATETC format: cfFormat.	^self privateGetData: format</body><body package="Com- Ole">privateGetDefaultFormatEtc: cfFormat	^COM_FORMATETC format: cfFormat</body><body package="Com- Ole">setDataFormat: cfFormat data: data	"	cfFormat is a clipboard format constant CF_"	| format medium |	format := self privateGetDefaultFormatEtc: cfFormat.	medium := COM_STGMEDIUM format: format data: data.	^[self setData: format storageMedium: medium release: true] ensure: 			[format enforceInvalidation.			medium enforceInvalidation]</body></methods><methods><class-id>External.IDataObject class</class-id> <category>private-rendering</category><body package="Com- Ole">getRenderingOperationFor: aFormatName	" Answer the operation to invoke when &lt;aFormatName&gt; is to be rendered. "	| anOperation |	anOperation := RenderingActionMap at: aFormatName		ifAbsent: [ nil ].	anOperation isNil		ifTrue: [			| sameAsKey |			sameAsKey := RenderingActionMap keys detect: [ :fn | fn sameAs: aFormatName ]				ifNone: [ nil ].			sameAsKey notNil				ifTrue: [ anOperation := RenderingActionMap at: sameAsKey ] ].	^anOperation</body><body package="Com- Ole">registerRenderingOperation: aThreeArgSelector for: aFormatName	" Register the operation to invoke when &lt;aFormatName&gt; is to be rendered. "	RenderingActionMap at: aFormatName		put: aThreeArgSelector.</body><body package="Com- Ole">renderingActionMap	^RenderingActionMap</body></methods><methods><class-id>External.IDataObject class</class-id> <category>clipboard services</category><body package="Com- Ole">clearClipboard	" Empty the clipboard. "	OLEDLL current OleSetClipboard: nil.</body><body package="Com- Ole">clipboardContainsObject	" Answer whether the system clipboard contains a COM data object. "	| anIDataObject |	anIDataObject := self getClipboardObject.	anIDataObject isNil		ifTrue: [ ^false ].	^true</body><body package="Com- Ole">flushClipboard	" Empty the clipboard.  Leave any hGlobal-based formats offered by the data transfer object on the clipboard so that they are available after application shutdown. "	| currentDataObject |	currentDataObject := self getClipboardObject.	currentDataObject isNil ifTrue: [^self].	OLEDLL current OleFlushClipboard</body><body package="Com- Ole">getClipboardObject	" Answer a new instance of the receiver referencing the COM data object contained in the system clipboard.  Answer nil if the clipboard does not contain a COM data object. "	| resultReference hresult |	resultReference := self new asValueReference.	[ hresult := OLEDLL current OleGetClipboard: resultReference ]		on: COMError		do: [ :ex | ^nil ].	hresult = S_OK		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body></methods><methods><class-id>External.IDataObject class</class-id> <category>clipboard formats-basic</category><body package="Com- Ole">cfBitmap	" Answer the clipboard format of a Bitmap. "	^ CF_BITMAP</body><body package="Com- Ole">cfBitmapName	" Answer the clipboard format name of a Bitmap. "	^ 'Bitmap'</body><body package="Com- Ole">cfEnhMetafilePict	" Answer the clipboard format of an enhanced Metafile picture. "	^ CF_ENHMETAFILE</body><body package="Com- Ole">cfEnhancedMetafilePictName	" Answer the clipboard format name of an enhanced Metafile picture. "	^'EnhMetaFilePict'</body><body package="Com- Ole">cfFilename	^'Filename'</body><body package="Com- Ole">cfFilenameName	^'Filename'</body><body package="Com- Ole">cfFilenameNameMedium	^ TYMED_FILE</body><body package="Com- Ole">cfMetafilePict	" Answer the clipboard format name of a String. "	^CF_METAFILEPICT</body><body package="Com- Ole">cfMetafilePictName	" Answer the clipboard format name of a Metafile picture. "	^'MetaFilePict'</body><body package="Com- Ole">cfNull	" Answer the NULL clipboard format. "	^CF_NULL</body><body package="Com- Ole">cfSmalltalkObject	" Answer the clipboard format of the persistent representation of a Smalltalk object. "	^Win32ClipboardInterface cfSmalltalkObject</body><body package="Com- Ole">cfSmalltalkObjectName	^Win32ClipboardInterface cfSmalltalkObjectName</body><body package="Com- Ole">cfString	" Answer the clipboard format of a String. "	^CF_TEXT</body><body package="Com- Ole">cfStringName	" Answer the name of the clipboard format of a String. "	^'String'</body><body package="Com- Ole">cfUnicodeString	" Answer the clipboard format of a String. "	^CF_UNICODETEXT</body><body package="Com- Ole">cfUnicodeStringName	" Answer the name of the clipboard format of a String. "	^'UnicodeString'</body></methods><methods><class-id>External.IDataObject class</class-id> <category>accessing</category><body package="Com- Ole">defaultBitmapClass	^DefaultBitmapClass ifNil: [Win32GenericHandle]</body><body package="Com- Ole">defaultBitmapClass: aClass	^DefaultBitmapClass := aClass.</body><body package="Com- Ole">defaultMetaFileClass	^DefaultMetaFileClass ifNil: [Win32GenericHandle]</body><body package="Com- Ole">defaultMetaFileClass: aClass	^DefaultMetaFileClass := aClass</body></methods><methods><class-id>External.IDataObject class</class-id> <category>private-installation</category><body package="Com- Ole">initialize	self iid: IID_IDataObject.	self initializeRenderingMap.	self updateAndRegister</body><body package="Com- Ole">initializeRenderingMap	" Private "	RenderingActionMap := Dictionary new.	self registerRenderingOperation: #unmarshalStringFormatEtc:medium: 		for: IDataObject cfStringName.	self registerRenderingOperation: #unmarshalUnicodeStringFormatEtc:medium: 		for: IDataObject cfUnicodeStringName.	self registerRenderingOperation: #unmarshalSmalltalkObjectFormatEtc:medium: 		for: IDataObject cfSmalltalkObjectName.	self registerRenderingOperation: #unmarshalMetafileFormatEtc:medium: 		for: IDataObject cfMetafilePictName.	self registerRenderingOperation: #unmarshalEnhancedMetafileFormatEtc:medium: 		for: IDataObject cfEnhancedMetafilePictName.	self registerRenderingOperation: #unmarshalBitmapFormatEtc:medium: 		for: IDataObject cfBitmapName.</body></methods><methods><class-id>External.IDataObjectImplementation</class-id> <category>interface operations</category><body package="Com- Ole">DAdvise: aFormatEtc _: advf _: anAdviseSink _: resultReference		" Invoke the IDataObject::DAdvise function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor DAdvise: aFormatEtc _:advf _: anAdviseSink _: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">DUnadvise: dwConnection		" Invoke the IDataObject::DUnadvise function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor DUnadvise: dwConnection		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">EnumDAdvise: resultReference		" Invoke the IDataObject::EnumDAdvise function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor EnumDAdvise: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">EnumFormatEtc: aDataDirection _: resultReference		" Invoke the IDataObject::EnumFormatEtc function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor EnumFormatEtc:  aDataDirection _: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">GetCanonicalFormatEtc: aFormatEtc _: resultReference		" Invoke the IDataObject::GetCanonicalFormatEtc function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetCanonicalFormatEtc: aFormatEtc _: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">GetData: aFormatEtc _: resultReference		" Invoke the IDataObject::GetData function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetData: aFormatEtc _: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">GetDataHere: aFormatEtc _: aStgMedium		" Invoke the IDataObject::GetDataHere function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetDataHere: aFormatEtc _: aStgMedium		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">QueryGetData: aFormatEtc		" Invoke the IDataObject::QueryGetData function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor QueryGetData: aFormatEtc		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult allow: DATA_E_FORMATETC.	^hresult</body><body package="Com- Ole">SetData: aFormatEtc _: aStgMedium _: fRelease		" Invoke the IDataObject::SetData function. 		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor SetData: aFormatEtc _: aStgMedium _: fRelease		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IDataObjectImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeDAdvise: this _: pFormatEtc _: advf _: pAdvSink _: pdwConnection	"Private - invoke the IDataObject::DAdvise function for an external caller. "	" HRESULT DAdvise(            /* [in] */ FORMATETC *pformatetc,            /* [in] */ DWORD advf,            /* [unique][in] */ IAdviseSink *pAdvSink,            /* [out] */ DWORD *pdwConnection); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult aFormatEtc anAdviseSink resultReference |	self reportExternalFunctionEntry.	(pAdvSink isValid and: [pFormatEtc isValid and: [pdwConnection isValid]])		ifFalse: [^E_INVALIDARG].	aFormatEtc := self structureAtAddress: pFormatEtc.	" type: #FORMATETC "	anAdviseSink := self interfaceAtAddress: pAdvSink type: IAdviseSink.	self clearScalarResultValueAtAddress: pdwConnection.	resultReference := nil asValueReference.	hresult := implementor				DAdvise: aFormatEtc				_: advf				_: anAdviseSink				_: resultReference.	hresult succeeded		ifTrue: [self scalarResultAtAddress: pdwConnection put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeDUnadvise: this _: dwConnection		"Private - invoke the IDataObject::DUnadvise function for an external caller. "	" HRESULT DUnadvise(            /* [in] */ DWORD dwConnection); "	^[   " terminate exception stack unwind at external callin boundary "	implementor DUnadvise: dwConnection.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeEnumDAdvise: this _: ppenumAdvise	"Private - invoke the IDataObject::EnumDAdvise function for an external caller. "	" HRESULT EnumDAdvise(		 /* [out] */ IEnumSTATDATA **ppenumAdvise); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	ppenumAdvise isValid ifFalse: [^E_INVALIDARG].	self clearPointerResultValueAtAddress: ppenumAdvise.	resultReference := nil asValueReference.	hresult := implementor EnumDAdvise: resultReference.	hresult succeeded		ifTrue: 			[self interfaceResultAtAddress: ppenumAdvise put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeEnumFormatEtc: this _: dwDirection _: pEnumFormatEtc	"Private - invoke the IDataObject::EnumFormatEtc function for an external caller. "	" HRESULT EnumFormatEtc(		/* [in] */ DWORD dwDirection,		 /* [out] */ IEnumFORMATETC **ppenumFormatEtc); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	pEnumFormatEtc isValid ifFalse: [^E_INVALIDARG].	self clearPointerResultValueAtAddress: pEnumFormatEtc.	resultReference := nil asValueReference.	hresult := implementor EnumFormatEtc: dwDirection _: resultReference.	hresult succeeded		ifTrue: 			[self interfaceResultAtAddress: pEnumFormatEtc put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeGetCanonicalFormatEtc: this _: pFormatEtcIn _: pFormatEtcOut	"Private - invoke the IDataObject::GetCanonicalFormatEtc function for an external caller. "	" HRESULT GetCanonicalFormatEtc(		 /* [unique][in] */ FORMATETC *pformatectIn,		 /* [out] */ FORMATETC *pformatetcOut); "	| formatEtcOut |	^	[" terminate exception stack unwind at external callin boundary "	| hresult formatEtcIn |	self reportExternalFunctionEntry.	(pFormatEtcIn isValid and: [pFormatEtcOut isValid])		ifFalse: [^E_INVALIDARG].	formatEtcIn := self structureAtAddress: pFormatEtcIn.	" type: #FORMATETC "	formatEtcOut := self structureAtAddress: pFormatEtcOut.	hresult := implementor GetCanonicalFormatEtc: formatEtcIn _: formatEtcOut.	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeGetData: this _: pFormatEtc _: pStgMedium	"Private - invoke the IDataObject::GetData function for an external caller. "	" HRESULT GetData(		/* [unique][in] */ FORMATETC *pformatetcIn,		/* [out] */ STGMEDIUM *pmedium); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult aFormatEtc resultReference |	self reportExternalFunctionEntry.	(pFormatEtc isValid and: [pStgMedium isValid]) ifFalse: [^E_INVALIDARG].	aFormatEtc := self structureAtAddress: pFormatEtc.	" type: #FORMATETC "	self clearStructureResultAtAddress: pStgMedium.	resultReference := nil asValueReference.	hresult := implementor GetData: aFormatEtc _: resultReference.	hresult succeeded		ifTrue: [self structureResultAtAddress: pStgMedium put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeGetDataHere: this _: pFormatEtc _: pStgMedium        "Private - invoke the IDataObject::GetData function for an external caller. "	" HRESULT GetDataHere(		/* [unique][in] */ FORMATETC *pformatetc,		/* [out][in] */ STGMEDIUM *pmedium); "	^[   " terminate exception stack unwind at external callin boundary "	| hresult aFormatEtc aStgMedium |	self reportExternalFunctionEntry.	( pFormatEtc isValid	and: [ pStgMedium isValid ] )		ifFalse: [ ^E_INVALIDARG ].	aFormatEtc := self structureAtAddress: pFormatEtc.  " type: #FORMATETC "	aStgMedium := self structureAtAddress: pStgMedium.  " type: #STGMEDIUM "	hresult := implementor GetDataHere: aFormatEtc 		_: aStgMedium.	hresult	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeQueryGetData: this _: pFormatEtc	"Private - invoke the IDataObject::QueryGetData function for an external caller. "	" HRESULT QueryGetData(		/* [unique][in] */ FORMATETC *pformatetc); "	^[   " terminate exception stack unwind at external callin boundary "	| hresult aFormatEtc |	self reportExternalFunctionEntry.	pFormatEtc isValid		ifFalse: [ ^E_INVALIDARG ] .	aFormatEtc := self structureAtAddress: pFormatEtc.  " type: #FORMATETC "	hresult := implementor QueryGetData: aFormatEtc.	hresult	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeSetData: this _: pFormatEtc _: pStgMedium _: fRelease	"Private - invoke the IDataObject::SetData function for an external caller. "	" HRESULT SetData(		/* [unique][in] */ FORMATETC *pformatetc,		/* [unique][in] */ STGMEDIUM *pmedium,		/* [in] */ BOOL fRelease); "	^[   " terminate exception stack unwind at external callin boundary "	| hresult aFormatEtc aStgMedium |	self reportExternalFunctionEntry.	( pFormatEtc isValid	and: [ pStgMedium isValid ] )		ifFalse: [ ^E_INVALIDARG ].	aFormatEtc := self structureAtAddress: pFormatEtc.  " type: #FORMATETC "	aStgMedium := self structureAtAddress: pStgMedium.  " type: #STGMEDIUM "	hresult := implementor SetData: aFormatEtc 		_: aStgMedium 		_: fRelease.    hresult	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IDataObjectImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IDataObject.	self vtableSignatureTypeName: #__IDataObjectVtbl.	self updateAndRegister</body></methods><methods><class-id>External.COMMultiQIResultBuffer</class-id> <category>accessing</category><body package="Com- Ole">atAllPut: aValue 	"Put &lt;aValue&gt; in every element of the receiver's buffer."	self shouldNotImplement.</body><body package="Com- Ole">copyFrom: startIndex to: stopIndex	" Answer the contents for the buffer for the elements in the rangs &lt;startIndex&gt; to &lt;stopIndex&gt;, inclusive.  Any other elements in the buffer are ignored and no longer accessible. "	self shouldNotImplement.</body></methods><methods><class-id>External.COMMultiQIResultBuffer</class-id> <category>private-accessing</category><body package="Com- Ole">iidList: anIIDList	" Private "	iidList := anIIDList.</body></methods><methods><class-id>External.COMMultiQIResultBuffer</class-id> <category>subclass-initialization</category><body package="Com- Ole">initialize	" Private - initialize a new instance. "	super initialize.	self initializeBuffer.</body><body package="Com- Ole">initializeBuffer	" Private - initialize the buffer contents. "	| lpMultiQI |	buffer isPointer 		ifFalse: 			[self 				error: #ErrFixedSpaceNotIm &lt;&lt; #com &gt;&gt; 'fixed space support is not yet implemented'].	lpMultiQI := buffer copy.	"Assert isTrue: [ iidList size = self bufferElementCount ]."	iidList do: 			[:anIID | 			lpMultiQI memberAt: #pIID put: anIID.	"( COMExternalInterface asGUIDParameter:"	")"			" remaining fields must be set to zero on entry, which our zero-init semantics for buffers ensure "			"Assert isTrue: [ ( lpMultiQI memberAt: #pItf ) = 0 ]."			"Assert isTrue: [ ( lpMultiQI memberAt: #hr ) = 0 ]."			lpMultiQI increment]</body></methods><methods><class-id>External.COMMultiQIResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Ole">getResultValuesFrom: startIndex to: stopIndex	" Private - convert the contents into a array.  Answer the array. "	| nValues anArray lpMultiQI anIID anInterfacePointer |	buffer isPointer		ifFalse: [self error: #ErrNotImplemented &lt;&lt; #com &gt;&gt; 'not yet implemented'].	" believe this is not gonna be polymorphic, sigh [DL 11-May-97] "	(startIndex = 1 and: [stopIndex = self bufferElementCount])		ifFalse: 			[self error: #ErrPartialGetNotSupp &lt;&lt; #com						&gt;&gt; 'partial retrieval of contents not supported'].	" otherwise we gotta release unretrieved guys "	nValues := stopIndex - startIndex + 1.	anArray := Array new: nValues.	lpMultiQI := buffer copy.	"startIndex &gt; 1		ifTrue: [ lpMultiQI := lpMultiQI += ( startIndex - 1 ) ]."	1 to: nValues		do: 			[:i |			anIID := iidList at: i.			anInterfacePointer := (lpMultiQI memberAt: #hr) asHRESULT failed						ifTrue: [nil]						ifFalse: 							[COMInterfacePointer fromReturnValue: (lpMultiQI memberAt: #pItf) iid: anIID].			anArray at: i put: anInterfacePointer.			lpMultiQI increment].	^anArray</body></methods><methods><class-id>External.COMMultiQIResultBuffer class</class-id> <category>instance creation</category><body package="Com- Ole">for: anIIDList	" Answer a new instance of the receiver with a buffer to perform a MultiQI for all the interfaces in whose IID's are specified in &lt;anIIDList&gt;. "	^self basicNew		bufferElementType: COMExternalInterface current MULTI_QI;		bufferElementCount: anIIDList size;		iidList: anIIDList;		initialize;		yourself</body><body package="Com- Ole">type: aType count: nElements	" Answer a new instance of the receiver with a buffer for &lt;nElements&gt; of type &lt;aType&gt;. "	" use #for: because we know the type but we need to have an IID list to work with "	self shouldNotImplement.</body></methods><methods><class-id>External.IMallocPointer</class-id> <category>interface operations</category><body package="Com- Ole">Alloc: anInteger		" Invoke the IMalloc::Alloc function. "	^self alloc: anInteger addressType: self addressClass</body><body package="Com- Ole">DidAlloc: aCOMAddress		" Invoke the IMalloc::DidAlloc function. "	^self invokeDidAlloc: aCOMAddress asPointerParameter</body><body package="Com- Ole">Free: aCOMAddress		" Invoke the IMalloc::Free function. "	self invokeFree: aCOMAddress asPointerParameter.	aCOMAddress doesNotNeedFinalization.</body><body package="Com- Ole">GetSize: aCOMAddress		" Invoke the IMalloc::GetSize function. "	| sizeInBytes |	( sizeInBytes := self invokeGetSize: aCOMAddress asPointerParameter ) &lt; 0		ifTrue: [ COMError raiseSignal: #ErrInvalidAddress &lt;&lt; #com &gt;&gt; 'invalid address' ].	^sizeInBytes</body><body package="Com- Ole">Realloc: aCOMAddress _: anInteger		" Invoke the IMalloc:Realloc function. "	| newPointer |	newPointer := self invokeRealloc: aCOMAddress asPointerParameter 		_: anInteger.	( newPointer isNull and: [ anInteger ~= 0 ] )		ifTrue: [ COMError raiseSignal: #ErrReallocateMemory &lt;&lt; #com &gt;&gt; 'unable to reallocate memory' ].	aCOMAddress pointer: newPointer.	^aCOMAddress</body></methods><methods><class-id>External.IMallocPointer</class-id> <category>extended operations</category><body package="Com- Ole">alloc: anInteger addressType: aCOMAddressClass		" Invoke the IMalloc::Alloc function. "	| lpVoid |	( lpVoid := self invokeAlloc: anInteger ) isNull		ifTrue: [ COMError raiseSignal: #ErrInsufficientMemory &lt;&lt; #com &gt;&gt; 'insufficient memory' ].	^( aCOMAddressClass fromPointer: lpVoid )		needsFinalization</body></methods><methods><class-id>External.IMallocPointer</class-id> <category>private-allocation</category><body package="Com- Ole">addressClass		" Private - answer the COM address class used for memory allocated from the receiver. "	| anIMalloc |	( ( anIMalloc := IMalloc taskMemoryAllocator ) notNil	and: [ self = anIMalloc interfaceBinding ] )		ifTrue: [ ^COMMemoryAddress ].	( ( anIMalloc := IMalloc sharedMemoryAllocator ) notNil	and: [ self = anIMalloc interfaceBinding ] )		ifTrue: [ ^COMSharedMemoryAddress ].	COMError raiseSignal: #ErrUnknownAllocator &lt;&lt; #com &gt;&gt; 'unknown COM memory allocator'</body></methods><methods><class-id>External.IMallocPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IMalloc.	self updateAndRegister</body></methods><methods><class-id>External.AdviseSink</class-id> <category>subclass-reference counting</category><body package="Com- Ole">incrementReferenceCount	" Private - increment the receiver's reference count.  This is the sum of the outstanding reference counts on all of its interfaces. "	^referenceCount := referenceCount + 1</body><body package="Com- Ole">token	^token</body></methods><methods><class-id>External.AdviseSink</class-id> <category>releasing</category><body package="Com- Ole">release	"Remove references to objects that may refer to the receiver. Answers self. "	self objectRelease.	self releaseConnection.  " disconnect if the sink was still connected "</body></methods><methods><class-id>External.AdviseSink</class-id> <category>interface protocol</category><body package="Com- Ole">OnClose	self triggerEvent: #OnClose.	^ S_OK</body><body package="Com- Ole">OnDataChange: aFormatEtc _: aStgMedium	self triggerEvent: #OnDataChange with: aFormatEtc with: aStgMedium.	^ S_OK</body><body package="Com- Ole">OnRename: anIMoniker	self triggerEvent: #OnRename with: anIMoniker.	^ S_OK</body><body package="Com- Ole">OnSave	self triggerEvent: #OnSave.	^ S_OK</body><body package="Com- Ole">OnViewChange: dwAspect _: lindex	self triggerEvent: #OnViewChange with: dwAspect with: lindex.	^ S_OK</body></methods><methods><class-id>External.AdviseSink</class-id> <category>accessing</category><body package="Com- Ole">establishConnectionTo: anInterface	token := anInterface advise: self iAdviseSink.	source := anInterface.	^ true</body><body package="Com- Ole">iAdviseSink	^ iAdviseSink ifNil: [ iAdviseSink := IAdviseSink directBindingOn: self ].</body><body package="Com- Ole">releaseConnection	source unadvise: self token.	token := nil.	source := nil</body><body package="Com- Ole">token: anObject	token := anObject</body></methods><methods><class-id>External.AdviseSink</class-id> <category>subclass-enumerating</category><body package="Com- Ole">allocatedInterfacesDo: aOneArgBlock	" Private - enumerate the interfaces supported by the receiver which have been allocated during its lifetime and evaluate &lt;aOneArgBlock&gt; with each.  Should be reimplemented by each subclass. "	super allocatedInterfacesDo: aOneArgBlock.	iAdviseSink notNil ifTrue: [ aOneArgBlock value: iAdviseSink ].</body></methods><methods><class-id>External.AdviseSink</class-id> <category>subclass-accessing</category><body package="Com- Ole">interfaceForIID: iid ifNone: aBlock	" Private - answer the interface supported by the receiver which is identified by the GUID &lt;iid&gt;.  Answer the result of evaluating a block if the requested interface is not supported. "	^ iid = IID_IAdviseSink 		ifTrue: 	[ self iAdviseSink ]		ifFalse: 	[ super interfaceForIID: iid ifNone: aBlock ]</body></methods><methods><class-id>External.IStoragePointer</class-id> <category>interface operations</category><body package="Com- Ole">CopyTo: ciidExclude _: rgiidExclude _: snbExclude _: destIStorage		" Invoke the IStorage::CopyTo function.		Raise an exception if an error occurs.  Answer the result code. "	| guidBuffer snbBuffer hresult |	"rgiidExclude size &gt; 0 ifTrue: [ Assert isTrue: [ ciidExclude = rgiidExclude size ] ]."	guidBuffer := GUID createArrayBuffer: rgiidExclude.	snbBuffer := COMExternalInterface createSNBBuffer: snbExclude.	[	hresult := self invokeCopyTo: ciidExclude		_: guidBuffer asPointerParameter		_: snbBuffer asPointerParameter		_: destIStorage asPointerParameter.	] ensure: [		snbBuffer enforceRelease.		guidBuffer enforceRelease ].	^hresult</body><body package="Com- Ole">CreateStorage: storageName _: grfMode _: dwStgFmt _: reserved2 _: resultReference		" Invoke the IStorage::CreateStorage function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IStoragePointer resultValueBuffer.	hresult := self invokeCreateStorage: storageName asUnicodeParameter		_: grfMode 		_: dwStgFmt 		_: reserved2		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">CreateStream: streamName _: grfMode _: reserved1 _: reserved2 _: resultReference		" Invoke the IStorage::CreateStream function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IStreamPointer resultValueBuffer.	hresult := self invokeCreateStream: streamName asUnicodeParameter		_: grfMode 		_: reserved1 		_: reserved2		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">DestroyElement: elementName		"Invoke the IStorage::DestroyElement function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeDestroyElement: elementName asUnicodeParameter</body><body package="Com- Ole">EnumElements: reserved1 _: reserved2 _: reserved3 _: resultReference		" Invoke the IStorage::EnumElements function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumSTATSTG.	hresult := self invokeEnumElements: reserved1 		_: reserved2 		_: reserved3		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">MoveElementTo: elementName _: destStorage _: newElementName _: grfFlags		" Invoke the IStorage::MoveElementTo function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeMoveElementTo: elementName asUnicodeParameter		_: destStorage asPointerParameter		_: newElementName asUnicodeParameter		_: grfFlags</body><body package="Com- Ole">OpenStorage: storageName _: pstgPriority _: grfMode _: snbExclude _: reserved _: resultReference        " Invoke the IStorage::OpenStorage function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult snbBuffer resultBuffer |	snbBuffer := COMExternalInterface createSNBBuffer: snbExclude.	resultBuffer := IStoragePointer resultValueBuffer.	[	hresult := self invokeOpenStorage: storageName asUnicodeParameter		_: pstgPriority asPointerParameter		 _: grfMode		_: snbBuffer asPointerParameter		_: reserved		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	] ensure: [		snbBuffer enforceRelease ].    ^hresult</body><body package="Com- Ole">OpenStream: streamName  _: reserved1 _: grfMode _: reserved2 _: resultReference		" Invoke the IStorage::OpenStream function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IStreamPointer resultValueBuffer.	hresult := self invokeOpenStream: streamName asUnicodeParameter		_: reserved1		_: grfMode 		_: reserved2		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">RenameElement: elementName _: newElementName		" Invoke the IStorage::RenameElement function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeRenameElement: elementName asUnicodeParameter		_: newElementName asUnicodeParameter</body><body package="Com- Ole">SetElementTimes: elementName _: cTime _: aTime _: mTime		"Invoke the IStorage::SetElementTimes function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSetElementTimes: elementName asUnicodeParameter		_: ( COMExternalInterface asFileTimeParameter: cTime )		_: ( COMExternalInterface asFileTimeParameter: aTime )		_: ( COMExternalInterface asFileTimeParameter: mTime )</body><body package="Com- Ole">Stat: resultReference _: grfStatFlag		" Invoke the IStorage::Stat function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMStructure resultValueBufferFor: #STATSTG.	hresult := self invokeStat: resultBuffer asPointerParameter		_: grfStatFlag.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.IStoragePointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IStorage.	self updateAndRegister</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>directory services</category><body package="Com- Ole">absoluteCOMDirectoryName	"Answer the absolute pathname for locating COM Connect files.  The path name ends with a directory separator character."	^self absolutePathName: self defaultCOMDirectoryName</body><body package="Com- Ole">absolutePathName: aPathName	"Answer the absolute pathname corresponding to &lt;aPathName&gt;. If &lt;aPathName&gt; is a directory a separator is the trailing character in the string."	| aFilename |	aFilename := aPathName asLogicalFileSpecification asFilename.	aFilename isAbsolute		ifTrue: [ ^self asDirectoryString: aFilename ].	aFilename := Filename defaultDirectory construct: aPathName.	^self asDirectoryString: aFilename</body><body package="Com- Ole">asDirectoryString: aDirectoryFilename	" Answer a string with the name of the directory &lt;aDirectoryFilename&gt;, ending with a trailing directory separator character. "	| separatorChar aPathName |	"Assert isTrue: [ aDirectoryFilename isDirectory ]."	separatorChar := Filename separator.	aPathName := aDirectoryFilename asString.	^aPathName last = separatorChar		ifTrue: [ aPathName ]		ifFalse: [ aPathName, ( String with: separatorChar ) ]</body><body package="Com- Ole">checkDefaultCOMDirectory	" Verify that the current setting of the COM default directory exists and is accessible.  Display a warning to the user if this is not so. "	| aStream messageText |	self defaultCOMDirectory definitelyExists		ifTrue: [ ^self ].	"Can't do anything"	HeadlessImage isHeadless ifTrue: [^ self ].	aStream :=  TextStream on: String new.	aStream 		cr; nextPutAll: (#BadCOMDirectorySetting &lt;&lt; #com &gt;&gt; 'Warning: the default COM directory setting is not valid.  This may affect the ability of COM applications to access files whose location is derived from this setting.') asString; cr; cr;		nextPutAll: (#EditToResetDirectory &lt;&lt; #com &gt;&gt; 'Edit the following expression and evaluate to reset the directory name:') asString; cr;		cr;		emphasis: #large; 		tab; nextPutAll: 'COMSessionManager defaultCOMDirectoryName: '; cr;		emphasis: #(#large #bold);		tab; tab; nextPutAll: self defaultCOMDirectoryName printString; cr;		emphasis: #large;		cr; cr.	messageText := aStream contents.	ComposedTextView edit: ( ValueHolder with: messageText )		label: (#DefaultCOMDirectoryInvalid &lt;&lt; #com &gt;&gt; 'Default COM Directory Invalid') asString		icon: ( Icon default)		extent: messageText asComposedText extent + (50@10).</body><body package="Com- Ole">defaultCOMDirectory	" Answer the default directory for locating COM Connect files. "	^DefaultCOMDirectory</body><body package="Com- Ole">defaultCOMDirectoryName	" Answer the name of the default directory for locating COM Connect files.  The path name ends with a terminating directory separator character. "	^self asDirectoryString: DefaultCOMDirectory</body><body package="Com- Ole">defaultCOMDirectoryName: aPathName 	" Specifiy the default directory for locating COM Connect files. "	| aFilename |	((aFilename := aPathName asLogicalFileSpecification) definitelyExists 		and: [aFilename isDirectory]) 			ifFalse: [self error: (#ErrNotDirectory &lt;&lt; #com &gt;&gt; '"&lt;1s&gt;" is not a directory' expandMacrosWith: aFilename)].	DefaultCOMDirectory := aFilename</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>private-resource management</category><body package="Com- Ole">allAllocatedInterfaces	" Answer a collection containing the COM interface pointers on Smalltalk COM objects which have been allocated in external memory during the current session. "	Tools.Note ISSUE.  " This should duplicate the information in the exported interfaces list obtained		from the EOT.  Review whether we really need this extra tracking in a registry.  		[DL 24-Apr-97] "	^self allocatedInterfacesRegistry weakObjects		"select: [ :aResource | aResource isCOMInterfaceImplementation ]"</body><body package="Com- Ole">allResourceRegistries	" Private - answer a collection containing all the COM resource registries. "	^Array 		with: self ownedInterfacesRegistry		with: self allocatedInterfacesRegistry 		with: self ownedMemoryRegistry</body><body package="Com- Ole">allResourcesDo: aBlock	ExternalStructure allGeneralInstancesDo: aBlock.	"COMRecord may not be loaded"	#{COMRecord} ifDefinedDo: [:class | class allGeneralInstancesDo: aBlock ].	COMMemoryAddress allGeneralInstancesDo: aBlock.	COMInterfacePointer allGeneralInstancesDo: aBlock.	COMInterfaceImplementation allGeneralInstancesDo: aBlock.</body><body package="Com- Ole">cleanUpResourceRegistry: aRegistry	" Private - clean up any unnecessary entries in &lt;aRegistry&gt;. "	| unnecessaryElements |	unnecessaryElements := aRegistry weakObjects		select: [ :anElement | anElement isValid not ].	unnecessaryElements do: [ :anElement |		aRegistry remove: anElement ].</body><body package="Com- Ole">registerSpecialSessionResource: aResource description: aString	" Private - register a description of a special resource of the current session. "	aResource isNil		ifTrue: [ ^nil ].	aResource isCOMInterfacePointer		ifTrue: [  " don't finalize interfaces with special session startup/shutdown handling "			aResource interfaceBinding doesNotNeedFinalization ].	self specialSessionResources at: aResource put: aString.</body><body package="Com- Ole">releaseResources	" Private - release all COM interfaces and memory addresses owned or allocated by this session. "	self triggerEvent: #releaseResources.	self allOwnedInterfaces do: 			[:anInterface |			[anInterface finalize] on: Error				do: [:ex | COMWarning log: (#WarnNamedIntRelease &lt;&lt; #com &gt;&gt; 'COM interface release error: &lt;1s&gt;' expandMacrosWith: ex description)]].	"Assert isTrue: [ self allOwnedInterfaces isEmpty ]."	self allAllocatedInterfaces do: 			[:anInterface |			[anInterface  finalize] on: Error				do: [:ex | COMWarning log: (#WarnNamedIntImpRelease &lt;&lt; #com &gt;&gt; 'COM interface impl release error: &lt;1s&gt;' expandMacrosWith: ex description)]].	"Assert isTrue: [ self allAllocatedInterfaces isEmpty ]."	" release the external VTable shared by all exported interfaces "	"[ COMExternalVTable releaseExternalVTable ]"	"VSE mapped all exported VTables onto single set of function bodies "	COMInterfaceImplementation allSubclasses do: 			[:aClass |			[aClass  invalidateExternalVTable] on: Error				do: [:ex | COMWarning log: (#WarnNamedCallinRelease &lt;&lt; #com &gt;&gt; 'COM callin VTable release error: &lt;1s&gt;' expandMacrosWith: ex description)]].	" release memory before the memory allocators themselves are released "	self allOwnedMemoryAddresses do: 			[:anAddress |			[anAddress finalize] on: Error				do: [:ex | COMWarning log: (#WarnNamedMemRelease &lt;&lt; #com &gt;&gt; 'COM memory release release error: &lt;1s&gt;' expandMacrosWith: ex description)]].	"Assert isTrue: [ self ownedMemoryAddresses isEmpty ]."</body><body package="Com- Ole">removeSpecialSessionResource: aResource	" Private - remove the registration of a special resource of the current session. "	self specialSessionResources removeKey: aResource ifAbsent: [].</body><body package="Com- Ole">resetResources	" Private - reset all COM interfaces and memory addresses owned or allocated by this session. "	self allResourcesDo: [:object | object startupImage].	self savedResources: nil.	self clearResourceRegistries.	COMInterfaceImplementation allSubclasses		do: [:aClass | aClass invalidateExternalVTable]</body><body package="Com- Ole">transferResources: resources to: aRegistry type: resourceDescription	" Private - add &lt;resources&gt; to &lt;aRegistry&gt;.  Notify the user that something unusual is going on. "	resources do: [ :aResource | aRegistry add: aResource ].	MessageBox notify: (#GenKey43 &lt;&lt; #com &gt;&gt; 'COMSessionManager Initialization Warning') asString		withText: ((#GenKey42 &lt;&lt; #com &gt;&gt; '&lt;1s&gt; &lt;2s&gt; have been transferred to a new resource tracking registry.')			expandMacrosWith: resources size printString			with: resourceDescription).</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>testing</category><body package="Com- Ole">isCOMAvailable        " Answer whether the basic COM support is available. "	IsCOMAvailable isNil		ifTrue: [ self isCOMAvailable: self checkIsCOMAvailable ].	^IsCOMAvailable</body><body package="Com- Ole">isDCOMAvailable        " Answer whether the basic DCOM support is enabled. "	^self isDCOMEnabled and: [ self isFreeThreadingAvailable ]</body><body package="Com- Ole">isDCOMEnabled        " Answer whether the basic DCOM support is enabled. "	IsDCOMEnabled isNil		ifTrue: [ self isDCOMEnabled: self checkIsDCOMEnabled ].	^IsDCOMEnabled</body><body package="Com- Ole">isFreeThreadingAvailable        " Answer whether the basic Free Threading support is available. "	IsFreeThreadingAvailable isNil		ifTrue: [ self isFreeThreadingAvailable: self checkIsFreeThreadingAvailable ].	^IsFreeThreadingAvailable</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>session management</category><body package="Com- Ole">checkForAutomationStartup	" Verify that the command line flags which indicate that the application was started by COM as an automation object server application are present.  Terminate the session if it is not. "	self commandLineIncludesAutomation		ifFalse: [			self terminateServer:				(#NoAutomationFlagFound &lt;&lt; #com &gt;&gt; 'The command line did not include the /Automation flag.This image is configured as a COM Automation server but it was not started with the /Automation flag.Make sure the /Automation flag is included in the registration file or command line. Due to this inconsistency, this image will now be terminated.') asString ].</body><body package="Com- Ole">checkForCOMServerSupport	" Verify that COM support is available for an object server session.  Terminate the session if it is not. "	self isCOMAvailable		ifFalse: [			self terminateServer:				(#GenKey29 &lt;&lt; #com &gt;&gt; 'COM support is not available or incorrect version') asString ].</body><body package="Com- Ole">checkForObjectStartup	" Verify that the command line flags which indicate that the application was started by COM as an object server application are present.  Terminate the session if it is not. "	self commandLineIncludesEmbedding		ifFalse: [			self terminateServer:				(#GenKey30 &lt;&lt; #com &gt;&gt; 'The command line did not include the /Embedding flag.This image is configured as a COM object server but it was not started with the /Embedding flag.Due to this inconsistency, this image will now be terminated.') asString ].</body><body package="Com- Ole">checkTracingOptions	" Process any tracing options specified on the command line. "	(ImageConfiguration isDevelopment not 		and: [self commandLineIncludesTracing]) 			ifTrue: 				[self traceManager isNil 					ifTrue: 						[#{External.COMTraceManager} ifDefinedDo: [:cls | cls installTraceSupport]							elseDo: [^nil]].				self activateRuntimeTracing]</body><body package="Com- Ole">classFactoryForCLSID: aGUID	" Answer the class factory which has been registered with COM for the CLSID &lt;aGUID&gt;.  Answer nil if not registered. "	^COMClassFactoryObject classFactoryForCLSID: aGUID</body><body package="Com- Ole">exitIfNotInUse: aBoolean	" Specify whether a server application publishing instances of the receiver will be terminated when the class factory and any manufactured objects are no longer in use. "	COMClassFactoryObject exitIfNotInUse: aBoolean.</body><body package="Com- Ole">freeUnusedLibraries	"Free unused libraries."	OLEDLL current CoFreeUnusedLibraries.</body><body package="Com- Ole">initializeAutomationServer    " Initialize COM and verify that the application is being run as an Automation object server.  Terminate the session if the necessary conditions for an automation object server application are not satisfied. "    self checkTracingOptions.    self logServerStartup.    self        checkForCOMServerSupport;        checkForAutomationStartup.</body><body package="Com- Ole">initializeObjectServer    " Initialize COM and verify that the application is being run as a COM object server.  Terminate the session if the necessary conditions for a COM object server application are not satisfied. "    self checkTracingOptions.    self logServerStartup.    self        checkForCOMServerSupport;        checkForObjectStartup.</body><body package="Com- Ole">installRuntime	" Prepare the image for deployment in a runtime image configuration. "	| comDirectory |	Tools.Note ISSUE.  "####TO DO: add suitable checking about COM resources and any local settings that we'd want to fiddle.. ###"	ImageConfiguration isDevelopment: false.	Assert evaluateAssertions: false.	( comDirectory := self defaultCOMDirectory ) isAbsolute		ifFalse: [			| absolutePathName |			absolutePathName := self absolutePathName: comDirectory asString.			( MessageBox confirm: 				((#GenKey34 &lt;&lt; #com &gt;&gt; 'The COM directory is currently a relative path name (&lt;1s&gt;).  Do you want to convert it to the absolute path name &lt;2s&gt;?')			expandMacrosWith: comDirectory asString			with: absolutePathName printString) )					ifTrue: [ self defaultCOMDirectoryName: absolutePathName ].			].</body><body package="Com- Ole">isServerInUse	" Answer whether the current session is in use as object server application supporting COM objects for clients. "	^COMClassFactoryObject isInUse</body><body package="Com- Ole">performDeferred: aMessageSend	" Perform a message without interrupting the current process flow. "	Tools.Note ISSUE.  " This is a substitute and perhaps temporary workaround		for the VSE Message&gt;&gt;performDeferred service, which is not		yet determined to be a commited Jigsaw facility in MessageSend.		Revert clients of this to their original #performDeferred implementation		if Jigsaw ends up supporting this directly.  [DL 13-Aug-96] "	[ aMessageSend value ] fork.</body><body package="Com- Ole">revokeAllClassFactories	" Revoke the registration of all registered class factory objects. "	ImageConfiguration isDevelopment		ifTrue: [ 			( MessageBox confirm: (#GenKey39 &lt;&lt; #com &gt;&gt; 'Release all registered class factories?') asString )				ifFalse: [ ^self ] ].	COMClassFactoryObject revokeAllClassFactories.</body><body package="Com- Ole">terminateServer	" Terminate an object server application. "	ImageConfiguration isDevelopment		ifTrue: [			( MessageBox confirm: (#GenKey40 &lt;&lt; #com &gt;&gt; 'The image is about to be shut down for COM object server application termination.  Proceed with releasing all registered class factories and shutting down the image?') asString )				ifFalse: [ ^self ].			].	self logServerTermination.	COMClassFactoryObject revokeAllClassFactories.	self isRuntimeTraceEnabled		ifTrue: [			COMSystem current when: #shutdown				send: #logServerExit to: self ].	COMSystem current shutdown.</body><body package="Com- Ole">terminateServer: reason	" Terminate an object server application.  Display a message giving the reason. If the server was started with the Debug flag on the command line, the user can choose to open a debugger. "	reason notNil		ifTrue: [			| traceFileName traceFileReference |			self isTraceEnabled				ifTrue: [					self traceManager						log: (#GenKey41 &lt;&lt; #com &gt;&gt; 'Terminating COM object server:') asString;						log: ( '&lt;t&gt;&lt;1s&gt;' expandMacrosWith: reason ) ].			traceFileName := ( self isTraceEnabled				ifTrue: [ self traceManager logFileName ]				ifFalse: [ nil ] ).			traceFileReference := ( traceFileName notNil				ifTrue: [ ((#See1s &lt;&lt; #com &gt;&gt; ' (see &lt;1s&gt;).')					expandMacrosWith: traceFileName) ]				ifFalse: [ '.' ] ).			self commandLineIncludesDebug				ifFalse: [					MessageBox notify: (#TerminatingCOMObjectServer &lt;&lt; #com &gt;&gt; 'Terminating COM Object Server') asString 							withText: reason, traceFileReference ]				ifTrue: [ | msg |					msg := #DebugOrTerminateCOMObjServer &lt;&lt; #com &gt;&gt; 										('Debug or Terminate COM Object Server:&lt;n&gt;&lt;n&gt;&lt;1s&gt;&lt;2s&gt;&lt;n&gt;&lt;n&gt;Click Yes to open a debugger.&lt;n&gt;Click No to terminate.').					( MessageBox confirm: (msg expandMacrosWith: reason with: traceFileReference) ) 						ifTrue: [ ^self halt ] ] ].	self terminateServer.</body><body package="Com- Ole">terminateServerDeferred	" Terminate an object server application.  Defer the request so that we return to the caller. "	self performDeferred: 		( MessageSend forReceiver: self selector: #terminateServer ).</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>resource management</category><body package="Com- Ole">allExportedInterfaces	" Answer a collection containing the COM interface implementations which are currently exported from this session. "	^ExportedObjectsTable registeredObjects		select: [ :anExternalObject | anExternalObject isCOMInterfaceImplementation ]</body><body package="Com- Ole">allExportedObjects	" Answer a collection containing the COM objects which are currently exported from this session. "	^( self allExportedInterfaces collect: [ :anInterface | anInterface implementingObject ] )		asSet</body><body package="Com- Ole">allOwnedInterfaces	" Answer a collection containing the COM interface pointers which are currently owned by this session. "	self cleanUpResourceRegistry: self ownedInterfacesRegistry.	^self ownedInterfacesRegistry weakObjects		"select: [ :aResource | aResource isCOMInterfacePointer ]"</body><body package="Com- Ole">allOwnedMemoryAddresses	" Answer a collection containing the COM memory addresses which are currently owned by this session. "	self cleanUpResourceRegistry: self ownedMemoryRegistry.	^self ownedMemoryRegistry weakObjects		"select: [ :aResource | aResource isCOMExternalAddress ]"</body><body package="Com- Ole">flushResources	4 timesRepeat: 			[self sessionHasResources ifFalse: [^self].			ObjectMemory garbageCollect]</body><body package="Com- Ole">saveCompleted	SavedResources := nil.</body><body package="Com- Ole">saveResourceRegistries	self savedResources		at: #allocatedInterfaces put: self allAllocatedInterfaces;		at: #ownedInterfaces put: self allOwnedInterfaces;		at: #ownedMemory put: self allOwnedMemoryAddresses.</body><body package="Com- Ole">sessionExportsResources	" Answer whether the session exports resources.  Ignore known resources which are handled specially. "	^self allAllocatedInterfaces notEmpty		or: [COMClassFactoryObject activeObjectCount &gt; 0]</body><body package="Com- Ole">sessionHasResources	" Answer whether this session currently owns or exports resources.  Ignore known resources which are handled specially. "	^self sessionOwnsResources or: [ self sessionExportsResources ]</body><body package="Com- Ole">sessionOwnedResources	" Answer whether the session owns resources.  Ignore known resources which are handled specially. "	^self allOwnedMemoryAddresses asArray , self allOwnedInterfaces asArray</body><body package="Com- Ole">sessionOwnsResources	" Answer whether the session owns resources.  Ignore known resources which are handled specially. "	^self allOwnedMemoryAddresses notEmpty	or: [ self allOwnedInterfaces notEmpty ]</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>private-installation</category><body package="Com- Ole">initialize	" Private - initialize the class. "	self defaultCOMDirectoryName: (Filename				fromComponents: #('$(VISUALWORKS)' 'com')).	self		initializeResourceRegistries;		initializeSpecialSessionResources;		initializeDefaultLocaleID;		registerSessionEventHandlers;		initializeDefaultLCIDInitializer</body><body package="Com- Ole">obsolete	"This class is being removed from the system."	self removeSessionEventHandlers.	^super obsolete.</body><body package="Com- Ole">registerSessionEventHandlers	" Private - register the image startup and shutdown event handlers. "	" COMSessionManager registerSessionEventHandlers "	(COMSystem current)		when: #coreStartupCompleted send: #startupImage to: self;		when: #saveCompleted send: #saveCompleted to: self;		when: #developmentStartup send: #startupDevelopment to: self;		when: #confirmSave send: #confirmSaveImage to: self;		when: #aboutToSave send: #aboutToSaveImage to: self;		when: #shutdown send: #shutdownImage to: self</body><body package="Com- Ole">removeSessionEventHandlers	" Private - remove the image startup and shutdown event handlers. "	" COMSessionManager removeSessionEventHandlers "	COMSystem current removeAllActionsWithReceiver: self</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>private-registry initialization</category><body package="Com- Ole">clearResourceRegistries	" Private - initialize the registries for tracking COM resources. "	self 		basicAllocatedInterfacesRegistry: self constructResourceRegistry;		basicOwnedInterfacesRegistry: self constructResourceRegistry;		basicOwnedMemoryRegistry: self constructResourceRegistry.</body><body package="Com- Ole">constructResourceRegistry	" Private - answer a new instance of a resource tracking registry. "	^WeakRegistry newFinalizationRegistry</body><body package="Com- Ole">initializeResourceRegistries	" Private - initialize the registries for tracking COM resources. "	self 		allocatedInterfacesRegistry: self constructResourceRegistry;		ownedInterfacesRegistry: self constructResourceRegistry;		ownedMemoryRegistry: self constructResourceRegistry.</body><body package="Com- Ole">initializeSpecialSessionResources	" Private - initialize the special session resources map. "	self specialSessionResources: IdentityDictionary new.</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>tracing</category><body package="Com- Ole">activateRuntimeTracing	" If COM tracing is installed and this is a deployed runtime session, turn on trace logging to the default log file. "	| aTraceManager |	( ImageConfiguration isDevelopment not	and: [ ( aTraceManager := self traceManager ) notNil ] )		ifTrue: [			aTraceManager isTraceEnabled				ifFalse: [ aTraceManager logToFile ].			].</body><body package="Com- Ole">activateRuntimeTracing: aFileName	" If COM tracing is installed and this is a deployed runtime session, turn on trace logging to the file named &lt;aFileName&gt;. "	| aTraceManager |	( ImageConfiguration isDevelopment not	and: [ ( aTraceManager := self traceManager ) notNil ] )		ifTrue: [			aTraceManager isTraceEnabled				ifFalse: [ aTraceManager logToFile: aFileName ].			].</body><body package="Com- Ole">isRuntimeTraceEnabled	" Answer whether this is a deployed runtime configuration with COM tracing enabled. "	^ImageConfiguration isDevelopment not and: [ self isTraceEnabled ]</body><body package="Com- Ole">isTraceEnabled	" Answer whether trace logging is currently enabled. "	^self traceManager notNil and: [ self traceManager isTraceEnabled ]</body><body package="Com- Ole">traceManager	" Answer the COM trace manager. "	^traceManager</body><body package="Com- Ole">traceManager: aTraceManager	" Set the COM trace manager. "	traceManager := aTraceManager.</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>private-accessing</category><body package="Com- Ole">allocatedInterfacesRegistry		" Private - answer the registry containing OLE interfaces for which an interface		invocation structure has been allocated in external memory in the current session. "	^AllocatedInterfacesRegistry</body><body package="Com- Ole">allocatedInterfacesRegistry: aRegistry	" Private - set the registry containing COM interfaces for which an interface VTable callback structure has been allocated in external memory in the current session. "	| resources |	( AllocatedInterfacesRegistry notNil	and: [ ( resources := self allAllocatedInterfaces ) notEmpty ] )		ifTrue: [ 			self transferResources: resources 				to: aRegistry 				type: 'allocated interfaces'.			AllocatedInterfacesRegistry action: nil.  " ignore the old collection "			].	AllocatedInterfacesRegistry := aRegistry.</body><body package="Com- Ole">basicAllocatedInterfacesRegistry: aRegistry	" Private - set the registry containing COM interfaces for which an interface VTable callback structure has been allocated in external memory in the current session. "	AllocatedInterfacesRegistry := aRegistry.</body><body package="Com- Ole">basicOwnedInterfacesRegistry: aRegistry	" Private - set the registry containing COM interfaces owned by clients in the current session. "	OwnedInterfacesRegistry := aRegistry.</body><body package="Com- Ole">basicOwnedMemoryRegistry: aRegistry	" Private - set the registry containing COM memory addresses owned by clients in the current session. "	OwnedMemoryRegistry := aRegistry.</body><body package="Com- Ole">classNamesForRegistration	"Answer the classes that are known to be registrable."	^ RegistrationCandidates ifNil: [		RegistrationCandidates := Set new ]</body><body package="Com- Ole">isCOMAvailable: aBooleanOrNil		" Private - set the flag recording whether COM support		has been sucessfully located during this session. "	IsCOMAvailable := aBooleanOrNil.</body><body package="Com- Ole">isDCOMEnabled: aBooleanOrNil		" Private - set the flag recording whether DCOM support		has been sucessfully located during this session. "	IsDCOMEnabled := aBooleanOrNil.</body><body package="Com- Ole">isFreeThreadingAvailable: aBooleanOrNil		" Private - set the flag recording whether Free Threading support		has been sucessfully located during this session. "	IsFreeThreadingAvailable := aBooleanOrNil.</body><body package="Com- Ole">ownedInterfacesRegistry		" Private - answer the registry containing OLE interfaces owned		by clients in the current session. "	^OwnedInterfacesRegistry</body><body package="Com- Ole">ownedInterfacesRegistry: aRegistry	" Private - set the registry containing COM interfaces owned by clients in the current session. "	| resources |	( OwnedInterfacesRegistry notNil	and: [ ( resources := self allOwnedInterfaces ) notEmpty ] )		ifTrue: [ 			self transferResources: resources 				to: aRegistry 				type: 'owned interfaces'.			OwnedInterfacesRegistry action: nil.  " ignore the old collection "			].	OwnedInterfacesRegistry := aRegistry.</body><body package="Com- Ole">ownedMemoryRegistry		" Private - answer the registry containing OLE memory addresses owned		by clients in the current session. "	^OwnedMemoryRegistry</body><body package="Com- Ole">ownedMemoryRegistry: aRegistry	" Private - set the registry containing COM memory addresses owned by clients in the current session. "	| resources |	( OwnedMemoryRegistry notNil	and: [ ( resources := self allOwnedMemoryAddresses ) notEmpty ] )		ifTrue: [ 			self transferResources: resources 				to: aRegistry 				type: 'owned memory addresses'.			OwnedMemoryRegistry action: nil.  " ignore the old collection "			].	OwnedMemoryRegistry := aRegistry.</body><body package="Com- Ole">specialSessionResources		" Private - answer a map of OLE resources owned or allocated		by the current session which are handled specially at session startup/shutdown. "	^SpecialSessionResources</body><body package="Com- Ole">specialSessionResources: aDictionary		" Private - set the map of OLE resources owned or allocated		by the current session which are handled specially at session startup/shutdown. "	SpecialSessionResources := aDictionary.</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>private-session management</category><body package="Com- Ole">aboutToSaveImage	" Private - the image is about to be saved.  Do any cleanup that is desired prior to actually saving the image state. "	self triggerEvent: #aboutToSaveImage.</body><body package="Com- Ole">confirmSaveImage	" Private - the image is about to be saved.  Check if there are issues with open resources.	  Vetoing has been disable to not interrupt snapshot process "	Tools.Note ISSUE.	" Shouldn't have to do this here - verify that		the base does this suitably and remove.  [DL 14-Aug-95] "	Tools.Note ISSUE.	" Disable on VWorks [DL 03-Jan-95] "	"Smalltalk unusedMemory."	self triggerEvent: #confirmSaveImage.	self saveResourceRegistries.</body><body package="Com- Ole">defaultLocaleIDInitializer	^ DefaultLCIDInitializer</body><body package="Com- Ole">defaultLocaleIDInitializer: aBlockLikeThing	" Set the default Win32 LCID initializer. "	DefaultLCIDInitializer := aBlockLikeThing.	self initializeDefaultLocaleID.</body><body package="Com- Ole">initializeDefaultLocaleID	" Private - initialize the default Win32 LCID. "	HostInterface isWin32		ifTrue: [ DefaultLCIDInitializer value]		ifFalse: [ self defaultLocaleID: nil ].</body><body package="Com- Ole">shutdownImage	" Private - the session is being exited.  Release COM resources owned or allocated during the current session. "	(HostInterface isWindows or: [ HostInterface isWindowsNT ]) ifFalse: [  ^ self ].	self triggerEvent: #shutdownImage.	self releaseResources.	IMalloc releaseMemoryAllocators.  " release references to the task memory allocators "	IRunningObjectTable releaseCurrent.  " release the reference to the running object table. "	OLEDLL closeCurrent.</body><body package="Com- Ole">startupDevelopment	" Private - a development session is being started.  The basic system restart is now completed. "	self checkDefaultCOMDirectory.</body><body package="Com- Ole">startupImage	" Private - the session is being started.  Reset com resources owned or allocated during the previous session. "	self resetResources.	self initializeDefaultLocaleID.	self 		isCOMAvailable: nil;		isDCOMEnabled: nil;		isFreeThreadingAvailable: nil.	COMDevelopmentWarning resetMessages.	self initializeSpecialSessionResources.	IMalloc resetMemoryAllocators.  " reset references to the task memory allocators "	IRunningObjectTable resetCurrent.  " release the reference to the running object table. "	COMClassFactoryObject resetServerState.	" need to ensure OLEDLL is reopened properly "	OLEDLL startupImage.	self triggerEvent: #startupImage.</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>localization services</category><body package="Com- Ole">defaultLocaleID	" Answer the default locale ID of the current user session. "	" COMSessionManager defaultLocaleID "	^DefaultLocaleID</body><body package="Com- Ole">defaultLocaleID: anLCID	" Specify the default locale ID of the current user session. "	DefaultLocaleID := anLCID.</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>private-events</category><body package="Com- Ole">constructEventsTriggered	"Private - answer all the events which can be triggered by instances of the receiver. "	^super constructEventsTriggered 	" image startup "		add: #startupImage ;	" image save "		add: #confirmSaveImage ;  " this is a vetoable confirmation event "		add: #aboutToSaveImage ;	" image shutdown "		add: #shutdownImage ;	" releasing all resources "		add: #releaseResources;		yourself</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>session startup options</category><body package="Com- Ole">commandLineIncludesAnyOf: anArrayOfStrings	" Answer whether the current session was started with any of &lt;anArrayOfStrings&gt; included as an argument on the command line.  The match is not case-sensitive. "	| normalizedArguments normalizedCommandLineArguments |	normalizedArguments := anArrayOfStrings collect: [ :anArg | anArg asLowercase ].	normalizedCommandLineArguments := ImageConfiguration commandLine collect: [ :anArg | anArg asLowercase ].	^( normalizedCommandLineArguments		detect: [ :anArg | normalizedArguments includes: anArg ]		ifNone: [ nil ] )			notNil</body><body package="Com- Ole">commandLineIncludesAutomation	" Answer whether the current session was started by COM as an automation server. "	^self commandLineIncludesAnyOf: #( '/Automation'  '-Automation' )</body><body package="Com- Ole">commandLineIncludesDebug	" Answer whether the current session was started by COM with the ComDebug flag. "	^self commandLineIncludesAnyOf: #( '/ComDebug'  '-ComDebug' )</body><body package="Com- Ole">commandLineIncludesEmbedding	" Answer whether the current session was started by COM as an object server. "	^self commandLineIncludesAnyOf: #( '-Embedding'  '/Embedding' )</body><body package="Com- Ole">commandLineIncludesTracing	" Answer whether the current session was started by COM with the ComTracing flag. "	^self commandLineIncludesAnyOf: #( '/ComTracing'  '-ComTracing' )</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>private-testing</category><body package="Com- Ole">checkIsCOMAvailable        " Private - determine whether the basic OLE support is available. "	HostInterface isWin32 ifFalse: [ ^false ].	Tools.Note temporarilyDisabled.   " VWorks doesn't understand File or system PATH [DL 03-Jan-95] "	"TEMP DISABLE:	( File findFileName: OLEDLL fileName ) isNil		ifTrue: [ ^false ].	"    [ OLEDLL current ]        on: Error        do: [:ex |  ^false ].  " unable to open or wrong version "	^true</body><body package="Com- Ole">checkIsDCOMEnabled        " Private - Determine whether DCOM support is enabled. "	HostInterface isWin32 ifFalse: [ ^false ].	^COMRegistryInterface isDCOMEnabled</body><body package="Com- Ole">checkIsFreeThreadingAvailable        " Private - Determine whether Free Threading support is available in OLE32.dll. "	HostInterface isWin32 ifFalse: [ ^false ].	[ OLEDLL current ]		on: Error		do: [:ex |  ^false ].  " unable to open or wrong version "	^OLEDLL current includesEntryPoint: 'CoInitializeEx'</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>private-tracing</category><body package="Com- Ole">logServerExit	" Append an entry to the COM trace log at exit of a COM object server application. "	self isTraceEnabled		ifTrue: [			self traceManager				log: (#ExitingObjectServer &lt;&lt; #com &gt;&gt; 'Exiting COM object server application') asString;				logCr ].</body><body package="Com- Ole">logServerStartup	" Append an entry to the COM trace log for entry to a COM object server application. "	self isTraceEnabled		ifTrue: [			self traceManager				logCr;				log: ((#GenKey37 &lt;&lt; #com &gt;&gt; 'Starting COM object server application  (&lt;1s&gt; &lt;2s&gt;)')			expandMacrosWith: Date today printString			with: Time now printString);				log: ((#GenKey36 &lt;&lt; #com &gt;&gt; '&lt;t&gt;Session command line: &lt;1p&gt;')			expandMacrosWith: ImageConfiguration commandLine );				logCr ].</body><body package="Com- Ole">logServerTermination	" Append an entry to the COM trace log for termination of a COM object server application. "	self isTraceEnabled		ifTrue: [			self traceManager				logCr;				log: ((#GenKey38 &lt;&lt; #com &gt;&gt; 'Terminating COM object server application  (&lt;1s&gt; &lt;2s&gt;)')			expandMacrosWith: Date today printString			with: Time now printString);				logCr ].</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>event accessing</category><body package="Com- Ole">addRegistrationSupportForClass: aClass 	"Add automatic registration support for this class - that is, include the class into the list of COM servers which will be registered when the /RegServer command-line option is passed without specifying a class to register."	(aClass respondsTo: #comRegistrationSpec) 		ifTrue: [self classNamesForRegistration add: aClass unambiguousName]</body><body package="Com- Ole">removeRegistrationSupportForClass: aClass 	"Remove automatic registration support for aClass"	self classNamesForRegistration remove: aClass unambiguousName ifAbsent: nil</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>accessing</category><body package="Com- Ole">defaultDefaultLCIDInitializerBlock	"Return the block which is per default used to initialize the default Initializer Block"	^ [ self defaultLocaleID: 1033 ].</body><body package="Com- Ole">initializeDefaultLCIDInitializer	self defaultLocaleIDInitializer: self defaultDefaultLCIDInitializerBlock</body><body package="Com- Ole">savedResources		^ SavedResources ifNil: [ SavedResources := Dictionary new ].</body><body package="Com- Ole">savedResources: anObject		^ SavedResources := anObject</body></methods><methods><class-id>External.COMSessionManager class</class-id> <category>instance creation</category><body package="Com- Ole">new        " Disallow the instantiation of instances.  This class provides session management services. "	Tools.Note ISSUEin72. "original code was '^ self invalidMessage' which was not implemented"    ^self shouldNotImplement</body></methods><methods><class-id>External.IClassFactoryImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeCreateInstance: this _: pUnkOuter _: riid _: ppvObject	" Private - invoke the IClassFactory::CreateInstance function for an external caller. "	" HRESULT CreateInstance(            /* [unique][in] */ IUnknown *pUnkOuter,            /* [in] */ REFIID riid,            /* [out] */ void **ppvObject); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult controllingUnknown iid resultReference |	self reportExternalFunctionEntry.	(riid isValid and: [ppvObject isValid]) ifFalse: [^E_INVALIDARG].	controllingUnknown := self interfaceAtAddress: pUnkOuter type: IUnknown.	iid := self guidAtAddress: riid.	self clearPointerResultValueAtAddress: ppvObject.	resultReference := nil asValueReference.	hresult := implementor				CreateInstance: controllingUnknown				_: iid				_: resultReference.	hresult succeeded		ifTrue: [self interfaceResultAtAddress: ppvObject put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeLockServer: this _: fLock        " Private - invoke the IClassFactory::LockServer function for an external caller. "	" HRESULT LockServer(            /* [in] */ BOOL fLock); "	^[   " terminate exception stack unwind at external callin boundary "	implementor LockServer: fLock.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IClassFactoryImplementation</class-id> <category>interface operations</category><body package="Com- Ole">CreateInstance: controllingUnknown _: iid _: resultReference        " Invoke the IClassFactory::CreateInstance function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor CreateInstance: controllingUnknown _: iid _: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">LockServer: aBoolean		" Invoke the IClassFactory::LockServer function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor LockServer: aBoolean		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IClassFactoryImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IClassFactory.	self vtableSignatureTypeName: #__IClassFactoryVtbl.	self updateAndRegister</body></methods><methods><class-id>External.IRootStoragePointer</class-id> <category>interface operations</category><body package="Com- Ole">SwitchToFile: aPathName		" Invoke the IRootStorage::SwitchToFile function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSwitchToFile: aPathName asUnicodeParameter</body></methods><methods><class-id>External.IRootStoragePointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IRootStorage.	self updateAndRegister</body></methods><methods><class-id>External.COMMemoryAddressResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Ole">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^CVoidType void pointerType</body></methods><methods><class-id>External.COMMemoryAddressResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Ole">getResultValue	" Private - answer the contents as a COM memory address. "	| lpData anAddress |	lpData := buffer contents.	lpData isNull		ifTrue: [ ^nil ].	anAddress := COMMemoryAddress fromPointer: lpData.	"??? anAddress needsFinalization. ???"  " we probably should be assuming ownership responsibility at this point... "	^anAddress</body></methods><methods><class-id>External.IStorage</class-id> <category>conversion operations</category><body package="Com- Ole">clearConvertStg		" Clear the conversion bit on the receiver object storage 		which tags the object it contains for conversion to another class. "    ^OLEDLL current SetConvertStg: self _: false</body><body package="Com- Ole">doAutoConvert        " Automatically convert an object in the receiver storage and        answer the CLSID to which the object was converted. "    | resultReference |    resultReference := nil asValueReference.    OLEDLL current OleDoAutoConvert: self _: resultReference.    ^resultReference value</body><body package="Com- Ole">getConvertStg        " Answer whether the conversion bit is set on the receiver object storage. "    ^( OLEDLL current GetConvertStg: self ) = S_OK</body><body package="Com- Ole">setConvertStg		" Set the conversion bit on the receiver object storage 		to tag the object it contains for conversion to another class. "    ^OLEDLL current SetConvertStg: self _: true</body><body package="Com- Ole">setConvertStg: convertFlag        " Set the conversion bit as specified by &lt;convertFlag&gt; in the receiver object storage.        The boolean &lt;convertFlag&gt; if TRUE tags the object for conversion to another class        of object; FALSE clears the conversion bit.  "    ^OLEDLL current SetConvertStg: self _: convertFlag</body></methods><methods><class-id>External.IStorage</class-id> <category>interface operations-operations</category><body package="Com- Ole">copyTo: destStorage		" Copy the contents of the storage to &lt;destStorage&gt;. "	interface CopyTo: 0 _: nil _: nil _: destStorage.</body><body package="Com- Ole">copyTo: destStorage excludeElements: elementExclusionList		" Copy the contents of the storage object to &lt;destStorage&gt;.		Storage elements whose names are in &lt;elementExclusionList&gt; 		are not copied to the destination.		Raise an exception if an error occurs.  Answer the result code. "	^interface CopyTo: 0 		_: nil		_: elementExclusionList 		_: destStorage</body><body package="Com- Ole">copyTo: destStorage excludeIIDs: iidExclusionList excludeElements: elementExclusionList		" Copy the contents of the storage object to &lt;destStorage&gt;.		Any interface identifiers in the list &lt;iidExclusionList&gt; are left to the		responsibility of the caller to copy.  Storage elements whose names		are in &lt;elementExclusionList&gt; are not copied to the destination.		Raise an exception if an error occurs.  Answer the result code. "	^interface CopyTo: iidExclusionList size 		_: iidExclusionList 		_: elementExclusionList 		_: destStorage</body><body package="Com- Ole">destroyElement: elementName		" Destroy the element named &lt;elementName&gt; in the storage object. "	interface DestroyElement: elementName.</body><body package="Com- Ole">moveElement: elementName to: destStorage		" Move the element named &lt;elementName&gt; in the the storage object		to the destination storage &lt;destStorage&gt;. "	interface MoveElementTo: elementName 		_: destStorage 		_: elementName		 _: STGMOVE_MOVE.</body><body package="Com- Ole">moveElement: elementName to: destStorage newName: newElementName		" Move the element named &lt;elementName&gt; in the the storage object		to the destination storage &lt;destStorage&gt; as &lt;newElementName&gt;. "	interface MoveElementTo: elementName 		_: destStorage 		_: newElementName		 _: STGMOVE_MOVE.</body><body package="Com- Ole">renameElement: elementName to: newElementName		" Rename the element named &lt;elementName&gt; in the storage		to have &lt;newElementName&gt;. "	interface RenameElement: elementName _:  newElementName</body></methods><methods><class-id>External.IStorage</class-id> <category>interface operations-storages</category><body package="Com- Ole">createStorage: storageName        " Create and open a new storage object named &lt;storageName&gt; in this storage        in read/write mode.  Answer the new storage. "	^self createStorage: storageName 		accessMode: self class accessModeReadWrite</body><body package="Com- Ole">createStorage: storageName accessMode: accessModeFlags        " Create and open a new storage object named &lt;storageName&gt; in this storage.        with STGM access mode flags &lt;accessModeFlags&gt;.  Answer the new storage. "	| resultReference hresult anIStorage |	resultReference := IStorage new asValueReference.	hresult := interface CreateStorage: storageName 		_: accessModeFlags 		_: 0 		_: 0 		_: resultReference.    hresult = S_OK   " STG_S_CONVERTED "        ifFalse: [ COMResultNotification hresult: hresult ].	anIStorage := resultReference value.	^anIStorage		container: self;		yourself</body><body package="Com- Ole">newStorage: storageName		" Create and open a new storage object named &lt;storageName&gt; in this storage		in read/write mode.  Remove the existing storage object of that name, if any.		Answer the new storage. "	^self createStorage: storageName 		accessMode: STGM_CREATE | self class accessModeReadWrite</body><body package="Com- Ole">newTransactedStorage: storageName		" Create and open a new storage object named &lt;storageName&gt; in this storage		in read/write mode.  Remove the existing storage object of that name, if any.		Answer the new storage. "	^self createStorage: storageName 		accessMode: 			STGM_CREATE 			| STGM_TRANSACTED 			| self class accessModeReadWrite</body><body package="Com- Ole">openOrCreateStorage: aName	^[self openStorageReadOnly: aName] on: COMError		do: 			[:ex |			ex hresult = STG_E_FILENOTFOUND				ifTrue: [self createStorage: aName accessMode: self class createMode]				ifFalse: [ex pass]]</body><body package="Com- Ole">openStorage: storageName        " Open an existing storage object named &lt;storageName&gt; in this storage        in read/write mode.  Answer the storage. "    ^self openStorage: storageName 		accessMode: self class accessModeReadWrite		storagePriority: nil		emptyElements: nil</body><body package="Com- Ole">openStorage: storageName accessMode: accessModeFlags		" Open an existing storage object named &lt;storageName&gt; in this storage.        with STGM access mode flags &lt;accessModeFlags&gt;.  Answer the storage. "	^self openStorage: storageName 		accessMode: accessModeFlags 		storagePriority: nil		emptyElements: nil</body><body package="Com- Ole">openStorage: storageName accessMode: accessModeFlags emptyElements: emptyElementList		" Open an existing storage object named &lt;storageName&gt; in this storage.		with STGM access mode flags &lt;accessModeFlags&gt;.  		The elements whose names are in the &lt;emptyElementList&gt; are		emptied when the storage is opened (streams are set to 0 length, storages		have their elements removed).		Answer the storage. "	^self openStorage: storageName 		accessMode: accessModeFlags 		storagePriority: nil		emptyElements: emptyElementList</body><body package="Com- Ole">openStorage: storageName 	accessMode: accessModeFlags 	storagePriority: storagePriority	emptyElements: emptyElementList		" Open an existing storage object named &lt;storageName&gt; in this storage.		with STGM access mode flags &lt;accessModeFlags&gt;.  		The &lt;storagePriority&gt; is a previously opened root IStorage.		The elements whose names are in the &lt;emptyElementList&gt; are		emptied when the storage is opened (streams are set to 0 length, storages		have their elements removed).		Answer the storage. "	| resultReference anIStorage |	resultReference := IStorage new asValueReference.	interface OpenStorage: storageName 		_: storagePriority 		_: accessModeFlags 		_: emptyElementList 		_: 0 		_: resultReference.	anIStorage := resultReference value.	^anIStorage		container: self;		yourself</body><body package="Com- Ole">openStorageReadOnly: storageName        " Open an existing storage object named &lt;storageName&gt; in this storage.        in readOnly mode.  Answer the storage. "    ^self openStorage: storageName 		accessMode: self class accessModeReadOnly		storagePriority: nil		emptyElements: nil</body></methods><methods><class-id>External.IStorage</class-id> <category>interface operations-streams</category><body package="Com- Ole">createStream: streamName		" Create and open a new stream object named &lt;streamName&gt; in this storage.		Answer the new stream. "    ^self createStream: streamName 		accessMode: self class accessModeReadWrite</body><body package="Com- Ole">createStream: streamName accessMode: accessModeFlags		" Create and open a new stream object named &lt;streamName&gt; in this storage		with STGM access mode flags &lt;accessModeFlags&gt;.  Answer the new stream. "	| resultReference anIStream |	resultReference := IStream new asValueReference.	interface CreateStream: streamName 		_: accessModeFlags 		_: 0 		_: 0 		_: resultReference.	anIStream := resultReference value.	^anIStream		container: self;		yourself</body><body package="Com- Ole">newStream: streamName        " Create and open a new stream object named &lt;streamName&gt; in this storage.		Remove the existing stream object with that name, if any.		Answer the new stream. "    ^self createStream: streamName 		accessMode: STGM_CREATE | self class accessModeReadWrite</body><body package="Com- Ole">openOrCreateStream: aName	^[self openStream: aName accessMode: self class accessModeReadOnly] on: COMError		do: 			[:ex |			ex hresult = STG_E_FILENOTFOUND				ifTrue: [self createStream: aName accessMode: self class createMode]				ifFalse: [ex pass]]</body><body package="Com- Ole">openStream: streamName		" Open an existing stream object named &lt;streamName&gt; in this storage        in read/write mode.  Answer the stream. "    ^self openStream: streamName 		accessMode: self class accessModeReadWrite</body><body package="Com- Ole">openStream: streamName accessMode: accessModeFlags		" Open an existing stream object named &lt;streamName&gt; in this storage		with STGM access mode flags &lt;accessModeFlags&gt;.  Answer the stream. "	| resultReference anIStream |	resultReference := IStream new asValueReference.	interface OpenStream: streamName 		_: nil 		_: accessModeFlags 		_: 0 		_: resultReference.	anIStream := resultReference value.	^anIStream		container: self;		yourself</body><body package="Com- Ole">openStreamReadOnly: streamName		" Open an existing stream object named &lt;streamName&gt; in this storage        in readOnly mode.  Answer the stream. "    ^self openStream: streamName 		accessMode: self class accessModeReadOnly</body></methods><methods><class-id>External.IStorage</class-id> <category>utility operations</category><body package="Com- Ole">readCLSID        " Answer the CLSID associated with the receiver. "    | resultReference |    resultReference := nil asValueReference.    OLEDLL current ReadClassStg: self        _: resultReference.    ^resultReference value</body><body package="Com- Ole">readClipboardFormatAndUserType        " Answer an Array containing the clipboard format and current user type of the receiver.        Either may be nil, indicating that the value is no longer of interest to the caller. "    | resultReferenceClipboardFormat resultReferenceUserType |    resultReferenceClipboardFormat := nil asValueReference.    resultReferenceUserType := nil asValueReference.    OLEDLL current ReadFmtUserTypeStg: self        _: resultReferenceClipboardFormat        _: resultReferenceUserType.    ^Array        with: resultReferenceClipboardFormat value        with: resultReferenceUserType value</body><body package="Com- Ole">writeCLSID: clsid		" Set the CLSID associated with the receiver to the GUID &lt;clsid&gt;. "	^OLEDLL current WriteClassStg: self _: clsid</body><body package="Com- Ole">writeClipboardFormat: aClipboardFormat userType: userTypeString		" Set the clipboard format and current user type of the receiver. "	^OLEDLL current WriteFmtUserTypeStg: self 		_: aClipboardFormat 		_: userTypeString</body></methods><methods><class-id>External.IStorage</class-id> <category>interface operations-accessing</category><body package="Com- Ole">elementsEnumerator		" Answer an enumerator that can be used to enumerate the		storage elements which are directly contained in the receiver. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumSTATSTG ) asValueReference.	interface EnumElements: 0 _: nil _: 0 _: resultReference.	^resultReference value</body><body package="Com- Ole">setClass: clsid		" Set the CLSID of the storage to the GUID &lt;clsid&gt;. 		Raise an exception if an error occurs.  Answer the result code. "	^interface SetClass: clsid</body><body package="Com- Ole">setElementTimes: elementName 	createdTime: cTime 	accessedTime: aTime 	modifiedTime: mTime		" Set the modification, access, and create times of the element		named &lt;elementName&gt; in the storage object.		Raise an exception if an error occurs.  Answer the result code. "	^interface SetElementTimes: elementName _: cTime _: aTime _: mTime</body><body package="Com- Ole">setStateBits: stateBits mask: mask		" Set the state bits of the storage object from the 32-bit value &lt;stateBits&gt;.		The binary &lt;mask&gt; indicates which state bits are significant in this call.		Raise an exception if an error occurs.  Answer the result code. "	^interface SetStateBits: stateBits _: mask</body></methods><methods><class-id>External.IStorage</class-id> <category>testing</category><body package="Com- Ole">hasElementNamed: elementName		"Answer whether the receiver contains a storage element named &lt;elementName&gt;. "	| hasElement |	hasElement := false.	self elements do: [ :aStatStg |		aStatStg name = elementName			ifTrue: [ hasElement := true ].		aStatStg enforceRelease ].	^hasElement</body><body package="Com- Ole">hasStorageNamed: elementName		"Answer whether the receiver contains a storage named &lt;elementName&gt;. "	| hasElement |	hasElement := false.	self elements do: [ :aStatStg |		( aStatStg isStorage		and: [ aStatStg name = elementName ] )			ifTrue: [ hasElement := true ].		aStatStg enforceRelease ].	^hasElement</body><body package="Com- Ole">hasStreamNamed: elementName		"Answer whether the receiver contains a stream named &lt;elementName&gt;. "	| hasElement |	hasElement := false.	self elements do: [ :aStatStg |		( aStatStg isStream		and: [ aStatStg name = elementName ] )			ifTrue: [ hasElement := true ].		aStatStg enforceRelease ].	^hasElement</body><body package="Com- Ole">isStorage		" Answer whether the receiver is an IStorage. "	^true</body></methods><methods><class-id>External.IStorage</class-id> <category>accessing</category><body package="Com- Ole">elementNames		"Answer a collection of the names of the storage and stream elements		directly contained within the receiver."    | names |    names := OrderedCollection new.    self elements do: [ :aStatStg |		names add: aStatStg name.		aStatStg enforceRelease ].    ^names</body><body package="Com- Ole">elements	" Answer the storage elements which are directly contained in the receiver. "	| anEnumerator |	anEnumerator := self elementsEnumerator.	^[anEnumerator contents] ensure: [anEnumerator enforceRelease]</body><body package="Com- Ole">storageNames		"Answer a collection of the names of the storages 		directly contained within the receiver."    | names |    names := OrderedCollection new.    self elements do: [ :aStatStg |		aStatStg isStorage			ifTrue: [ names add: aStatStg name ].		aStatStg enforceRelease ].    ^names</body><body package="Com- Ole">streamNames		"Answer a collection of the names of the streams 		directly contained within the receiver."    | names |    names := OrderedCollection new.    self elements do: [ :aStatStg |		aStatStg isStream			ifTrue: [ names add: aStatStg name ].		aStatStg enforceRelease ].    ^names</body></methods><methods><class-id>External.IStorage class</class-id> <category>access mode constants</category><body package="Com- Ole">accessModeReadOnly		" Answer the access mode flags for readOnly access. "	^STGM_READ | STGM_SHARE_EXCLUSIVE</body><body package="Com- Ole">accessModeReadWrite		" Answer the access mode flags for read/write access. "	^STGM_READWRITE | STGM_SHARE_EXCLUSIVE</body><body package="Com- Ole">createMode	^ self accessModeReadWrite":Section ReferencecreateModeDescription:			Helper to set the mode to create when creating a new IStorage file.Assumptions:			none.Return Value:			The STGM mode flags constant.Receiver Modified:	No.:End"</body><body package="Com- Ole">createNewMode	^ (STGM_DIRECT | STGM_READWRITE | STGM_SHARE_EXCLUSIVE | STGM_FAILIFTHERE).</body></methods><methods><class-id>External.IStorage class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IStorage.	self updateAndRegister</body></methods><methods><class-id>External.COMGlobalMemoryStorage</class-id> <category>private-accessing</category><body package="Com- Ole">lockBytes		" Private - answer the ILockBytes on which the receiver is defined. "	^iLockBytes</body><body package="Com- Ole">lockBytes: anILockBytes		" Private - specify the ILockBytes on which the receiver is defined. "	iLockBytes := anILockBytes.</body></methods><methods><class-id>External.COMGlobalMemoryStorage</class-id> <category>accessing</category><body package="Com- Ole">memoryAddress		" Answer the global memory address of the receiver. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current GetHGlobalFromILockBytes: self lockBytes		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.COMGlobalMemoryStorage</class-id> <category>converting</category><body package="Com- Ole">asByteArray	"Answer a ByteArray whose contents are the bytes of the receiver."	^( Win32MemoryReadWriteStream byteStreamOn: self memoryAddress )		contents"Implementation note:  The obvious implementation of this method is:	| nBytes nBytesRead bytes |	nBytes := self lockBytes size.	bytes := ByteArray new: nBytes.	nBytesRead := self lockBytes readAt: 0		buffer: bytes		count: nBytes.	""Assert isTrue: nBytesRead = nBytes ].""	^bytesThis implementation uses the COM-implemented ILockBytes::ReadAt service.  However, we encounterproblems (Protection Violation) which we have not been able to track downwhen reading large backing store contents directly from theCOM-implemented ILockBytes::ReadAt on the global memory.Extracting the bytes seems to work properly when we use our own memory stream accessing logic, however, so the alternate implementation usingMemoryReadWriteStream is used in this method."</body></methods><methods><class-id>External.COMGlobalMemoryStorage</class-id> <category>private-releasing</category><body package="Com- Ole">releaseLockBytes		" Private - release the receiver's byte array. "	self lockBytes: nil.</body></methods><methods><class-id>External.COMGlobalMemoryStorage</class-id> <category>private</category><body package="Com- Ole">privateRelease	" Release the receiver. ""	(iLockBytes notNil and: [iLockBytes isValid])		ifTrue: [iLockBytes enforceRelease]."	self releaseLockBytes.</body></methods><methods><class-id>External.COMGlobalMemoryStorage</class-id> <category>releasing</category><body package="Com- Ole">release		" Release the receiver. "	self releaseLockBytes.	^ super release.</body></methods><methods><class-id>External.COMGlobalMemoryStorage class</class-id> <category>creating</category><body package="Com- Ole">createOnAddress: aGlobalMemoryAddress deleteOnRelease: deleteOnRelease	" Answer a new instance of the receiver which is an IStorage on &lt;aGlobalMemoryAddress&gt;.  If &lt;deleteOnRelease&gt; is set the memory will be released by COM when the stream is released. "	| anILockBytes resultReference |	anILockBytes := ILockBytes createOnAddress: aGlobalMemoryAddress deleteOnRelease: deleteOnRelease.	resultReference := self new asValueReference.	OLEDLL current		StgCreateDocfileOnILockBytes: anILockBytes		_: STGM_CREATE | STGM_READWRITE | STGM_SHARE_EXCLUSIVE		_: 0		_: resultReference.	resultReference value lockBytes: anILockBytes.	^resultReference value</body><body package="Com- Ole">createOnLockBytes: anILockBytes	"Answer a new instance of the receiver which is an IStorage on &lt;anILockBytes&gt;.  "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current StgCreateDocfileOnILockBytes: anILockBytes		_: ( STGM_CREATE			| STGM_READWRITE			| STGM_SHARE_EXCLUSIVE )		_: 0		_: resultReference.	resultReference value lockBytes: anILockBytes.	^resultReference value</body><body package="Com- Ole">newTemporaryBackingStore	" Create a temporary structured storage in global memory.  Answer a new instance of the receiver on the storage object.  The memory will be released when the stream is released. "	^self createOnAddress: nil deleteOnRelease: true</body></methods><methods><class-id>External.COMGlobalMemoryStorage class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerIID	" Private - register the receiver as the interface class for its IID.  Do nothing for the receiver - its superclass IStorage is correctly registered as the class for the (shared) IID. "</body><body package="Com- Ole">removeIID	" Private - remove the registration of the receiver as the interface class for its IID.  Do nothing for the receiver - its superclass IStorage manages the registration for the (shared) IID. "</body></methods><methods><class-id>External.COMGlobalMemoryStorage class</class-id> <category>opening</category><body package="Com- Ole">on: aByteObject		" Answer a new instance of the receiver which is an IStorage 		on a newly allocated block of global memory whose contents		are initialized with the data in &lt;aByteObject&gt;.		The memory will be released when the stream is released. "	| aGlobalMemoryAddress anIStorage |	aByteObject class isBits		ifFalse: [ COMError raiseSignal: #ErrSourceBeByte &lt;&lt; #com &gt;&gt; 'source must be a byte object' ].	aByteObject isString		ifTrue: [   " strings not yet supported (trailing null philosophy not yet specified) "			COMError raiseSignal: #ErrMustBeByteArray &lt;&lt; #com &gt;&gt; 'must be a ByteArray' ].      " Note: the memory allocation flags are tricky.  The OLE Programmer's		Reference Vol. I says that the global memory must be movable.		However, omitting GMEM_MOVEABLE seems to the only		way we can get this to work. "	aGlobalMemoryAddress := Win32GlobalMemoryAddress		copyToExternalMemory: aByteObject		flags: ( GMEM_SHARE | "GMEM_MOVEABLE |" GMEM_NODISCARD ).	anIStorage := self openOnAddress: aGlobalMemoryAddress 		deleteOnRelease: true.	"Assert isTrue: [ anIStorage lockBytes isStorageBytes ]."	"Assert isTrue: [ anIStorage lockBytes size = nBytes ]."	^anIStorage</body><body package="Com- Ole">openOnAddress: aGlobalMemoryAddress deleteOnRelease: deleteOnRelease	" Answer a new instance of the receiver which is an IStorage on &lt;aGlobalMemoryAddress&gt;.  If &lt;deleteOnRelease&gt; is set the memory will be released by COM when the stream is released. "	| anILockBytes |	anILockBytes := ILockBytes createOnAddress: aGlobalMemoryAddress 		deleteOnRelease: deleteOnRelease.	^self openOnLockBytes: anILockBytes</body><body package="Com- Ole">openOnLockBytes: anILockBytes	" Answer a new instance of the receiver which is an IStorage on &lt;anILockBytes&gt;.  "	^self openOnLockBytes: anILockBytes		accessFlags: (			STGM_TRANSACTED |			STGM_READWRITE |			STGM_SHARE_DENY_WRITE )</body><body package="Com- Ole">openOnLockBytes: anILockBytes accessFlags: accessFlags	" Answer a new instance of the receiver which is an IStorage opened on &lt;anILockBytes&gt; with &lt;accessFlags&gt;.  "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current StgOpenStorageOnILockBytes: anILockBytes		_: nil		_: accessFlags		_: nil		_: 0		_: resultReference.	resultReference value lockBytes: anILockBytes.	^resultReference value</body><body package="Com- Ole">openOnLockBytesReadOnly: anILockBytes	" Answer a new instance of the receiver which is a read only  IStorage on &lt;anILockBytes&gt;.  "	^self openOnLockBytes: anILockBytes 		accessFlags: self accessModeReadOnly</body></methods><methods><class-id>External.COMGlobalMemoryStorage class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IStorage.	self updateAndRegister</body></methods><methods><class-id>External.COM_OBJECTDESCRIPTOR</class-id> <category>accessing</category><body package="Com- Ole">clsid        "Answer the receiver's class id field."    ^self guidMemberAt: #clsid</body><body package="Com- Ole">clsid: aGUID        "Set the receiver's class id field."    self guidMemberAt: #clsid put: aGUID.</body><body package="Com- Ole">drawAspect        "Answer the receiver's drawAspect field."    ^self memberAt: #dwDrawAspect</body><body package="Com- Ole">pointl        "Answer the receiver's pointl field."    | aPointStruct |    aPointStruct := self structure memberAt: #pointl.    ^( aPointStruct memberAt: #x ) @ ( aPointStruct memberAt: #y )</body><body package="Com- Ole">pointl: aPoint        "Set the receiver's pointl field."    | aPointStruct |    aPointStruct := self structure memberAt: #pointl.    aPointStruct        memberAt: #x put: aPoint x;        memberAt: #y put: aPoint y.    self structure memberAt: #pointl put: aPointStruct.</body><body package="Com- Ole">sizel        "Answer the receiver's sizel field."    | aSizeStruct |    aSizeStruct := self structure memberAt: #sizel.    ^( aSizeStruct memberAt: #cx ) @ ( aSizeStruct memberAt: #cy )</body><body package="Com- Ole">sizel: aPoint        "Set the receiver's sizel field."    | aSizeStruct |    aSizeStruct := self structure memberAt: #sizel.    aSizeStruct        memberAt: #cx put: aPoint x;        memberAt: #cy put: aPoint y.    self structure memberAt: #sizel put: aSizeStruct.</body></methods><methods><class-id>External.COM_OBJECTDESCRIPTOR class</class-id> <category>instance creation</category><body package="Com- Ole">fromOleObject: anIOleObject userTypeName: userType srcOfCopy: srcOfCopy        " Answer an instance of the receiver. Append null-terminated strings        &lt;userTypeString&gt; and &lt;srcOfCopyString&gt; to the end of the structure        with the size of the structure adjusted accordingly. "	| ucBytesUserType userTypeSize userTypeOffset 	  ucBytesSrcOfCopy srcOfCopySize srcOfCopyOffset 	  totalSizeInBytes |	" convert user type name to Unicode "	ucBytesUserType := COMExternalInterface asUnicodeStringBytes: userType.	userTypeSize := ucBytesUserType size.	userTypeOffset := self sizeInBytes.	" convert copy source description to Unicode "	ucBytesSrcOfCopy := ( srcOfCopy size &gt; 0		ifTrue: [ COMExternalInterface asUnicodeStringBytes: srcOfCopy ]		ifFalse: [ ucBytesUserType ] ).	srcOfCopySize := ucBytesSrcOfCopy size.	srcOfCopyOffset := userTypeOffset + userTypeSize.	totalSizeInBytes := srcOfCopyOffset + srcOfCopySize.	^( self new: totalSizeInBytes )		memberAt: #cbSize put: totalSizeInBytes;		memberAt: #dwFullUserTypeName put: userTypeOffset;		memberAt: #dwSrcOfCopy put: srcOfCopyOffset;		bytesAtOffset: userTypeOffset put: ucBytesUserType;		bytesAtOffset: srcOfCopyOffset put: ucBytesSrcOfCopy;		yourself</body><body package="Com- Ole">new: nBytes	" Answer a new instance of the receiver with a buffer of &lt;nBytes&gt;. "	nBytes &lt; self sizeInBytes		ifTrue: [ self error: (#ErrNamedTooSmallStruc &lt;&lt; #com &gt;&gt; 'too small for an &lt;1s&gt;' expandMacrosWith: self structureName) ].	^self onNew: ( CComposite newDatum: ( UninterpretedBytes new: nBytes )		ofType: self type )</body></methods><methods><class-id>External.COM_OBJECTDESCRIPTOR class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self structureName: #OBJECTDESCRIPTOR.	self updateAndRegister</body></methods><methods><class-id>External.IAnonymous</class-id> <category>identity</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid</body><body package="Com- Ole">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;. "	iid := anIID.	interface notNil		ifTrue: [ interface iid: anIID ].</body></methods><methods><class-id>External.IAnonymous</class-id> <category>private-error handling</category><body package="Com- Ole">checkInterfaceBindingIID: anInterfaceBinding    " Private - verify that a consistent binding is being installed in the receiver. "	" by definition this class doesn't support any particular IID's, so we just want to ensure we're internally consistent "	anInterfaceBinding iid = self iid        ifFalse: [ self error: 'IID mismatch' ].</body></methods><methods><class-id>External.IAnonymous class</class-id> <category>subclass-tracing</category><body package="Com- Ole">canTraceAdaptorAssumeHRESULT	" Answer whether a trace adaptor configured on an instance of the receiver can assume that the functions in the interface represented by the receiver follow the standard COM convention of returning an HRESULT as the function return value, with OUT values returned via parameter values. "	^false</body></methods><methods><class-id>External.IAnonymous class</class-id> <category>instance creation</category><body package="Com- Ole">forBinding: anInterfaceBinding	" Answer a new instance of the receiver with callin/callout binding &lt;anInterfaceBinding&gt;. "	^self new		iid: anInterfaceBinding iid;		interfaceBinding: anInterfaceBinding;			yourself</body><body package="Com- Ole">forIID: anIID	" Answer a new instance of the receiver for the interface specified by &lt;anIID&gt;. "	^self new		iid: anIID;		yourself</body></methods><methods><class-id>External.IAnonymous class</class-id> <category>identity</category><body package="Com- Ole">supportsIID: anIID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^false</body></methods><methods><class-id>External.IAnonymous class</class-id> <category>subclass-accessing</category><body package="Com- Ole">interfacePointerClass	" Private - answer the interface pointer class which is referenced by instances of the receiver. "	^IAnonymousPointer</body></methods><methods><class-id>External.IAnonymous class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	" private internal IID for cross-referencing.	  IAnonymous does not represent any specific interface "	self iid: IID_IAnonymous.	self updateAndRegister</body></methods><methods><class-id>External.IDataAdviseHolder</class-id> <category>interface operations</category><body package="Com- Ole">createAdviseConnectionFrom: aDataObject	to: anAdviseSink	format: aFormatEtc	flags: advfFlags		" Create an advise connection between the data object &lt;aDataObject&gt; 		and the advise sink &lt;anAdviseSink&gt; though which the sink can		be informed when the object's data changes.  The format		specified by &lt;aFormatEtc&gt; will be used when reporting changes.		The ADVF flags in &lt;advfFlags&gt; control the connection.		Answer a connection token which can later be used to delete		this advise connection. "	| resultReference |	resultReference := nil asValueReference.	interface Advise: aDataObject 		_: aFormatEtc		_: advfFlags		_: anAdviseSink 		_: resultReference.	^resultReference value</body><body package="Com- Ole">dataAdviseConnectionsEnumerator		" Answer an enumerator on the collection of STATDATA structures which 		describe the data advise connections currently established on the data object. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumSTATDATA ) asValueReference.	interface EnumAdvise: resultReference.	^resultReference value</body><body package="Com- Ole">removeAdviseConnection: connectionToken		"Delete the advisory connection identified by &lt;connectionToken&gt;,		which previously established using IDataAdviseHolder::Advise. "	interface Unadvise: connectionToken.</body><body package="Com- Ole">sendOnDataChange: aDataObject flags: advfFlags		"Invoke IAdviseSink::OnDataChange for all advisory sinks currently		registered with the holder whenever changes of interest to the object		represented by &lt;aDataObject&gt; occur.  The &lt;advfFlags&gt; flags specify		information about the notification to be sent. "	interface SendOnDataChange: aDataObject  _: 0 _: advfFlags.</body></methods><methods><class-id>External.IDataAdviseHolder</class-id> <category>accessing</category><body package="Com- Ole">dataAdviseConnections		" Answer a collection of STATDATA structures which describe		the data advise connections currently established on the data object. "	| anEnumerator contents |	anEnumerator := self dataAdviseConnectionsEnumerator.	contents := anEnumerator contents.	^contents</body></methods><methods><class-id>External.IDataAdviseHolder class</class-id> <category>instance creation</category><body package="Com- Ole">newHolder	" Create a new data advise holder.  Answer a new instance of the receiver. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current CreateDataAdviseHolder: resultReference.	^resultReference value</body></methods><methods><class-id>External.IDataAdviseHolder class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IDataAdviseHolder.	self updateAndRegister</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>object information utilities</category><body package="Com- Ole">getDataFormats: clsid		" Answer the formats registered in the registration database as the supported formats		which can be used to obtain the state of instances of the CLSID &lt;clsid&gt;. "	| anEnumerator contents |	anEnumerator := self getDataFormatsEnumerator: clsid.	anEnumerator isNil		ifTrue: [ ^#( ) ].	contents := anEnumerator contents.	^contents</body><body package="Com- Ole">getDataFormatsEnumerator: clsid		" Answer an enumerator that can be used to enumerate the formats		registered in the registration database as the supported formats		which can be used to obtain the state of instances of the CLSID &lt;clsid&gt;. "	| resultReference hresult |	resultReference := ( IEnum forIID: IID_IEnumFORMATETC ) asValueReference.	hresult := OLEDLL current OleRegEnumFormatEtc: clsid 		_: DATADIR_GET 		_: resultReference.	hresult = S_OK  " class or key not registered "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">getMiscStatus: clsid		" Answer the miscellaneous status information from the system registry 		for the DVASPECT_CONTENT aspect of the CLSID &lt;clsid&gt;. "	^self getMiscStatus: clsid aspect: DVASPECT_CONTENT</body><body package="Com- Ole">getMiscStatus: clsid aspect: dvAspect		" Answer the miscellaneous status information from the system registry 		for the DVASPECT value &lt;dvAspect&gt; of the CLSID &lt;clsid&gt;. "    | resultReference hresult |    resultReference := nil asValueReference.    hresult := OLEDLL current OleRegGetMiscStatus: clsid 		_: dvAspect 		_: resultReference.	hresult = S_OK  " class or key not registered "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">getUserTypeAppName: clsid		" Answer the name of the application servicing the class 		specified by the CLSID &lt;clsid&gt; in a user-presentable string. 		Used in the result text in dialogs."	| resultReference |	resultReference := nil asValueReference.	OLEDLL current OleRegGetUserType: clsid 		_: USERCLASSTYPE_APPNAME		_: resultReference.	^resultReference value</body><body package="Com- Ole">getUserTypeFull: clsid		" Answer the full type name of the class specified by the CLSID &lt;clsid&gt;		in a user-presentable string. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current OleRegGetUserType: clsid 		_: USERCLASSTYPE_FULL		_: resultReference.	^resultReference value</body><body package="Com- Ole">getUserTypeShort: clsid		" Answer the short type name of the class specified by the CLSID &lt;clsid&gt;		in a user-presentable string.  Used in popup menus and the Links dialog. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current OleRegGetUserType: clsid 		_: USERCLASSTYPE_SHORT		_: resultReference.	^resultReference value</body><body package="Com- Ole">serverNameOf: aCLSID		" Answer the name of the object server application registered for &lt;aCLSID&gt;. "    | clsidSection clsid clsidEntries serverKeys |    clsidSection := self classesRegistry at: 'CLSID'.    serverKeys := #( 'InprocServer' 'InprocServer32' 'LocalServer' 'LocalServer32' ).    clsidSection keysDo: [ :aKey |        ( ( clsid := GUID clsidFromString: aKey ) notNil        and: [ clsid = aCLSID ] )            ifTrue: [                clsidEntries := clsidSection at: aKey.                clsidEntries keysAndValuesDo: [ :key :value |                    ( serverKeys includes: key )                        ifTrue: [ ^value ].			].                ] ].    ^nil</body><body package="Com- Ole">setDataFormats: clsid		" Answer the formats registered in the registration database as the supported formats		which can be used to set the state of instances of the CLSID &lt;clsid&gt;. "	| anEnumerator contents |	anEnumerator := self setDataFormatsEnumerator: clsid.	anEnumerator isNil		ifTrue: [ ^#( ) ].	contents := anEnumerator contents.	^contents</body><body package="Com- Ole">setDataFormatsEnumerator: clsid		" Answer an enumerator that can be used to enumerate the formats		registered in the registration database as the supported formats		which can be used to set the state of instances of the CLSID &lt;clsid&gt;. "	| resultReference hresult |	resultReference := ( IEnum forIID: IID_IEnumFORMATETC ) asValueReference.	hresult := OLEDLL current OleRegEnumFormatEtc: clsid 		_: DATADIR_SET 		_: resultReference.	hresult = S_OK  " class or key not registered "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">verbs: clsid		" Answer the object verbs registered in the registration database 		for the CLSID &lt;clsid&gt;. "	| anEnumerator contents |	anEnumerator := self verbsEnumerator: clsid.	anEnumerator isNil		ifTrue: [ ^#( ) ].	contents := anEnumerator contents.	^contents</body><body package="Com- Ole">verbsEnumerator: clsid		" Answer an enumerator that can be used to enumerate the object verbs		registered in the registration database for the CLSID &lt;clsid&gt;. "	| resultReference hresult |	resultReference := ( IEnum forIID: IID_IEnumOLEVERB ) asValueReference.	hresult := OLEDLL current OleRegEnumVerbs: clsid 		_: resultReference.	hresult = S_OK  " class or key not registered or no verbs "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>type library information</category><body package="Com- Ole">currentTypeLibraryEntry: aCLSID	"Answer the type library entry for &lt;aCLSID&gt; for the current version of &lt;aCLSID&gt;"	| classesRegistry currentVersion typeLib |	( currentVersion := self currentTypeLibraryVersion: aCLSID ) isNil		ifTrue: [ ^nil ].	classesRegistry := self classesRegistry.	( typeLib := classesRegistry at: ( 'CLSID\' , aCLSID asString , '\TypeLib' ) ) isNil 		ifTrue: [ ^nil ].	^classesRegistry at: ( 'TypeLib\' , typeLib value , '\' , currentVersion ) ifAbsent: [ nil ]</body><body package="Com- Ole">currentTypeLibraryVersion: aCLSID	"Answer the type library entry for &lt;aCLSID&gt; for the current version of &lt;aCLSID&gt;"	| currentVersion |	currentVersion := self classesRegistry at: ( 'CLSID\', aCLSID asString, '\Version' ) 		ifAbsent: [ ^nil ].	^currentVersion value</body><body package="Com- Ole">getCurrentTypeLibraryVersionInfo: aTypeLibraryEntry		" Private - answer the version info under &lt;aTypeLibraryEntry&gt;		which defines the current version registered for the type library		as a list containing the version number string and the name. "	| currentVersionString currentVersionNumber aVersionNumber |	currentVersionNumber := 0.	aTypeLibraryEntry keysDo: [ :aVersionString |		( aVersionNumber := Number readFrom: aVersionString readStream ) &gt; currentVersionNumber			ifTrue: [ 				currentVersionNumber := aVersionNumber.				currentVersionString := aVersionString ] ].	^currentVersionString isNil		ifTrue: [ nil ]		ifFalse: [ Array 			with: currentVersionString			with: ( aTypeLibraryEntry at: currentVersionString ) value ]</body><body package="Com- Ole">getLocalesForVersionEntry: versionEntry		" Private - answer the list of supported locales for the given type library version. "	| localeKeys |	localeKeys := versionEntry keys select: [ :aKey |		( aKey detect: [ :c | c isDigit not ] ifNone: [ nil ] ) isNil ].	" perhaps should filter to Win32 platform... "	^localeKeys asArray collect: [ :aKey | 		Integer readFrom: aKey readStream radix: 16 ]</body><body package="Com- Ole">localesForTypeLibrary: typeLibraryID versionString: versionString	" Answer a list containing the supported locale ID's registered for the	specified version of the type library identified by the GUID &lt;typeLibraryID&gt;. "	| versionEntry locales |	versionEntry := self classesRegistry at: 'TypeLib\', typeLibraryID asString, '\', versionString.	locales := self getLocalesForVersionEntry: versionEntry.	^locales</body><body package="Com- Ole">typeLibraryCurrentVersionMap		" Answer a dictionary describing the current version of all 		the registered type libraries on the system.  The name		of the library is the key and the value is a list containing		the string representation of the library ID GUID, the		version string, and the locale id. "	" COMRegistryInterface typeLibraryCurrentVersionMap "	| currentVersionMap typeLibRegistry 	  aTypeLibEntry currentVersionInfo versionString description |	typeLibRegistry := self classesRegistry at: 'TypeLib'.	currentVersionMap := Dictionary new.	typeLibRegistry keysDo: [ :typeLibIDString |		aTypeLibEntry := typeLibRegistry at: typeLibIDString.		currentVersionInfo := self getCurrentTypeLibraryVersionInfo: aTypeLibEntry.		( currentVersionInfo notNil 		and: [ ( description := ( currentVersionInfo at: 2 ) ) size &gt; 0 ] )  " name "			ifTrue: [				currentVersionMap at: description					put: ( Array						with: typeLibIDString  " library ID GUID in string representation "						with: ( versionString := currentVersionInfo at: 1 )   " library version string "						with: ( self getLocalesForVersionEntry: ( aTypeLibEntry at: versionString ) ) ) ].		].	^currentVersionMap</body><body package="Com- Ole">typeLibraryCurrentVersionNumbers: aGUID	" Answer the most recent version registered for the type library identified by the ID &lt;aGUID&gt;,	in the form of a version numbers array containing &lt;major version number, minor version number&gt;. "    | currentVersionString |	currentVersionString := self typeLibraryCurrentVersionString: aGUID.	^currentVersionString isNil		ifTrue: [ nil ]		ifFalse: [ self typeLibraryVersionNumbersFromString: currentVersionString ]</body><body package="Com- Ole">typeLibraryCurrentVersionString: aGUID	" Answer the most recent version registered for the type library identified by the ID &lt;aGUID&gt;,	in the form of the 'major.minor' version string. "    | typeLibraryKey typeLibEntry 	  currentVersionInfo currentVersionString |    typeLibraryKey := 'TypeLib', '\', aGUID asString.    typeLibEntry := self classesRegistry at: typeLibraryKey 		ifAbsent: [ nil ].    ( typeLibEntry notNil	and: [ ( currentVersionInfo := self getCurrentTypeLibraryVersionInfo: typeLibEntry ) notNil ] )		ifTrue: [ currentVersionString := currentVersionInfo at: 1 ].	^currentVersionString</body><body package="Com- Ole">typeLibraryIDForCLSID: aCLSID	" Answer the GUID which identifies the type library registered for the class &lt;aCLSID&gt;. 	Answer nil if there is no type library registered for the class. "	| typeLibraryKey typeLibraryEntry |	typeLibraryKey := 'CLSID\' , aCLSID asString , '\TypeLib'.	typeLibraryEntry := self classesRegistry at: typeLibraryKey				ifAbsent: [^nil].	^typeLibraryEntry value asGUID</body><body package="Com- Ole">typeLibraryIDForIID: anIID	" Answer the GUID which identifies the type library registered for the interface &lt;anIID&gt;.	Answer nil if there is no type library registered for the interface. "	| typeLibraryKey typeLibraryEntry typeLibraryID |	typeLibraryKey := 'Interface\', anIID asString, '\TypeLib'.	typeLibraryEntry := self classesRegistry at: typeLibraryKey		ifAbsent: [ nil ].	typeLibraryEntry isNil        ifFalse: [ typeLibraryID := typeLibraryEntry value asGUID ].	^typeLibraryID</body><body package="Com- Ole">typeLibraryLocationForLIBID: aGUIDversion: aVersionlcid: anLCID	"Answer the location string registered for the type library identified by the ID &lt;aGUID&gt;, &lt;aVersion&gt; and &lt;anLCID&gt;. "	| typeLibraryKey classesRegistry typeLibEntry location |	typeLibraryKey := 'TypeLib' , '\' , aGUID asString , '\' , aVersion , '\' , anLCID asString.	classesRegistry := self classesRegistry.	typeLibEntry := classesRegistry at: typeLibraryKey ifAbsent: [nil].	typeLibEntry notNil		ifTrue: [ location := typeLibEntry at: 'win32' ].	classesRegistry close.	^location isNil		ifTrue: [ nil ]		ifFalse: [ location value ]</body><body package="Com- Ole">typeLibraryVersionNumbersFromString: aVersionString		" Answer the &lt;major version number, minor version number&gt; version		numbers array for a type library with version encoding in &lt;aVersionString&gt;. "	| aStream majorVersionNumber minorVersionNumber |	aStream := aVersionString readStream.	majorVersionNumber := aStream upTo: $..	minorVersionNumber := aStream upTo: nil.	^Array		with: ( Integer readFrom: majorVersionNumber readStream )		with: ( Integer readFrom: minorVersionNumber readStream )</body><body package="Com- Ole">typeLibraryVersionStrings: aGUID	" Answer the version strings registered for the type library identified by the ID &lt;aGUID&gt;. "    | typeLibraryKey typeLibEntry versions |    typeLibraryKey := 'TypeLib', '\', aGUID asString.    typeLibEntry := self classesRegistry at: typeLibraryKey 		ifAbsent: [ nil ].    typeLibEntry notNil        ifTrue: [ versions := typeLibEntry keys asArray ].    ^versions</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>object class information</category><body package="Com- Ole">insertableObjectMap        " Answer a dictionary describing all the registered OLE objects which can be inserted into a container, with the class name as the key and the string representation of the CLSID as the value. "	" COMRegistryInterface insertableObjectMap "    | classIDMap clsidSection clsidEntries clsidEntryNames |    classIDMap := Dictionary new.    clsidSection := self classesRegistry at: 'CLSID'.    clsidSection keysAndValuesDo: [ :key :value |        clsidEntries := clsidSection at: key.        clsidEntryNames := clsidEntries keys.        ( clsidEntryNames includes: 'Insertable' )                    ifTrue: [ classIDMap at: value put: key ]        ].    ^classIDMap</body><body package="Com- Ole">objectClassIDMap		" Answer a dictionary describing all the registered object classes		on the system, with the CLSID as the key and the PROGID name		as the value. "	" COMRegistryInterface objectClassIDMap "	| classIDMap classesRegistry clsidEntry |	classIDMap := Dictionary new.	classesRegistry := self classesRegistry.	classesRegistry keysAndValuesDo: [ :key :value |		" pick out &lt;ProgID&gt; entries with associated &lt;Progid&gt;\CLSID subkey "		( clsidEntry := classesRegistry at: key, '\CLSID' ifAbsent: [ nil ] ) notNil			ifTrue: [ 				| newKey |				( newKey := clsidEntry value asGUID ) notNil					ifTrue: [ classIDMap at: newKey put: key ] ] ].	^classIDMap</body><body package="Com- Ole">objectClassNameMap		" Answer a dictionary describing the names of all the registered object		classes on the system, with the PROGID as the key and the main		user type name as the value. "	" COMRegistryInterface objectClassNameMap "	| classNameMap classesRegistry |	classNameMap := Dictionary new.	classesRegistry := self classesRegistry.	classesRegistry keysAndValuesDo: [ :key :value |		" pick out &lt;ProgID&gt; entries with associated &lt;Progid&gt;\CLSD subkey "		( classesRegistry includesKey: key, '\CLSID' )			ifTrue: [ classNameMap at: key put: value ] ].	^classNameMap</body><body package="Com- Ole">objectClassProgIDNames        " Answer a list of the ProgID names of the OLE object classes		registered in the system registration database. "	" COMRegistryInterface objectClassProgIDNames "	^self objectClassNameMap keys asSortedCollection asArray</body><body package="Com- Ole">objectClassUserTypeNames        " Answer a list of the descriptive names of the OLE object classes		registered in the system registration database.		Use the PROGID if no user descriptive name is available. "	" COMRegistryInterface objectClassUserTypeNames "	| classNameMap names |	classNameMap := self objectClassNameMap.	names := OrderedCollection new: classNameMap size.	classNameMap keysAndValuesDo: [ :key :value |		value size = 0			ifTrue: [ names add: key ]			ifFalse: [ names add: value ] ].	^names asSortedCollection asArray</body><body package="Com- Ole">progIDFromVersionIndependentProgID: aStringOrGuid	"Answer the ProgID key for the version independent prog id &lt;aStringOrGuid&gt;. If &lt;aStringOrGuid&gt; is a String, it will be mapped to a GUID. For example, passing in 'Excel.Application', could answer 'Excel.Application.8'. This is useful for finding program version from the RegDB."	| guid |	( guid := aStringOrGuid asGUID ) isNil		ifTrue: [ ^nil ].	^( self classesRegistry 		at: 'CLSID\', guid asString, '\ProgID' ) value</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>accessing</category><body package="Com- Ole">classesRegistry		" Answer the CLASSES branch of the system registry. "	" COMRegistryInterface classesRegistry "	^Win32RegistrationDatabase classesRoot</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>interface information</category><body package="Com- Ole">interfaceIDMap        " Answer a dictionary describing all the registered interfaces,		with the IID as the key and the interface name as the value. "	" COMRegistryInterface interfaceIDMap "    | idMap interfaceSection iid |    idMap := Dictionary new.    interfaceSection := self classesRegistry at: 'Interface'.    interfaceSection keysAndValuesDo: [ :key :value |        ( iid := GUID iidFromString: key ) notNil            ifTrue: [ idMap at: iid put: value ] ].    ^idMap</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>testing</category><body package="Com- Ole">isClassRegistered: aCLSID	" Answer whether the class identified by &lt;aCLSID&gt;        is registered in the system registry. "	| clsidDefinitionKey |	clsidDefinitionKey := 'CLSID\' , aCLSID asString.	^(self classesRegistry includesKey: clsidDefinitionKey)		or: [self classesRegistry includesAlternateKey: clsidDefinitionKey]</body><body package="Com- Ole">isDCOMEnabled	"Answer whether DCOM is enabled."	| db enableDCOM |	 db := Win32RegistrationDatabase localMachine 		at: 'SOFTWARE\Microsoft\Ole' 		ifAbsent: [ ^false ].	enableDCOM := db namedValueAt: 'EnableDCOM' ifAbsent: [ nil ].	^enableDCOM = 'Y' or: [ enableDCOM = 'y' ]</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>type library experiments</category><body package="Com- Ole">typeLibraryIDMap		" Answer a dictionary describing all the registered type libraries		on the system, with the ID as the key and a list of all the		registered version/name pairs as the value. "	" COMRegistryInterface typeLibraryIDMap ""#### This probably should NOT be picked up in the product - it's not clearly useful,	or at any rate it's not obvious what info we want to this flavor of utility	to be useful [Deb 18-Mar-96] ###"	| idMap typeLibRegistry 	  aTypeLibEntry versionList |Tools.Note ISSUE.  " Experimental, probably should be thrown out if not redesigned. "	idMap := Dictionary new.	typeLibRegistry := self classesRegistry at: 'TypeLib'.	typeLibRegistry keysDo: [ :typeLibraryIDString |		aTypeLibEntry := typeLibRegistry at: typeLibraryIDString.		versionList := OrderedCollection new.		aTypeLibEntry keys do: [ :aVersionString |			versionList add: ( Array 				with: aVersionString				with: ( aTypeLibEntry at: aVersionString ) value ) ].		idMap at: ( GUID fromString: typeLibraryIDString ) 			put: versionList asArray.		].	^idMap</body></methods><methods><class-id>External.COMRegistryInterface class</class-id> <category>private</category><body package="Com- Ole">isLCID: aString	^ (aString contains: [:char |		char isDigit not]) not</body><body package="Com- Ole">putTypeLibDescriptorForLCIDEntry: aRegEntry template: infos into: aCollection	aRegEntry keysDo: 			[:platform | 					infos platform: platform.					self 						putTypeLibDescriptorsForPlatformEntry: (aRegEntry at: platform)						template: infos						into: aCollection ]</body><body package="Com- Ole">putTypeLibDescriptorsForPlatformEntry: entry template: template into: aCollection	| descriptor |	descriptor := template copy.	descriptor filename: entry value.	aCollection add: descriptor.</body><body package="Com- Ole">putTypeLibDescriptorsIn: aRegEntry template: template into: aCollection	aRegEntry keysDo: 			[:key | 			(self isLCID: key) ifTrue: [					template lcid: (Number readFromString: '16r',key) .					self 						putTypeLibDescriptorForLCIDEntry: (aRegEntry at: key)						template: template						into: aCollection ]]</body></methods><methods><class-id>External.COMDynamicLinkLibrary</class-id> <category>subclass-error handling</category><body package="Com- Ole">externalAccessFailedWith: errorCode	" Raise an exception that indicates something went wrong with an external access. "	( errorCode isError 	and: [ errorCode name = #'hresult error'  ] )		ifTrue: [ ^self signalExceptionForHRESULT: errorCode parameter asHRESULT].	^self signalExceptionForErrorCode: errorCode</body><body package="Com- Ole">externalAccessFailedWith: errorCode allowAnyHRESULTOf: listOfAcceptableValues	" An external function call has failed.  If it is an HRESULT failure and the value is one of the error codes in &lt;listOfAcceptableValues&gt;, return the HRESULT value.  Otherwise raise an exception that indicates something went wrong with an external access. "	( errorCode isError	and: [ errorCode name = #'hresult error' ] )		ifTrue: [ 			"^self checkHresult: hresult allowAny: acceptableValue"			| hresult | 			hresult := errorCode parameter asHRESULT.			( listOfAcceptableValues includes: hresult )				ifTrue: [ ^hresult ].			^self signalExceptionForHRESULT: hresult ].	^self signalExceptionForErrorCode: errorCode</body><body package="Com- Ole">externalAccessFailedWith: errorCode allowHRESULT: acceptableValue	" An external function call has failed.  If it is an HRESULT failure and the value is &lt;acceptableValue&gt;, return the HRESULT value.  Otherwise raise an exception that indicates something went wrong with an external access. "	( errorCode isError	and: [ errorCode name = #'hresult error' ] )		ifTrue: [ 			"^self checkHresult: hresult allow: acceptableValue"			| hresult |			hresult := errorCode parameter asHRESULT.			hresult = acceptableValue				ifTrue: [ ^hresult ].			^self signalExceptionForHRESULT: hresult ].	^self signalExceptionForErrorCode: errorCode</body><body package="Com- Ole">externalAccessFailedWith: errorCode allowHRESULT: acceptableValue or: anotherAcceptableValue	" An external function call has failed.  If it is an HRESULT failure and the value is &lt;acceptableValue&gt; or &lt;anotherAcceptableValue, return the HRESULT value.  Otherwise raise an exception that indicates something went wrong with an external access. "	( errorCode isError	and: [ errorCode name = #'hresult error' ] )		ifTrue: [ 			"^self checkHresult: hresult allow: acceptableValue or: anotherAcceptableValue"			| hresult |			hresult := errorCode parameter asHRESULT.			( hresult = acceptableValue or: [ hresult = anotherAcceptableValue ] )				ifTrue: [ ^hresult ].			^self signalExceptionForHRESULT: hresult ].	^self signalExceptionForErrorCode: errorCode</body><body package="Com- Ole">hresultSucceeded: aHresult	" Answer whether &lt;hresult&gt; is a success return code. "	" This service is only necessary if a subclass chooses to include		the COM external type definition pool in its compilation		context, which results in the HRESULT CType definition		overriding the HRESULT class in the name space. "	^aHresult asHRESULT succeeded</body><body package="Com- Ole">signalExceptionForErrorCode: errorCode	" Private - an external function call has failed for a reason other than an HRESULT failure.  Raise an exception. "	^super externalAccessFailedWith: errorCode</body><body package="Com- Ole">signalExceptionForHRESULT: hresult	" Private - raise an exception for the HRESULT error code &lt;hresult&gt;. "	hresult succeeded		ifTrue: 			[" VM problem, should not ever be here in the first place "			^self				error: (#ErrNamedHRESULTfail &lt;&lt; #com						&gt;&gt; 'Unexpected HRESULT external function call failure ( &lt;1s&gt; )'							expandMacrosWith: (hresult value printStringRadix: 16))].	^COMError hresult: hresult</body></methods><methods><class-id>External.COMDynamicLinkLibrary</class-id> <category>testing</category><body package="Com- Ole">includesEntryPoint: anEntryPointName	" Answer whether the receiver contains an entry point named &lt;anEntryPointName&gt;. "	^Win32DynamicLinkLibrary libraryNamed: self class fileName 		includesEntryPoint: anEntryPointName</body></methods><methods><class-id>External.COMPlatformProvider</class-id> <category>types</category><body package="Com- Ole">vtableType	self subclassResponsibility</body></methods><methods><class-id>External.COMPlatformProvider class</class-id> <category>system startup</category><body package="Com- Ole">feelsResponsibleForPlatform: platformID	self subclassResponsibility</body><body package="Com- Ole">installOn: aPlatformArray	"An instance of the platformprovider will immediately created for avoiding checking if 'current' isNil at call time"	"self installOn: (Array with: (OSHandle currentOS asSymbol) with: (OSHandle currentPlatformID) )"	"We do not open the platform provider here - this may lead to problems with relative path names"	(self == self comInterfaceBaseclass) ifTrue: [		PlatformProvider := self platformProviderFor: aPlatformArray.		current := nil ].</body><body package="Com- Ole">platformProviderFor: aPlatformArray	"	System startup - select a platformprovider for the current platform. "	| platID |	platID := aPlatformArray last.	self allSubclasses do: [:aClass |		(aClass feelsResponsibleForPlatform: platID) ifTrue: [ ^ aClass ] ].	^ nil</body></methods><methods><class-id>External.COMPlatformProvider class</class-id> <category>initialize-release</category><body package="Com- Ole">initialize 	self registerSystemVariables.	self initializeConstants.	self installOn: (Array with: (OSHandle currentOS asSymbol) with: (OSHandle currentPlatformID) ).</body><body package="Com- Ole">initializeConstants	#{COMConstants.COINIT_MULTITHREADED}  initialize.	#{COMConstants.COINIT_APARTMENTTHREADED} initialize.</body><body package="Com- Ole">registerSystemVariables	"'$(COM)\lib' asLogicalFileSpecification asFilename asString"	SystemUtils registerInternalSystemVar: 'COM' valueBlock: [COMSessionManager absoluteCOMDirectoryName ]</body><body package="Com- Ole">updateInterfacePointers	"Recompile all methdod in COMInterfacePointer an subclasses because it might happen that all	 COMExternalMethods need to be updated and should use the new callout functionality. 	 To switch between primitive calls and DLL calls, see COMInterfacePointer class&gt;dontUsePrimitive 	 Check whether the COMParser is installed in system before recompiling COM interface pointer classes"	#{COMCompiler} ifDefinedDo: [:parser |			COMInterfacePointer allSubclassesDo: [:aClass |				aClass recompileMethods ] ].</body></methods><methods><class-id>External.COMPlatformProvider class</class-id> <category>instance creation</category><body package="Com- Ole">new	^ super new initialize</body></methods><methods><class-id>External.COMPlatformProvider class</class-id> <category>subclass-initialization</category><body package="Com- Ole">getCurrent	"Private - get (open) an instance of the receiver."	^PlatformProvider isNil		ifTrue: 	[ nil ]		ifFalse:	[ PlatformProvider open ]</body></methods><methods><class-id>External.COMPlatformProvider class</class-id> <category>accessing</category><body package="Com- Ole">comInterfaceBaseclass		^ COMPlatformProvider</body></methods><methods><class-id>External.X64COMInterface class</class-id> <category>accessing</category><body package="Com- Ole">feelsResponsibleForPlatform: platformID	^ 'win32*X64*' match: platformID</body></methods><methods><class-id>External.IAdviseSinkImplementation</class-id> <category>interface operations</category><body package="Com- Ole">OnClose		" Invoke the IAdviseSink::OnClose function. "	^[  " terminate exception stack unwind at function invocation boundary "	implementor OnClose.	nil	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #internalCallin )</body><body package="Com- Ole">OnDataChange: aFormatEtc _: aStgMedium		" Invoke the IAdviseSink::OnDataChange function. "	^[  " terminate exception stack unwind at function invocation boundary "	implementor OnDataChange: aFormatEtc _: aStgMedium.	nil	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #internalCallin )</body><body package="Com- Ole">OnRename: anIMoniker		" Invoke the IAdviseSink::OnRename function. "	^[  " terminate exception stack unwind at function invocation boundary "	implementor OnRename: anIMoniker.	nil	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #internalCallin )</body><body package="Com- Ole">OnSave		" Invoke the IAdviseSink::OnSave function. "	^[  " terminate exception stack unwind at function invocation boundary "	implementor OnSave.	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #internalCallin )</body><body package="Com- Ole">OnViewChange: dwAspect _: lindex		" Invoke the IAdviseSink::OnViewChange function. "	^[  " terminate exception stack unwind at function invocation boundary "	implementor OnViewChange: dwAspect _: lindex.	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #internalCallin )</body></methods><methods><class-id>External.IAdviseSinkImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeOnClose: this		" Private - invoke the IAdviseSink::OnClose function for an external caller. "	" void OnClose( void); "	^[   " terminate exception stack unwind at external callin boundary "	implementor OnClose.	nil	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #externalCallin )</body><body package="Com- Ole">invokeOnDataChange: this _: pFormatetc _: pStgmed        " Private - invoke the IAdviseSink::OnDataChange function for an external caller. "    " void OnDataChange(            /* [unique][in] */ FORMATETC *pFormatetc,            /* [unique][in] */ STGMEDIUM *pStgmed); "	^[   " terminate exception stack unwind at external callin boundary "	| aFormatEtc aStgMedium |	self reportExternalFunctionEntry.	( pFormatetc isValid	and: [ pStgmed isValid ] )		ifFalse: [ ^nil ].  " not an HRESULT, so cannot return the usual E_INVALIDARG "	aFormatEtc := self structureAtAddress: pFormatetc.  " type: #FORMATETC "	aStgMedium := self structureAtAddress: pStgmed.  " type: #STGMEDIUM "	implementor OnDataChange: aFormatEtc _: aStgMedium.	nil	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #externalCallin )</body><body package="Com- Ole">invokeOnRename: this _: pmk        " Private - invoke the IAdviseSink::OnRename function for an external caller. "	" void OnRename(            /* [in] */ IMoniker *pmk); "	^[   " terminate exception stack unwind at external callin boundary "	| aMoniker |	self reportExternalFunctionEntry.	pmk isValid		ifFalse: [ ^nil ].  " not an HRESULT, so cannot return the usual E_INVALIDARG "	aMoniker := self interfaceAtAddress: pmk		type: IMoniker.	implementor OnRename: aMoniker.	nil	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #externalCallin )</body><body package="Com- Ole">invokeOnSave: this		" Private - invoke the IAdviseSink::OnSave function for an external caller. "	" void OnSave( void); "	^[   " terminate exception stack unwind at external callin boundary "	implementor OnSave.	nil	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #externalCallin )</body><body package="Com- Ole">invokeOnViewChange: this _: dwAspect _: lindex		" Private - invoke the IAdviseSink::OnViewChange function for an external caller. "	" void OnViewChange(            /* [in] */ DWORD dwAspect,            /* [in] */ LONG lindex);"	^[   " terminate exception stack unwind at external callin boundary "	implementor OnViewChange: dwAspect _: lindex.	nil	] on: self rootExceptions   		do: ( self exceptionHandlerForNilReturnValue: #externalCallin )</body></methods><methods><class-id>External.IAdviseSinkImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IAdviseSink.	self vtableSignatureTypeName: #__IAdviseSinkVtbl.	self updateAndRegister</body></methods><methods><class-id>Core.COMError</class-id> <category>private-accessing</category><body package="Com- Ole">ensureMessageTextInstalled	" Private - ensure that the receiver has some suitable message. "	messageText == nil ifTrue: [self messageText: self hresult description]</body><body package="Com- Ole">hresultAttribute: anInteger	" Private - set the receiver's hresult attribute.  This has to be done carefully in the VW 2.5 NGException facility due to a collision between the VW 4.0 inst var setter and the class signalling protocol which must be simulated via an instance method in VW 2.5. "	hresult := anInteger.</body></methods><methods><class-id>Core.COMError</class-id> <category>accessing</category><body package="Com- Ole">hresult        "Answer the COM result code which caused the notification. "    ^hresult</body><body package="Com- Ole">hresult: anInteger        "Set the result code set to &lt;anInteger&gt;."	self hresultAttribute: anInteger.	self ensureMessageTextInstalled.</body></methods><methods><class-id>Core.COMError</class-id> <category>private-initialization</category><body package="Com- Ole">initialize        "Private - initialize the receiver to be an unexpected COM error."	super initialize.	self hresultAttribute: E_UNEXPECTED.</body></methods><methods><class-id>Core.COMError class</class-id> <category>signalling</category><body package="Com- Ole">hresult: anInteger        "Signal a newly created instance of the receiver with the result code set to &lt;anInteger&gt;."    ^( self new hresult: anInteger ) raiseSignal</body></methods><methods><class-id>Core.COMError class</class-id> <category>instance creation</category><body package="Com- Ole">new	" Answer a new instance of the receiver. "    ^super new initialize</body></methods><methods><class-id>External.IBindCtxPointer class</class-id> <category>VTable utilities</category><body package="Com- Ole">validateVTable	" Verify that a complete and consistent set of VTable dispatch methods is defined in the receiver.  Notify the user of any problems. "	" We don't currently wrap the functions in this interface, so it's fine to just be IUnknown "	self vtableDescription size = self superclass vtableDescription size		ifTrue: [ ^self ].	super validateVTable.</body><body package="Com- Ole">validateVTableConsistency	" Verify that the VTable functions defined in the receiver are consistent with the interface VTable structure definition.  Notify the user of any problems. "	" We don't currently wrap the functions in this interface, so it's fine to just be IUnknown "	self vtableDescription size = self superclass vtableDescription size		ifTrue: [ ^self ].	super validateVTableConsistency.</body></methods><methods><class-id>External.IBindCtxPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IBindCtx.	self updateAndRegister</body></methods><methods><class-id>External.IEnumPointer</class-id> <category>interface operations</category><body package="Com- Ole">Clone: resultReference	" Invoke the IEnum::Clone function.  Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: self iid.	hresult := self invokeClone: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">Next: cElements _: elementBuffer _: resultReference	" Invoke the IEnum::Next function.  Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	" ensure that client is providing a stable buffer "	( elementBuffer isExternalAddress	or: [ ( elementBuffer class isBits and: [ elementBuffer isFixedArgument ] ) ] )		ifFalse: [ COMError raiseSignal:(#ErrNamedIEnumMemory &lt;&lt; #com &gt;&gt; 'IEnum buffer not in stable memory: &lt;1s&gt;' expandMacrosWith: elementBuffer class name) ].	resultReference notNil		ifTrue: [ resultBuffer := COMExternalInterface scalarResultBufferFor: #ULONG ].	hresult := self invokeNext: cElements 		_: elementBuffer		_: resultBuffer asPointerParameter.	resultReference notNil		ifTrue: [ resultReference value: resultBuffer contents ].	^hresult</body></methods><methods><class-id>External.IEnumPointer</class-id> <category>identity</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid</body><body package="Com- Ole">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;. "	"Assert isTrue: [ self iid isNil or: [ self iid = anIID ] ]."	iid := anIID.</body></methods><methods><class-id>External.IEnumPointer class</class-id> <category>external-transformations</category><body package="Com- Ole">resultValueArrayBuffer: count	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an array of &lt;count&gt; instances of the receiver.  The caller must send #asPointerParameter to the buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value.  The returned interface pointers become the responsibility of the caller, who must release them when done, in the usual fashion. "	self shouldNotImplement.  " you need to specify IID in order to instantiate enumerators "</body><body package="Com- Ole">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an instance of the receiver.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	self shouldNotImplement.  " you need to specify IID in order to instantiate enumerators "</body><body package="Com- Ole">resultValueBufferForIID: anIID	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an interface pointer instance of with the dispatch interface IID GUID &lt;anIID&gt;.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	( self supportsIID: anIID )		ifFalse: [ self error: ((#notAnEnumeratorIIDC1s &lt;&lt; #com &gt;&gt; 'not an enumerator IID: &lt;1s&gt;')			expandMacrosWith: anIID asString) ].	^COMInterfacePointerResultBuffer for: self iid: anIID</body></methods><methods><class-id>External.IEnumPointer class</class-id> <category>identity</category><body package="Com- Ole">supportsIID: aGUID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^( super supportsIID: aGUID )		or: [ IEnum supportsEnumeratorIID: aGUID ]</body></methods><methods><class-id>External.IEnumPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IEnum.	"A special generic enumerator IID is used for internal			identification of the Smalltalk enumerator interface class. "	self updateAndRegister</body></methods><methods><class-id>External.COMErrorReporter</class-id> <category>accessing</category><body package="Com- Ole">context	"Answer the context we are working on."	^context</body><body package="Com- Ole">descriptionDepth	"Answer the descriptionDepth to use."	^self class descriptionDepth</body><body package="Com- Ole">errorFilePath	"Answer the error file name to write to, by default defined by ImageConfiguration."	^errorFilePath ifNil:[ImageConfiguration errorLogPath]</body><body package="Com- Ole">errorFilePath: aFilename	errorFilePath := aFilename</body><body package="Com- Ole">exception	"Answer the execption we are working on."	^exception</body></methods><methods><class-id>External.COMErrorReporter</class-id> <category>private-accessing</category><body package="Com- Ole">setException: anException context: aContext	"Set the receiver to a well-formed state for reporting an error."	exception := anException.	context := aContext.</body></methods><methods><class-id>External.COMErrorReporter</class-id> <category>private-report generation</category><body package="Com- Ole">describeStackFrom: initialContext on: aStream	"Private. Append a description of the process stack resulting from the exception condition during the callin invocation of a VTable function to &lt;aStream&gt;. "	| aContext nLevels count |	aStream 		nextPutAll: (#ErrorDuringFunctionCallback &lt;&lt; #com &gt;&gt; 'An error has occurred during a callback to a COM interface function') asString; cr;		tab; nextPutAll: ((#ErrorC1s &lt;&lt; #com &gt;&gt; 'Error: &lt;1s&gt;')			expandMacrosWith: self exception description); cr;		cr.	" Describe the top n entries on the call stack "	aContext := initialContext.	nLevels := self descriptionDepth.	count := 0.	aStream nextPutAll: ((#Last1sFramesOnStack &lt;&lt; #com &gt;&gt; 'The last &lt;1s&gt; frames on the call stack are:')			expandMacrosWith: nLevels printString); cr.	[ aContext notNil and: [ count &lt; nLevels ] ]		whileTrue: [			aStream tab. 			aContext printOn: aStream. 			aStream cr.			true ifTrue: [  			" describe method arguments and temps "			aContext class = MethodContext				ifTrue: [					| nArgs tempNames |					nArgs := MessageSend numberOfArgumentsFor: aContext selector.					tempNames := aContext tempNames.					nArgs &gt; 0						ifTrue: [							aStream tab; tab; nextPutAll: (#Arguments &lt;&lt; #com &gt;&gt; '-- arguments --') asString; cr.							1 to: nArgs do: [ :i |								aStream tab; tab;									nextPutAll: ( tempNames at: i );									nextPutAll: ': ';									nextPutAll: ( aContext tempAt: i ) printString; 									cr ] ].					tempNames size &gt; nArgs						ifTrue: [							aStream tab; tab; nextPutAll: (#Temps &lt;&lt; #com &gt;&gt; '-- temps --') asString; cr.							nArgs + 1 to: tempNames size do: [ :i |								aStream tab; tab;									nextPutAll: ( tempNames at: i );									nextPutAll: ': ';									nextPutAll: ( aContext tempAt: i ) printString; 									cr ] ].					].			].			aContext := aContext sender.			count := count + 1 ].</body><body package="Com- Ole">writeErrorFooter: aStream	"Append an error header to &lt;aStream&gt;."	aStream 		nextPutAll: (#EndOfErrorReport &lt;&lt; #com &gt;&gt; 'End of error report.') asString;		cr.</body><body package="Com- Ole">writeErrorHeader: aStream	"Append an error header to &lt;aStream&gt;."	aStream 		cr;		nextPutAll: ((#ErrorReportedBy1s &lt;&lt; #com &gt;&gt; 'Error reported by &lt;1s&gt; on &lt;2s&gt;')			expandMacrosWith: self class name asString			with: Timestamp now printString); cr;		nextPutAll: ((#From1s &lt;&lt; #com &gt;&gt; 'From &lt;1s&gt;')			expandMacrosWith: Smalltalk version); cr;		nextPutAll: ((#Image1s &lt;&lt; #com &gt;&gt; 'Image ''&lt;1s&gt;''')			expandMacrosWith: ObjectMemory imageFilename asString);cr;		cr.</body><body package="Com- Ole">writeErrorToFile: aString 	"Private. Write a description of the process stack resulting from the exception condition exception to a file. "	| stream |	self class writeErrorsToFile ifFalse: [^self].	stream := self errorFilePath asFilename appendStream.		[self writeErrorHeader: stream.	stream		nextPutAll: aString;		cr.	self writeErrorFooter: stream] 			ensure: [stream close]</body></methods><methods><class-id>External.COMErrorReporter</class-id> <category>private-UI independence</category><body package="Com- Ole">ensureDumpFilenameIsWritable: aFilenameOrNil	"Return aFilenameOrNil if it is writable, or prompt for a new file if it is not. If aFilenameOrNil is nil, it represents the user's attempt to cancel, so return nil."	^(aFilenameOrNil isNil or: [aFilenameOrNil canBeWritten])		ifTrue: [aFilenameOrNil]		ifFalse:			[self				requestValidFilenameIfHeadful: #unwritableErrorLog &lt;&lt; #dialogs &gt;&gt;					'Unwritable file.  Please specify a writable file for the error log:'				default: aFilenameOrNil asString]</body><body package="Com- Ole">requestNewValidFilenameAfterError: ex	"There's been an error in writing out the log (e.g. disk full, disk error, no permissions). If we have a GUI available, ask the user if they want to try another filename, or just give up and quit. If there's no GUI, then just quit"	WindowingSystem isHeadless ifTrue: [ex return: false].	^#{Dialog} 			ifDefinedDo: 				[:dialogClass |  | tryToContinue |				"An OS error has prevented dump completion.  Ask the user for an alternate dump file and retry"				tryToContinue := (dialogClass 					choose: (#unableToWriteLog &lt;&lt; #dialogs &gt;&gt; 'Unable to write log: &lt;1s&gt;' 							expandMacrosWith: ex messageText)					labels: (Array 							with: #chooseNewDestination &lt;&lt; #dialogs &gt;&gt; 'Choose new destination'							with: #runtimeAbort &lt;&lt; #labels &gt;&gt; 'Quit without writing error log')					values: #(true false)					default: true).				tryToContinue 					ifTrue: [						errorFilePath := self 							requestValidFilenameIfHeadful: #invalidLogFileName &lt;&lt; #dialogs 									&gt;&gt; 'Invalid file name.  To what file should errors be written?'							default: errorFilePath asString.						ex retry]					ifFalse: [false]]			elseDo: [false]</body><body package="Com- Ole">requestValidFilenameIfHeadful: messageString default: defaultString 	"Ask the user to supply a filename.  Answer the resulting string, or answer nil if headless"	WindowingSystem isHeadless ifTrue: [^nil].	^self validDumpFilenameFrom: (#{FileDialog} 				ifDefinedDo: [:dialogClass | dialogClass openFileTitle: messageString pattern: defaultString])</body><body package="Com- Ole">showBusyWhile: aBlock 	WindowingSystem isHeadless ifTrue: [^aBlock value].	^#{Cursor} 		ifDefinedDo: [:cursorClass | cursorClass write showWhile: aBlock]		elseDo: aBlock</body><body package="Com- Ole">validDumpFilenameFrom: aFilenameStringOrNil 	"Return the filename representation of aFilenameStringOrNil, or nil.  Prompt the user for a new file if aFilenameStringOrNil does not represent a valid filename. If aFilenameStringOrNil is an empty String or nil, this represents the user's attempt to cancel, or an abort of the prompt when running headless, so return nil."	^(aFilenameStringOrNil isNil 		or: [aFilenameStringOrNil isString and: [aFilenameStringOrNil isEmpty]]) 			ifTrue: [nil]			ifFalse: 				[[aFilenameStringOrNil asFilename] on: Error					do: 						[:ex | 						self requestValidFilenameIfHeadful: #invalidLogFileName &lt;&lt; #dialogs 									&gt;&gt; 'Invalid file name.  To what file should errors be written?'							default: aFilenameStringOrNil]]</body></methods><methods><class-id>External.COMErrorReporter</class-id> <category>private-reporting</category><body package="Com- Ole">dumpLogTo: aFilename 	^self showBusyWhile: [self writeErrorToFile: self reportErrorString]</body><body package="Com- Ole">reportErrorString	"Private. An exception has occurred.  Answer an error String so that the problem can be diagnosed. "	| errorStream |	errorStream := ReadWriteStream on: String new.	self 		describeStackFrom: (self class copyCallinErrorStack: self context sender)		on: errorStream.	^errorStream contents</body></methods><methods><class-id>External.COMErrorReporter</class-id> <category>actions</category><body package="Com- Ole">createEmergencyDump	"Create a dump log unless #dumpLogTo: fails with an OsError. If the dump fails due to an OsError and the image is not headless alert the user of an error saving the dump file and ask for a new pathname until the dump is successful or the user cancels.    Answer true if the dump succeeded or false otherwise. Also answer true if no dump is requested"	^ImageConfiguration logToFile 		ifTrue: 			[			[errorFilePath := self ensureDumpFilenameIsWritable: errorFilePath.			errorFilePath isNil 				ifTrue: [false]				ifFalse: [self dumpLogTo: errorFilePath]] 					on: OsError					do: [:ex | self requestNewValidFilenameAfterError: ex]]		ifFalse: [true]</body></methods><methods><class-id>External.COMErrorReporter class</class-id> <category>defaults</category><body package="Com- Ole">defaultDescriptionDepth	"Answer the default descriptionDepth to use."	^40</body></methods><methods><class-id>External.COMErrorReporter class</class-id> <category>reporting</category><body package="Com- Ole">reportErrorString: anException context: aContext	"Private. An exception has occurred.  Answer the error as a String so that the problem can be diagnosed. "	^self new 		setException: anException context: aContext;		reportErrorString</body></methods><methods><class-id>External.COMErrorReporter class</class-id> <category>accessing</category><body package="Com- Ole">descriptionDepth	"Answer the descriptionDepth to use."	^DescriptionDepth notNil		ifTrue: [ DescriptionDepth ]		ifFalse: [ ^self defaultDescriptionDepth ]		"Intentionally do not rely on using a ClassInitializer method to define the default value. This makes sure that this class will work even if the file-in would not have run the ClassInitializer for whatever crazy reason."</body><body package="Com- Ole">descriptionDepth: anInteger	"Set the descriptionDepth to use. We are careful to check the validity of the argument &lt;anInteger&gt;."	"Test expressions."	" self descriptionDepth: self defaultDescriptionDepth "	" self descriptionDepth: nil "	" self descriptionDepth: 40 "	" self descriptionDepth: -10 "	( anInteger isInteger not and: [ COMDevelopmentWarning displayWarningMessages ] )		ifTrue: [ MessageBox message: ((#DescriptionDepthMustBeInteger &lt;&lt; #com &gt;&gt; 'Cannot set the description depth to &lt;1s&gt;.&lt;n&gt;You can only set the description depth to an Integer.&lt;n&gt;The current description depth of &lt;2s&gt; remains set.')			expandMacrosWith: anInteger printString			with: self descriptionDepth printString).			^self ].	( anInteger &lt; 1 and: [ COMDevelopmentWarning displayWarningMessages ] )		ifTrue: [ MessageBox message: ((#DescriptionDepthMustBePositive &lt;&lt; #com &gt;&gt; 'Cannot set the description depth to &lt;1s&gt;.&lt;n&gt;You can only set the description depth to an positive Integer.&lt;n&gt;The current description depth of &lt;2s&gt; remains set.')			expandMacrosWith: anInteger printString			with: self descriptionDepth printString).			^self ].	DescriptionDepth := anInteger</body><body package="Com- Ole">writeErrorsToFile	"Answer the whether or not to write errors to a file."	^ImageConfiguration logToFile</body><body package="Com- Ole">writeErrorsToFile: aBoolean	"Set whether to write the error stack to the file set by ImageConfiguration errorLogPath. We are careful to check the validity of the argument &lt;aBoolean&gt;."	ImageConfiguration logToFile: aBoolean</body></methods><methods><class-id>External.COMErrorReporter class</class-id> <category>instance creation</category><body package="Com- Ole">dumpSystemImage: anException context: aContext on: aFilename 	"Write stack to file aFilename"	^(self new)		errorFilePath: aFilename;		setException: anException			context: aContext;		createEmergencyDump</body><body package="Com- Ole">notify: anException context: aContext 	"Notify the user about an exception"	ImageConfiguration errorLogPath ifNotNil: 			[:logPath | 			ImageConfiguration logToFile 				ifTrue: 					[self 						dumpSystemImage: anException						context: aContext						on: logPath asFilename]].	ImageConfiguration isDevelopment 		ifTrue: 			[self 				openContext: aContext				label: anException description				proceedable: true].</body><body package="Com- Ole">openContext: aContext label: aUserMessageOrString proceedable: aBoolean 	"An exception has occurred during the callin invocation of a VTable function.  Open a non-proceedable notifier so that the problem can be diagnosed. "	Notifier current 		openContext: aContext		label: aUserMessageOrString asString		proceedable: aBoolean</body></methods><methods><class-id>External.COMErrorReporter class</class-id> <category>private-stack accessing</category><body package="Com- Ole">copyCallinErrorStack: initialContext	"Private. Answer a copy of the stack at the point of an exception.  Answer an interesting subset (prune uninteresting signalling logic off the top and then report some interesting depth). "	| aContext theException originatingSignal previousContext |	aContext := initialContext.	" work back up the stack to the callin exception handler (skip exception signalling stuff) "	[ aContext notNil	and: [ ( aContext isBlockContext			or: [ ( aContext receiver isExceptionHandler ) not ] ) ] ]		whileTrue: [ aContext := aContext sender ].	" work back through the exception generation to the originating signal "	aContext notNil		ifTrue:			[theException := aContext receiver.			"Assert isTrue: [ theException class == Exception ]."			[ aContext notNil			and: [ ( aContext isBlockContext or: [ aContext receiver == theException ] ) ] ]				whileTrue: [ aContext := aContext sender ].		" filter out out internal logic of exception generation in the originating signal "		"Assert isTrue: [ aContext receiver isKindOf: Signal ]."		( aContext notNil and: [ aContext receiver isKindOf: Signal ] )			ifTrue: [				"aContext := aContext sender."				originatingSignal := aContext receiver.				[ ( previousContext := aContext sender ) notNil  " paranoid but safe "				and: [ previousContext isBlockContext not    " ditto "				and: [ previousContext receiver == originatingSignal ] ] ]					whileTrue: [ aContext := previousContext ].				]]		ifFalse: [aContext := initialContext].		" okay, we should finally be back to the interesting point from which the exception was raised "	^aContext copyStackToDepth: self descriptionDepth</body></methods><methods><class-id>External.IPersistStorageImplementation</class-id> <category>interface operations</category><body package="Com- Ole">HandsOffStorage        " Invoke the IPersistStorage::HandsOffStorage function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor HandsOffStorage		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">InitNew: anIStorage        " Invoke the IPersistStorage::InitNew function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor InitNew: anIStorage		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">IsDirty        " Invoke the IPersistStorage::IsDirty function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor IsDirty		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Load: anIStorage        " Invoke the IPersistStorage::Load function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Load: anIStorage		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Save: anIStorage _: fSameAsLoad        " Invoke the IPersistStorage::Save function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Save: anIStorage _: fSameAsLoad		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">SaveCompleted: anIStorage		" Invoke the IPersistStorage::SaveCompleted function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor  SaveCompleted: anIStorage		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IPersistStorageImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeHandsOffStorage: this		" Private - invoke the IPersistStorage::HandsOffStorage function for an external caller. "	" HRESULT HandsOffStorage( void);"	^[   " terminate exception stack unwind at external callin boundary "	implementor HandsOffStorage.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeInitNew: this _: pStg        " Private - invoke the IPersistStorage::InitNew function for an external caller. "    " HRESULT InitNew(            /* [unique][in] */ IStorage *pStg); "	^[   " terminate exception stack unwind at external callin boundary "	| anIStorage |	self reportExternalFunctionEntry.	pStg isValid		ifFalse: [ ^E_INVALIDARG ].	anIStorage := self interfaceAtAddress: pStg		type: IStorage.	implementor InitNew: anIStorage.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeIsDirty: this		" Private - invoke the IPersistStorage::IsDirty function for an external caller. "	" HRESULT IsDirty( void);"	^[   " terminate exception stack unwind at external callin boundary "	implementor IsDirty.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeLoad: this _: pStg		" Private - invoke the IPersistStorage::Load function for an external caller. "	"  HRESULT Load(            /* [unique][in] */ IStorage *pStg); "	^[   " terminate exception stack unwind at external callin boundary "	| anIStorage |	self reportExternalFunctionEntry.	pStg isValid		ifFalse: [ ^E_INVALIDARG ].	anIStorage := self interfaceAtAddress: pStg		type: IStorage.	implementor Load: anIStorage.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeSave: this _: pStgSave _: fSameAsLoad		" Private - invoke the IPersistStorage::Save function for an external caller. "	" HRESULT Save(            /* [unique][in] */ IStorage *pStgSave,            /* [in] */ BOOL fSameAsLoad); "	^[   " terminate exception stack unwind at external callin boundary "	| anIStorage |	self reportExternalFunctionEntry.	pStgSave isValid		ifFalse: [ ^E_INVALIDARG ].	anIStorage := self interfaceAtAddress: pStgSave		type: IStorage.	implementor Save: anIStorage 		_: fSameAsLoad.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeSaveCompleted: this _: pStgNew		" Private - invoke the IPersistStorage::SaveCompleted function for an external caller. "	" HRESULT SaveCompleted(            /* [unique][in] */ IStorage *pStgNew); "	^[   " terminate exception stack unwind at external callin boundary "	| anIStorage |	self reportExternalFunctionEntry.	pStgNew isValid		ifFalse: [ ^E_INVALIDARG ].	anIStorage := self interfaceAtAddress: pStgNew		type: IStorage.	implementor SaveCompleted: anIStorage.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IPersistStorageImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistStorage.	self vtableSignatureTypeName: #__IPersistStorageVtbl.	self updateAndRegister</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>accessing</category><body package="Com- Ole">activeObjectCount	" Answer the number of objects created by the receiver which are still in use by clients. "	^self activeObjects size</body><body package="Com- Ole">activeObjects	" Answer all the objects created by the receiver which are still in use by clients. "	^self class activeObjects select: [ :anOleObject |		anOleObject class = self objectClass ]</body><body package="Com- Ole">lockCount	" Answer the number of locks currently held on the receiver. "	^lockCount</body><body package="Com- Ole">objectCLSID	" Answer the CLSID of objects which are instantiated by the receiver. "	^self objectClass clsid</body><body package="Com- Ole">objectClass	" Answer the class whose instance are created by the receiver. "	^objectClass</body><body package="Com- Ole">releaseIfNotInUse	" Answer whether the receiver should be released as soon as it is no longer in use (is not locked and all objects which it has created terminated).  Setting this true causes multi-factory applications to release class factory resources as soon as possible, rather than releasing all registered class factories only when the object server application exits. "	^releaseIfNotInUse</body><body package="Com- Ole">releaseIfNotInUse: aBoolean	" Specifiy whether the receiver should be released as soon as it is no longer in use (is not locked and all objects which it has created terminated).  Setting this true causes multi-factory applications to release class factory resources as soon as possible, rather than releasing all registered class factories only when the object server application exits. "	releaseIfNotInUse := aBoolean.</body><body package="Com- Ole">typeLibraryHolder	^ self objectClass</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>testing</category><body package="Com- Ole">isClassFactory	" Answer whether the receiver is a class factory which manufactures COM objects. "	^true</body><body package="Com- Ole">isInUse	" Answer whether the receiver is in use (is locked or has active objects). "	^self lockCount &gt; 0 or: [ self activeObjectCount &gt; 0 ]</body><body package="Com- Ole">isRegistered	" Answer whether the receiver is registered with COM. "	^self registrationToken notNil</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>registration</category><body package="Com- Ole">registerAsMultipleUseLocalServer	" Register the receiver with COM as a multiple-use local object server application. "	self registerClassContext: CLSCTX_LOCAL_SERVER 		flags: REGCLS_MULTIPLEUSE.</body><body package="Com- Ole">registerClassContext: classContext flags: flags	" Register the receiver with COM with the specified execution context &lt;classContext&gt; and connection flags &lt;flags&gt;. "	" The class execution context specifies how the object server application executes:		CLSCTX_INPROC_SERVER, CLSCTX_INPROC_HANDLER, or		CLSCTX_LOCAL_SERVER	The flags specify whether the factory supports single or multiple use:		REGCLS_SINGLEUSE, REGCLS_MULTIPLEUSE, REGCLS_MULTI_SEPARATE	"	self class registerClassFactory: self		classContext: classContext		flags: flags.</body><body package="Com- Ole">revokeRegistration	" Revoke the registration of the receiver with COM as a class factory object. "	self invalidateSessionSelfReferences.	self class revokeClassFactory: self.</body><body package="Com- Ole">revokeRegistrationDeferred	" Revoke the registration of the receiver with COM as a class factory object. "	| revokeAction |	revokeAction := MessageSend receiver: self		selector: #revokeRegistration.	COMSessionManager performDeferred: revokeAction.</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>subclass-object creation</category><body package="Com- Ole">createObject	" Private - answer a new instance of the object class. "	^self objectClass newServerObject</body><body package="Com- Ole">createObjectFor: aControllingUnknown	" Private - answer a new instance of the object class which will be used as an inner object in the aggregate controlled by &lt;aControllingUnknown&gt;. "	^self objectClass forControllingUnknown: aControllingUnknown</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>subclass-releasing</category><body package="Com- Ole">forceRelease	" Private - attempt to forcibly release the receiver.  Answer whether successful.  This is a dangerous thing to do and is primarily a developer debugging facility. "	self isRegistered		ifTrue: [			( MessageBox confirm: ((#RevokeRegistrationBeforeRelease &lt;&lt; #com &gt;&gt; 'The class factory registration of &lt;1s&gt; must be revoked before it can be released.  Proceed?')					expandMacrosWith: self printString) )				ifFalse: [ ^false ].			self revokeRegistration ].	^super forceRelease</body><body package="Com- Ole">resetAllocatedInterfaces	" Private - reset the references to the interfaces supported by the receiver. "	super resetAllocatedInterfaces.	iClassFactory := nil.</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>private-accessing</category><body package="Com- Ole">lockCount: anInteger	" Private - set the number of locks currently held on the receiver. "	lockCount := anInteger.</body><body package="Com- Ole">objectCLSID: aCLSID	" Private - set the CLSID of objects which are instantiated by the receiver. "	iClassFactory clsid: aCLSID.</body><body package="Com- Ole">objectClass: aClass	" Private - set the class whose instance are created by the receiver. "	objectClass := aClass.</body><body package="Com- Ole">registeredUnknown	" Private - answer the separately reference counted IUnknown which was used to register the receiver with COM.  Answer nil if the receiver is not registered with COM. "	^registeredUnknown</body><body package="Com- Ole">registeredUnknown: anIUnknown	" Private - set the separately reference counted IUnknown which was used to register the receiver with COM. "	registeredUnknown := anIUnknown.</body><body package="Com- Ole">registrationToken	" Private - answer the receiver's registration token.  Answer nil if the receiver is not registered with COM. "	^registrationToken</body><body package="Com- Ole">registrationToken: anInteger	" Private - set the receiver's registration token from its COM registration. "	registrationToken := anInteger.</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>subclass-reference counting</category><body package="Com- Ole">decrementLockCount	" Private - decrement the number of locks on the receiver.  Answer the lock count. "	self class decrementLockCount.	^self lockCount: ( self lockCount - 1 )</body><body package="Com- Ole">incrementLockCount	" Private - increment the number of locks on the receiver.  Answer the lock count. "	self class incrementLockCount.	^self lockCount: ( self lockCount + 1 )</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>subclass-initializing</category><body package="Com- Ole">initialize	" Private - initialize a new instance of the receiver. "	super initialize.	self 		lockCount: 0;		releaseIfNotInUse: false.  " perform lazy deallocation at server exit "</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>printing</category><body package="Com- Ole">printCLSIDOn: aStream	" Append a text representation of the receiver's CLSID to &lt;aStream&gt;. "	self objectCLSID notNil		ifTrue: [ aStream nextPutAll: ' (CLSID ', self objectCLSID asString, ')' ].</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>private-IClassFactory operations</category><body package="Com- Ole">CreateInstance: aControllingUnknown _: iid _: resultReference	" Private - perform the IClassFactory::CreateInstance function.  Answer the result code. "	(self requiresLicensedCreation: self licenseProvider)		ifTrue: [^CLASS_E_NOTLICENSED].	^self basicCreateInstance: aControllingUnknown _: iid _: resultReference</body><body package="Com- Ole">LockServer: aBoolean	" Private - perform the IClassFactory::LockServer function.  Answer the result code. "	" The external object lock technique used here comes for the OLE Programmer's 		Reference Manual discussion of this operation.  However, it is not done by 		Kraig Brockschmidt's sample class factory in 'Inside OLE', which is generally 		consideretd the guiding light of COM programmers everywhere.   We defer 		in this case the Microsoft's reference manual, although it seems a tad bit 		more heavy-handled than is perhaps necessary. "	" create a strong lock on the class factory; artifically reference count		the receiver's IUnknown interface to ensure that the object		remains stable during this call " 	self registeredUnknown enforceAddRef.	[	aBoolean		ifTrue: [ 			self incrementLockCount.			self registeredUnknown lockObject ]		ifFalse: [ 			self decrementLockCount.			self registeredUnknown unlockObject ].	] ensure: [		self registeredUnknown privateDecrementReferenceCount ].	aBoolean		ifFalse: [ self class checkInUse: self ].	^S_OK</body><body package="Com- Ole">basicCreateInstance: aControllingUnknown _: iid _: resultReference	" Private - perform the IClassFactory::CreateInstance function.  Answer the result code. "	| aCOMObject anInterface |	" create a new object and obtain the requested interface "	aControllingUnknown isNil		ifTrue: [			aCOMObject := self createObject.			anInterface := aCOMObject queryInterface: iid.			anInterface isNil				ifTrue: [ ^E_NOINTERFACE ].			]		ifFalse: [   " create a non-control object for use within an aggregate "			" insist that the control object ask for the local IUnknown of the non-control object "			iid ~= IID_IUnknown				ifTrue: [ ^E_NOINTERFACE ].			aCOMObject := self createObjectFor: aControllingUnknown.			aCOMObject isNil				ifTrue: [ ^CLASS_E_NOAGGREGATION ].  " doesn't support aggregation "			anInterface := aCOMObject innerUnknown.			].	" record the new object in the active objects registry "	self class registerObject: aCOMObject 		classFactory: self.	"Assert isTrue: [ aCOMObject referenceCount = 1 ]."	resultReference value: anInterface.	^S_OK</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>subclass-enumerating</category><body package="Com- Ole">allocatedInterfacesDo: aOneArgBlock	" Private - enumerate the interfaces supported by the receiver which have been allocated during its lifetime and evaluate &lt;aOneArgBlock&gt; with each. "	super allocatedInterfacesDo: aOneArgBlock.	iClassFactory ifNotNil: [ aOneArgBlock value: iClassFactory ].</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>As yet unclassified</category><body package="Com- Ole">performInCorrespondingAppartment: aBlockClosure	^ COMThreadManager performInSTA: aBlockClosure</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>private-IClassFactory2 operations</category><body package="Com- Ole">CreateInstanceLic: aControllingUnknown _: aReservedUnknown _: anIID _: aLicenseKey _: aResultReference	| provider |	provider := self licenseProvider.	aLicenseKey		ifNil: 			[(self requiresLicensedCreation: provider)				ifFalse: 					[^self basicCreateInstance: aControllingUnknown _: anIID _: aResultReference]].	(self supportsLicensedCreation: provider) ifFalse: [^CLASS_E_NOTLICENSED].	(provider checkLicenseKey: aLicenseKey) ifFalse: [^CLASS_E_NOTLICENSED].	^self basicCreateInstance: aControllingUnknown _: anIID _: aResultReference</body><body package="Com- Ole">GetLicInfo: aLicenseInfo	| provider |	provider := self licenseProvider.	aLicenseInfo memberAt: #fRuntimeKeyAvail		put: (self supportsRuntimeKeyRetrieval: provider).	aLicenseInfo memberAt: #fLicVerified		put: (self requiresLicensedCreation: provider) not.	^S_OK</body><body package="Com- Ole">RequestLicKey: dwReserved _: resultReference	| provider |	provider := self licenseProvider.	(self supportsRuntimeKeyRetrieval: provider) ifFalse: [^E_NOTIMPL].	^	[resultReference value: self licenseProvider requestLicenseKey.	S_OK]			on: Error			do: [:ex | ex return: E_NOTIMPL]</body><body package="Com- Ole">licenseProvider	^ self objectClass</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>private-IClassFactory2 tools</category><body package="Com- Ole">canCreateInstanceWithoutLicense: aProvider	"Can the provider create an instance without requiring a license key.	 This is only asked if the provider supports licensing and it shall be checked if currently it is possible to create instances	 without specifying the key. This is required to support the microsoft Developer/Runtime machine disctinction.	On developer machines, objects can be created without specifying a license key the server can be asked for license keys	for the object. The key is stored in the client executable and passed to CreateInstanceLic() on the runtime machine to	be able to create instances there."	^(aProvider respondsTo: #canCreateWithoutLicense)		and: [aProvider canCreateWithoutLicense]</body><body package="Com- Ole">requiresLicensedCreation: provider	"Answer whether licensed creation is required. If this method answers true,	only CreateInstanceLic() can be used to create instances."	^(self supportsLicensedCreation: provider)		and: [(self canCreateInstanceWithoutLicense: provider) not]</body><body package="Com- Ole">supportsLicensedCreation: provider	"Check if the license provider supports licensing at all"		^ provider respondsTo: #checkLicenseKey:</body><body package="Com- Ole">supportsRuntimeKeyRetrieval: provider	"Check if the license provider supports licensing at all"	^(provider respondsTo: #requestLicenseKey)		and: [self canCreateInstanceWithoutLicense: provider]</body><body package="Com- Ole">supportsUnlicensedCreation: aProvider	^(aProvider respondsTo: #canCreateWithoutLicense)		and: [aProvider canCreateWithoutLicense]</body></methods><methods><class-id>External.COMClassFactoryObject</class-id> <category>subclass-accessing</category><body package="Com- Ole">getInterfaceForIID: iid	" Private - answer the interface identified by the GUID &lt;iid&gt;.  Answer nil if the requested interface is not supported by the receiver. "	iid = IID_IClassFactory ifTrue: [^iClassFactory].	iid = IID_IClassFactory2 ifTrue: [^iClassFactory].	^nil</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>class factory services</category><body package="Com- Ole">classFactoryForCLSID: aGUID	" Answer the class factory which has been registered with COM for the CLSID &lt;aGUID&gt;.  Answer nil if not registered. "	self registeredClassFactories do: [ :aClassFactory |		aClassFactory objectCLSID = aGUID			ifTrue: [ ^aClassFactory ] ].	^nil</body><body package="Com- Ole">classFactoryForClass: aClass	" Answer the class factory which has been registered with COM for the COM object class &lt;aClass&gt;.   Answer nil if not registered. "	self registeredClassFactories do: [ :aClassFactory |		aClassFactory objectClass = aClass			ifTrue: [ ^aClassFactory ] ].	^nil</body><body package="Com- Ole">registerClassFactory: aClassFactory classContext: classContext flags: flags	" Register the class factory &lt;aClassFactory&gt; with COM.  Answer the registration token. "	| anIUnknown registrationToken |	aClassFactory isRegistered		ifTrue: [ COMError hresult: CO_E_OBJISREG ].	anIUnknown := aClassFactory queryInterface: IID_IUnknown.		" Note that this increments the reference count of the class factory.		Since we own this interface reference, we must release it when the		class factory is revoked. "	registrationToken := IClassFactory registerClassObject: aClassFactory objectCLSID  		unknown: anIUnknown 		classContext: classContext 		flags: flags.	aClassFactory 		registeredUnknown: anIUnknown;		registrationToken: registrationToken.	self classFactoryRegistry add: aClassFactory.	^registrationToken</body><body package="Com- Ole">revokeAllClassFactories	" Revoke the registration of all registered class factory objects. "	self registeredClassFactories do: [ :aClassFactory |		[self revokeRegistration: aClassFactory] on: Error do: [:ex | ] ].	self resetClassFactoryRegistry.</body><body package="Com- Ole">revokeClassFactory: aClassFactory	" Revoke the registration of the class factory object &lt;aClassFactory&gt;. "	aClassFactory isRegistered not		ifTrue: [ ^COMError hresult: CO_E_OBJNOTREG ].	self revokeRegistration: aClassFactory.	self classFactoryRegistry remove: aClassFactory ifAbsent: [].	self compressClassFactoryRegistry.	" backup check for server application termination "	( self isInUse not and: [ self exitIfNotInUse ] )		ifTrue: [  " the entire object server application can be shut down "			COMSessionManager terminateServerDeferred.			^self ].</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>testing</category><body package="Com- Ole">isInUse	" Answer whether the object server application is still in use  (i.e., there is an outstanding lock count on the object server application or objects created by a class factory during this session are still in use). "	^self lockCount &gt; 0 or: [ self activeObjectCount &gt; 0 ]</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>private-accessing</category><body package="Com- Ole">activeObjectsRegistry	" Private - answer the registry of objects which have been created during the current session. "	ActiveObjectsRegistry isNil		ifTrue: [ ActiveObjectsRegistry := self constructActiveObjectsRegistry ].	^ActiveObjectsRegistry</body><body package="Com- Ole">activeObjectsRegistry: aRegistry	" Private - set the registry of objects which have been created during the current session. "	ActiveObjectsRegistry := aRegistry.</body><body package="Com- Ole">classFactoryRegistry	" Private - answer the registry of class factories which have been registered with COM during the current session. "	ClassFactoryRegistry isNil		ifTrue: [ ClassFactoryRegistry := self constructClassFactoryRegistry ].	^ClassFactoryRegistry</body><body package="Com- Ole">classFactoryRegistry: aRegistry	" Private - set the registry of class factories which have been registered with COM during the current session. "	ClassFactoryRegistry := aRegistry.</body><body package="Com- Ole">compressActiveObjectsRegistry	" Private - minimize the storage requirements of the active objects registry. "	self activeObjectCount = 0		ifTrue: [ self resetActiveObjectsRegistry ].</body><body package="Com- Ole">compressClassFactoryRegistry	" Private - minimize the storage requirements of the class factory registry. "	self registeredClassFactories size = 0		ifTrue: [ self resetClassFactoryRegistry ].</body><body package="Com- Ole">constructActiveObjectsRegistry	" Private - construct the active objects registry. "	^WeakKeyedRegistry new		action: ( MessageSend forReceiver: self selector: #activeObjectDropped: );		yourself</body><body package="Com- Ole">constructClassFactoryRegistry	" Private - construct the class factory registry. "	^Set new</body><body package="Com- Ole">lockCount: anInteger	" Private - set the number of locks on the object server.  Answer the new count. "	^LockCount := anInteger</body><body package="Com- Ole">resetActiveObjectsRegistry	" Private - reset the registry of objects which have been created during the current session. "	self activeObjectsRegistry: nil.</body><body package="Com- Ole">resetClassFactoryRegistry	" Private - reset the registry of class factories which have been registered with COM during the current session. "	self classFactoryRegistry: nil.</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>private-session management</category><body package="Com- Ole">checkInUse: aClassFactory	" Private - the in-use status of &lt;aClassFactory&gt; may have changed.  Determine whether the object server application itself can be terminated or whether this class factory alone should be released at this time. "	( self isInUse not and: [ self exitIfNotInUse ] )		ifTrue: [  " the entire object server application can be shut down "			COMSessionManager terminateServerDeferred.			^self ].	( aClassFactory isInUse not 	and: [ aClassFactory isRegistered	and: [ aClassFactory releaseIfNotInUse ] ] )		ifTrue: [  " release this class factory but keep the object server running "			aClassFactory revokeRegistrationDeferred ].</body><body package="Com- Ole">resetServerState	" Private - reset the object server state. "	self 		lockCount: 0;		resetActiveObjectsRegistry;		resetClassFactoryRegistry.</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>private-resource management</category><body package="Com- Ole">activeObjectDropped: anEphemeron	" Private - the COM object described by &lt;anEphemeron&gt; which was created by a class factory was dropped from the active objects registry because it is no longer referenced by anything in the system. "	| "aCOMObject" aClassFactory |	" This should not be necessary, given the explicit		notification obtained from COMObject&gt;&gt;releaseResources.		Retain as a backstop. "	"aCOMObject := anEphemeron key."	aClassFactory := anEphemeron value.	"Assert isTrue: [ aCOMObject referenceCount = 0 ]."	self compressActiveObjectsRegistry.	self checkInUse: aClassFactory.</body><body package="Com- Ole">objectReleased: aCOMObject	" The COM object &lt;aCOMObject&gt; has been released by all its clients and is being terminated.   Remove it from the active objects registry if it was created by a class factory object. "	| aClassFactory |	ActiveObjectsRegistry isNil		ifTrue: [ ^self ].	aClassFactory := self activeObjectsRegistry at: aCOMObject		ifAbsent: [ ^nil ].   " wasn't created by a class factory "	self activeObjectsRegistry removeKey: aCOMObject ifAbsent: [].	self compressActiveObjectsRegistry.	self checkInUse: aClassFactory.</body><body package="Com- Ole">revokeRegistration: aClassFactoryObject	" Private - revoke the registration of a registered class factory. "	aClassFactoryObject invalidateSessionSelfReferences.		[aClassFactoryObject performInCorrespondingAppartment: 			[IClassFactory revokeClassObject: aClassFactoryObject registrationToken]]			on: Error			do: 				[:ex |				COMDevelopmentWarning raiseSignal: #ErrorRevokingClassFactory &lt;&lt; #com							&gt;&gt; 'Error when revoking classFactory'].	aClassFactoryObject registeredUnknown enforceRelease.	aClassFactoryObject		registeredUnknown: nil;		registrationToken: nil.	ObjectMemory garbageCollect.	aClassFactoryObject referenceCount &gt; 0		ifTrue: 			[COMDevelopmentWarning				raiseSignal: (#ErrNamedRevokedFactory &lt;&lt; #com						&gt;&gt; 'Revoked class factory for CLSID &lt;1p&gt; still has outstanding references (ref count = &lt;2p&gt;).'							expandMacrosWith: aClassFactoryObject objectCLSID							with: aClassFactoryObject referenceCount)]</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>resource management</category><body package="Com- Ole">activeObjectCount	" Answer the number of objects created by the receiver which are still in service. "	^ActiveObjectsRegistry isNil		ifTrue: [ 0 ]		ifFalse: [ self activeObjectsRegistry size ]</body><body package="Com- Ole">activeObjects	" Answer a collection containing all the active objects which have been created during the current session. "	^ActiveObjectsRegistry isNil		ifTrue: [ #( ) ]		ifFalse: [ self activeObjectsRegistry weakObjects ]</body><body package="Com- Ole">registerObject: aCOMObject classFactory: aClassFactory	" Register the COM object &lt;aCOMObject&gt; which was created by the class factory object &lt;aClassFactory&gt; in the active objects registry. "	self activeObjectsRegistry at: aCOMObject put: aClassFactory.	" arrange to be notified when the object goes away "	aCOMObject when: #released		send: #objectReleased:		to: COMClassFactoryObject		with: aCOMObject.</body><body package="Com- Ole">registeredClassFactories	" Answer the class factories which have been registered with COM during the current session. "	^ClassFactoryRegistry isNil		ifTrue: [ #( ) ]		ifFalse: [ self classFactoryRegistry ]</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>session management</category><body package="Com- Ole">decrementLockCount	" Decrement the number of locks on the object server application.  Answer the lock count. "	^self lockCount: ( self lockCount - 1 )</body><body package="Com- Ole">exitIfNotInUse	" Answer whether the process should be terminated when there are no locked class factories and all objects created by class factories in the current session have been released. "	^ExitIfNotInUse</body><body package="Com- Ole">exitIfNotInUse: aBoolean	" Specify whether the process should be terminated when there are no locked class factories and all objects created by class factories in the current session have been released. "	ExitIfNotInUse := aBoolean.</body><body package="Com- Ole">incrementLockCount	" Increment the number of locks on the object server application.  Answer the lock count. "	^self lockCount: ( self lockCount + 1 )</body><body package="Com- Ole">lockCount	" Answer the number of locks on the object server application. "	^LockCount</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>instance creation</category><body package="Com- Ole">forCLSID: aCLSID	" Answer a new instance of the receiver which creates instances of the COM objects implemented by the COM object class which supports the CLSID specified by the GUID &lt;aCLSID&gt;.   Answer nil if the CLSID is not supported. "	^self new		objectClass: ( COMObject classForCLSID: aCLSID 			ifNone: [ ^nil ] );		objectCLSID: aCLSID;		yourself</body><body package="Com- Ole">forClass: aCOMObjectClass 	" Answer a new instance of the receiver which creates instances of the COM objects implemented by &lt;aCOMObjectClass&gt;. "	| aCLSID |	(aCLSID := aCOMObjectClass clsid) isNil 		ifTrue: 			[self error: #ErrMustDefineCLSID &lt;&lt; #com &gt;&gt; 'must define CLSID to manufacture objects'].	^(self new)		objectClass: aCOMObjectClass;		objectCLSID: aCLSID;		yourself</body></methods><methods><class-id>External.COMClassFactoryObject class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self 		exitIfNotInUse: false;		resetServerState.</body></methods><methods><class-id>External.IEnum</class-id> <category>accessing</category><body package="Com- Ole">contents	" Answer the elements in the enumeration. "	| elements anElement |	"??self reset??"	elements := OrderedCollection new.	[ ( anElement := self next ) notNil ]		whileTrue: [ elements add: anElement ].	^elements</body></methods><methods><class-id>External.IEnum</class-id> <category>private-accessing</category><body package="Com- Ole">bufferElementType	" Private - answer the C type describing an element of the receiver's data type. "	^bufferElementType</body><body package="Com- Ole">elementClass	" Private - answer the class of the elements on which the receiver operates. "	^elementClass</body><body package="Com- Ole">elementSpecification	" Private - answer the kind of elements on which the receiver operates. "	^elementSpecification</body><body package="Com- Ole">elementSpecification: elementTypeSpecifier	" Private - specify the kind of elements on which the receiver operates. "	elementSpecification := elementTypeSpecifier.	self setElementUnpackingAttributes.</body><body package="Com- Ole">setElementUnpackingAttributes	" Private - determine the additional information derived from the element type specification that is needed to unpack the enumeration buffer elements into useful objects of the desired element class. "	elementSpecification == String		ifTrue: [			elementClass := String.			bufferElementType := COMExternalInterface unicodeStringPointerType.			elementUnpackingSelector := #unpackStringElement: .			^self ].	( elementSpecification isKindOf: COMInterface class )		ifTrue: [			elementClass := elementSpecification interfacePointerClass.			bufferElementType := elementClass baseCType.			elementUnpackingSelector := #unpackInterfaceElement: .			^self ].	elementSpecification isSymbol		ifTrue: [			elementClass := COMStructure classForStructureNamed: elementSpecification.			bufferElementType := ( elementClass == COMStructure				ifTrue: [ COMStructure typeNamed: elementSpecification ]				ifFalse: [ elementClass baseCType ] ).			elementUnpackingSelector := ( bufferElementType name = #VARIANT				ifTrue: [ #unpackVariantStructureElement: ]				ifFalse: [ #unpackStructureElement: ] ).			^self ].	( ( elementSpecification isKindOf: COMStructure class )	and: [ elementSpecification ~~ COMStructure ] )		ifTrue: [			elementClass := elementSpecification.			bufferElementType := elementClass baseCType.			elementUnpackingSelector := ( bufferElementType name = #VARIANT				ifTrue: [ #unpackVariantStructureElement: ]				ifFalse: [ #unpackStructureElement: ] ).			^self ].	COMError raiseSignal:(#ErrNamedIEnumNoSupport &lt;&lt; #com &gt;&gt; 'unsupported enumeration element class: &lt;1s&gt;'expandMacrosWith: elementClass name).</body></methods><methods><class-id>External.IEnum</class-id> <category>interface operations</category><body package="Com- Ole">clone	" Answer a new enumerator with the same enumeration sequence as the receiver. "	| resultReference |	resultReference := ( IEnum forIID: self iid ) asValueReference.	interface Clone: resultReference.	"^self class 		on: resultReference value 		elementClass: self elementClass"	^resultReference value</body><body package="Com- Ole">next	" Retrieve the next element in the enumeration sequence. "	| elements |	elements := self next: 1.	^elements isNil		ifTrue: [ nil ]		ifFalse: [ elements at: 1 ]</body><body package="Com- Ole">next: cElements	" Retrieve the next &lt;cElements&gt; elements in the enumeration sequence. "	| elementBuffer resultReference cElementsRetrieved elements |	elementBuffer := self allocateElementBuffer: cElements.	[	resultReference := nil asValueReference.	interface Next: cElements _: elementBuffer _: resultReference.	cElementsRetrieved := resultReference value.	"Assert isTrue: [		( hresult = S_OK and: [ cElementsRetrieved = cElements ] )		or: [ hresult = S_FALSE and: [ cElementsRetrieved &lt; cElements ] ] ]."	elements := ( cElementsRetrieved = 0		ifTrue: [ nil ]		ifFalse: [ self unpackElementBuffer: elementBuffer count: cElementsRetrieved ] ).	] ensure: [ 		self releaseElementBuffer: elementBuffer ].	^elements</body><body package="Com- Ole">reset	" Reset the enumeration sequence back to the beginning.   Answer the result code. "	^interface Reset</body><body package="Com- Ole">skip: cElements	" Skip the next &lt;cElements&gt; elements in the enumeration sequence.  Raise an exception if an error occurs.  Answer the result code. "	^interface Skip: cElements</body></methods><methods><class-id>External.IEnum</class-id> <category>private-enumerating</category><body package="Com- Ole">allocateElementBuffer: cElements	" Private - allocate a buffer which can contain up to &lt;cElements&gt; instances of the receiver's element type. "	^Win32BufferManager allocateHeapBuffer: self bufferElementType  		count: cElements</body><body package="Com- Ole">releaseElementBuffer: elementBuffer	" Private - allocate a buffer which can contain up to &lt;cElements&gt; instances of the receiver's element type. "	Win32BufferManager releaseBuffer: elementBuffer.</body><body package="Com- Ole">unpackElementBuffer: elementBuffer count: cElementsRetrieved	" Private - unpack the &lt;cElementsRetrieved&gt; retrieved by Next from the &lt;elementBuffer&gt;. "	| elements lpElement anElement |	elements := Array new: cElementsRetrieved.	lpElement := elementBuffer copy.	1 to: cElementsRetrieved do: [ :i |		anElement := self perform: elementUnpackingSelector			with: lpElement contents.		elements at: i  put: anElement.		lpElement increment ].	^elements</body><body package="Com- Ole">unpackInterfaceElement: interfacePointerData	" Private - answer an interface for an enumeration element. "	| anInterfacePointer anInterface |	interfacePointerData isNull  " shouldn't be, but we'll be careful just in case "		ifTrue: [ ^nil ].	" elementSpecification is an interface class, elementClass is its interface pointer class "	anInterfacePointer := elementClass fromReturnValue: interfacePointerData.	anInterface := elementSpecification forBinding: anInterfacePointer.		"??anInterfacePointer asInterfaceReference"	"Assert isEqual: anInterface iid to: anInterfacePointer iid."	^anInterface</body><body package="Com- Ole">unpackStringElement: lpString	" Private - answer a string for an enumeration element. "	| aString |	lpString isNull  " shouldn't be, but we'll be careful just in case "		ifTrue: [ ^nil ].	aString := COMExternalInterface stringFromUnicodePointer: lpString.	( COMMemoryAddress fromPointer: lpString ) free.	^aString</body><body package="Com- Ole">unpackStructureElement: structureData	" Private - answer a structure for an enumeration buffer element. "	| aStructure |	"Assert isTrue: [ structureData type isComposite ]."	aStructure := elementClass fromReturnValue: structureData.	"elementClass usesFinalization		ifTrue: [ Assert isTrue: [ aStructure hasFinalization ] ]."	^aStructure</body><body package="Com- Ole">unpackVariantStructureElement: structureData	" Private - answer a structure for an enumeration buffer element. "	^( self unpackStructureElement: structureData ) value</body></methods><methods><class-id>External.IEnum</class-id> <category>copying</category><body package="Com- Ole">copy	" Answer a copy of the receiver.  The copy is not separately reference counted and should not be released unless the it is explicitly reference counted. "	^self class forIID: self iid		binding: self copyInterfaceBinding		elementSpecification: self elementSpecification</body></methods><methods><class-id>External.IEnum</class-id> <category>identity</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid</body><body package="Com- Ole">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;. "	iid := anIID.	interface notNil 		ifTrue: [ interface iid isNil			ifTrue: [ interface iid: anIID ]			ifFalse: [ 				interface iid ~= anIID					ifTrue: [ COMDevelopmentWarning raiseSignal: #ErrIEnumMismatch &lt;&lt; #com &gt;&gt; 'IEnum iid mismatch with interface binding' ].				].			].</body></methods><methods><class-id>External.IEnum class</class-id> <category>private-accessing</category><body package="Com- Ole">elementTypeMap	" Private - answer the dictionary which maps element types to the IID of the interface which enumerates elements of that type. "	^ElementTypeMap		ifNil: 			[self initialize.			ElementTypeMap]</body><body package="Com- Ole">elementTypeMap: aDictionary	" Private - set the dictionary which maps element types to the IID of the interface which enumerates elements of that type. "	ElementTypeMap := aDictionary.</body><body package="Com- Ole">supportedIIDs	" Private - answer the enumerator interface id's which can be represented by instances of the receiver. "	^self elementTypeMap keys asArray</body></methods><methods><class-id>External.IEnum class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerIID	" Private - register the receiver as the interface class for its IID.  IEnum actually registers a family of interface ID's.  The IEnum class doesn't have an IID of its own, since it represents a family of enumerator interfaces, each with its own IID, differentiated only by the type of element being enumerated. "	super registerIID.	self elementTypeMap keysDo: [ :anIID |		self registerIID: anIID forClass: self ].</body><body package="Com- Ole">registerIID: anIID forClass: aClass	" Private - register &lt;aClass&gt; as the interface class representing  the interface whose IID is the interface ID GUID &lt;anIID&gt;. "	| pointerBindingClass callinBindingClass |	"Assert isTrue: [ aClass == IEnum ]."	super registerIID: anIID forClass: aClass.	" we do extra checking here to cover for an init order timing difficulties,		in the event that the host binding classes aren't properly		initialiazed prior to the reference class itself (although they		should be).  We don't mind some inefficiency here because		registration is only done once, when the code is first loaded. "	( pointerBindingClass := aClass interfacePointerClass ) notNil		ifTrue: [ pointerBindingClass registerIID: anIID forClass: pointerBindingClass ].	( callinBindingClass := aClass interfaceImplementationClass ) notNil		ifTrue: [ callinBindingClass registerIID: anIID forClass: callinBindingClass ].</body><body package="Com- Ole">removeIID	" Private - remove the registration of the receiver as the interface class for its IID.  IEnum actually registers a family of interface ID's.  The IEnum class doesn't have an IID of its own, since it represents a family of enumerator interfaces, each with its own IID, differentiated only by the type of element being enumerated. "	super removeIID.	self elementTypeMap keysDo: [ :anIID |		self removeIID: anIID ].</body></methods><methods><class-id>External.IEnum class</class-id> <category>private-installation</category><body package="Com- Ole">constructElementTypeMap	" Private - answer the map from an enumeration element type to the COM interface IID which enumerates elements of that type. "	^Dictionary new		" interface enumerators "		at: IID_IEnumMoniker put: IMoniker;		at: IID_IEnumUnknown put: IUnknown;		" structure enumerators "		at: IID_IEnumFORMATETC put: #FORMATETC;		at: IID_IEnumSTATDATA put: #STATDATA;		at: IID_IEnumSTATSTG put: #STATSTG;		at: IID_IEnumOLEVERB put: #OLEVERB;		" string enumerator "		at: IID_IEnumString put: String;		yourself</body><body package="Com- Ole">initializeElementTypeMap	" Private - initialize the map from an enumeration element type to the COM interface IID which enumerates elements of that type. "	self elementTypeMap: self constructElementTypeMap.</body></methods><methods><class-id>External.IEnum class</class-id> <category>identity</category><body package="Com- Ole">supportsEnumeratorIID: anIID	" Answer whether the receiver represents the enumeration interface identified by the IID &lt;anIID&gt;. "	^self elementTypeMap keys includes: anIID</body><body package="Com- Ole">supportsIID: anIID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^( super supportsIID: anIID )		or: [ self supportsEnumeratorIID: anIID ]</body></methods><methods><class-id>External.IEnum class</class-id> <category>instance creation</category><body package="Com- Ole">adaptorBindingOn: anObject	"Answer a new instance of the receiver which supports its interface indirectly on &lt;anObject&gt;, through a configurable adaptor which maps the standard message selectors for the interface functions to the desired protocol supported by the implementing object. "	^self forBinding: 		( ( self interfaceCallinBindingClass adaptorBindingOn: anObject )			iid: anObject enumeratorIID;			yourself )</body><body package="Com- Ole">directBindingOn: anObject	"Answer a new instance of the receiver which supports its interface directly on &lt;anObject&gt;, using the standard message selectors for the interface functions. "	^self forBinding: 		( ( self interfaceCallinBindingClass directBindingOn: anObject )			iid: anObject enumeratorIID;			yourself )</body><body package="Com- Ole">forBinding: anInterfaceBinding	" Answer a new instance of the receiver with callin/callout binding &lt;anInterfaceBinding&gt;. "	| anIID elementTypeSpecifier |	anIID := anInterfaceBinding iid.	elementTypeSpecifier := self elementTypeOfIID: anIID.	elementTypeSpecifier isNil  " element type not registered "		ifTrue: [ self error: #ErrUnsuppIEnumInt &lt;&lt; #com &gt;&gt; 'unsupported enumeration interface' ].	^self forIID: anIID 		binding: anInterfaceBinding		elementSpecification: elementTypeSpecifier</body><body package="Com- Ole">forIID: anIID	" Answer a new instance of the receiver for the interface specified by &lt;anIID&gt;. "	| elementTypeSpecifier |	elementTypeSpecifier := self elementTypeOfIID: anIID.	elementTypeSpecifier isNil  " element type not registered "		ifTrue: [ self error: #ErrUnsuppIEnumInt &lt;&lt; #com &gt;&gt; 'unsupported enumeration interface' ].	^self forIID: anIID 		binding: nil		elementSpecification: elementTypeSpecifier</body><body package="Com- Ole">on: anObject selectors: selectors 	"Answer a new instance of the receiver which supports its interface on &lt;anObject&gt;		using &lt;selectors&gt; as the interface function handlers to delegate processing		responsibility to the implementing object.  The &lt;selectors&gt; list must be exact match		in size, order, and argument count to the interface VTable function layout. "	anObject isCOMInterfaceBinding 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#ErrNamedOnSelInt &lt;&lt; #com 						&gt;&gt; 'The &lt;1s&gt; #on:selectors: instantiation message should only be used on objects, not interface bindings.' 							expandMacrosWith: self name).			^nil].	^self 		forBinding: ((self interfaceCallinBindingClass adaptorBindingOn: anObject				selectors: selectors)				iid: anObject enumeratorIID;				yourself)</body></methods><methods><class-id>External.IEnum class</class-id> <category>IID element map</category><body package="Com- Ole">elementTypeOfIID: anIID	" Answer the type of elements enumerated by an interface whose IID is &lt;anIID&gt;. "	^self elementTypeMap at: anIID ifAbsent: [ nil ]</body><body package="Com- Ole">enumeratorIIDFor: aClass	" Answer the IID of the enumerator interface which operates on elements of type &lt;aClass&gt;. "	^self elementTypeMap keyAtValue: aClass ifAbsent: [ nil ]</body></methods><methods><class-id>External.IEnum class</class-id> <category>registration</category><body package="Com- Ole">registerEnumeratorIID: anIID for: elementTypeSpecifier	" Register the GUID &lt;anIID&gt; as the IID of the enumerator interface which operates on elements of type &lt;elementTypeSpecifier&gt;. "	" The element type is specified by a class (e.g., an interface pointer class) or the name of a structure type "    ( anIID isNil or: [ anIID = IID_NULL ] )        ifTrue: [ ^nil ].  " ignore null IID's of abstract interface classes "	self elementTypeMap isNil		ifTrue: [ self initializeElementTypeMap ].	self elementTypeMap at: anIID put: elementTypeSpecifier.	self registerIID: anIID forClass: self</body><body package="Com- Ole">removeEnumeratorIID: anIID	" Remove the registration of the GUID &lt;anIID&gt; as the IID of an enumerator interface. "	self elementTypeMap removeKey: anIID ifAbsent: [ ].	self removeIID: anIID.</body></methods><methods><class-id>External.IEnum class</class-id> <category>private-instance creation</category><body package="Com- Ole">forIID: anIID binding: anInterfaceBinding elementSpecification: elementTypeSpecifier	"Private - answer a new instance of the receiver with IID &lt;anIID&gt; which uses the callin/callout binding &lt;anInterfaceBinding&gt; to enumerate interface pointer or data structure elements of type &lt;aClass&gt;. "	^self new		iid: anIID;		interfaceBinding: anInterfaceBinding;		elementSpecification: elementTypeSpecifier;		yourself</body></methods><methods><class-id>External.IEnum class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IEnum.	"A special generic enumerator IID is used for internal			identification of the Smalltalk enumerator interface class. "	self initializeElementTypeMap.	self updateAndRegister</body></methods><methods><class-id>External.GUIDResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Ole">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^GUID baseCType</body></methods><methods><class-id>External.GUIDResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Ole">getResultValue	" Private - answer the contents as a GUID. "	self useFixedSpace ifTrue: [ ^buffer ].	^GUID fromPointer: buffer</body></methods><methods><class-id>External.IUnknownInnerImplementation</class-id> <category>private-dispatch</category><body package="Com- Ole">dispatchAddRef	" Private - dispatch the IUnknown::AddRef function. "	referenceCount := referenceCount + 1.	^implementor innerAddRef</body><body package="Com- Ole">dispatchQueryInterface:  iid _: resultReference	" Private - dispatch the IUnknown::QueryInterface function. "	^implementor innerQueryInterface: iid 		_: resultReference</body><body package="Com- Ole">dispatchRelease	" Private - dispatch the IUnknown::Release function. "	referenceCount := referenceCount - 1.	referenceCount = 0 ifTrue: [ self releaseResources ].	^implementor innerRelease</body></methods><methods><class-id>External.IUnknownInnerImplementation</class-id> <category>private-tracing</category><body package="Com- Ole">isInterfaceFunctionSelector: aSelector	" Private - answer whether &lt;aSelector&gt; is an interface function selector of the receiver. "	^self class vtableSelectors includes: ( 'inner', aSelector ) asSymbol</body></methods><methods><class-id>External.IUnknownInnerImplementation</class-id> <category>dispatch configuring</category><body package="Com- Ole">dispatchSelectors	" Answer the message selectors of the receiver's interface function dispatch bindings "	"Assert isEqual: super dispatchSelectors		to: self class dispatchSelectors."	^self class vtableSelectors</body></methods><methods><class-id>External.IUnknownInnerImplementation class</class-id> <category>instance creation</category><body package="Com- Ole">adaptorBindingOn: anObject	" Answer an initialized instance of the receiver that is an interface for &lt;anObject&gt;.  The object can configure the interface binding to map the standard function selectors of this interface to any desired protocol.  The inner unknown is special, however, and we do not allow any fooling around with it. "	self shouldNotImplement.</body></methods><methods><class-id>External.IUnknownInnerImplementation class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerIID	" Private - register the receiver as the interface implementation binding class for its IID.  Do nothing for the receiver - its superclass IUnknownImplementation is correctly registered as the class for the (shared) IID. "</body><body package="Com- Ole">removeIID	" Private - remove the registration of the receiver as the interface implementation binding class for its IID.  Do nothing for the receiver - its superclass IUnknownImplementation is correctly registered as the class for the (shared) IID. "</body></methods><methods><class-id>External.IUnknownInnerImplementation class</class-id> <category>private-installation</category><body package="Com- Ole">defaultForwardingSelectorFor: anEntryPointDescription	" Private - answer the default selector to use when forwarding a callback for &lt;anEntryPointDescription&gt; to the implementing object which supports the interface. "	" Note that in Visual Smalltalk, the callin binding has the same argument list as the callout binding, while in Visual Works an additional 'this' argument is always prepended by the OE callback mechanism. "	^self constructSelectorFor: anEntryPointDescription name 		prefix: 'inner' 		nArgs: anEntryPointDescription numberOfArguments - 1  " strip leading This arg from VW callback when forwarding "</body></methods><methods><class-id>External.IUnknownInnerImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IUnknown.	self vtableSignatureTypeName: #__IUnknownVtbl.	self updateAndRegister</body></methods><methods><class-id>External.COMInterfaceVTableSignatures class</class-id> <category>private-installation</category><body package="Com- Ole">obsolete	"The receiver was removed from the system and is now obsolete. Perform any necessary clean-up. Answer the receiver."	COMInterfaceImplementation vtableSignaturesPool: nil.	^super obsolete</body></methods><methods><class-id>External.COMInterfaceVTableSignatures class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	COMInterfaceImplementation vtableSignaturesPool: self externals.</body></methods><methods><class-id>External.IBindCtx class</class-id> <category>instance creation</category><body package="Com- Ole">newBindContext	" Answer a newly allocated bind context. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current CreateBindCtx: 0 		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.IBindCtx class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IBindCtx.	self updateAndRegister</body></methods><methods><class-id>External.IClassFactoryPointer</class-id> <category>interface operations</category><body package="Com- Ole">CreateInstance: controllingUnknown _: iid _: resultReference        " Invoke the IClassFactory::CreateInstance function.        Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := self invokeCreateInstance: controllingUnknown asPointerParameter		_: iid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.IClassFactoryPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IClassFactory.	self updateAndRegister</body></methods><methods><class-id>External.IAdviseSinkPointer</class-id> <category>interface operations</category><body package="Com- Ole">OnDataChange: aFormatEtc _: aStgMedium		" Invoke the IAdviseSink::OnDataChange function. "	self invokeOnDataChange: aFormatEtc asPointerParameter 		_: aStgMedium asPointerParameter</body><body package="Com- Ole">OnRename: anIMoniker		" Invoke the IAdviseSink::OnRename function. "	self invokeOnRename: anIMoniker asPointerParameter</body></methods><methods><class-id>External.IAdviseSinkPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IAdviseSink.	self updateAndRegister</body></methods><methods><class-id>External.COMInterfaceValueReference</class-id> <category>private-accessing</category><body package="Com- Ole">interfaceReference	" Private - answer the interface reference value referenced by the receiver. "	^super value</body><body package="Com- Ole">interfaceReference: anInterface	" Private - set the interface reference value referenced by the receiver. "	"Assert isTrue: [ anInterface isCOMInterfaceReference ]."	super value: anInterface.</body></methods><methods><class-id>External.COMInterfaceValueReference</class-id> <category>accessing</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the value referenced by the receiver. "	^value notNil		ifTrue: [ value iid ]		ifFalse: [ nil ]</body><body package="Com- Ole">value	" Answer the value referenced by the receiver. "	value isNil ifTrue: [ ^nil ].	^value isValid		ifTrue: [ value ]		ifFalse: [ nil ]</body><body package="Com- Ole">value: anInterface	" Set the value referenced by the receiver to &lt;anInterface&gt;. "	( anInterface isNil or: [ anInterface isValid not ] )		ifTrue: [			value := nil.			^nil ].	anInterface isCOMInterfaceReference		ifTrue: [			self checkInterface: anInterface.			value := anInterface ]		ifFalse: [			Assert isTrue: [ anInterface isCOMInterfaceBinding ].			value interfaceBinding: anInterface interfaceBinding ].	^anInterface</body></methods><methods><class-id>External.COMInterfaceValueReference</class-id> <category>testing</category><body package="Com- Ole">isEmpty	" Answer whether the receiver contains a value. "	^super isEmpty or: [ self value isValid not ]</body></methods><methods><class-id>External.COMInterfaceValueReference</class-id> <category>printing</category><body package="Com- Ole">printValueOn: aStream	" Append a text description of value referenced by the receiver to &lt;aStream&gt; "	value isNil		ifTrue: [ ^super printValueOn: aStream ].	value isValid		ifTrue: [ self value printOn: aStream ]		ifFalse: [			nil printOn: aStream.			aStream nextPutAll: ' (for ', value class printString, ')' ].</body></methods><methods><class-id>External.COMInterfaceValueReference</class-id> <category>private-error handling</category><body package="Com- Ole">checkInterface: anInterface	" Private - verify that &lt;anInterface&gt; is suitable to install in the receiver. "	anInterface iid isNil		ifTrue: 			[self error: #InvalidInterface &lt;&lt; #com &gt;&gt; 'invalid interface (no iid)'].	Tools.Note ISSUE.	" Not sure how/whether to try to get this working with dispatch interfaces.		Give up for tonight.  [DL 02-Jun-97] "	value iid = IID_IDispatch ifTrue: [^self].	"Sometimes an subclass shall be put into an InterfaceValueReference configured to hold a superclass if ObjectStudio is loaded"	(value iid = anInterface iid		or: [value class supportsIID: anInterface iid])			ifFalse: [self error: #ErrIIDMismatch &lt;&lt; #com &gt;&gt; 'IID mismatch']</body></methods><methods><class-id>External.COMInterfaceValueReference class</class-id> <category>instance creation</category><body package="Com- Ole">forIID: anIID	" Answer a new instance of the receiver which will be used to obtain the interface binding for a new instance of the interface class identified by the GUID &lt;anIID&gt;. "	| anInterface |	anInterface := ( COMInterface classForIID: anIID ifNone: [ IAnonymous ] ) new		iid: anIID;		yourself.	^self on: anInterface</body><body package="Com- Ole">on: anInterface 	" Answer a new instance of the receiver which will be used to obtain the interface binding for the interface reference &lt;anInterface&gt;. "	anInterface isCOMInterface 		ifFalse: 			[self error: #ErrOnlyIntReferenced &lt;&lt; #com &gt;&gt; 'only interface values can be referenced'].	"Assert isTrue: [ anInterface interfaceBinding isNil ]."	^(self new)		interfaceReference: anInterface;		yourself</body></methods><methods><class-id>External.IAdviseSink2Pointer</class-id> <category>interface operations</category><body package="Com- Ole">OnLinkSrcChange: anIMoniker		" Invoke the IAdviseSink2::OnLinkSrcChange function. "	self invokeOnLinkSrcChange: anIMoniker asPointerParameter.</body></methods><methods><class-id>External.IAdviseSink2Pointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IAdviseSink2.	self updateAndRegister</body></methods><methods><class-id>External.COM_STATSTG</class-id> <category>testing</category><body package="Com- Ole">hasMode: aStorageModeFlag		" Answer whether the STGM storage mode flag &lt;aStorageModeFlag&gt; is set. "	^( ( self memberAt: #grfMode ) bitAnd: aStorageModeFlag ) ~= 0</body><body package="Com- Ole">hasName		" Answer whether the receiver includes a reference to a name string. "	"^( self addressAtOffset: 0 ) notNil"	^( self memberAt: #pwcsName ) isValid</body><body package="Com- Ole">isDirectStorage		" Answer whether the element is direct storage "	^self hasMode: STGM_DIRECT</body><body package="Com- Ole">isEditable		" Answer whether the element is editable "	^self hasMode: STGM_READWRITE</body><body package="Com- Ole">isLocked		" Answer whether the element has any access locks. "	^( self hasMode: STGM_SHARE_DENY_NONE ) not</body><body package="Com- Ole">isLockedExclusive		" Answer whether the element has an exclusive access lock. "	^self hasMode: STGM_SHARE_EXCLUSIVE</body><body package="Com- Ole">isProperty		" Answer whether this is a property element. "	^( self memberAt: #type ) = STGTY_PROPERTY</body><body package="Com- Ole">isReadOnly		" Answer whether the element is readOnly. "	^( ( self hasMode: STGM_READ ) and: [ ( self hasMode: STGM_READWRITE ) not ] )</body><body package="Com- Ole">isStorage		" Answer whether this is a storage element. "	^( self memberAt: #type ) = STGTY_STORAGE</body><body package="Com- Ole">isStream		" Answer whether this is a stream element. "	^( self memberAt: #type ) = STGTY_STREAM</body><body package="Com- Ole">isTransactedStorage		" Answer whether the element is transacted storage "	^self hasMode: STGM_TRANSACTED</body><body package="Com- Ole">isWriteLocked		" Answer whether the element has a no-writers access lock. "	^self hasMode: STGM_SHARE_DENY_WRITE</body><body package="Com- Ole">isWriteOnly		" Answer whether the element is writeOnly. "	^( ( self hasMode: STGM_WRITE ) and: [ ( self hasMode: STGM_READWRITE ) not ] )</body></methods><methods><class-id>External.COM_STATSTG</class-id> <category>accessing</category><body package="Com- Ole">cbSize	" Answer the size in bytes of a stream or byte element. "	^self uLargeIntegerMemberAt: #cbSize</body><body package="Com- Ole">clsid	" Answer the CLSID of the storage (if any). "	^self guidMemberAt: #clsid</body><body package="Com- Ole">createTime	" Answer the create-time timestamp. "	^self fileTimeMemberAt: #ctime</body><body package="Com- Ole">lastAccessedTime	" Answer the last-accessed timestamp. "	^self fileTimeMemberAt: #atime</body><body package="Com- Ole">lastModifiedTime	" Answer the last-modified timestamp. "	^self fileTimeMemberAt: #mtime</body><body package="Com- Ole">name	" Answer the name of the storage element. "	^self unicodePointerMemberAt: #pwcsName</body></methods><methods><class-id>External.COM_STATSTG</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream	" Append the ASCII representation of the receiver to aStream. "	| elementName |	super printOn: aStream.	self isValid 		ifFalse: [ ^self ].	aStream nextPutAll: ' (', self typeDescription.	( elementName := self name ) notNil		ifTrue: [ aStream space; nextPutAll: elementName printString ].	aStream nextPutAll: ') '.</body></methods><methods><class-id>External.COM_STATSTG</class-id> <category>subclass-releasing</category><body package="Com- Ole">releaseResources	" Private - release resources owned by the receiver. "	self releaseStorageName.	super releaseResources.</body><body package="Com- Ole">releaseStorageName	" Private - release the storage name in the receiver. "	| aPointer |	( aPointer := self memberAt: #pwcsName ) isNull		ifFalse: [			( COMMemoryAddress fromPointer: aPointer ) free.			self memberAt: #pwcsName put: nil ].</body></methods><methods><class-id>External.COM_STATSTG</class-id> <category>utilities</category><body package="Com- Ole">typeDescription	" Answer a string description of the storage element type. "	self isStorage ifTrue: [ ^'storage' ].	self isStream ifTrue: [ ^'stream' ].	self isProperty ifTrue: [ ^'property' ].	( self type = STGTY_LOCKBYTES ) ifTrue: [ ^'lockBytes' ].	^(#unknownType &lt;&lt; #com &gt;&gt; '(unknown type)') asString</body></methods><methods><class-id>External.COM_STATSTG class</class-id> <category>accessing</category><body package="Com- Ole">enumeratorIID	" Answer the IID of the interface which enumerates collections containing instances of the receiver. "	^IID_IEnumSTATSTG</body></methods><methods><class-id>External.COM_STATSTG class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self structureName: #STATSTG.	self updateAndRegister</body></methods><methods><class-id>External.IPersistFileImplementation</class-id> <category>interface operations</category><body package="Com- Ole">GetCurFile: resultReference		" Invoke the IPersistFile::GetCurFile function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetCurFile: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">IsDirty		" Invoke the IPersistFile::IsDirty function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor IsDirty		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Load: aPathName _: accessModeFlags		" Invoke the IPersistFile::Load function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Load: aPathName _: accessModeFlags		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Save: aPathName _: fRemember		" Invoke the IPersistFile::Save function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Save: aPathName _: fRemember		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">SaveCompleted: aPathName		" Invoke the IPersistFile::SaveCompleted function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor SaveCompleted: aPathName		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IPersistFileImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetCurFile: this _: ppszFileName	" Private - invoke the IPersistFile::GetCurFile function for an external caller. "	" HRESULT GetCurFile(            /* [out] */ LPOLESTR *ppszFileName); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	ppszFileName isValid ifFalse: [^E_INVALIDARG].	self clearPointerResultValueAtAddress: ppszFileName.	resultReference := nil asValueReference.	hresult := implementor GetCurFile: resultReference.	hresult succeeded		ifTrue: [self stringResultAtAddress: ppszFileName put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeIsDirty: this	" Private - invoke the IPersistFile::IsDirty function for an external caller. "	" HRESULT IsDirty( void);"	^[   " terminate exception stack unwind at external callin boundary "	implementor IsDirty.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeLoad: this _: pszFileName _: dwMode	" Private - invoke the IPersistFile::Load function for an external caller. "	" HRESULT Load(            /* [in] */ LPCOLESTR pszFileName,            /* [in] */ DWORD dwMode); "	^[   " terminate exception stack unwind at external callin boundary "	| aPathName |	self reportExternalFunctionEntry.	pszFileName isValid		ifFalse: [ ^E_INVALIDARG ].	aPathName := self stringAtAddress: pszFileName.	implementor Load: aPathName _: dwMode.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeSave: this _: pszFileName _: fRemember		" Private - invoke the IPersistFile::Save function for an external caller. "	" HRESULT Save(            /* [unique][in] */ LPCOLESTR pszFileName,            /* [in] */ BOOL fRemember); "	^[   " terminate exception stack unwind at external callin boundary "	| aPathName |	self reportExternalFunctionEntry.	pszFileName isValid		ifFalse: [ ^E_INVALIDARG ].	aPathName := self stringAtAddress: pszFileName.	implementor Save: aPathName 		_: fRemember.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeSaveCompleted: this _: pszFileName	" Private - invoke the IPersistFile::SaveCompleted function for an external caller. "	" HRESULT SaveCompleted(            /* [unique][in] */ LPCOLESTR pszFileName); "	^[   " terminate exception stack unwind at external callin boundary "	| aPathName |	self reportExternalFunctionEntry.	pszFileName isValid		ifFalse: [ ^E_INVALIDARG ].	aPathName := self stringAtAddress: pszFileName.	implementor SaveCompleted: aPathName.	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IPersistFileImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistFile.	self vtableSignatureTypeName: #__IPersistFileVtbl.	self updateAndRegister</body></methods><methods><class-id>External.IUnknownAdaptor</class-id> <category>interface operations</category><body package="Com- Ole">QueryInterface: iid _: resultReference	" Invoke the IUnknown::QueryInterface function. "	^self triggerEvent: #QueryInterface:_:		with: iid		with: resultReference</body></methods><methods><class-id>External.IUnknownAdaptor</class-id> <category>dispatch configuring</category><body package="Com- Ole">installMinimumDispatchHandlers	" Configure the receiver's interface function dispatch bindings to dispatch the IUnknown functions to the implementing object using the standard function selectors, with unimplemented-function semantics for all other operations. "	self installUnimplementedDispatchHandlers.	IUnknownImplementation vtableSelectors do: [ :aSelector |		self when: aSelector			send: (implementor vtableSelectorFor: aSelector) to: implementor ].</body></methods><methods><class-id>External.IUnknownAdaptor</class-id> <category>obsolete</category><body package="Com- Ole">AddRef	" Invoke the IUnknown::AddRef function. "	self callIsDispensable.</body><body package="Com- Ole">Release	self callIsDispensable.</body></methods><methods><class-id>External.IUnknownAdaptor</class-id> <category>private interface operations</category><body package="Com- Ole">privateAddRef	" Invoke the IUnknown::AddRef function. "	^self triggerEvent: #AddRef</body><body package="Com- Ole">privateRelease	" Invoke the IUnknown::Release function. "	^self triggerEvent: #Release</body><body package="Com- Ole">referenceCount	^ implementor referenceCount</body></methods><methods><class-id>External.COMStructurePointerResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Ole">getResultValue	" Private - convert the buffer contents into a suitable value for the structure.  Answer the value. "	| lpStruct aCOMAddress aStructure |	lpStruct := buffer contents.	lpStruct isNull		ifTrue: [ ^nil ].	aCOMAddress := COMMemoryAddress fromPointer: lpStruct.	"Assert isTrue: [ aCOMAddress hasFinalization not ]."	aStructure := structureClass fromReturnValue: aCOMAddress.	^aStructure</body></methods><methods><class-id>External.IGlobalInterfaceTableImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeGetInterfaceFromGlobal: this _: dwCookie _: riid _: ppU	" Private - invoke the IGlobalInterfaceTable::GetInterfaceFromGlobal function for an external caller. "	" HRESULT __stdcall  GetInterfaceFromGlobal(DWORD dwCookie, REFIID const riid, IUnknown * * ppU) = 5 ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^[  " terminate exception stack unwind at function invocation boundary "	| hresult resultReference |	"### optional - add checking for NULL argument pointers:	self reportExternalFunctionEntry.	riid isNull ifTrue: [ ^E_INVALIDARG ].	ppU isNull ifTrue: [ ^E_INVALIDARG ].	###"	self clearResultBufferAtAddress: ppU.	resultReference := nil asValueReference.	hresult := implementor GetInterfaceFromGlobal: dwCookie _: ( self guidAtAddress: riid ) _: resultReference.	( HRESULT succeeded: hresult )		ifTrue: [			self interfaceResultAtAddress: ppU put: resultReference value.			].	hresult	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeRegisterInterfaceInGlobal: this _: pUnk _: riid _: dwCookie	" Private - invoke the IGlobalInterfaceTable::RegisterInterfaceInGlobal function for an external caller. "	" HRESULT __stdcall  RegisterInterfaceInGlobal(IUnknown * pUnk, REFIID riid, dword * dwCookie) = 3 ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^[  " terminate exception stack unwind at function invocation boundary "	"### optional - add checking for NULL argument pointers:	self reportExternalFunctionEntry.	pUnk isNull ifTrue: [ ^E_INVALIDARG ].	riid isNull ifTrue: [ ^E_INVALIDARG ].	dwCookie isNull ifTrue: [ ^E_INVALIDARG ].	###"	implementor RegisterInterfaceInGlobal: ( "self interfaceAtAddress: "pUnk "### type: IFoo ##" ) _: ( self guidAtAddress: riid ) _: dwCookie  "### UNKNOWN TYPE ###"	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeRevokeInterfaceFromGlobal: this _: dwCookie	" Private - invoke the IGlobalInterfaceTable::RevokeInterfaceFromGlobal function for an external caller. "	" HRESULT __stdcall  RevokeInterfaceFromGlobal(DWORD dwCookie) = 4 "	^[  " terminate exception stack unwind at function invocation boundary "	implementor RevokeInterfaceFromGlobal: dwCookie	] on: self rootExceptions		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IGlobalInterfaceTableImplementation</class-id> <category>interface operations</category><body package="Com- Ole">GetInterfaceFromGlobal: dwCookie _: riid _: resultReference	" Invoke the IGlobalInterfaceTable::GetInterfaceFromGlobal function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor GetInterfaceFromGlobal: dwCookie _: riid _: resultReference		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">RegisterInterfaceInGlobal: pUnk _: riid _: dwCookie	" Invoke the IGlobalInterfaceTable::RegisterInterfaceInGlobal function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor RegisterInterfaceInGlobal: pUnk _: riid _: dwCookie		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">RevokeInterfaceFromGlobal: dwCookie	" Invoke the IGlobalInterfaceTable::RevokeInterfaceFromGlobal function. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor RevokeInterfaceFromGlobal: dwCookie		] on: self rootExceptions			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IGlobalInterfaceTableImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IGlobalInterfaceTable.	self vtableSignatureTypeName: #__IGlobalInterfaceTableVtbl.	self updateAndRegister</body></methods><methods><class-id>External.COMMemoryAddress</class-id> <category>private-memory allocator</category><body package="Com- Ole">memoryAllocator		" Private - answer the OLE memory allocator which owns the receiver. "	^self class memoryAllocator</body></methods><methods><class-id>External.COMMemoryAddress</class-id> <category>pointer arithmetic</category><body package="Com- Ole">increment	"Increment the receiver's referent address by one element.  The receiver's pointer value will be adjusted by the size of the receiver's referent type. "	^self pointer increment</body></methods><methods><class-id>External.COMMemoryAddress</class-id> <category>converting</category><body package="Com- Ole">asByteStream	" Answer a read write stream connected to the receiver which treats its contents as bytes."	^Win32MemoryReadWriteStream byteStreamOn: self</body><body package="Com- Ole">asCharacterStream	" Answer a read write stream connected to the receiver which treats its contents as characters."	^Win32MemoryReadWriteStream characterStreamOn: self</body><body package="Com- Ole">readWriteStream	"Answer a read write stream connected to the receiver."	^self asCharacterStream</body></methods><methods><class-id>External.COMMemoryAddress</class-id> <category>accessing</category><body package="Com- Ole">memberAt: aMember	"Answer the value of the structure member named by the symbol &lt;aMember&gt;. "	^pointer memberAt: aMember</body><body package="Com- Ole">memberAt: aMember put: aValue	"Set the value of the structure member named by the symbol &lt;aMember&gt; to &lt;aValue&gt;. "	^pointer memberAt: aMember put: aValue</body><body package="Com- Ole">memorySize        "Answer the size of the data associated with the receiver"    self isValid ifFalse: [ ^0 ].    ^self memoryAllocator getSize: self</body><body package="Com- Ole">reallocateMemory: newSizeInBytes        "Reallocate the receiver to be of size &lt;newSizeInBytes&gt;.  		Copy the contents as necessary.  Free any memory no longer used.  		Note that this may cause the block of memory to be allocated in a 		new location."    self memoryAllocator 		reallocate: self 		newSize: newSizeInBytes.	^self</body><body package="Com- Ole">refMemberAt: aMember	"Answer a pointer to the structure member named by the symbol &lt;aMember&gt;. "	^pointer refMemberAt: aMember</body></methods><methods><class-id>External.COMMemoryAddress</class-id> <category>subclass-releasing</category><body package="Com- Ole">finalizationRegistry		"Private - Answer the WeakRegistry to be used for finalizing instances of the receiver."    ^COMSessionManager ownedMemoryRegistry</body><body package="Com- Ole">finalize	"The receiver is no longer referenced by any object in the system and is about to be destroyed.  Free the external memory referenced by the receiver. "	^self privateRelease</body><body package="Com- Ole">releaseMemory        "Private - Release the memory at the receiver's address."	self memoryAllocator free: self.</body></methods><methods><class-id>External.COMMemoryAddress</class-id> <category>testing</category><body package="Com- Ole">isCOMExternalAddress	" Answer whether the receiver is an external memory address which was allocated by a COM memory allocator. "    ^true</body></methods><methods><class-id>External.COMMemoryAddress</class-id> <category>private-session management</category><body package="Com- Ole">shutdownImage	"Private - The image session is being shut down.  All allocated interfaces should have already been released at this point; cannot release now because memory allocators and OLEDLL are closed. "	self isValid 		ifTrue: 			[COMDevelopmentWarning 				raiseSignal: (#ErrNamedUnreleasedAddressAtExit1p &lt;&lt; #com 						&gt;&gt; 'Unreleased COM address found at image exit: &lt;1p&gt;' 							expandMacrosWith: self)]</body></methods><methods><class-id>External.COMMemoryAddress</class-id> <category>comparing</category><body package="Com- Ole">interfaceEqual: anInterfacePointer	^self asInteger = anInterfacePointer asInteger</body></methods><methods><class-id>External.COMMemoryAddress class</class-id> <category>instance creation</category><body package="Com- Ole">allocateMemory: allocationSpecification	" Allocate a block of COM external memory according to &lt;allocationSpecification&gt;, which can either be an integer specifying the size in bytes of an untyped block of memory or a C type describing the memory.  Answer a new instance of the receiver referencing the newly allocated memory. "	| anAddress |	anAddress := self memoryAllocator allocate: ( self getAllocationSizeFor: allocationSpecification )		addressType: self.	anAddress referentType: ( self getAllocationReferentTypeFor: allocationSpecification ).	^anAddress</body><body package="Com- Ole">allocateMemory: allocationSpecification flags: allocFlags	" Allocate a block of COM external memory according to &lt;allocationSpecification&gt;, which can either be an integer specifying the size in bytes of an untyped block of memory or a C type describing the memory.  The &lt;allocFlags&gt; are ignored, since they are not supported by the COM task memory allocator, except for the convention that the Win32 GMEM_ZEROINIT flag can be used to specify zero-initialization of the allocated memory.   Answer a new instance of the receiver referencing the newly allocated memory. "	| anAddress |	anAddress := self allocateMemory: allocationSpecification.	" flags aren't ordinarily relevant for COM memory allocation.  However, we		allow the use of the Win32 GMEM_ZEROINIT flag to enable		convenient allocation of zero-initialized memory. "	( self allocationFlagsClearMemory: allocFlags )		ifTrue: [ 			| nBytes |			nBytes := self getAllocationSizeFor: allocationSpecification.			anAddress replaceBytes: nBytes				with: ( ByteArray new: nBytes ) ].	^anAddress</body><body package="Com- Ole">allocateStructure: aStructureType        "Allocate a zero-initialized block in COM external memory to contain a structure of type &lt;aStructureType&gt;.  Answer a new instance of the receiver which references the newly allocated memory."	^self allocateMemory: aStructureType 		flags: Win32GlobalMemoryAddress zeroInitializationFlag</body><body package="Com- Ole">allocateStructure: aStructureType count: count        "Allocate a zero-initialized block in COM external memory to contain &lt;count&gt; instances of the structure of type &lt;aStructureType&gt;.  Answer a new instance of the receiver which references the newly allocated memory."	| anAddress |	anAddress := self allocateMemory: ( aStructureType sizeof * count ) 		flags: Win32GlobalMemoryAddress zeroInitializationFlag.	anAddress referentType: aStructureType.	^anAddress</body><body package="Com- Ole">defaultAllocationFlags	" Answer the default allocation flags for instances of the receiver.  Allocation flags are not relevant for COM memory.  However, the Win32 GMEM_ZEROINIT can be used to specify that allocated memory is zero-initialized. "	^0</body></methods><methods><class-id>External.COMMemoryAddress class</class-id> <category>subclass-allocation</category><body package="Com- Ole">allocateMemoryForExternalCopy: nBytes flags: allocFlags	" Private - allocate &lt;nBytes&gt; of external memory to which a byte object will be copied. "	" external copy will take care of zeroing any trailing extra bytes, so we		can ignore &lt;allocFlags&gt;, whose only purpose with COM memory		is to enable a convenient zero-initialized allocation "	^self allocateMemory: nBytes</body><body package="Com- Ole">memoryAllocator		" Private - answer the COM memory allocator which is used to allocate 		memory referenced by instances of the receiver. "	^IMalloc taskMemoryAllocator</body></methods><methods><class-id>External.COMMemoryAddress class</class-id> <category>external-transformations</category><body package="Com- Ole">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing an address which will be allocated by the callee using the COM task memory allocator.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^COMMemoryAddressResultBuffer new</body></methods><methods><class-id>External.IParseDisplayNamePointer</class-id> <category>interface operations</category><body package="Com- Ole">ParseDisplayName: aBindContext 	_: aDisplayName 	_: nCharsConsumedReference 	_: resultReference		" Invoke the IParseDisplayName::ParseDisplayName function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer nCharsConsumedBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	nCharsConsumedBuffer := COMExternalInterface scalarResultBufferFor: #ULONG.	hresult := self invokeParseDisplayName: aBindContext asPointerParameter		_: aDisplayName asUnicodeParameter		_: nCharsConsumedBuffer asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	nCharsConsumedReference value: nCharsConsumedBuffer contents.	^hresult</body></methods><methods><class-id>External.IParseDisplayNamePointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IParseDisplayName.	self updateAndRegister</body></methods><methods><class-id>External.IGlobalInterfaceTablePointer</class-id> <category>As yet unclassified</category><body package="Com- Ole">marshalToOtherApartment	^self</body><body package="Com- Ole">matchesProcessApartment	^ true</body></methods><methods><class-id>External.IGlobalInterfaceTablePointer</class-id> <category>interface operations</category><body package="Com- Ole">GetInterfaceFromGlobal: dwCookie _: riid _: resultReference	" Invoke the IGlobalInterfaceTable::GetInterfaceFromGlobal function. ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: riid.	hresult := self invokeGetInterfaceFromGlobal: dwCookie _: riid _: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">RegisterInterfaceInGlobal: pUnk _: riid _: dwCookie	" Invoke the IGlobalInterfaceTable::RegisterInterfaceInGlobal function. ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^self invokeRegisterInterfaceInGlobal: pUnk asPointerParameter _: riid _: dwCookie</body><body package="Com- Ole">RevokeInterfaceFromGlobal: dwCookie	" Invoke the IGlobalInterfaceTable::RevokeInterfaceFromGlobal function. "	^self invokeRevokeInterfaceFromGlobal: dwCookie</body></methods><methods><class-id>External.IGlobalInterfaceTablePointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IGlobalInterfaceTable.	self updateAndRegister</body></methods><methods><class-id>External.COMExternalVTable</class-id> <category>private-accessing</category><body package="Com- Ole">vtableDescription: anArrayOfEntryPointDescriptions		" Set the VTable description in the form of a list		of OLE entry point descriptions, ordered by VTable slot index. "	vtableDescription := anArrayOfEntryPointDescriptions.</body></methods><methods><class-id>External.COMExternalVTable</class-id> <category>accessing</category><body package="Com- Ole">callbackSelectors		" Answer the dispatch selectors for processing callins to this VTable,		ordered by VTable slot index. "	^ callbackSelectors</body><body package="Com- Ole">interfaceClass	^interfaceClass</body><body package="Com- Ole">interfaceClass: anObject	interfaceClass := anObject</body><body package="Com- Ole">size		" Answer the size of the VTable. "	^self vtableDescription size</body><body package="Com- Ole">vTablePointer	^vTablePointer ifNil: [self computeVTablePointer ].</body><body package="Com- Ole">vtableDescription		" Answer the VTable description in the form of a list		of OLE entry point descriptions, ordered by VTable slot index. "	^vtableDescription</body></methods><methods><class-id>External.COMExternalVTable</class-id> <category>private-initialization</category><body package="Com- Ole">entryPoints: entryPointDescriptions callbackSelectors: newCallbackSelectors	" Private - encode the &lt;entryPointDescriptions&gt; and		callback dispatch selectors in &lt;callbackSelectors&gt; in the		descriptor list format used by the VTable callin mechanism. 		A template for the encoding is pre-constructed - the actual		callin descriptor is fully constructed when the interface is exported. "	| nEntryPoints |	nEntryPoints := entryPointDescriptions size.	vtableDescription := Array new: nEntryPoints.	callbackSelectors := newCallbackSelectors.	1 to: nEntryPoints		do: [:i | vtableDescription at: i put: (entryPointDescriptions at: i) copy]</body></methods><methods><class-id>External.COMExternalVTable</class-id> <category>private</category><body package="Com- Ole">allocateVTable	| entryPointSize numEntries entriesSize size interface pointer |	interface := COMPlatformProvider current.	entryPointSize := interface entryPointType sizeof.	numEntries := self size.	entriesSize := (interface vtableType baseType memberNamed: #size) value				sizeof.	size := entryPointSize * numEntries + entriesSize.	pointer := (COMMemoryAddress allocateMemory: size				flags: Win32GlobalMemoryAddress zeroInitializationFlag)				referentType: interface vtableType;				doesNotNeedFinalization;				yourself.	"Managed by COM Connect - should not be visible in ResourceBrowser to users"	pointer memberAt: #size put: size.	self vTablePointer: pointer</body><body package="Com- Ole">callbackAt: index	| callback |	^(callbacks at: index)		ifNil: 			[callback := self callbackFor: (self vtableDescription at: index)						selector: (self callbackSelectors at: index).			callbacks at: index put: callback.			callback]</body><body package="Com- Ole">callbackFor: aCOMEntryPointDescription selector: aSymbol	^CCallback		do: (self perform: (self class callbackBlockSelectorFor: aSymbol)				with: aSymbol with: aCOMEntryPointDescription resultType)		ofType: aCOMEntryPointDescription signatureType pointerType</body><body package="Com- Ole">checkResult: result type: aType	"Check the return value. In case of an HRESULT, return the integer value.	 Raise an error if the value does not match the result type"	aType = COMExternalInterface current HRESULT		ifTrue: 			["Make sure we really have a compatible result. ObjectStudio has String&gt;asInteger which may just return nil"			^result asHRESULT asInteger].	ImageConfiguration isDevelopment ifFalse: [^result].	aType baseType = CVoidType void ifTrue: [^result].	aType = COMExternalInterface current GUID		ifTrue: [^result class = GUID ifTrue: [result] ifFalse: [self coerceError]].	"Check if the result matches the C type, but do not return the coerced result to avoid side effects"	aType coerce: result.	^result</body><body package="Com- Ole">checkResult: result warnIfNotMatching: resultType	"Check the result value and rais a COMDevelopment warning if it does not match the specified result type.	 #checkResult:type: may also convert values in specific situations"	^[self checkResult: result type: resultType] on: Error		do: 			[:ex |			COMDevelopmentWarning				raiseSignal: (#ProbablyWrongResultType1p2p &lt;&lt; #com						&gt;&gt; 'The result value &lt;1p&gt; does not seem to match the specified result type &lt;2p&gt; - please check server return statement. This may be caused by a server method which does not contain a return statement.'							expandMacrosWith: result							with: resultType)]</body><body package="Com- Ole">computeVTablePointer	self allocateVTable.	self fillVTable.	^ vTablePointer</body><body package="Com- Ole">fillVTable	| entries callback |	callbacks := Array new: self size.	entries := self vTablePointer refMemberAt: #entries.	1 to: self size		do: 			[:index |			"Reuse callbacks for both appartments"			callback := self callbackAt: index.			entries at: index - 1 put: callback asPointerParameter]</body><body package="Com- Ole">objectForThisPointer: aPointer	"Retrieve the interface for object for the given pointer. Normally this is a 	 COMInterfaceImplementation subclass instance"	| staPointer interfacePointer index typedPointer localPointer |	COMThreadManager isActiveProcessAnSTAProcess		ifTrue: ["If the pointer  is an STA pointer we don't need to do any marshaling"				localPointer := aPointer]		ifFalse: 			["we need to do apartment marshaling"			interfacePointer := self temporaryInterfacePointerFor: aPointer.			staPointer := COMThreadManager marshalToSTA: interfacePointer.			localPointer := staPointer interfaceBinding interfaceAddress].	typedPointer := COMPlatformProvider current interfaceType pointerType				cast: localPointer.	index := typedPointer memberAt: #entry.	^ExportedObjectsTable objectAt: index</body><body package="Com- Ole">temporaryInterfacePointerFor: aPointer	^ self interfaceClass interfacePointerClass newUncountedInterfacePointerAtAddress: aPointer.</body><body package="Com- Ole">tryToPerform: aSelector on: thisPointer withArgumentsFrom: argsBlock resultType: resultType	"perform &lt;aSelector&gt; on the object associated with &lt;thisPointer&gt; using the given block to retrieve the arguments.	 If the receiver is invalid, return an error instead Finally check result value which was returned by the server method."	| result receiver |	receiver := self objectForThisPointer: thisPointer.	^receiver		ifNil: [self serverUnavailable]		ifNotNil: 			[result := receiver perform: aSelector withArguments: argsBlock value.			self checkResult: result warnIfNotMatching: resultType]</body><body package="Com- Ole">vTablePointer: aCOMMemoryAddress 		vTablePointer := aCOMMemoryAddress.</body></methods><methods><class-id>External.COMExternalVTable</class-id> <category>converting</category><body package="Com- Ole">asPointerParameter	"return the pointer to the first entry of the VTable"	^ self vTablePointer refMemberAt: #entries</body></methods><methods><class-id>External.COMExternalVTable</class-id> <category>releasing</category><body package="Com- Ole">invalidate	" Invalidate the address of the interface VTable in external memory. "	vTablePointer		ifNotNil: 			[vTablePointer enforceInvalidation.			vTablePointer := nil]</body><body package="Com- Ole">release	" Release the interface VTable in external memory. "	vTablePointer ifNotNil: [:pointer | pointer enforceRelease].	vTablePointer := nil.	super release</body></methods><methods><class-id>External.COMExternalVTable</class-id> <category>vtable blocks</category><body package="Com- Ole">callbackBlockFor0Args: aByteSymbol resultType: resultType	^	[:interfacePointer |	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: [Array with: interfacePointer]		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor10Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 |	| args |	args :=			[(Array new: 11)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor11Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 |	| args |	args :=			[(Array new: 12)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor12Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 |	| args |	args :=			[(Array new: 13)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor13Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 :arg13 |	| args |	args :=			[(Array new: 14)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				at: 14 put: arg13;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor14Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 :arg13 :arg14 |	| args |	args :=			[(Array new: 15)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				at: 14 put: arg13;				at: 15 put: arg14;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor15Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 :arg13 :arg14 :arg15 |	| args |	args :=			[(Array new: 16)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				at: 14 put: arg13;				at: 15 put: arg14;				at: 16 put: arg15;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor16Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 :arg13 :arg14 :arg15 :arg16 |	| args |	args :=			[(Array new: 17)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				at: 14 put: arg13;				at: 15 put: arg14;				at: 16 put: arg15;				at: 17 put: arg16;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor17Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 :arg13 :arg14 :arg15 :arg16 :arg17 |	| args |	args :=			[(Array new: 18)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				at: 14 put: arg13;				at: 15 put: arg14;				at: 16 put: arg15;				at: 17 put: arg16;				at: 18 put: arg17;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor18Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 :arg13 :arg14 :arg15 :arg16 :arg17 :arg18 |	| args |	args :=			[(Array new: 19)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				at: 14 put: arg13;				at: 15 put: arg14;				at: 16 put: arg15;				at: 17 put: arg16;				at: 18 put: arg17;				at: 19 put: arg18;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor19Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 :arg13 :arg14 :arg15 :arg16 :arg17 :arg18 :arg19 |	| args |	args :=			[(Array new: 20)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				at: 14 put: arg13;				at: 15 put: arg14;				at: 16 put: arg15;				at: 17 put: arg16;				at: 18 put: arg17;				at: 19 put: arg18;				at: 20 put: arg19;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor1Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 |	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: [Array with: interfacePointer with: arg1]		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor20Args: aByteSymbol resultType: resultType	^	[:thisPointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 :arg10 :arg11 :arg12 :arg13 :arg14 :arg15 :arg16 :arg17 :arg18 :arg19 :arg20 |	| args |	args :=			[(Array new: 21)				at: 1 put: thisPointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				at: 11 put: arg10;				at: 12 put: arg11;				at: 13 put: arg12;				at: 14 put: arg13;				at: 15 put: arg14;				at: 16 put: arg15;				at: 17 put: arg16;				at: 18 put: arg17;				at: 19 put: arg18;				at: 20 put: arg19;				at: 21 put: arg20;				yourself].	self		tryToPerform: aByteSymbol		on: thisPointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor2Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 |	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: [Array with: interfacePointer with: arg1 with: arg2]		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor3Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 |	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: 			[Array				with: interfacePointer				with: arg1				with: arg2				with: arg3]		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor4Args: aByteSymbol resultType: resultType	^	[:thisPointer :arg1 :arg2 :arg3 :arg4 |	| args |	args :=			[(Array new: 5)				at: 1 put: thisPointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				yourself].	self		tryToPerform: aByteSymbol		on: thisPointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor5Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 |	| args |	args :=			[(Array new: 6)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor6Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 |	| args |	args :=			[(Array new: 7)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor7Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 |	| args |	args :=			[(Array new: 8)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor8Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 |	| args |	args :=			[(Array new: 9)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body><body package="Com- Ole">callbackBlockFor9Args: aByteSymbol resultType: resultType	^	[:interfacePointer :arg1 :arg2 :arg3 :arg4 :arg5 :arg6 :arg7 :arg8 :arg9 |	| args |	args :=			[(Array new: 10)				at: 1 put: interfacePointer;				at: 2 put: arg1;				at: 3 put: arg2;				at: 4 put: arg3;				at: 5 put: arg4;				at: 6 put: arg5;				at: 7 put: arg6;				at: 8 put: arg7;				at: 9 put: arg8;				at: 10 put: arg9;				yourself].	self		tryToPerform: aByteSymbol		on: interfacePointer		withArgumentsFrom: args		resultType: resultType]</body></methods><methods><class-id>External.COMExternalVTable</class-id> <category>error raising</category><body package="Com- Ole">coerceError	self error: #CoercingError &lt;&lt; #com &gt;&gt; 'Coercing Error'</body><body package="Com- Ole">serverUnavailable	^ External.COMStatusCodeConstants.RPC_E_SERVER_DIED_DNE</body></methods><methods><class-id>External.COMExternalVTable class</class-id> <category>releasing</category><body package="Com- Ole">invalidateExternalVTable		" Invalidate the address of the universal VTable in external memory. "3 timesRepeat: [ Screen default ringBell ].	Tools.Note ISSUE.  " Not needed on VW s.t. there is one VTable per interface class, rather than a universal VTable per VS  [DL 09-Jan-96] "</body><body package="Com- Ole">releaseExternalVTable		" Release the universal VTable in external memory. "3 timesRepeat: [ Screen default ringBell ].	Tools.Note ISSUE.  " Needs to be reimplemented on VW s.t. there is one VTable per interface class, rather than a universal VTable per VS  [DL 09-Jan-96] "</body></methods><methods><class-id>External.COMExternalVTable class</class-id> <category>private</category><body package="Com- Ole">callbackBlockSelectorFor: aSymbol 	^(self callbackCreationTable at: aSymbol numArgs)</body><body package="Com- Ole">callbackCreationTable	^CallbackCreationTable ifNil: [self createCallbackCreationTable]</body><body package="Com- Ole">createCallbackCreationTable	^CallbackCreationTable := (Array new: 21)				at: 1 put: #callbackBlockFor0Args:resultType:;				at: 2 put: #callbackBlockFor1Args:resultType:;				at: 3 put: #callbackBlockFor2Args:resultType:;				at: 4 put: #callbackBlockFor3Args:resultType:;				at: 5 put: #callbackBlockFor4Args:resultType:;				at: 6 put: #callbackBlockFor5Args:resultType:;				at: 7 put: #callbackBlockFor6Args:resultType:;				at: 8 put: #callbackBlockFor7Args:resultType:;				at: 9 put: #callbackBlockFor8Args:resultType:;				at: 10 put: #callbackBlockFor9Args:resultType:;				at: 11 put: #callbackBlockFor10Args:resultType:;				at: 12 put: #callbackBlockFor11Args:resultType:;				at: 13 put: #callbackBlockFor12Args:resultType:;				at: 14 put: #callbackBlockFor13Args:resultType:;				at: 15 put: #callbackBlockFor14Args:resultType:;				at: 16 put: #callbackBlockFor15Args:resultType:;				at: 17 put: #callbackBlockFor16Args:resultType:;				at: 18 put: #callbackBlockFor17Args:resultType:;				at: 19 put: #callbackBlockFor18Args:resultType:;				at: 20 put: #callbackBlockFor19Args:resultType:;				at: 21 put: #callbackBlockFor20Args:resultType:;				yourself</body></methods><methods><class-id>External.COMExternalVTable class</class-id> <category>instance creation</category><body package="Com- Ole">forEntryPoints: entryPointDescriptions callbackSelectors: callbackSelectors interfaceClass: aComInterfaceImplementationClass	"Answer a new instance of the receiver which defines the		callin descriptor for an interface, according to the function		type information in the entry point descriptions &lt;entryPointDescriptions&gt;		and the callback dispatch selectors in the list &lt;callbackSelectors&gt;. "	"VS universal VTable check:	entryPointDescriptions size &gt; self externalVTableSize		ifTrue: [ self error: 'VTable callin table size exceeded' ].	"	entryPointDescriptions size = callbackSelectors size		ifFalse: 			[self error: #ErrEntrySelectorSize &lt;&lt; #com						&gt;&gt; 'entry point/selector size mismatch'].	^(self new entryPoints: entryPointDescriptions		callbackSelectors: callbackSelectors)		interfaceClass: aComInterfaceImplementationClass;		yourself</body></methods><methods><class-id>Kernel.COMDecompiler</class-id> <category>private decompiling slow calls</category><body package="Com- Ole">primitiveFailCodeFrom: block	| newSequence temps return send failBlock |	builder := ProgramNodeBuilder new.	statements := block body statements.	return := statements first.	send := return value.	failBlock := send arguments last.		temps := failBlock body temporaries.	newSequence := builder newSequenceTemporaries: temps				statements: failBlock body statements.	^builder newBlockArguments: block arguments body: newSequence</body><body package="Com- Ole">renameExternalParamVarsInBlock: block names: external	"This method is used to rename param vars in external methods which don't use a primitive. This is a little more complex	 because the parameter order of the external function may differ from the method's one"	| vars |	vars := block arguments collect: [:each | each variable ].	external argumentNames 		ifNil: [ external argumentNames: (vars collect: [:each | each name ])]		ifNotNil: [:names | vars keysAndValuesDo: [:index :var | var name: (names at: index)]].</body></methods><methods><class-id>External.IParseDisplayNameImplementation</class-id> <category>interface operations</category><body package="Com- Ole">ParseDisplayName: aBindContext 	_: aDisplayName 	_: nCharsConsumedReference 	_: resultReference		" Invoke the IParseDisplayName::ParseDisplayName function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor ParseDisplayName: aBindContext 			_: aDisplayName 			_: nCharsConsumedReference 			_: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IParseDisplayNameImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeParseDisplayName: this _: pbc _: pszDisplayName _: pchEaten _: ppmkOut	"Private - invoke the IParseDisplayName::ParseDisplayName function for an external caller. "	" HRESULT ParseDisplayName(            /* [unique][in] */ IBindCtx *pbc,            /* [in] */ LPOLESTR pszDisplayName,            /* [out] */ ULONG *pchEaten,            /* [out] */ IMoniker **ppmkOut); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult anIBindContext aDisplayName resultReference charsConsumedReference |	self reportExternalFunctionEntry.	(pbc isValid		and: [pszDisplayName isValid and: [pchEaten isValid and: [ppmkOut isValid]]])			ifFalse: [^E_INVALIDARG].	anIBindContext := self interfaceAtAddress: pbc type: IBindCtx.	aDisplayName := self stringAtAddress: pszDisplayName.	self clearScalarResultValueAtAddress: pchEaten.	self clearPointerResultValueAtAddress: ppmkOut.	resultReference := nil asValueReference.	charsConsumedReference := nil asValueReference.	hresult := implementor				ParseDisplayName: anIBindContext				_: aDisplayName				_: charsConsumedReference				_: resultReference.	hresult succeeded		ifTrue: 			[self scalarResultAtAddress: pchEaten put: charsConsumedReference value.			self interfaceResultAtAddress: ppmkOut put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body></methods><methods><class-id>External.IParseDisplayNameImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IParseDisplayName.	self vtableSignatureTypeName: #__IParseDisplayNameVtbl.	self updateAndRegister</body></methods><methods><class-id>External.COMSharedMemoryAddress class</class-id> <category>subclass-allocation</category><body package="Com- Ole">memoryAllocator		" Private - answer the COM memory allocator which is used to allocate 		memory referenced by instances of the receiver. "	^IMalloc sharedMemoryAllocator</body></methods><methods><class-id>External.COMCompoundFile</class-id> <category>accessing</category><body package="Com- Ole">directory	"Answer the Directory in which the receiver is contained."	^self pathName asFilename directory"VS implementation using explicit Directory object was:	| aDirectory |	aDirectory := Directory pathName: self pathName fileNamePath.	^aDirectory valid		ifTrue: [ aDirectory ]		ifFalse: [ nil ]"</body><body package="Com- Ole">fileName		" Answer the name of the compound document file. "	^self name "fileNameLessPath" asFilename tail</body><body package="Com- Ole">pathName		" Answer the path name of the file containing the receiver. "	^self name</body></methods><methods><class-id>External.COMCompoundFile</class-id> <category>operations</category><body package="Com- Ole">flush        "Force all data written to the receiver to be         recorded on disk."	self commit.</body><body package="Com- Ole">switchToFile: aPathName        " Make a copy of the file underlying the reciever in the file indicated by &lt;aPathName&gt;.        Associates the receiver with this new file rather than with its current file, including        uncommitted changes."    | anIRootStorage |    anIRootStorage := self queryInterface: IID_IRootStorage.    anIRootStorage switchToFile: aPathName.    self name: aPathName.</body></methods><methods><class-id>External.COMCompoundFile class</class-id> <category>creating</category><body package="Com- Ole">newFile: aFileName	" Create a new structured storage in the file system named &lt;aFileName&gt;.  Answer a new instance of the receiver on the storage object. "	^self newFile: aFileName		accessMode: (			STGM_CREATE 			"| STGM_TRANSACTED"   " note difference from default open flags, which include this option "			| STGM_READWRITE 			| STGM_SHARE_EXCLUSIVE )</body><body package="Com- Ole">newFile: aFileName accessMode: modeFlags	" Create a new structured storage in the file system named &lt;aFileName&gt; with the access mode specified by the STGM flags &lt;modeFlags&gt;.  Answer a new instance of the receiver on the storage object. "	| resultReference hresult |	resultReference := self new asValueReference.	hresult := OLEDLL current StgCreateDocfile: aFileName		_: modeFlags		_: 0 		_: resultReference.	hresult = S_OK   " STG_S_CONVERTED "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">newTemporaryBackingStore	" Create a temporary structured storage in the file system.  Answer a new instance of the receiver on the storage object. "	"Note: The flags settings are tricky: Either STGM_TRANSACTED or STGM_SHARE_EXCLUSIVE must be set or a walkback will occur. They may both be set at the same time.  STGM_TRANSACTED | STGM_SHARE_DENY_WRITE is OK."	| resultReference |	resultReference := self new asValueReference.	OLEDLL current StgCreateDocfile: nil		_: ( STGM_CREATE			| STGM_DELETEONRELEASE			" | STGM_SHARE_EXCLUSIVE"			| STGM_TRANSACTED			| STGM_READWRITE )		_: 0		_: resultReference.    ^resultReference value</body></methods><methods><class-id>External.COMCompoundFile class</class-id> <category>accessing</category><body package="Com- Ole">getClassFile: aFileName	" Answer the CLSID associated with the storage object in the file named &lt;aFileName&gt;. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current GetClassFile: aFileName 		_: resultReference.	resultReference value</body><body package="Com- Ole">setTimes: aFileName created: cTime lastAccessed: aTime lastModified: mTime	" Set the creation, access, and modification times of the storage named &lt;aFileName&gt; in the file system to the specified TimeStamp values. "	OLEDLL current StgSetTimes: aFileName		_: cTime		_: aTime		_: mTime</body></methods><methods><class-id>External.COMCompoundFile class</class-id> <category>opening</category><body package="Com- Ole">pathName: aFileName	" Open the storage in the file system named &lt;aFileName&gt;.  Answer a new instance of the receiver on the storage object. "	^self pathName: aFileName 		accessMode: (			STGM_TRANSACTED 			| STGM_READWRITE 			| STGM_SHARE_DENY_WRITE			"| STGM_SHARE_EXCLUSIVE" )  " note difference from default create flags, which include this option "</body><body package="Com- Ole">pathName: aFileName accessMode: modeFlags	" Open the storage in the file system named &lt;aFileName&gt; with the access mode specified by the STGM flags &lt;modeFlags&gt;.  Answer a new instance of the receiver on the storage object. "	| resultReference |	resultReference := self new asValueReference.	OLEDLL current StgOpenStorage: aFileName		_: nil 		_: modeFlags 		_: nil 		_: 0 		_: resultReference.	^resultReference value</body><body package="Com- Ole">pathNameReadOnly: aFileName	" Open the storage in the file system named &lt;aFileName&gt; in readOnly access mode.  Answer a new instance of the receiver on the storage object. "	^self pathName: aFileName 		accessMode: ( STGM_READ | STGM_SHARE_DENY_WRITE )</body></methods><methods><class-id>External.COMCompoundFile class</class-id> <category>subclass-registration</category><body package="Com- Ole">registerIID	" Private - register the receiver as the interface class for its IID.  Do nothing for the receiver - its superclass IStorage is correctly registered as the class for the (shared) IID. "</body><body package="Com- Ole">removeIID	" Private - remove the registration of the receiver as the interface class for its IID.  Do nothing for the receiver - its superclass IStorage manages the registration for the (shared) IID. "</body></methods><methods><class-id>External.COMCompoundFile class</class-id> <category>testing</category><body package="Com- Ole">isStorageFile: aPathName	" Answer whether the file named &lt;aPathName&gt; is a storage object. "	^[ ( OLEDLL current StgIsStorageFile: aPathName ) = S_OK ]		on: COMError		do: [ :ex | 			ex hresult = STG_E_FILENOTFOUND				ifTrue: [ ^false ].			ex pass ].</body></methods><methods><class-id>External.COMCompoundFile class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IStorage.	self updateAndRegister</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>private-initialization</category><body package="Com- Ole">constructIDataObject	" Private - Answer a newly created IDataObject interface for the receiver. "	| anIDataObject |	anIDataObject := IDataObject adaptorBindingOn: self.	anIDataObject functionAdaptor		installMinimumDispatchHandlers;		when: #DAdvise			"send: #DAdvise:_:_:_: to: self;"			"VSE was: evaluate: [ ^OLE_E_ADVISENOTSUPPORTED ];"			evaluate: [ :aFormatEtc :advf :anAdviseSink :resultReference |				" DAdvise: aFormatEtc _: advf _: anAdviseSink _: resultReference "					" Create an advise connnection between the data transfer object					and an advise sink which is informated when the object's 					data changes.  Answer the result code. "				OLE_E_ADVISENOTSUPPORTED ];		when: #EnumFormatEtc			send: #EnumFormatEtc:_: to: self;		when: #GetData			send: #GetData:_: to: self;		when: #GetDataHere			send: #GetDataHere:_: to: self;		when: #QueryGetData			send: #QueryGetData: to: self;		when: #SetData			send: #SetData:_:_: to: self;		when: #DAdvise			send: #DAdvise:_:_:_: to: self;		when: #DUnadvise			send: #DUnadvise: to: self;		when: #EnumDAdvise			send: #EnumDAdvise: to: self;		yourself.	^anIDataObject</body><body package="Com- Ole">createFormatEtcs        "Private - create a collection of FORMATETCs from the supported formats."    ^formats collect: [ :rendering | rendering formatEtc deepCopy ]</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>subclass-operation</category><body package="Com- Ole">createRendering: aValue format: aFormatName	" Private - Create a rendering object to represent the data &lt;aValue&gt; in the data transfer format specified by &lt;aFormatName&gt;. "	| aFormatEtc |	aFormatEtc := ( COMStructure classForStructureNamed: #FORMATETC )		formatNamed: aFormatName.	^self dataRenderingClass for: aValue formatEtc: aFormatEtc</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>private-IDataObject operations</category><body package="Com- Ole">DAdvise: aFormatEtc _: advf _: anAdviseSink _: resultReference		" Private - implement the IDataObject::DAdvise function.		Create a connection between the data transfer object and an         advisory sink through which the sink can be informed when the         object's data changes.		Answer the result code. "	resultReference value: (self addAdvise: aFormatEtc flags: advf sink: anAdviseSink).	^ S_OK</body><body package="Com- Ole">DUnadvise: dwConnection		self advises removeKey: dwConnection ifAbsent: [ ^ OLE_E_NOCONNECTION ].	^ S_OK</body><body package="Com- Ole">EnumDAdvise: aValueReference 		aValueReference value: (COMStructureEnumerator forIID: IID_IEnumSTATDATA elements: self statData) enumeratorInterface.	^ S_OK</body><body package="Com- Ole">EnumFormatEtc: dwDirection _: resultReference        " Private - implement the IDataObject::EnumFormatEtc function.        Create an enumerator to enumerate the formats supported by the receiver.        Answer the result code. "    | anEnumerator |    dwDirection = DATADIR_SET        ifTrue: [ ^E_NOTIMPL ].    anEnumerator := COMStructureEnumerator forIID: IID_IEnumFORMATETC		elements: self createFormatEtcs.    resultReference value:        ( anEnumerator queryInterface: anEnumerator enumeratorIID ).    ^S_OK</body><body package="Com- Ole">GetData: aFormatEtc _: resultReference        " Private - implement the IDataObject::GetData function.        Retrieve data in specified format using a specified storage medium.        The data object allocates the storage medium and stores it into &lt;resultReference&gt;.        The caller is responsible for releasing the storage.        Answer the result code. "    | aRendering stgMedium |    aRendering := self renderingForFormat: aFormatEtc.    aRendering isNil         ifTrue: [ ^DATA_E_FORMATETC ].    stgMedium := COMStructure createStructureNamed: #STGMEDIUM.    aRendering renderValueOntoMedium: stgMedium.    resultReference value: stgMedium.    ^S_OK</body><body package="Com- Ole">GetDataHere: aFormatEtc _: aStgMedium        " Private - implement the IDataObject::GetDataHere function.        Retrieve data in specified format using a specified storage medium.        The caller provides the storage medium &lt;aStgMedium&gt;.        Answer the result code. "    | aRendering |    aFormatEtc tymed = TYMED_ISTORAGE        ifFalse: [ ^DATA_E_FORMATETC ].    aRendering := self renderingForFormat: aFormatEtc.    aRendering isNil         ifTrue: [ ^DATA_E_FORMATETC ].    " store the data into the caller's storage medium "     aRendering renderValueOntoMedium: aStgMedium.    ^S_OK</body><body package="Com- Ole">QueryGetData: aFormatEtc		" Private - implement the IDataObject::QueryGetData function.		Determine whether a call to IDataObject::GetData would succeed		if it were passed &lt;aFormatEtc&gt; as the requested data format.		Answer the result code. "	^( self renderingForFormat: aFormatEtc ) isNil		ifTrue: [ DATA_E_FORMATETC ]		ifFalse: [ S_OK ]</body><body package="Com- Ole">SetData: aFormatEtc _: aStgMedium _: release	| formatName aSelector theData |	formatName := COMDataRendering getFormatName: (aFormatEtc memberAt: #cfFormat).	formatName ifNil: [^ E_FAIL ].	aSelector := IDataObject getRenderingOperationFor: formatName.	aSelector isNil		ifTrue: 			[^COMError				raiseSignal: (#ErrNamedUnsuppFormat &lt;&lt; #com						&gt;&gt; 'unsupported data format: &lt;1s&gt;' expandMacrosWith: formatName)].	theData := iDataObject				perform: aSelector				with: aFormatEtc				with: aStgMedium.	self addRendering: theData format: formatName.	release ifTrue: [		aStgMedium enforceRelease. ].	^S_OK</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>subclass-accessing</category><body package="Com- Ole">allocatedInterfacesDo: aOneArgBlock		" Private - enumerate the interfaces supported by the receiver		which have been allocated during its lifetime and		evaluate &lt;aOneArgBlock&gt; with each. "	super allocatedInterfacesDo: aOneArgBlock.	iDataObject notNil		ifTrue: [ aOneArgBlock value: iDataObject ].</body><body package="Com- Ole">dataRenderingClass	" Private - answer the rendering descriptor class used by the receiver. "	^COMDataRendering</body><body package="Com- Ole">getInterfaceForIID: iid        " Private - answer the interface identified by the GUID &lt;iid&gt;.        Answer nil if the requested interface is not supported by the receiver. "    iid = IID_IDataObject        ifTrue: [ ^iDataObject ].    ^nil</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>testing</category><body package="Com- Ole">isClipboardObject	" Answer whether the receiver is on the system clipboard. "	^iDataObject notNil and: [ iDataObject isClipboardObject ]</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>private-accessing</category><body package="Com- Ole">addAdvise: aFormatEtc flags: advf sink: anAdviseSink	| newKey adviseInfo |	newKey := (self advises inject: 0 into: [:max :each | max max: each key]) + 1.	adviseInfo := AdviseInfo				formatEtc: aFormatEtc				flags: advf				sink: anAdviseSink				key: newKey.	advises at: newKey put: adviseInfo.	adviseInfo triggerOnInstallation		ifTrue: [self triggerAdviseEventFor: adviseInfo forceData: nil].	^newKey</body><body package="Com- Ole">advises	^advises ifNil: [advises := Dictionary new]</body><body package="Com- Ole">renderingForFormat: aFormatEtc		" Private - answer the rendering corresponding to &lt;aFormatEtc&gt;.		Answer nil if the format is not supported. "	formats do: [ :aRendering |		( aRendering sameFormatEtc: aFormatEtc ) 			ifTrue: [ ^aRendering ] ].	^nil</body><body package="Com- Ole">statData	^self advises collect: [:info | info asStatData ]</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>subclass-initializing</category><body package="Com- Ole">initialize        "Private - initialize the receiver."    super initialize.    formats := OrderedCollection new.</body><body package="Com- Ole">initializeInterfaces        " Private - Allocate any interfaces which are expected to be required        during the object's lifetime. "    super initializeInterfaces.    iDataObject := self constructIDataObject.</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>subclass-releasing</category><body package="Com- Ole">forceRelease	" Private - attempt to forcibly release the receiver.  Answer whether successful.  This is a dangerous thing to do and is primarily a developer debugging facility. "	" remove the receiver from the clipboard if it is the current data transfer source "	self isClipboardObject		ifTrue: [ 			( MessageBox confirm: ((#x1sMustBeRemovedBeforeReleased &lt;&lt; #com &gt;&gt; '&lt;1s&gt; must be removed from the system clipboard before it can be released.  Proceed?')					expandMacrosWith: self printString) asString )				ifFalse: [ ^false ].			IDataObject clearClipboard.			self isClipboardObject				ifTrue: [					MessageBox warning: ((#UnableToClearClipboard &lt;&lt; #com &gt;&gt; 'Unable to clear &lt;1s&gt; from the system clipboard - release attempt failed.')							expandMacrosWith: self printString) asString.					^false ].			].	^super forceRelease</body><body package="Com- Ole">releaseAdvises	self advises do: 			[:adviseInfo |			adviseInfo triggerBeforeDemise				ifTrue: [self basicTriggerAdviseEventFor: adviseInfo forceData: true].			adviseInfo sink isValid ifTrue: [adviseInfo sink onClose].			adviseInfo enforceRelease].	advises := nil.</body><body package="Com- Ole">releaseInnerObjects	" Private - release any inner objects owned by the receiver.  Should be reimplemented by subclasses which are controlling objects of an aggregate or which use containment to implement their services. "	super releaseInnerObjects.</body><body package="Com- Ole">releaseResources	" Private - release resources associated with the receiver. "	formats do: [ :aRendering | aRendering release ].	self releaseAdvises. 	super releaseResources.</body><body package="Com- Ole">resetAllocatedInterfaces		" Private - reset the references to the interfaces supported by the receiver. "	super resetAllocatedInterfaces.	iDataObject := nil.</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>operation</category><body package="Com- Ole">addRendering: aValue format: aFormatName	" Add a data rendering for &lt;aValue&gt; in the in the data transfer format specified by &lt;aFormatName&gt; to the receiver. "	| aRendering |	aRendering := self createRendering: aValue format: aFormatName.	formats add: aRendering.	self checkAdviseNotificationsFor: aRendering.</body><body package="Com- Ole">copyToClipboard        " Copy the receiver to the system clipboard. "    | anIDataObject |    anIDataObject := self queryInterface: IID_IDataObject.    anIDataObject copyToClipboard.</body></methods><methods><class-id>External.COMDataTransferObject</class-id> <category>private-Advise support</category><body package="Com- Ole">basicTriggerAdviseEventFor: anAdviseInfo forceData: forceData	| aRendering stgMedium |	(forceData not and: [anAdviseInfo provideNoData])		ifTrue: 			[^anAdviseInfo sink onDataChange: anAdviseInfo formatEtc storageMedium: nil].	aRendering := self renderingForFormat: anAdviseInfo formatEtc.	aRendering isNil		ifTrue: 			[^anAdviseInfo sink onDataChange: anAdviseInfo formatEtc storageMedium: nil].	stgMedium := COMStructure createStructureNamed: #STGMEDIUM.	aRendering renderValueOntoMedium: stgMedium.	anAdviseInfo sink onDataChange: anAdviseInfo formatEtc		storageMedium: stgMedium</body><body package="Com- Ole">checkAdviseNotificationsFor: aRendering	self advises do: 			[:each |			(each formatEtc sameFormatAs: aRendering formatEtc)				ifTrue: [self triggerAdviseEventFor: each forceData: false]]</body><body package="Com- Ole">triggerAdviseEventFor: anAdviseInfo forceData: forceData	self basicTriggerAdviseEventFor: anAdviseInfo forceData: forceData.	anAdviseInfo triggerOnlyOnce		ifTrue: [[self DUnadvise: anAdviseInfo key] fork]</body></methods><methods><class-id>External.COMStructureEnumerator</class-id> <category>subclass-operation</category><body package="Com- Ole">packCurrentElementInto: lpStruct	" Private - pack the element at the current index into the receiver into the element buffer at &lt;lpStruct&gt;.  Answer whether successful. "	| anElement copy |	anElement := self elements at: currentIndex.	anElement isNil ifTrue: [^false].	" perhaps somewhat obstinate, but hey, it's really a bug in the guy who constructed me "	copy := anElement asSeparateStructureParameter.	[lpStruct contents: copy] ensure: [copy enforceInvalidation].	^true</body></methods><methods><class-id>External.COMStructureEnumerator class</class-id> <category>subclass-instance creation</category><body package="Com- Ole">bufferElementTypeForIID: anIID	" Private "	"??^COMStructure typeNamed: ??"</body><body package="Com- Ole">checkElementValidity: elements	" Private - verify that the collection is a collection of valid elements, per COM enumeration model. "	| structTypes |	super checkElementValidity: elements.	structTypes := elements collect: [ :aStructure | COMStructure getFundamentalTypeOf: aStructure type ].	structTypes asSet size &gt; 1		ifTrue: [ COMError raiseSignal: #ErrUnlikeEnumItems &lt;&lt; #com &gt;&gt; 'enumeration elements must be homogeneous' ].	"... and check that the enumerated elements are what are expected by this enumerator ..."</body><body package="Com- Ole">getIIDForElement: anElement	" Private - answer the IID of the enumerator interface for a homogeneous collection of elements represented by &lt;anElement&gt;. "	| aType |	aType := COMStructure getFundamentalTypeOf: anElement type.	^IEnum enumeratorIIDFor: ( COMStructure registeredStructureNameOf: aType name )</body></methods><methods><class-id>External.COMStructureEnumerator class</class-id> <category>instance creation</category><body package="Com- Ole">forIID: anIID elements: anOrderedCollection	" Answer a new instance of the receiver which enumerates the homogeneous collection of interfaces or data structures specified by &lt;anIID&gt;. "	| aStructureSpecification aStructureType |	aStructureSpecification := IEnum elementTypeOfIID: anIID.	aStructureSpecification isNil		ifTrue: [ COMError raiseSignal: (#ErrNamedUnknownEnum &lt;&lt; #com &gt;&gt; 'unknown enumerator interface: &lt;1s&gt;' expandMacrosWith: (#nil &lt;&lt; #com &gt;&gt; 'nil')) ].	aStructureType := ( aStructureSpecification isSymbol		ifTrue: [ COMStructure typeNamed: aStructureSpecification ]		ifFalse: [ aStructureSpecification baseCType ] ).	"Assert isTrue: [ aStructureType isComposite ]."	^self forIID: anIID 		elements: anOrderedCollection		bufferElementType: aStructureType</body></methods><methods><class-id>External.COMEntryPointDescription</class-id> <category>accessing</category><body package="Com- Ole">argumentNames        "Answer the argument names of the entry point described by the receiver."	^self signatureType argumentNames</body><body package="Com- Ole">argumentTypes        "Answer the argument types of the entry point described by the receiver."	^self signatureType argumentTypes</body><body package="Com- Ole">name	"Answer the name of the entry point described by the receiver."	^name</body><body package="Com- Ole">name: aString	"Set the name of the entry point described by the receiver to &lt;aString&gt;."	name := aString.</body><body package="Com- Ole">numberOfArguments	" Answer the number of arguments used to invoke this function. "	^self signatureType numArgs</body><body package="Com- Ole">resultType        "Answer the result type of the entry point described by the receiver."	^self signatureType resultType</body><body package="Com- Ole">selector	"Answer the message selector which is sent to invoke the entry point described by the receiver."	^selector</body><body package="Com- Ole">selector: aSymbol	"Specify the message selector which is sent to invoke the entry point described by the receiver."	selector := aSymbol.</body><body package="Com- Ole">signatureType	"Answer the procedure type which defines the signature of the entry point described by the receiver."	^signatureType</body><body package="Com- Ole">signatureType: aProcedureType	"Set the procedure type which defines the signature of the entry point described by the receiver."	signatureType := aProcedureType.</body><body package="Com- Ole">vtableIndex	" Answer the VTable index of the entry point described by the receiver. "	^vtableIndex</body><body package="Com- Ole">vtableIndex: anInteger	" Set the VTable index of the entry point described by the receiver to &lt;anInteger&gt;. "	vtableIndex := anInteger.</body></methods><methods><class-id>External.COMEntryPointDescription</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream		"Append a string representation of the receiver to &lt;aStream&gt;."	name isNil		ifTrue: [ ^super printOn: aStream ].	aStream 		nextPutAll: self selector printString;		nextPutAll: ' =&gt; '.	self signatureType printOn: aStream forName: name.	aStream  nextPutAll: ' = ', self vtableIndex printString.</body></methods><methods><class-id>External.COMEntryPointDescription class</class-id> <category>instance creation</category><body package="Com- Ole">name: aString type: aProcedureType  vtableIndex: vtableIndex 	"Answer a new instance of the receiver describing the entry point as specified"	^self new		name: aString;		signatureType: aProcedureType;		vtableIndex: vtableIndex</body><body package="Com- Ole">name: aString type: aProcedureType  vtableIndex: vtableIndex selector: aSymbol	"Answer a new instance of the receiver describing the entry point as specified"	^self new		name: aString;		signatureType: aProcedureType;		vtableIndex: vtableIndex;		selector: aSymbol</body></methods><methods><class-id>External.IRunnableObjectPointer</class-id> <category>interface operations</category><body package="Com- Ole">GetRunningClass: lpClsid	" Invoke the IRunnableObject::GetRunningClass function. ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^self invokeGetRunningClass: lpClsid</body><body package="Com- Ole">IsRunning	" Invoke the IRunnableObject::IsRunning function. "	^self invokeIsRunning</body><body package="Com- Ole">LockRunning: fLock _: fLastUnlockCloses	" Invoke the IRunnableObject::LockRunning function. "	^self invokeLockRunning: fLock _: fLastUnlockCloses</body><body package="Com- Ole">Run: pbc	" Invoke the IRunnableObject::Run function. ""**** NOTE: Automatically generated method, requires manual review of argument marshalling logic ****"	^self invokeRun: pbc asPointerParameter</body><body package="Com- Ole">SetContainedObject: fContained	" Invoke the IRunnableObject::SetContainedObject function. "	^self invokeSetContainedObject: fContained</body></methods><methods><class-id>External.IRunnableObjectPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IRunnableObject.	self updateAndRegister</body></methods><methods><class-id>External.IParseDisplayName</class-id> <category>interface operations</category><body package="Com- Ole">parseDisplayName: aDisplayName        " Parse the object display name &lt;aDisplayName&gt; into a moniker to the object.        Answer the moniker. "    | resultReference |    resultReference := IMoniker new asValueReference.    interface ParseDisplayName: nil        _: aDisplayName        _: nil asValueReference        _: resultReference.    ^resultReference value</body><body package="Com- Ole">parseDisplayName: aDisplayName bindContext: aBindContext        " Parse the object display name &lt;aDisplayName&gt; into a moniker to the object.        &lt;aBindContext&gt; is the bind context to be used to accumulate bound objects.        Answer the moniker. "    | resultReference |    resultReference := IMoniker new asValueReference.    interface ParseDisplayName: aBindContext        _: aDisplayName        _: nil asValueReference        _: resultReference.    ^resultReference value</body><body package="Com- Ole">parseDisplayName: aDisplayName	bindContext: aBindContext 	charsConsumedReference: charsConsumedReference        " Parse the object display name &lt;aDisplayName&gt; into a moniker to the object.        &lt;aBindContext&gt; points to the bind context to be used to accumulate bound objects.        &lt;charsConsumedReference&gt; points to the number of characters parsed         from the display name.  Answer the moniker. "    | resultReference |    resultReference := IMoniker new asValueReference.    interface ParseDisplayName: aBindContext        _: aDisplayName        _: charsConsumedReference        _: resultReference.    ^resultReference value</body></methods><methods><class-id>External.IParseDisplayName class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IParseDisplayName.	self updateAndRegister</body></methods><methods><class-id>External.COMCOSERVERINFOBuffer</class-id> <category>subclass-accessing</category><body package="Com- Ole">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^COMExternalInterface current COSERVERINFO</body></methods><methods><class-id>External.COMCOSERVERINFOBuffer</class-id> <category>subclass-initializing</category><body package="Com- Ole">initializeBuffer	" Private - initialize the contents of the argument buffer with the server name. "	| lpServerName |	lpServerName := self value copyToHeapUnicode.	buffer memberAt: #pwszName put: lpServerName. 	" zero-initialization semantics of our buffer means we don't have to worry about clearing fields "	"Assert isTrue: [( buffer memberAt: #dwReserved1 ) = 0 ]."    "Reserved for future use. Must be 0."	"Assert isTrue: [ ( buffer memberAt: #pAuthInfo ) = 0 ]."	"Assert isTrue: [ ( buffer memberAt: #dwReserved2 ) =  0 ]. " "Reserved for future use. Must be 0."</body></methods><methods><class-id>External.COMCOSERVERINFOBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Ole">releaseBufferContents	" Private - release the contents of the buffer if necessary. "	| lpServerName |	( lpServerName := buffer memberAt: #pwszName ) isNull not		ifTrue: [ lpServerName free ].  " we allocated this from our heap "</body></methods><methods><class-id>External.IEnumImplementation</class-id> <category>private-invocation</category><body package="Com- Ole">invokeClone: this _: ppenum	"Private - invoke the IEnum::Clone function for an external caller. "	" HRESULT Clone(            /* [out] */ IEnum **ppenum); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	ppenum isValid ifFalse: [^E_INVALIDARG].	self clearPointerResultValueAtAddress: ppenum.	resultReference := nil asValueReference.	hresult := implementor Clone: resultReference.	hresult succeeded		ifTrue: [self interfaceResultAtAddress: ppenum put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeNext: this _: celt _: rgelt _: pceltFetched	"Private - invoke the IEnum::Next function for an external caller. "	" HRESULT Next(            /* [in] */ ULONG celt,            /* [out] */ void *rgelt,            /* [out] */ ULONG *pceltFetched); "	^	[" terminate exception stack unwind at external callin boundary "	| hresult resultReference |	self reportExternalFunctionEntry.	rgelt isValid ifFalse: [^E_INVALIDARG].	" Note that pceltFetched may be NULL if celt is one. "	pceltFetched isValid		ifTrue: [self clearScalarResultValueAtAddress: pceltFetched]		ifFalse: [celt &gt; 1 ifTrue: [^E_INVALIDARG]].	resultReference := nil asValueReference.	hresult := implementor Next: celt _: rgelt _: resultReference.	" note that we let the raw, untyped element buffer pointer through at this point "	(hresult succeeded and: [pceltFetched isValid])		ifTrue: [self scalarResultAtAddress: pceltFetched put: resultReference value].	hresult]			on: self rootExceptions			do: (self exceptionHandlerForHRESULTReturnValue: #externalCallin)</body><body package="Com- Ole">invokeReset: this		"Private - invoke the IEnum::Reset function for an external caller. "	" HRESULT Reset( void); "	^[   " terminate exception stack unwind at external callin boundary "	implementor Reset	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body><body package="Com- Ole">invokeSkip: this _: celt		"Private - invoke the IEnum::Skip function for an external caller. "	" HRESULT Skip(            /* [in] */ ULONG celt);"	^[   " terminate exception stack unwind at external callin boundary "	implementor Skip: celt	] on: self rootExceptions   		do: ( self exceptionHandlerForHRESULTReturnValue: #externalCallin )</body></methods><methods><class-id>External.IEnumImplementation</class-id> <category>interface operations</category><body package="Com- Ole">Clone: resultReference		" Invoke the IEnum::Clone function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Clone: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Next: cElements _: elementBuffer _: resultReference		" Invoke the IEnum::Next function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Next: cElements _: elementBuffer _: resultReference		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Reset		" Invoke the IEnum::Reset function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Reset		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body><body package="Com- Ole">Skip: cElements		" Invoke the IEnum::Skip function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult |	hresult := [  " terminate exception stack unwind at function invocation boundary "		implementor Skip: cElements		] on: self rootExceptions   			do: ( self exceptionHandlerForHRESULTReturnValue: #internalCallin ).	self checkHresult: hresult.	^hresult</body></methods><methods><class-id>External.IEnumImplementation</class-id> <category>identity</category><body package="Com- Ole">iid	"Answer the interface ID GUID which uniquely identifies the receiver. "	^iid</body><body package="Com- Ole">iid: anIID	" Set the the interface ID which uniquely identifies the receiver to the GUID &lt;anIID&gt;. "	"Assert isTrue: [ self iid isNil or: [ self iid = anIID ] ]."	iid := anIID.</body></methods><methods><class-id>External.IEnumImplementation class</class-id> <category>identity</category><body package="Com- Ole">supportsIID: aGUID	" Answer whether the receiver represents the interface identified by the IID &lt;anIID&gt;. "	^( super supportsIID: aGUID )		or: [ IEnum supportsEnumeratorIID: aGUID ]</body></methods><methods><class-id>External.IEnumImplementation class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IEnum.	"A special generic enumerator IID is used for internal			identification of the Smalltalk enumerator interface class. "	self vtableSignatureTypeName: #__IEnumVtbl.	" all the enumerators share 		the same basic signature, if you ignore the element type, so this is		an untyped form of the IEnumXXX family of typed VTable's "	self updateAndRegister</body></methods><methods><class-id>External.COMCallOutError</class-id> <category>private-defaults</category><body package="Com- Ole">defaultAction	ImageConfiguration errorNotifierClass notify: self context: thisContext sender</body></methods><methods><class-id>External.COMCallOutError</class-id> <category>private-accessing</category><body package="Com- Ole">ensureMessageTextInstalled	" Private - ensure that the receiver has some suitable message. "	messageText == nil		ifTrue: 			[self messageText: (#comCallOut &lt;&lt; #com &gt;&gt; 'COM Call Out:') asString , ' '						, self hresult description]</body></methods><methods><class-id>External.COMInterfaceEnumerator</class-id> <category>subclass-accessing</category><body package="Com- Ole">elements: aCollection	" Set the collection of elements being enumerated to &lt;aCollection&gt;. "	aCollection isNil		ifTrue: [ 			elements := nil.			^self ].	" we need to ensure that we have stable references to the interfaces we're enumerating "	super elements: ( aCollection collect: [ :anElement |		anElement ] ).</body></methods><methods><class-id>External.COMInterfaceEnumerator</class-id> <category>subclass-releasing</category><body package="Com- Ole">releaseResources	" Private - release resources associated with the receiver. "	self elements: nil.	super releaseResources.</body></methods><methods><class-id>External.COMInterfaceEnumerator</class-id> <category>subclass-operation</category><body package="Com- Ole">packCurrentElementInto: lpInterfacePointer	" Private - pack the element at the current index into the receiver into the element buffer at &lt;lpInterface&gt;.  Answer whether successful. "	| anElement |	anElement := self elements at: currentIndex.	anElement isNil		ifTrue: [ ^false ].  " perhaps somewhat obstinate, but hey, it's really a bug in the guy who constructed me "	" under the COM reference counting rules, whenever I return an interface to a caller		I have to give them a separately reference counting copy that they own.		While ordinarily we do a #separateReference on a return value, in this		case we can optimize to avoid the copy because we know that we're		hammering the bits into a raw buffer from which the caller has to		reconstruct the value. "	anElement enforceAddRef.	lpInterfacePointer contents: anElement asPointerParameter.	^true</body></methods><methods><class-id>External.COMInterfaceEnumerator class</class-id> <category>instance creation</category><body package="Com- Ole">forIID: anIID elements: anOrderedCollection	" Answer a new instance of the receiver which enumerates a collection of strings. "	^self forIID: anIID		elements: anOrderedCollection		bufferElementType: COMInterfacePointer baseCType		yourself</body></methods><methods><class-id>External.COMInterfaceEnumerator class</class-id> <category>subclass-instance creation</category><body package="Com- Ole">checkElementValidity: elements	" Private - verify that the collection is a collection of valid elements, per COM enumeration model. "	| iids |	elements do: [ :anElement |		anElement isCOMInterface			ifFalse: [ COMError raiseSignal: #ErrCollectionOfInterfaces &lt;&lt; #com &gt;&gt; 'collection must contain interfaces' ] ].	iids := elements collect: [ :anInterface | anInterface iid ].	iids asSet size &gt; 1		ifTrue: [ COMError raiseSignal: #ErrUnlikeEnumItems &lt;&lt; #com &gt;&gt; 'enumeration elements must be homogeneous' ].	"... and check that the enumerated elements are what are expected by this enumerator ..."</body><body package="Com- Ole">getIIDForElement: anElement	" Private - answer the IID of the enumerator interface for a homogeneous collection of elements represented by &lt;anElement&gt;. "	^IEnum enumeratorIIDFor: anElement class</body></methods><methods><class-id>External.GITCookie</class-id> <category>accessing</category><body package="Com- Ole">handle	^handle</body><body package="Com- Ole">handle: anObject	handle := anObject</body><body package="Com- Ole">iid	^iid</body><body package="Com- Ole">iid: anObject	iid := anObject</body></methods><methods><class-id>External.GITCookie class</class-id> <category>instance creation</category><body package="Com- Ole">iid: anIID handle: aHandle	^(self new)		iid: anIID;		handle: aHandle;		yourself</body></methods><methods><class-id>External.GUIDPointerResultBuffer</class-id> <category>subclass-accessing</category><body package="Com- Ole">bufferElementType	^ GUID baseCType pointerType</body></methods><methods><class-id>External.GUIDPointerResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Ole">getResultValue	^ GUID fromPointer: self buffer contents</body></methods><methods><class-id>External.GUIDPointerResultBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Ole">releaseBufferContents	"GUIDs are tranferred in external memory. Since the returned GUID instance does not reference the memory,	 we need to make sure the memory used for transferring it is released"	| pointer |	self buffer isValid ifFalse: [^self].	pointer := self buffer contents.	pointer isValid ifTrue: [pointer free]</body></methods><methods><class-id>External.IDataAdviseHolderPointer</class-id> <category>interface operations</category><body package="Com- Ole">Advise: aDataObject _: aFormatEtc _: advfFlags _: anAdviseSink _: resultReference		" Invoke the IDataAdviseHolder::Advise function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := Win32ExternalInterface scalarResultBufferFor: #DWORD.	hresult := self invokeAdvise: aDataObject asPointerParameter		_: aFormatEtc asPointerParameter		_: advfFlags		_: anAdviseSink asPointerParameter 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">EnumAdvise: resultReference		" Invoke the IDataAdviseHolder::EnumAdvise function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumSTATDATA.	hresult := self invokeEnumAdvise: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">SendOnDataChange: anIDataObject  _: dwReserved _: advfFlags		" Invoke the IDataAdviseHolder::Advise function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSendOnDataChange: anIDataObject asPointerParameter 		_: dwReserved		_: advfFlags</body></methods><methods><class-id>External.IDataAdviseHolderPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IDataAdviseHolder.	self updateAndRegister</body></methods><methods><class-id>External.IPersistStreamInitPointer</class-id> <category>interface operations</category><body package="Com- Ole">GetSizeMax: resultReference		" Invoke the IPersistStreamInit::GetSizeMax function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := Win32LargeInteger forUnsignedReturnValue.	hresult := self invokeGetSizeMax: resultBuffer asPointerParameter.	resultReference value: resultBuffer asUnsignedInteger.	^hresult</body><body package="Com- Ole">Load: anIStream		" Invoke the IPersistStreamInit::Load function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeLoad: anIStream asPointerParameter</body><body package="Com- Ole">Save: anIStream _: fClearDirty		" Invoke the IPersistStreamInit::Save function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSave: anIStream asPointerParameter 		_: fClearDirty</body></methods><methods><class-id>External.IPersistStreamInitPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistStreamInit.	self updateAndRegister</body></methods><methods><class-id>External.COM_STGMEDIUM</class-id> <category>printing</category><body package="Com- Ole">mediumDescription        " Answer a string description of the transfer medium. "	^self class mediumDescriptionOf: ( self memberAt: #tymed )</body><body package="Com- Ole">printOn: aStream        "Append the ASCII representation of the receiver         to aStream. "	super printOn: aStream.	self isValid		ifFalse: [ ^self ].	aStream 		nextPutAll: ' ( '; 		nextPutAll: self mediumDescription;		nextPutAll: ' )'.</body></methods><methods><class-id>External.COM_STGMEDIUM</class-id> <category>accessing</category><body package="Com- Ole">hGlobal        "Answer the receiver's global handle."	| hGlobal |	hGlobal := self unionMemberAt: #'u.hGlobal'.	hGlobal isNull		ifTrue: [ ^nil ].	^hGlobal</body><body package="Com- Ole">hGlobal: anAddress        "Set the receiver's global handle."	self unionMemberAt: #'u.hGlobal' put: anAddress asHandleParameter.</body><body package="Com- Ole">hImage: anImage	"Set the receiver's image handle (hBitmap, hMetaFilePict, hEnhMetaFile) ."	self unionMemberAt: #'u.hBitmap' put: anImage asHandleParameter.</body><body package="Com- Ole">lpFileName        "Answer the file path name field."	| lpszFileName |	lpszFileName := self unionMemberAt: #'u.lpszFileName'.	^COMExternalInterface stringFromUnicodePointer: lpszFileName</body><body package="Com- Ole">lpFileName: aFilePathName        "Set the receiver's file path name field to &lt;aFilePathName&gt;."	| anAddress |	anAddress := COMMemoryAddress copyUnicodeToExternalMemory: aFilePathName.	self unionMemberAt: #'u.lpszFileName' put: anAddress asPointerParameter.	Tools.Note ISSUE.  " Added the following so that we don't deallocate the string		out from underneath the structure.  Right?? 		But shoudn't we keep track of this and handle		suitably in the structure release logic???? [DL 22-Aug-96] "	anAddress enforceInvalidation.</body><body package="Com- Ole">pUnkForRelease	" Answer the IUnknown interface point to use to release the medium. "	iUnknown isNil		ifTrue: [ iUnknown := super interfaceMemberAt: #pUnkForRelease type: IUnknown ].	^iUnknown</body><body package="Com- Ole">pUnkForRelease: anInterfacePointer	" Specify the IUnknown interface point to use to release the medium. "	( anInterfacePointer notNil and: [ iUnknown notNil ] )		ifTrue: [ self error: #ErrContentsNotReleased &lt;&lt; #com &gt;&gt; 'previous contents not released' ].	super interfaceMemberAt: #pUnkForRelease put: anInterfacePointer.	iUnknown := anInterfacePointer.</body><body package="Com- Ole">pstg	"Answer the IStorage in the storage field."	backingStoreInterface isNil		ifTrue: [			backingStoreInterface := self interfaceMemberAt: #pstg				type: IStorage ].	^backingStoreInterface</body><body package="Com- Ole">pstg: anIStorage        "Set the storage field to &lt;anIStorage&gt;."    ( anIStorage notNil and: [ backingStoreInterface notNil ] )        ifTrue: [ self error: #ErrContentsNotReleased &lt;&lt; #com &gt;&gt; 'previous contents not released' ].    self interfaceMemberAt: #pstg put: anIStorage.    backingStoreInterface := anIStorage.</body><body package="Com- Ole">pstm	"Answer the IStream in the storage field."	backingStoreInterface isNil		ifTrue: [			backingStoreInterface := self interfaceMemberAt: #pstm				type: IStream ].	^backingStoreInterface</body><body package="Com- Ole">pstm: anIStream        "Set the storage field to &lt;anIStream&gt;."    ( anIStream notNil and: [ backingStoreInterface notNil ] )        ifTrue: [ self error: #ErrContentsNotReleased &lt;&lt; #com &gt;&gt; 'previous contents not released' ].    self interfaceMemberAt: #pstm put: anIStream.    backingStoreInterface := anIStream.</body><body package="Com- Ole">tymed        "Answer the receiver's global handle."	^ self memberAt: #tymed</body><body package="Com- Ole">tymed: aValue        "Answer the receiver's global handle."	^ self memberAt: #tymed put: aValue</body></methods><methods><class-id>External.COM_STGMEDIUM</class-id> <category>private-accessing</category><body package="Com- Ole">interfaceMemberAt: aMemberName put: anInterface	" Private - set the interface pointer at &lt;aMemberName&gt; in the medium union to &lt;anInterface&gt;. "	self unionMemberAt: ( 'u.', aMemberName ) asSymbol		put: anInterface asPointerParameter.</body><body package="Com- Ole">interfaceMemberAt: aMemberName type: anInterfaceClass	" Answer the interface pointer of type &lt;interfaceClass&gt; at &lt;aMemberName&gt;.  The interface is a temporary copy and is not separately reference counted.  The caller should copy the interface if they want to retain an independent copy.  Answer the interface or nil if not valid. "	| aPointer |	aPointer := self unionMemberAt: ( 'u.', aMemberName ) asSymbol.	^aPointer isNull		ifTrue: [ nil ]		ifFalse: [ anInterfaceClass forTemporaryInterfacePointerAtAddress: aPointer ]</body></methods><methods><class-id>External.COM_STGMEDIUM</class-id> <category>subclass-releasing</category><body package="Com- Ole">releaseInterfaces        " Private - release the interace pointers."    backingStoreInterface notNil 		ifTrue: [ 			" ReleaseStgMedium released the storage, we need invalidate the interface "			backingStoreInterface enforceInvalidation.				backingStoreInterface := nil ].    iUnknown notNil 		ifTrue: [ 			iUnknown := nil ]</body><body package="Com- Ole">releaseResources		" Private - release resources owned by the receiver. "	self releaseInterfaces.	super releaseResources.</body></methods><methods><class-id>External.COM_STGMEDIUM</class-id> <category>private</category><body package="Com- Ole">privateRelease        " Release any system resources associated with the receiver. "    "Original version using finalization:    self releaseInterfaces.    self doesNotNeedFinalization.    super release.    "    OLEDLL current ReleaseStgMedium: self.    super privateRelease</body></methods><methods><class-id>External.COM_STGMEDIUM class</class-id> <category>description services</category><body package="Com- Ole">mediumDescriptionOf: tymed	" Answer a string description of the transfer medium type &lt;tymed&gt;. "	| descriptions supportedTypes aStream |	tymed = TYMED_NULL		ifTrue: [ ^'(none)' ].	descriptions := Dictionary new		at: TYMED_GDI put: 'bitmap';		at: TYMED_ISTORAGE put: 'IStorage';		at: TYMED_HGLOBAL put: 'global memory';		at: TYMED_FILE put: 'file';		at: TYMED_ISTREAM put: 'IStream';		at: TYMED_ENHMF put: 'enhanced metafile';		at: TYMED_MFPICT put: 'metafile';		at: TYMED_NULL put: '(no data)';        yourself.	supportedTypes := SortedCollection new.	descriptions keysAndValuesDo: [ :aTYMED :aDescr |		( aTYMED bitAnd: tymed ) ~= 0			ifTrue: [ supportedTypes add: aDescr ] ].	supportedTypes isEmpty		ifTrue: [ ^'(unknown medium)' ].	aStream := ReadWriteStream on: String new.	supportedTypes do: [ :aDescr |		aStream size &gt; 0			ifTrue: [ aStream nextPutAll: ' | ' ].		aStream nextPutAll: aDescr ].	^aStream contents</body></methods><methods><class-id>External.COM_STGMEDIUM class</class-id> <category>instance creation</category><body package="Com- Ole">format: aFormatEtc data: aValue	"Answer a new instance of the receiver containing the rendering of &lt;aValue&gt; in the format specified by &lt;aFormatEtc&gt;. "	| aStgMedium |	aStgMedium := self new.	aStgMedium tymed: aFormatEtc tymed.	[	( COMDataRendering for: aValue formatEtc: aFormatEtc )		renderValueOntoMedium: aStgMedium.	] on: Error		do: [ :ex | COMError hresult: DV_E_CLIPFORMAT ].	^aStgMedium</body></methods><methods><class-id>External.COM_STGMEDIUM class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self structureName: #STGMEDIUM.	self updateAndRegister</body></methods><methods><class-id>External.IPersistStorage</class-id> <category>interface operations</category><body package="Com- Ole">handsOffStorage		" Release the object's storage and enter the hands-off storage state.		Raise an exception if an error occurs.  Answer the result code. "	^interface HandsOffStorage</body><body package="Com- Ole">initNew: aStorage		" Initialize the storage object &lt;aStorage&gt;.		Raise an exception if an error occurs.  Answer the result code. "	^interface InitNew: aStorage</body><body package="Com- Ole">isDirty		" Answer whether the object has been changed since it was last saved. "	^( interface IsDirty ) = S_OK</body><body package="Com- Ole">load: aStorage		" Load the object from the storage &lt;aStorage&gt; into memory or the running state.		Raise an exception if an error occurs.  Answer the result code. "	^interface Load: aStorage</body><body package="Com- Ole">save: aStorage		" Save the object to the storage &lt;anIStorage&gt;, including any nested objects,		and clear its dirty flag.  The storage is the one from which the object		was loaded or created. "	interface Save: aStorage _: true.</body><body package="Com- Ole">saveCompleted        " The object has been saved to its backing storage.        Terminate both the no-scribble and hands-off mode,        returning the object to normal storage mode.        Raise an exception if an error occurs.  Answer the result code. "    ^interface SaveCompleted: nil</body><body package="Com- Ole">saveCompleted: aStorage		" The object save to &lt;aStorage&gt; has been completed.  Terminate both the		no-scribble and hands-off mode, returning the object to normal storage mode.		Raise an exception if an error occurs.  Answer the result code. "	^interface SaveCompleted: aStorage</body><body package="Com- Ole">saveToAlternateStorage: aStorage		" Save the object to the storage &lt;anIStorage&gt;, including any nested objects,		and clear its dirty flag.  The storage is not the one from which the object		was loaded or created. "	interface Save: aStorage _: false.</body></methods><methods><class-id>External.IPersistStorage</class-id> <category>testing</category><body package="Com- Ole">usesStorage		" Answer whether the receiver operates on an IStorage. "	^true</body></methods><methods><class-id>External.IPersistStorage</class-id> <category>storing</category><body package="Com- Ole">saveTo: anIStorage sameAsLoad: fSameAsLoad		" Save the transacted-mode receiver to the storage object &lt;anIStorage&gt;.		The boolean &lt;fSameAsLoad&gt; is TRUE if &lt;anIStorage&gt; 		is the same storage object from which the object was loaded or created;		it is FALSE if &lt;anIStorage&gt; is a different storage object. "	OLEDLL current OleSave: self        _: anIStorage        _: fSameAsLoad.    self saveCompleted.</body></methods><methods><class-id>External.IPersistStorage class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistStorage.	self updateAndRegister</body></methods><methods><class-id>External.IRunningObjectTable</class-id> <category>interface operations-enumerating</category><body package="Com- Ole">runningMonikers	" Answer the monikers of the running objects registered in the running object table. "	| anEnumerator contents |	anEnumerator := self runningMonikersEnumerator.	contents := anEnumerator contents.	^contents</body><body package="Com- Ole">runningMonikersEnumerator		" Answer an enumerator that can be used to enumerate the		monikers of the running objects registered in the running object table. "	| resultReference |	resultReference := ( IEnum forIID: IID_IEnumMoniker ) asValueReference.	interface EnumRunning: resultReference.	^resultReference value</body></methods><methods><class-id>External.IRunningObjectTable</class-id> <category>interface operations-registration</category><body package="Com- Ole">registerObject: anIUnknown moniker: anIMoniker flags: grfFlags		" Register the running object &lt;anIUnknown&gt; in the running object table.		The moniker which is to bind to the newly running object is given by &lt;anIMoniker&gt;.		The strength or weakness of the registration is specfied by &lt;grfFlags&gt;.		Answer a token which identifies the registration. "	| resultReference hresult |	resultReference := nil asValueReference.	hresult := interface Register: grfFlags 		_: anIUnknown 		_: anIMoniker 		_: resultReference.    hresult = S_OK    " MK_S_MONIKERALREADYREGISTERED "        ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">revoke: registrationToken		" Revoke an object's registration from the running object table. "	^interface Revoke: registrationToken</body><body package="Com- Ole">strongRegisterObject: anIUnknown moniker: anIMoniker		" Register the running object &lt;anIUnknown&gt; in the running object table.		The moniker which is to bind to the newly running object is given by &lt;anIMoniker&gt;.		The registration is strong, enabling multiple clients to connect to and release		the active object multiple times.		Answer a token which identifies the registration. "	^self registerObject: anIUnknown 		moniker: anIMoniker 		flags: ROTFLAGS_REGISTRATIONKEEPSALIVE</body><body package="Com- Ole">weakRegisterObject: anIUnknown moniker: anIMoniker		" Register the running object &lt;anIUnknown&gt; in the running object table.		The moniker which is to bind to the newly running object is given by &lt;anIMoniker&gt;.		The registration is weak, enabling the object to be connected to and released only once.		Answer a token which identifies the registration. "	^self registerObject: anIUnknown 		moniker: anIMoniker 		flags: 0</body></methods><methods><class-id>External.IRunningObjectTable</class-id> <category>interface operations-accessing</category><body package="Com- Ole">getObject: anIMoniker		" Answer the running object designated by &lt;anIMoniker&gt;.		Answer nil if the object is not registered in the running object table. "	| resultReference hresult |	resultReference := IUnknown new asValueReference.	hresult := interface GetObject: anIMoniker _: resultReference.	hresult = S_OK  " MK_E_UNAVAILABLE "		ifFalse: [ COMResultNotification hresult: hresult ].	^resultReference value</body><body package="Com- Ole">getTimeOfLastChange: anIMoniker		" Answer the time of last-change of the running object designated by &lt;anIMoniker&gt;		Answer nil if the object is not registered in the running object table. "	| resultReference |	resultReference := nil asValueReference.	interface GetTimeOfLastChange: anIMoniker _: resultReference.	^resultReference value</body><body package="Com- Ole">noteChangeTime: registrationToken timeStamp: aTimeStamp		" Note the time that the object identified by the &lt;registrationToken&gt; changed.		Raise an exception if an error occurs.  Answer the result code. "	"The time-changed notification is used by IMoniker::GetTimeOfLastChange. "	^interface NoteChangeTime: registrationToken _: aTimeStamp</body></methods><methods><class-id>External.IRunningObjectTable</class-id> <category>interface operations-testing</category><body package="Com- Ole">isRunning: anIMoniker		" Answer whether an object with the moniker &lt;anIMoniker&gt;		is already registered as running. "	" This function should generally only be called by implementations of IMoniker::IsRunning.	Moniker clients should invoke IMoniker::IsRunning on their moniker, rather	than asking the running object table directly. "	^( interface IsRunning: anIMoniker ) = S_OK</body></methods><methods><class-id>External.IRunningObjectTable class</class-id> <category>private-accessing</category><body package="Com- Ole">current: anIRunningObjectTable	" Private - set the cached reference to the running object table for the caller's context. "	current := anIRunningObjectTable.</body></methods><methods><class-id>External.IRunningObjectTable class</class-id> <category>accessing</category><body package="Com- Ole">current	" Answer the running object table for the caller's context. The interface reference is shared by all clients in the session and should not be released by the caller. "	current isNil		ifTrue: [ self current: self getCurrent ].	^current</body></methods><methods><class-id>External.IRunningObjectTable class</class-id> <category>private-initialization</category><body package="Com- Ole">getCurrent	" Private - answer a new instance of the receiver for the running object table for the caller's context. "	| resultReference anIRunningObjectTable |	resultReference := self new asValueReference.	OLEDLL current GetRunningObjectTable: 0 		_: resultReference.	anIRunningObjectTable := resultReference value.	anIRunningObjectTable notNil		ifTrue: [ 			COMSessionManager registerSpecialSessionResource: anIRunningObjectTable 				description: (#COMRunningObjectTable &lt;&lt; #com &gt;&gt; 'COM running object table') asString.			].	^anIRunningObjectTable</body></methods><methods><class-id>External.IRunningObjectTable class</class-id> <category>releasing</category><body package="Com- Ole">releaseCurrent	" Release the cached reference to the current running object table. "	current notNil		ifTrue: [			COMSessionManager removeSpecialSessionResource: current.			self current: nil ].</body></methods><methods><class-id>External.IRunningObjectTable class</class-id> <category>private-releasing</category><body package="Com- Ole">resetCurrent	" Private - reset the cachaed reference to the current running object table."	current notNil		ifTrue: [			current enforceInvalidation.  " don't want to release/finalize any more "			self current: nil ].</body></methods><methods><class-id>External.IRunningObjectTable class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IRunningObjectTable.	self updateAndRegister</body></methods><methods><class-id>External.COMGUIDArrayBuffer</class-id> <category>subclass-initializing</category><body package="Com- Ole">initializeBuffer	" Private - initialize the contents of the argument buffer with the list of GUID values. "	| lpGUID nBytesGUID |	nBytesGUID := GUID sizeInBytes.  " self bufferElementType sizeof "	lpGUID := buffer copy.	self value do: [ :aGUID |		"lpGUID contents: aGUID."  " you wish "		lpGUID copyAt: 0			from: aGUID asByteArray  "?? is #asByteArray necessary ??"			size: nBytesGUID			startingAt: 1.		lpGUID increment ].</body></methods><methods><class-id>External.COMGUIDArrayBuffer</class-id> <category>subclass-testing</category><body package="Com- Ole">useFixedSpace	" Private - answer whether the structure value buffer should be allocated in fixed space.  If not, the buffer will be allocated in external memory to ensure that it is stable during external function calls. "	" force to external memory, at least until you figure out how to work with fixed space "	^false</body></methods><methods><class-id>External.COMGUIDArrayBuffer</class-id> <category>subclass-accessing</category><body package="Com- Ole">bufferElementCount	" Private - answer the number of elements in the buffer. "	^value size</body><body package="Com- Ole">bufferElementType	" Private - answer the C data type of the element in the receiver's buffer. "	^GUID baseCType</body></methods><methods><class-id>External.COMGUIDArrayBuffer</class-id> <category>subclass-buffer management</category><body package="Com- Ole">zzOLDclearBufferInExternalMemory	" Private - clear the buffer allocated in externalMemory to preserve invariant of zero-initialized object bodies.  Do nothing for the receiver because we're going to lay down all the bytes properly anyway. "</body></methods><methods><class-id>External.IPersistFilePointer</class-id> <category>interface operations</category><body package="Com- Ole">GetCurFile: resultReference		" Invoke the IPersistFile::GetCurFile function.		Raise an exception if an error occurs.  Answer the result code. "			| resultBuffer hresult |	resultBuffer := COMExternalInterface unicodeResultBuffer.	hresult := self invokeGetCurFile: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">Load: aPathName _: accessModeFlags		" Invoke the IPersistFile::Load function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeLoad: aPathName asUnicodeParameter		_: accessModeFlags</body><body package="Com- Ole">Save: aPathName _: fRemember		" Invoke the IPersistFile::Save function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSave: aPathName asUnicodeParameter		_: fRemember</body><body package="Com- Ole">SaveCompleted: aPathName		" Invoke the IPersistFile::SaveCompleted function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSaveCompleted: aPathName asUnicodeParameter</body></methods><methods><class-id>External.IPersistFilePointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistFile.	self updateAndRegister</body></methods><methods><class-id>External.IMalloc</class-id> <category>interface operations</category><body package="Com- Ole">alloc: anInteger		"Allocate from the receiver a block of memory of size &lt;anInteger&gt; bytes.  		Answer the address of the allocated memory. 		Raise an exception if the memory could not be allocated. "	^interface alloc: anInteger addressType: self addressClass</body><body package="Com- Ole">allocate: anInteger		"Allocate from the receiver a block of memory of size &lt;anInteger&gt; bytes.  		Answer the address of the allocated memory. 		Raise an exception if the memory could not be allocated. "	^interface alloc: anInteger addressType: self addressClass</body><body package="Com- Ole">allocate: anInteger addressType: aCOMMemoryAddressClass		"Allocate from the receiver a block of memory of size &lt;anInteger&gt; bytes.  		Answer the address of the allocated memory. 		Raise an exception if the memory could not be allocated. "	^interface alloc: anInteger addressType: aCOMMemoryAddressClass</body><body package="Com- Ole">didAlloc: aCOMMemoryAddress		"Answer whether the receiver allocated the block of memory 		pointed to by &lt;aCOMMemoryAddress&gt;."	^( interface DidAlloc: aCOMMemoryAddress ) = 1</body><body package="Com- Ole">free: aCOMMemoryAddress	" Free the block of memory referenced by &lt;aCOMMemoryAddress&gt;. "	interface Free: aCOMMemoryAddress.	aCOMMemoryAddress enforceInvalidation.</body><body package="Com- Ole">getSize: aCOMMemoryAddress		"Answer the size in bytes of the memory block referenced 		by &lt;aCOMMemoryAddress&gt;.  Raise an exception if an error occurs."	^interface GetSize: aCOMMemoryAddress</body><body package="Com- Ole">heapMinimize		" Request the receiver to minimize/reorganize itself by releasing unused memory. "	interface HeapMinimize.</body><body package="Com- Ole">realloc: aCOMMemoryAddress newSize: anInteger		" Reallocate the block of memory referenced by &lt;anOLEMemoryAddress&gt; 		to be of size &lt;anInteger&gt; bytes.   		Move the block if necessary.  Free memory no longer used.  		Answer the address of the allocated memory. 		Raise an exception if the memory could not be reallocated. "	^interface Realloc: aCOMMemoryAddress _: anInteger</body><body package="Com- Ole">reallocate: aCOMMemoryAddress newSize: anInteger		" Reallocate the block of memory referenced by &lt;anOLEMemoryAddress&gt; 		to be of size &lt;anInteger&gt; bytes.   		Move the block if necessary.  Free memory no longer used.  		Answer the address of the allocated memory. 		Raise an exception if the memory could not be reallocated. "	^interface Realloc: aCOMMemoryAddress _: anInteger</body></methods><methods><class-id>External.IMalloc</class-id> <category>private-allocation</category><body package="Com- Ole">addressClass		" Private - answer the COM address class used for memory allocated from the receiver. "	self = self class taskMemoryAllocator		ifTrue: [ ^COMMemoryAddress ].	self = self class sharedMemoryAllocator		ifTrue: [ ^COMSharedMemoryAddress ].	COMError raiseSignal: #ErrUnknownAllocator &lt;&lt; #com &gt;&gt; 'unknown COM memory allocator'</body></methods><methods><class-id>External.IMalloc class</class-id> <category>private-releasing</category><body package="Com- Ole">resetMemoryAllocators	" Private - reset the cached references to the COM memory allocators. "	self		resetTaskMemoryAllocator;		resetSharedMemoryAllocator.</body><body package="Com- Ole">resetSharedMemoryAllocator	" Private - reset the cached reference to the COM shared memory allocator. "	self sharedMemoryAllocator: nil</body><body package="Com- Ole">resetTaskMemoryAllocator	" Private - reset the cached reference to the COM task memory allocator. "	self taskMemoryAllocator: nil</body></methods><methods><class-id>External.IMalloc class</class-id> <category>private-accessing</category><body package="Com- Ole">sharedMemoryAllocator: anIMalloc	"Private - set the cached reference to the COM shared memory allocator to &lt;anIMalloc&gt;. "	sharedMemoryAllocator := anIMalloc.</body><body package="Com- Ole">taskMemoryAllocator: anIMalloc	"Private - set the cached reference to the COM task memory allocator to &lt;anIMalloc&gt;. "	taskMemoryAllocator := anIMalloc.</body></methods><methods><class-id>External.IMalloc class</class-id> <category>releasing</category><body package="Com- Ole">releaseMemoryAllocators	" Release the cached references to the COM memory allocators. "	self		releaseTaskMemoryAllocator;		releaseSharedMemoryAllocator.</body><body package="Com- Ole">releaseSharedMemoryAllocator	" Release the cached reference to the COM shared memory allocator. "	sharedMemoryAllocator notNil		ifTrue: [			COMSessionManager removeSpecialSessionResource: sharedMemoryAllocator.			self sharedMemoryAllocator: nil ].</body><body package="Com- Ole">releaseTaskMemoryAllocator	" Release the cached reference to the COM task memory allocator. "	taskMemoryAllocator notNil		ifTrue: [			COMSessionManager removeSpecialSessionResource: taskMemoryAllocator.			self taskMemoryAllocator: nil ].</body></methods><methods><class-id>External.IMalloc class</class-id> <category>accessing</category><body package="Com- Ole">sharedMemoryAllocator	" Answer the IMalloc interface of the COM shared memory allocator.  Answer nil if the shared memory allocator is not supported by this version of COM.  The interface reference is shared by all clients in the session and should not be released by the caller. "	sharedMemoryAllocator isNil		ifTrue: [ self sharedMemoryAllocator: self getSharedMemoryAllocator ].	^sharedMemoryAllocator</body><body package="Com- Ole">taskMemoryAllocator	" Answer the IMalloc interface of the COM task memory allocator.  The interface reference is shared by all clients in the session and should not be released by the caller. "	^taskMemoryAllocator		ifNil: 			[self taskMemoryAllocator: self getTaskMemoryAllocator.			taskMemoryAllocator]</body></methods><methods><class-id>External.IMalloc class</class-id> <category>subclass-tracing</category><body package="Com- Ole">canTraceAdaptorAssumeHRESULT	" Answer whether a trace adaptor configured on an instance of the receiver can assume that the functions in the interface represented by the receiver follow the standard COM convention of returning an HRESULT as the function return value, with OUT values returned via parameter values. "	^false</body></methods><methods><class-id>External.IMalloc class</class-id> <category>private-initialization</category><body package="Com- Ole">getSharedMemoryAllocator	" Private - answer a new instance of the receiver on the COM shared-memory allocator. "	| resultReference anIMalloc |	resultReference := self new asValueReference.	OLEDLL current CoGetMalloc: MEMCTX_SHARED 		_: resultReference.	anIMalloc := resultReference value.	anIMalloc notNil		ifTrue: [ 			COMSessionManager registerSpecialSessionResource: anIMalloc 				description: (#COMSharedMemoryAllocator &lt;&lt; #com &gt;&gt; 'COM shared memory allocator') asString.			].	^anIMalloc</body><body package="Com- Ole">getTaskMemoryAllocator	" Private - answer a new instance of the receiver on the COM task memory allocator. "	| resultReference anIMalloc |	resultReference := self new asValueReference.	OLEDLL current CoGetMalloc: MEMCTX_TASK 		_: resultReference.	anIMalloc := resultReference value.	anIMalloc notNil		ifTrue: [ 			COMSessionManager registerSpecialSessionResource: anIMalloc 				description: (#COMTaskMemoryAllocator &lt;&lt; #com &gt;&gt; 'COM task memory allocator') asString.			].	^anIMalloc</body></methods><methods><class-id>External.IMalloc class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IMalloc.	self updateAndRegister</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-conversion services</category><body package="Com- Ole">CoTreatAsClass: clsidOld _: clsidNew	" Establishes or removes an emulation from one object class to another.        The &lt;clsidNew&gt; specifies the CLSID of the object class that should emulate        &lt;clsidOld&gt; replacing any existing emulation. It can be CLSID_NULL, in which        case any existing emulation for &lt;clsidOld&gt; is removed. "	^(self invokeCoTreatAsClass: clsidOld _: clsidNew) asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-object conversion</category><body package="Com- Ole">GetConvertStg: anIStorage	" Answer the current value of the conversion bit in the object's storage,        &lt;anIStorage&gt; which was previously set with SetConvertStg. "	^(self invokeGetConvertStg: anIStorage asPointerParameter) asHRESULT</body><body package="Com- Ole">OleDoAutoConvert: anIStorage _: resultReference	" Automatically convert an object in storage &lt;anIStorage&gt; and        store the CLSID to which the object was converted in &lt;resultReference&gt; .        The object must have been previously tagged for automatic conversion,        typically at setup time for the object application.        Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := (self invokeOleDoAutoConvert: anIStorage asPointerParameter				_: resultBuffer asPointerParameter) asHRESULT.	hresult succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult</body><body package="Com- Ole">OleGetAutoConvert: clsidOld _: resultReference	" Retrieve the existing auto-convert class for object of class &lt;clsidOld&gt; and        store it into &lt;resultReference&gt;. If there is no such class, CLSID_NULL is returned.        Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := (self invokeOleGetAutoConvert: clsidOld				_: resultBuffer asPointerParameter) asHRESULT.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">OleSetAutoConvert: clsidOld _: clsidNew	" Tag an object of class &lt;clsidOld&gt; for automatic conversion to a        different class &lt;clsidNew&gt; on being loaded."	^(self OleSetAutoConvert: clsidOld _: clsidNew) asHRESULT</body><body package="Com- Ole">SetConvertStg: anIStorage _: fConvert	" Set the conversion bit in the object's storage &lt;anIStorage&gt; so that the setting        is retrievable with GetConvertStg.  The boolean &lt;fConvert&gt; if TRUE tags the        object for conversion to another class of object; FALSE clears the conversion bit. "	^(self invokeSetConvertStg: anIStorage asPointerParameter _: fConvert)		asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-data object operations</category><body package="Com- Ole">CreateDataAdviseHolder: resultReference		"Create a new data advise holder and store its IDataAdviseHolder		interface into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IDataAdviseHolderPointer resultValueBuffer.	hresult := self invokeCreateDataAdviseHolder: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CreateDataCache: controllingIUnknown _: clsid _: iid _: resultReference		"Create a data cache object, optionally as part of an aggregate		controlled by the object &lt;controllingIUnknown&gt;.		Optionally specify the GUID &lt;clsid&gt; which is to be used to generate		default icon labels (usually NULL).		Obtain the interface specified by the GUID &lt;iid&gt; and store it into the &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := self invokeCreateDataCache: controllingIUnknown asPointerParameter		_: clsid 		_: iid 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">OleDraw: anIUnknown _: dwAspect _: hdcDraw _: rcBounds	" OleDraw is a helper function that can be used to draw objects.        The interface &lt;anIUnknown&gt; is an interface of the object to be drawn.        The value &lt;dwAspect&gt; is from the enumeration DVASPECT.        The handle &lt;hdcDraw&gt; is the device context onto which the drawing should        actually be done (In OLE 2.01 this cannot be a metafile device context ).        The rectangle &lt;rcBounds&gt; indicates the rectangle on which the object should        be drawn. This parameter controls the positioning and stretching of the object.        Raise an exception if an error occurs.  Answer the result code. "	^(self		invokeOleDraw: anIUnknown asPointerParameter		_: dwAspect		_: hdcDraw asHandleParameter		_: (COMExternalInterface asRectangleParameter: rcBounds)) asHRESULT</body><body package="Com- Ole">OleDuplicateData: hSrc _: cfFormat _: uiFlags		" Duplicate a metafile, bitmap, or global memory resource.		Return a handle of the same type as the source data. "	| hSource hCopy |	hSource := hSrc asHandleParameter.	hCopy := self invokeOleDuplicateData: hSource		_: cfFormat		_: uiFlags.	Tools.Note ISSUE.  " Need to resolve handle strategy - VS Handle classes vs. raw types. [DL 24-Jan-96] "	^hCopy isNull		ifTrue: [ 			Tools.Note ISSUE.  " What error code should this be? [DL 17-Apr-96] "			COMError raiseSignal ]		ifFalse: [ hSource class fromHandle: hCopy ]</body><body package="Com- Ole">ReleaseStgMedium: aStgMedium		" Release the storage medium &lt;aStgMedium&gt;. "	COMExternalInterface checkInOutStructureParameter: aStgMedium.	self invokeReleaseStgMedium: aStgMedium asPointerParameter</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-FILETIME services</category><body package="Com- Ole">CoDosDateTimeToFileTime: nDosDate _: nDosTime _: resultReference	" Convert the DOS date/time values into a FILETIME and store the result into the &lt;resultReference&gt;.  Answer whether the conversion succeeded. "	| succeeded resultBuffer |	resultBuffer := COMStructure resultValueBufferFor: #FILETIME.	succeeded := self invokeCoDosDateTimeToFileTime: nDosDate 		_: nDosTime 		_: resultBuffer asPointerParameter.	succeeded		ifTrue: [ resultReference value: resultBuffer contents "asTimeStamp" ].	^succeeded</body><body package="Com- Ole">CoFileTimeNow: resultReference	" Obtain the current time as a FILETIME and store it into the &lt;resultReference&gt;.  Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMStructure resultValueBufferFor: #FILETIME.	hresult := self invokeCoFileTimeNow: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents "asTimeStamp".	^hresult asHRESULT</body><body package="Com- Ole">CoFileTimeToDosDateTime: aFILETIME _: resultReferenceDosDate _: resultReferenceDosTime		" Convert the FILETIME value &lt;aFILETIME&gt; to an MSDOS date and time.		Answer whether the conversion was successful. "	| succeeded dosDateBuffer dosTimeBuffer |	dosDateBuffer := COMExternalInterface scalarResultBufferFor: #WORD.	dosTimeBuffer := COMExternalInterface scalarResultBufferFor: #WORD.	succeeded := self invokeCoFileTimeToDosDateTime: aFILETIME asPointerParameter		_: dosDateBuffer asPointerParameter		_: dosTimeBuffer asPointerParameter.	succeeded		ifTrue: [			resultReferenceDosDate value: dosDateBuffer contents.			resultReferenceDosTime value: dosTimeBuffer contents ].	^succeeded</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-initialization</category><body package="Com- Ole">CoBuildVersion	"Answer an array containing the major and minor version numbers of the COM library. "	| dw |	dw := self invokeCoBuildVersion.	^Array 		with: ( Win32ExternalInterface HIWORD: dw )		with: ( Win32ExternalInterface LOWORD: dw )</body><body package="Com- Ole">CoInitialize: anIMalloc	| result |	result := (self invokeCoInitialize: anIMalloc asPointerParameter)				asHRESULT.	^result = S_OK or: [result = S_FALSE]</body><body package="Com- Ole">CoInitializeEx: anIMalloc mode: aMode	self deprecated: #(#version '8.0').	^self error: #ApartmentModelNotSupported &lt;&lt; #com				&gt;&gt; 'This apartment model is not supported. Please use COMThreadManager services.'</body><body package="Com- Ole">CoInitializeExAppartmentThreaded	"It is not supported to set the appartment model directly please use COMThreadManager services instead."	self deprecated: #(#version '8.0').	^ self error: #ApartmentModelNotSupported &lt;&lt; #com &gt;&gt; 'This apartment model is not supported. Please use COMThreadManager services.'</body><body package="Com- Ole">CoInitializeExMultiThreaded	"It is not supported to set the appartment model directly please use COMThreadManager services instead."	self deprecated: #(#version '8.0').	^ self error: #ApartmentModelNotSupported &lt;&lt; #com &gt;&gt; 'This apartment model is not supported. Please use COMThreadManager services.'</body><body package="Com- Ole">CoInitializeWorkerThread	^ (self invokeCoInitializeExThreaded: nil asPointerParameter coInit: COINIT_MULTITHREADED) asHRESULT</body><body package="Com- Ole">OleBuildVersion	"Answer an array containing the major and minor version numbers of the COM library. "	| dw |	dw := self invokeOleBuildVersion.	^Array 		with: ( Win32ExternalInterface HIWORD: dw )		with: ( Win32ExternalInterface LOWORD: dw )</body><body package="Com- Ole">OleInitialize: anIMalloc	" Initialize the COM library using the memory allocator &lt;anIMalloc&gt;.  If no memory allocator is specified, the default COM task allocator is used.  This function is unnecessary if the CoInitialize function is used.  Raise an exception if an error occurs.  Answer the result code. "	| result |	result := (self invokeOleInitialize: anIMalloc asPointerParameter)				asHRESULT.	^result = S_OK or: [result = S_FALSE]</body><body package="Com- Ole">versionNumbers	" Answer the major/minor version numbers of the COM library. "	^ self versionNumbersForMode: self mode</body><body package="Com- Ole">versionNumbersForMode: aMode	" Answer the major/minor version numbers of the COM library. "	^self		forMode: aMode		inOleDo: [self OleBuildVersion]		inSTAModeDo: [self CoBuildVersion]		elseDo: [COMSystem errorUnsupportedMode]</body><body package="Com- Ole">warnOperationDisabled	COMDevelopmentWarning raiseSignalOnce: #OperationDisbled &lt;&lt; #com				&gt;&gt; 'This operation has been disabled. Please use mode operation in COMSystem instead.'</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-object management</category><body package="Com- Ole">CoHasStrongExternalConnections: anIUnknown		"Answer whether the object &lt;anIUnknown&gt; has strong external connections. "	^self invokeCoHasStrongExternalConnections: anIUnknown asPointerParameter</body><body package="Com- Ole">CoIsHandlerConnected: anIUnknown		"Answer whether the in-process server or handler 		is connected for the object &lt;anIUnknown&gt;. "	^self invokeCoIsHandlerConnected: anIUnknown asPointerParameter</body><body package="Com- Ole">CoLockObjectExternal: anIUnknown _: fLock _: fLastUnlockReleases	"Lock or unlock the object &lt;anIUnknown&gt; in memory, 		according to the &lt;fLock&gt; boolean.		Raise an exception if an error occurs.  Answer the result code. "	^(self		invokeCoLockObjectExternal: anIUnknown asPointerParameter		_: fLock		_: fLastUnlockReleases) asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-icon extraction</category><body package="Com- Ole">OleGetIconOfClass: aCLSID _: labelString _: fUseTypeAsLabel	| hIcon |	hIcon := self invokeOleGetIconOfClass: aCLSID		_: labelString asUnicodeParameter		_: fUseTypeAsLabel.	Tools.Note ISSUE.  " Icon wrapper abstraction for VW?? "	^hIcon</body><body package="Com- Ole">OleGetIconOfFile: aPathName _: fUseFileAsLabel	| hIcon |	hIcon := self invokeOleGetIconOfFile: aPathName asUnicodeParameter		_: fUseFileAsLabel.	Tools.Note ISSUE.  " Icon wrapper abstraction for VW?? "	^hIcon</body><body package="Com- Ole">OleMetafilePictFromIconAndLabel: anIcon _: labelString _: lpszSourceFile _: iIconIndex	| hIcon |	hIcon := self invokeOleMetafilePictFromIconAndLabel: anIcon asHandleParameter		_: labelString asUnicodeParameter		_: lpszSourceFile asUnicodeParameter		_: iIconIndex.	Tools.Note ISSUE.  " Icon wrapper abstraction for VW?? "	^hIcon</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-GUID services</category><body package="Com- Ole">CLSIDFromProgID: aString _: resultReference	" Obtain the CLSID associated with the ProgId in &lt;aString&gt;		and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := self invokeCLSIDFromProgID: aString asUnicodeParameter				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Ole">CLSIDFromString: aString _: resultReference	" Obtain the CLSID associated whose display name is &lt;aString&gt;		and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := self invokeCLSIDFromString: aString asUnicodeParameter				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded		ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Ole">CoCreateGuid: resultReference		"Generate a new GUID and store it into &lt;resultReference&gt;.  		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := self invokeCoCreateGuid: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">IIDFromString: aString _: resultReference	" Obtain the IID associated whose display name is &lt;aString&gt;		and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := self invokeIIDFromString: aString asUnicodeParameter				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded		ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Ole">ProgIDFromCLSID: clsid _: resultReference		" Obtain the ProgID string associated with the CLSID &lt;clsid&gt; 		in the system registry and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface unicodeResultBuffer.	hresult := self invokeProgIDFromCLSID: clsid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">StringFromCLSID: clsid _: resultReference		" Convert the CLSID specified by the GUID &lt;clsid&gt; into a display string.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface unicodeResultBuffer.	hresult := self invokeStringFromCLSID: clsid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">StringFromGUID2: aGUID _: resultReference _: cbMax		" Convert the GUID &lt;aGUID&gt; into a display string, storing the 		string of up to &lt;cbMax&gt; bytes into the buffer &lt;stringBuffer&gt;.		Answer the number of characters stored (including the null at the end)."	| unicodeBuffer count |	unicodeBuffer := COMExternalInterface unicodeStringBuffer: cbMax.	count := self invokeStringFromGUID2: aGUID		_: unicodeBuffer asPointerParameter		_: cbMax.	count = 0		ifTrue: [ 			unicodeBuffer enforceRelease.			^COMError raiseSignal: #ErrBufferTooSmall &lt;&lt; #com &gt;&gt; 'buffer too small to hold result' ].	resultReference value: unicodeBuffer contents.	"Assert isTrue: [ resultReference value size = ( count - 1 ) ]."	unicodeBuffer enforceRelease.	^count</body><body package="Com- Ole">StringFromIID: iid _: resultReference		" Convert the IID specified by the GUID &lt;iid&gt; into a display string.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface unicodeResultBuffer.	hresult := self invokeStringFromIID: iid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-class factory</category><body package="Com- Ole">CoCreateInstance: clsid _: controllingUnknown _: dwClsContext _: iid _: resultReference	" Create a new instance of the COM class specified by the GUID &lt;clsid&gt;.        If a &lt;controllingUnknown&gt; is specified, the object is        being instantiated for use as a non-control object within an aggregate.        Obtain the interface specified by the GUID &lt;iid&gt; on the new object        and store it into the &lt;resultReference&gt;.        Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := COMThreadManager isActiveProcessAnMTAProcess				ifTrue: 					[self						threadedInvokeCoCreateInstance: clsid						_: controllingUnknown asPointerParameter						_: dwClsContext						_: iid						_: resultBuffer asPointerParameter]				ifFalse: 					[self						invokeCoCreateInstance: clsid						_: controllingUnknown asPointerParameter						_: dwClsContext						_: iid						_: resultBuffer asPointerParameter].	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CoCreateInstanceEx: clsid _: controllingUnknown _: dwClsContext _: serverName _: dwCount _: resultReferencesArray	" Create a new instance of the COM class specified by the GUID &lt;clsid&gt;.        If a &lt;controllingUnknown&gt; is specified, the object is        being instantiated for use as a non-control object within an aggregate.        Obtain the interfaces specified by the IID's in the &lt;resultReferencesArray&gt; on the new object        and store them back into the &lt;resultReferencesArray&gt;.&lt;serverName&gt;[in] Machine on which to instantiate the object. May be NULL, in which case the object is instantiated on the current machine or at the machine specified under the class's RemoteServerName sub-key in the registry, according to the interpretation of the dwClsCtx parameter (see the CLSCTX documentation for details).        Raise an exception if an error occurs.  Answer the result code. "	| hresult serverInfoBuffer multiQIBuffer interfacePointerList |	serverInfoBuffer := COMExternalInterface				createCOSERVERINFOBuffer: serverName.	multiQIBuffer := COMExternalInterface				multiQIResultBuffer: (resultReferencesArray						collect: [:anInterfaceReference | anInterfaceReference iid]).		[hresult := COMThreadManager isActiveProcessAnMTAProcess			ifTrue:  [self						threadedInvokeCoCreateInstanceEx: clsid						_: controllingUnknown asPointerParameter						_: dwClsContext						_: serverInfoBuffer asPointerParameter						_: dwCount						_: multiQIBuffer asPointerParameter]			ifFalse:  [self						invokeCoCreateInstanceEx: clsid						_: controllingUnknown asPointerParameter						_: dwClsContext						_: serverInfoBuffer asPointerParameter						_: dwCount						_: multiQIBuffer asPointerParameter].	interfacePointerList := multiQIBuffer contents.	Assert isTrue: [interfacePointerList size = resultReferencesArray size].	1 to: resultReferencesArray size		do: 			[:i |			| anInterfacePointer |			anInterfacePointer := interfacePointerList at: i.	" nil if no interface, which we do want to push through "			(resultReferencesArray at: i) value: anInterfacePointer]]			ensure: [serverInfoBuffer enforceRelease].	^hresult asHRESULT</body><body package="Com- Ole">CoGetClassObject: aCLSID _: dwClsContext _: serverName _: iid _: resultReference	"Obtain the interface specified by the GUID &lt;iid&gt;        for the class object specified by the GUID &lt;aCLSID&gt;.        Store the interface reference into &lt;resultReference&gt;.        Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer serverInfoBuffer |	serverInfoBuffer := COMExternalInterface				createCOSERVERINFOBuffer: serverName.	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.		[hresult := COMThreadManager isActiveProcessAnMTAProcess				ifTrue: 					[self						threadedInvokeCoGetClassObject: aCLSID						_: dwClsContext						_: serverInfoBuffer asPointerParameter						_: iid						_: resultBuffer asPointerParameter]				ifFalse: 					[self						invokeCoGetClassObject: aCLSID						_: dwClsContext						_: serverInfoBuffer asPointerParameter						_: iid						_: resultBuffer asPointerParameter].	hresult asHRESULT succeeded		ifTrue: [resultReference value: resultBuffer contents]]			ensure: [serverInfoBuffer enforceRelease].	^hresult asHRESULT</body><body package="Com- Ole">CoRegisterClassObject: clsid _: anIUnknown _: clsContext _: flags _: resultReference	" Register the class object &lt;anIUnknown&gt; of an EXE object server application		for the class whose CLSID is the GUID &lt;clsid&gt;.  		The CLSCTX value &lt;clsContext&gt; specifies the context in which		the executable code is to be run.  The REGCLS value &lt;flags&gt; 		controls how connections are made to the class object.		Store the class registration token into the &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult1 resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #ULONG.	hresult1 := self				invokeCoRegisterClassObject: clsid				_: anIUnknown asPointerParameter				_: clsContext				_: flags				_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult1 asHRESULT</body><body package="Com- Ole">CoRevokeClassObject: dwRegister	" Notify COM that a class object previously registered with 		CoRegisterClassObject is no longer available.		Raise an exception if an error occurs.  Answer the result code. "	"WINOLEAPI  CoRevokeClassObject(DWORD dwRegister); "	^(self invokeCoRevokeClassObject: dwRegister) asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-monikers</category><body package="Com- Ole">BindMoniker: anIMoniker _: grfOpt _: iid _: resultReference	" Bind the moniker &lt;anIMoniker&gt;.  Obtain the interface specified by &lt;iid&gt;		and store the interface pointer into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := self				invokeBindMoniker: anIMoniker asPointerParameter				_: grfOpt				_: iid				_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CreateAntiMoniker: resultReference		" Create a new anti-moniker and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeCreateAntiMoniker: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CreateBindCtx: reserved _: resultReference		" Create and initialize a new bind context.		Store the interface pointer into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IBindCtxPointer resultValueBuffer.	hresult := self invokeCreateBindCtx: reserved		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CreateFileMoniker: aPathName _: resultReference		" Create a file moniker from &lt;aPathName&gt;, which can be relative or absolute.		Obtain a new IMoniker interface and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeCreateFileMoniker: aPathName asUnicodeParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CreateGenericComposite: firstMoniker _: nextMoniker _: resultReference		" Create a composite moniker by concatenating &lt;pmkFirst&gt; and &lt;pmkRest&gt;.		Store the interface pointer into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeCreateGenericComposite: firstMoniker asPointerParameter 		_: nextMoniker asPointerParameter 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CreateItemMoniker: delimiterString _: itemName _: resultReference		" Create an item moniker from &lt;itemName&gt;, prefixed by the given &lt;delimiterString&gt;.		Store the interface pointer into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeCreateItemMoniker: delimiterString asUnicodeParameter		_: itemName asUnicodeParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CreatePointerMoniker: anIUnknown _: resultReference		" Create a pointer moniker from the interface &lt;anIUnknown&gt;.		Obtain a new IMoniker interface and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeCreatePointerMoniker: anIUnknown asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">GetRunningObjectTable: reserved _: resultReference		" Obtain a pointer to the running object table for the caller's context		and store it into the &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IRunningObjectTablePointer resultValueBuffer.	hresult := self invokeGetRunningObjectTable: reserved 		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">MkParseDisplayName: aBindContext 	_: displayName 	_: nCharsConsumedReference 	_: resultReference		" Parse the display name &lt;displayName&gt; into a moniker for the referenced object.		Store the moniker interface into &lt;resultReference&gt;.		Store the number of characters consumed in &lt;displayName&gt; 		into &lt;nCharsConsumedReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer nCharsConsumed |	resultBuffer := IMonikerPointer resultValueBuffer.	nCharsConsumed := COMExternalInterface scalarResultBufferFor: #ULONG.	hresult := self invokeMkParseDisplayName: aBindContext asPointerParameter		_: displayName asUnicodeParameter		_: nCharsConsumed asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	nCharsConsumedReference value: nCharsConsumed contents.	^hresult asHRESULT</body><body package="Com- Ole">MonikerCommonPrefixWith: aMoniker _: anotherMoniker _: resultReference	" Create a moniker specifying common prefix between &lt;aMoniker&gt;		and &lt;anotherMoniker&gt; and store its IMoniker into the &lt;resultReference&gt;.		Used in the implementation of a moniker class.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self				invokeMonikerCommonPrefixWith: aMoniker asPointerParameter				_: anotherMoniker asPointerParameter				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded		ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Ole">MonikerRelativePathTo: sourceMoniker _: destMoniker _: resultReference _: dwReserved		" Create a moniker specifying the relative path from &lt;sourceMoniker&gt;		to &lt;destMoniker&gt; and store its IMoniker into the &lt;resultReference&gt;.		Used in the implementation of a moniker class.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeMonikerRelativePathTo: sourceMoniker asPointerParameter		_: destMoniker asPointerParameter		_: resultBuffer asPointerParameter		_: dwReserved.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-storage</category><body package="Com- Ole">CreateILockBytesOnHGlobal: aGlobalAddress _: fDeleteOnRelease _: resultReference		" Create an ILockBytes whose data is stored inside the global memory		handle &lt;aGlobalAddress&gt; and store it into the &lt;resultReference&gt;.		The memory must be movable and nondiscardable.		If &lt;fDeleteOnRelease&gt; is set, the memory is automatically		freed when the stream is released.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := ILockBytesPointer resultValueBuffer.	hresult := self invokeCreateILockBytesOnHGlobal: aGlobalAddress asHandleParameter		_: fDeleteOnRelease		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">CreateStreamOnHGlobal: aGlobalAddress _: fDeleteOnRelease _: resultReference		" Create an IStream whose data is stored inside the global memory		handle &lt;aGlobalAddress&gt; and store it into the &lt;resultReference&gt;.		The memory must be movable and nondiscardable.		If &lt;fDeleteOnRelease&gt; is set, the memory is automatically		freed when the stream is released.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IStreamPointer resultValueBuffer.	hresult := self invokeCreateStreamOnHGlobal: aGlobalAddress asHandleParameter		_: fDeleteOnRelease		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">GetClassFile: aFileName _: resultReference		" Get the CLSID associated with the storage named &lt;aFileName&gt;		and store it into the &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := self invokeGetClassFile: aFileName asUnicodeParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">GetHGlobalFromILockBytes: anILockBytes _: resultReference		" Get the global memory address of &lt;anILockBytes&gt; and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer anAddress |	resultBuffer := Win32GlobalMemoryAddress resultValueBuffer.	hresult := self invokeGetHGlobalFromILockBytes: anILockBytes asPointerParameter		_: resultBuffer asPointerParameter.	anAddress := resultBuffer contents.	anAddress notNil		ifTrue: [ anAddress lock ].  " make the memory addressable "	resultReference value: anAddress.	^hresult asHRESULT</body><body package="Com- Ole">GetHGlobalFromStream: anIStream _: resultReference		" Get the global memory address of &lt;anIStream&gt; and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer anAddress |	resultBuffer := Win32GlobalMemoryAddress resultValueBuffer.	hresult := self invokeGetHGlobalFromStream: anIStream asPointerParameter		_: resultBuffer asPointerParameter.	anAddress := resultBuffer contents.	anAddress notNil		ifTrue: [ anAddress lock ].  " make the memory addressable "	resultReference value: anAddress.	^hresult asHRESULT</body><body package="Com- Ole">OleSave: anIPersistStorage _: anIStorage _: fSameAsLoad	" Save an object &lt;anIPersistStorage&gt; which was opened in 		transacted mode to the storage object &lt;anIStorage&gt;. 		The boolean &lt;fSameAsLoad&gt; is TRUE if &lt;anIStorage&gt; 		is the same storage object from which the object was loaded or created;		it is FALSE if &lt;anIStorage&gt; is a different storage object.		Raise an exception if an error occurs.  Answer the result code. "	^(self		invokeOleSave: anIPersistStorage asPointerParameter		_: anIStorage asPointerParameter		_: fSameAsLoad) asHRESULT</body><body package="Com- Ole">OleSaveToStream: anIPersistStream _: anIStream	" Save an object in &lt;anIPersistStream&gt; to the stream object &lt;anIStream&gt;.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeOleSaveToStream: anIPersistStream asPointerParameter		_: anIStream asPointerParameter) asHRESULT</body><body package="Com- Ole">ReadClassStg: anIStorage _: resultReference		" Get the CLSID associated with the storage &lt;anIStorage&gt;		and store it into the &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := self invokeReadClassStg: anIStorage asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">ReadClassStm: anIStream _: resultReference		" Get the CLSID associated with the stream &lt;anIStream&gt;		and store it into the &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := External.GUID resultValueBuffer.	hresult := self invokeReadClassStm: anIStream asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">ReadFmtUserTypeStg: anIStorage 	_: resultReferenceClipboardFormat 	_: resultReferenceUserType		" Read the clipboard format and current user type from the storage &lt;anIStorage&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult cfBuffer userTypeBuffer cf |	cfBuffer := COMExternalInterface scalarResultBufferFor: #CLIPFORMAT.	userTypeBuffer := COMExternalInterface unicodeResultBuffer.	hresult := self invokeReadFmtUserTypeStg: anIStorage asPointerParameter 		_: cfBuffer asPointerParameter		_: userTypeBuffer asPointerParameter.	( cf := cfBuffer contents ) ~= IDataObject cfNull   " NULL If the format is no longer of interest to the caller "		ifTrue: [ resultReferenceClipboardFormat value: cf ].	resultReferenceUserType value: userTypeBuffer contents.  " NULL If the user type is no longer of interest to the caller "	^hresult asHRESULT</body><body package="Com- Ole">StgCreateDocfile: aFileName _: grfMode _: reserved _: resultReference		" Create a new compound file in the file system named &lt;aFileName&gt;		and open in with the access mode specified by the STGM flags &lt;grfMode&gt;.		Obtain an IStorage interface on the new storage and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IStoragePointer resultValueBuffer.	hresult := self invokeStgCreateDocfile: aFileName asUnicodeParameter		_: grfMode		_: reserved		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.    ^hresult asHRESULT</body><body package="Com- Ole">StgCreateDocfileOnILockBytes: anILockBytes _: grfMode _: reserved _: resultReference		" Create and open a new compound file on the storage provided by &lt;anILockBytes&gt;		and open in with the access mode specified by the STGM flags &lt;grfMode&gt;.		Obtain an IStorage interface on the new storage and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IStoragePointer resultValueBuffer.	hresult := self invokeStgCreateDocfileOnILockBytes: anILockBytes asPointerParameter		_: grfMode		_: reserved		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult asHRESULT</body><body package="Com- Ole">StgIsStorageFile: aFileName		" Determine whether the file named &lt;aFileName&gt; is an IStorage object.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeStgIsStorageFile: aFileName asUnicodeParameter) asHRESULT</body><body package="Com- Ole">StgIsStorageILockBytes: anILockBytes	" Determine whether &lt;anILockBytes&gt; contains an IStorage object.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeStgIsStorageILockBytes: anILockBytes asPointerParameter)		asHRESULT</body><body package="Com- Ole">StgOpenStorage: aFileName _:pstgPriority _: grfMode _: snbExclude _: reserved _: resultReference		" Open the compound file in the file system named &lt;aFileName&gt;		with the access mode specified by the STGM flags &lt;grfMode&gt;.		Obtain an IStorage interface on the new storage and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult snbBuffer resultBuffer |	snbBuffer := COMExternalInterface createSNBBuffer: snbExclude.	resultBuffer := IStoragePointer resultValueBuffer.	[	hresult := self invokeStgOpenStorage: aFileName asUnicodeParameter		_: pstgPriority asPointerParameter		_: grfMode		_: snbBuffer asPointerParameter		_: reserved		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	] ensure: [		snbBuffer enforceRelease ].    ^hresult asHRESULT</body><body package="Com- Ole">StgOpenStorageOnILockBytes: anILockBytes _: pstgPriority _: grfMode _: snbExclude _: reserved _: resultReference		" Open a compound file on the existing backing store provided by &lt;anILockBytes&gt;		with the access mode specified by the STGM flags &lt;grfMode&gt;.		Obtain an IStorage interface on the new storage and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult snbBuffer resultBuffer |	snbBuffer := COMExternalInterface createSNBBuffer: snbExclude.	resultBuffer := IStoragePointer resultValueBuffer.	[	hresult := self invokeStgOpenStorageOnILockBytes: anILockBytes asPointerParameter		_: pstgPriority asPointerParameter		_: grfMode		_: snbBuffer asPointerParameter		_: reserved		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	] ensure: [		snbBuffer enforceRelease ].    ^hresult asHRESULT</body><body package="Com- Ole">StgSetTimes: aFileName _: cTime _: aTime _: mTime		" Set the creation, access, and modification times of the storage		named &lt;aFileName&gt; in the file system.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeStgSetTimes: aFileName asUnicodeParameter		_: ( COMExternalInterface asFileTimeParameter: cTime )		_: ( COMExternalInterface asFileTimeParameter: aTime )		_: ( COMExternalInterface asFileTimeParameter: mTime )) asHRESULT</body><body package="Com- Ole">WriteClassStg: anIStorage _: clsid		" Write the CLSID specified by the GUID &lt;clsid&gt; to the storage &lt;anIStorage&gt;.		Raise an exception if an error occurs.  Answer the result code. "	" Containers typically call WriteClassStg before calling IPersistStorage::Save. "	^(self invokeWriteClassStg: anIStorage asPointerParameter 		_: clsid) asHRESULT</body><body package="Com- Ole">WriteClassStm: anIStream _: clsid	" Write the CLSID specified by the GUID &lt;clsid&gt; to the stream &lt;anIStream&gt;.		Raise an exception if an error occurs.  Answer the result code. "	" Most applications do not call WriteClassStm; it is called by OLE	before making a call to an application's IPersistStream::Save function. "	^(self invokeWriteClassStm: anIStream asPointerParameter _: clsid)		asHRESULT</body><body package="Com- Ole">WriteFmtUserTypeStg: anIStorage _: cf _: userType		" Write the specified clipboard format and current user type to the storage &lt;anIStorage&gt;.		Raise an exception if an error occurs.  Answer the result code. "	" WriteClassStg must be called before WriteFmUserTypeStg, which is	called in an object's implementation of IPersistStorage::Save and by	document-level objects that use structured storage for their persistent	representation in their save sequence. "	^(self invokeWriteFmtUserTypeStg: anIStorage asPointerParameter 		_: cf		_: userType asUnicodeParameter) asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-clipboard</category><body package="Com- Ole">OleFlushClipboard	" Empty the clipboard, removing the IDataObject instance.		Raise an exception if an error occurs.  Answer the result code. "	" WINOLEAPI  OleFlushClipboard(void); "	^self invokeOleFlushClipboard asHRESULT</body><body package="Com- Ole">OleGetClipboard: resultReference	" Retrieve the IDataObject from the clipboard and store it into &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IDataObjectPointer resultValueBuffer.	hresult := (self invokeOleGetClipboard: resultBuffer asPointerParameter)				asHRESULT.	hresult = S_OK ifTrue: [resultReference value: resultBuffer contents].	^hresult</body><body package="Com- Ole">OleIsCurrentClipboard: anIDataObject	" Determine whether &lt;anIDataObject&gt; is still on the clipboard.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeOleIsCurrentClipboard: anIDataObject asPointerParameter)		asHRESULT</body><body package="Com- Ole">OleSetClipboard: anIDataObject	" Put &lt;anIDataObject&gt; on the clipboard.		Raise an exception if an error occurs.  Answer the result code. "	^(self invokeOleSetClipboard: anIDataObject asPointerParameter) asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operation-registration database</category><body package="Com- Ole">OleRegEnumFormatEtc: clsid _: dwDirection _: resultReference	" Obtain an enumerator of the supported data formats defined in		the registration database for the CLSID &lt;clsid&gt;		and store it into the &lt;resultReference&gt;.		The set of formats to be enumerated is specified by the DATADIR value &lt;dwDirection&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumFORMATETC.	hresult := self				invokeOleRegEnumFormatEtc: clsid				_: dwDirection				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Ole">OleRegEnumVerbs: clsid _: resultReference	" Obtain an enumerator of the supported object verbs defined in		the registration database for the CLSID &lt;clsid&gt;		and store it into the &lt;resultReference&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumOLEVERB.	hresult := self invokeOleRegEnumVerbs: clsid				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Ole">OleRegGetMiscStatus: clsid _: dwAspect _: resultReference	" Obtain the miscellaneous status information for the CLSID &lt;clsid&gt; 		from the registration database and store it into the &lt;resultReference&gt;.  		The desired aspect is specified by the DVASPECT value &lt;dwAspect&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #DWORD.	hresult := self				invokeOleRegGetMiscStatus: clsid				_: dwAspect				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded		ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Ole">OleRegGetUserType: clsid _: dwFormOfType _: resultReference	" Obtain the user type of the CLSID &lt;clsid&gt; from the registration 		database and store it into the &lt;resultReference&gt;.  The form of the 		user-presentable string is indicated by the USERCLASSTYPE value &lt;dwFormOfType&gt;.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface unicodeResultBuffer.	hresult := self				invokeOleRegGetUserType: clsid				_: dwFormOfType				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded		ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>API operations-memory management</category><body package="Com- Ole">CoGetMalloc: dwMemContext _: resultReference	"Obtain an IMalloc interface for the OLE memory allocator specified		by the integer &lt;dwMemContext&gt; and store it into &lt;resultReference&gt;.  		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMallocPointer resultValueBuffer.	hresult := self invokeCoGetMalloc: dwMemContext				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded		ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body><body package="Com- Ole">threadedCoGetMalloc: dwMemContext _: resultReference	"Obtain an IMalloc interface for the OLE memory allocator specified		by the integer &lt;dwMemContext&gt; and store it into &lt;resultReference&gt;.  		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMallocPointer resultValueBuffer.	hresult := self threadedInvokeCoGetMalloc: dwMemContext				_: resultBuffer asPointerParameter.	hresult asHRESULT succeeded		ifTrue: [resultReference value: resultBuffer contents].	^hresult asHRESULT</body></methods><methods><class-id>External.OLEDLL</class-id> <category>private</category><body package="Com- Ole">forMode: aModeSymbol inOleDo: oleBlock inSTAModeDo: staBlock elseDo: otherBlock	aModeSymbol = COMSystem oleModeConstant ifTrue: [^oleBlock value].	aModeSymbol = COMSystem singleThreadedModeConstant		ifTrue: [^staBlock value].	^otherBlock value</body><body package="Com- Ole">initialize: anIMalloc mode: aMode	^self		forMode: aMode		inOleDo: [self OleInitialize: anIMalloc]		inSTAModeDo: [self CoInitialize: anIMalloc]		elseDo: [COMSystem errorUnsupportedMode]</body><body package="Com- Ole">initializeMode: aMode	10 timesRepeat: 			[([self initialize: nil mode: aMode] on: Error do: [:ex | ex return: false])				ifTrue: [^true].			self CoUninitialize].	^false</body><body package="Com- Ole">isSupportedLibraryVersion: dllVersionNumbers		" Answer whether the major/minor OLE library version numbers in 		&lt;dllVersionNumbers&gt; is a supported version of the OLE library, 		per OLE2VER.H. "	^( dllVersionNumbers at: 1 ) = Rmm   " major build number must match "		and: [ ( dllVersionNumbers at: 2 ) &gt;= Rup ]  " minor build number must be this or newer "</body></methods><methods><class-id>External.OLEDLL</class-id> <category>releasing</category><body package="Com- Ole">close	self unInitialize.	^super close</body></methods><methods><class-id>External.OLEDLL</class-id> <category>deprecated</category><body package="Com- Ole">runsInOleMode	self deprecated: #(#version '8.0' #use 'COMSystem current runsInOleMode').	^ COMSystem current runsInOleMode</body><body package="Com- Ole">runsMultiThreaded	"Multithreaded mode is not supported for the Smalltalk thread any more. 	Please see COMThreadManager for replacement"	self deprecated: #(#version '8.0').	^ false</body><body package="Com- Ole">runsSingleThreaded	self deprecated: #(#version '8.0' #use 'COMSystem current runsSingleThreaded').	^ COMSystem current runsSingleThreaded</body><body package="Com- Ole">setModeToMultiThreaded	"Setting the apartment mode of the main thread to Multithreaded is not supported any more.	Please see COMThreadManager for replacement functionality."	self deprecated: #(#version '8.0' ).	^ true</body><body package="Com- Ole">setModeToOLE	self deprecated: #(#version '8.0' #use 'COMSystem current setModeToOLE').	^COMSystem current enableOLEExtensions</body><body package="Com- Ole">setModeToSingleThreaded	self deprecated: #(#version '8.0' #use 'COMSystem current setModeToSingleThreaded').	^COMSystem current disableOLEExtensions</body></methods><methods><class-id>External.OLEDLL</class-id> <category>initialize-release</category><body package="Com- Ole">initialize	super initialize.	mode := COMSystem uninitializedModeConstant.</body><body package="Com- Ole">setUp: aMode	| dllVersionNumbers |	dllVersionNumbers := self versionNumbersForMode: aMode.	(self isSupportedLibraryVersion: dllVersionNumbers)		ifFalse: 			[self				error: #ErrUnsupportedCOMVer &lt;&lt; #com &gt;&gt; 'not a supported version of COM'.			^false].	(self initializeMode: aMode) ifFalse: [^false].	mode := aMode.	^true</body></methods><methods><class-id>External.OLEDLL</class-id> <category>obsolete</category><body package="Com- Ole">doInOleMode: aBlock	"This operation is not required as the main thread is always a singled threaded apartment "	self deprecated: #(#version '8.0').	^ self doInOleMode: aBlock ifImpossibleDo: [ ^ self ]</body><body package="Com- Ole">doInOleMode: aBlock ifImpossibleDo: anotherBlock	"This operation is not required as the main thread is always a singled threaded apartment "	self deprecated: #(#version '8.0').	^ self error: #ThisApartmentModelIsNotSupported &lt;&lt; #com &gt;&gt; 'This apartment model is not supported. Please use COMThreadManager services.'</body></methods><methods><class-id>External.OLEDLL</class-id> <category>terminating</category><body package="Com- Ole">unInitialize	^self		forMode: self mode		inOleDo: [self OleUninitialize]		inSTAModeDo: [self CoUninitialize]		elseDo: [COMSystem errorUnsupportedMode]</body></methods><methods><class-id>External.OLEDLL</class-id> <category>accessing</category><body package="Com- Ole">mode	^ mode</body></methods><methods><class-id>External.OLEDLL class</class-id> <category>deprecated</category><body package="Com- Ole">runsInOleMode	self deprecated: #(#version '8.0' #use 'COMSystem current runsInOleMode').	^ COMSystem current runsInOleMode</body><body package="Com- Ole">runsMultiThreaded	"Multithreaded mode is not supported for the Smalltalk thread any more. 	Please see COMThreadManager for replacement"	self deprecated: #(#version '8.0').	^ false</body><body package="Com- Ole">runsSingleThreaded	self deprecated: #(#version '8.0' #use 'COMSystem current runsSingleThreaded').	^ COMSystem current runsSingleThreaded</body><body package="Com- Ole">setModeToMultiThreaded	"Setting the apartment mode of the main thread to Multithreaded is not supported any more.	Please see COMThreadManager for replacement functionality."	self deprecated: #(#version '8.0' ).	^ true</body><body package="Com- Ole">setModeToOLE	self deprecated: #(#version '8.0' #use 'COMSystem current setModeToOLE').	^COMSystem current enableOLEExtensions</body><body package="Com- Ole">setModeToSingleThreaded	self deprecated: #(#version '8.0' #use 'COMSystem current setModeToSingleThreaded').	^COMSystem current disableOLEExtensions</body></methods><methods><class-id>External.OLEDLL class</class-id> <category>private-accessing</category><body package="Com- Ole">basicCurrent	^current</body><body package="Com- Ole">supportAllOLE	" Private - answer whether the COM library should be initialized to support all OLE services (including type libraries, clipboard, drag/drop, and automation).   Answer false if only basic COM services are supported. "	self deprecated: #(#version '8.0' #use 'COMSystem current runsInOleMode').	^ COMSystem current runsInOleMode</body><body package="Com- Ole">supportAllOLE: aBoolean	" Private - specify whether the COM library should be initialized to support all OLE services (including type libraries, clipboard, drag/drop, and automation).  Set to false if only basic COM services are supported. "	self		deprecated: #(#version '8.0' #use 'COMSystem current setModeToOLE/setModeToSingleThreaded').	^aBoolean		ifTrue: [COMSystem current enableOLEExtensions]		ifFalse: [COMSystem current disableOLEExtensions]</body></methods><methods><class-id>External.OLEDLL class</class-id> <category>initialize-release</category><body package="Com- Ole">initialize	"Make sure we are initialized to avoid problems with .NET"	(HostInterface isWindows or: [HostInterface isWindowsNT])		ifTrue: [COMSystem current setUpCOMMode]</body></methods><methods><class-id>External.OLEDLL class</class-id> <category>session management</category><body package="Com- Ole">startupImage	"Clear the current and load the current OLEDLL. This will initialize the appartment model"	COMSystem current setUpCOMMode</body></methods><methods><class-id>External.OLEDLL class</class-id> <category>subclass-initialization</category><body package="Com- Ole">getCurrent	"Private - get (open) an instance of the receiver."	^super getCurrent		ifNil: 			[self flushAllCaches.			nil]</body></methods><methods><class-id>External.OLEDLL class</class-id> <category>opening</category><body package="Com- Ole">open	"Open the OLE Dll and set it up. This will return nil if something fails"	| instance |	instance := self basicNew initialize.	^(instance setUp: COMSystem current desiredMode)		ifTrue: [instance]		ifFalse: [nil]</body></methods><methods><class-id>External.COMUnicodeStringPointerResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Ole">getResultValue	" Private - convert the contents into a String.  Release the external COM memory.  Answer the string. "	| lpString aString |	( lpString := buffer contents ) isNull		 ifTrue: [ ^nil ].	aString := COMExternalInterface stringFromUnicodePointer: lpString.	( COMMemoryAddress fromPointer: lpString ) free.	^aString</body></methods><methods><class-id>External.COMInterfacePointerArrayResultBuffer</class-id> <category>private-accessing</category><body package="Com- Ole">iid: anIID	" Private - specify the IID to apply to the interface pointer which is instantiated from the buffer contents. "	iid := anIID.</body><body package="Com- Ole">interfaceDescription	" Private "	^iid isNil		ifTrue: [ interfacePointerClass name ]		ifFalse: [ interfacePointerClass name, ' ', iid asString ]</body><body package="Com- Ole">interfacePointerClass: anInterfacePointerClass	" Private - specify the interface pointer class to instantiate from the buffer contents. "	interfacePointerClass := anInterfacePointerClass.</body></methods><methods><class-id>External.COMInterfacePointerArrayResultBuffer</class-id> <category>accessing</category><body package="Com- Ole">atAllPut: aValue 	"Put &lt;aValue&gt; in every element of the receiver's buffer."	self shouldNotImplement.</body></methods><methods><class-id>External.COMInterfacePointerArrayResultBuffer</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream	" Append a text representation of the receiver to &lt;aStream&gt;. "	super printOn: aStream.	interfacePointerClass notNil		ifTrue: [ 			aStream nextPutAll: ' ('.			buffer isNil  " already brought result value back in "				ifTrue: [ value printOn: aStream ]				ifFalse: [ aStream nextPutAll: 'for ', self interfaceDescription ].			aStream nextPutAll: ')' ].</body></methods><methods><class-id>External.COMInterfacePointerArrayResultBuffer</class-id> <category>subclass-operation</category><body package="Com- Ole">getResultValuesFrom: startIndex to: stopIndex 	" Private - convert the contents into a array.  Answer the array. "	| nValues anArray lplpInterfacePointer lpInterfacePointer |	buffer isPointer ifFalse: [self error: (#actionNotImplemented &lt;&lt; #dialogs &gt;&gt; 'action not yet implemented')].	" believe this is not gonna be polymorphic, sigh [DL 11-May-97] "	nValues := stopIndex - startIndex + 1.	anArray := Array new: nValues.	lplpInterfacePointer := buffer copy.	startIndex &gt; 1 ifTrue: [lplpInterfacePointer += (startIndex - 1)].	1 to: nValues		do: 			[:i | 			| anInterfacePointer |			lpInterfacePointer := lplpInterfacePointer contents.			anInterfacePointer := lpInterfacePointer isNull 						ifTrue: [nil]						ifFalse: 							[iid isNil 								ifTrue: [interfacePointerClass fromReturnValue: lpInterfacePointer]								ifFalse: [interfacePointerClass fromReturnValue: lpInterfacePointer iid: iid]].	" should not be, but let's be careful out there "			"Assert isTrue: [ anInterfacePointer hasFinalization ]."	" we acquire ownership as resources enter the system here "			anArray at: i put: anInterfacePointer.			lplpInterfacePointer increment].	" To really be correct, we should probably go through the buffer for		everything outside the retrieve range and if it's not a NULL pointer		then release the referenced interface.  But for the moment we only		seem to use this when we're getting everything back, so don't worry		about it.  But leave a boobytrap behind that will alert a developer		who attempts to utilize this partial-retrieval feature that there is		an interface leak until this implementation is enhanced. "	(startIndex = 1 and: [stopIndex = bufferElementCount]) 		ifFalse: 			["... self releaseUnretrievedInterfacePointers..."			COMDevelopmentWarning 				raiseSignal: (#ErrNamedIntLeak &lt;&lt; #com 						&gt;&gt; 'interface leak in &lt;1s&gt; (partial contents retrieved)' 							expandMacrosWith: self class name)].	^anArray</body></methods><methods><class-id>External.COMInterfacePointerArrayResultBuffer class</class-id> <category>instance creation</category><body package="Com- Ole">type: anInterfacePointerClass count: nElements	" Answer a new instance of the receiver with a buffer for &lt;nElements&gt; of &lt;anInterfacePointerClass&gt;. "	^self basicNew		bufferElementType: COMInterfacePointer baseCType;		bufferElementCount: nElements;		interfacePointerClass: anInterfacePointerClass;		initialize;		yourself</body><body package="Com- Ole">type: anInterfacePointerClass iid: anIID count: nElements	" Answer a new instance of the receiver with a buffer for &lt;nElements&gt; of &lt;anInterfacePointerClass&gt;. "	^self basicNew		bufferElementType: COMInterfacePointer baseCType;		bufferElementCount: nElements;		interfacePointerClass: anInterfacePointerClass;		iid: anIID;		initialize;		yourself</body></methods><methods><class-id>External.ILockBytesPointer</class-id> <category>interface operations</category><body package="Com- Ole">LockRegion: offset _: count _: lockType		" Invoke the ILockBytes::LockRegion function.		Raise an exception if an error occurs.  Answer the result code. "	| libOffset cb |	libOffset := Win32LargeInteger fromUnsignedInteger: offset.	cb := Win32LargeInteger fromUnsignedInteger: count.	^self invokeLockRegion: libOffset asStructureParameter		_: cb asStructureParameter		_: lockType</body><body package="Com- Ole">ReadAt: offset _: buffer _: cbBuffer _: resultReference 	" Invoke the ILockBytes:ReadAt function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult ulOffset readBuffer cbReadBuffer cbRead |	ulOffset := Win32LargeInteger fromUnsignedInteger: offset.	buffer isExternalAddress 		ifTrue: [readBuffer := buffer]		ifFalse: 			[buffer class isBits 				ifFalse: 					[COMError 						raiseSignal: (#ErrNamedILockBytesNotByte &lt;&lt; #com 								&gt;&gt; 'ILockBytes buffer not a byte object: &lt;1s&gt;' 									expandMacrosWith: buffer class name)].			"Assert isTrue: [ buffer sizeInBytes = count ]."			buffer isFixedArgument 				ifTrue: [readBuffer := buffer]				ifFalse: 					["Maybe do:					readBuffer := ( Win32ExternalInterface allocateBuffersInFixedSpace						ifTrue: [ buffer class newInFixedSpace: cbBuffer ]						ifFalse: [ buffer class referentType gcMalloc: cbBuffer ].					"					COMError 						raiseSignal: (#ErrNamedILockBytesMem &lt;&lt; #com 								&gt;&gt; 'ILockBytes buffer not in stable memory: &lt;1s&gt;' 									expandMacrosWith: buffer class name)]].	cbReadBuffer := COMExternalInterface scalarResultBufferFor: #ULONG.	hresult := self 				invokeReadAt: ulOffset asStructureParameter				_: readBuffer asPointerParameter				_: cbBuffer				_: cbReadBuffer asPointerParameter.	cbRead := cbReadBuffer contents.	"Assert isTrue: [ cbRead &lt;= cbBuffer ]."	"future:	readBuffer ~~ buffer		ifTrue: [ 			readBuffer copyAt: 0				to: buffer				size: cbRead				startingAt: 1 ].	"	resultReference notNil ifTrue: [resultReference value: cbRead].	"future: ] ensure: [ readBuffer ~~ buffer ifTrue: [ readBuffer free ] ]."	^hresult</body><body package="Com- Ole">SetSize: newSize		" Invoke the ILockBytes::SetSize function.		Raise an exception if an error occurs.  Answer the result code. "	| cb |	cb := Win32LargeInteger fromUnsignedInteger: newSize.	^self invokeSetSize: cb asStructureParameter</body><body package="Com- Ole">Stat: resultReference _: grfStatFlag		" Invoke the ILockBytes::Stat function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMStructure resultValueBufferFor: #STATSTG.	hresult :=  self invokeStat: resultBuffer asPointerParameter		_: grfStatFlag.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">UnlockRegion: offset _: count _: lockType		" Invoke the ILockBytes::UnlockRegion function.		Raise an exception if an error occurs.  Answer the result code. "	| libOffset cb |	libOffset := Win32LargeInteger fromUnsignedInteger: offset.	cb := Win32LargeInteger fromUnsignedInteger: count.	^self  invokeUnlockRegion: libOffset asStructureParameter		_: cb asStructureParameter		_: lockType</body><body package="Com- Ole">WriteAt: offset _: buffer _: count _: resultReference 	" Invoke the ILockBytes::WriteAt function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult ulOffset writeBuffer cbWrittenBuffer |	ulOffset := Win32LargeInteger fromUnsignedInteger: offset.	buffer isExternalAddress 		ifTrue: [writeBuffer := buffer]		ifFalse: 			[buffer class isBits 				ifFalse: 					[COMError 						raiseSignal: (#ErrNamedILockBytesNotByte &lt;&lt; #com 								&gt;&gt; 'ILockBytes buffer not a byte object: &lt;1s&gt;' 									expandMacrosWith: buffer class name)].			"Assert isTrue: [ buffer sizeInBytes = count ]."			buffer isFixedArgument 				ifTrue: [writeBuffer := buffer]				ifFalse: 					["Maybe do:					writeBuffer := ( Win32ExternalInterface allocateBuffersInFixedSpace						ifTrue: [ buffer class newInFixedSpace: cbBuffer ]						ifFalse: [ buffer class referentType gcMalloc: cbBuffer ].					... and set the contents of the write buffer suitably ...					"					COMError 						raiseSignal: (#ErrNamedILockBytesMem &lt;&lt; #com 								&gt;&gt; 'ILockBytes buffer not in stable memory: &lt;1s&gt;' 									expandMacrosWith: buffer class name)]].	resultReference notNil 		ifTrue: 			[cbWrittenBuffer := COMExternalInterface scalarResultBufferFor: #ULONG].	hresult := self 				invokeWriteAt: ulOffset asStructureParameter				_: writeBuffer asPointerParameter				_: count				_: cbWrittenBuffer asPointerParameter.	resultReference notNil 		ifTrue: [resultReference value: cbWrittenBuffer contents].	"future: ] ensure: [ writeBuffer ~~ buffer ifTrue: [ writeBuffer free ] ]."	^hresult</body></methods><methods><class-id>External.ILockBytesPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_ILockBytes.	self updateAndRegister</body></methods><methods><class-id>External.COMSNBBuffer</class-id> <category>subclass-accessing</category><body package="Com- Ole">bufferElementCount	" Private - answer the number of elements in the buffer.  The value represented by a string pointer list buffer is a list of strings, plus a trailing NULL terminator in the SNB block itself. "	^value size + 1  " include NULL terminator for the list "</body></methods><methods><class-id>External.COMSNBBuffer</class-id> <category>subclass-initializing</category><body package="Com- Ole">initializeBuffer	" Private - initialize the contents of the argument buffer with the list of string values. "	" An SNB string name block is a NULL-terminated list of pointers to Unicode strings "	| lpTrailingNULL |	lpTrailingNULL := buffer copy.	lpTrailingNULL += self value size.	lpTrailingNULL contents: 0.   " Trailing NULL pointer "	super initializeBuffer.	"Assert isTrue: [ lpTrailingNULL contents = 0 ]."</body></methods><methods><class-id>External.IPersistStreamPointer</class-id> <category>interface operations</category><body package="Com- Ole">GetSizeMax: resultReference		" Invoke the IPersistStream::GetSizeMax function.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := Win32LargeInteger forUnsignedReturnValue.	hresult := self invokeGetSizeMax: resultBuffer asPointerParameter.	resultReference value: resultBuffer asUnsignedInteger.	^hresult</body><body package="Com- Ole">Load: anIStream		" Invoke the IPersistStream::Load function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeLoad: anIStream asPointerParameter</body><body package="Com- Ole">Save: anIStream _: fClearDirty		" Invoke the IPersistStream::Save function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSave: anIStream asPointerParameter 		_: fClearDirty</body></methods><methods><class-id>External.IPersistStreamPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistStream.	self updateAndRegister</body></methods><methods><class-id>External.IMonikerPointer</class-id> <category>interface operations</category><body package="Com- Ole">BindToObject: aBindContext _: monikerToLeft _: iid _: resultReference		" Invoke the IMoniker::BindToObject function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := self invokeBindToObject: aBindContext asPointerParameter		_: monikerToLeft asPointerParameter		_: iid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">BindToStorage: aBindContext _: monikerToLeft _: iid _: resultReference		" Invoke the IMoniker::BindToStorage function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMInterfacePointer resultValueBufferForIID: iid.	hresult := self invokeBindToStorage: aBindContext asPointerParameter		_: monikerToLeft asPointerParameter		_: iid		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">CommonPrefixWith: aMoniker _: resultReference	" Invoke the IMoniker::BindToStorage function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeCommonPrefixWith: aMoniker asPointerParameter				_: resultBuffer asPointerParameter.	hresult succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult</body><body package="Com- Ole">ComposeWith: monikerToRight _: fOnlyIfNotGeneric _: resultReference		" Invoke the IMoniker::ComposeWith function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeComposeWith: monikerToRight asPointerParameter		_: fOnlyIfNotGeneric		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">Enum: fForward _: resultReference		" Invoke the IMoniker::Enum function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IEnumPointer resultValueBufferForIID: IID_IEnumMoniker.	hresult := self invokeEnum: fForward		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.  " can be NULL if there is nothing to enumerate "	^hresult</body><body package="Com- Ole">GetDisplayName: aBindContext _: monikerToLeft _: resultReference		" Invoke the IMoniker::GetDisplayName function.		Raise an exception if an error occurs.  Answer the result code. "	| resultBuffer hresult |	resultBuffer := COMExternalInterface unicodeResultBuffer.	hresult := self invokeGetDisplayName: aBindContext asPointerParameter		_: monikerToLeft asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">GetTimeOfLastChange: aBindContext _:  monikerToLeft _: resultReference		" Invoke the IMoniker::GetTimeOfLastChange function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMStructure resultValueBufferFor: #FILETIME.	hresult := self invokeGetTimeOfLastChange: aBindContext asPointerParameter		_:  monikerToLeft asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents asTimestamp.	^hresult</body><body package="Com- Ole">Hash: resultReference		" Invoke the IMoniker::Hash function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #DWORD.	hresult := self invokeHash: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">Inverse: resultReference	" Invoke the IMoniker::Inverse function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeInverse: resultBuffer asPointerParameter.	hresult succeeded ifTrue: [resultReference value: resultBuffer contents].	^hresult</body><body package="Com- Ole">IsEqual: aMoniker		" Invoke the IMoniker::RelativePathTo function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeIsEqual: aMoniker asPointerParameter</body><body package="Com- Ole">IsRunning: aBindContext _:  monikerToLeft _: monikerNewlyRunning		" Invoke the IMoniker::IsRunning function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeIsRunning: aBindContext asPointerParameter		_:  monikerToLeft asPointerParameter		_: monikerNewlyRunning asPointerParameter</body><body package="Com- Ole">IsSystemMoniker: resultReference		" Invoke the IMoniker::IsSystemMoniker function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := COMExternalInterface scalarResultBufferFor: #DWORD.	hresult := self invokeIsSystemMoniker: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body><body package="Com- Ole">ParseDisplayName: aBindContext 	_: monikerToLeft 	_: displayName 	_: nCharsConsumedReference 	_: resultReference		" Invoke the IMoniker::ParseDisplayName function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer nCharsConsumedBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	nCharsConsumedBuffer := COMExternalInterface scalarResultBufferFor: #ULONG.	hresult := self invokeParseDisplayName: aBindContext asPointerParameter		_: monikerToLeft asPointerParameter		_: displayName asUnicodeParameter		_: nCharsConsumedBuffer asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	nCharsConsumedReference value: nCharsConsumedBuffer contents.	^hresult</body><body package="Com- Ole">Reduce: aBindContext _: dwReduceHowFar _: monikerToLeft _: resultReference		" Invoke the IMoniker::Reduce function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeReduce: aBindContext asPointerParameter		_: dwReduceHowFar		_: monikerToLeft asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.   " returns NULL if reduced to nothing "	^hresult</body><body package="Com- Ole">RelativePathTo: aMoniker _: resultReference		" Invoke the IMoniker::RelativePathTo function.		Raise an exception if an error occurs.  Answer the result code. "	| hresult resultBuffer |	resultBuffer := IMonikerPointer resultValueBuffer.	hresult := self invokeRelativePathTo: aMoniker asPointerParameter		_: resultBuffer asPointerParameter.	resultReference value: resultBuffer contents.	^hresult</body></methods><methods><class-id>External.IMonikerPointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IMoniker.	self updateAndRegister</body></methods><methods><class-id>External.COMObjectWithInterfaceStorage</class-id> <category>subclass-accessing</category><body package="Com- Ole">getInterfaceForIID: iid	" Private - answer the interface identified by the GUID &lt;iid&gt;.  Answer nil if the requested interface is not supported by the receiver.  This method does not need to be reimplemented by subclasses, which should simply reimplement #createInterfaceForIID:.. "	| anInterface |	anInterface := self interfaces at: iid ifAbsent: [ nil ].	anInterface isNil		ifTrue: [			anInterface := self createInterfaceForIID: iid.			anInterface notNil				ifTrue: [ self registerAllocatedInterface: anInterface iid: iid ] ].	^anInterface</body><body package="Com- Ole">registerAllocatedInterface: anInterface iid: iid	" Private - the interface &lt;anInterface&gt; has been allocated for the receiver.  Register the supported interface in the receiver's table of allocated interfaces. "	self interfaces at: iid put: anInterface.</body></methods><methods><class-id>External.COMObjectWithInterfaceStorage</class-id> <category>subclass-initializing</category><body package="Com- Ole">createInterfaceForIID: iid	" Private - answer a new instance of the interface identified by the GUID &lt;iid&gt; on the receiver.  Answer nil if the interface is not supported.  This method should be reimplemented by subclasses. "	^nil</body><body package="Com- Ole">initialInterfaceAllocationSize	" Private - answer the initial size of the interface storage dictionary.  The value should be the number of interfaces expected to be supported by the receiver during its lifetime.  May be reimplemented by subclasses to optimize instance size. "	^self class initialInterfaceAllocationSize</body><body package="Com- Ole">initializeInterfaces	" Private - Allocate any interfaces which are expected to be required during the object's lifetime.  The inner IUnknown is always allocated.  Allocate the interface storage dictionary.  May be reimplemented by subclasses.  Subclass implementations should invoke the superclass method first, then use the #registerAllocatedInterface:iid: to register any interfaces that are created. "	super initializeInterfaces.	interfaces := Dictionary new.</body></methods><methods><class-id>External.COMObjectWithInterfaceStorage</class-id> <category>subclass-releasing</category><body package="Com- Ole">resetAllocatedInterfaces	" Private - reset the references to the interfaces supported by the receiver.  This method does not need to be reimplemented by subclasses. "	super resetAllocatedInterfaces.	interfaces := nil.</body></methods><methods><class-id>External.COMObjectWithInterfaceStorage</class-id> <category>private-accessing</category><body package="Com- Ole">interfaces	" Private - answer the receiver's interface storage dictionary.  The key is the IID of a supported interface and the value is the instance of that interface supported with the receiver. "	^interfaces</body></methods><methods><class-id>External.COMObjectWithInterfaceStorage</class-id> <category>subclass-enumerating</category><body package="Com- Ole">allocatedInterfacesDo: aOneArgBlock	" Private - enumerate the interfaces supported by the receiver which have been allocated during its lifetime and evaluate &lt;aOneArgBlock&gt; with each.  This method does not need to be reimplemented by subclasses. "	super allocatedInterfacesDo: aOneArgBlock.	self interfaces		ifNotNil: [:aCollection | aCollection do: [:anInterface | aOneArgBlock value: anInterface]]</body></methods><methods><class-id>External.COMObjectWithInterfaceStorage class</class-id> <category>private-instance creation</category><body package="Com- Ole">initialInterfaceAllocationSize	" Private - answer the initial size of the interface storage dictionary.  The value should be the number of interfaces expected to be supported by an instance of the receiver during its lifetime.  May be reimplemented by subclasses to optimize instance size. "	^3</body></methods><methods><class-id>External.IPersistStreamInit</class-id> <category>interface operations</category><body package="Com- Ole">getSizeMax		" Answer the maximum size of the stream needed to save the object. "	| resultReference |	resultReference := nil asValueReference.	interface GetSizeMax: resultReference.	^resultReference value</body><body package="Com- Ole">initNew		" Notify the object that it is being newly created.		Raise an exception if an error occurs.  Answer the result code. "	^interface InitNew</body><body package="Com- Ole">isDirty		" Answer whether the object has been changed since it was last saved. "	^( interface IsDirty ) = S_OK</body><body package="Com- Ole">load: aStream		" Initialize an object previously stored with the Save operation		from the stream &lt;aStream&gt;.		Raise an exception if an error occurs.  Answer the result code. "	^interface Load: aStream</body><body package="Com- Ole">save: aStream		" Save a copy of the object to the stream &lt;aStream&gt; and clear its dirty flag. "	interface Save: aStream _: true.</body><body package="Com- Ole">saveAndLeaveDirty: aStream		" Save a copy of the object to the stream &lt;aStream&gt;.  Do not clear its dirty flag. "	interface Save: aStream _: false.</body></methods><methods><class-id>External.IPersistStreamInit</class-id> <category>testing</category><body package="Com- Ole">usesStream		" Answer whether the receiver operates on an IStream. "	^true</body></methods><methods><class-id>External.IPersistStreamInit</class-id> <category>storing</category><body package="Com- Ole">saveToStream: anIStream        " Save the the receiver to the stream object &lt;anIStream&gt;.         The CLSID and the object's persistent state are stored. "	OLEDLL current OleSaveToStream: self _: anIStream.</body></methods><methods><class-id>External.IPersistStreamInit class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistStreamInit.	self updateAndRegister</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>private accessing</category><body package="Com- Ole">accessLock	^ AccessLock</body><body package="Com- Ole">maximumPoolSize	"return the maximum number of processes/threads kept for subsequent threaded calls"	^1</body><body package="Com- Ole">reservedMTAProcesses	^ ReservedMTAProcesses</body><body package="Com- Ole">reservedSTAProcesses	^ ReservedSTAProcesses</body><body package="Com- Ole">runningProcesses	^RunningProcesses</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>initialize-release</category><body package="Com- Ole">initializeVariables	RunningProcesses := IdentitySet new.	ReservedMTAProcesses := OrderedCollection new.	ReservedSTAProcesses := OrderedCollection new.	MTAFinalizationSemaphore := Semaphore forMutualExclusion.	AccessLock := Semaphore forMutualExclusion.</body><body package="Com- Ole">obsolete	COMSessionManager removeAllActionsWithReceiver: self.	^ super obsolete</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>testing</category><body package="Com- Ole">isActiveProcessAnMTAProcess	^ Processor activeProcess isComMtaProcess</body><body package="Com- Ole">isActiveProcessAnSTAProcess	| process |	process := Processor activeProcess.	^ process isComMtaProcess not and: [ process isAttachedToThread not ].</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>session management</category><body package="Com- Ole">reset	"self reset"	| process |	self accessLock critical: 			[self runningProcesses do: [:each | each kill].			[(process := self getExistingProcessFrom: self reservedMTAProcesses) isNil]				whileFalse: [process kill].			[(process := self getExistingProcessFrom: self reservedSTAProcesses) isNil]				whileFalse: [process kill].			self initializeVariables]</body><body package="Com- Ole">startupImage	self reset.</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>threaded calls</category><body package="Com- Ole">basicPerformInMTA: aBlock	| process |	process := self getNextMTAProcess.	^[process evaluate: aBlock] ensure: [self rescueProcess: process]</body><body package="Com- Ole">basicPerformInSTA: aBlock	"Not really threaded - but ensures to perform the call in a process which is not marked to execute in the MTA.	 Please Make sure not to perform com related threaded C calls inside such a call. Otherwise objects might be created 	 in the wrong thread or the call my fail"	| process |	process := self getNextSTAProcess.	^[process evaluate: aBlock] ensure: [self rescueProcess: process]</body><body package="Com- Ole">performInMTA: aBlock	^self isActiveProcessAnMTAProcess		ifTrue: [aBlock value]		ifFalse: [self basicPerformInMTA: aBlock]</body><body package="Com- Ole">performInSTA: aBlock	^self isActiveProcessAnMTAProcess		ifTrue: [self basicPerformInSTA: aBlock]		ifFalse: 			[Processor activeProcess isAttachedToThread				ifTrue: [self basicPerformInSTA: aBlock]				ifFalse: [aBlock value]]</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>private</category><body package="Com- Ole">addProcess: process toPool: pool	pool size &gt;= self maximumPoolSize		ifTrue: [ process release]		ifFalse: [pool add: process]</body><body package="Com- Ole">addToRunningProcesses: process	self runningProcesses add: process.</body><body package="Com- Ole">getExistingProcessFrom: aPool	^aPool isEmpty ifTrue: [nil] ifFalse: [aPool removeLast]</body><body package="Com- Ole">getNextMTAProcess	| process |	self accessLock critical: 			[process := (self getExistingProcessFrom: self reservedMTAProcesses)						ifNil: [self createNewMTAProcess].			self addToRunningProcesses: process].	^process</body><body package="Com- Ole">getNextSTAProcess	| process |	self accessLock critical: 			[process := (self getExistingProcessFrom: self reservedSTAProcesses)						ifNil: [self createNewSTAProcess].			self addToRunningProcesses: process].	^process</body><body package="Com- Ole">performMTAFinalizationDo: aBlock	"Private - perform the given block as an MTA object finalization operation.	 MTA finalizations are linearized using the MtaFinalizationSemaphore to avoid finalization to	 produce a high cpu load and use up available threads."	^self isActiveProcessAnMTAProcess		ifTrue: [^aBlock value]		ifFalse: [MTAFinalizationSemaphore critical: [self basicPerformInMTA: aBlock]]</body><body package="Com- Ole">rescueProcess: process	self accessLock critical: 			[self runningProcesses remove: process				ifAbsent: 					[^self error: #ProcessIsNotRunning &lt;&lt; #com &gt;&gt; 'The process is not running'].			process isComMtaProcess				ifTrue: [self addProcess: process toPool: self reservedMTAProcesses]				ifFalse: [self addProcess: process toPool: self reservedSTAProcesses]]</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>interface marshaling</category><body package="Com- Ole">marshalToMTA: anInterfacePointer	^GlobalInterfaceTable current marshalToMTA: anInterfacePointer</body><body package="Com- Ole">marshalToSTA: anInterfacePointer	^GlobalInterfaceTable current marshalToSTA: anInterfacePointer</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>private process initialization</category><body package="Com- Ole">createNewMTAProcess	^COMWorkerProcess newMtaProcess</body><body package="Com- Ole">createNewSTAProcess	^COMWorkerProcess newStaProcess</body></methods><methods><class-id>External.COMThreadManager class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	COMSessionManager when: #startupImage send: #startupImage to: self.	self initializeVariables</body></methods><methods><class-id>External.IPersistStoragePointer</class-id> <category>interface operations</category><body package="Com- Ole">InitNew: anIStorage		" Invoke the IPersistStorage::InitNew function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeInitNew: anIStorage asPointerParameter</body><body package="Com- Ole">Load: anIStorage		" Invoke the IPersistStorage::Load function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeLoad: anIStorage asPointerParameter</body><body package="Com- Ole">Save: anIStorage _: fSameAsLoad		" Invoke the IPersistStorage::Save function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSave: anIStorage asPointerParameter		_:  fSameAsLoad</body><body package="Com- Ole">SaveCompleted: anIStorage		" Invoke the IPersistStorage::SaveCompleted function.		Raise an exception if an error occurs.  Answer the result code. "	^self invokeSaveCompleted: anIStorage asPointerParameter</body></methods><methods><class-id>External.IPersistStoragePointer class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IPersistStorage.	self updateAndRegister</body></methods><methods><class-id>External.IRunnableObject</class-id> <category>interface operations</category><body package="Com- Ole">getRunningClass: lpClsid	" Invoke the IRunnableObject::GetRunningClass function. ""**** NOTE: Automatically generated method, requires manual review ****"	^interface GetRunningClass: lpClsid</body><body package="Com- Ole">isRunning	" Invoke the IRunnableObject::IsRunning function. "	^interface IsRunning</body><body package="Com- Ole">lockRunning: fLock with: fLastUnlockCloses	" Invoke the IRunnableObject::LockRunning function. "	^interface LockRunning: fLock _: fLastUnlockCloses</body><body package="Com- Ole">run: pbc	" Invoke the IRunnableObject::Run function. "	^interface Run: pbc</body><body package="Com- Ole">setContainedObject: fContained	" Invoke the IRunnableObject::SetContainedObject function. "	^interface SetContainedObject: fContained</body></methods><methods><class-id>External.IRunnableObject class</class-id> <category>class initialization</category><body package="Com- Ole">initialize	self iid: IID_IRunnableObject.	self updateAndRegister</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>instance creation options</category><body package="Com- Ole">controllingUnknown	^controllingUnknown</body><body package="Com- Ole">controllingUnknown: anObject	controllingUnknown := anObject</body><body package="Com- Ole">iid	^iid</body><body package="Com- Ole">iid: anObject	anObject ifNotNil: [iids := nil].	iid := anObject</body><body package="Com- Ole">iids	^iids</body><body package="Com- Ole">iids: anObject	anObject ifNotNil: [iid := nil].	iids := anObject</body><body package="Com- Ole">licenseKey	^licenseKey</body><body package="Com- Ole">licenseKey: anObject	licenseKey := anObject</body><body package="Com- Ole">threaded	^threaded ifNil: [false]</body><body package="Com- Ole">threaded: anObject	threaded := anObject</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>comparing</category><body package="Com- Ole">= anObject	^clsid = anObject clsid and: 			[context = anObject context and: 					[controllingUnknown = anObject controllingUnknown and: 							[iid = anObject iid and: 									[iids = anObject iids and: 													[licenseKey = anObject licenseKey and: 															[platform = anObject platform and: 																	[serverName = anObject serverName and: 																			[specification = anObject specification and: [threaded = anObject threaded]]]]]]]]]</body><body package="Com- Ole">hash	^clsid hash + context hash + controllingUnknown hash + iid hash		+ iids hash + licenseKey hash		+ platform hash + serverName hash		+ specification hash + threaded hash</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>server options</category><body package="Com- Ole">context	^context</body><body package="Com- Ole">context: anObject	context := anObject</body><body package="Com- Ole">platform	^platform</body><body package="Com- Ole">platform: anObject	platform := anObject</body><body package="Com- Ole">platformContextFlags	platform ifNil: [^ 0].	platform = #win32 ifTrue: [ ^  CLSCTX_ACTIVATE_32_BIT_SERVER].	platform = #win64 ifTrue: [ ^  CLSCTX_ACTIVATE_64_BIT_SERVER].	self error: #UnknownPlatform &lt;&lt; #com &gt;&gt; 'Unknown platform'</body><body package="Com- Ole">serverName	^serverName</body><body package="Com- Ole">serverName: anObject	serverName := anObject</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>automation instance creation options </category><body package="Com- Ole">specification	^specification</body><body package="Com- Ole">specification: anObject	specification := anObject</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>testing</category><body package="Com- Ole">containsLicenseKey	^ licenseKey notNil</body><body package="Com- Ole">hasMultipleIIDs	^ self iids notNil</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>initialize-release</category><body package="Com- Ole">initializeForDispatch	iid := COMConstants.IID_IDispatch.	self context: External.COMConstants.CLSCTX_SERVER.</body><body package="Com- Ole">initializeForVTable	self context: External.COMConstants.CLSCTX_ALL</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>class factory options</category><body package="Com- Ole">clsid	^clsid</body><body package="Com- Ole">clsid: anObject	clsid := anObject</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>applying</category><body package="Com- Ole">applySpecificationOn: aDispatchDriver	self specification		ifNotNil: [:spec | spec applySpecificationOn: aDispatchDriver]</body></methods><methods><class-id>External.COMCreationOptions</class-id> <category>tools</category><body package="Com- Ole">performInCorrectApartment: aBlock	"Perform in MTA if my threaded option is set. Otherwise just perform the block (don't perform in STA)"	^ self threaded		ifTrue: [COMThreadManager performInMTA: aBlock]		ifFalse: [aBlock value].</body></methods><methods><class-id>External.COMCreationOptions class</class-id> <category>instance creation</category><body package="Com- Ole">clsid: aClsid	^ self new		clsid: aClsid;		yourself</body><body package="Com- Ole">clsid: aClsid iid: anIID	^ self new		clsid: aClsid;		iid: anIID;		yourself</body><body package="Com- Ole">clsid: aClsid iid: anIID context: aContext	^(self new)		clsid: aClsid;		iid: anIID;		context: aContext;		yourself</body><body package="Com- Ole">newForDispatch	^ self new initializeForDispatch</body><body package="Com- Ole">newForVTable	^ self new initializeForVTable</body></methods><methods><class-id>External.X86COMInterface class</class-id> <category>accessing</category><body package="Com- Ole">feelsResponsibleForPlatform: platformID	^ 'win32*i386*' match: platformID</body></methods><methods><class-id>Core.Integer</class-id> <category>converting</category><body package="Com- Ole">asHRESULT	^HRESULT newCode: self</body></methods><methods><class-id>Core.Integer</class-id> <category>comparing</category><body package="Com- Ole">equalsHResult: anHResult	^HRESULT equals: anHResult value and: self</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Com- Ole">asGUID		" Answer the GUID specified by the receiver if it is		a syntactically legal string representation of a GUID.		E.g. '{12345678-1234-1234-1234-123456789012}'  "    ^GUID fromString: self</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="Com- Ole">equalsHResult: anHResult	"Only intergers and HResults can be equal to a HResult"	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Com- Ole">isCOMExternalAddress	" Answer whether the receiver is an external memory address which was allocated by a COM memory allocator. "    ^false</body><body package="Com- Ole">isCOMInterface	" Answer whether the receiver is a COM interface. "	^false</body><body package="Com- Ole">isCOMInterfaceBinding	" Answer whether the receiver is a COM interface binding which provides direct access to the raw interface functions of a COM interface. "	^false</body><body package="Com- Ole">isCOMInterfaceImplementation	" Answer whether the receiver is a COM interface implemented in this Smalltalk image. "	^false</body><body package="Com- Ole">isCOMInterfacePointer	" Answer whether the receiver is a COM interface referencing a VTable in external memory. "	^false</body><body package="Com- Ole">isCOMInterfaceReference	" Answer whether the receiver is a COM interface reference which provides civilized protocol to invoke the interface functions of a COM interface. "	^false</body><body package="Com- Ole">isCOMStructure	"Answer &lt;true&gt; if the receiver supports the COMStructure protocol."	^false</body></methods><methods><class-id>External.ExternalProcedure class</class-id> <category>private</category><body package="Com- Ole">handleFrom: anInterfacePointer forVtableIndex: index 		| interfacePointer vtable vtableEntry |	interfacePointer := COMPlatformProvider current interfaceType pointerType newOfAddress: anInterfacePointer asInteger.	vtable := interfacePointer memberAt: #vtablePointer.	vtableEntry := vtable at: index.	^ vtableEntry asInteger</body></methods><methods><class-id>External.ExternalProcedure</class-id> <category>calling</category><body package="Com- Ole">callCOMMethodFor: anInterfacePointer withArguments: argumentArray	| newArgs transformedProcedure realPointer resultType result |	realPointer := anInterfacePointer asPointerParameter.	newArgs := (Array with: realPointer) , argumentArray.	transformedProcedure := self transformedCOMProcedureFor: realPointer				inProcess: Processor activeProcess.	result := transformedProcedure call: newArgs.	resultType := self type resultType baseType.	^(resultType isIntegral and: [resultType isHResult])		ifTrue: [result asHRESULT]		ifFalse: [result]</body><body package="Com- Ole">transformedCOMProcedureFor: anInterfacePointer inProcess: aProcess	| newType newProcedure newHandle |	newType := CProcedureType				resultType: type resultType				argumentTypes: (Array with: CVoidType void pointerType)						, type argumentTypes				argumentNames: (Array with: 'this') , (type argumentNames ifNil: [#()]).	newProcedure := self class name: self name procedureType: newType.	newHandle := self class handleFrom: anInterfacePointer				forVtableIndex: self index.	newProcedure handle: newHandle.	newProcedure owner: COMExternalInterface.	newProcedure type		specifierCallFlags: (self type specifierCallFlagsForCOMCallInProcess: aProcess).	^newProcedure</body></methods><methods><class-id>Core.ByteArray</class-id> <category>converting</category><body package="Com- Ole">asGUID		"Answer the GUID specified by the bytes of the receiver."    ^GUID fromBytes: self copy</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>initialize-release</category><body package="Com- Ole">initializeIfImplemented	(self class includesSelector: #initialize) ifTrue: [self initialize]</body></methods><methods><class-id>Core.Process</class-id> <category>accessing</category><body package="Com- Ole">beComMtaProcess	^ self environment at: #isMTAWorkerProcess put: true.</body><body package="Com- Ole">isComMtaProcess	"Answer if the receiver process is a COM MTA worker process. 	 In this case it is attached to an MTA worker thread."	^(self environment localAt: #isMTAWorkerProcess) notNil</body></methods><methods><class-id>Core.Timestamp</class-id> <category>conversion</category><body package="Com- Ole">asFileTime	" Answer the receiver as a Timestamp. "	^ (COMStructure classForStructureNamed: #FILETIME) fromTimeStamp: self</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>internal environment</category><body package="Com- Ole">registerInternalSystemVar: aName valueBlock: aBlock	^ self internalSystemVars at: (self systemVarNameForName: aName) put: aBlock</body><body package="Com- Ole">unregisterInternalSystemVar: aName 	^ self unregisterInternalSystemVar: aName  ifAbsent: []</body><body package="Com- Ole">unregisterInternalSystemVar: aName ifAbsent: aBlock	^ self internalSystemVars removeKey: (self systemVarNameForName: aName) ifAbsent: aBlock</body></methods><methods><class-id>External.HRESULT class</class-id> <category>description services</category><body package="Com- Ole">description: hresult		" Answer a textual description of the HRESULT value &lt;hresult&gt;. "	^( Win32DynamicLinkLibrary osErrorMessage: hresult ), 		' ( HRESULT ', ( self nameOrHexString: hresult ), ' )'.</body></methods><methods><class-id>External.HRESULT class</class-id> <category>comparing</category><body package="Com- Ole">equals: code1 and: code2	^(self formatHResult: code1) = (self formatHResult: code2)</body></methods><methods><class-id>External.HRESULT class</class-id> <category>testing</category><body package="Com- Ole">failed: hresult        " Answer whether &lt;hresult&gt; is an error return code. "	" #define FAILED(Status) ((HRESULT)(Status)&lt;0) "	"VS brought HRESULT values into the system as unsigned values:	^hresult &gt;= 16r80000000	"	"VW brings HRESULT values into the system as LONG values due to .h decls "	^( self type cast: hresult ) &lt; 0</body></methods><methods><class-id>External.HRESULT class</class-id> <category>private</category><body package="Com- Ole">formatHResult: hresult	^self type cast: hresult</body></methods><methods><class-id>External.HRESULT class</class-id> <category>accessing</category><body package="Com- Ole">getCode: hresult        " Answer the status code field of &lt;hresult&gt;. "	" #define HRESULT_CODE(hr)    ((hr) &amp; 0xFFFF) "	" #define SCODE_CODE(sc)      ((sc) &amp; 0xFFFF) "	^( CIntegerType unsignedLong cast: hresult ) bitAnd: 16rFFFF</body><body package="Com- Ole">getFacility: hresult        " Answer the facility code field of &lt;hresult&gt;. "	" #define HRESULT_FACILITY(hr)  (((hr) &gt;&gt; 16) &amp; 0x1fff) "	" #define SCODE_FACILITY(sc)    (((sc) &gt;&gt; 16) &amp; 0x1fff) "	^( ( CIntegerType unsignedLong cast: hresult ) bitShift: -16 ) bitAnd: 16r1FFF</body><body package="Com- Ole">getSeverity: hresult        " Answer the severity code field of &lt;hresult&gt;. "	" #define HRESULT_SEVERITY(hr)  (((hr) &gt;&gt; 31) &amp; 0x1) "	" #define SCODE_SEVERITY(sc)    (((sc) &gt;&gt; 31) &amp; 0x1) "	^( ( CIntegerType unsignedLong cast: hresult ) bitShift: -31 ) bitAnd: 16r1</body></methods><methods><class-id>External.HRESULT class</class-id> <category>description services</category><body package="Com- Ole">hexStringDescription: anInteger	"  Answer a string containing the hex representation of the HRESULT &lt;anInteger&gt;. "	Tools.Note portingPatch.  " VS prints 16r prefix, but VW does not [DL 31-Jan-96] "	^'16r', ( ( CIntegerType unsignedLong cast: anInteger ) printStringRadix: 16 )</body></methods><methods><class-id>External.HRESULT class</class-id> <category>private</category><body package="Com- Ole">initializeStatusCodesDictionary	| dict |	dict := Dictionary new.	COMStatusCodeConstants		bindingsDo: [:each | 			each value ifNil: [ each reinitializeValue].			dict at: (self formatHResult: each value value) put: each key].	^ StatusCodesDictionary := dict.</body></methods><methods><class-id>External.HRESULT class</class-id> <category>testing</category><body package="Com- Ole">isError: hresult        " Answer whether &lt;hresult&gt; is an error return code. "	" #define IS_ERROR(Status) ((unsigned long)(Status) &gt;&gt; 31 == SEVERITY_ERROR) "	"VS brought HRESULT values into the system as unsigned values:	^hresult &gt;= 16r80000000	"	"VW brings HRESULT values into the system as LONG values due to .h decls "	^( self type cast: hresult ) &lt; 0</body></methods><methods><class-id>External.HRESULT class</class-id> <category>description services</category><body package="Com- Ole">name: anInteger		" Answer the name of the HRESULT value &lt;anInteger&gt;.  		Answer nil if the name is not known. "	^self name: anInteger ifAbsent: [ nil ]</body><body package="Com- Ole">name: anInteger ifAbsent: aBlock	" Answer the name of the HRESULT value &lt;anInteger&gt;.  		Answer the result of evaluating &lt;aBlock&gt; if the name is not known. "	^self statusCodesDictionary at: anInteger ifAbsent: aBlock</body><body package="Com- Ole">nameOrHexString: anInteger	" Answer the name of the HRESULT value &lt;anInteger&gt;.  		Answer the hex representation of the result code if the name is not known. "	^self name: (self formatHResult: anInteger)		ifAbsent: [self hexStringDescription: anInteger]</body></methods><methods><class-id>External.HRESULT class</class-id> <category>instance creation</category><body package="Com- Ole">new        " Disallow the instantiation of HRESULT instances.		This is an abstract class which provides general services.		An HRESULT value is represented as a 32-bit integer. "    ^self shouldNotImplement</body></methods><methods><class-id>External.HRESULT class</class-id> <category>creation</category><body package="Com- Ole">severity: severity facility: facility code: code		" Answer the HRESULT value with the specified values in each field. "	" #define MAKE_HRESULT(sev,fac,code) \		((HRESULT) (((unsigned long)(sev)&lt;&lt;31) | ((unsigned long)(fac)&lt;&lt;16) | ((unsigned long)(code))) ) "	^self type cast: ( ( severity bitShift: 31 ) + ( facility bitShift: 16 ) + code )</body></methods><methods><class-id>External.HRESULT class</class-id> <category>private-accessing</category><body package="Com- Ole">statusCodesDictionary	" Private - answer the status code definition dictionary. "	^StatusCodesDictionary ifNil: [self initializeStatusCodesDictionary]</body></methods><methods><class-id>External.HRESULT class</class-id> <category>testing</category><body package="Com- Ole">succeeded: hresult        " Answer whether &lt;hresult&gt; is a success return code. "	" #define SUCCEEDED(Status) ((HRESULT)(Status) &gt;= 0) "	"VS brought HRESULT values into the system as unsigned values:	^hresult &lt; 16r80000000	"	"VW brings HRESULT values into the system as LONG values due to .h decls "	^( self type cast: hresult asInteger) &gt;= 0</body></methods><methods><class-id>External.HRESULT class</class-id> <category>accessing</category><body package="Com- Ole">type	" Answer the C data type represented by instances of the receiver. "	^COMExternalInterface current HRESULT</body></methods><methods><class-id>External.HRESULT</class-id> <category>comparing</category><body package="Com- Ole">= anHResult	^anHResult equalsHResult: self</body></methods><methods><class-id>External.HRESULT</class-id> <category>converting</category><body package="Com- Ole">asHRESULT	^ self</body><body package="Com- Ole">asInteger	^value</body></methods><methods><class-id>External.HRESULT</class-id> <category>accessing</category><body package="Com- Ole">code	^self class getCode: self value</body><body package="Com- Ole">constant	^self class nameOrHexString: self value</body><body package="Com- Ole">description	^self class description: self value</body></methods><methods><class-id>External.HRESULT</class-id> <category>testing</category><body package="Com- Ole">equalFromInteger: anInteger	^self value = anInteger</body></methods><methods><class-id>External.HRESULT</class-id> <category>comparing</category><body package="Com- Ole">equalsHResult: anHResult	^ self class equals: self value and: anHResult value</body></methods><methods><class-id>External.HRESULT</class-id> <category>accessing</category><body package="Com- Ole">facility	^self class getFacility: self value</body></methods><methods><class-id>External.HRESULT</class-id> <category>testing</category><body package="Com- Ole">failed	^self class failed: self value</body></methods><methods><class-id>External.HRESULT</class-id> <category>comparing</category><body package="Com- Ole">hash	^self value hash</body></methods><methods><class-id>External.HRESULT</class-id> <category>printing</category><body package="Com- Ole">printOn: aStream	aStream nextPutAll: self description</body></methods><methods><class-id>External.HRESULT</class-id> <category>testing</category><body package="Com- Ole">respondsToArithmetic	^ true</body></methods><methods><class-id>External.HRESULT</class-id> <category>accessing</category><body package="Com- Ole">severity	^self class getSeverity: self value</body></methods><methods><class-id>External.HRESULT</class-id> <category>os-printing</category><body package="Com- Ole">store	| s |	s := (String new: 128) writeStream.	s		nextPut: $(;		nextPutAll: self class fullName.	s		nextPutAll: ' newCode: ';		print: self value;		nextPut: $).	^s contents</body></methods><methods><class-id>External.HRESULT</class-id> <category>testing</category><body package="Com- Ole">succeeded	^self class succeeded: self value</body></methods><methods><class-id>External.HRESULT</class-id> <category>accessing</category><body package="Com- Ole">value	^value</body></methods><methods><class-id>Core.CommandLineInterest class</class-id> <category>private</category><body package="Com- Ole">registrationClassesFrom: aStream 	"Answer the classes enabled for COM Automation registration from aStream, or, if none, the default classes enabled and named for registration" 	| names classes |	names := self argumentsFrom: aStream.	names isEmpty 		ifTrue: [names := COMSessionManager classNamesForRegistration].	classes := Set new.	names do: 			[:each | 			(BindingReference pathString: each) 				ifDefinedDo: [:class | classes add: class]].	^classes select: [:class | class respondsTo: #comRegistrationSpec]</body></methods><methods><class-id>External.CPointerType</class-id> <category>converting</category><body package="Com- Ole">coerceForArgument: anObject	"Coerce anObject to an instance of the receiver's type for the purpose of a C procedure call.  Raise an exception if subclasses don't override.  The following coercion rules are used:	0] If the receiver is tagged __fixed then fail if the argument is not already at a fixed address.	1] If the argument is a String, let it pass.	2] If the receiver is a procedure pointer, the argument can be a procedure reference.	3] If the receiver is a void *, the argument cannot be a pointer to a constant.	4] If the receiver is a pointer to a constant, the argument must be a pointer to a constant.	5] If the argument is an array, the receiver can be a pointer to the array's base type.	6] If the argument is nil, answer nil - nil equates to the NULL pointer of any type.	7] If the argument is any non-immediate object, use the object's data pointer as the pointer value.	8] If the argument is tagged as _oopref, allow any non-pointer objects to pass."	self isFixedPointer		ifTrue:			[anObject isFixedArgument				ifFalse:					[^self class invalidArgumentSignal							raiseWith: anObject							errorString: (#errArgumentFixedData &lt;&lt; #external &gt;&gt; 'The argument does not have fixed data')]].	(anObject isNil or: [anObject = 0]) ifTrue: [^nil].	( anObject isFixedArgument)  ifTrue: [ ^ anObject].	(anObject isImmediate		or: [(anObject isKindOf: self defaultDatumClass) and: [anObject isPointer not]])		ifTrue: [^self class invalidArgumentSignal raiseWith: anObject].	(anObject isKindOf: self defaultDatumClass)		ifTrue: [			(referentType = anObject type referentType				or: [(referentType isVoid and: [anObject type referentType isConstant not])				or: [anObject type isArray not or: [anObject type baseArrayType = referentType]]])				ifTrue: [^anObject asPointer]].	(anObject isString		or: [self isOopRef and: [anObject class isBits and: [anObject class isVariable]]])			ifTrue: [^anObject].	^self class invalidArgumentSignal raiseWith: anObject</body></methods><methods><class-id>External.COMSystem class</class-id> <category>error raising</category><body package="Com- Ole">errorUnsupportedMode	^self error: #UnsupportedMode &lt;&lt; #com &gt;&gt; 'Unsupported Mode'</body></methods><methods><class-id>External.COMSystem class</class-id> <category>constants</category><body package="Com- Ole">oleModeConstant	^ #ole</body><body package="Com- Ole">singleThreadedModeConstant	^ #singleThreaded</body><body package="Com- Ole">uninitializedModeConstant	^#uninitialized</body><body package="Com- Ole">validModeNames	^Array with: self oleModeConstant with: self singleThreadedModeConstant</body></methods><methods><class-id>External.COMSystem</class-id> <category>private</category><body package="Com- Ole">desiredMode	^DesiredMode ifNil: [DesiredMode := COMSystem oleModeConstant]</body><body package="Com- Ole">desiredMode: aMode	"private - this method sets the desired OLEDLL mode but does not update the system. 	To modify the current mode, please use #mode: instead."	(self class validModeNames includes: aMode) ifFalse: [^self class errorUnsupportedMode].	DesiredMode := aMode</body></methods><methods><class-id>External.COMSystem</class-id> <category>mode accessing</category><body package="Com- Ole">disableOLEExtensions	"Set COM Mode to single threaded without support for OLE operations"	^self mode: self class singleThreadedModeConstant</body><body package="Com- Ole">enableOLEExtensions	"Set Mode to Single threaded while supporting OLE operations"	^self mode: self class oleModeConstant</body><body package="Com- Ole">mode	^OLEDLL basicCurrent ifNil: [self class uninitializedModeConstant] ifNotNil: [:current | current mode]</body><body package="Com- Ole">mode: aMode	aMode = self mode ifTrue: [^true].	self desiredMode: aMode.	self setUpCOMMode.	^self mode = aMode</body></methods><methods><class-id>External.COMSystem</class-id> <category>testing</category><body package="Com- Ole">runsInOleMode	"if the current library is not nil, the initialization was successful and we run in Ole mode"	^ self mode = self class oleModeConstant</body><body package="Com- Ole">runsInUnInitializedMode	^self mode = self class uninitializedModeConstant</body><body package="Com- Ole">runsSingleThreaded	^ self mode = self class singleThreadedModeConstant</body></methods><methods><class-id>External.COMSystem</class-id> <category>session management</category><body package="Com- Ole">setUpCOMMode	"Setup the OLEDLL mode."	OLEDLL		closeCurrent;		current.</body></methods><methods><class-id>Kernel.SystemError class</class-id> <category>private</category><body package="Com- Ole">errorNameForId: anId	^ ((anId notNil) and: [anId between: 1  and: ( self errorNames size)] )		ifTrue: 	[ self errorNames at: anId ]		ifFalse:	[ 'unknown' ]</body><body package="Com- Ole">errorNames	^ ErrorNames ifNil: [self initializeErrorNames ].</body></methods><methods><class-id>Kernel.SystemError class</class-id> <category>instance creation</category><body package="Com- Ole">id: aNumber parameters: anArray	"self id: 1 parameters: (Array with: 1234)"	| aName param |	aName := self errorNameForId: aNumber.	param := (self isHResultError: aName)				ifTrue: [anArray last]				ifFalse: [anArray].	^self named: aName parameter: param</body></methods><methods><class-id>Kernel.SystemError class</class-id> <category>class initialization</category><body package="Com- Ole">initializeErrorNames	^ ErrorNames := (Array new: 6)		at: 1 put: #'unsupported call';		at: 2 put: #'invalid argument';		at: 3 put: #'exception raised';		at: 4 put: #'hresult error';		at: 5 put: #'io error';		at: 6 put: #'invalid return value';		yourself</body></methods><methods><class-id>Kernel.SystemError class</class-id> <category>private</category><body package="Com- Ole">isHResultError: aName	^aName = #'hresult error'</body></methods><methods><class-id>Kernel.SystemError</class-id> <category>accessing</category><body package="Com- Ole">errorMessageString	^ self name asString, ' ', self parameter printString</body></methods><methods><class-id>Kernel.SystemError</class-id> <category>testing</category><body package="Com- Ole">isHRESULTError		^ self class isHResultError: (self name)</body></methods><methods><class-id>Kernel.SystemError</class-id> <category>accessing</category><body package="Com- Ole">parameter: aParameter	parameter := aParameter</body></methods><methods><class-id>External.GUID class</class-id> <category>external-transformations</category><body package="Com- Ole">baseCType	"Answer the receiver's base type with respect to the external interface C language type machinery."	^COMExternalInterface current GUID</body></methods><methods><class-id>External.GUID class</class-id> <category>instance creation</category><body package="Com- Ole">clsidFromProgID: aString	"Answer a new instance of the receiver that is the CLSID associated with the ProgID &lt;aString&gt; in the registration database."	| resultReference |	resultReference := nil asValueReference.	OLEDLL current CLSIDFromProgID: aString		_: resultReference.	^resultReference value</body><body package="Com- Ole">clsidFromString: aString	"Answer a new instance of the receiver that is the CLSID corresponding to the display string &lt;aString&gt;. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current CLSIDFromString: aString		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.GUID class</class-id> <category>external-transformations</category><body package="Com- Ole">createArrayBuffer: guidList	" Allocate and answer a buffer containing a packed list of the GUID's in &lt;guidList&gt; that can be used as the argument to an external function.  The caller must send #asPointerParameter to the buffer when it is passed as a function argument and ensure that #release is sent to the buffer after the function call is made. "	^COMGUIDArrayBuffer for: guidList"Test case:	| iidList guidListBuffer lpGUID aGUID |	iidList := Array with: IUnknown iid with: IDispatch iid.	guidListBuffer := GUID createArrayBuffer: iidList.	lpGUID := guidListBuffer buffer copy.	1 to: iidList size do: [ :i |		aGUID := ( Smalltalk at: #GUID ) fromPointer: lpGUID.		Screen default ringBell.		Transcript show: 'Got GUID: ', aGUID asString; cr.		Assert isEqual: aGUID to: ( iidList at: i ).		lpGUID increment ].	guidListBuffer release."</body></methods><methods><class-id>External.GUID class</class-id> <category>instance creation</category><body package="Com- Ole">decodeFromLiteralArray: anArray	" Answer a new instance of the receiver containing the dispatch specifications in the literal representation &lt;anArray&gt;. "	^self fromBytes: ( anArray at: 2 )</body><body package="Com- Ole">defineGuid: anArray	| data data4 |	data := COMExternalInterface current GUID gcCalloc.	data		memberAt: #Data1 put: anArray first;		memberAt: #Data2 put: (anArray at: 2);		memberAt: #Data3 put: (anArray at: 3).	data4 := data refMemberAt: #Data4.	(anArray allButFirst: 3)		doWithIndex: [:each :index | data4 at: index - 1 put: each].	^self fromBytes: data contents datum asByteArray</body></methods><methods><class-id>External.GUID class</class-id> <category>external-transformations</category><body package="Com- Ole">fromPointer: aPointer	"Answer an instance of the receiver with appropriate byte size and fill its contents from data at &lt;aPointer&gt;."	| aGUID |	aGUID := self newNullValue.	aPointer copyAt: 0 to: aGUID size: self sizeInBytes startingAt: 1.	^aGUID</body></methods><methods><class-id>External.GUID class</class-id> <category>instance creation</category><body package="Com- Ole">fromString: aString	"Answer a new instance of the receiver which corresponds to the platform string format representation of a GUID in &lt;aString&gt;. "	" GUID fromString: '{12345678-1234-1234-1234-123456789012}' "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current CLSIDFromString: aString		_: resultReference.	^resultReference value</body></methods><methods><class-id>External.GUID class</class-id> <category>accessing</category><body package="Com- Ole">iidFor: aSymbolOrIID	^self iidFor: aSymbolOrIID clsidBlock: nil</body><body package="Com- Ole">iidFor: aSymbolOrIID clsidBlock: aClsidRetrieveBlock	"return the IID for the given symbol or Interface id. 	If a class id of the implementing object is known, it can help to retrieve the iid for a symbol"	aSymbolOrIID isSymbol ifFalse: [^aSymbolOrIID].	"If Com- Automation is loaded, enhanced IID lookup is performed"	^Plugins		performPluginNamed: Plugins enhancedIIDLookUpKey		with: aSymbolOrIID		with: aClsidRetrieveBlock		ifAbsent: [nil]</body></methods><methods><class-id>External.GUID class</class-id> <category>instance creation</category><body package="Com- Ole">iidFromString: aString	" Answer a new instance of the receiver that is the IID corresponding to the display string &lt;aString&gt;. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current IIDFromString: aString		_: resultReference.	^resultReference value</body><body package="Com- Ole">new	"Answer a newly generated GUID guaranteed to be unique across all machines."	| resultReference |	resultReference := nil asValueReference.	OLEDLL current CoCreateGuid: resultReference.	^resultReference value</body></methods><methods><class-id>External.GUID class</class-id> <category>external-transformations</category><body package="Com- Ole">resultValueBuffer	" Answer an object which can be used as a result value buffer to obtain an OUT argument value containing a BSTR string which is realized from an instance of the receiver allocated by the called function in COM task memory.  The caller must send #asPointerParameter to the output value buffer when it is passed as the function argument.  The result value must be extracted from the buffer after the function call by sending #contents to the buffer value. "	^GUIDResultBuffer new</body><body package="Com- Ole">resultValuePointerBuffer	^GUIDPointerResultBuffer new</body></methods><methods><class-id>External.GUID</class-id> <category>comparing</category><body package="Com- Ole">= aGUID	" Answer whether the receiver and &lt;aGUID&gt; are equal. "	^aGUID class = self class and: [ aGUID asByteArray = self asByteArray ]</body></methods><methods><class-id>External.GUID</class-id> <category>converting</category><body package="Com- Ole">asByteArray	"Answer a ByteArray whose contents are the bytes of the receiver."	^( ByteArray new: self size )		replaceBytesFrom: 1 to: self size with: self startingAt: 1;		yourself</body><body package="Com- Ole">asCLSIDString	" Answer the string representation of the receiver CLSID. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current StringFromCLSID: self _: resultReference.	^resultReference value</body><body package="Com- Ole">asGUID	" Answer the GUID represented by the receiver. "	^self</body></methods><methods><class-id>External.GUID</class-id> <category>printing</category><body package="Com- Ole">asHexDescriptionString	" Answer a String representation of the hex bytes of the receiver. "	^self class name, ' ', self hexByteString</body></methods><methods><class-id>External.GUID</class-id> <category>converting</category><body package="Com- Ole">asIIDString	" Answer the string representation of the receiver IID. "	| resultReference |	resultReference := nil asValueReference.	OLEDLL current StringFromIID: self _: resultReference.	^resultReference value</body><body package="Com- Ole">asPointerParameter	"Answer the receiver in a form suitable for passing as a pointer parameter to an external function call."	Tools.Note ISSUE.  " For that matter, this really shouldn't be needed.		GUID parameters should just go straight through		the host binding layer to the external function.  		[DL 22-Jul-96] "	Assert isTrue: [ self isFixedArgument ].	^self</body><body package="Com- Ole">asProgID	" Answer the PROGID associated with the receiver CLSID in the system registry.  Answer nil if the receiver is not a CLSID or is not registered. "	| resultReference |	resultReference := nil asValueReference.	[ OLEDLL current ProgIDFromCLSID: self _: resultReference ]		on: COMError		do: [:ex| ^nil ].	^resultReference value</body><body package="Com- Ole">asString	"Answer the platform String representation of the receiver.E.g, 		'{12345678-1234-1234-1234-123456789012}' 	"	| resultReference |	resultReference := nil asValueReference.	OLEDLL current StringFromGUID2: self		_: resultReference		_: 80.	^resultReference value</body><body package="Com- Ole">asStructureParameter	"The VM can not handle byte objects as structure parameters. Create a new	 CComposite containing the GUID's data"	^CComposite newDatum: (UninterpretedBytes from: self asByteArray)		ofType: COMExternalInterface new _GUID</body><body package="Com- Ole">asText	"Answer a Text whose string is the string representation of the receiver."	^self asString asText</body></methods><methods><class-id>External.GUID</class-id> <category>private-accessing</category><body package="Com- Ole">bytes	" Private - answer the receiver's raw bytes. "	^self</body></methods><methods><class-id>External.GUID</class-id> <category>printing</category><body package="Com- Ole">constantName	"Answer the name of the receiver if it is a defined constant."	| namespace name |	namespace := #{COMConstants} valueOrDo: [^nil].	self = self class newNullValue ifTrue: 		["Special handling required for NULL values with dup constant mappings. "			#(#IID_NULL #CLSID_NULL) do: 				[:cName | 				"Using #localBindingFor: assumes that there are no name spaces that				 exist in COMConstants."				(namespace localBindingFor: cName) == self ifTrue: [^cName asString]].			^nil].	namespace keysAndValuesDo: 		[:key :value | value = self ifTrue: [name := key]].	name notNil ifTrue: 		[(namespace at: name) == self ifTrue: [^name asString].		^name , ' (dup)'].	^nil</body></methods><methods><class-id>External.GUID</class-id> <category>TEMP</category><body package="Com- Ole">creationString	| stream |	stream := ReadWriteStream on: ( String new: 64 ).	stream nextPutAll: '( GUID fromBytes: #[ '.	1 to: self size do: 		[ :index | 		stream nextPutAll: ( ( self at: index ) storeStringRadix: 16 ). 		stream space.		].	stream nextPutAll: ' ] )'.	^stream contents</body></methods><methods><class-id>External.GUID</class-id> <category>comparing</category><body package="Com- Ole">hash	"Answer the integer hash value for the receiver."	^self asByteArray hash</body></methods><methods><class-id>External.GUID</class-id> <category>printing</category><body package="Com- Ole">hexByteString	" Answer a string describing the bytes of the receiver in hexadecimal notation. "	| aStream |	aStream := ReadWriteStream on: String new.	self hexByteStringOn: aStream.	^aStream contents</body><body package="Com- Ole">hexByteStringOn: aStream	" Append a string describing the bytes of the receiver in hexadecimal notation to &lt;aStream&gt;. "	| aByte |	aStream nextPutAll: '#[ '.	1 to: self size do: [ :i |		aByte := self at: i.		aStream nextPutAll: ( aByte &lt;= 8			ifTrue: [ aByte printString ]			ifFalse: [ '16r', ( aByte printStringRadix: 16 ) ] ).		aStream space ].	aStream nextPut: $].</body></methods><methods><class-id>External.GUID</class-id> <category>testing</category><body package="Com- Ole">isOle1Class	" Answer whether the receiver is the CLSID of an OLE1 object. "	^( OLEDLL current CoIsOle1Class: self ) = S_OK</body></methods><methods><class-id>External.GUID</class-id> <category>literal representation</category><body package="Com- Ole">literalArrayEncoding	"Return a literal suitable for reconstituting the receiver."	^Array with: self class name asSymbol with: self asByteArray</body></methods><methods><class-id>External.GUID</class-id> <category>printing</category><body package="Com- Ole">name	" Answer a descriptive name of the receiver if it is a well-known value. "	| name ownerClass |	name := self constantName.	name notNil		ifTrue: [ ^name ].	ownerClass := COMInterface classForIID: self.	ownerClass notNil		ifTrue: [ ^ownerClass name, ' iid' ].	ownerClass := COMObject classForCLSID: self.	ownerClass notNil		ifTrue: [ ^ownerClass name, ' clsid' ].	^nil</body><body package="Com- Ole">printOn: aStream	"Append a text representation of the receiver on &lt;aStream&gt;."	| description |	description := self name.	description isNil		ifTrue: [ description := self class name ].	aStream nextPutAll: description, ' ', 		( [ self asString ]			on: COMError  " was: Error "   " it's really tacky for a printString to ever fail, so bulletproof this guy "			do: [ :ex | ex return: self hexByteString ] ).</body></methods><methods><class-id>External.GUID</class-id> <category>storing</category><body package="Com- Ole">storeOn: aStream        "Append the ASCII representation of the         receiver to aStream from which the         receiver can be reinstantiated."	aStream		nextPutAll: '( ';		nextPutAll: self class fullName;		nextPutAll: ' fromBytes: '.	self hexByteStringOn: aStream.	aStream nextPutAll: ' )'.</body></methods><methods><class-id>External.ExternalStructure</class-id> <category>subclass-releasing</category><body package="Com- Ole">finalizationRegistry	"Private - Answer the WeakRegistry to be used for finalizing instances of the receiver."	" This is a bit odd to map wrapper structures into the address registry, perhaps,		but it's not unreasonable and it does work "	^COMSessionManager ownedMemoryRegistry</body></methods><methods><class-id>Kernel.COMExternalMethod class</class-id> <category>private-calling</category><body package="Com- Ole">call: external from: anInterfacePointer withArgs: arguments onErrorDo: anExceptionBlock	^[external callCOMMethodFor: anInterfacePointer withArguments: arguments]		on: Error		do: [:ex | self handleException: ex with: anExceptionBlock]</body><body package="Com- Ole">callThreaded: external from: anInterfacePointer withArgs: arguments onErrorDo: anExceptionBlock"	OLEDLL runsMultiThreaded		ifFalse: 			[^self error: #MultithreadingRequiredToPerformThreadedCalls &lt;&lt; #com						&gt;&gt; 'Multithreading needs to be enabled to perform threaded calls']."	^	[COMThreadManager performInMTA: 			[external callCOMMethodFor: anInterfacePointer withArguments: arguments]]			on: Error			do: [:ex | self handleException: ex with: anExceptionBlock]</body><body package="Com- Ole">handleException: ex with: anExceptionBlock	((ex isKindOf: ExternalAccessFailed)		and: 			[ex parameter isHRESULTError])				ifTrue: [ex parameter parameter: ex parameter parameter asHRESULT].	^anExceptionBlock value: ex parameter</body></methods><methods><class-id>Kernel.COMExternalMethod class</class-id> <category>initialize-release</category><body package="Com- Ole">installExternalPlugin	"Install the plugin used for computing the external of one of my instances"	Plugins installPluginNamed: Plugins comExternalMethodExternalKey		block: [:method | method basicExternal ifNil: [method computeExternal]]</body><body package="Com- Ole">removeExternalPlugin	"remove the plugin used for computing the external of one of my instances"	Plugins removePluginNamed: Plugins comExternalMethodExternalKey</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>decompilation</category><body package="Com- Ole">argNamesFromExternal	"Get the argument names from the external declaration stored in the method if possible"	| argNames tempExternal |	tempExternal := self external.	^(tempExternal isNil 		or: [(argNames := tempExternal argumentNames) isNil]) 			ifTrue: [nil]			ifFalse: [argNames]</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>calling</category><body package="Com- Ole">callFrom: anInterfacePointer withArgs: arguments onErrorDo: anExceptionBlock	anInterfacePointer isValid ifFalse: [COMError hresult: External.COMStatusCodeConstants.CO_E_RELEASED].	^self class		call: self external		from: anInterfacePointer		withArgs: arguments		onErrorDo: anExceptionBlock</body><body package="Com- Ole">callThreadedFrom: anInterfacePointer withArgs: arguments onErrorDo: anExceptionBlock	^ self class callThreaded: self external from: anInterfacePointer  withArgs: arguments onErrorDo: anExceptionBlock</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>private</category><body package="Com- Ole">computeExternal	| vtable anExternal |	anExternal := ((vtable := self mclass vtableDescription) isNil				or: [vtable size &lt; (handle + 1)])					ifTrue: [self rebuildExternalDeclaration]					ifFalse: [self externalDeclarationFor: (vtable at: handle + 1)].	self external: anExternal.	^anExternal</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>decompilation</category><body package="Com- Ole">externalArgNames: names 	"get the external declaration while replacing it's argument names with the specified ones.	 This is used for decompilation"	^self external ifNotNil:[:anExternal |			anExternal 				argumentNames: names;				yourself]</body><body package="Com- Ole">externalAttributeMessages	"Get the external attribute message which will be temporarily added to attribute messages of the method		 for rebuilding the COM: pragma"	"self externalArgNames: names."	^self attributeMessages</body><body package="Com- Ole">externalAttributeMessagesArgNames: names 	"Get the external attribute message which will be temporarily added to attribute messages of the method		 for rebuilding the COM: pragma"	self externalArgNames: names.	^ self attributeMessages</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>accessing</category><body package="Com- Ole">externalDeclaration	^ self external</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>private external declaration creation</category><body package="Com- Ole">externalDeclarationFor: anEntryPointDescription 	"Build an external declaration from a COMEntryPointDescription."	| procType |	procType := anEntryPointDescription signatureType copy.	^ExternalProcedure 		name: anEntryPointDescription name		procedureType: procType		index: anEntryPointDescription vtableIndex</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>initialize-release</category><body package="Com- Ole">generateExternal	| newExternal |	newExternal := self external.	self external: newExternal.	^ newExternal notNil</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>testing</category><body package="Com- Ole">matchesVTableEntry: anotherMethod	handle = anotherMethod handle ifFalse: [ ^ false ].	(argumentKinds = anotherMethod argumentKinds) ifFalse: [^ false ].	self external name = anotherMethod external name ifFalse: [ ^ false ].	"Seems to be the same method"	^ true</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>private external declaration creation</category><body package="Com- Ole">rebuildExternalDeclaration	"Try to rebuild the external declaration of the method just from the information contained in itself, the argumentkinds, the return type and	 the given argument names"	^ExternalProcedure 		name: self supposedEntryPointname		resultType: resultType		argumentKinds: (argumentKinds copyFrom: 3 to: argumentKinds size) asArray		specifierFlags: specifierFlags		index: handle</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>accessing</category><body package="Com- Ole">returnKind	"Answer the first element of the argumentKinds which is the kind of the returnValue"	^argumentKinds first</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>private external declaration creation</category><body package="Com- Ole">supposedEntryPointname	"Guess the name of the entry point, since it is not stored in the method,	 which doesn't matter since VTable functions are accessed using the vtable index"	| name |	name := self selector readStream upTo: $:.	(name size &gt; 6 and: [(name copyFrom: 1 to: 6) = 'invoke']) 		ifTrue: [name := name copyFrom: 7 to: name size].	^name isEmpty 		ifTrue: ['DummyName']		ifFalse: 			[name at: 1 put: name first asUppercase.			name]</body></methods><methods><class-id>External.CProcedureType</class-id> <category>accessing-compilation</category><body package="Com- Ole">specifierCallFlagsForCOMCallInProcess: aProcess	"Answer a set of flags that indicate various bits of information about the receiver.  The layout of the specifierFlags word is as follows:	Bit		Meaning	0		use _far calling convention.	1		use C calling convention.	2		use Pascal calling convention.	3		is a long computation (_longcomp) procedure	4		is reentrant (not _nocallback)	5		is __cdecl calling convention	6		is _threaded non-blocking call mechanism"	| flags |	flags := 0.	self isFar ifTrue: [flags := 16r1].	self isCdecl ifTrue: [flags := flags bitOr: 16r2].	self isPascal ifTrue: [flags := flags bitOr: 16r4].	self isLongcomp ifTrue: [flags := flags bitOr: 16r8].	self isNotPermittingCallbacks not ifTrue: [flags := flags bitOr: 16r10].	self isStdcall ifTrue: [flags := flags bitOr: 16r20].	aProcess isComMtaProcess		ifTrue: [flags := flags bitOr: 16r40].	^flags</body></methods><initialize><class-id>External.COMInterfacePointer</class-id></initialize><initialize><class-id>External.IUnknownPointer</class-id></initialize><initialize><class-id>External.IPersistPointer</class-id></initialize><initialize><class-id>External.IRunningObjectTablePointer</class-id></initialize><initialize><class-id>External.COMInterface</class-id></initialize><initialize><class-id>External.IUnknown</class-id></initialize><initialize><class-id>External.COMStorageElementInterface</class-id></initialize><initialize><class-id>External.IStream</class-id></initialize><initialize><class-id>External.COM_FILETIME</class-id></initialize><initialize><class-id>External.IPersist</class-id></initialize><initialize><class-id>External.IPersistStream</class-id></initialize><initialize><class-id>External.IMoniker</class-id></initialize><initialize><class-id>External.COM_OLEVERB</class-id></initialize><initialize><class-id>External.IGlobalInterfaceTable</class-id></initialize><initialize><class-id>External.IAdviseSink</class-id></initialize><initialize><class-id>External.IAdviseSink2</class-id></initialize><initialize><class-id>External.COM_STATDATA</class-id></initialize><initialize><class-id>External.COMInterfaceImplementation</class-id></initialize><initialize><class-id>External.IUnknownImplementation</class-id></initialize><initialize><class-id>External.IRunnableObjectImplementation</class-id></initialize><initialize><class-id>External.IPersistFile</class-id></initialize><initialize><class-id>External.IPersistImplementation</class-id></initialize><initialize><class-id>External.IPersistStreamImplementation</class-id></initialize><initialize><class-id>External.COM_DVTARGETDEVICE</class-id></initialize><initialize><class-id>External.IRootStorage</class-id></initialize><initialize><class-id>External.IClassFactory</class-id></initialize><initialize><class-id>External.IDataObjectPointer</class-id></initialize><initialize><class-id>External.GlobalInterfaceTable</class-id></initialize><initialize><class-id>External.COM_FORMATETC</class-id></initialize><initialize><class-id>External.IAnonymousPointer</class-id></initialize><initialize><class-id>External.IStreamPointer</class-id></initialize><initialize><class-id>External.COMDataRendering</class-id></initialize><initialize><class-id>External.COMGlobalMemoryStream</class-id></initialize><initialize><class-id>External.ILockBytes</class-id></initialize><initialize><class-id>External.IDataObject</class-id></initialize><initialize><class-id>External.IDataObjectImplementation</class-id></initialize><initialize><class-id>External.IMallocPointer</class-id></initialize><initialize><class-id>External.IStoragePointer</class-id></initialize><initialize><class-id>External.COMSessionManager</class-id></initialize><initialize><class-id>External.IClassFactoryImplementation</class-id></initialize><initialize><class-id>External.IRootStoragePointer</class-id></initialize><initialize><class-id>External.IStorage</class-id></initialize><initialize><class-id>External.COMGlobalMemoryStorage</class-id></initialize><initialize><class-id>External.COM_OBJECTDESCRIPTOR</class-id></initialize><initialize><class-id>External.IAnonymous</class-id></initialize><initialize><class-id>External.IDataAdviseHolder</class-id></initialize><initialize><class-id>External.COMPlatformProvider</class-id></initialize><initialize><class-id>External.IAdviseSinkImplementation</class-id></initialize><initialize><class-id>External.IBindCtxPointer</class-id></initialize><initialize><class-id>External.IEnumPointer</class-id></initialize><initialize><class-id>External.IPersistStorageImplementation</class-id></initialize><initialize><class-id>External.COMClassFactoryObject</class-id></initialize><initialize><class-id>External.IEnum</class-id></initialize><initialize><class-id>External.IUnknownInnerImplementation</class-id></initialize><initialize><class-id>External.COMInterfaceVTableSignatures</class-id></initialize><initialize><class-id>External.IBindCtx</class-id></initialize><initialize><class-id>External.IClassFactoryPointer</class-id></initialize><initialize><class-id>External.IAdviseSinkPointer</class-id></initialize><initialize><class-id>External.IAdviseSink2Pointer</class-id></initialize><initialize><class-id>External.COM_STATSTG</class-id></initialize><initialize><class-id>External.IPersistFileImplementation</class-id></initialize><initialize><class-id>External.IGlobalInterfaceTableImplementation</class-id></initialize><initialize><class-id>External.IParseDisplayNamePointer</class-id></initialize><initialize><class-id>External.IGlobalInterfaceTablePointer</class-id></initialize><initialize><class-id>External.IParseDisplayNameImplementation</class-id></initialize><initialize><class-id>External.COMCompoundFile</class-id></initialize><initialize><class-id>External.IRunnableObjectPointer</class-id></initialize><initialize><class-id>External.IParseDisplayName</class-id></initialize><initialize><class-id>External.IEnumImplementation</class-id></initialize><initialize><class-id>External.IDataAdviseHolderPointer</class-id></initialize><initialize><class-id>External.IPersistStreamInitPointer</class-id></initialize><initialize><class-id>External.COM_STGMEDIUM</class-id></initialize><initialize><class-id>External.IPersistStorage</class-id></initialize><initialize><class-id>External.IRunningObjectTable</class-id></initialize><initialize><class-id>External.IPersistFilePointer</class-id></initialize><initialize><class-id>External.IMalloc</class-id></initialize><initialize><class-id>External.OLEDLL</class-id></initialize><initialize><class-id>External.ILockBytesPointer</class-id></initialize><initialize><class-id>External.IPersistStreamPointer</class-id></initialize><initialize><class-id>External.IMonikerPointer</class-id></initialize><initialize><class-id>External.IPersistStreamInit</class-id></initialize><initialize><class-id>External.COMThreadManager</class-id></initialize><initialize><class-id>External.IPersistStoragePointer</class-id></initialize><initialize><class-id>External.IRunnableObject</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ExternalProcedure</name><environment>External</environment><super>External.ExternalObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>COMExternalMethod</name><environment>Kernel</environment><super>Kernel.AnnotatedMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>handle specifierFlags argumentKinds structArgSize structReturnSize datumClass resultType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- ExtensionsToBase</package></attributes></class><class><name>ExternalStructure</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structure memberNames protocolMap </inst-vars><class-inst-vars>structureName </class-inst-vars><imports></imports><category>External-Data-Extensions</category><attributes><package>Com- External Data Enhancements</package></attributes></class><class><name>SystemError</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parameter name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Support</category><attributes><package>Kernel-Support</package></attributes></class><class><name>Win32ArgumentBuffer</name><environment>External</environment><super>External.Win32Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><class><name>Win32UnicodePointerListBuffer</name><environment>External</environment><super>External.Win32StringPointerListBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><class><name>ExternalStream</name><environment>OS</environment><super>Core.PositionableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Streaming</category><attributes><package>OS-Streaming</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Win32ResultValueBuffer</name><environment>External</environment><super>External.Win32Buffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><class><name>Timestamp</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>year month day hours minutes seconds milliseconds partialNanosecond </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>ValueReference</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><class><name>Win32Structure</name><environment>External</environment><super>External.ExternalStructure</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Binding Framework</category><attributes><package>Com- Win32</package></attributes></class><class><name>HRESULT</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- ExtensionsToBase</package></attributes></class><class><name>Win32PointerResultValueBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><class><name>Win32UnicodeStringPointerResultBuffer</name><environment>External</environment><super>External.Win32PointerResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><class><name>Process</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>suspendedContext priority myList systemRecords interruptProtect environment isSystem name debugger locale </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>Win32ArrayResultBuffer</name><environment>External</environment><super>External.Win32ResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bufferElementType bufferElementCount </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><class><name>ByteArray</name><environment>Core</environment><super>Core.IntegerArray</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>Win32StructurePointerResultBuffer</name><environment>External</environment><super>External.Win32PointerResultValueBuffer</super><private>false</private><indexed-type>none</indexed-type><inst-vars>structureType structureClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OS-Win32 Host Bindings</category><attributes><package>Com- Win32</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CPointerType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>none</indexed-type><inst-vars>referentType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>ExternalDecompiler</name><environment>Kernel</environment><super>Kernel.Decompiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM- Decompiler</category><attributes><package>DLLCC-Decompiler</package></attributes></class><class><name>CProcedureType</name><environment>External</environment><super>External.CType</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>argumentNames </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>Win32ExternalInterface</name><environment>External</environment><super>External.ExternalInterface</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports>			private External.Win32NLSConstants.*			private External.Win32ExternalInterfaceDictionary.*			</imports><category>OS-Win32 Host Binding Framework</category><attributes><includeFiles></includeFiles><includeDirectories></includeDirectories><libraryFiles></libraryFiles><libraryDirectories></libraryDirectories><beVirtual>false</beVirtual><optimizationLevel>full</optimizationLevel><package>Com- Win32</package></attributes></class><class><name>COMSystem</name><environment>External</environment><super>Core.Subsystem</super><private>false</private><indexed-type>none</indexed-type><inst-vars>deferredActions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- System Configuration Services</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>ExternalAccessFailed</name><environment>External</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Types</category><attributes><package>External-Types</package></attributes></class><class><name>GUID</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			External.COMStatusCodeConstants.*			External.COMConstants.*			</imports><category>COM-COM Support</category><attributes><package>Com- Ole Pools</package></attributes></class><class><name>UserNotification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Win32MemoryAddress</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>pointer </inst-vars><class-inst-vars></class-inst-vars><imports>			External.Win32Constants.*			</imports><category>OS-Win32 Interface</category><attributes><package>Com- Win32</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Notification</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>