<?xml version="1.0"?><st-source><!-- Name: Com- ExtensionsToBaseNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: This parcel contains base class extensions (new methods in existing classes) used in COM codeDbIdentifier: bear73DbTrace: 464069DbUsername: aaugustinDbVersion: 8.1 - 2DevelopmentPrerequisites: #(#(#any 'Com- CodeAnnotations' '') #(#any 'DLLCC' '') #(#any 'DLLCC-Decompiler' '') #(#any 'Com- Automation Pools' '') #(#any 'Com- System Configuration Services' ''))DialectVersion: VisualWorks 7.9PackageName: Com- ExtensionsToBaseParcel: #('ComExtensionsToBase')ParcelName: Com- ExtensionsToBasePrerequisiteDescriptions: #(#(#name 'Com- CodeAnnotations') #(#name 'DLLCC') #(#name 'DLLCC-Decompiler' #componentType #package) #(#name 'Com- Automation Pools' #componentType #package) #(#name 'Com- System Configuration Services' #componentType #package))PrerequisiteParcels: #(#('Com- CodeAnnotations' '') #('DLLCC' '') #('DLLCC-Decompiler' '') #('Com- Automation Pools' '') #('Com- System Configuration Services' ''))PrintStringCache: (8.1 - 2,aaugustin)Version: 8.1 - 2Date: 1:50:01 PM April 12, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (apr17.1) of 7. April 2017 on 12. April 2017 at 13:50:01</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>COMExternalMethod</name><environment>Kernel</environment><super>Kernel.AnnotatedMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>handle specifierFlags argumentKinds structArgSize structReturnSize datumClass resultType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- ExtensionsToBase</package></attributes></class><class><name>LiteralArrayEncoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- ExtensionsToBase</package></attributes></class><comment><class-id>LiteralArrayEncoder</class-id><body>LiteralArrayEncoder is used to generalize literal array encoding for several objects. The objects need to implement- #literallyEncodedAttributes (instance)	 returning a collection of accessor names used to retrieve attributes which shal be put into the literal array.	 It is assumed that the write acessors is the same as the read accessor followed by a colon.- #literalArrayEncoding (instance) 	usually just needs to contain "^ LiteralArrayEncoder encode: self"- #decodeFromLiteralArray: (class) 	usually just needs to contain "^ LiteralArrayEncoder decode: &lt;theArray&gt;"The rest will usually be done by the encoder.</body></comment><class><name>COMParser</name><environment>External</environment><super>Kernel.ExtendedParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-Host Binding Framework</category><attributes><package>Com- ExtensionsToBase</package></attributes></class><class><name>HRESULT</name><environment>External</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>COM-COM Support</category><attributes><package>Com- ExtensionsToBase</package></attributes></class><comment><class-id>External.HRESULT</class-id><body>The HRESULT class is an abstract class which provides utility services for HRESULT status values.</body></comment><class><name>Plugins</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- ExtensionsToBase</package></attributes></class><class><name>UnInitializedValue</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Com- ExtensionsToBase</package></attributes></class><comment><class-id>Core.UnInitializedValue</class-id><body>UnInitializedValue is a class which can be used for variables which are initialized lazy but may contain nil even after the initialization, e.g. in case an object does not have a specific property. Inspite of trying to initialize it again and again, we initialize the variable with the singleton instance of this class on creation of the containing object and can ask it if it has already been initializied before returing in the accessor method.</body></comment><shared-variable><name>StatusCodesDictionary</name><environment>External.HRESULT</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Com- ExtensionsToBase</package></attributes></shared-variable><shared-variable><name>PluginBlocks</name><environment>Core.Plugins</environment><private>false</private><constant>false</constant><category>plugin support</category><initializer>IdentityDictionary new</initializer><attributes><package>Com- ExtensionsToBase</package></attributes></shared-variable><shared-variable><name>VWSystemVars</name><environment>Kernel.SystemUtils</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer></initializer><attributes><package>Com- ExtensionsToBase</package></attributes></shared-variable><methods><class-id>Kernel.COMExternalMethod</class-id> <category>accessing</category><body package="Com- ExtensionsToBase">argumentKinds	"Answer an Array of Integers where each integer is an identifier indicating the return type and the argument types of the external code.  These tags are well-known by the run-time system."	^argumentKinds</body><body package="Com- ExtensionsToBase">attributeAt: key ifAbsent: exceptionBlock	attributes isNil ifTrue: [ attributes := #() ].	^super attributeAt: key ifAbsent: exceptionBlock</body><body package="Com- ExtensionsToBase">attributeMessages	attributes isNil ifTrue: [ attributes := #() ].	^ super attributeMessages</body><body package="Com- ExtensionsToBase">attributes	"Answer the receiver's attribute dictionary. If no attributes are defined, answer nil."	attributes isNil ifTrue: [ attributes := #() ].	^ super attributes</body><body package="Com- ExtensionsToBase">datumClass	"Answer the datum class used to create instances of the receiver's return type."	^datumClass</body><body package="Com- ExtensionsToBase">external	^Plugins		performPluginNamed: Plugins comExternalMethodExternalKey		with: self		ifAbsent: [self basicExternal]</body><body package="Com- ExtensionsToBase">external: anObject		self externalAttributeMessage		ifNil:			[self attributeMessages: (self attributeMessages 				copyWith: (Message selector: #COM: argument: anObject))]		ifNotNil: [:message | message setSelector: message selector arguments:  (Array with: anObject)]</body><body package="Com- ExtensionsToBase">handle	"Answer the external code handle that represents the external code location for a particular platform."	^handle</body><body package="Com- ExtensionsToBase">owner	"Anser the receiver's owner -- this is typically the class that defined the receiver."	self mclass isMeta		ifTrue: [^self mclass soleInstance]		ifFalse: [^self mclass]</body><body package="Com- ExtensionsToBase">referentAddress	"Answer the receiver referent address."	^self handle</body><body package="Com- ExtensionsToBase">resultType	"Answer a type object that represents the return type of the receiver's external code."	^resultType</body><body package="Com- ExtensionsToBase">specifierFlags	"Answer the flags that indicate various attributes about the external code."	^specifierFlags</body><body package="Com- ExtensionsToBase">structArgSize	"Answer an Integer indicating the total number of bytes of composite arguments passed by value to the receiver's external code."	^structArgSize</body><body package="Com- ExtensionsToBase">structReturnSize	"Answer the size in bytes of the structure return by value.  If the receive does not return a structure by value, answer zero."	^structReturnSize</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>initialize-release</category><body package="Com- ExtensionsToBase">for: anExternalAssociation selector: aSelector	"Initialize the receiver to be a method for the given external and the given method selector.  Answer the receiver."	| externalType  newExternal |	newExternal := anExternalAssociation value.	self external: newExternal.	newExternal isNil ifTrue: [^self].	handle := self class handleFromByteArray: newExternal referentAddress.	externalType := newExternal type.	specifierFlags := externalType specifierCallFlags.	argumentKinds := self class argumentKindsFrom: externalType argumentKinds.	structArgSize := externalType structArgumentSize.	resultType := externalType resultType.	datumClass := resultType defaultContainerClass.	self computeStructReturnSize.	^self</body><body package="Com- ExtensionsToBase">releaseHandle	"Reset the receiver's handle to indicate an unlinked state."	"The receiver's handle is unique across space-time."	^self</body><body package="Com- ExtensionsToBase">updateLayoutCache	"Update the cached information stored in the receiver's external."	self computeStructReturnSize</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>private</category><body package="Com- ExtensionsToBase">basicExternal		^self externalAttributeMessage		ifNil: [nil]		ifNotNil: [:message | message arguments first]</body><body package="Com- ExtensionsToBase">computeStructReturnSize	"Compute the receiver's return type sizer."	resultType isComposite		ifTrue: [structReturnSize := resultType dataSize]		ifFalse: [structReturnSize := 0]</body><body package="Com- ExtensionsToBase">copyStateFromOldVersion: oldMethod	"This message is sent by CodeRegenerator to a newly generated method, to allow the method to copy over the source pointer and any other information that the CodeRegenerator would not know how to preserve."	super copyStateFromOldVersion: oldMethod.	handle := oldMethod handle.	specifierFlags := oldMethod specifierFlags.	argumentKinds := oldMethod argumentKinds.	structArgSize := oldMethod structArgSize.	structReturnSize := oldMethod structReturnSize.	datumClass := oldMethod datumClass.	resultType := oldMethod resultType</body><body package="Com- ExtensionsToBase">externalAttributeMessage	^ self attributeMessages 			detect: [:message | (message selector = #COM:) ]			ifNone: [nil]</body></methods><methods><class-id>Kernel.COMExternalMethod</class-id> <category>testing</category><body package="Com- ExtensionsToBase">isExternalMethod	"Answer whether this is an external method or not."	^true</body></methods><methods><class-id>Kernel.COMExternalMethod class</class-id> <category>private-accessing</category><body package="Com- ExtensionsToBase">argumentKindsFrom: aTags	"Set the receiver's argument tag array to be that the argument tags. The implicit receiver-as-first-argument must be inserted into the tag array. Answer the new tag array."	| bTags |	bTags := aTags class new: aTags size + 1.	bTags		at: 1 put: (aTags at: 1);		at: 2 put: self receiverPointerKind.	bTags replaceFrom: 3 to: bTags size with: aTags startingAt: 2.	^bTags</body><body package="Com- ExtensionsToBase">handleFromByteArray: aByteArray 	"Answer a valid external heap handle for the sequence of bytes contained in the argument. The handle consists of the same bit pattern as the byte array. The argument must be an object that answers 8-bit values at each index."	| shift aHandle size |	shift := (size := aByteArray size) * 8.	size = 0 		ifTrue: [self error: #ErrInvalidMethodOffset &lt;&lt; #com &gt;&gt; 'Invalid COM method offset.'].	aHandle := 0.	1 to: size		do: [:i | aHandle := aHandle + ((aByteArray at: i) bitShift: (shift := shift - 8))].	^aHandle</body></methods><methods><class-id>Kernel.COMExternalMethod class</class-id> <category>private-calling</category><body package="Com- ExtensionsToBase">receiverPointerKind	"Answer the kind of pointer the receiver represents. Please consult the documentation for CPointerType for further information on pointer kinds. The kind answered by this method is well-known to the run-time system."	^CPointerType pointer32Kind</body></methods><methods><class-id>Kernel.COMExternalMethod class</class-id> <category>instance creation</category><body package="Com- ExtensionsToBase">bytes: b literals: l numArgs: na numTemps: nt maxDepth: m needsFrame: nf hybrid: hf forContext: cf		^(super bytes: b literals: l numArgs: na numTemps: nt maxDepth: m		needsFrame: nf hybrid: hf forContext: cf)		attributeMessages: #();		yourself</body></methods><methods><class-id>Kernel.COMExternalMethod class</class-id> <category>accessing</category><body package="Com- ExtensionsToBase">comNonThreadedCalloutSelector	"return the selector in myself (instance side) which will be sent to call a com method"	^ #callFrom:withArgs:onErrorDo:</body><body package="Com- ExtensionsToBase">comThreadedCalloutSelector	"return the selector in myself (instance side) which will be sent to call a threaded com method"	^#callThreadedFrom:withArgs:onErrorDo:</body></methods><methods><class-id>LiteralArrayEncoder class</class-id> <category>private decoding</category><body package="Com- ExtensionsToBase">decodeAttributesFrom: anArray on: instance	| value aName |	2 to: anArray size - 1 by: 2 do: [:index |		aName := anArray at: index. 		value := self decodeValue: (anArray at: index + 1).		self setAttribute: aName in: instance to: value].</body><body package="Com- ExtensionsToBase">decodeValue: aLiteralValue	^ (aLiteralValue class = Array)		ifTrue: [ self decodeValueFromLiteralArray: aLiteralValue  ]		ifFalse: [ aLiteralValue decodeAsLiteralArray ]</body><body package="Com- ExtensionsToBase">decodeValueFromLiteralArray: aLiteralArray	^aLiteralArray isEmpty		ifTrue: [#()]		ifFalse: 			[aLiteralArray first isSymbol				ifTrue: [aLiteralArray decodeAsLiteralArray]				ifFalse: [self decodeValuesFromLiteralArray: aLiteralArray]]</body><body package="Com- ExtensionsToBase">decodeValuesFromLiteralArray: anArray	^anArray collect: [:each | each decodeAsLiteralArray]</body></methods><methods><class-id>LiteralArrayEncoder class</class-id> <category>private encoding</category><body package="Com- ExtensionsToBase">literalEncode: aMember of: anObject on: aCollection at: aPosition	aCollection		at: aPosition put: aMember asSymbol;		at: aPosition + 1 put: (anObject perform: aMember asGetter) literalArrayEncoding</body><body package="Com- ExtensionsToBase">literalEncodeAttributes: members of: anObject on: aLiteralArray	members doWithIndex: 			[:each :index |			self				literalEncode: each				of: anObject				on: aLiteralArray				at: index * 2]</body><body package="Com- ExtensionsToBase">nonEmptyAttributesFor: anObject 		^ anObject literallyEncodedAttributes select: [:item | (self getAttribute: item from: anObject) notNil ]</body></methods><methods><class-id>LiteralArrayEncoder class</class-id> <category>decoding</category><body package="Com- ExtensionsToBase">decode: anArray	| class instance |	class := anArray first asQualifiedReference value.	instance := class basicNew.	self decodeAttributesFrom: anArray on: instance.	^ instance</body></methods><methods><class-id>LiteralArrayEncoder class</class-id> <category>encoding</category><body package="Com- ExtensionsToBase">encode: anObject	| aCollection |		aCollection := Array new: (self nonEmptyAttributesFor: anObject) size * 2 + 1.	self encode: anObject on: aCollection.	^aCollection</body><body package="Com- ExtensionsToBase">encode: anObject on: anArray	anArray at: 1 put: anObject class fullyQualifiedReference asSymbol.	self		literalEncodeAttributes: (self nonEmptyAttributesFor: anObject)		of: anObject		on: anArray</body></methods><methods><class-id>LiteralArrayEncoder class</class-id> <category>private accessing objects</category><body package="Com- ExtensionsToBase">getAttribute: aSymbol from: anObject	^ anObject perform: aSymbol asGetter</body><body package="Com- ExtensionsToBase">setAttribute: aName in: anObject to: value	anObject perform: aName asSetter with: value</body></methods><methods><class-id>External.COMParser</class-id> <category>public access</category><body package="Com- ExtensionsToBase">parseExternalDeclaration: sourceStream class: class  context: ctxt	notifying: req builder: aBuilder ifFail: aBlock	"Answer with a parse tree.  noPattern is true for doIts (Compiler evaluate)."	| meth |	targetClass := class.	self		init: sourceStream		notifying: req		saveComments: false		failBlock: [^aBlock value].	builder := aBuilder.	failBlock := aBlock.	requestor := req.	meth := self method: false context: ctxt.	builder := failBlock := requestor := parseNode := nil. "break cycles &amp; mitigate refct overflow"	^meth</body></methods><methods><class-id>External.COMParser</class-id> <category>method</category><body package="Com- ExtensionsToBase">getPatternFromDoIt: fromDoIt context: ctxt	^ fromDoIt			ifTrue: 				[ctxt == nil					ifTrue: [Array with: #DoIt with: #()]					ifFalse:						[Array							with: #DoItIn: 							with: (Array with: (builder newParameterVariable:												(builder newVariableName: 'DOITCONTEXT')))]]			ifFalse:				[self pattern].</body><body package="Com- ExtensionsToBase">getTemporaries	^ tokenType == #verticalBar		ifTrue: [self temporaries]		ifFalse:			[newLanguage				ifTrue: [nil]				ifFalse: [#()]].</body><body package="Com- ExtensionsToBase">method: fromDoIt context: ctxt	"pattern [ | temporaries ] block =&gt; MethodNode"	| start pat block  messageComment methodNode tempNodes externalCallStream externalCallStatements statementNodes |	start := mark.	pat := self getPatternFromDoIt: fromDoIt context: ctxt.	"pat={selector, arguments}"	messageComment := currentComment.	currentComment := nil.	"Parse temporaries before primitive, to allow for old language."	methodNode := builder newMethodSelector: (pat at: 1).	tempNodes := self getTemporaries.	(fromDoIt not and: [self matchToken: #&lt;])		ifTrue:			["First try external declaration"			| argNames |			argNames := (pat at:2) collect: [:arg | arg name].			externalCallStream := [self externalCallWithArguments: argNames exceptParamName: 'exceptBlock']									on: Object errorSignal									do: [:ex | ^self notify: (ex messageText size &gt; 0																ifTrue: ['syntax error, ', ex messageText]																ifFalse: ['syntax error'])].			externalCallStream notNil				ifTrue:					[ | oldSource  |					oldSource := source.					self scan: externalCallStream.						self readStandardPragmas: methodNode temps: tempNodes.						externalCallStatements := self statements.					self scan: oldSource.					tempNodes := self temporaries]				ifFalse: 					["Now try regular primitive"					self privateReadStandardPragmas: methodNode temps: tempNodes]].	self statementsArgs: (pat at: 2) temps: tempNodes statements: statementNodes.	block := (externalCallStatements isNil) 				ifTrue: 	[ parseNode]				ifFalse:	[	self restructParseTree: parseNode forExternalCall: externalCallStatements exceptBlockName: 'exceptBlock'. ].	tokenType == #doIt ifFalse: [^self expected: 'Nothing more'].	methodNode block: block.	methodNode addComment: messageComment.	methodNode sourcePosition: (start to: self endOfLastToken).	^methodNode</body></methods><methods><class-id>External.COMParser</class-id> <category>As yet unclassified</category><body package="Com- ExtensionsToBase">restructParseTree: blockNode forExternalCall: externalCallStatements exceptBlockName: exceptBlockName	| exceptBlock newMethodBlock args |	exceptBlock := builder newBlockArguments: 			(Array with: (builder newParameterVariable: (builder newVariableName: '_errorCode')))			body: blockNode body.	newMethodBlock := builder newBlockArguments: (blockNode arguments)			body: (builder newSequenceStatements: externalCallStatements).	"get the messageNode from the returnNode and replace the exceptParam with the exceptBlock"	args := externalCallStatements first value arguments.	args keysAndValuesDo: [:index :anArg |			((anArg isKindOf: VariableNode) and: [ anArg name = exceptBlockName ])			 	ifTrue: [ args at: index put: exceptBlock ] ].	^ newMethodBlock</body></methods><methods><class-id>External.COMParser</class-id> <category>externals</category><body package="Com- ExtensionsToBase">externalCallWithArguments: argNames exceptParamName: exceptName	"Generate an external language declaration using the external function argument names indicated by the argument.  Answer nil if the generation failed, otherwise answer a Stream containing the contents of the external declaration.	Generate the call stream which has an additional exceptName parameter which will be replaced later."	"Currently only &lt;COM: &gt; syntax is supported."	ExternalInterface externalCompilerClass isNil ifTrue:		[(requestor isKindOf: SilentCompilerErrorHandler)			ifTrue: [self skipPrimitive. ^'' readStream] "doing explain"			ifFalse: [^ExternalInterface externalCompilerMissingError]].	^ ( self matchToken: 'COM:' ) 		ifTrue: [ self externalComCallWithArguments: argNames exceptParamName: exceptName] 	      ifFalse: [ self error: #OnlyCOMPragmaSupported &lt;&lt; #com &gt;&gt;'Only COM: pragma supported' ].</body><body package="Com- ExtensionsToBase">externalComCallWithArguments: argNames exceptParamName: exceptName	"Invoke a CParser on source, which parses a C declaration until and including the $&gt; token.  Set the source pointer back to the point right after this token for subsequent parsing of the failure code by self (the Smalltalk parser).  Generate and return Smalltalk code (as a stream) that calls the C function, to be subsequently parsed by self.  argNames, the method's arguments, are used as arguments for the C call."	| interfaceClass assignedName |	self resetSourceToLastToken.	interfaceClass := self interfaceClass.	externals := interfaceClass tempExternals.	external := self parseDefineOrSingleDeclaration: externals.	(external isKindOf: Association)		ifTrue: 			[assignedName := external key.			external := external value].	external owner: interfaceClass.	interfaceClass isVirtual ifTrue: [external virtuals: #()].	^external		comCallStreamArgs: argNames		assign: assignedName		exceptParamName: exceptName</body></methods><methods><class-id>External.HRESULT</class-id> <category>accessing</category><body package="Com- ExtensionsToBase">value: anObject	value := anObject</body></methods><methods><class-id>External.HRESULT</class-id> <category>testing</category><body package="Com- ExtensionsToBase">isHResult	^ true</body></methods><methods><class-id>External.HRESULT</class-id> <category>converting</category><body package="Com- ExtensionsToBase">comVariantType	^ External.COMAutomationConstants.VT_HRESULT</body></methods><methods><class-id>External.HRESULT class</class-id> <category>instance creation</category><body package="Com- ExtensionsToBase">newCode: aCode	"self newCode: DISP_E_BADINDEX"	^(self basicNew)		value: aCode;		yourself</body></methods><methods><class-id>Core.Plugins class</class-id> <category>known plugins</category><body package="Com- ExtensionsToBase">comExternalMethodExternalKey	^ #COMExternalMethodExternal</body><body package="Com- ExtensionsToBase">enhancedIIDLookUpKey	^#enhancedIIDLookUp</body><body package="Com- ExtensionsToBase">installTracingKey	^#installTracing</body><body package="Com- ExtensionsToBase">reportExternalFunctionEntryKey	^ #reportExternalFunctionEntry</body><body package="Com- ExtensionsToBase">reportExternalFunctionInvalidArgExitKey	^#reportExternalFunctionInvalidArgExit</body><body package="Com- ExtensionsToBase">reportInvalidExternalArgKey	^ #reportInvalidExternalArg</body></methods><methods><class-id>Core.Plugins class</class-id> <category>plugin support</category><body package="Com- ExtensionsToBase">hasPlugin: aSymbol	^ self pluginBlocks includesKey: aSymbol</body><body package="Com- ExtensionsToBase">installPluginNamed: aSymbol block: aBlock 	self pluginBlocks at: aSymbol put: aBlock.</body><body package="Com- ExtensionsToBase">performPluginNamed: aSymbol  ifAbsent: aBlock	^ self performPluginNamed: aSymbol withArguments: #() ifAbsent: aBlock</body><body package="Com- ExtensionsToBase">performPluginNamed: aSymbol with: anArgument ifAbsent: aBlock	^self		performPluginNamed: aSymbol		withArguments: (Array with: anArgument)		ifAbsent: aBlock</body><body package="Com- ExtensionsToBase">performPluginNamed: aSymbol with: arg1 with: arg2 ifAbsent: aBlock	^self		performPluginNamed: aSymbol		withArguments: (Array with: arg1 with: arg2)		ifAbsent: aBlock</body><body package="Com- ExtensionsToBase">performPluginNamed: aSymbol with: arg1 with: arg2 with: arg3 ifAbsent: aBlock	^self		performPluginNamed: aSymbol		withArguments: (Array with: arg1 with: arg2 with: arg3)		ifAbsent: aBlock</body><body package="Com- ExtensionsToBase">performPluginNamed: aSymbol withArguments: args ifAbsent: aBlock	| pluginBlock |	pluginBlock := self pluginBlocks at: aSymbol ifAbsent: [^aBlock value].	^pluginBlock cullWithArguments: args</body><body package="Com- ExtensionsToBase">removePluginNamed: aSymbol	self pluginBlocks removeKey: aSymbol ifAbsent: []</body></methods><methods><class-id>Core.Plugins class</class-id> <category>private-plugin support</category><body package="Com- ExtensionsToBase">pluginBlocks	^ PluginBlocks</body></methods><methods><class-id>Core.UnInitializedValue</class-id> <category>testing</category><body package="Com- ExtensionsToBase">ifUnInitializedDo: aBlock elseDo: anotherBlock	^aBlock value</body><body package="Com- ExtensionsToBase">isUnInitialized	^true</body></methods><methods><class-id>Core.UnInitializedValue class</class-id> <category>instance creation</category><body package="Com- ExtensionsToBase">any	^ self new</body></methods><methods><class-id>Core.Object class</class-id> <category>literal representation</category><body package="Com- ExtensionsToBase">literallyEncodedAttributes	"return the names of instance variables which will be included in the literall representation"	^ #()</body></methods><methods><class-id>Core.Object</class-id> <category>notices</category><body package="Com- ExtensionsToBase">callIndicatesChangeNeeded	| message |	message := #CallsIndicateNeedToChangeImplementation &lt;&lt; #com				&gt;&gt; 'Calls to this method indicate a need to change the implementation'.	ImageConfiguration isDevelopment		ifTrue: 			[Transcript				show: message;				cr.			Dialog warn: message]</body><body package="Com- ExtensionsToBase">callIsDispensable	Transcript		show: (#CallsToThisMethodsAreDispensable &lt;&lt; #com					&gt;&gt; 'Sends of #''&lt;1s&gt;'' to &lt;2s&gt; are dispensable'						expandMacrosWith: thisContext sender selector with: thisContext sender receiver class name);		cr</body><body package="Com- ExtensionsToBase">enforceInvalidation	^ self invalidate</body><body package="Com- ExtensionsToBase">enforceRelease	^ self release</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Com- ExtensionsToBase">ifUnInitializedDo: aBlock	^self ifUnInitializedDo: aBlock elseDo: [self]</body><body package="Com- ExtensionsToBase">ifUnInitializedDo: aBlock elseDo: anotherBlock	^anotherBlock value</body></methods><methods><class-id>Core.Object</class-id> <category>notices</category><body package="Com- ExtensionsToBase">invalidate	^ self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="Com- ExtensionsToBase">isHResult	^false</body><body package="Com- ExtensionsToBase">isStringOrUserMessage	"Quick hack to get i18n to work for now for COM."	^false</body><body package="Com- ExtensionsToBase">isUnInitialized	^ false</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Com- ExtensionsToBase">asArrayOfSubstrings              "Answer an array of substrings from the receiver. The receiver        is divided into substrings by one or more occurrences of space characters."	^self asArrayOfSubstringsSeparatedBy: Character space</body><body package="Com- ExtensionsToBase">asArrayOfSubstringsSeparatedBy: aCharacter        "Answer an array of substrings from the receiver. The receiver        is divided into substrings by one or more occurrences of &lt;aCharacter&gt;."    | answer startIndex stopIndex size |    answer := OrderedCollection new.    startIndex := 1.    size := self size.    [ startIndex &lt;= size ] whileTrue: [        [ startIndex &lt;= size and: [ ( self at: startIndex ) = aCharacter ] ]            whileTrue: [ startIndex := startIndex + 1 ].        stopIndex := startIndex.        [ stopIndex &lt;= size and: [ ( self at: stopIndex ) ~= aCharacter ] ]            whileTrue: [ stopIndex := stopIndex + 1 ].        stopIndex &gt; startIndex            ifTrue: [ answer add: ( self copyFrom: startIndex to: stopIndex - 1 ) ].        startIndex := stopIndex ].    ^answer asArray</body><body package="Com- ExtensionsToBase">asSelector	| newString char |	self isEmpty ifTrue: [^self].	newString := self copy. 	1 to: self size		do: 			[:index |			char := self at: index.			char isUppercase				ifTrue: [newString at: index put: char asLowercase]				ifFalse: [^newString]].	^newString</body><body package="Com- ExtensionsToBase">capitalized	| newString |	self isEmpty ifTrue: [^self].	newString := self copy.	newString at: 1 put: self first asUppercase.	^newString</body></methods><methods><class-id>Core.String</class-id> <category>testing</category><body package="Com- ExtensionsToBase">isStringOrUserMessage	"Quick hack to get i18n to work for now for COM."	^true</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="Com- ExtensionsToBase">startingWithLowercaseLetter	| copy |	self isEmpty ifTrue: [^ self ].	self first isAlphabetic ifFalse: [ ^ self ].	copy := self copy.	copy at: 1 put: copy first asLowercase.	^ copy</body><body package="Com- ExtensionsToBase">startingWithUppercaseLetter	| copy |	self isEmpty ifTrue: [^ self ].	self first isAlphabetic ifFalse: [ ^ self ].	copy := self copy.	copy at: 1 put: copy first asUppercase.	^ copy</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="Com- ExtensionsToBase">elementsEqual: otherCollection	"Answer &lt;true&gt; if the elements of the receiver and the &lt;otherCollection&gt; are equal."	self size = otherCollection size		ifFalse: [^false].	self		do:			[:each |			(otherCollection includes: each)				ifFalse: [^false]].	^true</body></methods><methods><class-id>External.ExternalProcedure class</class-id> <category>instance creation</category><body package="Com- ExtensionsToBase">name: aName procedureType: procType index: index 	^(self new)		name: aName;		type: procType;		index: index;		yourself</body></methods><methods><class-id>External.ExternalProcedure</class-id> <category>code generating</category><body package="Com- ExtensionsToBase">comArgCreationStringFor: anArgNameArray	| size aString |	(anArgNameArray isEmpty)	ifTrue: [ 		^ '#()' ].	((size := anArgNameArray size) &lt;= 4) ifTrue: [ 		aString := '(Array'.		anArgNameArray keysAndValuesDo: [:index :aName |			aString := aString, ' with: ',aName asString  ].		^ aString, ')' ].		aString := '((Array new: ',size printString,')'.	anArgNameArray keysAndValuesDo: [:index :aName |				aString := aString, ' at: ', index printString , ' put: ', aName asString , ';'. ].	^ aString, ' yourself)'.</body><body package="Com- ExtensionsToBase">comCallStreamArgs: argNames assign: assignee exceptParamName: exceptName	"Answer a stream containing expressions used to evaluate the receiver within the interface aClass."	(self type isVarArg or: 			[assignee notNil or: 					[self type argumentNames notNil and: [argNames ~= self type argumentNames]]])		ifTrue: 			[^self error: #InvalidMethodSyntax &lt;&lt; #com &gt;&gt; 'Invalid method syntax.'].	^self		comCallStreamArgs: argNames		exceptParamName: exceptName		threaded: self type isThreadedCall</body><body package="Com- ExtensionsToBase">comCallStreamArgs: argNames exceptParamName: exceptName threaded: threaded	"Answer a stream containing expressions for optimized invocation of a COM interface function."	| nArgs stream selector |	nArgs := self type argumentTypes size.	(self type argumentNames size ~~ nArgs and: [argNames size ~~ nArgs])		ifTrue: [self error: #ErrWrongArgSize &lt;&lt; #com &gt;&gt; 'wrong number of arguments'].	stream := String new writeStream.	selector := threaded				ifTrue: [COMExternalMethod comThreadedCalloutSelector]				ifFalse: [COMExternalMethod comNonThreadedCalloutSelector].	"The first three arguments are the keyword of the selector. the 4th argument is the string containing the argument names and	 the last argument is the name of the exceptionBlock which will be substituted later"	stream nextPutAll: ('^ thisContext method &lt;1s&gt; self &lt;2s&gt; &lt;4s&gt; &lt;3s&gt; &lt;5s&gt;'				expandMacrosWithArguments: selector keywords						, (Array with: (self comArgCreationStringFor: argNames) with: exceptName)).	^ReadStream on: stream contents</body></methods><methods><class-id>Core.KeyedCollection</class-id> <category>accessing</category><body package="Com- ExtensionsToBase">keyAtValueEqual: value 	"Answer the key whose value equals the argument, value.  If there is none,	raise a signal."	^self keyAtValueEqual: value ifAbsent: [self valueNotFoundError: value]</body><body package="Com- ExtensionsToBase">keyAtValueEqual: value ifAbsent: exceptionBlock	"Answer the key whose value is equal to the argument, value.  	If there is none, answer the result of evaluating exceptionBlock." 	self keysAndValuesDo: 		[:aKey :aValue | value = aValue ifTrue: [^aKey]].	^exceptionBlock value</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>bit manipulation</category><body package="Com- ExtensionsToBase">| anInteger        "Answer an Integer representing the receiver bits ORed with        the argument anInteger."    &lt;primitive: 15&gt;    ^anInteger | self</body></methods><methods><class-id>Core.LargeInteger</class-id> <category>bit manipulation</category><body package="Com- ExtensionsToBase">| anInteger        "Answer an Integer representing the receiver bits ORed with        the argument anInteger."    ^self bitOr: anInteger</body></methods><methods><class-id>Core.Symbol</class-id> <category>converting</category><body package="Com- ExtensionsToBase">asGetter	^(self last: 1) = ':' ifTrue: [(self allButLast: 1) asSymbol] ifFalse: [self]</body><body package="Com- ExtensionsToBase">asSetter	^(self last: 1) = ':' ifTrue: [self] ifFalse: [(self , ':') asSymbol]</body><body package="Com- ExtensionsToBase">capitalized	| newString |	self isEmpty ifTrue: [^self].	newString := self asString.	newString at: 1 put: self first asUppercase.	^newString asSymbol</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="Com- ExtensionsToBase">keyAtValueEqual: value	"Answer the key whose value equals the argument &lt;value&gt;.  If there is none,	raise a signal."	^self keyAtValueEqual: value ifAbsent: [ self valueNotFoundError: value ]</body><body package="Com- ExtensionsToBase">keyAtValueEqual: value ifAbsent: exceptionBlock	"Answer the key whose value is identical to the argument &lt;value&gt;.  	If there is none, answer the result of evaluating exceptionBlock."	self keysAndValuesDo: 		[:aKey :aValue | value = aValue ifTrue: [^aKey]].	^exceptionBlock value</body></methods><methods><class-id>Core.MessageSend class</class-id> <category>instance creation</category><body package="Com- ExtensionsToBase">forReceiver: anObject selector: aSymbol	" Answer a new instance of the receiver which has a correctly size empty arguments array so that it can evaluated by #evaluateWithArguments:. "	" This is a workaround to avoid modifying #receiver:selector: in the base VW 2.5 system.  That implementation should be modifed when opportunity permits. "	^self new setReceiver: anObject 		selector: aSymbol 		arguments: ( Array new: aSymbol numArgs )</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>accessing</category><body package="Com- ExtensionsToBase">getEnvironmentVariable: varName 	"Get an environment variable's value from the OS. This has different 	 meanings on different platforms. On Windows NT and Windows 95, 	 environment variables are first looked-up in the registry, and subsequently	 in the C environment. On Windows 3.1, they are looked-up in a VISWORKS.INI	 file and subsequently in the C environment.. On Unix, the C environment	 variables are  used. 		 If the variable does not exist in the environment, answer the empty string."	"^OSSystemSupport concreteClass new getVariable: varName"	^ self internalSystemVarNamed: varName ifAbsent: [		OSSystemSupport concreteClass new			getVariable: varName ]</body><body package="Com- ExtensionsToBase">getEnvironmentVariable: varName ifAbsent: errorBlock	"Get an environment variable's value from the OS. This has different 	 meanings on different platforms. On Windows NT and Windows 95, 	 environment variables are first looked-up in the registry, and subsequently	 in the C environment. On Windows 3.1, they are looked-up in a VISWORKS.INI	 file and subsequently in the C environment.. On Unix, the C environment	 variables are  used. 		 If the variable does not exist in the environment, answer the empty string."	^  self internalSystemVarNamed: varName ifAbsent: [		OSSystemSupport concreteClass new getVariable: varName ifAbsent: errorBlock ]</body></methods><methods><class-id>Kernel.SystemUtils class</class-id> <category>internal environment</category><body package="Com- ExtensionsToBase">internalSystemVarNamed: aName ifAbsent: aBlock	^ (self internalSystemVars at: (self systemVarNameForName: aName) ifAbsent: [ aBlock ]) value</body><body package="Com- ExtensionsToBase">internalSystemVars	^ (VWSystemVars isNil)		ifTrue: 	[ VWSystemVars := Dictionary new]		ifFalse: 	[ VWSystemVars ]</body><body package="Com- ExtensionsToBase">systemVarNameForName: aStringOrSymbol	^ aStringOrSymbol asLowercase asSymbol</body></methods><methods><class-id>Kernel.UserMessage</class-id> <category>testing</category><body package="Com- ExtensionsToBase">isStringOrUserMessage	"Quick hack to get i18n to work for now for COM."	^true</body></methods><methods><class-id>Core.IdentityDictionary</class-id> <category>accessing</category><body package="Com- ExtensionsToBase">keyAtValueEqual: value ifAbsent: exceptionBlock	"Answer the key whose value is identical to the argument &lt;value&gt;.  	If there is none, answer the result of evaluating exceptionBlock."	| theKey |	1 to: self basicSize do:		[:index |		value = (valueArray at: index)			ifTrue:				[(theKey := self basicAt: index) == nil					ifFalse: [^theKey]]].	^exceptionBlock value</body></methods><methods><class-id>Kernel.Context</class-id> <category>copying</category><body package="Com- ExtensionsToBase">copyStackToDepth: depth	" Answer a copy of the top &lt;depth&gt; contexts on the stack containing the receiver. "	^self copy		sender: ( ( depth &lt;= 1 or: [ sender == nil ] ) 			ifFalse: [ sender copyStackToDepth: depth - 1 ] );		yourself	"thisContext copyStackToDepth: 5"</body></methods><methods><class-id>Core.Array</class-id> <category>accessing</category><body package="Com- ExtensionsToBase">at: anInteger ifAbsent: aBlock        "Answer the object in the receiver at index position         anInteger.  If anInteger is greater than the size         of the receiver or smaller than one, answer the result of evaluating aBlock. "    ^ (anInteger &lt;= self size and: [ anInteger &gt; 0 ])        ifTrue: [ self at: anInteger ]        ifFalse: [ aBlock value ]</body></methods><methods><class-id>Tools.ListIconLibrary class</class-id> <category>resources</category><body package="Com- ExtensionsToBase">com16x16	"UIMaskEditor new openOnClass: self andSelector: #com16x16"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5718 5718 5718)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6167 6167 6167)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(6553 6553 6553)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4304 4304 4304)) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 4112)) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[68 68 68 68 68 68 68 68 68 68 68 64 0 0 4 4 68 68 68 4 68 68 68 68 68 68 64 64 51 51 49 68 68 68 2 2 83 51 85 20 68 64 32 37 37 85 64 68 68 2 4 2 82 0 4 4 68 0 68 64 32 68 68 68 68 68 68 68 4 68 68 68 68 68 68 68 68 68 68 68 68 102 70 102 70 70 68 68 68 100 70 70 70 102 68 68 68 100 70 70 70 70 68 68 68 102 70 102 70 70 68 68 68 68 68 68 68 68 68 68 68 68 68 68 68 68 68 68])</body><body package="Com- ExtensionsToBase">com16x16mask	"UIMaskEditor new openOnClass: self andSelector: #com16x16mask"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 16@16 depth: 1 bitsPerPixel: 1 palette: CoveragePalette monoMaskPalette usingBits: #[0 0 0 0 1 254 0 0 3 254 0 0 5 254 0 0 15 254 0 0 31 254 0 0 59 250 0 0 49 192 0 0 0 128 0 0 0 0 0 0 55 80 0 0 37 112 0 0 37 80 0 0 55 80 0 0 0 0 0 0 0 0 0 0])</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>KeyedCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>LargeInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>AnnotatedMethod</name><environment>Kernel</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>attributes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ExternalProcedure</name><environment>External</environment><super>External.ExternalObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>External-Interface</category><attributes><package>External-Interface</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>ExtendedParser</name><environment>Kernel</environment><super>Kernel.Parser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>externals external </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>DLLCC-Parsing</category><attributes><package>DLLCC</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>UserMessage</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>defaultString key catalogID </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Internationalization</category><attributes><package>UIBasics-Internationalization</package></attributes></class><class><name>IdentityDictionary</name><environment>Core</environment><super>Core.Dictionary</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>valueArray </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>