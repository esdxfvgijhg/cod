<?xml version="1.0"?><st-source><!-- Name: Xtreams-SubstreamsNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: Substreams are streams embedded in other streams. Often there are multiple substreams embedded sequentially in a parent stream (for example multipart MIME messages). This package allows efficient handling of common types of substreams.	=== Fixed size substreams (#limiting:) ===Limiting substream starts at the position when the substream is created and ends when the specified number of elements is read or written.{{{	('abcdefghijklmno' reading limiting: 10) rest}}}{{{	| stream substream |	stream := String new writing.	substream := stream limiting: 5.	[ substream write: 'Hello World!' ] on: Incomplete do: [].	stream conclusion}}}	=== Bounded substreams (#ending:/#ending:inclusive:) ===Bounded substream ends when the argument matches the content passing through the stream. The argument can take one of the following forms:  * a block - evaluated with each element; the stream ends when the block returns true{{{	('abcdefghijklmnopqrstuvxyz' reading ending: [ :e | 'gmt' includes: e ]) rest.}}}{{{	| stream substream |	stream := String new writing.	substream := stream ending: [ :e | 'gmt' includes: e ].	[ substream write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].	stream conclusion}}}  * a collection - matched against the matching amount of last elements going through the stream; the stream ends when the collection matches{{{	('abcdefghijklmnopqrstuvxyz' reading ending: 'mno' inclusive: true) rest.}}}{{{	| stream substream |	stream := String new writing.	substream := stream ending: 'mno'.	[ substream write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].	stream conclusion}}}  * any other object - the stream ends when an equal element passes through the stream"{{{	('ab#cd#ef!ABC##' reading ending: $!) rest.}}}{{{	| stream substream |	stream := String new writing.	substream := stream ending: $!.	[ substream write: 'Hello World! Bye World!' ] on: Incomplete do: [].	stream conclusion}}}There is also a longer form #ending:inclusive: which takes an additional Boolean argument determining if the matching elements should be part of the substream content or not. The short form assumes the matching elements should be omitted.{{{	('abcdefghijklmnopqrstuvxyz' reading ending: [ :e | 'gmt' includes: e ] inclusive: true) rest.}}}{{{	| stream substream |	stream := String new writing.	substream := stream ending: [ :e | 'gmt' includes: e ] inclusive: true.	[ substream write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].	stream conclusion}}}Finally, closing a substream doesn't close the underlying stream by default. This is usually desirable because another substream is likely to follow so the main stream cannot be closed in that case. So in normal use the main stream is usually closed separately from the substreams. However, closing behavior of any substream can be modified through a custom closeBlock: if different behavior is desired.{{{	| limited |	limited := (String new writing limiting: 10) closeBlock: [ :stream | stream destination close ]; yourself.	[ limited write: Object comment ] on: Incomplete do: [ :ex | ].	limited close; terminal}}}	=== Streams of substreams (slicing and stitching) ===Slicing and Stitching is a meta-stream concept. Slicing breaks a stream with content that is delimited in some fashion (limiting:, ending:, etc) in to multiple substreams. The result of slicing is a read stream of substreams. Stitching is the inverse of slicing. It takes a read stream of streams and stiches those back together to look like a single continuous stream. Stitching a slicing stream will normally give the same result as the original underlying stream.Here is an example that creates a slicing stream that cuts the input up into substreams of size 5.{{{	((1 to: 49) reading limiting: 5) slicing collect: [ :slice | slice rest ]}}}Note that only the latest substream is active, previous substream is automatically depleted before next substream is created.Also note that since slicing always creates substreams, it is always a read stream, even if you're slicing a write stream. Output of the slicing stream are the substreams. Again, only the latest substream is active. The previous substream is automatically closed before next substream is created.{{{	| samples slices |	samples := String new writing.	slices := (samples limiting: 3) slicing.	Date.MonthNames do: [ :month | [ slices get write: month ] on: Xtreams.Incomplete do: [] ].	samples conclusion}}}In the following example the stream contains multiple messages delimited by $! and each message has multiple parts ending with $#. We want to process each part as a stream of its own (this is a simplified version of how multipart messages are represented in MIME).{{{	| messages |	messages := ('ab#cd#ef!ABC##' reading ending: $!) slicing.	messages collect: [ :message |		(message ending: $#) slicing collect: [ :part | part rest ] ]}}}Note that since only the last slice is active any sort of read-ahead will likely interfere with the expected behavior, e.g. if we used collecting: instead of collect: in the example above, it would not work.To generate the "hash-bang" style message encoding used in previous example we don't need any sort of end-detecting substream. Instead we need to emit the closing character when the substream is closed. There is a special "closing" substream and corresponding slicer for that as well.{{{	| connection messages |	connection := String new writing.	messages := (connection closing: [ connection put: $! ]) slicing.	3 timesRepeat: [ | parts message |		message := messages get.		parts := (message closing: [ connection put: $# ]) slicing.		#(one two three four) do: [ :body | parts get write: body ] ].	connection conclusion}}}Stitching takes a read stream of streams and makes them behave as a single continuous stream. Following example takes the 'chunks' and stitches them together.{{{	| chunks |	chunks := (#('abc' 'de' '' 'fghij') collect: [ :c | c reading ]) reading.	chunks stitching rest}}}The stream of streams can be inifinite in which case the stitching stream is inifinite as well. For example the following stitching stream will not end.{{{	| main |	main := (1 to: 10) reading.	[ main limiting: 3 ] reading stitching rest}}}The problem is that the underlying stream of streams keeps producing empty limiting streams at the end of the main stream. To make the example end with an empty limiting stream can be done as follows.{{{	| main wasEmpty |	main := (1 to: 10) reading.	wasEmpty := false.	[	wasEmpty ifTrue: [ Incomplete zero raise ].		wasEmpty := true.		(main doing: [ :e | wasEmpty := false ]) limiting: 3	] reading stitching rest}}}Here the #doing: transform captures the fact that there was in fact an element flowing through the limited: stream and sets the wasEmpty flag accordingly. This way we can detect the first empty limiting: stream and raise Incomplete. Alternatively the block stream can capture the substream in a variable and before creating next one it can check if its position reached the limit.{{{	| main current |	main := (1 to: 10) reading.	current := nil.	[	(current notNil and: [ current position < 3 ]) ifTrue: [ Incomplete zero raise ].		current := main limiting: 3	] reading stitching rest}}}Following example traverses current directory recursively by continuously adding to a queue of directories to search from and using the stitching to combine them together in to one long stream of filenames.{{{	| directories files |	directories := Xtreams.ElasticBuffer new: 10 class: Array.	directories put: '.' asFilename.	files :=		[	directories get reading				doing: [:filename | filename isDirectory ifTrue: [directories put: filename]]		] reading stitching.	files rest}}}A practical example of stitching write streams is chunking of written content into size-prefixed chunks of some maximum size. This is something that can be often seen in network protocols (e.g. when individual chunks need to be encrypted or signed).{{{	| output buffer |	output := ByteArray new writing.	buffer := RingBuffer on: (ByteArray new: 5).	[	(buffer writing limiting: buffer cacheSize)			closeBlock: [ output put: buffer readSize; write: buffer ];			yourself	] reading stitching		write: (1 to: 22); close.	output close terminal}}}	== Monitoring ==Monitoring transform is useful for gauging throughput and progress. It takes a monitoring block that will be invoked periodically in specified intervals. The monitoring block can take up to three arguments in this order:	* total number of elements processed so far	* increment in the number of elements since the last block invocation	* total microseconds elapsed since the monitoring transform was created{{{	| total |	total := 10000000.	(nil writing		monitoring: [ :processed :delta :elapsed |			Transcript writing cr;				print: (processed / total) floor; write: '% complete, ';				print: (processed / elapsed * 1000000) floor; write: ' elements/second' ]		every: 1 seconds		)	write: ([1] reading limiting: total floor * 100);		close}}}DbIdentifier: bear73DbTrace: 468773DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#any 'Xtreams-Support' '') #(#any 'Xtreams-Core' ''))DialectVersion: VisualWorks 7.9MonticelloPrefix: XTNamespace: Smalltalk.XtreamsPackageName: Xtreams-SubstreamsParcel: #('Xtreams-Substreams')ParcelName: Xtreams-SubstreamsPrerequisiteDescriptions: #(#(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Core' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Support' '') #('Xtreams-Core' ''))PrintStringCache: (8.2 - 0,tkogan)Url: http://www.squeaksource.com/Xtreams/Xtreams-Substreams-nice.5.mczVersion: 8.2 - 0Date: 11:27:49 AM June 16, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>ReadSubstream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>sourceAtEnd closeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.ReadSubstream</class-id><body>This is abstract superclass of all substreams. Substreams normally don't close their underlying source, their closing behavior is customized via closeBlock.Instance Variables	sourceAtEnd	&lt;Boolean&gt; flags end of the source	closeBlock	&lt;BlockClosure&gt; unary block invoked in response to #close, allows customizing closing behaviorNote that slicing clones an initial prototype of a substream to create the slices and it uses #copy for that. The prototype is not used to read so it should remain in its properly initialized initial state. However if any of its instance variables contain mutable objects that change their state during reading, those must be copied as well. Make sure any concrete subclass defines an appropriate #postCopy method if needed.</body></comment><class><name>MatchReadSubstream</name><environment>Xtreams</environment><super>Xtreams.ReadSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>substreamAtEnd pattern inclusive backtrack inputBuffer outputBuffer candidate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.MatchReadSubstream</class-id><body>This is a substream bounded by a string pattern. The algorithm used doesn't need to peek or step back to detect the pattern, so it can be used on non-positionable streams.Instance Variables	substreamAtEnd	&lt;Boolean&gt; is this substream at end	pattern	&lt;String&gt; the bounding pattern	patternStart	&lt;Integer&gt;	inclusive	&lt;Boolean&gt; is the boundary part of the substream contents	hasReread	&lt;Boolean&gt;	reread	&lt;Object&gt;	buffer	&lt;RingBuffer&gt; read-ahead buffer (to be able to stop before pattern if inclusive is false)	backtrack	&lt;Array&gt; backtracking table for pattern</body></comment><class><name>WriteSubstream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destinationAtEnd closeBlock substreamClosed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.WriteSubstream</class-id><body>This is abstract superclass of all substreams. Substreams normally don't close their underlying source, their closing behavior is customized via closeBlock.Instance Variables	destinationAtEnd	&lt;Boolean&gt; flags end of the destination	closeBlock	&lt;BlockClosure&gt; unary block invoked in response to #close, allows customizing closing behavior	substreamClosed	&lt;Boolean&gt; flags the end of the receiver</body></comment><class><name>TestWriteSubstream</name><environment>Xtreams</environment><super>Xtreams.WriteSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>substreamAtEnd test inclusive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.TestWriteSubstream</class-id><body>This is a substream bounded by an element matching the @test criteria.Instance Variables	substreamAtEnd	&lt;Boolean&gt; is this substream at end	test	&lt;BlockClosure&gt; the bounding criteria	inclusive	&lt;Boolean&gt; is the boundary part of the substream contents</body></comment><class><name>PositionReadSubstream</name><environment>Xtreams</environment><super>Xtreams.ReadSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.PositionReadSubstream</class-id><body>This is an abstract substreams that keeps track of its own position and allows positioning if the underlying stream is positionable.Instance Variables	position	&lt;Integer&gt; current position within the substream</body></comment><class><name>LimitReadSubstream</name><environment>Xtreams</environment><super>Xtreams.PositionReadSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>limit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.LimitReadSubstream</class-id><body>Limits the number of elements that can be read from the source stream.Instance Variables	limit	&lt;Integer&gt; maximum number of elements that can be read from this stream	position	&lt;Integer&gt; number of elements already read from the stream</body></comment><class><name>TestReadSubstream</name><environment>Xtreams</environment><super>Xtreams.ReadSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>substreamAtEnd test inclusive </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.TestReadSubstream</class-id><body>This is a substream bounded by an element matching the @test criteria.Instance Variables	substreamAtEnd	&lt;Boolean&gt; is this substream at end	test	&lt;BlockClosure&gt; the bounding criteria	inclusive	&lt;Boolean&gt; is the boundary part of the substream contents</body></comment><class><name>MatchWriteSubstream</name><environment>Xtreams</environment><super>Xtreams.WriteSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>substreamAtEnd pattern candidate inclusive backtrack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.MatchWriteSubstream</class-id><body>This is a substream bounded by a string pattern. The algorithm used doesn't need to peek or step back to detect the pattern, so it can be used on non-positionable streams.Instance Variables	substreamAtEnd	&lt;Boolean&gt; is this substream at end	pattern	&lt;String&gt; the bounding pattern	patternStart	&lt;Integer&gt; 	inclusive	&lt;Boolean&gt; is the boundary part of the substream contents	backtrack	&lt;Array&gt; backtracking table for pattern</body></comment><class><name>PositionWriteSubstream</name><environment>Xtreams</environment><super>Xtreams.WriteSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.PositionWriteSubstream</class-id><body>This is an abstract substreams that keeps track of its own position and allows positioning if the underlying stream is positionable.Instance Variables	position	&lt;Integer&gt; current position within the substream</body></comment><class><name>LimitWriteSubstream</name><environment>Xtreams</environment><super>Xtreams.PositionWriteSubstream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>limit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.LimitWriteSubstream</class-id><body>Limits the number of elements that can be written into the destination stream.Instance Variables	limit	&lt;Integer&gt; maximum number of elements that can be written into this stream	position	&lt;Integer&gt; number of elements already written into the stream</body></comment><class><name>StitchReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>active contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.StitchReadStream</class-id><body>StitchReadStream combines a stream of source which returns streams in to a single continuous stream.Instance Variables	active	&lt;ReadStream&gt;	the substream that is currently active	contentsSpecies	&lt;Class&gt;	the contents species of the substreams</body></comment><class><name>StitchWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>active contentsSpecies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Substreams</package></attributes></class><comment><class-id>Xtreams.StitchWriteStream</class-id><body>StitchWriteStream combines a stream of source which returns streams in to a single continuous stream.Instance Variables	active	&lt;WriteStream&gt;	the substream that is currently active	contentsSpecies	&lt;Class&gt;	the contents species of the substreams</body></comment><methods><class-id>Xtreams.ReadSubstream</class-id> <category>testing</category><body package="Xtreams-Substreams">sourceAtEnd	^sourceAtEnd</body></methods><methods><class-id>Xtreams.ReadSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">closeBlock	^closeBlock</body><body package="Xtreams-Substreams">closeBlock: anObject	closeBlock := anObject</body><body package="Xtreams-Substreams">get	^[source get] on: Incomplete do: [:incomplete | sourceAtEnd := true. incomplete pass]</body><body package="Xtreams-Substreams">read: anInteger into: aSequenceableCollection at: startIndex	^[source read: anInteger into: aSequenceableCollection at: startIndex] on: Incomplete do: [:incomplete | sourceAtEnd := true. incomplete pass]</body></methods><methods><class-id>Xtreams.ReadSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">close	closeBlock cull: self</body><body package="Xtreams-Substreams">contentsSpecies	^source contentsSpecies</body><body package="Xtreams-Substreams">on: aSource	super on: aSource.	closeBlock := [].	sourceAtEnd := false</body></methods><methods><class-id>Xtreams.MatchReadSubstream</class-id> <category>testing</category><body package="Xtreams-Substreams">isPositionable	^false</body></methods><methods><class-id>Xtreams.MatchReadSubstream</class-id> <category>private</category><body package="Xtreams-Substreams">gobble	| object |	object := inputBuffer hasDataToRead		ifTrue: [inputBuffer get]		ifFalse: [			[source get] on: Incomplete do: [:incomplete |				sourceAtEnd := true.				substreamAtEnd := true.				^self]].	(pattern at: candidate) = object		ifTrue: [			candidate := candidate + 1.			candidate &gt; pattern size ifTrue: [				"full match"				substreamAtEnd := true.				inclusive ifTrue: [outputBuffer write: pattern size from: pattern at: 1]]]		ifFalse: [			candidate = 1 ifTrue: [				"no match"				outputBuffer put: object].			candidate &gt; 1 ifTrue: [				| rewind |				"partial match"				rewind := backtrack at: candidate.				outputBuffer write: candidate - rewind from: pattern at: 1.				inputBuffer put: object.				candidate := rewind]]</body><body package="Xtreams-Substreams">streamingInsert: anInteger into: aWriteStream	| count amount |	count := 0.	[count &lt; anInteger and: [outputBuffer hasDataToRead or: [substreamAtEnd not]]] whileTrue:		[outputBuffer hasDataToRead ifFalse: [self gobble].		amount := outputBuffer readSize min: (anInteger - count).		amount &gt; 0 ifTrue: [aWriteStream insert: amount from: outputBuffer].		count := count + amount].	count &lt; anInteger ifTrue: [(Incomplete count: count) raise]</body><body package="Xtreams-Substreams">streamingInsertInto: aWriteStream	| amount |	[outputBuffer hasDataToRead or: [substreamAtEnd not]] whileTrue:		[outputBuffer hasDataToRead ifFalse: [self gobble].		amount := outputBuffer readSize.		aWriteStream insert: amount from: outputBuffer]</body><body package="Xtreams-Substreams">streamingWrite: anInteger into: aWriteStream	| count amount |	count := 0.	[count &lt; anInteger and: [outputBuffer hasDataToRead or: [substreamAtEnd not]]] whileTrue:		[outputBuffer hasDataToRead ifFalse: [self gobble].		amount := outputBuffer readSize min: (anInteger - count).		amount &gt; 0 ifTrue: [aWriteStream write: amount from: outputBuffer].		count := count + amount].	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Substreams">streamingWriteInto: aWriteStream	| amount count |	count := 0.	[outputBuffer hasDataToRead or: [substreamAtEnd not]] whileTrue:		[outputBuffer hasDataToRead ifFalse: [self gobble].		amount := outputBuffer readSize.		aWriteStream write: amount from: outputBuffer.		count := count + amount].	^count</body></methods><methods><class-id>Xtreams.MatchReadSubstream</class-id> <category>copying</category><body package="Xtreams-Substreams">postCopy	outputBuffer := RingBuffer new: pattern size class: self contentsSpecies</body></methods><methods><class-id>Xtreams.MatchReadSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">close	inputBuffer == nil ifTrue: [^self].	super close.	inputBuffer := nil.	outputBuffer := nil</body><body package="Xtreams-Substreams">on: aSource pattern: aPattern backtrack: aBacktrack inclusive: aBoolean	self on: aSource.	pattern := aPattern.	inputBuffer := RingBuffer new: 1 class: self contentsSpecies.	outputBuffer := RingBuffer new: pattern size class: self contentsSpecies.	candidate := 1.	backtrack := aBacktrack.	inclusive := aBoolean.	substreamAtEnd := false</body></methods><methods><class-id>Xtreams.MatchReadSubstream</class-id> <category>seeking</category><body package="Xtreams-Substreams">-= anInteger	anInteger isZero ifFalse: [^super -= anInteger].	[outputBuffer hasDataToRead or: [substreamAtEnd not]] whileTrue:		[outputBuffer hasDataToRead ifFalse: [self gobble].		outputBuffer readSkip: outputBuffer readSize].	^0</body></methods><methods><class-id>Xtreams.MatchReadSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">get	[outputBuffer hasDataToRead or: [substreamAtEnd]] whileFalse: [self gobble].	outputBuffer hasDataToRead ifFalse: [Incomplete zero raise].	^outputBuffer get</body><body package="Xtreams-Substreams">read: anInteger into: aSequenceableCollection at: startIndex	| count amount |	count := 0.	[count &lt; anInteger and: [outputBuffer hasDataToRead or: [substreamAtEnd not]]] whileTrue:		[outputBuffer hasDataToRead ifFalse: [self gobble].		amount := outputBuffer readSize min: (anInteger - count).		amount &gt; 0 ifTrue: [outputBuffer read: amount into: aSequenceableCollection at: startIndex + count].		count := count + amount].	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.MatchReadSubstream</class-id> <category>printing</category><body package="Xtreams-Substreams">streamingPrintOn: out	super streamingPrintOn: out.	out write: ' pattern: '.	[	((out limiting: 30)			collecting: [ :c | c = Character cr ifTrue: [ $\ ] ifFalse: [ c ] ]		) print: pattern	] on: Incomplete do: [ :ex | ]</body></methods><methods><class-id>Xtreams.MatchReadSubstream class</class-id> <category>instance creation</category><body package="Xtreams-Substreams">on: aSource pattern: aPattern backtrack: aBacktrack inclusive: aBoolean	^self new on: aSource pattern: aPattern backtrack: aBacktrack inclusive: aBoolean</body></methods><methods><class-id>Xtreams.WriteSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">close	closeBlock cull: self.	substreamClosed := true</body><body package="Xtreams-Substreams">contentsSpecies	^destination contentsSpecies</body><body package="Xtreams-Substreams">on: aDestination	super on: aDestination.	closeBlock := [].	destinationAtEnd := false.	substreamClosed := false</body><body package="Xtreams-Substreams">subseekend</body></methods><methods><class-id>Xtreams.WriteSubstream</class-id> <category>testing</category><body package="Xtreams-Substreams">destinationAtEnd	^destinationAtEnd</body><body package="Xtreams-Substreams">substreamClosed	^substreamClosed</body></methods><methods><class-id>Xtreams.WriteSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">closeBlock	^closeBlock</body><body package="Xtreams-Substreams">closeBlock: anObject	closeBlock := anObject</body><body package="Xtreams-Substreams">insert: anInteger from: aSequenceableCollection at: startIndex	[destination insert: anInteger from: aSequenceableCollection at: startIndex] on: Incomplete do: [:incomplete |		destinationAtEnd := true.		incomplete pass].	^anInteger</body><body package="Xtreams-Substreams">put: anObject	[destination put: anObject] on: Incomplete do: [:incomplete |		destinationAtEnd := true.		incomplete pass]</body><body package="Xtreams-Substreams">write: anInteger from: aSequenceableCollection at: startIndex	[destination write: anInteger from: aSequenceableCollection at: startIndex] on: Incomplete do: [:incomplete |		destinationAtEnd := true.		incomplete pass].	^anInteger</body></methods><methods><class-id>Xtreams.TestWriteSubstream</class-id> <category>private</category><body package="Xtreams-Substreams">streamingInsert: anInteger from: aReadStream	self streamingWrite: anInteger from: aReadStream</body><body package="Xtreams-Substreams">streamingInsertFrom: aReadStream	self streamingWriteFrom: aReadStream</body><body package="Xtreams-Substreams">streamingWrite: anInteger from: aReadStream	| count object |	substreamAtEnd ifTrue: [Incomplete zero raise].	count := 0.	[[count &lt; anInteger and: [substreamAtEnd not]] whileTrue:		[object := aReadStream get.		((substreamAtEnd := test value: object) and: [inclusive not]) ifFalse: [destination put: object].		count := count + 1]]			on: Incomplete do: [:incomplete |				destinationAtEnd := substreamAtEnd := true.				(Incomplete count: count) raise].	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Substreams">streamingWriteFrom: aReadStream	| object count |	substreamAtEnd ifTrue: [Incomplete zero raise].	count := 0.	^[[substreamAtEnd not] whileTrue:		[object := aReadStream get.		((substreamAtEnd := test value: object) and: [inclusive not]) ifFalse: [destination put: object. count := count + 1]].		count	] on: Incomplete do: [:incomplete | destinationAtEnd := substreamAtEnd := true. count ]</body></methods><methods><class-id>Xtreams.TestWriteSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">insert: anInteger from: aSequenceableCollection at: startIndex	^self write: anInteger from: aSequenceableCollection at: startIndex</body><body package="Xtreams-Substreams">put: anObject	substreamAtEnd ifTrue: [Incomplete zero raise].	((substreamAtEnd := test value: anObject) and: [inclusive not]) ifTrue: [Incomplete zero raise].	[destination put: anObject] on: Incomplete do: [:incomplete | destinationAtEnd := substreamAtEnd := true. incomplete pass].	^anObject</body><body package="Xtreams-Substreams">write: anInteger from: aSequenceableCollection at: startIndex	| count object |	substreamAtEnd ifTrue: [Incomplete zero raise].	count := 0.	[[count &lt; anInteger and: [substreamAtEnd not]] whileTrue:		[object := aSequenceableCollection at: startIndex + count.		((substreamAtEnd := test value: object) and: [inclusive not]) ifFalse: [destination put: object].		count := count + 1]]			on: Incomplete do: [:incomplete |				destinationAtEnd := substreamAtEnd := true.				(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.TestWriteSubstream</class-id> <category>testing</category><body package="Xtreams-Substreams">isPositionable	^false</body></methods><methods><class-id>Xtreams.TestWriteSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">on: aDestination test: testBlock inclusive: aBoolean	self on: aDestination.	test := testBlock.	inclusive := aBoolean.	substreamAtEnd := false</body></methods><methods><class-id>Xtreams.TestWriteSubstream class</class-id> <category>instance creation</category><body package="Xtreams-Substreams">on: aDestination test: testBlock inclusive: aBoolean	^self new on: aDestination test: testBlock inclusive: aBoolean</body></methods><methods><class-id>Xtreams.PositionReadSubstream</class-id> <category>testing</category><body package="Xtreams-Substreams">isPositionable	^source isPositionable</body></methods><methods><class-id>Xtreams.PositionReadSubstream</class-id> <category>seeking</category><body package="Xtreams-Substreams">++ anInteger	| count |	self isPositionable ifFalse: [ ^super ++ anInteger ].	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	count := self available min: anInteger.	count := [source ++ count. count] on: Incomplete do: [ :ex | ex count ].	position := position + count.	count &lt; anInteger ifTrue: [sourceAtEnd := true. (Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Substreams">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	count := anInteger min: position.	count := [source -- count. count] on: Incomplete do: [ :ex | ex count ].	position := position - count.	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	anInteger isZero ifFalse: [sourceAtEnd := false].	^anInteger</body><body package="Xtreams-Substreams">-= anInteger	self isPositionable ifFalse: [^super -= anInteger].	position := self length - anInteger max: 0.	^source -= anInteger</body><body package="Xtreams-Substreams">length	^source available + position</body><body package="Xtreams-Substreams">position	^position</body><body package="Xtreams-Substreams">position: anInteger	| delta available |	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	anInteger &lt; 0 ifTrue: [Incomplete zero raise].	available := anInteger min: self length.	delta := available - position.	[delta positive		ifTrue:	[source ++ delta]		ifFalse:	[source -- delta negated]]			on: Incomplete do: [sourceAtEnd := true].	position := available.	available = anInteger ifTrue: [^anInteger].	(Incomplete count: available) raise</body></methods><methods><class-id>Xtreams.PositionReadSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">get	| object |	object := super get.	position := position + 1.	^object</body><body package="Xtreams-Substreams">read: anInteger into: aSequenceableCollection at: startIndex	[source read: anInteger into: aSequenceableCollection at: startIndex] on: Incomplete do: [:incomplete |		sourceAtEnd := true.		position := position + incomplete count.		incomplete pass].	position := position + anInteger.	^anInteger</body></methods><methods><class-id>Xtreams.PositionReadSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">on: aSource	super on: aSource.	position := 0</body></methods><methods><class-id>Xtreams.PositionReadSubstream</class-id> <category>printing</category><body package="Xtreams-Substreams">streamingPrintOn: out	super streamingPrintOn: out.	out write: ' position: '; print: position.</body></methods><methods><class-id>Xtreams.LimitReadSubstream</class-id> <category>seeking</category><body package="Xtreams-Substreams">-= anInteger	| available |	anInteger &lt; 0 ifTrue: [Incomplete zero raise].	available := anInteger min: limit.	source ++ (limit - position - available).	position := limit - available.	available = anInteger ifTrue: [^anInteger].	^(Incomplete count: available) raise</body><body package="Xtreams-Substreams">length	^limit</body></methods><methods><class-id>Xtreams.LimitReadSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">get	position = limit ifTrue: [Incomplete zero raise].	^super get</body><body package="Xtreams-Substreams">read: anInteger into: aSequenceableCollection at: startIndex	| count |	count := anInteger min: self available.	super read: count into: aSequenceableCollection at: startIndex.	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.LimitReadSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">on: aSource limit: anInteger	self on: aSource.	limit := anInteger</body></methods><methods><class-id>Xtreams.LimitReadSubstream</class-id> <category>printing</category><body package="Xtreams-Substreams">streamingPrintOn: out	super streamingPrintOn: out.	out write: ' limit: '; print: limit.</body></methods><methods><class-id>Xtreams.LimitReadSubstream class</class-id> <category>instance creation</category><body package="Xtreams-Substreams">on: aSource limit: anInteger	^self new on: aSource limit: anInteger</body></methods><methods><class-id>Xtreams.TestReadSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">get	| object |	substreamAtEnd ifTrue: [Incomplete zero raise].	object := [source get] on: Incomplete do: [:incomplete | sourceAtEnd := substreamAtEnd := true. incomplete pass].	(substreamAtEnd := test value: object) ifTrue:		[inclusive ifTrue: [^object].		Incomplete zero raise].	^object</body><body package="Xtreams-Substreams">read: anInteger into: aSequenceableCollection at: startIndex	| object count |	substreamAtEnd ifTrue: [(Incomplete on: aSequenceableCollection count: 0 at: startIndex) raise].	count := 0.	[[count = anInteger or: [substreamAtEnd]] whileFalse:		[object := source get.		((substreamAtEnd := test value: object) not or: [inclusive]) ifTrue:			[aSequenceableCollection at: startIndex + count put: object.			count := count + 1]]]				on: Incomplete do: [sourceAtEnd := substreamAtEnd := true. (Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.TestReadSubstream</class-id> <category>testing</category><body package="Xtreams-Substreams">isPositionable	^false</body></methods><methods><class-id>Xtreams.TestReadSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">on: aSource test: testBlock inclusive: aBoolean	self on: aSource.	test := testBlock.	inclusive := aBoolean.	substreamAtEnd := false</body></methods><methods><class-id>Xtreams.TestReadSubstream</class-id> <category>private</category><body package="Xtreams-Substreams">streamingWrite: anInteger into: aWriteStream	| object count |	substreamAtEnd ifTrue: [Incomplete zero raise].	count := 0.	[[count = anInteger or: [substreamAtEnd]] whileFalse:		[object := source get.		((substreamAtEnd := test value: object) not or: [inclusive]) ifTrue:			[aWriteStream put: object.			count := count + 1]]]				on: Incomplete do: [sourceAtEnd := substreamAtEnd := true. (Incomplete count: count) raise].	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Substreams">streamingWriteInto: aWriteStream	| object count |	substreamAtEnd ifTrue: [^0].	count := 0.	^[	[	substreamAtEnd		] whileFalse: [			object := source get.			(substreamAtEnd := test value: object)				ifTrue:	[inclusive ifTrue: [aWriteStream put: object. count := count + 1]]				ifFalse:	[aWriteStream put: object. count := count + 1]].		count	] on: Incomplete do: [sourceAtEnd := substreamAtEnd := true. count ]</body></methods><methods><class-id>Xtreams.TestReadSubstream</class-id> <category>seeking</category><body package="Xtreams-Substreams">-= anInteger	| object |	anInteger isZero ifFalse: [^super -= anInteger].	substreamAtEnd ifTrue: [^self].	[[substreamAtEnd] whileFalse:		[object := source get.		substreamAtEnd := test value: object]]			on: Incomplete do: [sourceAtEnd := substreamAtEnd := true].	^0</body></methods><methods><class-id>Xtreams.TestReadSubstream class</class-id> <category>instance creation</category><body package="Xtreams-Substreams">on: aSource test: testBlock inclusive: aBoolean	^self new on: aSource test: testBlock inclusive: aBoolean</body></methods><methods><class-id>Xtreams.MatchWriteSubstream</class-id> <category>private</category><body package="Xtreams-Substreams">gobble: object	(pattern at: candidate) = object		ifTrue: [			candidate := candidate + 1.			candidate &gt; pattern size ifTrue: [				"full match"				substreamAtEnd := true.				inclusive ifTrue: [					destination write: pattern size from: pattern at: 1.					^pattern size].				].			^0]		ifFalse: [			candidate = 1 ifTrue: [				"no match"				destination put: object.				^1].			candidate &gt; 1 ifTrue: [				| rewind amount |				"partial match"				rewind := backtrack at: candidate.				amount := candidate - rewind.				destination write: amount from: pattern at: 1.				candidate := rewind.				^amount + (self gobble: object)]]</body><body package="Xtreams-Substreams">streamingInsert: anInteger from: aReadStream	self streamingWrite: anInteger from: aReadStream</body><body package="Xtreams-Substreams">streamingInsertFrom: aReadStream	self streamingWriteFrom: aReadStream</body><body package="Xtreams-Substreams">streamingWrite: anInteger from: aReadStream	| count |	count := 0.	[[count &lt; anInteger and: [substreamAtEnd not]] whileTrue:		[count := count + (self gobble: aReadStream get)]]			on: Incomplete do: [:incomplete |				destinationAtEnd := substreamAtEnd := true.				(Incomplete count: count) raise].	count &lt; anInteger ifTrue:		[substreamAtEnd := true.		(Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Substreams">streamingWriteFrom: aReadStream	| count |	substreamAtEnd ifTrue: [Incomplete zero raise].	count := 0.	^[[substreamAtEnd not] whileTrue: [count := count + (self gobble: aReadStream get)]]		on: Incomplete do: [:incomplete | destinationAtEnd := substreamAtEnd := true. count ]</body></methods><methods><class-id>Xtreams.MatchWriteSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">insert: anInteger from: aSequenceableCollection at: startIndex	^self write: anInteger from: aSequenceableCollection at: startIndex</body><body package="Xtreams-Substreams">put: anObject	substreamAtEnd ifTrue: [Incomplete zero raise].	[self gobble: anObject] on: Incomplete do: [:incomplete | destinationAtEnd := substreamAtEnd := true. incomplete pass].	^anObject</body><body package="Xtreams-Substreams">write: anInteger from: aSequenceableCollection at: startIndex	| count index |	count := 0.	index := startIndex.	[[count &lt; anInteger and: [substreamAtEnd not]] whileTrue:		[count := count + (self gobble: (aSequenceableCollection at: index)).		index := index + 1]]			on: Incomplete do: [:incomplete |				destinationAtEnd := substreamAtEnd := true.				(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	count &lt; anInteger ifTrue:		[substreamAtEnd := true.		(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.MatchWriteSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">on: aDestination pattern: aPattern backtrack: aBacktrack inclusive: aBoolean	self on: aDestination.	pattern := aPattern.	backtrack := aBacktrack.	candidate := 1.	inclusive := aBoolean.	substreamAtEnd := false</body></methods><methods><class-id>Xtreams.MatchWriteSubstream</class-id> <category>printing</category><body package="Xtreams-Substreams">streamingPrintOn: out	super streamingPrintOn: out.	out write: ' pattern: '.	[	((out limiting: 30)			collecting: [ :c | c = Character cr ifTrue: [ $\ ] ifFalse: [ c ] ]		) print: pattern	] on: Incomplete do: [ :ex | ]</body></methods><methods><class-id>Xtreams.MatchWriteSubstream class</class-id> <category>instance creation</category><body package="Xtreams-Substreams">on: aDestination pattern: aPattern backtrack: aBacktrack inclusive: aBoolean	^self new on: aDestination pattern: aPattern backtrack: aBacktrack inclusive: aBoolean</body></methods><methods><class-id>Xtreams.PositionWriteSubstream</class-id> <category>testing</category><body package="Xtreams-Substreams">isPositionable	^destination isPositionable</body></methods><methods><class-id>Xtreams.PositionWriteSubstream</class-id> <category>seeking</category><body package="Xtreams-Substreams">++ anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self -- anInteger negated ].	count := self available min: anInteger.	count := [destination ++ count. count] on: Incomplete do: [ :ex | ex count ].	position := position + count.	count &lt; anInteger ifTrue: [destinationAtEnd := true. (Incomplete count: count) raise].	^anInteger</body><body package="Xtreams-Substreams">-- anInteger	| count |	anInteger &lt; 0 ifTrue: [ ^self ++ anInteger negated ].	count := anInteger min: position.	count := [destination -- count. count] on: Incomplete do: [ :ex | ex count ].	position := position - count.	count &lt; anInteger ifTrue: [(Incomplete count: count) raise].	anInteger isZero ifFalse: [destinationAtEnd := false].	^anInteger</body><body package="Xtreams-Substreams">-= anInteger	position := self length - anInteger max: 0.	^destination -= anInteger.</body><body package="Xtreams-Substreams">length	^destination available + position</body><body package="Xtreams-Substreams">position	^position</body><body package="Xtreams-Substreams">position: anInteger	| available adjustment |	self isPositionable ifFalse: [self error: 'This stream is not positionable.'].	anInteger &lt; 0 ifTrue: [Incomplete zero raise].	available := anInteger min: self length.	adjustment := available - position.	adjustment positive		ifTrue: [ destination ++ adjustment ]		ifFalse: [ destination -- adjustment negated ].	position := available.	available = anInteger ifTrue: [^anInteger].	(Incomplete count: available) raise</body></methods><methods><class-id>Xtreams.PositionWriteSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">insert: anInteger from: aSequenceableCollection at: startIndex	[destination insert: anInteger from: aSequenceableCollection at: startIndex] on: Incomplete do: [:incomplete |		position := position + incomplete count.		incomplete pass].	position := position + anInteger.	^anInteger</body><body package="Xtreams-Substreams">put: anObject	| object |	object := destination put: anObject.	position := position + 1.	^object</body><body package="Xtreams-Substreams">write: anInteger from: aSequenceableCollection at: startIndex	[destination write: anInteger from: aSequenceableCollection at: startIndex] on: Incomplete do: [:incomplete |		position := position + incomplete count.		incomplete pass].	position := position + anInteger.	^anInteger</body></methods><methods><class-id>Xtreams.PositionWriteSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">on: aDestination	super on: aDestination.	position := 0</body></methods><methods><class-id>Xtreams.PositionWriteSubstream</class-id> <category>printing</category><body package="Xtreams-Substreams">streamingPrintOn: out	super streamingPrintOn: out.	out write: ' position: '; print: position.</body></methods><methods><class-id>Xtreams.LimitWriteSubstream</class-id> <category>seeking</category><body package="Xtreams-Substreams">-= anInteger	| available |	anInteger &lt; 0 ifTrue: [Incomplete zero raise].	available := anInteger min: limit.	destination ++ (limit - position - available).	position := limit - available.	available = anInteger ifTrue: [^anInteger].	^(Incomplete count: available) raise</body><body package="Xtreams-Substreams">length	^limit</body></methods><methods><class-id>Xtreams.LimitWriteSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">on: aDestination limit: anInteger	self on: aDestination.	limit := anInteger</body></methods><methods><class-id>Xtreams.LimitWriteSubstream</class-id> <category>accessing</category><body package="Xtreams-Substreams">insert: anInteger from: aSequenceableCollection at: startIndex	| count |	count := anInteger min: self available.	super insert: count from: aSequenceableCollection at: startIndex.	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body><body package="Xtreams-Substreams">put: anObject	position = limit ifTrue: [Incomplete zero raise].	^super put: anObject</body><body package="Xtreams-Substreams">write: anInteger from: aSequenceableCollection at: startIndex	| count |	count := anInteger min: self available.	super write: count from: aSequenceableCollection at: startIndex.	count &lt; anInteger ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].	^anInteger</body></methods><methods><class-id>Xtreams.LimitWriteSubstream</class-id> <category>printing</category><body package="Xtreams-Substreams">streamingPrintOn: out	super streamingPrintOn: out.	out write: ' limit: '; print: limit.</body></methods><methods><class-id>Xtreams.LimitWriteSubstream class</class-id> <category>instance creation</category><body package="Xtreams-Substreams">on: aDestination limit: anInteger	^self new on: aDestination limit: anInteger</body></methods><methods><class-id>Xtreams.StitchReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">close	active == nil ifFalse: [active close].	super close</body><body package="Xtreams-Substreams">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Substreams">on: aSource contentsSpecies: aClass	super on: aSource.	contentsSpecies := aClass</body><body package="Xtreams-Substreams">on: aSource first: firstActiveStream	super on: aSource.	active := firstActiveStream.	contentsSpecies := active contentsSpecies</body></methods><methods><class-id>Xtreams.StitchReadStream</class-id> <category>accessing</category><body package="Xtreams-Substreams">read: anInteger into: aSequenceableCollection at: startIndex	| remaining amount index |	index := startIndex.	remaining := anInteger.	amount := 0.	[		active == nil ifTrue: [			[active := source get]				on: Incomplete				do: [:ex | (Incomplete on: aSequenceableCollection count: anInteger - remaining at: startIndex) raise]].		amount := [active read: remaining into: aSequenceableCollection at: index] on: Incomplete do: [:ex | ex count].		remaining := remaining - amount.		index := index + amount.		remaining &gt; 0] whileTrue:			[[active close]				on: Incomplete				do: [:ex |					active := nil.					(Incomplete on: aSequenceableCollection count: anInteger - remaining at: startIndex) raise].							active := nil].	^anInteger</body></methods><methods><class-id>Xtreams.StitchReadStream class</class-id> <category>instance creation</category><body package="Xtreams-Substreams">on: aSource contentsSpecies: aClass	^self new on: aSource contentsSpecies: aClass</body><body package="Xtreams-Substreams">on: aSource first: firstActiveStream	^self new on: aSource first: firstActiveStream</body></methods><methods><class-id>Xtreams.StitchWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Substreams">close	self flush.	destination close</body><body package="Xtreams-Substreams">contentsSpecies	^contentsSpecies</body><body package="Xtreams-Substreams">flush	active == nil ifTrue: [^self].	active close.	active := nil</body><body package="Xtreams-Substreams">on: aDestination contentsSpecies: aClass	super on: aDestination.	contentsSpecies := aClass</body><body package="Xtreams-Substreams">on: aDestination first: firstActiveStream	super on: aDestination.	active := firstActiveStream.	contentsSpecies := active contentsSpecies</body></methods><methods><class-id>Xtreams.StitchWriteStream</class-id> <category>accessing</category><body package="Xtreams-Substreams">write: anInteger from: aSequenceableCollection at: startIndex	| remaining amount index |	index := startIndex.	remaining := anInteger.	amount := 0.	[		active == nil ifTrue: [			[active := destination get]				on: Incomplete				do: [ :ex | (Incomplete on: aSequenceableCollection count: anInteger - remaining at: startIndex) raise]].		amount := [active write: remaining from: aSequenceableCollection at: index] on: Incomplete do: [:ex | ex count].		remaining := remaining - amount.		index := index + amount.		remaining &gt; 0] whileTrue:			[active close.			active := nil].	^anInteger</body></methods><methods><class-id>Xtreams.StitchWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Substreams">on: aDestination contentsSpecies: aClass	^self new on: aDestination contentsSpecies: aClass</body><body package="Xtreams-Substreams">on: aDestination first: firstActiveStream	^self new on: aDestination first: firstActiveStream</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>substreaming</category><body package="Xtreams-Substreams">, aReadStream	"Return a read stream that combines self and @aReadStream into a single stream.	""		((1 to: 5) reading, (6 to: 10) reading) rest	""		| files |		files := '/pub/vw7.8' asFilename reading.		[ | fn | fn := files get. fn isDirectory ifTrue: [ files := fn reading, files ]. fn ] reading rest	"	^(Array with: self with: aReadStream) reading stitching</body><body package="Xtreams-Substreams">closing: aBlock	^(PositionReadSubstream on: self)		closeBlock: aBlock;		yourself</body><body package="Xtreams-Substreams">ending: aMatchable	"Creates a substream that will end when aMatchable finds a match in the content passing through. aMatchable is either		* a block that is evaluated with each element; the stream ends when the block returns true		* a collection that is matched against the last elements read, the stream ends when the collection matches		* any other object, the stream matches when an equal object is read from the stream"	"	aMatchable	&lt;BlockClosure | Collection | Object&gt;		^&lt;TransformReadStream&gt;	""		('abcdefghijklmnopqrstuvxyz' reading ending: $j) rest.	""		('abcdefghijklmnopqrstuvxyz' reading ending: 'mno') rest	""		('abcdefghijklmnopqrstuvxyz' reading ending: [ :e | 'gmt' includes: e ]) rest	"	^self ending: aMatchable inclusive: false</body><body package="Xtreams-Substreams">ending: aMatchable inclusive: inclusive	"Creates a substream that will end when aMatchable finds a match in the content passing through. aMatchable is either		* a block that is evaluated with each element - the stream ends when the block returns true		* a collection that is matched against the last elements read - the stream ends when the collection matches		* any other object - the stream matches when an equal object is read from the stream	The inclusive parameter determins if the elements matching the end condition should be included in the substream contents or not."	"	aMatchable	&lt;BlockClosure | Collection | Object&gt;	the substream ending criteria		inclusive	&lt;Boolean&gt; should the content matching the end condition be included in the substream		^&lt;TransformReadStream&gt;	""		('abcdefghijklmnopqrstuvxyz' reading ending: $j inclusive: true) rest.	""		('abcdefghijklmnopqrstuvxyz' reading ending: 'mno' inclusive: true) rest	""		('abcdefghijklmnopqrstuvxyz' reading ending: [ :e | 'gmt' includes: e ] inclusive: true) rest	"	^aMatchable streamingReadMatching: self inclusive: inclusive</body><body package="Xtreams-Substreams">limiting: limit	"Create a substream that will allow at most @limit number of elements to be read from the source."	"	limit		&lt;Integer&gt;	maximum number of elements that can be read from the source		^&lt;LimitReadStream&gt;"	"		('abcdefghi' reading limiting: 5) rest	"	^LimitReadSubstream on: self limit: limit</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="Xtreams-Substreams">monitoring: aNotificationBlock every: aNotificationInterval	"Monitor the through-put of the receiver."	"	aNotificationBlock &lt;BlockClosure&gt;	the block to execute when notifying		aNotificationInterval &lt;Duration&gt;	how often to notify		^&lt;PositionReadSubstream&gt;	"	"		| monitor |		monitor := ObjectMemory imageFilename reading			monitoring: [:totalTransferred :deltaTransferred :elapsedMicroseconds |				throughputSpeed := deltaTransferred.				averageSpeed := (totalTransferred / elapsedMicroseconds) * 1000000.				Transcript writing cr;					write: 'average speed: '; print: averageSpeed asFloat;					write: ' through-put speed: '; print: throughputSpeed asFloat;					write: ' elapsed-time: '; print: elapsedMicroseconds / 1000000.0]			every: 1 milliseconds.		[monitor rest] ensure: [monitor close].	"	| previousPosition timer start notifyBlock monitoring notifyProcess notifyFinished |	start := Time microsecondClock.	previousPosition := 0.	monitoring := nil.	timer := nil.	notifyFinished := false.	notifyBlock := [		aNotificationBlock cull: monitoring position cull: monitoring position - previousPosition cull: Time microsecondClock - start.		previousPosition := monitoring position].	notifyProcess := nil.	notifyProcess := [		[notifyBlock value. notifyFinished] whileFalse: [notifyProcess suspend]] newProcess.	notifyProcess priority: ((Processor activeProcess priority + 1) min: 99).	monitoring := self closing: [		timer stop.		notifyProcess resume.		notifyFinished := true.		notifyProcess resume.		self close].	timer := Timer every: aNotificationInterval resume: notifyProcess.	^monitoring</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>substreaming</category><body package="Xtreams-Substreams">slicing	"From a readable stream, return a readable stream that acts as a prototype factory for the readable stream."	"	^&lt;ReadStream&gt;"	"		((1 to: 100) reading limiting: 10) slicing do: [:substream | Transcript cr; print: substream rest]	"	| substream |	substream := nil.	^[substream == nil ifFalse:		[substream -= 0; close.		substream sourceAtEnd ifTrue: [Incomplete zero raise]].	substream := self copy]		reading			closeBlock: [				substream == nil ifFalse: [					substream close.					substream := nil].				source close];			yourself</body><body package="Xtreams-Substreams">stitching	"From a stream that returns streams (either read or write streams), stitch them together sequentially such that they appear to be one contiguous stream."	"^ &lt;StitchReadStream&gt;"	"		| data current |		data := (1 to: 100) reading.		current := nil.		[	(current notNil and: [ current position &lt; 10 ]) ifTrue: [ Incomplete zero raise ].			current := data limiting: 10		] reading stitching rest	"	| first |	first := self get.	first isReadable ifTrue: [^StitchReadStream on: self first: first].	first isWritable ifTrue: [^StitchWriteStream on: self first: first].	^self error: 'Cannot read or write to this stream, what is it?'</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>substreaming</category><body package="Xtreams-Substreams">closing: aBlock	^(PositionWriteSubstream on: self)		closeBlock: aBlock;		yourself</body><body package="Xtreams-Substreams">ending: aMatchable	"Creates a substream that will end when aMatchable finds a match in the content passing through. aMatchable is either		* a block that is evaluated with each element - the stream ends when the block returns true		* a collection that is matched against the last elements written - the stream ends when the collection matches		* any other object - the stream ends when an equal object is written into the stream"	"	aMatchable	&lt;BlockClosure | Collection | Object&gt; the substream ending criteria		^&lt;TransformWriteStream&gt;	""			| stream slice |		stream := String new writing.		slice := stream ending: $j.		[ slice write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].		stream conclusion	""		| stream slice |		stream := String new writing.		slice := stream ending: 'mno'.		[ slice write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].		stream conclusion	""		| stream slice |		stream := String new writing.		slice := stream ending: [ :e | 'gmt' includes: e ].		[ slice write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].		stream conclusion	"	^self ending: aMatchable inclusive: false</body><body package="Xtreams-Substreams">ending: aMatchable inclusive: inclusive	"Creates a substream that will end when aMatchable finds a match in the content passing through. aMatchable is either		* a block that is evaluated with each element - the stream ends when the block returns true		* a collection that is matched against the last elements written - the stream ends when the collection matches		* any other object - the stream ends when an equal object is written into the stream"	"	aMatchable	&lt;BlockClosure | Collection | Object&gt; the substream ending criteria		inclusive &lt;Boolean&gt; should the matched elements be included in the stream contents or not		^&lt;TransformWriteStream&gt;	""		| stream slice |		stream := String new writing.		slice := stream ending: $j inclusive: true.		[ slice write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].		stream conclusion	""		| stream slice |		stream := String new writing.		slice := stream ending: 'mno' inclusive: true.		[ slice write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].		stream conclusion	""		| stream slice |		stream := String new writing.		slice := stream ending: [ :e | 'gmt' includes: e ] inclusive: true.		[ slice write: 'abcdefghijklmnopqrstuvxyz' ] on: Incomplete do: [].		stream conclusion	"	^aMatchable streamingWriteMatching: self inclusive: inclusive</body><body package="Xtreams-Substreams">limiting: limit	"Create a substream that will allow at most @limit number of elements written into the destination."	"	limit	&lt;Integer&gt;	maximum number of elements that can be written into destination		^&lt;LimitWriteStream&gt;"	"		| stream slice |		stream := String new writing.		slice := stream limiting: 5.		[ slice write: 'abcdefghi' ] on: Incomplete do: [].		stream conclusion	"	^LimitWriteSubstream on: self limit: limit</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>transforming</category><body package="Xtreams-Substreams">monitoring: aNotificationBlock every: aNotificationInterval	"Monitor the through-put of the receiver."	"	aNotificationBlock &lt;BlockClosure&gt;	the block to execute when notifying		aNotificationInterval &lt;Duration&gt;	how often to notify		^&lt;PositionWriteSubstream&gt;	"	| previousPosition timer start notifyBlock monitoring notifyProcess notifyFinished |	start := Time microsecondClock.	previousPosition := 0.	monitoring := nil.	timer := nil.	notifyFinished := false.	notifyBlock := [		aNotificationBlock cull: monitoring position cull: monitoring position - previousPosition cull: Time microsecondClock - start.		previousPosition := monitoring position].	notifyProcess := nil.	notifyProcess := [		[notifyBlock value. notifyFinished] whileFalse: [notifyProcess suspend]] newProcess.	notifyProcess priority: ((Processor activeProcess priority + 1) min: 99).	monitoring := self closing: [		timer stop.		notifyProcess resume.		notifyFinished := true.		notifyProcess resume.		self close].	timer := Timer every: aNotificationInterval resume: notifyProcess.	^monitoring</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>substreaming</category><body package="Xtreams-Substreams">slicing	"From a writable stream, return a readable stream that acts as a prototype factory for the writable stream."	"	^&lt;ReadStream&gt;"	"(destination limiting: 10) slicing"	| substream |	substream := nil.	^[substream == nil ifFalse:		[substream close.		substream destinationAtEnd ifTrue: [Incomplete zero raise]].		substream := self copy]		reading			closeBlock: [				substream == nil ifFalse: [					substream close.					substream := nil].				destination close];			yourself</body><body package="Xtreams-Substreams">stitching	^self error: 'You can only stitch a read stream, however that read stream can return write streams and in so doing, you will create a stitching write stream.'</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>private</category><body package="Xtreams-Substreams">streamingReadMatching: aStream inclusive: tail	^TestReadSubstream on: aStream test: self inclusive: tail</body><body package="Xtreams-Substreams">streamingWriteMatching: aStream inclusive: tail	^TestWriteSubstream on: aStream test: self inclusive: tail</body></methods><methods><class-id>Core.Object</class-id> <category>private</category><body package="Xtreams-Substreams">streamingReadMatching: aStream inclusive: tail	^[:each | each == self] streamingReadMatching: aStream inclusive: tail</body><body package="Xtreams-Substreams">streamingWriteMatching: aStream inclusive: tail	^[:each | each == self] streamingWriteMatching: aStream inclusive: tail</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private</category><body package="Xtreams-Substreams">streamingMatchFailureFunction	"Compute the array that tells us how far we need to back up when a match fails. This is using the Knuth-Morris-Pratt matching algorithm"	| backtrack position candidate |	backtrack := #(0 1), (Array new: self size - 2). 	candidate := 1.	position := 3.	[position &lt;= self size] whileTrue: [		(self at: position - 1) = (self at: candidate)			ifTrue: [				candidate := candidate + 1.				backtrack at: position put: candidate.				position := position + 1]			ifFalse: [				candidate &gt; 1					ifTrue: [candidate := backtrack at: candidate]					ifFalse: [backtrack at: position put: 1. position := position + 1]]].	^backtrack</body><body package="Xtreams-Substreams">streamingReadMatching: aStream inclusive: tail	"Return a stream that produces substreams that separate by @pattern and include the pattern in the result if @tail is true.	 It uses the Knuth-Morris-Pratt algorithm, from Cormen et al.'s Algorithms, page 871. See also Gusfield's Alorithms on Strings, Trees and Sequences, page 23. This algorithm has the advantage in stream matching that it reads every character in the the text to be matched against exactly once, and never backtracks."	| backtrack |	backtrack := self streamingMatchFailureFunction.	^MatchReadSubstream on: aStream pattern: self backtrack: backtrack inclusive: tail</body><body package="Xtreams-Substreams">streamingWriteMatching: aStream inclusive: tail	"Return a stream that produces substreams that separate by @pattern and include the pattern in the result if @tail is true.	 It uses the Knuth-Morris-Pratt algorithm, from Cormen et al.'s Algorithms, page 871. See also Gusfield's Alorithms on Strings, Trees and Sequences, page 23. This algorithm has the advantage in stream matching that it reads every character in the the text to be matched against exactly once, and never backtracks."	| backtrack |	backtrack := self streamingMatchFailureFunction.	^MatchWriteSubstream on: aStream pattern: self backtrack: backtrack inclusive: tail</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class></st-source>