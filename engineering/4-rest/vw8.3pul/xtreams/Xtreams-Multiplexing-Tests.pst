<?xml version="1.0"?><st-source><!-- Name: Xtreams-Multiplexing-TestsNotice: The MIT LicenseCopyright 2011-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DbIdentifier: bear73DbTrace: 468778DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#any 'SUnitToo' '') #(#any 'Xtreams-Support' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Multiplexing' '') #(#any 'Xtreams-Transforms' ''))DialectVersion: VisualWorks 7.9PackageName: Xtreams-Multiplexing-TestsParcel: #('Xtreams-Multiplexing-Tests')PrerequisiteDescriptions: #(#(#name 'SUnitToo' #componentType #package) #(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Multiplexing' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package))PrerequisiteParcels: #(#('SUnitToo' '') #('Xtreams-Support' '') #('Xtreams-Core' '') #('Xtreams-Multiplexing' '') #('Xtreams-Transforms' ''))PrintStringCache: (8.2 - 0,tkogan)Version: 8.2 - 0Date: 11:27:50 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MultiplexingTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sockets server client timeoutDuration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Multiplexing-Tests</package></attributes></class><methods><class-id>Xtreams.MultiplexingTest</class-id> <category>running</category><body package="Xtreams-Multiplexing-Tests">debug	timeoutDuration := 1 hours.	^super debug</body></methods><methods><class-id>Xtreams.MultiplexingTest</class-id> <category>tests</category><body package="Xtreams-Multiplexing-Tests">testBidirectionalMarshaling	| serverInput serverOutput serverMarshaler clientInput clientOutput clientMarshaler |	self		server: [			serverMarshaler := ObjectMarshaler new.			serverOutput := server getOutputChannel.			serverInput := server getInputChannel.			"When debugging, BlockClosures that are normally clean, become full copies, so there is an outerContext which will pull in a LOT of data, which is not what we want in the test. So we create the block closure from a string instead."			(serverOutput marshaling: serverMarshaler) put: (Kernel.Compiler evaluate: '[3 + 4]').			self assert: (serverInput marshaling: serverMarshaler) get = 7]		client: [			clientMarshaler := ObjectMarshaler new.			clientInput := client getInputChannel.			clientOutput := client getOutputChannel.			(clientOutput marshaling: clientMarshaler) put:				(clientInput marshaling: clientMarshaler) get value]</body><body package="Xtreams-Multiplexing-Tests">testChannelMore	| phase1 result |	phase1 := Semaphore new.	self		server: [ | out |			out := server getOutputChannel.			out write: #[ 1 2 3 4 5 ].			phase1 wait.			1 milliseconds wait.			out write: #[ 6 7 8 9 0 ].			out close]		client: [			phase1 signal.			result := client getInputChannel rest.			self assert: result = #[ 1 2 3 4 5 6 7 8 9 0 ] ]</body><body package="Xtreams-Multiplexing-Tests">testChannelWindow	self		server: [server getOutputChannel write: (ByteArray new: Xtreams.Multiplexer.ChannelWindow + 1 withAll: 1); close]		client: [self assert: client getInputChannel rest = (ByteArray new: Xtreams.Multiplexer.ChannelWindow + 1 withAll: 1) ]</body><body package="Xtreams-Multiplexing-Tests">testDoubleChannel	| out1 out2 in1 in2 result1 result2 |	self		server: [			out1 := server getOutputChannel.			out1 write: #[ 1 2 ].			out2 := server getOutputChannel.			out1 write: #[ 3 4 ].			out2 write: #[ 5 6 7 8 ].			out1 close.			out2 close]		client: [			in1 := client getInputChannel.			in2 := client getInputChannel.			result2 := in2 rest.			result1 := in1 rest.			self assert: result2 = #[ 5 6 7 8 ].			self assert: result1 = #[ 1 2 3 4 ] ]</body><body package="Xtreams-Multiplexing-Tests">testDoubleClient	| out1 out2 in1 in2 result1 result2 |	self		server: [			out1 := server getOutputChannel.			out1 write: #[ 1 2 ].			out2 := server getOutputChannel.			out1 write: #[ 3 4 ].			out2 write: #[ 5 6 7 8 ].			out1 close.			out2 close]		client1: [			in1 := client getInputChannel.			result1 := in1 rest.			self assert: result1 = #[ 1 2 3 4 ] ]		client2: [			in2 := client getInputChannel.			result2 := in2 rest.			self assert: result2 = #[ 5 6 7 8 ] ]</body><body package="Xtreams-Multiplexing-Tests">testSingleChannel	self		server: [server getOutputChannel write: #[ 1 2 3 4 5 ]; close]		client: [self assert: client getInputChannel rest = #[ 1 2 3 4 5 ] ]</body><body package="Xtreams-Multiplexing-Tests">testSingleChannelGet	| output input result phase1 |	phase1 := Semaphore new.	self		server: [			output := server getOutputChannel.			phase1 wait.			10 timesRepeat: [output put: 1].			output close]		client: [			result := ByteArray new writing.			input := client getInputChannel.			phase1 signal.			10 timesRepeat: [result put: input get].			result := result conclusion.			self assert: result = #[ 1 1 1 1 1 1 1 1 1 1 ] ]</body></methods><methods><class-id>Xtreams.MultiplexingTest</class-id> <category>utilities</category><body package="Xtreams-Multiplexing-Tests">server: serverBlock client1: client1Block client2: client2Block	"For tests that must be able to write and read at the same time, where they may block on each."	|	timeout timeoutTimer		serverFailure serverProcess serverLock		client1Failure client1Process client1Lock		client2Failure client2Process client2Lock |	serverLock := Semaphore new.	client1Lock := Semaphore new.	client2Lock := Semaphore new.	timeout := serverFailure := client1Failure := client2Failure := false.	serverProcess :=		[serverBlock on: Error, SUnit.FailedAssertion do: [:exception |			serverLock signal.			serverFailure := true.			exception pass].		serverLock signal] newProcess.	serverProcess name: 'test-server'.	client1Process :=		[client1Block on: Error, SUnit.FailedAssertion do: [:exception |			client1Lock signal.			client1Failure := true.			exception pass].		client1Lock signal] newProcess.	client1Process name: 'test-client1'.	client2Process :=		[client2Block on: Error, SUnit.FailedAssertion do: [:exception |			client2Lock signal.			client2Failure := true.			exception pass].		client2Lock signal] newProcess.	client2Process name: 'test-client2'.	serverProcess resume.	client1Process resume.	client2Process resume.	timeoutTimer := Timer after: timeoutDuration do:		[serverProcess terminate.		client1Process terminate.		client2Process terminate.		timeout := true.		serverLock signal.		client1Lock signal.		client2Lock signal].	[serverLock wait.	client1Lock wait.	client2Lock] ensure: [		timeoutTimer stop.		self deny: serverFailure.		self deny: client1Failure.		self deny: client2Failure.		self deny: timeout]</body><body package="Xtreams-Multiplexing-Tests">server: serverBlock client: clientBlock	"For tests that must be able to write and read at the same time, where they may block on each."	|	timeout timeoutTimer		serverFailure serverProcess serverLock serverException		clientFailure clientProcess clientLock clientException |	serverLock := Semaphore new.	clientLock := Semaphore new.	timeout := serverFailure := clientFailure := false.	serverProcess :=		[serverBlock on: Error, SUnit.FailedAssertion do: [:exception |			serverLock signal.			serverException := exception.			serverFailure := true.			exception pass].		serverLock signal] newProcess.	serverProcess name: 'test-server'.	clientProcess :=		[clientBlock on: Error, SUnit.FailedAssertion do: [:exception |			clientLock signal.			clientException := exception.			clientFailure := true.			exception pass].		clientLock signal] newProcess.	clientProcess name: 'test-client'.	serverProcess resume.	clientProcess resume.	timeoutTimer := Timer after: timeoutDuration do:		[serverProcess terminate.		clientProcess terminate.		timeout := true.		serverLock signal.		clientLock signal].	[serverLock wait.	clientLock wait] ensure: [		timeoutTimer stop.		self deny: serverFailure.		self deny: clientFailure.		self deny: timeout]</body></methods><methods><class-id>Xtreams.MultiplexingTest</class-id> <category>initialize-release</category><body package="Xtreams-Multiplexing-Tests">setUp	super setUp.	timeoutDuration ifNil: [timeoutDuration := 3 seconds].	sockets := OS.SocketAccessor phonyPair.	self		server: [server := Multiplexer on: sockets first]		client: [client := Multiplexer on: sockets last].	"Enable if the tests fail, to see what the traffic is.""	server logger: Transcript writing.	client logger: Transcript writing"</body><body package="Xtreams-Multiplexing-Tests">tearDown	client close.	server close.	sockets reverseDo: #close.	super tearDown</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>