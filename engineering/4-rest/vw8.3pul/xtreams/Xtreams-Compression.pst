<?xml version="1.0"?><st-source><!-- Name: Xtreams-CompressionNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: Compression streams allow to compress/decompress bytes passing through the stream using ZLib deflate algorithm.CompressionWriteStream compresses bytes being written and writes the compressed content into the destination stream. The destination stream must be binary. The compression algorithm buffers the content being compressed, consequently the stream must be closed to sure that the entire compressed content is written into the destination stream.{{{	compressed := (ByteArray new writing compressing encoding: #ascii) write: 'Hello World!'; conclusion}}}CompressionReadStream treats the bytes produced by the source stream as compressed content and decompresses (inflates) it.{{{	(compressed reading compressing encoding: #ascii) rest}}}Since the read stream cannot estimate how much compressed content it needs to read in order to provide requested amount of bytes, some amount of read-ahead is likely to occur. This doesn't change the behavior of the API, but may need to be considered when reconfiguring a complex stream stack.DbIdentifier: bear73DbTrace: 468779DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#any 'Xtreams-Core' '') #(#any 'Compression-ZLib' ''))DisregardedPrerequisites: #(#(#name 'Xtreams-Support' #componentType #package))PackageName: Xtreams-CompressionParcel: #('Xtreams-Compression')PrerequisiteDescriptions: #(#(#name 'Xtreams-Core' #componentType #package) #(#name 'Compression-ZLib' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Core' '') #('Compression-ZLib' ''))PrintStringCache: (8.2 - 0,tkogan)Version: 8.2 - 0Date: 11:27:50 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Compression</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>library inflating finished </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.ZLib.ZLibInterface			</imports><category></category><attributes><package>Xtreams-Compression</package></attributes></class><comment><class-id>Xtreams.Compression</class-id><body>Deprecated class</body></comment><class><name>CompressWriteStream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>input output finished library </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.ZLib.*			</imports><category></category><attributes><package>Xtreams-Compression</package></attributes></class><comment><class-id>Xtreams.CompressWriteStream</class-id><body>Compresses the bytes (0..255) being written using the ZLib deflate algorithm and writes the compressed content into the destination stream which has to accept bytes as well.Note that the compression algorithm buffers the content being compressed, consequently the stream has to be closed in order to be sure that the entire compressed content was written into the destination stream.Instance Variables	zlib	&lt;ZLibInterface&gt; external interface to zlib	input	&lt;ByteArray&gt; fixed-space input buffer shared with zlib	output	&lt;ByteArray&gt; fixed-space output buffer shared with zlib	sourceAtEnd &lt;Boolean&gt; library &lt;ZLibInterface&gt; external interface to zlib	finished &lt;Boolean&gt;	library &lt;ZLibInterface&gt; external interface to zlib</body></comment><class><name>GZIPWriteStream</name><environment>Xtreams</environment><super>Xtreams.CompressWriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>compressionLevel crc </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.ZLib.*			</imports><category></category><attributes><package>Xtreams-Compression</package></attributes></class><comment><class-id>Xtreams.GZIPWriteStream</class-id><body>GZIPWriteStream uses ZLib library to compress data.Instance variables:	compressionLevel &lt;Number&gt; 	crc &lt;Number&gt;  cyclic redundancy checkImplementation is based on http://www.ietf.org/rfc/rfc1952.txt</body></comment><class><name>CompressReadStream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>input output unconsumedOut unconsumedIn sourceAtEnd library finished </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.ZLib.*			</imports><category></category><attributes><package>Xtreams-Compression</package></attributes></class><comment><class-id>Xtreams.CompressReadStream</class-id><body>Treats the bytes (0..255) produced by the source stream as ZLib compressed content and decompresses (inflates) them.Since the stream cannot estimate how much compressed content it needs to read in order to provide requested amount of bytes, some amount of read-ahead is likely to occur. This doesn't change the behavior of the API, but affects the overall state of the stream stack. Specifically, if the underlying byte stream contains more than just the compressed data, the compressing stream will likely read past the end of the compressed data, before it detects the end of the compressed data. Therefore, if possible, the underlying byte stream should end where the compressed data ends.Instance Variables	input	&lt;ByteArray&gt; fixed-space input buffer shared with zlib	output	&lt;ByteArray&gt; fixed-space output buffer shared with zlib	compression	&lt;Compression&gt;	unconsumedOut	&lt;SmallInteger&gt; how much of output was not processed yet	unconsumedIn	&lt;SmallInteger&gt; how much of input was not processed yet	sourceAtEnd &lt;Boolean&gt;	library &lt;ZLibInterface&gt; external interface to zlib	finished &lt;Boolean&gt;</body></comment><class><name>GZIPReadStream</name><environment>Xtreams</environment><super>Xtreams.CompressReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>checkCrc crc </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.ZLib.*			</imports><category></category><attributes><package>Xtreams-Compression</package></attributes></class><comment><class-id>Xtreams.GZIPReadStream</class-id><body>GZIPReadStream uses ZLib library to decompress data.Instance Variables:	checkCrc	&lt;Boolean&gt; checkCrc an option to verify uncompressed data using a cyclic redundancy check (CRC)	crc &lt;Number&gt;  cyclic redundancy checkImplementation is based on http://www.ietf.org/rfc/rfc1952.txt</body></comment><methods><class-id>Xtreams.Compression</class-id> <category>initialize-release</category><body package="Xtreams-Compression">deflate	inflating := false.	finished := false.	library deflateInit.</body><body package="Xtreams-Compression">inflate	inflating := true.	finished := false.	library inflateInit.</body><body package="Xtreams-Compression">initialize	library := ZLibInterface newUsingEngineAllocator</body><body package="Xtreams-Compression">release	inflating ifTrue: [ library inflateEnd ] ifFalse: [ library deflateEnd ].	finished := inflating := nil</body></methods><methods><class-id>Xtreams.Compression</class-id> <category>accessing</category><body package="Xtreams-Compression">finishInto: output do: action"This is called at the end to make sure that all the output is produced, at this point no more input is consumed. Note that not all output elements are necessarily produced with a single compression call (e.g. when the output is smaller than needed to accommodate all the output). After each compression call, the @action is invoked with the amount amount of output produced. The @action has to empty the output as it will likely be overwritten by next iteration. The @action must return a boolean indicating if another iteration is required. However next iteration happens only if finished is false. 	output	&lt;ByteArray&gt;	output buffer	action	&lt;BlockClosure&gt;	one argument block invoked after the compression action with amount of output produced; must return boolean (see above)	^&lt;Boolean&gt; finishedSince output is not an argument of the external call  it should be in fixed space to make sure it does not move before the call is made."	finished ifTrue: [^true].	[	library next_out: output; avail_out: output size; avail_in: 0.		finished := inflating ifTrue: [self doInflate: true] ifFalse: [self doDeflate: true].		(action value: output size - library avail_out) and: [ finished not ]	] whileTrue.	^finished</body><body package="Xtreams-Compression">finished	^finished</body><body package="Xtreams-Compression">update: count from: input into: output do: action"Run @count elements in the @input through the compression producing @output. Note that not all @count elements must be consumed with a single call (e.g. when the output is smaller than needed to consume all available input). After each compression call, the @action is invoked with amount of input consumed and amount of output produced. The @action must return a boolean indicating if another iteration with the current state of the input is required. The @action has to empty the output as it will likely be overwritten by next iteration.	count	&lt;SmallInteger&gt; amount of input in the input buffer	input	&lt;ByteArray&gt; input buffer	output	&lt;ByteArray&gt;	output buffer	action	&lt;BlockClosure&gt;	two argument block returning a boolean (see above)	^&lt;Boolean&gt; is compression finishedSince input and output are not passed as arguments of the external call, they should be in fixed space to make sure they do not move before the call is made."	library next_in: input; avail_in: count.	[	library next_out: output; avail_out: output size.		finished := inflating ifTrue: [self doInflate: false] ifFalse: [self doDeflate: false].		action value: count - library avail_in value: output size - library avail_out	] whileTrue.	^finished</body></methods><methods><class-id>Xtreams.Compression</class-id> <category>private</category><body package="Xtreams-Compression">doDeflate: finish	| errno |	errno := library cDeflate: library zstream flush: (finish ifTrue: [library Z_FINISH] ifFalse: [library Z_SYNC_FLUSH]).	errno == library Z_OK ifTrue: [^false].	errno == library Z_STREAM_END ifTrue: [^true].	self error: (library errorStringFor: errno)</body><body package="Xtreams-Compression">doInflate: finish	| errno |	errno := library cInflate: library zstream flush: (finish ifTrue: [library Z_FINISH] ifFalse: [library Z_NO_FLUSH]).	errno == library Z_OK ifTrue: [^false].	"We normally get Z_BUF_ERROR instead of Z_STREAM_END, because we often finish the input before we can use Z_FINISH."	(errno == library Z_STREAM_END or: [errno == library Z_BUF_ERROR and: [finish]]) ifTrue: [^true].	self error: (library errorStringFor: errno)</body></methods><methods><class-id>Xtreams.Compression class</class-id> <category>instance creation</category><body package="Xtreams-Compression">new	^super new initialize</body></methods><methods><class-id>Xtreams.Compression class</class-id> <category>accessing</category><body package="Xtreams-Compression">toolListIcon	^Tools.GeneralIcons deprecationWarning</body></methods><methods><class-id>Xtreams.CompressWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Compression">close	output ifNil: [^self].	self finishDo: [ :out | destination write: out from: output at: 1.  true].	super close.	self releaseResources</body><body package="Xtreams-Compression">contentsSpecies	^ByteArray</body><body package="Xtreams-Compression">initializeLibrary	finished := false.	library := ZLibInterface newUsingEngineAllocator.	library deflateInit.</body><body package="Xtreams-Compression">on: aSource		super on: aSource.	input := ByteArray newInFixedSpaceRecycledDefaultSize.	"output must be in fixed space, otherwise DLLCC will make a copy of it."	output := ByteArray newInFixedSpaceRecycledDefaultSize.	self initializeLibrary.</body><body package="Xtreams-Compression">releaseResources	| saved |	library deflateEnd.	saved := input.	input := nil.	saved == nil ifFalse: [ saved recycle ].	saved := output.	output := nil.	saved == nil ifFalse: [ saved recycle ].</body></methods><methods><class-id>Xtreams.CompressWriteStream</class-id> <category>private</category><body package="Xtreams-Compression">compress: count do: action"Run @count elements in the @input through the compression producing @output. Note that not all @count elements must be consumed with a single call (e.g. when the output is smaller than needed to consume all available input). After each compression call, the @action is invoked with amount of input consumed and amount of output produced. The @action must return a boolean indicating if another iteration with the current state of the input is required. The @action has to empty the output as it will likely be overwritten by next iteration.	count	&lt;SmallInteger&gt; amount of input in the input buffer	input	&lt;ByteArray&gt; input buffer	output	&lt;ByteArray&gt;	output buffer	action	&lt;BlockClosure&gt;	two argument block returning a boolean (see above)	^&lt;Boolean&gt; is compression finishedSince input and output are not passed as arguments of the external call, they should be in fixed space to make sure they do not move before the call is made."	library next_in: input; avail_in: count.	[	library next_out: output; avail_out: output size.		finished :=  self doDeflate: false.		action value: count - library avail_in value: output size - library avail_out	] whileTrue.	^finished</body><body package="Xtreams-Compression">doDeflate: finish	| errno |	errno := library cDeflate: library zstream flush: (finish ifTrue: [library Z_FINISH] ifFalse: [library Z_SYNC_FLUSH]).	errno == library Z_OK ifTrue: [^false].	errno == library Z_STREAM_END ifTrue: [^true].	self error: (library errorStringFor: errno)</body><body package="Xtreams-Compression">finishDo: action"This is called at the end to make sure that all the output is produced, at this point no more input is consumed. Note that not all output elements are necessarily produced with a single compression call (e.g. when the output is smaller than needed to accommodate all the output). After each compression call, the @action is invoked with the amount amount of output produced. The @action has to empty the output as it will likely be overwritten by next iteration. The @action must return a boolean indicating if another iteration is required. However next iteration happens only if finished is false. 	output	&lt;ByteArray&gt;	output buffer	action	&lt;BlockClosure&gt;	one argument block invoked after the compression action with amount of output produced; must return boolean (see above)	^&lt;Boolean&gt; finishedSince output is not an argument of the external call  it should be in fixed space to make sure it does not move before the call is made."	finished ifTrue: [^true].	[	library next_out: output; avail_out: output size; avail_in: 0.		finished := self doDeflate: true.		(action value: output size - library avail_out) and: [ finished not ]	] whileTrue.	^finished</body><body package="Xtreams-Compression">update: count from: inputBuffer into: outputBuffer do: action"Run @count elements in the @input through the compression producing @output. Note that not all @count elements must be consumed with a single call (e.g. when the output is smaller than needed to consume all available input). After each compression call, the @action is invoked with amount of input consumed and amount of output produced. The @action must return a boolean indicating if another iteration with the current state of the input is required. The @action has to empty the output as it will likely be overwritten by next iteration.	count	&lt;SmallInteger&gt; amount of input in the input buffer	input	&lt;ByteArray&gt; input buffer	output	&lt;ByteArray&gt;	output buffer	action	&lt;BlockClosure&gt;	two argument block returning a boolean (see above)	^&lt;Boolean&gt; is compression finishedSince input and output are not passed as arguments of the external call, they should be in fixed space to make sure they do not move before the call is made."	library next_in: inputBuffer; avail_in: count.	[	library next_out: outputBuffer; avail_out: outputBuffer size.		finished :=  self doDeflate: false.		action value: count - library avail_in value: outputBuffer size - library avail_out	] whileTrue.	^finished</body></methods><methods><class-id>Xtreams.CompressWriteStream</class-id> <category>accessing</category><body package="Xtreams-Compression">write: anInteger from: aSequenceableCollection at: startIndex	| count index |	anInteger isZero ifTrue: [^self].	count := anInteger.	index := startIndex.	[	| available |		available := count min: input size.		input replaceFrom: 1 to: available with: aSequenceableCollection startingAt: index.		count := count - available.		index := index + available.		self 			compress: available 			do: [ :in :out |					destination write: out from: output at: 1.					in &lt; available ].		count &gt; 0	] whileTrue.	^anInteger</body></methods><methods><class-id>Xtreams.GZIPWriteStream</class-id> <category>initialize-release</category><body package="Xtreams-Compression">close	|  total_in |	output ifNil: [^self].	self finishDo: [ :out | destination write: out from: output at: 1.  true].		"CRC32 (CRC-32) This contains a Cyclic Redundancy Check value of the uncompressed data computed according to CRC-32 algorithm used in the ISO 3309 standard and in section 8.1.1.6.2 of ITU-T recommendation V.42. "	1 to: 4 do: [:ind| destination write: (crc digitAt: ind)].	"ISIZE (Input SIZE) - This contains the size of the original (uncompressed) input data modulo 2^32"		total_in := library total_in.	1 to: 4 do: [:ind| destination write: (total_in digitAt: ind)].		destination close.	self releaseResources</body><body package="Xtreams-Compression">initializeLibrary"http://www.ietf.org/rfc/rfc1952.txt"	"The windowBits parameter is the base two logarithm of the window size (the size of the history buffer).  It should be in the range 8..15. Larger values of this parameter result in better compression at the expense of memory usage.  The default value is 15 for deflateInit.  Using negative windowBits is an undocumented feature of zlib to suppress the header and checksum generation."	| result |	library := ZLibInterface newUsingEngineAllocator.	result := library		cDeflateInit2: library zstream		level: compressionLevel		method: library Z_DEFLATED		windowBits: library MAX_WBITS negated		memLevel: library DEF_MEM_LEVEL		strategy: library Z_DEFAULT_STRATEGY		version: library version		streamSize: library z_stream dataSize.	result ~= library Z_OK ifTrue: [self error: 'zlib deflateInit: initialization failed'].		" ID1 (IDentification 1)  ID2 (IDentification 2)            These have the fixed values ID1 = 31 (0x1f, \037), ID2 = 139            (0x8b, \213), to identify the file as being in gzip format.   CM (Compression Method)            This identifies the compression method used in the file.  CM            = 0-7 are reserved.  CM = 8 denotes the 'deflate'            compression method, which is the one customarily used by            gzip and which is documented elsewhere."	"This contains a Cyclic Redundancy Check value of the uncompressed data"		crc := library cCrc32: 0 buffer: 0 length: 0.		library 		next_out: output fixedHeapAddress;		avail_out: output size.		destination		write: (GZipMagic digitAt: 1);		write: (GZipMagic digitAt: 2);		write: GZipDeflated.	7 timesRepeat: [ destination write: 0 ].</body><body package="Xtreams-Compression">on: aSource compressionLevel: anInteger	(anInteger between: ZLibInterface Z_BEST_SPEED and: ZLibInterface Z_BEST_COMPRESSION) ifFalse:		[self error: 'invalid compression level'].	compressionLevel := anInteger.		self on: aSource</body></methods><methods><class-id>Xtreams.GZIPWriteStream</class-id> <category>private</category><body package="Xtreams-Compression">compress: count  do: action	| maxedOut |	maxedOut :=  false.	library next_in: input; avail_in: count.	crc := library cCrc32: crc buffer: input  length: count.	[library avail_in &gt; 0 or: [maxedOut]] whileTrue: [		finished := self doDeflate: false.		maxedOut := library avail_out = 0.		library avail_out &lt; output size ifTrue:			[action value: count - library avail_in value: output size - library avail_out.			library next_out: output; avail_out: output size.]	].	^finished</body></methods><methods><class-id>Xtreams.GZIPWriteStream class</class-id> <category>instance creation</category><body package="Xtreams-Compression">on: aDestination  compressionLevel: anInteger	^self new on: aDestination  compressionLevel: anInteger</body></methods><methods><class-id>Xtreams.CompressReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Compression">close	output ifNil: [^self].	super close.	self releaseResources.</body><body package="Xtreams-Compression">contentsSpecies	^ByteArray</body><body package="Xtreams-Compression">initializeLibrary		library := ZLibInterface newUsingEngineAllocator.	library inflateInit.</body><body package="Xtreams-Compression">on: aSource		super on: aSource.	sourceAtEnd := false.	finished := false.	input := ByteArray newInFixedSpaceRecycledDefaultSize.	"output must be in fixed space, otherwise DLLCC will make a copy of it."	output := ByteArray newInFixedSpaceRecycledDefaultSize.	self initializeLibrary.	unconsumedOut := unconsumedIn := 0.</body><body package="Xtreams-Compression">releaseResources	| saved |	library inflateEnd.	saved := input.	input := nil.	saved == nil ifFalse: [ saved recycle ].	saved := output.	output := nil.	saved == nil ifFalse: [ saved recycle ].</body></methods><methods><class-id>Xtreams.CompressReadStream</class-id> <category>private</category><body package="Xtreams-Compression">decompress: count do: action"Run @count elements in the @input through the compression producing @output. Note that not all @count elements must be consumed with a single call (e.g. when the output is smaller than needed to consume all available input). After each compression call, the @action is invoked with amount of input consumed and amount of output produced. The @action must return a boolean indicating if another iteration with the current state of the input is required. The @action has to empty the output as it will likely be overwritten by next iteration.	count	&lt;SmallInteger&gt; amount of input in the input buffer	input	&lt;ByteArray&gt; input buffer	output	&lt;ByteArray&gt;	output buffer	action	&lt;BlockClosure&gt;	two argument block returning a boolean (see above)	^&lt;Boolean&gt; is compression finishedSince input and output are not passed as arguments of the external call, they should be in fixed space to make sure they do not move before the call is made."	library next_in: input; avail_in: count.	[	library next_out: output; avail_out: output size.		finished := self doInflate: false.		self processDecompressedBlock:  output size - library avail_out.		action value: count - library avail_in value: output size - library avail_out	] whileTrue.	^finished</body><body package="Xtreams-Compression">doInflate: finish	| errno |	errno := library cInflate: library zstream flush: (finish ifTrue: [library Z_FINISH] ifFalse: [library Z_NO_FLUSH]).	errno == library Z_OK ifTrue: [^false].	"We normally get Z_BUF_ERROR instead of Z_STREAM_END, because we often finish the input before we can use Z_FINISH."	(errno == library Z_STREAM_END or: [errno == library Z_BUF_ERROR and: [finish]]) ifTrue: [^true].	self error: (library errorStringFor: errno)</body><body package="Xtreams-Compression">finishDecompression</body><body package="Xtreams-Compression">finishDo: action"This is called at the end to make sure that all the output is produced, at this point no more input is consumed. Note that not all output elements are necessarily produced with a single compression call (e.g. when the output is smaller than needed to accommodate all the output). After each compression call, the @action is invoked with the amount amount of output produced. The @action has to empty the output as it will likely be overwritten by next iteration. The @action must return a boolean indicating if another iteration is required. However next iteration happens only if finished is false. 	output	&lt;ByteArray&gt;	output buffer	action	&lt;BlockClosure&gt;	one argument block invoked after the compression action with amount of output produced; must return boolean (see above)	^&lt;Boolean&gt; finishedSince output is not an argument of the external call  it should be in fixed space to make sure it does not move before the call is made."	finished ifTrue: [^true].	[	library next_out: output; avail_out: output size; avail_in: 0.		finished := self doInflate: true.		(action value: output size - library avail_out) and: [ finished not ]	] whileTrue.	^finished</body><body package="Xtreams-Compression">outputCopy: requested into: target at: start  	| copied |	unconsumedOut isZero ifTrue: [ ^0 ].	copied := unconsumedOut min: requested.	target replaceFrom: start to: start + copied - 1 with: output startingAt: 1.	unconsumedOut :=		unconsumedOut &gt; copied			ifTrue: [ "if there was more than was requested, realign the ouput buffer and exit"				output replaceFrom: 1 to: unconsumedOut - copied with: output startingAt: copied + 1.				unconsumedOut - copied ]			ifFalse: [ 0 ].	^copied</body><body package="Xtreams-Compression">processDecompressedBlock: aSize</body></methods><methods><class-id>Xtreams.CompressReadStream</class-id> <category>accessing</category><body package="Xtreams-Compression">read: anInteger into: aSequenceableCollection at: startIndex	| read requested start |	"make sure anything pending in the output buffer is completely consumed"	(read := self outputCopy: anInteger into: aSequenceableCollection at: startIndex) = anInteger ifTrue: [^anInteger].	requested := anInteger - read.	start := startIndex + read.	[	"process everything in the input buffer"		[ finished not and: [ unconsumedIn &gt; 0 ] ] whileTrue: [			self decompress: unconsumedIn do: [ :in :out |				(unconsumedIn := unconsumedIn - in) &gt; 0 ifTrue: [					input replaceFrom: 1 to: unconsumedIn with: input startingAt: in + 1 ].				unconsumedOut := out.				false "Do not continue" ].			(read := self outputCopy: requested into: aSequenceableCollection at: start) = requested ifTrue: [^anInteger].			requested := requested - read.			start := start + read ].		unconsumedIn &gt; 0 ifTrue: [ "This means that compressed content finished before the end of the source stream,			input has what we've consumed beyond the compressed content."			self finishDecompression.			(Incomplete on: aSequenceableCollection count: anInteger - requested at: startIndex) raise ].		"both input and output should be completely exhausted at this point;		we need to read more, but it's not clear how much since the input is compressed,		so let's attempt to read a full buffer."		sourceAtEnd ifFalse: [			unconsumedIn := [ source read: input size into: input at: 1 ] on: Incomplete do: [ :ex | sourceAtEnd := true. ex count ] ].		unconsumedIn isZero ifTrue: [			"There's no more input, but there might be some final bits of output in the compression state."			self finishDo: [ :out |				unconsumedOut := out.				(read := self outputCopy: requested into: aSequenceableCollection at: start) = requested ifTrue: [^anInteger].				requested := requested - read.				start := start + read.				true ].			self finishDecompression.			finished ifFalse: [ self error: 'The deflate stream terminated prematurely' ].			(Incomplete on: aSequenceableCollection count: anInteger - requested at: startIndex) raise  ].	] repeat.	^anInteger</body></methods><methods><class-id>Xtreams.GZIPReadStream</class-id> <category>accessing</category><body package="Xtreams-Compression">checkCrc	^checkCrc ifNil: [true]</body><body package="Xtreams-Compression">checkCrc: aBoolean	checkCrc := aBoolean</body></methods><methods><class-id>Xtreams.GZIPReadStream</class-id> <category>private</category><body package="Xtreams-Compression">finishDecompression	| fileCrcAndLength endOfCompressedInput |	self checkCrc ifFalse: [^nil ].		"Exact copy of GZipReadStream&gt;&gt;checkCrcAndLength"	fileCrcAndLength := UninterpretedBytes new: 8.	endOfCompressedInput := library next_in datum - input fixedHeapAddress.	input size - endOfCompressedInput &gt;= 8		ifTrue: [ fileCrcAndLength replaceBytesFrom: 1 to: 8 with: input startingAt: endOfCompressedInput  + 1 ]		ifFalse: [ | footerSplit |			"This means that some (possibly none) of the footer (crcAndLength) is already in the input buffer and some is still sitting in the sourceStream. We need to figure out what is the split and put the two pieces together. It's also possible to just skip back in the sourceStream based on the split value, but I don't think that imposing positionability on the sourceStream just to make this one bit a little easier is worth it."			footerSplit := input size - endOfCompressedInput. "how much of the footer is already in the inputBuffer"			fileCrcAndLength replaceBytesFrom: 1 to: footerSplit with: input startingAt: endOfCompressedInput + 1.			source next: 8 - footerSplit into: fileCrcAndLength startingAt: footerSplit + 1].	crc ~= (fileCrcAndLength unsignedLongAt: 1 bigEndian: false) ifTrue:		[self error: 'file crc error'].	library total_out ~= (fileCrcAndLength unsignedLongAt: 5 bigEndian: false) ifTrue:		[self error: 'file length error']</body><body package="Xtreams-Compression">processDecompressedBlock: aSize	self checkCrc ifTrue: [crc := library cCrc32: crc buffer: output  length: aSize]</body></methods><methods><class-id>Xtreams.GZIPReadStream</class-id> <category>initialize-release</category><body package="Xtreams-Compression">checkHeader	"Exact copy of GZipReadStream&gt;&gt;checkHeader"	| header flags |	header := (self source read: 10) asByteArray.	((header at: 1) ~= (GZipMagic digitAt: 1)	or: [(header at: 2) ~= (GZipMagic digitAt: 2)	or: [(header at: 3) ~= GZipDeflated]]) ifTrue:		[self error: 'input stream is not in gzip format'.		 ^false].	flags := header at: 4.	(flags anyMask: GZipEncryptFlag) ifTrue:		[self error:'Cannot decompress encrypted stream'.		 ^false].	(flags anyMask: GZipReservedFlags) ifTrue:		[self error:'Cannot decompress stream with unknown flags'.		 ^false].	(flags anyMask: GZipContinueFlag) ifTrue: "Number of multi-part archive - ignored"		[self source read; read]. 	(flags anyMask: GZipExtraField) ifTrue: "Extra fields - ignored"		[self source read: self source nextWord].	(flags anyMask: GZipNameFlag) ifTrue: "Original file name - ignored"		[self source skipThrough: 0].	(flags anyMask: GZipCommentFlag) ifTrue: "Comment - ignored"		[self source skipThrough: 0].	^true</body><body package="Xtreams-Compression">initializeLibrary	"The windowBits parameter is the base two logarithm of the window size (the size of the history buffer).  It should be in the range 8..15. Larger values of this parameter result in better compression at the expense of memory usage.  The default value is 15 for deflateInit.  Using negative windowBits is an undocumented feature of zlib to suppress the header and checksum generation."			| result |	library := ZLibInterface newUsingEngineAllocator.	result := library			cInflateInit2: library zstream			windowBits: library MAX_WBITS negated			version: library version			streamSize: library z_stream dataSize.	result ~= library Z_OK ifTrue:		[self error:  'zlib inflateInit2 initialization failed'].			"This contains a Cyclic Redundancy Check value of the uncompressed data"		crc := library cCrc32: 0 buffer: 0 length: 0.</body><body package="Xtreams-Compression">on: aSource		super on: aSource.	self checkHeader.</body></methods><methods><class-id>Xtreams.ReadStream</class-id> <category>transforming</category><body package="Xtreams-Compression">compressing	"Treats the bytes (0..255) produced by the source stream as ZLib compressed content and decompresses (inflates) them. The source must be binary."	"	^	&lt;CompressReadStream&gt;	""		| compressed |		compressed := (ByteArray new writing compressing encoding: #ascii) write: 'Hello World!'; conclusion.		(compressed reading compressing encoding: #ascii) rest.	"	^CompressReadStream on: self</body><body package="Xtreams-Compression">gzipCompressing	"Treats the bytes (0..255) produced by the source stream as ZLib compressed content and decompresses (inflates) them. The source must be binary."	"	^	&lt;GZIPReadStream&gt;	""		| compressed |		compressed := (ByteArray new writing gzipBestCompressing encoding: #ascii) write: 'Hello World!'; conclusion.		(compressed reading gzipCompressing encoding: #ascii) rest.	"	^GZIPReadStream on: self</body></methods><methods><class-id>Xtreams.WriteStream</class-id> <category>transforming</category><body package="Xtreams-Compression">compressing	"Compresses the bytes being written using the ZLib deflate compression method. The compressed content is written into the binary destination stream. The compression algorithm buffers the content being compressed, consequently the stream must be closed in order to ensure that the entire compressed content was written into the destination stream.	""	^	&lt;CompressWriteStream&gt;	""		| compressed |		compressed := (ByteArray new writing compressing encoding: #ascii) write: 'Hello World!'; conclusion.		(compressed reading compressing encoding: #ascii) rest.	"	^CompressWriteStream on: self</body><body package="Xtreams-Compression">gzipBestCompressing	^self gzipCompressing: ZLib.ZLibInterface Z_BEST_COMPRESSION</body><body package="Xtreams-Compression">gzipCompressing: anInteger	"	anInteger between: ZLibInterface Z_BEST_SPEED and: ZLibInterface Z_BEST_COMPRESSION		Compresses the bytes being written using the ZLib gzip compression method. The compressed content is written into the binary destination stream. The compression algorithm buffers the content being compressed, consequently the stream must be closed in order to ensure that the entire compressed content was written into the destination stream.	^	&lt;GZIPWriteStream&gt;		| compressed |		compressed := ((ByteArray new writing 						compression: ZLibInterface Z_BEST_COMPRESSION) 							encoding: #ascii) 								write: 'Hello World!'; 								conclusion.		(compressed reading compressing encoding: #ascii) rest.	"	^GZIPWriteStream on: self compressionLevel: anInteger</body><body package="Xtreams-Compression">gzipSpeedCompressing	^self gzipCompressing: ZLib.ZLibInterface Z_BEST_SPEED</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class></st-source>