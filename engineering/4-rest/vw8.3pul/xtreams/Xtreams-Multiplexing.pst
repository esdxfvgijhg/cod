<?xml version="1.0"?><st-source><!-- Name: Xtreams-MultiplexingNotice: The MIT LicenseCopyright 2011-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: This package implements a binary protocol for multiplexing read and write streams. The protocol intends to remain very simple, so that it can be implemented in other languages or implementations of Smalltalk if desired.	=== Multiplexing ===Multiplexing is the act of sharing a read/write between multiple green threads; fairly splitting up data based on their process priority. Only certain kinds of streams can be used in this manner; eg: unix domain sockets, tcp sockets. The streams must have the ability to be bi-directional.Every time the underlying stream is shared, a new "channel" is created, which acts as a substream. It is expected that each channel will run in its own green thread; but it is not necessary to do so. If you are running a multiplexer connected to itself with-in the same image, then you will need to run each multiplexer in its own thread. The first thing the multiplexer does is negotiate the protocol version, which will block on itself.{{{	| sockets server client |	sockets := OS.SocketAccessor phonyPair.	[[server := Multiplexer on: sockets first]		ensure: [sockets first close]] fork.	[[client := Multiplexer on: sockets last]		ensure: [sockets last close]] fork.}}}Once the multiplexer is established, one side can create a new output channel. This will inform the other side that the output channel exists and it can then fetch its corresponding input channel. Here you can see where separate threads or images is useful, because you cannot fetch the input channel on the 'client' until the server has initiated the action by getting an output channel.{{{	| output input |	output := server getOutputChannel.	input := client getInputChannel.}}}An output channel is a non-positionable binary write stream. An input channel is a non-positionable binary read stream. At this point you can communicate any kind of data across the stream you like. You can close the channels substream like normal and it will only close that channel, not the underlying stream. You must close the underlying stream when you are done.You do not have to close the underlying stream to stop multiplexing on it. Instead, you can close all substreams on it, then tell the multiplexer to #release and it will stop expecting input. This may not always work as expected, as the remote side may still be using the stream with a multiplexer. some sort of negotiation should be applied before performing this technique.	=== Multiplexer Protocol v0 ===Future protocols *must* honor older protocols. The first thing that transmits over the stream is a single byte version number. If this implementation is newer than the remote implementation, this implementation should not send commands that the remote implementation will not understand. If the remote implementation is newer than this implementation, it should not send this implementation commands it will not understand.Once negotiation is complete, the stream has four kinds of packets it will transmit. All tokens are sent as four byte little endian unsigned integers.	* ChannelOpen: <0> <channel id>		A new channel has been created by the remote side.	* ChannelClose: <1> <channel id>		A channel has been closed by the remote side.	* ChannelMore: <2> <channel id>		The remote side is requesting more data for a channel.	* ChannelData: <channel id> <packet size> <byte data x packet size>		The remote side has sent a packet of data for a channel.Channel id's start at 10, leaving some room for seven other commands without having to modify the ChannelData protocol. However, given the similarity of this protocol to the SSH2 multiplexing protocol, it seems unlikely many more forms of packets will be needed.The sending side will never send more than 2,000,000 bytes of data to the remote side at a time. Once that quota has been reached or the receiving side has consumed all the data that was sent to it, the remote side will send a ChannelMore packet, indicating it wants more data to be sent. This avoids one particular channel from saturating the underlying stream if it is not being read by the remote side. At most, each reading channel will buffer up to 2,000,000 bytes of unread data.When the sending side is sending small chunks of data and the receiving side is reading them quickly, you may end up with a protocol chattiness that is undesirable, eg: [-> Send 10 bytes. <- Read 10 bytes. <- Request more. -> Read request more] repeat. This is an undesirable use of the protocol and if this is happening (and creating noticeable latency over a network), buffer up your data before sending it, so that it can be sent in bulk.{{{	output := output buffering: 2000000}}}DbIdentifier: bear73DbTrace: 468777DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#any 'Xtreams-Support' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Terminals' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Substreams' ''))DialectVersion: VisualWorks 7.9PackageName: Xtreams-MultiplexingParcel: #('Xtreams-Multiplexing')PrerequisiteDescriptions: #(#(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Support' '') #('Xtreams-Core' '') #('Xtreams-Terminals' '') #('Xtreams-Transforms' '') #('Xtreams-Substreams' ''))PrintStringCache: (8.2 - 0,tkogan)Version: 8.2 - 0Date: 11:27:49 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>MultiplexWriteSubstream</name><environment>Xtreams</environment><super>Xtreams.WriteStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>waitingLock id quota multiplexer substreamClosed stateLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Multiplexing</package></attributes></class><comment><class-id>Xtreams.MultiplexWriteSubstream</class-id><body>MultiplexWriteSubstream is a write channel, which sends data through a multiplexer, up to its quota, which is granted more bytes once the remote side indicates it wants more from this channel.Instance Variables	id	&lt;Integer&gt;	the channel id	multiplexer	&lt;Multiplexer&gt;	the multiplexer we run on top of	quota		&lt;Integer&gt;		the number of bytes we're allowed to transmit before we must wait for a 'remote side wants more' message.	waitingLock	&lt;Semaphore&gt;	a lock we wait on when we've exhausted our quota	substreamClosed	&lt;Boolean&gt;	indicates that the stream was closed (remotely or locally)</body></comment><class><name>MultiplexReadSubstream</name><environment>Xtreams</environment><super>Xtreams.ReadStream</super><private>true</private><indexed-type>none</indexed-type><inst-vars>waitingLock id multiplexer substreamClosed stateLock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Multiplexing</package></attributes></class><comment><class-id>Xtreams.MultiplexReadSubstream</class-id><body>MultiplexReadSubstream is a read channel, which receives data in to its buffer from a Multiplexer.Instance Variables	id	&lt;Integer&gt;	the channel id	multiplexer	&lt;Multiplexer&gt;	the multiplexer we run on top of	stateLock	&lt;Semaphore&gt;	a lock to prevent incoming packets from the multiplexer disrupting the read operation of this stream	substreamClosed	&lt;Boolean&gt;	indicates that the stream was closed (remotely or locally)	waitingLock	&lt;Semaphore&gt;	a lock we wait on when expecting data to be sent from the remote side</body></comment><class><name>Multiplexer</name><environment>Xtreams</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input output version process channels inputUnsignedLong outputUnsignedLong outputMutex availableChannelsLock availableChannels identitiesNext logger channelsMutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Presenter</category><attributes><package>Xtreams-Multiplexing</package></attributes></class><comment><class-id>Xtreams.Multiplexer</class-id><body>A multiplexer protocol which takes an input and an output stream, connected to another remote multiplexer.Instance Variables	identitiesNext	&lt;Integer&gt;	the next channel identity to be allocated	input	&lt;ReadStream&gt;	the input stream the protocol reads from	inputUnsignedLong	&lt;InterpretedReadStream&gt;	the input stream as unsigned little endian longs	output	&lt;WriteStream&gt;	the output stream the protocol writes to	outputUnsignedLong	&lt;InterpretedWriteStream&gt;	the output stream as unsigned little endian longs	outputMutex	&lt;Semaphore&gt;	a mutex to ensure channel write streams do not clobber each other when transmitting data	availableChannels	&lt;SharedQueue&gt;	input channels that have been initiated by the remote side but not yet accepted by this side	availableChannelsLock	&lt;Semaphore&gt;	a lock to protect registering from consuming channels	logger	&lt;WriteStream&gt;	a write stream to record protocol messages to	process	&lt;Process&gt;	the process that reads packets from input	channels	&lt;(Array of: MultiplexReadSubstream) | (Array of: MultiplexWriteSubstream)&gt;	the active registered channels	channelsMutex	&lt;Semaphore&gt;	a mutex that protects the channels during register/deregister/lookup	version	&lt;Integer&gt;	the version of the protocol we're running as, negotiated with the remote sideShared Variables	ProtocolVersion	&lt;Integer&gt;	the maximum supported protocol version for this implementation. An actual running multiplexer may have run to at a lower version or reject the connection entirely.	ChannelOpen	&lt;Integer&gt;	the protocol command to open a new substream channel	ChannelClose	&lt;Integer&gt;	the protocol command to close an existing substream channel	ChannelMore	&lt;Integer&gt;	the protocol command to request more data for a substream channel	ChannelWindow	&lt;integer&gt;	the default size of the channel buffer window</body></comment><shared-variable><name>ChannelClose</name><environment>Xtreams.Multiplexer</environment><private>false</private><constant>false</constant><category>protocol - commands</category><attributes><package>Xtreams-Multiplexing</package></attributes></shared-variable><shared-variable><name>ChannelOpen</name><environment>Xtreams.Multiplexer</environment><private>false</private><constant>false</constant><category>protocol - commands</category><attributes><package>Xtreams-Multiplexing</package></attributes></shared-variable><shared-variable><name>ChannelMore</name><environment>Xtreams.Multiplexer</environment><private>false</private><constant>false</constant><category>protocol - commands</category><attributes><package>Xtreams-Multiplexing</package></attributes></shared-variable><shared-variable><name>ChannelWindow</name><environment>Xtreams.Multiplexer</environment><private>false</private><constant>false</constant><category>accessing</category><attributes><package>Xtreams-Multiplexing</package></attributes></shared-variable><shared-variable><name>ProtocolVersion</name><environment>Xtreams.Multiplexer</environment><private>false</private><constant>false</constant><category>protocol - version</category><attributes><package>Xtreams-Multiplexing</package></attributes></shared-variable><methods><class-id>Xtreams.MultiplexWriteSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Multiplexing">close	stateLock critical: [		substreamClosed ifFalse: [			multiplexer transmitChannelClose: id.			substreamClosed := true.			waitingLock signal]]</body><body package="Xtreams-Multiplexing">contentsSpecies	^destination contentsSpecies</body><body package="Xtreams-Multiplexing">on: aDestination multiplexer: aMultiplexer id: anInteger	self on: aDestination.	id := anInteger.	multiplexer := aMultiplexer.	waitingLock := Semaphore new.	stateLock := Semaphore forMutualExclusion.	substreamClosed := false.	self refill</body></methods><methods><class-id>Xtreams.MultiplexWriteSubstream</class-id> <category>accessing</category><body package="Xtreams-Multiplexing">put: anObject	substreamClosed ifTrue: [Incomplete zero raise].	quota isZero ifTrue: [waitingLock wait].	substreamClosed ifTrue: [Incomplete zero raise].	multiplexer transmitChannelData: id put: anObject</body><body package="Xtreams-Multiplexing">write: anInteger from: aSequenceableCollection at: startIndex	| count amount |	substreamClosed ifTrue: [(Incomplete on: aSequenceableCollection count: 0 at: startIndex) raise].	count := 0.	[count &lt; anInteger] whileTrue:		[quota isZero ifTrue: [waitingLock wait].		substreamClosed ifTrue: [(Incomplete on: aSequenceableCollection count: count at: startIndex) raise].		[amount := multiplexer transmitChannelData: id write: (quota min: (anInteger - count)) from: aSequenceableCollection at: startIndex + count]			on: Incomplete do: [:exception | (Incomplete on: aSequenceableCollection count: count + exception count at: startIndex) raise].		count := count + amount.		quota := quota - amount].	^anInteger</body></methods><methods><class-id>Xtreams.MultiplexWriteSubstream</class-id> <category>private</category><body package="Xtreams-Multiplexing">closed	stateLock critical: [		substreamClosed := true.		waitingLock signal]</body><body package="Xtreams-Multiplexing">refill	quota := Xtreams.Multiplexer.ChannelWindow.	waitingLock signal</body></methods><methods><class-id>Xtreams.MultiplexWriteSubstream class</class-id> <category>instance creation</category><body package="Xtreams-Multiplexing">on: aDestination multiplexer: aMultiplexer id: anInteger	^self new on: aDestination multiplexer: aMultiplexer id: anInteger</body></methods><methods><class-id>Xtreams.MultiplexReadSubstream</class-id> <category>initialize-release</category><body package="Xtreams-Multiplexing">close	stateLock critical: [		substreamClosed ifFalse: [			multiplexer transmitChannelClose: id.			substreamClosed := true.			waitingLock signal]]</body><body package="Xtreams-Multiplexing">contentsSpecies	^source contentsSpecies</body><body package="Xtreams-Multiplexing">on: aSource multiplexer: aMultiplexer id: anInteger	self on: aSource.	id := anInteger.	multiplexer := aMultiplexer.	waitingLock := Semaphore new.	stateLock := Semaphore forMutualExclusion.	substreamClosed := false</body></methods><methods><class-id>Xtreams.MultiplexReadSubstream</class-id> <category>private</category><body package="Xtreams-Multiplexing">closed	stateLock critical: [		substreamClosed := true.		waitingLock signal]</body><body package="Xtreams-Multiplexing">refill: size from: input	stateLock critical: [		source writing write: size from: input.		waitingLock signal]</body></methods><methods><class-id>Xtreams.MultiplexReadSubstream</class-id> <category>accessing</category><body package="Xtreams-Multiplexing">get	| object |	stateLock wait.	[source hasDataToRead] whileFalse:		[substreamClosed ifTrue:			[stateLock signal.			Incomplete zero raise].		multiplexer transmitChannelMore: id.		waitingLock excessSignals timesRepeat: [waitingLock wait].		stateLock signal.		waitingLock wait.		stateLock wait].	object := source get.	stateLock signal.	^object</body><body package="Xtreams-Multiplexing">read: anInteger into: aSequenceableCollection at: startIndex	| count amount |	anInteger isZero ifTrue: [^0].	count := 0.	[count &lt; anInteger] whileTrue: [		stateLock wait.		[amount := source read: anInteger - count into: aSequenceableCollection at: startIndex + count.		stateLock signal]			on: Incomplete do: [:exception |				substreamClosed ifTrue: [					stateLock signal.					(Incomplete on: aSequenceableCollection count: count + exception count at: startIndex) raise].				"Request more data from the remote side."				multiplexer transmitChannelMore: id.				"More data cannot signal waitingLock until stateLock is unlocked. We know we have fully consumed all the data in the buffer and that until stateLock is unlocked, waitingLock cannot be signalled. waitingLock may have been signalled multiple times before we locked stateLock though, so we must consume the excessSignals."				waitingLock excessSignals timesRepeat: [waitingLock wait].				"Release the stateLock so that incoming data can signal waitingLock at least once."				stateLock signal.				waitingLock wait.				amount := exception count].		count := count + amount].	^anInteger</body></methods><methods><class-id>Xtreams.MultiplexReadSubstream class</class-id> <category>instance creation</category><body package="Xtreams-Multiplexing">on: aSource multiplexer: aMultiplexer id: anInteger	^self new on: aSource multiplexer: aMultiplexer id: anInteger</body></methods><methods><class-id>Xtreams.Multiplexer</class-id> <category>initialize-release</category><body package="Xtreams-Multiplexing">cleanup	"Release all the locks."	availableChannelsLock signal.	channelsMutex critical: [		channels do: [:substream |			substream == nil ifFalse: [substream closed]]]</body><body package="Xtreams-Multiplexing">close	process terminate.	output close.	input close.	self cleanup</body><body package="Xtreams-Multiplexing">initialize	logger := nil.	availableChannelsLock := Semaphore new.	availableChannels := ElasticBuffer new: 10 class: Array.	outputMutex := Semaphore forMutualExclusion.	channelsMutex := Semaphore forMutualExclusion.	identitiesNext := self minimumIdentity.	channels := Array new: 32768.</body><body package="Xtreams-Multiplexing">input: anInput output: anOutput	input := anInput.	inputUnsignedLong := input interpreting: #unsignedLong_le.	output := anOutput.	outputUnsignedLong := output interpreting: #unsignedLong_le.	"Negotiate version. If our version is less than their version, we expect them to be nice to us or terminate the connection. If our version is more than their version, we should be nice to them and only use what they know."	self transmitProtocolVersion.	self processProtocolVersion.	"Start handling packets receiving."	process := [self process] newProcess.	process name: (Processor activeProcess name ifNil: [Processor activeProcess identityHash printString]), ' receiving'.	process resume</body><body package="Xtreams-Multiplexing">logger: aWriteStream	logger := aWriteStream</body></methods><methods><class-id>Xtreams.Multiplexer</class-id> <category>private - receiving</category><body package="Xtreams-Multiplexing">process	| type |	[		[type := inputUnsignedLong get] on: Incomplete, OS.OsError do: [:exception |			self log: ['received exception: ', exception description].			^self cleanup].		self process: type.	] repeat</body><body package="Xtreams-Multiplexing">process: type	type = ChannelOpen ifTrue: [^self processChannelOpen].	type = ChannelClose ifTrue: [^self processChannelClose].	type = ChannelMore ifTrue: [^self processChannelMore].	self processChannelData: type</body><body package="Xtreams-Multiplexing">processChannelClose	"A channel has been closed."	| id |	id := inputUnsignedLong get.	self log: ['received channel close: #', id printString].	channelsMutex critical: [		(channels at: id) closed.		channels at: id put: nil]</body><body package="Xtreams-Multiplexing">processChannelData: id	"A packet of data is available for one a read substreams."	| size channel |	channelsMutex critical: [channel := channels at: id].	size := inputUnsignedLong get.	channel == nil ifTrue: [		self log: ['received channel data (on closed channel): #', id printString, ' size: ', size printString, ' bytes'].		nil writing write: size from: input.		^self].	self log: ['received channel data: #', id printString, ' size: ', size printString, ' bytes'].	channel refill: size from: input</body><body package="Xtreams-Multiplexing">processChannelMore	"The remote side wants more data for a channel."	| id channel |	id := inputUnsignedLong get.	channelsMutex critical:		[(channel := channels at: id) == nil ifTrue: [			self log: ['received channel more (on closed channel): #', id printString].			^self].		self log: ['received channel more: #', id printString].		channel refill]</body><body package="Xtreams-Multiplexing">processChannelOpen	"The remote side has opened a new channel."	| id buffer channel |	id := inputUnsignedLong get.	self log: ['received channel open: #', id printString].	channelsMutex critical:		[channels size &lt; id ifTrue: [channels := channels growToAtLeast: id].		buffer := RingBuffer on: (input contentsSpecies new: ChannelWindow).		channel := MultiplexReadSubstream on: buffer multiplexer: self id: id.		channels at: id put: channel].	availableChannels writing put: channel.	availableChannelsLock signal</body><body package="Xtreams-Multiplexing">processProtocolVersion	"We are sent the clients version, but it's useless to know how much newer they are, so we max out at our own protocol."	version := input get min: ProtocolVersion.	self log: ['received protocol version: ', version printString]</body></methods><methods><class-id>Xtreams.Multiplexer</class-id> <category>private</category><body package="Xtreams-Multiplexing">log: aMessage	| hash |	logger == nil ifTrue: [^self].	hash := String new writeStream.	self identityHash printOn: hash paddedWith: $0 to: 8 base: 16.	logger		cr; print: Time millisecondClockValue;		space; write: hash contents;		space; write: aMessage value</body><body package="Xtreams-Multiplexing">maximumIdentity	^4294967296</body><body package="Xtreams-Multiplexing">minimumIdentity	^10</body><body package="Xtreams-Multiplexing">nextIdentityDo: aBlock	"Identities will tend toward moving upwards from the minimum. Identities will be re-used eventually, when the current sized substreams equals the next identity. If there are no free slots, the substreams is grown. It is possible for a false 'give me more data' signal to be sent to a write substream if an identity is re-used. The chances of this happening are low and if it does happen, the consequences are that the stream will get a slightly higher quota, temporarily."	channelsMutex critical: [		[identitiesNext &lt;= channels size] whileTrue: [			(channels at: identitiesNext) isNil ifTrue: [^channels at: identitiesNext put: (aBlock value: identitiesNext)].			identitiesNext := identitiesNext + 1].		identitiesNext := self minimumIdentity.		[identitiesNext &lt;= channels size] whileTrue: [			(channels at: identitiesNext) isNil ifTrue: [^channels at: identitiesNext put: (aBlock value: identitiesNext)].			identitiesNext := identitiesNext + 1].		identitiesNext &gt;= self maximumIdentity ifTrue: [self error: 'identities exhausted'].		channels changeSizeTo: channels size + 32768.		^channels at: identitiesNext put: (aBlock value: identitiesNext)]</body></methods><methods><class-id>Xtreams.Multiplexer</class-id> <category>private - transmitting</category><body package="Xtreams-Multiplexing">transmitChannelClose: id	"Tell the remote side we are closing a channel."	self log: ['transmit channel close: #', id printString].	outputMutex critical:		[outputUnsignedLong put: ChannelClose.		outputUnsignedLong put: id.		output flush].	channelsMutex critical: [channels at: id put: nil]</body><body package="Xtreams-Multiplexing">transmitChannelData: id put: anObject	"Tell the remote side we have some data for a channel. It is the responsibility of MultiplexWriteSubstream not to go over its quota."	self log: ['transmit channel data: #', id printString, ' size: 1 bytes'].	outputMutex critical:		[outputUnsignedLong put: id.		outputUnsignedLong put: 1.		output put: anObject.		output flush.		Processor yield]</body><body package="Xtreams-Multiplexing">transmitChannelData: id write: anInteger from: aSequenceableCollection at: startIndex	"Tell the remote side we have some data for a channel. It is the responsibility of MultiplexWriteSubstream not to go over its quota."	| written |	self log: ['transmit channel data: #', id printString, ' size: ', anInteger printString, ' bytes'].	outputMutex critical:		[outputUnsignedLong put: id.		outputUnsignedLong put: anInteger.		written := output write: anInteger from: aSequenceableCollection at: startIndex.		output flush.		Processor yield].	^written</body><body package="Xtreams-Multiplexing">transmitChannelMore: id	"Tell the remote side we want more data for a channel."	(channelsMutex critical: [channels at: id]) = nil ifTrue: [self error: 'channel already closed'].	self log: ['transmit channel more: #', id printString].	outputMutex critical:		[outputUnsignedLong put: ChannelMore.		outputUnsignedLong put: id.		output flush]</body><body package="Xtreams-Multiplexing">transmitChannelOpen: id	"Tell the remote side we are opening a channel."	self log: ['transmit channel open: #', id printString].	outputMutex critical:		[outputUnsignedLong put: ChannelOpen.		outputUnsignedLong put: id.		output flush]</body><body package="Xtreams-Multiplexing">transmitProtocolVersion	self log: ['transmit protocol version: ', ProtocolVersion printString].	outputMutex critical: [output put: ProtocolVersion; flush]</body></methods><methods><class-id>Xtreams.Multiplexer</class-id> <category>api</category><body package="Xtreams-Multiplexing">getInputChannel	"Get the next available channel input. The remote side must have initiated it."	"^		&lt;MultiplexReadStream&gt;	new read channel substream"	availableChannelsLock wait.	^availableChannels reading get</body><body package="Xtreams-Multiplexing">getOutputChannel	"Get a new output channel. This will initiate an input channel on the remote side."	"^		&lt;MultiplexWriteStream&gt;	new write channel substream"	^self nextIdentityDo: [:id |		self transmitChannelOpen: id.		MultiplexWriteSubstream on: output multiplexer: self id: id].</body></methods><methods><class-id>Xtreams.Multiplexer class</class-id> <category>instance creation</category><body package="Xtreams-Multiplexing">input: anInput output: anOutput	^self new input: anInput output: anOutput</body><body package="Xtreams-Multiplexing">new	^super new initialize</body><body package="Xtreams-Multiplexing">on: aTerminal	^self input: aTerminal reading output: aTerminal writing</body></methods><methods><class-id>Xtreams.Multiplexer class</class-id> <category>class initialization</category><body package="Xtreams-Multiplexing">initialize	"self initialize"	ProtocolVersion := 0.	ChannelWindow := 2000000.	ChannelOpen := 0.	ChannelClose := 1.	ChannelMore := 2.</body></methods><initialize><class-id>Xtreams.Multiplexer</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>WriteStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>destination </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class><class><name>ReadStream</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>source </inst-vars><class-inst-vars></class-inst-vars><imports>			private Tools.BehaviorIcons			</imports><category>My Classes</category><attributes><package>Xtreams-Core</package></attributes></class></st-source>