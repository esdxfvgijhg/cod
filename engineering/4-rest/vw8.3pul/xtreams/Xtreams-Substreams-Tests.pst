<?xml version="1.0"?><st-source><!-- Name: Xtreams-Substreams-TestsNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DbIdentifier: bear73DbTrace: 468774DbUsername: tkoganDbVersion: 8.2 - 0DevelopmentPrerequisites: #(#(#any 'Xtreams-Support' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Substreams' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Core-Tests' '') #(#any 'SUnitToo' ''))DialectVersion: VisualWorks 7.9MonticelloPrefix: XTPackageName: Xtreams-Substreams-TestsParcel: #('Xtreams-Substreams-Tests')PrerequisiteDescriptions: #(#(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Core-Tests' #componentType #package) #(#name 'SUnitToo' #componentType #package))PrerequisiteParcels: #(#('Xtreams-Support' '') #('Xtreams-Core' '') #('Xtreams-Substreams' '') #('Xtreams-Transforms' '') #('Xtreams-Core-Tests' '') #('SUnitToo' ''))PrintStringCache: (8.2 - 0,tkogan)Url: http://www.squeaksource.com/Xtreams/Xtreams-SubstreamsTests-nice.3.mczVersion: 8.2 - 0Date: 11:27:50 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>StitchingTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Substreams-Tests</package></attributes></class><class><name>PositionSubstreamTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Substreams-Tests</package></attributes></class><class><name>MatchStreamTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Substreams-Tests</package></attributes></class><methods><class-id>Xtreams.StitchingTest</class-id> <category>tests</category><body package="Xtreams-Substreams-Tests">test2SimpleReadStreams	| stream contents |	stream := (1 to: 5) reading, (6 to: 7) reading.	contents := stream rest.	self assert: contents = (1 to: 7)</body><body package="Xtreams-Substreams-Tests">test3SimpleReadStreams	| stream contents |	stream := (1 to: 5) reading, (6 to: 7) reading, (8 to: 10) reading.	contents := stream rest.	self assert: contents = (1 to: 10)</body><body package="Xtreams-Substreams-Tests">test3SimpleReadStreamsPrepending	| stream contents |	stream := (1 to: 5) reading, ((6 to: 7) reading, (8 to: 10) reading).	contents := stream rest.	self assert: contents = (1 to: 10)</body><body package="Xtreams-Substreams-Tests">testIncompleteOnClose	| stream contents |	stream := ['abcd' reading closing: [Incomplete zero raise]] reading stitching.	contents := stream rest.	self assert: contents = 'abcd'.	stream := ['abcd' reading closing: [Incomplete zero raise]] reading stitching.	contents := 'WRONG'.	[stream read: 10] on: Incomplete do: [:ex | contents := ex contents].	self assert: contents = 'abcd'</body></methods><methods><class-id>Xtreams.PositionSubstreamTest</class-id> <category>tests</category><body package="Xtreams-Substreams-Tests">testNonPositionableSeekToEnd	| source i |	i := 0.	source := [ i &lt; 100 ifTrue: [ i := i + 1 ] ifFalse: [ Incomplete zero raise ] ] reading.	(source closing: []) -= 0.	self assert: i = 100</body></methods><methods><class-id>Xtreams.MatchStreamTest</class-id> <category>tests</category><body package="Xtreams-Substreams-Tests">testGet	| stream |	stream := '1-2--345' reading ending: '--'.	'1-2' do: [ :c | self assert: stream get = c ].	self should: [ stream get ] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testMatchingOnEncoding	| stream message crcr |	stream := (ByteArray new writing encoding: #ascii) setLineEndCRLF; write: '123\\456\\78\\\\abc\\de' withCRs; close; terminal.	message := stream reading ending: #[13 10 13 10 13 10 13 10].	message := message encoding: #ascii.	crcr := String with: Character cr with: Character cr.	#('123' '456' '78') do: [ :next || part |		part := message ending: crcr.		self assert: part rest = next ].	self assert: message rest isEmpty.</body><body package="Xtreams-Substreams-Tests">testNestedMatchStreams	| stream message |	stream := '123##456##78!!abc##de' reading.	message := stream ending: '!!'.	#('123' '456' '78') do: [ :next || part |		part := message ending: '##'.		self assert: part rest = next ].	self assert: message rest isEmpty.</body><body package="Xtreams-Substreams-Tests">testRepeatingPattern	| stream result |	stream := '123-45--6789-abc--def' reading.	result := (stream ending: '--') rest.	self assert: result = '123-45'.	result := (stream ending: '--') rest.	self assert: result = '6789-abc'</body><body package="Xtreams-Substreams-Tests">testSimplePattern	| stream result |	stream := '112123456' reading.	result := (stream ending: '123') rest.	self assert: result = '112'</body><body package="Xtreams-Substreams-Tests">testWorstCase	| stream result |	stream := 'abaabaaabaaaabaaaaabaaaabaaabaabab' reading.	result := (stream ending: 'aaaaab') rest.	self assert: result = 'abaabaaabaaaab'</body><body package="Xtreams-Substreams-Tests">testWriteRepeatingPattern	| output stream result count |	stream := (output := String new writing) ending: '--'.	count := [ stream write: '123-45--6789'  ] on: Incomplete do: [ :ex | ex count ].	self assert: count = 6.	result := output conclusion.	self assert: result = '123-45'</body></methods><methods><class-id>Xtreams.FiniteReadingWritingTests</class-id> <category>tests - substream slicing</category><body package="Xtreams-Substreams-Tests">testReadClosing	| closing closed |	self output write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	closed := false.	closing := self input closing: [ closed := true ].	self assert: (closing read: 3) = #[ 1 2 3 ].	self assert: (closing read: 4) = #[ 4 5 6 7 ].	self deny: closed.	self assert: (closing read: 2) = #[ 8 9 ].	self deny: closed.	self should: [closing get] raise: Incomplete.	self deny: closed.	closing close.	self assert: closed</body><body package="Xtreams-Substreams-Tests">testReadEndingBlock	| substream ender |	self output write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	ender := (self input ending: [:e | e = 4]) slicing.	substream := ender get.	self assert: (substream read: 3) = #[ 1 2 3 ].	self should: [substream get] raise: Incomplete.	substream := ender get.	self assert: (substream read: 5) = #[ 5 6 7 8 9 ].	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadEndingBlockPositioning	| substream ender |	self output write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	ender := (self input ending: [:e | e = 4]) slicing.	substream := ender get.	substream ++ 2.	self assert: substream get = 3.	self should: [substream ++ 3] raise: Incomplete.	self should: [substream -- 2] raise: Error. "not positionable"	substream := ender get.	self assert: substream get = 5.	substream -= 0.	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadEndingBlockTail	| substream ender |	self output write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	ender := (self input ending: [:e | e = 4] inclusive: true) slicing.	substream := ender get.	self assert: (substream read: 4) = #[ 1 2 3 4 ].	self should: [substream get] raise: Incomplete.	self should: [substream get] raise: Incomplete.	substream := ender get.	self assert: (substream read: 5) = #[ 5 6 7 8 9 ].	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadEndingCollection	| substream ender |	self output write: #[ 0 1 1 2 1 2 3 4 5 6 ]; close.	ender := (self input ending: #[ 1 2 3 ]) slicing.	substream := ender get.	self assert: (substream read: 4) = #[ 0 1 1 2 ].	self should: [substream get] raise: Incomplete.	substream := ender get.	self assert: (substream read: 3) = #[ 4 5 6 ].	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadEndingCollectionPositioning	| substream ender |	self output write: #[ 0 1 1 2 1 2 3 4 5 6 ]; close.	ender := (self input ending: #[ 1 2 3 ]) slicing.	substream := ender get.	substream ++ 3.	self assert: substream get = 2.	self should: [substream ++ 3] raise: Incomplete.	self should: [substream -- 2] raise: Error. "not positionable"	substream := ender get.	self assert: substream get = 4.	substream -= 0.	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadEndingCollectionTail	| substream ender |	self output write: #[ 0 1 1 2 1 2 3 4 5 6 ]; close.	ender := (self input ending: #[ 1 2 3 ] inclusive: true) slicing.	substream := ender get.	self assert: (substream read: 7) = #[ 0 1 1 2 1 2 3 ].	self should: [substream get] raise: Incomplete.	substream := ender get.	self assert: (substream read: 3) = #[ 4 5 6 ].	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadEndingObject	| substream ender |	self output write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	ender := (self input ending: 4) slicing.	substream := ender get.	self assert: (substream read: 3) = #[ 1 2 3 ].	self should: [substream get] raise: Incomplete.	substream := ender get.	self assert: (substream read: 5) = #[ 5 6 7 8 9 ].	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadEndingObjectPositioning	| substream ender |	self output write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	ender := (self input ending: 4) slicing.	substream := ender get.	substream ++ 2.	self assert: substream get = 3.	self should: [substream ++ 3] raise: Incomplete.	self should: [substream -- 2] raise: Error. "not positionable"	substream := ender get.	self assert: substream get = 5.	substream -= 0.	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadEndingObjectTail	| substream ender |	self output write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	ender := (self input ending: 4 inclusive: true) slicing.	substream := ender get.	self assert: (substream read: 4) = #[ 1 2 3 4 ].	self should: [substream get] raise: Incomplete.	self should: [substream get] raise: Incomplete.	substream := ender get.	self assert: (substream read: 5) = #[ 5 6 7 8 9 ].	self should: [substream get] raise: Incomplete.	self should: [ender get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadLimiting	| subinput limiter |	self output write: #[ 1 1 1 2 2 2 ]; close.	limiter := (self input limiting: 3) slicing.	subinput := limiter get.	self assert: (subinput read: 3) = #[ 1 1 1 ].	self should: [subinput get] raise: Incomplete.	subinput := limiter get.	self assert: (subinput read: 3) = #[ 2 2 2 ].	self should: [subinput get] raise: Incomplete.	self should: [limiter get get] raise: Incomplete.	self should: [limiter get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testReadLimitingPositioning	| subinput limiter |	self output write: #[ 1 1 1 2 2 2 ]; close.	limiter := (self input limiting: 3) slicing.	subinput := limiter get.	subinput ++ 2.	self assert: subinput rest = #[ 1 ].	subinput isPositionable		ifTrue: [ subinput -- 2.			self assert: subinput rest = #[ 1 1 ].			subinput += 1.			self assert: subinput rest = #[ 1 1 ].			subinput -= 2.			self assert: subinput rest = #[ 1 1 ] ]		ifFalse: [ self should: [ subinput -- 2 ] raise: Error ].	self should: [subinput get] raise: Incomplete.	subinput := limiter get.	self assert: (subinput read: 3) = #[ 2 2 2 ].	self should: [subinput get] raise: Incomplete.	self should: [limiter get get] raise: Incomplete.	self should: [limiter get] raise: Incomplete</body></methods><methods><class-id>Xtreams.FiniteReadingWritingTests</class-id> <category>tests - substream stitching</category><body package="Xtreams-Substreams-Tests">testReadStitchingChunks"Chunks are prefixed with size in the first byte. Below we have 3 chunks of size 1, 3 and 7, and terminating 0 chunk."	| chunks contents stitched |	chunks := (ByteArray withAll: (1 to: 14)), #[0].	self output write: chunks; close.	stitched := [ self input limiting: self input get ] reading stitching.	contents := stitched rest.	self assert: contents = #[2 4 5 6 8 9 10 11 12 13 14]</body><body package="Xtreams-Substreams-Tests">testReadStitchLimiting"Note that a plain [ self input limiting: 3 ] reading stitching stream would never end because it keeps generating empty limiting: streams at the end of the input.That's why additional measure is necessary to make sure the slice source eventually generates Incomplete." 	| limiter wasEmpty |	self output write: #[ 1 1 1 2 2 2 ]; close.	wasEmpty := false.	limiter := [			wasEmpty ifTrue: [ Incomplete zero raise ]. wasEmpty := true.			(self input doing: [ :e | wasEmpty := false ]) limiting: 3		] reading stitching.	self assert: limiter rest = #[ 1 1 1 2 2 2].	self should: [limiter get] raise: Incomplete</body></methods><methods><class-id>Xtreams.FiniteReadingWritingTests</class-id> <category>tests - substream slicing</category><body package="Xtreams-Substreams-Tests">testWriteClosing	| closing suboutput |	closing := (self output closing: [ :s | s put: 0 ]) slicing.	suboutput := closing get.	suboutput write: #[ 1 1 1 ].	suboutput := closing get.	suboutput write: #[ 2 2 2 ].	closing close.	self assert: (self input read: 8) = #[ 1 1 1 0 2 2 2 0 ]</body><body package="Xtreams-Substreams-Tests">testWriteClosingPositioning	| closing suboutput |	"If we're on a non-positionable stream, there's no point trying to test substream positioning"	self output isPositionable ifFalse: [^self].	closing := (self output closing: [ :s | s put: 0 ]) slicing.	suboutput := closing get.	suboutput write: #[ 1 3 3 ].	self assert: suboutput position = 3.	suboutput -- 2.	self assert: suboutput position = 1.	suboutput write: #[ 1 1 ].	suboutput := closing get.	suboutput write: #[ 2 2 3 ].	suboutput += 1.	self assert: suboutput position = 1.	suboutput ++ 1.	suboutput put: 2.	closing close.	self assert: (self input read: 8) = #[ 1 1 1 0 2 2 2 0 ]</body><body package="Xtreams-Substreams-Tests">testWriteEndingBlock	| ender |	ender := (self output ending: [:e | e = 4]) slicing.	self should: [ ender get write: #[ 1 2 3 4 5 6 7 8 9 ] ] raise: Incomplete.	self shouldnt: [ ender get write: #[ 5 6 7 8 9 ] ] raise: Incomplete.	ender close.	self assert: (self input read: 8) = #[ 1 2 3 5 6 7 8 9 ].	self should: [self input get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testWriteEndingBlockTail	| ender |	ender := (self output ending: [:e | e = 4] inclusive: true) slicing.	self should: [ ender get write: #[ 1 2 3 4 5 6 7 8 9 ] ] raise: Incomplete.	self shouldnt: [ ender get write: #[ 5 6 7 8 9 ] ] raise: Incomplete.	ender close.	self assert: (self input read: 9) = #[ 1 2 3 4 5 6 7 8 9 ].	self should: [self input get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testWriteEndingCollection	| ender |	ender := (self output ending: #[ 1 2 3 ]) slicing.	self should: [ ender get write: #[ 0 1 1 2 1 2 3 4 5 6 ] ] raise: Incomplete.	self shouldnt: [ ender get write: #[ 4 5 6 ] ] raise: Incomplete.	ender close.	self assert: (self input read: 7) = #[ 0 1 1 2 4 5 6 ].	self should: [self input get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testWriteEndingCollectionTail	| ender |	ender := (self output ending: #[ 1 2 3 ] inclusive: true) slicing.	self should: [ ender get write: #[ 0 1 1 2 1 2 3 4 5 6 ] ] raise: Incomplete.	self shouldnt: [ ender get write: #[ 4 5 6 ] ] raise: Incomplete.	ender close.	self assert: (self input read: 10) = #[ 0 1 1 2 1 2 3 4 5 6 ].	self should: [self input get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testWriteEndingObject	| ender |	ender := (self output ending: 4) slicing.	self should: [ ender get write: #[ 1 2 3 4 5 6 7 8 9 ] ] raise: Incomplete.	self shouldnt: [ ender get write: #[ 5 6 7 8 9 ] ] raise: Incomplete.	ender close.	self assert: (self input read: 8) = #[ 1 2 3 5 6 7 8 9 ].	self should: [self input get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testWriteEndingObjectTail	| ender |	ender := (self output ending: 4 inclusive: true) slicing.	self should: [ ender get write: #[ 1 2 3 4 5 6 7 8 9 ] ] raise: Incomplete.	self shouldnt: [ ender get write: #[ 5 6 7 8 9 ] ] raise: Incomplete.	ender close.	self assert: (self input read: 9) = #[ 1 2 3 4 5 6 7 8 9 ].	self should: [self input get] raise: Incomplete</body><body package="Xtreams-Substreams-Tests">testWriteLimiting	| limiting suboutput |	limiting := (self output limiting: 3) slicing.	suboutput := limiting get.	suboutput write: #[ 1 1 1 ].	self should: [suboutput put: 1] raise: Incomplete.	suboutput := limiting get.	suboutput write: #[ 2 2 2 ].	self should: [suboutput put: 2] raise: Incomplete.	suboutput := limiting get.	suboutput write: #[ 3 3 3 ].	self should: [suboutput put: 3] raise: Incomplete.	limiting close.	self assert: (self input read: 9) = #[ 1 1 1 2 2 2 3 3 3 ]</body><body package="Xtreams-Substreams-Tests">testWriteLimitingPositioning	| limiting suboutput |	"If we're not on a positioning stream, there's no point testing substream positioning"	self output isPositionable ifFalse: [^self].	limiting := (self output limiting: 3) slicing.	suboutput := limiting get.	suboutput write: #[ 1 4 4 ].	self assert: suboutput position = 3.	self assert: suboutput length = 3.	self assert: suboutput available = 0.	suboutput -- 2.	self assert: suboutput position = 1.	self assert: suboutput length = 3.	self assert: suboutput available = 2.	suboutput write: #[ 1 1 ].	self should: [suboutput put: 1] raise: Incomplete.	suboutput := limiting get.	suboutput write: #[ 2 2 3 ].	suboutput += 1.	self assert: suboutput position = 1.	self assert: suboutput length = 3.	self assert: suboutput available = 2.	suboutput ++ 1.	self assert: suboutput position = 2.	self assert: suboutput length = 3.	self assert: suboutput available = 1.	suboutput put: 2.	self should: [suboutput put: 2] raise: Incomplete.	limiting close.	self assert: (self input read: 6) = #[ 1 1 1 2 2 2 ]</body></methods><methods><class-id>Xtreams.FiniteReadingWritingTests</class-id> <category>tests - substream stitching</category><body package="Xtreams-Substreams-Tests">testWriteStitchingChunks"Chunks are prefixed with size in the first byte. Below we have 3 chunks of size 1, 3 and 7, and terminating 0 chunk."	| contents buffer |	buffer := RingBuffer on: (ByteArray new: 3).	[	(buffer writing limiting: buffer cacheSize)			closeBlock: [ self output put: buffer readSize; write: buffer ];			yourself	] reading stitching		write: (1 to: 7); flush;		write: (8 to: 15); close.	self output close.	contents := self input rest.	self assert: contents =		#[	3 1 2 3 "first chunk"			3 4 5 6 "second chunk"			1 7		"short chunk after flush"			3 8 9 10 "full chunk"			3 11 12 13 "full chunk"			2 14 15	"final short chunk" ]</body><body package="Xtreams-Substreams-Tests">testWriteStitchLimiting	| limiting |	limiting := [self output limiting: 3] reading stitching.	limiting write: #[ 1 1 1 2 2 2 3 3 3 ].	limiting close.	self assert: (self input read: 9) = #[ 1 1 1 2 2 2 3 3 3 ]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>FiniteReadingWritingTests</name><environment>Xtreams</environment><super>Xtreams.ReadingWritingTest</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Core-Tests</package></attributes></class></st-source>