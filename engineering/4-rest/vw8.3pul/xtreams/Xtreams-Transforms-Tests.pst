<?xml version="1.0"?><st-source><!-- Name: Xtreams-Transforms-TestsNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DbIdentifier: bear73DbTrace: 499146DbUsername: tkoganDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#any 'SUnitToo' '') #(#any 'Xtreams-Support' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Transforms' '') #(#any 'Xtreams-Core-Tests' '') #(#any 'Xtreams-Substreams' '') #(#any 'Xtreams-Terminals-Tests' ''))MonticelloPrefix: XTPackageName: Xtreams-Transforms-TestsParcel: #('Xtreams-Transforms-Tests')ParcelName: Xtreams-Transforms-TestsPrerequisiteDescriptions: #(#(#name 'SUnitToo' #componentType #package) #(#name 'Xtreams-Support' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Transforms' #componentType #package) #(#name 'Xtreams-Core-Tests' #componentType #package) #(#name 'Xtreams-Substreams' #componentType #package) #(#name 'Xtreams-Terminals-Tests' #componentType #package))PrerequisiteParcels: #(#('SUnitToo' '') #('Xtreams-Support' '') #('Xtreams-Core' '') #('Xtreams-Transforms' '') #('Xtreams-Core-Tests' '') #('Xtreams-Substreams' '') #('Xtreams-Terminals-Tests' ''))PrintStringCache: (8.3 - 2,tkogan)Url: http://www.squeaksource.com/Xtreams/Xtreams-TransformsTests-nice.6.mczVersion: 8.3 - 2Date: 11:27:50 AM June 16, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>JSONMarshalingTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Transforms-Tests</package></attributes></class><class><name>DuplicateTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Transforms-Tests</package></attributes></class><class><name>NullWriteStreamTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Transforms-Tests</package></attributes></class><class><name>InterpretingStreamTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms-Tests</package></attributes></class><class><name>StoreStringMarshalerTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars>stream marshaling log bytes marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms-Tests</package></attributes></class><class><name>MessagePackMarshalerTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars>stream marshaling log bytes marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms-Tests</package></attributes></class><class><name>ObjectMarshalerTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars>stream marshaling log bytes marshaler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Transforms-Tests</package></attributes></class><methods><class-id>Xtreams.JSONMarshalingTest</class-id> <category>tests</category><body package="Xtreams-Transforms-Tests">testArray	self assert: (JSON decode: '[ 1, 2, 3 ]') = #(1 2 3)</body><body package="Xtreams-Transforms-Tests">testFalse	self assert: (JSON decode: 'false') == false</body><body package="Xtreams-Transforms-Tests">testNull	self assert: (JSON decode: 'null') isNil</body><body package="Xtreams-Transforms-Tests">testNumber	self assert: (JSON decode: '1') = 1</body><body package="Xtreams-Transforms-Tests">testNumberNegative	self assert: (JSON decode: '-1') = -1</body><body package="Xtreams-Transforms-Tests">testNumberReal	self assert: (JSON decode: '42.42') - 42.42 &lt; 0.001</body><body package="Xtreams-Transforms-Tests">testNumberRealScientific	self assert: (JSON decode: '4.242e-10') - 4.242d-10 &lt; 0.1d-10</body><body package="Xtreams-Transforms-Tests">testObject	| result |	result := JSON decode: '{ "one" : 1, "two" : 2 }'.	self assert: result size = 2.	self assert: (result at: #one) = 1.	self assert: (result at: #two) = 2</body><body package="Xtreams-Transforms-Tests">testString	self assert: (JSON decode: '"hello"') = 'hello'</body><body package="Xtreams-Transforms-Tests">testTrue	self assert: (JSON decode: 'true') == true</body><body package="Xtreams-Transforms-Tests">testWriteArray	| stream result |	stream := String new writing marshaling: JSON.	stream put: #[1 2 3].	result := stream				close;				terminal.	self assert: result = '[1, 2, 3]'</body><body package="Xtreams-Transforms-Tests">testWriteCustomObject	| result inverse |	result := JSON encode: self.	inverse := JSON decode: result.	self assert: (inverse at: #example1) = 'Produced from JSONMarshalingTest'.	self assert: ((inverse at: #example2) isKindOf: Dictionary)</body><body package="Xtreams-Transforms-Tests">testWriteEscapedString	| stream result string |	string := ' " \ ' withCRs, ' \ '.	stream := String new writing marshaling: JSON.	stream put: string.	result := stream close; terminal.	self assert: result = '" \" \n  \\ "'</body><body package="Xtreams-Transforms-Tests">testWriteNumber	| stream result |	stream := String new writing marshaling: JSON.	stream put: 42.	result := stream close; terminal.	self assert: result = '42'</body><body package="Xtreams-Transforms-Tests">testWriteNumberReal	| stream result |	stream := String new writing marshaling: JSON.	stream put: 42.42.	result := stream close; terminal.	self assert: result = '42.42'</body><body package="Xtreams-Transforms-Tests">testWriteNumberRealScientific	| stream result |	stream := String new writing marshaling: JSON.	stream put: 10 ** -6.	result := stream close; terminal.	self assert: result = '1.0e-6'</body><body package="Xtreams-Transforms-Tests">testWriteObject	| stream result |	stream := String new writing marshaling: JSON.	stream put: ((Dictionary new)				at: 'one' put: 1;				at: 'two' put: 2;				yourself).	result := stream				close;				terminal.	self assert: result = '{"one": 1, "two": 2}'.	"Nested Dictionary:"	self		assert: (JSON encode: (Dictionary with: 'a' -&gt; (Dictionary with: 'b' -&gt; nil)))					= '{"a": {"b": null}}'</body><body package="Xtreams-Transforms-Tests">testWriteObjectPoint	| stream result |	stream := String new writing marshaling: JSON.	stream put: 3 @ 4.	result := stream				close;				terminal.	self assert: result = '{"x": 3, "y": 4}'</body><body package="Xtreams-Transforms-Tests">testWriteObjectWithSuperclassInstVars	| stream result object |	"Don't use superclass instance variables"	object := JSONWriteStream on: 'something'.	stream := String new writing marshaling: JSON.	stream put: object.	result := stream close; terminal.	self assert: result = '{"depth": 50}'.		"Use superclass instance variables. TestCase class has the extension #jsonHierarchyRoot"	object := InterpretingStreamTest selector: #aaa.	stream := String new writing marshaling: JSON.	stream put: object.	result := stream close; terminal.	self assert: result = '{"testSelector": "aaa", "stream": null}'</body><body package="Xtreams-Transforms-Tests">testWriteString	| stream result |	stream := String new writing marshaling: JSON.	stream put: 'hello'.	result := stream close; terminal.	self assert: result = '"hello"'</body><body package="Xtreams-Transforms-Tests">testWriteUnicodeString	| stream result text |	text := 'Příliš žluťoučký kůň úpěl ďábelské ódy'.	stream := String new writing marshaling: JSON.	stream put: text.	result := stream close; terminal.	self assert: result = ('"', text, '"')</body></methods><methods><class-id>Xtreams.JSONMarshalingTest</class-id> <category>private</category><body package="Xtreams-Transforms-Tests">streamingWriteJSONOn: stream	stream putObjectWith: [ :emitKeyValue |		emitKeyValue			value: #example1 value: 'Produced from JSONMarshalingTest';			value: #example2 value: Dictionary new ]</body></methods><methods><class-id>Xtreams.DuplicateTest</class-id> <category>tests</category><body package="Xtreams-Transforms-Tests">testDuplicateReading	| copy |	copy := Array new writing.	self assert: ((0 to: 255) reading duplicating: copy) rest = copy conclusion</body><body package="Xtreams-Transforms-Tests">testDuplicateReadingIncomplete	| original copy |	copy := ByteArray new writing.	[(#[0 1 2 3 4 5 6 7 8 9] reading duplicating: copy) read: 20] on: Incomplete do: [:incomplete | original := incomplete contents].	copy := copy conclusion.	self assert: original = #[0 1 2 3 4 5 6 7 8 9].	self assert: copy = #[0 1 2 3 4 5 6 7 8 9]</body><body package="Xtreams-Transforms-Tests">testDuplicateReadingPositionable	self assert: (self with: #(1 3 5 7 9) reading merge: #(2 4 6 8 10) reading sort: [:a :b | a &lt; b]) = #(1 2 3 4 5 6 7 8 9 10).	self assert: (self with: #(1 2 3 4 5) reading merge: #(6 7 8 9 10) reading sort: [:a :b | a &lt; b])  = #(1 2 3 4 5 6 7 8 9 10).	self assert: (self with: #(1 2 3 4 10) reading merge: #(5 6 7 8 9) reading sort: [:a :b | a &lt; b])  = #(1 2 3 4 5 6 7 8 9 10).	self assert: (self with: #(1 2 3 4 5) reading merge: #() reading sort: [:a :b | a &lt; b])  = #(1 2 3 4 5).	self assert: (self with: #() reading merge: #(6 7 8 9 10) reading sort: [:a :b | a &lt; b]) = #(6 7 8 9 10).	self assert: (self with: #(1 2 3 4 5) reading merge: #(1 2 3 4 5) reading sort: [:a :b | a &lt; b])  = #(1 1 2 2 3 3 4 4 5 5).</body><body package="Xtreams-Transforms-Tests">testDuplicateWriting	| original copy |	original := ByteArray new writing.	copy := ByteArray new writing.	(original duplicating: copy) write: (0 to: 255).	self assert: original conclusion = copy conclusion</body><body package="Xtreams-Transforms-Tests">testDuplicateWritingIncomplete	| original copy |	original := ByteArray new writing.	copy := ByteArray new writing.	[((original limiting: 10) duplicating: copy) write: (0 to: 255)] on: Incomplete do: [:incomplete | ].	original := original conclusion.	copy := copy conclusion.	self assert: original = #[0 1 2 3 4 5 6 7 8 9].	self assert: copy = #[0 1 2 3 4 5 6 7 8 9]</body><body package="Xtreams-Transforms-Tests">testDuplicateWritingPositionable	| original copy duplicate |	duplicate := (original := Array new writing) duplicating: (copy := Array new writing).	duplicate write: (0 to: 255); -- 55; ++ 25.	self assert: original conclusion = (0 to: 225) asArray.	self assert: copy conclusion = (0 to: 225) asArray.</body></methods><methods><class-id>Xtreams.DuplicateTest</class-id> <category>utility</category><body package="Xtreams-Transforms-Tests">with: aStream merge: anotherStream sort: aSortBlock	"Given two streams, assumed to be individually ordered, merge them into an ordered output by ensuring both streams are positionable, giving them the same duplicating stream, then reading them in the sort order."	| mergedStream positionableParamStream positionableSelfStream |	mergedStream := aStream contentsSpecies new writing.	positionableParamStream := anotherStream positioning duplicating: mergedStream.	positionableSelfStream := aStream positioning duplicating: mergedStream.	[[(aSortBlock value: positionableSelfStream peek value: positionableParamStream peek)		ifTrue: [positionableSelfStream get]		ifFalse: [positionableParamStream get]] repeat]			on: Incomplete			do: [positionableParamStream rest; close.				positionableSelfStream rest; close].	^mergedStream conclusion</body></methods><methods><class-id>Xtreams.NullWriteStreamTest</class-id> <category>tests</category><body package="Xtreams-Transforms-Tests">testWritingFrom	| freq |	freq := Bag new.	nil writing write: 500 from: (		(Random new reading collecting: [ :e | (e * 4) floor ])			doing: [ :e | freq add: e ]).	self assert: freq size = 500.	self assert: freq asSet size = 4.</body></methods><methods><class-id>Xtreams.InterpretingStreamTest</class-id> <category>tests</category><body package="Xtreams-Transforms-Tests">testDouble	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #double.	interpreting put: (SmallInteger minVal - 1.5).	interpreting put: (SmallInteger maxVal + 1.5).	interpreting := stream contents reading interpreting: #double.	self assert: interpreting get = (SmallInteger minVal - 1.5).	self assert: interpreting get = (SmallInteger maxVal + 1.5)</body><body package="Xtreams-Transforms-Tests">testFloat	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #float.	-50.0 to: 50.0 by: 0.5 do: [:each | interpreting put: each].	self assert: (stream contents reading interpreting: #float) rest = (-50 to: 50 by: 0.5)</body><body package="Xtreams-Transforms-Tests">testSignedChar	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #signedChar.	-120 to: 120 do: [:each | interpreting put: each].	interpreting := stream contents reading interpreting: #signedChar.	self assert: interpreting rest = (-120 to: 120)</body><body package="Xtreams-Transforms-Tests">testSignedLong	| interpreting negative positive |	stream := ByteArray new writing.	negative := -268435456. "SmallInteger minVal // 2 in 32-bits"	positive :=  268435455. "SmallInteger maxVal // 2 in 32-bits"	interpreting := stream interpreting: #signedLong.	interpreting put: negative.	interpreting put: positive.	interpreting := stream contents reading interpreting: #signedLong.	self assert: interpreting get = negative.	self assert: interpreting get = positive</body><body package="Xtreams-Transforms-Tests">testSignedLonglong	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #signedLonglong.	interpreting put: (SmallInteger minVal // 2) - 1.	interpreting put: (SmallInteger maxVal // 2) + 1.	interpreting := stream contents reading interpreting: #signedLonglong.	self assert: interpreting get = ((SmallInteger minVal // 2) - 1).	self assert: interpreting get = ((SmallInteger maxVal // 2) + 1)</body><body package="Xtreams-Transforms-Tests">testSignedShort	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #signedShort.	interpreting put: -31000.	interpreting put: 31000.	interpreting := stream contents reading interpreting: #signedShort.	self assert: interpreting get = -31000.	self assert: interpreting get = 31000</body><body package="Xtreams-Transforms-Tests">testUnsignedChar	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #char.	0 to: 255 do: [:each | interpreting put: each].	self assert: (stream contents reading interpreting: #char) rest asArray = (0 to: 255)</body><body package="Xtreams-Transforms-Tests">testUnsignedLong	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #long.	65000 to: 70000 do: [:each | interpreting put: each].	self assert: (stream contents reading interpreting: #long) rest asArray = (65000 to: 70000)</body><body package="Xtreams-Transforms-Tests">testUnsignedLongLong	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #longlong.	(SmallInteger maxVal - 100) to: (SmallInteger maxVal + 100) do: [:each | interpreting put: each].	self assert: (stream contents reading interpreting: #longlong) rest = ((SmallInteger maxVal - 100) to: (SmallInteger maxVal + 100))</body><body package="Xtreams-Transforms-Tests">testUnsignedShort	| interpreting |	stream := ByteArray new writing.	interpreting := stream interpreting: #short.	250 to: 270 do: [:each | interpreting put: each].	self assert: (stream contents reading interpreting: #short) rest asArray = (250 to: 270)</body></methods><methods><class-id>Xtreams.StoreStringMarshalerTest</class-id> <category>tests</category><body package="Xtreams-Transforms-Tests">testArray	marshaling put: (Array with: 1 with: -2.7 with: true).	self analyse.	self assert: marshaling get = (Array with: 1 with: -2.7 with: true)</body><body package="Xtreams-Transforms-Tests">testCharacters	marshaling write: 'testing'.	self analyse.	self assert: marshaling rest = #( $t $e $s $t $i $n $g )</body><body package="Xtreams-Transforms-Tests">testClass	marshaling put: UndefinedObject.	marshaling put: ObjectMarshalerTest.	self analyse.	self assert: marshaling get = UndefinedObject.	self assert: marshaling get = ObjectMarshalerTest</body><body package="Xtreams-Transforms-Tests">testDictionary	| result |	marshaling put: (Dictionary new at: 1 put: 'one'; at: #two put: 2; at: 'three' put: (4 @ 5); yourself).	self analyse.	result := marshaling get.	self assert: (result at: 1) = 'one'.	self assert: (result at: #two) = 2.	self assert: (result at: 'three') = (4 @ 5)</body><body package="Xtreams-Transforms-Tests">testFloat	marshaling put: 5.4.	marshaling put: -172.111.	marshaling put: -172.11102d.	self analyse.	self assert: marshaling get = 5.4.	self assert: marshaling get = -172.111.	self assert: marshaling get = -172.11102d</body><body package="Xtreams-Transforms-Tests">testInteger	marshaling put: 0.	marshaling put: 1.	marshaling put: 255.	marshaling put: 254.	marshaling put: -1.	marshaling put: SmallInteger maxVal.	marshaling put: SmallInteger minVal.	self analyse.	self assert: marshaling get = 0.	self assert: marshaling get = 1.	self assert: marshaling get = 255.	self assert: marshaling get = 254.	self assert: marshaling get = -1.	self assert: marshaling get = SmallInteger maxVal.	self assert: marshaling get = SmallInteger minVal.</body><body package="Xtreams-Transforms-Tests">testInterval	marshaling put: (1 to: 12 by: 2).	self analyse.	self assert: marshaling get = (1 to: 11 by: 2)</body><body package="Xtreams-Transforms-Tests">testLargeInteger	marshaling put: SmallInteger maxVal * 2.	marshaling put: SmallInteger minVal * 2.	marshaling put: 2 ** 256.	marshaling put: -2 ** 256.	self analyse.	self assert: marshaling get = (SmallInteger maxVal * 2).	self assert: marshaling get = (SmallInteger minVal * 2).	self assert: marshaling get = (2 ** 256).	self assert: marshaling get = (-2 ** 256)</body><body package="Xtreams-Transforms-Tests">testNamespace	marshaling put: Root.Smalltalk.	marshaling put: Root.Smalltalk.Xtreams.	self analyse.	self assert: marshaling get = Root.Smalltalk.	self assert: marshaling get = Root.Smalltalk.Xtreams</body><body package="Xtreams-Transforms-Tests">testOrderedCollection	| result |	marshaling put: (OrderedCollection new add: #test; add: 'test'; add: 5; yourself).	self analyse.	result := marshaling get.	self assert: result first = #test.	self assert: (result at: 2) = 'test'.	self assert: result last = 5</body><body package="Xtreams-Transforms-Tests">testPoint	marshaling put: -1 @ 2.	marshaling put: 3.4 @ -4.5.	marshaling put: 5 @ 5.	self analyse.	self assert: marshaling get = (-1 @ 2).	self assert: marshaling get = (3.4 @ -4.5).	self assert: marshaling get = (5 @ 5)</body><body package="Xtreams-Transforms-Tests">testSortedCollection	| sortBlock result |	sortBlock := Kernel.Compiler evaluate: '[:a :b | a &lt;= b]'.	marshaling put: ((SortedCollection sortBlock: sortBlock) add: 5; add: 4; add: 1; add: 3; add: 2; yourself).	self analyse.	result := marshaling get.	self assert: result asArray = #(1 2 3 4 5).	result add: 1.5.	self assert: result asArray = #(1 1.5 2 3 4 5)</body><body package="Xtreams-Transforms-Tests">testString	marshaling put: 'testing Ω'.	self analyse.	self assert: marshaling get = 'testing Ω'</body></methods><methods><class-id>Xtreams.StoreStringMarshalerTest</class-id> <category>initialize-release</category><body package="Xtreams-Transforms-Tests">setUp	marshaler := StoreStringMarshaler new.	stream := ByteArray new writing.	marshaling := stream marshaling: marshaler.	bytes := nil.	log := nil</body></methods><methods><class-id>Xtreams.StoreStringMarshalerTest</class-id> <category>private</category><body package="Xtreams-Transforms-Tests">analyse	bytes := stream conclusion.	log := (bytes reading encoding: #utf8) rest.	marshaling := bytes reading marshaling: marshaler class new</body></methods><methods><class-id>Xtreams.MessagePackMarshalerTest</class-id> <category>tests</category><body package="Xtreams-Transforms-Tests">dontTestDictionaryBig	"A dictionary with keys &gt; 16k starts to hit the hash limit and causes lots of reshuffling as the dictionary is build, during the start of the test and during the unmarshal of the test. Because of this, we have opted to exclude testing the big variant from the test suite.""	(self selector: #dontTestDictionaryBig) run"	| fixed small big |	big := Dictionary new: 65537.	1 to: 65537 do: [:i | big at: i put: 1].	small := Dictionary new: 255.	1 to: 255 do: [:i | small at: i put: i].	fixed := Dictionary new		at: 1 put: big;		at: 2 put: small;		yourself.	marshaling put: fixed.	marshaling put: small.	marshaling put: big.	self analyse.	self assert: marshaling get = fixed.	self assert: marshaling get = small.	self assert: marshaling get = big</body><body package="Xtreams-Transforms-Tests">testArray	| fixed small big |	big := Array new: 65537 withAll: 1.	small := (1 to: 255) asArray.	fixed := Array with: small with: big.	marshaling put: fixed.	marshaling put: small.	marshaling put: big.	self analyse.	self assert: marshaling get = fixed.	self assert: marshaling get = small.	self assert: marshaling get = big</body><body package="Xtreams-Transforms-Tests">testDictionary	| fixed small |	small := Dictionary new: 255.	1 to: 255 do: [:i | small at: i put: i].	fixed := Dictionary new		at: 1 put: small;		yourself.	marshaling put: fixed.	marshaling put: small.	self analyse.	self assert: marshaling get = fixed.	self assert: marshaling get = small</body><body package="Xtreams-Transforms-Tests">testFloatDouble	marshaling write: #(3.14 3.14159 3.141592653589793).	self analyse.	self assert: marshaling rest = #(3.14 3.14159 3.141592653589793)</body><body package="Xtreams-Transforms-Tests">testIntegers	| inrange outofrange |	outofrange := #(18446744073709551616 -9223372036854775809).	inrange := #(		0 1 126 127 128 255 256		32767 32768 32769		65535 65536 65537		4294967294 4294967295 4294967296		18446744073709551614 18446744073709551615		-1 -2 -32 -33		-127 -128 -255 -256		-32767 -32768 -32769		-65535 -65536 -65537		-2147483647 -2147483648 -2147483649		-9223372036854775807 -9223372036854775808).	marshaling write: inrange.	outofrange do: [:each | self should: [marshaling put: each] raise: Error].	self analyse.	self assert: marshaling rest = inrange</body><body package="Xtreams-Transforms-Tests">testRaw	| big |	big := ByteArray new: 100000 withAll: 1.	marshaling put: #[10 255 0].	marshaling put: (ByteArray withAll: (1 to: 255)).	marshaling put: big.	self analyse.	self assert: marshaling get = #[10 255 0].	self assert: marshaling get = (ByteArray withAll: (1 to: 255)).	self assert: marshaling get = big</body><body package="Xtreams-Transforms-Tests">testSingletons	marshaling put: nil.	marshaling put: true.	marshaling put: false.	self analyse.	self assert: marshaling get = nil.	self assert: marshaling get = true.	self assert: marshaling get = false</body></methods><methods><class-id>Xtreams.MessagePackMarshalerTest</class-id> <category>initialize-release</category><body package="Xtreams-Transforms-Tests">setUp	marshaler := MessagePackMarshaler new.	stream := ByteArray new writing.	marshaling := stream marshaling: marshaler.	bytes := nil.	log := nil</body></methods><methods><class-id>Xtreams.MessagePackMarshalerTest</class-id> <category>private</category><body package="Xtreams-Transforms-Tests">analyse	"Run an analysis on the stream contents to ensure it has integrity"	bytes := stream conclusion.	log := String new writing.	(ObjectAnalyseStream on: bytes reading marshaler: marshaler class new) do: [:each | log write: each].	log := log conclusion.	marshaling := bytes reading marshaling: marshaler class new</body></methods><methods><class-id>Xtreams.ObjectMarshalerTest</class-id> <category>tests</category><body package="Xtreams-Transforms-Tests">testArray	marshaling put: (Array with: 1 with: -2.7 with: true).	self analyse.	self assert: marshaling get = (Array with: 1 with: -2.7 with: true)</body><body package="Xtreams-Transforms-Tests">testBag	| bag |	bag := Bag new addAll: #(1 2 2 3); yourself.	marshaling put: bag.	self analyse.	self assert: marshaling get = bag</body><body package="Xtreams-Transforms-Tests">testBlockClosureClean	marshaling put: [].	marshaling put: [:x :y | x + y].	self analyse.	self assert: marshaling get value = nil.	self assert: (marshaling get value: 2 value: 3) = 5</body><body package="Xtreams-Transforms-Tests">testBlockClosureDirty	| a a_original a_copy |	a := 1.	a_original := [a].	marshaling put: a_original.	self analyse.	a_copy := marshaling get.	self assert: a_original value = 1.	self assert: a_copy value = 1.	a := 2.	self assert: a_original value = 2.	self assert: a_copy value = 1</body><body package="Xtreams-Transforms-Tests">testByteArray	marshaling put: #[1 2 3 4 5].	self analyse.	self assert: marshaling get = #[ 1 2 3 4 5 ]</body><body package="Xtreams-Transforms-Tests">testCharacters	marshaling write: 'testing'.	self analyse.	self assert: marshaling rest = #( $t $e $s $t $i $n $g )</body><body package="Xtreams-Transforms-Tests">testClass	marshaling put: UndefinedObject.	marshaling put: ObjectMarshalerTest.	self analyse.	self assert: marshaling get = UndefinedObject.	self assert: marshaling get = ObjectMarshalerTest</body><body package="Xtreams-Transforms-Tests">testDictionary	| result |	marshaling put: (Dictionary new at: 1 put: 'one'; at: #two put: 2; at: 'three' put: (4 @ 5); yourself).	self analyse.	result := marshaling get.	self assert: (result at: 1) = 'one'.	self assert: (result at: #two) = 2.	self assert: (result at: 'three') = (4 @ 5)</body><body package="Xtreams-Transforms-Tests">testFloat	marshaling put: 5.4.	marshaling put: -172.111.	marshaling put: -172.11102d.	self analyse.	self assert: marshaling get = 5.4.	self assert: marshaling get = -172.111.	self assert: marshaling get = -172.11102d</body><body package="Xtreams-Transforms-Tests">testInteger	marshaling put: 0.	marshaling put: 1.	marshaling put: 255.	marshaling put: 254.	marshaling put: -1.	marshaling put: SmallInteger maxVal.	marshaling put: SmallInteger minVal.	self analyse.	self assert: marshaling get = 0.	self assert: marshaling get = 1.	self assert: marshaling get = 255.	self assert: marshaling get = 254.	self assert: marshaling get = -1.	self assert: marshaling get = SmallInteger maxVal.	self assert: marshaling get = SmallInteger minVal.</body><body package="Xtreams-Transforms-Tests">testInterval	marshaling put: (1 to: 12 by: 2).	self analyse.	self assert: marshaling get = (1 to: 11 by: 2)</body><body package="Xtreams-Transforms-Tests">testLargeInteger	marshaling put: SmallInteger maxVal * 2.	marshaling put: SmallInteger minVal * 2.	marshaling put: 2 ** 256.	marshaling put: -2 ** 256.	self analyse.	self assert: marshaling get = (SmallInteger maxVal * 2).	self assert: marshaling get = (SmallInteger minVal * 2).	self assert: marshaling get = (2 ** 256).	self assert: marshaling get = (-2 ** 256)</body><body package="Xtreams-Transforms-Tests">testMissingClass	| missingClass missingInstance object |	missingClass := ObjectMarshaler basicNew		resolveClass: 'fulluble'		isMeta: false		format: (Behavior formatFromType: #none super: Object instVars: #('a' 'b' 'c'))		instVarNames: #('a' 'b' 'c').	missingInstance := missingClass new.	missingInstance instVarNamed: 'a' put: 1.	missingInstance instVarNamed: 'b' put: 2.	missingInstance instVarNamed: 'c' put: 3.	marshaling put: missingInstance.	self analyse.	object := marshaling get.	self assert: object class ~~ missingClass.	self assert: object class superclass = Object.	self assert: (object instVarNamed: 'a') = 1.	self assert: (object instVarNamed: 'b') = 2.	self assert: (object instVarNamed: 'c') = 3.	self assert: object a = 1.	self assert: object b = 2.	self assert: object c = 3.	object a: 4.	object b: 5.	object c: 6.	self assert: object a = 4.	self assert: object b = 5.	self assert: object c = 6.</body><body package="Xtreams-Transforms-Tests">testNamespace	marshaling put: Root.Smalltalk.	marshaling put: Root.Smalltalk.Xtreams.	self analyse.	self assert: marshaling get = Root.Smalltalk.	self assert: marshaling get = Root.Smalltalk.Xtreams</body><body package="Xtreams-Transforms-Tests">testOrderedCollection	| result |	marshaling put: (OrderedCollection new add: #test; add: 'test'; add: 5; yourself).	self analyse.	result := marshaling get.	self assert: result first = #test.	self assert: (result at: 2) = 'test'.	self assert: result last = 5</body><body package="Xtreams-Transforms-Tests">testPoint	marshaling put: -1 @ 2.	marshaling put: 3.4 @ -4.5.	marshaling put: 5 @ 5.	self analyse.	self assert: marshaling get = (-1 @ 2).	self assert: marshaling get = (3.4 @ -4.5).	self assert: marshaling get = (5 @ 5)</body><body package="Xtreams-Transforms-Tests">testProcess	"Warning: Do not insert a breakpoint in to this method as the breakpoint will marshal and pull in far too much information. Do not set through the method until after the process has been marshaled, otherwise the test runner will inject itself in to the process and that too can become marshaled. Instead, place a 'self halt' in to the test."	| processA processB processC processAhash processBhash processChash status |	status := Buffer new: 10 class: Array.	Root.Smalltalk at: #status put: status.	processA :=		[(Root.Smalltalk at: #status) put: Kernel.Processor activeProcess identityHash printString, '+1'.		Kernel.Processor activeProcess suspend.		(Root.Smalltalk at: #status) put: Kernel.Processor activeProcess identityHash printString, '+2'] newProcess.	processA priority: 100.	processAhash := processA identityHash printString.	marshaling put: processA.	processA resume.	self assert: status get = (processAhash, '+1').	marshaling put: processA.	processA resume.	self assert: status get = (processAhash, '+2').	self analyse.	processB := marshaling get.	processBhash := processB identityHash printString.	processC := marshaling get.	processChash := processC identityHash printString.	processB resume.	self assert: status get = (processBhash, '+1').	processC resume.	self assert: status get = (processChash, '+2').	processB resume.	self assert: status get = (processBhash, '+2').	Root.Smalltalk removeKey: #status</body><body package="Xtreams-Transforms-Tests">testRecursion	| value result |	value := nil asValue.	value value: value.	marshaling put: value.	self analyse.	result := marshaling get.	self assert: result value == result</body><body package="Xtreams-Transforms-Tests">testSortedCollection	| sortBlock result |	sortBlock := Kernel.Compiler evaluate: '[:a :b | a &lt;= b]'.	marshaling put: ((SortedCollection sortBlock: sortBlock) add: 5; add: 4; add: 1; add: 3; add: 2; yourself).	self analyse.	result := marshaling get.	self assert: result asArray = #(1 2 3 4 5).	result add: 1.5.	self assert: result asArray = #(1 1.5 2 3 4 5)</body><body package="Xtreams-Transforms-Tests">testString	marshaling put: 'testing Ω'.	self analyse.	self assert: marshaling get = 'testing Ω'</body><body package="Xtreams-Transforms-Tests">testStruct	| struct |	marshaling put: ((Protocols.Struct name: 'Test')					x1: 'testX1';					x2: 'testX2';					yourself).	self analyse.	struct := marshaling get.	self assert: struct x1 = 'testX1'.	self assert: struct x2 = 'testX2'.</body><body package="Xtreams-Transforms-Tests">testTranscript	marshaling put: Transcript.	marshaling put: (Array with: Transcript).	self analyse.	self assert: marshaling get == Transcript.	self assert: marshaling get = (Array with: Transcript)</body><body package="Xtreams-Transforms-Tests">testUninterpretedBytes	marshaling put: (UninterpretedBytes from: #[1 2 3 4 5]).	self analyse.	self assert: marshaling get = (UninterpretedBytes from: #[1 2 3 4 5])</body></methods><methods><class-id>Xtreams.ObjectMarshalerTest</class-id> <category>private</category><body package="Xtreams-Transforms-Tests">analyse	"Run an analysis on the stream contents to ensure it has integrity"	bytes := stream conclusion.	log := String new writing.	(ObjectAnalyseStream on: bytes reading marshaler: marshaler class new) do: [:each | log write: each].	log := log conclusion.	marshaling := bytes reading marshaling: marshaler class new</body></methods><methods><class-id>Xtreams.ObjectMarshalerTest</class-id> <category>initialize-release</category><body package="Xtreams-Transforms-Tests">setUp	marshaler := ObjectMarshaler new.	stream := ByteArray new writing.	marshaling := stream marshaling: marshaler.	bytes := nil.	log := nil</body></methods><methods><class-id>Xtreams.FiniteReadingWritingTests</class-id> <category>tests - interpreting</category><body package="Xtreams-Transforms-Tests">testInterpretingDoubles	| doubles result |	doubles := (1 to: 10) reading collect: [ :i | i reciprocal asDouble ].	(self output interpreting: #double) write: doubles; close.	result := (self input interpreting: #double) rest.	self assert: result = doubles</body></methods><methods><class-id>Xtreams.FiniteReadingWritingTests</class-id> <category>tests - transforming</category><body package="Xtreams-Transforms-Tests">testWriteTransformingOverLimitingPastEnd	| limited transferred |	limited := (self output limiting: 10) transforming: [ :in :out | out put: in get ].	self assert: (		[	limited write: (ByteArray withAll: (1 to: 20)).			false		] on: Incomplete do: [ :ex | ex count = 11 ] ).	transferred := self input read: 10.	self assert: transferred = (ByteArray withAll: (1 to: 10))</body><body package="Xtreams-Transforms-Tests">testWriteTransformingPastEnd	| count transformed |	count := 1.	transformed := self output transforming: [:in :out |		count = 2 ifTrue: [Incomplete zero raise].		out put: in get.		count := count + 1].	self assert: (		[	transformed write: #[ 1 2 3 ].			false		] on: Incomplete do: [ :ex | ex count = 1 ]).	transformed close.	self assert: self input get = 1.	self should: [self input get] raise: Incomplete.	self should: [self input get] raise: Incomplete</body></methods><methods><class-id>Xtreams.CollectionReadingWritingTest</class-id> <category>tests - encoding</category><body package="Xtreams-Transforms-Tests">testDecodingError	self assert: (#[80 197 153 195 173 197 190] reading encoding:#utf8) rest = 'Příž'.		"Test not enought data to finish decoding"	self assert: (#[80 197 ] reading encoding:#utf8) rest = 'P'.	self assert: (#[233 ] reading encoding:#utf8) rest = String new.</body><body package="Xtreams-Transforms-Tests">testDecodingFromRingBuffer	| size buff stream |	size := 65535.	buff := RingBuffer on: (ByteArray new: size).	1 to: size do: [ :i | buff put: 97 ].	stream := (Xtreams.PositionReadSubstream on: buff) encoding: #utf8.	self assert: stream rest size = size.</body></methods><methods><class-id>Xtreams.CollectionReadingWritingTest</class-id> <category>tests - transforming</category><body package="Xtreams-Transforms-Tests">testWriteTransformHexToByte	| hex2Byte decoder result |	decoder := [ :char | ('0123456789ABCDEF' indexOf: char asUppercase) - 1 ].	hex2Byte := 		self output transforming: [ :in :out |			out put: (((decoder value: in get) bitShift: 4) + (decoder value: in get)) ].	hex2Byte buffer: (ElasticBuffer on: (ByteString new: 16)).	hex2Byte write: 'ab'.	hex2Byte write: 'cdef'.	hex2Byte close.	self assert: self input get = 16rAB.	result := self input read: 2.	self assert: result = #[16rcd 16ref].</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - transforming</category><body package="Xtreams-Transforms-Tests">testCharacters	(self output encoding: #utf8)		setLineEndTransparent;		backspace; bell; cr; delete; ff; lf; q; qq; space; tab; vtab; escape;		close.	self assert: (self input read: 12) = #[8 7 13 127 12 10 39 34 32 9 11 27]</body><body package="Xtreams-Transforms-Tests">testDoing	| outing inning |	outing := ByteArray new writing.	(self output doing: [:each | outing put: each]) write: #[ 1 2 3 4 5 ].	self assert: outing contents = #[ 1 2 3 4 5 ].	inning := ByteArray new writing.	self assert: ((self input doing: [:each | inning put: each]) read: 5) = #[ 1 2 3 4 5 ].	self assert: inning contents = #[ 1 2 3 4 5 ]</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - interpreting</category><body package="Xtreams-Transforms-Tests">testInterpretingPoints	| points result |	points := (Random new reading transforming: [ :in :out | out put: in get @ in get ]) read: 5.	(self output interpreting: [ :b :i :o | b doubleAt: i put: o x. b doubleAt: i + 8 put: o y ] size: 16 )		write: points;		close.	result := (self input interpreting: [ :b :i | (b doubleAt: i) @ (b doubleAt: i + 8) ] size: 16 cacheSize: 5) read: points size.	self assert: points = result</body><body package="Xtreams-Transforms-Tests">testMarshaling	| object result in out |	object := Object new.	out := self output marshaling.	in := self input marshaling.	2 timesRepeat: 		[out put: ((1 to: 11) collect: [:each | (1 to: 11) collect: [:ea | object]]).		result := in get.		self assert: result size = 11.		self assert: (result allSatisfy: [:each | each allSatisfy: [:ea | ea == result first first]])]</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - transforming</category><body package="Xtreams-Transforms-Tests">testReadCollecting	| data |	data := #[ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ].	self output write: data.	self assert: ((self input collecting: [:e | e * e]) read: data size) = (ByteArray withAll: (data collect: [:e | e * e]))</body><body package="Xtreams-Transforms-Tests">testReadCollectingContentsSpeciesChanged	| data result |	data := ByteArray withAll: ((1 to: 16) collect: [:index | 65]).	self output write: data.	result :=		(self input collecting: [:e | Character codePoint: e])			contentsSpecies: String;			read: data size.	self assert: result = (String withAll: (data asArray collect: [:e | Character codePoint: e]))</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - encoding</category><body package="Xtreams-Transforms-Tests">testReadDecodingBase32	(self output encoding: #ascii)		write: 'JVQW4IDJOMQGI2LTORUW4Z3VNFZWQZLEFQQG433UEBXW43DZEBRHSIDINFZSA4TFMFZW63RMEBRHK5BAMJ4SA5DINFZSA43JNZTXK3DBOIQHAYLTONUW63RAMZZG63JAN52GQZLSEBQW42LNMFWHGLBAO5UGSY3IEBUXGIDBEBWHK43UEBXWMIDUNBSSA3LJNZSCYIDUNBQXIIDCPEQGCIDQMVZHGZLWMVZGC3TDMUQG6ZRAMRSWY2LHNB2CA2LOEB2GQZJAMNXW45DJNZ2WKZBAMFXGIIDJNZSGKZTBORUWOYLCNRSSAZ3FNZSXEYLUNFXW4IDPMYQGW3TPO5WGKZDHMUWCAZLYMNSWKZDTEB2GQZJAONUG64TUEB3GK2DFNVSW4Y3FEBXWMIDBNZ4SAY3BOJXGC3BAOBWGKYLTOVZGKLQ=';		close.	self assert: (((self input encoding: #ascii) encodingBase32 encoding: #ascii) read: 269) = 'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.'</body><body package="Xtreams-Transforms-Tests">testReadDecodingBase64	(self output encoding: #ascii)		write: 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4=';		close.	self assert: (((self input encoding: #ascii) encodingBase64 encoding: #ascii) read: 269) = 'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.'</body><body package="Xtreams-Transforms-Tests">testReadDecodingCRLF	| result |	self output write: #[104 101 108 108 111 13 10 119 111 114 108 100 10 13 13 10 10 ]; close.	result := (self input encoding: #ascii) read: 15.	self assert: result = 'hello\world\\\\' withCRs</body><body package="Xtreams-Transforms-Tests">testReadDecodingTransparent	| result bytes |	bytes := #[104 101 108 108 111 13 10 119 111 114 108 100 13 10 13 10 13 10 ].	self output write: bytes; close.	result := (self input encoding: #ascii) setLineEndTransparent read: bytes size.	self assert: result = (String withAll: (bytes asArray collect: #asCharacter))</body><body package="Xtreams-Transforms-Tests">testReadDecodingUTF16	| result bytes |	bytes := #[0 72 0 101 0 108 0 108 0 111 0 32 0 87 0 111 0 114 0 108 0 100 0 33].	self output write: bytes; close.	result := (self input encoding: #utf16) read: 12.	self assert: result = 'Hello World!'</body><body package="Xtreams-Transforms-Tests">testReadDecodingUTF8	| result bytes text |	text := 'Příliš žluťoučký kůň úpěl ďábelské ódy'.	bytes := #[80 197 153 195 173 108 105 197 161 32 197 190 108 117 197 165 111 117 196 141 107 195 189 32 107 197 175 197 136 32 195 186 112 196 155 108 32 196 143 195 161 98 101 108 115 107 195 169 32 195 179 100 121].	self output write: bytes; close.	result := (self input encoding: #utf8) read: text size.	self assert: result = text</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - transforming</category><body package="Xtreams-Transforms-Tests">testReadDuplicating	| copy contents |	contents := Array withAll: (0 to: 15).	copy := Array new writing.	self assert: (contents reading duplicating: copy) rest = contents.	self assert: copy conclusion = contents</body><body package="Xtreams-Transforms-Tests">testReadInjecting	self output write: #[ 1 2 3 4 ].	self assert: ((self input injecting: 0 into: [:all :each | all + each]) read: 4) = #[ 1 3 6 10 ]</body><body package="Xtreams-Transforms-Tests">testReadRejecting	self output write: #[ 1 2 3 4 5 6 7 8 9 ].	self assert: ((self input rejecting: #even) read: 5) = #[ 1 3 5 7 9 ]</body><body package="Xtreams-Transforms-Tests">testReadSelecting	self output write: #[ 1 2 3 4 5 6 7 8 9 ].	self assert: ((self input selecting: #even) read: 4) = #[ 2 4 6 8 ]</body><body package="Xtreams-Transforms-Tests">testReadTransforming1into2	| result |	self output write: #[ 1 2 3 ].	result :=		(self input transforming: [:in :out | | x | x := in get. out put: x; put: x])			read: 6.	self assert: result = #[ 1 1 2 2 3 3 ]</body><body package="Xtreams-Transforms-Tests">testReadTransforming2into1	| result |	self output write: #[ 1 2 3 4 ].	result :=		(self input transforming: [:in :out | in get. out put: in get])			read: 2.	self assert: result = #[ 2 4 ]</body><body package="Xtreams-Transforms-Tests">testReadTransformingPastEnd	| count transformed |	count := 1.	self output write: #[ 1 2 3 ]; close.	transformed := self input transforming: [:in :out |		count = 2 ifTrue: [Incomplete zero raise].		out put: in get.		count := count + 1].	self assert: transformed get = 1.	self should: [transformed get] raise: Incomplete.	self should: [transformed get] raise: Incomplete</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - interpreting</category><body package="Xtreams-Transforms-Tests">testReadUnsignedShortEndianness	self output write: #[ 16rFF 16r00 16rFF 00]; close.	self assert: (self input interpreting: #unsignedShort_le) get = 16rFF.	self assert: (self input interpreting: #unsignedShort_be) get = 16rFF00.</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - transforming</category><body package="Xtreams-Transforms-Tests">testWriteCollecting	| data |	data := 1 to: 15.	(self output collecting: [:e | e * e]) write: data.	self assert: (self input read: data size) = (ByteArray withAll: (data collect: [:e | e * e]))</body><body package="Xtreams-Transforms-Tests">testWriteCollectingIncompatibleContentSpecies	| data |	data := (1 to: 15) collect: [ :x | x @ 0 ].	(self output collecting: [:e | e x ]) write: data.	self assert: (self input read: data size) = (ByteArray withAll: (data collect: [:e | e x]))</body><body package="Xtreams-Transforms-Tests">testWriteCollectingMultipleBufferSize	| data |	data := (1 to: DefaultBufferSize + 500) collect: [ :i | i \\ 16 ].	self timeout: 1 seconds		server:			[(self output collecting: [:e | e * e])				write: data;				close.			true]		client: [(self input read: data size) = (ByteArray withAll: (data collect: [:e | e * e]))]</body><body package="Xtreams-Transforms-Tests">testWriteDuplicating	| original copy contents |	contents := Array withAll: (0 to: 15).	original := Array new writing.	copy := Array new writing.	(original duplicating: copy) write: contents.	self assert: original conclusion = contents.	self assert: copy conclusion = contents</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - encoding</category><body package="Xtreams-Transforms-Tests">testWriteEncodingBase32	| result |	((self output encoding: #ascii) encodingBase32 encoding: #ascii)		write: 'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.';		close.	result := (self input encoding: #ascii) read: 432.	self assert: result = 'JVQW4IDJOMQGI2LTORUW4Z3VNFZWQZLEFQQG433UEBXW43DZEBRHSIDINFZSA4TFMFZW63RMEBRHK5BAMJ4SA5DINFZSA43JNZTXK3DBOIQHAYLTONUW63RAMZZG63JAN52GQZLSEBQW42LNMFWHGLBAO5UGSY3IEBUXGIDBEBWHK43UEBXWMIDUNBSSA3LJNZSCYIDUNBQXIIDCPEQGCIDQMVZHGZLWMVZGC3TDMUQG6ZRAMRSWY2LHNB2CA2LOEB2GQZJAMNXW45DJNZ2WKZBAMFXGIIDJNZSGKZTBORUWOYLCNRSSAZ3FNZSXEYLUNFXW4IDPMYQGW3TPO5WGKZDHMUWCAZLYMNSWKZDTEB2GQZJAONUG64TUEB3GK2DFNVSW4Y3FEBXWMIDBNZ4SAY3BOJXGC3BAOBWGKYLTOVZGKLQ='</body><body package="Xtreams-Transforms-Tests">testWriteEncodingBase64	((self output encoding: #ascii) encodingBase64 encoding: #ascii)		write: 'Man is distinguished, not only by his reason, but by this singular passion from other animals, which is a lust of the mind, that by a perseverance of delight in the continued and indefatigable generation of knowledge, exceeds the short vehemence of any carnal pleasure.';		close.	self assert: ((self input encoding: #ascii) read: 360) = 'TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIGx1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpbiB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xlZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3VyZS4='</body><body package="Xtreams-Transforms-Tests">testWriteEncodingCRLF	| result isCRLF |	(self output encoding: #ascii)		write: 'hello\world\\\' withCRs;		close.	isCRLF := IOAccessor defaultClass = PCIOAccessor.	result := self input read: (isCRLF ifTrue: [18] ifFalse: [14]).		self assert: result = (isCRLF		ifTrue: [#[104 101 108 108 111 13 10 119 111 114 108 100 13 10 13 10 13 10 ] ]		ifFalse: [#[104 101 108 108 111 10 119 111 114 108 100 10 10 10 ] ])</body><body package="Xtreams-Transforms-Tests">testWriteEncodingTransparent	| data result bytes |	bytes := #[104 101 108 108 111 13 10 119 111 114 108 100 13 10 13 10 13 10 ].	data := String withAll: (bytes asArray collect: #asCharacter).	(self output encoding: #ascii)		setLineEndTransparent;		write: data;		close.	result := self input read: data size.	self assert: result = bytes</body><body package="Xtreams-Transforms-Tests">testWriteEncodingUTF16	| result bytes |	bytes := #[0 72 0 101 0 108 0 108 0 111 0 32 0 87 0 111 0 114 0 108 0 100 0 33].	(self output encoding: #utf16) write: 'Hello World!'; close.	result := self input read: 24.	self assert: result = bytes</body><body package="Xtreams-Transforms-Tests">testWriteEncodingUTF8	| result bytes text |	text := 'Příliš žluťoučký kůň úpěl ďábelské ódy'.	bytes := #[80 197 153 195 173 108 105 197 161 32 197 190 108 117 197 165 111 117 196 141 107 195 189 32 107 197 175 197 136 32 195 186 112 196 155 108 32 196 143 195 161 98 101 108 115 107 195 169 32 195 179 100 121].	(self output encoding: #utf8) write: text; close.	result := self input read: bytes size.	self assert: result = bytes</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - transforming</category><body package="Xtreams-Transforms-Tests">testWriteInjecting	(self output injecting: 0 into: [:all :each | all + each])		write: #[ 1 2 3 4 ]; close.	self assert: (self input read: 4) = #[ 1 3 6 10 ]</body><body package="Xtreams-Transforms-Tests">testWriteRejecting	(self output rejecting: #even) write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	self assert: (self input read: 5) = #[ 1 3 5 7 9 ]</body><body package="Xtreams-Transforms-Tests">testWriteSelecting	(self output selecting: #even) write: #[ 1 2 3 4 5 6 7 8 9 ]; close.	self assert: (self input read: 4) = #[ 2 4 6 8 ]</body><body package="Xtreams-Transforms-Tests">testWriteTransformHexToByte	| hex2Byte decoder result |	decoder := [ :char | ('0123456789ABCDEF' indexOf: char asUppercase) - 1 ].	hex2Byte := 		self output transforming: [ :in :out |			out put: (((decoder value: in get) bitShift: 4) + (decoder value: in get)) ].	hex2Byte buffer: (ElasticBuffer on: (String new: 16)).	hex2Byte write: 'ab'.	self assert: self input get = 16rAB.	hex2Byte write: 'cdef'.	hex2Byte close.	result := self input read: 2.	self assert: result = #[16rcd 16ref].</body><body package="Xtreams-Transforms-Tests">testWriteTransforming1into2	| result |	(self output transforming: [:in :out | | x | x := in get. out put: x; put: x])		write: #[ 1 2 3 ];		close.	result := (self input read: 6).	self assert: result = #[ 1 1 2 2 3 3 ]</body><body package="Xtreams-Transforms-Tests">testWriteTransforming2into1	| result |	(self output transforming: [:in :out | in get. out put: in get])		write: #[ 1 2 3 4 ];		close.	result := self input read: 2.	self assert: result = #[ 2 4 ]</body></methods><methods><class-id>Xtreams.ReadingWritingTest</class-id> <category>tests - interpreting</category><body package="Xtreams-Transforms-Tests">testWriteUnsignedShortEndianness	(self output interpreting: #unsignedShort_le) put: 16rFF.	(self output interpreting: #unsignedShort_be) put: 16rFF00.	self output close.	self assert: (self input read: 4) = #[ 16rFF 16r00 16rFF 00]</body></methods><methods><class-id>SUnit.TestCase class</class-id> <category>json encoding</category><body package="Xtreams-Transforms-Tests">jsonHierarchyRoot	^TestCase</body></methods><methods><class-id>Xtreams.JSONMarshalingTest</class-id> <category>tests</category><body package="Xtreams-Transforms-Tests">testWriteCollections	"Test collections objects here."	&lt;test&gt;	self assert: (JSON encode: Array new) = '[]'.	self assert: (JSON encode: #(0 1 'x' #y)) = '[0, 1, "x", "y"]'.	self		assert: (JSON encode:  (OrderedCollection				with: 0				with: 1				with: 'x'				with: #y))				= '[0, 1, "x", "y"]'</body><body package="Xtreams-Transforms-Tests">testWriteMaxDepthExceededError	"	Objects with references deeper than certain limit can not be JSON-ified. Encoding should result in error.	Here we use a circular reference for inifinite depth.	"	&lt;test&gt;	| a b |	a := Dictionary new.	b := Dictionary new.	a at: #b put: b.	self shouldnt: [JSON encode: a] raise: Error.	self shouldnt: [JSON encode: b] raise: Error.	"Make a circular reference"	b at: #a put: a.	self should: [JSON encode: a] raise: Error.	self should: [JSON encode: b] raise: Error</body><body package="Xtreams-Transforms-Tests">testWritePrimitiveTypes	"Test the primitive types for JSON encoding."	"Undefined object"	&lt;test&gt;	self assert: (JSON encode: nil) = 'null'.	"Just an object"	self assert: (JSON encode: Object new) = '{}'.	" Numbers: "	self assert: (JSON encode: 0) = '0'.	self assert: (JSON encode: 0.0) = '0.0'.	self assert: (JSON encode: Float.Pi) = Float.Pi printString.	" Booleans: "	self assert: (JSON encode: true) = 'true'.	self assert: (JSON encode: false) = 'false'.	"Some characters:"	self assert: (JSON encode: Character space) = '" "'.	self assert: (JSON encode: Character tab) = '"\t"'.	self assert: (JSON encode: Character cr) = '"\n"'.	self assert: (JSON encode: Character lf) = '"\r"'.	self assert: (JSON encode: (Character value: 0)) = '"\u0000"'.	"Strings:"	self assert: (JSON encode: '') = '""'.	self assert: (JSON encode: 'some string') = '"some string"'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>ReadingWritingTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars>output input </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			SUnit.*			</imports><category></category><attributes><package>Xtreams-Core-Tests</package></attributes></class><class><name>FiniteReadingWritingTests</name><environment>Xtreams</environment><super>Xtreams.ReadingWritingTest</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Core-Tests</package></attributes></class><class><name>CollectionReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteBoundlessReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class></st-source>