<?xml version="1.0"?><st-source><!-- Name: Xtreams-SupportNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.Comment: This package gathers various VW extensions and support classes for Xtreams that aren't portable. A port of Xtreams will need to reimplement these and potentially add other compatibility bits.DbIdentifier: bear73DbTrace: 487211DbUsername: jkottDbVersion: 8.2 - 1DialectVersion: VisualWorks 7.9Namespace: Smalltalk.XtreamsPackageName: Xtreams-SupportParcel: #('Xtreams-Support')PrintStringCache: (8.2 - 1,jkott)Version: 8.2 - 1Date: 11:27:49 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:49 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Xtreams</name><environment>Smalltalk</environment><private>false</private><imports>			private OS.IOAccessor			private Core.*			</imports><category>My Classes</category><attributes><package>Xtreams-Support</package></attributes></name-space><class><name>Encoder</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Support</package></attributes></class><comment><class-id>Xtreams.Encoder</class-id><body>Abstract character encoder class defines the API and maintains a registry of known encoders (Encoders). Also provides a hook to allow plugging in dialect specific encoders (DialectEncoder) as a secondary encoder resource.Shared Variables	DialectEncoder	&lt;Class&gt; optional dialect specific encoder class providing support for additional encodings	Encoders	&lt;Dictionary key: Symbol value: Class&gt; maps encoding names to encoders</body></comment><class><name>VWEncoder</name><environment>Xtreams</environment><super>Xtreams.Encoder</super><private>true</private><indexed-type>none</indexed-type><inst-vars>encoder skipRecord backupRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Support</package></attributes></class><comment><class-id>Xtreams.VWEncoder</class-id><body>Provides access to all encodings supported by VisualWorks.Instance Variables	encoder	&lt;StreamEncoder&gt; the encoder from classic EncodedStream	skipRecord	&lt;PositionRecord&gt; the skipRecord of the encoder to allow repeated decoding attempts	backupRecord	&lt;PositionRecord&gt; snapshot of the skipRecord that we can restore from</body></comment><class><name>InterpretedBytes</name><environment>Xtreams</environment><super>Core.UninterpretedBytes</super><private>true</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Xtreams-Support</package></attributes></class><comment><class-id>Xtreams.InterpretedBytes</class-id><body>Extends UninterpretedBytes to allow efficient streaming over it.</body></comment><class><name>RecyclingCenter</name><environment>Xtreams</environment><super>Core.Object</super><private>true</private><indexed-type>none</indexed-type><inst-vars>recycled mutex </inst-vars><class-inst-vars>objectspace1 fixedspace1 objectspaceN fixedspaceN cacheSize largeCacheSize objectspaceL fixedspaceL </class-inst-vars><imports></imports><category>My Classes</category><attributes><package>Xtreams-Support</package></attributes></class><comment><class-id>Xtreams.RecyclingCenter</class-id><body>RecyclingCenter allows to recycle collection instances to lighten the load on the garbage collector. This is especially useful when large buffers are being allocated and thrown away in rapid sequence (e.g. when a server is handling a large number of short lived connections). By reusing instances we can save a lot of GC cycles.Note however that it is critical to make sure that a recycled instance cannot be used before it is returned to the recycling pool (generally by making sure there are no references to it), otherwise an instance may end up being shared among unrelated objects. Similarly, #recycle must not be called more than once, otherwise it can be registered in the pool several times and it will end up being shared once two clients ask for a new instance of the same class. It is best to use the following pattern to recycle a 'cache' collection:	| saved |	saved := cache.	cache := nil.	saved == nil ifFalse: [ saved recycle ]Instance Variables	recycled	&lt;IdentityDictionary key: Class value: (Array of: SequenceableCollection)&gt; caches fixed number of collections (3) per sequenceable collection class	mutex	&lt;Semaphore&gt; Class Instance Variables	objectspace1	&lt;RecyclingCenter&gt; old space collections size 1	fixedspace1	&lt;RecyclingCenter&gt; fixed space collections size 1	objectspaceN	&lt;RecyclingCenter&gt; old space collections of cacheSize	fixedspaceN	&lt;RecyclingCenter&gt; fixed space collection of cacheSize	cacheSize	&lt;SmallInteger&gt; default collection size</body></comment><shared-variable><name>DefaultBufferSize</name><environment>Xtreams</environment><private>false</private><constant>false</constant><category>accessing</category><initializer>32768</initializer><attributes><package>Xtreams-Support</package></attributes></shared-variable><shared-variable><name>Encoders</name><environment>Xtreams.Encoder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><initializer>IdentityDictionary new</initializer><attributes><package>Xtreams-Support</package></attributes></shared-variable><shared-variable><name>DialectEncoder</name><environment>Xtreams.Encoder</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Xtreams-Support</package></attributes></shared-variable><methods><class-id>Xtreams.Encoder</class-id> <category>accessing</category><body package="Xtreams-Support">backupState</body><body package="Xtreams-Support">decodeFrom: aReadStream	^self subclassResponsibility</body><body package="Xtreams-Support">encode: aCharacter on: aWriteStream	^self subclassResponsibility</body><body package="Xtreams-Support">restoreState</body><body package="Xtreams-Support">streamingAsEncoder	^self</body></methods><methods><class-id>Xtreams.Encoder class</class-id> <category>instance creation</category><body package="Xtreams-Support">for: anEncoding	anEncoding isSymbol ifFalse: [ ^anEncoding streamingAsEncoder ].	^Encoders at: anEncoding ifAbsent: [		DialectEncoder			ifNil: [ self error: 'Unknown encoding!' ]			ifNotNil: [ :factory | factory for: anEncoding ] ]</body><body package="Xtreams-Support">streamingAsEncoder	^self new</body></methods><methods><class-id>Xtreams.Encoder class</class-id> <category>accessing</category><body package="Xtreams-Support">encoders	^Encoders ifNil: [ Encoders := IdentityDictionary new ]</body></methods><methods><class-id>Xtreams.VWEncoder</class-id> <category>accessing</category><body package="Xtreams-Support">backupState	backupRecord := skipRecord copy</body><body package="Xtreams-Support">decodeFrom: aReadStream	^encoder readFrom: aReadStream</body><body package="Xtreams-Support">encode: aCharacter on: aWriteStream	^encoder write: aCharacter on: aWriteStream</body><body package="Xtreams-Support">encoder	^encoder</body><body package="Xtreams-Support">restoreState	skipRecord restore: backupRecord</body></methods><methods><class-id>Xtreams.VWEncoder</class-id> <category>initialize-release</category><body package="Xtreams-Support">encoder: anEncoder	skipRecord := PositionRecord new.	encoder := anEncoder.	encoder skipRecord: skipRecord.</body><body package="Xtreams-Support">encoding: anEncoding	| newEncoder |	newEncoder := StreamEncoder new: anEncoding.	(newEncoder isKindOf: UTF16StreamEncoder) ifTrue: [ newEncoder bigEndian: true ].	self encoder: newEncoder</body></methods><methods><class-id>Xtreams.VWEncoder class</class-id> <category>instance creation</category><body package="Xtreams-Support">encoder: anEncoder	^self new encoder: anEncoder</body><body package="Xtreams-Support">for: anEncoding	^self new encoding: anEncoding</body></methods><methods><class-id>Xtreams.VWEncoder class</class-id> <category>class initialization</category><body package="Xtreams-Support">initialize	DialectEncoder := self</body></methods><methods><class-id>Xtreams.InterpretedBytes</class-id> <category>accessing</category><body package="Xtreams-Support">at: index	^self basicAt: index</body><body package="Xtreams-Support">at: index put: byte	^self basicAt: index put: byte</body><body package="Xtreams-Support">copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at index start 	until element at index stop."	| newSize |	newSize := stop - start + 1.	^(ByteArray withSize: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start</body><body package="Xtreams-Support">recycle	RecyclingCenter recycle: self</body><body package="Xtreams-Support">replaceElementsFrom: start to: stop withInterpretedBytes: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the 	receiver starting at index, repStart, in the collection, replacement. 	Answer the receiver."	^self replaceFrom: start to: stop with: replacement startingAt: repStart</body><body package="Xtreams-Support">replaceFrom: start to: stop with: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the 	receiver starting at index, repStart, in the collection, replacement. 	Answer the receiver. No range checks are performed, but 	overlapping replacements are handled correctly."	^self replaceBytesFrom: start to: stop with: replacement startingAt: repStart</body><body package="Xtreams-Support">size	^self sizeInBytes</body><body package="Xtreams-Support">startingAt: repStart replaceElementsIn: collection from: start to: stop	"This destructively replaces elements from start to stop in the 	collection starting at index, repStart, in the receiver. 	Answer the collection."	^collection		replaceElementsFrom: start		to: stop		withInterpretedBytes: self startingAt: repStart</body></methods><methods><class-id>Xtreams.InterpretedBytes</class-id> <category>printing</category><body package="Xtreams-Support">printOn: aStream 	| printSize |	printSize := self size.	printSize &gt; 50		ifTrue: [printSize := 50].	aStream nextPutAll: '#['.	(1 to: printSize)		do: [:index | (self at: index) printOn: aStream]		separatedBy: [aStream space].	printSize &lt; self size ifTrue: [aStream nextPutAll: (#etc &lt;&lt; #dialogs &gt;&gt; '...etc...') asString].	aStream nextPut: $]</body></methods><methods><class-id>Xtreams.InterpretedBytes class</class-id> <category>type descriptions</category><body package="Xtreams-Support">char	^(Array with: 1 with: ByteArray with: [:b :i | b byteAt: i] with: [:b :i :o | b byteAt: i put: o])</body><body package="Xtreams-Support">double		^(Array with: 8 with: "DoubleArray" Array with: [:b :i | b doubleAt: i] with: [:b :i :o | b doubleAt: i put: o])</body><body package="Xtreams-Support">double_be		self isBigEndian ifTrue: [ ^self double ].	^(Array with: 8 with: "DoubleArray" Array with: [:b :i | b doubleAt: i bigEndian: true] with: [:b :i :o | b doubleAt: i put: o bigEndian: true])</body><body package="Xtreams-Support">double_le		self isBigEndian ifFalse: [ ^self double ].	^(Array with: 8 with: "DoubleArray" Array with: [:b :i | b doubleAt: i bigEndian: false] with: [:b :i :o | b doubleAt: i put: o bigEndian: false])</body><body package="Xtreams-Support">float	^(Array with: 4 with: "FloatArray" Array with: [:b :i | b floatAt: i] with: [:b :i :o | b floatAt: i put: o])</body><body package="Xtreams-Support">float_be	self isBigEndian ifTrue: [ ^self float ].	^(Array with: 4 with: "FloatArray" Array with: [:b :i | b floatAt: i bigEndian: true] with: [:b :i :o | b floatAt: i put: o bigEndian: true])</body><body package="Xtreams-Support">float_le	self isBigEndian ifFalse: [ ^self float ].	^(Array with: 4 with: "FloatArray" Array with: [:b :i | b floatAt: i bigEndian: false] with: [:b :i :o | b floatAt: i put: o bigEndian: false])</body><body package="Xtreams-Support">long		^(Array with: 4 with: DwordArray with: [:b :i | b unsignedLongAt: i] with: [:b :i :o | b unsignedLongAt: i put: o])</body><body package="Xtreams-Support">long_be		self isBigEndian ifTrue: [ ^self long ].	^(Array with: 4 with: DwordArray with: [:b :i | b unsignedLongAt: i bigEndian: true ] with: [:b :i :o | b unsignedLongAt: i put: o bigEndian: true])</body><body package="Xtreams-Support">long_le		self isBigEndian ifFalse: [ ^self long ].	^(Array with: 4 with: DwordArray with: [:b :i | b unsignedLongAt: i bigEndian: false ] with: [:b :i :o | b unsignedLongAt: i put: o bigEndian: false])</body><body package="Xtreams-Support">longlong	^(Array with: 8 with: Array with: [:b :i | b unsignedLongLongAt: i] with: [:b :i :o | b unsignedLongLongAt: i put: o])</body><body package="Xtreams-Support">longlong_be	self isBigEndian ifTrue: [ ^self longlong ].	^(Array with: 8 with: Array with: [:b :i | b unsignedLongLongAt: i bigEndian: true] with: [:b :i :o | b unsignedLongLongAt: i put: o bigEndian: true])</body><body package="Xtreams-Support">longlong_le	self isBigEndian ifFalse: [ ^self longlong ].	^(Array with: 8 with: Array with: [:b :i | b unsignedLongLongAt: i bigEndian: false] with: [:b :i :o | b unsignedLongLongAt: i put: o bigEndian: false])</body><body package="Xtreams-Support">short	^Array with: 2 with: WordArray with: [:b :i | b unsignedShortAt: i] with: [:b :i :o | b unsignedShortAt: i put: o]</body><body package="Xtreams-Support">short_be	self isBigEndian ifTrue: [ ^self short ].	^Array with: 2 with: WordArray with: [:b :i | b unsignedShortAt: i bigEndian: true ] with: [:b :i :o | b unsignedShortAt: i put: o bigEndian: true ]</body><body package="Xtreams-Support">short_le	self isBigEndian ifFalse: [ ^self short ].	^Array with: 2 with: WordArray with: [:b :i | b unsignedShortAt: i bigEndian: false ] with: [:b :i :o | b unsignedShortAt: i put: o bigEndian: false ]</body><body package="Xtreams-Support">signedChar	^(Array with: 1 with: Array with: [:b :i | b signedByteAt: i] with: [:b :i :o | b signedByteAt: i put: o])</body><body package="Xtreams-Support">signedLong	^(Array with: 4 with: Array with: [:b :i | b longAt: i] with: [:b :i :o | b longAt: i put: o])</body><body package="Xtreams-Support">signedLong_be		self isBigEndian ifTrue: [ ^self signedLong ].	^(Array with: 4 with: Array with: [:b :i | b longAt: i bigEndian: true ] with: [:b :i :o | b longAt: i put: o bigEndian: true])</body><body package="Xtreams-Support">signedLong_le		self isBigEndian ifFalse: [ ^self signedLong ].	^(Array with: 4 with: Array with: [:b :i | b longAt: i bigEndian: false ] with: [:b :i :o | b longAt: i put: o bigEndian: false])</body><body package="Xtreams-Support">signedLonglong	^(Array with: 8 with: Array with: [:b :i | b longLongAt: i] with: [:b :i :o | b longLongAt: i put: o])</body><body package="Xtreams-Support">signedLonglong_be	self isBigEndian ifTrue: [ ^self signedLonglong ].	^(Array with: 8 with: Array with: [:b :i | b longLongAt: i bigEndian: true] with: [:b :i :o | b longLongAt: i put: o bigEndian: true])</body><body package="Xtreams-Support">signedLonglong_le	self isBigEndian ifFalse: [ ^self signedLonglong ].	^(Array with: 8 with: Array with: [:b :i | b longLongAt: i bigEndian: false] with: [:b :i :o | b longLongAt: i put: o bigEndian: false])</body><body package="Xtreams-Support">signedShort		^(Array with: 2 with: Array with: [:b :i | b shortAt: i] with: [:b :i :o | b shortAt: i put: o])</body><body package="Xtreams-Support">signedShort_be	self isBigEndian ifTrue: [ ^self signedShort ].	^Array with: 2 with: Array with: [:b :i | b shortAt: i bigEndian: true ] with: [:b :i :o | b shortAt: i put: o bigEndian: true ]</body><body package="Xtreams-Support">signedShort_le	self isBigEndian ifFalse: [ ^self signedShort ].	^Array with: 2 with: Array with: [:b :i | b shortAt: i bigEndian: false ] with: [:b :i :o | b shortAt: i put: o bigEndian: false ]</body><body package="Xtreams-Support">unsignedChar	^(Array with: 1 with: ByteArray with: [:b :i | b byteAt: i] with: [:b :i :o | b byteAt: i put: o])</body><body package="Xtreams-Support">unsignedLong		^(Array with: 4 with: DwordArray with: [:b :i | b unsignedLongAt: i] with: [:b :i :o | b unsignedLongAt: i put: o])</body><body package="Xtreams-Support">unsignedLong_be		self isBigEndian ifTrue: [ ^self unsignedLong ].	^(Array with: 4 with: DwordArray with: [:b :i | b unsignedLongAt: i bigEndian: true ] with: [:b :i :o | b unsignedLongAt: i put: o bigEndian: true])</body><body package="Xtreams-Support">unsignedLong_le		self isBigEndian ifFalse: [ ^self unsignedLong ].	^(Array with: 4 with: DwordArray with: [:b :i | b unsignedLongAt: i bigEndian: false ] with: [:b :i :o | b unsignedLongAt: i put: o bigEndian: false])</body><body package="Xtreams-Support">unsignedLonglong	^(Array with: 8 with: Array with: [:b :i | b unsignedLongLongAt: i] with: [:b :i :o | b unsignedLongLongAt: i put: o])</body><body package="Xtreams-Support">unsignedLonglong_be	self isBigEndian ifTrue: [ ^self unsignedLonglong ].	^(Array with: 8 with: Array with: [:b :i | b unsignedLongLongAt: i bigEndian: true] with: [:b :i :o | b unsignedLongLongAt: i put: o bigEndian: true])</body><body package="Xtreams-Support">unsignedLonglong_le	self isBigEndian ifFalse: [ ^self unsignedLonglong ].	^(Array with: 8 with: Array with: [:b :i | b unsignedLongLongAt: i bigEndian: false] with: [:b :i :o | b unsignedLongLongAt: i put: o bigEndian: false])</body><body package="Xtreams-Support">unsignedShort	^Array with: 2 with: WordArray with: [:b :i | b unsignedShortAt: i] with: [:b :i :o | b unsignedShortAt: i put: o]</body><body package="Xtreams-Support">unsignedShort_be	self isBigEndian ifTrue: [ ^self unsignedShort ].	^Array with: 2 with: WordArray with: [:b :i | b unsignedShortAt: i bigEndian: true ] with: [:b :i :o | b unsignedShortAt: i put: o bigEndian: true ]</body><body package="Xtreams-Support">unsignedShort_le	self isBigEndian ifFalse: [ ^self unsignedShort ].	^Array with: 2 with: WordArray with: [:b :i | b unsignedShortAt: i bigEndian: false ] with: [:b :i :o | b unsignedShortAt: i put: o bigEndian: false ]</body></methods><methods><class-id>Xtreams.InterpretedBytes class</class-id> <category>instance creation</category><body package="Xtreams-Support">withSize: anInteger	^self new: anInteger</body></methods><methods><class-id>Xtreams.InterpretedBytes class</class-id> <category>xtreams</category><body package="Xtreams-Support">newInFixedSpaceRecycled: size	^RecyclingCenter newInFixedSpace: size class: self</body><body package="Xtreams-Support">newInFixedSpaceRecycledDefaultSize	^self newInFixedSpaceRecycled: DefaultBufferSize</body><body package="Xtreams-Support">newRecycled: size	^RecyclingCenter new: size class: self</body><body package="Xtreams-Support">newRecycledDefaultSize	^self newRecycled: DefaultBufferSize</body></methods><methods><class-id>Xtreams.RecyclingCenter</class-id> <category>recycling</category><body package="Xtreams-Support">existing: aClass	| queue |	queue := recycled at: aClass ifAbsent: [^nil].	^mutex critical: [ self existing: aClass in: queue ]</body><body package="Xtreams-Support">new: anInteger class: aClass	| collection |	(collection := self existing: aClass) == nil ifTrue: [collection := aClass withSize: anInteger].	^collection</body><body package="Xtreams-Support">newInFixedSpace: anInteger class: aClass	| collection |	(collection := self existing: aClass) == nil ifTrue: [collection := aClass newInFixedSpace: anInteger].	^collection</body><body package="Xtreams-Support">recycle1: aCollection	aCollection class isPointers ifTrue: [aCollection at: 1 put: nil].	self recycle: aCollection</body><body package="Xtreams-Support">recycle: aCollection	| queue |	queue := recycled at: aCollection class ifAbsent: [^self].	mutex critical: [ self recycle: aCollection in: queue ]</body></methods><methods><class-id>Xtreams.RecyclingCenter</class-id> <category>initialize-release</category><body package="Xtreams-Support">initialize1: aCacheLimit	mutex := Semaphore forMutualExclusion.	recycled := IdentityDictionary new.	SequenceableCollection allSubclassesDo: [:aClass | recycled at: aClass put: (Array new: aCacheLimit)].	recycled at: InterpretedBytes put: (Array new: aCacheLimit)</body><body package="Xtreams-Support">initialize: aCacheLimit	mutex := Semaphore forMutualExclusion.	recycled := IdentityDictionary new.	IntegerArray allSubclassesDo: [:aClass | recycled at: aClass put: (Array new: aCacheLimit)].	CharacterArray allSubclassesDo: [:aClass | recycled at: aClass put: (Array new: aCacheLimit)].	recycled at: InterpretedBytes put: (Array new: aCacheLimit)</body></methods><methods><class-id>Xtreams.RecyclingCenter</class-id> <category>private</category><body package="Xtreams-Support">existing: aClass in: queue	| collection |	1 to: queue size do: [:index |		collection := queue at: index.		collection == nil ifFalse:			[queue at: index put: nil.			^collection]].	^nil</body><body package="Xtreams-Support">recycle: aCollection in: queue"	aCollection can be in queue only once. If aCollection is recycled again before being reused,	it could end up in multiple slots in queue. Prevent that by checking if it's in queue already.."	1 to: queue size do: [:index |		(queue at: index)			ifNil: [ queue at: index put: aCollection.				^ self ]			ifNotNil: [ :another | another == aCollection ifTrue: [					^ self ] ] ].</body></methods><methods><class-id>Xtreams.RecyclingCenter class</class-id> <category>recycling</category><body package="Xtreams-Support">new: anInteger class: aClass	anInteger == 1 ifTrue: [^objectspace1 new: anInteger class: aClass].	anInteger == cacheSize ifTrue: [^objectspaceN new: anInteger class: aClass].	anInteger == largeCacheSize ifTrue: [^objectspaceL new: anInteger class: aClass].	^aClass withSize: anInteger</body><body package="Xtreams-Support">newInFixedSpace: anInteger class: aClass	anInteger == 1 ifTrue: [^fixedspace1 newInFixedSpace: anInteger class: aClass].	anInteger == cacheSize ifTrue: [^fixedspaceN newInFixedSpace: anInteger class: aClass].	anInteger == largeCacheSize ifTrue: [^objectspaceL newInFixedSpace: anInteger class: aClass].	^aClass newInFixedSpace: anInteger</body><body package="Xtreams-Support">recycle: aCollection	aCollection == nil ifTrue: [^nil].	aCollection isFixedArgument		ifTrue:			[aCollection size == 1 ifTrue: [fixedspace1 recycle1: aCollection].			aCollection size == cacheSize ifTrue: [fixedspaceN recycle: aCollection].			aCollection size == largeCacheSize ifTrue: [fixedspaceL recycle: aCollection]]		ifFalse:			[aCollection size == 1 ifTrue: [objectspace1 recycle1: aCollection].			aCollection size == cacheSize ifTrue: [objectspaceN recycle: aCollection].			aCollection size == largeCacheSize ifTrue: [objectspaceL recycle: aCollection]]</body></methods><methods><class-id>Xtreams.RecyclingCenter class</class-id> <category>class initialization</category><body package="Xtreams-Support">initialize	"self initialize"	| cacheLimit |	cacheSize := Xtreams.DefaultBufferSize.	largeCacheSize := 2000000.	cacheLimit := 3.	objectspace1 := self new initialize1: cacheLimit.	fixedspace1 := self new initialize1: cacheLimit.	objectspaceN := self new initialize: cacheLimit.	fixedspaceN := self new initialize: cacheLimit.	objectspaceL := self new initialize: cacheLimit.	fixedspaceL := self new initialize: cacheLimit</body></methods><methods><class-id>Core.StreamEncoder</class-id> <category>accessing</category><body package="Xtreams-Support">skipRecord	^skipRecord</body><body package="Xtreams-Support">streamingAsEncoder	^VWEncoder encoder: self</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>xtreams</category><body package="Xtreams-Support">newInFixedSpaceRecycled: size	^RecyclingCenter newInFixedSpace: size class: self</body><body package="Xtreams-Support">newInFixedSpaceRecycledDefaultSize	^self newInFixedSpaceRecycled: DefaultBufferSize</body><body package="Xtreams-Support">newRecycled: size	^RecyclingCenter new: size class: self</body><body package="Xtreams-Support">newRecycledAtLeast: size	^self newRecycled: (size max: DefaultBufferSize)</body><body package="Xtreams-Support">newRecycledDefaultSize	^self newRecycled: DefaultBufferSize</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>xtreams</category><body package="Xtreams-Support">recycle	RecyclingCenter recycle: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private</category><body package="Xtreams-Support">replaceElementsFrom: start to: stop withInterpretedBytes: replacement startingAt: repStart 	"This destructively replaces elements from start to stop in the 	receiver starting at index, repStart, in the collection, replacement. 	Answer the receiver. No range checks are performed, but 	overlapping replacements are handled correctly."	| repOff |	repOff := repStart - start.	(self == replacement and: [repStart &lt; start])		ifTrue: ["Replacement would be overwritten, copy in reverse order."				stop to: start by: -1					do: [:index | self at: index put: (replacement byteAt: repOff + index)]]		ifFalse: [start to: stop					do: [:index | self at: index put: (replacement byteAt: repOff + index)]]</body></methods><initialize><class-id>Xtreams.VWEncoder</class-id></initialize><initialize><class-id>Xtreams.RecyclingCenter</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UninterpretedBytes</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>StreamEncoder</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>encoder errorPolicy skipRecord </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class></st-source>