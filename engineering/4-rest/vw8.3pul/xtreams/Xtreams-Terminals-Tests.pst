<?xml version="1.0"?><st-source><!-- Name: Xtreams-Terminals-TestsNotice: The MIT LicenseCopyright 2010-2013 Cincom Systems, Martin Kobetic and Michael Lucas-SmithPermission is hereby granted, free of charge, to any person obtaining a copyof this software and associated documentation files (the "Software"), to dealin the Software without restriction, including without limitation the rightsto use, copy, modify, merge, publish, distribute, sublicense, and/or sellcopies of the Software, and to permit persons to whom the Software isfurnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included inall copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS ORIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THEAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHERLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS INTHE SOFTWARE.DbIdentifier: bear73DbTrace: 501434DbUsername: jkottDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#any 'SUnitToo' '') #(#any 'Xtreams-Core' '') #(#any 'Xtreams-Core-Tests' '') #(#any 'Xtreams-Terminals' '') #(#any 'PlatformTestResources' ''))DialectVersion: VisualWorks 7.9MonticelloPrefix: XTPackageName: Xtreams-Terminals-TestsParcel: #('Xtreams-Terminals-Tests')ParcelName: Xtreams-Terminals-TestsPrerequisiteDescriptions: #(#(#name 'SUnitToo' #componentType #package) #(#name 'Xtreams-Core' #componentType #package) #(#name 'Xtreams-Core-Tests' #componentType #package) #(#name 'Xtreams-Terminals' #componentType #package) #(#name 'PlatformTestResources' #componentType #package))PrerequisiteParcels: #(#('SUnitToo' '') #('Xtreams-Core' '') #('Xtreams-Core-Tests' '') #('Xtreams-Terminals' '') #('PlatformTestResources' ''))PrintStringCache: (8.3 - 1,jkott)Url: http://www.squeaksource.com/Xtreams/Xtreams-TerminalsTests-nice.8.mczVersion: 8.3 - 1Date: 11:27:50 AM June 16, 2017 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.3 (jun17.3) of June 16, 2017 on June 16, 2017 at 11:27:50 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SocketReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars>sockets </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>SlowReadingWritingTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			SUnit.*			</imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>SharedQueueReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.InfiniteReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars>queue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>BlockClosureTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>FiniteBoundlessReadingWritingTests</name><environment>Xtreams</environment><super>Xtreams.FiniteReadingWritingTests</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><comment><class-id>Xtreams.FiniteBoundlessReadingWritingTests</class-id><body>Tests for terminals that can be positioned past their current length.</body></comment><class><name>PipeTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars>input output </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			private SUnit.*			</imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>BufferReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>SocketTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars>input output sockets </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>PipeReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			private SUnit.*			</imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>FileReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteBoundlessReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars>file </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			</imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>ElasticBufferReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>DomainSocketTest</name><environment>Xtreams</environment><super>SUnit.TestCase</super><private>true</private><indexed-type>none</indexed-type><inst-vars>input output sockets </inst-vars><class-inst-vars></class-inst-vars><imports>			private OS.*			private SUnit.*			</imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><comment><class-id>Xtreams.DomainSocketTest</class-id><body>Instance Variables	input	&lt;Object&gt; undocumented	output	&lt;Object&gt; undocumented</body></comment><class><name>CollectionReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteBoundlessReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>RingBufferReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars>buffer </inst-vars><class-inst-vars></class-inst-vars><imports>			private SUnit.*			</imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><class><name>BlockClosureReadingWritingTest</name><environment>Xtreams</environment><super>Xtreams.FiniteReadingWritingTests</super><private>true</private><indexed-type>none</indexed-type><inst-vars>collection </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Terminals-Tests</package></attributes></class><methods><class-id>Xtreams.SocketReadingWritingTest</class-id> <category>utilities</category><body package="Xtreams-Terminals-Tests">timeout: timeoutDuration server: serverBlock client: clientBlock	"For tests that must be able to write and read at the same time, where they may block on each.	 Sockets, Pipes have an operating system buffer which dictates its bandwidth."	|	timeout		serverSuccess serverProcess serverLock		clientSuccess clientProcess clientLock|	timeout := false.	serverLock := Semaphore new.	clientLock := Semaphore new.	serverSuccess := clientSuccess := false.	serverProcess := [serverSuccess := serverBlock value. serverLock signal] fork.	clientProcess := [clientSuccess := clientBlock value. clientLock signal] fork.	Core.Timer after: timeoutDuration do:		[serverProcess terminate.		output ifNotNil: [ output close ].		clientProcess terminate.		input ifNotNil: [ input close ].		timeout := true.		serverLock signal.		clientLock signal].	serverLock wait.	clientLock wait.	self assert: serverSuccess.	self assert: clientSuccess.	self deny: timeout</body></methods><methods><class-id>Xtreams.SocketReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	"Use #phonyPair to make sure we're testing TCP sockets on Unix."	sockets := SocketAccessor phonyPair.	input := sockets first reading.	output := sockets last writing.</body><body package="Xtreams-Terminals-Tests">tearDown	input close.	output close.	sockets do: #close</body></methods><methods><class-id>Xtreams.SlowReadingWritingTest</class-id> <category>tests</category><body package="Xtreams-Terminals-Tests">testWithTimeout	| read |	read := self slowSenderReadstreamClass: Xtreams.ExternalTimeoutReadStream				readBlock: [:r | (1 to: 20) collect: [:_ | self readFrom: r]].	self assert: read = #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)</body><body package="Xtreams-Terminals-Tests">testWithoutTimeout	| read |	read := self slowSenderReadstreamClass: Xtreams.ExternalReadStream				readBlock: [:r | (1 to: 20) collect: [:_ | self readFrom: r]].	self assert: read = #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20)</body></methods><methods><class-id>Xtreams.SlowReadingWritingTest</class-id> <category>utilities</category><body package="Xtreams-Terminals-Tests">readFrom: r 	| next |	[next := [ r read: 1] on: Timeout do: [:ex |  ex return]. next isNil] whileTrue.	^next first</body><body package="Xtreams-Terminals-Tests">slowSenderReadstreamClass: readStreamClass readBlock: block	| sockets w r result process |	sockets := SocketAccessor openPair.	w := sockets first writing.	process := [[1 to: 255 do: [:i | (i*i) milliseconds wait. w put: i]] ensure: [ w close]] fork.	r := readStreamClass on: sockets last.	(r isKindOf: Xtreams.ExternalTimeoutReadStream) ifTrue:  [r timeout: 50 milliseconds].	result := block value: r.	process terminate.	r close.	^result</body></methods><methods><class-id>Xtreams.SharedQueueReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	queue := SharedQueue new.	(input := queue reading) contentsSpecies: ByteArray.	(output := queue writing) contentsSpecies: ByteArray</body></methods><methods><class-id>Xtreams.BlockClosureTest</class-id> <category>tests</category><body package="Xtreams-Terminals-Tests">testOneArgumentReading	| stream |	stream := [:out | 1 to: 10 do: [:i | out put: i]] reading contentsSpecies: ByteArray; yourself.	self assert: (stream read: 5) = #[ 1 2 3 4 5 ].	stream close</body></methods><methods><class-id>Xtreams.FiniteBoundlessReadingWritingTests</class-id> <category>tests - core - positioning</category><body package="Xtreams-Terminals-Tests">testBoundlessExplore	self output		explore: [			self output				position: 9;				write: 10];		write: #[1 2 3 4 5 6 7 8 9];		++ 1;		close.	self assert: self input rest = #[1 2 3 4 5 6 7 8 9 10]</body><body package="Xtreams-Terminals-Tests">testBoundlessExploreClip	self output		explore: [			self output				position: 9;				write: 10];		write: #[1 2 3 4 5 6 7 8 9];		close.	self assert: self input rest = #[1 2 3 4 5 6 7 8 9]</body><body package="Xtreams-Terminals-Tests">testBoundlessPositioningSeek	self output		position: 9;		write: 10;		close.	self assert: self input rest = #[0 0 0 0 0 0 0 0 0 10]</body><body package="Xtreams-Terminals-Tests">testBoundlessSeek	self output		++ 9;		write: 10;		close.	self assert: self input rest = #[0 0 0 0 0 0 0 0 0 10]</body><body package="Xtreams-Terminals-Tests">testWritePositioningSeek	| record out |	record := #[ 1 2 3 4 5 6 7 8 9 0 ].	out := self output positioning.	out	write: record.	self assert: (out -- 7) = 7.	self assert: out position = 3.	self assert: (out ++ 3) = 3.	self assert: out position = 6.	self assert: (out ++ record size) = record size.	out close.	self assert: (self input read: record size) = record</body><body package="Xtreams-Terminals-Tests">testWritePositioningSeekFrom	| record out |	record := #[ 1 2 3 4 5 6 7 8 9 0 ].	out := self output positioning.	out	write: record.	self assert: (out += 3) = 3.	self assert: out position = 3.	self assert: (out -= 4) = 4.	self assert: out position = 6.	self assert: ([ out -= (record size + 6) ] on: Incomplete do: [:ex | ex count]) = record size.	self assert: out position = 0.	self assert: (out += (record size + 6)) = (record size + 6).	self assert: out position = (record size + 6).	out close.	self assert: (self input read: record size) = record</body></methods><methods><class-id>Xtreams.PipeTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	| pipe |	(OSHandle currentOS = #win32) ifTrue: [self error: 'Does not work on Windows' ].	pipe := OSSystemSupport concreteClass pipeAccessorClass openPair.	input := pipe first.	output := pipe last.</body><body package="Xtreams-Terminals-Tests">tearDown	input close.	output close.</body></methods><methods><class-id>Xtreams.PipeTest</class-id> <category>testing</category><body package="Xtreams-Terminals-Tests">testReadSeeking	| in |	output writing put: 42; flush; close.	in := input reading.	self deny: in atEnd.	self assert: in peek = 42.	self assert: in peek = 42.	self deny: in atEnd.	self assert: in get = 42.	self assert: in atEnd.	self should: [ in peek ] raise: Incomplete</body><body package="Xtreams-Terminals-Tests">testReadTimeout	| happened |	self should: [ (input reading: 100 milliseconds) get ] raise: Timeout.	output writing put: 42; flush.	self assert: (input reading: 100 milliseconds) get = 42.	" test resumption "	happened := false.	[	self assert: (input reading: 100 milliseconds) get = 42	] on: Timeout do: [ :ex |		output writing put: 42; flush.		happened := true.		ex resume ].	self assert: happened</body><body package="Xtreams-Terminals-Tests">testWriteTimeout	| happened succeeded constant |	"Fill up the OS buffer"	constant := 42 repeating contentsSpecies: ByteArray.	self should: [ (output writing: 100 milliseconds) write: constant ] raise: Timeout.		" test resumption "	happened := succeeded := false.	[	(output writing: 100 milliseconds) put: 42.		succeeded := true	] on: Timeout do: [ :ex |		self assert: input reading get = 42.		happened := true.		ex resume ].	self assert: happened.	self assert: succeeded</body></methods><methods><class-id>Xtreams.PipeTest class</class-id> <category>accessing</category><body package="Xtreams-Terminals-Tests">resources	^Array with: PlatformHasVwPipeSupport</body></methods><methods><class-id>Xtreams.BufferReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	buffer := Buffer on: ByteArray new.	input := buffer reading.	output := buffer writing.</body></methods><methods><class-id>Xtreams.SocketTest</class-id> <category>testing</category><body package="Xtreams-Terminals-Tests">testReadSeeking	| in |	output writing put: 42; flush; close.	in := input reading.	self deny: in atEnd.	self assert: in peek = 42.	self assert: in peek = 42.	self deny: in atEnd.	self assert: in get = 42.	self assert: in atEnd.	self should: [ in peek ] raise: Incomplete</body><body package="Xtreams-Terminals-Tests">testReadTimeout	| happened |	self should: [ (input reading: 100 milliseconds) get ] raise: Timeout.	output writing put: 42; flush.	self assert: (input reading: 100 milliseconds) get = 42.	" test resumption "	happened := false.	[	self assert: (input reading: 100 milliseconds) get = 42	] on: Timeout do: [ :ex |		output writing put: 42; flush.		happened := true.		ex resume ].	self assert: happened</body><body package="Xtreams-Terminals-Tests">testWriteTimeout	| happened succeeded constant |	"self assert: (OSHandle currentOS ~= #win32) description: 'Does not work on Windows (AR#65763)'."	"AR#65763 Socket writeWaitWithTimeout: doesn't correctly signal when the outgoing buffer fills up on Windows"	OSHandle currentOS = #win32 ifTrue: [ ^self ].	"Fill up the OS buffer"	constant := 42 repeating contentsSpecies: ByteArray.	self should: [ (output writing: 100 milliseconds) write: constant ] raise: Timeout.		" test resumption "	happened := succeeded := false.	[	(output writing: 100 milliseconds) put: 42.		succeeded := true	] on: Timeout do: [ :ex |		self assert: input reading get = 42.		happened := true.		ex resume ].	self assert: happened.	self assert: succeeded</body></methods><methods><class-id>Xtreams.SocketTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	"Use #phonyPair to make sure we're testing TCP sockets on Unix."	sockets := SocketAccessor phonyPair.	input := sockets first.	output := sockets last.</body><body package="Xtreams-Terminals-Tests">tearDown	input close.	output close.	sockets do: #close</body></methods><methods><class-id>Xtreams.PipeReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	| pipe |	(OSHandle currentOS = #win32) ifTrue: [self error: 'Does not work on Windows' ].	pipe := OSSystemSupport concreteClass pipeAccessorClass openPair.	input := pipe first reading.	output := pipe last writing.</body><body package="Xtreams-Terminals-Tests">tearDown	input close.	output close.</body></methods><methods><class-id>Xtreams.PipeReadingWritingTest</class-id> <category>utilities</category><body package="Xtreams-Terminals-Tests">timeout: timeoutDuration server: serverBlock client: clientBlock	"For tests that must be able to write and read at the same time, where they may block on each.	 Sockets, Pipes have an operating system buffer which dictates its bandwidth."	|	timeout		serverSuccess serverProcess serverLock		clientSuccess clientProcess clientLock|	timeout := false.	serverLock := Semaphore new.	clientLock := Semaphore new.	serverSuccess := clientSuccess := false.	serverProcess := [serverSuccess := serverBlock value. serverLock signal] fork.	clientProcess := [clientSuccess := clientBlock value. clientLock signal] fork.	Core.Timer after: timeoutDuration do:		[serverProcess terminate.		output ifNotNil: [ output close ].		clientProcess terminate.		input ifNotNil: [ input close ].		timeout := true.		serverLock signal.		clientLock signal].	serverLock wait.	clientLock wait.	self assert: serverSuccess.	self assert: clientSuccess.	self deny: timeout</body></methods><methods><class-id>Xtreams.PipeReadingWritingTest class</class-id> <category>accessing</category><body package="Xtreams-Terminals-Tests">resources	^Array with: PlatformHasVwPipeSupport</body></methods><methods><class-id>Xtreams.FileReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	file := '&lt;1s&gt;-&lt;2s&gt;' expandMacrosWith: self class name with: testSelector.	file :=		(OSHandle currentOS = #unix and: [ '/dev/shm' asFilename exists ])			ifTrue: [ ('/dev/shm/', file) asFilename ]			ifFalse: [ file asFilename ].	output := file writing.	input := file reading.</body><body package="Xtreams-Terminals-Tests">tearDown	input close.	output close.	file delete</body></methods><methods><class-id>Xtreams.FileReadingWritingTest</class-id> <category>tests - core</category><body package="Xtreams-Terminals-Tests">testInsert	"Do nothing, since files are not expected to implement insert:* "</body></methods><methods><class-id>Xtreams.ElasticBufferReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	buffer := ElasticBuffer on: ByteArray new.	input := buffer reading.	output := buffer writing.</body></methods><methods><class-id>Xtreams.DomainSocketTest</class-id> <category>testing</category><body package="Xtreams-Terminals-Tests">testReadTimeout	| happened |	self should: [ (input reading: 100 milliseconds) get ] raise: Timeout.	output writing put: 42; flush.	self assert: (input reading: 100 milliseconds) get = 42.	" test resumption "	happened := false.	[	self assert: (input reading: 100 milliseconds) get = 42	] on: Timeout do: [ :ex |		output writing put: 42; flush.		happened := true.		ex resume ].	self assert: happened</body><body package="Xtreams-Terminals-Tests">testWriteTimeout	| happened succeeded constant |	"Fill up the OS buffer"	constant := 42 repeating contentsSpecies: ByteArray.	self should: [ (output writing: 100 milliseconds) write: constant ] raise: Timeout.		" test resumption "	happened := succeeded := false.	[	(output writing: 100 milliseconds) put: 42.		succeeded := true	] on: Timeout do: [ :ex |		self assert: input reading get = 42.		happened := true.		ex resume ].	self assert: happened.	self assert: succeeded</body></methods><methods><class-id>Xtreams.DomainSocketTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	(OSHandle currentOS = #win32) ifTrue: [self error: 'There are no domain sockets on Windows!' ].	sockets := SocketAccessor openPair.	input := sockets first.	output := sockets last.</body><body package="Xtreams-Terminals-Tests">tearDown	input close.	output close.	sockets do: #close.</body></methods><methods><class-id>Xtreams.DomainSocketTest class</class-id> <category>accessing</category><body package="Xtreams-Terminals-Tests">resources	^Array with: PlatformSupportsDomainSockets</body></methods><methods><class-id>Xtreams.CollectionReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">input	^input ifNil: [ input := (self output close; terminal) reading ]</body><body package="Xtreams-Terminals-Tests">output	^output ifNil: [ output := ByteArray new writing ]</body></methods><methods><class-id>Xtreams.CollectionReadingWritingTest</class-id> <category>tests - core</category><body package="Xtreams-Terminals-Tests">testInsert	self output write: #[ 1 2 3 4 7 8 9 0 ].	self output -- 4.	self output insert: #[ 5 6 ].	self output -= 0. "Have to seek to the end otherwise output gets truncated when we close it"	self assert: (self input read: 10) = #[ 1 2 3 4 5 6 7 8 9 0 ]</body><body package="Xtreams-Terminals-Tests">testReadWriteLargeAmount	| data |	1 to: 10 do: [:each | self output put: 1. self assert: self input get = 1].	#( 64 1024 2048 4096 8192 ) do: [:dataSize |		output := input := nil.		data := ByteArray new: dataSize.		1 to: data size do: [:i | data at: i put: (i - 1) \\ 256].		self	timeout:	1000 milliseconds			server:	[1 to: 10 do: [:each | self output write: data]. true]			client: 	[(1 to: 10) inject: true into: [:pass :each | pass and: [(self input read: data size) = data]]]]</body><body package="Xtreams-Terminals-Tests">testWriteFromCollectionAt	| data |	data := #[1 2 3 4 5 6 7].	self assert: (self output write: 4 from: data at: 1) = 4.	self assert: (self output write: 3 from: data at: 5) = 3.	self assert: (self input read: 4) = (data first: 4).	self assert: (self input read: 3) = (data last: 3)</body><body package="Xtreams-Terminals-Tests">testWriteFromStream	| data |	data := #[ 1 2 3 4 ] reading.	self assert: (self output write: 3 from: data) = 3.	self assert: (self output write: 1 from: data) = 1.	self assert: (self input read: 3) = #[ 1 2 3 ].	self assert: self input get = 4.	self assert: (		[	self output write: 2 from: data. false		] on: Incomplete do: [ :eos |			eos count = 0 ])</body></methods><methods><class-id>Xtreams.CollectionReadingWritingTest</class-id> <category>tests - core - positioning</category><body package="Xtreams-Terminals-Tests">testBoundlessArraySeek	output := Array new writing.	self output		++ 9;		write: 10;		close.	self assert: self input rest = ((Array new: 10 withAll: nil) at: 10 put: 10; yourself)</body><body package="Xtreams-Terminals-Tests">testBoundlessCharacterSeek	output := String new writing.	self output		++ 9;		write: 'a';		close.	self assert: self input rest = ((String new: 10 withAll: (Character codePoint: 0)) at: 10 put: $a; yourself)</body></methods><methods><class-id>Xtreams.RingBufferReadingWritingTest</class-id> <category>tests - transforming</category><body package="Xtreams-Terminals-Tests">testWriteCollectingMultipleBufferSize	"does not work on limited size ring buffer"</body></methods><methods><class-id>Xtreams.RingBufferReadingWritingTest</class-id> <category>tests - core</category><body package="Xtreams-Terminals-Tests">testReadWriteLargeAmount		"does not work on limited size ring buffer"</body></methods><methods><class-id>Xtreams.RingBufferReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	buffer := RingBuffer on: (ByteArray new: 8192).	input := buffer reading.	output := buffer writing.</body></methods><methods><class-id>Xtreams.BlockClosureReadingWritingTest</class-id> <category>initialize-release</category><body package="Xtreams-Terminals-Tests">setUp	collection := OrderedCollection new.	input := [ collection isEmpty ifTrue: [ Incomplete zero raise ]. collection removeFirst ] reading.	input contentsSpecies: ByteArray.	output := [ :x | collection addLast: x ] writing.	output contentsSpecies: ByteArray.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>InfiniteReadingWritingTests</name><environment>Xtreams</environment><super>Xtreams.ReadingWritingTest</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.*			</imports><category></category><attributes><package>Xtreams-Core-Tests</package></attributes></class><class><name>FiniteReadingWritingTests</name><environment>Xtreams</environment><super>Xtreams.ReadingWritingTest</super><private>true</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Xtreams-Core-Tests</package></attributes></class></st-source>