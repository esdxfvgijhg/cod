<?xml version="1.0"?><st-source><!-- Name: Opentalk-Core-ServicesNotice: Copyright 1999-2014 Cincom Systems, Inc.  All rights reserved.Comment: Opentalk-Core-Services contains the implementations of those base services that facilitate initial reference acquisition.Copyright: Copyright © 1999-2005 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 496344DbUsername: tkoganDbVersion: 8.3 - 1DevelopmentPrerequisites: #(#(#package 'Opentalk-STST' ''))PackageName: Opentalk-Core-ServicesParcel: #('Opentalk-Core-Services')ParcelName: Opentalk-Core-ServicesPrerequisiteParcels: #(#('Opentalk-STST' ''))PrintStringCache: (8.3 - 1,tkogan)Version: 8.3 - 1Date: 2:30:44 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:44 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OpentalkService</name><environment>Opentalk</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceId </inst-vars><class-inst-vars>default defaultId </class-inst-vars><imports></imports><category>Opentalk-Services</category><attributes><package>Opentalk-Core-Services</package></attributes></class><comment><class-id>Opentalk.OpentalkService</class-id><body>OpentalkService is an abstract class that supports a default instance, a service identifier, and several convenience methods for registering instances [1] in a naming service, [2] as a request broker service, or [3] in a broker's object adaptor under a OID specified by the user.  Concrete subclasses may invoke these methods in class initialization methods to ensure that default instances are registered in the Opentalk naming service or with a default broker at class initialization time.Instance Variables:	serviceId	&lt;Symbol&gt;	a service identifierClass Instance Variables:	default		&lt;Object&gt;	a default instance	defaultId	&lt;Symbol&gt;	a default service identifierShared Variables:	None.</body></comment><class><name>NamingService</name><environment>Opentalk</environment><super>Opentalk.OpentalkService</super><private>false</private><indexed-type>none</indexed-type><inst-vars>bindings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Services</category><attributes><package>Opentalk-Core-Services</package></attributes></class><comment><class-id>Opentalk.NamingService</class-id><body>NamingService is implemented along non-COS lines in two ways.  First, the naming service is not intended to reside on a single privileged image that others must connect to.  For the details, see the comment to NamingServiceRoot.  Secondly, naming service clients need to distinguish between object and context bindings and the latter are defined by type.  There no distinction between NamingService instances bound in as public parts of the service and those bound in for private use.  All are assumed to be public.  This has obvious drawbacks.  Nevertheless, as a result, the implementation is half the weight, in both protocol size and number of instVars as a naming service that is modeled on the COS Naming Service standard.  There is no distinction at the protocol level between binding in a public node and binding in an object.Internally, the keys of bindings are Symbols.  For the client user, binding keys may be either simple or compound.  Simple keys must understand 'asSymbol'.  Compound keys may be either [a] sequences of simple keys or [b] period-separated Symbols or Strings.  In place of COS binding iterators, there are protocols for [1] obtaining the set of bindings matching a pattern, potentially compound with wildcards in multiple components and [2] interrogating bound Objects for pass mode, passInstVars, location, marshalled size, and the like.  This is more powerful and more straightforward.  Instance Variables:	bindings	&lt;Dictionary&gt;	the dictionary of bindingsClass Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>OtEAlreadyBound</name><environment>Opentalk</environment><super>Opentalk.OtServiceException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core-Services</package></attributes></class><comment><class-id>Opentalk.OtEAlreadyBound</class-id><body>An attempt to bind a name in the naming service, using the 'bind:to:' rather than the 'rebind:to:' method has failed because an object is already bound under the key provided.Instance Variables:	None.Class Instance Variables:	None.Shared Variables:	None.</body></comment><class><name>UcastEventService</name><environment>Opentalk</environment><super>Core.EventManager</super><private>false</private><indexed-type>none</indexed-type><inst-vars>relays sources </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Services</category><attributes><package>Opentalk-Core-Services</package></attributes></class><comment><class-id>Opentalk.UcastEventService</class-id><body>UcastEventService implements a simple event service for use with connection based protocols.  It is not an event service in the sense in which that term is used by the OMG, but is instead an event multiplexer, employed to ensure that an image containing several object interested in an event need only be sent that event once.Instance Variables:	relays		&lt;IdentitySet&gt;	of event services that are event consumers	sources		&lt;IdentitySet&gt;	of event services that are event producersClass Instance Variables:	None.Shared Variables:	EventServiceRegistry	&lt;IdentityDictionary&gt;		of local relays</body></comment><methods><class-id>Opentalk.OpentalkService</class-id> <category>accessing</category><body package="Opentalk-Core-Services">serviceId	^( serviceId isNil )		ifTrue:	[ serviceId := self class serviceId ]		ifFalse:	[ serviceId ]</body><body package="Opentalk-Core-Services">serviceId: aSymbol	serviceId := aSymbol</body></methods><methods><class-id>Opentalk.OpentalkService</class-id> <category>api - naming service</category><body package="Opentalk-Core-Services">registerInNamingService: aNamingService	aNamingService		rebind: ( Array with: self serviceId )		to: self</body><body package="Opentalk-Core-Services">unregisterInNamingService: aNamingService	aNamingService		unbind: ( Array with: self serviceId )</body></methods><methods><class-id>Opentalk.OpentalkService</class-id> <category>api - broker service</category><body package="Opentalk-Core-Services">registerWithBroker: aBroker	aBroker		registerService: self		id: self serviceId</body><body package="Opentalk-Core-Services">unregisterWithBroker: aBroker	aBroker		unregisterServiceId: self serviceId</body></methods><methods><class-id>Opentalk.OpentalkService</class-id> <category>initialize-release</category><body package="Opentalk-Core-Services">initialize	"... intentionally null."</body></methods><methods><class-id>Opentalk.OpentalkService</class-id> <category>api - object adaptor oid</category><body package="Opentalk-Core-Services">registerInObjectTableOfBroker: aBroker	self 		registerInObjectTableOfBroker: aBroker 		underOID: self serviceId</body><body package="Opentalk-Core-Services">registerInObjectTableOfBroker: aBroker underOID: aSymbol	aBroker objectAdaptor objectTable 		register: self 		oid: aSymbol</body></methods><methods><class-id>Opentalk.OpentalkService class</class-id> <category>api - id - private</category><body package="Opentalk-Core-Services">defaultId	^defaultId</body><body package="Opentalk-Core-Services">defaultId: aSymbol	defaultId := aSymbol</body></methods><methods><class-id>Opentalk.OpentalkService class</class-id> <category>api - default</category><body package="Opentalk-Core-Services">default	( default isNil )		ifTrue:	[ self installDefault ].	^default</body><body package="Opentalk-Core-Services">default: anObject	default := anObject</body><body package="Opentalk-Core-Services">installDefault	default := self new initialize</body><body package="Opentalk-Core-Services">uninstallDefault	default := nil</body></methods><methods><class-id>Opentalk.OpentalkService class</class-id> <category>api - id - public</category><body package="Opentalk-Core-Services">serviceId	^defaultId</body></methods><methods><class-id>Opentalk.OpentalkService class</class-id> <category>class initialization</category><body package="Opentalk-Core-Services">initialize	defaultId := self name</body></methods><methods><class-id>Opentalk.NamingService</class-id> <category>private</category><body package="Opentalk-Core-Services">bindAt: aKey put: anObject	"... the low-level 'bind' operation."	( bindings includesKey: aKey )		ifTrue:	[ OtEAlreadyBound raiseErrorString: (					(#KeyAlreadyBound1s &lt;&lt; #opentalk &gt;&gt; 'Key already bound: &lt;1s&gt;.')						expandMacrosWith: aKey asString) ]		ifFalse:	[ bindings at: aKey put: anObject ]</body><body package="Opentalk-Core-Services">bindSequence: aSequence to: anObject	"... we locally get a reference to the endmost naming service in 	case anObject is large and passed by value, to avoid passing 	such an object across multiple images if aSequence happens 	to specify a path crossing multiple platforms.  Therefore, the code 	pattern here differs from the other '*Sequence:* methods, which	evaluate the terminal operation at the leaf node."	| tail base |	tail := aSequence last asSymbol.	base := ( aSequence size == 1 )				ifTrue:	[ self ]				ifFalse:	[ self resolveSequence: ( aSequence removeLast; yourself ) ].	base bindAt: tail put: anObject</body><body package="Opentalk-Core-Services">bindingsMap: aSelector	| dict |	dict := Dictionary new.	self bindings keysAndValuesDo: 		[ :k :v | dict at: k put: ( v perform: aSelector ) ].	^dict</body><body package="Opentalk-Core-Services">bindingsMap: aSelector withArguments: anArray	| dict |	dict := Dictionary new.	self bindings keysAndValuesDo: 		[ :k :v | dict at: k put: ( v perform: aSelector withArguments: anArray ) ].	^dict</body><body package="Opentalk-Core-Services">createSequence: aSequence	"Note that newly created NamingServices will be co-located	with the last found already extant NameService."	| head base |	head := aSequence first asSymbol.	base := bindings at: head ifAbsentPut: [ NamingService new ].	( aSequence size &gt; 1 )		ifTrue:	[ base createSequence: ( aSequence removeFirst; yourself ) ]</body><body package="Opentalk-Core-Services">keyComponents: aStringOrSymbol	| oc key str |	oc := OrderedCollection new.	key := aStringOrSymbol asString.	( key includes: $. )		ifTrue:	[	str := ReadStream on: key.					[ str atEnd ]						whileFalse: [ oc addLast: ( str upTo: $. ) ]				]		ifFalse:	[ oc addLast: key ].	^oc</body><body package="Opentalk-Core-Services">keysMatchingSequence: aSequence ignoreCase: aBoolean	| headPattern tailPattern matchingKeys result tailKeys base |	headPattern := aSequence first asSymbol.	matchingKeys := self bindings keys select: [ :k | headPattern match: k ignoreCase: aBoolean ].	result := Set new.	( aSequence size == 1)		ifTrue:	[  	result addAll: matchingKeys 				]		ifFalse:	[	matchingKeys := matchingKeys select: [ :m | ( self bindings at: m ) class == self class ].					tailPattern := aSequence copy removeFirst; yourself.					matchingKeys do:  						[ :m |	base := self bindings at: m.								tailKeys := base 												keysMatchingSequence: tailPattern												ignoreCase: aBoolean.								result addAll: ( tailKeys collect: [ :tk | m,'.',tk ] )						]				].	^result</body><body package="Opentalk-Core-Services">parseKey: aKey	^( aKey isCharacters )		ifTrue:	[ self keyComponents: aKey ]		ifFalse:	[ ( aKey isSequenceable )					ifTrue:	[ aKey asOrderedCollection ]					ifFalse:	[ aKey asSymbol ]				]</body><body package="Opentalk-Core-Services">querySequence: aSequence with: aSelector	| head base |	head := aSequence first asSymbol.	base := self bindings at: head.	^( aSequence size == 1 )				ifTrue:	[ ( base class == self class )							ifTrue:	[ self bindingsMap: aSelector ]							ifFalse:	[ base perform: aSelector ]						]				ifFalse:	[ base 							querySequence: ( aSequence removeFirst; yourself ) 							with: aSelector						]</body><body package="Opentalk-Core-Services">querySequence: aSequence with: aSelector withArguments: anArray	| head base |	head := aSequence first asSymbol.	base := self bindings at: head.	^( aSequence size == 1 )				ifTrue:	[ ( base class == self class )							ifTrue:	[ self bindingsMap: aSelector withArguments: anArray ]							ifFalse:	[ base perform: aSelector withArguments: anArray ]						]				ifFalse:	[ base 							querySequence: ( aSequence removeFirst; yourself ) 							with: aSelector							withArguments: anArray						]</body><body package="Opentalk-Core-Services">rebindAt: aKey put: anObject	"... the low-level 'rebind' operation."	bindings at: aKey put: anObject</body><body package="Opentalk-Core-Services">rebindSequence: aSequence to: anObject	"... we locally get a reference to the endmost naming service in 	case anObject is large and passed by value, to avoid passing 	such an object across multiple images if aSequence happens 	to specify a path crossing multiple platforms.  Therefore, the code 	pattern here differs from the other '*Sequence:* methods, which	evaluate the terminal operation at the leaf node."	| tail base |	tail := aSequence last asSymbol.	base := ( aSequence size == 1 )				ifTrue:	[ self ]				ifFalse:	[ self resolveSequence: ( aSequence removeLast; yourself ) ].	base rebindAt: tail put: anObject</body><body package="Opentalk-Core-Services">resolveSequence: aSequence	| head base |	head := aSequence first asSymbol.	base := self bindings at: head.	^( aSequence size == 1 )				ifTrue:	[ base ]				ifFalse:	[ base resolveSequence: ( aSequence removeFirst; yourself ) ]</body><body package="Opentalk-Core-Services">resolveSequence: aSequence ifAbsent: aBlock	| head base |	head := aSequence first asSymbol.	base := [ self bindings at: head ] 				on: KeyNotFoundError				do: [ :ex | ^aBlock value ].	^( aSequence size == 1 )				ifTrue:	[ base ]				ifFalse:	[ base 							resolveSequence: ( aSequence removeFirst; yourself )							ifAbsent: aBlock ]</body><body package="Opentalk-Core-Services">unbindSequence: aSequence	| head |	head := aSequence first asSymbol.	^( aSequence size == 1 )				ifTrue:	[ bindings removeKey: head ifAbsent: [] ]				ifFalse:	[ ( bindings at: head ) unbindSequence: ( aSequence removeFirst; yourself ) ]</body></methods><methods><class-id>Opentalk.NamingService</class-id> <category>initialize-release</category><body package="Opentalk-Core-Services">initialize	bindings := Dictionary new: 7</body></methods><methods><class-id>Opentalk.NamingService</class-id> <category>accessing</category><body package="Opentalk-Core-Services">bindingSet	^self bindings associations</body><body package="Opentalk-Core-Services">bindings	^( bindings isNil )		ifTrue:	[ bindings := Dictionary new: 7 ]		ifFalse:	[ bindings ]</body><body package="Opentalk-Core-Services">contextBindingSet	^self bindingSet select: [ :assoc | assoc value isNamingService ]</body></methods><methods><class-id>Opentalk.NamingService</class-id> <category>api - basic</category><body package="Opentalk-Core-Services">bind: aKey to: anObject	" ... creates a new binding."	self 		bindSequence: ( self parseKey: aKey ) 		to: anObject</body><body package="Opentalk-Core-Services">create: aKey	"... creates one or more new naming services."	self createSequence: ( self parseKey: aKey )</body><body package="Opentalk-Core-Services">keysMatching: aKeyPattern	"Answers aSet of all extant keys matching aKey, which may 	be compound and is expected to contain wildcards in one or 	several components.  The match is case-insensitive by default."	^self 		keysMatchingSequence: ( self parseKey: aKeyPattern )		ignoreCase: true</body><body package="Opentalk-Core-Services">query: aKey with: aSelector	"... ensures evaluation of aSelector at the location of	the naming service possessing the terminal binding,	the one most likely to be co-located with or 'near' the 	object in a federated naming service."	^self 		querySequence: ( self parseKey: aKey ) 		with: aSelector</body><body package="Opentalk-Core-Services">query: aKey with: aSelector withArguments: anArray	"... ensures evaluation of aSelector at the location of	the naming service possessing the terminal binding,	the one most likely to be co-located with or 'near' the 	object in a federated naming service."	^self 		querySequence: ( self parseKey: aKey ) 		with: aSelector		withArguments: anArray</body><body package="Opentalk-Core-Services">rebind: aKey to: anObject	" ... creates a new binding."	self 		rebindSequence: ( self parseKey: aKey ) 		to: anObject</body><body package="Opentalk-Core-Services">resolve: aKey	"... resolves a binding name."	^self resolveSequence: ( self parseKey: aKey )</body><body package="Opentalk-Core-Services">resolve: aKey ifAbsent: aBlock	"... resolves a binding name."	^self 		resolveSequence: ( self parseKey: aKey )		ifAbsent: aBlock</body><body package="Opentalk-Core-Services">unbind: aKey	" ... destroys a binding."	self unbindSequence: ( self parseKey: aKey )</body></methods><methods><class-id>Opentalk.NamingService</class-id> <category>api - query</category><body package="Opentalk-Core-Services">bindingCount	"Answers the number of bindings in the receiver."	^bindings size</body><body package="Opentalk-Core-Services">bindingCountAt: aKey	^self query: aKey with: #bindingCount</body><body package="Opentalk-Core-Services">bindingKeys	"Answers the set of binding keys of the receiver."	^bindings keys</body><body package="Opentalk-Core-Services">bindingKeysAt: aKey	^self query: aKey with: #bindingKeys</body><body package="Opentalk-Core-Services">classnameAt: aKey	^self query: aKey with: #classname</body><body package="Opentalk-Core-Services">imagePrefix	^ObjectMemory imagePrefix</body><body package="Opentalk-Core-Services">imagePrefixAt: aKey	^self query: aKey with: #imagePrefix</body><body package="Opentalk-Core-Services">isPassedByValueAt: aKey	^self query: aKey with: #isPassedByValue</body><body package="Opentalk-Core-Services">marshaledSizeAt: aKey	^self 		query: aKey 		with: #marshaledSizeUsingProtocol: 		withArguments: ( Array with: #STST )</body><body package="Opentalk-Core-Services">marshaledSizeAt: aKey usingProtocol: aSymbol	^self 		query: aKey 		with: #marshaledSizeUsingProtocol: 		withArguments: ( Array with: aSymbol )</body><body package="Opentalk-Core-Services">passInstVarsAt: aKey	^self query: aKey with: #passInstVars</body></methods><methods><class-id>Opentalk.NamingService</class-id> <category>api - meta</category><body package="Opentalk-Core-Services">isNamingService	^true</body></methods><methods><class-id>Opentalk.NamingService class</class-id> <category>instance creation</category><body package="Opentalk-Core-Services">new	^super new initialize</body></methods><methods><class-id>Opentalk.NamingService class</class-id> <category>class initialization</category><body package="Opentalk-Core-Services">initialize	super initialize</body></methods><methods><class-id>Opentalk.UcastEventService</class-id> <category>event triggering</category><body package="Opentalk-Core-Services">triggerEvent: eventName	super triggerEvent: eventName.	self relays copy do:	[ :r | [ r triggerEvent: eventName ] 								on: OtECommunicationFailure, OtEServerError								do: [ :ex | self removeRelay: r ]						]</body><body package="Opentalk-Core-Services">triggerEvent: eventName ifNotHandled: exceptionBlock	super triggerEvent: eventName ifNotHandled: exceptionBlock.	self relays do: [ :r | r triggerEvent: eventName ifNotHandled: exceptionBlock ]</body><body package="Opentalk-Core-Services">triggerEvent: eventName withArguments: argumentCollection	super triggerEvent: eventName withArguments: argumentCollection asArray.	self relays copy do:	[ :r | 						[ r 							triggerEvent: eventName 							withArguments: argumentCollection						]							on: OtECommunicationFailure, OtEServerError							do: [ :ex | self removeRelay: r ]						]</body><body package="Opentalk-Core-Services">triggerEvent: eventName withArguments: argumentCollection ifNotHandled: exceptionBlock	super 		triggerEvent: eventName 		withArguments: argumentCollection asArray		ifNotHandled: exceptionBlock.	self relays do: [ :r | r 						triggerEvent: eventName 						withArguments: argumentCollection						ifNotHandled: exceptionBlock ]</body></methods><methods><class-id>Opentalk.UcastEventService</class-id> <category>initialize-release</category><body package="Opentalk-Core-Services">initialize	self clearRelays.	self clearSources</body></methods><methods><class-id>Opentalk.UcastEventService</class-id> <category>configuration</category><body package="Opentalk-Core-Services">addRelay: anEventService	relays add: anEventService</body><body package="Opentalk-Core-Services">addSource: anEventService	sources add: anEventService</body><body package="Opentalk-Core-Services">clearRelays	relays := IdentitySet new.</body><body package="Opentalk-Core-Services">clearSources	sources := IdentitySet new.</body><body package="Opentalk-Core-Services">removeRelay: anEventService	relays 		remove: anEventService		ifAbsent: []</body><body package="Opentalk-Core-Services">removeSource: anEventService	sources 		remove: anEventService		ifAbsent: []</body></methods><methods><class-id>Opentalk.UcastEventService</class-id> <category>accessing</category><body package="Opentalk-Core-Services">relays	^relays</body><body package="Opentalk-Core-Services">relays: anIdentitySet	relays := anIdentitySet</body><body package="Opentalk-Core-Services">sources	^sources</body><body package="Opentalk-Core-Services">sources: anIdentitySet	sources := anIdentitySet</body></methods><methods><class-id>Opentalk.UcastEventService class</class-id> <category>instance management</category><body package="Opentalk-Core-Services">new	^super new initialize</body></methods><methods><class-id>Opentalk.UcastEventService class</class-id> <category>events</category><body package="Opentalk-Core-Services">canTriggerEvent: eventName	^true</body></methods><methods><class-id>Opentalk.RequestBroker</class-id> <category>api - services</category><body package="Opentalk-Core-Services">namingService	| ns |	ns := self serviceById: NamingService serviceId.	( ns isNil )		ifTrue:	[	ns := NamingService new.					ns registerWithBroker: self				].	^ns</body><body package="Opentalk-Core-Services">registerInstanceOf: aServiceClass	self registerService: aServiceClass new id: aServiceClass serviceId</body></methods><initialize><class-id>Opentalk.OpentalkService</class-id></initialize><initialize><class-id>Opentalk.NamingService</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>EventManager</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>handlers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Dependency Events</category><attributes><package>System-Dependency Events</package></attributes></class><class><name>RequestBroker</name><environment>Opentalk</environment><super>Opentalk.BasicRequestBroker</super><private>false</private><indexed-type>none</indexed-type><inst-vars>serviceDictionary openSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class><class><name>OtServiceException</name><environment>Opentalk</environment><super>Opentalk.OtException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core</package></attributes></class></st-source>