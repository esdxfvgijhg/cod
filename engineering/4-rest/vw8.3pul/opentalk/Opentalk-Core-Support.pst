<?xml version="1.0"?><st-source><!-- Name: Opentalk-Core-SupportNotice: Copyright 1999-2017 Cincom Systems, Inc.  All rights reserved.Comment: Opentalk-Core-Support contains system class extensions required by Opentalk, and defines classes that need to be loaded before the Opentalk core.Copyright: Copyright © 1999-2005 Cincom Systems, Inc.All Rights ReservedDbIdentifier: bear73DbTrace: 499617DbUsername: tkoganDbVersion: 8.3 - 2DevelopmentPrerequisites: #(#(#package 'Opentalk-Prerequisites' '') #(#package 'Protocols-Common' ''))PackageName: Opentalk-Core-SupportParcel: #('Opentalk-Core-Support')ParcelName: Opentalk-Core-SupportPrerequisiteParcels: #(#('Opentalk-Prerequisites' '') #('Protocols-Common' ''))PrintStringCache: (8.3 - 2,tkogan)Version: 8.3 - 2Date: 2:30:43 PM April 28, 2017 --><time-stamp>From VisualWorks®, Pre-Release 8.3 (apr17.3) of April 28, 2017 on April 28, 2017 at 2:30:43 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Proxy</name><environment>Opentalk</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars>objRef </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Opentalk-Core</category><attributes><package>Opentalk-Core-Support</package></attributes></class><comment><class-id>Opentalk.Proxy</class-id><body>Proxy is the abstract superclass of all species of proxies, e.g. RemoteObject, Demandor, etc.  An instance of Proxy is a representative of another object and it traps all messages addressed to it by reimplementing 'doesNotUnderstand:'  and redispatching the messages to the object the proxy represents.Instance Variables:	objRef	&lt;Object&gt;	the object reference to the object this proxy representsClass Instance Variables:	None.Shared Variables:	None.</body></comment><shared-variable><name>SmalltalkMessage</name><environment>Opentalk</environment><private>false</private><constant>true</constant><category>Opentalk</category><initializer>Kernel.Message</initializer><attributes><package>Opentalk-Core-Support</package></attributes></shared-variable><methods><class-id>Opentalk.Proxy</class-id> <category>local-accessing</category><body package="Opentalk-Core-Support">_error: aStringOrMessage	"Raise a non-proceedable signal that indicates an error with the argument 	as the message.  This additional message is the one a subclass should 	override in order to change the handling of errors.  Remove any trailing 	spaces from aString, as we know we do not want other strings appended 	to this one."	| lastNonSpace aString|	aString :=  aStringOrMessage asString.	lastNonSpace := aString findLast: [:ch | ch ~= Character space].	^Error raiseErrorString: (aString copyFrom: 1 to: lastNonSpace)</body><body package="Opentalk-Core-Support">_objRef	^objRef</body><body package="Opentalk-Core-Support">_primitiveFailed	"Announce that a primitive has failed and that there is no appropriate 	Smalltalk code to run."	self _error: (#aPrimitiveHasFailed &lt;&lt; #opentalk &gt;&gt; 'a primitive has failed')</body><body package="Opentalk-Core-Support">_type	"Answer the object which is the receiver's class."	&lt;primitive: 111&gt;	self _primitiveFailed</body></methods><methods><class-id>Opentalk.Proxy</class-id> <category>initialize-release</category><body package="Opentalk-Core-Support">_initializeWith: anObject	objRef := anObject.</body><body package="Opentalk-Core-Support">_release	objRef := nil.</body></methods><methods><class-id>Opentalk.Proxy</class-id> <category>local-comparing</category><body package="Opentalk-Core-Support">= anObject 	"Answer whether the receiver and the argument represent the same object.	If = is redefined in any subclass, also redefine the message hash."	^self == anObject</body><body package="Opentalk-Core-Support">== anObject	"Answer true if the receiver and the argument are the same object (have the 	same object pointer) and false otherwise.  Do not redefine the message == 	in any other class!  No Lookup."	"Added here to support the machinery used in AspectAdaptors and other like	machinery, which requires that we test proxies for identity."	&lt;primitive: 110&gt;	nil primitiveFailed</body><body package="Opentalk-Core-Support">hash	"See the method comment in class Object. ... added so that we do not 	have to go remote to put aProxy in a dictionary."	&lt;primitive: 75&gt;	nil primitiveFailed</body><body package="Opentalk-Core-Support">identityHash	"See the method comment in class Object. ... added so that we do not 	have to go remote to put aProxy in a dictionary."	&lt;primitive: 75&gt;	nil primitiveFailed</body></methods><methods><class-id>Opentalk.Proxy</class-id> <category>forwarding</category><body package="Opentalk-Core-Support">doesNotUnderstand: aMessage	"Forward aMessage to the objRef.  Return the result."	^objRef perform: aMessage selector withArguments: aMessage arguments</body></methods><methods><class-id>Opentalk.Proxy</class-id> <category>local-testing</category><body package="Opentalk-Core-Support">_isProxy	^true</body></methods><methods><class-id>Opentalk.Proxy class</class-id> <category>class initialization</category><body package="Opentalk-Core-Support">initialize	"self initialize"</body></methods><methods><class-id>Opentalk.Proxy class</class-id> <category>instance-creation</category><body package="Opentalk-Core-Support">newOn: anObject	^super new _initializeWith: anObject</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>opentalk</category><body package="Opentalk-Core-Support">homeMethodSelector	^self method homeMethod selector</body><body package="Opentalk-Core-Support">isExecutableBlock"We're adding this for cross-platform block closure testing"	^true</body></methods><methods><class-id>Core.Object</class-id> <category>opentalk</category><body package="Opentalk-Core-Support">_isProxy	^false</body><body package="Opentalk-Core-Support">_type	"Return the object's type for the marshaling."	^self class</body><body package="Opentalk-Core-Support">classname	^self class fullName</body><body package="Opentalk-Core-Support">isExecutableBlock"We're adding this for cross-platform block closure testing"	^false</body></methods><methods><class-id>Core.ProcessEnvironment</class-id> <category>opentalk</category><body package="Opentalk-Core-Support">environmentDictionary		^environmentDictionary</body></methods><methods><class-id>Protocols.ProtoObject</class-id> <category>opentalk</category><body package="Opentalk-Core-Support">_isProxy	^false</body><body package="Opentalk-Core-Support">_type	"Return the object's type for the marshaling."	^self class</body></methods><methods><class-id>Opentalk.Proxy class</class-id> <category>opentalk</category><body package="Opentalk-Core-Support">otPragmas	&lt;pragmas: #instance&gt;	^#(#aboutToRemoteSend:)</body></methods><methods><class-id>Core.Object class</class-id> <category>opentalk</category><body package="Opentalk-Core-Support">otPragmas	&lt;pragmas: #instance&gt;	^#(#aboutToRemoteReturn:)</body></methods><methods><class-id>Protocols.ProtoObject class</class-id> <category>opentalk</category><body package="Opentalk-Core-Support">otPragmas	&lt;pragmas: #instance&gt;	^#(#aboutToRemoteReturn:)</body></methods><initialize><class-id>Opentalk.Proxy</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ProcessEnvironment</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>environmentDictionary accessLock parentEnvironment bindingHandler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>ProtoObject</name><environment>Protocols</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Protocols-Common</category><attributes><package>Protocols-Common</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>